void sub_1B652B7B0(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void sub_1B652C0F4()
{
  uint64_t v0;
  const void *v1;
  const void *v2;

  v1 = *(const void **)(v0 + 680);
  if (v1)
    CFRelease(v1);
  v2 = *(const void **)(v0 + 688);
  if (v2)
    CFRelease(v2);
  JUMPOUT(0x1B652C134);
}

void sub_1B652C11C(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

void sub_1B652C124(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

void sub_1B652C150(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

void sub_1B652C158(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

void sub_1B652C160()
{
  uint64_t v0;
  const void *v1;
  const void *v2;

  v1 = *(const void **)(v0 + 952);
  if (v1)
    CFRelease(v1);
  v2 = *(const void **)(v0 + 960);
  if (v2)
    CFRelease(v2);
  JUMPOUT(0x1B652C1A0);
}

void sub_1B652C188(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

void sub_1B652C1EC(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

void sub_1B652C1F4(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

void sub_1B652C1FC(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

void sub_1B652C204(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

void sub_1B652C20C(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate();
  JUMPOUT(0x1B652C0E8);
}

uint64_t VoiceProcessorV5::RunUplinkDynamicsDSP(VoiceProcessorV5 *this, AudioBufferList *ioData, AudioTimeStamp *a3, uint64_t a4)
{
  char *v6;
  OpaqueAudioComponentInstance *v7;
  uint64_t v10;
  OpaqueAudioComponentInstance *v11;
  OpaqueAudioComponentInstance *v12;
  AudioUnitParameterID v13;
  AudioBufferList ioActionFlags;
  AudioUnitParameterValue outValue[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = (char *)this + 15897;
  if ((*((_BYTE *)this + 4664) & 0x10) != 0 && (*((_BYTE *)this + 4680) & 0x10) != 0)
  {
    v7 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 415);
    if (v7)
    {
      ioActionFlags.mNumberBuffers = 512;
      AudioUnitProcess(v7, &ioActionFlags.mNumberBuffers, a3, a4, ioData);
      if (*(_WORD *)v6)
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)this, 0x30u, a4, ioData, a3);
    }
  }
  if (*v6)
  {
    *(_QWORD *)outValue = 0;
    v10 = *((_QWORD *)this + 582);
    if ((v10 & 0x1000000000000000) != 0 && (*((_BYTE *)this + 4679) & 0x10) != 0)
    {
      v11 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 407);
      if (v11)
      {
        AudioUnitGetParameter(v11, 2u, 0, 0, outValue);
        v10 = *((_QWORD *)this + 582);
      }
    }
    if ((v10 & 0x80000000000000) != 0
      && (*((_BYTE *)this + 4678) & 0x80) != 0
      && (v12 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 402)) != 0)
    {
      v13 = 9;
    }
    else
    {
      if ((v10 & 0x20000000000000) == 0
        || (*((_BYTE *)this + 4678) & 0x20) == 0
        || (v12 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 400)) == 0)
      {
LABEL_20:
        *(_QWORD *)&ioActionFlags.mNumberBuffers = 1;
        *(_QWORD *)&ioActionFlags.mBuffers[0].mNumberChannels = 0x800000001;
        ioActionFlags.mBuffers[0].mData = outValue;
        if (*v6 || v6[1])
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)this, 0x5Au, 2, &ioActionFlags, a3);
        return 0;
      }
      v13 = 2;
    }
    AudioUnitGetParameter(v12, v13, 0, 0, &outValue[1]);
    goto LABEL_20;
  }
  return 0;
}

uint64_t VoiceProcessorV5::ProcessDSPChain_Uplink(uint64_t this, AudioTimeStamp *a2)
{
  VoiceProcessorV5 *v3;
  size_t v4;
  int v5;
  const AudioBufferList *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const AudioBufferList *v10;
  const AudioBufferList *v11;
  unsigned int v12;
  unsigned int *v13;
  void *v14;
  const void **v15;
  _QWORD *v16;
  NSObject *v17;
  int v18;
  int *v19;
  OpaqueAudioComponentInstance *v20;
  UInt64 v21;
  UInt64 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  AudioBufferList *v29;
  _DWORD *v30;
  unint64_t v31;
  uint64_t v32;
  AudioBufferList *v33;
  uint64_t v34;
  OpaqueAudioComponentInstance *v35;
  __int128 v36;
  __int128 v37;
  OpaqueAudioComponentInstance *v38;
  __int128 v39;
  __int128 v40;
  OpaqueAudioComponentInstance *v41;
  __int128 v42;
  __int128 v43;
  OpaqueAudioComponentInstance *v44;
  __int128 v45;
  __int128 v46;
  AudioBufferList *v47;
  uint64_t v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  OpaqueAudioComponentInstance *v57;
  __int128 v58;
  __int128 v59;
  OpaqueAudioComponentInstance *v60;
  __int128 v61;
  __int128 v62;
  OpaqueAudioComponentInstance *v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  __int128 v67;
  __int128 v68;
  AudioUnit v69;
  __int128 v70;
  __int128 v71;
  AudioUnitParameterID **v72;
  uint64_t v73;
  const AudioBufferList *v74;
  unsigned int v75;
  NSObject *v76;
  NSObject *v77;
  int v78;
  int *v79;
  uint64_t v80;
  OpaqueAudioComponentInstance *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  const AudioBufferList *v85;
  uint64_t v86;
  VPTimeFreqConverter *v87;
  uint64_t v88;
  uint64_t v89;
  const AudioBufferList *v90;
  uint64_t v91;
  uint64_t v92;
  const AudioBufferList *v93;
  uint64_t v94;
  uint64_t v95;
  const AudioBufferList *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  AudioUnitParameterValue *v101;
  uint64_t v102;
  __int128 v103;
  int v104;
  AudioUnit v105;
  uint64_t v106;
  __int128 v107;
  __int128 v108;
  OpaqueAudioComponentInstance *v109;
  float *v110;
  uint64_t Parameter;
  uint64_t v112;
  VPTimeFreqConverter *v113;
  uint64_t v114;
  VPTimeFreqConverter *v115;
  uint64_t v116;
  VPTimeFreqConverter *v117;
  uint64_t v118;
  float *v119;
  float v120;
  UInt64 v121;
  UInt64 v122;
  __int128 v123;
  __int128 v124;
  uint64_t v125;
  const AudioBufferList *v126;
  int v127;
  _BOOL4 v128;
  uint64_t v129;
  _BOOL4 v130;
  int v131;
  uint64_t v132;
  uint64_t v133;
  OpaqueAudioComponentInstance *v134;
  float v135;
  uint64_t v136;
  uint64_t v137;
  Float64 v138;
  Float64 v139;
  UInt64 v140;
  __int128 v141;
  __int128 v142;
  AudioUnitParameterValue v143;
  __int128 v144;
  __int128 v145;
  uint64_t v146;
  const AudioBufferList *v147;
  AudioTimeStamp *p_inInputBufferLists;
  uint64_t v149;
  unsigned int v150;
  AudioUnitParameterValue *v151;
  __int128 v152;
  __int128 v153;
  uint64_t v154;
  const AudioBufferList *v155;
  uint64_t v156;
  void *v157;
  const AudioBufferList *v158;
  AudioUnitParameterValue v159;
  OpaqueAudioComponentInstance *v160;
  __int128 v161;
  __int128 v162;
  const AudioBufferList *v163;
  uint64_t v164;
  BOOL *v165;
  __int128 v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  AudioUnitParameterValue *v170;
  uint64_t v171;
  __int128 v172;
  __int128 v173;
  uint64_t v174;
  uint64_t v175;
  __int128 v176;
  __int128 v177;
  uint64_t v178;
  uint64_t v179;
  AudioBufferList *v180;
  __int128 v181;
  __int128 v182;
  uint64_t v183;
  AudioUnitParameterValue *v184;
  OpaqueAudioComponentInstance *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  __int128 v191;
  int v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  Float64 v197;
  UInt64 v198;
  __int128 v199;
  __int128 v200;
  uint64_t v201;
  const AudioBufferList *v202;
  _BOOL4 v203;
  _BOOL4 v204;
  int v205;
  void *v206;
  uint64_t v207;
  OpaqueAudioComponentInstance *v208;
  UInt64 v209;
  uint64_t v210;
  __int128 v211;
  __int128 v212;
  OpaqueAudioComponentInstance *v213;
  AudioUnitParameterID v214;
  OpaqueAudioComponentInstance *v215;
  UInt64 v216;
  uint64_t v217;
  __int128 v218;
  __int128 v219;
  int v220;
  uint64_t v221;
  OpaqueAudioComponentInstance *v222;
  _BOOL4 v223;
  __int128 v224;
  __int128 v225;
  uint64_t v226;
  void *v227;
  unsigned int v228;
  _BOOL4 v229;
  OpaqueAudioComponentInstance *v230;
  UInt64 v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  OpaqueAudioComponentInstance *v235;
  uint64_t v236;
  void *v237;
  _BOOL4 v238;
  uint64_t v239;
  __int128 v240;
  __int128 v241;
  uint64_t v242;
  const AudioBufferList *v243;
  float *v245;
  const float *v246;
  float *v247;
  unsigned int v248;
  OpaqueAudioComponentInstance *v249;
  UInt64 v250;
  uint64_t v251;
  __int128 v252;
  __int128 v253;
  unsigned int v254;
  AudioUnitParameterValue v255;
  unsigned int v256;
  char v257;
  uint64_t v258;
  OpaqueAudioComponentInstance *v259;
  AudioUnitParameterID v260;
  OpaqueAudioComponentInstance *v261;
  unsigned int v262;
  OpaqueAudioComponentInstance *v263;
  __int128 v264;
  __int128 v265;
  OpaqueAudioComponentInstance *v266;
  __int128 v267;
  __int128 v268;
  uint64_t v269;
  OpaqueAudioComponentInstance *v270;
  __int128 v271;
  __int128 v272;
  OpaqueAudioComponentInstance *v273;
  __int128 v274;
  __int128 v275;
  int mSampleTime_low;
  OpaqueAudioComponentInstance *v277;
  uint64_t v279;
  AudioUnitParameterValue *v280;
  AudioUnitParameterValue *v281;
  AudioUnitParameterValue *v282;
  AudioUnitParameterValue *v283;
  AudioUnitParameterValue *v284;
  const AudioBufferList *v285;
  int v286;
  int v287;
  _BOOL4 v288;
  unsigned int v289;
  AudioUnitParameterValue **v290;
  AudioUnitParameterValue **v291;
  AudioUnitParameterValue v292;
  char v293;
  AudioUnitParameterValue v294;
  DSPSplitComplex v295;
  BOOL v296;
  BOOL v297;
  BOOL v298;
  BOOL v299;
  BOOL v300;
  AudioUnitRenderActionFlags v301;
  AudioUnitParameterValue v302;
  uint64_t v303;
  int v304;
  uint64_t v305;
  int v306;
  uint64_t v307;
  int v308;
  const AudioBufferList *v309;
  int v310;
  AudioTimeStamp v311;
  AudioBufferList *v312;
  const AudioBufferList *v313;
  AudioBufferList v314;
  void *v315;
  uint64_t v316;
  UInt32 ioDataSize[2];
  AudioUnitParameterValue *v318;
  AudioTimeStamp inInputBufferLists;
  AudioTimeStamp buf;
  uint64_t v321;

  v3 = (VoiceProcessorV5 *)this;
  v321 = *MEMORY[0x1E0C80C00];
  v4 = **(unsigned int **)(this + 1080);
  if ((_DWORD)v4)
    bzero(*(void **)(this + 1408), v4);
  if (*((_BYTE *)v3 + 1404))
    VoiceProcessorV2::PostSRCMicClipDetection(v3);
  if (!*((_BYTE *)v3 + 2083))
    VoiceProcessorV2::GetAbsoluteChIndexForEpmicAndApplyPreDigitalGain(v3);
  v5 = *((unsigned __int8 *)v3 + 15897);
  if (*((_BYTE *)v3 + 15897)
    && (VoiceProcessorV2::InjectionFilesReadSignal(v3, 7, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 134)),
        v5 = *((unsigned __int8 *)v3 + 15897),
        *((_BYTE *)v3 + 15897))
    && (VoiceProcessorV2::InjectionFilesReadSignal(v3, 8, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 135)),
        v5 = *((unsigned __int8 *)v3 + 15897),
        *((_BYTE *)v3 + 15897))
    && *((_BYTE *)v3 + 15896)
    || *((_BYTE *)v3 + 15899))
  {
    v6 = (const AudioBufferList *)*((_QWORD *)v3 + 134);
    if (v6->mNumberBuffers)
    {
      v7 = 0;
      v8 = 0;
      do
      {
        bzero(v6->mBuffers[v7].mData, v6->mBuffers[v7].mDataByteSize);
        ++v8;
        v6 = (const AudioBufferList *)*((_QWORD *)v3 + 134);
        ++v7;
      }
      while (v8 < v6->mNumberBuffers);
      v5 = *((unsigned __int8 *)v3 + 15897);
    }
  }
  else
  {
    v6 = (const AudioBufferList *)*((_QWORD *)v3 + 134);
  }
  v9 = *((unsigned int *)v3 + 127);
  if (v5 || *((_BYTE *)v3 + 15898))
  {
    this = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 4u, v9, v6, a2);
    v9 = *((unsigned int *)v3 + 127);
    v10 = (const AudioBufferList *)*((_QWORD *)v3 + 135);
    if (*((_BYTE *)v3 + 15897))
      goto LABEL_23;
  }
  else
  {
    v10 = (const AudioBufferList *)*((_QWORD *)v3 + 135);
  }
  if (!*((_BYTE *)v3 + 15898))
  {
    v11 = (const AudioBufferList *)*((_QWORD *)v3 + 177);
    goto LABEL_26;
  }
LABEL_23:
  this = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 5u, v9, v10, a2);
  v9 = *((unsigned int *)v3 + 127);
  v11 = (const AudioBufferList *)*((_QWORD *)v3 + 177);
  if (*((_BYTE *)v3 + 15897))
  {
LABEL_27:
    this = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Au, v9, v11, a2);
    goto LABEL_28;
  }
LABEL_26:
  if (*((_BYTE *)v3 + 15898))
    goto LABEL_27;
LABEL_28:
  v302 = 0.0;
  if (!*((_BYTE *)v3 + 2083) && !*((_BYTE *)v3 + 2085) && !*((_BYTE *)v3 + 472))
  {
    v25 = *((_QWORD *)v3 + 582);
    if (v25 || (*((_BYTE *)v3 + 4664) & 0x7F) != 0)
    {
      v301 = 0;
      *((_QWORD *)v3 + 2126) = 0;
      *((_QWORD *)v3 + 2127) = 0;
      *((_QWORD *)v3 + 2125) = 0;
      *((_DWORD *)v3 + 4250) = 1;
      *((_OWORD *)v3 + 1063) = *(_OWORD *)(*((_QWORD *)v3 + 134) + 8);
      if ((v25 & 1) != 0 && (*((_BYTE *)v3 + 4672) & 1) != 0)
      {
        this = *((_QWORD *)v3 + 347);
        if (this)
        {
          v26 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v26;
          v27 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v27;
          v301 = 512;
          this = AudioUnitProcess((AudioUnit)this, &v301, &buf, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 135));
        }
      }
      MEMORY[0x1E0C80A78](this);
      v29 = (AudioBufferList *)((char *)&v280 - ((v28 + 15) & 0x3FFFFFFFF0));
      v30 = (_DWORD *)*((_QWORD *)v3 + 135);
      if (*v30)
      {
        v31 = 0;
        v32 = 2;
        v33 = v29;
        do
        {
          *(_QWORD *)&v33->mNumberBuffers = 0;
          *(_QWORD *)&v33->mBuffers[0].mNumberChannels = 0;
          v33->mBuffers[0].mData = 0;
          v33->mNumberBuffers = 1;
          v33->mBuffers[0] = *(AudioBuffer *)&v30[v32];
          ++v31;
          v32 += 4;
          ++v33;
        }
        while (v31 < *v30);
      }
      v34 = *((_QWORD *)v3 + 582);
      if ((v34 & 2) != 0 && (*((_BYTE *)v3 + 4672) & 2) != 0)
      {
        v35 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 348);
        if (v35)
        {
          v36 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v36;
          v37 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v37;
          v301 = 512;
          AudioUnitProcess(v35, &v301, &buf, *((_DWORD *)v3 + 127), v29);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Bu, *((unsigned int *)v3 + 127), v29, &buf);
          CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 138), v29);
          v34 = *((_QWORD *)v3 + 582);
        }
      }
      if ((v34 & 4) != 0 && (*((_BYTE *)v3 + 4672) & 4) != 0)
      {
        v38 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 349);
        if (v38)
        {
          v39 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v39;
          v40 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v40;
          v301 = 512;
          AudioUnitProcess(v38, &v301, &buf, *((_DWORD *)v3 + 127), v29 + 1);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Cu, *((unsigned int *)v3 + 127), v29 + 1, &buf);
          CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 139), v29 + 1);
          v34 = *((_QWORD *)v3 + 582);
        }
      }
      if ((v34 & 8) != 0 && (*((_BYTE *)v3 + 4672) & 8) != 0)
      {
        v41 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 350);
        if (v41)
        {
          v42 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v42;
          v43 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v43;
          v301 = 512;
          AudioUnitProcess(v41, &v301, &buf, *((_DWORD *)v3 + 127), v29 + 2);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Du, *((unsigned int *)v3 + 127), v29 + 2, &buf);
          CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 140), v29 + 2);
          v34 = *((_QWORD *)v3 + 582);
        }
      }
      if ((v34 & 0x10) != 0 && (*((_BYTE *)v3 + 4672) & 0x10) != 0)
      {
        v44 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 351);
        if (v44)
        {
          v45 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v45;
          v46 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v46;
          v301 = 512;
          v47 = v29 + 3;
          AudioUnitProcess(v44, &v301, &buf, *((_DWORD *)v3 + 127), v47);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Eu, *((unsigned int *)v3 + 127), v47, &buf);
          CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 141), v47);
        }
      }
      v48 = *((_QWORD *)v3 + 135);
      v49 = *(_DWORD *)v48;
      v290 = &v280;
      if (v49 < 3)
      {
        *((_OWORD *)v3 + 1051) = *(_OWORD *)(v48 + 8);
        if (*(_DWORD *)v48 < 2u)
        {
          v54 = 0;
          v53 = 0;
          v52 = 0;
          v51 = 0;
        }
        else
        {
          v54 = 0;
          v53 = 0;
          if (*((_BYTE *)v3 + 17064))
          {
            v52 = 0;
            *((_OWORD *)v3 + 1051) = *(_OWORD *)(v48 + 24);
            *(_OWORD *)((char *)v3 + 16840) = *(_OWORD *)(v48 + 8);
            v51 = 1;
          }
          else
          {
            v51 = 0;
            *(_OWORD *)((char *)v3 + 16840) = *(_OWORD *)(v48 + 24);
            v52 = 1;
          }
        }
LABEL_115:
        v56 = *((_QWORD *)v3 + 582);
        LODWORD(v291) = v52;
        if ((v56 & 0x40) != 0 && (*((_BYTE *)v3 + 4672) & 0x40) != 0)
        {
          v57 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 353);
          if (v57)
          {
            v58 = *(_OWORD *)&a2->mRateScalar;
            *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
            *(_OWORD *)&buf.mRateScalar = v58;
            v59 = *(_OWORD *)&a2->mSMPTETime.mHours;
            *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
            *(_OWORD *)&buf.mSMPTETime.mHours = v59;
            v301 = 512;
            AudioUnitProcess(v57, &v301, &buf, *((_DWORD *)v3 + 127), (AudioBufferList *)((char *)v3 + 16808));
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 6u, *((unsigned int *)v3 + 127), (const AudioBufferList *)((char *)v3 + 16808), &buf);
            v56 = *((_QWORD *)v3 + 582);
          }
        }
        if ((v56 & 0x80) != 0 && (*((_BYTE *)v3 + 4672) & 0x80) != 0)
        {
          v60 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 354);
          if (v60)
          {
            v61 = *(_OWORD *)&a2->mRateScalar;
            *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
            *(_OWORD *)&buf.mRateScalar = v61;
            v62 = *(_OWORD *)&a2->mSMPTETime.mHours;
            *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
            *(_OWORD *)&buf.mSMPTETime.mHours = v62;
            v301 = 512;
            AudioUnitProcess(v60, &v301, &buf, *((_DWORD *)v3 + 127), (AudioBufferList *)((char *)v3 + 16832));
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 7u, *((unsigned int *)v3 + 127), (const AudioBufferList *)((char *)v3 + 16832), &buf);
            v56 = *((_QWORD *)v3 + 582);
          }
        }
        if ((v56 & 0x200) != 0 && (*((_BYTE *)v3 + 4673) & 2) != 0)
        {
          v63 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 356);
          if (v63)
          {
            v64 = *(_OWORD *)&a2->mRateScalar;
            *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
            *(_OWORD *)&buf.mRateScalar = v64;
            v65 = *(_OWORD *)&a2->mSMPTETime.mHours;
            *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
            *(_OWORD *)&buf.mSMPTETime.mHours = v65;
            v301 = 512;
            AudioUnitProcess(v63, &v301, &buf, *((_DWORD *)v3 + 127), (AudioBufferList *)((char *)v3 + 16880));
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 9u, *((unsigned int *)v3 + 127), (const AudioBufferList *)((char *)v3 + 16880), &buf);
            v56 = *((_QWORD *)v3 + 582);
          }
        }
        if ((v56 & 0x400) != 0 && (*((_BYTE *)v3 + 4673) & 4) != 0)
        {
          v66 = *((_QWORD *)v3 + 357);
          if (v66)
          {
            MEMORY[0x1E0C80A78](v66);
            *(&v280 - 6) = (AudioUnitParameterValue *)2;
            *(_OWORD *)(&v280 - 5) = *((_OWORD *)v3 + 1051);
            *(_OWORD *)(&v280 - 3) = *(_OWORD *)((char *)v3 + 16840);
            *(_QWORD *)&v311.mSampleTime = &v280 - 6;
            v311.mHostTime = 0;
            *(_QWORD *)&inInputBufferLists.mSampleTime = (char *)v3 + 16832;
            memset(&inInputBufferLists.mHostTime, 0, 24);
            v301 = 512;
            v67 = *(_OWORD *)&a2->mRateScalar;
            *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
            *(_OWORD *)&buf.mRateScalar = v67;
            v68 = *(_OWORD *)&a2->mSMPTETime.mHours;
            *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
            *(_OWORD *)&buf.mSMPTETime.mHours = v68;
            AudioUnitProcessMultiple(v69, &v301, &buf, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&v311, 4u, (AudioBufferList **)&inInputBufferLists);
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x63u, *((unsigned int *)v3 + 127), (const AudioBufferList *)((char *)v3 + 16832), &buf);
            v56 = *((_QWORD *)v3 + 582);
          }
        }
        v300 = 0;
        v70 = *(_OWORD *)&a2->mRateScalar;
        *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
        *(_OWORD *)&buf.mRateScalar = v70;
        v71 = *(_OWORD *)&a2->mSMPTETime.mHours;
        *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
        *(_OWORD *)&buf.mSMPTETime.mHours = v71;
        if ((v56 & 0x10000) != 0 && (*((_BYTE *)v3 + 4674) & 1) != 0 && *((_QWORD *)v3 + 363))
        {
          v72 = (AudioUnitParameterID **)*((_QWORD *)v3 + 2098);
          if (*((AudioUnitParameterID ***)v3 + 2099) == v72)
            goto LABEL_639;
          ECApplicator::apply(*v72, &buf, v51, &v300, (float *)v3 + 1046, (float *)v3 + 1050, (float *)v3 + 1054, (float *)v3 + 1058, (float *)v3 + 1062, (float *)v3 + 1066);
          v73 = *((unsigned int *)v3 + 127);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          {
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Cu, v73, (const AudioBufferList *)((char *)v3 + 16808), &buf);
            v73 = *((unsigned int *)v3 + 127);
            v74 = (const AudioBufferList *)*((_QWORD *)v3 + 418);
            if (*((_BYTE *)v3 + 15897))
            {
LABEL_185:
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xCu, v73, v74, &buf);
              goto LABEL_169;
            }
          }
          else
          {
            v74 = (const AudioBufferList *)*((_QWORD *)v3 + 418);
          }
          if (*((_BYTE *)v3 + 15898))
            goto LABEL_185;
        }
        else
        {
          v75 = 0;
          while (((*((_DWORD *)v3 + 116) >> v75) & 1) == 0)
          {
            if (++v75 == 32)
            {
              v75 = 33;
              break;
            }
          }
          if (v75 >= **((_DWORD **)v3 + 135))
          {
            v289 = v54;
            if (VPLogScope(void)::once != -1)
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            v76 = CALog::LogObjIfEnabled(1, VPLogScope(void)::scope);
            if (v76)
            {
              v77 = v76;
              if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
              {
                v78 = **((_DWORD **)v3 + 135);
                LODWORD(inInputBufferLists.mSampleTime) = 136315906;
                *(_QWORD *)((char *)&inInputBufferLists.mSampleTime + 4) = "vpProcessUplink_v5.cpp";
                WORD2(inInputBufferLists.mHostTime) = 1024;
                *(_DWORD *)((char *)&inInputBufferLists.mHostTime + 6) = 340;
                WORD1(inInputBufferLists.mRateScalar) = 1024;
                HIDWORD(inInputBufferLists.mRateScalar) = v75;
                LOWORD(inInputBufferLists.mWordClockTime) = 1024;
                *(_DWORD *)((char *)&inInputBufferLists.mWordClockTime + 2) = v78;
                _os_log_impl(&dword_1B5ED0000, v77, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", (uint8_t *)&inInputBufferLists, 0x1Eu);
              }
            }
            v79 = (int *)*((_QWORD *)v3 + 1570);
            if (v79 && (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898)))
            {
              if (VPLogScope(void)::once != -1)
                dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
              CALegacyLog::log(v79, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v5/vpProcessUplink_v5.cpp", 340, "ProcessDSPChain_Uplink", "ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", v75, **((_DWORD **)v3 + 135));
            }
            v75 = 0;
            v54 = v289;
          }
          v80 = *((_QWORD *)v3 + 135) + 16 * v75;
          memcpy(*(void **)(*((_QWORD *)v3 + 136) + 16), *(const void **)(v80 + 16), *(unsigned int *)(v80 + 12));
        }
LABEL_169:
        if ((*((_BYTE *)v3 + 4664) & 0x20) != 0 && (*((_BYTE *)v3 + 4680) & 0x20) != 0)
        {
          v81 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 416);
          if (v81)
          {
            inInputBufferLists.mSampleTime = *((Float64 *)v3 + 135);
            inInputBufferLists.mHostTime = (UInt64)v3 + 17000;
            v311.mSampleTime = *((Float64 *)v3 + 136);
            v301 = 512;
            AudioUnitProcessMultiple(v81, &v301, &buf, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&inInputBufferLists, 1u, (AudioBufferList **)&v311);
          }
        }
        v299 = 0;
        v82 = *((_QWORD *)v3 + 582);
        if ((v82 & 0x100000) == 0 || (*((_BYTE *)v3 + 4674) & 0x10) == 0 || !*((_QWORD *)v3 + 367))
        {
LABEL_195:
          v298 = 0;
          if ((v82 & 0x20000) != 0 && (*((_BYTE *)v3 + 4674) & 2) != 0 && *((_QWORD *)v3 + 364))
          {
            v88 = *((_QWORD *)v3 + 2098);
            if ((unint64_t)(*((_QWORD *)v3 + 2099) - v88) <= 8)
              goto LABEL_639;
            ECApplicator::apply(*(AudioUnitParameterID **)(v88 + 8), &buf, v291, &v298, (float *)v3 + 1047, (float *)v3 + 1051, (float *)v3 + 1055, (float *)v3 + 1059, (float *)v3 + 1063, (float *)v3 + 1067);
            v89 = *((unsigned int *)v3 + 127);
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            {
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Du, v89, (const AudioBufferList *)((char *)v3 + 16832), &buf);
              v89 = *((unsigned int *)v3 + 127);
              v90 = (const AudioBufferList *)*((_QWORD *)v3 + 419);
              if (*((_BYTE *)v3 + 15897))
              {
LABEL_205:
                VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xDu, v89, v90, &buf);
                goto LABEL_206;
              }
            }
            else
            {
              v90 = (const AudioBufferList *)*((_QWORD *)v3 + 419);
            }
            if (*((_BYTE *)v3 + 15898))
              goto LABEL_205;
          }
LABEL_206:
          v297 = 0;
          if ((*((_BYTE *)v3 + 4658) & 4) == 0 || (*((_BYTE *)v3 + 4674) & 4) == 0 || !*((_QWORD *)v3 + 365))
            goto LABEL_217;
          v91 = *((_QWORD *)v3 + 2098);
          if ((unint64_t)(*((_QWORD *)v3 + 2099) - v91) <= 0x10)
            goto LABEL_639;
          ECApplicator::apply(*(AudioUnitParameterID **)(v91 + 16), &buf, v54, &v297, (float *)v3 + 1048, (float *)v3 + 1052, (float *)v3 + 1056, (float *)v3 + 1060, (float *)v3 + 1064, (float *)v3 + 1068);
          v92 = *((unsigned int *)v3 + 127);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          {
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Eu, v92, (const AudioBufferList *)((char *)v3 + 16856), &buf);
            v92 = *((unsigned int *)v3 + 127);
            v93 = (const AudioBufferList *)*((_QWORD *)v3 + 421);
            if (*((_BYTE *)v3 + 15897))
            {
LABEL_216:
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xEu, v92, v93, &buf);
LABEL_217:
              v296 = 0;
              if ((*((_BYTE *)v3 + 4658) & 8) == 0 || (*((_BYTE *)v3 + 4674) & 8) == 0 || !*((_QWORD *)v3 + 366))
                goto LABEL_228;
              v94 = *((_QWORD *)v3 + 2098);
              if ((unint64_t)(*((_QWORD *)v3 + 2099) - v94) > 0x18)
              {
                ECApplicator::apply(*(AudioUnitParameterID **)(v94 + 24), &buf, v53, &v296, (float *)v3 + 1049, (float *)v3 + 1053, (float *)v3 + 1057, (float *)v3 + 1061, (float *)v3 + 1065, (float *)v3 + 1069);
                v95 = *((unsigned int *)v3 + 127);
                if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                {
                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Fu, v95, (const AudioBufferList *)((char *)v3 + 16880), &buf);
                  v95 = *((unsigned int *)v3 + 127);
                  v96 = (const AudioBufferList *)*((_QWORD *)v3 + 420);
                  if (*((_BYTE *)v3 + 15897))
                  {
LABEL_227:
                    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xFu, v95, v96, &buf);
                    goto LABEL_228;
                  }
                }
                else
                {
                  v96 = (const AudioBufferList *)*((_QWORD *)v3 + 420);
                }
                if (*((_BYTE *)v3 + 15898))
                  goto LABEL_227;
LABEL_228:
                if ((*((_BYTE *)v3 + 4660) & 0x20) != 0 && (*((_BYTE *)v3 + 4676) & 0x20) != 0)
                {
                  v97 = *((_QWORD *)v3 + 384);
                  if (v97)
                  {
                    MEMORY[0x1E0C80A78](v97);
                    v279 = 0;
                    *((_OWORD *)&v280 - 3) = 0u;
                    *((_OWORD *)&v280 - 2) = 0u;
                    *((_DWORD *)&v280 - 12) = 2;
                    *(_OWORD *)(&v280 - 5) = *(_OWORD *)(v98 + 32);
                    *(_OWORD *)(&v280 - 3) = *(_OWORD *)(v99 + 32);
                    MEMORY[0x1E0C80A78](v100);
                    *(&v280 - 6) = v101;
                    *(_OWORD *)(&v280 - 5) = *((_OWORD *)v3 + 1051);
                    *(_OWORD *)(&v280 - 3) = *(_OWORD *)((char *)v3 + 16840);
                    *(double *)&v103 = MEMORY[0x1E0C80A78](v102);
                    v279 = 0;
                    *((_OWORD *)&v280 - 3) = v103;
                    *((_OWORD *)&v280 - 2) = v103;
                    *((_DWORD *)&v280 - 12) = v104;
                    *(_OWORD *)(&v280 - 5) = *(_OWORD *)(*((_QWORD *)v3 + 418) + 8);
                    *(_OWORD *)(&v280 - 3) = *(_OWORD *)(*((_QWORD *)v3 + 419) + 8);
                    AudioUnitSetParameter(v105, 0x14u, 0, 0, *((AudioUnitParameterValue *)v3 + 1046), 0);
                    AudioUnitSetParameter(*((AudioUnit *)v3 + 384), 0x15u, 0, 0, *((AudioUnitParameterValue *)v3 + 1050), 0);
                    AudioUnitSetParameter(*((AudioUnit *)v3 + 384), 0x16u, 0, 0, *((AudioUnitParameterValue *)v3 + 1054), 0);
                    AudioUnitSetParameter(*((AudioUnit *)v3 + 384), 0x17u, 0, 0, *((AudioUnitParameterValue *)v3 + 1058), 0);
                    AudioUnitSetParameter(*((AudioUnit *)v3 + 384), 0x18u, 0, 0, *((AudioUnitParameterValue *)v3 + 1062), 0);
                    AudioUnitSetParameter(*((AudioUnit *)v3 + 384), 0x19u, 0, 0, *((AudioUnitParameterValue *)v3 + 1047), 0);
                    AudioUnitSetParameter(*((AudioUnit *)v3 + 384), 0x1Au, 0, 0, *((AudioUnitParameterValue *)v3 + 1051), 0);
                    AudioUnitSetParameter(*((AudioUnit *)v3 + 384), 0x1Bu, 0, 0, *((AudioUnitParameterValue *)v3 + 1055), 0);
                    AudioUnitSetParameter(*((AudioUnit *)v3 + 384), 0x1Cu, 0, 0, *((AudioUnitParameterValue *)v3 + 1059), 0);
                    AudioUnitSetParameter(*((AudioUnit *)v3 + 384), 0x1Du, 0, 0, *((AudioUnitParameterValue *)v3 + 1063), 0);
                    *(_QWORD *)&v311.mSampleTime = &v280 - 6;
                    v311.mHostTime = (UInt64)(&v280 - 6);
                    *(_QWORD *)&v311.mRateScalar = &v280 - 6;
                    v106 = *((_QWORD *)v3 + 418);
                    *(_QWORD *)&v314.mNumberBuffers = (char *)v3 + 16808;
                    *(_QWORD *)&v314.mBuffers[0].mNumberChannels = v106;
                    v301 = 512;
                    v107 = *(_OWORD *)&a2->mRateScalar;
                    *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                    *(_OWORD *)&inInputBufferLists.mRateScalar = v107;
                    v108 = *(_OWORD *)&a2->mSMPTETime.mHours;
                    *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                    *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v108;
                    AudioUnitProcessMultiple(*((AudioUnit *)v3 + 384), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 3u, (const AudioBufferList **)&v311, 2u, (AudioBufferList **)&v314);
                    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x23u, *((unsigned int *)v3 + 127), (const AudioBufferList *)((char *)v3 + 16808), &inInputBufferLists);
                    if ((*((_BYTE *)v3 + 4661) & 4) != 0 && (*((_BYTE *)v3 + 4677) & 4) != 0 && *((_QWORD *)v3 + 389))
                    {
                      LODWORD(v295.realp) = 0;
                      v109 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 384);
                      v291 = (AudioUnitParameterValue **)((char *)v3 + 4248);
                      AudioUnitGetParameter(v109, 0x13u, 0, 0, (AudioUnitParameterValue *)&v295);
                      AudioUnitSetParameter(*((AudioUnit *)v3 + 389), 0x27u, 0, 0, *(AudioUnitParameterValue *)&v295.realp, 0);
                      AudioUnitGetParameter(*((AudioUnit *)v3 + 384), 0x14u, 0, 0, (AudioUnitParameterValue *)v3 + 1046);
                      AudioUnitGetParameter(*((AudioUnit *)v3 + 384), 0x15u, 0, 0, (AudioUnitParameterValue *)v3 + 1050);
                      AudioUnitGetParameter(*((AudioUnit *)v3 + 384), 0x16u, 0, 0, (AudioUnitParameterValue *)v3 + 1054);
                      AudioUnitGetParameter(*((AudioUnit *)v3 + 384), 0x17u, 0, 0, (AudioUnitParameterValue *)v3 + 1058);
                      AudioUnitGetParameter(*((AudioUnit *)v3 + 384), 0x18u, 0, 0, (AudioUnitParameterValue *)v291);
                    }
                  }
                }
                v110 = (float *)(*(_QWORD *)(*((_QWORD *)v3 + 510) + 16) + 4 * *((unsigned int *)v3 + 127));
                v295.realp = *(float **)(*((_QWORD *)v3 + 510) + 16);
                v295.imagp = v110;
                Parameter = *((_QWORD *)v3 + 518);
                if (Parameter)
                  Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *((const float **)v3 + 2127), &v295);
                if ((*((_BYTE *)v3 + 4658) & 1) != 0 && (*((_BYTE *)v3 + 4674) & 1) != 0 && *((_QWORD *)v3 + 363))
                {
                  v112 = *((unsigned int *)v3 + 127);
                  v295.realp = *(float **)(*((_QWORD *)v3 + 428) + 16);
                  v295.imagp = &v295.realp[v112];
                  v113 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 512);
                  if (v113)
                  {
                    VPTimeFreqConverter::Analyze(v113, *((const float **)v3 + 2103), &v295);
                    v112 = *((unsigned int *)v3 + 127);
                  }
                  v295.realp = *(float **)(*((_QWORD *)v3 + 504) + 16);
                  v295.imagp = &v295.realp[v112];
                  Parameter = *((_QWORD *)v3 + 516);
                  if (Parameter)
                  {
                    Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *(const float **)(*((_QWORD *)v3 + 418) + 16), &v295);
                    v112 = *((unsigned int *)v3 + 127);
                  }
                  if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                    Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x12u, v112, *((const AudioBufferList **)v3 + 428), &buf);
                }
                if ((*((_BYTE *)v3 + 4658) & 2) != 0 && (*((_BYTE *)v3 + 4674) & 2) != 0 && *((_QWORD *)v3 + 364))
                {
                  v114 = *((unsigned int *)v3 + 127);
                  v295.realp = *(float **)(*((_QWORD *)v3 + 505) + 16);
                  v295.imagp = &v295.realp[v114];
                  v115 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 513);
                  if (v115)
                  {
                    VPTimeFreqConverter::Analyze(v115, *((const float **)v3 + 2106), &v295);
                    v114 = *((unsigned int *)v3 + 127);
                  }
                  v295.realp = *(float **)(*((_QWORD *)v3 + 504) + 32);
                  v295.imagp = &v295.realp[v114];
                  Parameter = *((_QWORD *)v3 + 517);
                  if (Parameter)
                  {
                    Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *(const float **)(*((_QWORD *)v3 + 419) + 16), &v295);
                    v114 = *((unsigned int *)v3 + 127);
                  }
                  if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                    Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x13u, v114, *((const AudioBufferList **)v3 + 505), &buf);
                }
                if ((*((_BYTE *)v3 + 4658) & 8) != 0 && (*((_BYTE *)v3 + 4674) & 8) != 0 && *((_QWORD *)v3 + 366))
                {
                  v116 = *((unsigned int *)v3 + 127);
                  v295.realp = *(float **)(*((_QWORD *)v3 + 506) + 16);
                  v295.imagp = &v295.realp[v116];
                  v117 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 515);
                  if (v117)
                  {
                    VPTimeFreqConverter::Analyze(v117, *((const float **)v3 + 2112), &v295);
                    v116 = *((unsigned int *)v3 + 127);
                  }
                  v295.realp = *(float **)(*((_QWORD *)v3 + 504) + 64);
                  v295.imagp = &v295.realp[v116];
                  Parameter = *((_QWORD *)v3 + 2096);
                  if (Parameter)
                  {
                    Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *(const float **)(*((_QWORD *)v3 + 420) + 16), &v295);
                    v116 = *((unsigned int *)v3 + 127);
                  }
                  if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                    Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x15u, v116, *((const AudioBufferList **)v3 + 506), &buf);
                }
                v294 = 0.0;
                v118 = *((_QWORD *)v3 + 582);
                if ((v118 & 0x40000000000) != 0 && (*((_BYTE *)v3 + 4677) & 4) != 0)
                {
                  Parameter = *((_QWORD *)v3 + 389);
                  if (Parameter)
                  {
                    Parameter = AudioUnitGetParameter((AudioUnit)Parameter, 0x2Bu, 0, 0, &v294);
                    v118 = *((_QWORD *)v3 + 582);
                  }
                }
                if ((v118 & 0x40000) != 0 && (*((_BYTE *)v3 + 4674) & 4) != 0)
                {
                  if (*((_QWORD *)v3 + 365))
                  {
                    if (v294 == 1.0)
                    {
                      v119 = (float *)(*(_QWORD *)(*((_QWORD *)v3 + 504) + 48) + 4 * *((unsigned int *)v3 + 127));
                      v295.realp = *(float **)(*((_QWORD *)v3 + 504) + 48);
                      v295.imagp = v119;
                      Parameter = *((_QWORD *)v3 + 2132);
                      if (Parameter)
                      {
                        Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *(const float **)(*((_QWORD *)v3 + 421) + 16), &v295);
                        v118 = *((_QWORD *)v3 + 582);
                      }
                    }
                  }
                }
                if ((v118 & 0x80000000000) == 0
                  || (*((_BYTE *)v3 + 4677) & 8) == 0
                  || (Parameter = *((_QWORD *)v3 + 390)) == 0)
                {
LABEL_294:
                  v293 = 0;
                  if ((v118 & 0x20000000) != 0 && (*((_BYTE *)v3 + 4675) & 0x20) != 0 && *((_QWORD *)v3 + 376))
                  {
                    v127 = 1;
                    v128 = 1;
                  }
                  else if ((v118 & 0x100000000) != 0 && (*((_BYTE *)v3 + 4676) & 1) != 0)
                  {
                    v127 = 0;
                    v128 = *((_QWORD *)v3 + 379) != 0;
                  }
                  else
                  {
                    v127 = 0;
                    v128 = 0;
                  }
                  v129 = v118 & 0x40000000;
                  if ((v118 & 0x40000000) != 0 && (*((_BYTE *)v3 + 4675) & 0x40) != 0 && *((_QWORD *)v3 + 377))
                  {
                    v130 = 1;
                    v131 = 1;
                    v127 = 1;
                    if ((v118 & 0x80000000) == 0)
                      goto LABEL_319;
                  }
                  else
                  {
                    if ((v118 & 0x80000000) == 0)
                    {
                      v130 = 0;
                      v131 = 1;
                      goto LABEL_319;
                    }
                    v131 = 1;
                    if ((*((_BYTE *)v3 + 4675) & 0x80) != 0)
                    {
                      v132 = *((_QWORD *)v3 + 378);
                      v130 = v132 != 0;
                      if (v132)
                        v131 = 2;
                      else
                        v131 = 1;
                    }
                    else
                    {
                      v130 = 0;
                    }
                  }
                  v133 = *((_QWORD *)v3 + 584);
                  if ((v133 & 0x80000000) != 0
                    && *((_QWORD *)v3 + 378)
                    && (v118 & v133 & 0x100000000) != 0
                    && *((_QWORD *)v3 + 379))
                  {
                    v127 = 2;
                    v131 = 2;
                  }
LABEL_319:
                  if ((v118 & 0x20000000) == 0)
                    goto LABEL_336;
                  if ((*((_BYTE *)v3 + 4675) & 0x20) == 0)
                    goto LABEL_336;
                  Parameter = *((_QWORD *)v3 + 376);
                  if (!Parameter)
                    goto LABEL_336;
                  AudioUnitSetProperty((AudioUnit)Parameter, 0x457u, 0, 0, (char *)v3 + 2316, 4u);
                  if ((*((_BYTE *)v3 + 4659) & 0x40) != 0 && (*((_BYTE *)v3 + 4675) & 0x40) != 0)
                  {
                    v134 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 376);
                    if (*((_QWORD *)v3 + 377))
                    {
                      v135 = (float)*((unsigned int *)v3 + 684);
LABEL_326:
                      AudioUnitSetParameter(v134, 0x1Bu, 0, 0, v135, 0);
                      v136 = *((_QWORD *)v3 + 582);
                      if ((v136 & 0x10000) != 0)
                      {
                        v137 = *((_QWORD *)v3 + 584);
                        if ((v137 & 0x10000) != 0
                          && *((_QWORD *)v3 + 363)
                          && (v136 & v137 & 0x20000) != 0
                          && *((_QWORD *)v3 + 364))
                        {
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 376), 0x3Fu, 0, 0, *((float *)v3 + 1054) * *((float *)v3 + 1055), 0);
                        }
                      }
                      *(_QWORD *)&v138 = *((_QWORD *)v3 + 138) + 24;
                      *(_QWORD *)&v139 = *((_QWORD *)v3 + 139) + 24;
                      if (**((_DWORD **)v3 + 135) <= 2u)
                      {
                        *(_QWORD *)&v311.mSampleTime = *((_QWORD *)v3 + 138) + 24;
                        *(Float64 *)&v311.mHostTime = v139;
                        v311.mRateScalar = 0.0;
                        v311.mWordClockTime = (UInt64)v3 + 17000;
                        *(_OWORD *)&v311.mSMPTETime.mSubframes = *((_OWORD *)v3 + 209);
                      }
                      else
                      {
                        v140 = *((_QWORD *)v3 + 140) + 24;
                        v311.mWordClockTime = (UInt64)v3 + 17000;
                        *(_OWORD *)&v311.mSMPTETime.mSubframes = *((_OWORD *)v3 + 209);
                        v311.mSampleTime = v139;
                        v311.mHostTime = v140;
                        v311.mRateScalar = v138;
                      }
                      *(_QWORD *)&v314.mNumberBuffers = 0;
                      v301 = 512;
                      AudioUnitSetParameter(*((AudioUnit *)v3 + 376), 0x2Cu, 0, 0, *((AudioUnitParameterValue *)v3 + 1090), 0);
                      v141 = *(_OWORD *)&a2->mRateScalar;
                      *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                      *(_OWORD *)&inInputBufferLists.mRateScalar = v141;
                      v142 = *(_OWORD *)&a2->mSMPTETime.mHours;
                      *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                      *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v142;
                      Parameter = AudioUnitProcessMultiple(*((AudioUnit *)v3 + 376), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)&v311, 1u, (AudioBufferList **)&v314);
                      v118 = *((_QWORD *)v3 + 582);
                      v129 = v118 & 0x40000000;
LABEL_336:
                      if (v129 && (*((_BYTE *)v3 + 4675) & 0x40) != 0 && *((_QWORD *)v3 + 377))
                      {
                        memcpy(*(void **)(*((_QWORD *)v3 + 434) + 16 * *((unsigned int *)v3 + 1040) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
                        memcpy(*(void **)(*((_QWORD *)v3 + 434) + 16 * *((unsigned int *)v3 + 1041) + 16), *(const void **)(*((_QWORD *)v3 + 505) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
                        if (*((float *)v3 + 1066) == 0.0 && *((float *)v3 + 1067) == 0.0)
                          v143 = 0.0;
                        else
                          v143 = 1.0;
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 377), 0x20u, 0, 0, v143, 0);
                        v311.mSampleTime = *((Float64 *)v3 + 434);
                        *(_QWORD *)&v314.mNumberBuffers = *((_QWORD *)v3 + 429);
                        v144 = *(_OWORD *)&a2->mRateScalar;
                        *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                        *(_OWORD *)&inInputBufferLists.mRateScalar = v144;
                        v145 = *(_OWORD *)&a2->mSMPTETime.mHours;
                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v145;
                        v301 = 512;
                        AudioUnitProcessMultiple(*((AudioUnit *)v3 + 377), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)&v311, 1u, (AudioBufferList **)&v314);
                        ioDataSize[0] = 8 * *((_DWORD *)v3 + 127);
                        AudioUnitGetProperty(*((AudioUnit *)v3 + 377), 0xE7Au, 0, 0, *(void **)(*((_QWORD *)v3 + 537) + 16), ioDataSize);
                        ioDataSize[0] = 8 * *((_DWORD *)v3 + 127);
                        Parameter = AudioUnitGetProperty(*((AudioUnit *)v3 + 377), 0xE79u, 0, 0, *(void **)(*((_QWORD *)v3 + 537) + 32), ioDataSize);
                        v146 = *((unsigned int *)v3 + 127);
                        v147 = (const AudioBufferList *)*((_QWORD *)v3 + 429);
                        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                        {
                          p_inInputBufferLists = &inInputBufferLists;
                          v149 = (uint64_t)v3;
                          v150 = 10;
LABEL_345:
                          Parameter = VoiceProcessorV2::SaveFilesWriteSignal(v149, v150, v146, v147, p_inInputBufferLists);
                        }
LABEL_373:
                        MEMORY[0x1E0C80A78](Parameter);
                        v163 = (const AudioBufferList *)(&v280 - 8);
                        *((_OWORD *)&v280 - 3) = 0u;
                        *((_OWORD *)&v280 - 2) = 0u;
                        *((_OWORD *)&v280 - 4) = 0u;
                        *((_DWORD *)&v280 - 16) = 3;
                        *(double *)&v166 = MEMORY[0x1E0C80A78](v164);
                        v291 = &v280 - 8;
                        v279 = 0;
                        *((_OWORD *)&v280 - 3) = v166;
                        *((_OWORD *)&v280 - 2) = v166;
                        *((_OWORD *)&v280 - 4) = v166;
                        *((_DWORD *)&v280 - 16) = v167;
                        v168 = *((_QWORD *)v3 + 582);
                        if ((v168 & 0x200000000) != 0 && (*((_BYTE *)v3 + 4676) & 2) != 0 && *((_QWORD *)v3 + 380)
                          || (v168 & 0x400000000) != 0 && (*((_BYTE *)v3 + 4676) & 4) != 0 && *((_QWORD *)v3 + 381)
                          || (v168 & 0x1000000000) != 0
                          && (*((_BYTE *)v3 + 4676) & 0x10) != 0
                          && *((_QWORD *)v3 + 383))
                        {
                          *(_OWORD *)(&v280 - 7) = *(_OWORD *)(*((_QWORD *)v3 + 428) + 8);
                          *(_OWORD *)(&v280 - 5) = *(_OWORD *)(*((_QWORD *)v3 + 505) + 8);
                          *(_OWORD *)(&v280 - 3) = *(_OWORD *)(*((_QWORD *)v3 + 506) + 8);
                          v169 = *((_QWORD *)v3 + 504);
                          v170 = (AudioUnitParameterValue *)v291;
                          *(_OWORD *)(v291 + 1) = *(_OWORD *)(v169 + 8);
                          *(_OWORD *)(v170 + 6) = *(_OWORD *)(v169 + 24);
                          v166 = *(_OWORD *)(v169 + 56);
                          *(_OWORD *)(v170 + 10) = v166;
                        }
                        if ((v168 & 0x200000000) == 0 || (*((_BYTE *)v3 + 4676) & 2) == 0 || !*((_QWORD *)v3 + 380))
                        {
LABEL_396:
                          if ((v168 & 0x400000000) == 0 || (*((_BYTE *)v3 + 4676) & 4) == 0 || !*((_QWORD *)v3 + 381))
                          {
LABEL_409:
                            if ((v168 & 0x1000000000) == 0
                              || (*((_BYTE *)v3 + 4676) & 0x10) == 0
                              || !*((_QWORD *)v3 + 383))
                            {
LABEL_422:
                              if (v127 == 2)
                              {
                                VoiceProcessorV4::SignalParamSwitchMixNF((AudioUnit *)v3, v130, v128, (BOOL *)&v293, *(AudioUnitParameterValue *)&v166);
                              }
                              else if (v127 == 1)
                              {
                                VoiceProcessorV2::SignalParamSwitchMix((AudioUnit *)v3, v130, v128, &v293, v165);
                              }
                              if (v131 == 1)
                                VoiceProcessorV2::TimeAlignedReferenceAndOtherHandling(v3, v300, v298, v130, v293 != 0);
                              else
                                VoiceProcessorV4::TimeAlignedReferenceAndOtherHandlingNF(v3, v300, v296, v130, v293 != 0);
                              v185 = (OpaqueAudioComponentInstance *)memcpy(*(void **)(*((_QWORD *)v3 + 432) + 16), *(const void **)(*((_QWORD *)v3 + 504) + 16), *((unsigned int *)v3 + 1071));
                              v186 = *((_QWORD *)v3 + 582);
                              if ((v186 & 0x40000) != 0
                                && (*((_BYTE *)v3 + 4674) & 4) != 0
                                && *((_QWORD *)v3 + 365)
                                && v294 == 1.0)
                              {
                                v185 = (OpaqueAudioComponentInstance *)memcpy(*(void **)(*((_QWORD *)v3 + 2131) + 16), *(const void **)(*((_QWORD *)v3 + 504) + 48), *((unsigned int *)v3 + 1071));
                                v186 = *((_QWORD *)v3 + 582);
                              }
                              if ((v186 & 0x200000000000) == 0
                                || (v187 = *((_QWORD *)v3 + 584), (v187 & 0x200000000000) == 0)
                                || !*((_QWORD *)v3 + 392))
                              {
LABEL_452:
                                if ((v186 & 0x20000000000000) != 0
                                  && (*((_BYTE *)v3 + 4678) & 0x20) != 0
                                  && *((_QWORD *)v3 + 400))
                                {
                                  v203 = 1;
                                }
                                else
                                {
                                  v203 = (v186 & 0x80000000000000) != 0
                                      && (*((_BYTE *)v3 + 4678) & 0x80) != 0
                                      && *((_QWORD *)v3 + 402) != 0;
                                }
                                ioDataSize[0] = 0;
                                LODWORD(v312) = 0;
                                AudioUnitGetParameter(*((AudioUnit *)v3 + 389), 0x1Du, 0, 0, (AudioUnitParameterValue *)ioDataSize);
                                v204 = *(float *)ioDataSize < 1.0 && v203;
                                if (v203)
                                {
                                  LODWORD(inInputBufferLists.mSampleTime) = 1065353216;
                                  if (*(float *)ioDataSize < 1.0)
                                    vDSP_vfill((const float *)&inInputBufferLists, *(float **)(*((_QWORD *)v3 + 501) + 16), 1, *((unsigned int *)v3 + 127));
                                  vDSP_vfill((const float *)&inInputBufferLists, *(float **)(*((_QWORD *)v3 + 499) + 16), 1, *((unsigned int *)v3 + 127));
                                }
                                else if ((*((_BYTE *)v3 + 4661) & 4) == 0
                                       || (*((_BYTE *)v3 + 4677) & 4) == 0
                                       || !*((_QWORD *)v3 + 389))
                                {
                                  v205 = 0;
                                  goto LABEL_475;
                                }
                                if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x61u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 428), &buf);
                                v205 = 1;
LABEL_475:
                                v206 = (void *)*((_QWORD *)v3 + 500);
                                v207 = *((_QWORD *)v3 + 582);
                                if ((v207 & 0x20000000000000) != 0
                                  && (*((_BYTE *)v3 + 4678) & 0x20) != 0
                                  && (v208 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 400)) != 0)
                                {
                                  v209 = *((_QWORD *)v3 + 499);
                                  v311.mSampleTime = *((Float64 *)v3 + 428);
                                  v311.mHostTime = v209;
                                  *(_QWORD *)&v311.mRateScalar = (char *)v3 + 16808;
                                  v210 = *((_QWORD *)v3 + 501);
                                  *(_QWORD *)&v314.mNumberBuffers = *((_QWORD *)v3 + 429);
                                  *(_QWORD *)&v314.mBuffers[0].mNumberChannels = v210;
                                  v314.mBuffers[0].mData = v206;
                                  v301 = 512;
                                  v211 = *(_OWORD *)&a2->mRateScalar;
                                  *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                  *(_OWORD *)&inInputBufferLists.mRateScalar = v211;
                                  v212 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                  *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                  *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v212;
                                  AudioUnitProcessMultiple(v208, &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 3u, (const AudioBufferList **)&v311, 3u, (AudioBufferList **)&v314);
                                  AudioUnitGetParameter(*((AudioUnit *)v3 + 400), 1u, 0, 0, &v302);
                                  if ((*((_BYTE *)v3 + 4664) & 2) == 0
                                    || (*((_BYTE *)v3 + 4680) & 2) == 0
                                    || !*((_QWORD *)v3 + 412))
                                  {
                                    goto LABEL_490;
                                  }
                                  v213 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 400);
                                  v214 = 2;
                                }
                                else
                                {
                                  if ((v207 & 0x80000000000000) == 0
                                    || (*((_BYTE *)v3 + 4678) & 0x80) == 0
                                    || (v215 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 402)) == 0)
                                  {
                                    v220 = 1;
                                    goto LABEL_495;
                                  }
                                  AudioUnitSetParameter(v215, 0x14u, 0, 0, *((AudioUnitParameterValue *)v3 + 4172), 0);
                                  v216 = *((_QWORD *)v3 + 431);
                                  v311.mSampleTime = *((Float64 *)v3 + 428);
                                  v311.mHostTime = v216;
                                  v311.mRateScalar = *((Float64 *)v3 + 499);
                                  v311.mWordClockTime = (UInt64)v3 + 16808;
                                  v217 = *((_QWORD *)v3 + 436);
                                  *(_QWORD *)&v314.mNumberBuffers = *((_QWORD *)v3 + 429);
                                  *(_QWORD *)&v314.mBuffers[0].mNumberChannels = v217;
                                  v314.mBuffers[0].mData = (void *)*((_QWORD *)v3 + 501);
                                  v315 = v206;
                                  v218 = *(_OWORD *)&a2->mRateScalar;
                                  *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                  *(_OWORD *)&inInputBufferLists.mRateScalar = v218;
                                  v219 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                  *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                  *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v219;
                                  v301 = 512;
                                  AudioUnitProcessMultiple(*((AudioUnit *)v3 + 402), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 4u, (const AudioBufferList **)&v311, 4u, (AudioBufferList **)&v314);
                                  AudioUnitGetParameter(*((AudioUnit *)v3 + 402), 2u, 0, 0, &v302);
                                  if ((*((_BYTE *)v3 + 4664) & 2) == 0
                                    || (*((_BYTE *)v3 + 4680) & 2) == 0
                                    || !*((_QWORD *)v3 + 412))
                                  {
LABEL_490:
                                    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x27u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 429), &inInputBufferLists);
                                    v220 = 0;
LABEL_495:
                                    v221 = *((_QWORD *)v3 + 582);
                                    if ((v221 & 0x200000000000000) != 0 && (*((_BYTE *)v3 + 4679) & 2) != 0)
                                    {
                                      v222 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 404);
                                      if (v222)
                                      {
                                        LODWORD(v291) = v205;
                                        v223 = v204;
                                        v311.mSampleTime = *((Float64 *)v3 + 428);
                                        *(_QWORD *)&v314.mNumberBuffers = 0;
                                        v224 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v224;
                                        v225 = *(_OWORD *)&a2->mRateScalar;
                                        *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                        *(_OWORD *)&inInputBufferLists.mRateScalar = v225;
                                        v301 = 512;
                                        v226 = *((_QWORD *)v3 + 502);
                                        v227 = *(void **)(v226 + 16);
                                        v228 = *(_DWORD *)(v226 + 12);
                                        if ((AudioUnitProcessMultiple(v222, &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)&v311, 1u, (AudioBufferList **)&v314)|| AudioUnitGetProperty(*((AudioUnit *)v3 + 404), 0x13EDu, 0, 0, *(void **)(*((_QWORD *)v3 + 502) + 16), (UInt32 *)(*((_QWORD *)v3 + 502) + 12)))&& v228 >= 4)
                                        {
                                          memset_pattern16(v227, &unk_1B6627B80, v228 & 0xFFFFFFFC);
                                        }
                                        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x52u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 502), &inInputBufferLists);
                                        v221 = *((_QWORD *)v3 + 582);
                                        v204 = v223;
                                        v205 = (int)v291;
                                      }
                                    }
                                    if ((v221 & 0x40000000000) == 0)
                                      goto LABEL_507;
                                    if ((*((_BYTE *)v3 + 4677) & 4) == 0
                                      || (v230 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 389)) == 0)
                                    {
LABEL_538:
                                      if ((*((_BYTE *)v3 + 4677) & 4) != 0 && *((_QWORD *)v3 + 389) && v204)
                                      {
                                        v245 = *(float **)(*((_QWORD *)v3 + 501) + 16);
                                        vDSP_vmin(*(const float **)(*((_QWORD *)v3 + 499) + 16), 1, v245, 1, v245, 1, *((unsigned int *)v3 + 127));
                                        if ((*((_BYTE *)v3 + 4663) & 2) != 0
                                          && (*((_BYTE *)v3 + 4679) & 2) != 0
                                          && *((_QWORD *)v3 + 404))
                                        {
                                          vDSP_vmin(*(const float **)(*((_QWORD *)v3 + 502) + 16), 1, v245, 1, v245, 1, *((unsigned int *)v3 + 127));
                                        }
                                        v246 = *(const float **)(*((_QWORD *)v3 + 428) + 16);
                                        v247 = *(float **)(*((_QWORD *)v3 + 429) + 16);
                                        vDSP_vmul(v246, 1, v245, 1, v247, 1, *((unsigned int *)v3 + 127));
                                        vDSP_vmul(&v246[*((unsigned int *)v3 + 127) + 1], 1, v245 + 1, 1, &v247[*((unsigned int *)v3 + 127) + 1], 1, (*((_DWORD *)v3 + 127) - 1));
                                        v246[*((unsigned int *)v3 + 127)] = v246[*((unsigned int *)v3 + 127)]
                                                                          * v245[*((_DWORD *)v3 + 127) - 1];
                                        goto LABEL_553;
                                      }
                                      v229 = (*((_BYTE *)v3 + 4677) & 4) != 0 && *((_QWORD *)v3 + 389) != 0;
LABEL_551:
                                      if (!v229 && !v203)
                                      {
                                        LODWORD(inInputBufferLists.mSampleTime) = 1065353216;
                                        v248 = *((_DWORD *)v3 + 127);
                                        vDSP_vfill((const float *)&inInputBufferLists, *(float **)(*((_QWORD *)v3 + 501) + 16), 1, v248);
                                        memcpy(*(void **)(*((_QWORD *)v3 + 429) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 8 * v248);
                                      }
LABEL_553:
                                      if (((v205 & 1) != 0
                                         || (*((_BYTE *)v3 + 4661) & 4) != 0
                                         && (*((_BYTE *)v3 + 4677) & 4) != 0
                                         && *((_QWORD *)v3 + 389))
                                        && (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898)))
                                      {
                                        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x60u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 429), &buf);
                                      }
                                      if ((*((_BYTE *)v3 + 4663) & 0x10) != 0 && (*((_BYTE *)v3 + 4679) & 0x10) != 0)
                                      {
                                        v249 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 407);
                                        if (v249)
                                        {
                                          AudioUnitSetParameter(v249, 0, 0, 0, *((AudioUnitParameterValue *)v3 + 3117), 0);
                                          AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 4u, 0, 0, *((AudioUnitParameterValue *)v3 + 1046), 0);
                                          AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 0x13u, 0, 0, *((AudioUnitParameterValue *)v3 + 1050), 0);
                                          AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 3u, 0, 0, v302, 0);
                                          AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 0xEu, 0, 0, (float)*((int *)v3 + 576), 0);
                                          v250 = *((_QWORD *)v3 + 510);
                                          v311.mSampleTime = *((Float64 *)v3 + 418);
                                          v311.mHostTime = v250;
                                          v311.mRateScalar = *((Float64 *)v3 + 429);
                                          v251 = *((_QWORD *)v3 + 499);
                                          v311.mWordClockTime = *((_QWORD *)v3 + 509);
                                          *(_QWORD *)&v311.mSMPTETime.mSubframes = v251;
                                          *(_QWORD *)&v311.mSMPTETime.mType = *((_QWORD *)v3 + 501);
                                          *(_QWORD *)&v314.mNumberBuffers = *((_QWORD *)v3 + 136);
                                          v301 = 512;
                                          v252 = *(_OWORD *)&a2->mRateScalar;
                                          *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                          *(_OWORD *)&inInputBufferLists.mRateScalar = v252;
                                          v253 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v253;
                                          AudioUnitProcessMultiple(*((AudioUnit *)v3 + 407), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)&v311, 1u, (AudioBufferList **)&v314);
                                          LODWORD(v309) = 0;
                                          AudioUnitGetParameter(*((AudioUnit *)v3 + 407), 1u, 0, 0, (AudioUnitParameterValue *)&v309);
                                          *((_DWORD *)v3 + 3118) = (_DWORD)v309;
                                          if ((*((_BYTE *)v3 + 4664) & 2) != 0
                                            && (*((_BYTE *)v3 + 4680) & 2) != 0
                                            && *((_QWORD *)v3 + 412))
                                          {
                                            AudioUnitGetParameter(*((AudioUnit *)v3 + 407), 2u, 0, 0, &v302);
                                            AudioUnitSetParameter(*((AudioUnit *)v3 + 412), 0x23u, 0, 0, v302, 0);
                                          }
                                        }
                                      }
                                      goto LABEL_567;
                                    }
                                    AudioUnitSetParameter(v230, 6u, 0, 0, *((AudioUnitParameterValue *)v3 + 1054), 0);
                                    AudioUnitSetParameter(*((AudioUnit *)v3 + 389), 7u, 0, 0, *((AudioUnitParameterValue *)v3 + 1058), 0);
                                    AudioUnitSetParameter(*((AudioUnit *)v3 + 389), 0xDu, 0, 0, *((AudioUnitParameterValue *)v3 + 1062), 0);
                                    v231 = *((_QWORD *)v3 + 432);
                                    v311.mSampleTime = *((Float64 *)v3 + 428);
                                    v311.mHostTime = v231;
                                    v311.mRateScalar = *((Float64 *)v3 + 511);
                                    v311.mWordClockTime = *((_QWORD *)v3 + 501);
                                    *(_QWORD *)&v311.mSMPTETime.mSubframes = v206;
                                    *(_QWORD *)&v311.mSMPTETime.mType = 0;
                                    if (!v204)
                                      v311.mWordClockTime = 0;
                                    v232 = *((_QWORD *)v3 + 509);
                                    *(_QWORD *)&v314.mNumberBuffers = 0;
                                    *(_QWORD *)&v314.mBuffers[0].mNumberChannels = v232;
                                    v314.mBuffers[0].mData = 0;
                                    v233 = *((_QWORD *)v3 + 582);
                                    LODWORD(v291) = v205;
                                    if ((v233 & 0x100000) != 0
                                      && (v234 = *((_QWORD *)v3 + 584), (v234 & 0x100000) != 0)
                                      && (v235 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 367)) != 0
                                      && (v233 & v234 & 0x20000) != 0
                                      && *((_QWORD *)v3 + 364))
                                    {
                                      LODWORD(inInputBufferLists.mSampleTime) = 0;
                                      *(_QWORD *)&v311.mSMPTETime.mType = *((_QWORD *)v3 + 507);
                                      AudioUnitGetParameter(v235, 0x2Du, 0, 0, (AudioUnitParameterValue *)&inInputBufferLists);
                                      AudioUnitSetParameter(*((AudioUnit *)v3 + 389), 0x2Au, 0, 0, *(AudioUnitParameterValue *)&inInputBufferLists.mSampleTime, 0);
                                      AudioUnitGetParameter(*((AudioUnit *)v3 + 364), 0x2Du, 0, 0, (AudioUnitParameterValue *)&inInputBufferLists);
                                      AudioUnitSetParameter(*((AudioUnit *)v3 + 389), 0x29u, 0, 0, *(AudioUnitParameterValue *)&inInputBufferLists.mSampleTime, 0);
                                    }
                                    else if ((v233 & 0x40000) != 0
                                           && (*((_BYTE *)v3 + 4674) & 4) != 0
                                           && *((_QWORD *)v3 + 365)
                                           && v294 == 1.0)
                                    {
                                      *(_QWORD *)&v311.mSMPTETime.mType = *((_QWORD *)v3 + 2131);
                                    }
                                    v236 = 4008;
                                    if (v204)
                                      v236 = 3992;
                                    v237 = *(void **)((char *)v3 + v236);
                                    v238 = v204;
                                    if (v204)
                                      v239 = 3448;
                                    else
                                      v239 = 3432;
                                    *(_QWORD *)&v314.mNumberBuffers = *(_QWORD *)((char *)v3 + v239);
                                    v314.mBuffers[0].mData = v237;
                                    v240 = *(_OWORD *)&a2->mRateScalar;
                                    *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                    *(_OWORD *)&inInputBufferLists.mRateScalar = v240;
                                    v241 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                    *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                    *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v241;
                                    v301 = 512;
                                    AudioUnitProcessMultiple(*((AudioUnit *)v3 + 389), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)&v311, 3u, (AudioBufferList **)&v314);
                                    if ((v220 | !v238) == 1)
                                      AudioUnitGetParameter(*((AudioUnit *)v3 + 389), 0x20u, 0, 0, &v302);
                                    v242 = *((unsigned int *)v3 + 127);
                                    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                    {
                                      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x24u, v242, *(const AudioBufferList **)((char *)v3 + v239), &inInputBufferLists);
                                      v242 = *((unsigned int *)v3 + 127);
                                      v243 = (const AudioBufferList *)*((_QWORD *)v3 + 499);
                                      v204 = v238;
                                      if (*((_BYTE *)v3 + 15897))
                                      {
LABEL_536:
                                        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Fu, v242, v243, &inInputBufferLists);
LABEL_537:
                                        LOBYTE(v205) = (_BYTE)v291;
                                        if ((*((_BYTE *)v3 + 4661) & 4) == 0)
                                        {
LABEL_507:
                                          v229 = 0;
                                          goto LABEL_551;
                                        }
                                        goto LABEL_538;
                                      }
                                    }
                                    else
                                    {
                                      v243 = (const AudioBufferList *)*((_QWORD *)v3 + 499);
                                      v204 = v238;
                                    }
                                    if (!*((_BYTE *)v3 + 15898))
                                      goto LABEL_537;
                                    goto LABEL_536;
                                  }
                                  v213 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 402);
                                  v214 = 9;
                                }
                                AudioUnitGetParameter(v213, v214, 0, 0, (AudioUnitParameterValue *)&v312);
                                AudioUnitSetParameter(*((AudioUnit *)v3 + 412), 0x12u, 0, 0, *(AudioUnitParameterValue *)&v312, 0);
                                goto LABEL_490;
                              }
                              ioDataSize[0] = 1092616192;
                              if ((v186 & v187 & 0x80000000000000) != 0)
                              {
                                v185 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 402);
                                if (v185)
                                {
                                  v185 = (OpaqueAudioComponentInstance *)AudioUnitGetParameter(v185, 9u, 0, 0, (AudioUnitParameterValue *)ioDataSize);
                                  v186 = *((_QWORD *)v3 + 582);
                                }
                              }
                              if ((v186 & 0x80000000) != 0
                                && (*((_BYTE *)v3 + 4675) & 0x80) != 0
                                && *((_QWORD *)v3 + 378))
                              {
                                LODWORD(inInputBufferLists.mSampleTime) = 0;
                                LODWORD(v311.mSampleTime) = 0;
                                v314.mNumberBuffers = 0;
                                AudioUnitGetParameter(*((AudioUnit *)v3 + 379), 0x18u, 0, 0, (AudioUnitParameterValue *)&inInputBufferLists);
                                AudioUnitGetParameter(*((AudioUnit *)v3 + 379), 0x19u, 0, 0, (AudioUnitParameterValue *)&v311);
                                AudioUnitGetParameter(*((AudioUnit *)v3 + 379), 5u, 0, 0, (AudioUnitParameterValue *)&v314.mNumberBuffers);
                                AudioUnitSetParameter(*((AudioUnit *)v3 + 392), 3u, 0, 0, *(AudioUnitParameterValue *)&inInputBufferLists.mSampleTime, 0);
                                AudioUnitSetParameter(*((AudioUnit *)v3 + 392), 4u, 0, 0, *(AudioUnitParameterValue *)&v311.mSampleTime, 0);
                                AudioUnitSetParameter(*((AudioUnit *)v3 + 392), 5u, 0, 0, *(AudioUnitParameterValue *)&v314.mNumberBuffers, 0);
                                v185 = (OpaqueAudioComponentInstance *)AudioUnitSetParameter(*((AudioUnit *)v3 + 392), 6u, 0, 0, *(AudioUnitParameterValue *)ioDataSize, 0);
                              }
                              MEMORY[0x1E0C80A78](v185);
                              v279 = 0;
                              *((_OWORD *)&v280 - 3) = 0u;
                              *((_OWORD *)&v280 - 2) = 0u;
                              *((_DWORD *)&v280 - 12) = 2;
                              v188 = *((_QWORD *)v3 + 428);
                              *(&v280 - 4) = *(AudioUnitParameterValue **)(v188 + 16);
                              *(&v280 - 5) = *(AudioUnitParameterValue **)(v188 + 8);
                              v189 = *((_QWORD *)v3 + 431);
                              v279 = *(_QWORD *)(v189 + 16);
                              *(&v280 - 3) = *(AudioUnitParameterValue **)(v189 + 8);
                              *(double *)&v191 = MEMORY[0x1E0C80A78](v190);
                              *((_OWORD *)&v280 - 3) = v191;
                              *((_OWORD *)&v280 - 2) = v191;
                              *((_DWORD *)&v280 - 12) = v192;
                              MEMORY[0x1E0C80A78](v193);
                              *(&v280 - 3) = 0;
                              v279 = 0;
                              *(&v280 - 4) = 0;
                              *((_DWORD *)&v280 - 8) = 1;
                              v194 = *((_QWORD *)v3 + 432);
                              *(_QWORD *)(v195 - 32) = *(_QWORD *)(v194 + 16);
                              *(_QWORD *)(v195 - 40) = *(_QWORD *)(v194 + 8);
                              v196 = *((_QWORD *)v3 + 504);
                              *(_QWORD *)(v195 - 16) = *(_QWORD *)(v196 + 32);
                              *(_QWORD *)(v195 - 24) = *(_QWORD *)(v196 + 24);
                              v279 = *(_QWORD *)(v194 + 16);
                              *(&v280 - 3) = *(AudioUnitParameterValue **)(v194 + 8);
                              v311.mSampleTime = v197;
                              v311.mHostTime = v198;
                              *(Float64 *)&v314.mNumberBuffers = v197;
                              *(_QWORD *)&v314.mBuffers[0].mNumberChannels = &v280 - 4;
                              v199 = *(_OWORD *)&a2->mRateScalar;
                              *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                              *(_OWORD *)&inInputBufferLists.mRateScalar = v199;
                              v200 = *(_OWORD *)&a2->mSMPTETime.mHours;
                              *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                              *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v200;
                              v301 = 512;
                              AudioUnitProcessMultiple(*((AudioUnit *)v3 + 392), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&v311, 2u, (AudioBufferList **)&v314);
                              v201 = *((unsigned int *)v3 + 127);
                              if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                              {
                                VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x81u, v201, *((const AudioBufferList **)v3 + 428), &inInputBufferLists);
                                v201 = *((unsigned int *)v3 + 127);
                                v202 = (const AudioBufferList *)*((_QWORD *)v3 + 431);
                                if (*((_BYTE *)v3 + 15897))
                                  goto LABEL_450;
                              }
                              else
                              {
                                v202 = (const AudioBufferList *)*((_QWORD *)v3 + 431);
                              }
                              if (!*((_BYTE *)v3 + 15898))
                              {
LABEL_451:
                                v186 = *((_QWORD *)v3 + 582);
                                goto LABEL_452;
                              }
LABEL_450:
                              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x82u, v201, v202, &inInputBufferLists);
                              goto LABEL_451;
                            }
                            v285 = v163;
                            v286 = v131;
                            v287 = v127;
                            v288 = v130;
                            v289 = v128;
                            v179 = 0;
                            v180 = (AudioBufferList *)*((_QWORD *)v3 + 523);
                            v281 = (AudioUnitParameterValue *)((char *)v3 + 4184);
                            v312 = v180;
                            LODWORD(v313) = *((_DWORD *)v3 + 1049);
                            v282 = (AudioUnitParameterValue *)((char *)v3 + 4200);
                            v309 = (const AudioBufferList *)*((_QWORD *)v3 + 525);
                            v310 = *((_DWORD *)v3 + 1053);
                            v283 = (AudioUnitParameterValue *)((char *)v3 + 4216);
                            v307 = *((_QWORD *)v3 + 527);
                            v308 = *((_DWORD *)v3 + 1057);
                            v284 = (AudioUnitParameterValue *)((char *)v3 + 4232);
                            v305 = *((_QWORD *)v3 + 529);
                            v306 = *((_DWORD *)v3 + 1061);
                            v280 = (AudioUnitParameterValue *)((char *)v3 + 4248);
                            v303 = *((_QWORD *)v3 + 531);
                            v304 = *((_DWORD *)v3 + 1065);
                            do
                            {
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x64u, 4u, v179, *((AudioUnitParameterValue *)&v312 + v179), 0);
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x65u, 4u, v179, *((AudioUnitParameterValue *)&v309 + v179), 0);
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x66u, 4u, v179, *((AudioUnitParameterValue *)&v307 + v179), 0);
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x67u, 4u, v179, *((AudioUnitParameterValue *)&v305 + v179), 0);
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x68u, 4u, v179, *((AudioUnitParameterValue *)&v303 + v179), 0);
                              ++v179;
                            }
                            while (v179 != 3);
                            *(_QWORD *)&v314.mNumberBuffers = 1;
                            *(_QWORD *)&v314.mBuffers[0].mNumberChannels = 0;
                            v314.mBuffers[0].mData = 0;
                            v314.mBuffers[0] = *(AudioBuffer *)(*((_QWORD *)v3 + 504) + 8);
                            *(_QWORD *)ioDataSize = v285;
                            v318 = (AudioUnitParameterValue *)v291;
                            v311.mSampleTime = *((Float64 *)v3 + 428);
                            v311.mHostTime = (UInt64)&v314;
                            v311.mWordClockTime = 0;
                            v311.mRateScalar = 0.0;
                            v301 = 512;
                            v181 = *(_OWORD *)&a2->mRateScalar;
                            *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                            *(_OWORD *)&inInputBufferLists.mRateScalar = v181;
                            v182 = *(_OWORD *)&a2->mSMPTETime.mHours;
                            *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                            *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v182;
                            AudioUnitProcessMultiple(*((AudioUnit *)v3 + 383), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)ioDataSize, 4u, (AudioBufferList **)&v311);
                            v292 = 0.0;
                            AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0xAu, 0, 0, &v292);
                            v183 = *((unsigned int *)v3 + 127);
                            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                            {
                              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x64u, v183, *((const AudioBufferList **)v3 + 428), &inInputBufferLists);
                              v183 = *((unsigned int *)v3 + 127);
                              v130 = v288;
                              v128 = v289;
                              v131 = v286;
                              v127 = v287;
                              v184 = v280;
                              if (*((_BYTE *)v3 + 15897))
                                goto LABEL_420;
                            }
                            else
                            {
                              v130 = v288;
                              v128 = v289;
                              v131 = v286;
                              v127 = v287;
                              v184 = v280;
                            }
                            if (!*((_BYTE *)v3 + 15898))
                            {
LABEL_421:
                              AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x64u, 4u, 0, v281);
                              AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x65u, 4u, 0, v282);
                              AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x66u, 4u, 0, v283);
                              AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x67u, 4u, 0, v284);
                              AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x68u, 4u, 0, v184);
                              goto LABEL_422;
                            }
LABEL_420:
                            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x65u, v183, &v314, &inInputBufferLists);
                            goto LABEL_421;
                          }
                          v285 = v163;
                          v286 = v131;
                          v287 = v127;
                          v288 = v130;
                          v289 = v128;
                          v175 = 0;
                          *(_QWORD *)ioDataSize = *((_QWORD *)v3 + 523);
                          LODWORD(v318) = *((_DWORD *)v3 + 1049);
                          v312 = (AudioBufferList *)*((_QWORD *)v3 + 525);
                          LODWORD(v313) = *((_DWORD *)v3 + 1053);
                          v309 = (const AudioBufferList *)*((_QWORD *)v3 + 527);
                          v310 = *((_DWORD *)v3 + 1057);
                          v307 = *((_QWORD *)v3 + 529);
                          v308 = *((_DWORD *)v3 + 1061);
                          v305 = *((_QWORD *)v3 + 531);
                          v306 = *((_DWORD *)v3 + 1065);
                          do
                          {
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x12u, 4u, v175, *(AudioUnitParameterValue *)&ioDataSize[v175], 0);
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x13u, 4u, v175, *((AudioUnitParameterValue *)&v312 + v175), 0);
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x14u, 4u, v175, *((AudioUnitParameterValue *)&v309 + v175), 0);
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x15u, 4u, v175, *((AudioUnitParameterValue *)&v307 + v175), 0);
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x16u, 4u, v175, *((AudioUnitParameterValue *)&v305 + v175), 0);
                            ++v175;
                          }
                          while (v175 != 3);
                          v163 = v285;
                          *(_QWORD *)&v311.mSampleTime = v285;
                          v311.mHostTime = (UInt64)v291;
                          *(_QWORD *)&v314.mNumberBuffers = v285;
                          *(_QWORD *)&v314.mBuffers[0].mNumberChannels = v291;
                          v301 = 512;
                          v176 = *(_OWORD *)&a2->mRateScalar;
                          *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                          *(_OWORD *)&inInputBufferLists.mRateScalar = v176;
                          v177 = *(_OWORD *)&a2->mSMPTETime.mHours;
                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v177;
                          AudioUnitProcessMultiple(*((AudioUnit *)v3 + 381), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&v311, 2u, (AudioBufferList **)&v314);
                          v178 = *((unsigned int *)v3 + 127);
                          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                          {
                            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x6Bu, v178, v163, &inInputBufferLists);
                            v178 = *((unsigned int *)v3 + 127);
                            v130 = v288;
                            v128 = v289;
                            v131 = v286;
                            v127 = v287;
                            if (*((_BYTE *)v3 + 15897))
                              goto LABEL_407;
                          }
                          else
                          {
                            v130 = v288;
                            v128 = v289;
                            v131 = v286;
                            v127 = v287;
                          }
                          if (!*((_BYTE *)v3 + 15898))
                          {
LABEL_408:
                            v168 = *((_QWORD *)v3 + 582);
                            goto LABEL_409;
                          }
LABEL_407:
                          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x6Cu, v178, (const AudioBufferList *)v291, &inInputBufferLists);
                          goto LABEL_408;
                        }
                        v285 = (const AudioBufferList *)(&v280 - 8);
                        v286 = v131;
                        v287 = v127;
                        v288 = v130;
                        v289 = v128;
                        v171 = 0;
                        *(_QWORD *)ioDataSize = *((_QWORD *)v3 + 523);
                        LODWORD(v318) = *((_DWORD *)v3 + 1049);
                        v312 = (AudioBufferList *)*((_QWORD *)v3 + 525);
                        LODWORD(v313) = *((_DWORD *)v3 + 1053);
                        v309 = (const AudioBufferList *)*((_QWORD *)v3 + 527);
                        v310 = *((_DWORD *)v3 + 1057);
                        v307 = *((_QWORD *)v3 + 529);
                        v308 = *((_DWORD *)v3 + 1061);
                        v305 = *((_QWORD *)v3 + 531);
                        v306 = *((_DWORD *)v3 + 1065);
                        do
                        {
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 9u, 4u, v171, *(AudioUnitParameterValue *)&ioDataSize[v171], 0);
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 0xAu, 4u, v171, *((AudioUnitParameterValue *)&v312 + v171), 0);
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 0xBu, 4u, v171, *((AudioUnitParameterValue *)&v309 + v171), 0);
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 0xCu, 4u, v171, *((AudioUnitParameterValue *)&v307 + v171), 0);
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 0xDu, 4u, v171, *((AudioUnitParameterValue *)&v305 + v171), 0);
                          ++v171;
                        }
                        while (v171 != 3);
                        v163 = v285;
                        *(_QWORD *)&v311.mSampleTime = v285;
                        v311.mHostTime = (UInt64)v291;
                        *(_QWORD *)&v314.mNumberBuffers = v285;
                        *(_QWORD *)&v314.mBuffers[0].mNumberChannels = v291;
                        v301 = 512;
                        v172 = *(_OWORD *)&a2->mRateScalar;
                        *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                        *(_OWORD *)&inInputBufferLists.mRateScalar = v172;
                        v173 = *(_OWORD *)&a2->mSMPTETime.mHours;
                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v173;
                        AudioUnitProcessMultiple(*((AudioUnit *)v3 + 380), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&v311, 2u, (AudioBufferList **)&v314);
                        v174 = *((unsigned int *)v3 + 127);
                        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                        {
                          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x69u, v174, v163, &inInputBufferLists);
                          v174 = *((unsigned int *)v3 + 127);
                          v130 = v288;
                          v128 = v289;
                          v131 = v286;
                          v127 = v287;
                          if (*((_BYTE *)v3 + 15897))
                            goto LABEL_394;
                        }
                        else
                        {
                          v130 = v288;
                          v128 = v289;
                          v131 = v286;
                          v127 = v287;
                        }
                        if (!*((_BYTE *)v3 + 15898))
                        {
LABEL_395:
                          v168 = *((_QWORD *)v3 + 582);
                          goto LABEL_396;
                        }
LABEL_394:
                        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x6Au, v174, (const AudioBufferList *)v291, &inInputBufferLists);
                        goto LABEL_395;
                      }
                      if ((v118 & 0x80000000) == 0 || (*((_BYTE *)v3 + 4675) & 0x80) == 0 || !*((_QWORD *)v3 + 378))
                        goto LABEL_373;
                      memcpy(*(void **)(*((_QWORD *)v3 + 434) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 8 * *((unsigned int *)v3 + 127));
                      memcpy(*(void **)(*((_QWORD *)v3 + 434) + 32), *(const void **)(*((_QWORD *)v3 + 506) + 16), 8 * *((unsigned int *)v3 + 127));
                      v309 = (const AudioBufferList *)*((_QWORD *)v3 + 434);
                      v151 = (AudioUnitParameterValue *)*((_QWORD *)v3 + 433);
                      *(_QWORD *)ioDataSize = *((_QWORD *)v3 + 429);
                      v318 = v151;
                      v152 = *(_OWORD *)&a2->mRateScalar;
                      *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                      *(_OWORD *)&inInputBufferLists.mRateScalar = v152;
                      v153 = *(_OWORD *)&a2->mSMPTETime.mHours;
                      *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                      *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v153;
                      Parameter = AudioUnitProcessMultiple(*((AudioUnit *)v3 + 378), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 1u, &v309, 2u, (AudioBufferList **)ioDataSize);
                      v154 = *((unsigned int *)v3 + 127);
                      if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                      {
                        Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x18u, v154, *(const AudioBufferList **)ioDataSize, &inInputBufferLists);
                        v154 = *((unsigned int *)v3 + 127);
                        v155 = (const AudioBufferList *)v318;
                        if (*((_BYTE *)v3 + 15897))
                          goto LABEL_358;
                      }
                      else
                      {
                        v155 = (const AudioBufferList *)v318;
                      }
                      if (!*((_BYTE *)v3 + 15898))
                      {
LABEL_359:
                        if ((*((_BYTE *)v3 + 4660) & 1) == 0
                          || (*((_BYTE *)v3 + 4676) & 1) == 0
                          || !*((_QWORD *)v3 + 379))
                        {
                          goto LABEL_373;
                        }
                        memcpy(*(void **)(*((_QWORD *)v3 + 435) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
                        memcpy(*(void **)(*((_QWORD *)v3 + 430) + 16), *(const void **)(*((_QWORD *)v3 + 431) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
                        LODWORD(v307) = 1092616192;
                        v156 = *((_QWORD *)v3 + 433);
                        *(_QWORD *)&v314.mNumberBuffers = *((_QWORD *)v3 + 429);
                        *(_QWORD *)&v314.mBuffers[0].mNumberChannels = v156;
                        v157 = (void *)*((_QWORD *)v3 + 506);
                        v314.mBuffers[0].mData = (void *)*((_QWORD *)v3 + 435);
                        v315 = v157;
                        v316 = *((_QWORD *)v3 + 430);
                        v158 = (const AudioBufferList *)*((_QWORD *)v3 + 431);
                        v159 = 10.0;
                        v312 = (AudioBufferList *)*((_QWORD *)v3 + 428);
                        v313 = v158;
                        if ((*((_BYTE *)v3 + 4662) & 0x80) != 0 && (*((_BYTE *)v3 + 4678) & 0x80) != 0)
                        {
                          v160 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 402);
                          if (v160)
                          {
                            AudioUnitGetParameter(v160, 9u, 0, 0, (AudioUnitParameterValue *)&v307);
                            v159 = *(float *)&v307;
                          }
                        }
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 379), 0xAu, 0, 0, v159, 0);
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 379), 0x17u, 0, 0, *((AudioUnitParameterValue *)v3 + 4172), 0);
                        v161 = *(_OWORD *)&a2->mRateScalar;
                        *(_OWORD *)&v311.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                        *(_OWORD *)&v311.mRateScalar = v161;
                        v162 = *(_OWORD *)&a2->mSMPTETime.mHours;
                        *(_OWORD *)&v311.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                        *(_OWORD *)&v311.mSMPTETime.mHours = v162;
                        Parameter = AudioUnitProcessMultiple(*((AudioUnit *)v3 + 379), &v301, &v311, *((_DWORD *)v3 + 127), 5u, (const AudioBufferList **)&v314, 2u, &v312);
                        v146 = *((unsigned int *)v3 + 127);
                        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                        {
                          Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Au, v146, v312, &v311);
                          v146 = *((unsigned int *)v3 + 127);
                          v147 = v313;
                          if (*((_BYTE *)v3 + 15897))
                            goto LABEL_372;
                        }
                        else
                        {
                          v147 = v313;
                        }
                        if (!*((_BYTE *)v3 + 15898))
                          goto LABEL_373;
LABEL_372:
                        p_inInputBufferLists = &v311;
                        v149 = (uint64_t)v3;
                        v150 = 27;
                        goto LABEL_345;
                      }
LABEL_358:
                      Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x19u, v154, v155, &inInputBufferLists);
                      goto LABEL_359;
                    }
                  }
                  else
                  {
                    v134 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 376);
                  }
                  v135 = 2.0;
                  goto LABEL_326;
                }
                v120 = *((float *)v3 + 1055);
                if (v120 == 0.0)
                {
                  v121 = *(_QWORD *)(*((_QWORD *)v3 + 435) + 16) + 4 * *((unsigned int *)v3 + 127);
                  inInputBufferLists.mSampleTime = *(Float64 *)(*((_QWORD *)v3 + 435) + 16);
                  inInputBufferLists.mHostTime = v121;
                  if (*((_QWORD *)v3 + 2097))
                  {
                    VPTimeFreqConverter::Analyze(*((VPTimeFreqConverter **)v3 + 2097), *(const float **)(*((_QWORD *)v3 + 424) + 16), (DSPSplitComplex *)&inInputBufferLists);
                    v120 = *((float *)v3 + 1055);
                    Parameter = *((_QWORD *)v3 + 390);
                  }
                }
                AudioUnitSetParameter((AudioUnit)Parameter, 6u, 0, 0, v120, 0);
                AudioUnitSetParameter(*((AudioUnit *)v3 + 390), 7u, 0, 0, *((AudioUnitParameterValue *)v3 + 1059), 0);
                AudioUnitSetParameter(*((AudioUnit *)v3 + 390), 0xDu, 0, 0, *((AudioUnitParameterValue *)v3 + 1063), 0);
                memcpy(*(void **)(*((_QWORD *)v3 + 433) + 16), *(const void **)(*((_QWORD *)v3 + 504) + 32), *((unsigned int *)v3 + 1071));
                v122 = *((_QWORD *)v3 + 433);
                v311.mSampleTime = *((Float64 *)v3 + 505);
                v311.mHostTime = v122;
                v311.mRateScalar = *((Float64 *)v3 + 511);
                memset(&v311.mWordClockTime, 0, 24);
                *(_QWORD *)&v314.mNumberBuffers = *((_QWORD *)v3 + 431);
                *(_QWORD *)&v314.mBuffers[0].mNumberChannels = 0;
                v314.mBuffers[0].mData = (void *)*((_QWORD *)v3 + 500);
                v123 = *(_OWORD *)&a2->mRateScalar;
                *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                *(_OWORD *)&inInputBufferLists.mRateScalar = v123;
                v124 = *(_OWORD *)&a2->mSMPTETime.mHours;
                *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v124;
                v301 = 512;
                Parameter = AudioUnitProcessMultiple(*((AudioUnit *)v3 + 390), &v301, &inInputBufferLists, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)&v311, 3u, (AudioBufferList **)&v314);
                v125 = *((unsigned int *)v3 + 127);
                if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                {
                  Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x25u, v125, *((const AudioBufferList **)v3 + 431), &inInputBufferLists);
                  v125 = *((unsigned int *)v3 + 127);
                  v126 = (const AudioBufferList *)*((_QWORD *)v3 + 500);
                  if (*((_BYTE *)v3 + 15897))
                    goto LABEL_292;
                }
                else
                {
                  v126 = (const AudioBufferList *)*((_QWORD *)v3 + 500);
                }
                if (!*((_BYTE *)v3 + 15898))
                {
LABEL_293:
                  v118 = *((_QWORD *)v3 + 582);
                  goto LABEL_294;
                }
LABEL_292:
                Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x50u, v125, v126, &inInputBufferLists);
                goto LABEL_293;
              }
LABEL_639:
              std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
            }
          }
          else
          {
            v93 = (const AudioBufferList *)*((_QWORD *)v3 + 421);
          }
          if (!*((_BYTE *)v3 + 15898))
            goto LABEL_217;
          goto LABEL_216;
        }
        v83 = *((_QWORD *)v3 + 2098);
        if ((unint64_t)(*((_QWORD *)v3 + 2099) - v83) <= 0x20)
          goto LABEL_639;
        ECApplicator::apply(*(AudioUnitParameterID **)(v83 + 32), &buf, v291, &v299, (float *)v3 + 1047, (float *)v3 + 1051, (float *)v3 + 1055, (float *)v3 + 1059, (float *)v3 + 1063, (float *)v3 + 1067);
        v84 = *((unsigned int *)v3 + 127);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
        {
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x21u, v84, *((const AudioBufferList **)v3 + 136), &buf);
          v84 = *((unsigned int *)v3 + 127);
          v85 = (const AudioBufferList *)*((_QWORD *)v3 + 422);
          if (*((_BYTE *)v3 + 15897))
            goto LABEL_188;
        }
        else
        {
          v85 = (const AudioBufferList *)*((_QWORD *)v3 + 422);
        }
        if (!*((_BYTE *)v3 + 15898))
        {
LABEL_189:
          v86 = *((_QWORD *)v3 + 507);
          inInputBufferLists.mSampleTime = *(Float64 *)(v86 + 16);
          inInputBufferLists.mHostTime = *(_QWORD *)&inInputBufferLists.mSampleTime + 4 * v84;
          v87 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 2130);
          if (v87)
          {
            VPTimeFreqConverter::Analyze(v87, *(const float **)(*((_QWORD *)v3 + 422) + 16), (DSPSplitComplex *)&inInputBufferLists);
            v84 = *((unsigned int *)v3 + 127);
            v86 = *((_QWORD *)v3 + 507);
          }
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x16u, v84, (const AudioBufferList *)v86, &buf);
          v82 = *((_QWORD *)v3 + 582);
          goto LABEL_195;
        }
LABEL_188:
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x10u, v84, v85, &buf);
        v84 = *((unsigned int *)v3 + 127);
        goto LABEL_189;
      }
      v50 = *((_DWORD *)v3 + 3098);
      if (v49 != 3)
      {
        if (v50 == 2)
        {
          v51 = 0;
          *((_OWORD *)v3 + 1054) = *(_OWORD *)(v48 + 40);
          *(_OWORD *)((char *)v3 + 16888) = *(_OWORD *)(v48 + 56);
          v52 = 1;
          v53 = 3;
          v54 = 2;
LABEL_114:
          v55 = v48 + 8;
          *((_OWORD *)v3 + 1051) = *(_OWORD *)(v55 + 16 * v51);
          *(_OWORD *)((char *)v3 + 16840) = *(_OWORD *)(v55 + 16 * v52);
          goto LABEL_115;
        }
        v50 = *((_DWORD *)v3 + 3098);
        if (v50 <= 0xC && ((0x1028u >> v50) & 1) != 0)
        {
          v51 = 0;
          *((_OWORD *)v3 + 1054) = *(_OWORD *)(v48 + 24);
          *(_OWORD *)((char *)v3 + 16888) = *(_OWORD *)(v48 + 40);
          v52 = 3;
          v53 = 2;
          v54 = 1;
          goto LABEL_114;
        }
      }
      if (v50 == 9)
      {
        v51 = 0;
        *((_OWORD *)v3 + 1054) = *(_OWORD *)(v48 + 56);
        *(_OWORD *)((char *)v3 + 16888) = *(_OWORD *)(v48 + 40);
        v52 = 1;
        v53 = 2;
        v54 = 3;
      }
      else
      {
        v54 = 0;
        v53 = 0;
        v51 = 1;
        v52 = 2;
      }
      goto LABEL_114;
    }
  }
  v12 = 0;
  while (((*((_DWORD *)v3 + 116) >> v12) & 1) == 0)
  {
    if (++v12 == 32)
    {
      v12 = 33;
      break;
    }
  }
  v13 = (unsigned int *)*((_QWORD *)v3 + 135);
  if (v12 >= *v13)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v16 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v17 = (*v16 ? *v16 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v18 = **((_DWORD **)v3 + 135);
        LODWORD(buf.mSampleTime) = 136315906;
        *(_QWORD *)((char *)&buf.mSampleTime + 4) = "vpProcessUplink_v5.cpp";
        WORD2(buf.mHostTime) = 1024;
        *(_DWORD *)((char *)&buf.mHostTime + 6) = 101;
        WORD1(buf.mRateScalar) = 1024;
        HIDWORD(buf.mRateScalar) = v12;
        LOWORD(buf.mWordClockTime) = 1024;
        *(_DWORD *)((char *)&buf.mWordClockTime + 2) = v18;
        _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", (uint8_t *)&buf, 0x1Eu);
      }
    }
    v19 = (int *)*((_QWORD *)v3 + 1570);
    if (v19 && (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      CALegacyLog::log(v19, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v5/vpProcessUplink_v5.cpp", 101, "ProcessDSPChain_Uplink", "ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", v12, **((_DWORD **)v3 + 135));
    }
    v14 = *(void **)(*((_QWORD *)v3 + 136) + 16);
    v15 = (const void **)*((_QWORD *)v3 + 135);
  }
  else
  {
    v14 = *(void **)(*((_QWORD *)v3 + 136) + 16);
    v15 = (const void **)&v13[4 * v12];
  }
  memcpy(v14, v15[2], *((unsigned int *)v15 + 3));
  if (*((_BYTE *)v3 + 2085))
  {
    if ((*((_BYTE *)v3 + 4662) & 0x20) != 0 && (*((_BYTE *)v3 + 4678) & 0x20) != 0)
    {
      v20 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 400);
      if (v20)
      {
        v21 = *((_QWORD *)v3 + 499);
        inInputBufferLists.mSampleTime = *((Float64 *)v3 + 136);
        inInputBufferLists.mHostTime = v21;
        v22 = *((_QWORD *)v3 + 501);
        v311.mSampleTime = inInputBufferLists.mSampleTime;
        v311.mHostTime = v22;
        v23 = *(_OWORD *)&a2->mRateScalar;
        *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
        *(_OWORD *)&buf.mRateScalar = v23;
        v24 = *(_OWORD *)&a2->mSMPTETime.mHours;
        *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
        *(_OWORD *)&buf.mSMPTETime.mHours = v24;
        v314.mNumberBuffers = 512;
        AudioUnitProcessMultiple(v20, &v314.mNumberBuffers, &buf, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&inInputBufferLists, 2u, (AudioBufferList **)&v311);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x27u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), &buf);
        if ((*((_BYTE *)v3 + 4664) & 2) != 0 && (*((_BYTE *)v3 + 4680) & 2) != 0 && *((_QWORD *)v3 + 412))
        {
          AudioUnitGetParameter(*((AudioUnit *)v3 + 400), 1u, 0, 0, &v302);
          AudioUnitSetParameter(*((AudioUnit *)v3 + 412), 0x23u, 0, 0, v302, 0);
        }
      }
    }
  }
LABEL_567:
  v314.mNumberBuffers = 0;
  v254 = VoiceProcessorV2::LocalVoiceDuckingForMediaChatEnabled(v3);
  v256 = v254;
  if (!*((_BYTE *)v3 + 2080))
  {
    if ((v254 & 1) == 0)
      goto LABEL_588;
    VoiceProcessorV2::DetectVoiceActivity(v3, a2, v255);
LABEL_576:
    v258 = *((_QWORD *)v3 + 582);
    if ((v258 & 0x2000000000000000) != 0
      && (*((_BYTE *)v3 + 4679) & 0x20) != 0
      && (v259 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 408)) != 0)
    {
      v260 = 1936748646;
    }
    else
    {
      if ((v258 & 0x1000000000000000) == 0
        || (*((_BYTE *)v3 + 4679) & 0x10) == 0
        || (v259 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 407)) == 0)
      {
        *(AudioUnitParameterValue *)&v314.mNumberBuffers = v302;
        goto LABEL_586;
      }
      v260 = 2;
    }
    AudioUnitGetParameter(v259, v260, 0, 0, (AudioUnitParameterValue *)&v314.mNumberBuffers);
    goto LABEL_586;
  }
  if (*((_QWORD *)v3 + 2054))
    v257 = 1;
  else
    v257 = v254;
  if ((v257 & 1) != 0)
  {
    VoiceProcessorV2::DetectVoiceActivity(v3, a2, v255);
    if ((v256 & 1) != 0)
      goto LABEL_576;
  }
LABEL_586:
  if (*((_BYTE *)v3 + 2080))
  {
    bzero(*(void **)(*((_QWORD *)v3 + 136) + 16), 4 * *((unsigned int *)v3 + 127));
    v314.mNumberBuffers = 0;
    goto LABEL_589;
  }
LABEL_588:
  *((_DWORD *)v3 + 4110) = 0;
LABEL_589:
  if ((*((_BYTE *)v3 + 8833) & 0x80) != 0 && (*((_BYTE *)v3 + 8841) & 0x80) != 0)
  {
    v261 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 452);
    v262 = v261 ? v256 : 0;
    if (v262 == 1)
      AudioUnitSetParameter(v261, 0x12u, 0, 0, *(AudioUnitParameterValue *)&v314.mNumberBuffers, 0);
  }
  if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Au, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
  if (*((_BYTE *)v3 + 2085))
  {
    if ((*((_BYTE *)v3 + 4664) & 0x40) != 0 && (*((_BYTE *)v3 + 4680) & 0x40) != 0)
    {
      v263 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 417);
      if (v263)
      {
        inInputBufferLists.mSampleTime = *((Float64 *)v3 + 136);
        v311.mSampleTime = inInputBufferLists.mSampleTime;
        LODWORD(v295.realp) = 512;
        v264 = *(_OWORD *)&a2->mRateScalar;
        *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
        *(_OWORD *)&buf.mRateScalar = v264;
        v265 = *(_OWORD *)&a2->mSMPTETime.mHours;
        *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
        *(_OWORD *)&buf.mSMPTETime.mHours = v265;
        AudioUnitProcessMultiple(v263, (AudioUnitRenderActionFlags *)&v295, &buf, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)&inInputBufferLists, 1u, (AudioBufferList **)&v311);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x7Cu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), &buf);
      }
    }
  }
  if ((*((_QWORD *)v3 + 582) & 0x8000000000000000) != 0 && (*((_QWORD *)v3 + 584) & 0x8000000000000000) != 0)
  {
    v266 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 410);
    if (v266)
    {
      v267 = *(_OWORD *)&a2->mRateScalar;
      *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
      *(_OWORD *)&buf.mRateScalar = v267;
      v268 = *(_OWORD *)&a2->mSMPTETime.mHours;
      *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
      *(_OWORD *)&buf.mSMPTETime.mHours = v268;
      LODWORD(inInputBufferLists.mSampleTime) = 512;
      AudioUnitProcess(v266, (AudioUnitRenderActionFlags *)&inInputBufferLists, &buf, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
      if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Cu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), &buf);
    }
  }
  v269 = *((_QWORD *)v3 + 583);
  if ((v269 & 1) != 0 && (*((_BYTE *)v3 + 4680) & 1) != 0)
  {
    v270 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 411);
    if (v270)
    {
      v271 = *(_OWORD *)&a2->mRateScalar;
      *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
      *(_OWORD *)&buf.mRateScalar = v271;
      v272 = *(_OWORD *)&a2->mSMPTETime.mHours;
      *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
      *(_OWORD *)&buf.mSMPTETime.mHours = v272;
      LODWORD(inInputBufferLists.mSampleTime) = 512;
      AudioUnitProcess(v270, (AudioUnitRenderActionFlags *)&inInputBufferLists, &buf, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
      v269 = *((_QWORD *)v3 + 583);
    }
  }
  if ((v269 & 2) != 0
    && (*((_BYTE *)v3 + 4680) & 2) != 0
    && (v273 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 412)) != 0)
  {
    v274 = *(_OWORD *)&a2->mRateScalar;
    *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
    *(_OWORD *)&buf.mRateScalar = v274;
    v275 = *(_OWORD *)&a2->mSMPTETime.mHours;
    *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
    *(_OWORD *)&buf.mSMPTETime.mHours = v275;
    LODWORD(inInputBufferLists.mSampleTime) = 512;
    AudioUnitProcess(v273, (AudioUnitRenderActionFlags *)&inInputBufferLists, &buf, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Du, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), &buf);
    if ((*((_BYTE *)v3 + 4663) & 0x10) != 0 && (*((_BYTE *)v3 + 4679) & 0x10) != 0 && *((_QWORD *)v3 + 407))
    {
      LODWORD(v311.mSampleTime) = 0;
      AudioUnitGetParameter(*((AudioUnit *)v3 + 412), 1u, 0, 0, (AudioUnitParameterValue *)&v311);
      AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 0x11u, 0, 0, *(AudioUnitParameterValue *)&v311.mSampleTime, 0);
    }
    LODWORD(v311.mSampleTime) = 0;
    AudioUnitGetParameter(*((AudioUnit *)v3 + 412), 0x1Bu, 0, 0, (AudioUnitParameterValue *)&v311);
    mSampleTime_low = LODWORD(v311.mSampleTime);
    if (*((float *)v3 + 572) != *(float *)&v311.mSampleTime)
    {
      if ((*((_BYTE *)v3 + 4663) & 0x10) != 0 && (*((_BYTE *)v3 + 4679) & 0x10) != 0)
      {
        v277 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 407);
        if (v277)
        {
          AudioUnitSetParameter(v277, 0x12u, 0, 0, *(AudioUnitParameterValue *)&v311.mSampleTime, 0);
          mSampleTime_low = LODWORD(v311.mSampleTime);
        }
      }
      *((_DWORD *)v3 + 572) = mSampleTime_low;
    }
  }
  else if ((*((_BYTE *)v3 + 4663) & 0x40) != 0 && ((*((_BYTE *)v3 + 4679) & 0x40) != 0 || *((_BYTE *)v3 + 472)))
  {
    LODWORD(buf.mSampleTime) = __exp10f(*((float *)v3 + 1091) / 20.0);
    vDSP_vsmul(*(const float **)(*((_QWORD *)v3 + 136) + 16), 1, (const float *)&buf, *(float **)(*((_QWORD *)v3 + 136) + 16), 1, *((unsigned int *)v3 + 127));
    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Bu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
  }
  return 0;
}

void AUCrossCorrelator::~AUCrossCorrelator(AUCrossCorrelator *this)
{
  AUCrossCorrelator::~AUCrossCorrelator(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;
  _QWORD *v3;
  void *v4;
  void *v5;
  _QWORD *v6;
  void **v7;

  *(_QWORD *)this = &off_1E69E88A8;
  v2 = *((_QWORD *)this + 111);
  *((_QWORD *)this + 111) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v7 = (void **)((char *)this + 848);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v7);
  v3 = (_QWORD *)*((_QWORD *)this + 103);
  *((_QWORD *)this + 103) = 0;
  if (v3)
    std::default_delete<CADeprecated::CABufferList>::operator()[abi:ne180100](v3);
  CrossCorrelator::~CrossCorrelator((AUCrossCorrelator *)((char *)this + 744));
  v4 = (void *)*((_QWORD *)this + 78);
  if (v4)
  {
    *((_QWORD *)this + 79) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 75);
  if (v5)
  {
    *((_QWORD *)this + 76) = v5;
    operator delete(v5);
  }
  v6 = (_QWORD *)*((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = 0;
  if (v6)
    std::default_delete<CADeprecated::CABufferList>::operator()[abi:ne180100](v6);
  ausdk::AUBase::~AUBase(this);
}

unint64_t AUCrossCorrelator::CreateExtendedElements(int64x2_t *this)
{
  unint64_t i;
  uint64_t v3;
  unint64_t result;
  std::string *v5;
  __int128 v6;
  void **v7;
  CFIndex v8;
  CFStringRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  std::runtime_error *exception;
  std::string v16;
  void *__p[2];
  int64_t v18;
  CFTypeRef cf;

  ausdk::AUScope::Initialize(this + 52, (ausdk::AUBase *)this, 4, 8);
  for (i = 0; ; ++i)
  {
    v3 = this[54].i64[1];
    result = v3
           ? (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3)
           : (unint64_t)(this[53].i64[1] - this[53].i64[0]) >> 3;
    if (i >= result)
      break;
    std::to_string(&v16, i);
    v5 = std::string::insert(&v16, 0, "Channel", 7uLL);
    v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v18 = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    if (v18 >= 0)
      v7 = __p;
    else
      v7 = (void **)__p[0];
    if (v18 >= 0)
      v8 = HIBYTE(v18);
    else
      v8 = (CFIndex)__p[1];
    v9 = CFStringCreateWithBytes(0, (const UInt8 *)v7, v8, 0x8000100u, 0);
    cf = v9;
    if (!v9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    if (SHIBYTE(v18) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v16.__r_.__value_.__l.__data_);
    v10 = this[54].i64[1];
    if (v10)
    {
      v11 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v10 + 32))(v10, i);
    }
    else
    {
      v12 = this[53].i64[0];
      if (i >= (this[53].i64[1] - v12) >> 3)
        v11 = 0;
      else
        v11 = *(_QWORD *)(v12 + 8 * i);
    }
    ausdk::Owned<__CFString const*>::operator=((const void **)(v11 + 72), v9);
    v13 = this[54].i64[1];
    if (v13)
      v14 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v13 + 32))(v13, i);
    else
      v14 = *(_QWORD *)(this[53].i64[0] + 8 * i);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 40))(v14, 4);
    if (cf)
      CFRelease(cf);
  }
  return result;
}

void sub_1B652FE90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t AUCrossCorrelator::Initialize(AUCrossCorrelator *this)
{
  uint64_t Element;
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  const AudioStreamBasicDescription *v6;
  _BOOL4 IsEquivalent;
  uint64_t result;
  float v9;
  uint64_t v10;
  const void *v11;
  unint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  long double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  DSPComplex *v28;
  DSPComplex *v29;
  DSPComplex *v30;
  float *p_imag;
  float v33;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  _BYTE *v40;
  uint64_t v41;
  void *v42;
  _BYTE *v43;
  uint64_t v44;
  AudioStreamBasicDescription v45;
  char *v46[2];
  CAStreamBasicDescription *v47[2];
  uint64_t v48;
  _OWORD v49[2];
  void *v50;
  _BYTE *v51;
  void *v52;
  _BYTE *v53;
  void *v54;
  _BYTE *v55;
  void *__p[2];
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  int v60;

  Element = ausdk::AUScope::SafeGetElement((AUCrossCorrelator *)((char *)this + 80), 0);
  v3 = *(_OWORD *)(Element + 96);
  *(_OWORD *)v46 = *(_OWORD *)(Element + 80);
  *(_OWORD *)v47 = v3;
  v48 = *(_QWORD *)(Element + 112);
  v4 = ausdk::AUScope::SafeGetElement((AUCrossCorrelator *)((char *)this + 128), 0);
  v5 = *(_OWORD *)(v4 + 96);
  *(_OWORD *)&v45.mSampleRate = *(_OWORD *)(v4 + 80);
  *(_OWORD *)&v45.mBytesPerPacket = v5;
  *(_QWORD *)&v45.mBitsPerChannel = *(_QWORD *)(v4 + 112);
  IsEquivalent = CAStreamBasicDescription::IsEquivalent((CAStreamBasicDescription *)v46, &v45, v6);
  result = 4294956428;
  if (IsEquivalent && HIDWORD(v47[1]) <= 8)
  {
    v9 = *((float *)this + 133);
    if (v9 == 0.0 || *(double *)v46 == v9)
    {
      v10 = *((_QWORD *)this + 73);
      if (v10)
      {
        v11 = *(const void **)(v10 + 40);
        v12 = *((unsigned int *)this + 148);
        v43 = 0;
        v44 = 0;
        v42 = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v42, v11, (uint64_t)v11 + 4 * v12, v12);
        v39 = 0;
        v40 = 0;
        v41 = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v39, v42, (uint64_t)v43, (v43 - (_BYTE *)v42) >> 2);
        v13 = v40 - (_BYTE *)v39;
        v14 = log2((double)(unint64_t)((v40 - (_BYTE *)v39) >> 2));
        v15 = ceil(v14);
        if (v15 != floor(v14))
        {
          v16 = exp2(v15);
          LODWORD(v49[0]) = 0;
          std::vector<float>::resize((uint64_t)&v39, (unint64_t)v16, v49);
          v13 = v40 - (_BYTE *)v39;
        }
        FreqDomainConvolver::FreqDomainConvolver((FreqDomainConvolver *)v49, v13 >> 1);
        v17 = operator new();
        *(_OWORD *)v17 = v49[0];
        v49[0] = 0uLL;
        std::valarray<float>::valarray((_QWORD *)(v17 + 32), (int **)&v50);
        v18 = *(_QWORD *)(v17 + 32);
        v19 = v18 + 4 * ((*(_QWORD *)(v17 + 40) - v18) >> 3);
        *(_QWORD *)(v17 + 16) = v18;
        *(_QWORD *)(v17 + 24) = v19;
        std::valarray<float>::valarray((_QWORD *)(v17 + 64), (int **)&v52);
        v20 = *(_QWORD *)(v17 + 64);
        v21 = v20 + 4 * ((*(_QWORD *)(v17 + 72) - v20) >> 3);
        *(_QWORD *)(v17 + 48) = v20;
        *(_QWORD *)(v17 + 56) = v21;
        std::valarray<float>::valarray((_QWORD *)(v17 + 96), (int **)&v54);
        v22 = *(_QWORD *)(v17 + 96);
        v23 = v22 + 4 * ((*(_QWORD *)(v17 + 104) - v22) >> 3);
        *(_QWORD *)(v17 + 80) = v22;
        *(_QWORD *)(v17 + 88) = v23;
        *(_OWORD *)(v17 + 112) = *(_OWORD *)__p;
        *(_QWORD *)(v17 + 128) = v57;
        __p[0] = 0;
        __p[1] = 0;
        *(_OWORD *)(v17 + 136) = v58;
        *(_QWORD *)(v17 + 152) = v59;
        v57 = 0;
        v58 = 0uLL;
        v59 = 0;
        *(_DWORD *)(v17 + 160) = v60;
        v24 = (_QWORD *)*((_QWORD *)this + 101);
        *((_QWORD *)this + 101) = v17;
        if (v24)
          std::default_delete<FreqDomainConvolver>::operator()[abi:ne180100](v24);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if (v54)
        {
          if (v55 != v54)
            v55 += ((_BYTE *)v54 - v55 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          operator delete(v54);
          v54 = 0;
          v55 = 0;
        }
        if (v52)
        {
          if (v53 != v52)
            v53 += ((_BYTE *)v52 - v53 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          operator delete(v52);
          v52 = 0;
          v53 = 0;
        }
        if (v50)
        {
          if (v51 != v50)
            v51 += ((_BYTE *)v50 - v51 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          operator delete(v50);
          v50 = 0;
          v51 = 0;
        }
        v25 = (std::__shared_weak_count *)*((_QWORD *)&v49[0] + 1);
        if (*((_QWORD *)&v49[0] + 1))
        {
          v26 = (unint64_t *)(*((_QWORD *)&v49[0] + 1) + 8);
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
        if ((void **)((char *)this + 760) != &v39)
          std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 760, (char *)v39, (uint64_t)v40, (v40 - (_BYTE *)v39) >> 2);
        v28 = (DSPComplex *)*((_QWORD *)this + 95);
        v29 = (DSPComplex *)*((_QWORD *)this + 96);
        v30 = (DSPComplex *)((char *)v29 - 4);
        if (v28 != v29 && v30 > v28)
        {
          p_imag = &v28->imag;
          do
          {
            v33 = *(p_imag - 1);
            *(p_imag - 1) = v30->real;
            v30->real = v33;
            v30 = (DSPComplex *)((char *)v30 - 4);
          }
          while (p_imag++ < (float *)v30);
        }
        FreqDomainConvolver::Initialize(*((DSPSplitComplex **)this + 101), v28, ((char *)v29 - (char *)v28) >> 2);
        if (*((_BYTE *)this + 744))
          vDSP_svesq(*((const float **)this + 95), 1, (float *)this + 187, (uint64_t)(*((_QWORD *)this + 96) - *((_QWORD *)this + 95)) >> 2);
        std::vector<float>::resize((uint64_t)this + 784, (uint64_t)(*((_QWORD *)this + 96) - *((_QWORD *)this + 95)) >> 1);
        if (v39)
        {
          v40 = v39;
          operator delete(v39);
        }
        FreqDomainConvolver::Reset(*((FreqDomainConvolver **)this + 101));
        std::vector<float>::resize((uint64_t)this + 600, *((unsigned int *)this + 204));
        std::vector<float>::resize((uint64_t)this + 624, (int)(*((_DWORD *)this + 204) + ((*((_QWORD *)this + 96) - *((_QWORD *)this + 95)) >> 2) - 1));
        v35 = CADeprecated::CABufferList::New((CADeprecated::CABufferList *)"", (const char *)HIDWORD(v46[1]), (const CAStreamBasicDescription *)HIDWORD(v47[1]));
        v36 = (_QWORD *)*((_QWORD *)this + 103);
        *((_QWORD *)this + 103) = v35;
        if (v36)
        {
          std::default_delete<CADeprecated::CABufferList>::operator()[abi:ne180100](v36);
          v35 = (_QWORD *)*((_QWORD *)this + 103);
        }
        CADeprecated::CABufferList::AllocateBuffers((uint64_t)v35, 4 * *((_DWORD *)this + 204));
        v37 = operator new();
        *(_QWORD *)v37 = &off_1E69EE198;
        *(_OWORD *)(v37 + 8) = 0u;
        *(_OWORD *)(v37 + 24) = 0u;
        *(_OWORD *)(v37 + 40) = 0u;
        *(_OWORD *)(v37 + 56) = 0u;
        *(_OWORD *)(v37 + 72) = 0u;
        *(_OWORD *)(v37 + 88) = 0u;
        *(_OWORD *)(v37 + 100) = 0u;
        bzero((void *)(v37 + 120), 0x314uLL);
        *(_WORD *)(v37 + 908) = 1;
        v38 = *((_QWORD *)this + 111);
        *((_QWORD *)this + 111) = v37;
        if (v38)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v38 + 8))(v38);
          v37 = *((_QWORD *)this + 111);
        }
        CADeprecated::AudioRingBuffer::Allocate((CADeprecated::AudioRingBuffer *)v37, (const CAStreamBasicDescription *)v46, *((_DWORD *)this + 84) + ((*((_QWORD *)this + 96) - *((_QWORD *)this + 95)) >> 2) - 1);
        if (v42)
        {
          v43 = v42;
          operator delete(v42);
        }
      }
      return 0;
    }
  }
  return result;
}

void sub_1B65303E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t AUCrossCorrelator::Reset(AUCrossCorrelator *this)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v3;

  v1 = *((_QWORD *)this + 111);
  if (v1)
  {
    for (i = 0; i != 768; i += 24)
    {
      v3 = v1 + i;
      *(_QWORD *)(v3 + 136) = 0;
      *(_QWORD *)(v3 + 144) = 0;
      *(_DWORD *)(v3 + 152) = 0;
    }
    *(_DWORD *)(v1 + 904) = 0;
    *(_BYTE *)(v1 + 908) = 1;
    *((_OWORD *)this + 56) = 0u;
  }
  return 0;
}

uint64_t AUCrossCorrelator::GetPropertyInfo(AUCrossCorrelator *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  unsigned int v7;

  if (a3)
    return 4294956417;
  v7 = 4;
  if ((a2 - 64102) >= 2 && a2 != 21)
  {
    if (a2 != 64101)
      return 4294956417;
    v7 = 8;
  }
  result = 0;
  *a6 = 1;
  *a5 = v7;
  return result;
}

uint64_t AUCrossCorrelator::GetProperty(AUCrossCorrelator *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  int v7;

  if (a3)
    return 4294956417;
  if (a2 > 64101)
  {
    if (a2 == 64102)
    {
      result = 0;
      v7 = *((_DWORD *)this + 220);
    }
    else
    {
      if (a2 != 64103)
        return 4294956417;
      result = 0;
      v7 = *((_DWORD *)this + 204);
    }
  }
  else
  {
    if (a2 != 21)
    {
      if (a2 == 64101)
        return 0;
      return 4294956417;
    }
    result = 0;
    v7 = *((unsigned __int8 *)this + 528);
  }
  *a5 = v7;
  return result;
}

uint64_t AUCrossCorrelator::SetProperty(AUCrossCorrelator *this, int a2, int a3, unsigned int a4, unsigned int *a5)
{
  uint64_t result;
  float v8;
  __int128 v9;
  __int128 v10;
  _QWORD *v11;
  _QWORD *v12;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 64101)
  {
    if (a2 == 64102)
    {
      result = 0;
      *((_DWORD *)this + 220) = *a5;
    }
    else if (a2 == 64103)
    {
      result = 0;
      *((_DWORD *)this + 204) = *a5;
    }
  }
  else if (a2 == 21)
  {
    result = 0;
    *((_BYTE *)this + 528) = *a5 != 0;
  }
  else if (a2 == 64101)
  {
    v8 = *(double *)a5;
    *((float *)this + 133) = v8;
    v9 = *(_OWORD *)a5;
    v10 = *((_OWORD *)a5 + 1);
    *((_QWORD *)this + 72) = *((_QWORD *)a5 + 4);
    *((_OWORD *)this + 34) = v9;
    *((_OWORD *)this + 35) = v10;
    *((_DWORD *)this + 148) = *(_DWORD *)(*((_QWORD *)a5 + 5) + 12) >> 2;
    v11 = CADeprecated::CABufferList::New((CADeprecated::CABufferList *)"", (const char *)a5[3], (const CAStreamBasicDescription *)a5[7]);
    v12 = (_QWORD *)*((_QWORD *)this + 73);
    *((_QWORD *)this + 73) = v11;
    if (v12)
    {
      std::default_delete<CADeprecated::CABufferList>::operator()[abi:ne180100](v12);
      v11 = (_QWORD *)*((_QWORD *)this + 73);
    }
    CADeprecated::CABufferList::AllocateBuffers((uint64_t)v11, 4 * *((_DWORD *)this + 148));
    CADeprecated::CABufferList::CopyDataFrom(*((void **)this + 73), *((const AudioBufferList **)a5 + 5));
    return 0;
  }
  return result;
}

uint64_t AUCrossCorrelator::SetParameter(AUCrossCorrelator *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  uint64_t result;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  if (a3 != 4)
    return 4294956430;
  if (a2 != 2)
    return 4294956418;
  result = 0;
  *((float *)this + a4 + 170) = a5;
  return result;
}

uint64_t AUCrossCorrelator::CanScheduleParameters(AUCrossCorrelator *this)
{
  return 0;
}

uint64_t AUCrossCorrelator::ProcessBufferLists(AUCrossCorrelator *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, unsigned int a5)
{
  unint64_t mNumberBuffers;
  uint64_t v10;
  unint64_t v11;
  size_t mDataByteSize;
  void *mData;
  void *v14;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  AudioBufferList *v20;
  unint64_t j;
  DSPSplitComplex *v22;
  float *v23;
  uint64_t v24;
  unint64_t v25;
  _BYTE *v26;
  _BYTE *v27;
  float v28;
  float *v29;
  float *v30;
  float *v31;
  float v32;
  double v33;
  BOOL v34;
  double v35;
  float v36;
  float *v37;
  char *v38;
  float v39;
  float *v40;
  float v41;
  float v42;
  float v43;
  unint64_t v44;
  unint64_t i;
  __n128 v46;
  float *v47;
  uint64_t v48;

  mNumberBuffers = a3->mNumberBuffers;
  if (mNumberBuffers != a4->mNumberBuffers)
    __assert_rtn("CopyBufferList", "AUCrossCorrelator.cpp", 16, "srcBufferList.mNumberBuffers == dstBufferList.mNumberBuffers");
  if (a3->mNumberBuffers)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      mDataByteSize = a3->mBuffers[v10].mDataByteSize;
      if ((_DWORD)mDataByteSize == a4->mBuffers[v10].mDataByteSize)
      {
        mData = a3->mBuffers[v10].mData;
        v14 = a4->mBuffers[v10].mData;
        if (mData != v14)
        {
          memcpy(v14, mData, mDataByteSize);
          mNumberBuffers = a3->mNumberBuffers;
        }
      }
      ++v11;
      ++v10;
    }
    while (v11 < mNumberBuffers);
  }
  if (*((_DWORD *)this + 84) < a5)
    return 4294956422;
  *((_QWORD *)this + 67) = 0;
  v16 = (char *)this + 648;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 712) = 0u;
  *(_OWORD *)((char *)this + 728) = 0u;
  if (*((_QWORD *)this + 73) && !*((_BYTE *)this + 528))
  {
    if (CADeprecated::AudioRingBuffer::Store(*((CADeprecated::AudioRingBuffer **)this + 111), a3, a5, *((_QWORD *)this + 113)))__assert_rtn("ProcessBufferLists", "AUCrossCorrelator.cpp", 418, "mAudioRingBuffer->Store(&inBufferList, inFramesToProcess, mAudioRingBufferWriteIdx) == kAudioRingBufferError_OK");
    v17 = *((_QWORD *)this + 112);
    v18 = *((unsigned int *)this + 204);
    v19 = *((_QWORD *)this + 113) + a5;
    if (v17 + v18 > v19)
    {
LABEL_45:
      v44 = 0;
      *((_QWORD *)this + 113) = v19;
      while (v44 < *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUCrossCorrelator *)((char *)this + 80), 0) + 108))
      {
        if (*((float *)this + v44 + 162) >= *((float *)this + v44 + 170))
          *((_BYTE *)this + v44 + 536) = 1;
        ++v44;
      }
      for (i = 0;
            i < *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUCrossCorrelator *)((char *)this + 80), 0) + 108);
            ++i)
      {
        if (*((_BYTE *)this + i + 536))
          v46.n128_f32[0] = 1.0;
        else
          v46.n128_f32[0] = 0.0;
        (*(void (**)(AUCrossCorrelator *, uint64_t, uint64_t, unint64_t, _QWORD, __n128))(*(_QWORD *)this + 152))(this, 3, 4, i, 0, v46);
        v47 = (float *)((char *)this + 4 * i);
        (*(void (**)(AUCrossCorrelator *, _QWORD, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 0, 4, i, 0, v47[162]);
        (*(void (**)(AUCrossCorrelator *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 1, 4, i, 0, v47[178]);
      }
      return 0;
    }
    v48 = a5;
LABEL_16:
    v20 = (AudioBufferList *)*((_QWORD *)this + 103);
    if (CADeprecated::AudioRingBuffer::Fetch(*((const void ****)this + 111), v20 + 1, v18, v17))
      __assert_rtn("ProcessBufferLists", "AUCrossCorrelator.cpp", 425, "mAudioRingBuffer->Fetch(&readABL, mCrossCorrelationInputSize, mAudioRingBufferReadIdx) == kAudioRingBufferError_OK");
    for (j = 0; ; ++j)
    {
      if (j >= *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUCrossCorrelator *)((char *)this + 80), 0) + 108))
      {
        v17 = *((_QWORD *)this + 112) + *((unsigned int *)this + 220);
        *((_QWORD *)this + 112) = v17;
        v18 = *((unsigned int *)this + 204);
        v19 = *((_QWORD *)this + 113) + v48;
        if (v17 + v18 > v19)
          goto LABEL_45;
        goto LABEL_16;
      }
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 600, (char *)v20[1].mBuffers[j].mData, (uint64_t)v20[1].mBuffers[j].mData + 4 * *((unsigned int *)this + 204), *((unsigned int *)this + 204));
      v23 = (float *)*((_QWORD *)this + 78);
      v24 = *((_QWORD *)this + 79) - (_QWORD)v23;
      if (v24 >= 1)
        bzero(*((void **)this + 78), 4 * (((unint64_t)v24 >> 2) - ((unint64_t)v24 > 3)) + 4);
      v25 = v24 >> 2;
      v26 = (_BYTE *)*((_QWORD *)this + 76);
      v27 = (_BYTE *)*((_QWORD *)this + 75);
      if (v24 >> 2 < (unint64_t)(((v26 - v27) >> 2)
                                       + ((uint64_t)(*((_QWORD *)this + 96) - *((_QWORD *)this + 95)) >> 2)
                                       - 1))
        __assert_rtn("process", "CrossCorrelator.cpp", 78, "output.size() >= (input.size() + mFilter.size() - 1)");
      if (v26 != v27)
      {
        memmove(*((void **)this + 98), v27, v26 - v27);
        v23 = (float *)*((_QWORD *)this + 78);
        v25 = (uint64_t)(*((_QWORD *)this + 79) - (_QWORD)v23) >> 2;
      }
      FreqDomainConvolver::Process(*((DSPSplitComplex **)this + 101), *((const float **)this + 98), v23, v25, 0, v22);
      if (*((_BYTE *)this + 744))
      {
        vDSP_svesq(*((const float **)this + 75), 1, (float *)this + 188, (uint64_t)(*((_QWORD *)this + 76) - *((_QWORD *)this + 75)) >> 2);
        v28 = *((float *)this + 188);
        if (v28 < 0.000000001)
          v28 = 0.000000001;
        *((float *)this + 188) = v28;
        v29 = (float *)*((_QWORD *)this + 78);
        v30 = (float *)*((_QWORD *)this + 79);
        v31 = v29;
        if (v29 == v30)
        {
LABEL_40:
          v38 = (char *)v29;
          goto LABEL_41;
        }
        do
        {
          v32 = *((float *)this + 187) * *((float *)this + 188);
          v33 = fabs(sqrt(v32));
          v34 = v32 == -INFINITY;
          v35 = INFINITY;
          if (!v34)
            v35 = v33;
          v36 = *v31 / v35;
          *v31++ = v36;
        }
        while (v31 != v30);
      }
      else
      {
        v29 = (float *)*((_QWORD *)this + 78);
        v30 = (float *)*((_QWORD *)this + 79);
      }
      if (v29 == v30)
        goto LABEL_40;
      v37 = v29 + 1;
      v38 = (char *)v29;
      if (v29 + 1 != v30)
      {
        v39 = *v29;
        v38 = (char *)v29;
        v40 = v29 + 1;
        do
        {
          v41 = *v40++;
          v42 = v41;
          if (v39 < v41)
          {
            v39 = v42;
            v38 = (char *)v37;
          }
          v37 = v40;
        }
        while (v40 != v30);
      }
LABEL_41:
      v43 = *(float *)v38;
      if (*(float *)v38 >= *(float *)&v16[4 * j])
      {
        *((float *)this + j + 178) = (float)((float)((float)((float)((v38 - (char *)v29) >> 2)
                                                           - (float)(int)((*((_QWORD *)this + 96)
                                                                         - *((_QWORD *)this + 95)) >> 2))
                                                   + 1.0)
                                           + (float)*((uint64_t *)this + 112))
                                   - (float)*((uint64_t *)this + 113);
        *(float *)&v16[4 * j] = v43;
      }
    }
  }
  return 0;
}

uint64_t AUCrossCorrelator::Render(AUCrossCorrelator *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  uint64_t Element;
  uint64_t v10;
  ausdk::AUInputElement *v11;
  uint64_t result;
  uint64_t BufferList;
  uint64_t v14;

  v8 = (AUCrossCorrelator *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AUCrossCorrelator *)((char *)this + 80), 0);
  v10 = ausdk::AUScope::SafeGetElement((AUCrossCorrelator *)((char *)this + 128), 0);
  v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  result = ausdk::AUInputElement::PullInput(v11, a2, a3, 0, a4);
  if (!(_DWORD)result)
  {
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    v14 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    return (*(uint64_t (**)(AUCrossCorrelator *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 176))(this, a2, BufferList, v14, a4);
  }
  return result;
}

uint64_t AUCrossCorrelator::GetParameterList(AUCrossCorrelator *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;

  if (a2 != 4)
    return 4294956430;
  result = 0;
  if (a3)
  {
    *(_OWORD *)a3 = xmmword_1B6626920;
    *a4 = 4;
  }
  return result;
}

uint64_t AUCrossCorrelator::GetParameterInfo(AUCrossCorrelator *this, int a2, unsigned int a3, AudioUnitParameterInfo *a4)
{
  uint64_t *v7;
  uint64_t *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t *v11;
  unsigned int v12;
  uint64_t **v13;
  char *v15;
  uint64_t *v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  const __CFString *cfNameString;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;

  getParameterInfo((uint64_t *)&v23);
  if (a2 != 4)
  {
    v10 = 4294956430;
    goto LABEL_15;
  }
  v7 = v24;
  if (!v24)
  {
LABEL_8:
    v10 = 4294956418;
    goto LABEL_15;
  }
  v8 = v24;
  while (1)
  {
    v9 = *((_DWORD *)v8 + 8);
    if (v9 <= a3)
      break;
LABEL_7:
    v8 = (uint64_t *)*v8;
    if (!v8)
      goto LABEL_8;
  }
  if (v9 < a3)
  {
    ++v8;
    goto LABEL_7;
  }
  do
  {
    while (1)
    {
      v11 = v7;
      v12 = *((_DWORD *)v7 + 8);
      if (v12 <= a3)
        break;
      v7 = (uint64_t *)*v11;
      if (!*v11)
      {
        v13 = (uint64_t **)v11;
        goto LABEL_18;
      }
    }
    if (v12 >= a3)
    {
      v15 = (char *)v11;
      goto LABEL_21;
    }
    v7 = (uint64_t *)v11[1];
  }
  while (v7);
  v13 = (uint64_t **)(v11 + 1);
LABEL_18:
  v15 = (char *)operator new(0x90uLL);
  *((_DWORD *)v15 + 8) = a3;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_OWORD *)(v15 + 56) = 0u;
  *(_OWORD *)(v15 + 72) = 0u;
  *(_OWORD *)(v15 + 88) = 0u;
  *(_OWORD *)(v15 + 104) = 0u;
  *(_OWORD *)(v15 + 120) = 0u;
  *((_QWORD *)v15 + 17) = 0;
  *(_QWORD *)v15 = 0;
  *((_QWORD *)v15 + 1) = 0;
  *((_QWORD *)v15 + 2) = v11;
  *v13 = (uint64_t *)v15;
  v16 = (uint64_t *)v15;
  if (*v23)
  {
    v23 = (uint64_t *)*v23;
    v16 = *v13;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v24, v16);
  ++v25;
LABEL_21:
  v17 = *(_OWORD *)(v15 + 88);
  v18 = *(_OWORD *)(v15 + 120);
  v19 = *((_QWORD *)v15 + 17);
  *(_OWORD *)&a4->clumpID = *(_OWORD *)(v15 + 104);
  *(_QWORD *)&a4->flags = v19;
  v20 = *(_OWORD *)(v15 + 56);
  v21 = *(_OWORD *)(v15 + 72);
  *(_OWORD *)a4->name = *(_OWORD *)(v15 + 40);
  *(_OWORD *)&a4->name[16] = v20;
  *(_OWORD *)&a4->unit = v18;
  *(_OWORD *)&a4->name[32] = v21;
  *(_OWORD *)&a4->name[48] = v17;
  cfNameString = a4->cfNameString;
  a4->flags = v19 | 0x8000000;
  CFStringGetCString(cfNameString, a4->name, 52, 0x8000100u);
  v10 = 0;
LABEL_15:
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v24);
  return v10;
}

void sub_1B6530ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a11);
  _Unwind_Resume(a1);
}

UInt8 *AUCrossCorrelator::SaveExtendedScopes(AUCrossCorrelator *this, __CFData *a2)
{
  ausdk::AUScope *Scope;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);
  return ausdk::AUScope::SaveState(Scope, a2);
}

double AUCrossCorrelator::GetLatency(AUCrossCorrelator *this)
{
  return 0.0;
}

double AUCrossCorrelator::GetTailTime(AUCrossCorrelator *this)
{
  return 0.0;
}

uint64_t AUCrossCorrelator::SupportsTail(AUCrossCorrelator *this)
{
  return 1;
}

BOOL AUCrossCorrelator::StreamFormatWritable(AUCrossCorrelator *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUCrossCorrelator::SupportedNumChannels(AUCrossCorrelator *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUCrossCorrelator::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 8;
}

uint64_t AUCrossCorrelator::GetScopeExtended(AUCrossCorrelator *this, int a2)
{
  if (a2 == 4)
    return (uint64_t)this + 832;
  else
    return 0;
}

void getParameterInfo(uint64_t *a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  BOOL v6;
  uint64_t __dst[57];

  __dst[56] = *MEMORY[0x1E0C80C00];
  {
    memcpy(__dst, &unk_1E69E86D8, 0x1C0uLL);
    std::map<unsigned int,AudioUnitParameterInfo>::map[abi:ne180100](__dst, 4);
    __cxa_atexit((void (*)(void *))std::map<unsigned int,AudioUnitParameterInfo>::~map[abi:ne180100], &getParameterInfo(void)::sParameterInfo, &dword_1B5ED0000);
  }
  a1[1] = 0;
  a1[2] = 0;
  *a1 = (uint64_t)(a1 + 1);
  v3 = getParameterInfo(void)::sParameterInfo;
  if ((uint64_t *)getParameterInfo(void)::sParameterInfo != &qword_1EF137240)
  {
    do
    {
      std::__tree<std::__value_type<unsigned int,AudioUnitParameterInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,AudioUnitParameterInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,AudioUnitParameterInfo>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int const,AudioUnitParameterInfo> const&>(a1, a1 + 1, *(_DWORD *)(v3 + 32), (_OWORD *)(v3 + 32));
      v4 = *(uint64_t **)(v3 + 8);
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = (uint64_t *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = *(uint64_t **)(v3 + 16);
          v6 = *v5 == v3;
          v3 = (uint64_t)v5;
        }
        while (!v6);
      }
      v3 = (uint64_t)v5;
    }
    while (v5 != &qword_1EF137240);
  }
}

void sub_1B653109C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *std::map<unsigned int,AudioUnitParameterInfo>::map[abi:ne180100](uint64_t *result, uint64_t a2)
{
  unsigned int *v2;
  uint64_t v3;

  qword_1EF137248 = 0;
  qword_1EF137240 = 0;
  getParameterInfo(void)::sParameterInfo = (uint64_t)&qword_1EF137240;
  if (a2)
  {
    v2 = (unsigned int *)result;
    v3 = 112 * a2;
    do
    {
      result = std::__tree<std::__value_type<unsigned int,AudioUnitParameterInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,AudioUnitParameterInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,AudioUnitParameterInfo>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int const,AudioUnitParameterInfo> const&>(&getParameterInfo(void)::sParameterInfo, &qword_1EF137240, *v2, v2);
      v2 += 28;
      v3 -= 112;
    }
    while (v3);
  }
  return result;
}

void sub_1B653112C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy((_QWORD *)qword_1EF137240);
  _Unwind_Resume(a1);
}

uint64_t std::map<unsigned int,AudioUnitParameterInfo>::~map[abi:ne180100](uint64_t a1)
{
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*(_QWORD **)(a1 + 8));
  return a1;
}

uint64_t *std::__tree<std::__value_type<unsigned int,AudioUnitParameterInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,AudioUnitParameterInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,AudioUnitParameterInfo>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int const,AudioUnitParameterInfo> const&>(uint64_t *result, uint64_t *a2, unsigned int a3, _OWORD *a4)
{
  uint64_t **v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t **v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t **v14;
  uint64_t *v15;
  BOOL v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t *v20;
  unsigned int v21;
  uint64_t *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v5 = (uint64_t **)result;
  v6 = (uint64_t **)(result + 1);
  if (result + 1 == a2 || (v7 = *((_DWORD *)a2 + 8), v7 > a3))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*result == a2)
    {
      v10 = a2;
LABEL_16:
      if (v8)
        v13 = (uint64_t **)v10;
      else
        v13 = (uint64_t **)a2;
      if (v8)
        v11 = (uint64_t **)(v10 + 1);
      else
        v11 = (uint64_t **)a2;
      goto LABEL_22;
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v15 = a2;
      do
      {
        v10 = (uint64_t *)v15[2];
        v16 = *v10 == (_QWORD)v15;
        v15 = v10;
      }
      while (v16);
    }
    if (*((_DWORD *)v10 + 8) < a3)
      goto LABEL_16;
    v17 = *v6;
    if (*v6)
    {
      while (1)
      {
        while (1)
        {
          v13 = (uint64_t **)v17;
          v18 = *((_DWORD *)v17 + 8);
          if (v18 <= a3)
            break;
          v17 = *v13;
          v6 = v13;
          if (!*v13)
            goto LABEL_44;
        }
        if (v18 >= a3)
          break;
        v6 = v13 + 1;
        v17 = v13[1];
        if (!v17)
          goto LABEL_44;
      }
LABEL_45:
      v11 = v6;
      goto LABEL_22;
    }
    goto LABEL_43;
  }
  if (v7 >= a3)
    return result;
  v11 = (uint64_t **)(a2 + 1);
  v12 = (uint64_t *)a2[1];
  if (v12)
  {
    do
    {
      v11 = (uint64_t **)v12;
      v12 = (uint64_t *)*v12;
      v13 = v11;
      v14 = v11;
    }
    while (v12);
  }
  else
  {
    v14 = (uint64_t **)a2;
    do
    {
      v19 = (uint64_t *)v14;
      v14 = (uint64_t **)v14[2];
    }
    while (*v14 != v19);
    v13 = (uint64_t **)a2;
  }
  if (v14 != v6 && *((_DWORD *)v14 + 8) <= a3)
  {
    v20 = *v6;
    if (*v6)
    {
      while (1)
      {
        while (1)
        {
          v13 = (uint64_t **)v20;
          v21 = *((_DWORD *)v20 + 8);
          if (v21 <= a3)
            break;
          v20 = *v13;
          v6 = v13;
          if (!*v13)
            goto LABEL_44;
        }
        if (v21 >= a3)
          goto LABEL_45;
        v6 = v13 + 1;
        v20 = v13[1];
        if (!v20)
          goto LABEL_44;
      }
    }
LABEL_43:
    v13 = (uint64_t **)(result + 1);
    goto LABEL_44;
  }
LABEL_22:
  v6 = v11;
  if (!*v11)
  {
LABEL_44:
    v22 = (uint64_t *)operator new(0x90uLL);
    v23 = a4[5];
    *((_OWORD *)v22 + 6) = a4[4];
    *((_OWORD *)v22 + 7) = v23;
    *((_OWORD *)v22 + 8) = a4[6];
    v24 = a4[1];
    *((_OWORD *)v22 + 2) = *a4;
    *((_OWORD *)v22 + 3) = v24;
    v25 = a4[3];
    *((_OWORD *)v22 + 4) = a4[2];
    *((_OWORD *)v22 + 5) = v25;
    return std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(v5, (uint64_t)v13, v6, v22);
  }
  return result;
}

void VoiceProcessorV6::~VoiceProcessorV6(VoiceProcessorV6 *this)
{
  VoiceProcessorV6::~VoiceProcessorV6(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  const applesauce::CF::StringRef *v2;
  void **v3;
  void **v4;
  vp *v5;
  VPTimeFreqConverter *v6;
  uint64_t v7;
  char v8;
  char v9;
  char *v10;
  VPTimeFreqConverter *v11;
  _QWORD *v12;
  VPTimeFreqConverter *v13;
  VPTimeFreqConverter *v14;
  void *v15;

  *(_QWORD *)this = &off_1E69E8AF8;
  caulk::details::lifetime_guard_base<VoiceProcessorV2>::invalidate((uint64_t)this + 16600);
  if (_os_feature_enabled_impl())
  {
    v3 = (void **)*((_QWORD *)this + 2161);
    if (v3)
      vp::CFNotificationDelegate::shutdown(v3);
    v4 = (void **)*((_QWORD *)this + 2163);
    if (v4)
      vp::CFNotificationDelegate::shutdown(v4);
  }
  v5 = (vp *)*((_QWORD *)this + 2069);
  if (v5)
    vp::RemoveActiveChatFlavorForBundleID(v5, v2);
  v6 = (VPTimeFreqConverter *)*((_QWORD *)this + 2145);
  if (v6)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v6);
    MEMORY[0x1BCC95CEC]();
    *((_QWORD *)this + 2145) = 0;
  }
  v7 = 0;
  v8 = 1;
  do
  {
    v9 = v8;
    v10 = (char *)this + 8 * v7;
    v11 = (VPTimeFreqConverter *)*((_QWORD *)v10 + 2146);
    if (v11)
    {
      v12 = v10 + 17168;
      VPTimeFreqConverter::~VPTimeFreqConverter(v11);
      MEMORY[0x1BCC95CEC]();
      *v12 = 0;
    }
    v8 = 0;
    v7 = 1;
  }
  while ((v9 & 1) != 0);
  myFreeABLDynamic((AudioBufferList **)this + 2134);
  myFreeABLDynamic((AudioBufferList **)this + 2135);
  myFreeABLDynamic((AudioBufferList **)this + 2136);
  myFreeABLDynamic((AudioBufferList **)this + 2137);
  myFreeABLDynamic((AudioBufferList **)this + 2138);
  myFreeABLDynamic((AudioBufferList **)this + 2139);
  myFreeABLDynamic((AudioBufferList **)this + 2140);
  myFreeABLDynamic((AudioBufferList **)this + 2141);
  myFreeABLDynamic((AudioBufferList **)this + 508);
  myFreeABLDynamic((AudioBufferList **)this + 2142);
  myFreeABLDynamic((AudioBufferList **)this + 2143);
  myFreeABLDynamic((AudioBufferList **)this + 2144);
  myFreeABLDynamic((AudioBufferList **)this + 2149);
  myFreeABLDynamic((AudioBufferList **)this + 2150);
  myFreeABLDynamic((AudioBufferList **)this + 2151);
  myFreeABLDynamic((AudioBufferList **)this + 2152);
  myFreeABLDynamic((AudioBufferList **)this + 2153);
  myFreeABLDynamic((AudioBufferList **)this + 2154);
  myFreeABLDynamic((AudioBufferList **)this + 2155);
  v13 = (VPTimeFreqConverter *)*((_QWORD *)this + 2156);
  if (v13)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v13);
    MEMORY[0x1BCC95CEC]();
    *((_QWORD *)this + 2156) = 0;
  }
  if (*((_QWORD *)this + 2166))
    myFreeABLDynamic((AudioBufferList **)this + 2166);
  v14 = (VPTimeFreqConverter *)*((_QWORD *)this + 2165);
  if (v14)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v14);
    MEMORY[0x1BCC95CEC]();
    *((_QWORD *)this + 2165) = 0;
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 17304);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 17288);
  v15 = (void *)*((_QWORD *)this + 2157);
  if (v15)
  {
    *((_QWORD *)this + 2158) = v15;
    operator delete(v15);
  }
  VoiceProcessorV5::~VoiceProcessorV5((AudioBufferList **)this);
}

uint64_t VoiceProcessorV6::GetVersion(VoiceProcessorV6 *this)
{
  return 6;
}

void VoiceProcessorV6::SetPreferredChatFlavorFromCFNotification(VoiceProcessorV6 *this, const __CFDictionary *a2)
{
  _QWORD *v3;
  NSObject *v4;
  void **v5;
  int *v6;
  uint64_t v7;
  const char *v8;
  std::runtime_error *v9;
  std::runtime_error *exception;
  void *__p[2];
  char v12;
  CFTypeRef cf;
  _BYTE buf[12];
  __int16 v15;
  int v16;
  __int16 v17;
  void **v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  vp::ExtractBundleIDFromAVAUVoiceIOChatFlavorNotification((vp *)&cf, a2);
  if (cf)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v3 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      v4 = (*v3 ? *v3 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        if (!cf)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Could not construct");
        }
        applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)__p);
        if (v12 >= 0)
          v5 = __p;
        else
          v5 = (void **)__p[0];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
        v15 = 1024;
        v16 = 1308;
        v17 = 2080;
        v18 = v5;
        _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> ChatFlavor updated notification received for %s", buf, 0x1Cu);
        if (v12 < 0)
          operator delete(__p[0]);
      }
    }
    v6 = (int *)*((_QWORD *)this + 1570);
    if (v6 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      if (!cf)
      {
        v9 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v9, "Could not construct");
      }
      v7 = VPLogScope(void)::scope;
      applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)buf);
      if (SBYTE3(v18) >= 0)
        v8 = buf;
      else
        v8 = *(const char **)buf;
      CALegacyLog::log(v6, 3, v7, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1308, "SetPreferredChatFlavorFromCFNotification", "ChatFlavor updated notification received for %s", v8);
      if (SBYTE3(v18) < 0)
        operator delete(*(void **)buf);
    }
    if (applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>((CFTypeRef *)this + 2069, (const __CFString **)&cf) == kCFCompareEqualTo)
    {
      *(_DWORD *)buf = (*(uint64_t (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 568))(this);
      (*(void (**)(VoiceProcessorV6 *, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)this + 56))(this, 1718384242, buf, 4);
    }
    if (cf)
      CFRelease(cf);
  }
}

void sub_1B65316E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  void *v20;

  __cxa_free_exception(v20);
  applesauce::CF::StringRef::~StringRef(&a14);
  _Unwind_Resume(a1);
}

void VoiceProcessorV6::SetAutomaticMicModeIsEnabledFromCFNotification(VoiceProcessorV6 *this, const __CFDictionary *a2)
{
  _QWORD *v3;
  NSObject *v4;
  void **v5;
  int *v6;
  uint64_t v7;
  const char *v8;
  std::runtime_error *v9;
  std::runtime_error *exception;
  void *__p[2];
  char v12;
  CFTypeRef cf;
  _BYTE buf[12];
  __int16 v15;
  int v16;
  __int16 v17;
  void **v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  vp::ExtractBundleIDFromAVAUVoiceIOChatFlavorNotification((vp *)&cf, a2);
  if (cf)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v3 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      v4 = (*v3 ? *v3 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        if (!cf)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Could not construct");
        }
        applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)__p);
        if (v12 >= 0)
          v5 = __p;
        else
          v5 = (void **)__p[0];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
        v15 = 1024;
        v16 = 1321;
        v17 = 2080;
        v18 = v5;
        _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Automatic Chat Flavor enablement updated notification received for %s", buf, 0x1Cu);
        if (v12 < 0)
          operator delete(__p[0]);
      }
    }
    v6 = (int *)*((_QWORD *)this + 1570);
    if (v6 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      if (!cf)
      {
        v9 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v9, "Could not construct");
      }
      v7 = VPLogScope(void)::scope;
      applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)buf);
      if (SBYTE3(v18) >= 0)
        v8 = buf;
      else
        v8 = *(const char **)buf;
      CALegacyLog::log(v6, 3, v7, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1321, "SetAutomaticMicModeIsEnabledFromCFNotification", "Automatic Chat Flavor enablement updated notification received for %s", v8);
      if (SBYTE3(v18) < 0)
        operator delete(*(void **)buf);
    }
    if (applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>((CFTypeRef *)this + 2069, (const __CFString **)&cf) == kCFCompareEqualTo)
    {
      *(_DWORD *)buf = (*(uint64_t (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 576))(this);
      (*(void (**)(VoiceProcessorV6 *, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)this + 56))(this, 1635085677, buf, 4);
    }
    if (cf)
      CFRelease(cf);
  }
}

void sub_1B6531A0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  void *v20;

  __cxa_free_exception(v20);
  applesauce::CF::StringRef::~StringRef(&a14);
  _Unwind_Resume(a1);
}

uint64_t VoiceProcessorV6::Initialize(VoiceProcessorV6 *this)
{
  int v2;
  int v3;
  uint64_t result;

  *((_DWORD *)this + 100) = 0;
  v2 = *((_DWORD *)this + 153);
  if (v2)
  {
    v3 = 0;
    do
    {
      v3 = (2 * v3) | 1;
      --v2;
    }
    while (v2);
    *((_DWORD *)this + 100) = v3;
  }
  result = VoiceProcessorV2::Initialize(this);
  if (!(_DWORD)result)
  {
    VoiceProcessorV4::InitializeV4Specifics(this);
    VoiceProcessorV5::InitializeV5Specifics(this);
    VoiceProcessorV6::InitializeV6Specifics(this);
    (*(void (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 696))(this);
    return 0;
  }
  return result;
}

void VoiceProcessorV6::InitializeSubclassUplinkTimeFreqConverters(VoiceProcessorV6 *this)
{
  VPTimeFreqConverter **v2;
  VPTimeFreqConverter *v3;

  v2 = (VPTimeFreqConverter **)((char *)this + 17320);
  v3 = (VPTimeFreqConverter *)*((_QWORD *)this + 2165);
  if (v3)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v3);
    MEMORY[0x1BCC95CEC]();
    *v2 = 0;
  }
  if (*((_QWORD *)this + 2166))
    myFreeABLDynamic((AudioBufferList **)this + 2166);
  if ((*((_BYTE *)this + 4664) & 4) != 0)
  {
    VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), v2);
    myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2166);
  }
}

uint64_t VoiceProcessorV6::CorrectHardwareOutputSafetyOffsets(VoiceProcessorV6 *this)
{
  return (*(uint64_t (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 272))(this);
}

uint64_t VoiceProcessorV6::CorrectHardwareOutputPresentationLatency(VoiceProcessorV6 *this)
{
  return (*(uint64_t (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 288))(this);
}

VoiceProcessorV2 *VoiceProcessorV6::SetupUplinkBasicAUChain(VoiceProcessorV6 *this)
{
  unint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  VoiceProcessorV2 *result;
  char *v8;
  int v9;

  v2 = (unint64_t *)((char *)this + 4656);
  v8 = (char *)this + 4656;
  v9 = 0;
  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)&v8);
  v3 = *((_QWORD *)this + 582);
  v4 = *((_QWORD *)this + 583);
  *((_QWORD *)this + 583) = v4 | 0x11;
  *((_QWORD *)this + 582) = v3 | 0xC220040000200040;
  if (*((_BYTE *)this + 1676))
    *v2 = v3 | 0xD220040000200040;
  v5 = *((_DWORD *)this + 571);
  if (v5 == 1 || v5 == -1)
    *((_QWORD *)this + 583) = v4 | 0x13;
  result = (VoiceProcessorV2 *)VoiceProcessorV2::GetChatFlavor(this);
  if ((_DWORD)result == 2 && (*((_BYTE *)this + 16544) & 4) != 0)
  {
    *((_QWORD *)this + 582) |= 0x800000000000000uLL;
    if (*((_BYTE *)this + 2246))
    {
      result = (VoiceProcessorV2 *)VoiceProcessorV2::IsDeviceSupportingAdvancedChatFlavors(result);
      if ((_DWORD)result)
        *((_QWORD *)this + 583) |= 4uLL;
    }
  }
  return result;
}

uint64_t VoiceProcessorV6::SetupUplinkLiteAUChain(VoiceProcessorV6 *this)
{
  unint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t result;
  char *v8;
  int v9;

  v2 = (unint64_t *)((char *)this + 4656);
  v8 = (char *)this + 4656;
  v9 = 0;
  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)&v8);
  v3 = *((_QWORD *)this + 582);
  v4 = *((_QWORD *)this + 583);
  *((_QWORD *)this + 583) = v4 | 0x10;
  *((_QWORD *)this + 582) = v3 | 0xC000040000200040;
  if (*((_BYTE *)this + 1676))
    *v2 = v3 | 0xD000040000200040;
  v5 = *((_DWORD *)this + 571);
  if (v5 == 1 || v5 == -1)
    *((_QWORD *)this + 583) = v4 | 0x12;
  result = (*(uint64_t (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 112))(this);
  if (result >= 8)
    *v2 |= 0x10000000uLL;
  return result;
}

uint64_t VoiceProcessorV6::SetupUplink_MMNS(uint64_t this, unsigned int a2)
{
  unint64_t v2;

  if (a2 != 1)
  {
    v2 = *(_QWORD *)(this + 4656) & 0xFD5FD7FFFFBFFF7FLL;
    *(_QWORD *)(this + 4656) = v2 + 0x80280000400080;
    if (a2)
    {
      *(_QWORD *)(this + 4656) = v2 | 0x80280000400086;
      if (a2 >= 3)
      {
        *(_QWORD *)(this + 4656) = v2 | 0x8028000040008ELL;
        if (a2 != 3)
          *(_QWORD *)(this + 4656) = v2 | 0x480280181C0029ELL;
      }
    }
  }
  return this;
}

uint64_t VoiceProcessorV6::SetupUplink_BF_MS(uint64_t this, unsigned int a2, char a3)
{
  uint64_t v3;
  uint64_t v4;

  if (a2 < 2)
  {
    if (a2 && (a3 & 1) == 0)
    {
      v4 = *(_QWORD *)(this + 4656) | 2;
      goto LABEL_9;
    }
  }
  else
  {
    v3 = *(_QWORD *)(this + 4656);
    *(_QWORD *)(this + 4656) = v3 | 0x60400081;
    if ((a3 & 1) == 0)
    {
      *(_QWORD *)(this + 4656) = v3 | 0x60400087;
      if (a2 != 2)
      {
        *(_QWORD *)(this + 4656) = v3 | 0x6040008F;
        if (a2 >= 4)
        {
          v4 = v3 | 0x6040009F;
LABEL_9:
          *(_QWORD *)(this + 4656) = v4;
        }
      }
    }
  }
  return this;
}

uint64_t VoiceProcessorV6::SetupUplink_MS(uint64_t this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a2 != 1)
  {
    v2 = *(_QWORD *)(this + 4656);
    v3 = v2 | 0x81;
    v4 = v2 | 0x87;
    v5 = 159;
    if (a2 == 3)
      v5 = 143;
    v6 = v2 | v5;
    if (a2 < 3)
      v6 = v4;
    if (!a2)
      v6 = v3;
    *(_QWORD *)(this + 4656) = v6 & 0xF9FFFFFFDDFFFBFFLL | 0x600000002000400;
  }
  return this;
}

_QWORD *VoiceProcessorV6::SetupUplink_SCLP_PMWF_BeamIt(_QWORD *this, unsigned int a2)
{
  _QWORD *v2;
  uint64_t v3;

  if (a2 >= 4)
  {
    v2 = this;
    this[582] |= 0x100001601400280uLL;
    this = (_QWORD *)VoiceProcessorV2::GetChatFlavor((VoiceProcessorV2 *)this);
    if ((_DWORD)this == 1)
      v3 = (v2[2068] << 49) & 0x4000000000000 | v2[582];
    else
      v3 = v2[582];
    v2[582] = v3 & 0xFDFFFFFFFFFFFFFFLL;
    *((_DWORD *)v2 + 3098) = 9;
  }
  return this;
}

void VoiceProcessorV6::SetupDownlinkBasicAUChain(VoiceProcessorV6 *this)
{
  float v2;

  VoiceProcessorV4::SetupDownlinkBasicAUChain(this);
  *((_QWORD *)this + 1104) = *((_QWORD *)this + 1104) & 0xEFFF7FFFFD5FFFFFLL | 0x800002800000;
  v2 = VoiceProcessorV2::DetermineRouteBasedPreGain(this);
  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)this + 9400, 7, v2);
  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)this + 9400, 5, *((float *)this + 3119));
  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)this + 9016, 26, v2);
}

uint64_t VoiceProcessorV6::SetupDownlinkLiteAUChain(VoiceProcessorV6 *this)
{
  uint64_t result;

  result = (*(uint64_t (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 400))(this);
  *((_QWORD *)this + 1104) &= 0xFFFFFFFF3FFFFFFFLL;
  return result;
}

uint64_t VoiceProcessorV6::GetVPVocoderOrUseCaseOverrideTuning4CC(VoiceProcessorV6 *this)
{
  uint64_t v2;
  int v3;
  double v4;
  _QWORD *v5;
  NSObject *v6;
  int *v7;
  int *v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  double v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = 1986998836;
  v3 = *((float *)this + 550);
  if (v3 > 23999)
  {
    if (v3 == 24000)
      return v2;
    if (v3 == 32000)
    {
      if ((*(unsigned int (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 232))(this))
        return 1986999090;
      else
        return 1986998836;
    }
  }
  else
  {
    if (v3 == 8000)
      return 1986998328;
    if (v3 == 16000)
      return 1986998582;
  }
  if (v3 >= 0x7D01)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v4 = (double)v3;
    v5 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      v6 = (*v5 ? *v5 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v11 = "VoiceProcessor_v6.cpp";
        v12 = 1024;
        v13 = 1014;
        v14 = 2048;
        v15 = v4;
        _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Unexpected vocoder sample rate = %f! Use 'vo24' instead.", buf, 0x1Cu);
      }
    }
    v7 = (int *)*((_QWORD *)this + 1570);
    if (v7 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
      {
        v9 = (int *)*((_QWORD *)this + 1570);
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v7 = v9;
      }
      CALegacyLog::log(v7, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1014, "GetVPVocoderOrUseCaseOverrideTuning4CC", "Unexpected vocoder sample rate = %f! Use 'vo24' instead.", v4);
    }
  }
  return v2;
}

uint64_t VoiceProcessorV6::ShouldThirdPartyAppUseFaceTimeDSPAndTuning(VoiceProcessorV6 *this)
{
  if (**((_DWORD **)this + 295) != 1886222185
    || **((_DWORD **)this + 292) != 1885892727
    || *((_DWORD *)this + 596) != 1781740087)
  {
    return 0;
  }
  if (VoiceProcessorV2::GetChatFlavor(this) != 2 || (*((_BYTE *)this + 16544) & 4) == 0)
  {
    if (VoiceProcessorV2::GetChatFlavor(this) == 1)
      return (*((unsigned __int8 *)this + 16544) >> 1) & 1;
    return 0;
  }
  return 1;
}

uint64_t VoiceProcessorV6::GetRefPortCodeForTuning(_BYTE *a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  char v12;
  unsigned int v13;
  _BOOL4 v16;
  unsigned int v18;

  v12 = _os_feature_enabled_impl();
  if ((_DWORD)a2 == 1885889645 && (v12 & 1) != 0)
    return 1886745455;
  if (((*(uint64_t (**)(_BYTE *))(*(_QWORD *)a1 + 608))(a1) & 1) == 0)
  {
    v13 = 1885433971;
    v16 = (a6 & 0xFF00000000) != 0 && (_DWORD)a6 == 1835361379 && a1[2244] != 0;
    if ((_DWORD)a2 != 1885631344 && (_DWORD)a2 != 1885889645)
    {
      if ((_DWORD)a2 != 1885892706 || (v13 = 1885892727, v16))
      {
        if (a3 == 1781740087 && (_DWORD)a2 == 1885892727)
          v13 = 909127729;
        else
          v13 = a2;
      }
    }
    if (a5 == 1886152047)
      v13 = 1886152047;
    if (v16)
      v18 = 1886152047;
    else
      v18 = 1885892727;
    if (v13 == 1886152047 && a4 == 1886152041)
      return v18;
    else
      return v13;
  }
  return a2;
}

uint64_t VoiceProcessorV6::GetMicPortCodeForTuning(_BYTE *a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;
  _BOOL4 v14;

  if (((*(uint64_t (**)(_BYTE *))(*(_QWORD *)a1 + 608))(a1) & 1) != 0)
    return a4;
  result = 1886222185;
  v14 = (a6 & 0xFF00000000) != 0 && (_DWORD)a6 == 1835361379 && a1[2244] != 0;
  if ((_DWORD)a4 != 1886216820 || v14)
  {
    if (a2 != 1886152047 || (_DWORD)a4 != 1886152041)
      v14 = 1;
    if (v14)
    {
      if ((_DWORD)a4 == 1886222185 && a3 == 1781740087)
        return 909127729;
      else
        return a4;
    }
  }
  return result;
}

uint64_t VoiceProcessorV6::LoadTuningsPlists(VoiceProcessorV6 *this)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  NSObject *v14;
  uint64_t v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  std::string::size_type size;
  std::string *v20;
  int v21;
  const char *v22;
  const char *v23;
  std::string *v24;
  uint64_t v25;
  _QWORD *v26;
  NSObject *v27;
  int *v28;
  uint64_t v29;
  std::string *v30;
  __int128 v31;
  std::string *v32;
  __int128 v33;
  void **v34;
  std::string::size_type v35;
  std::string *v36;
  __int128 v37;
  std::string *v38;
  __int128 v39;
  void **v40;
  std::string::size_type v41;
  std::string *v42;
  std::string::size_type v43;
  char v44;
  void **v45;
  void **v46;
  void *v47;
  void *__p[2];
  char v50;
  void *v51[2];
  unsigned __int8 v52;
  void *v53[2];
  unsigned __int8 v54;
  std::string v55;
  std::string v56;
  void **v57;
  char v58[16];
  char v59[16];
  char __s[16];
  std::string v61;
  _QWORD v62[2];
  _BYTE buf[28];
  __int16 v64;
  std::string *v65;
  __int16 v66;
  std::string *v67;
  std::string v68;
  std::string v69;
  std::string v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v2 = (char *)this + 15897;
  v3 = **((unsigned int **)this + 292);
  v4 = *((unsigned int *)this + 596);
  v5 = **((unsigned int **)this + 295);
  v6 = *((unsigned int *)this + 597);
  v7 = (*(uint64_t (**)(VoiceProcessorV6 *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this
                                                                                                 + 488))(this, v3, v4, v5, v6, 0);
  v8 = (*(uint64_t (**)(VoiceProcessorV6 *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this
                                                                                                 + 496))(this, v3, v4, v5, v6, 0);
  v9 = *((_DWORD *)this + 22);
  switch(v9)
  {
    case 1835627363:
      v12 = (*(uint64_t (**)(VoiceProcessorV6 *, uint64_t, uint64_t))(*(_QWORD *)this + 720))(this, v7, v8);
      if ((v12 & 0xFF00000000) != 0)
        LODWORD(v10) = v12;
      else
        LODWORD(v10) = 1835627363;
      goto LABEL_35;
    case 1986618467:
      if (VoiceProcessorV2::GetChatFlavor(this) == 2 && (*((_BYTE *)this + 16544) & 4) != 0)
      {
        LODWORD(v10) = 1986622319;
        goto LABEL_35;
      }
      LODWORD(v10) = 1986605620;
LABEL_15:
      if (VoiceProcessorV2::GetChatFlavor(this) == 1 && (*((_BYTE *)this + 16544) & 2) != 0)
        LODWORD(v10) = 1986884451;
      goto LABEL_35;
    case 1987012963:
      LODWORD(v10) = (*(uint64_t (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 472))(this);
      if (VoiceProcessorV2::GetChatFlavor(this) == 2 && (*((_BYTE *)this + 16544) & 4) != 0)
      {
        v11 = (*(uint64_t (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 632))(this);
        if ((v11 & 0xFF00000000) != 0)
          LODWORD(v10) = v11;
        else
          LODWORD(v10) = 1986622319;
        goto LABEL_35;
      }
      goto LABEL_15;
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v13 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
  {
    v14 = (*v13 ? *v13 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)&v70, *((_DWORD *)this + 22));
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 964;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = &v70;
      _os_log_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Unknown MainChatCategory: %s", buf, 0x1Cu);
    }
  }
  v10 = (int *)*((_QWORD *)this + 1570);
  if (v10)
  {
    if (*v2 || v2[1])
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v15 = VPLogScope(void)::scope;
      CAX4CCString::CAX4CCString((CAX4CCString *)buf, *((_DWORD *)this + 22));
      CALegacyLog::log(v10, 1, v15, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 964, "LoadTuningsPlists", "Unknown MainChatCategory: %s", buf);
    }
    LODWORD(v10) = 0;
  }
LABEL_35:
  VoiceProcessorV2::GetHardwareModelNameForTuning(&v70, (uint64_t)this);
  VoiceProcessorV2::GetRouteSpecificGenericTuningSubDir((std::string *)buf, (uint64_t)this);
  if (buf[24])
  {
    if ((buf[23] & 0x80000000) != 0)
      std::string::__init_copy_ctor_external(&v68, *(const std::string::value_type **)buf, *(std::string::size_type *)&buf[8]);
    else
      v68 = *(std::string *)buf;
    v16 = std::string::insert(&v68, 0, "/", 1uLL);
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v69.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v69.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v18 = &v69;
    else
      v18 = (std::string *)v69.__r_.__value_.__r.__words[0];
    if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v69.__r_.__value_.__r.__words[2]);
    else
      size = v69.__r_.__value_.__l.__size_;
    std::string::append(&v70, (const std::string::value_type *)v18, size);
    if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v69.__r_.__value_.__l.__data_);
    if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v68.__r_.__value_.__l.__data_);
    if (buf[24] && (buf[23] & 0x80000000) != 0)
      operator delete(*(void **)buf);
  }
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = &v70;
  else
    v20 = (std::string *)v70.__r_.__value_.__r.__words[0];
  VoiceProcessorV2::GetVersionNameForTuning((std::string *)buf, (uint64_t)this);
  v21 = buf[23];
  v22 = *(const char **)buf;
  VoiceProcessorV2::GetDeviceCodeNameForTuning((VoiceProcessorV2 *)&v69, (uint64_t)this);
  if (v21 >= 0)
    v23 = buf;
  else
    v23 = v22;
  if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v24 = &v69;
  else
    v24 = (std::string *)v69.__r_.__value_.__r.__words[0];
  VoiceProcessorV2::TryLoadingTuningPlists(this, (const char *)v20, v23, (const char *)v24, v7, v8, v10);
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v69.__r_.__value_.__l.__data_);
  if ((buf[23] & 0x80000000) != 0)
    operator delete(*(void **)buf);
  *((_DWORD *)this + 23) = (_DWORD)v10;
  if (*((_BYTE *)this + 4568))
  {
    v25 = 0;
  }
  else
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v26 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v27 = (*v26 ? *v26 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&v69, v7);
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&v68, v8);
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&v61, v10);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 979;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = &v69;
        v64 = 2080;
        v65 = &v68;
        v66 = 2080;
        v67 = &v61;
        _os_log_impl(&dword_1B5ED0000, v27, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> NEW TUNING LOGIC <SERIOUS ERROR>: no tuning plists found. Using default paramters!!! Use case %s-%s-%s", buf, 0x30u);
      }
    }
    v28 = (int *)*((_QWORD *)this + 1570);
    if (v28 && (*v2 || v2[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v29 = VPLogScope(void)::scope;
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, v7);
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&v69, v8);
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&v68, v10);
      CALegacyLog::log(v28, 1, v29, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 979, "LoadTuningsPlists", "NEW TUNING LOGIC <SERIOUS ERROR>: no tuning plists found. Using default paramters!!! Use case %s-%s-%s", buf, (const char *)&v69, (const char *)&v68);
    }
    *(_QWORD *)&buf[8] = 0;
    *(_QWORD *)&buf[16] = 0;
    *(_QWORD *)buf = &buf[8];
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)__s, v7);
    std::string::basic_string[abi:ne180100]<0>(&v55, __s);
    v30 = std::string::insert(&v55, 0, "No tuning plists found, using default paramters. Use case ", 0x3AuLL);
    v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v56.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    v32 = std::string::append(&v56, "-", 1uLL);
    v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v61.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v59, v8);
    std::string::basic_string[abi:ne180100]<0>(v53, v59);
    if ((v54 & 0x80u) == 0)
      v34 = v53;
    else
      v34 = (void **)v53[0];
    if ((v54 & 0x80u) == 0)
      v35 = v54;
    else
      v35 = (std::string::size_type)v53[1];
    v36 = std::string::append(&v61, (const std::string::value_type *)v34, v35);
    v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    v68.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0;
    v36->__r_.__value_.__r.__words[2] = 0;
    v36->__r_.__value_.__r.__words[0] = 0;
    v38 = std::string::append(&v68, "-", 1uLL);
    v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    v69.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v69.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v58, v10);
    std::string::basic_string[abi:ne180100]<0>(v51, v58);
    if ((v52 & 0x80u) == 0)
      v40 = v51;
    else
      v40 = (void **)v51[0];
    if ((v52 & 0x80u) == 0)
      v41 = v52;
    else
      v41 = (std::string::size_type)v51[1];
    v42 = std::string::append(&v69, (const std::string::value_type *)v40, v41);
    v43 = v42->__r_.__value_.__r.__words[0];
    v62[0] = v42->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v62 + 7) = *(std::string::size_type *)((char *)&v42->__r_.__value_.__r.__words[1] + 7);
    v44 = HIBYTE(v42->__r_.__value_.__r.__words[2]);
    v42->__r_.__value_.__l.__size_ = 0;
    v42->__r_.__value_.__r.__words[2] = 0;
    v42->__r_.__value_.__r.__words[0] = 0;
    std::string::basic_string[abi:ne180100]<0>(__p, "vp_tuning_setup_error");
    v57 = __p;
    v45 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)buf, __p, (_OWORD **)&v57);
    v46 = v45;
    if (*((char *)v45 + 79) < 0)
      operator delete(v45[7]);
    v47 = (void *)v62[0];
    v46[7] = (void *)v43;
    v46[8] = v47;
    *(void **)((char *)v46 + 71) = *(void **)((char *)v62 + 7);
    *((_BYTE *)v46 + 79) = v44;
    if (v50 < 0)
      operator delete(__p[0]);
    if ((char)v52 < 0)
      operator delete(v51[0]);
    if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v69.__r_.__value_.__l.__data_);
    if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v68.__r_.__value_.__l.__data_);
    if ((char)v54 < 0)
      operator delete(v53[0]);
    if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v61.__r_.__value_.__l.__data_);
    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v56.__r_.__value_.__l.__data_);
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v55.__r_.__value_.__l.__data_);
    AudioStatisticsHelperSendMessage(*((uint64_t **)this + 270), *((_DWORD *)this + 542), (const UInt8 **)buf, 6);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(_QWORD **)&buf[8]);
    v25 = 0xFFFFFFFFLL;
  }
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v70.__r_.__value_.__l.__data_);
  return v25;
}

void sub_1B6532D70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  uint64_t v55;

  if (*(char *)(v55 - 105) < 0)
    operator delete(*(void **)(v55 - 128));
  _Unwind_Resume(exception_object);
}

void sub_1B6532F00()
{
  JUMPOUT(0x1B6532EF8);
}

BOOL VoiceProcessorV6::ShouldBypassTuningLoading(VoiceProcessorV6 *this)
{
  int v2;
  BOOL v3;
  int v4;
  int v5;
  int v6;

  if (VoiceProcessorV2::GetChatFlavor(this) == 2)
    v2 = (*((unsigned __int8 *)this + 16544) >> 2) & 1;
  else
    v2 = 0;
  if (*((_BYTE *)this + 2085))
    v3 = v2 == 0;
  else
    v3 = 0;
  if (v3)
    return 1;
  v4 = **((_DWORD **)this + 292);
  if (v4 == 1886680175)
  {
    v5 = **((_DWORD **)this + 295);
    v6 = 1886680169;
  }
  else
  {
    if (v4 != 1885892727 || *((_DWORD *)this + 596) != 1752709424)
      return (*((_DWORD *)this + 18) - 53) < 3;
    v5 = **((_DWORD **)this + 295);
    v6 = 1886222185;
  }
  if (v5 == v6)
    return 1;
  return (*((_DWORD *)this + 18) - 53) < 3;
}

uint64_t VoiceProcessorV6::portSubTypeCanOverrideHWEQ(VoiceProcessorV6 *this, int a2, int a3)
{
  _BOOL4 v3;
  unsigned int v4;

  v3 = a3 == 1214329654 || a3 == 1214394677;
  v4 = (a3 - 1647718502) < 2 || v3;
  if (a2 == 1885892727)
    return v4;
  else
    return 0;
}

uint64_t VoiceProcessorV6::ApplyPortSubtypeTuningOverride(VoiceProcessorV6 *this, unsigned int a2)
{
  char *v4;
  _QWORD *v5;
  NSObject *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t TuningInSubdirs;
  _QWORD *v11;
  NSObject *v12;
  _QWORD *v13;
  int *v14;
  const char *v15;
  const __CFDictionary *v16;
  _QWORD *v17;
  NSObject *v18;
  int *v19;
  unsigned __int8 *v20;
  _QWORD *v21;
  NSObject *v22;
  int *v23;
  int v24;
  _QWORD *v25;
  NSObject *v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  NSObject *v31;
  _QWORD *v32;
  int *v33;
  const char *v34;
  const __CFDictionary *v35;
  _QWORD *v36;
  NSObject *v37;
  int *v38;
  unsigned __int8 *v39;
  _QWORD *v40;
  NSObject *v41;
  int *v42;
  int *v44;
  int *v45;
  int inData;
  CFStringRef v47;
  char v48;
  CFTypeRef cf;
  char v50;
  _BYTE v51[28];
  __int16 v52;
  const char *v53;
  __int128 *v54;
  char v55;
  uint8_t buf[32];
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  _BYTE v69[31];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v4 = (char *)this + 15897;
  if ((*(unsigned int (**)(VoiceProcessorV6 *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 520))(this, **((unsigned int **)this + 292), *((unsigned int *)this + 596), **((unsigned int **)this + 295)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v5 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
    {
      v6 = (*v5 ? *v5 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v51, *((_DWORD *)this + 596));
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1144;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v51;
        _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> known headphones with HW EQ AU preset override detected %s", buf, 0x1Cu);
      }
    }
    v7 = (int *)*((_QWORD *)this + 1570);
    if (v7 && (*v4 || v4[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v8 = VPLogScope(void)::scope;
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, *((_DWORD *)this + 596));
      CALegacyLog::log(v7, 5, v8, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1144, "ApplyPortSubtypeTuningOverride", "known headphones with HW EQ AU preset override detected %s", (const char *)buf);
    }
    v68 = 0u;
    memset(v69, 0, sizeof(v69));
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v57 = 0u;
    memset(buf, 0, sizeof(buf));
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v51, a2);
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&v54, *((_DWORD *)this + 23));
    snprintf((char *)buf, 0xFFuLL, "%s_vprx_%s", v51, (const char *)&v54);
    v9 = *((_QWORD *)this + 341);
    v54 = (__int128 *)CFStringCreateWithCString(0, "Generic", 0x600u);
    v55 = 1;
    cf = CFStringCreateWithCString(0, "Headphones", 0x600u);
    v50 = 1;
    v47 = CFStringCreateWithCString(0, (const char *)buf, 0x600u);
    v48 = 1;
    *(_QWORD *)v51 = &v54;
    *(_QWORD *)&v51[8] = &cf;
    *(_QWORD *)&v51[16] = &v47;
    TuningInSubdirs = TuningPListMgr::loadTuningInSubdirs_(v9, (const __CFString ***)v51, 3u, 1u);
    CACFString::~CACFString((CACFString *)&v47);
    CACFString::~CACFString((CACFString *)&cf);
    CACFString::~CACFString((CACFString *)&v54);
    if ((_DWORD)TuningInSubdirs)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v11 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v12 = (*v11 ? *v11 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          v13 = (_QWORD *)((char *)this + 8);
          if (*((char *)this + 31) < 0)
            v13 = (_QWORD *)*v13;
          *(_DWORD *)v51 = 136315906;
          *(_QWORD *)&v51[4] = "VoiceProcessor_v6.cpp";
          *(_WORD *)&v51[12] = 1024;
          *(_DWORD *)&v51[14] = 1152;
          *(_WORD *)&v51[18] = 2080;
          *(_QWORD *)&v51[20] = v13;
          v52 = 2080;
          v53 = (const char *)buf;
          _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> : failed to find Headphone EQ aupreset: %s/Generic/Headphones/%s", v51, 0x26u);
        }
      }
      v14 = (int *)*((_QWORD *)this + 1570);
      if (v14 && (*v4 || v4[1]))
      {
        if (VPLogScope(void)::once != -1)
        {
          v44 = (int *)*((_QWORD *)this + 1570);
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v14 = v44;
        }
        v15 = (char *)this + 8;
        if (*((char *)this + 31) < 0)
          v15 = *(const char **)v15;
        CALegacyLog::log(v14, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1152, "ApplyPortSubtypeTuningOverride", ": failed to find Headphone EQ aupreset: %s/Generic/Headphones/%s", v15, (const char *)buf);
      }
      return TuningInSubdirs;
    }
    cf = 0;
    v16 = TuningPListMgr::lookupPlist_(*((_QWORD *)this + 341), (const char *)buf, 1u);
    cf = v16;
    if (v16)
    {
      CFRetain(v16);
      AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1462, 0, 0, 0, 8uLL, &cf, 1);
      CFRelease(cf);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v17 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v18 = (*v17 ? *v17 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v51 = 136315906;
          *(_QWORD *)&v51[4] = "VoiceProcessor_v6.cpp";
          *(_WORD *)&v51[12] = 1024;
          *(_DWORD *)&v51[14] = 1163;
          *(_WORD *)&v51[18] = 2080;
          *(_QWORD *)&v51[20] = buf;
          v52 = 2080;
          v53 = "(DL-)HwEQ";
          _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> found Headphone EQ aupreset:%s for %s", v51, 0x26u);
        }
      }
      v19 = (int *)*((_QWORD *)this + 1570);
      if (v19 && (*v4 || v4[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v19, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1163, "ApplyPortSubtypeTuningOverride", "found Headphone EQ aupreset:%s for %s", (const char *)buf, "(DL-)HwEQ");
      }
      std::string::basic_string[abi:ne180100]<0>(v51, "(DL-)HwEQ");
      v54 = (__int128 *)v51;
      v20 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)this + 4576, v51, (uint64_t)&std::piecewise_construct, &v54);
      std::string::__assign_external((std::string *)(v20 + 40), (const std::string::value_type *)buf);
      if ((v51[23] & 0x80000000) != 0)
        operator delete(*(void **)v51);
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v21 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v22 = (*v21 ? *v21 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v51 = 136315906;
          *(_QWORD *)&v51[4] = "VoiceProcessor_v6.cpp";
          *(_WORD *)&v51[12] = 1024;
          *(_DWORD *)&v51[14] = 1166;
          *(_WORD *)&v51[18] = 2080;
          *(_QWORD *)&v51[20] = buf;
          v52 = 2080;
          v53 = "(DL-)HwEQ";
          _os_log_impl(&dword_1B5ED0000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> : failed to load Headphone EQ tuning aupreset:%s for %s", v51, 0x26u);
        }
      }
      v23 = (int *)*((_QWORD *)this + 1570);
      if (v23 && (*v4 || v4[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v23, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1166, "ApplyPortSubtypeTuningOverride", ": failed to load Headphone EQ tuning aupreset:%s for %s", (const char *)buf, "(DL-)HwEQ");
      }
    }
  }
  if (!(*(unsigned int (**)(VoiceProcessorV6 *, _QWORD, _QWORD))(*(_QWORD *)this + 712))(this, **((unsigned int **)this + 292), *((unsigned int *)this + 596)))return 0;
  v24 = *((_DWORD *)this + 21);
  if (v24 != 1718628662 && v24 != 1718628408)
    return 0;
  inData = 0;
  AudioUnitSetProperty(*((AudioUnit *)this + 404), 0x15u, 0, 0, &inData, 4u);
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v25 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
  {
    v26 = (*v25 ? *v25 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v51, *((_DWORD *)this + 596));
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1174;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = v51;
      _os_log_impl(&dword_1B5ED0000, v26, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> known headphones with ReverbSuppressor AU preset override detected %s", buf, 0x1Cu);
    }
  }
  v27 = (int *)*((_QWORD *)this + 1570);
  if (v27 && (*v4 || v4[1]))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v28 = VPLogScope(void)::scope;
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, *((_DWORD *)this + 596));
    CALegacyLog::log(v27, 5, v28, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1174, "ApplyPortSubtypeTuningOverride", "known headphones with ReverbSuppressor AU preset override detected %s", (const char *)buf);
  }
  v67 = xmmword_1B6687C2C;
  v68 = unk_1B6687C3C;
  memset(v69, 0, sizeof(v69));
  v63 = xmmword_1B6687BEC;
  v64 = unk_1B6687BFC;
  v65 = xmmword_1B6687C0C;
  v66 = unk_1B6687C1C;
  v59 = xmmword_1B6687BAC;
  v60 = unk_1B6687BBC;
  v61 = xmmword_1B6687BCC;
  v62 = unk_1B6687BDC;
  strcpy((char *)buf, "vptx_reverbsuppressor_telephony");
  v57 = xmmword_1B6687B8C;
  v58 = unk_1B6687B9C;
  v29 = *((_QWORD *)this + 341);
  v54 = (__int128 *)CFStringCreateWithCString(0, "Generic", 0x600u);
  v55 = 1;
  cf = CFStringCreateWithCString(0, "Headphones", 0x600u);
  v50 = 1;
  v47 = CFStringCreateWithCString(0, (const char *)buf, 0x600u);
  v48 = 1;
  *(_QWORD *)v51 = &v54;
  *(_QWORD *)&v51[8] = &cf;
  *(_QWORD *)&v51[16] = &v47;
  TuningInSubdirs = TuningPListMgr::loadTuningInSubdirs_(v29, (const __CFString ***)v51, 3u, 1u);
  CACFString::~CACFString((CACFString *)&v47);
  CACFString::~CACFString((CACFString *)&cf);
  CACFString::~CACFString((CACFString *)&v54);
  if (!(_DWORD)TuningInSubdirs)
  {
    v35 = TuningPListMgr::lookupPlist_(*((_QWORD *)this + 341), (const char *)buf, 1u);
    cf = v35;
    if (v35)
    {
      CFRetain(v35);
      AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1050, 0, 0, 0, 8uLL, &cf, 1);
      CFRelease(cf);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v36 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v37 = (*v36 ? *v36 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v51 = 136315906;
          *(_QWORD *)&v51[4] = "VoiceProcessor_v6.cpp";
          *(_WORD *)&v51[12] = 1024;
          *(_DWORD *)&v51[14] = 1191;
          *(_WORD *)&v51[18] = 2080;
          *(_QWORD *)&v51[20] = buf;
          v52 = 2080;
          v53 = "(UL-)ReverbSuppressor";
          _os_log_impl(&dword_1B5ED0000, v37, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> found Headphone ReverbSuppressor aupreset:%s for %s", v51, 0x26u);
        }
      }
      v38 = (int *)*((_QWORD *)this + 1570);
      if (v38 && (*v4 || v4[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v38, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1191, "ApplyPortSubtypeTuningOverride", "found Headphone ReverbSuppressor aupreset:%s for %s", (const char *)buf, "(UL-)ReverbSuppressor");
      }
      std::string::basic_string[abi:ne180100]<0>(v51, "(UL-)ReverbSuppressor");
      v54 = (__int128 *)v51;
      v39 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)this + 4616, v51, (uint64_t)&std::piecewise_construct, &v54);
      std::string::__assign_external((std::string *)(v39 + 40), (const std::string::value_type *)buf);
      if ((v51[23] & 0x80000000) != 0)
        operator delete(*(void **)v51);
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v40 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v41 = (*v40 ? *v40 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v51 = 136315906;
          *(_QWORD *)&v51[4] = "VoiceProcessor_v6.cpp";
          *(_WORD *)&v51[12] = 1024;
          *(_DWORD *)&v51[14] = 1195;
          *(_WORD *)&v51[18] = 2080;
          *(_QWORD *)&v51[20] = buf;
          v52 = 2080;
          v53 = "(UL-)ReverbSuppressor";
          _os_log_impl(&dword_1B5ED0000, v41, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> : failed to load Headphone EQ tuning aupreset:%s for %s", v51, 0x26u);
        }
      }
      v42 = (int *)*((_QWORD *)this + 1570);
      if (v42 && (*v4 || v4[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v42, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1195, "ApplyPortSubtypeTuningOverride", ": failed to load Headphone EQ tuning aupreset:%s for %s", (const char *)buf, "(UL-)ReverbSuppressor");
      }
    }
    return 0;
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v30 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
  {
    v31 = (*v30 ? *v30 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v32 = (_QWORD *)((char *)this + 8);
      if (*((char *)this + 31) < 0)
        v32 = (_QWORD *)*v32;
      *(_DWORD *)v51 = 136315906;
      *(_QWORD *)&v51[4] = "VoiceProcessor_v6.cpp";
      *(_WORD *)&v51[12] = 1024;
      *(_DWORD *)&v51[14] = 1180;
      *(_WORD *)&v51[18] = 2080;
      *(_QWORD *)&v51[20] = v32;
      v52 = 2080;
      v53 = (const char *)buf;
      _os_log_impl(&dword_1B5ED0000, v31, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> : failed to find Headphone ReverbSuppressor aupreset: %s/Generic/Headphones/%s", v51, 0x26u);
    }
  }
  v33 = (int *)*((_QWORD *)this + 1570);
  if (v33 && (*v4 || v4[1]))
  {
    if (VPLogScope(void)::once != -1)
    {
      v45 = (int *)*((_QWORD *)this + 1570);
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v33 = v45;
    }
    v34 = (char *)this + 8;
    if (*((char *)this + 31) < 0)
      v34 = *(const char **)v34;
    CALegacyLog::log(v33, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1180, "ApplyPortSubtypeTuningOverride", ": failed to find Headphone ReverbSuppressor aupreset: %s/Generic/Headphones/%s", v34, (const char *)buf);
  }
  return TuningInSubdirs;
}

void sub_1B6533EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t VoiceProcessorV6::SetChatFlavor(uint64_t a1, int a2)
{
  _DWORD *v2;
  _BYTE *v5;
  uint64_t v6;
  int v7;
  unsigned int *v8;
  unsigned int v9;
  int ChatFlavor;
  _QWORD *v11;
  NSObject *v12;
  int v13;
  int *v14;
  _QWORD *v15;
  NSObject *v16;
  int *v17;
  double v18;
  double v19;
  _QWORD *v20;
  NSObject *v21;
  int *v22;
  _QWORD *v23;
  NSObject *v24;
  int *v25;
  unsigned int v26;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v2 = (_DWORD *)(a1 + 16536);
  if (*(_DWORD *)(a1 + 16536) != a2)
  {
    v5 = (_BYTE *)(a1 + 15897);
    v6 = a1 + 2392;
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 2392) + 16))(a1 + 2392);
    v8 = (unsigned int *)(a1 + 2480);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
    while (*(_DWORD *)(a1 + 2484))
      usleep(0x1F4u);
    ChatFlavor = VoiceProcessorV2::GetChatFlavor((VoiceProcessorV2 *)a1);
    *v2 = a2;
    if (*v5)
      VoiceProcessorV2::PListWriteSetPropertyParameters((VoiceProcessorV2 *)a1, 1718384242);
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v11 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      v12 = (*v11 ? *v11 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = *v2;
        *(_DWORD *)buf = 136315650;
        v29 = "VoiceProcessor_v6.cpp";
        v30 = 1024;
        v31 = 1220;
        v32 = 1024;
        v33 = v13;
        _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> VP chat flavor set to %u", buf, 0x18u);
      }
    }
    v14 = *(int **)(a1 + 12560);
    if (v14 && (*v5 || v5[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      CALegacyLog::log(v14, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1220, "SetChatFlavor", "VP chat flavor set to %u", *v2);
    }
    if (*v2)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v15 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v16 = (*v15 ? *v15 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          v29 = "VoiceProcessor_v6.cpp";
          v30 = 1024;
          v31 = 1223;
          _os_log_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Forcing bypass to false due to chat flavor", buf, 0x12u);
        }
      }
      v17 = *(int **)(a1 + 12560);
      if (v17 && (*v5 || v5[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v17, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1223, "SetChatFlavor", "Forcing bypass to false due to chat flavor");
      }
      *(_BYTE *)(a1 + 472) = 0;
    }
    if (VoiceProcessorV2::GetChatFlavor((VoiceProcessorV2 *)a1) != ChatFlavor)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v20 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v21 = (*v20 ? *v20 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          v29 = "VoiceProcessor_v6.cpp";
          v30 = 1024;
          v31 = 1230;
          _os_log_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Begin self-reinit (SetChatFlavor)", buf, 0x12u);
        }
      }
      v22 = *(int **)(a1 + 12560);
      if (v22 && (*v5 || v5[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v22, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1230, "SetChatFlavor", "Begin self-reinit (SetChatFlavor)");
      }
      VoiceProcessorV2::ResetTimestampsAndInitializeVP((VoiceProcessorV2 *)a1, 1, v18, v19);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v23 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v24 = (*v23 ? *v23 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          v29 = "VoiceProcessor_v6.cpp";
          v30 = 1024;
          v31 = 1232;
          _os_log_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> End self-reinit (SetChatFlavor)", buf, 0x12u);
        }
      }
      v25 = *(int **)(a1 + 12560);
      if (v25 && (*v5 || v5[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v25, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1232, "SetChatFlavor", "End self-reinit (SetChatFlavor)");
      }
    }
    do
      v26 = __ldaxr(v8);
    while (__stlxr(v26 - 1, v8));
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  }
  return 0;
}

void sub_1B6534524(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t VoiceProcessorV6::CalculateSupportedChatflavors(uint64_t this)
{
  _QWORD *v1;
  unint64_t v2;
  uint64_t v3;

  v1 = (_QWORD *)this;
  v2 = *(_QWORD *)(this + 16544) & 0xFFFFFFFFFFFFFFF8;
  if (*(_BYTE *)(this + 16568))
  {
    v3 = v2 | 1;
LABEL_5:
    v1[2068] = v3;
    return this;
  }
  if (*(_BYTE *)(this + 2246))
  {
    v3 = v2 | 4;
    goto LABEL_5;
  }
  *(_QWORD *)(this + 16544) = v2 | 1;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)this + 736))(this)
    && (*(unsigned int (**)(_QWORD *))(*v1 + 728))(v1))
  {
    v1[2068] |= 4uLL;
  }
  this = (*(uint64_t (**)(_QWORD *))(*v1 + 752))(v1);
  if ((_DWORD)this)
  {
    this = (*(uint64_t (**)(_QWORD *))(*v1 + 744))(v1);
    if ((_DWORD)this)
    {
      v3 = v1[2068] | 2;
      goto LABEL_5;
    }
  }
  return this;
}

vp *VoiceProcessorV6::GetRequestedChatFlavor(VoiceProcessorV6 *this, const applesauce::CF::StringRef *a2)
{
  vp *result;

  result = (vp *)*((_QWORD *)this + 2069);
  if (result)
    return vp::GetRequestedChatFlavorForBundleID(result, a2);
  return result;
}

uint64_t VoiceProcessorV6::IsAutomaticChatFlavorEnabled(VoiceProcessorV6 *this, const applesauce::CF::StringRef *a2)
{
  if (*((_QWORD *)this + 2069))
    return vp::IsAutomaticChatFlavorEnabledForBundleID((VoiceProcessorV6 *)((char *)this + 16552), a2);
  else
    return 0;
}

void VoiceProcessorV6::UpdateMicrophoneModeUIModule(VoiceProcessorV6 *this, char a2, const applesauce::CF::StringRef *a3)
{
  unsigned int v3;
  char v4;
  _DWORD *v6;
  char *v7;
  uint64_t v8;
  _QWORD *v9;
  NSObject *v10;
  int *v11;
  _DWORD *v12;
  CFArrayRef v13;
  const applesauce::CF::StringRef *v14;
  _QWORD *v15;
  NSObject *v16;
  const __CFString *v17;
  void *v18;
  int *v19;
  uint64_t v20;
  const __CFString *v21;
  uint8_t *v22;
  _QWORD *v23;
  NSObject *v24;
  int *v25;
  _DWORD *v26;
  uint64_t v27;
  _DWORD *v28;
  _BYTE *v29;
  char *v30;
  _DWORD *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  _DWORD *v36;
  int v37;
  _QWORD *v38;
  NSObject *v39;
  int *v40;
  vp *v41;
  const applesauce::CF::StringRef *v42;
  _QWORD *v43;
  NSObject *v44;
  const __CFString *v45;
  void **v46;
  int *v47;
  uint64_t v48;
  const __CFString *v49;
  uint8_t *v50;
  CFArrayRef CFArray;
  const applesauce::CF::StringRef *v52;
  _QWORD *v53;
  NSObject *v54;
  const __CFString *v55;
  void *p_p;
  int *v57;
  uint64_t v58;
  const __CFString *v59;
  uint8_t *v60;
  _QWORD *v61;
  NSObject *v62;
  int *v63;
  char v64;
  void *v65[2];
  char v66;
  vp *v67;
  void *__p;
  _BYTE *v69;
  _DWORD *v70;
  uint8_t buf[40];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v3 = *((_DWORD *)this + 19);
  if (v3 > 6)
    return;
  v4 = a2;
  v6 = (_DWORD *)((char *)this + 16540);
  v7 = (char *)this + 15897;
  if (((1 << v3) & 0x57) != 0)
  {
    if ((a2 & 1) != 0)
      vp::SetVoiceProcessingBypassedForBundleID((vp *)*((unsigned __int8 *)this + 472), *((_QWORD *)this + 2069), a3);
    if ((v4 & 2) != 0)
    {
      if (VoiceProcessorV2::GetChatFlavor(this) == 2 && (*((_BYTE *)this + 16544) & 4) != 0)
      {
        v8 = 2;
      }
      else if (VoiceProcessorV2::GetChatFlavor(this) == 1)
      {
        v8 = (*((_DWORD *)this + 4136) >> 1) & 1;
      }
      else
      {
        v8 = 0;
      }
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v23 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v24 = (*v23 ? *v23 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1371;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v8;
          _os_log_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Setting active chat flavor to value %d", buf, 0x18u);
        }
      }
      v25 = (int *)*((_QWORD *)this + 1570);
      if (v25 && (*v7 || v7[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v25, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1371, "UpdateMicrophoneModeUIModule", "Setting active chat flavor to value %d", v8);
      }
      vp::SetActiveChatFlavorForBundleID((_anonymous_namespace_ *)v8, *((_QWORD *)this + 2069));
      if ((_DWORD)v8 != *v6)
        *v6 = v8;
    }
    if ((v4 & 4) == 0)
    {
LABEL_141:
      if ((v4 & 8) != 0)
      {
        memset(buf, 0, 24);
        CFArray = applesauce::CF::details::make_CFArrayRef<int>((int **)buf);
        v65[0] = CFArray;
        vp::SetHiddenChatFlavorsForBundleID(CFArray, *((const applesauce::CF::ArrayRef **)this + 2069), v52);
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v53 = (_QWORD *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
        {
          v54 = (*v53 ? *v53 : MEMORY[0x1E0C81028]);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            v55 = CFCopyDescription(CFArray);
            applesauce::CF::details::CFString_get_value<true>(v55, (uint64_t)&__p);
            if (v55)
              CFRelease(v55);
            p_p = &__p;
            if (SHIBYTE(v70) < 0)
              p_p = __p;
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1400;
            *(_WORD *)&buf[18] = 2080;
            *(_QWORD *)&buf[20] = p_p;
            _os_log_impl(&dword_1B5ED0000, v54, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Hidden chat flavors contain values : %s", buf, 0x1Cu);
            if (SHIBYTE(v70) < 0)
              operator delete(__p);
          }
        }
        v57 = (int *)*((_QWORD *)this + 1570);
        if (v57 && (*v7 || v7[1]))
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v58 = VPLogScope(void)::scope;
          v59 = CFCopyDescription(CFArray);
          applesauce::CF::details::CFString_get_value<true>(v59, (uint64_t)buf);
          if (v59)
            CFRelease(v59);
          v60 = buf;
          if ((buf[23] & 0x80u) != 0)
            v60 = *(uint8_t **)buf;
          CALegacyLog::log(v57, 3, v58, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1400, "UpdateMicrophoneModeUIModule", "Hidden chat flavors contain values : %s", (const char *)v60);
          if ((char)buf[23] < 0)
          {
            operator delete(*(void **)buf);
            if (!CFArray)
              goto LABEL_168;
            goto LABEL_167;
          }
        }
        if (CFArray)
LABEL_167:
          CFRelease(CFArray);
      }
LABEL_168:
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v61 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v62 = (*v61 ? *v61 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1403;
          _os_log_impl(&dword_1B5ED0000, v62, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Updated MicrophoneModeUIModule", buf, 0x12u);
        }
      }
      v63 = (int *)*((_QWORD *)this + 1570);
      if (v63 && (*v7 || v7[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v63, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1403, "UpdateMicrophoneModeUIModule", "Updated MicrophoneModeUIModule");
      }
      return;
    }
    v64 = v4;
    v26 = operator new(0xCuLL);
    v27 = 0;
    v28 = v26 + 3;
    __p = v26;
    v69 = v26;
    v70 = v26 + 3;
    v29 = v26;
    v30 = v7;
    do
    {
      if (((*((_QWORD *)this + 2068) >> v27) & 1) != 0)
      {
        if (v26 >= v28)
        {
          v32 = ((char *)v26 - v29) >> 2;
          v33 = v32 + 1;
          if ((unint64_t)(v32 + 1) >> 62)
          {
            v70 = v28;
            __p = v29;
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          }
          if (((char *)v28 - v29) >> 1 > v33)
            v33 = ((char *)v28 - v29) >> 1;
          if ((unint64_t)((char *)v28 - v29) >= 0x7FFFFFFFFFFFFFFCLL)
            v34 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v34 = v33;
          if (v34)
            v34 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(v34);
          else
            v35 = 0;
          v36 = (_DWORD *)(v34 + 4 * v32);
          *v36 = v27;
          v31 = v36 + 1;
          while (v26 != (_DWORD *)v29)
          {
            v37 = *--v26;
            *--v36 = v37;
          }
          v28 = (_DWORD *)(v34 + 4 * v35);
          v69 = v31;
          if (v29)
            operator delete(v29);
          v29 = v36;
          v7 = v30;
        }
        else
        {
          *v26 = v27;
          v31 = v26 + 1;
        }
        v69 = v31;
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v38 = (_QWORD *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
        {
          v39 = (*v38 ? *v38 : MEMORY[0x1E0C81028]);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1386;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v27;
            _os_log_impl(&dword_1B5ED0000, v39, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Supported chat flavors contain value %d", buf, 0x18u);
          }
        }
        v40 = (int *)*((_QWORD *)this + 1570);
        if (v40 && (*v7 || v7[1]))
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          CALegacyLog::log(v40, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1386, "UpdateMicrophoneModeUIModule", "Supported chat flavors contain value %d", v27);
        }
      }
      else
      {
        v31 = v26;
      }
      ++v27;
      v26 = v31;
    }
    while (v27 != 3);
    v70 = v28;
    __p = v29;
    v41 = applesauce::CF::details::make_CFArrayRef<int>((int **)&__p);
    v67 = v41;
    vp::SetSupportedChatFlavorsForBundleID(v41, *((const applesauce::CF::ArrayRef **)this + 2069), v42);
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v43 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      v44 = (*v43 ? *v43 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        v45 = CFCopyDescription(v41);
        applesauce::CF::details::CFString_get_value<true>(v45, (uint64_t)v65);
        if (v45)
          CFRelease(v45);
        v46 = v65;
        if (v66 < 0)
          v46 = (void **)v65[0];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1392;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v46;
        _os_log_impl(&dword_1B5ED0000, v44, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Supported chat flavors contain values : %s", buf, 0x1Cu);
        if (v66 < 0)
          operator delete(v65[0]);
      }
    }
    v47 = (int *)*((_QWORD *)this + 1570);
    if (!v47 || !*v7 && !v7[1])
      goto LABEL_137;
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v48 = VPLogScope(void)::scope;
    v49 = CFCopyDescription(v41);
    applesauce::CF::details::CFString_get_value<true>(v49, (uint64_t)buf);
    if (v49)
      CFRelease(v49);
    v50 = buf;
    if ((buf[23] & 0x80u) != 0)
      v50 = *(uint8_t **)buf;
    CALegacyLog::log(v47, 3, v48, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1392, "UpdateMicrophoneModeUIModule", "Supported chat flavors contain values : %s", (const char *)v50);
    if ((char)buf[23] < 0)
    {
      operator delete(*(void **)buf);
      if (!v41)
      {
LABEL_139:
        v4 = v64;
        if (v29)
        {
          v69 = v29;
          operator delete(v29);
        }
        goto LABEL_141;
      }
    }
    else
    {
LABEL_137:
      if (!v41)
        goto LABEL_139;
    }
    CFRelease(v41);
    goto LABEL_139;
  }
  if (v3 == 5)
  {
    if ((a2 & 2) != 0)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v9 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v10 = (*v9 ? *v9 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1410;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = 0;
          _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Setting active chat flavor to value %d", buf, 0x18u);
        }
      }
      v11 = (int *)*((_QWORD *)this + 1570);
      if (v11 && (*v7 || v7[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v11, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1410, "UpdateMicrophoneModeUIModule", "Setting active chat flavor to value %d", 0);
      }
      vp::SetActiveChatFlavorForBundleID(0, *((_QWORD *)this + 2069));
      if (*v6)
        *v6 = 0;
    }
    if ((v4 & 4) != 0)
    {
      v12 = operator new(4uLL);
      *v12 = 0;
      *(_QWORD *)buf = v12;
      *(_QWORD *)&buf[16] = v12 + 1;
      *(_QWORD *)&buf[8] = v12 + 1;
      v13 = applesauce::CF::details::make_CFArrayRef<int>((int **)buf);
      v65[0] = v13;
      operator delete(v12);
      vp::SetSupportedChatFlavorsForBundleID(v13, *((const applesauce::CF::ArrayRef **)this + 2069), v14);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v15 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v16 = (*v15 ? *v15 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = CFCopyDescription(v13);
          applesauce::CF::details::CFString_get_value<true>(v17, (uint64_t)&__p);
          if (v17)
            CFRelease(v17);
          v18 = &__p;
          if (SHIBYTE(v70) < 0)
            v18 = __p;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1423;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v18;
          _os_log_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Supported chat flavors contain values : %s", buf, 0x1Cu);
          if (SHIBYTE(v70) < 0)
            operator delete(__p);
        }
      }
      v19 = (int *)*((_QWORD *)this + 1570);
      if (v19 && (*v7 || v7[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v20 = VPLogScope(void)::scope;
        v21 = CFCopyDescription(v13);
        applesauce::CF::details::CFString_get_value<true>(v21, (uint64_t)buf);
        if (v21)
          CFRelease(v21);
        v22 = buf;
        if ((buf[23] & 0x80u) != 0)
          v22 = *(uint8_t **)buf;
        CALegacyLog::log(v19, 3, v20, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1423, "UpdateMicrophoneModeUIModule", "Supported chat flavors contain values : %s", (const char *)v22);
        if ((char)buf[23] < 0)
          operator delete(*(void **)buf);
      }
      if (v13)
        CFRelease(v13);
    }
  }
}

void sub_1B653534C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV6::RegisterChatFlavorNotificationListener(VoiceProcessorV6 *this)
{
  _QWORD *v2;
  NSObject *v3;
  void **v4;
  int *v5;
  uint64_t v6;
  const char *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  uint64_t *p_shared_weak_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  std::runtime_error *v17;
  std::runtime_error *v18;
  std::runtime_error *exception;
  void *__p[2];
  char v21;
  CFTypeRef cf;
  uint64_t v23;
  std::__shared_weak_count *v24;
  _QWORD v25[3];
  _QWORD *v26;
  _BYTE buf[12];
  __int16 v28;
  int v29;
  __int16 v30;
  void **v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  caulk::details::lifetime_guard_base<VoiceProcessorV2>::weak_T_ptr(&v23, *((_QWORD *)this + 2075), *((std::__shared_weak_count **)this + 2077));
  vp::GetAVAUVoiceIOPreferredChatFlavorDidChangeNotificationName((vp *)&cf);
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v2 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v3 = (*v2 ? *v2 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      if (!cf)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)__p);
      if (v21 >= 0)
        v4 = __p;
      else
        v4 = (void **)__p[0];
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
      v28 = 1024;
      v29 = 1278;
      v30 = 2080;
      v31 = v4;
      _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> ChatFlavor notification name is %s", buf, 0x1Cu);
      if (v21 < 0)
        operator delete(__p[0]);
    }
  }
  v5 = (int *)*((_QWORD *)this + 1570);
  if (v5 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    if (!cf)
    {
      v18 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v18, "Could not construct");
    }
    v6 = VPLogScope(void)::scope;
    applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)buf);
    if (SBYTE3(v31) >= 0)
      v7 = buf;
    else
      v7 = *(const char **)buf;
    CALegacyLog::log(v5, 3, v6, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1278, "RegisterChatFlavorNotificationListener", "ChatFlavor notification name is %s", v7);
    if (SBYTE3(v31) < 0)
      operator delete(*(void **)buf);
  }
  if (!cf)
  {
    v17 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v17, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)buf);
  v9 = v23;
  v8 = v24;
  if (v24)
  {
    p_shared_weak_owners = &v24->__shared_weak_owners_;
    do
      v11 = __ldxr((unint64_t *)p_shared_weak_owners);
    while (__stxr(v11 + 1, (unint64_t *)p_shared_weak_owners));
  }
  v25[0] = &off_1E69E8E00;
  v25[1] = v9;
  v25[2] = v8;
  v26 = v25;
  vp::CFNotificationDelegate::createDelegate((uint64_t **)__p, (uint64_t)buf, v25);
  std::shared_ptr<vp::xml::_xmlNode const>::operator=[abi:ne180100]((uint64_t)this + 17288, (__int128 *)__p);
  v12 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v13 = (unint64_t *)((char *)__p[1] + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = v26;
  if (v26 == v25)
  {
    v16 = 4;
    v15 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_40;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_40:
  if (SBYTE3(v31) < 0)
    operator delete(*(void **)buf);
  if (cf)
    CFRelease(cf);
  if (v24)
    std::__shared_weak_count::__release_weak(v24);
}

void sub_1B6535864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, uint64_t a15, std::__shared_weak_count *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  void *v26;

  __cxa_free_exception(v26);
  applesauce::CF::StringRef::~StringRef(&a14);
  if (a16)
    std::__shared_weak_count::__release_weak(a16);
  _Unwind_Resume(a1);
}

void VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(VoiceProcessorV6 *this)
{
  const __CFString *v2;
  _QWORD *v3;
  NSObject *v4;
  void **v5;
  int *v6;
  uint64_t v7;
  const char *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t *p_shared_weak_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  void *__p[2];
  char v19;
  CFTypeRef cf;
  uint64_t v21;
  std::__shared_weak_count *v22;
  _QWORD v23[3];
  _QWORD *v24;
  _BYTE buf[12];
  __int16 v26;
  int v27;
  __int16 v28;
  void **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  caulk::details::lifetime_guard_base<VoiceProcessorV2>::weak_T_ptr(&v21, *((_QWORD *)this + 2075), *((std::__shared_weak_count **)this + 2077));
  vp::GetAVAUVoiceIOAutomaticChatFlavorDidChangeNotificationName((vp *)&cf);
  v2 = (const __CFString *)cf;
  if (!cf)
    goto LABEL_42;
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v3 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v4 = (*v3 ? *v3 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      applesauce::CF::convert_to<std::string,0>(v2, (uint64_t)__p);
      v5 = v19 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "VoiceProcessor_v6.cpp";
      v26 = 1024;
      v27 = 1297;
      v28 = 2080;
      v29 = v5;
      _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> AutomaticChatFlavorEnabled notification name is %s", buf, 0x1Cu);
      if (v19 < 0)
        operator delete(__p[0]);
    }
  }
  v6 = (int *)*((_QWORD *)this + 1570);
  if (v6 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v7 = VPLogScope(void)::scope;
    applesauce::CF::convert_to<std::string,0>(v2, (uint64_t)buf);
    if (SBYTE3(v29) >= 0)
      v8 = buf;
    else
      v8 = *(const char **)buf;
    CALegacyLog::log(v6, 3, v7, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 1297, "RegisterEnableAutomaticChatFlavorNotificationListener", "AutomaticChatFlavorEnabled notification name is %s", v8);
    if (SBYTE3(v29) < 0)
      operator delete(*(void **)buf);
  }
  applesauce::CF::convert_to<std::string,0>(v2, (uint64_t)buf);
  v10 = v21;
  v9 = v22;
  if (v22)
  {
    p_shared_weak_owners = &v22->__shared_weak_owners_;
    do
      v12 = __ldxr((unint64_t *)p_shared_weak_owners);
    while (__stxr(v12 + 1, (unint64_t *)p_shared_weak_owners));
  }
  v23[0] = &off_1E69E8E48;
  v23[1] = v10;
  v23[2] = v9;
  v24 = v23;
  vp::CFNotificationDelegate::createDelegate((uint64_t **)__p, (uint64_t)buf, v23);
  std::shared_ptr<vp::xml::_xmlNode const>::operator=[abi:ne180100]((uint64_t)this + 17304, (__int128 *)__p);
  v13 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v14 = (unint64_t *)((char *)__p[1] + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v24;
  if (v24 == v23)
  {
    v17 = 4;
    v16 = v23;
    goto LABEL_37;
  }
  if (v24)
  {
    v17 = 5;
LABEL_37:
    (*(void (**)(void))(*v16 + 8 * v17))();
  }
  if (SBYTE3(v29) < 0)
    operator delete(*(void **)buf);
  if (cf)
    CFRelease(cf);
LABEL_42:
  if (v22)
    std::__shared_weak_count::__release_weak(v22);
}

void sub_1B6535C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, uint64_t a15, std::__shared_weak_count *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  applesauce::CF::StringRef::~StringRef(&a14);
  if (a16)
    std::__shared_weak_count::__release_weak(a16);
  _Unwind_Resume(a1);
}

uint64_t VoiceProcessorV6::IsInGenericVoiceIsolationMode(VoiceProcessorV6 *this)
{
  return 0;
}

void VoiceProcessorV6::ApplyCustomTelephonyDSPOverrides(int8x16_t *this, CFDictionaryRef theDict, int a3)
{
  const __CFNumber *Value;
  const __CFNumber *v7;
  uint64_t v8;
  const __CFNumber *v9;
  const __CFNumber *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  __int8 *v17;
  float v18;
  int v19;
  const __CFArray *v20;
  const __CFArray *v21;
  unsigned int Count;
  uint64_t v23;
  int8x16_t *v24;
  uint64_t v25;
  uint64_t v26;
  CFIndex v27;
  __int8 *v28;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  const __CFNumber *v35;
  const __CFNumber *v36;
  const void *v37;
  float valuePtr;

  if (theDict && CFDictionaryGetCount(theDict))
  {
    if (a3)
    {
      if (CFDictionaryContainsKey(theDict, CFSTR("noise suppression")))
      {
        Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("noise suppression"));
        if (Value)
        {
          v7 = Value;
          CFRetain(Value);
          valuePtr = 0.0;
          CFNumberGetValue(v7, kCFNumberFloat32Type, &valuePtr);
          CFRelease(v7);
          v8 = this[291].i64[0];
          this[291].i64[1] |= 0x10uLL;
          this[291].i64[0] = v8 & 0xFF5FFFFFFFFFFFFFLL | 0x20000000000000;
          AUPropAndParamHelper::AddItemToAUParamList((uint64_t)&this[372].i64[1], 0, valuePtr);
        }
      }
      if (CFDictionaryContainsKey(theDict, CFSTR("agc")))
      {
        v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("agc"));
        if (v9)
        {
          v10 = v9;
          CFRetain(v9);
          valuePtr = 0.0;
          CFNumberGetValue(v10, kCFNumberIntType, &valuePtr);
          CFRelease(v10);
          v11 = this[291].i64[1];
          v12 = v11 & 0xFFFFFFFFFFFFFFFDLL;
          v13 = v11 | 0x12;
          if (LODWORD(valuePtr) == 1)
            v14 = v13;
          else
            v14 = v12;
          this[291].i64[1] = v14;
        }
      }
    }
    if (CFDictionaryContainsKey(theDict, CFSTR("gain")))
    {
      v15 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("gain"));
      if (v15)
      {
        v16 = v15;
        CFRetain(v15);
        valuePtr = 0.0;
        CFNumberGetValue(v16, kCFNumberFloat32Type, &valuePtr);
        CFRelease(v16);
        if (a3)
        {
          this[291] = vorrq_s8(this[291], (int8x16_t)xmmword_1B66A0610);
          v17 = &this[436].i8[8];
          v18 = valuePtr;
          v19 = 1;
        }
        else
        {
          this[552].i64[0] |= 0x800800000000000uLL;
          AUPropAndParamHelper::AddItemToAUParamList((uint64_t)&this[678].i64[1], 0, valuePtr);
          v18 = valuePtr;
          v17 = &this[678].i8[8];
          v19 = 8;
        }
        AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v17, v19, v18);
      }
    }
    if (CFDictionaryContainsKey(theDict, CFSTR("eq")))
    {
      v20 = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("eq"));
      if (v20)
      {
        v21 = v20;
        CFRetain(v20);
        Count = CFArrayGetCount(v21);
        v23 = 9640;
        if (a3)
        {
          v23 = 6200;
          this[291].i64[0] |= 0x8000000000000000;
          v24 = (int8x16_t *)((char *)this + 4664);
          v25 = 16;
        }
        else
        {
          v24 = this + 552;
          v25 = 0x800200000000;
        }
        v24->i64[0] |= v25;
        if (Count >= 0xA)
          v26 = 10;
        else
          v26 = Count;
        if ((_DWORD)v26)
        {
          v27 = 0;
          v28 = &this->i8[v23];
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v21, v27);
            if (ValueAtIndex)
            {
              v30 = ValueAtIndex;
              CFRetain(ValueAtIndex);
              if (CFDictionaryContainsKey(v30, CFSTR("AUNBandEQ_FilterType"))
                && CFDictionaryContainsKey(v30, CFSTR("AUNBandEQ_FilterFrequency")))
              {
                AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 1000, 0.0);
                v31 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("AUNBandEQ_FilterType"));
                if (v31)
                {
                  v32 = v31;
                  CFRetain(v31);
                  valuePtr = 0.0;
                  CFNumberGetValue(v32, kCFNumberIntType, &valuePtr);
                  CFRelease(v32);
                  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 2000, (float)LODWORD(valuePtr));
                }
                v33 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("AUNBandEQ_FilterFrequency"));
                if (v33)
                {
                  v34 = v33;
                  CFRetain(v33);
                  valuePtr = 0.0;
                  CFNumberGetValue(v34, kCFNumberFloat32Type, &valuePtr);
                  CFRelease(v34);
                  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 3000, valuePtr);
                }
              }
              if (CFDictionaryContainsKey(v30, CFSTR("AUNBandEQ_FilterGain")))
              {
                v35 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("AUNBandEQ_FilterGain"));
                if (v35)
                {
                  v36 = v35;
                  CFRetain(v35);
                  valuePtr = 0.0;
                  CFNumberGetValue(v36, kCFNumberFloat32Type, &valuePtr);
                  CFRelease(v36);
                  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 4000, valuePtr);
                }
              }
              if (CFDictionaryContainsKey(v30, CFSTR("AUNBandEQ_FilterBandwidth")))
              {
                v37 = CFDictionaryGetValue(v30, CFSTR("AUNBandEQ_FilterBandwidth"));
                CFRetain(v37);
                valuePtr = 0.0;
                CFNumberGetValue((CFNumberRef)v37, kCFNumberFloat32Type, &valuePtr);
                CFRelease(v37);
                AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 5000, valuePtr);
              }
              CFRelease(v30);
            }
            ++v27;
          }
          while (v26 != v27);
        }
        CFRelease(v21);
      }
    }
  }
}

Float64 VoiceProcessorV6::CorrectDownlinkTimeStamp@<D0>(VoiceProcessorV6 *this@<X0>, const AudioTimeStamp *a2@<X1>, Float64 *a3@<X8>)
{
  __int128 v3;
  __int128 v4;
  Float64 result;

  v3 = *(_OWORD *)&a2->mRateScalar;
  *(_OWORD *)a3 = *(_OWORD *)&a2->mSampleTime;
  *((_OWORD *)a3 + 1) = v3;
  v4 = *(_OWORD *)&a2->mSMPTETime.mHours;
  *((_OWORD *)a3 + 2) = *(_OWORD *)&a2->mSMPTETime.mSubframes;
  *((_OWORD *)a3 + 3) = v4;
  result = a2->mSampleTime + (double)*((int *)this + 295);
  *a3 = result;
  return result;
}

uint64_t VoiceProcessorV6::SetupECApplicator(VoiceProcessorV6 *this)
{
  ECApplicator **v2;
  ECApplicator **v3;
  ECApplicator *v4;
  ECApplicator **v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  ECApplicator **v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  ECApplicator *v18;
  int64x2_t v19;
  ECApplicator *v20;
  unint64_t v21;
  ECApplicator *v22;
  ECApplicator **v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  ECApplicator **v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  ECApplicator *v36;
  int64x2_t v37;
  ECApplicator *v38;
  unint64_t v39;
  ECApplicator *v40;
  ECApplicator **v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  ECApplicator **v49;
  unint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  ECApplicator *v54;
  int64x2_t v55;
  ECApplicator *v56;
  unint64_t v57;
  ECApplicator *v58;
  ECApplicator **v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  ECApplicator **v67;
  unint64_t v68;
  _QWORD *v69;
  _QWORD *v70;
  _QWORD *v71;
  ECApplicator *v72;
  int64x2_t v73;
  ECApplicator *v74;
  unint64_t v75;
  ECApplicator *v76;
  ECApplicator **v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  ECApplicator **v85;
  unint64_t v86;
  _QWORD *v87;
  _QWORD *v88;
  _QWORD *v89;
  ECApplicator *v90;
  int64x2_t v91;
  ECApplicator *v92;
  unint64_t v93;
  ECApplicator *v94;
  ECApplicator **v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  ECApplicator **v103;
  unint64_t v104;
  _QWORD *v105;
  _QWORD *v106;
  _QWORD *v107;
  ECApplicator *v108;
  int64x2_t v109;
  ECApplicator *v110;
  unint64_t v111;
  AudioBufferList *v112;
  uint64_t *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t result;
  uint64_t v121;
  AudioBufferList **v122[6];
  AudioBufferList *v123[2];
  AudioBufferList **v124[6];
  AudioBufferList *v125[2];
  AudioBufferList **v126[6];
  AudioBufferList *v127[2];
  AudioBufferList **v128[6];
  AudioBufferList *v129[2];
  AudioBufferList **v130[6];
  AudioBufferList *v131[2];
  AudioBufferList **v132;
  int64x2_t v133;
  unint64_t v134;
  char *v135;
  uint64_t v136;
  AudioBufferList *v137[3];

  v137[2] = *(AudioBufferList **)MEMORY[0x1E0C80C00];
  v2 = (ECApplicator **)*((_QWORD *)this + 2099);
  v3 = (ECApplicator **)*((_QWORD *)this + 2098);
  while (v2 != v3)
    std::unique_ptr<ECApplicator>::reset[abi:ne180100](--v2);
  *((_QWORD *)this + 2099) = v3;
  v4 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v4, this, 21, 6);
  v130[0] = (AudioBufferList **)v4;
  v5 = (ECApplicator **)*((_QWORD *)this + 2099);
  v6 = *((_QWORD *)this + 2100);
  if ((unint64_t)v5 >= v6)
  {
    v7 = *((_QWORD *)this + 2098);
    v8 = ((uint64_t)v5 - v7) >> 3;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v10 = v6 - v7;
    if (v10 >> 2 > v9)
      v9 = v10 >> 2;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    v135 = (char *)this + 16800;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v11);
    else
      v12 = 0;
    v13 = (ECApplicator **)(v11 + 8 * v8);
    v14 = v11 + 8 * v12;
    v134 = v14;
    v130[0] = 0;
    *v13 = v4;
    v15 = v13 + 1;
    v133.i64[1] = (uint64_t)(v13 + 1);
    v16 = (_QWORD *)*((_QWORD *)this + 2099);
    v17 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v16 == v17)
    {
      v20 = 0;
      v19 = vdupq_n_s64((unint64_t)v16);
    }
    else
    {
      do
      {
        v18 = (ECApplicator *)*--v16;
        *v16 = 0;
        *--v13 = v18;
      }
      while (v16 != v17);
      v19 = *((int64x2_t *)this + 1049);
      v15 = (_QWORD *)v133.i64[1];
      v14 = v134;
      v20 = (ECApplicator *)v130[0];
    }
    *((_QWORD *)this + 2098) = v13;
    *((_QWORD *)this + 2099) = v15;
    v133 = v19;
    v21 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v14;
    v134 = v21;
    v132 = (AudioBufferList **)v19.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v132);
    *((_QWORD *)this + 2099) = v15;
    if (v20)
    {
      ECApplicator::~ECApplicator(v20);
      MEMORY[0x1BCC95CEC]();
    }
  }
  else
  {
    *v5 = v4;
    *((_QWORD *)this + 2099) = v5 + 1;
  }
  v22 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v22, this, 22, 6);
  v130[0] = (AudioBufferList **)v22;
  v23 = (ECApplicator **)*((_QWORD *)this + 2099);
  v24 = *((_QWORD *)this + 2100);
  if ((unint64_t)v23 >= v24)
  {
    v25 = *((_QWORD *)this + 2098);
    v26 = ((uint64_t)v23 - v25) >> 3;
    v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v28 = v24 - v25;
    if (v28 >> 2 > v27)
      v27 = v28 >> 2;
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
      v29 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v29 = v27;
    v135 = (char *)this + 16800;
    if (v29)
      v29 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v29);
    else
      v30 = 0;
    v31 = (ECApplicator **)(v29 + 8 * v26);
    v32 = v29 + 8 * v30;
    v134 = v32;
    v130[0] = 0;
    *v31 = v22;
    v33 = v31 + 1;
    v133.i64[1] = (uint64_t)(v31 + 1);
    v34 = (_QWORD *)*((_QWORD *)this + 2099);
    v35 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v34 == v35)
    {
      v38 = 0;
      v37 = vdupq_n_s64((unint64_t)v34);
    }
    else
    {
      do
      {
        v36 = (ECApplicator *)*--v34;
        *v34 = 0;
        *--v31 = v36;
      }
      while (v34 != v35);
      v37 = *((int64x2_t *)this + 1049);
      v33 = (_QWORD *)v133.i64[1];
      v32 = v134;
      v38 = (ECApplicator *)v130[0];
    }
    *((_QWORD *)this + 2098) = v31;
    *((_QWORD *)this + 2099) = v33;
    v133 = v37;
    v39 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v32;
    v134 = v39;
    v132 = (AudioBufferList **)v37.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v132);
    *((_QWORD *)this + 2099) = v33;
    if (v38)
    {
      ECApplicator::~ECApplicator(v38);
      MEMORY[0x1BCC95CEC]();
    }
  }
  else
  {
    *v23 = v22;
    *((_QWORD *)this + 2099) = v23 + 1;
  }
  v40 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v40, this, 23, 6);
  v130[0] = (AudioBufferList **)v40;
  v41 = (ECApplicator **)*((_QWORD *)this + 2099);
  v42 = *((_QWORD *)this + 2100);
  if ((unint64_t)v41 >= v42)
  {
    v43 = *((_QWORD *)this + 2098);
    v44 = ((uint64_t)v41 - v43) >> 3;
    v45 = v44 + 1;
    if ((unint64_t)(v44 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v46 = v42 - v43;
    if (v46 >> 2 > v45)
      v45 = v46 >> 2;
    if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8)
      v47 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v47 = v45;
    v135 = (char *)this + 16800;
    if (v47)
      v47 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v47);
    else
      v48 = 0;
    v49 = (ECApplicator **)(v47 + 8 * v44);
    v50 = v47 + 8 * v48;
    v134 = v50;
    v130[0] = 0;
    *v49 = v40;
    v51 = v49 + 1;
    v133.i64[1] = (uint64_t)(v49 + 1);
    v52 = (_QWORD *)*((_QWORD *)this + 2099);
    v53 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v52 == v53)
    {
      v56 = 0;
      v55 = vdupq_n_s64((unint64_t)v52);
    }
    else
    {
      do
      {
        v54 = (ECApplicator *)*--v52;
        *v52 = 0;
        *--v49 = v54;
      }
      while (v52 != v53);
      v55 = *((int64x2_t *)this + 1049);
      v51 = (_QWORD *)v133.i64[1];
      v50 = v134;
      v56 = (ECApplicator *)v130[0];
    }
    *((_QWORD *)this + 2098) = v49;
    *((_QWORD *)this + 2099) = v51;
    v133 = v55;
    v57 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v50;
    v134 = v57;
    v132 = (AudioBufferList **)v55.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v132);
    *((_QWORD *)this + 2099) = v51;
    if (v56)
    {
      ECApplicator::~ECApplicator(v56);
      MEMORY[0x1BCC95CEC]();
    }
  }
  else
  {
    *v41 = v40;
    *((_QWORD *)this + 2099) = v41 + 1;
  }
  v58 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v58, this, 24, 6);
  v130[0] = (AudioBufferList **)v58;
  v59 = (ECApplicator **)*((_QWORD *)this + 2099);
  v60 = *((_QWORD *)this + 2100);
  if ((unint64_t)v59 >= v60)
  {
    v61 = *((_QWORD *)this + 2098);
    v62 = ((uint64_t)v59 - v61) >> 3;
    v63 = v62 + 1;
    if ((unint64_t)(v62 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v64 = v60 - v61;
    if (v64 >> 2 > v63)
      v63 = v64 >> 2;
    if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8)
      v65 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v65 = v63;
    v135 = (char *)this + 16800;
    if (v65)
      v65 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v65);
    else
      v66 = 0;
    v67 = (ECApplicator **)(v65 + 8 * v62);
    v68 = v65 + 8 * v66;
    v134 = v68;
    v130[0] = 0;
    *v67 = v58;
    v69 = v67 + 1;
    v133.i64[1] = (uint64_t)(v67 + 1);
    v70 = (_QWORD *)*((_QWORD *)this + 2099);
    v71 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v70 == v71)
    {
      v74 = 0;
      v73 = vdupq_n_s64((unint64_t)v70);
    }
    else
    {
      do
      {
        v72 = (ECApplicator *)*--v70;
        *v70 = 0;
        *--v67 = v72;
      }
      while (v70 != v71);
      v73 = *((int64x2_t *)this + 1049);
      v69 = (_QWORD *)v133.i64[1];
      v68 = v134;
      v74 = (ECApplicator *)v130[0];
    }
    *((_QWORD *)this + 2098) = v67;
    *((_QWORD *)this + 2099) = v69;
    v133 = v73;
    v75 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v68;
    v134 = v75;
    v132 = (AudioBufferList **)v73.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v132);
    *((_QWORD *)this + 2099) = v69;
    if (v74)
    {
      ECApplicator::~ECApplicator(v74);
      MEMORY[0x1BCC95CEC]();
    }
  }
  else
  {
    *v59 = v58;
    *((_QWORD *)this + 2099) = v59 + 1;
  }
  v76 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v76, this, 25, 6);
  v130[0] = (AudioBufferList **)v76;
  v77 = (ECApplicator **)*((_QWORD *)this + 2099);
  v78 = *((_QWORD *)this + 2100);
  if ((unint64_t)v77 >= v78)
  {
    v79 = *((_QWORD *)this + 2098);
    v80 = ((uint64_t)v77 - v79) >> 3;
    v81 = v80 + 1;
    if ((unint64_t)(v80 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v82 = v78 - v79;
    if (v82 >> 2 > v81)
      v81 = v82 >> 2;
    if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8)
      v83 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v83 = v81;
    v135 = (char *)this + 16800;
    if (v83)
      v83 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v83);
    else
      v84 = 0;
    v85 = (ECApplicator **)(v83 + 8 * v80);
    v86 = v83 + 8 * v84;
    v134 = v86;
    v130[0] = 0;
    *v85 = v76;
    v87 = v85 + 1;
    v133.i64[1] = (uint64_t)(v85 + 1);
    v88 = (_QWORD *)*((_QWORD *)this + 2099);
    v89 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v88 == v89)
    {
      v92 = 0;
      v91 = vdupq_n_s64((unint64_t)v88);
    }
    else
    {
      do
      {
        v90 = (ECApplicator *)*--v88;
        *v88 = 0;
        *--v85 = v90;
      }
      while (v88 != v89);
      v91 = *((int64x2_t *)this + 1049);
      v87 = (_QWORD *)v133.i64[1];
      v86 = v134;
      v92 = (ECApplicator *)v130[0];
    }
    *((_QWORD *)this + 2098) = v85;
    *((_QWORD *)this + 2099) = v87;
    v133 = v91;
    v93 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v86;
    v134 = v93;
    v132 = (AudioBufferList **)v91.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v132);
    *((_QWORD *)this + 2099) = v87;
    if (v92)
    {
      ECApplicator::~ECApplicator(v92);
      MEMORY[0x1BCC95CEC]();
    }
  }
  else
  {
    *v77 = v76;
    *((_QWORD *)this + 2099) = v77 + 1;
  }
  v94 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v94, this, 26, 6);
  v130[0] = (AudioBufferList **)v94;
  v95 = (ECApplicator **)*((_QWORD *)this + 2099);
  v96 = *((_QWORD *)this + 2100);
  if ((unint64_t)v95 >= v96)
  {
    v97 = *((_QWORD *)this + 2098);
    v98 = ((uint64_t)v95 - v97) >> 3;
    v99 = v98 + 1;
    if ((unint64_t)(v98 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v100 = v96 - v97;
    if (v100 >> 2 > v99)
      v99 = v100 >> 2;
    if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF8)
      v101 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v101 = v99;
    v135 = (char *)this + 16800;
    if (v101)
      v101 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v101);
    else
      v102 = 0;
    v103 = (ECApplicator **)(v101 + 8 * v98);
    v104 = v101 + 8 * v102;
    v134 = v104;
    v130[0] = 0;
    *v103 = v94;
    v105 = v103 + 1;
    v133.i64[1] = (uint64_t)(v103 + 1);
    v106 = (_QWORD *)*((_QWORD *)this + 2099);
    v107 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v106 == v107)
    {
      v110 = 0;
      v109 = vdupq_n_s64((unint64_t)v106);
    }
    else
    {
      do
      {
        v108 = (ECApplicator *)*--v106;
        *v106 = 0;
        *--v103 = v108;
      }
      while (v106 != v107);
      v109 = *((int64x2_t *)this + 1049);
      v105 = (_QWORD *)v133.i64[1];
      v104 = v134;
      v110 = (ECApplicator *)v130[0];
    }
    *((_QWORD *)this + 2098) = v103;
    *((_QWORD *)this + 2099) = v105;
    v133 = v109;
    v111 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v104;
    v134 = v111;
    v132 = (AudioBufferList **)v109.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v132);
    *((_QWORD *)this + 2099) = v105;
    if (v110)
    {
      ECApplicator::~ECApplicator(v110);
      MEMORY[0x1BCC95CEC]();
    }
  }
  else
  {
    *v95 = v94;
    *((_QWORD *)this + 2099) = v95 + 1;
  }
  v112 = (AudioBufferList *)*((_QWORD *)this + 134);
  v137[0] = (AudioBufferList *)((char *)this + 16808);
  v137[1] = v112;
  v132 = (AudioBufferList **)((char *)this + 1088);
  v133.i64[0] = (uint64_t)this + 3344;
  v133.i64[1] = (uint64_t)this + 3384;
  v134 = 0;
  v135 = 0;
  v136 = 0;
  v131[0] = (AudioBufferList *)((char *)this + 16832);
  v131[1] = v112;
  v130[0] = (AudioBufferList **)((char *)this + 1088);
  v130[1] = (AudioBufferList **)((char *)this + 3352);
  v130[2] = (AudioBufferList **)((char *)this + 3392);
  memset(&v130[3], 0, 24);
  v129[0] = (AudioBufferList *)((char *)this + 16856);
  v129[1] = v112;
  v128[0] = (AudioBufferList **)((char *)this + 1088);
  v128[1] = (AudioBufferList **)((char *)this + 3368);
  v128[2] = (AudioBufferList **)((char *)this + 3400);
  memset(&v128[3], 0, 24);
  v127[0] = (AudioBufferList *)((char *)this + 16880);
  v127[1] = v112;
  v126[0] = (AudioBufferList **)((char *)this + 1088);
  v126[1] = (AudioBufferList **)((char *)this + 3360);
  v126[2] = (AudioBufferList **)((char *)this + 3408);
  memset(&v126[3], 0, 24);
  v125[0] = (AudioBufferList *)((char *)this + 16808);
  v125[1] = v112;
  v124[0] = (AudioBufferList **)((char *)this + 1088);
  v124[1] = (AudioBufferList **)((char *)this + 3376);
  v124[2] = (AudioBufferList **)((char *)this + 3416);
  v124[3] = (AudioBufferList **)((char *)this + 17072);
  v124[4] = (AudioBufferList **)((char *)this + 17080);
  v124[5] = (AudioBufferList **)((char *)this + 17088);
  v123[0] = (AudioBufferList *)((char *)this + 16832);
  v123[1] = v112;
  v122[0] = (AudioBufferList **)((char *)this + 1088);
  v122[1] = (AudioBufferList **)((char *)this + 17096);
  v122[2] = (AudioBufferList **)((char *)this + 17104);
  v122[3] = (AudioBufferList **)((char *)this + 17112);
  v122[4] = (AudioBufferList **)((char *)this + 17120);
  v122[5] = (AudioBufferList **)((char *)this + 17128);
  v113 = (uint64_t *)*((_QWORD *)this + 2098);
  if (*((uint64_t **)this + 2099) == v113)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  ECApplicator::setInputOutputABLs(*v113, v137, &v132);
  v114 = *((_QWORD *)this + 2098);
  if ((unint64_t)(*((_QWORD *)this + 2099) - v114) <= 8)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  ECApplicator::setInputOutputABLs(*(_QWORD *)(v114 + 8), v131, v130);
  v115 = *((_QWORD *)this + 2098);
  if ((unint64_t)(*((_QWORD *)this + 2099) - v115) <= 0x10)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  ECApplicator::setInputOutputABLs(*(_QWORD *)(v115 + 16), v129, v128);
  v116 = *((_QWORD *)this + 2098);
  if ((unint64_t)(*((_QWORD *)this + 2099) - v116) <= 0x18)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  ECApplicator::setInputOutputABLs(*(_QWORD *)(v116 + 24), v127, v126);
  v117 = *((_QWORD *)this + 2098);
  if ((unint64_t)(*((_QWORD *)this + 2099) - v117) <= 0x20)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  ECApplicator::setInputOutputABLs(*(_QWORD *)(v117 + 32), v125, v124);
  v118 = *((_QWORD *)this + 2098);
  v119 = *((_QWORD *)this + 2099) - v118;
  if (v119 <= 0x20)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_BYTE *)(*(_QWORD *)(v118 + 32) + 12) = 0;
  if (v119 <= 0x28)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  result = ECApplicator::setInputOutputABLs(*(_QWORD *)(v118 + 40), v123, v122);
  v121 = *((_QWORD *)this + 2098);
  if ((unint64_t)(*((_QWORD *)this + 2099) - v121) <= 0x28)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_BYTE *)(*(_QWORD *)(v121 + 40) + 12) = 0;
  return result;
}

void sub_1B6536B48(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<ECApplicator>::reset[abi:ne180100]((ECApplicator **)(v1 - 184));
  _Unwind_Resume(a1);
}

BOOL VoiceProcessorV6::portSubTypeCanOverrideReverbSuppressor(VoiceProcessorV6 *this, int a2, unsigned int a3)
{
  return a2 == 1885892727 && a3 >> 1 == 823859251;
}

uint64_t VoiceProcessorV6::OverrideMiscUseCase(VoiceProcessorV6 *this, int a2)
{
  if (a2 == 1885433971)
    return 0x1766F3234;
  else
    return 1986998784;
}

BOOL VoiceProcessorV6::IsVoiceIsolationSupportedUnderCurrentRoute(VoiceProcessorV6 *this)
{
  return **((_DWORD **)this + 295) == 1886222185
      && **((_DWORD **)this + 292) == 1885892727
      && *((_DWORD *)this + 596) == 1781740087;
}

BOOL VoiceProcessorV6::IsVoiceIsolationSupportedUnderCurrentUseCase(VoiceProcessorV6 *this)
{
  unsigned int v2;
  _BOOL8 result;
  BOOL v4;
  int v5;
  int v7;

  v2 = *((_DWORD *)this + 19);
  result = 1;
  v4 = v2 > 4;
  v5 = (1 << v2) & 0x15;
  if (v4 || v5 == 0)
    result = _os_feature_enabled_impl()
          && ((v7 = *((_DWORD *)this + 19), v7 == 6) || v7 == 1)
          && (*(unsigned int (**)(VoiceProcessorV6 *))(*(_QWORD *)this + 112))(this) >= 7
          && *((_DWORD *)this + 16) == 1;
  return result;
}

BOOL VoiceProcessorV6::IsMusicModeSupportedUnderCurrentRoute(VoiceProcessorV6 *this)
{
  return **((_DWORD **)this + 295) == 1886222185
      && **((_DWORD **)this + 292) == 1885892727
      && *((_DWORD *)this + 596) == 1781740087;
}

BOOL VoiceProcessorV6::IsMusicModeSupportedUnderCurrentUseCase(VoiceProcessorV6 *this)
{
  unsigned int v1;

  v1 = *((_DWORD *)this + 19);
  return (v1 & 1) == 0 && v1 < 5;
}

_QWORD *std::__function::__func<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_1E69E8E48;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void std::__function::__func<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_1E69E8E48;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_1E69E8E48;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t std::__function::__func<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 16);
  *a2 = &off_1E69E8E48;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

void std::__function::__func<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::destroy(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void std::__function::__func<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::destroy_deallocate(_QWORD *__p)
{
  std::__shared_weak_count *v2;

  v2 = (std::__shared_weak_count *)__p[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  operator delete(__p);
}

void std::__function::__func<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterEnableAutomaticChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  std::__shared_weak_count *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    v4 = *a2;
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 8);
      if (v7)
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 224))(v7, v4);
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_1B6536F1C(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_1E69E8E00;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void std::__function::__func<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_1E69E8E00;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_1E69E8E00;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t std::__function::__func<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 16);
  *a2 = &off_1E69E8E00;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

void std::__function::__func<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::destroy(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void std::__function::__func<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::destroy_deallocate(_QWORD *__p)
{
  std::__shared_weak_count *v2;

  v2 = (std::__shared_weak_count *)__p[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  operator delete(__p);
}

void std::__function::__func<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0,std::allocator<VoiceProcessorV6::RegisterChatFlavorNotificationListener(void)::$_0>,void ()(__CFDictionary const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  std::__shared_weak_count *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    v4 = *a2;
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 8);
      if (v7)
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 216))(v7, v4);
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_1B6537124(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<int>(int **a1)
{
  unint64_t v2;
  int *v3;
  int *v4;
  CFNumberRef *v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  void **v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  int64x2_t v15;
  void **v16;
  CFArrayRef v17;
  int64x2_t v19;
  _QWORD v20[3];
  void **v21;
  int64x2_t v22;
  void **v23;
  _QWORD *v24;

  v2 = a1[1] - *a1;
  v19 = 0uLL;
  v20[0] = 0;
  std::vector<applesauce::CF::NumberRef>::reserve((char **)&v19, v2);
  v3 = *a1;
  v4 = a1[1];
  if (*a1 != v4)
  {
    v5 = (CFNumberRef *)v19.i64[1];
    do
    {
      v6 = *v3;
      if ((unint64_t)v5 >= v20[0])
      {
        v7 = ((uint64_t)v5 - v19.i64[0]) >> 3;
        if ((unint64_t)(v7 + 1) >> 61)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v8 = (v20[0] - v19.i64[0]) >> 2;
        if (v8 <= v7 + 1)
          v8 = v7 + 1;
        if (v20[0] - v19.i64[0] >= 0x7FFFFFFFFFFFFFF8uLL)
          v9 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v9 = v8;
        v24 = v20;
        if (v9)
          v10 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,float>>>((uint64_t)v20, v9);
        else
          v10 = 0;
        v21 = v10;
        v22.i64[0] = (uint64_t)&v10[v7];
        v22.i64[1] = v22.i64[0];
        v23 = &v10[v9];
        std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,int,applesauce::CF::NumberRef*>((CFNumberRef *)v22.i64[0], v6);
        v11 = v22.i64[0];
        v5 = (CFNumberRef *)(v22.i64[1] + 8);
        v22.i64[1] += 8;
        v12 = (_QWORD *)v19.i64[1];
        v13 = (_QWORD *)v19.i64[0];
        if (v19.i64[1] == v19.i64[0])
        {
          v15 = vdupq_n_s64(v19.u64[1]);
        }
        else
        {
          do
          {
            v14 = *--v12;
            *(_QWORD *)(v11 - 8) = v14;
            v11 -= 8;
            *v12 = 0;
          }
          while (v12 != v13);
          v15 = v19;
          v5 = (CFNumberRef *)v22.i64[1];
        }
        v19.i64[0] = v11;
        v19.i64[1] = (uint64_t)v5;
        v22 = v15;
        v16 = (void **)v20[0];
        v20[0] = v23;
        v23 = v16;
        v21 = (void **)v15.i64[0];
        std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)&v21);
      }
      else
      {
        std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,int,applesauce::CF::NumberRef*>(v5++, *v3);
      }
      v19.i64[1] = (uint64_t)v5;
      ++v3;
    }
    while (v3 != v4);
  }
  v17 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::NumberRef>((uint64_t **)&v19);
  v21 = (void **)&v19;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&v21);
  return v17;
}

void sub_1B65372FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a9;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&a13);
  _Unwind_Resume(a1);
}

CFNumberRef *std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,int,applesauce::CF::NumberRef*>(CFNumberRef *a1, int a2)
{
  CFNumberRef v3;
  std::runtime_error *exception;
  int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *a1 = v3;
  if (!v3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B65373BC(_Unwind_Exception *exception_object)
{
  CFTypeRef *v1;

  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV6::InitializeV6Specifics(VoiceProcessorV6 *this)
{
  UInt32 *v2;
  _QWORD *v3;
  NSObject *v4;
  float v5;
  UInt32 v6;
  int *v7;
  float v8;
  VPTimeFreqConverter *v9;
  unint64_t v10;
  VPTimeFreqConverter *v11;
  uint64_t v12;
  char v13;
  char v14;
  VPTimeFreqConverter **v15;
  int v16;
  int v17;
  UInt32 ioDataSize;
  double outData;
  AudioStreamBasicDescription buf;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = (UInt32 *)((char *)this + 17184);
  if (VoiceProcessorV2::GetChatFlavor(this) == 2 && (*((_BYTE *)this + 4660) & 8) != 0)
  {
    outData = 0.0;
    ioDataSize = 8;
    AudioUnitGetProperty(*((AudioUnit *)this + 382), 0xCu, 0, 0, &outData, &ioDataSize);
    *v2 = vcvtad_u64_f64(outData * *((double *)this + 113));
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v3 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      v4 = (*v3 ? *v3 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = outData;
        v6 = *v2;
        LODWORD(buf.mSampleRate) = 136315906;
        *(_QWORD *)((char *)&buf.mSampleRate + 4) = "VoiceProcessor_v6.cpp";
        LOWORD(buf.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&buf.mFormatFlags + 2) = 167;
        HIWORD(buf.mBytesPerPacket) = 2048;
        *(double *)&buf.mFramesPerPacket = v5;
        LOWORD(buf.mChannelsPerFrame) = 1024;
        *(UInt32 *)((char *)&buf.mChannelsPerFrame + 2) = v6;
        _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> NOTICE: AUNeuralNet latency is %f ms, which is %d samples", (uint8_t *)&buf, 0x22u);
      }
    }
    v7 = (int *)*((_QWORD *)this + 1570);
    if (v7 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v8 = outData;
      CALegacyLog::log(v7, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v6/VoiceProcessor_v6.cpp", 167, "InitializeV6Specifics", "NOTICE: AUNeuralNet latency is %f ms, which is %d samples", v8, *v2);
    }
    myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *v2 + *((_DWORD *)this + 127), (AudioBufferList **)this + 2149);
    myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *v2 + *((_DWORD *)this + 127), (AudioBufferList **)this + 2150);
    myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *v2 + *((_DWORD *)this + 127), (AudioBufferList **)this + 2151);
    myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *v2 + *((_DWORD *)this + 127), (AudioBufferList **)this + 2152);
    myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2153);
    myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2154);
    myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2155);
    v9 = (VPTimeFreqConverter *)*((_QWORD *)this + 2156);
    if (v9)
    {
      VPTimeFreqConverter::~VPTimeFreqConverter(v9);
      MEMORY[0x1BCC95CEC]();
    }
    VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), (VPTimeFreqConverter **)this + 2156);
    v10 = (float)(ceilf((float)*v2 / (float)*((unsigned int *)this + 127)) + 1.0);
    LODWORD(buf.mSampleRate) = 0;
    std::vector<float>::assign((char **)this + 2157, v10, &buf);
  }
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2134);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2135);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2136);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2137);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2138);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2141);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2139);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2140);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 508);
  buf.mSampleRate = *((Float64 *)this + 103);
  *(_OWORD *)&buf.mFormatID = xmmword_1B6626900;
  *(_OWORD *)&buf.mBytesPerFrame = xmmword_1B66A0830;
  myAllocABLDynamic(&buf, 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2142);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2143);
  myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2144);
  LODWORD(outData) = 1065353216;
  vDSP_vfill((const float *)&outData, *(float **)(*((_QWORD *)this + 2143) + 16), 1, *((unsigned int *)this + 127));
  vDSP_vfill((const float *)&outData, *(float **)(*((_QWORD *)this + 2144) + 16), 1, *((unsigned int *)this + 127));
  v11 = (VPTimeFreqConverter *)*((_QWORD *)this + 2145);
  if (v11)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v11);
    MEMORY[0x1BCC95CEC]();
  }
  VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), (VPTimeFreqConverter **)this + 2145);
  v12 = 0;
  v13 = 1;
  do
  {
    v14 = v13;
    v15 = (VPTimeFreqConverter **)((char *)this + 8 * v12 + 17168);
    if (*v15)
    {
      VPTimeFreqConverter::~VPTimeFreqConverter(*v15);
      MEMORY[0x1BCC95CEC]();
      *v15 = 0;
    }
    VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), v15);
    v13 = 0;
    v12 = 1;
  }
  while ((v14 & 1) != 0);
  v2[24] = 0;
  if (**((_DWORD **)this + 135) > 3u)
  {
    v16 = *((_DWORD *)this + 3098);
    v17 = 1;
    if (v16 <= 4)
    {
      if (v16 != 2)
      {
        if (v16 != 3)
          return;
        v17 = 2;
      }
      goto LABEL_34;
    }
    if (v16 == 5 || v16 == 12)
LABEL_34:
      v2[24] = v17;
  }
}

double vp::v6::create@<D0>(vp::v6 *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5;
  double result;

  v5 = operator new();
  VoiceProcessorV4::VoiceProcessorV4((VoiceProcessorV4 *)v5, this);
  *(_QWORD *)(v5 + 17056) = 0;
  result = 0.0;
  *(_OWORD *)(v5 + 17040) = 0u;
  *(_BYTE *)(v5 + 17064) = 0;
  *(_BYTE *)(v5 + 479) = 1;
  *(_QWORD *)v5 = &off_1E69E8AF8;
  *(_OWORD *)(v5 + 17072) = 0u;
  *(_OWORD *)(v5 + 17088) = 0u;
  *(_OWORD *)(v5 + 17104) = 0u;
  *(_OWORD *)(v5 + 17120) = 0u;
  *(_OWORD *)(v5 + 17136) = 0u;
  *(_OWORD *)(v5 + 17152) = 0u;
  *(_OWORD *)(v5 + 17168) = 0u;
  *(_DWORD *)(v5 + 17184) = 0;
  *(_OWORD *)(v5 + 17192) = 0u;
  *(_OWORD *)(v5 + 17208) = 0u;
  *(_OWORD *)(v5 + 17224) = 0u;
  *(_OWORD *)(v5 + 17240) = 0u;
  *(_OWORD *)(v5 + 17256) = 0u;
  *(_OWORD *)(v5 + 17268) = 0u;
  *(_OWORD *)(v5 + 17304) = 0u;
  *(_OWORD *)(v5 + 17320) = 0u;
  *(_OWORD *)(v5 + 17288) = 0u;
  *a2 = v5;
  return result;
}

void sub_1B6537C90(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10F3C4028E7192ALL);
  _Unwind_Resume(a1);
}

void VBAPSpatializer::~VBAPSpatializer(VBAPSpatializer *this)
{
  VBAPSpatializer::~VBAPSpatializer(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  *(_QWORD *)this = &off_1E69E8E90;
  v2 = (void *)*((_QWORD *)this + 64);
  if (v2)
  {
    *((_QWORD *)this + 65) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 61);
  if (v3)
  {
    *((_QWORD *)this + 62) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 58);
  if (v4)
  {
    *((_QWORD *)this + 59) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 55);
  if (v5)
  {
    *((_QWORD *)this + 56) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 52);
  if (v6)
  {
    *((_QWORD *)this + 53) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 49);
  if (v7)
  {
    *((_QWORD *)this + 50) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 46);
  if (v8)
  {
    *((_QWORD *)this + 47) = v8;
    operator delete(v8);
  }
  std::unique_ptr<VBAP>::reset[abi:ne180100]((VBAP **)this + 45, 0);
  std::unique_ptr<VBAP>::reset[abi:ne180100]((VBAP **)this + 44, 0);
  Spatializer::~Spatializer(this);
}

uint64_t VBAPSpatializer::setParams(VBAPSpatializer *this, const SpatializerParams *a2)
{
  if (!*((_BYTE *)this + 16))
    (*(void (**)(VBAPSpatializer *, char *))(*(_QWORD *)this + 152))(this, (char *)a2 + 40);
  return Spatializer::setParams(this, a2);
}

uint64_t VBAPSpatializer::setBypassCoeffs(VBAP **this, float *a2, unsigned int a3)
{
  uint64_t result;

  result = Spatializer::setBypassCoeffs((Spatializer *)this, a2, a3);
  if (!(_DWORD)result)
  {
    if (this[11] == this[12])
      return 0;
    else
      return VBAPSpatializer::calculateExclusionBypassCoeffs(this, this[45], (uint64_t)(this + 58));
  }
  return result;
}

uint64_t VBAPSpatializer::setExclusionZones(uint64_t a1, float **a2)
{
  char **v2;
  char *v4;
  uint64_t v5;
  float *v6;
  float *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  float *v14;
  char *v15;
  int64_t v16;
  char *v17;
  char *v18;
  char *v19;
  VBAP *v20;
  uint64_t v21;
  VBAP *v22;
  char **v24;
  char *v25;
  int v26;
  VBAP *v27;
  VBAP *v28;
  void *__p;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  char *v33;
  uint64_t v34;
  void *v35;
  float *v36;
  uint64_t v37;

  v2 = (char **)a2;
  v5 = *(_QWORD *)(a1 + 88);
  v4 = (char *)(a1 + 88);
  v7 = *a2;
  v6 = a2[1];
  if ((char *)v6 - (char *)*a2 == *(_QWORD *)(a1 + 96) - v5)
  {
    while (v7 != v6)
    {
      if (!AUSM::ExclusionZone::operator==(v7, v5))
        goto LABEL_5;
      v7 += 7;
      v5 += 28;
    }
    return 0;
  }
  else
  {
LABEL_5:
    v35 = 0;
    v36 = 0;
    v37 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v35, *(const void **)(a1 + 392), *(_QWORD *)(a1 + 400), (uint64_t)(*(_QWORD *)(a1 + 400) - *(_QWORD *)(a1 + 392)) >> 2);
    v32 = 0;
    v33 = 0;
    v34 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v32, *(const void **)(a1 + 416), *(_QWORD *)(a1 + 424), (uint64_t)(*(_QWORD *)(a1 + 424) - *(_QWORD *)(a1 + 416)) >> 2);
    __p = 0;
    v30 = 0;
    v31 = 0;
    std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *(const void **)(a1 + 440), *(_QWORD *)(a1 + 448), (uint64_t)(*(_QWORD *)(a1 + 448) - *(_QWORD *)(a1 + 440)) >> 2);
    v8 = *v2;
    v9 = v2[1];
    if (*v2 != v9)
    {
      v24 = v2;
      v25 = v4;
      v10 = (char *)__p;
      v11 = v30;
      do
      {
        if ((int)((unint64_t)((char *)v36 - (_BYTE *)v35) >> 2) >= 1)
        {
          v12 = ((unint64_t)((char *)v36 - (_BYTE *)v35) >> 2) + 1;
          do
          {
            v13 = (v12 - 2);
            v14 = (float *)((char *)v35 + 4 * v13);
            v15 = (char *)v32;
            if (AUSM::ExclusionZone::isInExclusionZone((AUSM::ExclusionZone *)v8, *v14, *((float *)v32 + v13), (BOOL)v35))
            {
              v16 = (char *)v36 - (char *)(v14 + 1);
              if (v36 != v14 + 1)
              {
                memmove(v14, v14 + 1, (char *)v36 - (char *)(v14 + 1));
                v15 = (char *)v32;
              }
              v36 = (float *)((char *)v14 + v16);
              v17 = &v15[4 * v13];
              v18 = (char *)(v33 - (v17 + 4));
              if (v33 != v17 + 4)
                memmove(&v15[4 * v13], v17 + 4, v33 - (v17 + 4));
              v33 = &v18[(_QWORD)v17];
              v19 = &v10[4 * v13];
              if ((char *)v11 != v19 + 4)
                memmove(&v10[4 * v13], v19 + 4, v11 - (_QWORD)(v19 + 4));
              v11 -= 4;
            }
            --v12;
          }
          while (v12 > 1);
        }
        v8 += 28;
      }
      while (v8 != v9);
      v30 = v11;
      v2 = v24;
      v4 = v25;
    }
    if (v35 == v36)
    {
      v21 = 4294900553;
    }
    else
    {
      v28 = 0;
      v26 = 1;
      std::make_unique[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &,VBAP::Algorithm>((uint64_t *)&v27, (uint64_t)&v35, (uint64_t)&v32, &v26);
      v20 = v27;
      v28 = v27;
      v21 = VBAPSpatializer::calculateExclusionBypassCoeffs((_QWORD *)a1, v27, (uint64_t)&__p);
      if (!(_DWORD)v21)
      {
        v22 = *(VBAP **)(a1 + 360);
        *(_QWORD *)(a1 + 360) = v20;
        v28 = v22;
        if (v4 != (char *)v2)
          std::vector<AUSM::ExclusionZone>::__assign_with_size[abi:ne180100]<AUSM::ExclusionZone*,AUSM::ExclusionZone*>(v4, *v2, (uint64_t)v2[1], 0x6DB6DB6DB6DB6DB7 * ((v2[1] - *v2) >> 2));
        std::vector<int>::__assign_with_size[abi:ne180100]<int *,int *>((char *)(a1 + 464), (char *)__p, v30, (v30 - (uint64_t)__p) >> 2);
        *(_BYTE *)(a1 + 328) = 1;
        v20 = v22;
      }
      if (v20)
      {
        VBAP::~VBAP(v20);
        MEMORY[0x1BCC95CEC]();
      }
    }
    if (__p)
      operator delete(__p);
    if (v32)
    {
      v33 = (char *)v32;
      operator delete(v32);
    }
    if (v35)
    {
      v36 = (float *)v35;
      operator delete(v35);
    }
  }
  return v21;
}

void sub_1B653803C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, VBAP *a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  std::unique_ptr<VBAP>::reset[abi:ne180100](&a13, 0);
  if (__p)
    operator delete(__p);
  if (a17)
  {
    a18 = (uint64_t)a17;
    operator delete(a17);
  }
  if (a20)
  {
    a21 = (uint64_t)a20;
    operator delete(a20);
  }
  _Unwind_Resume(a1);
}

uint64_t VBAPSpatializer::initialize(VBAPSpatializer *this, float a2, unsigned int a3, int a4)
{
  double v6;
  double v7;
  double v8;
  float v9;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _BYTE *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  const __CFDictionary *v18;
  void *v19;
  unsigned int v20;
  unsigned __int8 v21;
  CFTypeRef cf;
  _BYTE *v23;
  uint64_t v24;
  void *__p;
  _BYTE *v26;
  uint64_t v27;

  *((float *)this + 2) = a2;
  *((_DWORD *)this + 3) = a4;
  v6 = a2 * 0.001953125 * 0.02;
  if (v6 >= 2.22507386e-308)
    v7 = -6.90775528 / v6;
  else
    v7 = -INFINITY;
  v8 = exp(v7);
  if (v7 < -708.4)
    v8 = 0.0;
  v9 = v8;
  *((float *)this + 134) = v9;
  if (a3 < (unint64_t)((uint64_t)(*((_QWORD *)this + 65) - *((_QWORD *)this + 64)) >> 2))
    return 4294900553;
  v11 = *((_QWORD *)this + 44);
  if (!v11)
    return 4294956421;
  if (*(_BYTE *)(v11 + 313))
  {
    __p = 0;
    v26 = 0;
    v27 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)(v11 + 80), *(_QWORD *)(v11 + 88), (uint64_t)(*(_QWORD *)(v11 + 88) - *(_QWORD *)(v11 + 80)) >> 2);
    v12 = *((_QWORD *)this + 44);
    v23 = 0;
    v24 = 0;
    cf = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&cf, *(const void **)(v12 + 56), *(_QWORD *)(v12 + 64), (uint64_t)(*(_QWORD *)(v12 + 64) - *(_QWORD *)(v12 + 56)) >> 2);
    v13 = ((unint64_t)((uint64_t)(*(_QWORD *)(*((_QWORD *)this + 44) + 232)
                                      - *(_QWORD *)(*((_QWORD *)this + 44) + 224)) >> 2)
         * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64;
    v14 = __p;
    v15 = 2 * (((v23 - (_BYTE *)cf) >> 2) / 3uLL + ((v26 - (_BYTE *)__p) >> 2) / 3uLL);
    if (cf)
    {
      v23 = cf;
      operator delete((void *)cf);
      v14 = __p;
    }
    v16 = (v13 >> 1);
    v17 = v15 - 4;
    if (v14)
    {
      v26 = v14;
      operator delete(v14);
    }
    if (v17 != v16)
      return 4294956421;
  }
  v18 = (const __CFDictionary *)*((_QWORD *)this + 5);
  if (v18)
  {
    cf = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*&>(&__p, v18, (const void *)kOptionalFeatureSupport, &cf);
    if (cf)
      CFRelease(cf);
    v19 = __p;
    if (__p)
    {
      v20 = (unsigned __int16)applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const*&>((const __CFDictionary *)__p, (const void *)kOptionalFeatureSourceExtent);
      if (v20 <= 0x100)
        LOBYTE(v20) = 0;
      v21 = v20 != 0;
    }
    else
    {
      v21 = 0;
    }
  }
  else
  {
    v19 = 0;
    v21 = 0;
    __p = 0;
  }
  atomic_store(v21, (unsigned __int8 *)this + 548);
  LODWORD(cf) = 0;
  std::vector<float>::resize((uint64_t)this + 136, a3, &cf);
  LODWORD(cf) = 0;
  std::vector<float>::resize((uint64_t)this + 272, a3, &cf);
  *((_WORD *)this + 8) = 257;
  if (v19)
    CFRelease(v19);
  return 0;
}

void sub_1B65382EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void VBAPSpatializer::reset(VBAPSpatializer *this)
{
  void *v2;
  uint64_t v3;

  *((_BYTE *)this + 17) = 1;
  *((_BYTE *)this + 268) = *((_BYTE *)this + 132);
  v2 = (void *)*((_QWORD *)this + 61);
  v3 = *((_QWORD *)this + 62) - (_QWORD)v2;
  if (v3 >= 1)
    bzero(v2, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
}

uint64_t VBAPSpatializer::processAccumulating(VBAPSpatializer *this, const float *__A, float *const *a3, int a4, float *const *a5, unsigned int a6, vDSP_Length __N, float a8, IR::ComplexDataCircBuffer *a9)
{
  unsigned int v10;
  unsigned __int8 v15;
  float v16;
  float v17;
  unsigned int **v18;
  uint64_t *v19;
  VBAP *v20;
  NSObject *v21;
  uint64_t result;
  char v23;
  uint64_t v24;
  uint64_t v25;
  float v26;
  float v27;
  std::string *v28;
  __int128 v29;
  std::string *v30;
  __int128 v31;
  __int128 *p_Start;
  std::string v33;
  std::string __Step;
  __int128 __Start;
  int64_t v36;
  uint8_t buf[4];
  __int128 *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 16))
  {
    v10 = __N;
    if (*((_BYTE *)this + 320)
      || (v15 = atomic_load((unsigned __int8 *)this + 540), (v15 & 1) != 0)
      || *((_BYTE *)this + 17)
      || *((_BYTE *)this + 328))
    {
      if (!*((_BYTE *)this + 112) || *((_QWORD *)this + 11) == *((_QWORD *)this + 12))
      {
        v16 = *((float *)this + 12);
        v17 = *((float *)this + 13);
        v18 = (unsigned int **)((char *)this + 440);
        v19 = (uint64_t *)((char *)this + 136);
        v20 = (VBAP *)*((_QWORD *)this + 44);
      }
      else
      {
        v16 = *((float *)this + 12);
        v17 = *((float *)this + 13);
        v18 = (unsigned int **)((char *)this + 464);
        v19 = (uint64_t *)((char *)this + 160);
        v20 = (VBAP *)*((_QWORD *)this + 45);
      }
      result = VBAPSpatializer::doTriangleLookup((uint64_t)this, v18, v19, v20, v16, v17);
      if ((_DWORD)result)
        return result;
      if (*((_BYTE *)this + 113))
        AUSM::speakerSnap(*((AUSM **)this + 64), (*((_QWORD *)this + 65) - *((_QWORD *)this + 64)) >> 2);
      if (*((_BYTE *)this + 17))
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 488, *((char **)this + 64), *((_QWORD *)this + 65), (uint64_t)(*((_QWORD *)this + 65) - *((_QWORD *)this + 64)) >> 2);
      *((_BYTE *)this + 320) = 0;
      *((_BYTE *)this + 17) = 0;
      atomic_store(0, (unsigned __int8 *)this + 540);
      *((_BYTE *)this + 328) = 0;
    }
    v23 = *((_BYTE *)this + 132);
    if (!v23)
      a8 = 0.0;
    if (a4)
    {
      v24 = 0;
      do
      {
        LODWORD(__Start) = 0;
        v25 = *((_QWORD *)this + 61);
        LODWORD(__Start) = *(_DWORD *)(v25 + 4 * v24);
        v26 = a8 * *(float *)(*((_QWORD *)this + 64) + 4 * v24);
        v27 = v26;
        if (!*((_DWORD *)this + 81))
          v27 = v26 + (float)(*((float *)this + 134) * (float)(*(float *)(v25 + 4 * v24) - v26));
        *(float *)(v25 + 4 * v24) = v27;
        if (v10)
        {
          LODWORD(__Step.__r_.__value_.__l.__data_) = 0;
          *(float *)&__Step.__r_.__value_.__l.__data_ = (float)(*(float *)(v25 + 4 * v24) - *(float *)&__Start)
                                                      / (float)v10;
          if (fabsf(*(float *)&__Step.__r_.__value_.__l.__data_) <= 0.000001)
          {
            if (fabsf(*(float *)&__Start) > 0.000001)
            {
              *(float *)(v25 + 4 * v24) = v26;
              vDSP_vsma(__A, 1, (const float *)&__Start, a3[v24], 1, a3[v24], 1, v10);
            }
          }
          else
          {
            vDSP_vrampmuladd(__A, 1, (float *)&__Start, (const float *)&__Step, a3[v24], 1, v10);
          }
        }
        ++v24;
      }
      while (a4 != v24);
      v23 = *((_BYTE *)this + 132);
    }
    result = 0;
    *((_BYTE *)this + 268) = v23;
    *((_DWORD *)this + 5) = v10;
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v21 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      std::string::basic_string[abi:ne180100]<0>(&v33, "VBAPSpatializer");
      v28 = std::string::append(&v33, "::", 2uLL);
      v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
      __Step.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__Step.__r_.__value_.__l.__data_ = v29;
      v28->__r_.__value_.__l.__size_ = 0;
      v28->__r_.__value_.__r.__words[2] = 0;
      v28->__r_.__value_.__r.__words[0] = 0;
      v30 = std::string::append(&__Step, "processAccumulating", 0x13uLL);
      v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
      v36 = v30->__r_.__value_.__r.__words[2];
      __Start = v31;
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      p_Start = &__Start;
      if (v36 < 0)
        p_Start = (__int128 *)__Start;
      *(_DWORD *)buf = 136315138;
      v38 = p_Start;
      _os_log_debug_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_DEBUG, "%s: ERROR: not initialized", buf, 0xCu);
      if (SHIBYTE(v36) < 0)
        operator delete((void *)__Start);
      if (SHIBYTE(__Step.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__Step.__r_.__value_.__l.__data_);
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v33.__r_.__value_.__l.__data_);
    }
    return 4294956429;
  }
  return result;
}

void sub_1B65386DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t VBAPSpatializer::doTriangleLookup(uint64_t a1, unsigned int **a2, uint64_t *a3, VBAP *a4, float a5, float a6)
{
  uint64_t v9;
  void *v10;
  double v13;
  __double2 v14;
  uint64_t v15;
  __double2 v16;
  unsigned int v17;
  unsigned int v18;
  float sinval;
  uint64_t v20;
  float *v21;
  uint64_t result;
  float32x4_t v23;
  unsigned __int8 v24;
  float v25;
  float *v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  BOOL v33;
  float v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  unint64_t v42;
  unsigned int *v43;
  unsigned int *v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int *v47;
  unint64_t v48;
  unint64_t v49;
  unsigned int *v50;
  unsigned int *v51;
  unsigned int v52;
  __double2 v53;
  unsigned int v54;
  unsigned int v55;
  float32x4_t v56;
  __double2 v57;
  unsigned int v58;
  unsigned int v59;
  float v60;
  uint64_t v61;
  uint64_t v62;
  float *v63;
  __double2 v64;
  unsigned int v65;
  unsigned int v66;
  float v67;
  int32x4_t v68;
  float32x2_t v69;
  float32x2_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int32x4_t v73;
  float32x2_t v74;
  float32x2_t v75;
  float v76;
  float v77;
  __float2 v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int32x4_t v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int32x4_t v87;
  int8x16_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float v92;
  __float2 v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  int32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  int32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  int v111;
  float __B;
  float32x2_t v113;
  float v114;
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 0xFFFFFFFFLL;
  if (*a2 == a2[1])
    return 0xFFFFFFFFLL;
  v9 = a3[1] - *a3;
  v10 = *(void **)(a1 + 512);
  if (v9 != *(_QWORD *)(a1 + 520) - (_QWORD)v10)
    return 0xFFFFFFFFLL;
  v13 = a5 * 0.0174532925;
  v14 = __sincos_stret(a6 * 0.0174532925);
  v16 = __sincos_stret(v13);
  *(float *)&v17 = v14.__cosval * v16.__cosval;
  *(float *)&v18 = v14.__cosval * v16.__sinval;
  v113 = (float32x2_t)__PAIR64__(v18, v17);
  sinval = v14.__sinval;
  v114 = sinval;
  if (v9 >= 1)
    bzero(v10, 4 * (((unint64_t)v9 >> 2) - ((unint64_t)v9 > 3)) + 4);
  MEMORY[0x1E0C80A78](v15);
  v21 = (float *)((char *)v106.f32 - v20);
  result = VBAP::calculateVBAPGains(a4, &v113, (float *)((char *)v106.f32 - v20));
  if (!(_DWORD)result)
  {
    v24 = atomic_load((unsigned __int8 *)(a1 + 548));
    if ((v24 & 1) != 0)
    {
      v25 = *(float *)(a1 + 64);
      if (*(float *)(a1 + 60) > 0.0 || v25 > 0.0)
      {
        *(float32x2_t *)v23.f32 = v113;
        v23.f32[2] = v114;
        v109 = v23;
        v53 = __sincos_stret((float)(a6 + 90.0) * 0.0174532925);
        *(float *)&v54 = v53.__cosval * v16.__cosval;
        *(float *)&v55 = v53.__cosval * v16.__sinval;
        v113 = (float32x2_t)__PAIR64__(v55, v54);
        v56.i64[0] = __PAIR64__(v55, v54);
        v110 = v56;
        v57 = __sincos_stret((float)(a6 + (float)(v25 * 90.0)) * 0.0174532925);
        *(float *)&v58 = v57.__cosval * v16.__cosval;
        *(float *)&v59 = v57.__cosval * v16.__sinval;
        v113 = (float32x2_t)__PAIR64__(v59, v58);
        v60 = v57.__sinval;
        v114 = v60;
        MEMORY[0x1E0C80A78](v61);
        v63 = (float *)((char *)v106.f32 - v62);
        result = VBAP::calculateVBAPGains(a4, &v113, (float *)((char *)v106.f32 - v62));
        if ((_DWORD)result)
          return result;
        vDSP_vsq(v21, 1, v21, 1, a2[1] - *a2);
        vDSP_vsq(v63, 1, v63, 1, a2[1] - *a2);
        vDSP_vadd(v63, 1, v21, 1, v21, 1, a2[1] - *a2);
        v64 = __sincos_stret((float)(a6 + (float)(*(float *)(a1 + 64) * -90.0)) * 0.0174532925);
        *(float *)&v65 = v64.__cosval * v16.__cosval;
        *(float *)&v66 = v64.__cosval * v16.__sinval;
        v113 = (float32x2_t)__PAIR64__(v66, v65);
        v67 = v64.__sinval;
        v114 = v67;
        result = VBAP::calculateVBAPGains(a4, &v113, v63);
        if ((_DWORD)result)
          return result;
        v68 = (int32x4_t)vmulq_f32(v109, v109);
        v68.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v68, 2), vadd_f32(*(float32x2_t *)v68.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v68.i8, 1))).u32[0];
        v69 = vrsqrte_f32((float32x2_t)v68.u32[0]);
        v70 = vmul_f32(v69, vrsqrts_f32((float32x2_t)v68.u32[0], vmul_f32(v69, v69)));
        v71 = vmulq_n_f32(v109, vmul_f32(v70, vrsqrts_f32((float32x2_t)v68.u32[0], vmul_f32(v70, v70))).f32[0]);
        *(float *)v68.i32 = v53.__sinval;
        v72 = v110;
        v72.i32[2] = v68.i32[0];
        v73 = (int32x4_t)vmulq_f32(v72, v72);
        v73.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v73, 2), vadd_f32(*(float32x2_t *)v73.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v73.i8, 1))).u32[0];
        v74 = vrsqrte_f32((float32x2_t)v73.u32[0]);
        v75 = vmul_f32(v74, vrsqrts_f32((float32x2_t)v73.u32[0], vmul_f32(v74, v74)));
        v109 = v71;
        v110 = vmulq_n_f32(v72, vmul_f32(v75, vrsqrts_f32((float32x2_t)v73.u32[0], vmul_f32(v75, v75))).f32[0]);
        vDSP_vsq(v63, 1, v63, 1, a2[1] - *a2);
        vDSP_vadd(v63, 1, v21, 1, v21, 1, a2[1] - *a2);
        v76 = *(float *)(a1 + 60);
        v77 = (float)(v76 + v76) * 3.14159265 / 3.0;
        v78 = __sincosf_stret(v77 * 0.5);
        v79 = vmulq_n_f32(v110, v78.__sinval);
        v80 = v79;
        v80.i32[3] = LODWORD(v78.__cosval);
        v108 = (float32x4_t)xmmword_1B66A07B0;
        v81 = vmulq_f32(v80, (float32x4_t)xmmword_1B66A07B0);
        v82 = (int32x4_t)vnegq_f32(v81);
        v83 = (int8x16_t)vtrn2q_s32((int32x4_t)v81, vtrn1q_s32((int32x4_t)v81, v82));
        v84 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v81, (int8x16_t)v82, 8uLL), *(float32x2_t *)v109.f32, 1), (float32x4_t)vextq_s8(v83, v83, 8uLL), v109.f32[0]);
        v85 = (float32x4_t)vrev64q_s32((int32x4_t)v81);
        v85.i32[0] = v82.i32[1];
        v85.i32[3] = v82.i32[2];
        v86 = vmlaq_laneq_f32(v84, v85, v109, 2);
        v87 = (int32x4_t)vnegq_f32(v86);
        v88 = (int8x16_t)vtrn2q_s32((int32x4_t)v86, vtrn1q_s32((int32x4_t)v86, v87));
        v89 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v86, (int8x16_t)v87, 8uLL), *(float32x2_t *)v79.f32, 1), (float32x4_t)vextq_s8(v88, v88, 8uLL), v79.f32[0]);
        v90 = (float32x4_t)vrev64q_s32((int32x4_t)v86);
        v90.i32[0] = v87.i32[1];
        v90.i32[3] = v87.i32[2];
        v91 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v86, v80, 3), v90, v79, 2), v89);
        v113 = *(float32x2_t *)v91.f32;
        v114 = v91.f32[2];
        result = VBAP::calculateVBAPGains(a4, &v113, v63);
        if ((_DWORD)result)
          return result;
        v106 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v109.f32, 0);
        v107 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v109, 2);
        v92 = (float)(v76 * -2.0) * 3.14159265 / 3.0;
        v93 = __sincosf_stret(v92 * 0.5);
        v94 = vmulq_n_f32(v110, v93.__sinval);
        v95 = v94;
        v95.i32[3] = LODWORD(v93.__cosval);
        v96 = vmulq_f32(v95, v108);
        v97 = (int32x4_t)vnegq_f32(v96);
        v98 = (int8x16_t)vtrn2q_s32((int32x4_t)v96, vtrn1q_s32((int32x4_t)v96, v97));
        v99 = vmlaq_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v96, (int8x16_t)v97, 8uLL), *(float32x2_t *)v109.f32, 1), (float32x4_t)vextq_s8(v98, v98, 8uLL), v106);
        v100 = (float32x4_t)vrev64q_s32((int32x4_t)v96);
        v100.i32[0] = v97.i32[1];
        v100.i32[3] = v97.i32[2];
        v101 = vmlaq_f32(v99, v100, v107);
        v102 = (int32x4_t)vnegq_f32(v101);
        v103 = (int8x16_t)vtrn2q_s32((int32x4_t)v101, vtrn1q_s32((int32x4_t)v101, v102));
        v104 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v101, (int8x16_t)v102, 8uLL), *(float32x2_t *)v94.f32, 1), (float32x4_t)vextq_s8(v103, v103, 8uLL), v94.f32[0]);
        v105 = (float32x4_t)vrev64q_s32((int32x4_t)v101);
        v105.i32[0] = v102.i32[1];
        v105.i32[3] = v102.i32[2];
        v110 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v101, v95, 3), v105, v94, 2), v104);
        vDSP_vsq(v63, 1, v63, 1, a2[1] - *a2);
        vDSP_vadd(v63, 1, v21, 1, v21, 1, a2[1] - *a2);
        v113 = *(float32x2_t *)v110.f32;
        v114 = v110.f32[2];
        result = VBAP::calculateVBAPGains(a4, &v113, v63);
        if ((_DWORD)result)
          return result;
        vDSP_vsq(v63, 1, v63, 1, a2[1] - *a2);
        vDSP_vadd(v63, 1, v21, 1, v21, 1, a2[1] - *a2);
        __B = 0.2;
        vDSP_vsmul(v21, 1, &__B, v21, 1, a2[1] - *a2);
        v111 = (unint64_t)((char *)a2[1] - (char *)*a2) >> 2;
        vvsqrtf(v21, v21, &v111);
      }
    }
    v26 = (float *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 320))(a1);
    v27 = *(float *)(a1 + 56);
    v28 = *v26;
    v29 = v26[1];
    if (*v26 >= v29)
    {
      v33 = v28 <= v27;
      v32 = 0.0;
      if (!v33)
        v32 = 1.0;
    }
    else
    {
      v30 = (float)(v27 - v28) / (float)(v29 - v28);
      v31 = 1.0 - v30;
      if (v30 > 1.0)
        v31 = 0.0;
      if (v30 >= 0.0)
        v32 = v31;
      else
        v32 = 1.0;
    }
    v34 = *(float *)(a1 + 124);
    v35 = 0.0;
    if (v34 > 0.000001 && v27 < v34)
    {
      if (v27 >= 0.0)
        v35 = *(float *)(a1 + 56);
      v35 = (float)(v34 - v35) / v34;
    }
    v36 = *(_QWORD *)(a1 + 520);
    v37 = *(_QWORD *)(a1 + 512);
    v38 = v36 - v37;
    if (v36 != v37)
    {
      v39 = 0;
      v40 = 0;
      v41 = 0;
      v42 = v38 >> 2;
      v43 = *a2;
      v44 = a2[1];
      v45 = v44 - *a2;
      v46 = *a3;
      do
      {
        if (v44 == v43)
          goto LABEL_34;
        v47 = v43;
        v48 = v45;
        do
        {
          v49 = v48 >> 1;
          v50 = &v47[v48 >> 1];
          v52 = *v50;
          v51 = v50 + 1;
          v48 += ~(v48 >> 1);
          if (v52 < v41)
            v47 = v51;
          else
            v48 = v49;
        }
        while (v48);
        if (v47 == v44 || v41 < *v47)
        {
LABEL_34:
          if (v35 > 0.0)
            *(float *)(v37 + 4 * v39) = (float)(v35 * *(float *)(v46 + 4 * v39)) * 0.31623;
        }
        else
        {
          *(float *)(v37 + 4 * v39) = v21[v40]
                                    + (float)(v35
                                            * (float)((float)((float)((float)(1.0 - v32) * *(float *)(a1 + 544))
                                                            + (float)(v32 * *(float *)(v46 + 4 * v39)))
                                                    - v21[v40]));
          ++v40;
        }
        v39 = ++v41;
      }
      while (v42 > v41);
    }
    return 0;
  }
  return result;
}

void std::make_unique[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &,VBAP::Algorithm>(uint64_t *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v8;
  int v9;
  void *v10[3];
  void *__p;
  void *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  uint64_t v19;
  void **v20;

  v8 = operator new();
  v18 = 0;
  v19 = 0;
  v17 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v17, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  v14 = 0;
  v15 = 0;
  v16 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v14, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
  v9 = *a4;
  __p = 0;
  v12 = 0;
  v13 = 0;
  memset(v10, 0, sizeof(v10));
  VBAP::VBAP(v8, (uint64_t *)&v17, (uint64_t *)&v14, v9, (uint64_t)&__p, v10);
  *a1 = v8;
  v20 = v10;
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&v20);
  if (__p)
  {
    v12 = __p;
    operator delete(__p);
  }
  if (v14)
  {
    v15 = v14;
    operator delete(v14);
  }
  if (v17)
  {
    v18 = v17;
    operator delete(v17);
  }
}

void sub_1B653900C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  *(_QWORD *)(v22 - 56) = v21;
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v22 - 56));
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  if (a19)
    operator delete(a19);
  MEMORY[0x1BCC95CEC](v20, 0x10B0C40F5E5D8C6);
  _Unwind_Resume(a1);
}

uint64_t VBAPSpatializer::calculateExclusionBypassCoeffs(_QWORD *a1, VBAP *a2, uint64_t a3)
{
  _QWORD *v6;
  const float **v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  _DWORD *v13;
  _DWORD *v14;
  float v15;
  _DWORD *v16;
  _DWORD *v17;
  _DWORD *v18;
  uint64_t v19;
  double v20;
  __double2 v21;
  __double2 v22;
  unsigned int v23;
  unsigned int v24;
  float sinval;
  uint64_t v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  float *v35;
  float v36;
  float v37;
  float **v38;
  _BYTE v40[12];
  float __C;
  float *v42;
  float *v43;
  unint64_t v44;
  float v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v6 = a1 + 18;
  v7 = (const float **)(a1 + 17);
  v8 = (uint64_t)(a1[18] - a1[17]) >> 2;
  LODWORD(v44) = 0;
  std::vector<float>::vector(&v42, v8, &v44);
  __C = 0.0;
  vDSP_svesq(*v7, 1, &__C, (uint64_t)(*v6 - (_QWORD)*v7) >> 2);
  if (fabsf(__C) >= 0.00000011921)
  {
    v10 = a1[17];
    v9 = a1[18];
    if (v9 != v10)
    {
      v11 = 0;
      v12 = 0;
      while (1)
      {
        v13 = *(_DWORD **)(a3 + 8);
        v14 = *(_DWORD **)a3;
        if (*(_DWORD **)a3 != v13)
        {
          while (*v14 != v12)
          {
            if (++v14 == v13)
            {
              v14 = *(_DWORD **)(a3 + 8);
              break;
            }
          }
        }
        if (v14 != v13)
          break;
        if (!a2)
          goto LABEL_11;
        v15 = *(float *)(v10 + 4 * v11);
        if (fabsf(v15) < 0.00000011921)
          goto LABEL_11;
        v16 = (_DWORD *)a1[55];
        v17 = (_DWORD *)a1[56];
        v18 = v16;
        if (v16 != v17)
        {
          while (*v18 != v12)
          {
            if (++v18 == v17)
            {
              v18 = (_DWORD *)a1[56];
              break;
            }
          }
        }
        if (v18 == v17)
          goto LABEL_10;
        v19 = v18 - v16;
        v20 = *(float *)(a1[49] + 4 * v19) * 0.0174532925;
        v21 = __sincos_stret(*(float *)(a1[52] + 4 * v19) * 0.0174532925);
        v22 = __sincos_stret(v20);
        *(float *)&v23 = v21.__cosval * v22.__cosval;
        *(float *)&v24 = v21.__cosval * v22.__sinval;
        v44 = __PAIR64__(v24, v23);
        sinval = v21.__sinval;
        v45 = sinval;
        MEMORY[0x1E0C80A78](v26);
        v28 = &v40[-v27];
        v29 = VBAP::calculateVBAPGains(a2, (float32x2_t *)&v44, (float *)&v40[-v27]);
        if ((_DWORD)v29)
          goto LABEL_29;
        v30 = *(_DWORD **)a3;
        v31 = *(_QWORD *)(a3 + 8);
        v32 = v31 - *(_QWORD *)a3;
        if (v31 != *(_QWORD *)a3)
        {
          v33 = 0;
          v34 = v32 >> 2;
          v35 = v42;
          do
          {
            v36 = *(float *)&v28[4 * v33];
            if (fabsf(v36) >= 0.00000011921)
            {
              v37 = v36 * *(float *)(a1[17] + 4 * v11);
              v35[v30[v33]] = v35[v30[v33]] + (float)(v37 * v37);
            }
            ++v33;
          }
          while (v34 > v33);
        }
        v10 = a1[17];
        v9 = a1[18];
LABEL_11:
        v11 = ++v12;
        if (v12 >= (unint64_t)((v9 - v10) >> 2))
          goto LABEL_27;
      }
      v15 = *(float *)(v10 + 4 * v11);
LABEL_10:
      v42[v11] = v15 * v15;
      goto LABEL_11;
    }
LABEL_27:
    LODWORD(v44) = (unint64_t)((char *)v43 - (char *)v42) >> 2;
    v38 = (float **)(a1 + 20);
    std::vector<float>::resize((uint64_t)v38, (int)(v43 - v42));
    vvsqrtf(*v38, v42, (const int *)&v44);
  }
  v29 = 0;
LABEL_29:
  if (v42)
  {
    v43 = v42;
    operator delete(v42);
  }
  return v29;
}

void sub_1B6539368(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 160);
  if (v3)
  {
    *(_QWORD *)(v1 - 152) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void VBAPSpatializer::VBAPSpatializer(VBAPSpatializer *this, AudioChannelLayout *a2)
{
  uint64_t v4;
  VBAP **v5;
  _QWORD *v6;
  uint64_t v7;
  std::string::size_type v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  BOOL v20;
  int v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  _DWORD *v36;
  _DWORD *v37;
  _DWORD *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  BOOL v42;
  unint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  int v46;
  unint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  BOOL v50;
  unint64_t v51;
  int v52;
  NSObject *v53;
  uint64_t v54;
  char *v55;
  _QWORD *v56;
  char *v57;
  int64_t v58;
  char *v59;
  int64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  float v65;
  std::string *v66;
  __int128 v67;
  std::string *v68;
  __int128 v69;
  AudioChannelLayout *p_src;
  std::string::size_type v71;
  uint64_t v72;
  VBAP **v73;
  unint64_t v74;
  _QWORD *v75;
  uint64_t v76;
  std::string v77;
  std::string v78;
  _BYTE v79[36];
  AudioChannelLayout __src;
  uint64_t v81;
  void *__p;
  void *v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  Spatializer::Spatializer(this);
  *(_OWORD *)(v4 + 332) = xmmword_1B66A1E20;
  *(_QWORD *)v4 = &off_1E69E8E90;
  v5 = (VBAP **)(v4 + 352);
  v6 = (_QWORD *)(v4 + 368);
  v7 = v4 + 392;
  *(_DWORD *)(v4 + 544) = 0;
  v8 = v4 + 416;
  v9 = (_QWORD *)(v4 + 440);
  v10 = v4 + 488;
  *(_OWORD *)(v4 + 352) = 0u;
  *(_OWORD *)(v4 + 368) = 0u;
  v76 = v4 + 512;
  *(_OWORD *)(v4 + 384) = 0u;
  *(_OWORD *)(v4 + 400) = 0u;
  *(_OWORD *)(v4 + 416) = 0u;
  *(_OWORD *)(v4 + 432) = 0u;
  *(_OWORD *)(v4 + 448) = 0u;
  *(_OWORD *)(v4 + 464) = 0u;
  *(_OWORD *)(v4 + 480) = 0u;
  *(_OWORD *)(v4 + 496) = 0u;
  *(_OWORD *)(v4 + 512) = 0u;
  *(_OWORD *)(v4 + 525) = 0u;
  *(_BYTE *)(v4 + 548) = 1;
  GetChannelLayoutSphericalCoordinates(&__src, (float *)&a2->mChannelLayoutTag);
  *(_QWORD *)v79 = v7;
  *(_QWORD *)&v79[8] = v8;
  *(_QWORD *)&v79[16] = v6;
  std::__memberwise_forward_assign[abi:ne180100]<std::tuple<std::vector<float> &,std::vector<float> &,std::vector<float> &>,std::tuple<std::vector<float>,std::vector<float>,std::vector<float>>,std::vector<float>,std::vector<float>,std::vector<float>,0ul,1ul,2ul>((void ***)v79, (uint64_t)&__src);
  if (__p)
  {
    v83 = __p;
    operator delete(__p);
  }
  if (*(_QWORD *)&__src.mChannelDescriptions[0].mCoordinates[1])
  {
    v81 = *(_QWORD *)&__src.mChannelDescriptions[0].mCoordinates[1];
    operator delete(*(void **)&__src.mChannelDescriptions[0].mCoordinates[1]);
  }
  if (*(_QWORD *)&__src.mChannelLayoutTag)
  {
    *(_QWORD *)&__src.mNumberChannelDescriptions = *(_QWORD *)&__src.mChannelLayoutTag;
    operator delete(*(void **)&__src.mChannelLayoutTag);
  }
  GetChannelLayoutChannelLabels((const AudioChannelLayout *)v79, (int *)a2);
  v11 = *((_QWORD *)this + 50) - *((_QWORD *)this + 49);
  v12 = v11 >> 2;
  if (v11 >> 2 == (uint64_t)(*((_QWORD *)this + 53) - *((_QWORD *)this + 52)) >> 2
    && v12 == (uint64_t)(*((_QWORD *)this + 47) - *((_QWORD *)this + 46)) >> 2)
  {
    v13 = *(_QWORD *)&v79[8];
    if (v12 == (uint64_t)(*(_QWORD *)&v79[8] - *(_QWORD *)v79) >> 2)
    {
      v72 = v7;
      v73 = v5;
      v71 = v8;
      v75 = v9;
      if (*(_QWORD *)v79 != *(_QWORD *)&v79[8])
      {
        v14 = *(_DWORD **)v79;
        while (*v14 != 44)
        {
          if (++v14 == *(_DWORD **)&v79[8])
            goto LABEL_16;
        }
        v12 = ((uint64_t)v14 - *(_QWORD *)v79) >> 2;
      }
LABEL_16:
      v74 = ((unint64_t)v11 >> 2);
      if ((int)((unint64_t)v11 >> 2) >= 1)
      {
        v15 = ((unint64_t)v11 >> 2);
        v16 = *(_QWORD *)v79 + 4 * v12;
        do
        {
          v17 = v15 - 1;
          v18 = (v15 - 1);
          v19 = *(unsigned int *)(*(_QWORD *)v79 + 4 * v18);
          if (((v19 < 0x3F) & (0x4000002000000010uLL >> v19)) != 0
            || (_DWORD)v19 == 45
            || (v16 != v13 ? (v20 = (_DWORD)v19 == 9) : (v20 = 0),
                !v20 ? (v21 = 0) : (v21 = 1),
                *(float *)(*v6 + 4 * v18) != 0.0 ? (v22 = v21 == 0) : (v22 = 0),
                !v22))
          {
            v23 = *((_QWORD *)this + 49);
            v24 = *((_QWORD *)this + 50);
            v25 = v23 + 4 * v18;
            v26 = v24 - (v25 + 4);
            if (v24 != v25 + 4)
              memmove((void *)(v23 + 4 * v18), (const void *)(v25 + 4), v24 - (v25 + 4));
            *((_QWORD *)this + 50) = v25 + v26;
            v27 = *((_QWORD *)this + 52);
            v28 = *((_QWORD *)this + 53);
            v29 = v27 + 4 * v18;
            v30 = v28 - (v29 + 4);
            if (v28 != v29 + 4)
              memmove((void *)(v27 + 4 * v18), (const void *)(v29 + 4), v28 - (v29 + 4));
            *((_QWORD *)this + 53) = v29 + v30;
            v31 = *((_QWORD *)this + 46);
            v32 = *((_QWORD *)this + 47);
            v33 = v31 + 4 * v18;
            v34 = v32 - (v33 + 4);
            if (v32 != v33 + 4)
              memmove((void *)(v31 + 4 * v18), (const void *)(v33 + 4), v32 - (v33 + 4));
            *((_QWORD *)this + 47) = v33 + v34;
          }
          else
          {
            v36 = (_DWORD *)*((_QWORD *)this + 56);
            v35 = *((_QWORD *)this + 57);
            if ((unint64_t)v36 >= v35)
            {
              v38 = (_DWORD *)*v75;
              v39 = ((uint64_t)v36 - *v75) >> 2;
              v40 = v39 + 1;
              if ((unint64_t)(v39 + 1) >> 62)
                std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
              v41 = v35 - (_QWORD)v38;
              if (v41 >> 1 > v40)
                v40 = v41 >> 1;
              v42 = (unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL;
              v43 = 0x3FFFFFFFFFFFFFFFLL;
              if (!v42)
                v43 = v40;
              if (v43)
              {
                v43 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(v43);
                v38 = (_DWORD *)*((_QWORD *)this + 55);
                v36 = (_DWORD *)*((_QWORD *)this + 56);
              }
              else
              {
                v44 = 0;
              }
              v45 = (_DWORD *)(v43 + 4 * v39);
              *v45 = v17;
              v37 = v45 + 1;
              while (v36 != v38)
              {
                v46 = *--v36;
                *--v45 = v46;
              }
              *((_QWORD *)this + 55) = v45;
              *((_QWORD *)this + 56) = v37;
              *((_QWORD *)this + 57) = v43 + 4 * v44;
              if (v38)
                operator delete(v38);
            }
            else
            {
              *v36 = v17;
              v37 = v36 + 1;
            }
            *((_QWORD *)this + 56) = v37;
          }
          v50 = v15-- <= 1;
        }
        while (!v50);
      }
      v47 = *((_QWORD *)this + 55);
      v48 = *((_QWORD *)this + 56);
      v49 = (_DWORD *)(v48 - 4);
      v50 = v47 != v48 && (unint64_t)v49 > v47;
      if (v50)
      {
        v51 = v47 + 4;
        do
        {
          v52 = *(_DWORD *)(v51 - 4);
          *(_DWORD *)(v51 - 4) = *v49;
          *v49-- = v52;
          v42 = v51 >= (unint64_t)v49;
          v51 += 4;
        }
        while (!v42);
      }
      if (*((_QWORD *)this + 50) != *((_QWORD *)this + 49) && *((_QWORD *)this + 53) != *((_QWORD *)this + 52))
        goto LABEL_90;
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v53 = getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        std::string::basic_string[abi:ne180100]<0>(&v77, "VBAPSpatializer");
        v66 = std::string::append(&v77, "::", 2uLL);
        v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
        v78.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v78.__r_.__value_.__l.__data_ = v67;
        v66->__r_.__value_.__l.__size_ = 0;
        v66->__r_.__value_.__r.__words[2] = 0;
        v66->__r_.__value_.__r.__words[0] = 0;
        v68 = std::string::append(&v78, "VBAPSpatializer", 0xFuLL);
        v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
        *(_QWORD *)&__src.mChannelDescriptions[0].mChannelFlags = *((_QWORD *)&v68->__r_.__value_.__l + 2);
        *(_OWORD *)&__src.mChannelLayoutTag = v69;
        v68->__r_.__value_.__l.__size_ = 0;
        v68->__r_.__value_.__r.__words[2] = 0;
        v68->__r_.__value_.__r.__words[0] = 0;
        p_src = &__src;
        if (__src.mChannelDescriptions[0].mCoordinates[0] < 0.0)
          p_src = *(AudioChannelLayout **)&__src.mChannelLayoutTag;
        *(_DWORD *)&v79[24] = 136315138;
        *(_QWORD *)&v79[28] = p_src;
        _os_log_error_impl(&dword_1B5ED0000, v53, OS_LOG_TYPE_ERROR, "%s: ERROR: Azimuth and/or Elevation vectors are empty.  Default to stereo", &v79[24], 0xCu);
        if (SHIBYTE(__src.mChannelDescriptions[0].mCoordinates[0]) < 0)
          operator delete(*(void **)&__src.mChannelLayoutTag);
        if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v78.__r_.__value_.__l.__data_);
        if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v77.__r_.__value_.__l.__data_);
      }
      GetChannelLayoutSphericalCoordinates(&__src);
      v78.__r_.__value_.__r.__words[0] = v72;
      v78.__r_.__value_.__l.__size_ = v71;
      v78.__r_.__value_.__r.__words[2] = (std::string::size_type)v6;
      std::__memberwise_forward_assign[abi:ne180100]<std::tuple<std::vector<float> &,std::vector<float> &,std::vector<float> &>,std::tuple<std::vector<float>,std::vector<float>,std::vector<float>>,std::vector<float>,std::vector<float>,std::vector<float>,0ul,1ul,2ul>((void ***)&v78, (uint64_t)&__src);
      if (__p)
      {
        v83 = __p;
        operator delete(__p);
      }
      if (*(_QWORD *)&__src.mChannelDescriptions[0].mCoordinates[1])
      {
        v81 = *(_QWORD *)&__src.mChannelDescriptions[0].mCoordinates[1];
        operator delete(*(void **)&__src.mChannelDescriptions[0].mCoordinates[1]);
      }
      if (*(_QWORD *)&__src.mChannelLayoutTag)
      {
        *(_QWORD *)&__src.mNumberChannelDescriptions = *(_QWORD *)&__src.mChannelLayoutTag;
        operator delete(*(void **)&__src.mChannelLayoutTag);
      }
      *(_QWORD *)&__src.mChannelLayoutTag = 0x100000000;
      v54 = *((_QWORD *)this + 57);
      v55 = (char *)*((_QWORD *)this + 55);
      if ((unint64_t)(v54 - (_QWORD)v55) >= 8)
      {
        v57 = (char *)*((_QWORD *)this + 56);
        v58 = v57 - v55;
        if ((unint64_t)(v57 - v55) <= 7)
        {
          v59 = (char *)&__src + v58;
          if (v57 != v55)
          {
            memcpy(*((void **)this + 55), &__src, v57 - v55);
            v55 = (char *)*((_QWORD *)this + 56);
          }
          v60 = 8 - v58;
          memcpy(v55, v59, v60);
          v61 = v60 >> 2;
          goto LABEL_89;
        }
      }
      else
      {
        if (v55)
        {
          *((_QWORD *)this + 56) = v55;
          operator delete(v55);
          v54 = 0;
          v56 = v75;
          *v75 = 0;
          v75[1] = 0;
          v75[2] = 0;
        }
        else
        {
          v56 = v75;
        }
        v62 = v54 >> 1;
        if ((unint64_t)(v54 >> 1) <= 2)
          v62 = 2;
        if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFFCLL)
          v63 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v63 = v62;
        std::vector<int>::__vallocate[abi:ne180100](v56, v63);
        v55 = (char *)*((_QWORD *)this + 56);
      }
      *(_QWORD *)v55 = 0x100000000;
      v61 = 2;
LABEL_89:
      *((_QWORD *)this + 56) = &v55[4 * v61];
LABEL_90:
      LODWORD(v78.__r_.__value_.__l.__data_) = 1;
      std::make_unique[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &,VBAP::Algorithm>((uint64_t *)&__src, v72, v71, (int *)&v78);
      std::unique_ptr<VBAP>::reset[abi:ne180100](v73, *(VBAP **)&__src.mChannelLayoutTag);
      __src.mChannelLayoutTag = 0;
      std::vector<float>::resize(v10, v74, &__src);
      __src.mChannelLayoutTag = 0;
      std::vector<float>::resize(v76, v74, &__src);
      v64 = *((_QWORD *)this + 56) - *((_QWORD *)this + 55);
      v65 = 1.0 / (float)(unint64_t)(v64 >> 2);
      if (!v64)
        v65 = 1.0;
      *((float *)this + 136) = sqrtf(v65);
      *((_QWORD *)this + 6) = 0;
      *((_DWORD *)this + 14) = 0;
    }
  }
  if (*(_QWORD *)v79)
  {
    *(_QWORD *)&v79[8] = *(_QWORD *)v79;
    operator delete(*(void **)v79);
  }
}

void sub_1B6539ADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, void **a10, void **a11, VBAP **a12, uint64_t a13, void **a14, void **a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29)
{
  uint64_t v29;
  void **v30;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;

  if (__p)
    operator delete(__p);
  v32 = *a15;
  if (*a15)
  {
    *(_QWORD *)(v29 + 520) = v32;
    operator delete(v32);
  }
  v33 = *a9;
  if (*a9)
  {
    *(_QWORD *)(v29 + 496) = v33;
    operator delete(v33);
  }
  v34 = *(void **)(v29 + 464);
  if (v34)
  {
    *(_QWORD *)(v29 + 472) = v34;
    operator delete(v34);
  }
  v35 = *a14;
  if (*a14)
  {
    *(_QWORD *)(v29 + 448) = v35;
    operator delete(v35);
  }
  v36 = *a10;
  if (*a10)
  {
    *(_QWORD *)(v29 + 424) = v36;
    operator delete(v36);
  }
  v37 = *a11;
  if (*a11)
  {
    *(_QWORD *)(v29 + 400) = v37;
    operator delete(v37);
  }
  v38 = *v30;
  if (*v30)
  {
    *(_QWORD *)(v29 + 376) = v38;
    operator delete(v38);
  }
  std::unique_ptr<VBAP>::reset[abi:ne180100]((VBAP **)(v29 + 360), 0);
  std::unique_ptr<VBAP>::reset[abi:ne180100](a12, 0);
  Spatializer::~Spatializer((Spatializer *)v29);
  _Unwind_Resume(a1);
}

BOOL AUSM::RoomCongruence::UserData::isValid(AUSM::RoomCongruence::UserData *this)
{
  float *v1;
  uint64_t v2;
  unint64_t v3;
  float *v4;
  float *v5;
  _BOOL8 result;
  float *v7;
  float v8;
  float v9;
  float *v10;

  v2 = *(_QWORD *)this;
  v1 = (float *)*((_QWORD *)this + 1);
  if (v1 == *(float **)this)
    return 0;
  if (*((float *)this + 12) <= 0.0)
    return 0;
  v3 = ((uint64_t)v1 - *(_QWORD *)this) >> 2;
  v4 = (float *)*((_QWORD *)this + 3);
  if (v3 != (uint64_t)(*((_QWORD *)this + 4) - (_QWORD)v4) >> 2
    || v3 != (uint64_t)(*((_QWORD *)this + 8) - *((_QWORD *)this + 7)) >> 2
    || v3 != (uint64_t)(*((_QWORD *)this + 11) - *((_QWORD *)this + 10)) >> 2
    || v3 != (uint64_t)(*((_QWORD *)this + 14) - *((_QWORD *)this + 13)) >> 2)
  {
    return 0;
  }
  if (v3 <= 1)
    v3 = 1;
  v5 = *(float **)this;
  result = 0;
  while (*v5 > 0.0 && *v5 < 24000.0)
  {
    if (*v4 < 0.0)
      return 0;
    ++v4;
    ++v5;
    if (!--v3)
    {
      v7 = (float *)(v2 + 4);
      while (v7 != v1)
      {
        v9 = *(v7 - 1);
        v8 = *v7++;
        if (v8 < v9)
        {
          v10 = v7 - 1;
          return v10 == v1;
        }
      }
      v10 = v1;
      return v10 == v1;
    }
  }
  return result;
}

void AUNeuralNetSPP::~AUNeuralNetSPP(AUNeuralNetSPP *this)
{
  AUNeuralNetSPP::~AUNeuralNetSPP(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t *v2;
  void *v3;
  void *v4;
  void **v5;

  *(_QWORD *)this = &off_1E69E8FE8;
  v2 = (uint64_t *)((char *)this + 1032);
  std::unique_ptr<NeuralNetRES>::reset[abi:ne180100]((uint64_t *)this + 129, 0);
  std::unique_ptr<NeuralNetRES>::reset[abi:ne180100]((uint64_t *)this + 130, 0);
  std::unique_ptr<NeuralNetRES>::reset[abi:ne180100]((uint64_t *)this + 130, 0);
  std::unique_ptr<NeuralNetRES>::reset[abi:ne180100](v2, 0);
  v3 = (void *)*((_QWORD *)this + 126);
  if (v3)
  {
    *((_QWORD *)this + 127) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 123);
  if (v4)
  {
    *((_QWORD *)this + 124) = v4;
    operator delete(v4);
  }
  v5 = (void **)((char *)this + 584);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v5);
  ausdk::AUBase::~AUBase(this);
}

void AUNeuralNetSPP::CreateExtendedElements(AUNeuralNetSPP *this)
{
  unint64_t i;
  std::string *v3;
  __int128 v4;
  void **v5;
  CFIndex v6;
  CFStringRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  std::runtime_error *exception;
  std::string v12;
  void *__p[2];
  int64_t v14;

  ausdk::AUScope::Initialize((int64x2_t *)((char *)this + 568), this, 4, 16);
  for (i = 0; i != 16; ++i)
  {
    std::to_string(&v12, i);
    v3 = std::string::insert(&v12, 0, "Mic", 3uLL);
    v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    v14 = v3->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v4;
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v12.__r_.__value_.__l.__data_);
    if (v14 >= 0)
      v5 = __p;
    else
      v5 = (void **)__p[0];
    if (v14 >= 0)
      v6 = HIBYTE(v14);
    else
      v6 = (CFIndex)__p[1];
    v7 = CFStringCreateWithBytes(0, (const UInt8 *)v5, v6, 0x8000100u, 0);
    v12.__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
    if (!v7)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    v8 = *((_QWORD *)this + 76);
    if (v8)
    {
      v9 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v8 + 32))(v8, i);
    }
    else
    {
      v10 = *((_QWORD *)this + 73);
      if (i >= (*((_QWORD *)this + 74) - v10) >> 3)
        v9 = 0;
      else
        v9 = *(_QWORD *)(v10 + 8 * i);
    }
    ausdk::Owned<__CFString const*>::operator=((const void **)(v9 + 72), v7);
    if (v12.__r_.__value_.__r.__words[0])
      CFRelease(v12.__r_.__value_.__l.__data_);
    if (SHIBYTE(v14) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B6539E84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t AUNeuralNetSPP::Initialize(AUNeuralNetSPP *this)
{
  NSObject *v2;
  uint64_t Element;
  unsigned int v4;
  uint64_t v5;
  int64x2_t *Scope;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t result;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  ausdk::AUElement *v36;
  ausdk::AUElement **v37;
  uint64_t v38;
  ausdk::AUElement *v39;
  ausdk::AUElement **v40;
  NSObject *v41;
  _BOOL4 v42;
  int v43;
  const char *v44;
  __int16 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (AUNeuralNetSPPLogScope(void)::once != -1)
    dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
  if (AUNeuralNetSPPLogScope(void)::scope)
  {
    v2 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
    if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
      goto LABEL_9;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v43 = 136315394;
    v44 = "AUNeuralNetSPP.cpp";
    v45 = 1024;
    v46 = 114;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d AUNeuralNetSPP: Initialize.\n", (uint8_t *)&v43, 0x12u);
  }
LABEL_9:
  if (*((_BYTE *)this + 616) || *((_BYTE *)this + 617))
  {
    *((_DWORD *)this + 155) = *((_DWORD *)this + 84);
    (*(void (**)(AUNeuralNetSPP *))(*(_QWORD *)this + 64))(this);
    Element = ausdk::AUScope::SafeGetElement((AUNeuralNetSPP *)((char *)this + 80), 0);
    v4 = 0;
    v5 = *(_QWORD *)(Element + 80);
    *((_DWORD *)this + 158) = *(_DWORD *)(Element + 108);
    *((_QWORD *)this + 78) = v5;
    do
    {
      if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNetSPP *)((char *)this + 80), v4) + 108) != *((_DWORD *)this + 158))
        return 4294956421;
      ++v4;
    }
    while (v4 != 3);
    if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNetSPP *)((char *)this + 128), 0) + 108) != *((_DWORD *)this + 158))
      return 4294956421;
    Scope = (int64x2_t *)ausdk::AUBase::GetScope(this, 4u);
    ausdk::AUScope::SetNumberOfElements(Scope, 0x10u);
    if (!*((_BYTE *)this + 616))
    {
LABEL_51:
      if (!*((_BYTE *)this + 617))
        goto LABEL_72;
      v16 = *((_QWORD *)this + 130);
      if (*((double *)this + 78) == *(double *)v16)
      {
LABEL_62:
        if (*((_DWORD *)this + 155) == *(_DWORD *)(v16 + 8))
          goto LABEL_72;
        if (AUNeuralNetSPPLogScope(void)::once != -1)
          dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
        if (AUNeuralNetSPPLogScope(void)::scope)
        {
          v18 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
          if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
          {
LABEL_71:
            *((_BYTE *)this + 560) = 1;
LABEL_72:
            (*(void (**)(AUNeuralNetSPP *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
            if (*((_BYTE *)this + 616))
            {
              v19 = *((_QWORD *)this + 9);
              if (v19)
              {
                v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
              }
              else
              {
                v21 = (ausdk::AUElement **)*((_QWORD *)this + 6);
                if (*((ausdk::AUElement ***)this + 7) == v21)
                  v20 = 0;
                else
                  v20 = *v21;
              }
              v22 = **(_QWORD **)(*((_QWORD *)this + 129) + 152);
              v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 16))(v22);
              ausdk::AUElement::SetParameter(v20, 0, (float)v23, 0);
              v24 = *((_QWORD *)this + 9);
              if (v24)
              {
                v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
              }
              else
              {
                v26 = (ausdk::AUElement **)*((_QWORD *)this + 6);
                if (*((ausdk::AUElement ***)this + 7) == v26)
                  v25 = 0;
                else
                  v25 = *v26;
              }
              ausdk::AUElement::SetParameter(v25, 1u, (float)*(unsigned int *)(*((_QWORD *)this + 129) + 12), 0);
              v27 = *((_QWORD *)this + 9);
              if (v27)
              {
                v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
              }
              else
              {
                v29 = (ausdk::AUElement **)*((_QWORD *)this + 6);
                if (*((ausdk::AUElement ***)this + 7) == v29)
                  v28 = 0;
                else
                  v28 = *v29;
              }
              ausdk::AUElement::SetParameter(v28, 2u, *(float *)(*((_QWORD *)this + 129) + 16), 0);
            }
            if (*((_BYTE *)this + 617))
            {
              v30 = *((_QWORD *)this + 9);
              if (v30)
              {
                v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
              }
              else
              {
                v32 = (ausdk::AUElement **)*((_QWORD *)this + 6);
                if (*((ausdk::AUElement ***)this + 7) == v32)
                  v31 = 0;
                else
                  v31 = *v32;
              }
              v33 = **(_QWORD **)(*((_QWORD *)this + 130) + 152);
              v34 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v33 + 16))(v33);
              ausdk::AUElement::SetParameter(v31, 5u, (float)v34, 0);
              v35 = *((_QWORD *)this + 9);
              if (v35)
              {
                v36 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 32))(v35, 0);
              }
              else
              {
                v37 = (ausdk::AUElement **)*((_QWORD *)this + 6);
                if (*((ausdk::AUElement ***)this + 7) == v37)
                  v36 = 0;
                else
                  v36 = *v37;
              }
              ausdk::AUElement::SetParameter(v36, 6u, (float)*(unsigned int *)(*((_QWORD *)this + 130) + 12), 0);
              v38 = *((_QWORD *)this + 9);
              if (v38)
              {
                v39 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v38 + 32))(v38, 0);
              }
              else
              {
                v40 = (ausdk::AUElement **)*((_QWORD *)this + 6);
                if (*((ausdk::AUElement ***)this + 7) == v40)
                  v39 = 0;
                else
                  v39 = *v40;
              }
              ausdk::AUElement::SetParameter(v39, 7u, *(float *)(*((_QWORD *)this + 130) + 16), 0);
            }
            if (AUNeuralNetSPPLogScope(void)::once != -1)
              dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
            if (AUNeuralNetSPPLogScope(void)::scope)
            {
              v41 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
              if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
                return 0;
            }
            else
            {
              v41 = MEMORY[0x1E0C81028];
            }
            v42 = os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT);
            result = 0;
            if (v42)
            {
              v43 = 136315394;
              v44 = "AUNeuralNetSPP.cpp";
              v45 = 1024;
              v46 = 206;
              _os_log_impl(&dword_1B5ED0000, v41, OS_LOG_TYPE_DEFAULT, "%25s:%-5d AUNeuralNetSPP: Successfully Initialized.\n", (uint8_t *)&v43, 0x12u);
              return 0;
            }
            return result;
          }
        }
        else
        {
          v18 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          v43 = 136315394;
          v44 = "AUNeuralNetSPP.cpp";
          v45 = 1024;
          v46 = 185;
          _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Block size for NNRES is not supported! Setting AU in Bypass mode.\n", (uint8_t *)&v43, 0x12u);
        }
        goto LABEL_71;
      }
      if (AUNeuralNetSPPLogScope(void)::once != -1)
        dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
      if (AUNeuralNetSPPLogScope(void)::scope)
      {
        v17 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
        if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
        {
LABEL_61:
          *((_BYTE *)this + 560) = 1;
          v16 = *((_QWORD *)this + 130);
          goto LABEL_62;
        }
      }
      else
      {
        v17 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v43 = 136315394;
        v44 = "AUNeuralNetSPP.cpp";
        v45 = 1024;
        v46 = 181;
        _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Sample rate for NNRES is not supported! Setting AU in Bypass mode.\n", (uint8_t *)&v43, 0x12u);
      }
      goto LABEL_61;
    }
    v7 = *((_QWORD *)this + 129);
    if (*((double *)this + 78) == *(double *)v7)
    {
LABEL_41:
      if (*((_DWORD *)this + 155) == *(_DWORD *)(v7 + 8))
        goto LABEL_51;
      if (AUNeuralNetSPPLogScope(void)::once != -1)
        dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
      if (AUNeuralNetSPPLogScope(void)::scope)
      {
        v15 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
        if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
        {
LABEL_50:
          *((_BYTE *)this + 560) = 1;
          goto LABEL_51;
        }
      }
      else
      {
        v15 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v43 = 136315394;
        v44 = "AUNeuralNetSPP.cpp";
        v45 = 1024;
        v46 = 175;
        _os_log_impl(&dword_1B5ED0000, v15, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Block size for NNNS is not supported! Setting AU in Bypass mode.\n", (uint8_t *)&v43, 0x12u);
      }
      goto LABEL_50;
    }
    if (AUNeuralNetSPPLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
    if (AUNeuralNetSPPLogScope(void)::scope)
    {
      v8 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
      if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
      {
LABEL_40:
        *((_BYTE *)this + 560) = 1;
        v7 = *((_QWORD *)this + 129);
        goto LABEL_41;
      }
    }
    else
    {
      v8 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v43 = 136315394;
      v44 = "AUNeuralNetSPP.cpp";
      v45 = 1024;
      v46 = 171;
      _os_log_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Sample rate for NNNS is not supported! Setting AU in Bypass mode.\n", (uint8_t *)&v43, 0x12u);
    }
    goto LABEL_40;
  }
  if (AUNeuralNetSPPLogScope(void)::once != -1)
    dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
  if (!AUNeuralNetSPPLogScope(void)::scope)
  {
    v9 = MEMORY[0x1E0C81028];
LABEL_28:
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v43 = 136315394;
      v44 = "AUNeuralNetSPP.cpp";
      v45 = 1024;
      v46 = 121;
      _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Initialize called without setting setting NeuralNetNSLayers or NeuralNetRESLayers plist! Setting AU in Bypass mode.\n", (uint8_t *)&v43, 0x12u);
    }
    goto LABEL_30;
  }
  v9 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
  if (*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
    goto LABEL_28;
LABEL_30:
  *((_BYTE *)this + 560) = 1;
  v10 = ausdk::AUScope::SafeGetElement((AUNeuralNetSPP *)((char *)this + 80), 0);
  v11 = 0;
  v12 = *(_QWORD *)(v10 + 80);
  *((_DWORD *)this + 158) = *(_DWORD *)(v10 + 108);
  *((_QWORD *)this + 78) = v12;
  do
  {
    if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNetSPP *)((char *)this + 80), v11) + 108) != *((_DWORD *)this + 158))
      return 4294956421;
    ++v11;
  }
  while (v11 != 3);
  if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNetSPP *)((char *)this + 128), 0) + 108) != *((_DWORD *)this + 158))
    return 4294956421;
  v13 = *((_DWORD *)this + 84);
  *((_DWORD *)this + 155) = v13;
  *((_QWORD *)this + 124) = *((_QWORD *)this + 123);
  std::vector<float>::resize((uint64_t)this + 984, (v13 + 1));
  *((_QWORD *)this + 127) = *((_QWORD *)this + 126);
  std::vector<float>::resize((uint64_t)this + 1008, (*((_DWORD *)this + 155) + 1));
  return 0;
}

char *AUNeuralNetSPP::Cleanup(AUNeuralNetSPP *this)
{
  NSObject *v2;
  unint64_t v3;
  unint64_t v4;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (AUNeuralNetSPPLogScope(void)::once != -1)
    dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
  if (AUNeuralNetSPPLogScope(void)::scope)
  {
    v2 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
    if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
      goto LABEL_9;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136315394;
    v7 = "AUNeuralNetSPP.cpp";
    v8 = 1024;
    v9 = 218;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d AUNeuralNetSPP: Cleanup().\n", (uint8_t *)&v6, 0x12u);
  }
LABEL_9:
  if (*((_BYTE *)this + 616))
    NeuralNetRES::Cleanup(*((NeuralNetRES **)this + 129));
  if (*((_BYTE *)this + 617))
    NeuralNetRES::Cleanup(*((NeuralNetRES **)this + 130));
  v3 = (*((_DWORD *)this + 155) + 1);
  v6 = 0;
  std::vector<float>::assign((char **)this + 123, v3, &v6);
  v4 = (*((_DWORD *)this + 155) + 1);
  v6 = 0;
  return std::vector<float>::assign((char **)this + 126, v4, &v6);
}

uint64_t AUNeuralNetSPP::Reset(AUNeuralNetSPP *this)
{
  return 0;
}

uint64_t AUNeuralNetSPP::GetPropertyInfo(AUNeuralNetSPP *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  int v8;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 36998)
  {
    if (a2 == 21)
    {
LABEL_7:
      *a6 = 1;
      v8 = 4;
LABEL_13:
      result = 0;
      *a5 = v8;
      return result;
    }
    if (a2 != 3699)
    {
      if (a2 != 3700)
        return result;
      goto LABEL_7;
    }
LABEL_12:
    *a6 = 0;
    v8 = 4 * *((_DWORD *)this + 155) + 4;
    goto LABEL_13;
  }
  if (a2 == 36999)
    goto LABEL_12;
  if (a2 == 103699 || a2 == 1036999)
  {
    *a6 = 0;
    v8 = 8;
    goto LABEL_13;
  }
  return result;
}

uint64_t AUNeuralNetSPP::GetProperty(AUNeuralNetSPP *this, int a2, int a3, unsigned int a4, _DWORD *__dst)
{
  uint64_t result;
  int v8;
  char *v9;
  const void *v10;
  CFArrayRef CFArray;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 36998)
  {
    if (a2 == 21)
    {
      result = 0;
      v8 = *((unsigned __int8 *)this + 560);
LABEL_13:
      *__dst = v8;
      return result;
    }
    if (a2 != 3699)
    {
      if (a2 != 3700)
        return result;
      result = 0;
      v8 = *((unsigned __int8 *)this + 376);
      goto LABEL_13;
    }
    v10 = (const void *)*((_QWORD *)this + 123);
    goto LABEL_16;
  }
  switch(a2)
  {
    case 36999:
      v10 = (const void *)*((_QWORD *)this + 126);
LABEL_16:
      memcpy(__dst, v10, 4 * (*((_DWORD *)this + 155) + 1));
      return 0;
    case 103699:
      v9 = (char *)this + 984;
      break;
    case 1036999:
      v9 = (char *)this + 1008;
      break;
    default:
      return result;
  }
  CFArray = applesauce::CF::details::make_CFArrayRef<float>(v9);
  result = 0;
  *(_QWORD *)__dst = CFArray;
  return result;
}

uint64_t AUNeuralNetSPP::SetProperty(AUNeuralNetSPP *this, int a2, int a3, unsigned int a4, _BYTE *a5, unsigned int a6)
{
  uint64_t result;
  const __CFDictionary *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  const __CFDictionary *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 3697)
  {
    if (a2 != 3698)
    {
      if (a2 == 3700)
      {
        result = 4294956445;
        if (a6 >= 4)
        {
          if (*a5)
            return 0;
          else
            return 4294956445;
        }
      }
      return result;
    }
    if (!a5)
    {
      if (AUNeuralNetSPPLogScope(void)::once != -1)
        dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
      if (AUNeuralNetSPPLogScope(void)::scope)
      {
        v16 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
        if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
          return 4294956445;
      }
      else
      {
        v16 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v18 = "AUNeuralNetSPP.cpp";
        v19 = 1024;
        v20 = 488;
        goto LABEL_58;
      }
      return 4294956445;
    }
    v12 = *(const __CFDictionary **)a5;
    if (*((_QWORD *)this + 130))
      std::unique_ptr<NeuralNetRES>::reset[abi:ne180100]((uint64_t *)this + 130, 0);
    if (AUNeuralNetSPPLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
    v13 = AUNeuralNetSPPLogScope(void)::scope;
    v14 = operator new();
    NeuralNetRES::NeuralNetRES(v14, v12, v13);
    std::unique_ptr<NeuralNetRES>::reset[abi:ne180100]((uint64_t *)this + 130, v14);
    if (AUNeuralNetSPPLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
    if (AUNeuralNetSPPLogScope(void)::scope)
    {
      v15 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
      if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
      {
LABEL_51:
        result = 0;
        *((_BYTE *)this + 617) = 1;
        return result;
      }
    }
    else
    {
      v15 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315394;
      v18 = "AUNeuralNetSPP.cpp";
      v19 = 1024;
      v20 = 512;
      _os_log_impl(&dword_1B5ED0000, v15, OS_LOG_TYPE_INFO, "%25s:%-5d Successfully loaded NeuralNetRES plist.\n", buf, 0x12u);
    }
    goto LABEL_51;
  }
  if (a2 == 21)
  {
    result = 0;
    *((_BYTE *)this + 560) = *(_DWORD *)a5 != 0;
    return result;
  }
  if (a2 == 3697)
  {
    if (a5)
    {
      v8 = *(const __CFDictionary **)a5;
      if (*((_QWORD *)this + 129))
        std::unique_ptr<NeuralNetRES>::reset[abi:ne180100]((uint64_t *)this + 129, 0);
      if (AUNeuralNetSPPLogScope(void)::once != -1)
        dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
      v9 = AUNeuralNetSPPLogScope(void)::scope;
      v10 = operator new();
      NeuralNetRES::NeuralNetRES(v10, v8, v9);
      std::unique_ptr<NeuralNetRES>::reset[abi:ne180100]((uint64_t *)this + 129, v10);
      if (AUNeuralNetSPPLogScope(void)::once != -1)
        dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
      if (AUNeuralNetSPPLogScope(void)::scope)
      {
        v11 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
        if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
        {
LABEL_47:
          result = 0;
          *((_BYTE *)this + 616) = 1;
          return result;
        }
      }
      else
      {
        v11 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136315394;
        v18 = "AUNeuralNetSPP.cpp";
        v19 = 1024;
        v20 = 470;
        _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_INFO, "%25s:%-5d Successfully loaded NeuralNetNS plist.\n", buf, 0x12u);
      }
      goto LABEL_47;
    }
    if (AUNeuralNetSPPLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
    if (AUNeuralNetSPPLogScope(void)::scope)
    {
      v16 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
      if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
        return 4294956445;
    }
    else
    {
      v16 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v18 = "AUNeuralNetSPP.cpp";
      v19 = 1024;
      v20 = 446;
LABEL_58:
      _os_log_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d The CFDictionaryRef passed to SetProperty is null.\n", buf, 0x12u);
      return 4294956445;
    }
    return 4294956445;
  }
  return result;
}

void sub_1B653AEC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void (**a9)(CAException *__hidden this), int a10, int a11, __int128 buf, __int16 a13, __int16 a14, int a15)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *exception_ptr;
  int v21;
  NSObject **v22;
  NSObject *v23;

  MEMORY[0x1BCC95CEC](v15, 0x10E0C403CD53A6ALL);
  if (a2 != 1)
    _Unwind_Resume(a1);
  exception_ptr = __cxa_get_exception_ptr(a1);
  a9 = &off_1E69EE218;
  v21 = exception_ptr[2];
  a10 = v21;
  __cxa_begin_catch(a1);
  if (*(_QWORD *)(v17 + 608) != -1)
    dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
  v22 = *(NSObject ***)(v16 + 600);
  if (v22)
  {
    v23 = *v22;
    if (!*v22)
      goto LABEL_10;
  }
  else
  {
    v23 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315650;
    *(_QWORD *)((char *)&buf + 4) = "AUNeuralNetSPP.cpp";
    WORD6(buf) = 1024;
    *(_DWORD *)((char *)&buf + 14) = 501;
    a14 = 1024;
    a15 = v21;
    _os_log_impl(&dword_1B5ED0000, v23, OS_LOG_TYPE_ERROR, "%25s:%-5d Could not load NeuralNetRES plist, exception (%d).\n", (uint8_t *)&buf, 0x18u);
  }
LABEL_10:
  std::exception::~exception((std::exception *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x1B653AE24);
}

uint64_t AUNeuralNetSPP::SetParameter(AUNeuralNetSPP *this, unsigned int a2, int a3, uint64_t a4, float a5)
{
  uint64_t v8;
  ausdk::AUElement *v9;
  uint64_t v10;
  ausdk::AUElement *v11;
  uint64_t result;
  ausdk::AUElement **v13;
  uint64_t v14;
  char *v15;

  if (a3 == 4)
  {
    v10 = *((_QWORD *)this + 76);
    if (v10)
    {
      v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 32))(v10, a4);
    }
    else
    {
      v14 = *((_QWORD *)this + 73);
      if (a4 >= (unint64_t)((*((_QWORD *)this + 74) - v14) >> 3))
        v11 = 0;
      else
        v11 = *(ausdk::AUElement **)(v14 + 8 * a4);
    }
    ausdk::AUElement::SetParameter(v11, a2, a5, 0);
    v15 = (char *)this + 544;
  }
  else
  {
    if (a3)
      return 4294956418;
    v8 = *((_QWORD *)this + 9);
    if (v8)
    {
      v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
    }
    else
    {
      v13 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v13)
        v9 = 0;
      else
        v9 = *v13;
    }
    ausdk::AUElement::SetParameter(v9, a2, a5, 0);
    v15 = (char *)this + 528;
  }
  result = 0;
  ++*(_QWORD *)v15;
  return result;
}

uint64_t AUNeuralNetSPP::CanScheduleParameters(AUNeuralNetSPP *this)
{
  return 0;
}

uint64_t AUNeuralNetSPP::ProcessMultipleBufferLists(AUNeuralNetSPP *this, unsigned int *a2, AudioDSP::Utility *a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  int v9;
  uint64_t v11;
  uint64_t v12;
  ausdk::AUElement *v13;
  ausdk::AUElement **v14;
  float Parameter;
  float v16;
  uint64_t v17;
  ausdk::AUElement *v18;
  ausdk::AUElement **v19;
  float v20;
  float v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  float v25;
  float v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  float v30;
  float v31;
  uint64_t v32;
  ausdk::AUElement *v33;
  ausdk::AUElement **v34;
  uint64_t v35;
  ausdk::AUElement *v36;
  ausdk::AUElement **v37;
  float v38;
  float v39;
  uint64_t v40;
  unint64_t v41;
  float *v42;
  uint64_t v43;
  ausdk::AUElement *v44;
  uint64_t v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  uint64_t v48;
  uint64_t v49;
  ausdk::AUElement *v50;
  uint64_t v51;
  uint64_t v52;
  ausdk::AUElement *v53;
  uint64_t v54;
  uint64_t v55;
  ausdk::AUElement *v56;
  uint64_t v57;
  int *v58;
  int v59;
  const AudioBufferList *v60;
  const AudioBufferList *v61;
  AudioDSP::Utility *v62;
  BOOL *v63;
  BOOL *v64;
  NSObject *v65;
  NSObject *v67;
  const char *v68;
  unint64_t v69;
  unint64_t v70;
  float v71;
  uint64_t v72;
  BOOL *v73;
  unint64_t v74;
  uint64_t v75;
  NSObject *v76;
  float __A;
  AudioStreamBasicDescription v78;
  AudioBufferList buf;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;

  v9 = (int)a3;
  v83 = *MEMORY[0x1E0C80C00];
  v11 = *((_QWORD *)this + 66);
  if (*((_QWORD *)this + 67) != v11)
  {
    v12 = *((_QWORD *)this + 9);
    if (v12)
    {
      v13 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, 0);
    }
    else
    {
      v14 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v14)
        v13 = 0;
      else
        v13 = *v14;
    }
    Parameter = ausdk::AUElement::GetParameter(v13, 3u);
    v16 = 1.0;
    if (Parameter != 0.0)
      v16 = __exp10f(Parameter / 20.0);
    *((float *)this + 160) = v16;
    v17 = *((_QWORD *)this + 9);
    if (v17)
    {
      v18 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 32))(v17, 0);
    }
    else
    {
      v19 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v19)
        v18 = 0;
      else
        v18 = *v19;
    }
    v20 = ausdk::AUElement::GetParameter(v18, 4u);
    v21 = 1.0;
    if (v20 != 0.0)
      v21 = __exp10f(v20 / 20.0);
    *((float *)this + 161) = v21;
    v22 = *((_QWORD *)this + 9);
    if (v22)
    {
      v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
    }
    else
    {
      v24 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v24)
        v23 = 0;
      else
        v23 = *v24;
    }
    v25 = ausdk::AUElement::GetParameter(v23, 8u);
    v26 = 1.0;
    if (v25 != 0.0)
      v26 = __exp10f(v25 / 20.0);
    *((float *)this + 162) = v26;
    v27 = *((_QWORD *)this + 9);
    if (v27)
    {
      v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
    }
    else
    {
      v29 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v29)
        v28 = 0;
      else
        v28 = *v29;
    }
    v30 = ausdk::AUElement::GetParameter(v28, 9u);
    v31 = 1.0;
    if (v30 != 0.0)
      v31 = __exp10f(v30 / 20.0);
    *((float *)this + 163) = v31;
    v32 = *((_QWORD *)this + 9);
    if (v32)
    {
      v33 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v32 + 32))(v32, 0);
    }
    else
    {
      v34 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v34)
        v33 = 0;
      else
        v33 = *v34;
    }
    *((_BYTE *)this + 656) = ausdk::AUElement::GetParameter(v33, 0xAu) != 0.0;
    v35 = *((_QWORD *)this + 9);
    if (v35)
    {
      v36 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 32))(v35, 0);
    }
    else
    {
      v37 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v37)
        v36 = 0;
      else
        v36 = *v37;
    }
    v38 = ausdk::AUElement::GetParameter(v36, 0xBu);
    v39 = 1.0;
    if (v38 != 0.0)
      v39 = __exp10f(v38 / 10.0);
    *((float *)this + 165) = v39;
    *((_QWORD *)this + 67) = v11;
  }
  v40 = *((_QWORD *)this + 68);
  if (*((_QWORD *)this + 69) != v40)
  {
    if (*((_DWORD *)this + 158))
    {
      v41 = 0;
      v42 = (float *)((char *)this + 680);
      do
      {
        v43 = *((_QWORD *)this + 76);
        if (v43)
        {
          v44 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v43 + 32))(v43, v41);
        }
        else
        {
          v45 = *((_QWORD *)this + 73);
          if (v41 >= (*((_QWORD *)this + 74) - v45) >> 3)
            v44 = 0;
          else
            v44 = *(ausdk::AUElement **)(v45 + 8 * v41);
        }
        *(v42 - 4) = ausdk::AUElement::GetParameter(v44, 0x64u);
        v46 = *((_QWORD *)this + 76);
        if (v46)
        {
          v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v46 + 32))(v46, v41);
        }
        else
        {
          v48 = *((_QWORD *)this + 73);
          if (v41 >= (*((_QWORD *)this + 74) - v48) >> 3)
            v47 = 0;
          else
            v47 = *(ausdk::AUElement **)(v48 + 8 * v41);
        }
        *(v42 - 3) = ausdk::AUElement::GetParameter(v47, 0x65u);
        v49 = *((_QWORD *)this + 76);
        if (v49)
        {
          v50 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v49 + 32))(v49, v41);
        }
        else
        {
          v51 = *((_QWORD *)this + 73);
          if (v41 >= (*((_QWORD *)this + 74) - v51) >> 3)
            v50 = 0;
          else
            v50 = *(ausdk::AUElement **)(v51 + 8 * v41);
        }
        *(v42 - 2) = ausdk::AUElement::GetParameter(v50, 0x66u);
        v52 = *((_QWORD *)this + 76);
        if (v52)
        {
          v53 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v52 + 32))(v52, v41);
        }
        else
        {
          v54 = *((_QWORD *)this + 73);
          if (v41 >= (*((_QWORD *)this + 74) - v54) >> 3)
            v53 = 0;
          else
            v53 = *(ausdk::AUElement **)(v54 + 8 * v41);
        }
        *(v42 - 1) = ausdk::AUElement::GetParameter(v53, 0x67u);
        v55 = *((_QWORD *)this + 76);
        if (v55)
        {
          v56 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v55 + 32))(v55, v41);
        }
        else
        {
          v57 = *((_QWORD *)this + 73);
          if (v41 >= (*((_QWORD *)this + 74) - v57) >> 3)
            v56 = 0;
          else
            v56 = *(ausdk::AUElement **)(v57 + 8 * v41);
        }
        *v42 = ausdk::AUElement::GetParameter(v56, 0x68u);
        v42 += 5;
        ++v41;
      }
      while (v41 < *((unsigned int *)this + 158));
    }
    *((_QWORD *)this + 69) = v40;
  }
  if (*((_DWORD *)this + 84) != v9)
    return 4294956422;
  v58 = (int *)*a5;
  if (!*a5)
  {
    if (AUNeuralNetSPPLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
    if (AUNeuralNetSPPLogScope(void)::scope)
    {
      v67 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
      if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
        return 4294956420;
    }
    else
    {
      v67 = MEMORY[0x1E0C81028];
    }
    if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
      return 4294956420;
    buf.mNumberBuffers = 136315394;
    *(_QWORD *)(&buf.mNumberBuffers + 1) = "AUNeuralNetSPP.cpp";
    LOWORD(buf.mBuffers[0].mDataByteSize) = 1024;
    *(UInt32 *)((char *)&buf.mBuffers[0].mDataByteSize + 2) = 1082;
    v68 = "%25s:%-5d MCLPoutSignals cannot be NULL. It is a required input\n";
LABEL_116:
    _os_log_impl(&dword_1B5ED0000, v67, OS_LOG_TYPE_ERROR, v68, (uint8_t *)&buf, 0x12u);
    return 4294956420;
  }
  v59 = *v58;
  if (*v58 != *((_DWORD *)this + 158))
    return 4294956428;
  v60 = a5[1];
  if (!v60)
  {
    if (AUNeuralNetSPPLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
    if (AUNeuralNetSPPLogScope(void)::scope)
    {
      v67 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
      if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
        return 4294956420;
    }
    else
    {
      v67 = MEMORY[0x1E0C81028];
    }
    if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
      return 4294956420;
    buf.mNumberBuffers = 136315394;
    *(_QWORD *)(&buf.mNumberBuffers + 1) = "AUNeuralNetSPP.cpp";
    LOWORD(buf.mBuffers[0].mDataByteSize) = 1024;
    *(UInt32 *)((char *)&buf.mBuffers[0].mDataByteSize + 2) = 1087;
    v68 = "%25s:%-5d ECleeSignals cannot be NULL. It is a required input\n";
    goto LABEL_116;
  }
  if (v60->mNumberBuffers != v59)
    return 4294956428;
  v61 = a5[2];
  if (!v61)
  {
    if (AUNeuralNetSPPLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
    if (AUNeuralNetSPPLogScope(void)::scope)
    {
      v67 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
      if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
        return 4294956420;
    }
    else
    {
      v67 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      buf.mNumberBuffers = 136315394;
      *(_QWORD *)(&buf.mNumberBuffers + 1) = "AUNeuralNetSPP.cpp";
      LOWORD(buf.mBuffers[0].mDataByteSize) = 1024;
      *(UInt32 *)((char *)&buf.mBuffers[0].mDataByteSize + 2) = 1092;
      v68 = "%25s:%-5d ECoutSignals cannot be NULL. It is a required input\n";
      goto LABEL_116;
    }
    return 4294956420;
  }
  if (v61->mNumberBuffers != v59 || *a7 && (*a7)->mNumberBuffers != v59)
    return 4294956428;
  LODWORD(v78.mSampleRate) = 0;
  v62 = (AudioDSP::Utility *)(2 * *((_DWORD *)this + 155));
  *(_QWORD *)&buf.mNumberBuffers = *((_QWORD *)this + 78);
  buf.mBuffers[0] = (AudioBuffer)xmmword_1B6626900;
  v80 = 4;
  v81 = v59;
  v82 = 32;
  AudioDSP::Utility::DetectNonFinites(v62, v58, &buf, (AudioStreamBasicDescription *)((char *)&v78.mSampleRate + 3), (BOOL *)a5);
  AudioDSP::Utility::DetectNonFinites(v62, a5[1], &buf, (AudioStreamBasicDescription *)((char *)&v78.mSampleRate + 2), v63);
  AudioDSP::Utility::DetectNonFinites(v62, a5[2], &buf, (AudioStreamBasicDescription *)((char *)&v78.mSampleRate + 1), v64);
  if (*((_BYTE *)this + 560) || (WORD1(v78.mSampleRate) || BYTE1(v78.mSampleRate)) && *((_BYTE *)this + 636))
  {
    __A = 1.0;
    vDSP_vfill(&__A, *((float **)this + 123), 1, (*((_DWORD *)this + 155) + 1));
    vDSP_vfill(&__A, *((float **)this + 126), 1, (*((_DWORD *)this + 155) + 1));
    CopyBufferList(&(*a5)->mNumberBuffers, *a7);
    if (!WORD1(v78.mSampleRate) && !BYTE1(v78.mSampleRate))
      return 0;
    if (AUNeuralNetSPPLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
    if (AUNeuralNetSPPLogScope(void)::scope)
    {
      v65 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
      if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
        return 0;
    }
    else
    {
      v65 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      HIDWORD(v78.mSampleRate) = 136316162;
      *(_QWORD *)&v78.mFormatID = "AUNeuralNetSPP.cpp";
      LOWORD(v78.mBytesPerPacket) = 1024;
      *(UInt32 *)((char *)&v78.mBytesPerPacket + 2) = 1128;
      HIWORD(v78.mFramesPerPacket) = 1024;
      v78.mBytesPerFrame = BYTE3(v78.mSampleRate);
      LOWORD(v78.mChannelsPerFrame) = 1024;
      *(UInt32 *)((char *)&v78.mChannelsPerFrame + 2) = BYTE2(v78.mSampleRate);
      HIWORD(v78.mBitsPerChannel) = 1024;
      v78.mReserved = BYTE1(v78.mSampleRate);
      _os_log_impl(&dword_1B5ED0000, v65, OS_LOG_TYPE_ERROR, "%25s:%-5d AUNeuralNetSPP: (MCLPoutSignals, ECleeSignals, ECoutSignals) is NOT finite: (%u, %u, %u)", (uint8_t *)&v78.mSampleRate + 4, 0x24u);
    }
    return 0;
  }
  LODWORD(v69) = *((_DWORD *)this + 158);
  if ((_DWORD)v69)
  {
    v70 = 0;
    v71 = 0.0;
    v72 = 16;
    do
    {
      v71 = cblas_sdsdot(2 * *((_DWORD *)this + 155), v71, *(const float **)((char *)&a5[1]->mNumberBuffers + v72), 1, *(const float **)((char *)&a5[1]->mNumberBuffers + v72), 1);
      ++v70;
      v69 = *((unsigned int *)this + 158);
      v72 += 16;
    }
    while (v70 < v69);
    if (v71 > 2.2204e-16)
    {
      if ((*((float *)this + 162) != 1.0 || *((float *)this + 163) != 1.0) && *((_BYTE *)this + 617))
      {
        NeuralNetRES::ProcessBufferList(*((NeuralNetRES **)this + 130), *a5, a5[1], *a7, 0.0, 1, *((unsigned __int8 *)this + 656), *((float *)this + 165));
        vDSP_vthr(*(const float **)(*((_QWORD *)this + 130) + 192), 1, (const float *)this + 162, *((float **)this + 123), 1, (*((_DWORD *)this + 155) + 1));
        vDSP_vthr(*(const float **)(*((_QWORD *)this + 130) + 192), 1, (const float *)this + 163, *((float **)this + 126), 1, (*((_DWORD *)this + 155) + 1));
        goto LABEL_140;
      }
LABEL_139:
      HIDWORD(v78.mSampleRate) = 1065353216;
      vDSP_vfill((const float *)&v78.mSampleRate + 1, *((float **)this + 123), 1, (*((_DWORD *)this + 155) + 1));
      vDSP_vfill((const float *)&v78.mSampleRate + 1, *((float **)this + 126), 1, (*((_DWORD *)this + 155) + 1));
      CopyBufferList(&(*a5)->mNumberBuffers, *a7);
      goto LABEL_140;
    }
  }
  if (*((float *)this + 160) == 1.0 && *((float *)this + 161) == 1.0 || !*((_BYTE *)this + 616))
    goto LABEL_139;
  if ((_DWORD)v69)
  {
    v74 = 0;
    v75 = 16;
    do
    {
      vDSP_vsub(*(const float **)((char *)&(*a5)->mNumberBuffers + v75), 1, *(const float **)((char *)&a5[2]->mNumberBuffers + v75), 1, *(float **)((char *)&(*a7)->mNumberBuffers + v75), 1, (2 * *((_DWORD *)this + 155)));
      ++v74;
      v75 += 16;
    }
    while (v74 < *((unsigned int *)this + 158));
  }
  NeuralNetRES::ProcessBufferList(*((NeuralNetRES **)this + 129), *a5, *a7, *a7, 0.0, 1, *((unsigned __int8 *)this + 656), *((float *)this + 165));
  vDSP_vthr(*(const float **)(*((_QWORD *)this + 129) + 192), 1, (const float *)this + 160, *((float **)this + 123), 1, (*((_DWORD *)this + 155) + 1));
  vDSP_vthr(*(const float **)(*((_QWORD *)this + 129) + 192), 1, (const float *)this + 161, *((float **)this + 126), 1, (*((_DWORD *)this + 155) + 1));
LABEL_140:
  AudioDSP::Utility::DetectNonFinites(v62, *a7, &buf, &v78, v73);
  if (!LOBYTE(v78.mSampleRate) || !*((_BYTE *)this + 636))
    return 0;
  if (AUNeuralNetSPPLogScope(void)::once != -1)
    dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
  if (!AUNeuralNetSPPLogScope(void)::scope)
  {
    v76 = MEMORY[0x1E0C81028];
LABEL_148:
    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
    {
      HIDWORD(v78.mSampleRate) = 136315650;
      *(_QWORD *)&v78.mFormatID = "AUNeuralNetSPP.cpp";
      LOWORD(v78.mBytesPerPacket) = 1024;
      *(UInt32 *)((char *)&v78.mBytesPerPacket + 2) = 1202;
      HIWORD(v78.mFramesPerPacket) = 1024;
      v78.mBytesPerFrame = LOBYTE(v78.mSampleRate);
      _os_log_impl(&dword_1B5ED0000, v76, OS_LOG_TYPE_ERROR, "%25s:%-5d AUNeuralNetSPP: (OutputSignals) is NOT finite: (%u)", (uint8_t *)&v78.mSampleRate + 4, 0x18u);
    }
    goto LABEL_150;
  }
  v76 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
  if (*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
    goto LABEL_148;
LABEL_150:
  (*(void (**)(AUNeuralNetSPP *))(*(_QWORD *)this + 64))(this);
  HIDWORD(v78.mSampleRate) = 1065353216;
  vDSP_vfill((const float *)&v78.mSampleRate + 1, *((float **)this + 123), 1, (*((_DWORD *)this + 155) + 1));
  vDSP_vfill((const float *)&v78.mSampleRate + 1, *((float **)this + 126), 1, (*((_DWORD *)this + 155) + 1));
  CopyBufferList(&(*a5)->mNumberBuffers, *a7);
  return 0;
}

uint64_t AUNeuralNetSPP::Render(AUNeuralNetSPP *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  uint64_t v8;
  char v9;
  ausdk::AUScope *v10;
  ausdk::AUInputElement *Element;
  uint64_t result;
  ausdk::AUIOElement *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[3];
  _QWORD v18[2];

  v8 = 0;
  v9 = 0;
  v18[1] = *MEMORY[0x1E0C80C00];
  v10 = (AUNeuralNetSPP *)((char *)this + 80);
  do
  {
    if (ausdk::AUBase::HasInput(this, v8))
    {
      Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v10, v8);
      result = ausdk::AUInputElement::PullInput(Element, a2, a3, v8, a4);
      if ((_DWORD)result)
        return result;
    }
    else
    {
      v9 = 1;
    }
    v8 = (v8 + 1);
  }
  while ((_DWORD)v8 != 3);
  v13 = (ausdk::AUIOElement *)ausdk::AUScope::SafeGetElement((AUNeuralNetSPP *)((char *)this + 128), 0);
  v14 = ausdk::AUIOElement::PrepareBuffer(v13, a4);
  result = 0;
  v18[0] = v14;
  if ((v9 & 1) == 0)
  {
    v15 = 0;
    memset(v17, 0, sizeof(v17));
    do
    {
      v16 = ausdk::AUScope::SafeGetElement(v10, v15);
      v17[v15++] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v16 + 144));
    }
    while (v15 != 3);
    return (*(uint64_t (**)(AUNeuralNetSPP *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, _QWORD *))(*(_QWORD *)this + 184))(this, a2, a4, 3, v17, 1, v18);
  }
  return result;
}

uint64_t AUNeuralNetSPP::GetParameterList(AUNeuralNetSPP *this, int a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t result;

  if (a2 == 4)
  {
    if (!a3)
    {
      v4 = 5;
      goto LABEL_11;
    }
    v4 = 5;
    *a3 = 100;
    v12 = 104;
    v11 = 103;
    v10 = 102;
    v9 = 101;
    v5 = 4;
    v6 = 3;
    v7 = 2;
    v8 = 1;
  }
  else
  {
    if (a2)
      return 4294956430;
    if (!a3)
    {
      v4 = 12;
      goto LABEL_11;
    }
    v4 = 12;
    v5 = 11;
    v6 = 10;
    v7 = 9;
    v8 = 8;
    *(_OWORD *)a3 = xmmword_1B6626920;
    *((_OWORD *)a3 + 1) = xmmword_1B66A0770;
    v9 = 8;
    v10 = 9;
    v11 = 10;
    v12 = 11;
  }
  a3[v8] = v9;
  a3[v7] = v10;
  a3[v6] = v11;
  a3[v5] = v12;
LABEL_11:
  result = 0;
  *a4 = v4;
  return result;
}

uint64_t AUNeuralNetSPP::GetParameterInfo(AUNeuralNetSPP *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t v5;
  uint64_t result;
  const __CFString *v7;
  AudioUnitParameterOptions flags;
  int v9;
  AudioUnitParameterOptions v10;
  AudioUnitParameterValue v11;
  const __CFString *v12;
  AudioUnitParameterOptions v13;
  AudioUnitParameterValue v14;
  const __CFString *v15;
  AudioUnitParameterOptions v16;

  buffer->flags = 0;
  buffer->unitName = 0;
  if (a2 == 4)
  {
    switch(a3)
    {
      case 'd':
        buffer->cfNameString = CFSTR("EC Delta EIR.");
        buffer->flags = 0x8000000;
        CFStringGetCString(CFSTR("EC Delta EIR."), buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Generic;
        buffer->defaultValue = 0.0;
        v5 = 0x501502F900000000;
        goto LABEL_14;
      case 'e':
        buffer->cfNameString = CFSTR("EC IR Delay.");
        buffer->flags = 0x8000000;
        CFStringGetCString(CFSTR("EC IR Delay."), buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Generic;
        buffer->defaultValue = 0.0;
        v5 = 0x43C8000000000000;
        goto LABEL_14;
      case 'f':
        v7 = CFSTR("EC Adapted flag.");
        goto LABEL_13;
      case 'g':
        buffer->cfNameString = CFSTR("EC Time aligned ref signal energy.");
        buffer->flags = 0x8000000;
        CFStringGetCString(CFSTR("EC Time aligned ref signal energy."), buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Generic;
        buffer->defaultValue = 0.0;
        v5 = 0x447A000000000000;
        goto LABEL_14;
      case 'h':
        v7 = CFSTR("EC Mic-Eclee cross correlation.");
LABEL_13:
        buffer->cfNameString = v7;
        buffer->flags = 0x8000000;
        CFStringGetCString(v7, buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Generic;
        buffer->defaultValue = 0.0;
        v5 = 0x3F80000000000000;
LABEL_14:
        *(_QWORD *)&buffer->minValue = v5;
LABEL_15:
        flags = buffer->flags;
        v9 = 1073774592;
        goto LABEL_16;
      default:
        return 4294956418;
    }
  }
  if (a2)
    return 4294956430;
  switch(a3)
  {
    case 0:
      buffer->cfNameString = CFSTR("NS: Number of DNN layers");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("NS: Number of DNN layers"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x4100000000000000;
      buffer->defaultValue = 0.0;
      goto LABEL_15;
    case 1:
      buffer->cfNameString = CFSTR("NS: Number of frames for context window");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("NS: Number of frames for context window"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x410000003F800000;
      v11 = 1.0;
      goto LABEL_20;
    case 2:
      buffer->cfNameString = CFSTR("NS: Forgetting factor (time constant)");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("NS: Forgetting factor (time constant)"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      *(_QWORD *)&buffer->minValue = 0x404000003E99999ALL;
      v11 = 0.3;
LABEL_20:
      buffer->defaultValue = v11;
      goto LABEL_15;
    case 3:
      v12 = CFSTR("NS: Noise suppression amount");
      goto LABEL_23;
    case 4:
      v12 = CFSTR("NS: Noise suppression amount as post mask");
LABEL_23:
      buffer->cfNameString = v12;
      buffer->flags = 0x8000000;
      CFStringGetCString(v12, buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 3281387520;
      buffer->defaultValue = 0.0;
      v10 = buffer->flags | 0xC0000000;
      goto LABEL_17;
    case 5:
      buffer->cfNameString = CFSTR("RES: Number of DNN layers");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("RES: Number of DNN layers"), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 1;
      v13 = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x4100000000000000;
      buffer->defaultValue = 0.0;
      goto LABEL_28;
    case 6:
      buffer->cfNameString = CFSTR("RES: Number of frames for context window");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("RES: Number of frames for context window"), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 1;
      v13 = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x410000003F800000;
      v14 = 1.0;
      goto LABEL_27;
    case 7:
      buffer->cfNameString = CFSTR("RES: Forgetting factor (time constant)");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("RES: Forgetting factor (time constant)"), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 1;
      v13 = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      *(_QWORD *)&buffer->minValue = 0x404000003E99999ALL;
      v14 = 0.3;
LABEL_27:
      buffer->defaultValue = v14;
LABEL_28:
      v10 = v13 | 0x40108000;
      goto LABEL_17;
    case 8:
      v15 = CFSTR("RES: Echo suppression amount");
      goto LABEL_31;
    case 9:
      v15 = CFSTR("RES: Echo suppression amount as post mask");
LABEL_31:
      buffer->cfNameString = v15;
      buffer->flags = 0x8000000;
      CFStringGetCString(v15, buffer->name, 52, 0x8000100u);
      buffer->clumpID = 1;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 3281387520;
      buffer->defaultValue = 0.0;
      break;
    case 10:
      buffer->cfNameString = CFSTR("Use energy threshold for channel averaging? Only channels with mean subband energy larger than the threshold will be used.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Use energy threshold for channel averaging? Only channels with mean subband energy larger than the threshold will be used."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 2;
      v16 = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Boolean;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      buffer->defaultValue = 0.0;
      v10 = v16 | 0xC0100000;
      goto LABEL_17;
    case 11:
      buffer->cfNameString = CFSTR("Energy threshold for channel averaging (in dB).");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Energy threshold for channel averaging (in dB)."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 2;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 3281387520;
      buffer->defaultValue = -300.0;
      break;
    default:
      return 4294956418;
  }
  v9 = -1072693248;
LABEL_16:
  v10 = flags | v9;
LABEL_17:
  result = 0;
  buffer->flags = v10;
  return result;
}

UInt8 *AUNeuralNetSPP::SaveExtendedScopes(AUNeuralNetSPP *this, __CFData *a2)
{
  ausdk::AUScope *Scope;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);
  return ausdk::AUScope::SaveState(Scope, a2);
}

uint64_t AUNeuralNetSPP::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
  {
    this[66] = (OpaqueAudioComponentInstance *)((char *)this[66] + 1);
    this[68] = (OpaqueAudioComponentInstance *)((char *)this[68] + 1);
  }
  return result;
}

uint64_t AUNeuralNetSPP::GetParameterValueStrings(AUNeuralNetSPP *this, int a2, unsigned int a3, const __CFArray **a4)
{
  BOOL v4;

  if (a4)
    v4 = a2 == 0;
  else
    v4 = 1;
  if (v4)
    return 0;
  else
    return 4294956430;
}

double AUNeuralNetSPP::GetLatency(AUNeuralNetSPP *this)
{
  return 0.0;
}

double AUNeuralNetSPP::GetTailTime(AUNeuralNetSPP *this)
{
  return 0.05;
}

uint64_t AUNeuralNetSPP::SupportsTail(AUNeuralNetSPP *this)
{
  return 1;
}

BOOL AUNeuralNetSPP::StreamFormatWritable(AUNeuralNetSPP *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUNeuralNetSPP::SupportedNumChannels(AUNeuralNetSPP *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUNeuralNetSPP::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 16;
}

uint64_t AUNeuralNetSPP::ValidFormat(AUNeuralNetSPP *this, int a2, unsigned int a3, const AudioStreamBasicDescription *a4)
{
  uint64_t result;

  if (a4->mBitsPerChannel == 64 && a4->mFormatID == 1718773105)
    result = (LOBYTE(a4->mFormatFlags) >> 5) & 1;
  else
    result = 0;
  if (a2 == 2 || a2 == 1)
  {
    if (a4->mChannelsPerFrame < 0x11)
      return result;
    else
      return 0;
  }
  return result;
}

uint64_t AUNeuralNetSPP::ChangeStreamFormat(AUNeuralNetSPP *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  int v6;
  int v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Element;
  NSObject *v13;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v6 = a3;
  v7 = a2;
  v19 = *MEMORY[0x1E0C80C00];
  ausdk::AUBase::ChangeStreamFormat(this, a2, a3, a4, a5);
  v9 = 0;
  if (v7 == 1 && !v6)
  {
    v10 = *((_QWORD *)this + 15);
    if (v10)
    {
      if (!(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 32))(v10, 1))
        return 0;
    }
    else
    {
      v11 = *((_QWORD *)this + 12);
      if ((unint64_t)(*((_QWORD *)this + 13) - v11) < 9 || !*(_QWORD *)(v11 + 8))
        return 0;
    }
    Element = ausdk::AUScope::SafeGetElement((AUNeuralNetSPP *)((char *)this + 80), 1u);
    v9 = (*(uint64_t (**)(uint64_t, const AudioStreamBasicDescription *))(*(_QWORD *)Element + 56))(Element, a5);
    if (AUNeuralNetSPPLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetSPPLogScope(void)::once, &__block_literal_global_21878);
    if (AUNeuralNetSPPLogScope(void)::scope)
    {
      v13 = *(NSObject **)AUNeuralNetSPPLogScope(void)::scope;
      if (!*(_QWORD *)AUNeuralNetSPPLogScope(void)::scope)
        return v9;
    }
    else
    {
      v13 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v15 = 136315394;
      v16 = "AUNeuralNetSPP.cpp";
      v17 = 1024;
      v18 = 956;
      _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_INFO, "%25s:%-5d Setting the stream format for the second input bus to match the format of the first bus.\n", (uint8_t *)&v15, 0x12u);
    }
  }
  return v9;
}

uint64_t AUNeuralNetSPP::GetScopeExtended(AUNeuralNetSPP *this, int a2)
{
  if (a2 == 4)
    return (uint64_t)this + 568;
  else
    return 0;
}

os_log_t ___ZL22AUNeuralNetSPPLogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "nnspp");
  *v0 = result;
  AUNeuralNetSPPLogScope(void)::scope = (uint64_t)v0;
  return result;
}

void VPTimeFreqConverter::VPTimeFreqConverter(VPTimeFreqConverter *this, int a2, int a3)
{
  MultiRadixRealFFT *v4;
  char *v5;
  char *v6;
  unsigned int v7;
  int v8;

  *((_OWORD *)this + 2) = 0u;
  v4 = (VPTimeFreqConverter *)((char *)this + 32);
  *((_OWORD *)this + 4) = 0u;
  v5 = (char *)this + 64;
  *((_OWORD *)this + 7) = 0u;
  v6 = (char *)this + 112;
  *(_OWORD *)((char *)this + 169) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  v7 = 2 * a3;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  if (2 * a3)
  {
    if (a3)
    {
      *(_DWORD *)this = 0;
      *((_DWORD *)this + 1) = a2;
      *((_DWORD *)this + 2) = a3;
      *((_DWORD *)this + 3) = a3;
      *((_DWORD *)this + 4) = v7;
      *((_DWORD *)this + 5) = v7;
      *((float *)this + 6) = 1.0 / (float)v7;
      *((_DWORD *)this + 7) = a3 & 0x7FFFFFFF;
      *((_QWORD *)this + 6) = operator new[]();
      *((_QWORD *)this + 7) = operator new[]();
      if (!MultiRadixRealFFT::Initialize(v4, *((_DWORD *)this + 5)))
      {
        std::vector<float>::resize((uint64_t)v4 + 56, *((unsigned int *)this + 5));
        v8 = *((_DWORD *)this + 1);
        if ((v8 | 2) == 2)
        {
          std::vector<float>::resize((uint64_t)v5, *((unsigned int *)this + 5));
          std::vector<float>::resize((uint64_t)v4 + 104, *((unsigned int *)this + 5));
          CreateMagicalWindow(*((_QWORD *)this + 17), *((_DWORD *)this + 4));
          v8 = *((_DWORD *)this + 1);
        }
        if ((v8 - 1) <= 1)
        {
          std::vector<float>::resize((uint64_t)this + 160, *((unsigned int *)this + 5));
          CreateMagicalWindow(*((_QWORD *)this + 20), *((_DWORD *)this + 4));
          std::vector<float>::resize((uint64_t)v6, *((unsigned int *)this + 5));
        }
        *((_BYTE *)this + 184) = 1;
      }
    }
  }
}

void sub_1B653C970(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  v8 = (void *)v2[20];
  if (v8)
  {
    v2[21] = v8;
    operator delete(v8);
  }
  v9 = *v6;
  if (*v6)
  {
    v2[18] = v9;
    operator delete(v9);
  }
  v10 = *v4;
  if (*v4)
  {
    v2[15] = v10;
    operator delete(v10);
  }
  v11 = *v5;
  if (*v5)
  {
    v2[12] = v11;
    operator delete(v11);
  }
  v12 = *v3;
  if (*v3)
  {
    v2[9] = v12;
    operator delete(v12);
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void VPTimeFreqConverter::~VPTimeFreqConverter(VPTimeFreqConverter *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = *((_QWORD *)this + 6);
  if (v2)
    MEMORY[0x1BCC95CC8](v2, 0x1000C8052888210);
  v3 = *((_QWORD *)this + 7);
  if (v3)
    MEMORY[0x1BCC95CC8](v3, 0x1000C8052888210);
  v4 = (void *)*((_QWORD *)this + 20);
  if (v4)
  {
    *((_QWORD *)this + 21) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 17);
  if (v5)
  {
    *((_QWORD *)this + 18) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 14);
  if (v6)
  {
    *((_QWORD *)this + 15) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 11);
  if (v7)
  {
    *((_QWORD *)this + 12) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 8);
  if (v8)
  {
    *((_QWORD *)this + 9) = v8;
    operator delete(v8);
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 32);
}

uint64_t VPTimeFreqConverter::Analyze(VPTimeFreqConverter *this, const float *a2, DSPSplitComplex *a3)
{
  NSObject *v5;
  const char *v6;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 184))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v9 = 136315394;
      v10 = "vpTimeFreqConverter.cpp";
      v11 = 1024;
      v12 = 69;
      v5 = MEMORY[0x1E0C81028];
      v6 = "%25s:%-5d _vp: vptimefreqconverter::analyze: not configured for conversion";
LABEL_9:
      _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v9, 0x12u);
    }
    return 4294956433;
  }
  if ((*((_DWORD *)this + 1) | 2) != 2)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v9 = 136315394;
      v10 = "vpTimeFreqConverter.cpp";
      v11 = 1024;
      v12 = 76;
      v5 = MEMORY[0x1E0C81028];
      v6 = "%25s:%-5d _vp: vptimefreqconverter::analyze: not configured for analysis";
      goto LABEL_9;
    }
    return 4294956433;
  }
  if (*(_DWORD *)this)
    return 4294967292;
  memcpy(*((void **)this + 8), (const void *)(*((_QWORD *)this + 8) + 4 * *((unsigned int *)this + 3)), 4 * (*((_DWORD *)this + 4) - *((_DWORD *)this + 3)));
  memcpy((void *)(*((_QWORD *)this + 8) + 4 * (*((_DWORD *)this + 4) - *((_DWORD *)this + 3))), a2, 4 * *((unsigned int *)this + 3));
  vDSP_vmul(*((const float **)this + 17), 1, *((const float **)this + 8), 1, *((float **)this + 11), 1, *((unsigned int *)this + 4));
  vDSP_vsmul(*((const float **)this + 11), 1, (const float *)this + 6, *((float **)this + 11), 1, *((unsigned int *)this + 4));
  MultiRadixRealFFT::RealOutOfPlaceForwardTransform((VPTimeFreqConverter *)((char *)this + 32), *((DSPComplex **)this + 11), a3, 1.0);
  return 0;
}

uint64_t VPTimeFreqConverter::Synthesize(VPTimeFreqConverter *this, const DSPSplitComplex *a2, float *a3)
{
  NSObject *v5;
  const char *v6;
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 184))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v8 = 136315394;
      v9 = "vpTimeFreqConverter.cpp";
      v10 = 1024;
      v11 = 117;
      v5 = MEMORY[0x1E0C81028];
      v6 = "%25s:%-5d _vp: vptimefreqconverter::synthesize: not configured for conversion";
LABEL_9:
      _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v8, 0x12u);
    }
    return 4294956433;
  }
  if ((*((_DWORD *)this + 1) - 1) >= 2)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v8 = 136315394;
      v9 = "vpTimeFreqConverter.cpp";
      v10 = 1024;
      v11 = 124;
      v5 = MEMORY[0x1E0C81028];
      v6 = "%25s:%-5d _vp: vptimefreqconverter::synthesize: not configured for synthesis";
      goto LABEL_9;
    }
    return 4294956433;
  }
  if (*(_DWORD *)this)
    return 4294967292;
  MultiRadixRealFFT::RealOutOfPlaceInverseTransform((const vDSP_DFT_SetupStruct ***)this + 4, a2, *((DSPComplex **)this + 11));
  vDSP_vmul(*((const float **)this + 11), 1, *((const float **)this + 20), 1, *((float **)this + 11), 1, *((unsigned int *)this + 4));
  vDSP_vadd(*((const float **)this + 11), 1, *((const float **)this + 14), 1, *((float **)this + 14), 1, *((unsigned int *)this + 4));
  memcpy(a3, *((const void **)this + 14), 4 * *((unsigned int *)this + 3));
  memmove(*((void **)this + 14), (const void *)(*((_QWORD *)this + 14) + 4 * *((unsigned int *)this + 3)), 4 * (*((_DWORD *)this + 4) - *((_DWORD *)this + 3)));
  bzero((void *)(*((_QWORD *)this + 14) + 4 * (*((_DWORD *)this + 4) - *((_DWORD *)this + 3))), 4 * *((unsigned int *)this + 3));
  return 0;
}

void VPTimeFreqConverter_Create(int a1, int a2, VPTimeFreqConverter **a3)
{
  VPTimeFreqConverter *v6;

  v6 = (VPTimeFreqConverter *)operator new();
  VPTimeFreqConverter::VPTimeFreqConverter(v6, a1, a2);
  *a3 = v6;
}

void sub_1B653CE84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10A0C406C6E14A4);
  _Unwind_Resume(a1);
}

void Meter::SetMeterType(uint64_t a1, int a2, float a3, float a4)
{
  uint64_t v8;
  char *v9;
  double *v10;
  unint64_t v11;
  __int128 v12;
  int v13;
  __int128 v14;
  int v15;
  _BYTE v16[20];
  __int128 v17;
  int v18;
  __int128 v19;
  int v20;
  _BYTE v21[20];
  __int128 v22;
  int v23;
  __int128 v24;
  int v25;
  _BYTE v26[20];
  __int128 v27;
  int v28;
  __int128 v29;
  int v30;
  __int128 v31;
  int v32;
  __int128 v33;
  int v34;
  __int128 v35;
  int v36;
  _OWORD __src[2];
  _QWORD v38[6];

  v38[5] = *MEMORY[0x1E0C80C00];
  v9 = (char *)(a1 + 200);
  v8 = *(_QWORD *)(a1 + 200);
  *(_DWORD *)(a1 + 224) = a2;
  *(_QWORD *)(a1 + 208) = v8;
  LODWORD(__src[0]) = 1065353216;
  std::vector<float>::resize(a1 + 200, 8uLL, __src);
  switch(a2)
  {
    case 0:
      LODWORD(v11) = *(_DWORD *)(a1 + 228);
      DspLib::Biquad::Design::kWeighting((double)v11, (uint64_t)__src);
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)__src, 2, 0, 0x41uLL);
      v36 = 0;
      v35 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v35, 1, 2, 0x41uLL);
      __src[0] = xmmword_1B6687CC0;
      __src[1] = unk_1B6687CD0;
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v9, (char *)__src, (uint64_t)v38, 8uLL);
      break;
    case 1:
      LODWORD(v11) = *(_DWORD *)(a1 + 228);
      DspLib::Biquad::Design::aWeighting((double)v11, __src);
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)__src, 3, 0, 0x41uLL);
      break;
    case 2:
      LODWORD(v11) = *(_DWORD *)(a1 + 228);
      DspLib::Biquad::Design::cWeighting((double)v11, (uint64_t)__src);
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)__src, 2, 0, 0x41uLL);
      v34 = 0;
      v33 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v33, 1, 2, 0x41uLL);
      break;
    case 3:
      v32 = 0;
      v31 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v31, 1, 0, 0x41uLL);
      v30 = 0;
      v29 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v29, 1, 1, 0x41uLL);
      v28 = 0;
      v27 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v27, 1, 2, 0x41uLL);
      break;
    case 4:
      LODWORD(__src[0]) = 14;
      *(_QWORD *)((char *)__src + 4) = LODWORD(a3);
      *((float *)__src + 3) = a4;
      DspLib::Biquad::Design::ParametricEQ::design((DspLib::Biquad::Design::ParametricEQ *)__src, (float)*(unsigned int *)(a1 + 228), 0, v10, (uint64_t)v26);
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)v26, 1, 0, 0x41uLL);
      v25 = 0;
      v24 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v24, 1, 1, 0x41uLL);
      v23 = 0;
      v22 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v22, 1, 2, 0x41uLL);
      break;
    case 5:
      LODWORD(__src[0]) = 8;
      *(_QWORD *)((char *)__src + 4) = LODWORD(a3);
      *((float *)__src + 3) = a4;
      DspLib::Biquad::Design::ParametricEQ::design((DspLib::Biquad::Design::ParametricEQ *)__src, (float)*(unsigned int *)(a1 + 228), 0, v10, (uint64_t)v21);
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)v21, 1, 0, 0x41uLL);
      v20 = 0;
      v19 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v19, 1, 1, 0x41uLL);
      v18 = 0;
      v17 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v17, 1, 2, 0x41uLL);
      break;
    case 6:
      LODWORD(__src[0]) = 9;
      *(_QWORD *)((char *)__src + 4) = LODWORD(a3);
      *((float *)__src + 3) = a4;
      DspLib::Biquad::Design::ParametricEQ::design((DspLib::Biquad::Design::ParametricEQ *)__src, (float)*(unsigned int *)(a1 + 228), 0, v10, (uint64_t)v16);
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)v16, 1, 0, 0x41uLL);
      v15 = 0;
      v14 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v14, 1, 1, 0x41uLL);
      v13 = 0;
      v12 = DspLib::Biquad::kBypassSection;
      DspLib::Biquad::Filter::setCoefficients(a1, (uint64_t)&v12, 1, 2, 0x41uLL);
      break;
    default:
      break;
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 72) + 28) = 0;
  DspLib::Biquad::SetupWrapper::reset((DspLib::Biquad::SetupWrapper *)(a1 + 48));
}

os_log_t ___Z12getScottyLogv_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreaudio", "AUScotty");
  getScottyLog(void)::gLog = (uint64_t)result;
  return result;
}

void LegacyHRTFSpatializer::~LegacyHRTFSpatializer(LegacyHRTFSpatializer *this)
{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_1E69E92B8;
  v3 = (void **)((char *)this + 344);
  std::vector<IR::DelayLine>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = *((_QWORD *)this + 42);
  *((_QWORD *)this + 42) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  Spatializer::~Spatializer(this);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_1E69E92B8;
  v3 = (void **)((char *)this + 344);
  std::vector<IR::DelayLine>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = *((_QWORD *)this + 42);
  *((_QWORD *)this + 42) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  Spatializer::~Spatializer(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t LegacyHRTFSpatializer::initialize(LegacyHRTFSpatializer *this, float a2, unsigned int a3, int a4)
{
  uint64_t result;
  uint64_t v7;
  IR *v8;
  const __CFURL *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  void *v14;
  NSObject *v15;
  size_t Length;
  void *v17;
  uint64_t i;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  _DWORD *v27;
  int *v28;
  uint64_t v29;
  float v30;
  int v31;
  uint64_t j;
  uint64_t v33;
  _QWORD *v34;
  char v35;
  char v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  std::bad_alloc *exception;
  std::bad_alloc *v46;
  uint64_t v47;
  FILE *v50;
  void *v51;
  __int128 v52;
  __int128 v53;
  unsigned int v54;
  _BYTE buf[40];
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (a3 < 2)
    return 4294900553;
  v7 = operator new();
  *(_QWORD *)v7 = &off_1E69EBDB8;
  *(_QWORD *)(v7 + 8) = 0;
  ConvolutionFilter::ConvolutionFilter((ConvolutionFilter *)(v7 + 16));
  *(_QWORD *)(v7 + 16) = &off_1E69ED6A8;
  ConvolutionFilter::ConvolutionFilter((ConvolutionFilter *)(v7 + 56));
  *(_QWORD *)(v7 + 56) = &off_1E69ED6A8;
  *(_OWORD *)(v7 + 104) = 0u;
  *(_OWORD *)(v7 + 120) = 0u;
  gConvolution = v7;
  if ((HRTFConvolution::sIsInitialized & 1) == 0)
  {
    v9 = (const __CFURL *)IR::copyHRTFBinURL(v8);
    v50 = (FILE *)&off_1E69EE080;
    v51 = 0;
    v47 = v7;
    if (TFileBSD::TFileBSD(__CFURL const*)::once != -1)
      dispatch_once(&TFileBSD::TFileBSD(__CFURL const*)::once, &__block_literal_global_25433);
    v10 = kTFileBSDSubsystem;
    if (kTFileBSDSubsystem)
    {
      v11 = *(NSObject **)kTFileBSDSubsystem;
      if (!*(_QWORD *)kTFileBSDSubsystem)
        goto LABEL_14;
    }
    else
    {
      v11 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_QWORD *)&buf[4] = "TFileBSD.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 77;
      *(_WORD *)&buf[18] = 2080;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[20] = "TFileBSD";
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = &v50;
      _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", buf, 0x26u);
      v10 = kTFileBSDSubsystem;
    }
    if (v10)
    {
      v12 = *(NSObject **)v10;
      if (!*(_QWORD *)v10)
      {
LABEL_14:
        v53 = 0u;
        v52 = 0u;
LABEL_19:
        if ((*(_BYTE *)(v10 + 8) & 1) != 0)
        {
          v13 = *(NSObject **)v10;
          if (*(_QWORD *)v10)
          {
            if (os_log_type_enabled(*(os_log_t *)v10, OS_LOG_TYPE_DEBUG))
            {
              *(_QWORD *)&buf[4] = "TFileBSD.cpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 155;
              *(_WORD *)&buf[18] = 2080;
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[20] = "Initialize";
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = &v50;
              _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", buf, 0x26u);
            }
          }
        }
LABEL_23:
        if (v9)
        {
          if (v51)
          {
            free(v51);
            v51 = 0;
          }
          v14 = malloc_type_malloc(0x400uLL, 0x7C51E058uLL);
          if (!v14)
          {
            exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
            v46 = std::bad_alloc::bad_alloc(exception);
          }
          v51 = v14;
          if (CFURLGetFileSystemRepresentation(v9, 1u, (UInt8 *)v14, 1024) != 1 && v51)
            *(_BYTE *)v51 = 0;
        }
        if (kTFileBSDSubsystem)
        {
          if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
          {
            v15 = *(NSObject **)kTFileBSDSubsystem;
            if (*(_QWORD *)kTFileBSDSubsystem)
            {
              if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
              {
                *(_QWORD *)&buf[4] = "TFileBSD.cpp";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 102;
                *(_WORD *)&buf[18] = 2080;
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[20] = "TFileBSD";
                *(_WORD *)&buf[28] = 2048;
                *(_QWORD *)&buf[30] = &v50;
                _os_log_impl(&dword_1B5ED0000, v15, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", buf, 0x26u);
              }
            }
          }
        }
        CFRelease(v9);
        TFileBSD::Open((const char **)&v50, 0);
        Length = (int)TFileBSD::GetLength(&v50);
        v17 = malloc_type_malloc(Length, 0x217192ADuLL);
        *(_QWORD *)&buf[16] = v17;
        *(_QWORD *)&buf[24] = Length;
        *(_QWORD *)&buf[32] = 0;
        *(_QWORD *)buf = &off_1E69EE280;
        *(_QWORD *)&buf[8] = 0;
        v56 = 1;
        if (v17)
          (*(void (**)(FILE **, void *, size_t))&v50->_flags)(&v50, v17, Length);
        for (i = 0; i != 50; ++i)
        {
          v19 = operator new();
          v20 = (int *)v19;
          v21 = 3208;
          do
          {
            v22 = v19 + v21;
            *(_QWORD *)v22 = 0;
            *(_DWORD *)(v22 + 12) = 0;
            v21 += 16;
          }
          while (v22 + 16 != v19 + 8328);
          v23 = 8328;
          do
          {
            v24 = v19 + v23;
            *(_QWORD *)v24 = 0;
            *(_DWORD *)(v24 + 12) = 0;
            v23 += 16;
          }
          while (v24 + 16 != v19 + 13448);
          LOWORD(v54) = 0;
          (*(void (**)(_BYTE *, unsigned int *, uint64_t))(*(_QWORD *)buf + 16))(buf, &v54, 2);
          v25 = (unsigned __int16)v54;
          *v20 = __rev16((unsigned __int16)v54);
          if (v25)
          {
            v26 = 0;
            v27 = v20 + 163;
            v28 = v20;
            do
            {
              ConvolutionKernel::ConvolutionKernel((uint64_t)(v28 + 802), (uint64_t)buf);
              ConvolutionKernel::ConvolutionKernel((uint64_t)(v28 + 2082), (uint64_t)buf);
              v54 = 0;
              (*(void (**)(_BYTE *, unsigned int *, uint64_t))(*(_QWORD *)buf + 16))(buf, &v54, 4);
              *(v27 - 1) = bswap32(v54);
              v54 = 0;
              (*(void (**)(_BYTE *, unsigned int *, uint64_t))(*(_QWORD *)buf + 16))(buf, &v54, 4);
              *v27 = bswap32(v54);
              v27 += 2;
              ++v26;
              v28 += 4;
            }
            while (v26 < *v20);
          }
          HRTFConvolution::sHRTF[i] = v20;
        }
        TFileBSD::Close((TFileBSD *)&v50);
        HRTFConvolution::sIsInitialized = 1;
        MemoryStream::~MemoryStream((MemoryStream *)buf);
        TFileBSD::~TFileBSD((TFileBSD *)&v50);
        v7 = v47;
        goto LABEL_47;
      }
    }
    else
    {
      v12 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_QWORD *)&buf[4] = "TFileBSD.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 150;
      *(_WORD *)&buf[18] = 2080;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[20] = "Initialize";
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = &v50;
      _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", buf, 0x26u);
      v10 = kTFileBSDSubsystem;
    }
    v53 = 0u;
    v52 = 0u;
    if (!v10)
      goto LABEL_23;
    goto LABEL_19;
  }
LABEL_47:
  *(_QWORD *)(v7 + 96) = 0;
  *(_QWORD *)(v7 + 136) = 0;
  *(_QWORD *)(v7 + 144) = 0;
  *(_QWORD *)(v7 + 152) = 0xFFFFFFFFLL;
  v29 = *((_QWORD *)this + 42);
  *((_QWORD *)this + 42) = v7;
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  v30 = a2 * 0.00145;
  v31 = vcvtps_u32_f32(v30);
  v33 = *((_QWORD *)this + 43);
  for (j = *((_QWORD *)this + 44); j != v33; IR::DelayLine::~DelayLine((IR::DelayLine *)(j - 304)))
    ;
  v34 = (_QWORD *)((char *)this + 344);
  *((_QWORD *)this + 44) = v33;
  v35 = 1;
  do
  {
    v36 = v35;
    IR::DelayLine::DelayLine((uint64_t)&v50, v31, 1, 1uLL, 0x400u, 1024);
    v38 = *((_QWORD *)this + 44);
    v37 = *((_QWORD *)this + 45);
    if (v38 >= v37)
    {
      v40 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v38 - *v34) >> 4);
      v41 = v40 + 1;
      if (v40 + 1 > 0xD79435E50D7943)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v42 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v37 - *v34) >> 4);
      if (2 * v42 > v41)
        v41 = 2 * v42;
      if (v42 >= 0x6BCA1AF286BCA1)
        v43 = 0xD79435E50D7943;
      else
        v43 = v41;
      *(_QWORD *)&buf[32] = (char *)this + 360;
      if (v43)
        v43 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::DelayLine>>(v43);
      else
        v44 = 0;
      *(_QWORD *)buf = v43;
      *(_QWORD *)&buf[8] = v43 + 304 * v40;
      *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
      *(_QWORD *)&buf[24] = v43 + 304 * v44;
      IR::DelayLine::DelayLine(*(uint64_t *)&buf[8], (uint64_t)&v50);
      *(_QWORD *)&buf[16] += 304;
      std::vector<IR::DelayLine>::__swap_out_circular_buffer((uint64_t *)this + 43, buf);
      v39 = *((_QWORD *)this + 44);
      std::__split_buffer<IR::DelayLine>::~__split_buffer((uint64_t)buf);
    }
    else
    {
      IR::DelayLine::DelayLine(*((_QWORD *)this + 44), (uint64_t)&v50);
      v39 = v38 + 304;
      *((_QWORD *)this + 44) = v39;
    }
    *((_QWORD *)this + 44) = v39;
    IR::DelayLine::~DelayLine((IR::DelayLine *)&v50);
    v35 = 0;
  }
  while ((v36 & 1) != 0);
  *((float *)this + 2) = a2;
  *((_DWORD *)this + 3) = a4;
  *((_DWORD *)this + 5) = v31 + 64;
  LODWORD(v50) = 0;
  std::vector<float>::resize((uint64_t)this + 136, a3, &v50);
  LODWORD(v50) = 0;
  std::vector<float>::resize((uint64_t)this + 272, a3, &v50);
  result = 0;
  *((_WORD *)this + 8) = 257;
  return result;
}

void sub_1B653DBB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *a15)
{
  uint64_t v15;

  if (a2)
  {
    MemoryStream::~MemoryStream((MemoryStream *)(v15 - 176));
    TFileBSD::~TFileBSD((TFileBSD *)&a14);
    __cxa_begin_catch(exception_object);
    fwrite("ERROR : opening 3D files...\n", 0x1CuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    __cxa_end_catch();
    JUMPOUT(0x1B653D95CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B653DD44()
{
  void **v0;

  ConvolutionFilter::~ConvolutionFilter(v0);
  JUMPOUT(0x1B653DC20);
}

void LegacyHRTFSpatializer::reset(LegacyHRTFSpatializer *this)
{
  uint64_t v2;
  IR::DelayLine *v3;
  IR::DelayLine *v4;

  *((_BYTE *)this + 17) = 1;
  *((_BYTE *)this + 268) = *((_BYTE *)this + 132);
  v2 = *((_QWORD *)this + 42);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = (IR::DelayLine *)*((_QWORD *)this + 43);
  v4 = (IR::DelayLine *)*((_QWORD *)this + 44);
  while (v3 != v4)
  {
    IR::DelayLine::reset(v3);
    v3 = (IR::DelayLine *)((char *)v3 + 304);
  }
}

uint64_t LegacyHRTFSpatializer::processAccumulating(LegacyHRTFSpatializer *this, const float *a2, float *const *a3, unsigned int a4, std::string::pointer *a5, int a6, vDSP_Length a7, float a8, IR::ComplexDataCircBuffer *a9, double a10, __n128 a11)
{
  NSObject *v12;
  std::string *v13;
  __int128 v14;
  std::string *v15;
  __int128 v16;
  std::string *p_p;
  void *v18;
  SphericalHeadSpatializer *v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float *v30;
  float v31;
  float v32;
  IR::DelayLine *v33;
  uint64_t i;
  NSObject *v36;
  NSObject *v37;
  std::string *v38;
  std::string *v39;
  std::string v40;
  std::string v41;
  std::string buf;
  std::string __p;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a4 <= 1)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v12 = getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
      return 4294956445;
    std::string::basic_string[abi:ne180100]<0>(&v40, "LegacyHRTFSpatializer");
    v13 = std::string::append(&v40, "::", 2uLL);
    v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    v15 = std::string::append(&v41, "processAccumulating", 0x13uLL);
    v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = a4;
    _os_log_debug_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEBUG, "%s: ERROR: cannot process with %d output channels", (uint8_t *)&buf, 0x12u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v41.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return 4294956445;
    v18 = (void *)v40.__r_.__value_.__r.__words[0];
LABEL_46:
    operator delete(v18);
    return 4294956445;
  }
  if (a6 != a4)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v36 = getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
      return 4294956445;
    std::string::basic_string[abi:ne180100]<0>(&buf, "LegacyHRTFSpatializer");
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("::", &buf, &v40);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("processAccumulating", &v40, &v41);
    if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v38 = &v41;
    else
      v38 = (std::string *)v41.__r_.__value_.__r.__words[0];
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = a4;
    WORD1(__p.__r_.__value_.__r.__words[2]) = 1024;
    HIDWORD(__p.__r_.__value_.__r.__words[2]) = a6;
    _os_log_debug_impl(&dword_1B5ED0000, v36, OS_LOG_TYPE_DEBUG, "%s: ERROR: cannot process with %d output channels != %d", (uint8_t *)&__p, 0x18u);
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v41.__r_.__value_.__l.__data_);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v40.__r_.__value_.__l.__data_);
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return 4294956445;
    v18 = (void *)buf.__r_.__value_.__r.__words[0];
    goto LABEL_46;
  }
  if (*((_BYTE *)this + 16))
  {
    if (*((_BYTE *)this + 132))
      a11.n128_f32[0] = a8;
    else
      a11.n128_f32[0] = 0.0;
    v24 = (SphericalHeadSpatializer *)(*(uint64_t (**)(_QWORD, const float *, std::string::pointer *, vDSP_Length, uint64_t, float, float, __n128))(**((_QWORD **)this + 42) + 16))(*((_QWORD *)this + 42), a2, a5, a7, 1, *((float *)this + 12), *((float *)this + 13), a11);
    *((_BYTE *)this + 268) = *((_BYTE *)this + 132);
    if ((*((_BYTE *)this + 24) & 1) != 0)
    {
      v25 = *((float *)this + 12);
      v26 = *((float *)this + 13);
      if (v25 != *((float *)this + 46) || v26 != *((float *)this + 47) || *((_BYTE *)this + 17))
      {
        v27 = SphericalHeadSpatializer::CalculateInterauralTimeDelays(v24, v25, v26, *((float *)this + 2));
        v29 = v28;
        IR::DelayLine::setDelay(*((_QWORD *)this + 43), v27);
        IR::DelayLine::setDelay(*((_QWORD *)this + 43) + 304, v29);
        *((_QWORD *)this + 23) = *((_QWORD *)this + 6);
        *((_BYTE *)this + 17) = 0;
      }
      v30 = (float *)*((_QWORD *)this + 43);
      v31 = -0.00033333;
      if (*((_DWORD *)this + 81))
        v31 = 1.0;
      v32 = expf(v31);
      v30[24] = v32;
      v30[100] = v32;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)*a5;
      IR::DelayLine::process((IR::DelayLine *)v30, (const float *)__p.__r_.__value_.__l.__data_, (float **)&__p, a7);
      v33 = (IR::DelayLine *)(*((_QWORD *)this + 43) + 304);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)a5[1];
      IR::DelayLine::process(v33, (const float *)__p.__r_.__value_.__l.__data_, (float **)&__p, a7);
    }
    for (i = 0; i != 2; ++i)
      vDSP_vadd((const float *)a5[i], 1, a3[i], 1, a3[i], 1, a7);
    return 0;
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v37 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      std::string::basic_string[abi:ne180100]<0>(&v40, "LegacyHRTFSpatializer");
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("::", &v40, &v41);
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("processAccumulating", &v41, &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v39 = &__p;
      else
        v39 = (std::string *)__p.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v39;
      _os_log_debug_impl(&dword_1B5ED0000, v37, OS_LOG_TYPE_DEBUG, "%s: ERROR: not initialized", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v40.__r_.__value_.__l.__data_);
    }
    return 4294956429;
  }
}

void sub_1B653E2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void AUMagnitudeDifferenceNoiseSuppressor::~AUMagnitudeDifferenceNoiseSuppressor(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  AUMagnitudeDifferenceNoiseSuppressor::~AUMagnitudeDifferenceNoiseSuppressor(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_1E69E9408;
  v2 = *((_QWORD *)this + 68);
  if (v2)
  {
    CNoiseSuppressorV3::speex_preprocess_state_destroy(v2);
    *((_QWORD *)this + 68) = 0;
  }
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::Initialize(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  uint64_t Element;
  char *v3;

  (*(void (**)(AUMagnitudeDifferenceNoiseSuppressor *))(*(_QWORD *)this + 64))(this);
  *((_BYTE *)this + 540) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUMagnitudeDifferenceNoiseSuppressor *)((char *)this + 80), 0)+ 88) == 1718773105;
  *((_BYTE *)this + 541) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUMagnitudeDifferenceNoiseSuppressor *)((char *)this + 128), 0)+ 88) == 1718773105;
  Element = ausdk::AUScope::SafeGetElement((AUMagnitudeDifferenceNoiseSuppressor *)((char *)this + 128), 0);
  v3 = CNoiseSuppressorV3::speex_preprocess_state_init((CNoiseSuppressorV3 *)*((unsigned int *)this + 84), *(double *)(Element + 80), 2);
  *((_QWORD *)this + 68) = v3;
  if (!v3)
    return 4294956421;
  *((_DWORD *)this + 134) = *((_DWORD *)this + 133);
  AUMagnitudeDifferenceNoiseSuppressor::UpdateParameters(this);
  return 0;
}

void AUMagnitudeDifferenceNoiseSuppressor::Cleanup(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 68);
  if (v2)
  {
    CNoiseSuppressorV3::speex_preprocess_state_destroy(v2);
    *((_QWORD *)this + 68) = 0;
  }
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::GetPropertyInfo(AUMagnitudeDifferenceNoiseSuppressor *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  BOOL v7;

  if (a3)
    return 4294956417;
  if (a2 == 21)
  {
    v7 = 1;
  }
  else
  {
    if (a2 != 3700)
      return 4294956417;
    v7 = 0;
  }
  result = 0;
  *a6 = v7;
  *a5 = 4;
  return result;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::GetProperty(AUMagnitudeDifferenceNoiseSuppressor *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  int v7;

  if (a3)
    return 4294956417;
  if (a2 == 3700)
  {
    v7 = *((unsigned __int8 *)this + 376);
    goto LABEL_7;
  }
  if (a2 == 21)
  {
    v7 = (*(uint64_t (**)(AUMagnitudeDifferenceNoiseSuppressor *))(*(_QWORD *)this + 576))(this);
LABEL_7:
    result = 0;
    *a5 = v7;
    return result;
  }
  return 4294956417;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::SetProperty(AUMagnitudeDifferenceNoiseSuppressor *this, int a2, int a3, unsigned int a4, int *a5, unsigned int a6)
{
  uint64_t result;
  int v8;
  int v9;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    if (a6 >= 4)
    {
      v8 = *a5;
      v9 = *a5 != 0;
      if (v9 != (*(unsigned int (**)(AUMagnitudeDifferenceNoiseSuppressor *))(*(_QWORD *)this + 576))(this))
        (*(void (**)(AUMagnitudeDifferenceNoiseSuppressor *, BOOL))(*(_QWORD *)this + 584))(this, v8 != 0);
      return 0;
    }
    else
    {
      return 4294956445;
    }
  }
  return result;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::SetParameter(AUMagnitudeDifferenceNoiseSuppressor *this, unsigned int a2, int a3, unsigned int a4, float a5)
{
  uint64_t result;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  uint64_t v12;
  ausdk::AUElement *Element;
  unsigned int v14;
  ausdk::AUElement **v15;

  if (a3)
    return 4294956430;
  if (a2 > 0x14)
    goto LABEL_13;
  if (((1 << a2) & 0x18801A) != 0)
  {
    v9 = *((_QWORD *)this + 9);
    if (v9)
    {
      v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
    }
    else
    {
      v11 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v11)
        v10 = 0;
      else
        v10 = *v11;
    }
    v14 = a2;
LABEL_16:
    ausdk::AUElement::SetParameter(v10, v14, a5, 0);
    result = 0;
    ++*((_DWORD *)this + 133);
    return result;
  }
  if (a2)
  {
LABEL_13:
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMagnitudeDifferenceNoiseSuppressor *)((char *)this + 32), a4);
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
    return 0;
  }
  if ((int)a5 <= 2)
  {
    v12 = *((_QWORD *)this + 9);
    if (v12)
    {
      v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, 0);
    }
    else
    {
      v15 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v15)
        v10 = 0;
      else
        v10 = *v15;
    }
    v14 = 0;
    goto LABEL_16;
  }
  return 4294956418;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::CanScheduleParameters(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  return 0;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::ProcessMultipleBufferLists(AUMagnitudeDifferenceNoiseSuppressor *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  uint64_t result;
  AudioBufferList *v11;
  unsigned int mDataByteSize;
  void *mData;
  void *v14;
  size_t v15;
  int v16;
  float *v17;
  float *v18;
  uint64_t v19;
  uint64_t v20;
  __n128 v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  uint64_t v33;
  ausdk::AUElement *v34;
  ausdk::AUElement **v35;
  uint64_t v36;
  ausdk::AUElement *v37;
  ausdk::AUElement **v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  ausdk::AUElement **v44;
  uint64_t v45;
  ausdk::AUElement *v46;
  ausdk::AUElement **v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  ausdk::AUElement **v50;
  uint64_t v51;
  ausdk::AUElement *v52;
  ausdk::AUElement **v53;
  uint64_t v54;
  ausdk::AUElement *v55;
  ausdk::AUElement **v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  ausdk::AUElement **v59;
  uint64_t v60;
  ausdk::AUElement *v61;
  ausdk::AUElement **v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  ausdk::AUElement **v65;
  uint64_t v66;
  ausdk::AUElement *v67;
  ausdk::AUElement **v68;
  char *v69;
  void *v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  const void *v74;
  float *v75;
  size_t v76;
  float *v77;
  float *v78[2];
  const float *v79[2];

  if (*((_DWORD *)this + 84) != a3)
    return 4294956422;
  result = 4294956419;
  if (a4 >= 3 && a6 >= 3)
  {
    if ((*(unsigned int (**)(AUMagnitudeDifferenceNoiseSuppressor *, unsigned int *))(*(_QWORD *)this + 576))(this, a2))
    {
      v11 = a7[2];
      mDataByteSize = v11->mBuffers[0].mDataByteSize;
      if (mDataByteSize >= 4)
        memset_pattern16(v11->mBuffers[0].mData, &unk_1B6627B80, mDataByteSize & 0xFFFFFFFC);
      if (*((unsigned __int8 *)this + 540) != *((unsigned __int8 *)this + 541))
      {
        bzero((*a7)->mBuffers[0].mData, (*a7)->mBuffers[0].mDataByteSize);
        return 0;
      }
      mData = (*a5)->mBuffers[0].mData;
      v14 = (*a7)->mBuffers[0].mData;
      v15 = (*a7)->mBuffers[0].mDataByteSize;
    }
    else
    {
      v16 = *((_DWORD *)this + 133);
      if (v16 != *((_DWORD *)this + 134))
      {
        AUMagnitudeDifferenceNoiseSuppressor::UpdateParameters(this);
        *((_DWORD *)this + 134) = v16;
      }
      v17 = (float *)(*a5)->mBuffers[0].mData;
      v18 = (float *)a5[1]->mBuffers[0].mData;
      v19 = *((_QWORD *)this + 68);
      *(_QWORD *)(v19 + 600) = a5[2]->mBuffers[0].mData;
      if (*((_BYTE *)this + 540))
      {
        v20 = *((unsigned int *)this + 84);
        v79[0] = v17;
        v79[1] = &v17[v20];
        v78[0] = v18;
        v78[1] = &v18[v20];
        CNoiseSuppressorV3::speex_preprocess_run_freq(v19, v79, v78);
      }
      else
      {
        v21.n128_f32[0] = CNoiseSuppressorV3::speex_preprocess_run((int *)v19, (char *)v17, (char *)v18);
      }
      v22 = *((_QWORD *)this + 68);
      if (v22)
        v23 = *(float *)(v22 + 332);
      else
        v23 = 0.0;
      v24 = *((_QWORD *)this + 9);
      if (v24)
      {
        v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v24 + 32))(v24, 0, v21);
      }
      else
      {
        v26 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v26)
          v25 = 0;
        else
          v25 = *v26;
      }
      ausdk::AUElement::SetParameter(v25, 2u, v23, 0);
      v27 = *((_QWORD *)this + 9);
      if (v27)
      {
        v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
      }
      else
      {
        v29 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v29)
          v28 = 0;
        else
          v28 = *v29;
      }
      ausdk::AUElement::SetParameter(v28, 5u, (float)*(int *)(*((_QWORD *)this + 68) + 484), 0);
      v30 = *((_QWORD *)this + 9);
      if (v30)
      {
        v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
      }
      else
      {
        v32 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v32)
          v31 = 0;
        else
          v31 = *v32;
      }
      ausdk::AUElement::SetParameter(v31, 6u, *(float *)(*((_QWORD *)this + 68) + 480), 0);
      v33 = *((_QWORD *)this + 9);
      if (v33)
      {
        v34 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v33 + 32))(v33, 0);
      }
      else
      {
        v35 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v35)
          v34 = 0;
        else
          v34 = *v35;
      }
      ausdk::AUElement::SetParameter(v34, 7u, (float)*(int *)(*((_QWORD *)this + 68) + 432), 0);
      v36 = *((_QWORD *)this + 9);
      if (v36)
      {
        v37 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v36 + 32))(v36, 0);
      }
      else
      {
        v38 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v38)
          v37 = 0;
        else
          v37 = *v38;
      }
      ausdk::AUElement::SetParameter(v37, 8u, *(float *)(*((_QWORD *)this + 68) + 436), 0);
      v39 = *((_QWORD *)this + 9);
      if (v39)
      {
        v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
      }
      else
      {
        v41 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v41)
          v40 = 0;
        else
          v40 = *v41;
      }
      ausdk::AUElement::SetParameter(v40, 9u, *(float *)(*((_QWORD *)this + 68) + 336), 0);
      v42 = *((_QWORD *)this + 9);
      if (v42)
      {
        v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v42 + 32))(v42, 0);
      }
      else
      {
        v44 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v44)
          v43 = 0;
        else
          v43 = *v44;
      }
      ausdk::AUElement::SetParameter(v43, 0xAu, *(float *)(*((_QWORD *)this + 68) + 340), 0);
      v45 = *((_QWORD *)this + 9);
      if (v45)
      {
        v46 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v45 + 32))(v45, 0);
      }
      else
      {
        v47 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v47)
          v46 = 0;
        else
          v46 = *v47;
      }
      ausdk::AUElement::SetParameter(v46, 0xBu, *(float *)(*((_QWORD *)this + 68) + 504), 0);
      v48 = *((_QWORD *)this + 9);
      if (v48)
      {
        v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v48 + 32))(v48, 0);
      }
      else
      {
        v50 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v50)
          v49 = 0;
        else
          v49 = *v50;
      }
      ausdk::AUElement::SetParameter(v49, 0xCu, *(float *)(*((_QWORD *)this + 68) + 508), 0);
      v51 = *((_QWORD *)this + 9);
      if (v51)
      {
        v52 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v51 + 32))(v51, 0);
      }
      else
      {
        v53 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v53)
          v52 = 0;
        else
          v52 = *v53;
      }
      ausdk::AUElement::SetParameter(v52, 0xDu, (float)*(int *)(*((_QWORD *)this + 68) + 52), 0);
      v54 = *((_QWORD *)this + 9);
      if (v54)
      {
        v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v54 + 32))(v54, 0);
      }
      else
      {
        v56 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v56)
          v55 = 0;
        else
          v55 = *v56;
      }
      ausdk::AUElement::SetParameter(v55, 0x10u, *(float *)(*((_QWORD *)this + 68) + 616) - *(float *)(*((_QWORD *)this + 68) + 612), 0);
      v57 = *((_QWORD *)this + 9);
      if (v57)
      {
        v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v57 + 32))(v57, 0);
      }
      else
      {
        v59 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v59)
          v58 = 0;
        else
          v58 = *v59;
      }
      ausdk::AUElement::SetParameter(v58, 0x11u, *(float *)(*((_QWORD *)this + 68) + 524), 0);
      v60 = *((_QWORD *)this + 9);
      if (v60)
      {
        v61 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v60 + 32))(v60, 0);
      }
      else
      {
        v62 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v62)
          v61 = 0;
        else
          v61 = *v62;
      }
      ausdk::AUElement::SetParameter(v61, 0x12u, *(float *)(*((_QWORD *)this + 68) + 612), 0);
      v63 = *((_QWORD *)this + 9);
      if (v63)
      {
        v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v63 + 32))(v63, 0);
      }
      else
      {
        v65 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v65)
          v64 = 0;
        else
          v64 = *v65;
      }
      ausdk::AUElement::SetParameter(v64, 0x15u, *(float *)(*((_QWORD *)this + 68) + 512), 0);
      v66 = *((_QWORD *)this + 9);
      if (v66)
      {
        v67 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v66 + 32))(v66, 0);
      }
      else
      {
        v68 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v68)
          v67 = 0;
        else
          v67 = *v68;
      }
      ausdk::AUElement::SetParameter(v67, 0x16u, *(float *)(*((_QWORD *)this + 68) + 516), 0);
      memcpy(a7[2]->mBuffers[0].mData, *(const void **)(*((_QWORD *)this + 68) + 168), 4 * *(int *)(*((_QWORD *)this + 68) + 4));
      v69 = (char *)(*a7)->mBuffers[0].mData;
      v70 = a7[1]->mBuffers[0].mData;
      v71 = *((unsigned int *)this + 84);
      if (*((_BYTE *)this + 541))
      {
        v72 = &v69[4 * v71];
        v73 = *((_QWORD *)this + 68);
        if (v73)
        {
          v74 = *(const void **)(v73 + 584);
          v75 = *(float **)(v73 + 592);
        }
        else
        {
          v74 = 0;
          v75 = 0;
        }
        memcpy(v69, v74, 4 * v71);
        v76 = 4 * *((unsigned int *)this + 84);
        v69 = v72;
        v77 = v75;
      }
      else
      {
        v76 = 4 * v71;
        v77 = v17;
      }
      memcpy(v69, v77, v76);
      mData = *(void **)(*((_QWORD *)this + 68) + 384);
      v15 = 4 * *((unsigned int *)this + 84);
      v14 = v70;
    }
    memcpy(v14, mData, v15);
    return 0;
  }
  return result;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::Render(AUMagnitudeDifferenceNoiseSuppressor *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  uint64_t Element;
  ausdk::AUInputElement *v9;
  uint64_t result;
  unsigned int v11;
  ausdk::AUInputElement *v12;
  uint64_t v13;
  uint64_t BufferList;
  uint64_t v15;
  ausdk::AUBufferList *v16;
  _QWORD v17[3];
  _QWORD v18[4];

  v18[3] = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 84) != (_DWORD)a4)
    return 4294956422;
  if (!ausdk::AUBase::HasInput(this, 0))
    return 4294956420;
  Element = ausdk::AUScope::SafeGetElement((AUMagnitudeDifferenceNoiseSuppressor *)((char *)this + 128), 0);
  v9 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUMagnitudeDifferenceNoiseSuppressor *)((char *)this + 80), 0);
  result = ausdk::AUInputElement::PullInput(v9, a2, a3, 0, a4);
  if ((_DWORD)result)
    return result;
  if (ausdk::AUBase::HasInput(this, 1u))
  {
    v11 = 1;
    v12 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUMagnitudeDifferenceNoiseSuppressor *)((char *)this + 80), 1u);
    result = ausdk::AUInputElement::PullInput(v12, a2, a3, 1, a4);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    v11 = 0;
  }
  v13 = ausdk::AUScope::SafeGetElement((AUMagnitudeDifferenceNoiseSuppressor *)((char *)this + 80), v11);
  BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v13 + 144));
  v15 = ausdk::AUScope::SafeGetElement((AUMagnitudeDifferenceNoiseSuppressor *)((char *)this + 80), 0);
  v18[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v15 + 144));
  v18[1] = BufferList;
  v18[2] = BufferList;
  v16 = (ausdk::AUBufferList *)(Element + 144);
  v17[0] = ausdk::AUBufferList::GetBufferList(v16);
  v17[1] = ausdk::AUBufferList::GetBufferList(v16);
  v17[2] = ausdk::AUBufferList::GetBufferList(v16);
  return (*(uint64_t (**)(AUMagnitudeDifferenceNoiseSuppressor *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, _QWORD *))(*(_QWORD *)this + 184))(this, a2, a4, 3, v18, 3, v17);
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::GetParameterList(AUMagnitudeDifferenceNoiseSuppressor *this, int a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int v4;

  if (a2)
  {
    v4 = 0;
  }
  else
  {
    if (a3)
    {
      *(_OWORD *)a3 = xmmword_1B66A28D0;
      *((_OWORD *)a3 + 1) = xmmword_1B66A21F0;
      *((_OWORD *)a3 + 2) = xmmword_1B66A28E0;
      *((_OWORD *)a3 + 3) = xmmword_1B66A28F0;
      a3[16] = 22;
    }
    v4 = 17;
  }
  *a4 = v4;
  return 0;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::GetParameterInfo(AUMagnitudeDifferenceNoiseSuppressor *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  uint64_t v6;
  AudioUnitParameterValue v7;
  const __CFString *v8;
  AudioUnitParameterOptions v9;
  const __CFString *v10;
  const __CFString *v17;
  AudioUnitParameterOptions v18;

  buffer->flags = 0x40000000;
  buffer->unitName = 0;
  if (a2)
    return 4294956418;
  switch(a3)
  {
    case 0:
      buffer->cfNameString = CFSTR("noise supp mode");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("noise supp mode"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Indexed;
      v6 = 0x4000000000000000;
      goto LABEL_9;
    case 1:
      buffer->cfNameString = CFSTR("noise supp level");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("noise supp level"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 3256877056;
      v7 = -6.0;
      goto LABEL_10;
    case 2:
      v8 = CFSTR("(I) speech probability");
      goto LABEL_32;
    case 3:
      buffer->cfNameString = CFSTR("SPL Meter Calibration");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("SPL Meter Calibration"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 0x42C80000C1C80000;
      v7 = 80.0;
      goto LABEL_10;
    case 4:
      buffer->cfNameString = CFSTR("SPL Time Constant");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("SPL Time Constant"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v6 = 0x4120000000000000;
LABEL_9:
      *(_QWORD *)&buffer->minValue = v6;
      v7 = 2.0;
LABEL_10:
      v9 = buffer->flags | 0x80000000;
      goto LABEL_22;
    case 5:
      v8 = CFSTR("occlusion mode");
      goto LABEL_32;
    case 6:
      v8 = CFSTR("(I) occ_2ndMic confd");
      goto LABEL_32;
    case 7:
      v8 = CFSTR("(I) ns_auto_mode");
      goto LABEL_32;
    case 8:
      v8 = CFSTR("auto_blend_alpha");
      goto LABEL_32;
    case 9:
      v10 = CFSTR("(I) noise SPL (gated PS)");
      goto LABEL_17;
    case 10:
      v10 = CFSTR("(I) noise SPL (one mic)");
LABEL_17:
      buffer->cfNameString = v10;
      buffer->flags = 1207959552;
      CFStringGetCString(v10, buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x42C8000041A00000;
      v7 = 40.0;
      goto LABEL_21;
    case 11:
      v8 = CFSTR("(I) 1mic vad");
      goto LABEL_32;
    case 12:
      v8 = CFSTR("(I) 2mic vad");
      goto LABEL_32;
    case 13:
      buffer->cfNameString = CFSTR("auto NS level");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("auto NS level"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0xC0A00000C1C80000;
      v7 = -24.0;
LABEL_21:
      v9 = buffer->flags | 0x8000;
LABEL_22:
      buffer->defaultValue = v7;
      buffer->flags = v9;
      return result;
    case 14:
      buffer->cfNameString = CFSTR("AGC dynamic gain");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("AGC dynamic gain"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      __asm { FMOV            V0.2S, #-20.0 }
      break;
    case 15:
      buffer->cfNameString = CFSTR("AGC post gain");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("AGC post gain"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      __asm { FMOV            V0.2S, #-20.0 }
      *(_QWORD *)&buffer->minValue = _D0;
      buffer->defaultValue = 0.0;
      return result;
    case 16:
      v17 = CFSTR("hb minus lb_sep");
      goto LABEL_28;
    case 17:
      v8 = CFSTR("P_OCCL_based_alpha");
      goto LABEL_32;
    case 18:
      v17 = CFSTR("lb_sep");
LABEL_28:
      buffer->cfNameString = v17;
      buffer->flags = 1207959552;
      CFStringGetCString(v17, buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      _D0 = 0x41A00000C0A00000;
      break;
    case 19:
      buffer->cfNameString = CFSTR("Test_Switch");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("Test_Switch"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      v18 = buffer->flags | 0x80000000;
      goto LABEL_34;
    case 20:
      v8 = CFSTR("DL Speech Prob");
      goto LABEL_32;
    case 21:
      v8 = CFSTR("Inv 2mic vad");
LABEL_32:
      buffer->cfNameString = v8;
      buffer->flags = 1207959552;
      CFStringGetCString(v8, buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      _D0 = 0x3F80000000000000;
      break;
    case 22:
      buffer->cfNameString = CFSTR("tmv - itmv");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("tmv - itmv"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      _D0 = 0x3FC00000BF000000;
      break;
    default:
      return 4294956418;
  }
  *(_QWORD *)&buffer->minValue = _D0;
  v18 = buffer->flags | 0x8000;
LABEL_34:
  buffer->defaultValue = 0.0;
  buffer->flags = v18;
  return result;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
    ++*((_DWORD *)this + 133);
  return result;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::GetParameterValueStrings(AUMagnitudeDifferenceNoiseSuppressor *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  const __CFArray *v6;
  __int128 v7;
  const __CFString *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a3 | a2)
    return 4294956417;
  if (!a4)
    return 0;
  v7 = xmmword_1E69E9658;
  v8 = CFSTR("TwoMic");
  v6 = CFArrayCreate(0, (const void **)&v7, 3, 0);
  result = 0;
  *a4 = v6;
  return result;
}

double AUMagnitudeDifferenceNoiseSuppressor::GetLatency(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  return 0.0;
}

double AUMagnitudeDifferenceNoiseSuppressor::GetTailTime(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  return 0.0;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::SupportsTail(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  return 1;
}

BOOL AUMagnitudeDifferenceNoiseSuppressor::StreamFormatWritable(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::SupportedNumChannels(AUMagnitudeDifferenceNoiseSuppressor *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUMagnitudeDifferenceNoiseSuppressor::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::ValidFormat(AUMagnitudeDifferenceNoiseSuppressor *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  int v5;
  uint64_t result;
  char v7;
  __int128 v8;
  _OWORD v9[2];
  uint64_t v10;
  int v11;

  v5 = (int)a2;
  result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if ((_DWORD)result)
    result = (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
  if ((v5 - 1) <= 1)
  {
    if (a4->mFormatID == 1718773105)
      v7 = result;
    else
      v7 = 1;
    if ((v7 & 1) == 0)
    {
      v8 = *(_OWORD *)&a4->mBytesPerPacket;
      v9[0] = *(_OWORD *)&a4->mSampleRate;
      v9[1] = v8;
      v10 = *(_QWORD *)&a4->mBitsPerChannel;
      DWORD2(v9[0]) = 1819304813;
      v11 = 0;
      LODWORD(result) = CAStreamBasicDescription::IdentifyCommonPCMFormat(v9, &v11, 0);
      if (v11 != 4)
        LODWORD(result) = 0;
    }
    if (a4->mChannelsPerFrame == 1)
      return result;
    else
      return 0;
  }
  return result;
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::ShouldBypassEffect(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  return *((unsigned __int8 *)this + 528);
}

uint64_t AUMagnitudeDifferenceNoiseSuppressor::SetBypassEffect(uint64_t this, char a2)
{
  *(_BYTE *)(this + 528) = a2;
  return this;
}

void AUMagnitudeDifferenceNoiseSuppressor::UpdateParameters(AUMagnitudeDifferenceNoiseSuppressor *this)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  __n128 v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  __n128 v11;
  uint64_t v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  float Parameter;
  uint64_t v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;

  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v4 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  v5.n128_f32[0] = ausdk::AUElement::GetParameter(v3, 1u);
  v6 = *((_QWORD *)this + 68);
  if (v6)
  {
    v7 = (int)v5.n128_f32[0];
    if ((int)v5.n128_f32[0] >= 0)
      v7 = -v7;
    *(_DWORD *)(v6 + 52) = v7;
    *(_DWORD *)(v6 + 476) = 1;
  }
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v8 + 32))(v8, 0, v5);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  v11.n128_f32[0] = ausdk::AUElement::GetParameter(v9, 0);
  v12 = *((_QWORD *)this + 68);
  if (v12)
    *(_DWORD *)(v12 + 428) = (int)v11.n128_f32[0];
  v13 = *((_QWORD *)this + 9);
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v13 + 32))(v13, 0, v11);
  }
  else
  {
    v15 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v15)
      v14 = 0;
    else
      v14 = *v15;
  }
  *(float *)(*((_QWORD *)this + 68) + 356) = ausdk::AUElement::GetParameter(v14, 3u);
  v16 = *((_QWORD *)this + 9);
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  Parameter = ausdk::AUElement::GetParameter(v17, 4u);
  v20 = *((_QWORD *)this + 68);
  *(float *)(v20 + 360) = 1.0
                        - expf(-1.0 / (float)(Parameter * (float)((float)*(int *)(v20 + 8) / (float)*(int *)(v20 + 4))));
  v21 = *((_QWORD *)this + 9);
  if (v21)
  {
    v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
  }
  else
  {
    v23 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v23)
      v22 = 0;
    else
      v22 = *v23;
  }
  *(float *)(*((_QWORD *)this + 68) + 624) = ausdk::AUElement::GetParameter(v22, 0x13u);
  v24 = *((_QWORD *)this + 9);
  if (v24)
  {
    v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
  }
  else
  {
    v26 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v26)
      v25 = 0;
    else
      v25 = *v26;
  }
  *(float *)(*((_QWORD *)this + 68) + 628) = ausdk::AUElement::GetParameter(v25, 0x14u);
}

const __CFArray *CFHelper::extractVector<float>(uint64_t a1, CFArrayRef *a2)
{
  unint64_t Count;
  unsigned int i;
  const __CFArray *result;
  unint64_t v7;
  float *v8;
  float *v9;
  float *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  float *v16;
  int v17;
  float v18;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v18 = 0.0;
  if (*a2)
    Count = CFArrayGetCount(*a2);
  else
    Count = 0;
  std::vector<float>::reserve((void **)a1, Count);
  for (i = 0; ; ++i)
  {
    result = *a2;
    if (*a2)
      result = (const __CFArray *)CFArrayGetCount(result);
    if (i >= result)
      break;
    CACFArray::GetFloat32(a2, i, &v18);
    v8 = *(float **)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)v8 >= v7)
    {
      v10 = *(float **)a1;
      v11 = ((uint64_t)v8 - *(_QWORD *)a1) >> 2;
      v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 62)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v13 = v7 - (_QWORD)v10;
      if (v13 >> 1 > v12)
        v12 = v13 >> 1;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
        v14 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v14 = v12;
      if (v14)
      {
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(a1 + 16, v14);
        v10 = *(float **)a1;
        v8 = *(float **)(a1 + 8);
      }
      else
      {
        v15 = 0;
      }
      v16 = (float *)&v15[4 * v11];
      *v16 = v18;
      v9 = v16 + 1;
      while (v8 != v10)
      {
        v17 = *((_DWORD *)v8-- - 1);
        *((_DWORD *)v16-- - 1) = v17;
      }
      *(_QWORD *)a1 = v16;
      *(_QWORD *)(a1 + 8) = v9;
      *(_QWORD *)(a1 + 16) = &v15[4 * v14];
      if (v10)
        operator delete(v10);
    }
    else
    {
      *v8 = v18;
      v9 = v8 + 1;
    }
    *(_QWORD *)(a1 + 8) = v9;
  }
  return result;
}

void sub_1B653F818(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

const __CFArray *CFHelper::extractVector<double>(uint64_t a1, CFArrayRef *a2)
{
  unint64_t Count;
  unsigned int i;
  const __CFArray *result;
  unint64_t v7;
  double *v8;
  double *v9;
  double *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  double *v16;
  uint64_t v17;
  double v18;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v18 = 0.0;
  if (*a2)
    Count = CFArrayGetCount(*a2);
  else
    Count = 0;
  std::vector<double>::reserve((void **)a1, Count);
  for (i = 0; ; ++i)
  {
    result = *a2;
    if (*a2)
      result = (const __CFArray *)CFArrayGetCount(result);
    if (i >= result)
      break;
    CACFArray::GetFloat64(a2, i, &v18);
    v8 = *(double **)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)v8 >= v7)
    {
      v10 = *(double **)a1;
      v11 = ((uint64_t)v8 - *(_QWORD *)a1) >> 3;
      v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v13 = v7 - (_QWORD)v10;
      if (v13 >> 2 > v12)
        v12 = v13 >> 2;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v12;
      if (v14)
      {
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,float>>>(a1 + 16, v14);
        v10 = *(double **)a1;
        v8 = *(double **)(a1 + 8);
      }
      else
      {
        v15 = 0;
      }
      v16 = (double *)&v15[8 * v11];
      *v16 = v18;
      v9 = v16 + 1;
      while (v8 != v10)
      {
        v17 = *((_QWORD *)v8-- - 1);
        *((_QWORD *)v16-- - 1) = v17;
      }
      *(_QWORD *)a1 = v16;
      *(_QWORD *)(a1 + 8) = v9;
      *(_QWORD *)(a1 + 16) = &v15[8 * v14];
      if (v10)
        operator delete(v10);
    }
    else
    {
      *v8 = v18;
      v9 = v8 + 1;
    }
    *(_QWORD *)(a1 + 8) = v9;
  }
  return result;
}

void sub_1B653F994(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

const __CFArray *CFHelper::extractVector<unsigned int>(std::vector<unsigned int> *a1, CFArrayRef *a2)
{
  std::vector<unsigned int>::size_type Count;
  unsigned int i;
  const __CFArray *result;
  unsigned int CFType;
  const __CFNumber *v8;
  unsigned int v9;
  CFTypeID v10;
  unsigned int *value;
  std::vector<unsigned int>::pointer end;
  unsigned int *v13;
  std::vector<unsigned int>::pointer begin;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int valuePtr;
  CFTypeRef cf;

  a1->__begin_ = 0;
  a1->__end_ = 0;
  a1->__end_cap_.__value_ = 0;
  valuePtr = 0;
  if (*a2)
    Count = CFArrayGetCount(*a2);
  else
    Count = 0;
  std::vector<unsigned int>::reserve(a1, Count);
  for (i = 0; ; ++i)
  {
    result = *a2;
    if (*a2)
      result = (const __CFArray *)CFArrayGetCount(result);
    if (i >= result)
      break;
    cf = 0;
    CFType = CACFArray::GetCFType(a2, i, &cf);
    v8 = (const __CFNumber *)cf;
    if (cf)
      v9 = CFType;
    else
      v9 = 0;
    if (v9 == 1)
    {
      v10 = CFGetTypeID(cf);
      if (v10 == CFNumberGetTypeID())
        CFNumberGetValue(v8, kCFNumberSInt32Type, &valuePtr);
    }
    end = a1->__end_;
    value = a1->__end_cap_.__value_;
    if (end >= value)
    {
      begin = a1->__begin_;
      v15 = end - a1->__begin_;
      v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 62)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v17 = (char *)value - (char *)begin;
      if (v17 >> 1 > v16)
        v16 = v17 >> 1;
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL)
        v18 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v18 = v16;
      if (v18)
      {
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&a1->__end_cap_, v18);
        begin = a1->__begin_;
        end = a1->__end_;
      }
      else
      {
        v19 = 0;
      }
      v20 = (unsigned int *)&v19[4 * v15];
      *v20 = valuePtr;
      v13 = v20 + 1;
      while (end != begin)
      {
        v21 = *--end;
        *--v20 = v21;
      }
      a1->__begin_ = v20;
      a1->__end_ = v13;
      a1->__end_cap_.__value_ = (unsigned int *)&v19[4 * v18];
      if (begin)
        operator delete(begin);
    }
    else
    {
      *end = valuePtr;
      v13 = end + 1;
    }
    a1->__end_ = v13;
  }
  return result;
}

void sub_1B653FB50(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

const __CFArray *CFHelper::extractVectorOfVectors<float>(uint64_t *a1, CFArrayRef *a2)
{
  unint64_t Count;
  unsigned int v5;
  const CFArrayCallBacks *v6;
  const __CFArray *result;
  void *__p[3];
  CFArrayRef Mutable;
  __int16 v10;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (*a2)
    Count = CFArrayGetCount(*a2);
  else
    Count = 0;
  std::vector<std::vector<float>>::reserve(a1, Count);
  v5 = 0;
  v6 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  while (1)
  {
    result = *a2;
    if (*a2)
      result = (const __CFArray *)CFArrayGetCount(result);
    if (v5 >= result)
      break;
    Mutable = CFArrayCreateMutable(0, 0, v6);
    v10 = 257;
    CACFArray::GetCACFArray(a2, v5, (CACFArray *)&Mutable);
    CFHelper::extractVector<float>((uint64_t)__p, &Mutable);
    std::vector<std::vector<float>>::push_back[abi:ne180100](a1, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    CACFArray::~CACFArray((CACFArray *)&Mutable);
    ++v5;
  }
  return result;
}

void sub_1B653FC58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t EndpointVADDSPChain::Uninitialize(uint64_t this)
{
  uint64_t v1;

  if (*(_BYTE *)this)
  {
    v1 = this;
    this = AudioUnitUninitialize(*(AudioUnit *)(this + 56));
    if (!(_DWORD)this)
    {
      AudioUnitUninitialize(*(AudioUnit *)(v1 + 64));
      this = *(_QWORD *)(v1 + 48);
      if (this)
        this = MEMORY[0x1BCC95CEC](this, 0x1000C40FF89C88ELL);
      *(_QWORD *)(v1 + 48) = 0;
      *(_BYTE *)v1 = 0;
    }
  }
  return this;
}

void AUVolumeTaper::~AUVolumeTaper(id *this)
{

  AUDspLib::~AUDspLib((AUDspLib *)this);
}

{

  AUDspLib::~AUDspLib((AUDspLib *)this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AUVolumeTaper::Initialize(NSDictionary **this)
{
  uint64_t result;
  NSDictionary *v3;
  BOOL v4;

  result = AUDspLib::Initialize((AUDspLib *)this);
  v3 = this[276];
  if (v3)
    v4 = (_DWORD)result == 0;
  else
    v4 = 0;
  if (v4)
    return AUVolumeTaper::parseDictionary((AUVolumeTaper *)this, v3);
  return result;
}

uint64_t AUVolumeTaper::GetPropertyInfo(AUVolumeTaper *this, int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a2 != 1987342435 && a2 != 6620)
    return AUDspLib::GetPropertyInfo(this, a2, a3, a4, a5, a6);
  *a5 = 8;
  *a6 = 1;
  return 0;
}

uint64_t AUVolumeTaper::GetProperty(AUVolumeTaper *this, int a2, int a3, unsigned int a4, CFDictionaryRef *a5, int *a6, float a7)
{
  uint64_t result;
  uint64_t v10;
  int v11;
  unint64_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  NSObject *v18;
  double v19;
  int v20;
  double v21;
  __int16 v22;
  double v23;
  __int16 v24;
  double v25;
  __int16 v26;
  double v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a3)
    return 4294956430;
  if (a2 != 1987342435)
    return AUDspLib::GetProperty(this, a2, 0, a4, a5, a6);
  v10 = *((_QWORD *)this + 66);
  if (!v10)
    return 4294956429;
  v11 = *((_DWORD *)this + 551);
  if (v11 == 1)
  {
    v13 = *((float *)this + 550);
    v14 = 0.0;
    if (v13 >= 0.0)
    {
      v14 = 1.0;
      if (v13 <= 1.0)
        v14 = *((float *)this + 550);
    }
    a7 = DspLib::VolumeTaper::Algorithm::gainInDecibelsForSliderPosition(*((DspLib::VolumeTaper::Algorithm **)this + 66), v14);
    v11 = 0;
    goto LABEL_15;
  }
  if (v11)
  {
LABEL_15:
    result = 0;
    *(float *)a5 = a7;
    *((_DWORD *)a5 + 1) = v11;
    return result;
  }
  v12 = DspLib::VolumeTaper::Algorithm::sliderPositionForGainCalculator(*((DspLib::VolumeTaper::Algorithm **)this + 66), *((float *)this + 550));
  v11 = 1;
  if ((v12 & 0xFF00000000) != 0)
  {
    a7 = *(float *)&v12;
    goto LABEL_15;
  }
  v15 = *(float *)(v10 + 432);
  v16 = *(float *)(v10 + 496);
  if (vabds_f32(*((float *)this + 550), v15) >= vabds_f32(*((float *)this + 550), v16))
    v17 = 1.0;
  else
    v17 = 0.0;
  *(float *)a5 = v17;
  *((_DWORD *)a5 + 1) = 1;
  DspLib::VolumeTaper::getAUVolumeTaperLog((DspLib::VolumeTaper *)v12);
  v18 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    v19 = *((float *)this + 550);
    v20 = 134218752;
    v21 = v19;
    v22 = 2048;
    v23 = v15;
    v24 = 2048;
    v25 = v16;
    v26 = 2048;
    v27 = v17;
    _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEFAULT, "GetProperty(UnitConverter): requested value (%.2fdB) is out of range [%.2f, %.2f]dB. Returning %.2f", (uint8_t *)&v20, 0x2Au);
  }

  return 4294956445;
}

uint64_t AUVolumeTaper::SetProperty(NSDictionary **this, int a2, int a3, unsigned int a4, int *a5, void *a6, int *a7)
{
  id v8;
  uint64_t isKindOfClass;
  id v10;
  uint64_t v11;
  NSDictionary *v12;
  uint64_t v13;
  id v14;
  DspLib::VolumeTaper::Algorithm *v15;
  NSObject *v17;
  NSObject *v19;
  uint8_t v20[16];
  uint8_t buf[16];

  if (a2 != 1987342435)
  {
    if (a2 != 6620)
      return AUDspLib::SetProperty((AUDspLib *)this, a2, a3, a4, a5, a6, a7);
    if ((_DWORD)a6 == 8)
    {
      if (a5)
      {
        v8 = *(id *)a5;
        applesauce::dispatch::v1::queue::get(*(id *)a5);
        objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        isKindOfClass = objc_opt_isKindOfClass();
        if ((isKindOfClass & 1) != 0)
        {
          v10 = v8;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithDictionary:", v10);
          v11 = objc_claimAutoreleasedReturnValue();
          v12 = this[276];
          this[276] = (NSDictionary *)v11;

          v13 = AUVolumeTaper::parseDictionary((AUVolumeTaper *)this, this[276]);
        }
        else
        {
          DspLib::VolumeTaper::getAUVolumeTaperLog((DspLib::VolumeTaper *)isKindOfClass);
          v19 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v20 = 0;
            _os_log_error_impl(&dword_1B5ED0000, v19, OS_LOG_TYPE_ERROR, "SetProperty(kAudioUnitProperty_DspLibDictionary) Error: unknown plist format\n", v20, 2u);
          }

          v10 = 0;
          v13 = 4294956417;
        }

      }
      else
      {
        DspLib::VolumeTaper::getAUVolumeTaperLog((DspLib::VolumeTaper *)this);
        v17 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_ERROR, "SetProperty(kAudioUnitProperty_DspLibDictionary) Error : data\n", buf, 2u);
        }

        return 4294956417;
      }
      return v13;
    }
    return 4294956445;
  }
  if ((_DWORD)a6 != 8)
    return 4294956445;
  v14 = *(id *)a5;
  this[275] = *(NSDictionary **)a5;
  if (HIDWORD(v14) == 1)
  {
    if (*(float *)&v14 >= 0.0 && *(float *)&v14 <= 1.0)
      return 0;
    return 4294956445;
  }
  if (!HIDWORD(v14))
  {
    v15 = (DspLib::VolumeTaper::Algorithm *)this[66];
    if (!v15)
      return 4294956429;
    if ((DspLib::VolumeTaper::Algorithm::sliderPositionForGainCalculator(v15, *(float *)&v14) & 0xFF00000000) == 0)
      return 4294956445;
  }
  return 0;
}

void sub_1B65401B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t AUVolumeTaper::SetParameter(DspLib::VolumeTaper::Algorithm **this, uint64_t a2, unsigned int a3, uint64_t a4, float a5)
{
  unsigned __int8 v10;
  DspLib::VolumeTaper::Algorithm *v11;
  float v12;
  float v13;
  float v14;
  DspLib::VolumeTaper *v15;
  NSObject *v16;
  uint64_t (***v18)(_QWORD, _QWORD, uint64_t);
  int v19;
  double v20;
  __int16 v21;
  double v22;
  __int16 v23;
  double v24;
  __int16 v25;
  double v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if ((v10 & 1) == 0
  {
    v18 = (uint64_t (***)(_QWORD, _QWORD, uint64_t))(*((uint64_t (**)(DspLib::VolumeTaper::Algorithm **))*this
                                                              + 80))(this);
    AUVolumeTaper::SetParameter(unsigned int,unsigned int,unsigned int,float,unsigned int)::kAUParameterVolumeSlider = (**v18)(v18, 0, 4);
  }
  if (AUVolumeTaper::SetParameter(unsigned int,unsigned int,unsigned int,float,unsigned int)::kAUParameterVolumeSlider == (_DWORD)a2)
  {
    v11 = this[66];
    if (v11)
    {
      v12 = DspLib::VolumeTaper::Algorithm::gainInDecibels(this[66]);
      v13 = DspLib::VolumeTaper::Algorithm::currentSliderPosition(v11);
      v14 = DspLib::VolumeTaper::Algorithm::gainInDecibelsForSliderPosition(v11, a5);
      DspLib::VolumeTaper::getAUVolumeTaperLog(v15);
      v16 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v19 = 134218752;
        v20 = a5;
        v21 = 2048;
        v22 = v14;
        v23 = 2048;
        v24 = v12;
        v25 = 2048;
        v26 = v13;
        _os_log_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEFAULT, "<Updated Dezipper> Setting volume slider to: %.2f (%.2fdB). Current gain: %.2fdB - slider position: %.2f", (uint8_t *)&v19, 0x2Au);
      }

    }
  }
  return AUDspLibWithNewParameters::SetParameter((AUDspLibWithNewParameters *)this, a2, a3, a4, a5);
}

void sub_1B6540380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t AUVolumeTaper::ProcessBufferLists(DspLib::VolumeTaper::Algorithm **this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  uint64_t v6;
  DspLib::VolumeTaper::Algorithm *v7;
  float v8;
  ausdk::AUScope *v9;
  ausdk::AUElement *Element;
  float v11;
  ausdk::AUElement *v12;
  float v13;
  ausdk::AUElement *v14;
  AudioBufferList *v16;
  const AudioBufferList *v17;

  v16 = a4;
  v17 = a3;
  v6 = (*((uint64_t (**)(DspLib::VolumeTaper::Algorithm **, unsigned int *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))*this
        + 23))(this, a2, a5, 1, &v17, 1, &v16);
  v7 = this[66];
  if (v7)
  {
    v8 = DspLib::VolumeTaper::Algorithm::gainInDecibels(this[66]);
    v9 = (ausdk::AUScope *)(this + 4);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v9, 0);
    ausdk::AUElement::SetParameter(Element, 0x64u, v8, 0);
    v11 = DspLib::VolumeTaper::Algorithm::currentSliderPosition(v7);
    v12 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v9, 0);
    ausdk::AUElement::SetParameter(v12, 0x65u, v11, 0);
    v13 = DspLib::VolumeTaper::Algorithm::isRamping(v7);
    v14 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v9, 0);
    ausdk::AUElement::SetParameter(v14, 0x66u, v13, 0);
  }
  return v6;
}

uint64_t AUVolumeTaper::GetParameterInfo(AUVolumeTaper *this, unsigned int a2, uint64_t a3, AudioUnitParameterInfo *buffer)
{
  const __CFString *v4;

  switch((_DWORD)a3)
  {
    case 'f':
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      *(_QWORD *)&buffer->defaultValue = 0x4980800000000000;
      v4 = CFSTR("Is Ramping");
      goto LABEL_7;
    case 'e':
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      *(_QWORD *)&buffer->defaultValue = 0x4980800000000000;
      v4 = CFSTR("Current Slider Position");
      goto LABEL_7;
    case 'd':
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 0x41200000C3700000;
      *(_QWORD *)&buffer->defaultValue = 0x49808000C3700000;
      v4 = CFSTR("Gain");
LABEL_7:
      buffer->cfNameString = v4;
      CFStringGetCString(v4, buffer->name, 52, 0x8000100u);
      return 0;
  }
  return AUDspLibWithNewParameters::GetParameterInfo(this, a2, a3, buffer);
}

uint64_t AUVolumeTaper::GetParameterValueStrings(AUVolumeTaper *this, unsigned int a2, int a3, const __CFArray **a4)
{
  uint64_t (***v7)(_QWORD, _QWORD, uint64_t);
  int v8;
  uint64_t (***v9)(_QWORD, uint64_t, _QWORD);
  int v10;
  char **v11;
  uint64_t v12;
  uint64_t result;
  __CFArray *v14;

  if (!a4)
    return 4294956418;
  v7 = (uint64_t (***)(_QWORD, _QWORD, uint64_t))(*(uint64_t (**)(AUVolumeTaper *))(*(_QWORD *)this + 640))(this);
  v8 = (**v7)(v7, 0, 7);
  v9 = (uint64_t (***)(_QWORD, uint64_t, _QWORD))(*(uint64_t (**)(AUVolumeTaper *))(*(_QWORD *)this + 640))(this);
  v10 = (**v9)(v9, 0x200000000, 0);
  if (v8 == a3)
  {
    v11 = _ZGRN6DspLib11VolumeTaperL20kSlewRateUnitOptionsE_;
    v12 = 2;
LABEL_7:
    v14 = AUDspLib::CFArrayOfStringsCreateWithCArrayOfStrings((const char **)v11, (const char *const *)v12);
    result = 0;
    *a4 = v14;
    return result;
  }
  if (v10 == a3)
  {
    v11 = _ZGRN6DspLib11VolumeTaper10ParametersL19kCustomCurveOptionsE_;
    v12 = 3;
    goto LABEL_7;
  }
  return 0;
}

uint64_t AUVolumeTaper::Version(AUVolumeTaper *this)
{
  return 16842762;
}

DspLib::VolumeTaper::Algorithm *AUVolumeTaper::newDspLibAlgorithm(AUVolumeTaper *this)
{
  DspLib::VolumeTaper::Algorithm *v1;

  v1 = (DspLib::VolumeTaper::Algorithm *)operator new();
  DspLib::VolumeTaper::Algorithm::Algorithm(v1);
  return v1;
}

void sub_1B654065C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10E1C40317801A1);
  _Unwind_Resume(a1);
}

id DspLib::VolumeTaper::getAUVolumeTaperLog(DspLib::VolumeTaper *this)
{
  if (DspLib::VolumeTaper::getAUVolumeTaperLog(void)::onceToken != -1)
    dispatch_once(&DspLib::VolumeTaper::getAUVolumeTaperLog(void)::onceToken, &__block_literal_global_22123);
  return (id)DspLib::VolumeTaper::getAUVolumeTaperLog(void)::gLog;
}

void ___ZN6DspLib11VolumeTaper19getAUVolumeTaperLogEv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.coreaudio", "AUVolumeTaper");
  v1 = (void *)DspLib::VolumeTaper::getAUVolumeTaperLog(void)::gLog;
  DspLib::VolumeTaper::getAUVolumeTaperLog(void)::gLog = (uint64_t)v0;

}

uint64_t AUVolumeTaper::parseDictionary(AUVolumeTaper *this, NSDictionary *a2)
{
  unint64_t v2;
  NSDictionary *v4;
  id v5;
  uint64_t isKindOfClass;
  DspLib::VolumeTaper *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t i;
  void *v12;
  uint64_t (***v13)(_QWORD, uint64_t, unint64_t);
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  int v28;
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  -[NSDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", CFSTR("mainCurve"));
  v5 = (id)objc_claimAutoreleasedReturnValue();
  if (!v5)
  {
    -[NSDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", CFSTR("OutputMap"));
    v5 = (id)objc_claimAutoreleasedReturnValue();
    if (!v5)
      goto LABEL_17;
  }
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();
  if ((isKindOfClass & 1) == 0)
  {
    DspLib::VolumeTaper::getAUVolumeTaperLog((DspLib::VolumeTaper *)isKindOfClass);
    v16 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
LABEL_16:

LABEL_17:
      v15 = 4294956445;
      goto LABEL_18;
    }
    *(_WORD *)buf = 0;
    v17 = "parseDictionary() Error: array expected";
    v18 = v16;
    v19 = 2;
LABEL_20:
    _os_log_error_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
    goto LABEL_16;
  }
  v7 = (DspLib::VolumeTaper *)objc_msgSend(v5, "count");
  if (v7 != (DspLib::VolumeTaper *)17)
  {
    DspLib::VolumeTaper::getAUVolumeTaperLog(v7);
    v16 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_16;
    *(_DWORD *)buf = 134218240;
    v26 = objc_msgSend(v5, "count");
    v27 = 1024;
    v28 = 17;
    v17 = "parseDictionary() Error: length is %lu, but should be %d";
    v18 = v16;
    v19 = 18;
    goto LABEL_20;
  }
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v5 = v5;
  v8 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
  if (v8)
  {
    v9 = 0;
    v10 = *(_QWORD *)v22;
    do
    {
      for (i = 0; i != v8; ++i)
      {
        if (*(_QWORD *)v22 != v10)
          objc_enumerationMutation(v5);
        v12 = *(void **)(*((_QWORD *)&v21 + 1) + 8 * i);
        v13 = (uint64_t (***)(_QWORD, uint64_t, unint64_t))(*(uint64_t (**)(AUVolumeTaper *))(*(_QWORD *)this + 640))(this);
        v2 = v2 & 0xFFFFFFFF00000000 | (v9 + i);
        v14 = (**v13)(v13, 0x100000000, v2);
        objc_msgSend(v12, "floatValue", (_QWORD)v21);
        (*(void (**)(AUVolumeTaper *, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 152))(this, v14, 0, 0, 0);
      }
      v8 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
      v9 += i;
    }
    while (v8);
  }

  v15 = 0;
  (*(void (**)(AUVolumeTaper *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 432))(this, 36, 0, 0);
LABEL_18:

  return v15;
}

void sub_1B654098C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

TorqueEngine *TorqueEngine::processBlock(TorqueEngine *result, uint64_t a2, _DWORD *a3)
{
  uint64_t v5;
  int v6;
  unint64_t v7;
  int v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  TorqueEngine *v13;
  int v14;
  float *v15;
  float *v16;
  float32x2_t *v17;
  float32x2_t *v18;
  int v19;
  float32x2_t *v20;
  float32x2_t *v21;
  int v22;
  float32x2_t *v23;
  int v24;
  float32x2_t *v25;
  uint64_t v26;
  float v27;
  float32x2_t v28;
  float v29;
  float32x2_t v30;
  uint64_t *v31;
  uint64_t *v32;
  int v33;
  _QWORD *v34;
  _QWORD *v35;
  int v36;
  _QWORD *v37;
  _QWORD *v38;
  float *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  __float2 v55;
  __float2 v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  BOOL v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float32x2_t v73;
  float *v74;
  float32x2_t v75;
  float v76;
  uint64_t v77;
  int v78;
  float *v79;
  int v80;
  float *v81;
  float *v82;
  int v83;
  float *v84;
  float *v85;
  float v86;
  int v87;
  float *v88;
  float *v89;
  float v90;
  int v91;
  float *v92;
  float *v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  __float2 v107;
  float v108;
  float v109;
  __float2 v110;
  __float2 v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  __float2 v125;
  float v126;
  float v127;
  __float2 v128;
  __float2 v129;
  __float2 v130;
  uint64_t v131;
  float v132;
  float v133;
  float v134;
  float v135;
  __float2 v136;
  uint64_t v137;
  float v138;
  float v139;
  float v140;
  float v141;
  int v142;
  float *v143;
  float *v144;
  int v145;
  float *v146;
  int v147;
  float *v148;
  int v149;
  float *v150;
  float v151;
  float v152;
  float v153;
  float v154;
  BOOL v155;
  float v156;
  float v157;
  float v158;
  float v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float32x2_t *v164;
  float32x2_t *v165;
  float32x2_t *v166;
  int v167;
  float32x2_t *v168;
  float32x2_t *v169;
  float32x2_t *v170;
  float32x2_t *v171;
  float32x2_t *v172;
  float32x2_t *v173;
  float v174;
  __float2 v175;
  __float2 v176;
  float v177;
  float v178;
  float v179;
  float v180;
  float v181;
  float v182;
  float v183;
  float v184;
  __float2 v185;
  float v186;
  float v187;
  uint64_t v188;
  float32x2_t v189;
  float32x2_t v190;
  float32x2_t v191;
  int v192;
  float32x2_t *v193;
  int v194;
  float32x2_t *v195;
  int v196;
  float *v197;
  float *v198;
  uint64_t v199;
  float v200;
  float v201;
  int v202;
  uint64_t v203;
  uint64_t v204;
  int v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t i;
  float v216;
  float v217;
  _DWORD *v218;
  uint64_t v219;
  float v220;
  float v221;
  TorqueEngine *v222;
  float v223;
  float v224;
  float v225;
  float v226;
  float v227;

  v5 = *(int *)(a2 + 4);
  if (!*((_BYTE *)result + 4))
  {
    v13 = result;
    TorqueEngine::updateCrossoverResponse(result);
    v14 = *((_DWORD *)v13 + 3948);
    if (v14 <= 1)
    {
      v15 = 0;
    }
    else
    {
      v15 = (float *)*((_QWORD *)v13 + 1977);
      if (v14 != 2)
      {
        v16 = (float *)*((_QWORD *)v13 + 1978);
        goto LABEL_23;
      }
    }
    v16 = 0;
LABEL_23:
    if (*(int *)a2 < 1)
    {
      v17 = 0;
    }
    else
    {
      v17 = *(float32x2_t **)(a2 + 16);
      if (*(_DWORD *)a2 != 1)
      {
        v18 = *(float32x2_t **)(a2 + 24);
        goto LABEL_28;
      }
    }
    v18 = 0;
LABEL_28:
    v19 = *((_DWORD *)v13 + 2128);
    if (v19 < 1)
    {
      v20 = 0;
    }
    else
    {
      v20 = (float32x2_t *)*((_QWORD *)v13 + 1066);
      if (v19 != 1)
      {
        v21 = (float32x2_t *)*((_QWORD *)v13 + 1067);
        goto LABEL_33;
      }
    }
    v21 = 0;
LABEL_33:
    v22 = *((_DWORD *)v13 + 2388);
    if (v22 < 1)
    {
      v24 = 0;
      v23 = 0;
    }
    else
    {
      v23 = (float32x2_t *)*((_QWORD *)v13 + 1196);
      if (v22 != 1)
      {
        v25 = (float32x2_t *)*((_QWORD *)v13 + 1197);
        v24 = 1;
        if (!(_DWORD)v5)
          goto LABEL_42;
LABEL_40:
        v26 = v5;
        do
        {
          *v20++ = vmul_n_f32(*v17, *v15);
          v27 = *v15++;
          *v21++ = vmul_n_f32(*v18, v27);
          v28 = *v17++;
          *v23++ = vmul_n_f32(v28, *v16);
          v28.f32[0] = *v16++;
          v29 = v28.f32[0];
          v30 = *v18++;
          *v25++ = vmul_n_f32(v30, v29);
          --v26;
        }
        while (v26);
LABEL_42:
        if (v22 < 1)
        {
          v31 = 0;
          if (v24)
            goto LABEL_44;
        }
        else
        {
          v31 = (uint64_t *)*((_QWORD *)v13 + 1196);
          if (v24)
          {
LABEL_44:
            v32 = (uint64_t *)*((_QWORD *)v13 + 1197);
            goto LABEL_47;
          }
        }
        v32 = 0;
LABEL_47:
        v33 = *((_DWORD *)v13 + 2908);
        if (v33 < 1)
        {
          v34 = 0;
        }
        else
        {
          v34 = (_QWORD *)*((_QWORD *)v13 + 1456);
          if (v33 != 1)
          {
            v35 = (_QWORD *)*((_QWORD *)v13 + 1457);
            goto LABEL_52;
          }
        }
        v35 = 0;
LABEL_52:
        v36 = *((_DWORD *)v13 + 2648);
        if (v36 < 1)
        {
          v37 = 0;
        }
        else
        {
          v37 = (_QWORD *)*((_QWORD *)v13 + 1326);
          if (v36 != 1)
          {
            v38 = (_QWORD *)*((_QWORD *)v13 + 1327);
            goto LABEL_57;
          }
        }
        v38 = 0;
LABEL_57:
        v218 = a3;
        v219 = v5;
        v222 = v13;
        if (*((_BYTE *)v13 + 16))
        {
          if (*((int *)v13 + 3168) < 1)
          {
            v39 = 0;
            if (!(_DWORD)v5)
              goto LABEL_92;
          }
          else
          {
            v39 = (float *)*((_QWORD *)v13 + 1586);
            if (!(_DWORD)v5)
              goto LABEL_92;
          }
          v43 = 0;
          v44 = v5;
          do
          {
            v45 = *(float *)&v31[v43];
            v46 = *((float *)&v31[v43] + 1);
            v47 = *(float *)&v32[v43];
            v48 = *((float *)&v32[v43] + 1);
            v49 = (float)(v46 * v46) + (float)(v45 * v45);
            v50 = (float)(v48 * v48) + (float)(v47 * v47);
            v51 = sqrtf(v49 + v50);
            v52 = (float)(atan2f(sqrtf(v49), sqrtf(v50)) * 1.2732) + -1.0;
            v53 = atan2f(v48, v47);
            v54 = v53 - atan2f(v46, v45);
            v55 = __sincosf_stret((float)(v52 * 3.1416) * 0.5);
            v56 = __sincosf_stret(v54);
            v57 = v51 * (float)(v55.__cosval * v56.__cosval);
            v58 = v51 * v55.__sinval;
            v59 = v51 * (float)(v55.__cosval * v56.__sinval);
            v60 = *v39;
            v61 = v39[1];
            v62 = v39[2];
            v63 = sqrtf((float)((float)(v61 * v61) + (float)(v60 * v60)) + (float)(v62 * v62));
            v64 = sqrtf((float)((float)(v58 * v58) + (float)(v57 * v57)) + (float)(v59 * v59));
            if (v64 >= v63)
              v65 = v63;
            else
              v65 = v64;
            v66 = v65 <= 0.000001;
            v67 = 0.0;
            if (!v66)
            {
              v68 = v63 / v64;
              if (v63 >= v64)
                v68 = v64 / v63;
              if (v64 == 0.0)
                v68 = 0.0;
              if (v63 == 0.0)
                v69 = 0.0;
              else
                v69 = v68;
              v70 = (float)((float)((float)(v61 * (float)(1.0 / v63)) * (float)(v58 * (float)(1.0 / v64)))
                          + (float)((float)(v60 * (float)(1.0 / v63)) * (float)(v57 * (float)(1.0 / v64))))
                  + (float)((float)(v62 * (float)(1.0 / v63)) * (float)(v59 * (float)(1.0 / v64)));
              if (v70 <= 1.0)
                v71 = (float)((float)((float)(v61 * (float)(1.0 / v63)) * (float)(v58 * (float)(1.0 / v64)))
                            + (float)((float)(v60 * (float)(1.0 / v63)) * (float)(v57 * (float)(1.0 / v64))))
                    + (float)((float)(v62 * (float)(1.0 / v63)) * (float)(v59 * (float)(1.0 / v64)));
              else
                v71 = 1.0;
              if (v70 >= 0.0)
                v72 = v71;
              else
                v72 = 0.0;
              v67 = (float)(1.0 - powf(v72, 3.0)) * v69;
            }
            if (*((_BYTE *)v222 + 17))
            {
              v73 = 0;
              v34[v43] = 0;
            }
            else
            {
              v74 = (float *)&v34[v43];
              *v74 = v45 * (float)(1.0 - v67);
              v74[1] = v46 * (float)(1.0 - v67);
              v73 = vmul_n_f32((float32x2_t)v32[v43], 1.0 - v67);
            }
            v35[v43] = v73;
            if (*((_BYTE *)v222 + 18))
            {
              v75 = 0;
              v37[v43] = 0;
            }
            else
            {
              v37[v43] = vmul_n_f32((float32x2_t)v31[v43], v67);
              v75 = vmul_n_f32((float32x2_t)v32[v43], v67);
            }
            v38[v43++] = v75;
            *v39 = v57;
            v39[1] = v58;
            v39[2] = v59;
            v39 += 3;
            --v44;
          }
          while (v44);
        }
        else if ((_DWORD)v5)
        {
          v40 = v5;
          do
          {
            v41 = *v31++;
            *v34++ = v41;
            v42 = *v32++;
            *v35++ = v42;
            *v37++ = 0;
            *v38++ = 0;
            --v40;
          }
          while (v40);
        }
LABEL_92:
        v76 = *((float *)v222 + 2);
        v77 = v5;
        if (v76 == 0.0)
          goto LABEL_141;
        v78 = *((_DWORD *)v222 + 7);
        v79 = (float *)((char *)v222 + 16836);
        switch(v78)
        {
          case 1:
            v86 = (float)((float)(1.0 - cosf(v76 * 0.017453)) * 1.5708) * 0.5;
            v87 = *((_DWORD *)v222 + 2648);
            if (v87 < 1)
            {
              v88 = 0;
            }
            else
            {
              v88 = (float *)*((_QWORD *)v222 + 1326);
              if (v87 != 1)
              {
                v89 = (float *)*((_QWORD *)v222 + 1327);
                goto LABEL_132;
              }
            }
            v89 = 0;
LABEL_132:
            v130 = __sincosf_stret(v86);
            if ((_DWORD)v219)
            {
              v131 = v219;
              do
              {
                v132 = v88[1];
                v133 = (float)(v130.__sinval * *v88) + (float)(v132 * v130.__cosval);
                *v88 = (float)(*v88 * v130.__cosval) - (float)(v132 * v130.__sinval);
                v88[1] = v133;
                v88 += 2;
                v134 = v89[1];
                v135 = (float)(v130.__sinval * *v89) + (float)(v134 * v130.__cosval);
                *v89 = (float)(*v89 * v130.__cosval) - (float)(v134 * v130.__sinval);
                v89[1] = v135;
                v89 += 2;
                --v131;
              }
              while (v131);
            }
            goto LABEL_141;
          case 2:
            v90 = (float)((float)(1.0 - cosf(v76 * 0.017453)) * 1.5708) * 0.5;
            v91 = *((_DWORD *)v222 + 2648);
            if (v91 < 1)
            {
              v92 = 0;
            }
            else
            {
              v92 = (float *)*((_QWORD *)v222 + 1326);
              if (v91 != 1)
              {
                v93 = (float *)*((_QWORD *)v222 + 1327);
                goto LABEL_138;
              }
            }
            v93 = 0;
LABEL_138:
            v136 = __sincosf_stret(v90);
            if ((_DWORD)v219)
            {
              v137 = v219;
              do
              {
                v138 = v92[1];
                v139 = (float)(v136.__sinval * *v92) + (float)(v138 * v136.__cosval);
                *v92 = (float)(*v92 * v136.__cosval) - (float)(v138 * v136.__sinval);
                v92[1] = v139;
                v92 += 2;
                v140 = v93[1];
                v141 = (float)(*v93 * (float)-v136.__sinval) + (float)(v140 * v136.__cosval);
                *v93 = (float)(v136.__sinval * v140) + (float)(*v93 * v136.__cosval);
                v93[1] = v141;
                v93 += 2;
                --v137;
              }
              while (v137);
            }
            goto LABEL_141;
          case 3:
          case 4:
            v80 = *((_DWORD *)v222 + 2648);
            if (v80 < 1)
            {
              v81 = 0;
            }
            else
            {
              v81 = (float *)*((_QWORD *)v222 + 1326);
              if (v80 != 1)
              {
                v82 = (float *)*((_QWORD *)v222 + 1327);
LABEL_108:
                if (v78 != 3)
                  v76 = -v76;
                v94 = v76 * 0.017453;
                if (*v79 != v94)
                {
                  *v79 = v94;
                  *((__float2 *)v222 + 2105) = __sincosf_stret(v94);
                }
                if ((_DWORD)v5)
                {
                  do
                  {
                    TorqueUtils::EnergySphere::energySphereFromCoeffs(&v223, *v81, v81[1], *v82, v82[1]);
                    v96 = *((float *)v222 + 4210);
                    v95 = *((float *)v222 + 4211);
                    v97 = (float)(v95 * v224) - (float)(v96 * v225);
                    v98 = (float)(v95 * v225) + (float)(v96 * v224);
                    v99 = (float)((float)(v97 * v97) + (float)(v223 * v223)) + (float)(v98 * v98);
                    if (v99 == 0.0)
                    {
                      v102 = 0.0;
                      v101 = 1.0;
                      v103 = 0.7854;
                    }
                    else
                    {
                      v100 = 1.0 / v99;
                      v101 = v223 * (float)(1.0 / v99);
                      v102 = v98 * v100;
                      v103 = (float)((float)((float)(v97 * v100) + 1.0) * 3.1416) * 0.25;
                    }
                    v105 = v226;
                    v104 = v227;
                    v106 = atan2f(v102, v101);
                    v107 = __sincosf_stret(v103);
                    v108 = v105 * v107.__sinval;
                    v109 = v105 * v107.__cosval;
                    v110 = __sincosf_stret(v104 - (float)(v106 * -0.5));
                    v111 = __sincosf_stret(v104 + (float)(v106 * -0.5));
                    *v81 = v108 * v110.__cosval;
                    v81[1] = v108 * v110.__sinval;
                    v81 += 2;
                    *v82 = v109 * v111.__cosval;
                    v82[1] = v109 * v111.__sinval;
                    v82 += 2;
                    --v5;
                  }
                  while (v5);
                }
                goto LABEL_141;
              }
            }
            v82 = 0;
            goto LABEL_108;
          case 5:
          case 6:
            v83 = *((_DWORD *)v222 + 2648);
            if (v83 < 1)
            {
              v84 = 0;
            }
            else
            {
              v84 = (float *)*((_QWORD *)v222 + 1326);
              if (v83 != 1)
              {
                v85 = (float *)*((_QWORD *)v222 + 1327);
LABEL_120:
                if (v78 != 5)
                  v76 = -v76;
                v112 = v76 * 0.017453;
                if (*v79 != v112)
                {
                  *v79 = v112;
                  *((__float2 *)v222 + 2105) = __sincosf_stret(v112);
                }
                if ((_DWORD)v5)
                {
                  do
                  {
                    TorqueUtils::EnergySphere::energySphereFromCoeffs(&v223, *v84, v84[1], *v85, v85[1]);
                    v114 = *((float *)v222 + 4210);
                    v113 = *((float *)v222 + 4211);
                    v115 = (float)(v113 * v223) - (float)(v114 * v224);
                    v116 = (float)(v113 * v224) + (float)(v114 * v223);
                    v117 = (float)((float)(v116 * v116) + (float)(v115 * v115)) + (float)(v225 * v225);
                    if (v117 == 0.0)
                    {
                      v120 = 0.0;
                      v119 = 1.0;
                      v121 = 0.7854;
                    }
                    else
                    {
                      v118 = 1.0 / v117;
                      v119 = v115 * (float)(1.0 / v117);
                      v120 = v225 * v118;
                      v121 = (float)((float)((float)(v116 * v118) + 1.0) * 3.1416) * 0.25;
                    }
                    v123 = v226;
                    v122 = v227;
                    v124 = atan2f(v120, v119);
                    v125 = __sincosf_stret(v121);
                    v126 = v123 * v125.__sinval;
                    v127 = v123 * v125.__cosval;
                    v128 = __sincosf_stret(v122 - (float)(v124 * -0.5));
                    v129 = __sincosf_stret(v122 + (float)(v124 * -0.5));
                    *v84 = v126 * v128.__cosval;
                    v84[1] = v126 * v128.__sinval;
                    v84 += 2;
                    *v85 = v127 * v129.__cosval;
                    v85[1] = v127 * v129.__sinval;
                    v85 += 2;
                    --v5;
                  }
                  while (v5);
                }
LABEL_141:
                v142 = *((_DWORD *)v222 + 2908);
                if (v142 < 1)
                {
                  v143 = 0;
                }
                else
                {
                  v143 = (float *)*((_QWORD *)v222 + 1456);
                  if (v142 != 1)
                  {
                    v144 = (float *)*((_QWORD *)v222 + 1457);
                    goto LABEL_146;
                  }
                }
                v144 = 0;
LABEL_146:
                v145 = *((_DWORD *)v222 + 3428);
                if (v145 < 1)
                {
                  v147 = 0;
                  v148 = 0;
                  v146 = 0;
                }
                else
                {
                  v146 = (float *)*((_QWORD *)v222 + 1716);
                  if (v145 != 1)
                  {
                    v148 = (float *)*((_QWORD *)v222 + 1717);
                    if (v145 < 3)
                    {
                      v147 = 0;
                      v150 = 0;
                    }
                    else
                    {
                      v150 = (float *)*((_QWORD *)v222 + 1718);
                      v147 = 1;
                    }
                    v149 = 1;
                    if (!(_DWORD)v219)
                      goto LABEL_165;
                    goto LABEL_156;
                  }
                  v147 = 0;
                  v148 = 0;
                }
                v149 = 0;
                v150 = 0;
                if (!(_DWORD)v219)
                  goto LABEL_165;
                do
                {
LABEL_156:
                  v151 = *v143;
                  v152 = v143[1];
                  v153 = *v144;
                  v154 = v144[1];
                  v155 = *v144 == *v143 && v154 == v152;
                  v156 = *v143;
                  v157 = v143[1];
                  if (!v155)
                  {
                    v158 = v153 - v151;
                    v159 = v154 - v152;
                    v160 = hypotf(v153 - v151, v154 - v152);
                    v156 = v151;
                    v157 = v152;
                    if (v160 != 0.0)
                    {
                      v161 = v158 / v160;
                      v162 = v152 * (float)(v159 / v160);
                      v156 = v151;
                      v157 = v152;
                      if ((float)(v162 + (float)(v151 * (float)(v158 / v160))) < 0.0)
                      {
                        v163 = -(float)(v162 + (float)(v151 * v161));
                        v156 = v153;
                        v157 = v154;
                        if (v160 > v163)
                        {
                          v156 = v151 + (float)(v161 * v163);
                          v157 = v152 + (float)((float)(v159 / v160) * v163);
                        }
                      }
                    }
                  }
                  *v146 = v151 - v156;
                  v146[1] = v152 - v157;
                  v146 += 2;
                  *v148 = v156 * 1.4142;
                  v148[1] = v157 * 1.4142;
                  v148 += 2;
                  v143 += 2;
                  v144 += 2;
                  *v150 = v153 - v156;
                  v150[1] = v154 - v157;
                  v150 += 2;
                  --v77;
                }
                while (v77);
LABEL_165:
                if (v145 < 1)
                {
                  v164 = 0;
                  if (v149)
                  {
LABEL_167:
                    v165 = (float32x2_t *)*((_QWORD *)v222 + 1717);
                    if (!v147)
                    {
LABEL_168:
                      v166 = 0;
                      goto LABEL_172;
                    }
LABEL_171:
                    v166 = (float32x2_t *)*((_QWORD *)v222 + 1718);
LABEL_172:
                    v167 = *((_DWORD *)v222 + 3688);
                    if (v167 < 1)
                    {
                      v169 = 0;
                      v170 = 0;
                      v168 = 0;
                    }
                    else
                    {
                      v168 = (float32x2_t *)*((_QWORD *)v222 + 1846);
                      if (v167 != 1)
                      {
                        v171 = (float32x2_t *)*((_QWORD *)v222 + 1847);
                        if (v167 < 3)
                        {
                          v169 = 0;
                          v170 = 0;
                        }
                        else
                        {
                          v170 = (float32x2_t *)*((_QWORD *)v222 + 1848);
                          if (v167 != 3)
                          {
                            v172 = (float32x2_t *)*((_QWORD *)v222 + 1849);
                            if (v167 < 5)
                            {
                              v169 = 0;
                            }
                            else
                            {
                              v169 = (float32x2_t *)*((_QWORD *)v222 + 1850);
                              if (v167 != 5)
                              {
                                v173 = (float32x2_t *)*((_QWORD *)v222 + 1851);
LABEL_179:
                                if ((_DWORD)v219)
                                {
                                  v174 = *((float *)v222 + 2);
                                  v175 = __sincosf_stret((float)((float)((float)(v174 + 90.0) * 0.017453) * 0.5) + 0.7854);
                                  v221 = fabsf(v175.__sinval);
                                  v220 = fabsf(v175.__cosval);
                                  v176 = __sincosf_stret((float)((float)(v174 * 0.017453) * 0.5) + 0.7854);
                                  v177 = fabsf(v176.__sinval);
                                  v178 = *((float *)v222 + 8);
                                  v179 = sqrtf(1.0 - (float)(v178 * v178));
                                  if (v178 >= v177)
                                    v180 = v177;
                                  else
                                    v180 = *((float *)v222 + 8);
                                  if (v177 >= v179)
                                    v181 = v180;
                                  else
                                    v181 = v179;
                                  v217 = v181;
                                  v182 = fabsf(v176.__cosval);
                                  if (v178 >= v182)
                                    v183 = v182;
                                  else
                                    v183 = *((float *)v222 + 8);
                                  if (v182 >= v179)
                                    v184 = v183;
                                  else
                                    v184 = v179;
                                  v216 = v184;
                                  v185 = __sincosf_stret((float)((float)((float)(v174 + -90.0) * 0.017453) * 0.5) + 0.7854);
                                  v186 = fabsf(v185.__sinval);
                                  v187 = fabsf(v185.__cosval);
                                  v188 = v219;
                                  do
                                  {
                                    *v168++ = vmul_n_f32(*v164, v187);
                                    v189 = *v164++;
                                    *v171++ = vmul_n_f32(v189, v186);
                                    *v170++ = vmul_n_f32(*v165, v216);
                                    v190 = *v165++;
                                    *v172++ = vmul_n_f32(v190, v217);
                                    *v169++ = vmul_n_f32(*v166, v220);
                                    v191 = *v166++;
                                    *v173++ = vmul_n_f32(v191, v221);
                                    --v188;
                                  }
                                  while (v188);
                                }
                                TorqueEngine::updateHighShelfResponses(v222);
                                v192 = *((_DWORD *)v222 + 3688);
                                if (v192 < 3)
                                {
                                  v194 = 0;
                                  v193 = 0;
                                }
                                else
                                {
                                  v193 = (float32x2_t *)*((_QWORD *)v222 + 1848);
                                  if (v192 != 3)
                                  {
                                    v195 = (float32x2_t *)*((_QWORD *)v222 + 1849);
                                    v194 = 1;
LABEL_203:
                                    v196 = *((_DWORD *)v222 + 3948);
                                    if (v196 <= 3)
                                    {
                                      v197 = 0;
                                    }
                                    else
                                    {
                                      v197 = (float *)*((_QWORD *)v222 + 1979);
                                      if (v196 != 4)
                                      {
                                        v198 = (float *)*((_QWORD *)v222 + 1980);
                                        if (!(_DWORD)v219)
                                          goto LABEL_211;
                                        goto LABEL_209;
                                      }
                                    }
                                    v198 = 0;
                                    if (!(_DWORD)v219)
                                      goto LABEL_211;
LABEL_209:
                                    v199 = v219;
                                    do
                                    {
                                      v200 = *v197++;
                                      *v193 = vmul_n_f32(*v193, v200);
                                      ++v193;
                                      v201 = *v198++;
                                      *v195 = vmul_n_f32(*v195, v201);
                                      ++v195;
                                      --v199;
                                    }
                                    while (v199);
LABEL_211:
                                    v202 = *((_DWORD *)v222 + 2128);
                                    if (v202 < 1)
                                    {
                                      v203 = 0;
                                    }
                                    else
                                    {
                                      v203 = *((_QWORD *)v222 + 1066);
                                      if (v202 != 1)
                                      {
                                        v204 = *((_QWORD *)v222 + 1067);
                                        goto LABEL_216;
                                      }
                                    }
                                    v204 = 0;
LABEL_216:
                                    v205 = *((_DWORD *)v222 + 2648);
                                    if (v205 < 1)
                                    {
                                      v206 = 0;
                                    }
                                    else
                                    {
                                      v206 = *((_QWORD *)v222 + 1326);
                                      if (v205 != 1)
                                      {
                                        v207 = *((_QWORD *)v222 + 1327);
                                        goto LABEL_221;
                                      }
                                    }
                                    v207 = 0;
LABEL_221:
                                    if (v192 < 1)
                                    {
                                      v209 = 0;
                                      v208 = 0;
                                    }
                                    else
                                    {
                                      v208 = *((_QWORD *)v222 + 1846);
                                      if (v192 == 1)
                                      {
                                        v209 = 0;
                                      }
                                      else
                                      {
                                        v209 = *((_QWORD *)v222 + 1847);
                                        if (v192 >= 3)
                                        {
                                          v210 = *((_QWORD *)v222 + 1848);
                                          if (v194)
                                          {
LABEL_229:
                                            v211 = *((_QWORD *)v222 + 1849);
LABEL_230:
                                            if (v192 < 5)
                                            {
                                              v212 = 0;
                                            }
                                            else
                                            {
                                              v212 = *((_QWORD *)v222 + 1850);
                                              if (v192 != 5)
                                              {
                                                v213 = *((_QWORD *)v222 + 1851);
                                                goto LABEL_235;
                                              }
                                            }
                                            v213 = 0;
LABEL_235:
                                            if ((int)*v218 < 1)
                                            {
                                              result = 0;
                                            }
                                            else
                                            {
                                              result = (TorqueEngine *)*((_QWORD *)v218 + 2);
                                              if (*v218 != 1)
                                              {
                                                v214 = *((_QWORD *)v218 + 3);
                                                if (!(_DWORD)v219)
                                                  return result;
LABEL_241:
                                                for (i = 0; i != v219; ++i)
                                                {
                                                  *((float32x2_t *)result + i) = vadd_f32(vadd_f32(vadd_f32(vadd_f32(*(float32x2_t *)(v203 + 8 * i), *(float32x2_t *)(v206 + 8 * i)), *(float32x2_t *)(v208 + 8 * i)), *(float32x2_t *)(v210 + 8 * i)), *(float32x2_t *)(v212 + 8 * i));
                                                  *(float32x2_t *)(v214 + 8 * i) = vadd_f32(vadd_f32(vadd_f32(vadd_f32(*(float32x2_t *)(v204 + 8 * i), *(float32x2_t *)(v207 + 8 * i)), *(float32x2_t *)(v209 + 8 * i)), *(float32x2_t *)(v211 + 8 * i)), *(float32x2_t *)(v213 + 8 * i));
                                                }
                                                return result;
                                              }
                                            }
                                            v214 = 0;
                                            if (!(_DWORD)v219)
                                              return result;
                                            goto LABEL_241;
                                          }
LABEL_227:
                                          v211 = 0;
                                          goto LABEL_230;
                                        }
                                      }
                                    }
                                    v210 = 0;
                                    if (v194)
                                      goto LABEL_229;
                                    goto LABEL_227;
                                  }
                                  v194 = 0;
                                }
                                v195 = 0;
                                goto LABEL_203;
                              }
                            }
LABEL_178:
                            v173 = 0;
                            goto LABEL_179;
                          }
                          v169 = 0;
                        }
LABEL_177:
                        v172 = 0;
                        goto LABEL_178;
                      }
                      v169 = 0;
                      v170 = 0;
                    }
                    v171 = 0;
                    goto LABEL_177;
                  }
                }
                else
                {
                  v164 = (float32x2_t *)*((_QWORD *)v222 + 1716);
                  if (v149)
                    goto LABEL_167;
                }
                v165 = 0;
                if (!v147)
                  goto LABEL_168;
                goto LABEL_171;
              }
            }
            v85 = 0;
            goto LABEL_120;
          default:
            goto LABEL_141;
        }
      }
      v24 = 0;
    }
    v25 = 0;
    if (!(_DWORD)v5)
      goto LABEL_42;
    goto LABEL_40;
  }
  v6 = *(_DWORD *)a2;
  if (*(_DWORD *)a2)
  {
    v7 = 0;
    if (v5 <= 1)
      v8 = 1;
    else
      v8 = *(_DWORD *)(a2 + 4);
    do
    {
      if (v7 == 128)
        __assert_rtn("getChannel", "Overlapper.hpp", 103, "pCh < kMaxNumChannels");
      if (v6 <= (int)v7)
        v9 = 0;
      else
        v9 = *(uint64_t **)(a2 + 16 + 8 * (int)v7);
      if (*a3 <= (int)v7)
        v10 = 0;
      else
        v10 = *(_QWORD **)&a3[2 * (int)v7 + 4];
      v11 = v8;
      if ((_DWORD)v5)
      {
        do
        {
          v12 = *v9++;
          *v10++ = v12;
          --v11;
        }
        while (v11);
        v6 = *(_DWORD *)a2;
      }
      ++v7;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t STFT<float>::~STFT(uint64_t a1)
{
  vDSP_DFT_SetupStruct *v2;
  vDSP_DFT_SetupStruct *v3;
  _QWORD *v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_1E69E99A0;
  v2 = *(vDSP_DFT_SetupStruct **)(a1 + 8456);
  if (v2)
    vDSP_DFT_DestroySetup(v2);
  v3 = *(vDSP_DFT_SetupStruct **)(a1 + 8464);
  if (v3)
    vDSP_DFT_DestroySetup(v3);
  v4 = *(_QWORD **)(a1 + 8448);
  if (v4 == (_QWORD *)(a1 + 8424))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 8424);
    goto LABEL_9;
  }
  if (v4)
  {
    v5 = 5;
LABEL_9:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  free(*(void **)(a1 + 7392));
  free(*(void **)(a1 + 6352));
  free(*(void **)(a1 + 5312));
  free(*(void **)(a1 + 4272));
  free(*(void **)(a1 + 4248));
  free(*(void **)(a1 + 4232));
  return Overlapper<float>::~Overlapper(a1);
}

uint64_t Overlapper<float>::~Overlapper(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  *(_QWORD *)a1 = &off_1E69E99D8;
  free(*(void **)(a1 + 3192));
  free(*(void **)(a1 + 2152));
  free(*(void **)(a1 + 1112));
  free(*(void **)(a1 + 72));
  v2 = *(_QWORD **)(a1 + 48);
  if (v2 == (_QWORD *)(a1 + 24))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 24);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

void Overlapper<float>::~Overlapper(uint64_t a1)
{
  Overlapper<float>::~Overlapper(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void Overlapper<float>::clear(uint64_t a1)
{
  signed int *v2;
  signed int v3;
  signed int v4;
  signed int *v5;

  v2 = (signed int *)(a1 + 64);
  if (*(int *)(a1 + 64) >= 1)
  {
    v3 = 0;
    do
      OverlapperAudioBuffer<float>::clearChannel(v2, v3++);
    while (v3 < *v2);
  }
  if (*(int *)(a1 + 3184) >= 1)
  {
    v4 = 0;
    v5 = (signed int *)(a1 + 3184);
    do
      OverlapperAudioBuffer<float>::clearChannel(v5, v4++);
    while (v4 < *v5);
  }
}

_QWORD *Overlapper<float>::setProcessingCallback(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(applesauce::CF::DictionaryRef)>::operator=[abi:ne180100]((_QWORD *)(a1 + 24), a2);
}

int *Overlapper<float>::processBlock(uint64_t a1, int *a2, int *a3)
{
  int v4;
  int v5;
  int *v6;
  int *v7;
  int *v8;
  int *v9;
  int v10;
  int v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  size_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  float *v29;
  float *v30;
  int v31;
  float v32;
  int v33;
  int *v34;
  int *v35;
  int v36;
  int *result;
  int *v39;
  int *v40;
  int *v41;
  int v42;
  int v43;
  uint64_t v44;
  int *v45;

  if (*a2 != *(_DWORD *)(a1 + 8))
    __assert_rtn("processBlock", "Overlapper.hpp", 315, "pIn.getNumChannels() == mNumChIn");
  if (*a3 != *(_DWORD *)(a1 + 12))
    __assert_rtn("processBlock", "Overlapper.hpp", 316, "pOut.getNumChannels() == mNumChOut");
  v4 = a2[1];
  if (v4 != a3[1])
    __assert_rtn("processBlock", "Overlapper.hpp", 317, "pIn.getNumSamples() == pOut.getNumSamples()");
  if (!v4)
  {
    OverlapperAudioBuffer<float>::mcCopyFrom<float>(a3, 0, (int *)(a1 + 3184), 0, 0);
    v33 = *(_DWORD *)(a1 + 20);
    v34 = (int *)(a1 + 3184);
    v35 = (int *)(a1 + 3184);
    v36 = 0;
    goto LABEL_39;
  }
  v5 = 0;
  v6 = (int *)(a1 + 64);
  v7 = (int *)(a1 + 1104);
  v8 = (int *)(a1 + 2144);
  v9 = (int *)(a1 + 3184);
  v10 = *(_DWORD *)(a1 + 56);
  v44 = a1 + 80;
  v45 = a2;
  v42 = a2[1];
  v40 = (int *)(a1 + 1104);
  v41 = (int *)(a1 + 3184);
  v39 = (int *)(a1 + 2144);
  do
  {
    v11 = *(_DWORD *)(a1 + 68) - v10;
    if (v11 >= v4 - v5)
      v11 = v4 - v5;
    LODWORD(v12) = *a2;
    if (*a2 != *(_DWORD *)(a1 + 64))
      __assert_rtn("mcCopyFrom", "Overlapper.hpp", 190, "pSrc.getNumChannels() == mNumChannels");
    if ((int)v12 <= 0)
    {
      v5 += v11;
    }
    else
    {
      v13 = v6;
      v14 = 0;
      v15 = v5;
      v16 = v11 + v10;
      v17 = v11 + v5;
      v18 = v10;
      v43 = v11;
      v19 = 4 * v11;
      do
      {
        if (v16 > *(_DWORD *)(a1 + 68))
          __assert_rtn("copyFrom", "Overlapper.hpp", 167, "pDstSample + pNumSamples <= mNumSamples");
        if (v17 > a2[1])
          __assert_rtn("copyFrom", "Overlapper.hpp", 168, "pSrcSample + pNumSamples <= pSrc.getNumSamples()");
        if (v14 >= (int)v12)
          __assert_rtn("copyFrom", "Overlapper.hpp", 169, "pDstCh < mNumChannels");
        if (v14 >= *a2)
          __assert_rtn("copyFrom", "Overlapper.hpp", 170, "pSrcCh < pSrc.getNumChannels()");
        if (v14 == 128)
          goto LABEL_40;
        memmove((void *)(*(_QWORD *)(v44 + 8 * v14) + 4 * v18), (const void *)(*(_QWORD *)&a2[2 * v14 + 4] + 4 * v15), v19);
        a2 = v45;
        ++v14;
        v12 = *v13;
      }
      while (v14 < v12);
      v10 = *(_DWORD *)(a1 + 56);
      v5 = v17;
      v4 = v42;
      v6 = v13;
      v7 = v40;
      v9 = v41;
      v8 = v39;
      v11 = v43;
    }
    v10 += v11;
    *(_DWORD *)(a1 + 56) = v10;
    v20 = *(_DWORD *)(a1 + 16);
    if (v10 < 2 * v20)
      continue;
    v21 = 2 * v20;
    do
    {
      OverlapperAudioBuffer<float>::mcCopyFrom<float>(v7, 0, v6, 0, v21);
      v22 = *(_QWORD *)(a1 + 48);
      if (!v22)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, int *, int *))(*(_QWORD *)v22 + 48))(v22, v7, v8);
      OverlapperAudioBuffer<float>::mcCopyFrom<float>(v6, 0, v6, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 68) - *(_DWORD *)(a1 + 16));
      v23 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 56) -= v23;
      v24 = *(unsigned int *)(a1 + 2144);
      if ((_DWORD)v24 != *(_DWORD *)(a1 + 3184))
        __assert_rtn("mcAccumulateFrom", "Overlapper.hpp", 217, "pSrc.getNumChannels() == mNumChannels");
      v25 = *(int *)(a1 + 60);
      if ((int)v24 > 0)
      {
        v26 = 0;
        v27 = v23 + v25;
        v28 = *(_DWORD *)(a1 + 3188);
        while (1)
        {
          if (v27 > v28)
            __assert_rtn("accumulateFrom", "Overlapper.hpp", 199, "pDstSample + pNumSamples <= mNumSamples");
          if (*(_DWORD *)(a1 + 2148) < v23)
            __assert_rtn("accumulateFrom", "Overlapper.hpp", 200, "pSrcSample + pNumSamples <= pSrc.getNumSamples()");
          if (v26 == 128)
            break;
          if (v23 >= 1)
          {
            v29 = (float *)(*(_QWORD *)(a1 + 3200 + 8 * v26) + 4 * v25);
            v30 = *(float **)(a1 + 2160 + 8 * v26);
            v31 = v23;
            do
            {
              v32 = *v30++;
              *v29 = v32 + *v29;
              ++v29;
              --v31;
            }
            while (v31);
          }
          if (++v26 == v24)
            goto LABEL_34;
        }
LABEL_40:
        __assert_rtn("getChannel", "Overlapper.hpp", 103, "pCh < kMaxNumChannels");
      }
      v27 = v25 + v23;
LABEL_34:
      *(_DWORD *)(a1 + 60) = v27;
      OverlapperAudioBuffer<float>::mcCopyFrom<float>(v9, v27, v8, v23, v23);
      v10 = *(_DWORD *)(a1 + 56);
      v21 = 2 * *(_DWORD *)(a1 + 16);
    }
    while (v10 >= v21);
    a2 = v45;
  }
  while (v5 != v4);
  OverlapperAudioBuffer<float>::mcCopyFrom<float>(a3, 0, v9, 0, v4);
  v33 = *(_DWORD *)(a1 + 20);
  v34 = v9;
  v35 = v9;
  v36 = v4;
LABEL_39:
  result = OverlapperAudioBuffer<float>::mcCopyFrom<float>(v34, 0, v35, v36, v33);
  *(_DWORD *)(a1 + 60) -= v4;
  return result;
}

int *OverlapperAudioBuffer<float>::mcCopyFrom<float>(int *result, int a2, int *a3, int a4, int a5)
{
  uint64_t v5;
  int *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;

  LODWORD(v5) = *a3;
  if (*a3 != *result)
    __assert_rtn("mcCopyFrom", "Overlapper.hpp", 190, "pSrc.getNumChannels() == mNumChannels");
  if ((int)v5 >= 1)
  {
    v7 = result;
    v8 = a4;
    v9 = a5 + a2;
    v10 = a5 + a4;
    v11 = a2;
    v12 = 4 * a5;
    v13 = 2;
    do
    {
      if (v9 > v7[1])
        __assert_rtn("copyFrom", "Overlapper.hpp", 167, "pDstSample + pNumSamples <= mNumSamples");
      if (v10 > a3[1])
        __assert_rtn("copyFrom", "Overlapper.hpp", 168, "pSrcSample + pNumSamples <= pSrc.getNumSamples()");
      if (v13 - 2 >= (int)v5)
        __assert_rtn("copyFrom", "Overlapper.hpp", 169, "pDstCh < mNumChannels");
      if (v13 - 2 >= *a3)
        __assert_rtn("copyFrom", "Overlapper.hpp", 170, "pSrcCh < pSrc.getNumChannels()");
      if (v13 == 130)
        __assert_rtn("getChannel", "Overlapper.hpp", 103, "pCh < kMaxNumChannels");
      result = (int *)memmove((void *)(*(_QWORD *)&v7[2 * v13] + 4 * v11), (const void *)(*(_QWORD *)&a3[2 * v13] + 4 * v8), v12);
      v5 = *v7;
      v14 = v13++ - 1;
    }
    while (v14 < v5);
  }
  return result;
}

void OverlapperAudioBuffer<float>::clearChannel(signed int *a1, signed int a2)
{
  void *v2;

  if (a2 >= 0x80)
    __assert_rtn("getChannel", "Overlapper.hpp", 103, "pCh < kMaxNumChannels");
  if (*a1 <= a2)
    v2 = 0;
  else
    v2 = *(void **)&a1[2 * a2 + 4];
  bzero(v2, 4 * a1[1]);
}

void STFT<float>::~STFT(uint64_t a1)
{
  STFT<float>::~STFT(a1);
  JUMPOUT(0x1BCC95CECLL);
}

float TorqueEngine::updateCrossoverResponse(TorqueEngine *this)
{
  float result;
  int v2;
  float *v3;
  int v4;
  float *v5;
  float *v6;
  float v7;
  float v8;
  float v9;

  result = *((float *)this + 3);
  if (result != *((float *)this + 4208))
  {
    v2 = *((_DWORD *)this + 3948);
    if (v2 < 2)
    {
      v3 = 0;
      v5 = 0;
    }
    else
    {
      v3 = (float *)*((_QWORD *)this + 1977);
      if (v2 == 2)
      {
        v5 = 0;
        v4 = *((_DWORD *)this + 3949);
        if (result == 0.0)
          goto LABEL_9;
        goto LABEL_13;
      }
      v5 = (float *)*((_QWORD *)this + 1978);
    }
    v4 = *((_DWORD *)this + 3949);
    if (result == 0.0)
    {
LABEL_9:
      while (v4)
      {
        *v3++ = 0.0;
        *v5++ = 1.0;
        --v4;
      }
      goto LABEL_18;
    }
    if (v2 < 1)
    {
      v6 = 0;
      if (!v4)
      {
LABEL_18:
        result = *((float *)this + 3);
        *((float *)this + 4208) = result;
        return result;
      }
LABEL_16:
      v7 = 1.0 / result;
      do
      {
        v8 = *v6++;
        v9 = 1.0
           / (float)((float)((float)((float)(v7 * v8) * (float)(v7 * v8)) * (float)((float)(v7 * v8) * (float)(v7 * v8)))
                   + 1.0);
        *v3++ = v9;
        *v5++ = 1.0 - v9;
        --v4;
      }
      while (v4);
      goto LABEL_18;
    }
LABEL_13:
    v6 = (float *)*((_QWORD *)this + 1976);
    if (!v4)
      goto LABEL_18;
    goto LABEL_16;
  }
  return result;
}

void TorqueUtils::EnergySphere::energySphereFromCoeffs(float *a1, float a2, float a3, float a4, float a5)
{
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  __float2 v19;
  __float2 v20;
  float v21;
  float v22;
  __float2 v23;
  __float2 v24;

  v10 = (float)(a3 * a3) + (float)(a2 * a2);
  v11 = (float)(a5 * a5) + (float)(a4 * a4);
  if (a2 == 0.0 && a3 == 0.0 || a4 == 0.0 && a5 == 0.0)
  {
    if (a2 == 0.0 && a3 == 0.0)
    {
      v12 = 0.0;
      if (a4 == 0.0 && a5 == 0.0)
      {
        v13 = 0.0;
        v14 = 0.0;
      }
      else
      {
        v14 = atan2f(a5, a4);
        v13 = -1.5708;
      }
    }
    else
    {
      v14 = atan2f(a3, a2);
      v12 = 0.0;
      v13 = 1.5708;
    }
  }
  else
  {
    v15 = (float)(atan2f(sqrtf(v10), sqrtf(v11)) * 1.2732) + -1.0;
    v16 = atan2f(a3, a2);
    v17 = atan2f(a5, a4);
    v18 = remainderf(v17 - v16, 6.2832);
    if (v18 <= -3.1416)
      v12 = v18 + 6.2832;
    else
      v12 = v18;
    v14 = v16 + (float)(v12 * 0.5);
    v13 = v15 * 1.5708;
  }
  v19 = __sincosf_stret(v13);
  v20 = __sincosf_stret(v12);
  v21 = atan2f(v19.__sinval, v19.__cosval * v20.__cosval);
  v22 = asinf(-(float)(v19.__cosval * v20.__sinval));
  v23 = __sincosf_stret(v21);
  v24 = __sincosf_stret(v22);
  *a1 = v23.__cosval * v24.__cosval;
  a1[1] = v23.__sinval * v24.__cosval;
  a1[2] = v24.__sinval;
  a1[3] = sqrtf(v10 + v11);
  a1[4] = v14;
}

void TorqueEngine::updateHighShelfResponses(TorqueEngine *this)
{
  char *v2;
  float v3;
  int v4;
  int v5;
  _DWORD *v6;
  _DWORD *v7;
  float *v8;
  float *v9;
  float *v10;
  float v11;
  float i;
  float v13;
  float v14;

  v2 = (char *)this + 16848;
  v3 = *((float *)this + 5);
  if (v3 != *((float *)this + 4212)
    || *((float *)this + 6) != *((float *)this + 4213)
    || *((float *)this + 2) != *((float *)this + 4214))
  {
    v4 = *((_DWORD *)this + 3949);
    v5 = *((_DWORD *)this + 3948);
    if (v3 == 0.0)
    {
      if (v5 < 4)
      {
        v6 = 0;
      }
      else
      {
        v6 = (_DWORD *)*((_QWORD *)this + 1979);
        if (v5 != 4)
        {
          v7 = (_DWORD *)*((_QWORD *)this + 1980);
          if (!v4)
            goto LABEL_22;
          goto LABEL_15;
        }
      }
      v7 = 0;
      if (!v4)
      {
LABEL_22:
        *((_QWORD *)this + 2106) = *(_QWORD *)((char *)this + 20);
        *((_DWORD *)v2 + 2) = *((_DWORD *)this + 2);
        return;
      }
      do
      {
LABEL_15:
        *v6++ = 1065353216;
        *v7++ = 1065353216;
        --v4;
      }
      while (v4);
      goto LABEL_22;
    }
    if (v5 < 1)
    {
      v9 = 0;
      v8 = 0;
    }
    else
    {
      v8 = (float *)*((_QWORD *)this + 1976);
      if (v5 < 4)
      {
        v9 = 0;
      }
      else
      {
        v9 = (float *)*((_QWORD *)this + 1979);
        if (v5 != 4)
        {
          v10 = (float *)*((_QWORD *)this + 1980);
          goto LABEL_20;
        }
      }
    }
    v10 = 0;
LABEL_20:
    v11 = sinf(*((float *)this + 2) * 0.017453);
    for (i = __exp10f((float)(*((float *)this + 6) * v11) / 20.0); v4; --v4)
    {
      v13 = *v8++;
      v14 = 1.0
          / (float)((float)((float)((float)((float)(1.0 / v3) * v13) * (float)((float)(1.0 / v3) * v13))
                          * (float)((float)((float)(1.0 / v3) * v13) * (float)((float)(1.0 / v3) * v13)))
                  + 1.0);
      *v9++ = (float)(1.0 / i) + (float)((float)(1.0 - (float)(1.0 / i)) * v14);
      *v10++ = i + (float)((float)(1.0 - i) * v14);
    }
    goto LABEL_22;
  }
}

void std::__function::__func<std::__bind<void (TorqueEngine::*)(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&),TorqueEngine*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (TorqueEngine::*)(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&),TorqueEngine*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<void (TorqueEngine::*)(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&),TorqueEngine*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (TorqueEngine::*)(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&),TorqueEngine*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E69E9AA0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<void (TorqueEngine::*)(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&),TorqueEngine*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (TorqueEngine::*)(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&),TorqueEngine*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69E9AA0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<void (TorqueEngine::*)(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&),TorqueEngine*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (TorqueEngine::*)(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&),TorqueEngine*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(OverlapperAudioBuffer<DSPComplex> const&,OverlapperAudioBuffer<DSPComplex>&)>::operator()(_QWORD *a1)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD *);
  _QWORD *v3;

  v1 = a1[2];
  v2 = (uint64_t (*)(_QWORD *))a1[1];
  v3 = (_QWORD *)(a1[3] + (v1 >> 1));
  if ((v1 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *))(*v3 + v2);
  return v2(v3);
}

void STFT<float>::privateProcessBlock(uint64_t a1, unsigned int *a2, int *a3)
{
  unint64_t v3;
  int *v4;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  float *v16;
  float *v17;
  float *v18;
  float *v19;
  uint64_t v20;
  float v21;
  float v22;
  float v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  uint64_t v30;
  uint64_t v31;
  __n128 v32;
  uint64_t v33;
  float *v34;
  uint64_t v35;
  uint64_t v36;
  const DSPComplex *v37;
  DSPComplex *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const DSPComplex *v42;
  DSPComplex *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  float *v52;
  float *v53;
  float *v54;
  uint64_t v55;
  float v56;
  float v57;
  float v58;
  uint64_t v59;
  int *v60;
  uint64_t v61;
  unsigned int *v62;
  float *v63;
  DSPSplitComplex v64;
  DSPSplitComplex __Z;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if ((_DWORD)v3 != *(_DWORD *)(a1 + 8))
    __assert_rtn("privateProcessBlock", "STFT.hpp", 204, "pIn.getNumChannels() == this->mNumChIn");
  v4 = a3;
  if (*a3 != *(_DWORD *)(a1 + 12))
    __assert_rtn("privateProcessBlock", "STFT.hpp", 205, "pOut.getNumChannels() == this->mNumChOut");
  v6 = (int)a2[1];
  v7 = *(_DWORD *)(a1 + 16);
  if ((_DWORD)v6 != 2 * v7)
    __assert_rtn("privateProcessBlock", "STFT.hpp", 206, "pIn.getNumSamples() == 2 * this->mHalfBlockSize");
  if (a3[1] != (_DWORD)v6)
    __assert_rtn("privateProcessBlock", "STFT.hpp", 207, "pOut.getNumSamples() == 2 * this->mHalfBlockSize");
  v8 = *(_DWORD *)(a1 + 4224);
  if (v8 == 1)
  {
    v9 = 4248;
  }
  else
  {
    if (v8)
      __assert_rtn("privateProcessBlock", "STFT.hpp", 212, "false");
    v9 = 4232;
  }
  v63 = *(float **)(a1 + v9);
  if ((int)v3 <= 0)
  {
    LODWORD(v13) = *(_DWORD *)(a1 + 4228) * v6;
  }
  else
  {
    v10 = 0;
    v62 = a2 + 4;
    v11 = *(int *)(a1 + 4264);
    v60 = a3;
    v61 = a1 + 4280;
    v12 = *(_DWORD *)(a1 + 4228);
    v13 = (v12 * v6);
    if ((int)v6 <= 1)
      v14 = 1;
    else
      v14 = v6;
    v15 = 4 * (v7 * (2 * v12 - 2) - 2) + 8;
    do
    {
      if (v10 == 128)
        goto LABEL_64;
      if (v10 >= v3)
        v16 = 0;
      else
        v16 = *(float **)&v62[2 * v10];
      if ((uint64_t)v10 >= v11)
        v17 = 0;
      else
        v17 = *(float **)(v61 + 8 * v10);
      v18 = v63;
      v19 = v17;
      v20 = v14;
      if (v7 >= 1)
      {
        do
        {
          v21 = *v18++;
          v22 = v21;
          v23 = *v16++;
          *v19++ = v22 * v23;
          --v20;
        }
        while (v20);
      }
      if ((int)v6 < (int)v13)
      {
        v24 = v13;
        bzero(&v17[v6], v15);
        v13 = v24;
      }
      ++v10;
    }
    while (v10 != v3);
    v4 = v60;
  }
  v25 = v13;
  v26 = (int)v13 >> 1;
  MEMORY[0x1E0C80A78](a1);
  MEMORY[0x1E0C80A78](v27);
  __Z.realp = v29;
  __Z.imagp = (float *)((char *)&v59 - v28);
  MEMORY[0x1E0C80A78](v30);
  v32.n128_f64[0] = MEMORY[0x1E0C80A78](v31);
  v64.realp = v34;
  v64.imagp = (float *)((char *)&v59 - v33);
  if (*(int *)(a1 + 8) >= 1)
  {
    v35 = 0;
    v36 = a1 + 4280;
    while (v35 != 128)
    {
      if (v35 >= *(int *)(a1 + 4264))
        v37 = 0;
      else
        v37 = *(const DSPComplex **)v36;
      vDSP_ctoz(v37, 2, &__Z, 1, v26);
      vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(a1 + 8456), __Z.realp, __Z.imagp, v64.realp, v64.imagp);
      if (v35 >= *(int *)(a1 + 6344))
        v38 = 0;
      else
        v38 = *(DSPComplex **)(v36 + 2080);
      vDSP_ztoc(&v64, 1, v38, 2, v26);
      ++v35;
      v36 += 8;
      if (v35 >= *(int *)(a1 + 8))
        goto LABEL_38;
    }
LABEL_64:
    __assert_rtn("getChannel", "Overlapper.hpp", 103, "pCh < kMaxNumChannels");
  }
LABEL_38:
  v39 = *(_QWORD *)(a1 + 8448);
  if (!v39)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t, uint64_t, __n128))(*(_QWORD *)v39 + 48))(v39, a1 + 6344, a1 + 7384, v32);
  if (*(int *)(a1 + 12) >= 1)
  {
    v40 = 0;
    v41 = a1 + 5320;
    do
    {
      if (v40 == 128)
        goto LABEL_64;
      if (v40 >= *(int *)(a1 + 7384))
        v42 = 0;
      else
        v42 = *(const DSPComplex **)(v41 + 2080);
      vDSP_ctoz(v42, 2, &__Z, 1, v26);
      vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(a1 + 8464), __Z.realp, __Z.imagp, v64.realp, v64.imagp);
      if (v40 >= *(int *)(a1 + 5304))
        v43 = 0;
      else
        v43 = *(DSPComplex **)v41;
      vDSP_ztoc(&v64, 1, v43, 2, v26);
      ++v40;
      v41 += 8;
    }
    while (v40 < *(int *)(a1 + 12));
    v44 = *(unsigned int *)(a1 + 12);
    if ((int)v44 >= 1)
    {
      v45 = 0;
      v46 = *(int *)(a1 + 5304);
      v49 = *v4;
      v48 = v4 + 4;
      v47 = v49;
      v50 = *(_DWORD *)(a1 + 16);
      LODWORD(v51) = 2 * v50;
      if (2 * v50 <= 1)
        v51 = 1;
      else
        v51 = v51;
      while (v45 != 128)
      {
        if (v45 >= v46)
          v52 = 0;
        else
          v52 = *(float **)(a1 + 5320 + 8 * v45);
        if (v45 >= v47)
          v53 = 0;
        else
          v53 = *(float **)&v48[2 * v45];
        v54 = v63;
        v55 = v51;
        if (v50 >= 1)
        {
          do
          {
            v56 = *v54++;
            v57 = (float)(0.5 / (float)v25) * v56;
            v58 = *v52++;
            *v53++ = v57 * v58;
            --v55;
          }
          while (v55);
        }
        if (++v45 == v44)
          return;
      }
      goto LABEL_64;
    }
  }
}

void std::__function::__func<std::__bind<void (STFT<float>::*)(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&),STFT<float>*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (STFT<float>::*)(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&),STFT<float>*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<void (STFT<float>::*)(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&),STFT<float>*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (STFT<float>::*)(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&),STFT<float>*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E69E9A58;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<void (STFT<float>::*)(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&),STFT<float>*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (STFT<float>::*)(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&),STFT<float>*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69E9A58;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<void (STFT<float>::*)(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&),STFT<float>*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>,std::allocator<std::__bind<void (STFT<float>::*)(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&),STFT<float>*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&>>,void ()(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)>::operator()(_QWORD *a1)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD *);
  _QWORD *v3;

  v1 = a1[2];
  v2 = (uint64_t (*)(_QWORD *))a1[1];
  v3 = (_QWORD *)(a1[3] + (v1 >> 1));
  if ((v1 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *))(*v3 + v2);
  return v2(v3);
}

void std::__function::__func<Overlapper<float>::{lambda(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)#1},std::allocator<Overlapper<float>::{lambda(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)#1}>,void ()(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<Overlapper<float>::{lambda(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)#1},std::allocator<Overlapper<float>::{lambda(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)#1}>,void ()(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E69E9A10;
  return result;
}

void std::__function::__func<Overlapper<float>::{lambda(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)#1},std::allocator<Overlapper<float>::{lambda(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)#1}>,void ()(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E69E9A10;
}

void std::__function::__func<Overlapper<float>::{lambda(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)#1},std::allocator<Overlapper<float>::{lambda(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)#1}>,void ()(OverlapperAudioBuffer<float> const&,OverlapperAudioBuffer<float>&)>::operator()()
{
  __assert_rtn("operator()", "Overlapper.hpp", 366, "false");
}

double TorqueEngine::resizeBuffers(void **this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  void **v7;
  void *v8;
  double result;

  OverlapperAudioBuffer<TorqueUtils::Complex<float>>::resize(this + 1064, 2, a2);
  OverlapperAudioBuffer<TorqueUtils::Complex<float>>::resize(this + 1194, 2, a2);
  OverlapperAudioBuffer<TorqueUtils::Complex<float>>::resize(this + 1324, 2, a2);
  OverlapperAudioBuffer<TorqueUtils::Complex<float>>::resize(this + 1454, 2, a2);
  if (this[1584] == (void *)__PAIR64__(a2, 1) && this[1585])
  {
    v4 = 0;
    LODWORD(v5) = 1;
    do
    {
      if (v4 == 128)
        __assert_rtn("getChannel", "Overlapper.hpp", 103, "pCh < kMaxNumChannels");
      if (v4 >= (int)v5)
        v6 = 0;
      else
        v6 = this[v4 + 1586];
      bzero(v6, 12 * *((int *)this + 3169));
      ++v4;
      v5 = *((int *)this + 3168);
    }
    while (v4 < v5);
  }
  else
  {
    v7 = this + 1585;
    free(this[1585]);
    if (a2 < 1)
    {
      v8 = 0;
      *v7 = 0;
    }
    else
    {
      malloc_type_posix_memalign(this + 1585, 0x10uLL, 12 * a2, 0x10000403E1C8BA9uLL);
      bzero(*v7, 12 * a2);
      v8 = *v7;
      if (!*v7)
        __assert_rtn("resize", "Overlapper.hpp", 76, "mBuffer");
    }
    this[1586] = v8;
    *((_DWORD *)this + 3168) = 1;
    *((_DWORD *)this + 3169) = a2;
  }
  OverlapperAudioBuffer<TorqueUtils::Complex<float>>::resize(this + 1714, 3, a2);
  OverlapperAudioBuffer<TorqueUtils::Complex<float>>::resize(this + 1844, 6, a2);
  OverlapperAudioBuffer<float>::resize((uint64_t)(this + 1974), 5u, a2);
  *((_DWORD *)this + 4208) = -1082130432;
  __asm { FMOV            V0.2S, #-1.0 }
  *((double *)this + 2106) = result;
  return result;
}

void OverlapperAudioBuffer<TorqueUtils::Complex<float>>::resize(void **a1, int a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v6;
  void *v7;
  void **v8;
  char *v9;
  uint64_t v10;

  LODWORD(v4) = a2;
  if (*(_DWORD *)a1 == a2 && *((_DWORD *)a1 + 1) == a3 && a1[1])
  {
    v6 = 0;
    do
    {
      if (v6 == 128)
        __assert_rtn("getChannel", "Overlapper.hpp", 103, "pCh < kMaxNumChannels");
      if (v6 >= (int)v4)
        v7 = 0;
      else
        v7 = a1[v6 + 2];
      bzero(v7, 8 * *((int *)a1 + 1));
      ++v6;
      v4 = *(int *)a1;
    }
    while (v6 < v4);
  }
  else
  {
    v8 = a1 + 1;
    free(a1[1]);
    if ((int)(a3 * v4) < 1)
    {
      v9 = 0;
      *v8 = 0;
    }
    else
    {
      malloc_type_posix_memalign(a1 + 1, 0x10uLL, 8 * a3 * v4, 0x100004000313F17uLL);
      bzero(*v8, 8 * a3 * v4);
      v9 = (char *)*v8;
      if (!*v8)
        __assert_rtn("resize", "Overlapper.hpp", 76, "mBuffer");
    }
    v10 = 0;
    do
    {
      a1[v10++ + 2] = v9;
      v9 += 8 * a3;
    }
    while (v4 != v10);
    *(_DWORD *)a1 = v4;
    *((_DWORD *)a1 + 1) = a3;
  }
}

void OverlapperAudioBuffer<float>::resize(uint64_t a1, unsigned int a2, int a3)
{
  signed int v6;
  void **v7;
  char *v8;
  _QWORD *v9;
  uint64_t v10;

  if (a2 >= 0x81)
    __assert_rtn("resize", "Overlapper.hpp", 65, "inNumChannels <= kMaxNumChannels");
  if (*(_DWORD *)a1 != a2 || *(_DWORD *)(a1 + 4) != a3 || !*(_QWORD *)(a1 + 8))
  {
    v7 = (void **)(a1 + 8);
    free(*(void **)(a1 + 8));
    if ((int)(a3 * a2) < 1)
    {
      v8 = 0;
      *v7 = 0;
      if (!a2)
      {
LABEL_16:
        *(_DWORD *)a1 = a2;
        *(_DWORD *)(a1 + 4) = a3;
        return;
      }
    }
    else
    {
      malloc_type_posix_memalign((void **)(a1 + 8), 0x10uLL, 4 * a3 * a2, 0x100004052888210uLL);
      bzero(*v7, 4 * a3 * a2);
      v8 = (char *)*v7;
      if (!*v7)
        __assert_rtn("resize", "Overlapper.hpp", 76, "mBuffer");
      if (!a2)
        goto LABEL_16;
    }
    v9 = (_QWORD *)(a1 + 16);
    v10 = a2;
    do
    {
      *v9++ = v8;
      v8 += 4 * a3;
      --v10;
    }
    while (v10);
    goto LABEL_16;
  }
  if (a2)
  {
    v6 = 0;
    do
      OverlapperAudioBuffer<float>::clearChannel((signed int *)a1, v6++);
    while (v6 < *(_DWORD *)a1);
  }
}

void OverlapperAudioBuffer<DSPComplex>::resize(int *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  void **v7;
  char *v8;

  if (*a1 == 2 && a1[1] == a2 && *((_QWORD *)a1 + 1))
  {
    v4 = 0;
    LODWORD(v5) = 2;
    do
    {
      if (v4 == 128)
        __assert_rtn("getChannel", "Overlapper.hpp", 103, "pCh < kMaxNumChannels");
      if (v4 >= (int)v5)
        v6 = 0;
      else
        v6 = *(void **)&a1[2 * v4 + 4];
      bzero(v6, 8 * a1[1]);
      ++v4;
      v5 = *a1;
    }
    while (v4 < v5);
  }
  else
  {
    v7 = (void **)(a1 + 2);
    free(*((void **)a1 + 1));
    if (a2 < 1)
    {
      v8 = 0;
      *v7 = 0;
    }
    else
    {
      malloc_type_posix_memalign((void **)a1 + 1, 0x10uLL, 8 * (2 * a2), 0x100004000313F17uLL);
      bzero(*v7, 8 * (2 * a2));
      v8 = (char *)*v7;
      if (!*v7)
        __assert_rtn("resize", "Overlapper.hpp", 76, "mBuffer");
    }
    *((_QWORD *)a1 + 2) = v8;
    *((_QWORD *)a1 + 3) = &v8[8 * a2];
    *a1 = 2;
    a1[1] = a2;
  }
}

uint64_t AlignedBuffer<float>::resize(uint64_t result)
{
  uint64_t v1;

  if (*(_QWORD *)(result + 8) != 256)
  {
    v1 = result;
    free(*(void **)result);
    result = malloc_type_posix_memalign((void **)v1, 0x10uLL, 0x400uLL, 0x100004052888210uLL);
    if ((_DWORD)result == 22 || (_DWORD)result == 12)
    {
      *(_QWORD *)v1 = 0;
      *(_QWORD *)(v1 + 8) = 0;
    }
    else
    {
      *(_QWORD *)(v1 + 8) = 256;
    }
  }
  return result;
}

void *TorqueEngine::processInplace(TorqueEngine *this, float *a2, float *a3, unsigned int a4)
{
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  size_t v13;
  int v16[2];
  _QWORD v17[129];
  int v18[2];
  _QWORD v19[130];

  v19[129] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](this);
  v9 = (char *)&v16[-2] - ((v8 + 15) & 0x7FFFFFFF0);
  MEMORY[0x1E0C80A78](v10);
  v12 = (char *)&v16[-2] - v11;
  bzero(v19, 0x408uLL);
  v19[1] = a2;
  v19[2] = a3;
  v18[0] = 2;
  v18[1] = a4;
  bzero(v17, 0x408uLL);
  v17[1] = v9;
  v17[2] = v12;
  v16[0] = 2;
  v16[1] = a4;
  Overlapper<float>::processBlock((uint64_t)this + 40, v18, v16);
  v13 = 4 * a4;
  memcpy(a2, v9, v13);
  return memcpy(a3, v12, v13);
}

double MatrixDecompositions::setMandN(MatrixDecompositions *this, int a2, int a3)
{
  void *v6;
  int v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  double result;
  __int128 v14;
  uint64_t v15;

  std::vector<__CLPK_complex>::vector(&v14, a3 * a2);
  v6 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v6;
    operator delete(v6);
  }
  *(_OWORD *)this = v14;
  *((_QWORD *)this + 2) = v15;
  if (a3 >= a2)
    v7 = a2;
  else
    v7 = a3;
  std::vector<float>::vector(&v14, v7);
  v8 = (void *)*((_QWORD *)this + 3);
  if (v8)
  {
    *((_QWORD *)this + 4) = v8;
    operator delete(v8);
  }
  *(_OWORD *)((char *)this + 24) = v14;
  *((_QWORD *)this + 5) = v15;
  std::vector<__CLPK_complex>::vector(&v14, (a2 * a2));
  v9 = (void *)*((_QWORD *)this + 6);
  if (v9)
  {
    *((_QWORD *)this + 7) = v9;
    operator delete(v9);
  }
  *((_OWORD *)this + 3) = v14;
  *((_QWORD *)this + 8) = v15;
  std::vector<__CLPK_complex>::vector(&v14, (a3 * a3));
  v10 = (void *)*((_QWORD *)this + 9);
  if (v10)
  {
    *((_QWORD *)this + 10) = v10;
    operator delete(v10);
  }
  *(_OWORD *)((char *)this + 72) = v14;
  *((_QWORD *)this + 11) = v15;
  std::vector<__CLPK_complex>::vector(&v14, a3 + 2 * a2);
  v11 = (void *)*((_QWORD *)this + 12);
  if (v11)
  {
    *((_QWORD *)this + 13) = v11;
    operator delete(v11);
  }
  *((_OWORD *)this + 6) = v14;
  *((_QWORD *)this + 14) = v15;
  std::vector<float>::vector(&v14, 5 * v7);
  v12 = (void *)*((_QWORD *)this + 15);
  if (v12)
  {
    *((_QWORD *)this + 16) = v12;
    operator delete(v12);
  }
  result = *(double *)&v14;
  *(_OWORD *)((char *)this + 120) = v14;
  *((_QWORD *)this + 17) = v15;
  return result;
}

void MatrixDecompositions::LinearSolverPLU(MatrixDecompositions *this, __CLPK_integer *a2, CLiteMatrix *a3, float **a4)
{
  __CLPK_integer v7;
  __CLPK_integer v8;
  __CLPK_integer __info;
  __CLPK_integer __ldb;
  __CLPK_integer __lda;
  __CLPK_integer __nrhs;
  __CLPK_integer __n;

  v7 = *a2;
  __nrhs = *((_QWORD *)a3 + 1);
  __n = v7;
  CLiteMatrix::ToCLPKComplex((CLiteMatrix *)a2, this);
  CLiteMatrix::ToCLPKComplex(a3, (_QWORD *)this + 39);
  if (v7 <= 1)
    v8 = 1;
  else
    v8 = v7;
  __ldb = v8;
  __lda = v8;
  __info = 0;
  cgesv_(&__n, &__nrhs, *(__CLPK_complex **)this, &__lda, *((__CLPK_integer **)this + 42), *((__CLPK_complex **)this + 39), &__ldb, &__info);
  if (__info)
    vDSP_vclr(a4[2], 1, a4[3] - a4[2]);
  else
    CLiteMatrix::FromCLPKComplex((unint64_t *)a4, (_QWORD *)this + 39);
}

void AULoudspeakerSystemIDV2::~AULoudspeakerSystemIDV2(AULoudspeakerSystemIDV2 *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E69E9B00;
  if (*((_BYTE *)this + 2224))
  {
    v2 = (void *)*((_QWORD *)this + 275);
    if (v2)
    {
      *((_QWORD *)this + 276) = v2;
      operator delete(v2);
    }
  }
  AUDspLib::~AUDspLib(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E69E9B00;
  if (*((_BYTE *)this + 2224))
  {
    v2 = (void *)*((_QWORD *)this + 275);
    if (v2)
    {
      *((_QWORD *)this + 276) = v2;
      operator delete(v2);
    }
  }
  AUDspLib::~AUDspLib(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AULoudspeakerSystemIDV2::Initialize(DspLib::LoudspeakerSystemIDV2::Algorithm **this)
{
  uint64_t result;
  DspLib::LoudspeakerSystemIDV2::Algorithm *v3;
  unint64_t v4;
  char v5;
  char v6;
  std::runtime_error *exception;
  CFTypeRef cf[2];
  char v9;
  void *__p[2];
  char v11;

  result = AUDspLib::Initialize((AUDspLib *)this);
  if (!(_DWORD)result)
  {
    v3 = this[66];
    if (v3)
    {
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)cf, CFSTR("com.apple.coreaudio"));
      if (!cf[0])
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      applesauce::CF::convert_to<std::string,0>((const __CFString *)cf[0], (uint64_t)__p);
      if (cf[0])
        CFRelease(cf[0]);
      std::string::basic_string[abi:ne180100]<0>(cf, "LSMv2EnableLogging");
      v4 = GetPreference<long long>((const UInt8 *)__p, (const UInt8 *)cf);
      v6 = v5;
      if (v9 < 0)
        operator delete((void *)cf[0]);
      if (v6)
        DspLib::LoudspeakerSystemIDV2::Algorithm::configureLogging(v3, v4);
      if (v11 < 0)
        operator delete(__p[0]);
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

void sub_1B6543694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  void *v20;

  __cxa_free_exception(v20);
  applesauce::CF::StringRef::~StringRef((const void **)&a9);
  _Unwind_Resume(a1);
}

uint64_t AULoudspeakerSystemIDV2::GetPropertyInfo(AULoudspeakerSystemIDV2 *this, int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  unsigned int v7;

  if (a2 == 1936290675)
  {
    result = 0;
    *a6 = 1;
    v7 = 8;
LABEL_10:
    *a5 = v7;
    return result;
  }
  if (a2 == 64005)
  {
    *a6 = 1;
    v7 = *((unsigned __int8 *)this + 2224);
    if (*((_BYTE *)this + 2224))
      v7 = (*((_DWORD *)this + 552) - *((_DWORD *)this + 550)) & 0xFFFFFFFC;
    result = 0;
    goto LABEL_10;
  }
  if (a2 != 6630)
    return AUDspLib::GetPropertyInfo(this, a2, a3, a4, a5, a6);
  if (a3)
    return 4294956430;
  result = 0;
  *a5 = 1600;
  *a6 = 0;
  return result;
}

uint64_t AULoudspeakerSystemIDV2::GetProperty(AULoudspeakerSystemIDV2 *this, int a2, unsigned int a3, unsigned int a4, char *a5, int *a6)
{
  _BYTE *v8;
  _BYTE *v9;
  DspLib::LoudspeakerSystemIDV2::Algorithm *v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int32x2_t v20;
  uint64_t i;
  uint64_t v22;
  char *v23;
  char *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _OWORD v31[3];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  if (a2 == 64005)
  {
    if (*((_BYTE *)this + 2224))
    {
      v8 = (_BYTE *)*((_QWORD *)this + 275);
      v9 = (_BYTE *)*((_QWORD *)this + 276);
      if (v9 != v8)
        memmove(a5, v8, v9 - v8);
    }
    return 0;
  }
  if (a2 != 6630)
    return AUDspLib::GetProperty(this, a2, a3, a4, (CFDictionaryRef *)a5, a6);
  if (a3)
    return 4294956430;
  v10 = (DspLib::LoudspeakerSystemIDV2::Algorithm *)*((_QWORD *)this + 66);
  if (!v10 || *((_QWORD *)v10 + 38) == *((_QWORD *)v10 + 37))
  {
    LODWORD(v12) = 0;
    goto LABEL_16;
  }
  v11 = 0;
  LODWORD(v12) = 0;
  do
  {
    DspLib::LoudspeakerSystemIDV2::Algorithm::speakerModel(v10, v12, (uint64_t)v31);
    v13 = &a5[200 * v11];
    v14 = v40;
    *((_OWORD *)v13 + 10) = v39;
    *((_OWORD *)v13 + 11) = v14;
    *((_QWORD *)v13 + 24) = v41;
    v15 = v36;
    *((_OWORD *)v13 + 6) = v35;
    *((_OWORD *)v13 + 7) = v15;
    v16 = v38;
    *((_OWORD *)v13 + 8) = v37;
    *((_OWORD *)v13 + 9) = v16;
    v17 = v32;
    *((_OWORD *)v13 + 2) = v31[2];
    *((_OWORD *)v13 + 3) = v17;
    v18 = v34;
    *((_OWORD *)v13 + 4) = v33;
    *((_OWORD *)v13 + 5) = v18;
    v19 = v31[1];
    *(_OWORD *)v13 = v31[0];
    *((_OWORD *)v13 + 1) = v19;
    v12 = (v12 + 1);
    v11 = v12;
  }
  while (0x12616AB58F0FD3E3 * ((uint64_t)(*((_QWORD *)v10 + 38) - *((_QWORD *)v10 + 37)) >> 4) > v12);
  if (v12 <= 7)
  {
LABEL_16:
    v20 = vdup_n_s32(0xC2C80000);
    for (i = v12; i != 8; ++i)
    {
      v41 = 0;
      v39 = 0uLL;
      v40 = 0uLL;
      v37 = 0uLL;
      v38 = 0uLL;
      v35 = 0uLL;
      v36 = 0uLL;
      v33 = 0uLL;
      v34 = 0uLL;
      v32 = 0uLL;
      LODWORD(v31[0]) = 1;
      memset((char *)v31 + 4, 0, 24);
      memset((char *)&v31[1] + 9, 0, 23);
      *(_QWORD *)((char *)&v31[2] + 4) = 0;
      v22 = 52;
      BYTE12(v31[2]) = 0;
      do
      {
        v23 = (char *)v31 + v22;
        *(_QWORD *)v23 = 0;
        *((_QWORD *)v23 + 1) = 0;
        v23[24] = 0;
        *((_QWORD *)v23 + 2) = 0;
        *(_QWORD *)(v23 + 28) = 0;
        v23[36] = 0;
        v22 += 44;
        v23[40] = 0;
      }
      while (v23 + 44 != (char *)&v40 + 8);
      *((int32x2_t *)&v40 + 1) = v20;
      LODWORD(v41) = 1065353216;
      BYTE4(v41) = 0;
      v24 = &a5[200 * i];
      v25 = v40;
      *((_OWORD *)v24 + 10) = v39;
      *((_OWORD *)v24 + 11) = v25;
      *((_QWORD *)v24 + 24) = v41;
      v26 = v36;
      *((_OWORD *)v24 + 6) = v35;
      *((_OWORD *)v24 + 7) = v26;
      v27 = v38;
      *((_OWORD *)v24 + 8) = v37;
      *((_OWORD *)v24 + 9) = v27;
      v28 = v32;
      *((_OWORD *)v24 + 2) = v31[2];
      *((_OWORD *)v24 + 3) = v28;
      v29 = v34;
      *((_OWORD *)v24 + 4) = v33;
      *((_OWORD *)v24 + 5) = v29;
      v30 = v31[1];
      *(_OWORD *)v24 = v31[0];
      *((_OWORD *)v24 + 1) = v30;
    }
  }
  return 0;
}

uint64_t AULoudspeakerSystemIDV2::SetProperty(AULoudspeakerSystemIDV2 *this, int a2, int a3, unsigned int a4, id *a5, void *a6, int *a7)
{
  std::vector<unsigned int>::size_type v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  void *v13;
  int v14;
  void *v16;
  void *v17;
  _BYTE *v18;
  uint64_t v19;
  std::vector<unsigned int> v20;
  std::vector<unsigned int> __p;
  char v22;

  if (a2 == 1936290675)
  {
    if (*((_BYTE *)this + 17))
    {
      v11 = *((_QWORD *)this + 66);
      if (v11)
      {
        v12 = *a5;
        applesauce::dispatch::v1::queue::get(*a5);
        objc_msgSend((id)objc_claimAutoreleasedReturnValue(), "objectForKeyedSubscript:", CFSTR("sysIdSpeakerForStatus"));
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        v14 = objc_msgSend(v13, "unsignedIntValue");

        *(_DWORD *)(v11 + 392) = v14;
      }
    }
  }
  else
  {
    if (a2 != 64005)
      return AUDspLib::SetProperty(this, a2, a3, a4, (int *)a5, a6, a7);
    if (a5 && a6 >= 4)
    {
      v9 = a6 >> 2;
      std::vector<unsigned int>::vector(&v20, v9);
      __p = v20;
      memset(&v20, 0, sizeof(v20));
      v22 = 1;
      std::__optional_storage_base<std::vector<clsp::telemetry::Item>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::vector<clsp::telemetry::Item>,false>>((uint64_t)this + 2200, (__n128 *)&__p);
      if (v22 && __p.__begin_)
        operator delete(__p.__begin_);
      if (v20.__begin_)
      {
        v20.__end_ = v20.__begin_;
        operator delete(v20.__begin_);
      }
      memmove(*((void **)this + 275), a5, 4 * v9);
      if (*((_BYTE *)this + 17))
      {
        v10 = *((_QWORD *)this + 66);
        if (v10)
        {
          if (!*((_BYTE *)this + 2224))
            std::__throw_bad_optional_access[abi:ne180100]();
          v17 = 0;
          v18 = 0;
          v19 = 0;
          std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&v17, *((const void **)this + 275), *((_QWORD *)this + 276), (uint64_t)(*((_QWORD *)this + 276) - *((_QWORD *)this + 275)) >> 2);
          memset(&__p, 0, sizeof(__p));
          std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&__p, v17, (uint64_t)v18, (v18 - (_BYTE *)v17) >> 2);
          v22 = 1;
          std::__optional_storage_base<std::vector<clsp::telemetry::Item>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::vector<clsp::telemetry::Item>,false>>(v10 + 360, (__n128 *)&__p);
          if (v22 && __p.__begin_)
          {
            __p.__end_ = __p.__begin_;
            operator delete(__p.__begin_);
          }
          if (v17)
          {
            v18 = v17;
            operator delete(v17);
          }
        }
      }
    }
    else if (*((_BYTE *)this + 2224))
    {
      v16 = (void *)*((_QWORD *)this + 275);
      if (v16)
      {
        *((_QWORD *)this + 276) = v16;
        operator delete(v16);
      }
      *((_BYTE *)this + 2224) = 0;
    }
  }
  return 0;
}

void sub_1B6543BA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t AULoudspeakerSystemIDV2::ProcessBufferLists(AULoudspeakerSystemIDV2 *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  float v8;
  ausdk::AUElement *Element;
  AudioBufferList *v11;
  const AudioBufferList *v12;

  v11 = a4;
  v12 = a3;
  v6 = (*(uint64_t (**)(AULoudspeakerSystemIDV2 *, unsigned int *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))(*(_QWORD *)this + 184))(this, a2, a5, 1, &v12, 1, &v11);
  v7 = *((_QWORD *)this + 66);
  if (v7)
  {
    v8 = *(float *)(v7 + 324);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AULoudspeakerSystemIDV2 *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(Element, 0x40000000u, v8, 0);
  }
  return v6;
}

uint64_t AULoudspeakerSystemIDV2::GetParameterInfo(AULoudspeakerSystemIDV2 *this, unsigned int a2, uint64_t a3, AudioUnitParameterInfo *buffer)
{
  if ((_DWORD)a3 != 0x40000000)
    return AUDspLibWithNewParameters::GetParameterInfo(this, a2, a3, buffer);
  buffer->unit = kAudioUnitParameterUnit_Generic;
  *(_QWORD *)&buffer->minValue = 0x447A000000000000;
  *(_QWORD *)&buffer->defaultValue = 0x4880A00000000000;
  buffer->cfNameString = CFSTR("TotalMeasuredSpeakerPower");
  CFStringGetCString(CFSTR("TotalMeasuredSpeakerPower"), buffer->name, 52, 0x8000100u);
  return 0;
}

uint64_t AULoudspeakerSystemIDV2::SupportedNumChannels(AULoudspeakerSystemIDV2 *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AULoudspeakerSystemIDV2::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  return 8;
}

uint64_t AULoudspeakerSystemIDV2::Version(AULoudspeakerSystemIDV2 *this)
{
  return 0x2000000;
}

DspLib::LoudspeakerSystemIDV2::Algorithm *AULoudspeakerSystemIDV2::newDspLibAlgorithm(AULoudspeakerSystemIDV2 *this)
{
  DspLib::LoudspeakerSystemIDV2::Algorithm *v1;

  v1 = (DspLib::LoudspeakerSystemIDV2::Algorithm *)operator new();
  DspLib::LoudspeakerSystemIDV2::Algorithm::Algorithm(v1);
  return v1;
}

void sub_1B6543D18(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10F3C40262A5E19);
  _Unwind_Resume(a1);
}

float CNoiseSuppressorV3::hypergeom_gain(CNoiseSuppressorV3 *this, float a2)
{
  unsigned int v2;
  float v4;

  v2 = vcvtms_s32_f32(a2 + a2);
  if ((v2 & 0x80000000) != 0)
    return 1.0;
  if (v2 >= 0x14)
    return (float)(0.1296 / a2) + 1.0;
  v4 = floorf(a2 + a2);
  return (float)((float)((float)-(float)(v4 - (float)(a2 * 2.0))
                       * *((float *)&NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeHypergeometricGain(std::vector<float> &,AutoValue<std::vector<float>,(LogTypes)0> &)::table
                         + v2
                         + 1))
               + (float)((float)(1.0 - (float)-(float)(v4 - (float)(a2 * 2.0)))
                       * *((float *)&NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeHypergeometricGain(std::vector<float> &,AutoValue<std::vector<float>,(LogTypes)0> &)::table
                         + v2)))
       / sqrtf(a2 + 0.0001);
}

float *CNoiseSuppressorV3::hypergeom_gain_vopt(float *this, float *a2)
{
  uint64_t v2;
  float v3;
  unsigned int v4;
  float v5;
  float v6;

  if ((int)a2 >= 1)
  {
    v2 = a2;
    do
    {
      v3 = *this;
      v4 = vcvtms_s32_f32(v3 + v3);
      v5 = 1.0;
      if ((v4 & 0x80000000) == 0)
      {
        if (v4 < 0x14)
        {
          v6 = -(float)(floorf(v3 + v3) - (float)(v3 * 2.0));
          v5 = (float)((float)(v6
                             * *((float *)&NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeHypergeometricGain(std::vector<float> &,AutoValue<std::vector<float>,(LogTypes)0> &)::table
                               + v4
                               + 1))
                     + (float)((float)(1.0 - v6)
                             * *((float *)&NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeHypergeometricGain(std::vector<float> &,AutoValue<std::vector<float>,(LogTypes)0> &)::table
                               + v4)))
             / sqrtf(v3 + 0.0001);
        }
        else
        {
          v5 = (float)(0.1296 / v3) + 1.0;
        }
      }
      *this++ = v5;
      --v2;
    }
    while (v2);
  }
  return this;
}

float CNoiseSuppressorV3::speex_synthesis(int *a1, float *a2)
{
  vDSP_Length v4;
  int v5;
  uint64_t v6;
  float *v7;
  float *v8;
  uint64_t v9;
  _QWORD *v10;
  float v11;
  MultiRadixRealFFT *v12;
  uint64_t v13;
  uint64_t v14;
  float result;
  uint64_t v16;
  int v17;
  float *v18;
  float *v19;
  float v20;
  NSObject *v21;
  DSPSplitComplex __Z;
  float __B;
  const char *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = a1[1];
  v5 = 2 * v4;
  MEMORY[0x1E0C80A78](a1);
  v7 = (float *)((char *)&__Z - v6);
  v8 = (float *)((char *)&__Z + 4 * v4 - v6);
  __Z.realp = v8 + 1;
  __Z.imagp = (float *)((char *)&__Z.imagp - v6);
  vDSP_ctoz((const DSPComplex *)(*(_QWORD *)(v9 + 136) + 8), 2, &__Z, 1, v4 - 2);
  v10 = (_QWORD *)*((_QWORD *)a1 + 17);
  *(_QWORD *)v7 = *v10;
  v7[2 * (int)v4 - 1] = *(float *)&v10[v4 - 1];
  *v8 = *((float *)&v10[(int)v4 - 1] + 1);
  __Z.realp = v7;
  __Z.imagp = v8;
  __B = 0.000030518;
  vDSP_vsmul(v7, 1, &__B, v7, 1, (2 * v4));
  v12 = (MultiRadixRealFFT *)*((_QWORD *)a1 + 72);
  if (v12)
  {
    MultiRadixRealFFT::RealInPlaceTransform(v12, &__Z, -1, v11);
    goto LABEL_3;
  }
  if (SuppressorClassLogScope(void)::once != -1)
    dispatch_once(&SuppressorClassLogScope(void)::once, &__block_literal_global_5244);
  if (SuppressorClassLogScope(void)::scope)
  {
    v21 = *(NSObject **)SuppressorClassLogScope(void)::scope;
    if (!*(_QWORD *)SuppressorClassLogScope(void)::scope)
      goto LABEL_3;
  }
  else
  {
    v21 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    __B = 4.8151e-34;
    v24 = "CNoiseSuppressorV3.cpp";
    v25 = 1024;
    v26 = 497;
    _os_log_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d MultiRadixRealFFT_RealInPlaceTransform() returned an error.", (uint8_t *)&__B, 0x12u);
  }
LABEL_3:
  vDSP_ztoc(&__Z, 1, *((DSPComplex **)a1 + 15), 2, v4);
  vDSP_vmul(*((const float **)a1 + 15), 1, *((const float **)a1 + 23), 1, *((float **)a1 + 15), 1, v5);
  v13 = (v5 - *a1);
  v14 = (*a1 - v13);
  vDSP_vadd(*((const float **)a1 + 69), 1, *((const float **)a1 + 15), 1, a2, 1, (int)v13);
  if ((int)v14 >= 1)
  {
    v16 = *((_QWORD *)a1 + 15);
    v17 = v13;
    do
    {
      result = *(float *)(v16 + 4 * v17);
      a2[v17++] = result;
      --v14;
    }
    while (v14);
  }
  if ((int)v13 >= 1)
  {
    v18 = (float *)*((_QWORD *)a1 + 69);
    v19 = (float *)(*((_QWORD *)a1 + 15) + 4 * *a1);
    do
    {
      v20 = *v19++;
      result = v20;
      *v18++ = v20;
      --v13;
    }
    while (v13);
  }
  return result;
}

uint64_t CNoiseSuppressorV3::speex_preprocess_run_ns_freq(uint64_t a1, const float **a2, float **a3)
{
  vDSP_Length v6;
  int64_t v7;
  const float *v8;
  float *v9;
  const float *v10;
  float *v11;
  uint64_t v12;
  float *v13;
  float *v14;
  int v15;
  float v16;
  int v17;
  vDSP_Length v18;
  int v19;
  uint64_t v20;
  float *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float *v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  float *v30;
  unint64_t v31;
  float *v32;
  float v33;
  vDSP_Length v34;
  float *v35;
  float *v36;
  float v37;
  float v38;
  float *v39;
  float v40;
  float v41;
  float v42;
  float v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float *v47;
  float v48;
  double v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  int v56;
  float v57;
  float v58;
  float v59;
  float v60;
  unint64_t v61;
  float v62;
  float v63;
  float v64;
  float v65;
  int64_t v66;
  const float *v67;
  float *v68;
  const float *v69;
  const float *v70;
  float *v71;
  float v72;
  uint64_t v73;
  float v74;
  float v75;
  float v76;
  float *v77;
  CNoiseSuppressorV3 *v78;
  uint64_t v79;
  uint64_t v80;
  const float *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  float *v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float *v92;
  float *v93;
  int v94;
  vDSP_Length v95;
  float *v96;
  float *v97;
  float *v98;
  float *v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  uint64_t v105;
  const float *v106;
  uint64_t v107;
  const float *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  float *v112;
  float *v113;
  _QWORD *v114;
  size_t v115;
  float v116;
  float *v118;
  vDSP_Length v119;
  const float *v120;
  uint64_t v121;
  float **v122;
  size_t v123;
  float *v124;
  DSPSplitComplex __B;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float __A;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float __C;
  float v139;
  float v140;
  uint64_t v141;
  float v142;
  float v143;
  uint64_t v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float v149;
  uint64_t v150;

  v150 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned int *)(a1 + 4);
  v7 = (int)v6;
  v120 = *(const float **)(a1 + 152);
  v147 = 0.05;
  v148 = 0.0;
  v146 = 1.05;
  v145 = 2.0;
  v144 = 0;
  v143 = 0.000001;
  v142 = 1.0;
  v141 = 0;
  v140 = 0.0;
  v8 = *a2;
  v9 = *(float **)(a1 + 656);
  LODWORD(__B.realp) = 1191182336;
  vDSP_vsmul(v8, 1, (const float *)&__B, v9, 1, v6);
  v10 = a2[1];
  v11 = *(float **)(a1 + 664);
  LODWORD(__B.realp) = 1191182336;
  vDSP_vsmul(v10, 1, (const float *)&__B, v11, 1, v6);
  if (a3 && *(_DWORD *)(a1 + 428) == 2)
  {
    v13 = *a3;
    LODWORD(__B.realp) = 1191182336;
    vDSP_vsmul(v13, 1, (const float *)&__B, v13, 1, v6);
    v14 = a3[1];
    LODWORD(__B.realp) = 1191182336;
    vDSP_vsmul(v14, 1, (const float *)&__B, v14, 1, v6);
  }
  v122 = &v118;
  v15 = *(_DWORD *)(a1 + 560);
  v16 = (float)(int)v6;
  if (v15 + 1 < (int)(float)((float)((float)*(int *)(a1 + 8) * 30.0) / (float)(int)v6))
    v17 = v15 + 1;
  else
    v17 = (int)(float)((float)((float)*(int *)(a1 + 8) * 30.0) / (float)(int)v6);
  *(_DWORD *)(a1 + 560) = v17;
  ++*(_DWORD *)(a1 + 568);
  v18 = *(int *)(a1 + 12);
  HIDWORD(v144) = *(_DWORD *)(a1 + 412);
  *(float *)&v144 = 1.0 - *((float *)&v144 + 1);
  v148 = *(float *)(a1 + 424);
  v19 = v18 + v6;
  MEMORY[0x1E0C80A78](v12);
  v21 = (float *)((char *)&v118 - ((v20 + 15) & 0x7FFFFFFF0));
  MEMORY[0x1E0C80A78](v22);
  v124 = (float *)((char *)&v118 - v23);
  v24 = 4 * v6;
  MEMORY[0x1E0C80A78](v25);
  v26 = (float *)((char *)&v118 - ((4 * v6 + 15) & 0x7FFFFFFF0));
  MEMORY[0x1E0C80A78](v27);
  v29 = (float *)((char *)&v118 - v28);
  CNoiseSuppressorV4::preprocess_analysis_freq(a1, *(_QWORD *)(a1 + 656), *(const void **)(a1 + 664));
  if (*(_DWORD *)(a1 + 428) == 2)
    CNoiseSuppressorV4::preprocess_analysis_sec_freq(a1, (uint64_t)*a3, a3[1]);
  CNoiseSuppressorV4::update_noise_prob(a1);
  v30 = v124;
  vDSP_vsmul(*(const float **)(a1 + 152), 1, (const float *)&v144 + 1, v124, 1, (int)v6);
  vDSP_vsma(*(const float **)(a1 + 200), 1, (const float *)&v144, v30, 1, v30, 1, (int)v6);
  vDSP_vsmul(*(const float **)(a1 + 288), 1, &v148, v21, 1, (int)v6);
  vDSP_vsub(v21, 1, *(const float **)(a1 + 152), 1, v21, 1, (int)v6);
  vDSP_vmax(*(const float **)(a1 + 304), 1, v21, 1, v21, 1, (int)v6);
  v123 = 4 * (int)v6;
  if ((int)v6 < 1)
  {
    if (*(_DWORD *)(a1 + 428) == 2)
    {
      LODWORD(__B.realp) = 0;
      v38 = 0.0;
      v37 = 0.0;
      v33 = 0.0;
      goto LABEL_29;
    }
    goto LABEL_38;
  }
  v31 = 0;
  do
  {
    if (v21[v31 / 4] <= 0.0)
    {
      v32 = *(float **)(a1 + 152);
LABEL_15:
      *(float *)(*(_QWORD *)(a1 + 200) + v31) = v32[v31 / 4];
      goto LABEL_16;
    }
    v32 = v30;
    if (*(float *)(*(_QWORD *)(a1 + 272) + v31) < (float)(*(float *)(a1 + 416) * *(float *)(*(_QWORD *)(a1 + 288) + v31)))
      goto LABEL_15;
LABEL_16:
    v31 += 4;
  }
  while (v24 != v31);
  if (*(_DWORD *)(a1 + 428) != 2)
  {
LABEL_38:
    memcpy(*(void **)(a1 + 192), *(const void **)(a1 + 200), 4 * (int)v6);
    goto LABEL_76;
  }
  LODWORD(__B.realp) = 0;
  v33 = 0.0;
  v34 = v6;
  v35 = *(float **)(a1 + 304);
  v36 = *(float **)(a1 + 312);
  v37 = 0.0;
  v38 = 0.0;
  v39 = *(float **)(a1 + 320);
  do
  {
    v40 = *v35++;
    if (v40 > 0.0)
      v33 = v33 + 1.0;
    v41 = *v36++;
    if (v41 > 0.0)
      v37 = v37 + 1.0;
    v42 = *v39++;
    if (v42 > 0.0)
      v38 = v38 + 1.0;
    --v34;
  }
  while (v34);
LABEL_29:
  *(float *)(a1 + 504) = v33 / v16;
  *(float *)(a1 + 508) = v37 / v16;
  v43 = v38 / v16;
  *(float *)(a1 + 512) = v43;
  *(float *)(a1 + 516) = (float)(v37 / v16) - v43;
  v139 = 0.0;
  v149 = (float)(*(float *)(a1 + 336) - *(float *)(a1 + 632)) / (float)(*(float *)(a1 + 636) - *(float *)(a1 + 632));
  vDSP_vsmul(*(const float **)(a1 + 160), 1, &v146, v21, 1, (int)v6);
  vDSP_vsmul(*(const float **)(a1 + 152), 1, &v147, v30, 1, (int)v6);
  vDSP_vsub(v30, 1, v21, 1, v30, 1, (int)v6);
  vDSP_vsmul(*(const float **)(a1 + 288), 1, &v145, v21, 1, (int)v6);
  vDSP_vmax(v30, 1, v21, 1, v30, 1, (int)v6);
  if ((int)v6 >= 1)
  {
    v44 = 0;
    v45 = *(_QWORD *)(a1 + 312);
    v46 = *(_QWORD *)(a1 + 208);
    do
    {
      v47 = v30;
      if (*(float *)(v45 + v44) <= 0.0)
        v47 = *(float **)(a1 + 152);
      *(float *)(v46 + v44) = v47[v44 / 4];
      v44 += 4;
    }
    while (v24 != v44);
  }
  if (*(float *)(a1 + 516) < -0.2)
  {
    if (v149 <= 0.0)
    {
      memcpy(*(void **)(a1 + 208), *(const void **)(a1 + 152), v123);
    }
    else if (v149 < 1.0)
    {
      v139 = 1.0 - v149;
      vDSP_vsmul(*(const float **)(a1 + 152), 1, &v149, v21, 1, (int)v6);
      vDSP_vsmul(*(const float **)(a1 + 208), 1, &v139, v30, 1, (int)v6);
      vDSP_vadd(v21, 1, v30, 1, *(float **)(a1 + 208), 1, (int)v6);
    }
  }
  __C = 0.0;
  vDSP_meanv(*(const float **)(a1 + 600), 1, &__C, (int)v6);
  if (__C > 0.99 && *(float *)(a1 + 628) < 0.4)
  {
    vDSP_vsadd(*(const float **)(a1 + 152), 1, &v143, v26, 1, (int)v6);
    vDSP_vsadd(*(const float **)(a1 + 160), 1, &v143, v29, 1, (int)v6);
    vDSP_vdbcon(v26, 1, &v142, v26, 1, (int)v6, 0);
    vDSP_vdbcon(v29, 1, &v142, v29, 1, (int)v6, 0);
    vDSP_vsub(v29, 1, v26, 1, v26, 1, (int)v6);
    vDSP_meanv(v26, 1, (float *)&v141 + 1, (int)v6);
    vDSP_meanv(v26, 1, (float *)&v141, *(int *)(a1 + 620));
    vDSP_meanv(&v26[*(int *)(a1 + 620)], 1, &v140, (int)v6 - (uint64_t)*(int *)(a1 + 620));
    v48 = *(float *)(a1 + 392);
    v49 = 1.0 - v48;
    v50 = (float)(v48 * *(float *)(a1 + 608)) + v49 * *((float *)&v141 + 1);
    *(float *)(a1 + 608) = v50;
    v51 = (float)(v48 * *(float *)(a1 + 612)) + v49 * *(float *)&v141;
    *(float *)(a1 + 612) = v51;
    v52 = (float)(v48 * *(float *)(a1 + 616)) + v49 * v140;
    *(float *)(a1 + 616) = v52;
  }
  v53 = *(float *)(a1 + 524);
  if ((float)(*(float *)(a1 + 616) - *(float *)(a1 + 612)) <= 10.0)
  {
    *(_DWORD *)(a1 + 488) = 0;
    v54 = v53 - *(float *)(a1 + 532);
    *(float *)&__B.realp = v54;
    if (v54 < 0.0)
    {
      LODWORD(__B.realp) = 0;
      v54 = 0.0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 488) = 1;
    v54 = v53 + *(float *)(a1 + 528);
    if (v54 > 1.0)
      v54 = 1.0;
    *(float *)&__B.realp = v54;
  }
  *(float *)(a1 + 524) = v54;
  v55 = CNoiseSuppressorV3::mic2occlusion_detection(a1);
  *(float *)(a1 + 480) = v55;
  v56 = *(_DWORD *)(a1 + 484);
  if (v55 < 0.3 && v56 == 1)
  {
    *(_DWORD *)(a1 + 484) = 0;
LABEL_59:
    *(_DWORD *)(a1 + 432) = 1;
    v57 = *(float *)(a1 + 520) - *(float *)(a1 + 448);
    if (v57 < 0.0)
      v57 = 0.0;
  }
  else
  {
    if (v55 <= 0.4 || v56)
    {
      if (v56 != 1)
        goto LABEL_59;
    }
    else
    {
      *(_DWORD *)(a1 + 484) = 1;
    }
    *(_DWORD *)(a1 + 432) = 0;
    v57 = *(float *)(a1 + 520) + *(float *)(a1 + 448);
    if (v57 > 1.0)
      v57 = 1.0;
  }
  *(float *)(a1 + 520) = v57;
  *(float *)(a1 + 436) = v57;
  if (v57 <= *(float *)(a1 + 524))
    v57 = *(float *)(a1 + 524);
  v58 = *(float *)(a1 + 648);
  v59 = fmaxf((float)(v58 * (float)(*(float *)(a1 + 336) - *(float *)(a1 + 644)))/ (float)(*(float *)(a1 + 640) - *(float *)(a1 + 644)), 0.0);
  if (v59 < v58)
    v58 = v59;
  *(float *)(a1 + 652) = v58;
  if (v57 <= v58)
    v57 = v58;
  *(float *)&__B.realp = v57;
  v137 = 1.0 - v57;
  vDSP_vsmul(*(const float **)(a1 + 200), 1, (const float *)&__B, v21, 1, (int)v6);
  vDSP_vsmul(*(const float **)(a1 + 208), 1, &v137, v30, 1, (int)v6);
  vDSP_vadd(v21, 1, v30, 1, *(float **)(a1 + 192), 1, (int)v6);
  if (*(_DWORD *)(a1 + 484) != 1 && *(_DWORD *)(a1 + 488) != 1)
  {
    v136 = 63.0;
    v60 = 1.0e10;
    if (*(float *)(a1 + 508) >= 0.8)
      v60 = 0.0;
    v135 = v60;
    vDSP_vsmul(*(const float **)(a1 + 200), 1, &v136, v21, 1, (int)v6);
    vDSP_vthr(v21, 1, &v135, v21, 1, (int)v6);
    vDSP_vsub(*(const float **)(a1 + 208), 1, v21, 1, v30, 1, (int)v6);
    if ((int)v6 >= 1)
    {
      v61 = 0;
      do
      {
        if (v30[v61 / 4] <= 0.0)
          *(_DWORD *)(*(_QWORD *)(a1 + 192) + v61) = *(_DWORD *)(*(_QWORD *)(a1 + 200) + v61);
        v61 += 4;
      }
      while (v24 != v61);
    }
  }
LABEL_76:
  vDSP_vmax(*(const float **)(a1 + 192), 1, *(const float **)(a1 + 224), 1, *(float **)(a1 + 192), 1, (int)v6);
  vDSP_vmin(*(const float **)(a1 + 192), 1, *(const float **)(a1 + 216), 1, *(float **)(a1 + 192), 1, (int)v6);
  CFilterBank::filterbank_compute_bank32(*(_QWORD *)(a1 + 16), *(const float **)(a1 + 192), (float *)(*(_QWORD *)(a1 + 192) + 4 * (int)v6));
  if (*(float *)(a1 + 332) < 0.5)
  {
    v62 = *(float *)(a1 + 360);
    v63 = *(float *)(a1 + 336);
    *(float *)(a1 + 336) = (float)(v62 * CNoiseSuppressorV4::AweightSPL(a1)) + (float)((float)(1.0 - v62) * v63);
  }
  v64 = *(float *)(a1 + 360);
  v65 = *(float *)(a1 + 340);
  *(float *)(a1 + 340) = (float)(v64 * CNoiseSuppressorV4::AweightSPL(a1)) + (float)((float)(1.0 - v64) * v65);
  v66 = v19;
  v67 = v120;
  if (*(_DWORD *)(a1 + 560) == 1)
    memcpy(*(void **)(a1 + 240), v120, 4 * v19);
  v139 = -1.0e20;
  v137 = 0.0;
  __C = -1.0;
  v136 = 0.1;
  v135 = 0.19;
  v134 = 0.2;
  v133 = 0.8;
  v132 = 0.89;
  v130 = 3.0;
  __A = 1.0;
  v128 = 1.0e-20;
  v129 = 100.0;
  v68 = v124;
  vDSP_vsadd(*(const float **)(a1 + 192), 1, &v128, v124, 1, v19);
  vDSP_svdiv(&__A, v68, 1, v21, 1, v19);
  vDSP_vadd(*(const float **)(a1 + 240), 1, v68, 1, v68, 1, v19);
  vDSP_vdiv(v68, 1, *(const float **)(a1 + 240), 1, v68, 1, v19);
  vDSP_vsq(v68, 1, v68, 1, v19);
  if (*(_DWORD *)(a1 + 460))
  {
    v69 = &v135;
    v70 = &v133;
  }
  else
  {
    v69 = &v132;
    v70 = &v136;
  }
  vDSP_vsmsa(v68, 1, v69, v70, v68, 1, v19);
  vDSP_vmsa(v67, 1, v21, 1, &__C, *(float **)(a1 + 264), 1, v19);
  vDSP_vclip(*(const float **)(a1 + 264), 1, &v137, &v129, *(float **)(a1 + 256), 1, v19);
  vDSP_vmin(*(const float **)(a1 + 264), 1, *(const float **)(a1 + 256), 1, *(float **)(a1 + 264), 1, v19);
  vDSP_vmul(*(const float **)(a1 + 256), 1, v68, 1, *(float **)(a1 + 256), 1, v19);
  vDSP_vsadd(v68, 1, &__C, v68, 1, v19);
  vDSP_vmul(v68, 1, *(const float **)(a1 + 240), 1, v68, 1, v19);
  vDSP_vmul(v68, 1, v21, 1, v21, 1, v19);
  vDSP_vsub(v21, 1, *(const float **)(a1 + 256), 1, *(float **)(a1 + 256), 1, v19);
  vDSP_vclip(*(const float **)(a1 + 256), 1, &v139, &v129, *(float **)(a1 + 256), 1, v19);
  vDSP_vsub((const float *)(*(_QWORD *)(a1 + 256) + 4 * (int)v6), 1, (const float *)(*(_QWORD *)(a1 + 368) + 4 * (int)v6), 1, &v21[(int)v6], 1, v18);
  v71 = &v68[(int)v6];
  vDSP_vthres(&v21[(int)v6], 1, &v137, v71, 1, v18);
  vDSP_vsub(v71, 1, &v21[(int)v6], 1, &v21[(int)v6], 1, v18);
  vDSP_vsma(&v21[(int)v6], 1, (const float *)(a1 + 396), (const float *)(*(_QWORD *)(a1 + 256) + 4 * (int)v6), 1, &v21[(int)v6], 1, v18);
  vDSP_vsma(v71, 1, (const float *)(a1 + 400), &v21[(int)v6], 1, (float *)(*(_QWORD *)(a1 + 368) + 4 * (int)v6), 1, 5uLL);
  vDSP_vsma(v71 + 5, 1, (const float *)(a1 + 404), &v21[(int)v6 + 5], 1, (float *)(*(_QWORD *)(a1 + 368) + 4 * (int)v6 + 20), 1, v18 - 5);
  v121 = (v18 + v6);
  v119 = v6;
  if ((int)v18 < 1)
  {
    v72 = 0.0;
  }
  else
  {
    v72 = 0.0;
    v73 = (int)v6;
    do
    {
      v74 = *(float *)(*(_QWORD *)(a1 + 368) + 4 * v73);
      if (v74 <= 3.0)
        v74 = -0.0;
      v72 = v72 + v74;
      ++v73;
    }
    while (v73 < v19);
  }
  v75 = v72 / (float)*(int *)(a1 + 12);
  *(float *)(a1 + 328) = v75;
  v76 = 0.5;
  *(float *)(a1 + 332) = (float)((float)(1.0 / (float)((float)(0.5 / v75) + 1.0)) * 0.899) + 0.1;
  v77 = (float *)(*(_QWORD *)(a1 + 176) + 4 * (int)v6);
  LODWORD(__B.realp) = sqrtf(expf((float)*(int *)(a1 + 52) * 0.23026));
  vDSP_vfill((const float *)&__B, v77, 1, v18);
  if ((int)v18 <= 0)
  {
    v85 = *(float **)(a1 + 168);
  }
  else
  {
    v118 = v21;
    v79 = *(_QWORD *)(a1 + 256);
    v80 = *(_QWORD *)(a1 + 264);
    v81 = v67;
    v82 = *(_QWORD *)(a1 + 240);
    v83 = *(_QWORD *)(a1 + 248);
    v84 = *(_QWORD *)(a1 + 368);
    v85 = *(float **)(a1 + 168);
    v120 = (const float *)v7;
    do
    {
      v86 = *(float *)(v79 + 4 * v7) / (float)(*(float *)(v79 + 4 * v7) + 1.0);
      v87 = *(float *)(v80 + 4 * v7) + 1.0;
      v88 = v86 * CNoiseSuppressorV3::hypergeom_gain(v78, v86 * v87);
      if (v88 > 1.0)
        v88 = 1.0;
      *(float *)(v83 + 4 * v7) = v88;
      *(float *)(v82 + 4 * v7) = (float)((float)(v88 * (float)(v88 * 0.8)) * v81[v7])
                               + (float)(*(float *)(v82 + 4 * v7) * 0.2);
      v89 = 1.0
          - (float)(*(float *)(a1 + 332)
                  * (float)((float)((float)(1.0 / (float)((float)(v76 / *(float *)(v84 + 4 * v7)) + 1.0)) * 0.899) + 0.1));
      v90 = (float)(*(float *)(v79 + 4 * v7) + 1.0) * (float)(v89 / (float)(1.0 - v89));
      v91 = (float)(v90 * expf(-(float)(v86 * v87))) + 1.0;
      v76 = 0.5;
      v85[v7++] = 1.0 / v91;
    }
    while (v7 < v66);
    v7 = (int64_t)v120;
    v21 = v118;
    v67 = v81;
  }
  CFilterBank::filterbank_compute_psd16(*(int ***)(a1 + 16), (uint64_t)&v85[v7], v85);
  CFilterBank::filterbank_compute_psd16(*(int ***)(a1 + 16), *(_QWORD *)(a1 + 248) + 4 * v7, *(float **)(a1 + 248));
  CFilterBank::filterbank_compute_psd16(*(int ***)(a1 + 16), *(_QWORD *)(a1 + 176) + 4 * v7, *(float **)(a1 + 176));
  v92 = v124;
  vDSP_vsadd(*(const float **)(a1 + 256), 1, &__A, v124, 1, v7);
  vDSP_vdiv(v92, 1, *(const float **)(a1 + 256), 1, v92, 1, v7);
  vDSP_vsadd(*(const float **)(a1 + 264), 1, &__A, v21, 1, v7);
  vDSP_vmul(v92, 1, v21, 1, v21, 1, v7);
  CNoiseSuppressorV3::hypergeom_gain_vopt(v21, (float *)v7);
  vDSP_vmul(v92, 1, v21, 1, v21, 1, v7);
  vDSP_vclip(v21, 1, &v139, &__A, v21, 1, v7);
  vDSP_vsmul(*(const float **)(a1 + 248), 1, &v130, v92, 1, v7);
  vDSP_vmin(v21, 1, v92, 1, *(float **)(a1 + 248), 1, v7);
  vDSP_vsq(*(const float **)(a1 + 248), 1, v92, 1, v7);
  vDSP_vmul(v92, 1, v67, 1, v92, 1, v7);
  vDSP_vsmul(v92, 1, &v133, v92, 1, v7);
  vDSP_vsma(*(const float **)(a1 + 240), 1, &v134, v92, 1, *(float **)(a1 + 240), 1, v7);
  vDSP_vmax(*(const float **)(a1 + 248), 1, *(const float **)(a1 + 176), 1, *(float **)(a1 + 248), 1, v7);
  v93 = *(float **)(a1 + 168);
  v94 = v121;
  v95 = v119;
  if ((int)v7 >= 1)
  {
    v96 = *(float **)(a1 + 248);
    v97 = *(float **)(a1 + 176);
    v98 = *(float **)(a1 + 168);
    v99 = v92;
    do
    {
      v100 = *v98++;
      v101 = v100;
      v102 = *v96++;
      v103 = sqrtf(v102);
      v104 = *v97++;
      *v99++ = (float)((float)(1.0 - v101) * sqrtf(v104)) + (float)(v101 * v103);
      --v95;
    }
    while (v95);
  }
  vDSP_vsq(v92, 1, v93, 1, v7);
  v127 = 0.25;
  v126 = 0.5;
  *v21 = 0.0;
  vDSP_vsmul(*(const float **)(a1 + 168), 1, &v127, v21 + 1, 1, v7 - 1);
  vDSP_vsma((const float *)(*(_QWORD *)(a1 + 168) + 4), 1, &v127, v21, 1, v21, 1, v7 - 1);
  vDSP_vsma(*(const float **)(a1 + 168), 1, &v126, v21, 1, *(float **)(a1 + 168), 1, v7);
  v105 = *(_QWORD *)(a1 + 168);
  if (!*(_DWORD *)(a1 + 24) && v94 >= 1)
    memset_pattern16(*(void **)(a1 + 168), &unk_1B6627B80, 4 * (v94 - 1) + 4);
  v106 = (const float *)(v105 + 4);
  v107 = 1;
  vDSP_vmul(v106, 1, (const float *)(*(_QWORD *)(a1 + 136) + 4), 2, (float *)(*(_QWORD *)(a1 + 136) + 4), 2, v7 - 1);
  vDSP_vmul(*(const float **)(a1 + 168), 1, *(const float **)(a1 + 136), 2, *(float **)(a1 + 136), 2, v7);
  v108 = *(const float **)(a1 + 168);
  v109 = 8 * (_DWORD)v7 - 4;
  *(float *)(*(_QWORD *)(a1 + 136) + v109) = v108[v7 - 1] * *(float *)(*(_QWORD *)(a1 + 136) + v109);
  vDSP_vmul(v108, 1, *(const float **)(a1 + 200), 1, *(float **)(a1 + 384), 1, v7);
  MEMORY[0x1E0C80A78](v110);
  v112 = (float *)((char *)&v118 - v111);
  v113 = (float *)((char *)&v118 + 4 * v7 - v111);
  __B.realp = v113 + 1;
  __B.imagp = (float *)((char *)&v118 - v111 + 8);
  vDSP_ctoz((const DSPComplex *)(*(_QWORD *)(a1 + 136) + 8), 2, &__B, 1, (int)v7 - 2);
  v114 = *(_QWORD **)(a1 + 136);
  *(_QWORD *)v112 = *v114;
  *(float *)((char *)v112 + v109) = *(float *)&v114[v7 - 1];
  *v113 = *(float *)((char *)v114 + v109);
  __B.realp = v112;
  __B.imagp = v113;
  v149 = 0.000030518;
  vDSP_vsmul(v112, 1, &v149, v112, 1, (2 * v7));
  v115 = v123;
  memcpy(*(void **)(a1 + 584), __B.realp, v123);
  memcpy(*(void **)(a1 + 592), __B.imagp, v115);
  if (*(_DWORD *)(a1 + 28))
  {
    v116 = *(float *)(a1 + 332);
    if (v116 > *(float *)(a1 + 44) || *(_DWORD *)(a1 + 564) && v116 > *(float *)(a1 + 48))
    {
      v107 = 1;
      *(_DWORD *)(a1 + 564) = 1;
    }
    else
    {
      v107 = 0;
      *(_DWORD *)(a1 + 564) = 0;
    }
  }
  return v107;
}

float CNoiseSuppressorV3::mic2occlusion_detection(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  vDSP_Length v4;
  float v5;
  float v6;
  uint64_t __C;

  __C = 0;
  v2 = *(_QWORD *)(a1 + 160);
  v3 = *(int *)(a1 + 468);
  v4 = *(_DWORD *)(a1 + 472) - (int)v3 + 1;
  vDSP_sve((const float *)(*(_QWORD *)(a1 + 152) + 4 * v3), 1, (float *)&__C + 1, v4);
  vDSP_sve((const float *)(v2 + 4 * *(int *)(a1 + 468)), 1, (float *)&__C, v4);
  v5 = *((float *)&__C + 1) / (*(float *)&__C + 0.00000011921) + 0.00000011921;
  v6 = (float)(*(float *)(a1 + 492) * 0.95) + (float)(log10f(v5) * 10.0) * 0.0500000119;
  *(float *)(a1 + 492) = v6;
  return 1.0 / ((float)(expf(v6 * -0.25) * 150.0) + 1.0);
}

float CNoiseSuppressorV3::update_noise_prob_vadns(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  float *v4;
  uint64_t v5;
  const float *v6;
  float v7;
  int v8;
  float v9;
  float v10;
  double v12;
  int *v14;
  int *v15;
  _DWORD *v16;
  int v17;
  float v19;
  float __B;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(a1 + 4);
  MEMORY[0x1E0C80A78](a1);
  v4 = (float *)((char *)&v19 - ((v3 + 15) & 0x7FFFFFFF0));
  v6 = (const float *)(v5 + 392);
  v7 = 1.0 - *(float *)(v5 + 392);
  v19 = v7 * 0.667;
  __B = v7 * 0.333;
  *v4 = 0.0;
  vDSP_vsmul(*(const float **)(v5 + 152), 1, &__B, v4 + 1, 1, (int)v2 - 1);
  vDSP_vsma((const float *)(*(_QWORD *)(a1 + 152) + 4), 1, &__B, v4, 1, v4, 1, (int)v2 - 1);
  vDSP_vsma(*(const float **)(a1 + 152), 1, &v19, v4, 1, v4, 1, (int)v2);
  vDSP_vsma(*(const float **)(a1 + 272), 1, v6, v4, 1, *(float **)(a1 + 272), 1, (int)v2);
  vDSP_vmul(*(const float **)(a1 + 160), 1, *(const float **)(a1 + 96), 1, *(float **)(a1 + 160), 1, (int)v2);
  if (*(_DWORD *)(a1 + 428) == 2)
  {
    *v4 = 0.0;
    vDSP_vsmul(*(const float **)(a1 + 160), 1, &__B, v4 + 1, 1, (int)v2 - 1);
    vDSP_vsma((const float *)(*(_QWORD *)(a1 + 160) + 4), 1, &__B, v4, 1, v4, 1, (int)v2 - 1);
    vDSP_vsma(*(const float **)(a1 + 160), 1, &v19, v4, 1, v4, 1, (int)v2);
    vDSP_vsma(*(const float **)(a1 + 280), 1, v6, v4, 1, *(float **)(a1 + 280), 1, (int)v2);
  }
  v8 = *(_DWORD *)(a1 + 560);
  if (v8 == 1)
  {
    vDSP_vclr(*(float **)(a1 + 288), 1, (int)v2);
    vDSP_vclr(*(float **)(a1 + 296), 1, (int)v2);
    v8 = *(_DWORD *)(a1 + 560);
  }
  v9 = (float)*(int *)(a1 + 8);
  v10 = (float)(v9 * 0.2) / (float)(int)v2;
  if (v10 <= (float)v8 && (float)((float)(v9 * 0.5) / (float)(int)v2) <= (float)v8)
    v10 = (float)(v9 + v9) / (float)(int)v2;
  if (*(_DWORD *)(a1 + 568) <= (int)v10)
  {
    vDSP_vmin(*(const float **)(a1 + 288), 1, *(const float **)(a1 + 272), 1, *(float **)(a1 + 288), 1, (int)v2);
    vDSP_vmin(*(const float **)(a1 + 296), 1, *(const float **)(a1 + 272), 1, *(float **)(a1 + 296), 1, (int)v2);
  }
  else
  {
    *(_DWORD *)(a1 + 568) = 0;
    vDSP_vmin(*(const float **)(a1 + 296), 1, *(const float **)(a1 + 272), 1, *(float **)(a1 + 288), 1, (int)v2);
    memcpy(*(void **)(a1 + 296), *(const void **)(a1 + 272), 4 * (int)v2);
  }
  vDSP_vmul(*(const float **)(a1 + 288), 1, *(const float **)(a1 + 80), 1, v4, 1, (int)v2);
  vDSP_vmul(v4, 1, *(const float **)(a1 + 112), 1, v4, 1, (int)v2);
  vDSP_vsub(v4, 1, *(const float **)(a1 + 272), 1, *(float **)(a1 + 304), 1, (int)v2);
  if (*(_DWORD *)(a1 + 428) == 2)
  {
    vDSP_vmul(*(const float **)(a1 + 280), 1, *(const float **)(a1 + 88), 1, v4, 1, (int)v2);
    vDSP_vsub(v4, 1, *(const float **)(a1 + 272), 1, *(float **)(a1 + 312), 1, (int)v2);
    vDSP_vmul(*(const float **)(a1 + 272), 1, *(const float **)(a1 + 88), 1, v4, 1, (int)v2);
    vDSP_vsub(v4, 1, *(const float **)(a1 + 280), 1, *(float **)(a1 + 320), 1, (int)v2);
  }
  v12 = (float)((float)(*(_DWORD *)(a1 + 560) * v2) / (float)*(int *)(a1 + 8));
  if (v12 < 0.05 && (int)v2 >= 1)
  {
    v14 = *(int **)(a1 + 152);
    v15 = *(int **)(a1 + 200);
    v16 = *(_DWORD **)(a1 + 288);
    do
    {
      *v15++ = *v14;
      v17 = *v14++;
      LODWORD(v12) = v17;
      *v16++ = v17;
      --v2;
    }
    while (v2);
  }
  return *(float *)&v12;
}

uint64_t CNoiseSuppressorV3::speex_preprocess_run_vadns_freq(uint64_t a1, const float **a2, float **a3)
{
  vDSP_Length v6;
  int64_t v7;
  const void *v8;
  const float *v9;
  float *v10;
  const float *v11;
  float *v12;
  uint64_t v13;
  float *v14;
  float *v15;
  int v16;
  float v17;
  int v18;
  vDSP_Length v19;
  float v20;
  float v21;
  int v22;
  uint64_t v23;
  float *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  unint64_t v33;
  float *v34;
  const void *v35;
  float *v36;
  float v37;
  vDSP_Length v38;
  float *v39;
  float *v40;
  float v41;
  float v42;
  float *v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  float *v52;
  const float *v53;
  float *v54;
  float v55;
  double v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  int v63;
  float v65;
  float v66;
  const float *v67;
  float v68;
  float *v69;
  unint64_t v70;
  uint64_t v71;
  _QWORD *v72;
  float v73;
  float v74;
  float v75;
  float v76;
  int64_t v77;
  float *v78;
  float *v79;
  float v80;
  uint64_t v81;
  float v82;
  float v83;
  float v84;
  float *v85;
  CNoiseSuppressorV3 *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  float *v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float *v99;
  float *v100;
  float *v101;
  float *v102;
  float *v103;
  float *v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  uint64_t v110;
  const float *v111;
  uint64_t v112;
  const float *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  float *v117;
  float *v118;
  _QWORD *v119;
  size_t v120;
  float v121;
  vDSP_Length v123;
  float *v124;
  float *v125;
  vDSP_Length *v126;
  size_t v127;
  const void *v128;
  float *v129;
  DSPSplitComplex __B;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float __A;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float __C;
  float v143;
  float v144;
  uint64_t v145;
  float v146;
  float v147;
  uint64_t v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;
  uint64_t v154;

  v154 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned int *)(a1 + 4);
  v7 = (int)v6;
  v8 = *(const void **)(a1 + 152);
  v151 = 0.05;
  v152 = 0.0;
  v150 = 1.05;
  v149 = 2.0;
  v148 = 0;
  v147 = 0.000001;
  v146 = 1.0;
  v145 = 0;
  v144 = 0.0;
  v9 = *a2;
  v10 = *(float **)(a1 + 656);
  LODWORD(__B.realp) = 1191182336;
  vDSP_vsmul(v9, 1, (const float *)&__B, v10, 1, v6);
  v11 = a2[1];
  v12 = *(float **)(a1 + 664);
  LODWORD(__B.realp) = 1191182336;
  vDSP_vsmul(v11, 1, (const float *)&__B, v12, 1, v6);
  if (a3 && *(_DWORD *)(a1 + 428) == 2)
  {
    v14 = *a3;
    LODWORD(__B.realp) = 1191182336;
    vDSP_vsmul(v14, 1, (const float *)&__B, v14, 1, v6);
    v15 = a3[1];
    LODWORD(__B.realp) = 1191182336;
    vDSP_vsmul(v15, 1, (const float *)&__B, v15, 1, v6);
  }
  v128 = v8;
  v126 = &v123;
  v16 = *(_DWORD *)(a1 + 560);
  v17 = (float)(int)v6;
  if (v16 + 1 < (int)(float)((float)((float)*(int *)(a1 + 8) * 30.0) / (float)(int)v6))
    v18 = v16 + 1;
  else
    v18 = (int)(float)((float)((float)*(int *)(a1 + 8) * 30.0) / (float)(int)v6);
  *(_DWORD *)(a1 + 560) = v18;
  ++*(_DWORD *)(a1 + 568);
  v19 = *(int *)(a1 + 12);
  HIDWORD(v148) = *(_DWORD *)(a1 + 412);
  *(float *)&v148 = 1.0 - *((float *)&v148 + 1);
  v20 = *(float *)(a1 + 104);
  v21 = v20 * *(float *)(a1 + 424);
  *(float *)(a1 + 424) = v21;
  *(float *)(a1 + 416) = v20 * *(float *)(a1 + 416);
  v152 = v21;
  v22 = v19 + v6;
  MEMORY[0x1E0C80A78](v13);
  v24 = (float *)((char *)&v123 - ((v23 + 15) & 0x7FFFFFFF0));
  MEMORY[0x1E0C80A78](v25);
  v129 = (float *)((char *)&v123 - v26);
  v27 = 4 * v6;
  MEMORY[0x1E0C80A78](v28);
  v29 = (float *)((char *)&v123 - ((4 * v6 + 15) & 0x7FFFFFFF0));
  MEMORY[0x1E0C80A78](v30);
  v125 = (float *)((char *)&v123 - v31);
  CNoiseSuppressorV4::preprocess_analysis_freq(a1, *(_QWORD *)(a1 + 656), *(const void **)(a1 + 664));
  if (*(_DWORD *)(a1 + 428) == 2)
    CNoiseSuppressorV4::preprocess_analysis_sec_freq(a1, (uint64_t)*a3, a3[1]);
  CNoiseSuppressorV3::update_noise_prob_vadns(a1);
  v32 = v129;
  vDSP_vsmul(*(const float **)(a1 + 152), 1, (const float *)&v148 + 1, v129, 1, (int)v6);
  vDSP_vsma(*(const float **)(a1 + 200), 1, (const float *)&v148, v32, 1, v32, 1, (int)v6);
  vDSP_vsmul(*(const float **)(a1 + 288), 1, &v152, v24, 1, (int)v6);
  vDSP_vmul(v24, 1, *(const float **)(a1 + 112), 1, v24, 1, (int)v6);
  vDSP_vsub(v24, 1, *(const float **)(a1 + 152), 1, v24, 1, (int)v6);
  vDSP_vmax(*(const float **)(a1 + 304), 1, v24, 1, v24, 1, (int)v6);
  v127 = 4 * (int)v6;
  if ((int)v6 < 1)
  {
    v35 = v128;
    if (*(_DWORD *)(a1 + 428) == 2)
    {
      LODWORD(__B.realp) = 0;
      v42 = 0.0;
      v41 = 0.0;
      v37 = 0.0;
      goto LABEL_30;
    }
    goto LABEL_39;
  }
  v33 = 0;
  v34 = v129;
  v35 = v128;
  do
  {
    if (v24[v33 / 4] <= 0.0)
    {
      v36 = *(float **)(a1 + 152);
LABEL_16:
      *(float *)(*(_QWORD *)(a1 + 200) + v33) = v36[v33 / 4];
      goto LABEL_17;
    }
    if (!*(_DWORD *)(a1 + 464))
    {
      v36 = v34;
      if (*(float *)(*(_QWORD *)(a1 + 272) + v33) < (float)((float)(*(float *)(a1 + 416)
                                                                   * *(float *)(*(_QWORD *)(a1 + 288) + v33))
                                                           * *(float *)(*(_QWORD *)(a1 + 112) + v33)))
        goto LABEL_16;
    }
LABEL_17:
    v33 += 4;
  }
  while (v27 != v33);
  if (*(_DWORD *)(a1 + 428) != 2)
  {
LABEL_39:
    memcpy(*(void **)(a1 + 192), *(const void **)(a1 + 200), 4 * (int)v6);
    goto LABEL_78;
  }
  LODWORD(__B.realp) = 0;
  v37 = 0.0;
  v38 = v6;
  v39 = *(float **)(a1 + 304);
  v40 = *(float **)(a1 + 312);
  v41 = 0.0;
  v42 = 0.0;
  v43 = *(float **)(a1 + 320);
  do
  {
    v44 = *v39++;
    if (v44 > 0.0)
      v37 = v37 + 1.0;
    v45 = *v40++;
    if (v45 > 0.0)
      v41 = v41 + 1.0;
    v46 = *v43++;
    if (v46 > 0.0)
      v42 = v42 + 1.0;
    --v38;
  }
  while (v38);
LABEL_30:
  *(float *)(a1 + 504) = v37 / v17;
  *(float *)(a1 + 508) = v41 / v17;
  v47 = v42 / v17;
  *(float *)(a1 + 512) = v47;
  *(float *)(a1 + 516) = (float)(v41 / v17) - v47;
  v143 = 0.0;
  v153 = (float)(*(float *)(a1 + 336) - *(float *)(a1 + 632)) / (float)(*(float *)(a1 + 636) - *(float *)(a1 + 632));
  vDSP_vsmul(*(const float **)(a1 + 160), 1, &v150, v24, 1, (int)v6);
  v48 = v129;
  vDSP_vsmul(*(const float **)(a1 + 152), 1, &v151, v129, 1, (int)v6);
  vDSP_vsub(v48, 1, v24, 1, v48, 1, (int)v6);
  vDSP_vsmul(*(const float **)(a1 + 288), 1, &v149, v24, 1, (int)v6);
  vDSP_vmax(v48, 1, v24, 1, v48, 1, (int)v6);
  if ((int)v6 >= 1)
  {
    v49 = 0;
    v50 = *(_QWORD *)(a1 + 312);
    v51 = *(_QWORD *)(a1 + 208);
    do
    {
      v52 = v48;
      if (*(float *)(v50 + v49) <= 0.0)
        v52 = *(float **)(a1 + 152);
      *(float *)(v51 + v49) = v52[v49 / 4];
      v49 += 4;
    }
    while (v27 != v49);
  }
  if (*(float *)(a1 + 516) < 0.2)
  {
    if (v153 <= 0.0)
    {
      memcpy(*(void **)(a1 + 208), *(const void **)(a1 + 152), v127);
    }
    else if (v153 < 1.0)
    {
      v143 = 1.0 - v153;
      vDSP_vsmul(*(const float **)(a1 + 152), 1, &v153, v24, 1, (int)v6);
      v53 = v129;
      vDSP_vsmul(*(const float **)(a1 + 208), 1, &v143, v129, 1, (int)v6);
      vDSP_vadd(v24, 1, v53, 1, *(float **)(a1 + 208), 1, (int)v6);
    }
  }
  __C = 0.0;
  vDSP_meanv(*(const float **)(a1 + 600), 1, &__C, (int)v6);
  if (__C > 0.99 && *(float *)(a1 + 628) < 0.4)
  {
    vDSP_vsadd(*(const float **)(a1 + 152), 1, &v147, v29, 1, (int)v6);
    v54 = v125;
    vDSP_vsadd(*(const float **)(a1 + 160), 1, &v147, v125, 1, (int)v6);
    vDSP_vdbcon(v29, 1, &v146, v29, 1, (int)v6, 0);
    vDSP_vdbcon(v54, 1, &v146, v54, 1, (int)v6, 0);
    vDSP_vsub(v54, 1, v29, 1, v29, 1, (int)v6);
    vDSP_meanv(v29, 1, (float *)&v145 + 1, (int)v6);
    vDSP_meanv(v29, 1, (float *)&v145, *(int *)(a1 + 620));
    vDSP_meanv(&v29[*(int *)(a1 + 620)], 1, &v144, (int)v6 - (uint64_t)*(int *)(a1 + 620));
    v55 = *(float *)(a1 + 392);
    v56 = 1.0 - v55;
    v57 = (float)(v55 * *(float *)(a1 + 608)) + v56 * *((float *)&v145 + 1);
    *(float *)(a1 + 608) = v57;
    v58 = (float)(v55 * *(float *)(a1 + 612)) + v56 * *(float *)&v145;
    *(float *)(a1 + 612) = v58;
    v59 = (float)(v55 * *(float *)(a1 + 616)) + v56 * v144;
    *(float *)(a1 + 616) = v59;
  }
  v60 = *(float *)(a1 + 524);
  if ((float)(*(float *)(a1 + 616) - *(float *)(a1 + 612)) <= 10.0)
  {
    *(_DWORD *)(a1 + 488) = 0;
    v61 = v60 - *(float *)(a1 + 532);
    if (v61 < 0.0)
    {
      LODWORD(__B.realp) = 0;
      v61 = 0.0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 488) = 1;
    v61 = v60 + *(float *)(a1 + 528);
    if (v61 > 1.0)
      v61 = 1.0;
    *(float *)&__B.realp = v61;
  }
  *(float *)(a1 + 524) = v61;
  v62 = CNoiseSuppressorV3::mic2occlusion_detection(a1);
  *(float *)(a1 + 480) = v62;
  v63 = *(_DWORD *)(a1 + 484);
  if (v62 < 0.3 && v63 == 1)
  {
    *(_DWORD *)(a1 + 484) = 0;
LABEL_62:
    *(_DWORD *)(a1 + 432) = 1;
    v65 = *(float *)(a1 + 520) - *(float *)(a1 + 448);
    if (v65 < 0.0)
      v65 = 0.0;
    goto LABEL_64;
  }
  if (v62 <= 0.4 || v63)
  {
    if (v63 == 1)
      goto LABEL_59;
    goto LABEL_62;
  }
  *(_DWORD *)(a1 + 484) = 1;
LABEL_59:
  *(_DWORD *)(a1 + 432) = 0;
  v65 = *(float *)(a1 + 520) + *(float *)(a1 + 448);
  if (v65 > 1.0)
    v65 = 1.0;
LABEL_64:
  *(float *)(a1 + 520) = v65;
  *(float *)(a1 + 436) = v65;
  v66 = 0.0;
  if (*(float *)(a1 + 624) < 0.5)
  {
    v66 = *(float *)(a1 + 524);
    if (v65 > v66)
      v66 = v65;
  }
  *(float *)&__B.realp = v66;
  v141 = 1.0 - v66;
  vDSP_vsmul(*(const float **)(a1 + 200), 1, (const float *)&__B, v24, 1, (int)v6);
  v67 = v129;
  vDSP_vsmul(*(const float **)(a1 + 208), 1, &v141, v129, 1, (int)v6);
  vDSP_vadd(v24, 1, v67, 1, *(float **)(a1 + 192), 1, (int)v6);
  if (*(_DWORD *)(a1 + 484) != 1 && *(_DWORD *)(a1 + 488) != 1)
  {
    v140 = 63.0;
    v68 = 1.0e10;
    if (*(float *)(a1 + 508) >= 0.8)
      v68 = 0.0;
    v139 = v68;
    vDSP_vsmul(*(const float **)(a1 + 200), 1, &v140, v24, 1, (int)v6);
    vDSP_vthr(v24, 1, &v139, v24, 1, (int)v6);
    v69 = v129;
    vDSP_vsub(*(const float **)(a1 + 208), 1, v24, 1, v129, 1, (int)v6);
    if ((int)v6 >= 1)
    {
      v70 = 0;
      v71 = *(_QWORD *)(a1 + 192);
      do
      {
        if (v69[v70 / 4] <= 0.0)
          v72 = (_QWORD *)(a1 + 200);
        else
          v72 = (_QWORD *)(a1 + 208);
        *(_DWORD *)(v71 + v70) = *(_DWORD *)(*v72 + v70);
        v70 += 4;
      }
      while (v27 != v70);
    }
  }
  v35 = v128;
LABEL_78:
  vDSP_vmax(*(const float **)(a1 + 192), 1, *(const float **)(a1 + 224), 1, *(float **)(a1 + 192), 1, (int)v6);
  vDSP_vmin(*(const float **)(a1 + 192), 1, *(const float **)(a1 + 216), 1, *(float **)(a1 + 192), 1, (int)v6);
  CFilterBank::filterbank_compute_bank32(*(_QWORD *)(a1 + 16), *(const float **)(a1 + 192), (float *)(*(_QWORD *)(a1 + 192) + 4 * (int)v6));
  if (*(float *)(a1 + 332) < 0.5)
  {
    v73 = *(float *)(a1 + 360);
    v74 = *(float *)(a1 + 336);
    *(float *)(a1 + 336) = (float)(v73 * CNoiseSuppressorV4::AweightSPL(a1)) + (float)((float)(1.0 - v73) * v74);
  }
  v75 = *(float *)(a1 + 360);
  v76 = *(float *)(a1 + 340);
  *(float *)(a1 + 340) = (float)(v75 * CNoiseSuppressorV4::AweightSPL(a1)) + (float)((float)(1.0 - v75) * v76);
  v77 = v22;
  if (*(_DWORD *)(a1 + 560) == 1)
    memcpy(*(void **)(a1 + 240), v35, 4 * v22);
  v143 = -1.0e20;
  v141 = 0.0;
  __C = -1.0;
  v140 = 0.1;
  v139 = 0.2;
  v138 = 0.8;
  v137 = 0.89;
  v135 = 3.0;
  __A = 1.0;
  v133 = 1.0e-20;
  v134 = 100.0;
  v78 = v129;
  vDSP_vsadd(*(const float **)(a1 + 192), 1, &v133, v129, 1, v22);
  vDSP_svdiv(&__A, v78, 1, v24, 1, v22);
  vDSP_vadd(*(const float **)(a1 + 240), 1, v78, 1, v78, 1, v22);
  vDSP_vdiv(v78, 1, *(const float **)(a1 + 240), 1, v78, 1, v22);
  vDSP_vsq(v78, 1, v78, 1, v22);
  vDSP_vsmsa(v78, 1, &v137, &v140, v78, 1, v22);
  vDSP_vmsa((const float *)v35, 1, v24, 1, &__C, *(float **)(a1 + 264), 1, v22);
  vDSP_vclip(*(const float **)(a1 + 264), 1, &v141, &v134, *(float **)(a1 + 256), 1, v22);
  vDSP_vmin(*(const float **)(a1 + 264), 1, *(const float **)(a1 + 256), 1, *(float **)(a1 + 264), 1, v22);
  vDSP_vmul(*(const float **)(a1 + 256), 1, v78, 1, *(float **)(a1 + 256), 1, v22);
  vDSP_vsadd(v78, 1, &__C, v78, 1, v22);
  vDSP_vmul(v78, 1, *(const float **)(a1 + 240), 1, v78, 1, v22);
  vDSP_vmul(v78, 1, v24, 1, v24, 1, v22);
  vDSP_vsub(v24, 1, *(const float **)(a1 + 256), 1, *(float **)(a1 + 256), 1, v22);
  vDSP_vclip(*(const float **)(a1 + 256), 1, &v143, &v134, *(float **)(a1 + 256), 1, v22);
  vDSP_vsub((const float *)(*(_QWORD *)(a1 + 256) + 4 * (int)v6), 1, (const float *)(*(_QWORD *)(a1 + 368) + 4 * (int)v6), 1, &v24[(int)v6], 1, v19);
  v79 = &v78[(int)v6];
  vDSP_vthres(&v24[(int)v6], 1, &v141, v79, 1, v19);
  vDSP_vsub(v79, 1, &v24[(int)v6], 1, &v24[(int)v6], 1, v19);
  vDSP_vsma(&v24[(int)v6], 1, (const float *)(a1 + 396), (const float *)(*(_QWORD *)(a1 + 256) + 4 * (int)v6), 1, &v24[(int)v6], 1, v19);
  vDSP_vsma(v79, 1, (const float *)(a1 + 400), &v24[(int)v6], 1, (float *)(*(_QWORD *)(a1 + 368) + 4 * (int)v6), 1, 5uLL);
  vDSP_vsma(v79 + 5, 1, (const float *)(a1 + 404), &v24[(int)v6 + 5], 1, (float *)(*(_QWORD *)(a1 + 368) + 4 * (int)v6 + 20), 1, v19 - 5);
  if ((int)v19 < 1)
  {
    v80 = 0.0;
  }
  else
  {
    v80 = 0.0;
    v81 = (int)v6;
    do
    {
      v82 = *(float *)(*(_QWORD *)(a1 + 368) + 4 * v81);
      if (v82 <= 3.0)
        v82 = -0.0;
      v80 = v80 + v82;
      ++v81;
    }
    while (v81 < v22);
  }
  v83 = v80 / (float)*(int *)(a1 + 12);
  *(float *)(a1 + 328) = v83;
  v84 = 0.5;
  *(float *)(a1 + 332) = (float)((float)(1.0 / (float)((float)(0.5 / v83) + 1.0)) * 0.899) + 0.1;
  v85 = (float *)(*(_QWORD *)(a1 + 176) + 4 * (int)v6);
  LODWORD(__B.realp) = sqrtf(expf((float)*(int *)(a1 + 52) * 0.23026));
  vDSP_vfill((const float *)&__B, v85, 1, v19);
  if ((int)v19 <= 0)
  {
    v92 = *(float **)(a1 + 168);
  }
  else
  {
    v123 = v6;
    v124 = v24;
    v125 = (float *)(v19 + v6);
    v87 = *(_QWORD *)(a1 + 256);
    v88 = *(_QWORD *)(a1 + 264);
    v89 = *(_QWORD *)(a1 + 240);
    v90 = *(_QWORD *)(a1 + 248);
    v91 = *(_QWORD *)(a1 + 368);
    v92 = *(float **)(a1 + 168);
    v128 = (const void *)v7;
    do
    {
      v93 = *(float *)(v87 + 4 * v7) / (float)(*(float *)(v87 + 4 * v7) + 1.0);
      v94 = *(float *)(v88 + 4 * v7) + 1.0;
      v95 = v93 * CNoiseSuppressorV3::hypergeom_gain(v86, v93 * v94);
      if (v95 > 1.0)
        v95 = 1.0;
      *(float *)(v90 + 4 * v7) = v95;
      *(float *)(v89 + 4 * v7) = (float)((float)(v95 * (float)(v95 * 0.8)) * *((float *)v35 + v7))
                               + (float)(*(float *)(v89 + 4 * v7) * 0.2);
      v96 = 1.0
          - (float)(*(float *)(a1 + 332)
                  * (float)((float)((float)(1.0 / (float)((float)(v84 / *(float *)(v91 + 4 * v7)) + 1.0)) * 0.899) + 0.1));
      v97 = (float)(*(float *)(v87 + 4 * v7) + 1.0) * (float)(v96 / (float)(1.0 - v96));
      v98 = (float)(v97 * expf(-(float)(v93 * v94))) + 1.0;
      v84 = 0.5;
      v92[v7++] = 1.0 / v98;
    }
    while (v7 < v77);
    v7 = (int64_t)v128;
    v22 = (int)v125;
    v24 = v124;
    v6 = v123;
  }
  CFilterBank::filterbank_compute_psd16(*(int ***)(a1 + 16), (uint64_t)&v92[v7], v92);
  CFilterBank::filterbank_compute_psd16(*(int ***)(a1 + 16), *(_QWORD *)(a1 + 248) + 4 * v7, *(float **)(a1 + 248));
  CFilterBank::filterbank_compute_psd16(*(int ***)(a1 + 16), *(_QWORD *)(a1 + 176) + 4 * v7, *(float **)(a1 + 176));
  v99 = v129;
  vDSP_vsadd(*(const float **)(a1 + 256), 1, &__A, v129, 1, v7);
  vDSP_vdiv(v99, 1, *(const float **)(a1 + 256), 1, v99, 1, v7);
  vDSP_vsadd(*(const float **)(a1 + 264), 1, &__A, v24, 1, v7);
  vDSP_vmul(v99, 1, v24, 1, v24, 1, v7);
  CNoiseSuppressorV3::hypergeom_gain_vopt(v24, (float *)v7);
  vDSP_vmul(v99, 1, v24, 1, v24, 1, v7);
  vDSP_vclip(v24, 1, &v143, &__A, v24, 1, v7);
  vDSP_vsmul(*(const float **)(a1 + 248), 1, &v135, v99, 1, v7);
  vDSP_vmin(v24, 1, v99, 1, *(float **)(a1 + 248), 1, v7);
  vDSP_vsq(*(const float **)(a1 + 248), 1, v99, 1, v7);
  vDSP_vmul(v99, 1, (const float *)v35, 1, v99, 1, v7);
  vDSP_vsmul(v99, 1, &v138, v99, 1, v7);
  vDSP_vsma(*(const float **)(a1 + 240), 1, &v139, v99, 1, *(float **)(a1 + 240), 1, v7);
  vDSP_vmax(*(const float **)(a1 + 248), 1, *(const float **)(a1 + 176), 1, *(float **)(a1 + 248), 1, v7);
  v100 = *(float **)(a1 + 168);
  if ((int)v7 >= 1)
  {
    v101 = *(float **)(a1 + 248);
    v102 = *(float **)(a1 + 176);
    v103 = *(float **)(a1 + 168);
    v104 = v99;
    do
    {
      v105 = *v103++;
      v106 = v105;
      v107 = *v101++;
      v108 = sqrtf(v107);
      v109 = *v102++;
      *v104++ = (float)((float)(1.0 - v106) * sqrtf(v109)) + (float)(v106 * v108);
      --v6;
    }
    while (v6);
  }
  vDSP_vsq(v99, 1, v100, 1, v7);
  v132 = 0.25;
  v131 = 0.5;
  *v24 = 0.0;
  vDSP_vsmul(*(const float **)(a1 + 168), 1, &v132, v24 + 1, 1, v7 - 1);
  vDSP_vsma((const float *)(*(_QWORD *)(a1 + 168) + 4), 1, &v132, v24, 1, v24, 1, v7 - 1);
  vDSP_vsma(*(const float **)(a1 + 168), 1, &v131, v24, 1, *(float **)(a1 + 168), 1, v7);
  v110 = *(_QWORD *)(a1 + 168);
  if (!*(_DWORD *)(a1 + 24) && v22 >= 1)
    memset_pattern16(*(void **)(a1 + 168), &unk_1B6627B80, 4 * (v22 - 1) + 4);
  v111 = (const float *)(v110 + 4);
  v112 = 1;
  vDSP_vmul(v111, 1, (const float *)(*(_QWORD *)(a1 + 136) + 4), 2, (float *)(*(_QWORD *)(a1 + 136) + 4), 2, v7 - 1);
  vDSP_vmul(*(const float **)(a1 + 168), 1, *(const float **)(a1 + 136), 2, *(float **)(a1 + 136), 2, v7);
  v113 = *(const float **)(a1 + 168);
  v114 = 8 * (_DWORD)v7 - 4;
  *(float *)(*(_QWORD *)(a1 + 136) + v114) = v113[v7 - 1] * *(float *)(*(_QWORD *)(a1 + 136) + v114);
  vDSP_vmul(v113, 1, *(const float **)(a1 + 200), 1, *(float **)(a1 + 384), 1, v7);
  MEMORY[0x1E0C80A78](v115);
  v117 = (float *)((char *)&v123 - v116);
  v118 = (float *)((char *)&v123 + 4 * v7 - v116);
  __B.realp = v118 + 1;
  __B.imagp = (float *)((char *)&v123 - v116 + 8);
  vDSP_ctoz((const DSPComplex *)(*(_QWORD *)(a1 + 136) + 8), 2, &__B, 1, (int)v7 - 2);
  v119 = *(_QWORD **)(a1 + 136);
  *(_QWORD *)v117 = *v119;
  *(float *)((char *)v117 + v114) = *(float *)&v119[v7 - 1];
  *v118 = *(float *)((char *)v119 + v114);
  __B.realp = v117;
  __B.imagp = v118;
  v153 = 0.000030518;
  vDSP_vsmul(v117, 1, &v153, v117, 1, (2 * v7));
  v120 = v127;
  memcpy(*(void **)(a1 + 584), __B.realp, v127);
  memcpy(*(void **)(a1 + 592), __B.imagp, v120);
  if (*(_DWORD *)(a1 + 28))
  {
    v121 = *(float *)(a1 + 332);
    if (v121 > *(float *)(a1 + 44) || *(_DWORD *)(a1 + 564) && v121 > *(float *)(a1 + 48))
    {
      v112 = 1;
      *(_DWORD *)(a1 + 564) = 1;
    }
    else
    {
      v112 = 0;
      *(_DWORD *)(a1 + 564) = 0;
    }
  }
  return v112;
}

uint64_t CNoiseSuppressorV3::speex_preprocess_run_freq(uint64_t a1, const float **a2, float **a3)
{
  if (*(_DWORD *)(a1 + 456))
    return CNoiseSuppressorV3::speex_preprocess_run_vadns_freq(a1, a2, a3);
  else
    return CNoiseSuppressorV3::speex_preprocess_run_ns_freq(a1, a2, a3);
}

char *CNoiseSuppressorV3::speex_preprocess_state_init(CNoiseSuppressorV3 *this, int a2, int a3)
{
  int v5;
  char *v6;
  char *v7;
  int v8;
  NSObject *v9;
  float v10;
  float v11;
  float v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  float *v40;
  int v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  uint64_t v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  float v88;
  int v89;
  _DWORD *v90;
  _DWORD *v91;
  _DWORD *v92;
  _DWORD *v93;
  _DWORD *v94;
  _DWORD *v95;
  _DWORD *v96;
  _DWORD *v97;
  _DWORD *v98;
  uint64_t v99;
  uint64_t v100;
  _DWORD *v101;
  _DWORD *v102;
  int v103;
  int v104;
  void *v105;
  void *v106;
  void *v107;
  void *v108;
  void *v109;
  void *v110;
  char *v111;
  char *v112;
  double v113;
  float v114;
  uint64_t v115;
  int32x2_t v116;
  uint64x2_t v117;
  float *v118;
  float32x2_t v119;
  float32x2_t v120;
  float32x2_t v121;
  int64x2_t v122;
  float64x2_t v123;
  float64x2_t v124;
  float v125;
  float64x2_t v126;
  float64x2_t v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  std::bad_alloc *exception;
  std::bad_alloc *v134;
  int64x2_t v135;
  uint64x2_t v136;
  float v137;
  float64x2_t __x;
  long double v139;
  float32x2_t v140;
  int32x2_t v141;
  int64x2_t v142;
  float __A;
  uint8_t buf[4];
  const char *v145;
  __int16 v146;
  int v147;
  uint64_t v148;

  v5 = (int)this;
  v148 = *MEMORY[0x1E0C80C00];
  __A = 3.4028e38;
  v6 = (char *)malloc_type_malloc(0x2A0uLL, 0x2C8E6D5CuLL);
  if (!v6)
    goto LABEL_122;
  v7 = v6;
  bzero(v6 + 8, 0x298uLL);
  *(_DWORD *)v7 = v5;
  *((_DWORD *)v7 + 1) = v5;
  v8 = 2 * v5;
  *((_DWORD *)v7 + 107) = a3;
  if (!MultiRadixRealFFT_Create(2 * v5, (MultiRadixRealFFT **)v7 + 72))
  {
    *((_QWORD *)v7 + 3) = 0x100000001;
    *((_DWORD *)v7 + 8) = 0;
    *(_QWORD *)(v7 + 52) = 0xFFFFFFD8FFFFFFFALL;
    *((_DWORD *)v7 + 15) = -15;
    *(_OWORD *)(v7 + 36) = xmmword_1B66A25F0;
    *((_DWORD *)v7 + 116) = 0;
    *((_QWORD *)v7 + 13) = 1065353216;
    *((_QWORD *)v7 + 14) = 0;
    *((_QWORD *)v7 + 57) = 0;
    *((_DWORD *)v7 + 2) = a2;
    *((_DWORD *)v7 + 3) = 24;
    v10 = (float)a2;
    *((_QWORD *)v7 + 2) = CFilterBank::filterbank_new((CFilterBank *)0x18, v5, (float)a2);
    v11 = (float)a2 / (float)v5;
    *((float *)v7 + 98) = expf(-1.0 / (float)(v11 * 0.04));
    *((float *)v7 + 99) = expf(-1.0 / (float)(v11 * 0.005));
    v12 = expf(-1.0 / (float)(v11 * 0.01));
    *((float *)v7 + 100) = v12;
    *((float *)v7 + 101) = v12;
    *((float *)v7 + 102) = 1.0 - expf(-1.0 / (float)(v11 * 0.1));
    *((float *)v7 + 105) = 1.0 - expf(-1.0 / (float)(v11 * 0.05));
    *((_DWORD *)v7 + 106) = 1094713344;
    *((float *)v7 + 103) = 1.0 - expf(-1.0 / (float)(v11 * 0.5));
    *((_DWORD *)v7 + 104) = 1112014848;
    v13 = malloc_type_malloc(4 * v8, 0x2C8E6D5CuLL);
    v14 = v13;
    if (!v5 || v13)
    {
      bzero(v13, 4 * v8);
      *((_QWORD *)v7 + 15) = v14;
      v15 = malloc_type_malloc(4 * v8, 0x2C8E6D5CuLL);
      v16 = v15;
      if (!v5 || v15)
      {
        bzero(v15, 4 * v8);
        *((_QWORD *)v7 + 16) = v16;
        v17 = malloc_type_malloc(4 * v8, 0x2C8E6D5CuLL);
        v18 = v17;
        if (!v5 || v17)
        {
          bzero(v17, 4 * v8);
          *((_QWORD *)v7 + 23) = v18;
          v19 = malloc_type_malloc(4 * v8, 0x2C8E6D5CuLL);
          v20 = v19;
          if (!v5 || v19)
          {
            bzero(v19, 4 * v8);
            *((_QWORD *)v7 + 17) = v20;
            v21 = malloc_type_malloc(4 * v8, 0x2C8E6D5CuLL);
            v22 = v21;
            if (!v5 || v21)
            {
              bzero(v21, 4 * v8);
              *((_QWORD *)v7 + 18) = v22;
              v23 = (v5 + 24);
              v24 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
              v25 = v24;
              if (v5 == -24 || v24)
              {
                bzero(v24, 4 * (int)v23);
                *((_QWORD *)v7 + 19) = v25;
                v26 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                v27 = v26;
                if (v5 == -24 || v26)
                {
                  bzero(v26, 4 * (int)v23);
                  *((_QWORD *)v7 + 20) = v27;
                  v28 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                  v29 = v28;
                  if (v5 == -24 || v28)
                  {
                    bzero(v28, 4 * (int)v23);
                    *((_QWORD *)v7 + 24) = v29;
                    v30 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                    v31 = v30;
                    if (!v5 || v30)
                    {
                      bzero(v30, 4 * v5);
                      *((_QWORD *)v7 + 27) = v31;
                      v32 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                      v33 = v32;
                      if (!v5 || v32)
                      {
                        bzero(v32, 4 * v5);
                        *((_QWORD *)v7 + 28) = v33;
                        v34 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                        v35 = v34;
                        if (!v5 || v34)
                        {
                          bzero(v34, 4 * v5);
                          *((_QWORD *)v7 + 11) = v35;
                          v36 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                          v37 = v36;
                          if (!v5 || v36)
                          {
                            bzero(v36, 4 * v5);
                            *((_QWORD *)v7 + 12) = v37;
                            if (*((_DWORD *)v7 + 107) == 2)
                            {
                              v38 = *((_QWORD *)v7 + 11);
                              if (a2 == 8000)
                              {
                                CNoiseSuppressorV4::curve_fn(flt_1B6687D68, 6, v5, v38);
                                v39 = *((_QWORD *)v7 + 12);
                                v40 = (float *)&unk_1B6687DE8;
                                v41 = 6;
                              }
                              else
                              {
                                CNoiseSuppressorV4::curve_fn(flt_1B6687D98, 10, v5, v38);
                                v39 = *((_QWORD *)v7 + 12);
                                v40 = (float *)&unk_1B6687E18;
                                v41 = 10;
                              }
                              CNoiseSuppressorV4::curve_fn(v40, v41, v5, v39);
                            }
                            vDSP_vfill(&__A, *((float **)v7 + 27), 1, v5);
                            v42 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                            v43 = v42;
                            if (v5 == -24 || v42)
                            {
                              bzero(v42, 4 * (int)v23);
                              *((_QWORD *)v7 + 25) = v43;
                              v44 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                              v45 = v44;
                              if (v5 == -24 || v44)
                              {
                                bzero(v44, 4 * (int)v23);
                                *((_QWORD *)v7 + 26) = v45;
                                v46 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                                v47 = v46;
                                if (v5 == -24 || v46)
                                {
                                  bzero(v46, 4 * (int)v23);
                                  *((_QWORD *)v7 + 47) = v47;
                                  v48 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                                  v49 = v48;
                                  if (v5 == -24 || v48)
                                  {
                                    bzero(v48, 4 * (int)v23);
                                    *((_QWORD *)v7 + 29) = v49;
                                    v50 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                                    v51 = v50;
                                    if (v5 == -24 || v50)
                                    {
                                      bzero(v50, 4 * (int)v23);
                                      *((_QWORD *)v7 + 30) = v51;
                                      v52 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                                      v53 = v52;
                                      if (v5 == -24 || v52)
                                      {
                                        bzero(v52, 4 * (int)v23);
                                        *((_QWORD *)v7 + 32) = v53;
                                        v54 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                                        v55 = v54;
                                        if (v5 == -24 || v54)
                                        {
                                          bzero(v54, 4 * (int)v23);
                                          *((_QWORD *)v7 + 33) = v55;
                                          v56 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                                          v57 = v56;
                                          if (v5 == -24 || v56)
                                          {
                                            bzero(v56, 4 * (int)v23);
                                            *((_QWORD *)v7 + 31) = v57;
                                            v58 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                                            v59 = v58;
                                            if (v5 == -24 || v58)
                                            {
                                              bzero(v58, 4 * (int)v23);
                                              *((_QWORD *)v7 + 21) = v59;
                                              v60 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                                              v61 = v60;
                                              if (v5 == -24 || v60)
                                              {
                                                bzero(v60, 4 * (int)v23);
                                                *((_QWORD *)v7 + 22) = v61;
                                                v62 = malloc_type_malloc(4 * (int)v23, 0x2C8E6D5CuLL);
                                                v63 = v62;
                                                if (v5 == -24 || v62)
                                                {
                                                  bzero(v62, 4 * (int)v23);
                                                  *((_QWORD *)v7 + 46) = v63;
                                                  v64 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                  v65 = v64;
                                                  if (!v5 || v64)
                                                  {
                                                    bzero(v64, 4 * v5);
                                                    *((_QWORD *)v7 + 34) = v65;
                                                    v66 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                    v67 = v66;
                                                    if (!v5 || v66)
                                                    {
                                                      bzero(v66, 4 * v5);
                                                      *((_QWORD *)v7 + 35) = v67;
                                                      v68 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                      v69 = v68;
                                                      if (!v5 || v68)
                                                      {
                                                        bzero(v68, 4 * v5);
                                                        *((_QWORD *)v7 + 36) = v69;
                                                        v70 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                        v71 = v70;
                                                        if (!v5 || v70)
                                                        {
                                                          bzero(v70, 4 * v5);
                                                          *((_QWORD *)v7 + 37) = v71;
                                                          v72 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                          v73 = v72;
                                                          if (!v5 || v72)
                                                          {
                                                            bzero(v72, 4 * v5);
                                                            *((_QWORD *)v7 + 38) = v73;
                                                            v74 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                            v75 = v74;
                                                            if (!v5 || v74)
                                                            {
                                                              bzero(v74, 4 * v5);
                                                              *((_QWORD *)v7 + 39) = v75;
                                                              v76 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                              v77 = v76;
                                                              if (!v5 || v76)
                                                              {
                                                                bzero(v76, 4 * v5);
                                                                *((_QWORD *)v7 + 40) = v77;
                                                                v78 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                v79 = v78;
                                                                if (!v5 || v78)
                                                                {
                                                                  bzero(v78, 4 * v5);
                                                                  *((_QWORD *)v7 + 48) = v79;
                                                                  *((_DWORD *)v7 + 18) = 6;
                                                                  *((_QWORD *)v7 + 8) = CNoiseSuppressorV3::setup_update_thresh_lut(int,int,SpeexPair_tV2 **,int *,float **)::threshold_points;
                                                                  *(float *)&dword_1EF134748 = v10 * 0.5;
                                                                  v80 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                  v81 = (uint64_t)v80;
                                                                  if (!v5 || v80)
                                                                  {
                                                                    bzero(v80, 4 * v5);
                                                                    *((_QWORD *)v7 + 10) = v81;
                                                                    CNoiseSuppressorV4::curve_fn(CNoiseSuppressorV3::setup_update_thresh_lut(int,int,SpeexPair_tV2 **,int *,float **)::threshold_points, *((_DWORD *)v7 + 18), v5, v81);
                                                                    v82 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                    v83 = v82;
                                                                    if (!v5 || v82)
                                                                    {
                                                                      bzero(v82, 4 * v5);
                                                                      *((_QWORD *)v7 + 67) = v83;
                                                                      v84 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                      v85 = v84;
                                                                      if (!v5 || v84)
                                                                      {
                                                                        bzero(v84, 4 * v5);
                                                                        *((_QWORD *)v7 + 68) = v85;
                                                                        v86 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                        v87 = v86;
                                                                        if (!v5 || v86)
                                                                        {
                                                                          bzero(v86, 4 * v5);
                                                                          *((_QWORD *)v7 + 69) = v87;
                                                                          if (*((_DWORD *)v7 + 107) == 2)
                                                                          {
                                                                            *((_QWORD *)v7 + 54) = 1;
                                                                            v88 = 1.0 - expf(-1.0 / v11);
                                                                            *((float *)v7 + 110) = v88;
                                                                            *((float *)v7 + 111) = 1.0 - v88;
                                                                            *((float *)v7 + 112) = 2.5 / v11;
                                                                          }
                                                                          *((_DWORD *)v7 + 119) = 0;
                                                                          CreateMagicalWindow(*((_QWORD *)v7 + 23), 2 * v5);
                                                                          v89 = *((_DWORD *)v7 + 1);
                                                                          if (v8 < 2 * v89)
                                                                            memset_pattern16((void *)(*((_QWORD *)v7 + 23) + 4 * v8), &unk_1B6627B80, 4 * (2 * v89 - v8 - 2) + 8);
                                                                          if (v5 < -23)
                                                                            goto LABEL_100;
                                                                          v90 = (_DWORD *)*((_QWORD *)v7 + 24);
                                                                          v91 = (_DWORD *)*((_QWORD *)v7 + 29);
                                                                          v92 = (_DWORD *)*((_QWORD *)v7 + 30);
                                                                          v94 = (_DWORD *)*((_QWORD *)v7 + 32);
                                                                          v93 = (_DWORD *)*((_QWORD *)v7 + 33);
                                                                          v95 = (_DWORD *)*((_QWORD *)v7 + 31);
                                                                          do
                                                                          {
                                                                            *v90++ = 1065353216;
                                                                            *v91++ = 0;
                                                                            *v92++ = 1065353216;
                                                                            *v95++ = 1065353216;
                                                                            *v93++ = 1065353216;
                                                                            *v94++ = 1065353216;
                                                                            --v23;
                                                                          }
                                                                          while (v23);
                                                                          if (v5 < 1)
                                                                          {
LABEL_100:
                                                                            v103 = 0;
                                                                          }
                                                                          else
                                                                          {
                                                                            v96 = (_DWORD *)*((_QWORD *)v7 + 38);
                                                                            v97 = (_DWORD *)*((_QWORD *)v7 + 39);
                                                                            v98 = (_DWORD *)*((_QWORD *)v7 + 25);
                                                                            v99 = v5;
                                                                            v100 = v5;
                                                                            do
                                                                            {
                                                                              *v96++ = 1065353216;
                                                                              *v97++ = 1065353216;
                                                                              *v98++ = 981668463;
                                                                              --v100;
                                                                            }
                                                                            while (v100);
                                                                            v101 = (_DWORD *)*((_QWORD *)v7 + 67);
                                                                            v102 = (_DWORD *)*((_QWORD *)v7 + 69);
                                                                            do
                                                                            {
                                                                              *v101++ = 0;
                                                                              *v102++ = 0;
                                                                              --v99;
                                                                            }
                                                                            while (v99);
                                                                            v103 = 1;
                                                                          }
                                                                          *((_DWORD *)v7 + 141) = 0;
                                                                          v104 = *((_DWORD *)v7 + 2);
                                                                          *((_DWORD *)v7 + 117) = 4000 * v89 / v104 - 1;
                                                                          *((_DWORD *)v7 + 118) = 8000 * v89 / v104 - 1;
                                                                          *((_DWORD *)v7 + 120) = 0;
                                                                          v105 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                          v106 = v105;
                                                                          if (!v5 || v105)
                                                                          {
                                                                            bzero(v105, 4 * v5);
                                                                            *((_QWORD *)v7 + 62) = v106;
                                                                            *(_QWORD *)(v7 + 484) = 0;
                                                                            *((_DWORD *)v7 + 123) = 0;
                                                                            *((_QWORD *)v7 + 63) = 0;
                                                                            *((_QWORD *)v7 + 65) = 0;
                                                                            *((_DWORD *)v7 + 132) = 1065353216;
                                                                            *((float *)v7 + 133) = 0.5 / v11;
                                                                            v107 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                            v108 = v107;
                                                                            if (!v5 || v107)
                                                                            {
                                                                              bzero(v107, 4 * v5);
                                                                              *((_QWORD *)v7 + 73) = v108;
                                                                              v109 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                              v110 = v109;
                                                                              if (!v5 || v109)
                                                                              {
                                                                                bzero(v109, 4 * v5);
                                                                                *((_QWORD *)v7 + 74) = v110;
                                                                                *((_DWORD *)v7 + 140) = 0;
                                                                                *((_DWORD *)v7 + 142) = 0;
                                                                                *((_DWORD *)v7 + 113) = 0;
                                                                                *((_QWORD *)v7 + 42) = 0;
                                                                                v111 = (char *)malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                                v112 = v111;
                                                                                if (!v5 || v111)
                                                                                {
                                                                                  bzero(v111, 4 * v5);
                                                                                  *((_QWORD *)v7 + 43) = v112;
                                                                                  *((float *)v7 + 88) = 1.0 / (float)((float)((float)v5 + (float)v5) * (float)v5);
                                                                                  *((float *)v7 + 90) = 1.0 - expf(-1.0 / (float)(v11 + v11));
                                                                                  v113 = (double)*((int *)v7 + 2);
                                                                                  if (v103)
                                                                                  {
                                                                                    v114 = v113
                                                                                         / ((double)v5 + (double)v5);
                                                                                    v137 = v114;
                                                                                    v136 = (uint64x2_t)vdupq_n_s64((unint64_t)v5 - 1);
                                                                                    v115 = (v5 + 1) & 0x1FFFFFFFELL;
                                                                                    v116 = (int32x2_t)0x100000000;
                                                                                    v117 = (uint64x2_t)xmmword_1B6626830;
                                                                                    v118 = (float *)(v112 + 4);
                                                                                    v119 = (float32x2_t)vdup_n_s32(0x43D428CAu);
                                                                                    v120 = (float32x2_t)vdup_n_s32(0x4D0DCF73u);
                                                                                    v135 = vdupq_n_s64(2uLL);
                                                                                    do
                                                                                    {
                                                                                      v141 = vmovn_s64((int64x2_t)vcgeq_u64(v136, v117));
                                                                                      v142 = (int64x2_t)v117;
                                                                                      v121 = vmul_n_f32(vcvt_f32_s32(v116), v137);
                                                                                      v140 = vmul_f32(v121, v121);
                                                                                      __x = vcvtq_f64_f32(v121);
                                                                                      v139 = pow(__x.f64[1], 8.0);
                                                                                      *(double *)v122.i64 = pow(__x.f64[0], 8.0);
                                                                                      *(long double *)&v122.i64[1] = v139;
                                                                                      v123 = vcvtq_f64_f32(vadd_f32(v140, v119));
                                                                                      v124 = vcvtq_f64_f32(vadd_f32(v140, v120));
                                                                                      if ((v141.i8[0] & 1) != 0)
                                                                                      {
                                                                                        v125 = 3.5041384e16
                                                                                             * *(double *)v122.i64
                                                                                             / ((float)(v140.f32[0] + 11589.0)
                                                                                              * vmulq_f64(v123, v123).f64[0]
                                                                                              * (float)(v140.f32[0] + 544440.0)
                                                                                              * vmulq_f64(v124, v124).f64[0]);
                                                                                        *(v118 - 1) = v125;
                                                                                      }
                                                                                      if ((v141.i8[4] & 1) != 0)
                                                                                      {
                                                                                        v126 = (float64x2_t)vzip2q_s64(v122, (int64x2_t)v124);
                                                                                        v124.f64[0] = 3.5041384e16;
                                                                                        v127 = vmulq_f64(v126, v124);
                                                                                        *(float *)v127.f64 = v127.f64[0] / vmuld_lane_f64(vmuld_lane_f64((float)(v140.f32[1] + 11589.0), vmulq_f64(v123, v123), 1) * (float)(v140.f32[1] + 544440.0), v127, 1);
                                                                                        *v118 = *(float *)v127.f64;
                                                                                      }
                                                                                      v117 = (uint64x2_t)vaddq_s64(v142, v135);
                                                                                      v116 = vadd_s32(v116, (int32x2_t)0x200000002);
                                                                                      v118 += 2;
                                                                                      v115 -= 2;
                                                                                    }
                                                                                    while (v115);
                                                                                  }
                                                                                  *((_QWORD *)v7 + 76) = 0x4100000041000000;
                                                                                  *((_DWORD *)v7 + 154) = 1090519040;
                                                                                  *((_DWORD *)v7 + 155) = (int)((double)v8 * 1000.0 / v113);
                                                                                  *((_OWORD *)v7 + 39) = xmmword_1B66A2600;
                                                                                  *((_QWORD *)v7 + 80) = 0x425C000042480000;
                                                                                  *((_DWORD *)v7 + 162) = 1059481190;
                                                                                  v128 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                                  v129 = v128;
                                                                                  if (!v5 || v128)
                                                                                  {
                                                                                    bzero(v128, 4 * v5);
                                                                                    *((_QWORD *)v7 + 82) = v129;
                                                                                    v130 = malloc_type_malloc(4 * v5, 0x2C8E6D5CuLL);
                                                                                    v131 = v130;
                                                                                    if (!v5 || v130)
                                                                                    {
                                                                                      bzero(v130, 4 * v5);
                                                                                      *((_QWORD *)v7 + 83) = v131;
                                                                                      return v7;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_122:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v134 = std::bad_alloc::bad_alloc(exception);
  }
  if (SuppressorClassLogScope(void)::once != -1)
    dispatch_once(&SuppressorClassLogScope(void)::once, &__block_literal_global_5244);
  if (!SuppressorClassLogScope(void)::scope)
  {
    v9 = MEMORY[0x1E0C81028];
LABEL_36:
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v145 = "CNoiseSuppressorV3.cpp";
      v146 = 1024;
      v147 = 2792;
      _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d MultiRadixRealFFT_Create() returned an error. Invalid block size?", buf, 0x12u);
    }
    goto LABEL_38;
  }
  v9 = *(NSObject **)SuppressorClassLogScope(void)::scope;
  if (*(_QWORD *)SuppressorClassLogScope(void)::scope)
    goto LABEL_36;
LABEL_38:
  free(v7);
  return 0;
}

void CNoiseSuppressorV3::speex_preprocess_state_destroy(uint64_t a1)
{
  free(*(void **)(a1 + 120));
  free(*(void **)(a1 + 128));
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 144));
  free(*(void **)(a1 + 152));
  free(*(void **)(a1 + 160));
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 176));
  free(*(void **)(a1 + 184));
  free(*(void **)(a1 + 192));
  free(*(void **)(a1 + 216));
  free(*(void **)(a1 + 224));
  free(*(void **)(a1 + 200));
  free(*(void **)(a1 + 208));
  free(*(void **)(a1 + 232));
  free(*(void **)(a1 + 240));
  free(*(void **)(a1 + 248));
  free(*(void **)(a1 + 256));
  free(*(void **)(a1 + 264));
  free(*(void **)(a1 + 376));
  free(*(void **)(a1 + 272));
  free(*(void **)(a1 + 280));
  free(*(void **)(a1 + 288));
  free(*(void **)(a1 + 296));
  free(*(void **)(a1 + 304));
  free(*(void **)(a1 + 312));
  free(*(void **)(a1 + 320));
  free(*(void **)(a1 + 368));
  free(*(void **)(a1 + 80));
  free(*(void **)(a1 + 88));
  free(*(void **)(a1 + 96));
  free(*(void **)(a1 + 112));
  free(*(void **)(a1 + 536));
  free(*(void **)(a1 + 544));
  free(*(void **)(a1 + 552));
  free(*(void **)(a1 + 384));
  free(*(void **)(a1 + 344));
  free(*(void **)(a1 + 496));
  free(*(void **)(a1 + 656));
  free(*(void **)(a1 + 664));
  MultiRadixFFT_Dispose(*(_QWORD *)(a1 + 576));
  free(*(void **)(a1 + 584));
  free(*(void **)(a1 + 592));
  CFilterBank::filterbank_destroy(*(void ***)(a1 + 16));
  free((void *)a1);
}

float CNoiseSuppressorV3::speex_preprocess_run(int *a1, char *a2, char *a3)
{
  vDSP_Length v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  float v13;
  MultiRadixRealFFT *v14;
  vDSP_Length v15;
  int v16;
  int v17;
  float v18;
  MultiRadixRealFFT *v19;
  DSPSplitComplex *v20;
  float result;
  NSObject *v22;
  NSObject *v23;
  DSPSplitComplex v24;
  DSPSplitComplex __Z;
  float __B;
  const char *v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v6 = a1[1];
  MEMORY[0x1E0C80A78](a1);
  MEMORY[0x1E0C80A78](v7);
  __Z.realp = v8;
  __Z.imagp = &v8[v6];
  v24.realp = (float *)((char *)&v24 - v9);
  v24.imagp = (float *)((char *)&v24 + 4 * v6 - v9);
  if (v10)
  {
    v11 = 2 * v6 - *a1;
    v12 = *a1 - v11;
    memcpy(*((void **)a1 + 15), *((const void **)a1 + 67), 4 * v11);
    memcpy((void *)(*((_QWORD *)a1 + 15) + 4 * v11), a2, 4 * *a1);
    memcpy(*((void **)a1 + 67), &a2[4 * v12], 4 * v11);
    vDSP_vmul(*((const float **)a1 + 15), 1, *((const float **)a1 + 23), 1, *((float **)a1 + 15), 1, 2 * v6);
    vDSP_ctoz(*((const DSPComplex **)a1 + 15), 2, &__Z, 1, v6);
    v14 = (MultiRadixRealFFT *)*((_QWORD *)a1 + 72);
    if (v14)
    {
      MultiRadixRealFFT::RealInPlaceTransform(v14, &__Z, 1, v13);
LABEL_4:
      __B = (float)(int)v6 + (float)(int)v6;
      vDSP_vsdiv(__Z.realp, 1, &__B, __Z.realp, 1, v6);
      vDSP_vsdiv(__Z.imagp, 1, &__B, __Z.imagp, 1, v6);
      goto LABEL_5;
    }
    if (SuppressorClassLogScope(void)::once != -1)
      dispatch_once(&SuppressorClassLogScope(void)::once, &__block_literal_global_5244);
    if (SuppressorClassLogScope(void)::scope)
    {
      v22 = *(NSObject **)SuppressorClassLogScope(void)::scope;
      if (!*(_QWORD *)SuppressorClassLogScope(void)::scope)
        goto LABEL_4;
    }
    else
    {
      v22 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      __B = 4.8151e-34;
      v27 = "CNoiseSuppressorV3.cpp";
      v28 = 1024;
      v29 = 439;
      _os_log_impl(&dword_1B5ED0000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d MultiRadixRealFFT_RealInPlaceTransform() returned an error.", (uint8_t *)&__B, 0x12u);
    }
    goto LABEL_4;
  }
LABEL_5:
  if (a3)
  {
    v15 = a1[1];
    v16 = 2 * v15 - *a1;
    v17 = *a1 - v16;
    memcpy(*((void **)a1 + 16), *((const void **)a1 + 68), 4 * v16);
    memcpy((void *)(*((_QWORD *)a1 + 16) + 4 * v16), a3, 4 * *a1);
    memcpy(*((void **)a1 + 68), &a3[4 * v17], 4 * v16);
    vDSP_vmul(*((const float **)a1 + 16), 1, *((const float **)a1 + 23), 1, *((float **)a1 + 16), 1, 2 * v15);
    vDSP_ctoz(*((const DSPComplex **)a1 + 16), 2, &v24, 1, v15);
    v19 = (MultiRadixRealFFT *)*((_QWORD *)a1 + 72);
    if (v19)
    {
      MultiRadixRealFFT::RealInPlaceTransform(v19, &v24, 1, v18);
LABEL_8:
      __B = (float)(int)v15 + (float)(int)v15;
      vDSP_vsdiv(v24.realp, 1, &__B, v24.realp, 1, v15);
      vDSP_vsdiv(v24.imagp, 1, &__B, v24.imagp, 1, v15);
      v20 = &v24;
      goto LABEL_10;
    }
    if (SuppressorClassLogScope(void)::once != -1)
      dispatch_once(&SuppressorClassLogScope(void)::once, &__block_literal_global_5244);
    if (SuppressorClassLogScope(void)::scope)
    {
      v23 = *(NSObject **)SuppressorClassLogScope(void)::scope;
      if (!*(_QWORD *)SuppressorClassLogScope(void)::scope)
        goto LABEL_8;
    }
    else
    {
      v23 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      __B = 4.8151e-34;
      v27 = "CNoiseSuppressorV3.cpp";
      v28 = 1024;
      v29 = 469;
      _os_log_impl(&dword_1B5ED0000, v23, OS_LOG_TYPE_ERROR, "%25s:%-5d MultiRadixRealFFT_RealInPlaceTransform() returned an error.", (uint8_t *)&__B, 0x12u);
    }
    goto LABEL_8;
  }
  v20 = 0;
LABEL_10:
  CNoiseSuppressorV3::speex_preprocess_run_freq((uint64_t)a1, (const float **)&__Z.realp, &v20->realp);
  if (a2)
    return CNoiseSuppressorV3::speex_synthesis(a1, (float *)a2);
  return result;
}

os_log_t ___Z15getAUHOAZoomLogv_block_invoke_22507()
{
  os_log_t result;

  result = os_log_create("com.apple.coreaudio", "hoaz");
  getAUHOAZoomLog(void)::gLog = (uint64_t)result;
  return result;
}

void DominanceCurveCoordinator::UpdateEffectiveDominanceCurve(DominanceCurveCoordinator *this)
{
  unint64_t v2;
  std::string *v3;
  std::string *v4;
  float v5;
  float v6;
  float v7;
  PiecewiseLinearTransform **v8;
  float v9;
  PiecewiseLinearTransform **v10;
  float v11;
  uint64_t v12;
  unint64_t v13;
  float v14;
  float v15;
  float v16;
  std::string __p;
  std::string v18;

  if (*((_QWORD *)this + 10) != *((_QWORD *)this + 9))
  {
    v2 = 0;
    v3 = (std::string *)((char *)this + 136);
    v4 = (std::string *)((char *)this + 160);
    do
    {
      v5 = (float)v2 * 0.5 * *((double *)this + 12) / (double)*((unint64_t *)this + 13);
      v6 = logf(v5);
      if (v5 <= 0.0)
        v7 = -30.0;
      else
        v7 = v6;
      if (*((char *)this + 159) < 0)
        std::string::__init_copy_ctor_external(&v18, *((const std::string::value_type **)this + 17), *((_QWORD *)this + 18));
      else
        v18 = *v3;
      v8 = (PiecewiseLinearTransform **)ZoomCurveValue::operator[]((uint64_t)this, (__int128 *)&v18);
      v9 = PiecewiseLinearTransform::tx(*v8, v7, v8[1]);
      if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v18.__r_.__value_.__l.__data_);
      if (*((char *)this + 183) < 0)
        std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 20), *((_QWORD *)this + 21));
      else
        __p = *v4;
      v10 = (PiecewiseLinearTransform **)ZoomCurveValue::operator[]((uint64_t)this, (__int128 *)&__p);
      v11 = PiecewiseLinearTransform::tx(*v10, v7, v10[1]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v12 = *((_QWORD *)this + 9);
      v13 = (*((_QWORD *)this + 10) - v12) >> 2;
      if (v13 <= v2)
        std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
      v14 = (float)(v9 * *((float *)this + 46)) + v11 * (1.0 - *((float *)this + 46));
      if (v14 <= 1.0)
        v15 = (float)(v9 * *((float *)this + 46)) + v11 * (1.0 - *((float *)this + 46));
      else
        v15 = 1.0;
      if (v14 >= 0.0)
        v16 = v15;
      else
        v16 = 0.0;
      *(float *)(v12 + 4 * v2++) = v16;
    }
    while (v2 < v13);
  }
}

void sub_1B65485A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0)
    operator delete(a9);
  _Unwind_Resume(exception_object);
}

uint64_t DominanceZoom::DominanceZoom(uint64_t a1, int a2, int a3, uint64_t a4, double a5)
{
  uint64_t i;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  _BYTE *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  NSObject *v30;
  std::string __p;
  std::string *v33;
  std::string *v34;
  std::string *v35;
  std::string **v36;
  _BYTE buf[32];
  uint64_t v38;
  _QWORD v39[3];
  __int128 v40;

  *(_QWORD *)&v40 = *MEMORY[0x1E0C80C00];
  std::string::basic_string[abi:ne180100]<0>(buf, "HOAZoomCurve");
  std::string::basic_string[abi:ne180100]<0>(&buf[24], "HOAZoomInDominanceCurve");
  std::string::basic_string[abi:ne180100]<0>(v39, "HOAZoomOutDominanceCurve");
  v33 = 0;
  v34 = 0;
  v35 = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v33;
  __p.__r_.__value_.__s.__data_[8] = 0;
  v33 = (std::string *)operator new(0x48uLL);
  v34 = v33;
  v35 = v33 + 3;
  v34 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((uint64_t)&v35, (__int128 *)buf, &v40, v33);
  std::string::basic_string[abi:ne180100]<0>(&__p, "");
  ZoomCurveValue::ZoomCurveValue(a1, (uint64_t)&v33, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v36 = &v33;
  std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100]((void ***)&v36);
  for (i = 0; i != -9; i -= 3)
  {
    if (SHIBYTE(v39[i + 2]) < 0)
      operator delete((void *)v39[i]);
  }
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(double *)(a1 + 96) = a5;
  *(_QWORD *)(a1 + 104) = a4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(a1 + 112), "HOAZoomCurve");
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(a1 + 136), "HOAZoomInDominanceCurve");
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(a1 + 160), "HOAZoomOutDominanceCurve");
  *(_QWORD *)(a1 + 184) = 0;
  if (a5 <= 0.0)
    __assert_rtn("DominanceCurveCoordinator", "DominanceZoom.hpp", 33, "sampleRate > 0.0");
  v11 = a4 + 1;
  std::vector<float>::resize(a1 + 72, a4 + 1);
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(a1 + 192));
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_QWORD *)(a1 + 296) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_DWORD *)(a1 + 304) = a2;
  *(_DWORD *)(a1 + 320) = a3;
  *(_QWORD *)(a1 + 328) = a4;
  v12 = ((a2 + 1) * (a2 + 1));
  *(_QWORD *)(a1 + 312) = v12;
  CLiteMatrix::CLiteMatrix((CLiteMatrix *)buf, v12, 1);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)buf;
  v13 = *(void **)(a1 + 216);
  if (v13)
  {
    *(_QWORD *)(a1 + 224) = v13;
    operator delete(v13);
    *(_QWORD *)(a1 + 216) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
  }
  *(_OWORD *)(a1 + 216) = *(_OWORD *)&buf[16];
  *(_QWORD *)(a1 + 232) = v38;
  CLiteMatrix::CLiteMatrix((CLiteMatrix *)buf, *(_QWORD *)(a1 + 312), 1);
  *(_OWORD *)(a1 + 240) = *(_OWORD *)buf;
  v14 = *(void **)(a1 + 256);
  if (v14)
  {
    *(_QWORD *)(a1 + 264) = v14;
    operator delete(v14);
    *(_QWORD *)(a1 + 256) = 0;
    *(_QWORD *)(a1 + 264) = 0;
    *(_QWORD *)(a1 + 272) = 0;
  }
  *(_OWORD *)(a1 + 256) = *(_OWORD *)&buf[16];
  *(_QWORD *)(a1 + 272) = v38;
  CLiteMatrix::CLiteMatrix((CLiteMatrix *)buf, *(_QWORD *)(a1 + 312), *(_QWORD *)(a1 + 312));
  v15 = *(_BYTE **)(a1 + 280);
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 296) - (_QWORD)v15) >> 3) < v11)
  {
    std::vector<CLiteMatrix>::__vdeallocate((uint64_t *)(a1 + 280));
    if (v11 > 0x666666666666666)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v16 = 0x999999999999999ALL * ((uint64_t)(*(_QWORD *)(a1 + 296) - *(_QWORD *)(a1 + 280)) >> 3);
    if (v16 <= v11)
      v16 = a4 + 1;
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 296) - *(_QWORD *)(a1 + 280)) >> 3) >= 0x333333333333333)
      v17 = 0x666666666666666;
    else
      v17 = v16;
    std::vector<CLiteMatrix>::__vallocate[abi:ne180100]((_QWORD *)(a1 + 280), v17);
    v18 = *(_QWORD *)(a1 + 288);
    v19 = v18 + 40 * v11;
    v20 = (_QWORD *)(v18 + 16);
    v21 = 40 * a4 + 40;
    do
    {
      *((_OWORD *)v20 - 1) = *(_OWORD *)buf;
      v20[1] = 0;
      v20[2] = 0;
      *v20 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v20, *(const void **)&buf[16], *(uint64_t *)&buf[24], (uint64_t)(*(_QWORD *)&buf[24] - *(_QWORD *)&buf[16]) >> 2);
      v20 += 5;
      v21 -= 40;
    }
    while (v21);
    goto LABEL_32;
  }
  v22 = (*(_QWORD *)(a1 + 288) - (_QWORD)v15) / 40;
  if (v22 >= v11)
    v23 = a4 + 1;
  else
    v23 = (*(_QWORD *)(a1 + 288) - (_QWORD)v15) / 40;
  for (; v23; --v23)
  {
    *(_OWORD *)v15 = *(_OWORD *)buf;
    if (v15 != buf)
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v15 + 16, *(char **)&buf[16], *(uint64_t *)&buf[24], (uint64_t)(*(_QWORD *)&buf[24] - *(_QWORD *)&buf[16]) >> 2);
    v15 += 40;
  }
  if (v11 > v22)
  {
    v24 = *(_QWORD *)(a1 + 288);
    v19 = v24 + 40 * (v11 - v22);
    v25 = (_QWORD *)(v24 + 16);
    v26 = 40 * a4 - 40 * v22 + 40;
    do
    {
      *((_OWORD *)v25 - 1) = *(_OWORD *)buf;
      v25[1] = 0;
      v25[2] = 0;
      *v25 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v25, *(const void **)&buf[16], *(uint64_t *)&buf[24], (uint64_t)(*(_QWORD *)&buf[24] - *(_QWORD *)&buf[16]) >> 2);
      v25 += 5;
      v26 -= 40;
    }
    while (v26);
LABEL_32:
    *(_QWORD *)(a1 + 288) = v19;
    goto LABEL_39;
  }
  v27 = *(_QWORD *)(a1 + 288);
  v28 = *(_QWORD *)(a1 + 280) + 40 * v11;
  while (v27 != v28)
  {
    v29 = *(void **)(v27 - 24);
    if (v29)
    {
      *(_QWORD *)(v27 - 16) = v29;
      operator delete(v29);
    }
    v27 -= 40;
  }
  *(_QWORD *)(a1 + 288) = v28;
LABEL_39:
  if (*(_QWORD *)&buf[16])
  {
    *(_QWORD *)&buf[24] = *(_QWORD *)&buf[16];
    operator delete(*(void **)&buf[16]);
  }
  *(_DWORD *)(a1 + 336) = 0;
  if (a2 != 1)
  {
    if (getAUHOAZoomLog(void)::onceToken != -1)
      dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
    v30 = getAUHOAZoomLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "DominanceZoom.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 158;
      _os_log_error_impl(&dword_1B5ED0000, v30, OS_LOG_TYPE_ERROR, "%s:%i unsupported order!", buf, 0x12u);
    }
  }
  atomic_store(1u, (unsigned int *)(a1 + 336));
  return a1;
}

void sub_1B6548B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  uint64_t v23;
  void *v25;
  void *v26;

  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  std::vector<CLiteMatrix>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
  v25 = *(void **)(v23 + 256);
  if (v25)
  {
    *(_QWORD *)(v23 + 264) = v25;
    operator delete(v25);
  }
  v26 = *(void **)(v23 + 216);
  if (v26)
  {
    *(_QWORD *)(v23 + 224) = v26;
    operator delete(v26);
  }
  DominanceCurveCoordinator::~DominanceCurveCoordinator((void **)v23);
  _Unwind_Resume(a1);
}

uint64_t DominanceZoom::SetZoomCurveValue(DominanceZoom *this, ZoomCurveValue *a2)
{
  NSObject *v4;
  NSObject *v5;
  void ***v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  int v12;
  NSObject *v13;
  uint64_t *v14;
  double v15;
  uint64_t *v16;
  double v17;
  uint64_t *v18;
  double v19;
  unsigned int *v20;
  unsigned int v21;
  std::string v23;
  std::string v24;
  void *v25[2];
  char v26;
  void *__p[2];
  char v28;
  std::string v29;
  _BYTE buf[12];
  __int16 v31;
  int v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (getAUHOAZoomLog(void)::onceToken != -1)
    dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
  v4 = getAUHOAZoomLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "DominanceZoom.cpp";
    v31 = 1024;
    v32 = 191;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%s:%i --", buf, 0x12u);
  }
  caulk::pooled_semaphore_mutex::_lock((DominanceZoom *)((char *)this + 192));
  if (getAUHOAZoomLog(void)::onceToken != -1)
    dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
  v5 = getAUHOAZoomLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "DominanceZoom.cpp";
    v31 = 1024;
    v32 = 191;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEFAULT, "%s:%i locked", buf, 0x12u);
  }
  std::string::basic_string[abi:ne180100]<0>(buf, "HOAZoomCurve");
  v6 = (void ***)((char *)a2 + 8);
  v7 = std::__tree<std::__value_type<std::string,PiecewiseLinearTransform>,std::__map_value_compare<std::string,std::__value_type<std::string,PiecewiseLinearTransform>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,PiecewiseLinearTransform>>>::__count_unique<std::string>(*((void ***)a2 + 1), (void **)buf);
  if (v33 < 0)
    operator delete(*(void **)buf);
  std::string::basic_string[abi:ne180100]<0>(__p, "HOAZoomInDominanceCurve");
  v8 = std::__tree<std::__value_type<std::string,PiecewiseLinearTransform>,std::__map_value_compare<std::string,std::__value_type<std::string,PiecewiseLinearTransform>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,PiecewiseLinearTransform>>>::__count_unique<std::string>(*v6, __p);
  if (v28 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v25, "HOAZoomOutDominanceCurve");
  v9 = std::__tree<std::__value_type<std::string,PiecewiseLinearTransform>,std::__map_value_compare<std::string,std::__value_type<std::string,PiecewiseLinearTransform>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,PiecewiseLinearTransform>>>::__count_unique<std::string>(*v6, v25);
  if (v7)
    v10 = v8 == 0;
  else
    v10 = 1;
  v12 = !v10 && v9 != 0;
  if (v26 < 0)
  {
    operator delete(v25[0]);
    if (v12)
      goto LABEL_24;
  }
  else if (v12)
  {
LABEL_24:
    if (this != a2)
    {
      std::__tree<std::__value_type<std::string,PiecewiseLinearTransform>,std::__map_value_compare<std::string,std::__value_type<std::string,PiecewiseLinearTransform>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,PiecewiseLinearTransform>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<std::string,PiecewiseLinearTransform>,std::__tree_node<std::__value_type<std::string,PiecewiseLinearTransform>,void *> *,long>>((uint64_t)this, *(__int128 **)a2, (__int128 *)((char *)a2 + 8));
      std::vector<std::string>::__assign_with_size[abi:ne180100]<std::string*,std::string*>((std::vector<std::string> *)this + 1, *((std::string **)a2 + 3), *((__int128 **)a2 + 4), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)a2 + 4) - *((_QWORD *)a2 + 3)) >> 3));
    }
    std::string::operator=((std::string *)this + 2, (const std::string *)a2 + 2);
    if (*((char *)this + 135) < 0)
      std::string::__init_copy_ctor_external(&v29, *((const std::string::value_type **)this + 14), *((_QWORD *)this + 15));
    else
      v29 = *(std::string *)((char *)this + 112);
    v14 = ZoomCurveValue::operator[]((uint64_t)this, (__int128 *)&v29);
    ApplyLogTransformationOfXValues((char **)v14, v15);
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v29.__r_.__value_.__l.__data_);
    if (*((char *)this + 159) < 0)
      std::string::__init_copy_ctor_external(&v24, *((const std::string::value_type **)this + 17), *((_QWORD *)this + 18));
    else
      v24 = *(std::string *)((char *)this + 136);
    v16 = ZoomCurveValue::operator[]((uint64_t)this, (__int128 *)&v24);
    ApplyLogTransformationOfXValues((char **)v16, v17);
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v24.__r_.__value_.__l.__data_);
    if (*((char *)this + 183) < 0)
      std::string::__init_copy_ctor_external(&v23, *((const std::string::value_type **)this + 20), *((_QWORD *)this + 21));
    else
      v23 = *(std::string *)((char *)this + 160);
    v18 = ZoomCurveValue::operator[]((uint64_t)this, (__int128 *)&v23);
    ApplyLogTransformationOfXValues((char **)v18, v19);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v23.__r_.__value_.__l.__data_);
    goto LABEL_46;
  }
  if (getAUHOAZoomLog(void)::onceToken != -1)
    dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
  v13 = getAUHOAZoomLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    LODWORD(v29.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v29.__r_.__value_.__r.__words + 4) = (std::string::size_type)"DominanceZoom.cpp";
    WORD2(v29.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&v29.__r_.__value_.__r.__words[1] + 6) = 92;
    _os_log_error_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_ERROR, "%s:%i invalid zoom curve value for dominance zoom", (uint8_t *)&v29, 0x12u);
  }
LABEL_46:
  v20 = (unsigned int *)((char *)this + 336);
  do
    v21 = __ldaxr(v20);
  while (__stlxr(v21 + 1, v20));
  return caulk::pooled_semaphore_mutex::_unlock((DominanceZoom *)((char *)this + 192));
}

void sub_1B65490E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  caulk::pooled_semaphore_mutex *v34;

  if (a14 < 0)
    operator delete(a9);
  caulk::pooled_semaphore_mutex::_unlock(v34);
  _Unwind_Resume(a1);
}

uint64_t DominanceZoom::CopyZoomCurveValue(std::string *this, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  std::string *v6;
  uint64_t *v7;
  double v8;
  uint64_t *v9;
  double v10;
  uint64_t *v11;
  double v12;
  std::string __p;
  std::string v15;
  std::string buf;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (getAUHOAZoomLog(void)::onceToken != -1)
    dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
  v4 = getAUHOAZoomLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"DominanceZoom.cpp";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 198;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%s:%i --", (uint8_t *)&buf, 0x12u);
  }
  caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(a2 + 192));
  if (getAUHOAZoomLog(void)::onceToken != -1)
    dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
  v5 = getAUHOAZoomLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"DominanceZoom.cpp";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 198;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEFAULT, "%s:%i locked", (uint8_t *)&buf, 0x12u);
  }
  std::map<std::string,PiecewiseLinearTransform>::map[abi:ne180100]((uint64_t)this, (_QWORD *)a2);
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(this + 1, *(__int128 **)(a2 + 24), *(__int128 **)(a2 + 32), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 3));
  v6 = this + 2;
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 48), *(_QWORD *)(a2 + 56));
  }
  else
  {
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 48);
    this[2].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 64);
  }
  if (*(char *)(a2 + 135) < 0)
    std::string::__init_copy_ctor_external(&buf, *(const std::string::value_type **)(a2 + 112), *(_QWORD *)(a2 + 120));
  else
    buf = *(std::string *)(a2 + 112);
  v7 = ZoomCurveValue::operator[]((uint64_t)this, (__int128 *)&buf);
  UndoLogTransformationOfXValues((char **)v7, v8);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    operator delete(buf.__r_.__value_.__l.__data_);
  if (*(char *)(a2 + 159) < 0)
    std::string::__init_copy_ctor_external(&v15, *(const std::string::value_type **)(a2 + 136), *(_QWORD *)(a2 + 144));
  else
    v15 = *(std::string *)(a2 + 136);
  v9 = ZoomCurveValue::operator[]((uint64_t)this, (__int128 *)&v15);
  UndoLogTransformationOfXValues((char **)v9, v10);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v15.__r_.__value_.__l.__data_);
  if (*(char *)(a2 + 183) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 160), *(_QWORD *)(a2 + 168));
  else
    __p = *(std::string *)(a2 + 160);
  v11 = ZoomCurveValue::operator[]((uint64_t)this, (__int128 *)&__p);
  UndoLogTransformationOfXValues((char **)v11, v12);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(a2 + 192));
}

void sub_1B6549428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  caulk::pooled_semaphore_mutex *v29;

  std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(*(_QWORD **)(v28 + 8));
  caulk::pooled_semaphore_mutex::_unlock(v29);
  _Unwind_Resume(a1);
}

uint64_t DominanceZoom::SetFOV(DominanceZoom *this, float a2)
{
  NSObject *v4;
  NSObject *v5;
  PiecewiseLinearTransform **v6;
  float v7;
  float v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  unsigned int *v13;
  unsigned int v14;
  std::string __p;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (getAUHOAZoomLog(void)::onceToken != -1)
    dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
  v4 = getAUHOAZoomLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)"DominanceZoom.cpp";
    WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = 204;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%s:%i --", (uint8_t *)&__p, 0x12u);
  }
  caulk::pooled_semaphore_mutex::_lock((DominanceZoom *)((char *)this + 192));
  if (getAUHOAZoomLog(void)::onceToken != -1)
    dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
  v5 = getAUHOAZoomLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)"DominanceZoom.cpp";
    WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = 204;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEFAULT, "%s:%i locked", (uint8_t *)&__p, 0x12u);
  }
  *((float *)this + 47) = a2;
  if (*((char *)this + 135) < 0)
    std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 14), *((_QWORD *)this + 15));
  else
    __p = *(std::string *)((char *)this + 112);
  v6 = (PiecewiseLinearTransform **)ZoomCurveValue::operator[]((uint64_t)this, (__int128 *)&__p);
  v7 = *((float *)this + 47);
  v8 = logf(v7);
  if (v7 <= 0.0)
    v8 = -30.0;
  v9 = PiecewiseLinearTransform::tx(*v6, v8, v6[1]);
  v10 = 1.0;
  if (v9 <= 1.0)
    v10 = v9;
  v11 = v9 < 0.0;
  v12 = 0.0;
  if (!v11)
    v12 = v10;
  *((float *)this + 46) = v12;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (unsigned int *)((char *)this + 336);
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 + 1, v13));
  return caulk::pooled_semaphore_mutex::_unlock((DominanceZoom *)((char *)this + 192));
}

void sub_1B65496F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  caulk::pooled_semaphore_mutex *v14;

  caulk::pooled_semaphore_mutex::_unlock(v14);
  _Unwind_Resume(a1);
}

uint64_t DominanceZoom::SetZoomAmount(DominanceZoom *this, float a2)
{
  NSObject *v4;
  NSObject *v5;
  float v6;
  unsigned int *v7;
  unsigned int v8;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (getAUHOAZoomLog(void)::onceToken != -1)
    dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
  v4 = getAUHOAZoomLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136315394;
    v11 = "DominanceZoom.cpp";
    v12 = 1024;
    v13 = 217;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%s:%i --", (uint8_t *)&v10, 0x12u);
  }
  caulk::pooled_semaphore_mutex::_lock((DominanceZoom *)((char *)this + 192));
  if (getAUHOAZoomLog(void)::onceToken != -1)
    dispatch_once(&getAUHOAZoomLog(void)::onceToken, &__block_literal_global_22500);
  v5 = getAUHOAZoomLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUHOAZoomLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136315394;
    v11 = "DominanceZoom.cpp";
    v12 = 1024;
    v13 = 217;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEFAULT, "%s:%i locked", (uint8_t *)&v10, 0x12u);
  }
  v6 = 1.0;
  if (a2 <= 1.0)
    v6 = a2;
  if (a2 < 0.0)
    v6 = 0.0;
  *((float *)this + 46) = v6;
  v7 = (unsigned int *)((char *)this + 336);
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 + 1, v7));
  return caulk::pooled_semaphore_mutex::_unlock((DominanceZoom *)((char *)this + 192));
}

void sub_1B65498FC(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void AUsubMAEC::learnRate::~learnRate(AUsubMAEC::learnRate *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  if (this)
  {
    v2 = *(void **)this;
    if (*(_QWORD *)this)
    {
      free(v2);
      *(_QWORD *)this = 0;
    }
  }
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
  {
    free(v3);
    *((_QWORD *)this + 12) = 0;
  }
  v4 = (void *)*((_QWORD *)this + 1);
  if (v4)
  {
    free(v4);
    *((_QWORD *)this + 1) = 0;
  }
  v5 = (void *)*((_QWORD *)this + 13);
  if (v5)
  {
    free(v5);
    *((_QWORD *)this + 13) = 0;
  }
  v6 = (void *)*((_QWORD *)this + 2);
  if (v6)
  {
    free(v6);
    *((_QWORD *)this + 2) = 0;
  }
  v7 = (void *)*((_QWORD *)this + 20);
  if (v7)
  {
    free(v7);
    *((_QWORD *)this + 20) = 0;
  }
  v8 = (void *)*((_QWORD *)this + 21);
  if (v8)
  {
    free(v8);
    *((_QWORD *)this + 21) = 0;
  }
  v9 = (void *)*((_QWORD *)this + 22);
  if (v9)
  {
    free(v9);
    *((_QWORD *)this + 22) = 0;
  }
  v10 = (void *)*((_QWORD *)this + 24);
  if (v10)
  {
    free(v10);
    *((_QWORD *)this + 24) = 0;
  }
}

void AUsubMAEC::learnRate::initStatistics(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  float *v4;
  float *v5;
  int v6;
  int v7;
  size_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  float v17;
  float v18;
  void *v19;
  void *v20;
  float *v21;
  float *v22;
  int v23;
  char *v24;
  char *v25;
  char *v26;
  float *v27;
  float *v28;
  float v29;
  int32x2_t v30;
  float v31;
  std::bad_alloc *exception;
  std::bad_alloc *v33;
  float v34;
  float __A;

  *(_DWORD *)(a1 + 40) = a2[12];
  v3 = (int)a2[6];
  *(_DWORD *)(a1 + 44) = v3;
  *(_DWORD *)(a1 + 48) = a2[2];
  *(_DWORD *)(a1 + 52) = a2[3];
  *(_DWORD *)(a1 + 56) = a2[4];
  *(_DWORD *)(a1 + 60) = a2[5];
  *(_DWORD *)(a1 + 64) = a2[13];
  *(_DWORD *)(a1 + 68) = a2[14];
  *(_DWORD *)(a1 + 72) = a2[8];
  v4 = (float *)malloc_type_malloc(4 * v3, 0x2C8E6D5CuLL);
  v5 = v4;
  if ((_DWORD)v3 && !v4)
    goto LABEL_20;
  bzero(v4, 4 * v3);
  *(_QWORD *)a1 = v5;
  __A = 1.0;
  vDSP_vfill(&__A, v5, 1, *(int *)(a1 + 44));
  v6 = *(_DWORD *)(a1 + 44);
  v7 = 4 * v6;
  v8 = 4 * v6;
  v9 = malloc_type_malloc(v8, 0x2C8E6D5CuLL);
  v10 = v9;
  if (4 * v6)
  {
    if (!v9)
      goto LABEL_20;
  }
  bzero(v9, v7);
  *(_QWORD *)(a1 + 96) = v10;
  v11 = malloc_type_malloc(v7, 0x2C8E6D5CuLL);
  v12 = v11;
  if ((_DWORD)v8)
  {
    if (!v11)
      goto LABEL_20;
  }
  bzero(v11, v7);
  *(_QWORD *)(a1 + 8) = v12;
  v13 = malloc_type_malloc(v7, 0x2C8E6D5CuLL);
  v14 = v13;
  if ((_DWORD)v8)
  {
    if (!v13)
      goto LABEL_20;
  }
  bzero(v13, v7);
  *(_QWORD *)(a1 + 104) = v14;
  v15 = malloc_type_malloc(v7, 0x2C8E6D5CuLL);
  v16 = v15;
  if ((_DWORD)v8)
  {
    if (!v15)
      goto LABEL_20;
  }
  bzero(v15, v7);
  *(_QWORD *)(a1 + 16) = v16;
  *(int32x2_t *)(a1 + 112) = vdup_n_s32(0x30800002u);
  v17 = (float)*(int *)(a1 + 48);
  v18 = (float)(v17 / (float)*(int *)(a1 + 72)) * 0.25;
  *(float *)(a1 + 120) = v18;
  *(float *)(a1 + 124) = v18;
  *(float *)(a1 + 128) = v17 / 32000.0;
  *(_DWORD *)(a1 + 24) = 1065353216;
  *(_OWORD *)(a1 + 132) = xmmword_1B66A2900;
  *(_BYTE *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 28) = 0;
  v19 = malloc_type_malloc(v7, 0x2C8E6D5CuLL);
  v20 = v19;
  if ((_DWORD)v8)
  {
    if (!v19)
      goto LABEL_20;
  }
  bzero(v19, v7);
  *(_QWORD *)(a1 + 160) = v20;
  v21 = (float *)malloc_type_malloc(v7, 0x2C8E6D5CuLL);
  v22 = v21;
  if ((_DWORD)v8)
  {
    if (!v21)
      goto LABEL_20;
  }
  bzero(v21, v7);
  *(_QWORD *)(a1 + 168) = v22;
  v34 = 9.3132e-10;
  vDSP_vfill(&v34, v22, 1, *(int *)(a1 + 44));
  v23 = 8 * v6;
  v24 = (char *)malloc_type_malloc(8 * v6, 0x2C8E6D5CuLL);
  v25 = v24;
  if (v23)
  {
    if (!v24)
      goto LABEL_20;
  }
  bzero(v24, v23);
  v26 = &v25[4 * *(int *)(a1 + 44)];
  *(_QWORD *)(a1 + 176) = v25;
  *(_QWORD *)(a1 + 184) = v26;
  v27 = (float *)malloc_type_malloc(v8, 0x2C8E6D5CuLL);
  v28 = v27;
  if ((_DWORD)v8)
  {
    if (!v27)
    {
LABEL_20:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v33 = std::bad_alloc::bad_alloc(exception);
    }
  }
  bzero(v27, v8);
  *(_QWORD *)(a1 + 192) = v28;
  vDSP_vfill(&v34, v28, 1, *(int *)(a1 + 44));
  v29 = (float)*(int *)(a1 + 72);
  *(float *)v30.i32 = v29 / (float)*(int *)(a1 + 48);
  *(int32x2_t *)(a1 + 200) = vcvt_s32_f32(vmaxnm_f32(vrndm_f32(vdiv_f32((float32x2_t)0x4396000044E10000, (float32x2_t)vdup_lane_s32(v30, 0))), 0));
  v31 = expf((float)((float)*(int *)(a1 + 60) / v29) / -0.03);
  *(float *)(a1 + 208) = v31;
  *(float *)(a1 + 212) = 1.0 - v31;
}

void AUsubMAEC::learnRate::adaptFilter(const float **this, DSPSplitComplex a2, AUsubMAEC::dftBuffer *a3, AUsubMAEC::myFilter *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  uint64_t v21;
  float *v22;
  const float **v23;
  const float *v24;
  vDSP_Length v25;
  float *v26;
  uint64_t v27;
  float *v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  float *v37;
  float *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  int v45;
  int v46;
  int v47;
  float *v48;
  float *v49;
  uint64_t v50;
  float *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t i;
  int v55;
  int v56;
  int v57;
  float *v58;
  float *v59;
  uint64_t v60;
  uint64_t v61;
  float *v62;
  uint64_t v63;
  int v64;
  float *v65;
  int *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int *v74;
  uint64_t v75;
  int v76;
  float *v77;
  float *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int *v83;
  int v84;
  float *v85;
  float *v86;
  uint64_t v87;
  float *imagp;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  vDSP_Length v93;
  uint64_t v94;
  uint64_t v95;
  int *v96;
  _DWORD *v97;
  uint64_t v98;
  uint64_t v99;
  float *v100;
  DSPSplitComplex v101;
  DSPSplitComplex __D;
  DSPSplitComplex __C;
  DSPSplitComplex __A;
  uint64_t v105;

  imagp = a2.imagp;
  v105 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)a4;
  v92 = *((_QWORD *)a4 + 1);
  v7 = *((_QWORD *)a4 + 2);
  v6 = *((_QWORD *)a4 + 3);
  v8 = *((_QWORD *)a4 + 4);
  v98 = *((_QWORD *)a4 + 5);
  v9 = *(_QWORD *)a3;
  v94 = *((_QWORD *)a3 + 1);
  v95 = v9;
  v10 = (_DWORD *)*((_QWORD *)a3 + 5);
  v96 = (int *)*((_QWORD *)a3 + 4);
  MEMORY[0x1E0C80A78](this);
  v12 = (float *)((char *)&v87 - ((v11 + 15) & 0x7FFFFFFF0));
  MEMORY[0x1E0C80A78](v13);
  v15 = (float *)((char *)&v87 - v14);
  v93 = *(int *)(v16 + 64) * (uint64_t)v17;
  MEMORY[0x1E0C80A78](v16);
  v19 = (float *)((char *)&v87 - ((v18 + 15) & 0x7FFFFFFF0));
  MEMORY[0x1E0C80A78](v20);
  v22 = (float *)((char *)&v87 - v21);
  vDSP_vmul(v24, 1, *v23, 1, v12, 1, v25);
  vDSP_vmul(imagp, 1, *this, 1, v15, 1, *((int *)this + 11));
  v101.realp = v12 + 1;
  v101.imagp = v15 + 1;
  if (*((int *)this + 10) >= 1)
  {
    v26 = v22;
    v27 = 0;
    v90 = v7;
    v91 = v5;
    v99 = v6;
    v100 = v22;
    v89 = v8;
    v97 = v10;
    do
    {
      v28 = *(float **)(v94 + 8 * v27);
      __A.realp = *(float **)(v95 + 8 * v27);
      __A.imagp = v28;
      __C.realp = v19;
      __C.imagp = v26;
      v29 = v27;
      vDSP_zvconj(&__A, 1, &__C, 1, v93);
      v30 = v92;
      v31 = v96;
      if (*((int *)this + 16) >= 1)
      {
        v32 = v5;
        v33 = 0;
        do
        {
          v34 = *((_DWORD *)this + 11);
          v35 = v34 * v31[v33] + 1;
          v36 = v34 * v33 + 1;
          v37 = (float *)(*(_QWORD *)(v32 + 8 * v29) + 4 * v36);
          v38 = (float *)(*(_QWORD *)(v30 + 8 * v29) + 4 * v36);
          __D.realp = v37;
          __D.imagp = v38;
          __A.realp = &v19[v35];
          __A.imagp = &v100[v35];
          vDSP_zvma(&v101, 1, &__A, 1, &__D, 1, &__D, 1, *((int *)this + 14));
          ++v33;
        }
        while (v33 < *((int *)this + 16));
      }
      LODWORD(v39) = *((_DWORD *)this + 17);
      v40 = v98;
      v26 = v100;
      v41 = v29;
      if ((_DWORD)v39)
      {
        v42 = v90;
        if ((int)v39 >= 1)
        {
          v43 = 0;
          v44 = v97;
          do
          {
            v45 = *((_DWORD *)this + 11);
            v46 = v45 * v44[v43];
            v47 = v45 * v43 + 1;
            v48 = (float *)(*(_QWORD *)(v42 + 8 * v41) + 4 * v47);
            v49 = (float *)(*(_QWORD *)(v99 + 8 * v41) + 4 * v47);
            __D.realp = v48;
            __D.imagp = v49;
            __A.realp = &v19[v46];
            __A.imagp = &v26[v46];
            v50 = v42;
            v51 = v26;
            v52 = v41;
            vDSP_zvma(&v101, 1, &__A, 1, &__D, 1, &__D, 1, *((int *)this + 14));
            v41 = v52;
            v42 = v50;
            v26 = v51;
            ++v43;
            v39 = *((int *)this + 17);
          }
          while (v43 < v39);
          v53 = v89;
          v40 = v98;
          v31 = v96;
          if ((int)v39 >= 1)
          {
            for (i = 0; i < v39; ++i)
            {
              v55 = *((_DWORD *)this + 11);
              v56 = v55 * v97[i] + 2;
              v57 = v55 * i + 1;
              v58 = (float *)(*(_QWORD *)(v53 + 8 * v41) + 4 * v57);
              v59 = (float *)(*(_QWORD *)(v40 + 8 * v41) + 4 * v57);
              __D.realp = v58;
              __D.imagp = v59;
              __A.realp = &v19[v56];
              __A.imagp = &v26[v56];
              vDSP_zvma(&v101, 1, &__A, 1, &__D, 1, &__D, 1, *((int *)this + 14));
              v41 = v52;
              v26 = v51;
              v40 = v98;
              v39 = *((int *)this + 17);
            }
            v31 = v96;
            v42 = v50;
          }
          goto LABEL_16;
        }
      }
      else
      {
        v42 = v90;
      }
      v53 = v89;
LABEL_16:
      v60 = *((unsigned int *)this + 16);
      v5 = v91;
      if ((int)v60 >= 1)
      {
        v61 = *((int *)this + 11);
        v62 = *(float **)(v91 + 8 * v41);
        v63 = *((int *)this + 13);
        do
        {
          v64 = *v31++;
          v65 = &v19[(int)v61 * v64];
          *v62 = *v62 + (float)(*v12 * *v65);
          v62[v63] = v62[v63] + (float)(v12[v63] * v65[v63]);
          v62 += v61;
          --v60;
        }
        while (v60);
      }
      v66 = v97;
      if ((int)v39 >= 1)
      {
        v67 = 0;
        v68 = *((int *)this + 11);
        v69 = *(_QWORD *)(v42 + 8 * v41);
        v70 = *(_QWORD *)(v99 + 8 * v41);
        v71 = *((int *)this + 13);
        v72 = v71 - 1;
        v39 = v39;
        v73 = 4 * v68;
        v74 = v97;
        v75 = v39;
        do
        {
          v76 = *v74++;
          v77 = &v19[(int)v68 * v76];
          v78 = &v26[(int)v68 * v76];
          *(float *)(v69 + v67) = *(float *)(v69 + v67) + (float)((float)(*v12 * v77[1]) - (float)(*v15 * v78[1]));
          *(float *)(v70 + v67) = *(float *)(v70 + v67) + (float)((float)(*v15 * v77[1]) + (float)(*v12 * v78[1]));
          *(float *)(v69 + 4 * v71 + v67) = *(float *)(v69 + 4 * v71 + v67)
                                          + (float)((float)(v12[v71] * v77[v72]) - (float)(v15[v71] * v78[v72]));
          *(float *)(v70 + 4 * v71 + v67) = *(float *)(v70 + 4 * v71 + v67)
                                          + (float)((float)(v15[v71] * v77[v72]) + (float)(v12[v71] * v78[v72]));
          v67 += v73;
          --v75;
        }
        while (v75);
        v79 = 0;
        v80 = *(_QWORD *)(v53 + 8 * v41);
        v81 = *(_QWORD *)(v40 + 8 * v41);
        v82 = (int)v71 - 2;
        v83 = v66;
        do
        {
          v84 = *v83++;
          v85 = &v19[(int)v68 * v84];
          v86 = &v26[(int)v68 * v84];
          *(float *)(v80 + v79) = *(float *)(v80 + v79) + (float)((float)(*v12 * v85[2]) - (float)(*v15 * v86[2]));
          *(float *)(v81 + v79) = *(float *)(v81 + v79) + (float)((float)(*v15 * v85[2]) + (float)(*v12 * v86[2]));
          *(float *)(v80 + 4 * v71 + v79) = *(float *)(v80 + 4 * v71 + v79)
                                          + (float)((float)(v12[v71] * v85[v82]) - (float)(v15[v71] * v86[v82]));
          *(float *)(v81 + 4 * v71 + v79) = *(float *)(v81 + 4 * v71 + v79)
                                          + (float)((float)(v15[v71] * v85[v82]) + (float)(v12[v71] * v86[v82]));
          v79 += v73;
          --v39;
        }
        while (v39);
      }
      v27 = v41 + 1;
    }
    while (v27 < *((int *)this + 10));
  }
}

float AUsubMAEC::learnRate::crossCorrSpec(AUsubMAEC::learnRate *this, const float *a2, const float *a3, const float *a4, float *a5, float *a6, float *a7)
{
  uint64_t v11;
  float *v12;
  int v13;
  vDSP_Length v14;
  const float *v15;
  const float *v16;
  float v17;
  float v18;
  float result;
  _QWORD __C[2];

  __C[1] = *MEMORY[0x1E0C80C00];
  __C[0] = 0;
  MEMORY[0x1E0C80A78](this);
  v12 = (float *)((char *)__C - v11);
  v14 = v13;
  vDSP_vsub(v16, 1, v15, 1, (float *)((char *)__C - v11), 1, v13);
  vDSP_svesq(v12, 1, (float *)__C + 1, v14);
  vDSP_vsbm((const float *)this, 1, a2, 1, v12, 1, v12, 1, v14);
  vDSP_sve(v12, 1, (float *)__C, v14);
  *(float *)__C = *(float *)__C + 8.6736e-19;
  v17 = *(float *)__C;
  *((float *)__C + 1) = *((float *)__C + 1) + 8.6736e-19;
  v18 = sqrtf(*((float *)__C + 1));
  *a6 = v18;
  result = v17 / v18;
  *a5 = result;
  return result;
}

float AUsubMAEC::learnRate::updateTimeStatistics2(AUsubMAEC::learnRate *this, const float *__A, const float *a3, const float *a4, const float *a5)
{
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float result;
  uint64_t __C;

  __C = 0;
  vDSP_svesq(__A, 1, (float *)&__C + 1, *((int *)this + 11));
  vDSP_svesq(a3, 1, (float *)&__C, *((int *)this + 11));
  *((float *)this + 21) = (float)(*((float *)&__C + 1) + *(float *)&__C) * (float)*((int *)this + 12);
  vDSP_svesq(a4, 1, (float *)&__C + 1, *((int *)this + 11));
  vDSP_svesq(a5, 1, (float *)&__C, *((int *)this + 11));
  v9 = (float)*((int *)this + 12);
  v10 = (float)(*((float *)&__C + 1) + *(float *)&__C) * v9;
  v11 = *((float *)this + 21);
  *((float *)this + 22) = v11;
  *((float *)this + 23) = v10;
  v12 = (float)(v9 * 100.0) * 9.3132e-10;
  if (v11 < v12)
    *((float *)this + 21) = v12;
  v13 = v11 / (*((float *)this + 20) + 1.0e-20);
  *((float *)this + 39) = v13;
  v14 = v13 + 1.0e-20;
  result = log10f(v14) * 10.0;
  *((float *)this + 8) = result;
  return result;
}

void AUsubMAEC::learnRate::getLeakage(AUsubMAEC::learnRate *this, float *a2, float *a3, float *a4, float *a5)
{
  vDSP_Length v8;
  float *v9;
  vDSP_Length v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  double v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  uint64_t v25;
  DSPSplitComplex __A;

  v25 = 0;
  __A.realp = a2;
  v8 = *((int *)this + 11);
  v9 = (float *)*((_QWORD *)this + 12);
  __A.imagp = a3;
  vDSP_zvmags(&__A, 1, v9, 1, v8);
  v10 = *((int *)this + 11);
  v11 = (float *)*((_QWORD *)this + 13);
  __A.realp = a4;
  __A.imagp = a5;
  vDSP_zvmags(&__A, 1, v11, 1, v10);
  AUsubMAEC::learnRate::crossCorrSpec(*((AUsubMAEC::learnRate **)this + 12), *((const float **)this + 1), *((const float **)this + 13), *((const float **)this + 2), (float *)&v25 + 1, (float *)&v25, (float *)*((unsigned int *)this + 11));
  v12 = *((float *)this + 30);
  v13 = *((float *)this + 31) * *((float *)this + 23);
  v14 = *((float *)this + 21);
  if (v13 > (float)(v12 * v14))
    v13 = v12 * v14;
  v15 = v13 / v14;
  if (v14 >= 9.3132e-19)
    v16 = v15;
  else
    v16 = *((float *)this + 30);
  v17 = fmin(v14 / (*((float *)this + 20) + 1.0e-20), 1.0);
  v18 = log10(v17 + 1.0e-20);
  v19 = (float)(v16 * *((float *)&v25 + 1)) + (float)((float)(1.0 - v16) * *((float *)this + 28));
  v20 = (float)(v16 * *(float *)&v25) + (float)((float)(1.0 - v16) * *((float *)this + 29));
  if (v20 < 9.3132e-10)
    v20 = 9.3132e-10;
  if (v19 >= (float)(v20 * 0.005))
    v21 = (float)(v16 * *((float *)&v25 + 1)) + (float)((float)(1.0 - v16) * *((float *)this + 28));
  else
    v21 = v20 * 0.005;
  if (v21 <= v20)
    v22 = v21;
  else
    v22 = v20;
  *((float *)this + 39) = v17;
  v23 = v18 * 10.0;
  *((float *)this + 8) = v23;
  *((float *)this + 28) = v19;
  *((float *)this + 29) = v20;
  if (v19 < (float)(v20 * 0.005) || v21 > v20)
    *((float *)this + 28) = v22;
  *((float *)this + 33) = v22 / v20;
  VPEchoGateV3::GatesmoothPowerSpectrum(*((VPEchoGateV3 **)this + 1), *((const float **)this + 12), (const float *)*((unsigned int *)this + 11), *((float *)this + 32));
  VPEchoGateV3::GatesmoothPowerSpectrum(*((VPEchoGateV3 **)this + 2), *((const float **)this + 13), (const float *)*((unsigned int *)this + 11), *((float *)this + 32));
  *((_DWORD *)this + 34) = 1056964608;
  if (*((float *)this + 6) < 0.85 && *((_BYTE *)this + 148) && !*((_BYTE *)this + 28))
    *((_DWORD *)this + 34) = 0;
  AUsubMAEC::learnRate::getAdaptationRate(this);
  if (!*((_BYTE *)this + 148) && *((float *)this + 38) > 8.0 && *((float *)this + 33) > *((float *)this + 36))
    *((_BYTE *)this + 148) = 1;
}

float AUsubMAEC::learnRate::getAdaptationRate(AUsubMAEC::learnRate *this)
{
  uint64_t v2;
  float *v3;
  uint64_t v4;
  uint64_t v5;
  float *v6;
  vDSP_Length v7;
  double v8;
  float v9;
  vDSP_Length v10;
  float v11;
  float v12;
  float v13;
  _BYTE v15[12];
  float v16;
  float __C;
  float __B;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v16 = 0.0;
  __C = 0.1;
  if (*((_BYTE *)this + 148))
  {
    __B = *((float *)this + 33) + *((float *)this + 33);
    MEMORY[0x1E0C80A78](this);
    v3 = (float *)&v15[-((v2 + 15) & 0x7FFFFFFF0)];
    MEMORY[0x1E0C80A78](v4);
    v6 = (float *)&v15[-((v5 + 15) & 0x7FFFFFFF0)];
    vDSP_vsmul(*((const float **)this + 13), 1, &__B, v3, 1, v7);
    __B = 9.0e-10;
    vDSP_vsadd(*((const float **)this + 12), 1, &__B, v6, 1, *((int *)this + 11));
    vDSP_vmin(v3, 1, v6, 1, v3, 1, *((int *)this + 11));
    __B = 0.35;
    vDSP_vsmul(v3, 1, &__B, v3, 1, *((int *)this + 11));
    __B = *((float *)this + 34) * 0.3;
    vDSP_vsma(v6, 1, &__B, v3, 1, v3, 1, *((int *)this + 11));
    vDSP_vdiv(v6, 1, v3, 1, *(float **)this, 1, *((int *)this + 11));
    v8 = *((float *)this + 6);
    if (v8 < 0.85 && !*((_BYTE *)this + 28))
      vDSP_vclip(*(const float **)this, 1, &v16, &__C, *(float **)this, 1, *((int *)this + 11));
  }
  else
  {
    __B = 0.0;
    v9 = *((float *)this + 19);
    v10 = *((int *)this + 11);
    if (v9 > (float)((float)((float)((int)v10 - 1) * 2000.0) * 9.3132e-10))
    {
      v11 = v9 * 0.25;
      v12 = *((float *)this + 21);
      if (v11 > (float)(v12 * 0.25))
        v11 = v12 * 0.25;
      v13 = v11 / (v12 + 1.0e-20);
      __B = v13;
    }
    vDSP_vfill(&__B, *(float **)this, 1, v10);
    *(float *)&v8 = *((float *)this + 38) + __B;
    *((_DWORD *)this + 38) = LODWORD(v8);
  }
  return *(float *)&v8;
}

float AUsubMAEC::learnRate::micEchoXcorrForDTD(AUsubMAEC::learnRate *this, DSPSplitComplex a2, DSPSplitComplex a3)
{
  uint64_t v4;
  float *v5;
  uint64_t v6;
  vDSP_Length v7;
  float result;
  uint64_t v9;
  DSPSplitComplex v10;
  DSPSplitComplex __A;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  __A = a2;
  v10 = a3;
  MEMORY[0x1E0C80A78](this);
  v5 = (float *)((char *)&v9 - ((v4 + 15) & 0x7FFFFFFF0));
  vDSP_zvmags(&__A, 1, *(float **)(v6 + 160), 1, v7);
  vDSP_vsmul(*((const float **)this + 20), 1, (const float *)this + 53, v5, 1, *((int *)this + 11));
  vDSP_vsma(*((const float **)this + 21), 1, (const float *)this + 52, v5, 1, *((float **)this + 21), 1, *((int *)this + 11));
  vDSP_zvcmul(&v10, 1, &__A, 1, (const DSPSplitComplex *)this + 11, 1, *((int *)this + 11));
  vDSP_zvabs((const DSPSplitComplex *)this + 11, 1, v5, 1, *((int *)this + 11));
  vDSP_vsmul(v5, 1, (const float *)this + 53, v5, 1, *((int *)this + 11));
  vDSP_vsma(*((const float **)this + 24), 1, (const float *)this + 52, v5, 1, *((float **)this + 24), 1, *((int *)this + 11));
  HIDWORD(v9) = 629145252;
  vDSP_vsadd(*((const float **)this + 21), 1, (const float *)&v9 + 1, v5, 1, *((int *)this + 11));
  vDSP_vdiv(v5, 1, *((const float **)this + 24), 1, v5, 1, *((int *)this + 11));
  vDSP_meanv(&v5[*((int *)this + 51)], 1, (float *)this + 6, *((_DWORD *)this + 50) - *((_DWORD *)this + 51) + 1);
  result = fmaxf(fminf(*((float *)this + 6), 1.0), 0.0);
  *((float *)this + 6) = result;
  return result;
}

void IR::FixedIntegerDelay::reset(IR::FixedIntegerDelay *this)
{
  void *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;

  v2 = (void *)*((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2) - (_QWORD)v2;
  if (v3 >= 1)
    bzero(v2, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
  v4 = (void *)*((_QWORD *)this + 4);
  v5 = *((_QWORD *)this + 5) - (_QWORD)v4;
  if (v5 >= 1)
    bzero(v4, 4 * (((unint64_t)v5 >> 2) - ((unint64_t)v5 > 3)) + 4);
}

IR::FixedIntegerDelay *IR::FixedIntegerDelay::FixedIntegerDelay(IR::FixedIntegerDelay *this, unsigned int a2, int a3)
{
  unint64_t v5;
  int v7;
  int v8;

  *(_DWORD *)this = a2;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  if (a2)
  {
    v8 = 0;
    std::vector<float>::resize((uint64_t)this + 8, a2, &v8);
    if (a3)
    {
      v5 = *(unsigned int *)this;
      v7 = 0;
      std::vector<float>::resize((uint64_t)this + 32, v5, &v7);
    }
  }
  IR::FixedIntegerDelay::reset(this);
  return this;
}

void sub_1B654AD34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 40) = v5;
    operator delete(v5);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

__n128 IR::FixedIntegerDelay::process(IR::FixedIntegerDelay *this, float *__src, float *__dst, unsigned int a4)
{
  uint64_t v8;
  char *v9;
  float *v10;
  const float *v11;
  size_t v12;
  uint64_t v13;
  __n128 result;
  void *v15;
  const void *v16;
  float *v17;
  size_t v18;
  void *v19;
  __int128 v20;
  uint64_t v21;

  if (a4)
  {
    v8 = *(unsigned int *)this;
    if ((_DWORD)v8)
    {
      v9 = (char *)*((_QWORD *)this + 1);
      if (v9 == *((char **)this + 2))
        __assert_rtn("process", "FixedIntegerDelay.cpp", 40, "!mPrimaryDelayBuf.empty()");
      if (v8 > a4)
      {
        if (__src != __dst)
        {
          memcpy(__dst, v9, 4 * a4);
          memmove(*((void **)this + 1), (const void *)(*((_QWORD *)this + 1) + 4 * a4), 4 * (*(_DWORD *)this - a4));
          v10 = (float *)(*((_QWORD *)this + 1) + 4 * *(unsigned int *)this - 4 * a4);
          v11 = __src;
          v12 = 4 * a4;
LABEL_12:
          memcpy(v10, v11, v12);
          return result;
        }
        v15 = (void *)*((_QWORD *)this + 4);
        if (v15 == *((void **)this + 5))
          __assert_rtn("process", "FixedIntegerDelay.cpp", 56, "!mSecondaryDelayBuf.empty()");
        memcpy(v15, &v9[4 * a4], 4 * (v8 - a4));
        memcpy((void *)(*((_QWORD *)this + 4) + 4 * *(unsigned int *)this - 4 * a4), __src, 4 * a4);
        v16 = (const void *)*((_QWORD *)this + 1);
        v17 = __src;
        v18 = 4 * a4;
        goto LABEL_17;
      }
      if (__src == __dst)
      {
        v19 = (void *)*((_QWORD *)this + 4);
        if (v19 == *((void **)this + 5))
          __assert_rtn("process", "FixedIntegerDelay.cpp", 44, "!mSecondaryDelayBuf.empty()");
        memcpy(v19, &__src[a4 - v8], 4 * v8);
        memmove(&__src[*(unsigned int *)this], __src, 4 * (a4 - *(_DWORD *)this));
        v16 = (const void *)*((_QWORD *)this + 1);
        v18 = 4 * *(unsigned int *)this;
        v17 = __src;
LABEL_17:
        memcpy(v17, v16, v18);
        result = *((__n128 *)this + 2);
        v20 = *(_OWORD *)((char *)this + 8);
        *(__n128 *)((char *)this + 8) = result;
        *((_OWORD *)this + 2) = v20;
        v21 = *((_QWORD *)this + 3);
        *((_QWORD *)this + 3) = *((_QWORD *)this + 6);
        *((_QWORD *)this + 6) = v21;
        return result;
      }
      memcpy(__dst, v9, 4 * v8);
      memcpy(*((void **)this + 1), &__src[a4 - *(unsigned int *)this], 4 * *(unsigned int *)this);
      v13 = *(unsigned int *)this;
      v10 = &__dst[v13];
      v12 = 4 * (a4 - v13);
    }
    else
    {
      if (__src == __dst)
        return result;
      v12 = 4 * a4;
      v10 = __dst;
    }
    v11 = __src;
    goto LABEL_12;
  }
  return result;
}

void AUCarter::~AUCarter(IR::DelayLine **this)
{
  AUCarter::~AUCarter(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  *this = (IR::DelayLine *)&off_1E69E9E18;
  std::unique_ptr<IR::DelayLine>::reset[abi:ne180100](this + 89, 0);
  std::unique_ptr<IR::DelayLine>::reset[abi:ne180100](this + 68, 0);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)this);
}

uint64_t AUCarter::Initialize(AUCarter *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  double v7;
  int v8;
  double v9;

  v2 = *((_QWORD *)this + 15);
  if (v2)
    LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  else
    v3 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  if ((_DWORD)v3 != 1)
    return 4294956428;
  v4 = *((_QWORD *)this + 21);
  if (v4)
    LODWORD(v5) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  else
    v5 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
  if ((_DWORD)v5 != 1
    || *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUCarter *)((char *)this + 80), 0) + 108) != 6
    || *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUCarter *)((char *)this + 128), 0) + 108) != 2)
  {
    return 4294956428;
  }
  v6 = *(double *)(ausdk::AUScope::SafeGetElement((AUCarter *)((char *)this + 128), 0) + 80);
  if (*((double *)this + 67) != v6)
  {
    *((double *)this + 67) = v6;
    (*(void (**)(AUCarter *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 432))(this, 12, 0, 0);
  }
  v7 = (*(double (**)(AUCarter *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
  v8 = *((_DWORD *)this + 84);
  v9 = IR::HilbertIIR::initialize((IR::DelayLine **)this + 68, v7, v8);
  IR::HilbertIIR::initialize((IR::DelayLine **)this + 89, v9, v8);
  return 0;
}

void AUCarter::Cleanup(IR::DelayLine **this)
{
  std::unique_ptr<IR::DelayLine>::reset[abi:ne180100](this + 68, 0);
  vDSP_biquad_DestroySetup(this[69]);
  std::unique_ptr<IR::DelayLine>::reset[abi:ne180100](this + 89, 0);
  vDSP_biquad_DestroySetup(this[90]);
}

uint64_t AUCarter::Reset(AUCarter *this)
{
  IR::DelayLine *v2;
  __int128 v3;
  IR::DelayLine *v4;

  v2 = (IR::DelayLine *)*((_QWORD *)this + 68);
  if (v2)
    IR::DelayLine::reset(v2);
  *((_QWORD *)this + 88) = 0;
  v3 = 0uLL;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 35) = 0u;
  v4 = (IR::DelayLine *)*((_QWORD *)this + 89);
  if (v4)
  {
    IR::DelayLine::reset(v4);
    v3 = 0uLL;
  }
  *((_QWORD *)this + 109) = 0;
  *(_OWORD *)((char *)this + 840) = v3;
  *(_OWORD *)((char *)this + 856) = v3;
  *(_OWORD *)((char *)this + 808) = v3;
  *(_OWORD *)((char *)this + 824) = v3;
  *(_OWORD *)((char *)this + 776) = v3;
  *(_OWORD *)((char *)this + 792) = v3;
  *(_OWORD *)((char *)this + 744) = v3;
  *(_OWORD *)((char *)this + 760) = v3;
  *(_OWORD *)((char *)this + 728) = v3;
  return 0;
}

uint64_t AUCarter::GetPropertyInfo(AUCarter *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    result = 0;
    *a6 = 1;
    *a5 = 4;
  }
  return result;
}

uint64_t AUCarter::GetProperty(AUCarter *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    result = 0;
    *a5 = *((unsigned __int8 *)this + 528);
  }
  return result;
}

uint64_t AUCarter::SetProperty(AUCarter *this, int a2, int a3, unsigned int a4, _DWORD *a5, unsigned int a6)
{
  uint64_t result;
  int v8;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    if (a6 >= 4)
    {
      v8 = *a5 != 0;
      if (*((unsigned __int8 *)this + 528) == v8)
      {
        return 0;
      }
      else
      {
        if (*((_BYTE *)this + 17))
          (*(void (**)(AUCarter *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
        result = 0;
        *((_BYTE *)this + 528) = v8;
      }
    }
    else
    {
      return 4294956445;
    }
  }
  return result;
}

uint64_t AUCarter::SetParameter(AUCarter *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  return 0;
}

uint64_t AUCarter::CanScheduleParameters(AUCarter *this)
{
  return 0;
}

uint64_t AUCarter::ProcessBufferLists(AUCarter *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, vDSP_Length a5)
{
  int v9;
  void *mData;
  const void *v11;
  const float *v12;
  const float *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  IR::DelayLine *v17;
  IR::DelayLine *v18;
  uint64_t v19;
  IR::DelayLine *v20;
  uint64_t v21;
  IR::DelayLine *v22;
  uint64_t v23;
  const float *v24;
  float v25;
  float v26;
  float v27;
  float __B;
  float *v29[2];

  v29[1] = *(float **)MEMORY[0x1E0C80C00];
  if (a3->mNumberBuffers != 6 || a4->mNumberBuffers != 2)
    return 4294956428;
  if ((_DWORD)a5)
  {
    v9 = *((unsigned __int8 *)this + 528);
    mData = a3->mBuffers[0].mData;
    v11 = *(const void **)&a3[1].mBuffers[0].mNumberChannels;
    v12 = *(const float **)&a3[2].mNumberBuffers;
    v13 = *(const float **)&a3[3].mBuffers[0].mNumberChannels;
    v24 = *(const float **)&a3[4].mNumberBuffers;
    v14 = a4->mBuffers[0].mData;
    v15 = *(void **)&a4[1].mBuffers[0].mNumberChannels;
    __B = 0.70711;
    memcpy(v14, mData, 4 * a5);
    vDSP_vsma(v12, 1, &__B, (const float *)v14, 1, (float *)v14, 1, a5);
    memcpy(v15, v11, 4 * a5);
    vDSP_vsma(v12, 1, &__B, (const float *)v15, 1, (float *)v15, 1, a5);
    if (v9)
    {
      vDSP_vsma(v13, 1, &__B, (const float *)v14, 1, (float *)v14, 1, a5);
      vDSP_vsma(v24, 1, &__B, (const float *)v15, 1, (float *)v15, 1, a5);
      v17 = (IR::DelayLine *)*((_QWORD *)this + 68);
      v29[0] = (float *)v14;
      IR::DelayLine::process(v17, (const float *)v14, v29, a5);
      v18 = (IR::DelayLine *)*((_QWORD *)this + 89);
      v29[0] = (float *)v15;
      IR::DelayLine::process(v18, (const float *)v15, v29, a5);
    }
    else
    {
      MEMORY[0x1E0C80A78](v16);
      v19 = (4 * a5 + 15) & 0x7FFFFFFF0;
      v20 = (IR::DelayLine *)*((_QWORD *)this + 68);
      v29[0] = (float *)v14;
      IR::DelayLine::process(v20, (const float *)v14, v29, a5);
      vDSP_biquad(*((const vDSP_biquad_SetupStruct **)this + 69), (float *)this + 140, v13, 1, (float *)((char *)&v23 - v19), 1, a5);
      MEMORY[0x1E0C80A78](v21);
      v22 = (IR::DelayLine *)*((_QWORD *)this + 89);
      v29[0] = (float *)v15;
      IR::DelayLine::process(v22, (const float *)v15, v29, a5);
      vDSP_biquad(*((const vDSP_biquad_SetupStruct **)this + 90), (float *)this + 182, v24, 1, (float *)((char *)&v23 - v19), 1, a5);
      LODWORD(v29[0]) = 1063202038;
      v27 = -0.4899;
      vDSP_vsma((const float *)((char *)&v23 - v19), 1, (const float *)v29, (const float *)v14, 1, (float *)v14, 1, a5);
      vDSP_vsma((const float *)((char *)&v23 - v19), 1, &v27, (const float *)v15, 1, (float *)v15, 1, a5);
      v26 = 0.4899;
      v25 = -0.87178;
      vDSP_vsma((const float *)((char *)&v23 - v19), 1, &v26, (const float *)v14, 1, (float *)v14, 1, a5);
      vDSP_vsma((const float *)((char *)&v23 - v19), 1, &v25, (const float *)v15, 1, (float *)v15, 1, a5);
    }
  }
  return 0;
}

uint64_t AUCarter::ProcessMultipleBufferLists(AUCarter *this, unsigned int *a2, unsigned int a3, int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7)
{
  BOOL v7;
  BOOL v8;

  if (a4 == 1 && a5 && (*a5 ? (v7 = a6 == 1) : (v7 = 0), v7 ? (v8 = a7 == 0) : (v8 = 1), !v8 && *a7))
    return (*(uint64_t (**)(AUCarter *, unsigned int *))(*(_QWORD *)this + 176))(this, a2);
  else
    return 4294956418;
}

uint64_t AUCarter::Render(AUCarter *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  uint64_t Element;
  uint64_t v10;
  ausdk::AUInputElement *v11;
  uint64_t result;
  uint64_t BufferList;
  uint64_t v14;
  unsigned int v15;

  v8 = (AUCarter *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AUCarter *)((char *)this + 80), 0);
  v10 = ausdk::AUScope::SafeGetElement((AUCarter *)((char *)this + 128), 0);
  v15 = 0;
  v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  result = ausdk::AUInputElement::PullInput(v11, &v15, a3, 0, a4);
  if (!(_DWORD)result)
  {
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    v14 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    return (*(uint64_t (**)(AUCarter *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 176))(this, a2, BufferList, v14, a4);
  }
  return result;
}

uint64_t AUCarter::GetParameterList(AUCarter *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;

  if (a2)
    return 4294956430;
  result = 0;
  *a4 = 0;
  return result;
}

uint64_t AUCarter::GetParameterInfo(AUCarter *this, unsigned int a2, unsigned int a3, AudioUnitParameterInfo *a4)
{
  return 4294956418;
}

double AUCarter::GetLatency(AUCarter *this)
{
  double v1;
  double v2;
  BOOL v3;
  double result;

  v1 = *(double *)(ausdk::AUScope::SafeGetElement((AUCarter *)((char *)this + 128), 0) + 80);
  v2 = 34.5 / v1;
  v3 = v1 <= 8000.0;
  result = 0.0043125;
  if (!v3)
    return v2;
  return result;
}

double AUCarter::GetTailTime(AUCarter *this)
{
  return 0.1;
}

uint64_t AUCarter::SupportsTail(AUCarter *this)
{
  return 1;
}

BOOL AUCarter::StreamFormatWritable(AUCarter *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUCarter::SupportedNumChannels(AUCarter *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUCarter::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

uint64_t AUCarter::ValidFormat(AUCarter *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  int v5;
  _BOOL4 v6;
  BOOL v7;
  _BOOL4 v8;

  v5 = (int)a2;
  if (ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2))
    v6 = (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
  else
    v6 = 0;
  if (v5 == 2)
  {
    v7 = a4->mChannelsPerFrame == 2;
  }
  else
  {
    if (v5 != 1)
      goto LABEL_12;
    v7 = a4->mChannelsPerFrame == 6;
  }
  if (!v7)
    v6 = 0;
LABEL_12:
  v8 = a4->mSampleRate >= 44100.0;
  if (a4->mSampleRate > 48000.0)
    v8 = 0;
  return v8 & v6;
}

double IR::HilbertIIR::initialize(IR::DelayLine **this, double a2, int a3)
{
  IR::DelayLine *v5;
  double result;

  v5 = (IR::DelayLine *)operator new();
  IR::DelayLine::DelayLine((uint64_t)v5, 45, 6, 0xAuLL, 0, a3);
  std::unique_ptr<IR::DelayLine>::reset[abi:ne180100](this, v5);
  IR::DelayLine::setDelay((uint64_t)*this, 29.5);
  this[1] = vDSP_biquad_CreateSetup(IR::HilbertIIR::PSFilter::kBiquadCoefficients, 0x12uLL);
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  this[20] = 0;
  return result;
}

void sub_1B654B8D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10B0C4057A31370);
  _Unwind_Resume(a1);
}

void AULimitWindBoost::~AULimitWindBoost(AULimitWindBoost *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E69EA068;
  v2 = (void *)*((_QWORD *)this + 123);
  if (v2)
  {
    *((_QWORD *)this + 124) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 120);
  if (v3)
  {
    *((_QWORD *)this + 121) = v3;
    operator delete(v3);
  }
  LimitWindBoost::~LimitWindBoost((AULimitWindBoost *)((char *)this + 528));
  ausdk::AUBase::~AUBase(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E69EA068;
  v2 = (void *)*((_QWORD *)this + 123);
  if (v2)
  {
    *((_QWORD *)this + 124) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 120);
  if (v3)
  {
    *((_QWORD *)this + 121) = v3;
    operator delete(v3);
  }
  LimitWindBoost::~LimitWindBoost((AULimitWindBoost *)((char *)this + 528));
  ausdk::AUBase::~AUBase(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AULimitWindBoost::Initialize(AULimitWindBoost *this)
{
  NSObject *v2;
  uint64_t Element;
  __int128 v4;
  int v5;
  uint64_t v6;
  __int128 v7;
  const AudioStreamBasicDescription *v8;
  _BOOL4 IsEquivalent;
  uint64_t result;
  unint64_t v11;
  unint64_t v12;
  int v13;
  AudioStreamBasicDescription v14;
  _BYTE buf[32];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (AULimitWindBoostLogScope(void)::once != -1)
    dispatch_once(&AULimitWindBoostLogScope(void)::once, &__block_literal_global_22630);
  if (AULimitWindBoostLogScope(void)::scope)
  {
    v2 = *(NSObject **)AULimitWindBoostLogScope(void)::scope;
    if (!*(_QWORD *)AULimitWindBoostLogScope(void)::scope)
      goto LABEL_9;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "AULimitWindBoost.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 68;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d -", buf, 0x12u);
  }
LABEL_9:
  Element = ausdk::AUScope::SafeGetElement((AULimitWindBoost *)((char *)this + 80), 0);
  v4 = *(_OWORD *)(Element + 96);
  *(_OWORD *)buf = *(_OWORD *)(Element + 80);
  *(_OWORD *)&buf[16] = v4;
  v16 = *(_QWORD *)(Element + 112);
  v5 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AULimitWindBoost *)((char *)this + 80), 2u) + 108);
  v6 = ausdk::AUScope::SafeGetElement((AULimitWindBoost *)((char *)this + 128), 0);
  v7 = *(_OWORD *)(v6 + 96);
  *(_OWORD *)&v14.mSampleRate = *(_OWORD *)(v6 + 80);
  *(_OWORD *)&v14.mBytesPerPacket = v7;
  *(_QWORD *)&v14.mBitsPerChannel = *(_QWORD *)(v6 + 112);
  IsEquivalent = CAStreamBasicDescription::IsEquivalent((CAStreamBasicDescription *)buf, &v14, v8);
  result = 4294956428;
  if (IsEquivalent && v5 == 1)
  {
    *((_QWORD *)this + 118) = *(_QWORD *)buf;
    v11 = *((unsigned int *)this + 84);
    *((_DWORD *)this + 234) = v11;
    v13 = 0;
    std::vector<float>::assign((char **)this + 120, v11, &v13);
    v12 = (2 * *((_DWORD *)this + 234));
    v13 = 0;
    std::vector<float>::assign((char **)this + 123, v12, &v13);
    LimitWindBoost::initialize((AULimitWindBoost *)((char *)this + 528), *(unsigned int *)&buf[28], *((_DWORD *)this + 234), *((double *)this + 118), *((_DWORD *)this + 238));
    return 0;
  }
  return result;
}

uint64_t AULimitWindBoost::GetPropertyInfo(AULimitWindBoost *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  BOOL v7;

  if (a3)
    return 4294956417;
  if (a2 == 21)
  {
    v7 = 1;
  }
  else
  {
    if (a2 != 3700)
      return 4294956417;
    v7 = 0;
  }
  result = 0;
  *a6 = v7;
  *a5 = 4;
  return result;
}

uint64_t AULimitWindBoost::GetProperty(AULimitWindBoost *this, int a2, int a3, unsigned int a4, int *a5)
{
  uint64_t result;
  int v6;

  if (a3)
    return 4294956417;
  if (a2 == 3700)
  {
    v6 = 1;
  }
  else
  {
    if (a2 != 21)
      return 4294956417;
    v6 = *((unsigned __int8 *)this + 932);
  }
  result = 0;
  *a5 = v6;
  return result;
}

uint64_t AULimitWindBoost::SetProperty(AULimitWindBoost *this, int a2, int a3, unsigned int a4, _DWORD *a5, unsigned int a6)
{
  uint64_t result;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    if (a6 >= 4)
    {
      result = 0;
      *((_BYTE *)this + 932) = *a5 != 0;
    }
    else
    {
      return 4294956445;
    }
  }
  return result;
}

uint64_t AULimitWindBoost::SetParameter(AULimitWindBoost *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  unsigned int *v11;
  unsigned int v12;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  v11 = (unsigned int *)((char *)this + 928);
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 + 1, v11));
  return 0;
}

uint64_t AULimitWindBoost::CanScheduleParameters(AULimitWindBoost *this)
{
  return 0;
}

uint64_t AULimitWindBoost::ProcessMultipleBufferLists(AULimitWindBoost *this, unsigned int *a2, unsigned int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  AudioBufferList *v8;
  _DWORD *v9;
  const AudioBufferList *v10;
  _DWORD *v11;
  unsigned int v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  float Parameter;
  unint64_t v17;
  uint64_t v19;
  unint64_t v20;
  size_t v21;
  const void *v22;
  void *v23;
  float v24;
  float v25;
  unsigned int *v26;
  unsigned int v27;
  unint64_t i;
  uint64_t v29;
  ausdk::AUElement *v30;
  ausdk::AUElement **v31;
  float v32;
  uint64_t v33;
  float *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  void *v38;
  size_t v39;
  const void *v40;
  size_t v41;
  float v42;
  uint64_t v43;
  ausdk::AUElement *v44;
  ausdk::AUElement **v45;
  DSPSplitComplex v47;

  if (a4 >= 3)
  {
    v9 = *a5;
    v8 = (AudioBufferList *)a5[1];
    v10 = a5[2];
    v11 = *a7;
    v12 = *((_DWORD *)this + 234);
    v13 = *((_QWORD *)this + 9);
    if (v13)
    {
      v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
    }
    else
    {
      v15 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v15)
        v14 = 0;
      else
        v14 = *v15;
    }
    Parameter = ausdk::AUElement::GetParameter(v14, 1u);
    if (*((_BYTE *)this + 932))
    {
      v17 = *v9;
      if (v17 == *v11 && v17 != 0)
      {
        v19 = 0;
        v20 = 0;
        do
        {
          v21 = v9[v19 + 3];
          if ((_DWORD)v21 == v11[v19 + 3])
          {
            v22 = *(const void **)&v9[v19 + 4];
            v23 = *(void **)&v11[v19 + 4];
            if (v22 != v23)
            {
              memcpy(v23, v22, v21);
              v17 = *v9;
            }
          }
          ++v20;
          v19 += 4;
        }
        while (v20 < v17);
      }
    }
    else
    {
      if (!*((_BYTE *)this + 632))
        __assert_rtn("ProcessMultipleBufferLists", "AULimitWindBoost.cpp", 549, "mLimitWindBoost.isInitiazlied()");
      v24 = Parameter / (*((double *)this + 118) * 0.5) * (float)v12;
      v25 = roundf(v24);
      v26 = (unsigned int *)((char *)this + 928);
      do
        v27 = __ldaxr(v26);
      while (__stlxr(0, v26));
      if (v27)
      {
        for (i = 0; i != 18; ++i)
        {
          v29 = *((_QWORD *)this + 9);
          if (v29)
          {
            v30 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v29 + 32))(v29, 0);
          }
          else
          {
            v31 = (ausdk::AUElement **)*((_QWORD *)this + 6);
            if (*((ausdk::AUElement ***)this + 7) == v31)
              v30 = 0;
            else
              v30 = *v31;
          }
          v32 = ausdk::AUElement::GetParameter(v30, i);
          v33 = *((_QWORD *)this + 66);
          if (i >= (*((_QWORD *)this + 67) - v33) >> 2)
            goto LABEL_51;
          *(float *)(v33 + 4 * i) = v32;
        }
        if (*((_BYTE *)this + 17) && *((_BYTE *)this + 632))
          LimitWindBoost::propagateParameterChanges((AULimitWindBoost *)((char *)this + 528));
      }
      v34 = (float *)((char *)v10->mBuffers[0].mData + 4 * *((unsigned int *)this + 234));
      v47.realp = (float *)v10->mBuffers[0].mData;
      v47.imagp = v34;
      vDSP_zvmags(&v47, 1, *((float **)this + 120), 1, (unint64_t)v25);
      v35 = *((_QWORD *)this + 66);
      if ((unint64_t)(*((_QWORD *)this + 67) - v35) <= 0x10)
LABEL_51:
        std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
      *(_DWORD *)(v35 + 16) = 0;
      if (*v9)
      {
        v36 = 0;
        v37 = 0;
        do
        {
          v38 = (void *)*((_QWORD *)this + 123);
          v39 = *((_QWORD *)this + 124) - (_QWORD)v38;
          if (v39 > v9[v36 + 3])
            __assert_rtn("ProcessMultipleBufferLists", "AULimitWindBoost.cpp", 562, "beamsABL->mBuffers[i].mDataByteSize >= mTemp.size() * sizeof(Float32)");
          memcpy(v38, *(const void **)&v9[v36 + 4], v39);
          LimitWindBoost::process((uint64_t)this + 528, (uint64_t *)this + 120, (uint64_t)this + 984, &v8->mNumberBuffers, (const float **)&v47.realp, v37);
          v40 = (const void *)*((_QWORD *)this + 123);
          v41 = *((_QWORD *)this + 124) - (_QWORD)v40;
          if (v41 > v11[v36 + 3])
            __assert_rtn("ProcessMultipleBufferLists", "AULimitWindBoost.cpp", 565, "outputABL->mBuffers[i].mDataByteSize >= mTemp.size() * sizeof(Float32)");
          memcpy(*(void **)&v11[v36 + 4], v40, v41);
          ++v37;
          v36 += 4;
        }
        while (v37 < *v9);
        v35 = *((_QWORD *)this + 66);
        if ((unint64_t)(*((_QWORD *)this + 67) - v35) <= 0xF)
          __assert_rtn("getParameter", "LimitWindBoost.cpp", 159, "index <= mParameter.size()");
      }
      v42 = *(float *)(v35 + 16);
      v43 = *((_QWORD *)this + 9);
      if (v43)
      {
        v44 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v43 + 32))(v43, 0);
      }
      else
      {
        v45 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v45)
          v44 = 0;
        else
          v44 = *v45;
      }
      ausdk::AUElement::SetParameter(v44, 4u, v42, 0);
    }
  }
  return 0;
}

uint64_t AULimitWindBoost::Render(AULimitWindBoost *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  ausdk::AUInputElement *Element;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t BufferList;

  v8 = (AULimitWindBoost *)((char *)this + 80);
  Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AULimitWindBoost *)((char *)this + 80), 0);
  result = ausdk::AUInputElement::PullInput(Element, a2, a3, 0, a4);
  if (!(_DWORD)result)
  {
    v11 = ausdk::AUScope::SafeGetElement((AULimitWindBoost *)((char *)this + 128), 0);
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v11 + 144));
    v12 = ausdk::AUScope::SafeGetElement(v8, 0);
    v13 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v12 + 144));
    return (*(uint64_t (**)(AULimitWindBoost *, unsigned int *, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t *))(*(_QWORD *)this + 184))(this, a2, a4, 1, &v13, 1, &BufferList);
  }
  return result;
}

uint64_t AULimitWindBoost::GetParameterList(AULimitWindBoost *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;
  uint64_t i;

  if (a2)
    return 4294956430;
  if (a3)
  {
    for (i = 0; i != 18; ++i)
      a3[i] = i;
  }
  result = 0;
  *a4 = 18;
  return result;
}

uint64_t AULimitWindBoost::GetParameterInfo(AULimitWindBoost *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  AudioUnitParameterOptions flags;
  uint64_t v7;
  int v8;
  uint64_t v9;
  AudioUnitParameterValue v10;
  AudioUnitParameterValue v11;
  AudioUnitParameterValue v12;

  buffer->flags = 0;
  buffer->unitName = 0;
  if (a2)
    return 4294956430;
  switch(a3)
  {
    case 0:
      buffer->cfNameString = CFSTR("Reference mic index.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Reference mic index."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x4170000000000000;
      buffer->defaultValue = 0.0;
      goto LABEL_25;
    case 1:
      buffer->cfNameString = CFSTR("Cutoff frequency for wind boost limiting.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Cutoff frequency for wind boost limiting."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Hertz;
      buffer->defaultValue = 500.0;
      v7 = 0x457A000000000000;
      goto LABEL_24;
    case 2:
      buffer->cfNameString = CFSTR("Wind boost detection threshold (dB).");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Wind boost detection threshold (dB)."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultValue = 6.0;
      goto LABEL_9;
    case 3:
      buffer->cfNameString = CFSTR("Max wind boost allowed (dB).");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Max wind boost allowed (dB)."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultValue = 0.0;
LABEL_9:
      v7 = 0x4140000000000000;
      goto LABEL_24;
    case 4:
      buffer->cfNameString = CFSTR("Current Crossover Frequency (MAX).");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Current Crossover Frequency (MAX)."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Hertz;
      buffer->defaultValue = 20.0;
      *(_QWORD *)&buffer->minValue = 0x469C400041A00000;
      v8 = 1079017472;
      goto LABEL_30;
    case 5:
      buffer->cfNameString = CFSTR("Scale Cutoff.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Scale Cutoff."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultValue = -100.0;
      v9 = 0x42C80000C2C80000;
      goto LABEL_29;
    case 6:
      buffer->cfNameString = CFSTR("Raw Scale Smoothing.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Raw Scale Smoothing."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      v10 = 0.03;
      goto LABEL_28;
    case 7:
      buffer->cfNameString = CFSTR("Omni Blend Scale Thres.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Omni Blend Scale Thres."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultValue = -12.0;
      v7 = 0x42C80000C2C80000;
      goto LABEL_24;
    case 8:
      buffer->cfNameString = CFSTR("Crossover Max Frequency.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Crossover Max Frequency."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Hertz;
      v11 = 1250.0;
      goto LABEL_21;
    case 9:
      buffer->cfNameString = CFSTR("Crossover Index Attack.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Crossover Index Attack."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      v12 = 0.1;
      goto LABEL_18;
    case 10:
      buffer->cfNameString = CFSTR("Crossover Index Release.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Crossover Index Release."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      v12 = 1.0;
      goto LABEL_18;
    case 11:
      buffer->cfNameString = CFSTR("Crossover Index Hold.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Crossover Index Hold."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      v12 = 1.5;
LABEL_18:
      buffer->defaultValue = v12;
      v7 = 0x4120000000000000;
      goto LABEL_24;
    case 12:
      buffer->cfNameString = CFSTR("Crossover Index Smoothing.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Crossover Index Smoothing."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      v10 = 0.4;
      goto LABEL_28;
    case 13:
      buffer->cfNameString = CFSTR("Min Omni Blend Crossover Frequency.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Min Omni Blend Crossover Frequency."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Hertz;
      v11 = 250.0;
LABEL_21:
      buffer->defaultValue = v11;
      v7 = 0x469C400000000000;
      goto LABEL_24;
    case 14:
      buffer->cfNameString = CFSTR("Min Omni Blend Abs. Energy Trigger.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Min Omni Blend Abs. Energy Trigger."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultValue = -90.0;
      v7 = 0x43480000C3480000;
      goto LABEL_24;
    case 15:
      buffer->cfNameString = CFSTR("Wind / Scratch Detect Trigger Attack.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Wind / Scratch Detect Trigger Attack."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      buffer->defaultValue = 0.25;
      v7 = 0x3F80000000000000;
LABEL_24:
      *(_QWORD *)&buffer->minValue = v7;
LABEL_25:
      v8 = -1072693248;
      goto LABEL_30;
    case 16:
      buffer->cfNameString = CFSTR("Wind / Scratch Detect Trigger Release.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Wind / Scratch Detect Trigger Release."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      buffer->defaultValue = 0.25;
      v9 = 0x3F80000000000000;
      goto LABEL_29;
    case 17:
      buffer->cfNameString = CFSTR("Cross Fade Length Ramp Slope.");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Cross Fade Length Ramp Slope."), buffer->name, 52, 0x8000100u);
      buffer->clumpID = 3;
      flags = buffer->flags;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v10 = 0.75;
LABEL_28:
      buffer->defaultValue = v10;
      v9 = 0x4120000000000000;
LABEL_29:
      *(_QWORD *)&buffer->minValue = v9;
      v8 = -1005584384;
LABEL_30:
      result = 0;
      buffer->flags = flags | v8;
      break;
    default:
      result = 4294956418;
      break;
  }
  return result;
}

uint64_t AULimitWindBoost::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;
  unsigned int *v4;
  unsigned int v5;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
  {
    v4 = (unsigned int *)(this + 116);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
  return result;
}

double AULimitWindBoost::GetLatency(AULimitWindBoost *this)
{
  return 0.0;
}

double AULimitWindBoost::GetTailTime(AULimitWindBoost *this)
{
  return 0.0;
}

uint64_t AULimitWindBoost::SupportsTail(AULimitWindBoost *this)
{
  return 1;
}

BOOL AULimitWindBoost::StreamFormatWritable(AULimitWindBoost *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AULimitWindBoost::SupportedNumChannels(AULimitWindBoost *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AULimitWindBoost::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

uint64_t AULimitWindBoost::ValidFormat(AULimitWindBoost *this, unsigned int a2, unsigned int a3, const AudioStreamBasicDescription *a4)
{
  if (a4->mBitsPerChannel == 64 && a4->mFormatID == 1718773105)
    return (LOBYTE(a4->mFormatFlags) >> 5) & 1;
  else
    return 0;
}

char *AULimitWindBoost::GetAudioChannelLayout(AULimitWindBoost *this, unsigned int a2, int a3, AudioChannelLayout *a4, BOOL *a5)
{
  int v6;
  char *v7;
  std::vector<char>::pointer begin;
  std::vector<char> __p;
  std::vector<char>::value_type __x;

  if (a3)
    ausdk::Throw((ausdk *)0xFFFFD583);
  *a5 = 1;
  v6 = *((_DWORD *)this + 238);
  __x = 0;
  std::vector<char>::vector(&__p, 0x20uLL, &__x);
  v7 = 0;
  begin = __p.__begin_;
  *((_DWORD *)__p.__begin_ + 1) = 0;
  *((_DWORD *)begin + 2) = 0;
  *(_DWORD *)begin = v6;
  if ((v6 | 0x10000) != 0x10000)
  {
    if ((_WORD)v6)
    {
      v7 = (char *)(__p.__end_ - begin);
      if (a4 && (_DWORD)v7)
        memcpy(a4, begin, (LODWORD(__p.__end_) - (_DWORD)begin));
    }
    else
    {
      v7 = 0;
    }
  }
  __p.__end_ = begin;
  operator delete(begin);
  return v7;
}

uint64_t AULimitWindBoost::SetAudioChannelLayout(AULimitWindBoost *this, unsigned int a2, int a3, const AudioChannelLayout *a4)
{
  uint64_t result;

  if (a3)
    return 4294956419;
  if (!a4)
    return 4294956445;
  result = 0;
  *((_DWORD *)this + 238) = a4->mChannelLayoutTag;
  return result;
}

os_log_t ___ZL24AULimitWindBoostLogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "aulwb");
  *v0 = result;
  AULimitWindBoostLogScope(void)::scope = (uint64_t)v0;
  return result;
}

float CResidualSuppressorV3::preprocess_analysis_freq(uint64_t a1, uint64_t a2, const void *a3)
{
  vDSP_Length v5;
  float *v6;
  uint64_t v7;
  char *v8;
  float *v9;
  const void *v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v14;
  DSPSplitComplex __Z;
  DSPSplitComplex __A;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v5 = *(int *)(a1 + 8);
  v6 = *(float **)(a1 + 104);
  MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v14 - v7;
  v9 = (float *)((char *)&v14 + 4 * v5 - v7);
  __A.realp = (float *)((char *)&v14 - v7);
  __A.imagp = v9;
  memcpy((char *)&v14 - v7, v10, 4 * v5);
  memcpy(v9, a3, 4 * v5);
  __Z.realp = v9 + 1;
  __Z.imagp = (float *)(v8 + 8);
  vDSP_ztoc(&__Z, 1, (DSPComplex *)(*(_QWORD *)(a1 + 96) + 8), 2, v5 - 2);
  v11 = *(_DWORD **)(a1 + 96);
  *v11 = *(_DWORD *)v8;
  v11[1] = *((_DWORD *)v8 + 1);
  v12 = 8 * v5 - 4;
  v11[2 * (int)v5 - 2] = *(_DWORD *)&v8[v12];
  *(float *)((char *)v11 + v12) = *v9;
  vDSP_zvmags(&__A, 1, v6, 1, v5);
  *v6 = *__A.realp * *__A.realp;
  return CFilterBank::filterbank_compute_bank32(*(_QWORD *)(a1 + 24), v6, &v6[v5]);
}

void CResidualSuppressorV3::speex_analysis(uint64_t a1, char *a2, DSPSplitComplex *a3)
{
  int v6;
  vDSP_Length v7;
  int v8;
  int v9;
  float v10;
  MultiRadixRealFFT *v11;
  float __B;

  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(int *)(a1 + 8);
  v8 = 2 * v7 - v6;
  v9 = v6 - v8;
  memcpy(*(void **)(a1 + 88), *(const void **)(a1 + 312), 4 * v8);
  memcpy((void *)(*(_QWORD *)(a1 + 88) + 4 * v8), a2, 4 * *(int *)(a1 + 4));
  memcpy(*(void **)(a1 + 312), &a2[4 * v9], 4 * v8);
  vDSP_vmul(*(const float **)(a1 + 88), 1, *(const float **)(a1 + 128), 1, *(float **)(a1 + 88), 1, 2 * v7);
  vDSP_ctoz(*(const DSPComplex **)(a1 + 88), 2, a3, 1, v7);
  v11 = *(MultiRadixRealFFT **)(a1 + 336);
  if (v11)
    MultiRadixRealFFT::RealInPlaceTransform(v11, a3, 1, v10);
  __B = (float)(int)v7 + (float)(int)v7;
  vDSP_vsdiv(a3->realp, 1, &__B, a3->realp, 1, v7);
  vDSP_vsdiv(a3->imagp, 1, &__B, a3->imagp, 1, v7);
}

float CResidualSuppressorV3::speex_synthesis(uint64_t a1, float *a2)
{
  vDSP_Length v4;
  int v5;
  uint64_t v6;
  float *v7;
  float *v8;
  uint64_t v9;
  _QWORD *v10;
  float v11;
  MultiRadixRealFFT *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  float result;
  uint64_t v17;
  int v18;
  float *v19;
  float *v20;
  float v21;
  DSPSplitComplex __Z;
  float __B;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = *(int *)(a1 + 8);
  v5 = 2 * v4;
  MEMORY[0x1E0C80A78](a1);
  v7 = (float *)((char *)&__Z - v6);
  v8 = (float *)((char *)&__Z + 4 * v4 - v6);
  __Z.realp = v8 + 1;
  __Z.imagp = (float *)((char *)&__Z.imagp - v6);
  vDSP_ctoz((const DSPComplex *)(*(_QWORD *)(v9 + 96) + 8), 2, &__Z, 1, v4 - 2);
  v10 = *(_QWORD **)(a1 + 96);
  *(_QWORD *)v7 = *v10;
  v7[2 * (int)v4 - 1] = *(float *)&v10[v4 - 1];
  *v8 = *((float *)&v10[(int)v4 - 1] + 1);
  __Z.realp = v7;
  __Z.imagp = v8;
  __B = 0.000030518;
  vDSP_vsmul(v7, 1, &__B, v7, 1, (2 * v4));
  v12 = *(MultiRadixRealFFT **)(a1 + 336);
  if (v12)
    MultiRadixRealFFT::RealInPlaceTransform(v12, &__Z, -1, v11);
  vDSP_ztoc(&__Z, 1, *(DSPComplex **)(a1 + 88), 2, v4);
  vDSP_vmul(*(const float **)(a1 + 88), 1, *(const float **)(a1 + 128), 1, *(float **)(a1 + 88), 1, v5);
  v13 = *(_DWORD *)(a1 + 4);
  v14 = (v5 - v13);
  v15 = (v13 - v14);
  vDSP_vadd(*(const float **)(a1 + 320), 1, *(const float **)(a1 + 88), 1, a2, 1, (int)v14);
  if ((int)v15 >= 1)
  {
    v17 = *(_QWORD *)(a1 + 88);
    v18 = v14;
    do
    {
      result = *(float *)(v17 + 4 * v18);
      a2[v18++] = result;
      --v15;
    }
    while (v15);
  }
  if ((int)v14 >= 1)
  {
    v19 = *(float **)(a1 + 320);
    v20 = (float *)(*(_QWORD *)(a1 + 88) + 4 * *(int *)(a1 + 4));
    do
    {
      v21 = *v20++;
      result = v21;
      *v19++ = v21;
      --v14;
    }
    while (v14);
  }
  return result;
}

void *CResidualSuppressorV3::EstimateNoise(uint64_t a1, const float *__A)
{
  vDSP_Length v4;
  float v5;
  float v6;
  float v7;
  uint64_t v8;
  int v9;
  float v10;
  float v11;
  unint64_t v13;
  uint64_t v14;
  const float *v15;
  uint64_t v16;
  uint64_t v17;
  float v19;
  float v20;
  float v21;
  float v22;
  float __B;

  v4 = *(int *)(a1 + 8);
  v5 = (float)(int)v4;
  if (*(_DWORD *)(a1 + 328) <= (int)(float)((float)((float)*(int *)(a1 + 12) * 0.5) / (float)(int)v4))
  {
    v6 = *(float *)(a1 + 292);
  }
  else if (*(_DWORD *)a1)
  {
    v6 = *(float *)(a1 + 284);
  }
  else
  {
    v6 = *(float *)(a1 + 280);
  }
  v21 = v6;
  v19 = *(float *)(a1 + 296);
  v20 = 1.0 - v6;
  v7 = 1.0 - *(float *)(a1 + 264);
  v22 = v7 * 0.667;
  __B = v7 * 0.333;
  v8 = *(_QWORD *)(a1 + 744);
  *(_DWORD *)v8 = 0;
  vDSP_vsmul(__A, 1, &__B, (float *)(v8 + 4), 1, v4 - 1);
  vDSP_vsma(__A + 1, 1, &__B, *(const float **)(a1 + 744), 1, *(float **)(a1 + 744), 1, v4 - 1);
  vDSP_vsma(__A, 1, &v22, *(const float **)(a1 + 744), 1, *(float **)(a1 + 744), 1, v4);
  vDSP_vsma(*(const float **)(a1 + 184), 1, (const float *)(a1 + 264), *(const float **)(a1 + 744), 1, *(float **)(a1 + 184), 1, v4);
  v9 = *(_DWORD *)(a1 + 328);
  if (v9 == 1)
  {
    vDSP_vclr(*(float **)(a1 + 192), 1, v4);
    vDSP_vclr(*(float **)(a1 + 200), 1, v4);
    v9 = *(_DWORD *)(a1 + 328);
  }
  v10 = (float)*(int *)(a1 + 12);
  v11 = (float)(v10 * 0.2) / v5;
  if (v11 <= (float)v9 && (float)((float)(v10 * 0.5) / v5) <= (float)v9)
    v11 = (float)(v10 + v10) / v5;
  if (*(_DWORD *)(a1 + 332) <= (int)v11)
  {
    vDSP_vmin(*(const float **)(a1 + 192), 1, *(const float **)(a1 + 184), 1, *(float **)(a1 + 192), 1, v4);
    vDSP_vmin(*(const float **)(a1 + 200), 1, *(const float **)(a1 + 184), 1, *(float **)(a1 + 200), 1, v4);
  }
  else
  {
    *(_DWORD *)(a1 + 332) = 0;
    vDSP_vmin(*(const float **)(a1 + 200), 1, *(const float **)(a1 + 184), 1, *(float **)(a1 + 192), 1, v4);
    memcpy(*(void **)(a1 + 200), *(const void **)(a1 + 184), 4 * v4);
  }
  vDSP_vmul(*(const float **)(a1 + 192), 1, *(const float **)(a1 + 80), 1, *(float **)(a1 + 744), 1, v4);
  vDSP_vsub(*(const float **)(a1 + 744), 1, *(const float **)(a1 + 184), 1, *(float **)(a1 + 208), 1, v4);
  vDSP_vsmul(__A, 1, &v21, *(float **)(a1 + 752), 1, v4);
  vDSP_vsma(*(const float **)(a1 + 144), 1, &v20, *(const float **)(a1 + 752), 1, *(float **)(a1 + 752), 1, v4);
  vDSP_vsmul(*(const float **)(a1 + 192), 1, &v19, *(float **)(a1 + 744), 1, v4);
  vDSP_vsub(*(const float **)(a1 + 744), 1, __A, 1, *(float **)(a1 + 744), 1, v4);
  vDSP_vmax(*(const float **)(a1 + 208), 1, *(const float **)(a1 + 744), 1, *(float **)(a1 + 744), 1, v4);
  if (*(_DWORD *)a1)
  {
    if ((int)v4 >= 1)
    {
      v13 = 0;
      v14 = *(_QWORD *)(a1 + 744);
      while (1)
      {
        v15 = __A;
        if (*(float *)(v14 + v13) <= 0.0)
          goto LABEL_23;
        if (*(float *)(*(_QWORD *)(a1 + 184) + v13) < (float)(*(float *)(a1 + 288)
                                                             * *(float *)(*(_QWORD *)(a1 + 192) + v13)))
          break;
LABEL_24:
        v13 += 4;
        if (4 * v4 == v13)
          return memcpy(*(void **)(a1 + 136), *(const void **)(a1 + 144), 4 * v4);
      }
      v15 = *(const float **)(a1 + 752);
LABEL_23:
      *(float *)(*(_QWORD *)(a1 + 144) + v13) = v15[v13 / 4];
      goto LABEL_24;
    }
  }
  else if ((int)v4 >= 1)
  {
    v16 = 0;
    v17 = *(_QWORD *)(a1 + 744);
    do
    {
      if (*(float *)(v17 + v16) <= 0.0)
        *(_DWORD *)(*(_QWORD *)(a1 + 144) + v16) = *(_DWORD *)(*(_QWORD *)(a1 + 752) + v16);
      v16 += 4;
    }
    while (4 * v4 != v16);
  }
  return memcpy(*(void **)(a1 + 136), *(const void **)(a1 + 144), 4 * v4);
}

void CResidualSuppressorV3::AdjustResidual(uint64_t a1)
{
  uint64_t v2;
  float v3;
  vDSP_Length v4;
  float v5;
  char *v6;
  unsigned int v7;
  float *v8;
  float v9;
  float *v10;
  float *v11;
  double v12;
  const float *v13;
  unint64_t v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  float v21;
  uint64_t v22;
  float *v23;
  float v24;
  _DWORD *v25;
  float v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  float *v30;
  float v31;
  _DWORD *v32;
  vDSP_Length v33;
  _DWORD *v34;
  vDSP_Length v35;
  float v36;
  float __C;
  float v38;
  float v39;
  float v40;
  float __B;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v3 = log10((float)(*(float *)(a1 + 560) / (float)*(int *)(a1 + 456)) + 1.0e-20) * 10.0;
  v4 = *(unsigned int *)(a1 + 8);
  v5 = **(float **)(a1 + 392);
  v6 = *(char **)(a1 + 616);
  if (v3 > -85.0)
  {
    v7 = *(_DWORD *)(a1 + 564);
    if (v7 < *(_DWORD *)(a1 + 568))
      *(_DWORD *)(a1 + 564) = v7 + 1;
  }
  v8 = *(float **)(a1 + 256);
  v9 = *(float *)(a1 + 556);
  v10 = *(float **)(a1 + 744);
  v11 = *(float **)(a1 + 752);
  v12 = MEMORY[0x1E0C80A78](v2);
  v13 = (float *)((char *)&v36 - ((4 * v4 + 15) & 0x7FFFFFFF0));
  v40 = 0.5;
  __B = 2.0;
  v39 = 1.0e-20;
  v38 = 1.0;
  if (*(float *)&v12 > -85.0)
  {
    vDSP_vsmul(*(const float **)(a1 + 136), 1, &__B, v10, 1, v4);
    vDSP_vsub(v10, 1, *(const float **)(a1 + 104), 1, v10, 1, v4);
    vDSP_vthr(v10, 1, &v39, v10, 1, v4);
    vDSP_vsmul(v10, 1, &v40, v10, 1, v4);
    vDSP_vthr(*(const float **)(a1 + 256), 1, &v39, v11, 1, v4);
    if ((_DWORD)v4)
      memset_pattern16(v6, &unk_1B6627B80, 4 * v4);
    __C = 0.0;
    if (*(_DWORD *)(a1 + 584))
    {
      v14 = 0;
      v15 = 0.0;
      do
      {
        v16 = v15;
        v17 = *(_QWORD *)(a1 + 592);
        v18 = *(unsigned int *)(v17 + 4 * v14++);
        v19 = *(_DWORD *)(v17 + 4 * v14);
        vDSP_maxv(&v11[v18], 1, &__C, (v19 - v18 + 1));
        v15 = (float)(__C * 10.0) + 1.0e-20;
        __C = v15;
        v20 = (v19 + 1);
        if (v18 < v20)
        {
          if (v15 <= v16)
            v21 = v16;
          else
            v21 = v15;
          v22 = v20 - v18;
          v23 = (float *)&v13[v18];
          do
          {
            *v23++ = v21;
            --v22;
          }
          while (v22);
        }
      }
      while (v14 < *(unsigned int *)(a1 + 584));
    }
    vDSP_vmin(v10, 1, v13, 1, v10, 1, v4);
    v36 = 0.0;
    if (*(_DWORD *)(a1 + 564) < *(_DWORD *)(a1 + 568) || !*(_DWORD *)(a1 + 488) || v5 > *(float *)(a1 + 504))
    {
      vDSP_vdiv(v11, 1, v10, 1, (float *)v6, 1, v4);
      v24 = *(float *)(a1 + 520);
LABEL_20:
      v36 = v24;
      vDSP_vclip((const float *)v6, 1, &v38, &v36, (float *)v6, 1, v4);
      v25 = (_DWORD *)(a1 + 548);
LABEL_21:
      *(_DWORD *)(a1 + 544) = *v25;
      goto LABEL_24;
    }
    v31 = *(float *)(a1 + 512);
    if (v5 <= *(float *)(a1 + 508))
    {
      if (v9 > v31)
      {
        vDSP_vdiv(v11, 1, v10, 1, (float *)v6, 1, v4);
        v24 = *(float *)(a1 + 528);
        goto LABEL_20;
      }
      if ((_DWORD)v4)
      {
        v34 = v6;
        v35 = v4;
        do
        {
          *v34++ = *(_DWORD *)(a1 + 532);
          --v35;
        }
        while (v35);
      }
    }
    else
    {
      if (v9 > v31)
      {
        vDSP_vdiv(v11, 1, v10, 1, (float *)v6, 1, v4);
        v24 = *(float *)(a1 + 524);
        goto LABEL_20;
      }
      if ((_DWORD)v4)
      {
        v32 = v6;
        v33 = v4;
        do
        {
          *v32++ = *(_DWORD *)(a1 + 532);
          --v33;
        }
        while (v33);
      }
    }
    v25 = (_DWORD *)(a1 + 552);
    goto LABEL_21;
  }
  if ((_DWORD)v4)
    memset_pattern16(v6, &unk_1B6627B80, 4 * v4);
LABEL_24:
  if (*(_DWORD *)(a1 + 576) == 1)
  {
    v26 = (float)*(int *)(a1 + 12) / (float)(*(_DWORD *)(a1 + 456) - 1);
    v27 = vcvtms_u32_f32(300.0 / v26);
    v28 = vcvtms_u32_f32(1500.0 / v26) + 1;
    if (v28 > v27)
    {
      v29 = v28 - v27;
      v30 = (float *)&v6[4 * v27];
      do
      {
        *v30 = fminf(*v30, 4.0);
        ++v30;
        --v29;
      }
      while (v29);
    }
  }
  vDSP_vmul(v8, 1, (const float *)v6, 1, v8, 1, v4);
}

void *CResidualSuppressorV3::speex_preprocess_run_res_suppressor(uint64_t a1)
{
  vDSP_Length v2;
  vDSP_Length v3;
  unsigned int v4;
  const float *v5;
  void *v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float *v12;
  unsigned int v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  int v19;
  int v20;
  float v21;
  float v22;
  uint64_t v23;
  vDSP_Length v24;
  float v25;
  vDSP_Length v26;
  vDSP_Length v27;
  vDSP_Length v28;
  vDSP_Length v29;
  float v30;
  vDSP_Length v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float *v39;
  float *v40;
  const float *v41;
  float v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  float *v46;
  float *v47;
  float *v48;
  uint64_t v49;
  float v50;
  float v51;
  float v52;
  float v53;
  const float *v54;
  float *v55;
  float v56;
  float v57;
  vDSP_Length v58;
  CNoiseSuppressorV3 *v59;
  vDSP_Length v60;
  float *v61;
  float v62;
  float *v63;
  vDSP_Length v64;
  vDSP_Length v65;
  float *v66;
  unint64_t v67;
  float *v68;
  float *v69;
  float v70;
  float v71;
  float v72;
  float v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  vDSP_Length v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  float *v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float *v91;
  CNoiseSuppressorV3 *v92;
  float *v93;
  float *v94;
  vDSP_Length v95;
  const float *v96;
  float *v97;
  float *v98;
  float *v99;
  float *v100;
  float *v101;
  vDSP_Length v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  int v108;
  uint64_t v109;
  vDSP_Length v110;
  float *v111;
  float *v112;
  const DSPComplex *v113;
  uint64_t v114;
  uint64_t v115;
  float *v116;
  _DWORD *v117;
  float *v119;
  const float *v120;
  int v121;
  const float *v122;
  DSPSplitComplex __Z;
  float v124;
  float v125;
  float v126;
  float __B;
  float v128;
  float v129;
  float __A;
  float v131;
  float v132;
  float v133;
  float __C;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  float v140[3];

  v2 = *(unsigned int *)(a1 + 16);
  v3 = *(unsigned int *)(a1 + 8);
  v4 = v3 + v2;
  v5 = *(const float **)(a1 + 104);
  v139 = 1.0e-20;
  v137 = -1.0e20;
  v135 = 0.0;
  v136 = -1.0;
  __C = 0.1;
  v133 = 0.2;
  v132 = 0.8;
  v131 = 0.89;
  v129 = 3.0;
  __A = 1.0;
  __B = 1.0e-20;
  v128 = 100.0;
  if (*(_DWORD *)a1 == 1)
  {
    memcpy(*(void **)(a1 + 752), *(const void **)(a1 + 248), 4 * (v3 + v2));
    vDSP_vadd(*(const float **)(a1 + 752), 1, *(const float **)(a1 + 136), 1, *(float **)(a1 + 752), 1, (v3 + v2));
  }
  else
  {
    if (*(_DWORD *)a1)
    {
      v6 = *(void **)(a1 + 752);
      v7 = *(const void **)(a1 + 136);
    }
    else
    {
      v6 = *(void **)(a1 + 752);
      v7 = *(const void **)(a1 + 248);
    }
    memcpy(v6, v7, 4 * (v3 + v2));
  }
  v8 = (int)v3;
  v138 = 0.0;
  vDSP_vsadd(*(const float **)(a1 + 752), 1, &__B, *(float **)(a1 + 752), 1, (v3 + v2));
  vDSP_svdiv(&__A, *(const float **)(a1 + 752), 1, *(float **)(a1 + 744), 1, (v3 + v2));
  vDSP_vadd(*(const float **)(a1 + 152), 1, *(const float **)(a1 + 752), 1, *(float **)(a1 + 752), 1, (v3 + v2));
  vDSP_vdiv(*(const float **)(a1 + 752), 1, *(const float **)(a1 + 152), 1, *(float **)(a1 + 752), 1, (v3 + v2));
  vDSP_vsq(*(const float **)(a1 + 752), 1, *(float **)(a1 + 752), 1, (v3 + v2));
  vDSP_vsmsa(*(const float **)(a1 + 752), 1, &v131, &__C, *(float **)(a1 + 752), 1, (v3 + v2));
  vDSP_vmsa(v5, 1, *(const float **)(a1 + 744), 1, &v136, *(float **)(a1 + 176), 1, (v3 + v2));
  vDSP_vclip(*(const float **)(a1 + 176), 1, &v135, &v128, *(float **)(a1 + 168), 1, (v3 + v2));
  vDSP_vmin(*(const float **)(a1 + 176), 1, *(const float **)(a1 + 168), 1, *(float **)(a1 + 176), 1, (v3 + v2));
  vDSP_vmul(*(const float **)(a1 + 168), 1, *(const float **)(a1 + 752), 1, *(float **)(a1 + 168), 1, (v3 + v2));
  vDSP_vsadd(*(const float **)(a1 + 752), 1, &v136, *(float **)(a1 + 752), 1, (v3 + v2));
  vDSP_vmul(*(const float **)(a1 + 752), 1, *(const float **)(a1 + 152), 1, *(float **)(a1 + 752), 1, (v3 + v2));
  vDSP_vmul(*(const float **)(a1 + 752), 1, *(const float **)(a1 + 744), 1, *(float **)(a1 + 744), 1, (v3 + v2));
  vDSP_vsub(*(const float **)(a1 + 744), 1, *(const float **)(a1 + 168), 1, *(float **)(a1 + 168), 1, (v3 + v2));
  vDSP_vclip(*(const float **)(a1 + 168), 1, &v137, &v128, *(float **)(a1 + 168), 1, (v3 + v2));
  v9 = *(_QWORD *)(a1 + 744) + 4 * v3;
  v10 = *(_QWORD *)(a1 + 752) + 4 * v3;
  vDSP_vsub((const float *)(*(_QWORD *)(a1 + 168) + 4 * v3), 1, (const float *)(*(_QWORD *)(a1 + 240) + 4 * v3), 1, (float *)v9, 1, v2);
  vDSP_vthres((const float *)v9, 1, &v135, (float *)v10, 1, v2);
  vDSP_vsub((const float *)v10, 1, (const float *)v9, 1, (float *)v9, 1, v2);
  vDSP_vsma((const float *)v9, 1, (const float *)(a1 + 268), (const float *)(*(_QWORD *)(a1 + 168) + 4 * v3), 1, (float *)v9, 1, v2);
  vDSP_vsma((const float *)v10, 1, (const float *)(a1 + 272), (const float *)v9, 1, (float *)(*(_QWORD *)(a1 + 240) + 4 * v3), 1, 5uLL);
  vDSP_vsma((const float *)(v10 + 20), 1, (const float *)(a1 + 276), (const float *)(v9 + 20), 1, (float *)(*(_QWORD *)(a1 + 240) + 4 * v3 + 20), 1, (v2 - 5));
  v11 = 0.0;
  if (v3 < v4)
  {
    v12 = (float *)(*(_QWORD *)(a1 + 240) + 4 * (int)v3);
    v13 = v3;
    do
    {
      v14 = *v12++;
      v15 = v14;
      if (v14 <= 3.0)
        v15 = -0.0;
      v11 = v11 + v15;
      ++v13;
    }
    while (v4 > v13);
  }
  v16 = v11 / (float)*(int *)(a1 + 16);
  v17 = 0.1;
  v18 = (float)((float)(1.0 / (float)((float)(0.5 / v16) + 1.0)) * 0.899) + 0.1;
  *(float *)(a1 + 216) = v16;
  *(float *)(a1 + 220) = v18;
  *(float *)(a1 + 224) = v18;
  v19 = *(_DWORD *)(a1 + 228);
  if (v19 == 2)
  {
    v18 = *(float *)(a1 + 232);
  }
  else
  {
    if (v19 != 1)
      goto LABEL_19;
    if (v18 >= *(float *)(a1 + 232))
      v18 = *(float *)(a1 + 232);
  }
  *(float *)(a1 + 220) = v18;
LABEL_19:
  v20 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    if (v18 < 0.5)
    {
      v21 = *(float *)(a1 + 680);
      v22 = *(float *)(a1 + 676);
      v23 = *(_QWORD *)(a1 + 136);
      LODWORD(__Z.realp) = 0;
      v24 = *(unsigned int *)(a1 + 716);
      if ((int)v24 < 1)
      {
        v25 = 0.0;
      }
      else
      {
        vDSP_sve((const float *)(v23 + 4 * *(int *)(a1 + 692)), 1, (float *)&__Z, v24);
        v25 = (float)(*(float *)&__Z.realp * 0.1) + 0.0;
      }
      v26 = *(unsigned int *)(a1 + 720);
      if ((int)v26 >= 1)
      {
        vDSP_sve((const float *)(v23 + 4 * *(int *)(a1 + 696)), 1, (float *)&__Z, v26);
        v25 = v25 + (float)(*(float *)&__Z.realp * 0.25);
      }
      v27 = *(unsigned int *)(a1 + 724);
      if ((int)v27 >= 1)
      {
        vDSP_sve((const float *)(v23 + 4 * *(int *)(a1 + 700)), 1, (float *)&__Z, v27);
        v25 = v25 + (float)(*(float *)&__Z.realp * 0.6);
      }
      v28 = *(unsigned int *)(a1 + 728);
      if ((int)v28 >= 1)
      {
        vDSP_sve((const float *)(v23 + 4 * *(int *)(a1 + 704)), 1, (float *)&__Z, v28);
        v25 = v25 + *(float *)&__Z.realp;
      }
      v29 = *(unsigned int *)(a1 + 732);
      if ((int)v29 >= 1)
      {
        vDSP_sve((const float *)(v23 + 4 * *(int *)(a1 + 708)), 1, (float *)&__Z, v29);
        v25 = v25 + (float)(*(float *)&__Z.realp * 1.25);
      }
      v30 = *(float *)(a1 + 688) + (float)(log10f(v25 * *(float *)(a1 + 684)) * 10.0);
      if (v30 < 0.0)
        v30 = 0.0;
      *(float *)(a1 + 676) = (float)(v21 * fminf(v30, 100.0)) + (float)((float)(1.0 - v21) * v22);
      v20 = *(_DWORD *)a1;
    }
    if (v20 > 1)
    {
      v54 = (const float *)(a1 + 60);
      v55 = *(float **)(a1 + 120);
      goto LABEL_89;
    }
    v18 = *(float *)(a1 + 220);
  }
  v31 = *(unsigned int *)(a1 + 664);
  v32 = 1.0 - v18;
  if (*(_DWORD *)(a1 + 488) == 1)
  {
    v33 = (float)(v18 * (float)*(int *)(a1 + 40)) + (float)(v32 * (float)*(int *)(a1 + 36));
    v34 = (float)(v18 * -15.0) + (float)(v32 * -50.0);
  }
  else
  {
    v33 = (float)(v18 * (float)*(int *)(a1 + 40)) + (float)(v32 * -70.0);
    v34 = (float)(v18 * -15.0) + (float)(v32 * -70.0);
  }
  v35 = (float)(v18 * *(float *)(a1 + 672)) + (float)(v32 * *(float *)(a1 + 668));
  v36 = expf(v33 * 0.23026);
  *(float *)&__Z.realp = v36;
  v37 = expf(v34 * 0.23026);
  v140[0] = v37;
  v38 = expf(v35 * 0.23026);
  if (*(_DWORD *)(a1 + 540) == 1)
  {
    vDSP_vsadd(*(const float **)(a1 + 104), 1, &v139, *(float **)(a1 + 744), 1, v3);
    vDSP_vdiv(*(const float **)(a1 + 744), 1, *(const float **)(a1 + 136), 1, *(float **)(a1 + 744), 1, v3);
    vDSP_vclip(*(const float **)(a1 + 744), 1, &v135, &__A, *(float **)(a1 + 744), 1, v3);
    v39 = *(float **)(a1 + 744);
    v40 = *(float **)(a1 + 120);
    *v40 = *v39;
    v40[1] = (float)(*v39 + v39[1]) * 0.5;
    memcpy(v40 + 2, v39, 4 * (v3 - 2));
    vDSP_vadd((const float *)(*(_QWORD *)(a1 + 744) + 4), 1, (const float *)(*(_QWORD *)(a1 + 120) + 8), 1, (float *)(*(_QWORD *)(a1 + 120) + 8), 1, (v3 - 2));
    vDSP_vadd((const float *)(*(_QWORD *)(a1 + 744) + 8), 1, (const float *)(*(_QWORD *)(a1 + 120) + 8), 1, (float *)(*(_QWORD *)(a1 + 120) + 8), 1, (v3 - 2));
    v126 = 0.33333;
    vDSP_vsmul((const float *)(*(_QWORD *)(a1 + 120) + 8), 1, &v126, (float *)(*(_QWORD *)(a1 + 120) + 8), 1, (v3 - 2));
    if (*(_DWORD *)a1 == 1)
      goto LABEL_66;
    if (*(_DWORD *)a1 || *(_DWORD *)(a1 + 572) != 1)
      goto LABEL_67;
    v41 = *(const float **)(a1 + 304);
    if (!v41)
    {
LABEL_66:
      vDSP_vsmul(*(const float **)(a1 + 120), 1, (const float *)(a1 + 56), *(float **)(a1 + 120), 1, v3);
    }
    else
    {
      vDSP_vmul(*(const float **)(a1 + 120), 1, v41, 1, *(float **)(a1 + 120), 1, v3);
      vDSP_vmul(*(const float **)(a1 + 120), 1, *(const float **)(a1 + 304), 1, *(float **)(a1 + 120), 1, v3);
    }
LABEL_67:
    v125 = __exp10f(*(float *)(a1 + 544) * 0.1);
    vDSP_vsmul(*(const float **)(a1 + 120), 1, &v125, *(float **)(a1 + 120), 1, v3);
    vDSP_vclip(*(const float **)(a1 + 120), 1, v140, (const float *)&__Z, *(float **)(a1 + 120), 1, v3);
    if (v3 > v31)
    {
      v60 = v3 - v31;
      v61 = (float *)(*(_QWORD *)(a1 + 120) + 4 * v31);
      do
      {
        v62 = *v61;
        if (*v61 >= v38)
          v62 = v38;
        *v61++ = v62;
        --v60;
      }
      while (v60);
    }
    if (*(_DWORD *)a1 == 1)
    {
      v124 = 1.0;
      vDSP_vsmul(*(const float **)(a1 + 248), 1, (const float *)(a1 + 52), *(float **)(a1 + 744), 1, v3);
      vDSP_vadd(*(const float **)(a1 + 744), 1, *(const float **)(a1 + 136), 1, *(float **)(a1 + 752), 1, v3);
      vDSP_vsadd(*(const float **)(a1 + 752), 1, &v124, *(float **)(a1 + 752), 1, v3);
      vDSP_vmul(*(const float **)(a1 + 120), 1, *(const float **)(a1 + 744), 1, *(float **)(a1 + 744), 1, v3);
      vDSP_vsmul(*(const float **)(a1 + 136), 1, (const float *)(a1 + 56), (float *)(*(_QWORD *)(a1 + 744) + 4 * v3), 1, v3);
      vDSP_vadd(*(const float **)(a1 + 744), 1, (const float *)(*(_QWORD *)(a1 + 744) + 4 * v3), 1, *(float **)(a1 + 744), 1, v3);
      vDSP_vdiv(*(const float **)(a1 + 752), 1, *(const float **)(a1 + 744), 1, *(float **)(a1 + 120), 1, v3);
    }
    if ((_DWORD)v3)
    {
      v63 = *(float **)(a1 + 120);
      v64 = v3;
      do
      {
        *v63 = sqrtf(*v63);
        ++v63;
        --v64;
      }
      while (v64);
    }
    goto LABEL_91;
  }
  v42 = sqrtf(v37);
  v43 = sqrtf(v38);
  if (v20 != 1)
  {
    v56 = sqrtf(v36);
    if (v56 > v42)
      v42 = v56;
    v138 = v42;
    if ((_DWORD)v31)
    {
      v55 = *(float **)(a1 + 120);
      if (v31 < v3)
      {
        vDSP_vfill(&v138, v55, 1, v31);
        v57 = v138;
        if (v138 >= v43)
          v57 = v43;
        v138 = v57;
        v55 = (float *)(*(_QWORD *)(a1 + 120) + 4 * v31);
        v58 = (v3 - v31);
        v54 = &v138;
        goto LABEL_90;
      }
    }
    else
    {
      if (v42 >= v43)
        v42 = v43;
      v138 = v42;
      v55 = *(float **)(a1 + 120);
    }
    v54 = &v138;
LABEL_89:
    v58 = v3;
LABEL_90:
    vDSP_vfill(v54, v55, 1, v58);
    goto LABEL_91;
  }
  LODWORD(v44) = v2;
  if (v3 > v31)
    LODWORD(v44) = *(_DWORD *)(**(_QWORD **)(a1 + 24) + 4 * v31);
  if ((int)v2 >= (int)v44)
    v44 = v44;
  else
    v44 = v2;
  if (v36 > v42)
    v42 = v36;
  v45 = *(_QWORD *)(a1 + 744);
  if ((int)v44 < 1)
  {
    LODWORD(v44) = 0;
  }
  else
  {
    v46 = (float *)(*(_QWORD *)(a1 + 248) + 4 * (int)v3);
    v47 = (float *)(*(_QWORD *)(a1 + 136) + 4 * (int)v3);
    v48 = *(float **)(a1 + 744);
    v49 = v44;
    do
    {
      v50 = *v47++;
      v51 = v50;
      v52 = *v46++;
      v53 = *(float *)(a1 + 52) * v52;
      v138 = v51 * *(float *)(a1 + 56);
      *v48++ = sqrtf((float)(v138 + (float)(v42 * v53)) / (float)((float)(v51 + 1.0) + v53));
      --v49;
    }
    while (v49);
  }
  if (v42 >= v43)
    v42 = v43;
  if ((int)v44 < (int)v2)
  {
    v65 = v2 - v44;
    v66 = (float *)(v45 + 4 * v44);
    v67 = (int)v3 + (unint64_t)v44;
    v68 = (float *)(*(_QWORD *)(a1 + 248) + 4 * v67);
    v69 = (float *)(*(_QWORD *)(a1 + 136) + 4 * v67);
    do
    {
      v70 = *v69++;
      v71 = v70;
      v72 = *v68++;
      v73 = *(float *)(a1 + 52) * v72;
      v138 = v71 * *(float *)(a1 + 56);
      *v66++ = sqrtf((float)(v138 + (float)(v42 * v73)) / (float)((float)(v71 + 1.0) + v73));
      --v65;
    }
    while (v65);
  }
  CFilterBank::filterbank_compute_psd16(*(int ***)(a1 + 24), v45, *(float **)(a1 + 120));
LABEL_91:
  if (v3 >= v4)
  {
    v91 = *(float **)(a1 + 112);
  }
  else
  {
    v74 = 0;
    v120 = v5;
    v122 = &v5[(int)v3];
    v121 = *(_DWORD *)(a1 + 228);
    v75 = *(_QWORD *)(a1 + 152) + 4 * (int)v3;
    v76 = *(_QWORD *)(a1 + 240) + 4 * (int)v3;
    v77 = v3;
    v78 = *(_QWORD *)(a1 + 160) + 4 * (int)v3;
    v79 = *(_QWORD *)(a1 + 176) + 4 * v8;
    v80 = *(_QWORD *)(a1 + 168) + 4 * v8;
    v119 = *(float **)(a1 + 112);
    v81 = &v119[v8];
    do
    {
      v82 = *(float *)(v80 + 4 * v74) / (float)(*(float *)(v80 + 4 * v74) + 1.0);
      v83 = *(float *)(v79 + 4 * v74) + 1.0;
      v84 = v82 * CNoiseSuppressorV3::hypergeom_gain(v59, v82 * v83);
      if (v84 > 1.0)
        v84 = 1.0;
      *(float *)(v78 + 4 * v74) = v84;
      v86 = *(float *)(a1 + 220);
      if (v86 >= 0.01)
        v87 = *(float *)(a1 + 220);
      else
        v87 = 0.01;
      if (v121)
        v86 = v87;
      v85 = v17 + (float)((float)(1.0 / (float)((float)(0.5 / *(float *)(v76 + 4 * v74)) + 1.0)) * 0.899);
      v88 = v17;
      v89 = (float)((float)(1.0 - (float)(v86 * v85)) / (float)(1.0 - (float)(1.0 - (float)(v86 * v85))))
          * (float)(*(float *)(v80 + 4 * v74) + 1.0);
      v90 = (float)(v89 * expf(-(float)(v82 * v83))) + 1.0;
      v17 = v88;
      v81[v74] = 1.0 / v90;
      *(float *)(v75 + 4 * v74) = (float)(v122[v74]
                                        * (float)(*(float *)(v78 + 4 * v74) * (float)(*(float *)(v78 + 4 * v74) * 0.8)))
                                + (float)(*(float *)(v75 + 4 * v74) * 0.2);
      ++v74;
    }
    while (v4 > (int)v77 + (int)v74);
    v3 = v77;
    v91 = v119;
    v5 = v120;
  }
  CFilterBank::filterbank_compute_psd16(*(int ***)(a1 + 24), (uint64_t)&v91[v3], v91);
  CFilterBank::filterbank_compute_psd16(*(int ***)(a1 + 24), *(_QWORD *)(a1 + 160) + 4 * v3, *(float **)(a1 + 160));
  vDSP_vsadd(*(const float **)(a1 + 168), 1, &__A, *(float **)(a1 + 752), 1, v3);
  vDSP_vdiv(*(const float **)(a1 + 752), 1, *(const float **)(a1 + 168), 1, *(float **)(a1 + 752), 1, v3);
  vDSP_vsadd(*(const float **)(a1 + 176), 1, &__A, *(float **)(a1 + 744), 1, v3);
  vDSP_vmul(*(const float **)(a1 + 752), 1, *(const float **)(a1 + 744), 1, *(float **)(a1 + 744), 1, v3);
  v93 = *(float **)(a1 + 744);
  if ((_DWORD)v3)
  {
    v94 = *(float **)(a1 + 744);
    v95 = v3;
    do
    {
      *v94 = CNoiseSuppressorV3::hypergeom_gain(v92, *v94);
      ++v94;
      --v95;
    }
    while (v95);
  }
  vDSP_vmul(*(const float **)(a1 + 752), 1, v93, 1, v93, 1, v3);
  vDSP_vclip(*(const float **)(a1 + 744), 1, &v137, &__A, *(float **)(a1 + 744), 1, v3);
  vDSP_vsmul(*(const float **)(a1 + 160), 1, &v129, *(float **)(a1 + 752), 1, v3);
  vDSP_vmin(*(const float **)(a1 + 744), 1, *(const float **)(a1 + 752), 1, *(float **)(a1 + 160), 1, v3);
  vDSP_vsq(*(const float **)(a1 + 160), 1, *(float **)(a1 + 752), 1, v3);
  vDSP_vmul(*(const float **)(a1 + 752), 1, v5, 1, *(float **)(a1 + 752), 1, v3);
  vDSP_vsmul(*(const float **)(a1 + 752), 1, &v132, *(float **)(a1 + 752), 1, v3);
  vDSP_vsma(*(const float **)(a1 + 152), 1, &v133, *(const float **)(a1 + 752), 1, *(float **)(a1 + 152), 1, v3);
  vDSP_vmax(*(const float **)(a1 + 160), 1, *(const float **)(a1 + 120), 1, *(float **)(a1 + 160), 1, v3);
  v96 = *(const float **)(a1 + 752);
  v97 = *(float **)(a1 + 112);
  if ((_DWORD)v3)
  {
    v98 = *(float **)(a1 + 160);
    v99 = *(float **)(a1 + 120);
    v100 = *(float **)(a1 + 112);
    v101 = *(float **)(a1 + 752);
    v102 = v3;
    do
    {
      v103 = *v100++;
      v104 = v103;
      v105 = *v98++;
      v106 = sqrtf(v105);
      v107 = *v99++;
      *v101++ = (float)((float)(1.0 - v104) * sqrtf(v107)) + (float)(v104 * v106);
      --v102;
    }
    while (v102);
  }
  vDSP_vsq(v96, 1, v97, 1, v3);
  vDSP_vmax(*(const float **)(a1 + 112), 1, *(const float **)(a1 + 120), 1, *(float **)(a1 + 112), 1, v3);
  vDSP_vclip(*(const float **)(a1 + 112), 1, &v135, &__A, *(float **)(a1 + 112), 1, v3);
  v108 = 2 * v3;
  v125 = 0.5;
  v126 = 0.25;
  v109 = *(_QWORD *)(a1 + 744);
  *(_DWORD *)v109 = 0;
  v110 = (v3 - 1);
  vDSP_vsmul(*(const float **)(a1 + 112), 1, &v126, (float *)(v109 + 4), 1, v110);
  vDSP_vsma((const float *)(*(_QWORD *)(a1 + 112) + 4), 1, &v126, *(const float **)(a1 + 744), 1, *(float **)(a1 + 744), 1, v110);
  vDSP_vsma(*(const float **)(a1 + 112), 1, &v125, *(const float **)(a1 + 744), 1, *(float **)(a1 + 744), 1, v3);
  v111 = *(float **)(a1 + 112);
  v112 = *(float **)(a1 + 744);
  *v112 = (float)(*v111 + v111[1]) * 0.5;
  v112[v110] = (float)(v111[(v3 - 2)] + v111[v110]) * 0.5;
  memcpy(v111, v112, 4 * v3);
  if (*(int *)(a1 + 44) <= 0)
  {
    v113 = *(const DSPComplex **)(a1 + 96);
    v114 = (v108 - 1);
  }
  else
  {
    vDSP_vmul((const float *)(*(_QWORD *)(a1 + 112) + 4), 1, (const float *)(*(_QWORD *)(a1 + 96) + 4), 2, (float *)(*(_QWORD *)(a1 + 96) + 4), 2, (v3 - 1));
    vDSP_vmul(*(const float **)(a1 + 112), 1, *(const float **)(a1 + 96), 2, *(float **)(a1 + 96), 2, v3);
    v113 = *(const DSPComplex **)(a1 + 96);
    v114 = (v108 - 1);
    *(&v113->real + v114) = *(float *)(*(_QWORD *)(a1 + 112) + 4 * v110)
                                        * *(&v113->real + v114);
  }
  v115 = *(_QWORD *)(a1 + 744);
  v116 = (float *)(v115 + 4 * v3);
  __Z.realp = v116 + 1;
  __Z.imagp = (float *)(v115 + 8);
  vDSP_ctoz(v113 + 1, 2, &__Z, 1, (v3 - 2));
  v117 = *(_DWORD **)(a1 + 96);
  *(_DWORD *)v115 = *v117;
  *(_DWORD *)(v115 + 4) = v117[1];
  *(_DWORD *)(v115 + 4 * v114) = v117[v108 - 2];
  *v116 = *(float *)&v117[v114];
  __Z.realp = (float *)v115;
  __Z.imagp = v116;
  v140[0] = 0.000030518;
  vDSP_vsmul((const float *)v115, 1, v140, (float *)v115, 1, (2 * v3));
  memcpy(*(void **)(a1 + 344), __Z.realp, (4 * v3));
  return memcpy(*(void **)(a1 + 352), __Z.imagp, (4 * v3));
}

void *CResidualSuppressorV3::speex_preprocess_run_freq(uint64_t a1, float **a2, float **a3, float **a4, uint64_t a5)
{
  unsigned int v9;
  vDSP_Length v10;
  vDSP_Length v11;
  const void *v12;
  const float *v13;
  float *v14;
  const float *v15;
  float *v16;
  int v17;
  int v18;
  float *v19;
  const float *v20;
  float *v21;
  int v22;
  float v24;
  float __B;

  v9 = *(_DWORD *)a1;
  if (*(int *)a1 < 1
    || (*(_DWORD *)(a1 + 572) = 0, v9 == 1)
    || (*(_DWORD *)(a1 + 496) = 0, *(_DWORD *)(a1 + 540) = 0, v9 <= 2))
  {
    CResidualSuppressorV3::GetLeakageForSuppressor(a1, *a2, a2[1], *a3, a3[1]);
    CResidualSuppressorV3::GetResidualForSuppressor(a1, a4);
  }
  *(_QWORD *)(a1 + 304) = a5;
  v10 = *(unsigned int *)(a1 + 8);
  v11 = (v10 + *(_DWORD *)(a1 + 16));
  v12 = *(const void **)(a1 + 104);
  v13 = *a2;
  v14 = *(float **)(a1 + 624);
  v24 = 1.0e-20;
  __B = 32768.0;
  vDSP_vsmul(v13, 1, &__B, v14, 1, v10);
  v15 = a2[1];
  v16 = *(float **)(a1 + 632);
  __B = 32768.0;
  vDSP_vsmul(v15, 1, &__B, v16, 1, v10);
  v17 = *(_DWORD *)(a1 + 328);
  if (v17 + 1 < (int)(float)((float)((float)*(int *)(a1 + 12) * 30.0) / (float)v10))
    v18 = v17 + 1;
  else
    v18 = (int)(float)((float)((float)*(int *)(a1 + 12) * 30.0) / (float)v10);
  *(_DWORD *)(a1 + 328) = v18;
  ++*(_DWORD *)(a1 + 332);
  CResidualSuppressorV3::preprocess_analysis_freq(a1, *(_QWORD *)(a1 + 624), *(const void **)(a1 + 632));
  vDSP_vclr(*(float **)(a1 + 136), 1, v11);
  if (*(int *)a1 > 2)
  {
    v20 = *(const float **)(a1 + 104);
    v21 = *(float **)(a1 + 648);
  }
  else
  {
    v19 = *(float **)(a1 + 256);
    if (*v19 < 0.0 || *v19 >= (float)((float)v10 * 1000000000.0))
    {
      vDSP_vclr(v19, 1, v10);
      v19 = *(float **)(a1 + 256);
    }
    vDSP_vmin(v19, 1, *(const float **)(a1 + 104), 1, v19, 1, v10);
    memcpy(*(void **)(a1 + 640), *(const void **)(a1 + 256), 4 * v10);
    vDSP_vsadd(*(const float **)(a1 + 640), 1, &v24, *(float **)(a1 + 640), 1, v10);
    vDSP_vsub(*(const float **)(a1 + 256), 1, *(const float **)(a1 + 104), 1, *(float **)(a1 + 648), 1, v10);
    v20 = *(const float **)(a1 + 648);
    v21 = (float *)v20;
  }
  vDSP_vsadd(v20, 1, &v24, v21, 1, v10);
  if (*(_DWORD *)(a1 + 540) != 1 && !*(_DWORD *)a1
    || (CResidualSuppressorV3::EstimateNoise(a1, *(const float **)(a1 + 648)), !*(_DWORD *)a1)
    || (CFilterBank::filterbank_compute_bank32(*(_QWORD *)(a1 + 24), *(const float **)(a1 + 136), (float *)(*(_QWORD *)(a1 + 136) + 4 * v10)), v22 = *(_DWORD *)a1, *(int *)a1 < 2))
  {
    if (*(_DWORD *)(a1 + 496) == 1)
      CResidualSuppressorV3::AdjustResidual(a1);
    vDSP_vsub(*(const float **)(a1 + 136), 1, *(const float **)(a1 + 104), 1, *(float **)(a1 + 744), 1, v10);
    vDSP_vmin(*(const float **)(a1 + 744), 1, *(const float **)(a1 + 256), 1, *(float **)(a1 + 256), 1, v10);
    vDSP_vmax(*(const float **)(a1 + 256), 1, *(const float **)(a1 + 640), 1, *(float **)(a1 + 256), 1, v10);
    v22 = *(_DWORD *)a1;
  }
  if (v22 <= 2)
  {
    __B = 0.6;
    vDSP_vsmul(*(const float **)(a1 + 248), 1, &__B, *(float **)(a1 + 248), 1, v10);
    vDSP_vmax(*(const float **)(a1 + 248), 1, *(const float **)(a1 + 256), 1, *(float **)(a1 + 248), 1, v10);
    CFilterBank::filterbank_compute_bank32(*(_QWORD *)(a1 + 24), *(const float **)(a1 + 248), (float *)(*(_QWORD *)(a1 + 248) + 4 * v10));
  }
  if (*(_DWORD *)(a1 + 328) == 1)
    memcpy(*(void **)(a1 + 152), v12, 4 * v11);
  return CResidualSuppressorV3::speex_preprocess_run_res_suppressor(a1);
}

void CResidualSuppressorV3::GetLeakageForSuppressor(uint64_t a1, float *a2, float *a3, float *a4, float *a5)
{
  VPEchoGateV3 *v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  float v14;
  vDSP_Length v15;
  float *v16;
  float v17;
  float v18;
  const float *v19;
  vDSP_Length v20;
  const float *v21;
  const float *v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  uint64_t v26;
  uint64_t v27;
  float *v28;
  vDSP_Length v29;
  float *v30;
  float *v31;
  float *v32;
  float *v33;
  float *v34;
  unsigned int *v35;
  float *v36;
  float v37;
  float v38;
  vDSP_Length v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  float v43;
  float v44;
  unsigned int v45;
  vDSP_Length v46;
  unsigned int v47;
  unint64_t v48;
  float v49;
  float v50;
  float v51;
  float v52;
  uint64_t v53;
  unsigned int v54;
  float v55;
  unsigned int v56;
  uint64_t v57;
  float *v58;
  float *v59;
  vDSP_Length v60;
  uint64_t *v61;
  float *v62;
  vDSP_Length v63;
  float *v64;
  VPEchoGateV3 *v65;
  VPEchoGateV3 *v66;
  float *v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t __B;
  uint64_t __C;
  float v72;
  DSPSplitComplex __A;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v72 = 0.001;
  v11 = *(_QWORD *)(a1 + 408);
  v10 = *(VPEchoGateV3 **)(a1 + 416);
  v12 = *(_QWORD *)(a1 + 432);
  v64 = *(float **)(a1 + 424);
  v65 = v10;
  v13 = *(float **)(a1 + 448);
  v14 = *(float *)(a1 + 400);
  v15 = *(int *)(a1 + 4);
  v16 = (float *)*(unsigned int *)(a1 + 460);
  v66 = *(VPEchoGateV3 **)(a1 + 440);
  v67 = v16;
  v17 = *(float *)(a1 + 368);
  v18 = *(float *)(a1 + 372);
  __C = 0;
  __B = 0;
  v19 = *(const float **)(a1 + 480);
  __A.realp = a2;
  __A.imagp = a3;
  vDSP_zvmags(&__A, 1, (float *)v11, 1, v15);
  *(float *)v11 = *a2 * *a2;
  *(float *)(v11 + 4 * v15) = *a3 * *a3;
  __A.realp = a4;
  __A.imagp = a5;
  vDSP_zvmags(&__A, 1, (float *)v12, 1, v15);
  *(float *)v12 = *a4 * *a4;
  *(float *)(v12 + 4 * v15) = *a5 * *a5;
  vDSP_sve((const float *)(v11 + 4), 1, (float *)&__C + 1, v15 - 1);
  vDSP_sve((const float *)(v12 + 4), 1, (float *)&__C, v15 - 1);
  *((float *)&__C + 1) = (float)(*(float *)v11 + (float)(*((float *)&__C + 1) * 2.0)) + *(float *)(v11 + 4 * v15);
  *(float *)&__C = (float)(*(float *)v12 + (float)(*(float *)&__C * 2.0)) + *(float *)(v12 + 4 * v15);
  *(_DWORD *)(a1 + 560) = __C;
  v20 = (int)v67;
  v21 = (const float *)v11;
  v22 = v64;
  vDSP_vmul(v21, 1, v19, 1, v64, 1, (int)v67);
  vDSP_vmul((const float *)v12, 1, v19, 1, v13, 1, (int)v67);
  MEMORY[0x1E0C80A78](v23);
  v25 = (float *)((char *)&v57 - ((v24 + 15) & 0x7FFFFFFF0));
  MEMORY[0x1E0C80A78](v26);
  v28 = (float *)((char *)&v57 - v27);
  v62 = v13;
  vDSP_vsub((const float *)v66, 1, v13, 1, v25, 1, v20);
  vDSP_vsub((const float *)v65, 1, v22, 1, v28, 1, v20);
  v67 = v25;
  vDSP_vmul(v25, 1, v28, 1, v28, 1, v20);
  LODWORD(__A.realp) = 813694978;
  v29 = *(unsigned int *)(a1 + 584);
  v69 = 0;
  v30 = *(float **)(a1 + 608);
  v31 = *(float **)(a1 + 600);
  v33 = *(float **)(a1 + 376);
  v32 = *(float **)(a1 + 384);
  v34 = *(float **)(a1 + 392);
  v35 = *(unsigned int **)(a1 + 592);
  v68 = 0;
  v63 = v29;
  v61 = &v57;
  if ((_DWORD)v29 == 1)
  {
    v36 = v67;
    vDSP_svesq(v67, 1, (float *)&v69 + 1, v20);
    vDSP_sve(v28, 1, (float *)&v69, v20);
    *(float *)&v69 = *(float *)&v69 + 8.6736e-19;
    v37 = *(float *)&v69;
    *((float *)&v69 + 1) = *((float *)&v69 + 1) + 8.6736e-19;
    v38 = sqrtf(*((float *)&v69 + 1));
    *v30 = v38;
    *v31 = v37 / v38;
    v39 = v63;
  }
  else
  {
    v58 = v33;
    v59 = v32;
    v60 = v20;
    v40 = v35[1];
    HIDWORD(v68) = 0;
    vDSP_svesq(v67, 1, (float *)&v68 + 1, v40 + 1);
    vDSP_sve(v28, 1, (float *)&v68, v40 + 1);
    v41 = 0;
    v42 = (v63 - 1);
    v44 = *((float *)&v68 + 1);
    v43 = *(float *)&v68;
    do
    {
      v45 = v35[(v41 + 2)];
      v46 = v45 - v40;
      v47 = v40 + 1;
      vDSP_svesq(&v67[v47], 1, (float *)&v68 + 1, v46);
      vDSP_sve(&v28[v47], 1, (float *)&v68, v46);
      v48 = v68;
      v49 = (float)(v43 + *(float *)&v68) + 8.6736e-19;
      *(float *)&v69 = v49;
      *((float *)&v69 + 1) = (float)(v44 + *((float *)&v68 + 1)) + 8.6736e-19;
      v50 = sqrtf(*((float *)&v69 + 1));
      v30[v41] = v50;
      v31[v41++] = v49 / v50;
      LODWORD(v44) = HIDWORD(v48);
      LODWORD(v43) = v48;
      v40 = v45;
    }
    while (v42 != v41);
    v39 = v63;
    v30[v42] = v30[(v63 - 2)];
    v31[v42] = v31[(v39 - 2)];
    v20 = v60;
    v32 = v59;
    v33 = v58;
    v36 = v67;
  }
  v51 = v17 * *(float *)&__C;
  if ((float)(v17 * *(float *)&__C) > (float)(v18 * *((float *)&__C + 1)))
    v51 = v18 * *((float *)&__C + 1);
  v52 = v51 / *((float *)&__C + 1);
  if (*((float *)&__C + 1) < 9.3132e-19)
    v52 = v18;
  *((float *)&__B + 1) = v52;
  *(float *)&__B = 1.0 - v52;
  vDSP_vsmul(v31, 1, (const float *)&__B + 1, v31, 1, v39);
  vDSP_vsma(v33, 1, (const float *)&__B, v31, 1, v33, 1, v39);
  vDSP_vsmul(v30, 1, (const float *)&__B + 1, v30, 1, v39);
  vDSP_vsma(v32, 1, (const float *)&__B, v30, 1, v32, 1, v39);
  vDSP_vthr(v32, 1, (const float *)&__A, v32, 1, v39);
  vDSP_vsmul(v32, 1, &v72, v36, 1, v39);
  vDSP_vmax(v36, 1, v33, 1, v33, 1, v39);
  vDSP_vmin(v33, 1, v32, 1, v33, 1, v39);
  if ((_DWORD)v39)
  {
    v53 = 0;
    v54 = *v35;
    do
    {
      if (v53)
      {
        v55 = v33[v53] / v32[v53];
        if (v55 <= *v34)
          v55 = *v34;
      }
      else
      {
        v55 = *v33 / *v32;
      }
      v56 = v35[++v53];
      while (v54 <= v56)
        v34[v54++] = v55;
      v54 = v56;
    }
    while (v53 != v39);
  }
  VPEchoGateV3::GatesmoothPowerSpectrum(v65, v64, (const float *)v20, v14);
  VPEchoGateV3::GatesmoothPowerSpectrum(v66, v62, (const float *)v20, v14);
}

void CResidualSuppressorV3::GetResidualForSuppressor(uint64_t a1, float **a2)
{
  vDSP_Length v4;
  float *v5;
  float *v6;
  vDSP_Length v7;
  float v8;
  float *v9;
  float *v10;
  float *v11;
  float v12;
  float __B;
  DSPSplitComplex __A;

  v4 = *(unsigned int *)(a1 + 4);
  memcpy(*(void **)(a1 + 656), *(const void **)(a1 + 392), 4 * v4);
  v5 = *(float **)(a1 + 656);
  __B = 2.0;
  vDSP_vsmul(v5, 1, &__B, v5, 1, v4);
  if ((_DWORD)v4)
  {
    v6 = v5;
    v7 = v4;
    do
    {
      v8 = *(float *)(a1 + 500);
      if (*v6 > v8)
        *v6 = v8;
      ++v6;
      --v7;
    }
    while (v7);
  }
  v12 = 1073700000.0;
  vDSP_vsmul(v5, 1, &v12, v5, 1, v4);
  if (*(_DWORD *)(a1 + 488) || *(float *)(a1 + 492) < (float)((float)((float)*(int *)(a1 + 456) * 500.0) * 9.3132e-10))
  {
    v9 = *(float **)(a1 + 432);
  }
  else
  {
    v10 = *a2;
    v11 = a2[1];
    v9 = *(float **)(a1 + 408);
    __A.realp = v10;
    __A.imagp = v11;
    vDSP_zvmags(&__A, 1, v9, 1, (int)v4);
    *v9 = *v10 * *v10;
    v9[(int)v4] = *v11 * *v11;
  }
  vDSP_vmul(v9, 1, v5, 1, *(float **)(a1 + 256), 1, v4);
}

NSObject *CResidualSuppressorV3::speex_preprocess_state_res_init(CResidualSuppressorV3 *this, int a2)
{
  int v3;
  NSObject *v4;
  NSObject *v5;
  int v6;
  uint64_t *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  objc_class *v12;
  objc_class *v13;
  objc_class *v14;
  objc_class *v15;
  objc_class *v16;
  objc_class *v17;
  objc_class *v18;
  objc_class *v19;
  objc_class *v20;
  objc_class *v21;
  objc_class *v22;
  objc_class *v23;
  objc_class *v24;
  objc_class *v25;
  objc_class *v26;
  objc_class *v27;
  objc_class *v28;
  objc_class *v29;
  objc_class *v30;
  objc_class *v31;
  objc_class *v32;
  objc_class *v33;
  objc_class *v34;
  objc_class *v35;
  objc_class *v36;
  objc_class *v37;
  objc_class *v38;
  objc_class *v39;
  objc_class *v40;
  objc_class *v41;
  int v42;
  objc_class *v43;
  objc_class *v44;
  objc_class *v45;
  objc_class *v46;
  objc_class *v47;
  objc_class *v48;
  objc_class *v49;
  objc_class *v50;
  objc_class *v51;
  objc_class *v52;
  int isa;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  float v57;
  float v58;
  float *v59;
  float *v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v69;
  float v70;
  objc_class *v72;
  objc_class *v73;
  objc_class *v74;
  objc_class *v75;
  int v76;
  _DWORD *v77;
  _DWORD *v78;
  _DWORD *v79;
  uint64_t v80;
  _DWORD *v81;
  _DWORD *v82;
  uint64_t v83;
  _DWORD *v84;
  _DWORD *v85;
  int v86;
  objc_class *v87;
  objc_class *v88;
  objc_class *v89;
  objc_class *v90;
  int isa_high;
  uint64_t v92;
  float v93;
  float v94;
  int v95;
  objc_class *v96;
  objc_class *v97;
  objc_class *v98;
  objc_class *v99;
  objc_class *v100;
  objc_class *v101;
  objc_class *v102;
  objc_class *v103;
  objc_class *v104;
  objc_class *v105;
  objc_class *v106;
  objc_class *v107;
  objc_class *v108;
  objc_class *v109;
  objc_class *v110;
  objc_class *v111;
  float v112;
  objc_class *v113;
  objc_class *v114;
  MultiRadixRealFFT *v115;
  float *v116;
  _DWORD *v117;
  _DWORD *v118;
  objc_class *v119;
  objc_class *v120;
  objc_class *v121;
  objc_class *v122;
  float v123;
  float v124;
  float v125;
  uint64_t v126;
  int v127;
  objc_class *v128;
  objc_class *v130;
  int32x2_t v131;
  unint64_t v132;
  uint64_t v133;
  uint64x2_t v134;
  float32x2_t v135;
  int v136;
  uint32x2_t v137;
  int32x2_t v138;
  float32x2_t v139;
  int v140;
  int v141;
  objc_class *v142;
  objc_class *v143;
  objc_class *v144;
  objc_class *v145;
  objc_class *v146;
  objc_class *v147;
  objc_class *v148;
  objc_class *v149;
  _DWORD *v150;
  _DWORD *v151;
  objc_class *v152;
  objc_class *v153;
  objc_class *v154;
  objc_class *v155;
  objc_class *v156;
  objc_class *v157;
  objc_class *v158;
  objc_class *v159;
  objc_class *v160;
  objc_class *v161;
  objc_class *v162;
  objc_class *v163;
  int v164;
  float v165;
  float v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  std::bad_alloc *exception;
  std::bad_alloc *v175;
  int v176;
  size_t v177;
  int v178;
  _BYTE __A[18];
  uint64_t v180;

  v3 = (int)this;
  v180 = *MEMORY[0x1E0C80C00];
  v4 = malloc_type_malloc(0x2F8uLL, 0x2C8E6D5CuLL);
  if (!v4)
    goto LABEL_181;
  v5 = v4;
  bzero(&v4[2], 0x2E8uLL);
  LODWORD(v5->isa) = 0;
  HIDWORD(v5->isa) = v3;
  LODWORD(v5[4].isa) = -6;
  *(_OWORD *)&v5[6].isa = xmmword_1B66A2910;
  v6 = 2 * v3;
  LODWORD(v5[1].isa) = v3;
  HIDWORD(v5[1].isa) = a2;
  v7 = (uint64_t *)&v5[42];
  if (!MultiRadixRealFFT_Create(2 * v3, &v5[42].isa))
  {
    *(Class *)((char *)&v5[4].isa + 4) = (Class)0xFFFFFFF1FFFFFFD8;
    HIDWORD(v5[5].isa) = 1;
    LODWORD(v5[2].isa) = 24;
    v8 = (float)a2;
    v5[3].isa = (Class)CFilterBank::filterbank_new((CFilterBank *)0x18, v3, (float)a2);
    v9 = (float)v3;
    v10 = (float)a2 / (float)v3;
    *(float *)&v5[33].isa = expf(-1.0 / (float)(v10 * 0.04));
    *((float *)&v5[33].isa + 1) = expf(-1.0 / (float)(v10 * 0.005));
    v11 = expf(-1.0 / (float)(v10 * 0.02));
    *(float *)&v5[34].isa = v11;
    *((float *)&v5[34].isa + 1) = v11;
    *(float *)&v5[35].isa = 1.0 - expf(-1.0 / (float)(v10 * 0.1));
    *((float *)&v5[36].isa + 1) = 1.0 - expf(-1.0 / (float)(v10 * 0.05));
    LODWORD(v5[37].isa) = 1094713344;
    *((float *)&v5[35].isa + 1) = 1.0 - expf(-1.0 / (float)(v10 * 0.5));
    LODWORD(v5[36].isa) = 1112014848;
    v5[38].isa = 0;
    v12 = (objc_class *)malloc_type_malloc(4 * v6, 0x2C8E6D5CuLL);
    v13 = v12;
    if (!v3 || v12)
    {
      bzero(v12, 4 * v6);
      v5[11].isa = v13;
      v14 = (objc_class *)malloc_type_malloc(4 * v6, 0x2C8E6D5CuLL);
      v15 = v14;
      if (!v3 || v14)
      {
        bzero(v14, 4 * v6);
        v5[16].isa = v15;
        v16 = (objc_class *)malloc_type_malloc(4 * v6, 0x2C8E6D5CuLL);
        v17 = v16;
        if (!v3 || v16)
        {
          v178 = v3 + 24;
          bzero(v16, 4 * v6);
          v5[12].isa = v17;
          v18 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
          v19 = v18;
          if (!(4 * (v3 + 24)) || v18)
          {
            bzero(v18, (4 * (v3 + 24)));
            v5[13].isa = v19;
            v20 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
            v21 = v20;
            if (!(4 * (v3 + 24)) || v20)
            {
              bzero(v20, (4 * (v3 + 24)));
              v5[17].isa = v21;
              v22 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
              v23 = v22;
              if (!(4 * (v3 + 24)) || v22)
              {
                bzero(v22, (4 * (v3 + 24)));
                v5[18].isa = v23;
                v24 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
                v25 = v24;
                if (!(4 * (v3 + 24)) || v24)
                {
                  bzero(v24, (4 * (v3 + 24)));
                  v5[31].isa = v25;
                  v26 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
                  v27 = v26;
                  if (!(4 * (v3 + 24)) || v26)
                  {
                    bzero(v26, (4 * (v3 + 24)));
                    v5[32].isa = v27;
                    v28 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
                    v29 = v28;
                    if (!(4 * (v3 + 24)) || v28)
                    {
                      bzero(v28, (4 * (v3 + 24)));
                      v5[19].isa = v29;
                      v30 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
                      v31 = v30;
                      if (!(4 * (v3 + 24)) || v30)
                      {
                        bzero(v30, (4 * (v3 + 24)));
                        v5[21].isa = v31;
                        v32 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
                        v33 = v32;
                        if (!(4 * (v3 + 24)) || v32)
                        {
                          bzero(v32, (4 * (v3 + 24)));
                          v5[22].isa = v33;
                          v34 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
                          v35 = v34;
                          if (!(4 * (v3 + 24)) || v34)
                          {
                            bzero(v34, (4 * (v3 + 24)));
                            v5[20].isa = v35;
                            v36 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
                            v37 = v36;
                            if (!(4 * (v3 + 24)) || v36)
                            {
                              bzero(v36, (4 * (v3 + 24)));
                              v5[14].isa = v37;
                              v38 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
                              v39 = v38;
                              if (!(4 * (v3 + 24)) || v38)
                              {
                                bzero(v38, (4 * (v3 + 24)));
                                v5[15].isa = v39;
                                v40 = (objc_class *)malloc_type_malloc((4 * (v3 + 24)), 0x2C8E6D5CuLL);
                                v41 = v40;
                                if (!(4 * (v3 + 24)) || v40)
                                {
                                  bzero(v40, (4 * (v3 + 24)));
                                  v5[30].isa = v41;
                                  v42 = 4 * v3;
                                  v43 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                  v44 = v43;
                                  if (!(4 * v3) || v43)
                                  {
                                    bzero(v43, (4 * v3));
                                    v5[23].isa = v44;
                                    v45 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                    v46 = v45;
                                    if (!v42 || v45)
                                    {
                                      bzero(v45, (4 * v3));
                                      v5[24].isa = v46;
                                      v47 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                      v48 = v47;
                                      if (!v42 || v47)
                                      {
                                        bzero(v47, (4 * v3));
                                        v5[25].isa = v48;
                                        v49 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                        v50 = v49;
                                        if (!v42 || v49)
                                        {
                                          bzero(v49, (4 * v3));
                                          v5[26].isa = v50;
                                          LODWORD(v5[9].isa) = 6;
                                          v5[8].isa = (Class)CResidualSuppressorV3::setup_update_thresh_lut(int,int,RESSpeexPair_tV3 **,int *,float **)::threshold_points;
                                          *(float *)&dword_1EF1347A8 = v8 * 0.5;
                                          v51 = (objc_class *)malloc_type_malloc(4 * v3, 0x2C8E6D5CuLL);
                                          v52 = v51;
                                          if (!v3 || v51)
                                          {
                                            bzero(v51, 4 * v3);
                                            v5[10].isa = v52;
                                            isa = (int)v5[9].isa;
                                            if (isa >= 2)
                                            {
                                              v54 = 0;
                                              LODWORD(v55) = 0;
                                              v56 = (isa - 1);
                                              v57 = v9
                                                  / (float)(CResidualSuppressorV3::setup_update_thresh_lut(int,int,RESSpeexPair_tV3 **,int *,float **)::threshold_points[2 * (int)v56]
                                                          - CResidualSuppressorV3::setup_update_thresh_lut(int,int,RESSpeexPair_tV3 **,int *,float **)::threshold_points[0]);
                                              v58 = CResidualSuppressorV3::setup_update_thresh_lut(int,int,RESSpeexPair_tV3 **,int *,float **)::threshold_points[0]
                                                  * v57;
                                              do
                                              {
                                                v59 = &CResidualSuppressorV3::setup_update_thresh_lut(int,int,RESSpeexPair_tV3 **,int *,float **)::threshold_points[2 * v54++];
                                                v60 = &CResidualSuppressorV3::setup_update_thresh_lut(int,int,RESSpeexPair_tV3 **,int *,float **)::threshold_points[2 * v54];
                                                v61 = v59[1];
                                                v63 = *v60;
                                                v62 = v60[1];
                                                v64 = v57 * (float)((float)(*v59 + *v60) * 0.5);
                                                v65 = (float)(v61 + v62) * 0.5;
                                                if (v58 < v64)
                                                {
                                                  v66 = v57 * *v59;
                                                  v55 = (int)v55;
                                                  do
                                                  {
                                                    *((float *)v52 + v55++) = v61
                                                                            + (float)((float)((float)((float)(v58 - v66) / (float)(v64 - v66))
                                                                                            * (float)((float)(v58 - v66) / (float)(v64 - v66)))
                                                                                    * (float)(v65 - v61));
                                                    v58 = v58 + 1.0;
                                                  }
                                                  while (v58 < v64);
                                                }
                                                v67 = v57 * v63;
                                                if (v58 < v67 && (int)v55 < v3)
                                                {
                                                  v69 = v64 - v67;
                                                  v70 = v62 - v65;
                                                  v55 = (int)v55;
                                                  do
                                                  {
                                                    *((float *)v52 + v55++) = v65
                                                                            + (float)((float)(1.0
                                                                                            - (float)((float)((float)(v58 - v67) / v69) * (float)((float)(v58 - v67) / v69)))
                                                                                    * v70);
                                                    v58 = v58 + 1.0;
                                                  }
                                                  while (v58 < v67 && v55 < v3);
                                                }
                                              }
                                              while (v54 != v56);
                                            }
                                            v72 = (objc_class *)malloc_type_malloc(4 * v3, 0x2C8E6D5CuLL);
                                            v73 = v72;
                                            if (!v3 || v72)
                                            {
                                              bzero(v72, 4 * v3);
                                              v5[39].isa = v73;
                                              v74 = (objc_class *)malloc_type_malloc(4 * v3, 0x2C8E6D5CuLL);
                                              v75 = v74;
                                              if (!v3 || v74)
                                              {
                                                bzero(v74, 4 * v3);
                                                v5[40].isa = v75;
                                                HIDWORD(v5[37].isa) = 0;
                                                CreateMagicalWindow((uint64_t)v5[16].isa, 2 * v3);
                                                v76 = (int)v5[1].isa;
                                                if (v6 < 2 * v76)
                                                  memset_pattern16((char *)v5[16].isa + 4 * v6, &unk_1B6627B80, 4 * (2 * v76 - v6 - 2) + 8);
                                                if (v3 < -23)
                                                  goto LABEL_82;
                                                v77 = v5[17].isa;
                                                v78 = v5[19].isa;
                                                v79 = v5[20].isa;
                                                v80 = v178 <= 1 ? 1 : v178;
                                                v82 = v5[21].isa;
                                                v81 = v5[22].isa;
                                                do
                                                {
                                                  *v77++ = 1065353216;
                                                  *v78++ = 1065353216;
                                                  *v79++ = 1065353216;
                                                  *v81++ = 1065353216;
                                                  *v82++ = 1065353216;
                                                  --v80;
                                                }
                                                while (v80);
                                                if (v3 <= 0)
                                                {
LABEL_82:
                                                  v86 = 0;
                                                }
                                                else
                                                {
                                                  v83 = v3;
                                                  memset_pattern16(v5[26].isa, &unk_1B6627B80, 4 * v3);
                                                  v84 = v5[39].isa;
                                                  v85 = v5[40].isa;
                                                  do
                                                  {
                                                    *v84++ = 0;
                                                    *v85++ = 0;
                                                    --v83;
                                                  }
                                                  while (v83);
                                                  v86 = 1;
                                                }
                                                v87 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                                v88 = v87;
                                                if (!v42 || v87)
                                                {
                                                  bzero(v87, (4 * v3));
                                                  v5[43].isa = v88;
                                                  v89 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                                  v90 = v89;
                                                  if (!v42 || v89)
                                                  {
                                                    bzero(v89, (4 * v3));
                                                    v5[44].isa = v90;
                                                    v5[41].isa = 0;
                                                    isa_high = HIDWORD(v5->isa);
                                                    LODWORD(v5[57].isa) = 2 * isa_high;
                                                    v92 = (isa_high + 1);
                                                    HIDWORD(v5[57].isa) = v92;
                                                    v93 = (float)-(float)isa_high / (float)SHIDWORD(v5[1].isa);
                                                    v94 = 1.0 - expf(v93 / 0.1616);
                                                    *(float *)&v5[46].isa = v94;
                                                    *((float *)&v5[46].isa + 1) = v94 * 0.25;
                                                    *(float *)&v5[50].isa = 1.0 - expf(v93 / 0.6617);
                                                    v95 = 4 * v92;
                                                    v96 = (objc_class *)malloc_type_malloc((4 * v92), 0x2C8E6D5CuLL);
                                                    v97 = v96;
                                                    if (!(4 * (_DWORD)v92) || v96)
                                                    {
                                                      bzero(v96, (4 * v92));
                                                      v5[51].isa = v97;
                                                      v98 = (objc_class *)malloc_type_malloc((4 * v92), 0x2C8E6D5CuLL);
                                                      v99 = v98;
                                                      if (!v95 || v98)
                                                      {
                                                        bzero(v98, (4 * v92));
                                                        v5[52].isa = v99;
                                                        v100 = (objc_class *)malloc_type_malloc((4 * v92), 0x2C8E6D5CuLL);
                                                        v101 = v100;
                                                        if (!v95 || v100)
                                                        {
                                                          bzero(v100, (4 * v92));
                                                          v5[53].isa = v101;
                                                          v102 = (objc_class *)malloc_type_malloc((4 * v92), 0x2C8E6D5CuLL);
                                                          v103 = v102;
                                                          if (!v95 || v102)
                                                          {
                                                            bzero(v102, (4 * v92));
                                                            v5[54].isa = v103;
                                                            v104 = (objc_class *)malloc_type_malloc((4 * v92), 0x2C8E6D5CuLL);
                                                            v105 = v104;
                                                            if (!v95 || v104)
                                                            {
                                                              bzero(v104, (4 * v92));
                                                              v5[55].isa = v105;
                                                              v106 = (objc_class *)malloc_type_malloc((4 * v92), 0x2C8E6D5CuLL);
                                                              v107 = v106;
                                                              if (!v95 || v106)
                                                              {
                                                                bzero(v106, (4 * v92));
                                                                v5[56].isa = v107;
                                                                v108 = (objc_class *)malloc_type_malloc((4 * v92), 0x2C8E6D5CuLL);
                                                                v109 = v108;
                                                                if (!v95 || v108)
                                                                {
                                                                  v176 = v86;
                                                                  v177 = 4 * v178;
                                                                  bzero(v108, (4 * v92));
                                                                  v5[60].isa = v109;
                                                                  v110 = (objc_class *)malloc_type_malloc((4 * v92), 0x2C8E6D5CuLL);
                                                                  v111 = v110;
                                                                  if (!v95 || v110)
                                                                  {
                                                                    bzero(v110, (4 * v92));
                                                                    v5[49].isa = v111;
                                                                    v113 = v5[51].isa;
                                                                    v114 = v5[52].isa;
                                                                    v5[58].isa = v113;
                                                                    v5[59].isa = v114;
                                                                    *(_DWORD *)v113 = 1065353216;
                                                                    *(_DWORD *)v114 = -1083808154;
                                                                    v115 = v5[42].isa;
                                                                    if (v115)
                                                                    {
                                                                      MultiRadixRealFFT::RealInPlaceTransform(v115, (DSPSplitComplex *)&v5[58], 1, v112);
                                                                      v113 = v5[58].isa;
                                                                      v114 = v5[59].isa;
                                                                    }
                                                                    v116 = (float *)v5[60].isa;
                                                                    *(_QWORD *)__A = v113;
                                                                    *(_QWORD *)&__A[8] = v114;
                                                                    vDSP_zvmags((const DSPSplitComplex *)__A, 1, v116, 1, v3);
                                                                    *v116 = *(float *)v113 * *(float *)v113;
                                                                    v116[v3] = *(float *)v114 * *(float *)v114;
                                                                    if ((isa_high & 0x80000000) == 0)
                                                                    {
                                                                      v117 = v5[51].isa;
                                                                      v118 = v5[52].isa;
                                                                      do
                                                                      {
                                                                        *v117++ = 0;
                                                                        *v118++ = 0;
                                                                        --v92;
                                                                      }
                                                                      while (v92);
                                                                    }
                                                                    v5[61].isa = 0;
                                                                    LODWORD(v5[62].isa) = 0;
                                                                    *(_OWORD *)((char *)&v5[62].isa + 4) = xmmword_1B6627DC0;
                                                                    *(_OWORD *)((char *)&v5[64].isa + 4) = xmmword_1B66A17D0;
                                                                    *(Class *)((char *)&v5[66].isa + 4) = (Class)0x3F8000003F800000;
                                                                    HIDWORD(v5[70].isa) = 0;
                                                                    *(Class *)((char *)&v5[68].isa + 4) = 0;
                                                                    *(Class *)((char *)&v5[69].isa + 4) = 0;
                                                                    *(Class *)((char *)&v5[67].isa + 4) = 0;
                                                                    LODWORD(v5[71].isa) = (float)(0.2 / (float)((float)SLODWORD(v5[1].isa) / (float)SHIDWORD(v5[1].isa)));
                                                                    v5[27].isa = 0;
                                                                    v119 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                                                    v120 = v119;
                                                                    if (!v42 || v119)
                                                                    {
                                                                      bzero(v119, (4 * v3));
                                                                      v5[78].isa = v120;
                                                                      v121 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                                                      v122 = v121;
                                                                      if (!v42 || v121)
                                                                      {
                                                                        bzero(v121, (4 * v3));
                                                                        v5[79].isa = v122;
                                                                        *(Class *)((char *)&v5[71].isa + 4) = (Class)0x100000001;
                                                                        HIDWORD(v5[72].isa) = 1157234688;
                                                                        v123 = (float)SHIDWORD(v5[1].isa);
                                                                        v124 = (float)(v123 * 0.5) / 2000.0;
                                                                        v125 = floorf(v124);
                                                                        if (v124 > v125)
                                                                          v124 = v125 + 1.0;
                                                                        v126 = v124;
                                                                        LODWORD(v5[73].isa) = v126;
                                                                        v127 = (int)v5[57].isa;
                                                                        v128 = (objc_class *)malloc_type_malloc(4* (v126 + 1), 0x2C8E6D5CuLL);
                                                                        if (v128 || (_DWORD)v126 == -1)
                                                                        {
                                                                          v130 = v128;
                                                                          bzero(v128, 4 * (v126 + 1));
                                                                          v5[74].isa = v130;
                                                                          *(_DWORD *)v130 = 0;
                                                                          if (v126 <= 1)
                                                                          {
                                                                            v136 = v176;
                                                                          }
                                                                          else
                                                                          {
                                                                            v132 = 0;
                                                                            *(float *)v131.i32 = v123
                                                                                               / (float)(v127 - 1);
                                                                            v133 = *(uint64_t *)((char *)&v5[72].isa + 4);
                                                                            v134 = (uint64x2_t)vdupq_n_s64(v126 - 2);
                                                                            v135 = (float32x2_t)vdup_lane_s32(v131, 0);
                                                                            v136 = v176;
                                                                            do
                                                                            {
                                                                              v137.i32[0] = v132 | 1;
                                                                              v137.i32[1] = vadd_s32(vdup_lane_s32((int32x2_t)v132, 0), (int32x2_t)0x200000002).i32[1];
                                                                              v138 = vmovn_s64((int64x2_t)vcgeq_u64(v134, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v132), (int8x16_t)xmmword_1B6626830)));
                                                                              v139 = vrndm_f32(vdiv_f32(vmul_n_f32(vcvt_f32_u32(v137), *(float *)&v133), v135));
                                                                              if ((v138.i8[0] & 1) != 0)
                                                                                *((_DWORD *)v130 + v132 + 1) = v139.f32[0];
                                                                              if ((v138.i8[4] & 1) != 0)
                                                                                *((_DWORD *)v130 + v132 + 2) = v139.f32[1];
                                                                              v132 += 2;
                                                                            }
                                                                            while ((v126 & 0xFFFFFFFE) != v132);
                                                                          }
                                                                          v140 = v3 - 1;
                                                                          *((_DWORD *)v130 + v126) = v3 - 1;
                                                                          v141 = 4 * v126;
                                                                          v142 = (objc_class *)malloc_type_malloc((4 * v126), 0x2C8E6D5CuLL);
                                                                          v143 = v142;
                                                                          if (!(4 * (_DWORD)v126) || v142)
                                                                          {
                                                                            bzero(v142, (4 * v126));
                                                                            v5[47].isa = v143;
                                                                            v144 = (objc_class *)malloc_type_malloc((4 * v126), 0x2C8E6D5CuLL);
                                                                            v145 = v144;
                                                                            if (!v141 || v144)
                                                                            {
                                                                              bzero(v144, (4 * v126));
                                                                              v5[48].isa = v145;
                                                                              v146 = (objc_class *)malloc_type_malloc((4 * v126), 0x2C8E6D5CuLL);
                                                                              v147 = v146;
                                                                              if (!v141 || v146)
                                                                              {
                                                                                bzero(v146, (4 * v126));
                                                                                v5[75].isa = v147;
                                                                                v148 = (objc_class *)malloc_type_malloc((4 * v126), 0x2C8E6D5CuLL);
                                                                                v149 = v148;
                                                                                if (!v141 || v148)
                                                                                {
                                                                                  bzero(v148, (4 * v126));
                                                                                  v5[76].isa = v149;
                                                                                  if ((_DWORD)v126)
                                                                                  {
                                                                                    v150 = v5[47].isa;
                                                                                    v151 = v5[48].isa;
                                                                                    do
                                                                                    {
                                                                                      *v150++ = 813694978;
                                                                                      *v151++ = 813694978;
                                                                                      --v126;
                                                                                    }
                                                                                    while (v126);
                                                                                  }
                                                                                  v152 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                                                                  v153 = v152;
                                                                                  if (!v42 || v152)
                                                                                  {
                                                                                    bzero(v152, (4 * v3));
                                                                                    v5[77].isa = v153;
                                                                                    if (v136)
                                                                                      memset_pattern16(v153, &unk_1B6627B80, 4 * v3);
                                                                                    v154 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                                                                    v155 = v154;
                                                                                    if (!v42 || v154)
                                                                                    {
                                                                                      bzero(v154, (4 * v3));
                                                                                      v5[80].isa = v155;
                                                                                      v156 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                                                                      v157 = v156;
                                                                                      if (!v42 || v156)
                                                                                      {
                                                                                        bzero(v156, (4 * v3));
                                                                                        v5[81].isa = v157;
                                                                                        v158 = (objc_class *)malloc_type_malloc((4 * v3), 0x2C8E6D5CuLL);
                                                                                        v159 = v158;
                                                                                        if (!v42 || v158)
                                                                                        {
                                                                                          bzero(v158, (4 * v3));
                                                                                          v5[82].isa = v159;
                                                                                          LODWORD(v5[83].isa) = v5[1].isa;
                                                                                          *(Class *)((char *)&v5[83].isa + 4) = (Class)0xC28C000000000000;
                                                                                          v160 = (objc_class *)malloc_type_malloc(4 * (v178 + v3), 0x2C8E6D5CuLL);
                                                                                          v161 = v160;
                                                                                          if (!(v178 + v3) || v160)
                                                                                          {
                                                                                            bzero(v160, 4 * (v178 + v3));
                                                                                            v5[93].isa = v161;
                                                                                            v162 = (objc_class *)malloc_type_malloc(v177, 0x2C8E6D5CuLL);
                                                                                            v163 = v162;
                                                                                            if (v3 == -24 || v162)
                                                                                            {
                                                                                              bzero(v162, v177);
                                                                                              v5[94].isa = v163;
                                                                                              HIDWORD(v5[84].isa) = 0;
                                                                                              v164 = HIDWORD(v5[1].isa);
                                                                                              *(float *)&v5[85].isa = 1.0 - expf(-1.0 / (float)((float)v164 / (float)(v9 + v9)));
                                                                                              LODWORD(v5[86].isa) = 1117782016;
                                                                                              v165 = (double)v164 / ((double)v3 + (double)v3);
                                                                                              v166 = 1.0 / v165;
                                                                                              v167 = (int)(float)(v166 * 150.0);
                                                                                              if (v140 < v167)
                                                                                                v167 = v3 - 1;
                                                                                              HIDWORD(v5[86].isa) = v167;
                                                                                              v168 = (int)(float)(v166 * 200.0);
                                                                                              if (v167 >= v168)
                                                                                                v168 = v167 + 1;
                                                                                              if (v168 >= v140)
                                                                                                v168 = v3 - 1;
                                                                                              LODWORD(v5[87].isa) = v168;
                                                                                              v169 = (int)(float)(v166 * 400.0);
                                                                                              if (v168 >= v169)
                                                                                                v169 = v168 + 1;
                                                                                              if (v169 >= v140)
                                                                                                v169 = v3 - 1;
                                                                                              v170 = (int)(float)(v166 * 800.0);
                                                                                              HIDWORD(v5[87].isa) = v169;
                                                                                              if (v169 >= v170)
                                                                                                v170 = v169 + 1;
                                                                                              if (v170 >= v140)
                                                                                                v170 = v3 - 1;
                                                                                              LODWORD(v5[88].isa) = v170;
                                                                                              v171 = (int)(float)(v166 * 1100.0);
                                                                                              if (v170 >= v171)
                                                                                                v171 = v170 + 1;
                                                                                              if (v171 >= v140)
                                                                                                v171 = v3 - 1;
                                                                                              HIDWORD(v5[88].isa) = v171;
                                                                                              v172 = (int)(float)(v166 * 4000.0);
                                                                                              if (v171 >= v172)
                                                                                                v172 = v171 + 1;
                                                                                              if (v172 >= v140)
                                                                                                v172 = v3 - 1;
                                                                                              LODWORD(v5[89].isa) = v172;
                                                                                              HIDWORD(v5[89].isa) = v168 - v167;
                                                                                              LODWORD(v5[90].isa) = v169 - v168;
                                                                                              HIDWORD(v5[90].isa) = v170 - v169;
                                                                                              LODWORD(v5[91].isa) = v171 - v170;
                                                                                              HIDWORD(v5[91].isa) = v172 - v171;
                                                                                              *((float *)&v5[85].isa + 1) = 1.0 / (float)((float)((float)v172 + (float)v172) * (float)v172);
                                                                                              return v5;
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_181:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v175 = std::bad_alloc::bad_alloc(exception);
  }
  if (*v7)
    MultiRadixFFT_Dispose(*v7);
  free(v5);
  if (SuppressorClassLogScope(void)::once != -1)
    dispatch_once(&SuppressorClassLogScope(void)::once, &__block_literal_global_5244);
  if (SuppressorClassLogScope(void)::scope)
  {
    v5 = *(NSObject **)SuppressorClassLogScope(void)::scope;
    if (!*(_QWORD *)SuppressorClassLogScope(void)::scope)
      return v5;
  }
  else
  {
    v5 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__A = 136315394;
    *(_QWORD *)&__A[4] = "CResidualSuppressorV3.cpp";
    *(_WORD *)&__A[12] = 1024;
    *(_DWORD *)&__A[14] = 1246;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d MultiRadixRealFFT_Create() returned an error. Invalid block size?", __A, 0x12u);
  }
  return 0;
}

void CResidualSuppressorV3::speex_preprocess_state_res_destroy(uint64_t a1)
{
  free(*(void **)(a1 + 88));
  free(*(void **)(a1 + 96));
  free(*(void **)(a1 + 104));
  free(*(void **)(a1 + 112));
  free(*(void **)(a1 + 120));
  free(*(void **)(a1 + 128));
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 144));
  free(*(void **)(a1 + 152));
  free(*(void **)(a1 + 160));
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 176));
  free(*(void **)(a1 + 248));
  free(*(void **)(a1 + 256));
  free(*(void **)(a1 + 184));
  free(*(void **)(a1 + 192));
  free(*(void **)(a1 + 200));
  free(*(void **)(a1 + 208));
  free(*(void **)(a1 + 240));
  free(*(void **)(a1 + 80));
  free(*(void **)(a1 + 312));
  free(*(void **)(a1 + 320));
  MultiRadixFFT_Dispose(*(_QWORD *)(a1 + 336));
  free(*(void **)(a1 + 344));
  free(*(void **)(a1 + 352));
  free(*(void **)(a1 + 408));
  free(*(void **)(a1 + 416));
  free(*(void **)(a1 + 424));
  free(*(void **)(a1 + 432));
  free(*(void **)(a1 + 440));
  free(*(void **)(a1 + 448));
  free(*(void **)(a1 + 480));
  free(*(void **)(a1 + 624));
  free(*(void **)(a1 + 632));
  free(*(void **)(a1 + 392));
  free(*(void **)(a1 + 592));
  free(*(void **)(a1 + 376));
  free(*(void **)(a1 + 384));
  free(*(void **)(a1 + 600));
  free(*(void **)(a1 + 608));
  free(*(void **)(a1 + 616));
  free(*(void **)(a1 + 640));
  free(*(void **)(a1 + 648));
  free(*(void **)(a1 + 656));
  free(*(void **)(a1 + 744));
  free(*(void **)(a1 + 752));
  CFilterBank::filterbank_destroy(*(void ***)(a1 + 24));
  free((void *)a1);
}

void CResidualSuppressorV3::speex_preprocess_run(uint64_t a1, char *a2, float **a3, float **a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  DSPSplitComplex v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v14.realp = (float *)((char *)&v13 - v11);
  v14.imagp = (float *)((char *)&v13 + 4 * v10 - v11);
  if (v12)
  {
    CResidualSuppressorV3::speex_analysis(a1, a2, &v14);
    CResidualSuppressorV3::speex_preprocess_run_freq(a1, &v14.realp, a3, a4, a5);
    CResidualSuppressorV3::speex_synthesis(a1, (float *)a2);
  }
  else
  {
    CResidualSuppressorV3::speex_preprocess_run_freq(a1, &v14.realp, a3, a4, a5);
  }
}

float learnrate_v3::crossCorrSpec_raw(learnrate_v3 *this, const float *a2, const float *a3, const float *a4, const float *a5, float *a6, float *a7)
{
  float *v7;
  float *v8;
  float *v9;
  float *v10;
  const float *v11;
  const float *v12;
  const float *v13;
  const float *v14;
  int v15;
  vDSP_Length __N;
  const float *v17;
  const float *v18;
  float result;
  float v20;
  float v21;
  float v22;
  float __C[1025];
  uint64_t v24;

  MEMORY[0x1E0C80A78](this);
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v24 = *MEMORY[0x1E0C80C00];
  v21 = 0.0;
  v22 = 0.0;
  __N = v15;
  vDSP_vsub(v18, 1, v17, 1, __C, 1, v15);
  vDSP_svesq(__C, 1, &v22, __N);
  vDSP_vsbm(v14, 1, v12, 1, __C, 1, __C, 1, __N);
  vDSP_sve(__C, 1, &v21, __N);
  result = v22 + 8.6736e-19;
  v20 = v21 + 8.6736e-19;
  *v8 = v22 + 8.6736e-19;
  *v10 = v20;
  return result;
}

void learnrate_v3::getAdaptationRate3_v6(uint64_t a1, const float *__B, int a3, int a4, int a5, int a6)
{
  uint64_t v9;
  float *v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  int v14;
  vDSP_Length v15;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v29;
  float v30;
  float v31;
  float *v32;
  uint64_t v33;
  _BYTE v34[4];
  float __Ba;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 140) == 1)
  {
    __Ba = *(float *)(a1 + 132) + *(float *)(a1 + 132);
    MEMORY[0x1E0C80A78](a1);
    v10 = (float *)&v34[-((v9 + 15) & 0x7FFFFFFF0)];
    MEMORY[0x1E0C80A78](v11);
    v13 = (float *)&v34[-v12];
    v15 = v14;
    vDSP_vsmul(*(const float **)(a1 + 56), 1, &__Ba, v10, 1, v14);
    __Ba = 9.0e-10;
    vDSP_vsadd(*(const float **)(a1 + 40), 1, &__Ba, v13, 1, v15);
    vDSP_vmin(v10, 1, v13, 1, v10, 1, v15);
    __Ba = 0.35;
    vDSP_vsmul(v10, 1, &__Ba, v10, 1, v15);
    __Ba = *(float *)(a1 + 136) * 0.3;
    vDSP_vsmul(v13, 1, &__Ba, *(float **)(a1 + 104), 1, v15);
    vDSP_vadd(v10, 1, *(const float **)(a1 + 104), 1, v10, 1, v15);
    if (a3 == 1)
      vDSP_vmul(v13, 1, __B, 1, v13, 1, v15);
    vDSP_vdiv(v13, 1, v10, 1, *(float **)(a1 + 104), 1, v15);
  }
  else
  {
    v17 = (float)(a4 - 1);
    if (a6)
    {
      v18 = *(float *)(a1 + 4);
      v19 = (float)(v17 * 2000.0) * 9.3132e-10;
      v20 = 0.0;
      if (v18 > v19)
      {
        v21 = v18 * 0.25;
        v22 = *(float *)(a1 + 24);
        v23 = v22 * 0.25;
        if (v21 <= (float)(v22 * 0.25))
          v23 = v21;
        v20 = v23 / v22;
      }
    }
    else
    {
      v24 = (float)(v17 * 1000.0) * 9.3132e-10;
      v20 = 0.0;
      if (*(float *)(a1 + 348) > v24)
      {
        if (!a5)
          ++*(_DWORD *)(a1 + 356);
        v25 = *(float *)(a1 + 308);
        v26 = *(float *)(a1 + 312);
        v20 = 0.25;
        if (v25 > v26)
        {
          v27 = *(float *)(a1 + 304);
          if (v27 > v25 || v27 < v26)
          {
            if (v27 <= v25)
              v20 = *(float *)(a1 + 320);
            else
              v20 = *(float *)(a1 + 316);
          }
          else
          {
            v20 = *(float *)(a1 + 320)
                + (float)((float)((float)(v27 - v26) / (float)(v25 - v26))
                        * (float)(*(float *)(a1 + 316) - *(float *)(a1 + 320)));
          }
          v29 = 0.25;
          if (v20 >= 0.25)
            v29 = v20;
          if (*(_DWORD *)(a1 + 356) <= *(_DWORD *)(a1 + 360))
            v20 = v29;
        }
      }
    }
    v30 = fminf(v20 * 2.5, 1.0);
    if (a5 == 2)
      v31 = v30;
    else
      v31 = v20;
    if (a4 >= 1)
    {
      v32 = *(float **)(a1 + 104);
      v33 = a4;
      do
      {
        *v32++ = v31;
        --v33;
      }
      while (v33);
    }
    if (a3 == 1)
      vDSP_vdiv(__B, 1, *(const float **)(a1 + 104), 1, *(float **)(a1 + 104), 1, a4);
    if (!a5)
      *(float *)(a1 + 144) = v31 + *(float *)(a1 + 144);
  }
}

void learnrate_v3::updateStatistics_echo(int a1, const float *a2, const float *__A, float *a4)
{
  vDSP_Length v8;
  float v9;
  float v10;

  v8 = a1;
  vDSP_svesq(__A, 1, a4 + 4, a1);
  vDSP_svesq(a2, 1, a4 + 6, v8);
  v9 = a4[6];
  a4[7] = v9;
  a4[8] = v9;
  v10 = (float)((float)(2 * a1) * 100.0) * 9.3132e-10;
  if (v9 < v10)
    a4[6] = v10;
  vDSP_dotpr(a2, 1, __A, 1, a4 + 3, v8);
}

void learnrate_v3::adaptLmsFilter_v3(uint64_t a1)
{
  const float *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  const float *v11;
  const float *v12;
  const float *v13;
  uint64_t v14;
  vDSP_Length v15;
  int v16;
  uint64_t v17;
  const float *v18;
  const float *v19;
  float v20;
  float v21;
  float *v22;
  float *v23;
  const float *v24;
  const float *v25;
  float *v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  _DWORD *v33;
  vDSP_Length v34;
  int v35;
  vDSP_Length v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  const float *v41;
  uint64_t *v42;
  float *v43;
  const float *v44;
  const float *v45;
  float *v46;
  const float *v47;
  uint64_t v48;
  float *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float *v53;
  float v54;
  float v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  int v62;
  size_t v63;
  vDSP_Length v64;
  int v65;
  uint64_t v66;
  int v67;
  const void *v68;
  const void *v69;
  uint64_t v70;
  uint64_t v71;
  float *v72;
  float *v73;
  float v74;
  MultiRadixRealFFT *v75;
  float v76;
  int *v77;
  float *v78;
  float *v79;
  uint64_t v80;
  int v81;
  float v82;
  MultiRadixRealFFT *v83;
  float *v84;
  int v85;
  _QWORD *v86;
  float *v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  float *v91;
  int v92;
  const float *v93;
  uint64_t v94;
  int *v95;
  vDSP_Length __N;
  int __Na;
  uint64_t v98;
  float __B;
  DSPSplitComplex __A;
  _DWORD v101[64];
  _DWORD v102[64];
  float __E[1024];
  float v104[1024];
  float v105[1025];
  uint64_t v106;

  MEMORY[0x1E0C80A78](a1);
  v4 = v3;
  v6 = v5;
  v95 = v7;
  v9 = v8;
  v10 = v2;
  v12 = v11;
  v13 = v1;
  v106 = *MEMORY[0x1E0C80C00];
  __N = v7[4];
  v98 = v8;
  v14 = v7[11];
  v15 = v7[10];
  v16 = *((_DWORD *)v2 + 19);
  v17 = *((int *)v2 + 18);
  *(_DWORD *)(v8 + 72) = v17;
  *(_DWORD *)(v8 + 76) = v16;
  v87 = (float *)v1;
  if ((_DWORD)v14 == 1)
  {
    v19 = (const float *)*v2;
    v18 = (const float *)v2[1];
    v20 = *(float *)*v2;
    v21 = *v18;
    vDSP_vmul(*(const float **)(v4 + 104), 1, v1, 1, v105, 1, __N);
    vDSP_vmul(*(const float **)(v4 + 104), 1, v12, 1, v104, 1, __N);
    v23 = *(float **)v9;
    v22 = *(float **)(v9 + 8);
    v24 = *(const float **)(v6 + 16);
    v25 = *(const float **)(v6 + 24);
    vDSP_vmma(v105, 1, v24, 1, v104, 1, v25, 1, __E, 1, __N);
    vDSP_vadd(__E, 1, v19, 1, v23, 1, __N);
    vDSP_vmmsb(v104, 1, v24, 1, v105, 1, v25, 1, __E, 1, __N);
    vDSP_vadd(__E, 1, v18, 1, v22, 1, __N);
    v26 = *(float **)(v4 + 104);
    v27 = *v12 * v26[__N];
    *v23 = v20 + (float)((float)(*v87 * *v26) * *v24);
    *v22 = v21 + (float)(v27 * *v25);
  }
  else
  {
    LODWORD(__A.realp) = 0;
    vDSP_vmul(*(const float **)(v4 + 88), 1, *(const float **)(v4 + 104), 1, *(float **)(v4 + 104), 1, v15);
    vDSP_vmul(*(const float **)(v4 + 104), 1, v13, 1, v105, 1, __N);
    vDSP_vmul(*(const float **)(v4 + 104), 1, v12, 1, v104, 1, __N);
    v28 = 4 * __N;
    if ((int)v14 >= 1)
    {
      v29 = 0;
      v30 = *v10;
      v31 = v10[1];
      v32 = v101;
      v33 = v102;
      do
      {
        *v33++ = *(_DWORD *)(v30 + v29);
        *v32++ = *(_DWORD *)(v31 + v29);
        v29 += v28;
        --v14;
      }
      while (v14);
    }
    v86 = (_QWORD *)v6;
    v84 = (float *)v12;
    if (*((_DWORD *)v10 + 17) == 1)
    {
      LODWORD(__A.realp) = 0;
      v34 = (v17 * __N);
      if ((int)v34 >= 1)
      {
        vDSP_vfill((const float *)&__A, *(float **)v9, 1, (v17 * __N));
        vDSP_vfill((const float *)&__A, *(float **)(v9 + 8), 1, v34);
        vDSP_vfill((const float *)&__A, *(float **)(v9 + 16), 1, v34);
        vDSP_vfill((const float *)&__A, *(float **)(v9 + 24), 1, v34);
      }
      v85 = v17 * __N;
      v35 = __N + __N * v16;
      v36 = (*(_DWORD *)(v9 + 36) - v35);
      if ((int)v36 >= 1)
      {
        vDSP_vfill((const float *)&__A, (float *)(*(_QWORD *)v9 + 4 * v35), 1, v36);
        vDSP_vfill((const float *)&__A, (float *)(*(_QWORD *)(v9 + 8) + 4 * v35), 1, v36);
        vDSP_vfill((const float *)&__A, (float *)(*(_QWORD *)(v9 + 16) + 4 * v35), 1, v36);
        vDSP_vfill((const float *)&__A, (float *)(*(_QWORD *)(v9 + 24) + 4 * v35), 1, v36);
      }
    }
    else
    {
      v85 = v17 * __N;
    }
    if ((int)v17 <= v16)
    {
      v37 = 4 * v85;
      v38 = v16 - v17 + 1;
      v39 = 4 * v17;
      v89 = v4;
      do
      {
        LODWORD(__A.realp) = *(_DWORD *)(*(_QWORD *)(v4 + 96) + v39);
        v40 = *(_DWORD *)(v86[11] + v39) * __N;
        v41 = (const float *)(*v10 + v37);
        v93 = (const float *)(v10[1] + v37);
        v42 = v10;
        v43 = (float *)(*(_QWORD *)v9 + v37);
        v91 = (float *)(*(_QWORD *)(v9 + 8) + v37);
        v44 = (const float *)(v86[2] + 4 * v40);
        v45 = (const float *)(v86[3] + 4 * v40);
        vDSP_vmma(v105, 1, v44, 1, v104, 1, v45, 1, __E, 1, __N);
        v46 = v43;
        v10 = v42;
        vDSP_vsma(__E, 1, (const float *)&__A, v41, 1, v46, 1, __N);
        v47 = v44;
        v9 = v98;
        vDSP_vmmsb(v104, 1, v47, 1, v105, 1, v45, 1, __E, 1, __N);
        v28 = 4 * __N;
        v4 = v89;
        vDSP_vsma(__E, 1, (const float *)&__A, v93, 1, v91, 1, __N);
        v37 += 4 * __N;
        v39 += 4;
        --v38;
      }
      while (v38);
    }
    if ((int)v17 <= v16)
    {
      v48 = 0;
      v49 = *(float **)v9;
      v50 = *(_QWORD *)(v9 + 8);
      v51 = v86[2];
      v52 = v86[3];
      v53 = *(float **)(v4 + 104);
      v54 = *v87 * *v53;
      v55 = *v84 * v53[__N];
      v56 = 4 * v85;
      v57 = *(_QWORD *)(v4 + 96) + 4 * v17;
      v58 = v86[11] + 4 * v17;
      do
      {
        v59 = *(_DWORD *)(v58 + 4 * v48) * __N;
        *(float *)((char *)v49 + v56) = *(float *)&v102[v17 + v48]
                                      + (float)((float)(v54 * *(float *)(v57 + 4 * v48)) * *(float *)(v51 + 4 * v59));
        *(float *)(v50 + v56) = *(float *)&v101[v17 + v48]
                              + (float)((float)(v55 * *(float *)(v57 + 4 * v48)) * *(float *)(v52 + 4 * v59));
        v56 += v28;
        ++v48;
      }
      while (v16 - (_DWORD)v17 + 1 != (_DWORD)v48);
    }
  }
  v60 = *(_DWORD *)(v9 + 76);
  v61 = *(int *)(v9 + 72);
  if ((int)v61 <= v60)
  {
    v62 = *v95 >> 1;
    v94 = v62;
    v63 = 4 * v62;
    __Na = *v95;
    v64 = (uint64_t)*v95 >> 2;
    if (v62 <= 2)
      v65 = 2;
    else
      v65 = *v95 >> 1;
    v88 = ((v65 - 1) >> 1) + 1;
    v90 = *v95 >> 1;
    v92 = v60 + 1;
    v66 = 4 * (int)v61 * (uint64_t)v62;
    v67 = ~(_DWORD)v61;
    do
    {
      v68 = (const void *)(*(_QWORD *)v9 + 4 * v61 * v94);
      v69 = (const void *)(*(_QWORD *)(v9 + 8) + 4 * v61 * v94);
      v71 = *(_QWORD *)(v9 + 16);
      v70 = *(_QWORD *)(v9 + 24);
      v72 = (float *)(v71 + 4 * v61 * v94);
      v73 = (float *)(v70 + 4 * v61 * v94);
      __A.realp = v72;
      __A.imagp = v73;
      memcpy(v72, v68, v63);
      memcpy(v73, v69, v63);
      v75 = (MultiRadixRealFFT *)*((_QWORD *)v95 + 1);
      if (v75)
        MultiRadixRealFFT::RealInPlaceTransform(v75, &__A, -1, v74);
      __B = *((float *)v95 + 21) * *((float *)v95 + 20);
      vDSP_vsmul(v72, 1, &__B, v72, 1, v64);
      vDSP_vsmul(v73, 1, &__B, v73, 1, v64);
      vDSP_vclr(&v72[v64], 1, v64);
      vDSP_vclr(&v73[v64], 1, v64);
      v9 = v98;
      if (__Na >= 2)
      {
        v77 = (int *)(v71 + v66);
        v78 = (float *)(*(_QWORD *)(v98 + 48) + 4 * v90 * (v95[11] + v67) + 4);
        v79 = (float *)(v70 + v66);
        v80 = v88;
        do
        {
          v81 = *v77++;
          *((_DWORD *)v78 - 1) = v81;
          v82 = *v79++;
          v76 = v82;
          *v78 = v82;
          v78 += 2;
          --v80;
        }
        while (v80);
      }
      v83 = (MultiRadixRealFFT *)*((_QWORD *)v95 + 1);
      if (v83)
        MultiRadixRealFFT::RealInPlaceTransform(v83, &__A, 1, v76);
      ++v61;
      v66 += v63;
      --v67;
    }
    while (v92 != (_DWORD)v61);
  }
}

uint64_t DictionaryBlobReader::ReadVectorFromDictionary(NSObject ***a1, CFDictionaryRef theDict, const __CFString *key, char **a4)
{
  const __CFData *Value;
  const __CFData *v8;
  unsigned int Length;
  unsigned int v10;
  const UInt8 *BytePtr;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unsigned int v15;
  NSObject **v16;
  NSObject *v17;
  int v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const char *CStringPtr;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  Value = (const __CFData *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    v8 = Value;
    Length = CFDataGetLength(Value);
    v10 = Length >> 2;
    v19 = 0;
    std::vector<float>::assign(a4, Length >> 2, &v19);
    BytePtr = CFDataGetBytePtr(v8);
    v12 = 0;
    if (Length >= 4)
    {
      v13 = *a4;
      if (v10 <= 1)
        v14 = 1;
      else
        v14 = v10;
      do
      {
        v15 = *(_DWORD *)BytePtr;
        BytePtr += 4;
        *(_DWORD *)v13 = bswap32(v15);
        v13 += 4;
        --v14;
      }
      while (v14);
      return 0;
    }
  }
  else
  {
    v12 = 4294900555;
    v16 = *a1;
    if (*a1)
    {
      v17 = *v16;
      if (!*v16)
        return v12;
    }
    else
    {
      v17 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v19 = 136315650;
      v20 = "DictionaryBlobReader.cpp";
      v21 = 1024;
      v22 = 21;
      v23 = 2080;
      CStringPtr = CFStringGetCStringPtr(key, 0x8000100u);
      _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Failed to retrieve %s.", (uint8_t *)&v19, 0x1Cu);
    }
  }
  return v12;
}

uint64_t DictionaryBlobReader::ReadSparseMatrix(uint64_t **this, CFDictionaryRef theDict, const __CFString *key, unsigned int *a4, const __CFString *a5, int a6, const __CFString *a7, sparse_m_float **a8)
{
  const __CFDictionary *Value;
  uint64_t *v15;
  const __CFDictionary *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject **v21;
  uint64_t *v22;
  NSObject *v23;
  const char *v24;
  const char *v25;
  NSObject *v26;
  uint64_t *v27;
  uint64_t *v29;
  NSObject *v30;
  const char *v31;
  float *v32;
  _BYTE *v33;
  unint64_t v34;
  unint64_t i;
  uint64_t *v36;
  NSObject *v37;
  double v38;
  unint64_t v39;
  uint64_t *v40;
  const char *v41;
  sparse_index *v42;
  sparse_index *v43;
  unint64_t v44;
  unint64_t j;
  uint64_t *v46;
  NSObject *v47;
  double v48;
  unint64_t v49;
  uint64_t *v50;
  NSObject *v51;
  sparse_index *v52;
  sparse_index *v53;
  unint64_t v54;
  unint64_t k;
  uint64_t *v56;
  NSObject *v57;
  double v58;
  unint64_t v59;
  sparse_m_float *v60;
  unint64_t v61;
  sparse_status v62;
  uint64_t *v63;
  NSObject *v64;
  NSObject *v65;
  const char *v66;
  const char *v67;
  unsigned int v68;
  int v69;
  unint64_t v70;
  uint64_t *v71;
  NSObject *v72;
  double v73;
  unint64_t v74;
  float *y[3];
  float *x[3];
  sparse_index *jndx;
  sparse_index *v79;
  uint64_t v80;
  sparse_index *indx;
  sparse_index *v82;
  uint64_t v83;
  void *__p;
  _BYTE *v85;
  uint64_t v86;
  unsigned int v87;
  uint8_t buf[4];
  const char *v89;
  __int16 v90;
  int v91;
  __int16 v92;
  double v93;
  __int16 v94;
  int v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  v87 = 0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, key);
  v15 = *this;
  if (Value)
  {
    v16 = Value;
    if (v15)
    {
      v17 = *v15;
      if (!*v15)
        goto LABEL_17;
    }
    else
    {
      v17 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315650;
      v89 = "DictionaryBlobReader.cpp";
      v90 = 1024;
      v91 = 67;
      v92 = 2080;
      v93 = COERCE_DOUBLE(CFStringGetCStringPtr(key, 0x8000100u));
      _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_DEBUG, "%25s:%-5d Found the dictionary %s.\n", buf, 0x1Cu);
      v15 = *this;
    }
    if (v15)
    {
      v20 = *v15;
      if (!*v15)
        goto LABEL_17;
    }
    else
    {
      v20 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315394;
      v89 = "DictionaryBlobReader.cpp";
      v90 = 1024;
      v91 = 70;
      _os_log_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_DEBUG, "%25s:%-5d Loading from matrixDict.\n", buf, 0x12u);
    }
LABEL_17:
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>(this, v16, a7, &v87))
    {
      v18 = 4294900555;
      v21 = (NSObject **)*this;
      if (*this)
      {
        v19 = *v21;
        if (!*v21)
          return v18;
      }
      else
      {
        v19 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(double *)&v24 = COERCE_DOUBLE(CFStringGetCStringPtr(a7, 0x8000100u));
        *(_DWORD *)buf = 136315650;
        v89 = "DictionaryBlobReader.cpp";
        v90 = 1024;
        v91 = 75;
        v92 = 2080;
        v93 = *(double *)&v24;
        v25 = "%25s:%-5d Missing scalar %s.\n";
LABEL_31:
        _os_log_impl(&dword_1B5ED0000, v19, OS_LOG_TYPE_ERROR, v25, buf, 0x1Cu);
        return v18;
      }
      return v18;
    }
    v22 = *this;
    if (v87 == a6)
    {
      if (v22)
      {
        v23 = *v22;
        if (!*v22)
          goto LABEL_38;
      }
      else
      {
        v23 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315394;
        v89 = "DictionaryBlobReader.cpp";
        v90 = 1024;
        v91 = 86;
        _os_log_impl(&dword_1B5ED0000, v23, OS_LOG_TYPE_DEBUG, "%25s:%-5d Loading from matrixDict.\n", buf, 0x12u);
      }
LABEL_38:
      if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>(this, v16, a5, a4))
      {
        v18 = 4294900555;
        v27 = *this;
        if (*this)
        {
          v19 = *v27;
          if (!*v27)
            return v18;
        }
        else
        {
          v19 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(double *)&v31 = COERCE_DOUBLE(CFStringGetCStringPtr(a5, 0x8000100u));
          *(_DWORD *)buf = 136315650;
          v89 = "DictionaryBlobReader.cpp";
          v90 = 1024;
          v91 = 91;
          v92 = 2080;
          v93 = *(double *)&v31;
          v25 = "%25s:%-5d Missing scalar %s.\n";
          goto LABEL_31;
        }
        return v18;
      }
      __p = 0;
      v85 = 0;
      v86 = 0;
      indx = 0;
      v82 = 0;
      v83 = 0;
      jndx = 0;
      v79 = 0;
      v80 = 0;
      if (DictionaryBlobReader::ReadVectorFromDictionary((NSObject ***)this, v16, CFSTR("Coefficients"), (char **)&__p))
      {
        v18 = 4294900555;
        v29 = *this;
        if (*this)
        {
          v30 = *v29;
          if (!*v29)
            goto LABEL_142;
        }
        else
        {
          v30 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v89 = "DictionaryBlobReader.cpp";
          v90 = 1024;
          v91 = 105;
          v41 = "%25s:%-5d Missing vector Coefficients.\n";
LABEL_92:
          _os_log_impl(&dword_1B5ED0000, v30, OS_LOG_TYPE_ERROR, v41, buf, 0x12u);
          goto LABEL_142;
        }
        goto LABEL_142;
      }
      v32 = (float *)__p;
      v33 = v85;
      v34 = (v85 - (_BYTE *)__p) >> 2;
      if (v34 >= 4)
        v34 = 4;
      if (v34)
      {
        for (i = 0; i < v39; ++i)
        {
          v36 = *this;
          if (*this)
          {
            if ((v36[1] & 1) != 0)
            {
              v37 = *v36;
              if (*v36)
              {
                if (os_log_type_enabled((os_log_t)*v36, OS_LOG_TYPE_DEBUG))
                {
                  v38 = v32[i];
                  *(_DWORD *)buf = 136315906;
                  v89 = "DictionaryBlobReader.cpp";
                  v90 = 1024;
                  v91 = 113;
                  v92 = 2048;
                  v93 = v38;
                  v94 = 1024;
                  v95 = i;
                  _os_log_impl(&dword_1B5ED0000, v37, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved coefficients data (%g) at index (%u).\n", buf, 0x22u);
                  v32 = (float *)__p;
                  v33 = v85;
                }
              }
            }
          }
          v39 = (v33 - (_BYTE *)v32) >> 2;
          if (v39 >= 4)
            v39 = 4;
        }
      }
      if (DictionaryBlobReader::ReadVectorFromDictionary<long long>((NSObject ***)this, v16, CFSTR("RowIndices"), (char **)&indx))
      {
        v18 = 4294900555;
        v40 = *this;
        if (*this)
        {
          v30 = *v40;
          if (!*v40)
            goto LABEL_142;
        }
        else
        {
          v30 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v89 = "DictionaryBlobReader.cpp";
          v90 = 1024;
          v91 = 121;
          v41 = "%25s:%-5d Missing vector RowIndices\n";
          goto LABEL_92;
        }
LABEL_142:
        if (jndx)
        {
          v79 = jndx;
          operator delete(jndx);
        }
        if (indx)
        {
          v82 = indx;
          operator delete(indx);
        }
        if (__p)
        {
          v85 = __p;
          operator delete(__p);
        }
        return v18;
      }
      v42 = indx;
      v43 = v82;
      v44 = v82 - indx;
      if (v44 >= 4)
        v44 = 4;
      if (v44)
      {
        for (j = 0; j < v49; ++j)
        {
          v46 = *this;
          if (*this)
          {
            if ((v46[1] & 1) != 0)
            {
              v47 = *v46;
              if (*v46)
              {
                if (os_log_type_enabled((os_log_t)*v46, OS_LOG_TYPE_DEBUG))
                {
                  v48 = *(double *)&v42[j];
                  *(_DWORD *)buf = 136315906;
                  v89 = "DictionaryBlobReader.cpp";
                  v90 = 1024;
                  v91 = 129;
                  v92 = 2048;
                  v93 = v48;
                  v94 = 1024;
                  v95 = j;
                  _os_log_impl(&dword_1B5ED0000, v47, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved row index data (%lld) at index (%u).\n", buf, 0x22u);
                  v42 = indx;
                  v43 = v82;
                }
              }
            }
          }
          v49 = v43 - v42;
          if (v49 >= 4)
            v49 = 4;
        }
      }
      if (DictionaryBlobReader::ReadVectorFromDictionary<long long>((NSObject ***)this, v16, CFSTR("ColumnIndices"), (char **)&jndx))
      {
        v50 = *this;
        if (*this)
        {
          v51 = *v50;
          if (!*v50)
          {
LABEL_112:
            v18 = 0xFFFFFFFFLL;
            goto LABEL_142;
          }
        }
        else
        {
          v51 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v89 = "DictionaryBlobReader.cpp";
          v90 = 1024;
          v91 = 137;
          _os_log_impl(&dword_1B5ED0000, v51, OS_LOG_TYPE_ERROR, "%25s:%-5d Missing vector ColumnIndices.\n", buf, 0x12u);
        }
        goto LABEL_112;
      }
      v52 = jndx;
      v53 = v79;
      v54 = v79 - jndx;
      if (v54 >= 4)
        v54 = 4;
      if (v54)
      {
        for (k = 0; k < v59; ++k)
        {
          v56 = *this;
          if (*this)
          {
            if ((v56[1] & 1) != 0)
            {
              v57 = *v56;
              if (*v56)
              {
                if (os_log_type_enabled((os_log_t)*v56, OS_LOG_TYPE_DEBUG))
                {
                  v58 = *(double *)&v52[k];
                  *(_DWORD *)buf = 136315906;
                  v89 = "DictionaryBlobReader.cpp";
                  v90 = 1024;
                  v91 = 144;
                  v92 = 2048;
                  v93 = v58;
                  v94 = 1024;
                  v95 = k;
                  _os_log_impl(&dword_1B5ED0000, v57, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved column index data (%lld) at index (%u).\n", buf, 0x22u);
                  v52 = jndx;
                  v53 = v79;
                }
              }
            }
          }
          v59 = v53 - v52;
          if (v59 >= 4)
            v59 = 4;
        }
      }
      v60 = sparse_matrix_create_float(*a4, v87);
      *a8 = v60;
      sparse_insert_entries_float(v60, (v85 - (_BYTE *)__p) >> 2, (const float *)__p, indx, jndx);
      sparse_commit(*a8);
      *(_DWORD *)buf = 1065353216;
      std::vector<float>::vector(x, v87, buf);
      v61 = *a4;
      *(_DWORD *)buf = 0;
      std::vector<float>::vector(y, v61, buf);
      v62 = sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *a8, x[0], 1, y[0], 1);
      v63 = *this;
      if (v62)
      {
        if (v63)
        {
          v64 = *v63;
          if (!*v63)
          {
LABEL_119:
            v18 = 4294956418;
LABEL_138:
            if (y[0])
            {
              y[1] = y[0];
              operator delete(y[0]);
            }
            if (x[0])
            {
              x[1] = x[0];
              operator delete(x[0]);
            }
            goto LABEL_142;
          }
        }
        else
        {
          v64 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
          *(double *)&v66 = COERCE_DOUBLE(CFStringGetCStringPtr(key, 0x8000100u));
          *(_DWORD *)buf = 136315650;
          v89 = "DictionaryBlobReader.cpp";
          v90 = 1024;
          v91 = 161;
          v92 = 2080;
          v93 = *(double *)&v66;
          _os_log_impl(&dword_1B5ED0000, v64, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed sparse_matrix_vector_product_dense_float for %s.\n", buf, 0x1Cu);
        }
        goto LABEL_119;
      }
      if (v63)
      {
        v65 = *v63;
        if (!*v63)
        {
LABEL_123:
          v68 = *a4;
          if (*a4 >= 4)
            v69 = 4;
          else
            v69 = *a4;
          if (v69)
          {
            v70 = 0;
            do
            {
              v71 = *this;
              if (*this)
              {
                if ((v71[1] & 1) != 0)
                {
                  v72 = *v71;
                  if (*v71)
                  {
                    if (os_log_type_enabled((os_log_t)*v71, OS_LOG_TYPE_DEBUG))
                    {
                      v73 = y[0][v70];
                      *(_DWORD *)buf = 136315906;
                      v89 = "DictionaryBlobReader.cpp";
                      v90 = 1024;
                      v91 = 168;
                      v92 = 2048;
                      v93 = v73;
                      v94 = 1024;
                      v95 = v70;
                      _os_log_impl(&dword_1B5ED0000, v72, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully computed SparseMatrix * Ones data (%g) at index (%u).\n", buf, 0x22u);
                      v68 = *a4;
                    }
                  }
                }
              }
              ++v70;
              if (v68 >= 4)
                v74 = 4;
              else
                v74 = v68;
            }
            while (v70 < v74);
          }
          v18 = 0;
          goto LABEL_138;
        }
      }
      else
      {
        v65 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
      {
        *(double *)&v67 = COERCE_DOUBLE(CFStringGetCStringPtr(key, 0x8000100u));
        *(_DWORD *)buf = 136315650;
        v89 = "DictionaryBlobReader.cpp";
        v90 = 1024;
        v91 = 157;
        v92 = 2080;
        v93 = *(double *)&v67;
        _os_log_impl(&dword_1B5ED0000, v65, OS_LOG_TYPE_INFO, "%25s:%-5d Successfully called sparse_matrix_vector_product_dense_float for %s.\n", buf, 0x1Cu);
      }
      goto LABEL_123;
    }
    if (v22)
    {
      v26 = *v22;
      if (!*v22)
        return 4294956418;
    }
    else
    {
      v26 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v89 = "DictionaryBlobReader.cpp";
      v90 = 1024;
      v91 = 81;
      _os_log_impl(&dword_1B5ED0000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d NumDictColumns does not match NumColumns we use.\n", buf, 0x12u);
    }
    return 4294956418;
  }
  v18 = 4294900555;
  if (v15)
  {
    v19 = *v15;
    if (!*v15)
      return v18;
  }
  else
  {
    v19 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    v89 = "DictionaryBlobReader.cpp";
    v90 = 1024;
    v91 = 61;
    v92 = 2080;
    v93 = COERCE_DOUBLE(CFStringGetCStringPtr(key, 0x8000100u));
    v25 = "%25s:%-5d Missing dictionary %s.\n";
    goto LABEL_31;
  }
  return v18;
}

void sub_1B6551EC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  if (a19)
    operator delete(a19);
  if (a22)
    operator delete(a22);
  if (a25)
    operator delete(a25);
  _Unwind_Resume(exception_object);
}

uint64_t DictionaryBlobReader::ReadVectorFromDictionary<long long>(NSObject ***a1, CFDictionaryRef theDict, const __CFString *key, char **a4)
{
  const __CFData *Value;
  const __CFData *v8;
  unsigned int Length;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject **v19;
  NSObject *v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  const UInt8 *BytePtr;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  int v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  const char *CStringPtr;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  Value = (const __CFData *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    v8 = Value;
    Length = CFDataGetLength(Value);
    v10 = Length >> 3;
    v11 = (uint64_t)a4[2];
    v12 = *a4;
    if (v10 <= (v11 - (uint64_t)*a4) >> 3)
    {
      v21 = a4[1];
      v22 = (v21 - v12) >> 3;
      if (v22 >= v10)
        v23 = Length >> 3;
      else
        v23 = (v21 - v12) >> 3;
      if (v23)
      {
        v24 = *a4;
        do
        {
          *(_QWORD *)v24 = 0;
          v24 += 8;
          --v23;
        }
        while (v23);
      }
      if (v10 <= v22)
      {
        a4[1] = &v12[8 * v10];
      }
      else
      {
        v25 = &v21[8 * (v10 - v22)];
        v26 = 8 * v10 - 8 * v22;
        do
        {
          *(_QWORD *)v21 = 0;
          v21 += 8;
          v26 -= 8;
        }
        while (v26);
        a4[1] = v25;
      }
    }
    else
    {
      if (v12)
      {
        a4[1] = v12;
        operator delete(v12);
        v11 = 0;
        *a4 = 0;
        a4[1] = 0;
        a4[2] = 0;
      }
      v13 = v11 >> 2;
      if (v11 >> 2 <= v10)
        v13 = Length >> 3;
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      std::vector<std::tuple<unsigned int,float>>::__vallocate[abi:ne180100](a4, v14);
      v15 = a4[1];
      v16 = &v15[8 * v10];
      v17 = 8 * v10;
      do
      {
        *(_QWORD *)v15 = 0;
        v15 += 8;
        v17 -= 8;
      }
      while (v17);
      a4[1] = v16;
    }
    BytePtr = CFDataGetBytePtr(v8);
    if (Length >= 8)
    {
      v28 = *a4;
      if (v10 <= 1)
        v29 = 1;
      else
        v29 = v10;
      do
      {
        v30 = *(_QWORD *)BytePtr;
        BytePtr += 8;
        *(_QWORD *)v28 = v30;
        v28 += 8;
        --v29;
      }
      while (v29);
    }
    return 0;
  }
  else
  {
    v18 = 4294900555;
    v19 = *a1;
    if (*a1)
    {
      v20 = *v19;
      if (!*v19)
        return v18;
    }
    else
    {
      v20 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      v32 = 136315650;
      v33 = "DictionaryBlobReader.hpp";
      v34 = 1024;
      v35 = 95;
      v36 = 2080;
      CStringPtr = CFStringGetCStringPtr(key, 0x8000100u);
      _os_log_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Failed to retrieve %s.", (uint8_t *)&v32, 0x1Cu);
    }
  }
  return v18;
}

void AUSeparate::~AUSeparate(SeparationBase **this)
{
  AUSeparate::~AUSeparate(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  SeparationBase **v2;
  void **v3;

  *this = (SeparationBase *)&off_1E69EA2F8;
  v2 = this + 86;
  std::unique_ptr<IVA_HRLS_Rank1>::reset[abi:ne180100](this + 86, 0);
  std::unique_ptr<IVA_DirectiV_Rank1A>::reset[abi:ne180100](this + 87, 0);
  std::unique_ptr<IVA_DirectiV_Rank1A>::reset[abi:ne180100](this + 87, 0);
  std::unique_ptr<IVA_HRLS_Rank1>::reset[abi:ne180100](v2, 0);
  v3 = (void **)(this + 71);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v3);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)this);
}

void AUSeparate::CreateExtendedElements(AUSeparate *this)
{
  unint64_t i;
  std::string *v3;
  __int128 v4;
  void **v5;
  CFStringRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::string v10;
  void *__p[2];
  int64_t v12;

  ausdk::AUScope::Initialize((int64x2_t *)((char *)this + 552), this, 4, 16);
  for (i = 0; i != 16; ++i)
  {
    std::to_string(&v10, i);
    v3 = std::string::insert(&v10, 0, "Mic", 3uLL);
    v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    v12 = v3->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v4;
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v10.__r_.__value_.__l.__data_);
    if (v12 >= 0)
      v5 = __p;
    else
      v5 = (void **)__p[0];
    v6 = CFStringCreateWithCString(0, (const char *)v5, 0x8000100u);
    v7 = *((_QWORD *)this + 74);
    if (v7)
    {
      v8 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v7 + 32))(v7, i);
    }
    else
    {
      v9 = *((_QWORD *)this + 71);
      if (i >= (*((_QWORD *)this + 72) - v9) >> 3)
        v8 = 0;
      else
        v8 = *(_QWORD *)(v9 + 8 * i);
    }
    ausdk::Owned<__CFString const*>::operator=((const void **)(v8 + 72), v6);
    CFRelease(v6);
    if (SHIBYTE(v12) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B65522C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t AUSeparate::Initialize(AUSeparate *this)
{
  NSObject *v2;
  uint64_t Element;
  uint64_t v4;
  int64x2_t *Scope;
  NSObject *v6;
  uint64_t result;
  _BOOL4 v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (AUSeparateLogScope(void)::once != -1)
    dispatch_once(&AUSeparateLogScope(void)::once, &__block_literal_global_22744);
  if (AUSeparateLogScope(void)::scope)
  {
    v2 = *(NSObject **)AUSeparateLogScope(void)::scope;
    if (!*(_QWORD *)AUSeparateLogScope(void)::scope)
      goto LABEL_9;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v9 = 136315394;
    v10 = "AUSeparate.cpp";
    v11 = 1024;
    v12 = 102;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d AUSeparate: Initialize.\n", (uint8_t *)&v9, 0x12u);
  }
LABEL_9:
  Element = ausdk::AUScope::SafeGetElement((AUSeparate *)((char *)this + 80), 0);
  v4 = *(_QWORD *)(Element + 80);
  *((_DWORD *)this + 154) = *(_DWORD *)(Element + 108);
  *((_QWORD *)this + 76) = v4;
  if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUSeparate *)((char *)this + 80), 0) + 108) != *((_DWORD *)this + 154)
    || *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUSeparate *)((char *)this + 128), 0) + 108) != *((_DWORD *)this + 154))
  {
    return 4294956421;
  }
  Scope = (int64x2_t *)ausdk::AUBase::GetScope(this, 4u);
  ausdk::AUScope::SetNumberOfElements(Scope, 0x10u);
  *((_DWORD *)this + 150) = *((_DWORD *)this + 84);
  AUSeparate::UpdateState(this);
  *((_QWORD *)this + 67) = *((_QWORD *)this + 66);
  (*(void (**)(AUSeparate *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
  if (AUSeparateLogScope(void)::once != -1)
    dispatch_once(&AUSeparateLogScope(void)::once, &__block_literal_global_22744);
  if (AUSeparateLogScope(void)::scope)
  {
    v6 = *(NSObject **)AUSeparateLogScope(void)::scope;
    if (!*(_QWORD *)AUSeparateLogScope(void)::scope)
      return 0;
  }
  else
  {
    v6 = MEMORY[0x1E0C81028];
  }
  v8 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v8)
  {
    v9 = 136315394;
    v10 = "AUSeparate.cpp";
    v11 = 1024;
    v12 = 132;
    _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d AUSeparate: Successfully initialized.\n", (uint8_t *)&v9, 0x12u);
    return 0;
  }
  return result;
}

float AUSeparate::Cleanup(AUSeparate *this)
{
  NSObject *v2;
  SeparationBase *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  float result;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (AUSeparateLogScope(void)::once != -1)
    dispatch_once(&AUSeparateLogScope(void)::once, &__block_literal_global_22744);
  if (AUSeparateLogScope(void)::scope)
  {
    v2 = *(NSObject **)AUSeparateLogScope(void)::scope;
    if (!*(_QWORD *)AUSeparateLogScope(void)::scope)
      goto LABEL_9;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136315394;
    v11 = "AUSeparate.cpp";
    v12 = 1024;
    v13 = 143;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d AUSeparate: Cleanup.\n", (uint8_t *)&v10, 0x12u);
  }
LABEL_9:
  v3 = (SeparationBase *)*((_QWORD *)this + 86);
  if (v3)
    SeparationBase::Cleanup(v3);
  v4 = *((_QWORD *)this + 87);
  if (v4)
  {
    SeparationBase::Cleanup((SeparationBase *)v4);
    bzero(*(void **)(v4 + 1152), *(_QWORD *)(v4 + 1160) - *(_QWORD *)(v4 + 1152));
    bzero(*(void **)(v4 + 1176), *(_QWORD *)(v4 + 1184) - *(_QWORD *)(v4 + 1176));
    bzero(*(void **)(v4 + 1200), *(_QWORD *)(v4 + 1208) - *(_QWORD *)(v4 + 1200));
    bzero(*(void **)(v4 + 1224), *(_QWORD *)(v4 + 1232) - *(_QWORD *)(v4 + 1224));
    bzero(*(void **)(v4 + 1248), *(_QWORD *)(v4 + 1256) - *(_QWORD *)(v4 + 1248));
    bzero(*(void **)(v4 + 1272), *(_QWORD *)(v4 + 1280) - *(_QWORD *)(v4 + 1272));
    bzero(*(void **)(v4 + 1296), *(_QWORD *)(v4 + 1304) - *(_QWORD *)(v4 + 1296));
    v5 = *(unsigned int *)(v4 + 48);
    if ((_DWORD)v5)
    {
      v6 = 0;
      v7 = *(_QWORD *)(v4 + 1152);
      result = 0.000000041723;
      do
      {
        v8 = fmax(*(float *)(v4 + 36) / ((double)v6 * 0.15 + 1.0), *(float *)(v4 + 120));
        *(float *)(v7 + 4 * v6++) = v8;
      }
      while (v5 != v6);
    }
  }
  return result;
}

uint64_t AUSeparate::Reset(AUSeparate *this)
{
  int v1;
  SeparationBase **v2;
  SeparationBase *v3;

  v1 = *((_DWORD *)this + 156);
  if (v1 == 1)
  {
    v2 = (SeparationBase **)((char *)this + 696);
    goto LABEL_5;
  }
  if (!v1)
  {
    v2 = (SeparationBase **)((char *)this + 688);
LABEL_5:
    v3 = *v2;
    SeparationBase::ResetWA(*v2);
    SeparationBase::ResetiV(v3);
  }
  return 0;
}

uint64_t AUSeparate::GetPropertyInfo(AUSeparate *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;

  if (a3 || a2 != 3700 && a2 != 21)
    return 4294956417;
  result = 0;
  *a6 = 1;
  *a5 = 4;
  return result;
}

uint64_t AUSeparate::GetProperty(AUSeparate *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  unsigned __int8 *v6;

  if (a3)
    return 4294956417;
  if (a2 == 3700)
  {
    v6 = (unsigned __int8 *)this + 376;
  }
  else
  {
    if (a2 != 21)
      return 4294956417;
    v6 = (unsigned __int8 *)this + 544;
  }
  result = 0;
  *a5 = *v6;
  return result;
}

uint64_t AUSeparate::SetProperty(AUSeparate *this, int a2, int a3, unsigned int a4, _BYTE *a5, unsigned int a6)
{
  uint64_t result;

  if (a3)
    return 4294956417;
  if (a2 == 3700)
  {
    result = 4294956445;
    if (a6 >= 4)
    {
      if (*a5)
        return 0;
      else
        return 4294956445;
    }
  }
  else
  {
    if (a2 != 21)
      return 4294956417;
    result = 0;
    *((_BYTE *)this + 544) = *(_DWORD *)a5 != 0;
  }
  return result;
}

uint64_t AUSeparate::SetParameter(AUSeparate *this, unsigned int a2, int a3, float a4)
{
  uint64_t v7;
  ausdk::AUElement *v8;
  uint64_t result;
  ausdk::AUElement **v10;

  if (a3 == 4)
    return 0;
  if (a3)
    return 4294956418;
  v7 = *((_QWORD *)this + 9);
  if (v7)
  {
    v8 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v8 = 0;
    else
      v8 = *v10;
  }
  ausdk::AUElement::SetParameter(v8, a2, a4, 0);
  result = 0;
  ++*((_QWORD *)this + 66);
  return result;
}

uint64_t AUSeparate::CanScheduleParameters(AUSeparate *this)
{
  return 0;
}

uint64_t AUSeparate::ProcessMultipleBufferLists(AUSeparate *this, unsigned int *a2, AudioDSP::Utility *a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  int v9;
  uint64_t v11;
  NSObject *v12;
  int *v13;
  int v14;
  AudioDSP::Utility *v15;
  BOOL *v16;
  NSObject *v17;
  NSObject *v19;
  int v20;
  SeparationBase **v21;
  NSObject *v22;
  __int16 v23;
  int v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  AudioBufferList v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;

  v9 = (int)a3;
  v34 = *MEMORY[0x1E0C80C00];
  v11 = *((_QWORD *)this + 66);
  if (*((_QWORD *)this + 67) != v11)
  {
    AUSeparate::UpdateState(this);
    *((_QWORD *)this + 67) = v11;
    if (AUSeparateLogScope(void)::once != -1)
      dispatch_once(&AUSeparateLogScope(void)::once, &__block_literal_global_22744);
    if (AUSeparateLogScope(void)::scope)
    {
      v12 = *(NSObject **)AUSeparateLogScope(void)::scope;
      if (!*(_QWORD *)AUSeparateLogScope(void)::scope)
        goto LABEL_10;
    }
    else
    {
      v12 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v30.mNumberBuffers = 136315394;
      *(_QWORD *)(&v30.mNumberBuffers + 1) = "AUSeparate.cpp";
      LOWORD(v30.mBuffers[0].mDataByteSize) = 1024;
      *(UInt32 *)((char *)&v30.mBuffers[0].mDataByteSize + 2) = 854;
      _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d parameters changed after Initialize, which will allocate memory on the realtime audio thread - only SetParameter before Initialize\n", (uint8_t *)&v30, 0x12u);
    }
  }
LABEL_10:
  if (*((_DWORD *)this + 150) != v9)
    return 4294956422;
  v13 = (int *)*a5;
  if (!*a5)
  {
    if (AUSeparateLogScope(void)::once != -1)
      dispatch_once(&AUSeparateLogScope(void)::once, &__block_literal_global_22744);
    if (AUSeparateLogScope(void)::scope)
    {
      v19 = *(NSObject **)AUSeparateLogScope(void)::scope;
      if (!*(_QWORD *)AUSeparateLogScope(void)::scope)
        return 4294956420;
    }
    else
    {
      v19 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v30.mNumberBuffers = 136315394;
      *(_QWORD *)(&v30.mNumberBuffers + 1) = "AUSeparate.cpp";
      LOWORD(v30.mBuffers[0].mDataByteSize) = 1024;
      *(UInt32 *)((char *)&v30.mBuffers[0].mDataByteSize + 2) = 865;
      _os_log_impl(&dword_1B5ED0000, v19, OS_LOG_TYPE_ERROR, "%25s:%-5d InputSignals cannot be NULL. It is a required input\n", (uint8_t *)&v30, 0x12u);
    }
    return 4294956420;
  }
  v14 = *v13;
  if (*v13 != *((_DWORD *)this + 154) || *a7 && (*a7)->mNumberBuffers != v14)
    return 4294956428;
  v23 = 0;
  v15 = (AudioDSP::Utility *)(2 * v9);
  *(_QWORD *)&v30.mNumberBuffers = *((_QWORD *)this + 76);
  v30.mBuffers[0] = (AudioBuffer)xmmword_1B6626900;
  v31 = 4;
  v32 = v14;
  v33 = 32;
  AudioDSP::Utility::DetectNonFinites(v15, v13, &v30, (const AudioStreamBasicDescription *)((char *)&v23 + 1), (BOOL *)a5);
  if (!*((_BYTE *)this + 544) && (!HIBYTE(v23) || !*((_BYTE *)this + 620)))
  {
    v20 = *((_DWORD *)this + 156);
    if (v20 == 1)
    {
      v21 = (SeparationBase **)((char *)this + 696);
    }
    else
    {
      if (v20)
      {
LABEL_43:
        AudioDSP::Utility::DetectNonFinites(v15, *a7, &v30, (const AudioStreamBasicDescription *)&v23, v16);
        if (!(_BYTE)v23 || !*((_BYTE *)this + 620))
          return 0;
        if (AUSeparateLogScope(void)::once != -1)
          dispatch_once(&AUSeparateLogScope(void)::once, &__block_literal_global_22744);
        if (AUSeparateLogScope(void)::scope)
        {
          v22 = *(NSObject **)AUSeparateLogScope(void)::scope;
          if (!*(_QWORD *)AUSeparateLogScope(void)::scope)
          {
LABEL_53:
            (*(void (**)(AUSeparate *))(*(_QWORD *)this + 64))(this);
            CopyBufferList(&(*a5)->mNumberBuffers, *a7);
            return 0;
          }
        }
        else
        {
          v22 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          v24 = 136315650;
          v25 = "AUSeparate.cpp";
          v26 = 1024;
          v27 = 926;
          v28 = 1024;
          v29 = v23;
          _os_log_impl(&dword_1B5ED0000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d AUSeparate: (OutputSignals) is NOT finite: (%u)\n", (uint8_t *)&v24, 0x18u);
        }
        goto LABEL_53;
      }
      v21 = (SeparationBase **)((char *)this + 688);
    }
    SeparationBase::ProcessBufferList(*v21, *a5, *a7);
    goto LABEL_43;
  }
  CopyBufferList(&(*a5)->mNumberBuffers, *a7);
  if (HIBYTE(v23))
  {
    if (AUSeparateLogScope(void)::once != -1)
      dispatch_once(&AUSeparateLogScope(void)::once, &__block_literal_global_22744);
    if (AUSeparateLogScope(void)::scope)
    {
      v17 = *(NSObject **)AUSeparateLogScope(void)::scope;
      if (!*(_QWORD *)AUSeparateLogScope(void)::scope)
        return 0;
    }
    else
    {
      v17 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v24 = 136315650;
      v25 = "AUSeparate.cpp";
      v26 = 1024;
      v27 = 898;
      v28 = 1024;
      v29 = HIBYTE(v23);
      _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_ERROR, "%25s:%-5d AUSeparate: (InputSignals) is NOT finite: (%u)\n", (uint8_t *)&v24, 0x18u);
    }
  }
  return 0;
}

uint64_t AUSeparate::Render(AUSeparate *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUInputElement *Element;
  uint64_t result;
  ausdk::AUIOElement *v10;
  uint64_t v11;
  ausdk::AUIOElement *v12;
  uint64_t BufferList;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  if (ausdk::AUBase::HasInput(this, 0))
  {
    Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUSeparate *)((char *)this + 80), 0);
    result = ausdk::AUInputElement::PullInput(Element, a2, a3, 0, a4);
    if (!(_DWORD)result)
    {
      v10 = (ausdk::AUIOElement *)ausdk::AUScope::SafeGetElement((AUSeparate *)((char *)this + 128), 0);
      v14[0] = ausdk::AUIOElement::PrepareBuffer(v10, a4);
      v11 = ausdk::AUScope::SafeGetElement((AUSeparate *)((char *)this + 80), 0);
      BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v11 + 144));
      return (*(uint64_t (**)(AUSeparate *, unsigned int *, uint64_t, uint64_t, uint64_t *, uint64_t, _QWORD *))(*(_QWORD *)this + 184))(this, a2, a4, 1, &BufferList, 1, v14);
    }
  }
  else
  {
    v12 = (ausdk::AUIOElement *)ausdk::AUScope::SafeGetElement((AUSeparate *)((char *)this + 128), 0);
    ausdk::AUIOElement::PrepareBuffer(v12, a4);
    return 0;
  }
  return result;
}

uint64_t AUSeparate::GetParameterList(AUSeparate *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;

  if (a2 == 4)
    return 0;
  if (a2)
    return 4294956430;
  if (a3)
  {
    *(_OWORD *)a3 = xmmword_1B6626920;
    *((_OWORD *)a3 + 1) = xmmword_1B66A0770;
    *((_OWORD *)a3 + 2) = xmmword_1B66A07D0;
    *((_QWORD *)a3 + 6) = 0xD0000000CLL;
    a3[14] = 14;
  }
  result = 0;
  *a4 = 15;
  return result;
}

uint64_t AUSeparate::GetParameterInfo(AUSeparate *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  AudioUnitParameterUnit v6;
  AudioUnitParameterValue v7;
  uint64_t v8;
  AudioUnitParameterOptions v9;
  uint64_t v10;
  AudioUnitParameterOptions v11;

  buffer->flags = 0;
  buffer->unitName = 0;
  if (a2 == 4)
    return 0;
  if (a2)
    return 4294956430;
  switch(a3)
  {
    case 0:
      buffer->cfNameString = CFSTR("IVA mode");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("IVA mode"), buffer->name, 52, 0x8000100u);
      result = 0;
      v6 = kAudioUnitParameterUnit_Indexed;
      goto LABEL_14;
    case 1:
      buffer->cfNameString = CFSTR("Smoothing time constant for mic PSD");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Smoothing time constant for mic PSD"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      *(_QWORD *)&buffer->minValue = 0x4080000000000000;
      v7 = 2.0;
      goto LABEL_25;
    case 2:
      buffer->cfNameString = CFSTR("Parameter for source prior model");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Parameter for source prior model"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x3F8000003F000000;
      v7 = 0.9;
      goto LABEL_25;
    case 3:
      buffer->cfNameString = CFSTR("Speech RMS floor");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Speech RMS floor"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      v8 = 3267887104;
      goto LABEL_16;
    case 4:
      buffer->cfNameString = CFSTR("Signal pre-emphasis factor");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Signal pre-emphasis factor"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 0x42C80000C3960000;
      v7 = 9.5424;
      goto LABEL_25;
    case 5:
      buffer->cfNameString = CFSTR("Initial condition factor for covariance matrices");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Initial condition factor for covariance matrices"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 0x41A00000C2C80000;
      v7 = -20.0;
      goto LABEL_25;
    case 6:
      buffer->cfNameString = CFSTR("Use uniform diagonal elements to initilize covariance matrices");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Use uniform diagonal elements to initilize covariance matrices"), buffer->name, 52, 0x8000100u);
      result = 0;
      v6 = kAudioUnitParameterUnit_Boolean;
LABEL_14:
      buffer->unit = v6;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      v9 = buffer->flags | 0xC0000000;
      buffer->defaultValue = 0.0;
      buffer->flags = v9;
      return result;
    case 7:
      buffer->cfNameString = CFSTR("Covariance diagonal loading factor for direct inverse approach");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Covariance diagonal loading factor for direct inverse approach"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      v8 = 0x41200000C2C80000;
LABEL_16:
      *(_QWORD *)&buffer->minValue = v8;
      v7 = -30.0;
      goto LABEL_25;
    case 8:
      buffer->cfNameString = CFSTR("Minimum frequency to calculate speech RMS");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Minimum frequency to calculate speech RMS"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Hertz;
      *(_QWORD *)&buffer->minValue = 0x43FA000042480000;
      v7 = 60.0;
      goto LABEL_25;
    case 9:
      buffer->cfNameString = CFSTR("Maximum frequency to calculate speech RMS");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Maximum frequency to calculate speech RMS"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Hertz;
      *(_QWORD *)&buffer->minValue = 0x45FA0000455AC000;
      v7 = 7000.0;
      goto LABEL_25;
    case 10:
      buffer->cfNameString = CFSTR("Initial wait time before starting unmixing matrix update");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Initial wait time before starting unmixing matrix update"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Seconds;
      *(_QWORD *)&buffer->minValue = 0x4000000000000000;
      v7 = 0.1;
      goto LABEL_25;
    case 11:
      buffer->cfNameString = CFSTR("Maximum output signal gain");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Maximum output signal gain"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 0x4120000000000000;
      v7 = 6.0;
      goto LABEL_25;
    case 12:
      buffer->cfNameString = CFSTR("Gain floor of separation filter");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Gain floor of separation filter"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      v10 = 3281387520;
      goto LABEL_24;
    case 13:
      buffer->cfNameString = CFSTR("Regularization factor of lower triangular matrix in Cholesky factorization");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Regularization factor of lower triangular matrix in Cholesky factorization"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 3281387520;
      v7 = -90.0;
      goto LABEL_25;
    case 14:
      buffer->cfNameString = CFSTR("Regularization factor in HRLS-based covariance inverse");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Regularization factor in HRLS-based covariance inverse"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      v10 = 3273654272;
LABEL_24:
      *(_QWORD *)&buffer->minValue = v10;
      v7 = -100.0;
LABEL_25:
      v11 = buffer->flags | 0xC0000000;
      buffer->defaultValue = v7;
      buffer->flags = v11;
      break;
    default:
      result = 4294956418;
      break;
  }
  return result;
}

UInt8 *AUSeparate::SaveExtendedScopes(AUSeparate *this, __CFData *a2)
{
  ausdk::AUScope *Scope;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);
  return ausdk::AUScope::SaveState(Scope, a2);
}

uint64_t AUSeparate::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
    this[66] = (OpaqueAudioComponentInstance *)((char *)this[66] + 1);
  return result;
}

uint64_t AUSeparate::GetParameterValueStrings(AUSeparate *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  const __CFArray *v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 0;
  if (a2)
    return 4294956430;
  if (a3)
    return 0;
  v7 = xmmword_1E69EA538;
  v6 = CFArrayCreate(0, (const void **)&v7, 2, 0);
  result = 0;
  *a4 = v6;
  return result;
}

double AUSeparate::GetLatency(AUSeparate *this)
{
  return 0.0;
}

double AUSeparate::GetTailTime(AUSeparate *this)
{
  return 0.05;
}

uint64_t AUSeparate::SupportsTail(AUSeparate *this)
{
  return 1;
}

BOOL AUSeparate::StreamFormatWritable(AUSeparate *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUSeparate::SupportedNumChannels(AUSeparate *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUSeparate::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 16;
}

uint64_t AUSeparate::ValidFormat(AUSeparate *this, int a2, unsigned int a3, const AudioStreamBasicDescription *a4)
{
  uint64_t result;

  if (a4->mBitsPerChannel == 64 && a4->mFormatID == 1718773105)
    result = (LOBYTE(a4->mFormatFlags) >> 5) & 1;
  else
    result = 0;
  if (a2 == 2 || a2 == 1)
  {
    if (a4->mChannelsPerFrame < 0x11)
      return result;
    else
      return 0;
  }
  return result;
}

uint64_t AUSeparate::ChangeStreamFormat(AUSeparate *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  ausdk::AUBase::ChangeStreamFormat(this, a2, a3, a4, a5);
  if (a4->mSampleRate != a5->mSampleRate)
    *((_QWORD *)this + 76) = *(_QWORD *)&a5->mSampleRate;
  return 0;
}

uint64_t AUSeparate::GetScopeExtended(AUSeparate *this, int a2)
{
  if (a2 == 4)
    return (uint64_t)this + 552;
  else
    return 0;
}

uint64_t AUSeparate::SetMaxFramesPerSlice(AUSeparate *this, int a2)
{
  uint64_t result;

  result = ausdk::AUBase::SetMaxFramesPerSlice((uint64_t)this, a2);
  if (*((_DWORD *)this + 150) != a2)
    *((_DWORD *)this + 150) = a2;
  return result;
}

void AUSeparate::UpdateState(AUSeparate *this)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  uint64_t v5;
  ausdk::AUElement *v6;
  ausdk::AUElement **v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  uint64_t v14;
  ausdk::AUElement *v15;
  ausdk::AUElement **v16;
  uint64_t v17;
  ausdk::AUElement *v18;
  ausdk::AUElement **v19;
  uint64_t v20;
  ausdk::AUElement *v21;
  ausdk::AUElement **v22;
  uint64_t v23;
  ausdk::AUElement *v24;
  ausdk::AUElement **v25;
  uint64_t v26;
  ausdk::AUElement *v27;
  ausdk::AUElement **v28;
  uint64_t v29;
  ausdk::AUElement *v30;
  ausdk::AUElement **v31;
  uint64_t v32;
  ausdk::AUElement *v33;
  ausdk::AUElement **v34;
  uint64_t v35;
  ausdk::AUElement *v36;
  ausdk::AUElement **v37;
  uint64_t v38;
  ausdk::AUElement *v39;
  ausdk::AUElement **v40;
  uint64_t v41;
  ausdk::AUElement *v42;
  ausdk::AUElement **v43;
  uint64_t v44;
  ausdk::AUElement *v45;
  ausdk::AUElement **v46;
  uint64_t v47;
  ausdk::AUElement *v48;
  ausdk::AUElement **v49;
  float Parameter;
  float v51;
  float v52;

  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v4 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  *((_DWORD *)this + 156) = (int)ausdk::AUElement::GetParameter(v3, 0);
  v5 = *((_QWORD *)this + 9);
  if (v5)
  {
    v6 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
  }
  else
  {
    v7 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v7)
      v6 = 0;
    else
      v6 = *v7;
  }
  *((float *)this + 157) = ausdk::AUElement::GetParameter(v6, 1u);
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  *((float *)this + 158) = ausdk::AUElement::GetParameter(v9, 2u);
  v11 = *((_QWORD *)this + 9);
  if (v11)
  {
    v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
  }
  else
  {
    v13 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v13)
      v12 = 0;
    else
      v12 = *v13;
  }
  *((float *)this + 159) = ausdk::AUElement::GetParameter(v12, 3u);
  v14 = *((_QWORD *)this + 9);
  if (v14)
  {
    v15 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 32))(v14, 0);
  }
  else
  {
    v16 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v16)
      v15 = 0;
    else
      v15 = *v16;
  }
  *((float *)this + 160) = ausdk::AUElement::GetParameter(v15, 4u);
  v17 = *((_QWORD *)this + 9);
  if (v17)
  {
    v18 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 32))(v17, 0);
  }
  else
  {
    v19 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v19)
      v18 = 0;
    else
      v18 = *v19;
  }
  *((float *)this + 161) = ausdk::AUElement::GetParameter(v18, 5u);
  v20 = *((_QWORD *)this + 9);
  if (v20)
  {
    v21 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 32))(v20, 0);
  }
  else
  {
    v22 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v22)
      v21 = 0;
    else
      v21 = *v22;
  }
  *((_BYTE *)this + 648) = ausdk::AUElement::GetParameter(v21, 6u) != 0.0;
  v23 = *((_QWORD *)this + 9);
  if (v23)
  {
    v24 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
  }
  else
  {
    v25 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v25)
      v24 = 0;
    else
      v24 = *v25;
  }
  *((float *)this + 163) = ausdk::AUElement::GetParameter(v24, 7u);
  v26 = *((_QWORD *)this + 9);
  if (v26)
  {
    v27 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 32))(v26, 0);
  }
  else
  {
    v28 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v28)
      v27 = 0;
    else
      v27 = *v28;
  }
  *((float *)this + 165) = ausdk::AUElement::GetParameter(v27, 8u);
  v29 = *((_QWORD *)this + 9);
  if (v29)
  {
    v30 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v29 + 32))(v29, 0);
  }
  else
  {
    v31 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v31)
      v30 = 0;
    else
      v30 = *v31;
  }
  *((float *)this + 166) = ausdk::AUElement::GetParameter(v30, 9u);
  v32 = *((_QWORD *)this + 9);
  if (v32)
  {
    v33 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v32 + 32))(v32, 0);
  }
  else
  {
    v34 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v34)
      v33 = 0;
    else
      v33 = *v34;
  }
  *((float *)this + 167) = ausdk::AUElement::GetParameter(v33, 0xAu);
  v35 = *((_QWORD *)this + 9);
  if (v35)
  {
    v36 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 32))(v35, 0);
  }
  else
  {
    v37 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v37)
      v36 = 0;
    else
      v36 = *v37;
  }
  *((float *)this + 168) = ausdk::AUElement::GetParameter(v36, 0xBu);
  v38 = *((_QWORD *)this + 9);
  if (v38)
  {
    v39 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v38 + 32))(v38, 0);
  }
  else
  {
    v40 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v40)
      v39 = 0;
    else
      v39 = *v40;
  }
  *((float *)this + 169) = ausdk::AUElement::GetParameter(v39, 0xCu);
  v41 = *((_QWORD *)this + 9);
  if (v41)
  {
    v42 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v41 + 32))(v41, 0);
  }
  else
  {
    v43 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v43)
      v42 = 0;
    else
      v42 = *v43;
  }
  *((float *)this + 170) = ausdk::AUElement::GetParameter(v42, 0xDu);
  v44 = *((_QWORD *)this + 9);
  if (v44)
  {
    v45 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v44 + 32))(v44, 0);
  }
  else
  {
    v46 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v46)
      v45 = 0;
    else
      v45 = *v46;
  }
  *((float *)this + 171) = ausdk::AUElement::GetParameter(v45, 0xEu);
  v47 = *((_QWORD *)this + 9);
  if (v47)
  {
    v48 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v47 + 32))(v47, 0);
  }
  else
  {
    v49 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v49)
      v48 = 0;
    else
      v48 = *v49;
  }
  Parameter = ausdk::AUElement::GetParameter(v48, 1u);
  v51 = 0.0;
  if (Parameter != 0.0)
  {
    v52 = *((double *)this + 76);
    v51 = expf((float)((float)-(float)*((unsigned int *)this + 150) / v52) / Parameter);
  }
  *((float *)this + 164) = v51;
  AUSeparate::InitializeIVAClasses(this);
}

os_log_t ___ZL18AUSeparateLogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "auauss");
  *v0 = result;
  AUSeparateLogScope(void)::scope = (uint64_t)v0;
  return result;
}

void AUSeparate::InitializeIVAClasses(AUSeparate *this)
{
  NSObject *v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  int v19;
  int v20;
  float *v21;
  float v22;
  int v23;
  uint64_t v24;
  float v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (AUSeparateLogScope(void)::once != -1)
    dispatch_once(&AUSeparateLogScope(void)::once, &__block_literal_global_22744);
  if (AUSeparateLogScope(void)::scope)
  {
    v2 = *(NSObject **)AUSeparateLogScope(void)::scope;
    if (!*(_QWORD *)AUSeparateLogScope(void)::scope)
      goto LABEL_9;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    v50 = "AUSeparate.cpp";
    v51 = 1024;
    v52 = 982;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d AUSeparate: Initialize IVA Classes.\n", buf, 0x12u);
  }
LABEL_9:
  v3 = *((float *)this + 159);
  v4 = 1.0;
  v5 = 1.0;
  if (v3 != 0.0)
    v5 = __exp10f(v3 / 10.0);
  v6 = *((float *)this + 160);
  if (v6 != 0.0)
    v4 = __exp10f(v6 / 20.0);
  v7 = *((float *)this + 161);
  v8 = 1.0;
  v9 = 1.0;
  if (v7 != 0.0)
    v9 = __exp10f(v7 / 20.0);
  v10 = *((float *)this + 163);
  if (v10 != 0.0)
    v8 = __exp10f(v10 / 10.0);
  v11 = *((float *)this + 168);
  v12 = 1.0;
  v13 = 1.0;
  if (v11 != 0.0)
    v13 = __exp10f(v11 / 10.0);
  v14 = *((float *)this + 169);
  if (v14 != 0.0)
    v12 = __exp10f(v14 / 20.0);
  v15 = *((float *)this + 170);
  v16 = 1.0;
  v17 = 1.0;
  if (v15 != 0.0)
    v17 = __exp10f(v15 / 10.0);
  v18 = *((float *)this + 171);
  if (v18 != 0.0)
    v16 = __exp10f(v18 / 10.0);
  if (*((_QWORD *)this + 86))
    std::unique_ptr<IVA_HRLS_Rank1>::reset[abi:ne180100]((SeparationBase **)this + 86, 0);
  if (*((_QWORD *)this + 87))
    std::unique_ptr<IVA_DirectiV_Rank1A>::reset[abi:ne180100]((SeparationBase **)this + 87, 0);
  v19 = *((_DWORD *)this + 156);
  if (v19 == 1)
  {
    v23 = *((_DWORD *)this + 150);
    v24 = operator new();
    v25 = *((double *)this + 76);
    SeparationBase::SeparationBase((SeparationBase *)v24, *((_DWORD *)this + 154), v23 + 1, v25, *((float *)this + 164), *((float *)this + 158), v5, v4, v9, *((_BYTE *)this + 648), v8, 1, *((float *)this + 165), *((float *)this + 166), *((float *)this + 167), v13, v12, v17, v16);
    *(_QWORD *)v24 = off_1E69EA5B8;
    v26 = *(unsigned int *)(v24 + 48);
    *(_DWORD *)buf = 0;
    std::vector<float>::vector((_QWORD *)(v24 + 1152), v26, buf);
    v27 = (*(_DWORD *)(v24 + 48) * *(_DWORD *)(v24 + 52));
    *(_DWORD *)buf = 0;
    std::vector<float>::vector((_QWORD *)(v24 + 1176), v27, buf);
    v28 = (*(_DWORD *)(v24 + 48) * *(_DWORD *)(v24 + 52));
    *(_DWORD *)buf = 0;
    std::vector<float>::vector((_QWORD *)(v24 + 1200), v28, buf);
    v29 = (*(_DWORD *)(v24 + 48) * *(_DWORD *)(v24 + 52));
    *(_DWORD *)buf = 0;
    std::vector<float>::vector((_QWORD *)(v24 + 1224), v29, buf);
    v30 = (*(_DWORD *)(v24 + 48) * *(_DWORD *)(v24 + 52));
    *(_DWORD *)buf = 0;
    std::vector<float>::vector((_QWORD *)(v24 + 1248), v30, buf);
    v31 = (*(_DWORD *)(v24 + 48) * *(_DWORD *)(v24 + 52));
    *(_DWORD *)buf = 0;
    std::vector<float>::vector((_QWORD *)(v24 + 1272), v31, buf);
    v32 = (*(_DWORD *)(v24 + 48) * *(_DWORD *)(v24 + 52));
    *(_DWORD *)buf = 0;
    std::vector<float>::vector((_QWORD *)(v24 + 1296), v32, buf);
    std::vector<DSPSplitComplex>::vector((_QWORD *)(v24 + 1320), *(unsigned int *)(v24 + 52));
    std::vector<DSPSplitComplex>::vector((_QWORD *)(v24 + 1344), *(unsigned int *)(v24 + 52));
    v33 = std::vector<DSPSplitComplex>::vector((_QWORD *)(v24 + 1368), *(unsigned int *)(v24 + 52));
    v34 = *(unsigned int *)(v24 + 48);
    if ((_DWORD)v34)
    {
      v35 = 0;
      v36 = *(_QWORD *)(v24 + 1152);
      do
      {
        v37 = fmax(*(float *)(v24 + 36) / ((double)v35 * 0.15 + 1.0), *(float *)(v24 + 120));
        *(float *)(v36 + 4 * v35++) = v37;
      }
      while (v34 != v35);
    }
    v38 = *(unsigned int *)(v24 + 52);
    if ((_DWORD)v38)
    {
      v39 = 0;
      v40 = *(_QWORD *)(v24 + 1176);
      v41 = *(_QWORD *)(v24 + 1248);
      v42 = *(_QWORD *)(v24 + 1200);
      v43 = *(_QWORD *)(v24 + 1272);
      v44 = *(_QWORD *)(v24 + 1224);
      v45 = *(_QWORD *)(v24 + 1296);
      v46 = (_QWORD *)(*v33 + 8);
      v47 = (_QWORD *)(*(_QWORD *)(v24 + 1344) + 8);
      v48 = (_QWORD *)(*(_QWORD *)(v24 + 1320) + 8);
      do
      {
        *(v48 - 1) = v40 + 4 * v39;
        *v48 = v41 + 4 * v39;
        *(v47 - 1) = v42 + 4 * v39;
        *v47 = v43 + 4 * v39;
        *(v46 - 1) = v44 + 4 * v39;
        *v46 = v45 + 4 * v39;
        v46 += 2;
        v47 += 2;
        v48 += 2;
        v39 += v34;
        --v38;
      }
      while (v38);
    }
    std::unique_ptr<IVA_DirectiV_Rank1A>::reset[abi:ne180100]((SeparationBase **)this + 87, (SeparationBase *)v24);
  }
  else if (!v19)
  {
    v20 = *((_DWORD *)this + 150);
    v21 = (float *)operator new();
    v22 = *((double *)this + 76);
    SeparationBase::SeparationBase((SeparationBase *)v21, *((_DWORD *)this + 154), v20 + 1, v22, *((float *)this + 164), *((float *)this + 158), v5, v4, v9, *((_BYTE *)this + 648), v8, 0, *((float *)this + 165), *((float *)this + 166), *((float *)this + 167), v13, v12, v17, v16);
    *(_QWORD *)v21 = off_1E69CC1C0;
    v21[288] = 1.0 / sqrtf(v21[3]);
    std::unique_ptr<IVA_HRLS_Rank1>::reset[abi:ne180100]((SeparationBase **)this + 86, (SeparationBase *)v21);
  }
}

void sub_1B6553F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  SeparationBase *v12;
  void **v13;
  void **v14;
  void **v15;
  void **v16;
  void **v17;
  void **v18;
  void **v19;
  void **v20;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;

  v22 = *v14;
  if (*v14)
  {
    *((_QWORD *)v12 + 169) = v22;
    operator delete(v22);
  }
  v23 = *v20;
  if (*v20)
  {
    *((_QWORD *)v12 + 166) = v23;
    operator delete(v23);
  }
  v24 = *v19;
  if (*v19)
  {
    *((_QWORD *)v12 + 163) = v24;
    operator delete(v24);
  }
  v25 = *v18;
  if (*v18)
  {
    *((_QWORD *)v12 + 160) = v25;
    operator delete(v25);
  }
  v26 = *v17;
  if (*v17)
  {
    *((_QWORD *)v12 + 157) = v26;
    operator delete(v26);
  }
  v27 = *v16;
  if (*v16)
  {
    *((_QWORD *)v12 + 154) = v27;
    operator delete(v27);
  }
  v28 = *v15;
  if (*v15)
  {
    *((_QWORD *)v12 + 151) = v28;
    operator delete(v28);
  }
  v29 = *v13;
  if (*v13)
  {
    *((_QWORD *)v12 + 148) = v29;
    operator delete(v29);
  }
  v30 = *a12;
  if (*a12)
  {
    *((_QWORD *)v12 + 145) = v30;
    operator delete(v30);
  }
  SeparationBase::~SeparationBase(v12);
  MEMORY[0x1BCC95CEC](v12, 0x10A1C408614EAFDLL);
  _Unwind_Resume(a1);
}

void sub_1B6554078()
{
  JUMPOUT(0x1B6554050);
}

void sub_1B6554080()
{
  JUMPOUT(0x1B6554058);
}

void sub_1B6554088()
{
  JUMPOUT(0x1B6554064);
}

void sub_1B655409C()
{
  JUMPOUT(0x1B6554070);
}

SeparationBase *std::unique_ptr<IVA_HRLS_Rank1>::reset[abi:ne180100](SeparationBase **a1, SeparationBase *a2)
{
  SeparationBase *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    SeparationBase::~SeparationBase(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

SeparationBase **std::unique_ptr<IVA_DirectiV_Rank1A>::reset[abi:ne180100](SeparationBase **result, SeparationBase *a2)
{
  SeparationBase *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    *(_QWORD *)v2 = off_1E69EA5B8;
    v3 = (void *)*((_QWORD *)v2 + 171);
    if (v3)
    {
      *((_QWORD *)v2 + 172) = v3;
      operator delete(v3);
    }
    v4 = (void *)*((_QWORD *)v2 + 168);
    if (v4)
    {
      *((_QWORD *)v2 + 169) = v4;
      operator delete(v4);
    }
    v5 = (void *)*((_QWORD *)v2 + 165);
    if (v5)
    {
      *((_QWORD *)v2 + 166) = v5;
      operator delete(v5);
    }
    v6 = (void *)*((_QWORD *)v2 + 162);
    if (v6)
    {
      *((_QWORD *)v2 + 163) = v6;
      operator delete(v6);
    }
    v7 = (void *)*((_QWORD *)v2 + 159);
    if (v7)
    {
      *((_QWORD *)v2 + 160) = v7;
      operator delete(v7);
    }
    v8 = (void *)*((_QWORD *)v2 + 156);
    if (v8)
    {
      *((_QWORD *)v2 + 157) = v8;
      operator delete(v8);
    }
    v9 = (void *)*((_QWORD *)v2 + 153);
    if (v9)
    {
      *((_QWORD *)v2 + 154) = v9;
      operator delete(v9);
    }
    v10 = (void *)*((_QWORD *)v2 + 150);
    if (v10)
    {
      *((_QWORD *)v2 + 151) = v10;
      operator delete(v10);
    }
    v11 = (void *)*((_QWORD *)v2 + 147);
    if (v11)
    {
      *((_QWORD *)v2 + 148) = v11;
      operator delete(v11);
    }
    v12 = (void *)*((_QWORD *)v2 + 144);
    if (v12)
    {
      *((_QWORD *)v2 + 145) = v12;
      operator delete(v12);
    }
    SeparationBase::~SeparationBase(v2);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

uint64_t OrientationAndCameraDirectionDependentBox<SCMicSelectionInfo>::Get(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v5 = ClampOrientation(a3);
  v6 = ClampCameraDirection(a2);
  LODWORD(v5) = ClampOrientation(v5);
  v7 = ClampCameraDirection(v6) | (2 * (_DWORD)v5);
  v8 = *(_QWORD *)(a1 + 784);
  if (v7 >= (*(_QWORD *)(a1 + 792) - v8) >> 5)
    __assert_rtn("GetIndex", "OrientationAndCameraDirectionDependentBox.hpp", 60, "index < mInfoPerCameraDirectionAndOrientation.size()");
  return v8 + 32 * v7;
}

void std::vector<SCMicSelectionInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 3);
        if (v6)
        {
          *((_QWORD *)v4 - 2) = v6;
          operator delete(v6);
        }
        v4 -= 32;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t OrientationAndCameraDirectionDependentBox<SCMicSelectionInfo>::setParameter(uint64_t result, int a2, float a3)
{
  uint64_t v3;

  v3 = result;
  if (a2)
  {
    if (a2 == 30)
    {
      result = ClampOrientation(a3);
      *(_DWORD *)(v3 + 772) = result;
    }
  }
  else
  {
    result = ClampCameraDirection(a3);
    *(_DWORD *)(v3 + 776) = result;
  }
  return result;
}

void SCMicSelectionBox::~SCMicSelectionBox(SCMicSelectionBox *this)
{
  void *v2;
  void **v3;

  *(_QWORD *)this = &off_1E69EA5D8;
  v2 = (void *)*((_QWORD *)this + 101);
  if (v2)
  {
    *((_QWORD *)this + 102) = v2;
    operator delete(v2);
  }
  *(_QWORD *)this = off_1E69EA868;
  v3 = (void **)((char *)this + 784);
  std::vector<SCMicSelectionInfo>::__destroy_vector::operator()[abi:ne180100](&v3);
  DSPGraph::Box::~Box(this);
}

{
  void *v2;
  void **v3;

  *(_QWORD *)this = &off_1E69EA5D8;
  v2 = (void *)*((_QWORD *)this + 101);
  if (v2)
  {
    *((_QWORD *)this + 102) = v2;
    operator delete(v2);
  }
  *(_QWORD *)this = off_1E69EA868;
  v3 = (void **)((char *)this + 784);
  std::vector<SCMicSelectionInfo>::__destroy_vector::operator()[abi:ne180100](&v3);
  DSPGraph::Box::~Box(this);
  JUMPOUT(0x1BCC95CECLL);
}

const char *SCMicSelectionBox::ClassName(SCMicSelectionBox *this)
{
  return "SCMicSelectionBox";
}

float SCMicSelectionBox::getParameter(SCMicSelectionBox *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5;
  int v6;

  v6 = 0;
  v5 = 4;
  (*(void (**)(SCMicSelectionBox *, uint64_t, uint64_t, uint64_t, int *, int *))(*(_QWORD *)this + 304))(this, a2, a3, a4, &v5, &v6);
  return (float)v6;
}

double SCMicSelectionBox::desc@<D0>(uint64_t a1@<X8>)
{
  double result;

  result = 1.14860057e248;
  *(_OWORD *)a1 = xmmword_1B66A1220;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

uint64_t SCMicSelectionBox::getPropertyInfo(SCMicSelectionBox *this)
{
  return 4;
}

uint64_t SCMicSelectionBox::getProperty(SCMicSelectionBox *this, int a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6)
{
  unint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a2 == 2)
  {
    v11 = (_DWORD *)(OrientationAndCameraDirectionDependentBox<SCMicSelectionInfo>::Get((uint64_t)this, *((unsigned int *)this + 194), *((unsigned int *)this + 193))+ 4);
    goto LABEL_11;
  }
  if (a2 == 1)
  {
    v11 = (_DWORD *)OrientationAndCameraDirectionDependentBox<SCMicSelectionInfo>::Get((uint64_t)this, *((unsigned int *)this + 194), *((unsigned int *)this + 193));
    goto LABEL_11;
  }
  if (a2)
  {
    v12 = (a2 - 3);
    v13 = OrientationAndCameraDirectionDependentBox<SCMicSelectionInfo>::Get((uint64_t)this, *((unsigned int *)this + 194), *((unsigned int *)this + 193));
    if (v12 >= (uint64_t)(*(_QWORD *)(v13 + 16) - *(_QWORD *)(v13 + 8)) >> 2)
      return 4294956417;
    v14 = OrientationAndCameraDirectionDependentBox<SCMicSelectionInfo>::Get((uint64_t)this, *((unsigned int *)this + 194), *((unsigned int *)this + 193));
    v15 = *(_QWORD *)(v14 + 8);
    if (v12 < (*(_QWORD *)(v14 + 16) - v15) >> 2)
    {
      v11 = (_DWORD *)(v15 + 4 * v12);
      goto LABEL_11;
    }
LABEL_14:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
  v9 = *((unsigned int *)this + 194);
  v10 = *((_QWORD *)this + 101);
  if (v9 >= (*((_QWORD *)this + 102) - v10) >> 2)
    goto LABEL_14;
  v11 = (_DWORD *)(v10 + 4 * v9);
LABEL_11:
  v16 = 0;
  *a6 = *v11;
  *a5 = 4;
  return v16;
}

void aec_v3::aec_init(uint64_t *a1, unsigned int a2, int a3, int a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15, float a16, int a17, float a18, float a19, int a20,int a21,int a22,int a23,float a24,int a25,int a26,int a27,int a28,int a29,int a30)
{
  _QWORD *v43;
  _OWORD *v44;
  int v45;
  uint64_t v46;
  _DWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  int v60;
  size_t v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  uint64_t v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  uint64_t v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  uint64_t v88;
  _DWORD *v89;
  _DWORD *v90;
  uint64_t v91;
  void *v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  void *v100;
  void *v101;
  _QWORD *v102;
  _QWORD *v103;
  vDSP_Length v104;
  uint64_t v105;
  int v106;
  int v107;
  char *v108;
  char *v109;
  void *v110;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  void *v116;
  void *v117;
  void *v118;
  void *v119;
  float v120;
  uint64_t v121;
  float v122;
  void *v123;
  void *v124;
  void *v125;
  void *v126;
  uint64_t v127;
  _DWORD *v128;
  _DWORD *v129;
  uint64_t v130;
  void *v131;
  void *v132;
  void *v133;
  void *v134;
  float v135;
  uint64_t v136;
  _DWORD *v137;
  uint64_t v138;
  float *v139;
  float v140;
  size_t v141;
  unint64_t v142;
  _QWORD *v143;
  __int128 v144;
  void *v145;
  void *v146;
  void *v147;
  void *v148;
  uint64_t v149;
  _DWORD *v150;
  _DWORD *v151;
  uint64_t v152;
  float v153;
  unsigned int v154;
  unsigned int v155;
  size_t v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  void *v162;
  size_t v163;
  void *v164;
  void *v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  int32x2_t v170;
  uint32x2_t *v171;
  float32x2_t v172;
  uint32x2_t v177;
  float v178;
  unsigned int v179;
  float v180;
  unsigned int v181;
  float v182;
  unsigned int v183;
  unsigned int v184;
  unsigned int v185;
  unsigned int v186;
  size_t v187;
  void *v188;
  void *v190;
  uint64_t v191;
  uint64_t v192;
  _DWORD *v193;
  _DWORD *v194;
  uint64_t v195;
  _DWORD *v196;
  _DWORD *v197;
  unsigned int v198;
  float v199;
  uint64_t v200;
  float v201;
  int32x2_t v202;
  uint64_t v203;
  int v204;
  uint64_t v206;
  int v207;
  int v208;
  int v209;
  int32x2_t v210;
  int8x8_t v211;
  int v212;
  void *v213;
  void *v215;
  void *v216;
  void *v218;
  void *v219;
  void *v221;
  void *v222;
  void *v224;
  int v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  void *v232;
  void *v233;
  float v234;
  uint64_t v235;
  void *v236;
  void *v237;
  void *v238;
  void *v239;
  void *v240;
  void *v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  void *v245;
  void *v246;
  void *v247;
  void *v248;
  void *v249;
  void *v250;
  void *v251;
  void *v252;
  void *v253;
  void *v254;
  void *v255;
  void *v256;
  uint64_t v257;
  void *v258;
  void *v259;
  void *v260;
  void *v261;
  void *v262;
  void *v263;
  void *v264;
  void *v265;
  void *v266;
  void *v267;
  void *v268;
  void *v269;
  uint64_t v270;
  uint64_t v271;
  int v272;
  uint64_t v273;
  void *v274;
  void *v275;
  int v276;
  void *v277;
  void *v278;
  void *v279;
  void *v280;
  void *v281;
  void *v282;
  void *v283;
  void *v284;
  void *v285;
  void *v286;
  uint64_t v287;
  void *v288;
  void *v289;
  void *v290;
  void *v291;
  std::bad_alloc *exception;
  std::bad_alloc *v293;
  int v294;
  size_t v295;
  float v296;
  uint64_t v297;
  int v298;
  float v301;
  int v302;
  uint64_t v303;
  size_t v304;
  int v305;
  float __A[3];

  v43 = malloc_type_malloc(0x78uLL, 0x2C8E6D5CuLL);
  if (!v43)
    goto LABEL_242;
  v43[14] = 0;
  *((_OWORD *)v43 + 5) = 0u;
  *((_OWORD *)v43 + 6) = 0u;
  *((_OWORD *)v43 + 3) = 0u;
  *((_OWORD *)v43 + 4) = 0u;
  *((_OWORD *)v43 + 1) = 0u;
  *((_OWORD *)v43 + 2) = 0u;
  *(_OWORD *)v43 = 0u;
  *a1 = (uint64_t)v43;
  v44 = malloc_type_malloc(0x160uLL, 0x2C8E6D5CuLL);
  if (!v44)
    goto LABEL_242;
  v44[20] = 0u;
  v44[21] = 0u;
  v44[18] = 0u;
  v44[19] = 0u;
  v44[16] = 0u;
  v44[17] = 0u;
  v44[14] = 0u;
  v44[15] = 0u;
  v44[12] = 0u;
  v44[13] = 0u;
  v44[10] = 0u;
  v44[11] = 0u;
  v44[8] = 0u;
  v44[9] = 0u;
  v44[6] = 0u;
  v44[7] = 0u;
  v44[4] = 0u;
  v44[5] = 0u;
  v44[2] = 0u;
  v44[3] = 0u;
  *v44 = 0u;
  v44[1] = 0u;
  *(_QWORD *)(*a1 + 56) = v44;
  v45 = a3 / a4 <= 1 ? 1 : a3 / a4;
  v305 = a4;
  v294 = a7;
  v302 = a6;
  v298 = a8;
  dft_v3::dftInit2(*a1, v45 * a4, a4, v45, a2, a7, a6, a8, a5);
  v46 = *a1;
  v47 = *(_DWORD **)*a1;
  v48 = v47[9];
  v49 = (int)v47[4];
  v50 = v47[14];
  v51 = v47[15];
  v52 = v47[11];
  v303 = (int)v47[18];
  v53 = malloc_type_malloc(0x78uLL, 0x2C8E6D5CuLL);
  if (!v53)
    goto LABEL_242;
  v53[14] = 0;
  *((_OWORD *)v53 + 5) = 0u;
  *((_OWORD *)v53 + 6) = 0u;
  *((_OWORD *)v53 + 3) = 0u;
  *((_OWORD *)v53 + 4) = 0u;
  *((_OWORD *)v53 + 1) = 0u;
  *((_OWORD *)v53 + 2) = 0u;
  *(_OWORD *)v53 = 0u;
  *(_QWORD *)(v46 + 8) = v53;
  if ((v48 & 0x80000000) != 0)
    goto LABEL_242;
  v54 = malloc_type_malloc(4 * v48, 0x2C8E6D5CuLL);
  v55 = v54;
  if ((_DWORD)v48)
  {
    if (!v54)
      goto LABEL_242;
  }
  bzero(v54, 4 * v48);
  **(_QWORD **)(v46 + 8) = v55;
  v56 = malloc_type_malloc(4 * v48, 0x2C8E6D5CuLL);
  v57 = v56;
  if ((_DWORD)v48)
  {
    if (!v56)
      goto LABEL_242;
  }
  bzero(v56, 4 * v48);
  *(_QWORD *)(*(_QWORD *)(v46 + 8) + 8) = v57;
  v58 = malloc_type_malloc(8 * v49, 0x2C8E6D5CuLL);
  v59 = v58;
  if ((_DWORD)v49)
  {
    if (!v58)
      goto LABEL_242;
  }
  bzero(v58, 8 * v49);
  *(_QWORD *)(*(_QWORD *)(v46 + 8) + 32) = v59;
  *(_QWORD *)(*(_QWORD *)(v46 + 8) + 40) = *(_QWORD *)(*(_QWORD *)(v46 + 8) + 32);
  *(_QWORD *)(*(_QWORD *)(v46 + 8) + 48) = *(_QWORD *)(*(_QWORD *)(v46 + 8) + 32) + 4 * v49;
  if (v47[24])
  {
    *(_QWORD *)(*(_QWORD *)(v46 + 8) + 56) = 0;
    v60 = v305;
  }
  else
  {
    v61 = 4 * v303;
    v62 = malloc_type_malloc(4 * v303, 0x2C8E6D5CuLL);
    v63 = v62;
    v60 = v305;
    if ((_DWORD)v303 && !v62)
      goto LABEL_242;
    bzero(v62, v61);
    *(_QWORD *)(*(_QWORD *)(v46 + 8) + 56) = v63;
    v64 = malloc_type_malloc(v61, 0x2C8E6D5CuLL);
    v65 = v64;
    if ((_DWORD)v303)
    {
      if (!v64)
        goto LABEL_242;
    }
    bzero(v64, v61);
    *(_QWORD *)(*(_QWORD *)(v46 + 8) + 64) = v65;
  }
  v66 = *(_QWORD *)(v46 + 8);
  *(_DWORD *)(v66 + 112) = v47[11];
  *(_QWORD *)(v66 + 72) = 0;
  *(_DWORD *)(v66 + 80) = 0;
  if ((v52 & 0x80000000) != 0)
    goto LABEL_242;
  v67 = malloc_type_malloc(4 * v52, 0x2C8E6D5CuLL);
  v68 = v67;
  if ((_DWORD)v52)
  {
    if (!v67)
      goto LABEL_242;
  }
  bzero(v67, 4 * v52);
  *(_QWORD *)(*(_QWORD *)(v46 + 8) + 88) = v68;
  if ((v51 & 0x80000000) != 0)
    goto LABEL_242;
  v69 = malloc_type_malloc(4 * v51, 0x2C8E6D5CuLL);
  v70 = v69;
  if ((_DWORD)v51)
  {
    if (!v69)
      goto LABEL_242;
  }
  bzero(v69, 4 * v51);
  *(_QWORD *)(*(_QWORD *)(v46 + 8) + 16) = v70;
  v71 = malloc_type_malloc(4 * v51, 0x2C8E6D5CuLL);
  v72 = v71;
  if ((_DWORD)v51)
  {
    if (!v71)
      goto LABEL_242;
  }
  bzero(v71, 4 * v51);
  *(_QWORD *)(*(_QWORD *)(v46 + 8) + 24) = v72;
  if ((v50 & 0x80000000) != 0)
    goto LABEL_242;
  v73 = malloc_type_malloc(4 * v50, 0x2C8E6D5CuLL);
  v74 = v73;
  if ((_DWORD)v50)
  {
    if (!v73)
      goto LABEL_242;
  }
  bzero(v73, 4 * v50);
  *(_QWORD *)(*(_QWORD *)(v46 + 8) + 96) = v74;
  if ((_DWORD)v50)
    memset_pattern16(*(void **)(*(_QWORD *)(v46 + 8) + 96), &unk_1B66A2A40, 4 * v50);
  v75 = malloc_type_malloc(4 * v52, 0x2C8E6D5CuLL);
  v76 = v75;
  if ((_DWORD)v52)
  {
    if (!v75)
      goto LABEL_242;
    bzero(v75, 4 * v52);
    *(_QWORD *)(*(_QWORD *)(v46 + 8) + 104) = v76;
    bzero(*(void **)(*(_QWORD *)(v46 + 8) + 104), 4 * v52);
  }
  else
  {
    bzero(v75, 4 * v52);
    *(_QWORD *)(*(_QWORD *)(v46 + 8) + 104) = v76;
  }
  v77 = malloc_type_malloc(4 * v60, 0x2C8E6D5CuLL);
  v78 = v77;
  if (v60)
  {
    if (!v77)
      goto LABEL_242;
  }
  bzero(v77, 4 * v60);
  **(_QWORD **)(*a1 + 56) = v78;
  v79 = malloc_type_malloc(4 * v60, 0x2C8E6D5CuLL);
  v80 = v79;
  if (v60)
  {
    if (!v79)
      goto LABEL_242;
  }
  v81 = v60;
  bzero(v79, 4 * v60);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 8) = v80;
  v82 = malloc_type_malloc(8 * v60, 0x2C8E6D5CuLL);
  v83 = v82;
  if (v60)
  {
    if (!v82)
      goto LABEL_242;
  }
  bzero(v82, 8 * v60);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 16) = v83;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 24) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 16) + 4 * v60;
  v84 = malloc_type_malloc(4 * v60, 0x2C8E6D5CuLL);
  v85 = v84;
  if (v60)
  {
    if (!v84)
      goto LABEL_242;
  }
  bzero(v84, 4 * v60);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 32) = v85;
  v86 = malloc_type_malloc(4 * v60, 0x2C8E6D5CuLL);
  v87 = v86;
  if (v60)
  {
    if (!v86)
      goto LABEL_242;
  }
  bzero(v86, 4 * v60);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 40) = v87;
  if (v60 >= 1)
  {
    v88 = *(_QWORD *)(*a1 + 56);
    v89 = *(_DWORD **)(v88 + 32);
    v90 = *(_DWORD **)(v88 + 40);
    v91 = v60;
    do
    {
      *v89++ = 0;
      *v90++ = 0;
      --v91;
    }
    while (v91);
  }
  v92 = malloc_type_malloc(4 * v60, 0x2C8E6D5CuLL);
  v93 = v92;
  if (v60)
  {
    if (!v92)
      goto LABEL_242;
  }
  bzero(v92, 4 * v60);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 48) = v93;
  v94 = malloc_type_malloc(4 * v60, 0x2C8E6D5CuLL);
  v95 = v94;
  if (v60)
  {
    if (!v94)
      goto LABEL_242;
  }
  bzero(v94, 4 * v60);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 56) = v95;
  v96 = malloc_type_malloc(4 * v60, 0x2C8E6D5CuLL);
  v97 = v96;
  if (v60)
  {
    if (!v96)
      goto LABEL_242;
  }
  bzero(v96, 4 * v60);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 64) = v97;
  v98 = malloc_type_malloc(4 * v60, 0x2C8E6D5CuLL);
  v99 = v98;
  if (v60)
  {
    if (!v98)
      goto LABEL_242;
  }
  bzero(v98, 4 * v60);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 96) = v99;
  v100 = malloc_type_malloc(8 * v60, 0x2C8E6D5CuLL);
  v101 = v100;
  if (v60)
  {
    if (!v100)
      goto LABEL_242;
  }
  v295 = 8 * v60;
  bzero(v100, v295);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 72) = v101;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 80) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 72);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 88) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 72) + 4 * v60;
  v102 = malloc_type_malloc(0x10uLL, 0x2C8E6D5CuLL);
  if (!v102)
    goto LABEL_242;
  v304 = 4 * v60;
  *v102 = 0;
  v102[1] = 0;
  *(_QWORD *)(*a1 + 64) = v102;
  lmsfilt_v3::initLmsFilter(a28, a29, a30, *(_QWORD *)*a1, (float ***)(*a1 + 88));
  *(_QWORD *)(*a1 + 16) = *(_QWORD *)(*a1 + 88);
  *(_QWORD *)(*a1 + 32) = *(_QWORD *)(*a1 + 88);
  lmsfilt_v3::initLmsFilter(a28, a29, a30, *(_QWORD *)*a1, (float ***)(*a1 + 96));
  *(_QWORD *)(*a1 + 24) = *(_QWORD *)(*a1 + 96);
  v103 = (_QWORD *)*a1;
  *(_QWORD *)(*(_QWORD *)(*a1 + 24) + 56) = 0x100000001;
  v105 = *(int *)(*v103 + 40);
  v104 = *(int *)(*v103 + 44);
  v106 = *(_DWORD *)(*v103 + 36);
  v297 = *v103;
  v107 = *(_DWORD *)(*v103 + 16);
  v108 = (char *)malloc_type_malloc(0x260uLL, 0x2C8E6D5CuLL);
  if (!v108)
    goto LABEL_242;
  v109 = v108;
  bzero(v108 + 1, 0x25FuLL);
  v103[6] = v109;
  *v109 = 1;
  *(_OWORD *)(v109 + 4) = xmmword_1B66A2920;
  *(int32x4_t *)(v109 + 20) = vdupq_n_s32(0x30800002u);
  v110 = malloc_type_malloc(4 * v105, 0x2C8E6D5CuLL);
  v111 = v110;
  if ((_DWORD)v105)
  {
    if (!v110)
      goto LABEL_242;
  }
  bzero(v110, 4 * v105);
  *(_QWORD *)(v103[6] + 40) = v111;
  v112 = malloc_type_malloc(4 * v105, 0x2C8E6D5CuLL);
  v113 = v112;
  if ((_DWORD)v105)
  {
    if (!v112)
      goto LABEL_242;
  }
  bzero(v112, 4 * v105);
  *(_QWORD *)(v103[6] + 48) = v113;
  v114 = malloc_type_malloc(4 * v105, 0x2C8E6D5CuLL);
  v115 = v114;
  if ((_DWORD)v105)
  {
    if (!v114)
      goto LABEL_242;
  }
  bzero(v114, 4 * v105);
  *(_QWORD *)(v103[6] + 56) = v115;
  if ((v105 & 0x80000000) != 0)
    goto LABEL_242;
  v116 = malloc_type_malloc(4 * v105, 0x2C8E6D5CuLL);
  v117 = v116;
  if ((_DWORD)v105)
  {
    if (!v116)
      goto LABEL_242;
  }
  bzero(v116, 4 * v105);
  *(_QWORD *)(v103[6] + 64) = v117;
  v118 = malloc_type_malloc(4 * v105, 0x2C8E6D5CuLL);
  v119 = v118;
  if ((_DWORD)v105)
  {
    if (!v118)
      goto LABEL_242;
  }
  v296 = (float)a2;
  v120 = (float)v107 / (float)a2;
  bzero(v118, 4 * v105);
  *(_QWORD *)(v103[6] + 72) = v119;
  v121 = v103[6];
  *(int32x2_t *)(v121 + 80) = vdup_n_s32(0x30800002u);
  v122 = a2 >> 6 >= 0x177 ? 1.0 - expf(v120 / -0.65) : (float)v106 / 8000.0;
  *(float *)(v121 + 120) = v122;
  *(float *)(v121 + 124) = v120 + v120;
  *(float *)(v121 + 128) = v120 * 0.5;
  *(_QWORD *)(v121 + 140) = 0;
  *(_QWORD *)(v121 + 132) = 0;
  v123 = malloc_type_malloc(4 * (int)v105, 0x2C8E6D5CuLL);
  v124 = v123;
  if (v105 << 34)
  {
    if (!v123)
      goto LABEL_242;
  }
  bzero(v123, 4 * (int)v105);
  *(_QWORD *)(v103[6] + 104) = v124;
  v125 = malloc_type_malloc(4 * (int)v105, 0x2C8E6D5CuLL);
  v126 = v125;
  if (v105 << 34)
  {
    if (!v125)
      goto LABEL_242;
  }
  bzero(v125, 4 * (int)v105);
  *(_QWORD *)(v103[6] + 88) = v126;
  if ((_DWORD)v105)
  {
    v127 = v103[6];
    v128 = *(_DWORD **)(v127 + 104);
    v129 = *(_DWORD **)(v127 + 88);
    v130 = v105;
    do
    {
      *v128++ = 813130719;
      *v129++ = 813130719;
      --v130;
    }
    while (v130);
  }
  v131 = malloc_type_malloc(4 * v104, 0x2C8E6D5CuLL);
  v132 = v131;
  if ((_DWORD)v104)
  {
    if (!v131)
      goto LABEL_242;
  }
  bzero(v131, 4 * v104);
  *(_QWORD *)(v103[6] + 112) = v132;
  __A[0] = 0.0;
  vDSP_vfill(__A, *(float **)(v103[6] + 112), 1, v104);
  v133 = malloc_type_malloc(4 * v104, 0x2C8E6D5CuLL);
  v134 = v133;
  if ((_DWORD)v104)
  {
    if (!v133)
      goto LABEL_242;
  }
  bzero(v133, 4 * v104);
  *(_QWORD *)(v103[6] + 96) = v134;
  v135 = expf(-2.4 / (float)*(int *)(v297 + 44));
  v136 = v103[6];
  v137 = *(_DWORD **)(v136 + 96);
  *v137 = 1060320051;
  __A[0] = 0.7;
  if ((int)v104 > 1)
  {
    v138 = v104 - 1;
    v139 = (float *)(v137 + 1);
    do
    {
      v140 = v135 * *(v139 - 1);
      *v139++ = v140;
      __A[0] = v140 + __A[0];
      --v138;
    }
    while (v138);
  }
  v141 = v304;
  if ((int)v104 >= 1)
  {
    v142 = v104 + 1;
    do
    {
      *(float *)&v137[(v142 - 2)] = *(float *)&v137[(v142 - 2)] / __A[0];
      --v142;
    }
    while (v142 > 1);
  }
  *(_QWORD *)(v136 + 152) = 0;
  *(_QWORD *)(v103[6] + 160) = 0;
  *(_QWORD *)(v103[6] + 168) = 0;
  *(_QWORD *)(v103[6] + 176) = 0;
  *(_QWORD *)(v103[6] + 184) = 0;
  *(_QWORD *)(v103[6] + 192) = 0;
  *(_QWORD *)(v103[6] + 200) = 0;
  v143 = (_QWORD *)v103[6];
  *(_QWORD *)((char *)v143 + 252) = 0;
  v143 = (_QWORD *)((char *)v143 + 252);
  *(int32x2_t *)((char *)v143 - 44) = vdup_n_s32(0x30800002u);
  *((_DWORD *)v143 - 9) = 0;
  *(_QWORD *)&v144 = 0x100000001;
  *((_QWORD *)&v144 + 1) = 0x100000001;
  *((_OWORD *)v143 - 2) = xmmword_1B66A1290;
  *((_OWORD *)v143 - 1) = v144;
  *(_QWORD *)((char *)v143 + 36) = 0;
  v143[1] = 0;
  v143[2] = 0;
  *(_QWORD *)(v103[6] + 296) = 0;
  *(_QWORD *)(v103[6] + 276) = 0x3080000230800002;
  v145 = malloc_type_malloc(4 * v105, 0x2C8E6D5CuLL);
  v146 = v145;
  if ((_DWORD)v105)
  {
    if (!v145)
      goto LABEL_242;
  }
  bzero(v145, 4 * v105);
  *(_QWORD *)(v103[6] + 288) = v146;
  v147 = malloc_type_malloc(4 * v105, 0x2C8E6D5CuLL);
  v148 = v147;
  if ((_DWORD)v105)
  {
    if (!v147)
    {
LABEL_242:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v293 = std::bad_alloc::bad_alloc(exception);
    }
  }
  bzero(v147, 4 * v105);
  *(_QWORD *)(v103[6] + 296) = v148;
  v149 = v103[6];
  if ((_DWORD)v105)
  {
    v150 = *(_DWORD **)(v149 + 288);
    v151 = *(_DWORD **)(v149 + 296);
    v152 = v105;
    do
    {
      *v150++ = 0;
      *v151++ = 0;
      --v152;
    }
    while (v152);
  }
  v153 = floorf(a9 / *(float *)(v297 + 24));
  if (v153 <= 1.0)
    v153 = 1.0;
  v154 = v153;
  *(_DWORD *)(v149 + 228) = v153;
  v155 = 2 * *(_DWORD *)(v297 + 44);
  if (v155 > v153)
  {
    v154 = v155 | 1;
    *(_DWORD *)(v149 + 228) = v155 | 1;
  }
  if (v154 >= 5)
  {
    if (v154 < 0x51)
      goto LABEL_110;
    v154 = 80;
  }
  else
  {
    v154 = 5;
  }
  *(_DWORD *)(v149 + 228) = v154;
LABEL_110:
  v156 = 4 * v154;
  v157 = malloc_type_malloc(v156, 0x2C8E6D5CuLL);
  if (!v157)
    goto LABEL_242;
  v158 = v157;
  bzero(v157, v156);
  *(_QWORD *)(v103[6] + 184) = v158;
  v159 = malloc_type_malloc(v156, 0x2C8E6D5CuLL);
  if (!v159)
    goto LABEL_242;
  v160 = v159;
  bzero(v159, v156);
  *(_QWORD *)(v103[6] + 192) = v160;
  v161 = malloc_type_malloc(v156, 0x2C8E6D5CuLL);
  if (!v161)
    goto LABEL_242;
  v162 = v161;
  bzero(v161, v156);
  *(_QWORD *)(v103[6] + 200) = v162;
  v163 = (4 * *(_DWORD *)(v103[6] + 228));
  v164 = malloc_type_malloc(v163, 0x2C8E6D5CuLL);
  v165 = v164;
  if ((_DWORD)v163)
  {
    if (!v164)
      goto LABEL_242;
  }
  bzero(v164, v163);
  *(_QWORD *)(v103[6] + 152) = v165;
  v166 = malloc_type_malloc(v163, 0x2C8E6D5CuLL);
  v167 = v166;
  if ((_DWORD)v163)
  {
    if (!v166)
      goto LABEL_242;
  }
  v301 = v120;
  bzero(v166, v163);
  *(_QWORD *)(v103[6] + 160) = v167;
  v168 = malloc_type_malloc(v163, 0x2C8E6D5CuLL);
  v169 = v168;
  if ((_DWORD)v163)
  {
    if (!v168)
      goto LABEL_242;
  }
  bzero(v168, v163);
  *(_QWORD *)(v103[6] + 168) = v169;
  v170.i32[0] = *(_DWORD *)(v297 + 24);
  v171 = (uint32x2_t *)v103[6];
  v172 = vrndm_f32(vdiv_f32((float32x2_t)__PAIR64__(LODWORD(a11), LODWORD(a10)), (float32x2_t)vdup_lane_s32(v170, 0)));
  __asm { FMOV            V8.2S, #1.0 }
  v177 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcge_f32(_D8, v172), (int8x8_t)_D8, (int8x8_t)v172));
  v178 = floorf(a12 / *(float *)v170.i32);
  if (v178 <= 1.0)
    v178 = 1.0;
  v179 = v178;
  v180 = floorf(a19 / *(float *)v170.i32);
  if (v180 <= 1.0)
    v180 = 1.0;
  v181 = v180;
  v182 = floorf(a13 / *(float *)v170.i32);
  if (v182 <= 1.0)
    v182 = 1.0;
  v183 = v182;
  if (v155 > v182)
  {
    v183 = v155;
    if (a13 > a9)
      v183 = v155 + 2;
  }
  v184 = v171[28].u32[1];
  v171[29] = vmin_u32((uint32x2_t)vdup_n_s32(v184), v177);
  if (v184 < v179)
    v179 = v184;
  if (v184 < v181)
    v181 = v184;
  v171[31].i32[0] = v181;
  v185 = v183 >= v184 + 1 ? v184 + 1 : v183;
  v171[30].i32[0] = v179;
  v171[30].i32[1] = v185;
  v186 = v185 <= v184 ? v184 : v185;
  v187 = 4 * v186;
  v188 = malloc_type_malloc(v187, 0x2C8E6D5CuLL);
  if (!v188 && (_DWORD)v187 != 0)
    goto LABEL_242;
  v190 = v188;
  bzero(v188, v187);
  *(_QWORD *)(v103[6] + 176) = v190;
  v191 = v103[6];
  v192 = *(unsigned int *)(v191 + 228);
  if ((_DWORD)v192)
  {
    v193 = *(_DWORD **)(v191 + 176);
    v194 = *(_DWORD **)(v191 + 184);
    v195 = *(unsigned int *)(v191 + 228);
    v196 = *(_DWORD **)(v191 + 192);
    v197 = *(_DWORD **)(v191 + 200);
    do
    {
      *v193++ = 1;
      *v194++ = 1;
      *v196++ = 1;
      *v197++ = 1;
      --v195;
    }
    while (v195);
  }
  v198 = *(_DWORD *)(v191 + 244);
  if (v192 < v198)
    memset_pattern16((void *)(*(_QWORD *)(v191 + 176) + 4 * v192), &unk_1B66A2BB0, 4 * (v198 + ~(_DWORD)v192) + 4);
  v199 = __exp10f(a14 / 10.0);
  v200 = v103[6];
  *(float *)(v200 + 252) = v199;
  *(float *)(v200 + 256) = a15;
  *(float *)(v200 + 260) = a16;
  *(_DWORD *)(v200 + 264) = a17;
  v201 = __exp10f(a18 / 10.0);
  v203 = v103[6];
  *(float *)(v203 + 268) = v201;
  *(_OWORD *)(v203 + 304) = 0u;
  *(_OWORD *)(v203 + 320) = 0u;
  *(_DWORD *)(v203 + 336) = 0;
  *(_QWORD *)(v203 + 344) = 0;
  *(_QWORD *)(v203 + 352) = 0;
  *(_QWORD *)(v203 + 360) = 0x3CF5C28F00000000;
  if (!*(_DWORD *)(v297 + 96))
  {
    *(_DWORD *)(v203 + 308) = a22;
    *(_DWORD *)(v203 + 312) = a23;
    *(_DWORD *)(v203 + 316) = a20;
    v204 = *(_DWORD *)(v297 + 44);
    *(_DWORD *)(v203 + 320) = a21;
    if ((float)(*(float *)(v297 + 24) * (float)v204) >= 0xC9)
    {
      v202.i32[1] = 1045891645;
      *(_QWORD *)(v203 + 308) = 0x3E570A3D3F0CCCCDLL;
      *(_DWORD *)(v203 + 320) = 1048576000;
    }
    *(_QWORD *)(v203 + 332) = 0x7080000012CLL;
    *(float *)v202.i32 = v296 / (float)(2 * *(_DWORD *)v297);
    *(int32x2_t *)(v203 + 324) = vcvt_s32_f32(vrndm_f32(vdiv_f32((float32x2_t)0x44E1000043960000, (float32x2_t)vdup_lane_s32(v202, 0))));
    *(float *)(v203 + 340) = a24 / 1000.0;
    *(float *)(v203 + 344) = expf((float)-v301 / (float)(a24 / 1000.0));
    *(_DWORD *)(v203 + 356) = 0;
    *(_DWORD *)(v203 + 360) = v204;
    *(_DWORD *)(v203 + 364) = a25;
  }
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v203 + 368) = _Q0;
  *(float32x2_t *)(v203 + 384) = _D8;
  *(_DWORD *)(v203 + 392) = 1065353216;
  *(_QWORD *)(v203 + 424) = 0;
  *(_QWORD *)(v103[6] + 432) = 0;
  *(_QWORD *)(v103[6] + 440) = 0;
  *(_QWORD *)(v103[6] + 448) = 0;
  *(_QWORD *)(v103[6] + 472) = 0;
  *(_QWORD *)(v103[6] + 480) = 0;
  *(_QWORD *)(v103[6] + 456) = 0;
  *(_QWORD *)(v103[6] + 464) = 0;
  v206 = v103[6];
  *(_QWORD *)(v206 + 400) = 0;
  *(_QWORD *)(v206 + 408) = 0;
  *(_QWORD *)(v206 + 416) = 0;
  *(_DWORD *)(v206 + 368) = a26;
  *(_DWORD *)(v206 + 372) = a27;
  if (a2 >> 3 >= 0x55F)
    v207 = 256;
  else
    v207 = 160;
  if (a2 >> 7 <= 0x7C)
    v208 = v207;
  else
    v208 = 320;
  if (a2 >> 4 <= 0x55E)
    v209 = v208;
  else
    v209 = 512;
  if (v209 <= *(_DWORD *)(v297 + 16))
    v209 = *(_DWORD *)(v297 + 16);
  *(_DWORD *)(v206 + 400) = v209;
  *(_DWORD *)(v206 + 404) = 2 * v209;
  *(_DWORD *)(v206 + 416) = v209 + 1;
  *(float *)&_Q0 = v296 / (float)(2 * v209);
  v210 = vcvt_s32_f32(vrndm_f32(vdiv_f32((float32x2_t)0x44E1000043960000, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&_Q0, 0))));
  v211 = vand_s8((int8x8_t)vadd_s32(v210, (int32x2_t)-1), (int8x8_t)vcgt_s32(v210, (int32x2_t)0x100000001));
  *(int8x8_t *)(v206 + 408) = v211;
  *(_DWORD *)(v206 + 420) = v211.i32[1] + 1;
  v212 = 4 * (v211.i32[1] + 1);
  v213 = malloc_type_malloc(v212, 0x2C8E6D5CuLL);
  if (!v213 && v212 != 0)
    goto LABEL_242;
  v215 = v213;
  bzero(v213, v212);
  *(_QWORD *)(v103[6] + 472) = v215;
  v216 = malloc_type_malloc(v212, 0x2C8E6D5CuLL);
  if (v212 && v216 == 0)
    goto LABEL_242;
  v218 = v216;
  bzero(v216, v212);
  *(_QWORD *)(v103[6] + 480) = v218;
  v219 = malloc_type_malloc(v212, 0x2C8E6D5CuLL);
  if (v212 && v219 == 0)
    goto LABEL_242;
  v221 = v219;
  bzero(v219, v212);
  *(_QWORD *)(v103[6] + 456) = v221;
  v222 = malloc_type_malloc(v212, 0x2C8E6D5CuLL);
  if (v212 && v222 == 0)
    goto LABEL_242;
  v224 = v222;
  bzero(v222, v212);
  *(_QWORD *)(v103[6] + 464) = v224;
  v225 = 4 * *(_DWORD *)(v103[6] + 416);
  v226 = malloc_type_malloc(v225, 0x2C8E6D5CuLL);
  v227 = v226;
  if (v225)
  {
    if (!v226)
      goto LABEL_242;
  }
  bzero(v226, v225);
  *(_QWORD *)(v103[6] + 424) = v227;
  v228 = malloc_type_malloc(v225, 0x2C8E6D5CuLL);
  v229 = v228;
  if (v225)
  {
    if (!v228)
      goto LABEL_242;
  }
  bzero(v228, v225);
  *(_QWORD *)(v103[6] + 432) = v229;
  v230 = malloc_type_malloc(v225, 0x2C8E6D5CuLL);
  v231 = v230;
  if (v225)
  {
    if (!v230)
      goto LABEL_242;
  }
  bzero(v230, v225);
  *(_QWORD *)(v103[6] + 440) = v231;
  v232 = malloc_type_malloc(v225, 0x2C8E6D5CuLL);
  v233 = v232;
  if (v225)
  {
    if (!v232)
      goto LABEL_242;
  }
  bzero(v232, v225);
  *(_QWORD *)(v103[6] + 448) = v233;
  v234 = expf(v301 / -0.03);
  v235 = v103[6];
  *(float *)(v235 + 388) = v234;
  *(float *)(v235 + 392) = v234;
  *(float *)(v235 + 396) = 1.0 - expf(v301 * -2.0);
  *(_DWORD *)(v235 + 488) = 813694978;
  *(_DWORD *)(v235 + 524) = 0;
  *(_OWORD *)(v235 + 492) = 0u;
  *(_OWORD *)(v235 + 508) = 0u;
  *(_OWORD *)(v235 + 528) = xmmword_1B66A12A0;
  *(_QWORD *)(v235 + 544) = 0x3CCCCCCD00000000;
  *(_OWORD *)(v235 + 552) = xmmword_1B66A1290;
  *(_QWORD *)(v235 + 568) = 0;
  *(_QWORD *)(v235 + 576) = 0xC1A0000000000000;
  *(_DWORD *)(v235 + 600) = 0;
  *(_OWORD *)(v235 + 584) = 0u;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 104) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 112) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 120) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 128) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 136) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 144) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 152) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 160) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 168) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 176) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 184) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 192) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 200) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 208) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 216) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 224) = 0;
  *(_QWORD *)(*a1 + 72) = 0;
  v236 = malloc_type_malloc(v304, 0x2C8E6D5CuLL);
  v237 = v236;
  if (v305)
  {
    if (!v236)
      goto LABEL_242;
  }
  bzero(v236, v304);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 232) = v237;
  v238 = malloc_type_malloc(v304, 0x2C8E6D5CuLL);
  v239 = v238;
  if (v305)
  {
    if (!v238)
      goto LABEL_242;
  }
  bzero(v238, v304);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 240) = v239;
  v240 = malloc_type_malloc(v295, 0x2C8E6D5CuLL);
  v241 = v240;
  if (v305)
  {
    if (!v240)
      goto LABEL_242;
  }
  bzero(v240, v295);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 248) = v241;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 256) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 248) + 4 * v81;
  v242 = *a1;
  v243 = *(_QWORD *)*a1;
  if (!*(_DWORD *)(v243 + 96))
  {
    v244 = *(int *)(v243 + 76);
    v245 = malloc_type_malloc(4 * v244, 0x2C8E6D5CuLL);
    v246 = v245;
    if ((_DWORD)v244 && !v245)
      goto LABEL_242;
    bzero(v245, 4 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 104) = v246;
    v247 = malloc_type_malloc(4 * v244, 0x2C8E6D5CuLL);
    v248 = v247;
    if ((_DWORD)v244)
    {
      if (!v247)
        goto LABEL_242;
    }
    bzero(v247, 4 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 112) = v248;
    v249 = malloc_type_malloc(4 * v244, 0x2C8E6D5CuLL);
    v250 = v249;
    if ((_DWORD)v244)
    {
      if (!v249)
        goto LABEL_242;
    }
    bzero(v249, 4 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 120) = v250;
    v251 = malloc_type_malloc(4 * v244, 0x2C8E6D5CuLL);
    v252 = v251;
    if ((_DWORD)v244)
    {
      if (!v251)
        goto LABEL_242;
    }
    bzero(v251, 4 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 160) = v252;
    v253 = malloc_type_malloc(4 * v244, 0x2C8E6D5CuLL);
    v254 = v253;
    if ((_DWORD)v244)
    {
      if (!v253)
        goto LABEL_242;
    }
    bzero(v253, 4 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 168) = v254;
    v255 = malloc_type_malloc(8 * v244, 0x2C8E6D5CuLL);
    v256 = v255;
    if ((_DWORD)v244)
    {
      if (!v255)
        goto LABEL_242;
    }
    v257 = 2 * v81;
    bzero(v255, 8 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 176) = v256;
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 184) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 176) + 8 * v81;
    v258 = malloc_type_malloc(4 * v244, 0x2C8E6D5CuLL);
    v259 = v258;
    if ((_DWORD)v244)
    {
      if (!v258)
        goto LABEL_242;
    }
    bzero(v258, 4 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 192) = v259;
    v260 = malloc_type_malloc(4 * v244, 0x2C8E6D5CuLL);
    v261 = v260;
    if ((_DWORD)v244)
    {
      if (!v260)
        goto LABEL_242;
    }
    bzero(v260, 4 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 200) = v261;
    v262 = malloc_type_malloc(8 * v244, 0x2C8E6D5CuLL);
    v263 = v262;
    if ((_DWORD)v244)
    {
      if (!v262)
        goto LABEL_242;
    }
    bzero(v262, 8 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 208) = v263;
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 216) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 208) + 8 * v81;
    v264 = malloc_type_malloc(8 * v244, 0x2C8E6D5CuLL);
    v265 = v264;
    if ((_DWORD)v244)
    {
      if (!v264)
        goto LABEL_242;
    }
    bzero(v264, 8 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 128) = v265;
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 136) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 128) + 8 * v81;
    v266 = malloc_type_malloc(8 * v244, 0x2C8E6D5CuLL);
    v267 = v266;
    if ((_DWORD)v244)
    {
      if (!v266)
        goto LABEL_242;
    }
    bzero(v266, 8 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 144) = v267;
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 152) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 144) + 8 * v81;
    v268 = malloc_type_malloc(4 * v244, 0x2C8E6D5CuLL);
    v269 = v268;
    if ((_DWORD)v244)
    {
      if (!v268)
        goto LABEL_242;
    }
    bzero(v268, 4 * v244);
    *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 224) = v269;
    vDSP_hann_window(*(float **)(*(_QWORD *)(*a1 + 56) + 224), v257, 0);
    dft_v3::dftInit2(*a1 + 72, v257, v257, 2, a2, v294, v302, v298, 0);
    v242 = *a1;
    v141 = v304;
  }
  *(_QWORD *)(*(_QWORD *)(v242 + 56) + 280) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 288) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 296) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 304) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 312) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 320) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 328) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 336) = 0;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 344) = 0;
  v270 = *(_QWORD *)(*a1 + 48);
  v271 = *(int *)(v270 + 404);
  v272 = (int)v271 >= 0 ? *(_DWORD *)(v270 + 404) : v271 + 1;
  v273 = *(int *)(v270 + 400);
  v274 = malloc_type_malloc(4 * v271, 0x2C8E6D5CuLL);
  v275 = v274;
  if ((_DWORD)v271)
  {
    if (!v274)
      goto LABEL_242;
  }
  v276 = v272 >> 1;
  bzero(v274, 4 * v271);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 280) = v275;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 288) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 280) + 4 * v276;
  v277 = malloc_type_malloc(4 * v271, 0x2C8E6D5CuLL);
  v278 = v277;
  if ((_DWORD)v271)
  {
    if (!v277)
      goto LABEL_242;
  }
  bzero(v277, 4 * v271);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 296) = v278;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 304) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 296) + 4 * v276;
  v279 = malloc_type_malloc(4 * v271, 0x2C8E6D5CuLL);
  v280 = v279;
  if ((_DWORD)v271)
  {
    if (!v279)
      goto LABEL_242;
  }
  bzero(v279, 4 * v271);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 312) = v280;
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 320) = *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 312) + 4 * v276;
  v281 = malloc_type_malloc(4 * v273, 0x2C8E6D5CuLL);
  v282 = v281;
  if ((_DWORD)v273)
  {
    if (!v281)
      goto LABEL_242;
  }
  bzero(v281, 4 * v273);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 328) = v282;
  v283 = malloc_type_malloc(4 * v273, 0x2C8E6D5CuLL);
  v284 = v283;
  if ((_DWORD)v273)
  {
    if (!v283)
      goto LABEL_242;
  }
  bzero(v283, 4 * v273);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 336) = v284;
  v285 = malloc_type_malloc(4 * v273, 0x2C8E6D5CuLL);
  v286 = v285;
  if ((_DWORD)v273)
  {
    if (!v285)
      goto LABEL_242;
  }
  bzero(v285, 4 * v273);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 344) = v286;
  dft_v3::dftInit2(*a1 + 80, v276, v276, 2, a2, 0, v302, v298, 0);
  *(_QWORD *)(*a1 + 104) = 0;
  *(_QWORD *)(*a1 + 112) = 0;
  v287 = *(_QWORD *)*a1;
  if (*(int *)(v287 + 100) < 1)
    return;
  lmsfilt_v3::initLmsFilter(a28, a29, a30, v287, (float ***)(*a1 + 104));
  *(_QWORD *)(*a1 + 32) = *(_QWORD *)(*a1 + 104);
  lmsfilt_v3::initLmsFilter(a28, a29, a30, *(_QWORD *)*a1, (float ***)(*a1 + 112));
  *(_QWORD *)(*a1 + 40) = *(_QWORD *)(*a1 + 112);
  v288 = malloc_type_malloc(v141, 0x2C8E6D5CuLL);
  v289 = v288;
  if (v305)
  {
    if (!v288)
      goto LABEL_242;
  }
  bzero(v288, v141);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 264) = v289;
  v290 = malloc_type_malloc(v141, 0x2C8E6D5CuLL);
  v291 = v290;
  if (v305)
  {
    if (!v290)
      goto LABEL_242;
  }
  bzero(v290, v141);
  *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 272) = v291;
}

void aec_v3::aec_remove(void ***a1)
{
  void **v2;
  void *v3;
  void **v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  _QWORD *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  _QWORD *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void **v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  _QWORD *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  void **v68;
  void **v69;
  _DWORD *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void **v80;
  void *v81;

  v2 = *a1;
  v3 = (*a1)[8];
  if (v3)
  {
    free(v3);
    v2[8] = 0;
    v2 = *a1;
  }
  v4 = (void **)v2[7];
  if (v4 && *v4)
  {
    free(*v4);
    *v4 = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v5 = v4[1];
  if (v5)
  {
    free(v5);
    v4[1] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v6 = v4[2];
  if (v6)
  {
    free(v6);
    v4[2] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v7 = v4[4];
  if (v7)
  {
    free(v7);
    v4[4] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v8 = v4[5];
  if (v8)
  {
    free(v8);
    v4[5] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v9 = v4[6];
  if (v9)
  {
    free(v9);
    v4[6] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v10 = v4[7];
  if (v10)
  {
    free(v10);
    v4[7] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v11 = v4[8];
  if (v11)
  {
    free(v11);
    v4[8] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v12 = v4[12];
  if (v12)
  {
    free(v12);
    v4[12] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v13 = v4[9];
  if (v13)
  {
    free(v13);
    v4[9] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v14 = v4[29];
  if (v14)
  {
    free(v14);
    v4[29] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v15 = v4[30];
  if (v15)
  {
    free(v15);
    v4[30] = 0;
    v2 = *a1;
    v4 = (void **)(*a1)[7];
  }
  v16 = v4[31];
  if (v16)
  {
    free(v16);
    v4[31] = 0;
    v2 = *a1;
  }
  if (!*((_DWORD *)*v2 + 24))
  {
    v17 = v2[7];
    v18 = (void *)v17[13];
    if (v18)
    {
      free(v18);
      v17[13] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v19 = (void *)v17[14];
    if (v19)
    {
      free(v19);
      v17[14] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v20 = (void *)v17[15];
    if (v20)
    {
      free(v20);
      v17[15] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v21 = (void *)v17[16];
    if (v21)
    {
      free(v21);
      v17[16] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v22 = (void *)v17[18];
    if (v22)
    {
      free(v22);
      v17[18] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v23 = (void *)v17[20];
    if (v23)
    {
      free(v23);
      v17[20] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v24 = (void *)v17[21];
    if (v24)
    {
      free(v24);
      v17[21] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v25 = (void *)v17[22];
    if (v25)
    {
      free(v25);
      v17[22] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v26 = (void *)v17[24];
    if (v26)
    {
      free(v26);
      v17[24] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v27 = (void *)v17[25];
    if (v27)
    {
      free(v27);
      v17[25] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v28 = (void *)v17[26];
    if (v28)
    {
      free(v28);
      v17[26] = 0;
      v2 = *a1;
      v17 = (*a1)[7];
    }
    v29 = (void *)v17[28];
    if (v29)
    {
      free(v29);
      v17[28] = 0;
      v2 = *a1;
    }
    dft_v3::dftRemove(v2 + 9);
    v2 = *a1;
  }
  v30 = v2[7];
  v31 = (void *)v30[35];
  if (v31)
  {
    free(v31);
    v30[35] = 0;
    v2 = *a1;
    v30 = (*a1)[7];
  }
  v32 = (void *)v30[37];
  if (v32)
  {
    free(v32);
    v30[37] = 0;
    v2 = *a1;
    v30 = (*a1)[7];
  }
  v33 = (void *)v30[39];
  if (v33)
  {
    free(v33);
    v30[39] = 0;
    v2 = *a1;
    v30 = (*a1)[7];
  }
  v34 = (void *)v30[41];
  if (v34)
  {
    free(v34);
    v30[41] = 0;
    v2 = *a1;
    v30 = (*a1)[7];
  }
  v35 = (void *)v30[42];
  if (v35)
  {
    free(v35);
    v30[42] = 0;
    v2 = *a1;
    v30 = (*a1)[7];
  }
  v36 = (void *)v30[43];
  if (v36)
  {
    free(v36);
    v30[43] = 0;
    v2 = *a1;
  }
  dft_v3::dftRemove(v2 + 10);
  lmsfilt_v3::removeLmsFilter((uint64_t *)*a1 + 11);
  lmsfilt_v3::removeLmsFilter((uint64_t *)*a1 + 12);
  v37 = *a1;
  if (*((int *)**a1 + 25) >= 1)
  {
    lmsfilt_v3::removeLmsFilter((uint64_t *)v37 + 13);
    lmsfilt_v3::removeLmsFilter((uint64_t *)*a1 + 14);
    v37 = *a1;
    v38 = (*a1)[7];
    v39 = (void *)v38[33];
    if (v39)
    {
      free(v39);
      v38[33] = 0;
      v37 = *a1;
      v38 = (*a1)[7];
    }
    v40 = (void *)v38[34];
    if (v40)
    {
      free(v40);
      v38[34] = 0;
      v37 = *a1;
    }
  }
  v41 = v37[6];
  if (v41)
  {
    v42 = (void *)v41[5];
    if (v42)
    {
      free(v42);
      v41[5] = 0;
      v41 = v37[6];
    }
    v43 = (void *)v41[6];
    if (v43)
    {
      free(v43);
      v41[6] = 0;
      v41 = v37[6];
    }
    v44 = (void *)v41[7];
    if (v44)
    {
      free(v44);
      v41[7] = 0;
      v41 = v37[6];
    }
    v45 = (void *)v41[8];
    if (v45)
    {
      free(v45);
      v41[8] = 0;
      v41 = v37[6];
    }
    v46 = (void *)v41[9];
    if (v46)
    {
      free(v46);
      v41[9] = 0;
      v41 = v37[6];
    }
    v47 = (void *)v41[14];
    if (v47)
    {
      free(v47);
      v41[14] = 0;
      v41 = v37[6];
    }
    v48 = (void *)v41[12];
    if (v48)
    {
      free(v48);
      v41[12] = 0;
      v41 = v37[6];
    }
    v49 = (void *)v41[13];
    if (v49)
    {
      free(v49);
      v41[13] = 0;
      v41 = v37[6];
    }
    v50 = (void *)v41[11];
    if (v50)
    {
      free(v50);
      v41[11] = 0;
      v41 = v37[6];
    }
    v51 = (void *)v41[19];
    if (v51)
    {
      free(v51);
      v41[19] = 0;
      v41 = v37[6];
    }
    v52 = (void *)v41[20];
    if (v52)
    {
      free(v52);
      v41[20] = 0;
      v41 = v37[6];
    }
    v53 = (void *)v41[21];
    if (v53)
    {
      free(v53);
      v41[21] = 0;
      v41 = v37[6];
    }
    v54 = (void *)v41[22];
    if (v54)
    {
      free(v54);
      v41[22] = 0;
      v41 = v37[6];
    }
    v55 = (void *)v41[23];
    if (v55)
    {
      free(v55);
      v41[23] = 0;
      v41 = v37[6];
    }
    v56 = (void *)v41[24];
    if (v56)
    {
      free(v56);
      v41[24] = 0;
      v41 = v37[6];
    }
    v57 = (void *)v41[25];
    if (v57)
    {
      free(v57);
      v41[25] = 0;
      v41 = v37[6];
    }
    v58 = (void *)v41[36];
    if (v58)
    {
      free(v58);
      v41[36] = 0;
      v41 = v37[6];
    }
    v59 = (void *)v41[37];
    if (v59)
    {
      free(v59);
      v41[37] = 0;
      v41 = v37[6];
    }
    v60 = (void *)v41[53];
    if (v60)
    {
      free(v60);
      v41[53] = 0;
      v41 = v37[6];
    }
    v61 = (void *)v41[54];
    if (v61)
    {
      free(v61);
      v41[54] = 0;
      v41 = v37[6];
    }
    v62 = (void *)v41[55];
    if (v62)
    {
      free(v62);
      v41[55] = 0;
      v41 = v37[6];
    }
    v63 = (void *)v41[56];
    if (v63)
    {
      free(v63);
      v41[56] = 0;
      v41 = v37[6];
    }
    v64 = (void *)v41[59];
    if (v64)
    {
      free(v64);
      v41[59] = 0;
      v41 = v37[6];
    }
    v65 = (void *)v41[60];
    if (v65)
    {
      free(v65);
      v41[60] = 0;
      v41 = v37[6];
    }
    v66 = (void *)v41[57];
    if (v66)
    {
      free(v66);
      v41[57] = 0;
      v41 = v37[6];
    }
    v67 = (void *)v41[58];
    if (!v67 || (free(v67), v41[58] = 0, (v41 = v37[6]) != 0))
    {
      free(v41);
      v37[6] = 0;
    }
  }
  v68 = *a1;
  v69 = (void **)(*a1)[1];
  if (v69)
  {
    v70 = *v68;
    if (*v69)
    {
      free(*v69);
      *v69 = 0;
      v69 = (void **)v68[1];
    }
    v71 = v69[1];
    if (v71)
    {
      free(v71);
      v69[1] = 0;
      v69 = (void **)v68[1];
    }
    v72 = v69[4];
    if (v72)
    {
      free(v72);
      v69[4] = 0;
      v69 = (void **)v68[1];
    }
    if (!v70[24])
    {
      v73 = v69[7];
      if (v73)
      {
        free(v73);
        v69[7] = 0;
        v69 = (void **)v68[1];
      }
      v74 = v69[8];
      if (v74)
      {
        free(v74);
        v69[8] = 0;
        v69 = (void **)v68[1];
      }
    }
    v75 = v69[11];
    if (v75)
    {
      free(v75);
      v69[11] = 0;
      v69 = (void **)v68[1];
    }
    v76 = v69[2];
    if (v76)
    {
      free(v76);
      v69[2] = 0;
      v69 = (void **)v68[1];
    }
    v77 = v69[3];
    if (v77)
    {
      free(v77);
      v69[3] = 0;
      v69 = (void **)v68[1];
    }
    v78 = v69[12];
    if (v78)
    {
      free(v78);
      v69[12] = 0;
      v69 = (void **)v68[1];
    }
    v79 = v69[13];
    if (!v79 || (free(v79), v69[13] = 0, (v69 = (void **)v68[1]) != 0))
    {
      free(v69);
      v68[1] = 0;
    }
  }
  dft_v3::dftRemove(*a1);
  v80 = *a1;
  v81 = (*a1)[7];
  if (!v81 || (free(v81), v80[7] = 0, (v80 = *a1) != 0))
  {
    free(v80);
    *a1 = 0;
  }
}

void AUDynamicDucker::~AUDynamicDucker(AUDynamicDucker *this)
{
  AUDynamicDucker::~AUDynamicDucker(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_1E69EAB38;
  v2 = *((_QWORD *)this + 94);
  if (v2)
  {
    MEMORY[0x1BCC95CC8](v2, 0x1000C8052888210);
    *((_QWORD *)this + 94) = 0;
  }
  CDSPSplitComplex::~CDSPSplitComplex((AUDynamicDucker *)((char *)this + 656));
  CDSPSplitComplex::~CDSPSplitComplex((AUDynamicDucker *)((char *)this + 624));
  CDSPSplitComplex::~CDSPSplitComplex((AUDynamicDucker *)((char *)this + 592));
  CDSPSplitComplex::~CDSPSplitComplex((AUDynamicDucker *)((char *)this + 560));
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUDynamicDucker::Initialize(AUDynamicDucker *this)
{
  uint64_t Element;
  uint64_t result;
  NSObject *v4;
  double v5;
  double v6;
  int v7;
  double v8;
  __int16 v9;
  double v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  Element = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 0);
  if (*(double *)(Element + 80) != *(double *)(ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 128), 0)+ 80))return 4294956428;
  *((_QWORD *)this + 94) = operator new[]();
  AUDynamicDucker::ResetHistoryWindows(this);
  *((_DWORD *)this + 133) = *((_DWORD *)this + 132);
  AUDynamicDucker::UpdateDuckerState(this);
  if (AUDynamicDuckerLog(void)::onceToken != -1)
    dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
  v4 = AUDynamicDuckerLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *((float *)this + 177);
    v6 = *((float *)this + 176);
    v7 = 134218240;
    v8 = v5;
    v9 = 2048;
    v10 = v6;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "media chat other audio ducking level %.2f, db: %.2f", (uint8_t *)&v7, 0x16u);
  }
  result = 0;
  *((_DWORD *)this + 199) = 0;
  return result;
}

uint64_t AUDynamicDucker::Cleanup(AUDynamicDucker *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 94);
  if (result)
  {
    result = MEMORY[0x1BCC95CC8](result, 0x1000C8052888210);
    *((_QWORD *)this + 94) = 0;
  }
  return result;
}

uint64_t AUDynamicDucker::Reset(AUDynamicDucker *this)
{
  AUDynamicDucker::ResetHistoryWindows(this);
  return 0;
}

uint64_t AUDynamicDucker::GetPropertyInfo(AUDynamicDucker *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  int v7;

  result = 4294956417;
  if (!a3)
  {
    if (a2 > 1852141668)
    {
      if (a2 == 1852141676)
        goto LABEL_9;
      v7 = 1852141669;
    }
    else
    {
      if (a2 == 21)
        goto LABEL_9;
      v7 = 1633973611;
    }
    if (a2 != v7)
      return result;
LABEL_9:
    result = 0;
    *a6 = 1;
    *a5 = 4;
  }
  return result;
}

uint64_t AUDynamicDucker::GetProperty(AUDynamicDucker *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  int v7;

  result = 4294956417;
  if (a2 > 1852141668)
  {
    if (a2 == 1852141669)
    {
      if (!a3)
      {
        v7 = *((unsigned __int8 *)this + 762);
        goto LABEL_15;
      }
    }
    else
    {
      if (a2 != 1852141676)
        return result;
      if (!a3)
      {
        v7 = *((_DWORD *)this + 191);
        goto LABEL_15;
      }
    }
    return 4294956430;
  }
  if (a2 == 21)
  {
    if (!a3)
    {
      v7 = *((_DWORD *)this + 134);
      goto LABEL_15;
    }
    return 4294956430;
  }
  if (a2 != 1633973611)
    return result;
  if (a3)
    return 4294956430;
  v7 = *((unsigned __int8 *)this + 760);
LABEL_15:
  result = 0;
  *a5 = v7;
  return result;
}

uint64_t AUDynamicDucker::SetProperty(AUDynamicDucker *this, int a2, int a3, unsigned int a4, _DWORD *a5, unsigned int a6)
{
  uint64_t result;
  NSObject *v8;
  const char *v9;
  int v10;
  int v11;
  uint64_t v12;
  _BOOL4 v13;
  int v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  uint64_t v18;
  _BOOL4 v19;
  const char *v20;
  int v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 1852141668)
  {
    if (a2 == 1852141669)
    {
      if (a6 <= 3)
      {
        if (AUDynamicDuckerLog(void)::onceToken != -1)
          dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
        v8 = AUDynamicDuckerLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_ERROR))
          return 4294956445;
        LOWORD(v21) = 0;
        v9 = "NonMediaChatDynamicDuckingEnabled: invalid propery size";
LABEL_38:
        _os_log_error_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v21, 2u);
        return 4294956445;
      }
      *((_BYTE *)this + 762) = *a5 != 0;
      if (AUDynamicDuckerLog(void)::onceToken != -1)
        dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
      v18 = AUDynamicDuckerLog(void)::gLog;
      v19 = os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v19)
        return result;
      if (*((_BYTE *)this + 762))
        v20 = "Enabled";
      else
        v20 = "Disabled";
      v21 = 136315138;
      v22 = v20;
      v15 = "[%s] non-media-chat dynamic ducking";
      v16 = v18;
      v17 = 12;
    }
    else
    {
      if (a2 != 1852141676)
        return result;
      if (a6 <= 3)
      {
        if (AUDynamicDuckerLog(void)::onceToken != -1)
          dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
        v8 = AUDynamicDuckerLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_ERROR))
          return 4294956445;
        LOWORD(v21) = 0;
        v9 = "NonMediaChatRequestedDuckingLevel: invalid propery size";
        goto LABEL_38;
      }
      *((_DWORD *)this + 191) = *a5;
      if (AUDynamicDuckerLog(void)::onceToken != -1)
        dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
      v12 = AUDynamicDuckerLog(void)::gLog;
      v13 = os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v13)
        return result;
      v14 = *((_DWORD *)this + 191);
      v21 = 67109120;
      LODWORD(v22) = v14;
      v15 = "non-media-chat requested ducking level set to %u";
      v16 = v12;
      v17 = 8;
    }
    _os_log_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&v21, v17);
    return 0;
  }
  if (a2 == 21)
  {
    if (a6 >= 4)
    {
      result = 0;
      v10 = *((_DWORD *)this + 134);
      v11 = *a5;
      *((_DWORD *)this + 134) = *a5 != 0;
      if (v10)
      {
        if (!v11)
        {
          result = 0;
          *((_BYTE *)this + 540) = 1;
        }
      }
      return result;
    }
    return 4294956445;
  }
  if (a2 == 1633973611)
  {
    if (a6 >= 4)
    {
      result = 0;
      *((_BYTE *)this + 760) = *a5 != 0;
      return result;
    }
    return 4294956445;
  }
  return result;
}

uint64_t AUDynamicDucker::SetParameter(AUDynamicDucker *this, signed int a2, unsigned int a3, unsigned int a4, float a5)
{
  NSObject *v10;
  double v11;
  const char *v12;
  double v13;
  double v14;
  double v15;
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  int v19;
  double v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a2 > 13)
  {
    if (a2 == 14)
    {
      *((float *)this + 193) = fminf(fmaxf(a5, 0.1), 1.0);
      *((_BYTE *)this + 540) = 1;
      if (AUDynamicDuckerLog(void)::onceToken != -1)
        dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
      v10 = AUDynamicDuckerLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
      {
        v15 = *((float *)this + 193);
        v19 = 134217984;
        v20 = v15;
        v12 = "Media Chat: setting dynamic ducking accumulation time %.2fs";
        goto LABEL_22;
      }
    }
    else if (a2 == 15)
    {
      *((float *)this + 194) = a5;
      if (AUDynamicDuckerLog(void)::onceToken != -1)
        dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
      v10 = AUDynamicDuckerLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
      {
        v13 = *((float *)this + 194);
        v19 = 134217984;
        v20 = v13;
        v12 = "Media Chat: setting unducking ramp time %.2fs";
        goto LABEL_22;
      }
    }
  }
  else if (a2 == 2)
  {
    *((float *)this + 176) = a5;
    *((float *)this + 177) = __exp10f(a5 / 20.0);
    if (AUDynamicDuckerLog(void)::onceToken != -1)
      dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
    v10 = AUDynamicDuckerLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *((float *)this + 177);
      v19 = 134217984;
      v20 = v14;
      v12 = "Media Chat: setting other audio ducking level %.2f";
      goto LABEL_22;
    }
  }
  else if (a2 == 13)
  {
    *((float *)this + 192) = a5;
    if (AUDynamicDuckerLog(void)::onceToken != -1)
      dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
    v10 = AUDynamicDuckerLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *((float *)this + 192);
      v19 = 134217984;
      v20 = v11;
      v12 = "Media Chat: setting ducking ramp time %.2fs";
LABEL_22:
      _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v19, 0xCu);
    }
  }
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  if (a2 == 18)
    *((float *)this + 198) = a5;
  else
    ++*((_DWORD *)this + 132);
  return 0;
}

uint64_t AUDynamicDucker::CanScheduleParameters(AUDynamicDucker *this)
{
  return 0;
}

uint64_t AUDynamicDucker::ProcessMultipleBufferLists(AUDynamicDucker *this, unsigned int *a2, vDSP_Length __N, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  unsigned int v11;
  int v13;
  _BOOL4 v14;
  const AudioBufferList *v15;
  const AudioBufferList *v16;
  const AudioBufferList *v17;
  _BOOL4 v18;
  const AudioBufferList *v19;
  float v20;
  vDSP_Length v21;
  const AudioBufferList *v22;
  const AudioBufferList *v23;
  int v24;
  float v25;
  float v26;
  float v27;
  float v28;
  vDSP_Length v29;
  const AudioBufferList *v30;
  UInt32 v31;
  UInt32 *v32;
  unint64_t v33;
  unint64_t i;
  void *mData;
  void *v36;
  UInt32 *v37;
  UInt32 v38;
  uint64_t v39;
  const void **v40;
  unsigned int *v41;
  unint64_t v42;
  void **v43;
  const AudioBufferList *v44;
  const AudioBufferList *v45;
  AudioBufferList *v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  void **p_mData;
  void *v51;
  void *v52;
  const AudioBufferList *v53;
  unsigned int mNumberBuffers;
  unsigned int v55;
  const AudioBufferList **v56;
  unsigned int v57;
  unsigned int v58;
  const AudioBufferList *v59;
  unsigned int v60;
  const AudioBufferList *v61;
  unsigned int v62;
  float v63;
  unsigned int v64;
  float v65;
  const float **v66;
  uint64_t v67;
  unsigned int v68;
  unsigned int v69;
  float v70;
  unsigned int v71;
  float v72;
  const float **v73;
  uint64_t v74;
  unsigned int v75;
  unsigned int v76;
  float v77;
  const AudioBufferList *v78;
  float v79;
  const AudioBufferList *v80;
  unsigned int v81;
  unsigned int v82;
  float v83;
  const float **v84;
  uint64_t v85;
  unsigned int v86;
  unsigned int v87;
  float v88;
  float v89;
  unsigned int v90;
  unsigned int v91;
  float v92;
  const float **v93;
  uint64_t v94;
  unsigned int v95;
  unsigned int v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  _BOOL4 v103;
  float v104;
  _BOOL4 v105;
  char v106;
  char v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  int v114;
  float v115;
  float v116;
  _BOOL4 v117;
  int v118;
  float v119;
  unsigned int v120;
  float v121;
  unsigned int v122;
  unsigned int v123;
  const AudioBufferList *v124;
  float v125;
  float *v127;
  uint64_t v128;
  float v129;
  double v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  unsigned int v137;
  unsigned int v138;
  const AudioBufferList *v139;
  float v140;
  uint64_t v142;
  float v143;
  double v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float *v149;
  float *p_C;
  UInt32 v151;
  float *v152;
  float v153;
  float v154;
  float v155;
  UInt32 *v156;
  unint64_t v157;
  unint64_t j;
  void *v159;
  void *v160;
  UInt32 *v161;
  UInt32 v162;
  uint64_t v163;
  const void **v164;
  unsigned int *v165;
  unint64_t v166;
  void **v167;
  float v168;
  int v169;
  float *v170;
  float v171;
  float v172;
  uint64_t v174;
  float v175;
  double v176;
  float v177;
  float v178;
  float v179;
  float v180;
  float *v181;
  float *v182;
  float v183;
  float v184;
  float v185;
  const AudioBufferList *v186;
  const AudioBufferList *v187;
  AudioBufferList *v188;
  unint64_t v189;
  unint64_t v190;
  unint64_t v191;
  void **v192;
  void *v193;
  void *v194;
  uint64_t v195;
  ausdk::AUElement *v196;
  ausdk::AUElement **v197;
  uint64_t v198;
  ausdk::AUElement *v199;
  ausdk::AUElement **v200;
  uint64_t v201;
  ausdk::AUElement *v202;
  ausdk::AUElement **v203;
  float v204;
  uint64_t v205;
  ausdk::AUElement *v206;
  ausdk::AUElement **v207;
  const AudioBufferList *v209;
  unsigned int v210;
  uint64_t v211;
  int v212;
  const AudioBufferList *v213;
  uint64_t v214;
  const AudioBufferList *v215;
  _BOOL4 v216;
  const AudioBufferList **v217;
  unsigned int v218;
  unsigned int v219;
  unsigned int v220;
  unsigned int v221;
  float v222;
  float v223;
  float v224;
  float v225;
  float __C;
  float __B[3];

  v11 = __N;
  v13 = *((_DWORD *)this + 132);
  if (v13 != *((_DWORD *)this + 133))
  {
    AUDynamicDucker::UpdateDuckerState(this);
    *((_DWORD *)this + 133) = v13;
  }
  v14 = *((float *)this + 198) > *((float *)this + 197) && *((_BYTE *)this + 800) != 0;
  if (*((_DWORD *)this + 134))
  {
    v15 = *a5;
    v220 = a4;
    if (a4 >= 2)
    {
      v16 = a5[1];
      if (v16)
      {
        v218 = a6;
        v217 = a5;
        if (a4 == 2)
        {
          v17 = 0;
          v18 = 0;
        }
        else
        {
          v17 = a5[2];
          v18 = v17 != 0;
        }
        mNumberBuffers = v16->mNumberBuffers;
        v55 = v15->mNumberBuffers;
        if (v16->mNumberBuffers <= v15->mNumberBuffers)
          v30 = v15;
        else
          v30 = v16;
        v29 = v11;
        vDSP_vadd((const float *)v15->mBuffers[0].mData, 1, (const float *)v16->mBuffers[0].mData, 1, (float *)v30->mBuffers[0].mData, 1, v11);
        v31 = v30->mNumberBuffers;
        if (v30->mNumberBuffers < 2)
        {
          a6 = v218;
          a5 = v217;
          if (!v18)
            goto LABEL_25;
          goto LABEL_68;
        }
        vDSP_vadd((const float *)v15->mBuffers[v55 > 1].mData, 1, (const float *)v16->mBuffers[mNumberBuffers > 1].mData, 1, *(float **)&v30[1].mBuffers[0].mNumberChannels, 1, v11);
        a6 = v218;
        a5 = v217;
        if (v18)
        {
LABEL_68:
          v56 = a5;
          v57 = v17->mNumberBuffers;
          v58 = v30->mNumberBuffers;
          if (v17->mNumberBuffers <= v30->mNumberBuffers)
            v59 = v30;
          else
            v59 = v17;
          vDSP_vadd((const float *)v30->mBuffers[0].mData, 1, (const float *)v17->mBuffers[0].mData, 1, (float *)v59->mBuffers[0].mData, 1, v29);
          v31 = v59->mNumberBuffers;
          if (v59->mNumberBuffers < 2)
          {
            v30 = v59;
            a5 = v56;
            goto LABEL_25;
          }
          vDSP_vadd((const float *)v30->mBuffers[v58 > 1].mData, 1, (const float *)v17->mBuffers[v57 > 1].mData, 1, *(float **)&v59[1].mBuffers[0].mNumberChannels, 1, v29);
          v30 = v59;
          a5 = v56;
        }
LABEL_24:
        v31 = v30->mNumberBuffers;
LABEL_25:
        v32 = (UInt32 *)*a7;
        if (v31)
        {
          v33 = 0;
          for (i = 0; i < v31; ++i)
          {
            mData = v30->mBuffers[v33 / 0x10].mData;
            v36 = *(void **)&v32[v33 / 4 + 4];
            if (mData != v36)
            {
              memcpy(v36, mData, v30->mBuffers[v33 / 0x10].mDataByteSize);
              v31 = v30->mNumberBuffers;
            }
            v33 += 16;
          }
          v37 = (UInt32 *)*a7;
        }
        else
        {
          v37 = (UInt32 *)*a7;
        }
        v38 = *v37;
        if (v31 < v38)
        {
          v39 = (uint64_t)&v30->mBuffers[v31 - 1];
          v40 = (const void **)(v39 + 8);
          v41 = (unsigned int *)(v39 + 4);
          v42 = v31;
          v43 = (void **)&v32[4 * v31 + 4];
          do
          {
            if (*v40 != *v43)
            {
              memcpy(*v43, *v40, *v41);
              v38 = (*a7)->mNumberBuffers;
            }
            ++v42;
            v43 += 2;
          }
          while (v42 < v38);
        }
        if (v220 < 4)
        {
          v45 = 0;
        }
        else
        {
          v44 = a5[3];
          if (v220 == 4)
          {
            v45 = a5[3];
          }
          else
          {
            v53 = a5[4];
            if (v53)
              v45 = v53;
            else
              v45 = v44;
            if (v53 && v44)
            {
              v45 = v53->mNumberBuffers <= v44->mNumberBuffers ? v44 : v53;
              vDSP_vadd((const float *)v44->mBuffers[0].mData, 1, (const float *)v53->mBuffers[0].mData, 1, (float *)v45->mBuffers[0].mData, 1, v11);
              if (v45->mNumberBuffers >= 2)
                vDSP_vadd((const float *)v44->mBuffers[v44->mNumberBuffers > 1].mData, 1, (const float *)v53->mBuffers[v53->mNumberBuffers > 1].mData, 1, *(float **)&v45[1].mBuffers[0].mNumberChannels, 1, v11);
            }
          }
        }
        if (a6 >= 2)
        {
          v46 = a7[1];
          if (v46)
          {
            if (v45)
            {
              v47 = v45->mNumberBuffers;
              if ((_DWORD)v47)
              {
                v48 = 0;
                v49 = 0;
                p_mData = &v46->mBuffers[0].mData;
                do
                {
                  v51 = v45->mBuffers[v48 / 0x10].mData;
                  v52 = p_mData[v48 / 8];
                  if (v51 != v52)
                  {
                    memcpy(v52, v51, v45->mBuffers[v48 / 0x10].mDataByteSize);
                    v47 = v45->mNumberBuffers;
                  }
                  ++v49;
                  v48 += 16;
                }
                while (v49 < v47);
              }
            }
          }
        }
        return 0;
      }
      if (a4 != 2)
      {
        v17 = a5[2];
        if (v17)
        {
          v29 = v11;
          v30 = *a5;
          goto LABEL_68;
        }
      }
    }
    v30 = *a5;
    goto LABEL_24;
  }
  if (*((_BYTE *)this + 540))
  {
    (*(void (**)(AUDynamicDucker *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
    *((_BYTE *)this + 540) = 0;
  }
  if (a4 < 2)
  {
    v22 = *a5;
    if (!*a5)
      return 0;
    v213 = 0;
    v214 = 0;
    v23 = 0;
    v216 = 0;
    LODWORD(v211) = 0;
    v24 = 0;
    v215 = 0;
    v25 = -200.0;
    v26 = -200.0;
    v27 = -200.0;
    v28 = -200.0;
LABEL_118:
    v98 = *((float *)this + 178);
    if (v26 >= v98)
    {
      v99 = v98 - v27;
      v101 = v98 - v25;
      v100 = v98 - v28;
    }
    else
    {
      v99 = 0.0;
      v100 = 0.0;
      v101 = 0.0;
      if (v26 >= (float)(v98 + -18.0))
      {
        v102 = (float)(v26 - (float)(v98 + -18.0)) / 18.0;
        v99 = (float)(v98 - v27) * v102;
        v101 = (float)(v98 - v25) * v102;
        v100 = (float)(v98 - v28) * v102;
      }
    }
    if (*((_BYTE *)this + 760))
      v103 = 1;
    else
      v103 = *((_BYTE *)this + 761) != 0;
    v104 = *((float *)this + 179);
    v105 = v27 >= v104 && v103;
    if (v14 || v105)
    {
      v106 = 0;
      *((_BYTE *)this + 761) = 1;
      v101 = (float)(v104 - v25) + v101;
      v100 = (float)(v104 - v28) + v100;
    }
    else
    {
      v107 = !v103;
      if (v27 < (float)(v104 + -18.0))
        v107 = 1;
      if ((v107 & 1) != 0)
      {
        *((_BYTE *)this + 761) = 0;
        v106 = 1;
      }
      else
      {
        v106 = 0;
        *((_BYTE *)this + 761) = 1;
        v108 = (float)(v27 - (float)(v104 + -18.0)) / 18.0;
        v101 = v101 + (float)(v108 * (float)(v104 - v25));
        v100 = v100 + (float)(v108 * (float)(v104 - v28));
      }
    }
    if (v99 != 0.0)
    {
      v109 = *((float *)this + 180);
      if ((float)(v27 + v99) < v109)
        v99 = v109 - v27;
      if (v99 > 0.0)
        v99 = 0.0;
    }
    __B[0] = v99;
    if (v101 != 0.0)
    {
      v110 = *((float *)this + 181);
      if ((float)(v25 + v101) < v110)
        v101 = v110 - v25;
      if (v101 > 0.0)
        v101 = 0.0;
    }
    __C = v101;
    v111 = *((float *)this + 182);
    if (v100 != 0.0)
    {
      if ((float)(v28 + v100) < v111)
        v100 = v111 - v28;
      if (v100 > 0.0)
        v100 = 0.0;
    }
    v225 = v100;
    v112 = *((float *)this + 199);
    v221 = a4;
    if (v112 > (float)(v111 + -12.0) && v28 < (float)(v111 + 4.0) && ((v24 ^ 1) & 1) == 0)
    {
      if (v112 > (float)(v111 + -6.0))
        v100 = v100 + -8.0;
      else
        v100 = v100 + (float)((float)((float)(v112 - (float)(v111 + -12.0)) / -6.0) * 8.0);
      v225 = v100;
    }
    v113 = *((float *)this + 183);
    v114 = *((_DWORD *)this + 191);
    switch(v114)
    {
      case 30:
        v115 = 1.3333;
        break;
      case 20:
        v115 = 0.66667;
        break;
      case 10:
        v115 = 0.33333;
        break;
      default:
        goto LABEL_164;
    }
    v113 = v113 * v115;
LABEL_164:
    HIDWORD(v211) = v24;
    if ((float)(v28 + v100) > v113)
    {
      v100 = v113 - v28;
      v225 = v113 - v28;
    }
    v116 = log10f(*((float *)this + 137)) * 20.0;
    if (v100 >= v116)
    {
      v118 = *((_DWORD *)this + 195);
      v117 = v216;
      if (v118)
      {
        *((_DWORD *)this + 195) = v118 - 1;
        v225 = v116;
        v100 = v116;
      }
    }
    else
    {
      *((_DWORD *)this + 195) = *((_DWORD *)this + 196);
      v117 = v216;
    }
    if (*((_BYTE *)this + 762))
    {
      if (v114 == 30)
      {
        if ((v106 & 1) != 0)
          v119 = -6.0;
        else
          v119 = -9.0;
      }
      else
      {
        if (v114 != 10)
          goto LABEL_178;
        v119 = 0.0;
      }
      v225 = v100 + v119;
      __C = v101 + v119;
    }
LABEL_178:
    v219 = a6;
    if (!v117)
    {
      v23 = v22;
      goto LABEL_208;
    }
    v120 = v11;
    v121 = __exp10f(v99 / 20.0);
    __B[0] = v121;
    v122 = v23->mNumberBuffers;
    v123 = v22->mNumberBuffers;
    v124 = v23;
    if (v23->mNumberBuffers <= v22->mNumberBuffers)
      v23 = v22;
    v125 = *((float *)this + 136);
    if (v121 == 1.0 && v125 == 1.0)
    {
      vDSP_vadd((const float *)v22->mBuffers[0].mData, 1, (const float *)v124->mBuffers[0].mData, 1, (float *)v23->mBuffers[0].mData, 1, v120);
      if (v23->mNumberBuffers >= 2)
        vDSP_vadd((const float *)v22->mBuffers[v123 > 1].mData, 1, (const float *)v124->mBuffers[v122 > 1].mData, 1, *(float **)&v23[1].mBuffers[0].mNumberChannels, 1, v120);
    }
    else
    {
      if (v121 != v125)
      {
        v127 = (float *)((char *)this + 544);
        v128 = 768;
        if (v121 > v125)
          v128 = 776;
        v129 = *(float *)((char *)this + v128);
        v224 = 0.0;
        v130 = (float)(1.0 - *((float *)this + 173));
        v131 = v130
             / (*(double *)(ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 128), 0) + 80)
              * v129);
        v224 = v131;
        v223 = 1.0;
        v132 = *((float *)this + 173);
        v222 = v132;
        if (__B[0] >= *((float *)this + 136))
        {
          v223 = fminf(__B[0], 1.0);
        }
        else
        {
          v224 = -v131;
          if (v132 >= __B[0])
            v133 = v132;
          else
            v133 = __B[0];
          v222 = v133;
        }
        vDSP_vramp((const float *)this + 136, &v224, *((float **)this + 94), 1, v120);
        vDSP_vclip(*((const float **)this + 94), 1, &v222, &v223, *((float **)this + 94), 1, v120);
        vDSP_vma((const float *)v22->mBuffers[0].mData, 1, *((const float **)this + 94), 1, (const float *)v124->mBuffers[0].mData, 1, (float *)v23->mBuffers[0].mData, 1, v120);
        if (v23->mNumberBuffers >= 2)
          vDSP_vma((const float *)v22->mBuffers[v123 > 1].mData, 1, *((const float **)this + 94), 1, (const float *)v124->mBuffers[v122 > 1].mData, 1, *(float **)&v23[1].mBuffers[0].mNumberChannels, 1, v120);
        v134 = v224;
        v135 = *v127 + (float)(v224 * (float)v120);
        *v127 = v135;
        v11 = v120;
        if (v135 < __B[0] && v134 < 0.0 || v135 > __B[0] && v134 > 0.0)
          *v127 = __B[0];
        a6 = v219;
LABEL_208:
        if (!(_DWORD)v214)
        {
          v139 = v23;
LABEL_252:
          v151 = v139->mNumberBuffers;
          goto LABEL_253;
        }
        v136 = __exp10f(__C / 20.0);
        __C = v136;
        v137 = v213->mNumberBuffers;
        v138 = v23->mNumberBuffers;
        if (v213->mNumberBuffers <= v23->mNumberBuffers)
          v139 = v23;
        else
          v139 = v213;
        v140 = *((float *)this + 138);
        if (v136 == 1.0 && v140 == 1.0)
        {
          vDSP_vadd((const float *)v23->mBuffers[0].mData, 1, (const float *)v213->mBuffers[0].mData, 1, (float *)v139->mBuffers[0].mData, 1, v11);
          v151 = v139->mNumberBuffers;
          if (v139->mNumberBuffers >= 2)
          {
            vDSP_vadd((const float *)v23->mBuffers[v138 > 1].mData, 1, (const float *)v213->mBuffers[v137 > 1].mData, 1, *(float **)&v139[1].mBuffers[0].mNumberChannels, 1, v11);
LABEL_251:
            a6 = v219;
            goto LABEL_252;
          }
        }
        else
        {
          if (v136 != v140)
          {
            v142 = 768;
            if (v136 > v140)
              v142 = 776;
            v143 = *(float *)((char *)this + v142);
            v224 = 0.0;
            v144 = (float)(1.0 - *((float *)this + 175));
            v145 = v144
                 / (*(double *)(ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 128), 0) + 80)
                  * v143);
            v224 = v145;
            v223 = 1.0;
            v146 = *((float *)this + 175);
            v147 = v146 * v146;
            v222 = v146 * v146;
            v148 = *((float *)this + 138);
            if (__C < v148)
            {
              v145 = -v145;
              v224 = v145;
            }
            v149 = (float *)((char *)this + 700);
            if (v145 < 0.0)
            {
              if (v148 < v146 || (v211 & HIDWORD(v211) & 1) != 0)
              {
                if (v147 < __C)
                  v147 = __C;
              }
              else
              {
                p_C = &__C;
                if (v146 >= __C)
                  p_C = (float *)((char *)this + 700);
                v147 = *p_C;
              }
              v222 = v147;
            }
            v152 = (float *)((char *)this + 552);
            if (v145 > 0.0)
            {
              if (v148 <= v146 && v211)
              {
                if (__C < v146)
                  v149 = &__C;
                v153 = *v149;
              }
              else
              {
                v153 = fminf(__C, 1.0);
              }
              v223 = v153;
            }
            vDSP_vramp((const float *)this + 138, &v224, *((float **)this + 94), 1, v11);
            vDSP_vclip(*((const float **)this + 94), 1, &v222, &v223, *((float **)this + 94), 1, v11);
            vDSP_vma((const float *)v213->mBuffers[0].mData, 1, *((const float **)this + 94), 1, (const float *)v23->mBuffers[0].mData, 1, (float *)v139->mBuffers[0].mData, 1, v11);
            if (v139->mNumberBuffers >= 2)
              vDSP_vma((const float *)v213->mBuffers[v137 > 1].mData, 1, *((const float **)this + 94), 1, (const float *)v23->mBuffers[v138 > 1].mData, 1, *(float **)&v139[1].mBuffers[0].mNumberChannels, 1, v11);
            v154 = v224;
            v155 = *v152 + (float)(v224 * (float)v11);
            *v152 = v155;
            if (v155 < __C && v154 < 0.0 || v155 > __C && v154 > 0.0)
              *v152 = __C;
            goto LABEL_251;
          }
          vDSP_vsma((const float *)v213->mBuffers[0].mData, 1, &__C, (const float *)v23->mBuffers[0].mData, 1, (float *)v139->mBuffers[0].mData, 1, v11);
          v151 = v139->mNumberBuffers;
          if (v139->mNumberBuffers >= 2)
          {
            vDSP_vsma((const float *)v213->mBuffers[v137 > 1].mData, 1, &__C, (const float *)v23->mBuffers[v138 > 1].mData, 1, *(float **)&v139[1].mBuffers[0].mNumberChannels, 1, v11);
            goto LABEL_251;
          }
        }
        a6 = v219;
LABEL_253:
        v156 = (UInt32 *)*a7;
        if (v151)
        {
          v157 = 0;
          for (j = 0; j < v151; ++j)
          {
            v159 = v139->mBuffers[v157 / 0x10].mData;
            v160 = *(void **)&v156[v157 / 4 + 4];
            if (v159 != v160)
            {
              memcpy(v160, v159, v139->mBuffers[v157 / 0x10].mDataByteSize);
              v151 = v139->mNumberBuffers;
            }
            v157 += 16;
          }
          v161 = (UInt32 *)*a7;
        }
        else
        {
          v161 = (UInt32 *)*a7;
        }
        v162 = *v161;
        if (v151 < v162)
        {
          v163 = (uint64_t)&v139->mBuffers[v151 - 1];
          v164 = (const void **)(v163 + 8);
          v165 = (unsigned int *)(v163 + 4);
          v166 = v151;
          v167 = (void **)&v156[4 * v151 + 4];
          do
          {
            if (*v164 != *v167)
            {
              memcpy(*v167, *v164, *v165);
              v162 = (*a7)->mNumberBuffers;
            }
            ++v166;
            v167 += 2;
          }
          while (v166 < v162);
        }
        v168 = 1.0;
        v169 = HIDWORD(v214);
        if (HIDWORD(v214))
        {
          v170 = (float *)((char *)this + 548);
          v171 = __exp10f(v225 / 20.0);
          v225 = v171;
          v172 = *((float *)this + 137);
          if (v171 != 1.0 || v172 != 1.0)
          {
            if (v171 == v172)
            {
              vDSP_vsmul((const float *)v215->mBuffers[0].mData, 1, &v225, (float *)v215->mBuffers[0].mData, 1, v11);
              if (v215->mNumberBuffers >= 2)
                vDSP_vsmul(*(const float **)&v215[1].mBuffers[0].mNumberChannels, 1, &v225, *(float **)&v215[1].mBuffers[0].mNumberChannels, 1, v11);
              v168 = v225;
            }
            else
            {
              v174 = 768;
              if (v171 > v172)
                v174 = 776;
              v175 = *(float *)((char *)this + v174);
              v224 = 0.0;
              v176 = (float)(1.0 - *((float *)this + 177));
              v177 = v176
                   / (*(double *)(ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 128), 0) + 80)
                    * v175);
              v224 = v177;
              v223 = 1.0;
              v178 = *((float *)this + 177);
              v179 = v178 * v178;
              v222 = v178 * v178;
              v180 = *((float *)this + 137);
              if (v225 < v180)
              {
                v177 = -v177;
                v224 = v177;
              }
              v181 = (float *)((char *)this + 708);
              if (v177 < 0.0)
              {
                if (v180 < v178 || (v211 & HIDWORD(v211) & 1) != 0)
                {
                  if (v179 < v225)
                    v179 = v225;
                }
                else
                {
                  v182 = &v225;
                  if (v178 >= v225)
                    v182 = (float *)((char *)this + 708);
                  v179 = *v182;
                }
                v222 = v179;
              }
              if (v177 > 0.0)
              {
                if (v180 <= v178 && v211)
                {
                  if (v225 < v178)
                    v181 = &v225;
                  v183 = *v181;
                }
                else
                {
                  v183 = fminf(v225, 1.0);
                }
                v223 = v183;
              }
              vDSP_vramp((const float *)this + 137, &v224, *((float **)this + 94), 1, v11);
              vDSP_vclip(*((const float **)this + 94), 1, &v222, &v223, *((float **)this + 94), 1, v11);
              vDSP_vmul((const float *)v215->mBuffers[0].mData, 1, *((const float **)this + 94), 1, (float *)v215->mBuffers[0].mData, 1, v11);
              if (v215->mNumberBuffers >= 2)
                vDSP_vmul(*(const float **)&v215[1].mBuffers[0].mNumberChannels, 1, *((const float **)this + 94), 1, *(float **)&v215[1].mBuffers[0].mNumberChannels, 1, v11);
              v184 = v224;
              v185 = *v170 + (float)(v224 * (float)v11);
              *v170 = v185;
              if (v185 < v225 && v184 < 0.0 || v185 > v225 && v184 > 0.0)
                *v170 = v225;
              v168 = *(float *)(*((_QWORD *)this + 94) + 4 * (v11 - 1));
              v169 = HIDWORD(v214);
            }
          }
        }
        if (v221 >= 5 && (v186 = a5[4]) != 0)
        {
          if (v169)
          {
            if (v186->mNumberBuffers <= v215->mNumberBuffers)
              v187 = v215;
            else
              v187 = v186;
            vDSP_vadd((const float *)v215->mBuffers[0].mData, 1, (const float *)v186->mBuffers[0].mData, 1, (float *)v187->mBuffers[0].mData, 1, v11);
            if (v187->mNumberBuffers >= 2)
              vDSP_vadd((const float *)v215->mBuffers[v215->mNumberBuffers > 1].mData, 1, (const float *)v186->mBuffers[v186->mNumberBuffers > 1].mData, 1, *(float **)&v187[1].mBuffers[0].mNumberChannels, 1, v11);
          }
          else
          {
            v187 = v186;
          }
        }
        else if (v169)
        {
          v187 = v215;
        }
        else
        {
          v187 = 0;
        }
        if (a6 >= 2)
        {
          v188 = a7[1];
          if (v188)
          {
            if (v187)
            {
              v189 = v187->mNumberBuffers;
              if ((_DWORD)v189)
              {
                v190 = 0;
                v191 = 0;
                v192 = &v188->mBuffers[0].mData;
                do
                {
                  v193 = v187->mBuffers[v190 / 0x10].mData;
                  v194 = v192[v190 / 8];
                  if (v193 != v194)
                  {
                    memcpy(v194, v193, v187->mBuffers[v190 / 0x10].mDataByteSize);
                    v189 = v187->mNumberBuffers;
                  }
                  ++v191;
                  v190 += 16;
                }
                while (v191 < v189);
              }
            }
          }
        }
        v195 = *((_QWORD *)this + 9);
        if (v195)
        {
          v196 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v195 + 32))(v195, 0);
        }
        else
        {
          v197 = (ausdk::AUElement **)*((_QWORD *)this + 6);
          if (*((ausdk::AUElement ***)this + 7) == v197)
            v196 = 0;
          else
            v196 = *v197;
        }
        ausdk::AUElement::SetParameter(v196, 0xCu, v27, 0);
        v198 = *((_QWORD *)this + 9);
        if (v198)
        {
          v199 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v198 + 32))(v198, 0);
        }
        else
        {
          v200 = (ausdk::AUElement **)*((_QWORD *)this + 6);
          if (*((ausdk::AUElement ***)this + 7) == v200)
            v199 = 0;
          else
            v199 = *v200;
        }
        ausdk::AUElement::SetParameter(v199, 0x14u, v28, 0);
        v201 = *((_QWORD *)this + 9);
        if (v201)
        {
          v202 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v201 + 32))(v201, 0);
        }
        else
        {
          v203 = (ausdk::AUElement **)*((_QWORD *)this + 6);
          if (*((ausdk::AUElement ***)this + 7) == v203)
            v202 = 0;
          else
            v202 = *v203;
        }
        v204 = log10f(v168);
        ausdk::AUElement::SetParameter(v202, 0x15u, v204 * 20.0, 0);
        v205 = *((_QWORD *)this + 9);
        if (v205)
        {
          v206 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v205 + 32))(v205, 0);
        }
        else
        {
          v207 = (ausdk::AUElement **)*((_QWORD *)this + 6);
          if (*((ausdk::AUElement ***)this + 7) == v207)
            v206 = 0;
          else
            v206 = *v207;
        }
        ausdk::AUElement::SetParameter(v206, 0x16u, *((float *)this + 199), 0);
        return 0;
      }
      vDSP_vsma((const float *)v22->mBuffers[0].mData, 1, __B, (const float *)v124->mBuffers[0].mData, 1, (float *)v23->mBuffers[0].mData, 1, v120);
      if (v23->mNumberBuffers >= 2)
        vDSP_vsma((const float *)v22->mBuffers[v123 > 1].mData, 1, __B, (const float *)v124->mBuffers[v122 > 1].mData, 1, *(float **)&v23[1].mBuffers[0].mNumberChannels, 1, v120);
    }
    a6 = v219;
    v11 = v120;
    goto LABEL_208;
  }
  v19 = a5[1];
  v216 = v19 != 0;
  if (!v19)
  {
    v22 = *a5;
    if (!*a5)
      return 0;
    v60 = v11;
    v61 = 0;
    v62 = a4;
    v210 = v60;
    LODWORD(v211) = 0;
    v21 = v60;
    v63 = (float)v60;
    v26 = -200.0;
    goto LABEL_84;
  }
  v20 = *((float *)this + 184);
  if (v20 == 0.0)
  {
    v21 = v11;
  }
  else
  {
    __B[0] = __exp10f(v20 / 20.0);
    v21 = v11;
    vDSP_vsmul((const float *)v19->mBuffers[0].mData, 1, __B, (float *)v19->mBuffers[0].mData, 1, v11);
    if (v19->mNumberBuffers >= 2)
      vDSP_vsmul(*(const float **)&v19[1].mBuffers[0].mNumberChannels, 1, __B, *(float **)&v19[1].mBuffers[0].mNumberChannels, 1, v11);
  }
  v64 = v19->mNumberBuffers;
  __B[0] = 0.0;
  vDSP_svesq((const float *)v19->mBuffers[0].mData, 1, __B, v21);
  v63 = (float)v11;
  v65 = __B[0] / (float)v11;
  __B[0] = v65;
  if (v64 >= 2)
  {
    __C = 0.0;
    vDSP_svesq(*(const float **)&v19[1].mBuffers[0].mNumberChannels, 1, &__C, v21);
    v65 = __C / v63;
    if (__B[0] >= (float)(__C / v63))
      v65 = __B[0];
  }
  v66 = (const float **)((char *)this + 592);
  v67 = *((unsigned int *)this + 149);
  *(float *)(*((_QWORD *)this + 76) + 4 * v67) = v65;
  v68 = *((_DWORD *)this + 150);
  *((_DWORD *)this + 149) = ((int)v67 + 1) % v68;
  v69 = *((_DWORD *)this + 148);
  if (v69 < v68)
    *(_DWORD *)v66 = v69 + 1;
  v70 = SlidingRMSWindow::ComputeRMS(v66) + 1.0e-20;
  v26 = log10f(v70) * 10.0;
  v22 = *a5;
  if (*a5)
  {
    v210 = v11;
    LODWORD(v211) = v26 > *((float *)this + 178);
    v61 = v19;
    v62 = a4;
LABEL_84:
    v71 = v22->mNumberBuffers;
    __B[0] = 0.0;
    vDSP_svesq((const float *)v22->mBuffers[0].mData, 1, __B, v21);
    v72 = __B[0] / v63;
    __B[0] = __B[0] / v63;
    if (v71 >= 2)
    {
      __C = 0.0;
      vDSP_svesq(*(const float **)&v22[1].mBuffers[0].mNumberChannels, 1, &__C, v21);
      v72 = __C / v63;
      if (__B[0] >= (float)(__C / v63))
        v72 = __B[0];
    }
    v73 = (const float **)((char *)this + 560);
    v74 = *((unsigned int *)this + 141);
    *(float *)(*((_QWORD *)this + 72) + 4 * v74) = v72;
    v75 = *((_DWORD *)this + 142);
    *((_DWORD *)this + 141) = ((int)v74 + 1) % v75;
    v76 = *((_DWORD *)this + 140);
    a4 = v62;
    if (v76 < v75)
      *(_DWORD *)v73 = v76 + 1;
    v77 = SlidingRMSWindow::ComputeRMS(v73) + 1.0e-20;
    v27 = log10f(v77) * 10.0;
    v24 = v27 > *((float *)this + 179) || v14;
    v23 = v61;
    if (a4 < 3)
    {
      v213 = 0;
      v214 = 0;
      v215 = 0;
      v25 = -200.0;
      v28 = -200.0;
      v11 = v210;
    }
    else
    {
      v78 = a5[2];
      LODWORD(v214) = v78 != 0;
      v213 = v78;
      v212 = v24;
      v209 = v61;
      if (v78)
      {
        v79 = *((float *)this + 185);
        if (v79 != 0.0)
        {
          __B[0] = 0.0;
          v80 = v78;
          __B[0] = __exp10f(v79 / 20.0);
          vDSP_vsmul((const float *)v80->mBuffers[0].mData, 1, __B, (float *)v80->mBuffers[0].mData, 1, v21);
          if (v80->mNumberBuffers >= 2)
            vDSP_vsmul(*(const float **)&v213[1].mBuffers[0].mNumberChannels, 1, __B, *(float **)&v213[1].mBuffers[0].mNumberChannels, 1, v21);
          v78 = v213;
        }
        v81 = a4;
        v82 = v78->mNumberBuffers;
        __B[0] = 0.0;
        vDSP_svesq((const float *)v78->mBuffers[0].mData, 1, __B, v21);
        v83 = __B[0] / v63;
        __B[0] = __B[0] / v63;
        if (v82 >= 2)
        {
          __C = 0.0;
          vDSP_svesq(*(const float **)&v213[1].mBuffers[0].mNumberChannels, 1, &__C, v21);
          v83 = __C / v63;
          if (__B[0] >= (float)(__C / v63))
            v83 = __B[0];
        }
        v84 = (const float **)((char *)this + 624);
        v85 = *((unsigned int *)this + 157);
        *(float *)(*((_QWORD *)this + 80) + 4 * v85) = v83;
        v86 = *((_DWORD *)this + 158);
        *((_DWORD *)this + 157) = ((int)v85 + 1) % v86;
        v87 = *((_DWORD *)this + 156);
        a4 = v81;
        v11 = v210;
        if (v87 < v86)
          *(_DWORD *)v84 = v87 + 1;
        v88 = SlidingRMSWindow::ComputeRMS(v84) + 1.0e-20;
        v25 = log10f(v88) * 10.0;
        v24 = v212;
        v23 = v209;
      }
      else
      {
        v25 = -200.0;
        v11 = v210;
      }
      if (a4 >= 4 && (v215 = a5[3]) != 0)
      {
        v89 = *((float *)this + 186);
        if (v89 != 0.0)
        {
          __B[0] = 0.0;
          __B[0] = __exp10f(v89 / 20.0);
          vDSP_vsmul((const float *)v215->mBuffers[0].mData, 1, __B, (float *)v215->mBuffers[0].mData, 1, v21);
          if (v215->mNumberBuffers >= 2)
            vDSP_vsmul(*(const float **)&v215[1].mBuffers[0].mNumberChannels, 1, __B, *(float **)&v215[1].mBuffers[0].mNumberChannels, 1, v21);
        }
        v90 = a4;
        v91 = v215->mNumberBuffers;
        __B[0] = 0.0;
        vDSP_svesq((const float *)v215->mBuffers[0].mData, 1, __B, v21);
        v92 = __B[0] / v63;
        __B[0] = __B[0] / v63;
        if (v91 >= 2)
        {
          __C = 0.0;
          vDSP_svesq(*(const float **)&v215[1].mBuffers[0].mNumberChannels, 1, &__C, v21);
          v92 = __C / v63;
          if (__B[0] >= (float)(__C / v63))
            v92 = __B[0];
        }
        v93 = (const float **)((char *)this + 656);
        v94 = *((unsigned int *)this + 165);
        *(float *)(*((_QWORD *)this + 84) + 4 * v94) = v92;
        v95 = *((_DWORD *)this + 166);
        *((_DWORD *)this + 165) = ((int)v94 + 1) % v95;
        v96 = *((_DWORD *)this + 164);
        a4 = v90;
        if (v96 < v95)
          *(_DWORD *)v93 = v96 + 1;
        v97 = SlidingRMSWindow::ComputeRMS(v93) + 1.0e-20;
        v28 = log10f(v97) * 10.0;
        *((float *)this + 199) = (float)(v28 * 0.005) + (float)(*((float *)this + 199) * 0.995);
        HIDWORD(v214) = 1;
        v24 = v212;
        v23 = v209;
      }
      else
      {
        v215 = 0;
        HIDWORD(v214) = 0;
        v28 = -200.0;
      }
    }
    goto LABEL_118;
  }
  return 0;
}

uint64_t AUDynamicDucker::Render(AUDynamicDucker *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  uint64_t Element;
  ausdk::AUInputElement *v9;
  uint64_t result;
  ausdk::AUInputElement *v11;
  uint64_t v12;
  uint64_t BufferList;
  ausdk::AUInputElement *v14;
  uint64_t v15;
  uint64_t v16;
  ausdk::AUInputElement *v17;
  uint64_t v18;
  uint64_t v19;
  ausdk::AUInputElement *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD v24[2];
  _QWORD v25[6];

  v25[5] = *MEMORY[0x1E0C80C00];
  if (!ausdk::AUBase::HasInput(this, 0))
    return 4294956420;
  Element = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 128), 0);
  v9 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 0);
  result = ausdk::AUInputElement::PullInput(v9, a2, a3, 0, a4);
  if ((_DWORD)result)
    return result;
  if (ausdk::AUBase::HasInput(this, 1u))
  {
    v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 1u);
    result = ausdk::AUInputElement::PullInput(v11, a2, a3, 1, a4);
    if ((_DWORD)result)
      return result;
    v12 = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 1u);
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v12 + 144));
  }
  else
  {
    BufferList = 0;
  }
  if (ausdk::AUBase::HasInput(this, 2u))
  {
    v14 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 2u);
    result = ausdk::AUInputElement::PullInput(v14, a2, a3, 2, a4);
    if ((_DWORD)result)
      return result;
    v15 = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 2u);
    v16 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v15 + 144));
  }
  else
  {
    v16 = 0;
  }
  if (ausdk::AUBase::HasInput(this, 3u))
  {
    v17 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 3u);
    result = ausdk::AUInputElement::PullInput(v17, a2, a3, 3, a4);
    if ((_DWORD)result)
      return result;
    v18 = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 3u);
    v19 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v18 + 144));
  }
  else
  {
    v19 = 0;
  }
  if (!ausdk::AUBase::HasInput(this, 4u))
  {
    v22 = 0;
    goto LABEL_21;
  }
  v20 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 4u);
  result = ausdk::AUInputElement::PullInput(v20, a2, a3, 4, a4);
  if (!(_DWORD)result)
  {
    v21 = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 4u);
    v22 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v21 + 144));
LABEL_21:
    v23 = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 0);
    v25[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v23 + 144));
    v25[1] = BufferList;
    v25[2] = v16;
    v25[3] = v19;
    v25[4] = v22;
    v24[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    v24[1] = 0;
    return (*(uint64_t (**)(AUDynamicDucker *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, _QWORD *))(*(_QWORD *)this + 184))(this, a2, a4, 5, v25, 2, v24);
  }
  return result;
}

BOOL AUDynamicDucker::BusCountWritable(AUDynamicDucker *this, int a2)
{
  return a2 == 1;
}

uint64_t AUDynamicDucker::SetBusCount(AUDynamicDucker *this, int a2, unsigned int a3)
{
  unsigned int v3;
  int64x2_t *v4;
  uint64_t v5;

  v3 = a3 - 1;
  if (a2 == 1 && v3 <= 4)
  {
    v4 = (int64x2_t *)((char *)this + 80);
LABEL_7:
    ausdk::AUScope::SetNumberOfElements(v4, a3);
    return 0;
  }
  v5 = 4294956445;
  if (a2 == 2 && v3 <= 1)
  {
    v4 = (int64x2_t *)((char *)this + 128);
    goto LABEL_7;
  }
  return v5;
}

uint64_t AUDynamicDucker::GetParameterList(AUDynamicDucker *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;
  uint64_t i;

  if (a2)
    return 4294956430;
  for (i = 0; i != 23; ++i)
  {
    if (a3)
      a3[i] = i;
  }
  result = 0;
  *a4 = 23;
  return result;
}

uint64_t AUDynamicDucker::GetParameterInfo(AUDynamicDucker *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v6;
  uint64_t v7;
  const __CFString *v8;
  uint64_t v9;
  AudioUnitParameterValue v10;
  const __CFString *v11;
  uint64_t v12;
  AudioUnitParameterValue v13;
  AudioUnitParameterOptions v14;
  const __CFString *v15;

  buffer->flags = -1073741824;
  buffer->unitName = 0;
  if (a2)
    return 4294956418;
  switch(a3)
  {
    case 0:
      v6 = CFSTR("Primary Ducking Level (dB)");
      goto LABEL_8;
    case 1:
      v6 = CFSTR("Game Audio Ducking Level (dB)");
      goto LABEL_8;
    case 2:
      v6 = CFSTR("Other Audio Ducking Level (dB)");
LABEL_8:
      buffer->cfNameString = v6;
      buffer->flags = -939524096;
      CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v7 = 3267362816;
      goto LABEL_17;
    case 3:
      v8 = CFSTR("System Sound Ducking Threshold (dB)");
      goto LABEL_11;
    case 4:
      v8 = CFSTR("Primary Ducking Threshold (dB)");
LABEL_11:
      buffer->cfNameString = v8;
      buffer->flags = -939524096;
      CFStringGetCString(v8, buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v9 = 3259498496;
      goto LABEL_13;
    case 5:
      buffer->cfNameString = CFSTR("Primary Ducking Min Level (dB)");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Primary Ducking Min Level (dB)"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v9 = 3267362816;
LABEL_13:
      *(_QWORD *)&buffer->minValue = v9;
      v10 = -40.0;
      goto LABEL_31;
    case 6:
      buffer->cfNameString = CFSTR("Game Audio Ducking Min Level (dB)");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Game Audio Ducking Min Level (dB)"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 3267362816;
      v10 = -45.0;
      goto LABEL_31;
    case 7:
      buffer->cfNameString = CFSTR("Other Audio Ducking Min Level (dB)");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Other Audio Ducking Min Level (dB)"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 3267362816;
      v10 = -50.0;
      goto LABEL_31;
    case 8:
      buffer->cfNameString = CFSTR("Other Audio RMS Limit (dB)");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Other Audio RMS Limit (dB)"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v7 = 3276275712;
LABEL_17:
      *(_QWORD *)&buffer->minValue = v7;
      v10 = -18.0;
      goto LABEL_31;
    case 9:
      v11 = CFSTR("System Sound Gain (dB)");
      goto LABEL_21;
    case 10:
      v11 = CFSTR("Game Audio Gain (dB)");
      goto LABEL_21;
    case 11:
      v11 = CFSTR("Other Audio Gain (dB)");
LABEL_21:
      buffer->cfNameString = v11;
      buffer->flags = -939524096;
      CFStringGetCString(v11, buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v12 = 0x41400000C1C00000;
      goto LABEL_28;
    case 12:
      buffer->cfNameString = CFSTR("FEV Audio RMS");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("FEV Audio RMS"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x41400000C2C80000;
      v13 = -96.0;
      goto LABEL_39;
    case 13:
      buffer->cfNameString = CFSTR("Ducking Ramp Time (s)");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Ducking Ramp Time (s)"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x400000003C23D70ALL;
      v10 = 0.25;
      goto LABEL_31;
    case 14:
      buffer->cfNameString = CFSTR("History Accumulation Time (s)");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("History Accumulation Time (s)"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x3F8000003DCCCCCDLL;
      v10 = 0.1;
      goto LABEL_31;
    case 15:
      buffer->cfNameString = CFSTR("UnDucking Ramp Time (s)");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("UnDucking Ramp Time (s)"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v12 = 0x4000000000000000;
      goto LABEL_28;
    case 16:
      buffer->cfNameString = CFSTR("Release Hold Time (s)");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Release Hold Time (s)"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v12 = 0x4120000000000000;
      goto LABEL_28;
    case 17:
      buffer->cfNameString = CFSTR("0 --> Off, 1 --> ON");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("0 --> Off, 1 --> ON"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Boolean;
      v12 = 0x3F80000000000000;
LABEL_28:
      *(_QWORD *)&buffer->minValue = v12;
      buffer->defaultValue = 0.0;
      goto LABEL_32;
    case 18:
      buffer->cfNameString = CFSTR("Local voice probability");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Local voice probability"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      buffer->defaultValue = 0.0;
      v14 = buffer->flags & 0x7FFF7FFF | 0x8000;
      goto LABEL_33;
    case 19:
      buffer->cfNameString = CFSTR("Threshold for ducking for local voice");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Threshold for ducking for local voice"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      v10 = 0.5;
LABEL_31:
      buffer->defaultValue = v10;
LABEL_32:
      v14 = buffer->flags | 0xC0000000;
      goto LABEL_33;
    case 20:
      v15 = CFSTR("Other Audio RMS");
      goto LABEL_38;
    case 21:
      buffer->cfNameString = CFSTR("Other Audio Ducking Gain");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Other Audio Ducking Gain"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 3262119936;
      buffer->defaultValue = 0.0;
      goto LABEL_40;
    case 22:
      v15 = CFSTR("Other Audio LongTerm RMS");
LABEL_38:
      buffer->cfNameString = v15;
      buffer->flags = -939524096;
      CFStringGetCString(v15, buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x41A00000C3480000;
      v13 = -200.0;
LABEL_39:
      buffer->defaultValue = v13;
LABEL_40:
      v14 = buffer->flags & 0x3FFF7FFF | 0x40008000;
LABEL_33:
      result = 0;
      buffer->flags = v14;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t AUDynamicDucker::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
    ++*((_DWORD *)this + 132);
  return result;
}

double AUDynamicDucker::GetLatency(AUDynamicDucker *this)
{
  return 0.0;
}

double AUDynamicDucker::GetTailTime(AUDynamicDucker *this)
{
  return 0.0;
}

uint64_t AUDynamicDucker::SupportsTail(AUDynamicDucker *this)
{
  return 1;
}

BOOL AUDynamicDucker::StreamFormatWritable(AUDynamicDucker *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUDynamicDucker::SupportedNumChannels(AUDynamicDucker *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUDynamicDucker::SupportedNumChannels(AUChannelInfo const**)::chans;
  return 3;
}

uint64_t AUDynamicDucker::ValidFormat(AUDynamicDucker *this, unsigned int a2, int a3, const AudioStreamBasicDescription *a4)
{
  UInt32 mChannelsPerFrame;
  unsigned int v5;
  BOOL v6;

  mChannelsPerFrame = a4->mChannelsPerFrame;
  v5 = (LOBYTE(a4->mFormatFlags) >> 5) & 1;
  if (mChannelsPerFrame == 1)
    v5 = 1;
  if (a3)
    v6 = 0;
  else
    v6 = mChannelsPerFrame >= 3;
  if (v6)
    return 0;
  else
    return v5;
}

double AUDynamicDucker::UpdateDuckerState(AUDynamicDucker *this)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  uint64_t v5;
  ausdk::AUElement *v6;
  ausdk::AUElement **v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  uint64_t v14;
  ausdk::AUElement *v15;
  ausdk::AUElement **v16;
  uint64_t v17;
  ausdk::AUElement *v18;
  ausdk::AUElement **v19;
  uint64_t v20;
  ausdk::AUElement *v21;
  ausdk::AUElement **v22;
  uint64_t v23;
  ausdk::AUElement *v24;
  ausdk::AUElement **v25;
  uint64_t v26;
  ausdk::AUElement *v27;
  ausdk::AUElement **v28;
  uint64_t v29;
  ausdk::AUElement *v30;
  ausdk::AUElement **v31;
  uint64_t v32;
  ausdk::AUElement *v33;
  ausdk::AUElement **v34;
  uint64_t v35;
  ausdk::AUElement *v36;
  ausdk::AUElement **v37;
  uint64_t v38;
  ausdk::AUElement *v39;
  ausdk::AUElement **v40;
  uint64_t v41;
  ausdk::AUElement *v42;
  ausdk::AUElement **v43;
  uint64_t v44;
  ausdk::AUElement *v45;
  ausdk::AUElement **v46;
  uint64_t v47;
  ausdk::AUElement *v48;
  ausdk::AUElement **v49;
  double Parameter;
  uint64_t Element;
  unint64_t v52;
  uint64_t v53;
  ausdk::AUElement *v54;
  ausdk::AUElement **v55;
  uint64_t v56;
  ausdk::AUElement *v57;
  ausdk::AUElement **v58;
  uint64_t v59;
  unint64_t v60;
  double v61;
  unsigned int v62;
  double result;

  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v4 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  *((float *)this + 172) = ausdk::AUElement::GetParameter(v3, 0);
  v5 = *((_QWORD *)this + 9);
  if (v5)
  {
    v6 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
  }
  else
  {
    v7 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v7)
      v6 = 0;
    else
      v6 = *v7;
  }
  *((float *)this + 174) = ausdk::AUElement::GetParameter(v6, 1u);
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  *((float *)this + 176) = ausdk::AUElement::GetParameter(v9, 2u);
  v11 = *((_QWORD *)this + 9);
  if (v11)
  {
    v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
  }
  else
  {
    v13 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v13)
      v12 = 0;
    else
      v12 = *v13;
  }
  *((float *)this + 178) = ausdk::AUElement::GetParameter(v12, 3u);
  v14 = *((_QWORD *)this + 9);
  if (v14)
  {
    v15 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 32))(v14, 0);
  }
  else
  {
    v16 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v16)
      v15 = 0;
    else
      v15 = *v16;
  }
  *((float *)this + 179) = ausdk::AUElement::GetParameter(v15, 4u);
  v17 = *((_QWORD *)this + 9);
  if (v17)
  {
    v18 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 32))(v17, 0);
  }
  else
  {
    v19 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v19)
      v18 = 0;
    else
      v18 = *v19;
  }
  *((float *)this + 180) = ausdk::AUElement::GetParameter(v18, 5u);
  v20 = *((_QWORD *)this + 9);
  if (v20)
  {
    v21 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 32))(v20, 0);
  }
  else
  {
    v22 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v22)
      v21 = 0;
    else
      v21 = *v22;
  }
  *((float *)this + 181) = ausdk::AUElement::GetParameter(v21, 6u);
  v23 = *((_QWORD *)this + 9);
  if (v23)
  {
    v24 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
  }
  else
  {
    v25 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v25)
      v24 = 0;
    else
      v24 = *v25;
  }
  *((float *)this + 182) = ausdk::AUElement::GetParameter(v24, 7u);
  v26 = *((_QWORD *)this + 9);
  if (v26)
  {
    v27 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 32))(v26, 0);
  }
  else
  {
    v28 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v28)
      v27 = 0;
    else
      v27 = *v28;
  }
  *((float *)this + 183) = ausdk::AUElement::GetParameter(v27, 8u);
  v29 = *((_QWORD *)this + 9);
  if (v29)
  {
    v30 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v29 + 32))(v29, 0);
  }
  else
  {
    v31 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v31)
      v30 = 0;
    else
      v30 = *v31;
  }
  *((float *)this + 184) = ausdk::AUElement::GetParameter(v30, 9u);
  v32 = *((_QWORD *)this + 9);
  if (v32)
  {
    v33 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v32 + 32))(v32, 0);
  }
  else
  {
    v34 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v34)
      v33 = 0;
    else
      v33 = *v34;
  }
  *((float *)this + 185) = ausdk::AUElement::GetParameter(v33, 0xAu);
  v35 = *((_QWORD *)this + 9);
  if (v35)
  {
    v36 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 32))(v35, 0);
  }
  else
  {
    v37 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v37)
      v36 = 0;
    else
      v36 = *v37;
  }
  *((float *)this + 186) = ausdk::AUElement::GetParameter(v36, 0xBu);
  v38 = *((_QWORD *)this + 9);
  if (v38)
  {
    v39 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v38 + 32))(v38, 0);
  }
  else
  {
    v40 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v40)
      v39 = 0;
    else
      v39 = *v40;
  }
  *((float *)this + 192) = ausdk::AUElement::GetParameter(v39, 0xDu);
  v41 = *((_QWORD *)this + 9);
  if (v41)
  {
    v42 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v41 + 32))(v41, 0);
  }
  else
  {
    v43 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v43)
      v42 = 0;
    else
      v42 = *v43;
  }
  *((float *)this + 194) = ausdk::AUElement::GetParameter(v42, 0xFu);
  v44 = *((_QWORD *)this + 9);
  if (v44)
  {
    v45 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v44 + 32))(v44, 0);
  }
  else
  {
    v46 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v46)
      v45 = 0;
    else
      v45 = *v46;
  }
  *((float *)this + 193) = ausdk::AUElement::GetParameter(v45, 0xEu);
  if (*((float *)this + 194) == 0.0)
    *((_DWORD *)this + 194) = *((_DWORD *)this + 192);
  *((float *)this + 173) = __exp10f(*((float *)this + 172) / 20.0);
  *((float *)this + 175) = __exp10f(*((float *)this + 174) / 20.0);
  *((float *)this + 177) = __exp10f(*((float *)this + 176) / 20.0);
  v47 = *((_QWORD *)this + 9);
  if (v47)
  {
    v48 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v47 + 32))(v47, 0);
  }
  else
  {
    v49 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v49)
      v48 = 0;
    else
      v48 = *v49;
  }
  Parameter = ausdk::AUElement::GetParameter(v48, 0x10u);
  Element = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 128), 0);
  LODWORD(v52) = *((_DWORD *)this + 84);
  *((_DWORD *)this + 196) = (*(double *)(Element + 80) * Parameter / (double)v52);
  v53 = *((_QWORD *)this + 9);
  if (v53)
  {
    v54 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v53 + 32))(v53, 0);
  }
  else
  {
    v55 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v55)
      v54 = 0;
    else
      v54 = *v55;
  }
  *((float *)this + 197) = ausdk::AUElement::GetParameter(v54, 0x13u);
  v56 = *((_QWORD *)this + 9);
  if (v56)
  {
    v57 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v56 + 32))(v56, 0);
  }
  else
  {
    v58 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v58)
      v57 = 0;
    else
      v57 = *v58;
  }
  *((_BYTE *)this + 800) = ausdk::AUElement::GetParameter(v57, 0x11u) == 1.0;
  v59 = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 0);
  *(double *)&v60 = *((float *)this + 193);
  v61 = *(double *)(v59 + 80) * *(double *)&v60;
  LODWORD(v60) = *((_DWORD *)this + 84);
  v62 = (v61 / (double)v60);
  if (v62 <= 1)
    v62 = 1;
  *((_DWORD *)this + 142) = v62;
  *((_DWORD *)this + 150) = v62;
  *((_DWORD *)this + 158) = v62;
  *((_DWORD *)this + 166) = v62;
  result = 0.0;
  *((_QWORD *)this + 70) = 0;
  *((_QWORD *)this + 74) = 0;
  *((_QWORD *)this + 78) = 0;
  *((_QWORD *)this + 82) = 0;
  return result;
}

os_log_t ___Z18AUDynamicDuckerLogv_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreaudio", "AUDynamicDuckerLog");
  AUDynamicDuckerLog(void)::gLog = (uint64_t)result;
  return result;
}

void AUDynamicDucker::ResetHistoryWindows(AUDynamicDucker *this)
{
  uint64_t Element;
  double v3;
  double v4;
  unsigned int v5;
  NSObject *v6;
  _DWORD v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  Element = ausdk::AUScope::SafeGetElement((AUDynamicDucker *)((char *)this + 80), 0);
  std::valarray<float>::resize((uint64_t)this + 576, *(double *)(Element + 80), 0.0);
  *((_QWORD *)this + 70) = 0;
  std::valarray<float>::resize((uint64_t)this + 608, *(double *)(Element + 80), 0.0);
  *((_QWORD *)this + 74) = 0;
  std::valarray<float>::resize((uint64_t)this + 640, *(double *)(Element + 80), 0.0);
  *((_QWORD *)this + 78) = 0;
  std::valarray<float>::resize((uint64_t)this + 672, *(double *)(Element + 80), 0.0);
  v4 = *((float *)this + 193);
  v3 = *(double *)(Element + 80) * v4;
  LODWORD(v4) = *((_DWORD *)this + 84);
  if ((v3 / (double)*(unint64_t *)&v4) <= 1)
    v5 = 1;
  else
    v5 = (v3 / (double)*(unint64_t *)&v4);
  *((_DWORD *)this + 142) = v5;
  *((_DWORD *)this + 150) = v5;
  *((_DWORD *)this + 158) = v5;
  *((_DWORD *)this + 166) = v5;
  *((_QWORD *)this + 70) = 0;
  *((_QWORD *)this + 74) = 0;
  *((_QWORD *)this + 78) = 0;
  *((_QWORD *)this + 82) = 0;
  if (AUDynamicDuckerLog(void)::onceToken != -1)
    dispatch_once(&AUDynamicDuckerLog(void)::onceToken, &__block_literal_global_22856);
  v6 = AUDynamicDuckerLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)AUDynamicDuckerLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = v5;
    _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEFAULT, "history window blocks to average: %u", (uint8_t *)v7, 8u);
  }
}

void AUBeam2::~AUBeam2(AUBeam2 *this)
{
  AUBeam2::~AUBeam2(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  NSObject *v2;
  const void *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE v6[12];
  __int16 v7;
  int v8;
  __int16 v9;
  AUBeam2 *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E69EAD88;
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeam2LogScope(void)::scope + 8) & 1) != 0)
    {
      v2 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (*(_QWORD *)AUBeam2LogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeam2LogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v6 = 136315650;
          *(_QWORD *)&v6[4] = "AUBeam2.cpp";
          v7 = 1024;
          v8 = 381;
          v9 = 2048;
          v10 = this;
          _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2::~AUBeam2 (%p)", v6, 0x1Cu);
        }
      }
    }
  }
  (*(void (**)(AUBeam2 *))(*(_QWORD *)this + 64))(this);
  v3 = (const void *)*((_QWORD *)this + 86);
  if (v3)
    CFRelease(v3);
  v4 = (_BYTE *)*((_QWORD *)this + 345);
  if (v4)
  {
    v5 = (_BYTE *)*((_QWORD *)this + 346);
    if (v5 != v4)
      *((_QWORD *)this + 346) = &v5[(v4 - v5 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    operator delete(v4);
    *((_QWORD *)this + 345) = 0;
    *((_QWORD *)this + 346) = 0;
  }
  *(_QWORD *)v6 = (char *)this + 656;
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100]((void ***)v6);
  std::__optional_destruct_base<BlockProcessor,false>::~__optional_destruct_base[abi:ne180100]((_BYTE *)this + 568);
  std::unique_ptr<CmhBEAM2NOpt>::reset[abi:ne180100]((CmhBEAM2NOpt **)this + 70, 0);
  std::unique_ptr<CmhBEAM>::reset[abi:ne180100]((uint64_t *)this + 69, 0);
  ausdk::AUBase::~AUBase(this);
}

const void **AUBeam2::CreateExtendedElements(int64x2_t *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  ausdk::AUScope::Initialize(this + 40, (ausdk::AUBase *)this, 4, 2);
  v2 = this[42].i64[1];
  if (v2)
  {
    v3 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v4 = (uint64_t *)this[41].i64[0];
    if ((uint64_t *)this[41].i64[1] == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  ausdk::Owned<__CFString const*>::operator=((const void **)(v3 + 72), CFSTR("Front Beam Settings"));
  v5 = this[42].i64[1];
  if (v5)
  {
    v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 32))(v5, 1);
  }
  else
  {
    v7 = this[41].i64[0];
    if ((unint64_t)(this[41].i64[1] - v7) < 9)
      v6 = 0;
    else
      v6 = *(_QWORD *)(v7 + 8);
  }
  return ausdk::Owned<__CFString const*>::operator=((const void **)(v6 + 72), CFSTR("Back Beam Settings"));
}

uint64_t AUBeam2::Initialize(AUBeam2 *this)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t Element;
  int16x8_t v7;
  NSObject *v8;
  uint64_t v9;
  int16x8_t v10;
  double v11;
  int v12;
  unsigned int v13;
  const __CFDictionary *v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  const __CFNumber *Value;
  NSObject *v20;
  CmhBEAM2NOpt *v21;
  NSObject *v22;
  uint64_t v23;
  int v24;
  int32x2_t *v25;
  uint64_t v26;
  NSObject *v27;
  double v28;
  double v29;
  NSObject *v30;
  const char *v31;
  NSObject *v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  CmhBEAM2NOpt *v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  unsigned int v41;
  NSObject *v42;
  os_log_type_t v43;
  uint32_t v44;
  __int32 valuePtr;
  unsigned int v46;
  _BYTE v47[40];
  __int16 v48;
  int v49;
  uint8_t v50[4];
  const char *v51;
  __int16 v52;
  int v53;
  __int16 v54;
  uint8_t *v55;
  uint8_t buf[4];
  const char *v57;
  __int16 v58;
  int v59;
  __int16 v60;
  AUBeam2 *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeam2LogScope(void)::scope + 8) & 1) != 0)
    {
      v2 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (*(_QWORD *)AUBeam2LogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeam2LogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          v57 = "AUBeam2.cpp";
          v58 = 1024;
          v59 = 404;
          v60 = 2048;
          v61 = this;
          _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2::Initialize (%p)", buf, 0x1Cu);
        }
      }
    }
  }
  if (*((_BYTE *)this + 17))
  {
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
    if (AUBeam2LogScope(void)::scope)
    {
      v3 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        return 4294956447;
    }
    else
    {
      v3 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v57 = "AUBeam2.cpp";
      v58 = 1024;
      v59 = 408;
      _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error: Initialized", buf, 0x12u);
    }
    return 4294956447;
  }
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    v4 = *(NSObject **)AUBeam2LogScope(void)::scope;
    if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
      goto LABEL_27;
  }
  else
  {
    v4 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    Element = ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0);
    v7 = *(int16x8_t *)(Element + 96);
    *(_OWORD *)v47 = *(_OWORD *)(Element + 80);
    *(int16x8_t *)&v47[16] = v7;
    *(_QWORD *)&v47[32] = *(_QWORD *)(Element + 112);
    CAStreamBasicDescription::AsString((CAStreamBasicDescription *)v47, (char *)buf, *(double *)v47, v7);
    *(_DWORD *)v50 = 136315650;
    v51 = "AUBeam2.cpp";
    v52 = 1024;
    v53 = 414;
    v54 = 2080;
    v55 = buf;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d \tAUBeam2: input stream format: %s", v50, 0x1Cu);
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  }
LABEL_27:
  if (AUBeam2LogScope(void)::scope)
  {
    v8 = *(NSObject **)AUBeam2LogScope(void)::scope;
    if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
      goto LABEL_33;
  }
  else
  {
    v8 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    v9 = ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 128), 0);
    v10 = *(int16x8_t *)(v9 + 96);
    *(_OWORD *)v47 = *(_OWORD *)(v9 + 80);
    *(int16x8_t *)&v47[16] = v10;
    *(_QWORD *)&v47[32] = *(_QWORD *)(v9 + 112);
    CAStreamBasicDescription::AsString((CAStreamBasicDescription *)v47, (char *)buf, *(double *)v47, v10);
    *(_DWORD *)v50 = 136315650;
    v51 = "AUBeam2.cpp";
    v52 = 1024;
    v53 = 415;
    v54 = 2080;
    v55 = buf;
    _os_log_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d \tAUBeam2: output stream format: %s", v50, 0x1Cu);
  }
LABEL_33:
  if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0) + 108) != 2)
    return 4294956428;
  if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 128), 0) + 108) != 1)
    return 4294956428;
  v11 = *(double *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0) + 80);
  if (v11 != *(double *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 128), 0) + 80))
    return 4294956428;
  v12 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0) + 88);
  if (v12 != *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 128), 0) + 88))
    return 4294956428;
  *(_DWORD *)v50 = 2;
  v13 = *((_DWORD *)this + 133);
  valuePtr = 20;
  v46 = v13;
  v14 = (const __CFDictionary *)*((_QWORD *)this + 86);
  if (v14
    && !CFDictionaryGetValue(v14, CFSTR("diffr"))
    && CFDictionaryGetValue(*((CFDictionaryRef *)this + 86), CFSTR("mic_spacing")))
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 86), CFSTR("mic_spacing"));
    if (!CFNumberGetValue(Value, kCFNumberIntType, &valuePtr))
    {
      if (AUBeam2LogScope(void)::once != -1)
        dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
      if (AUBeam2LogScope(void)::scope)
      {
        v30 = *(NSObject **)AUBeam2LogScope(void)::scope;
        if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
          return 4294956421;
      }
      else
      {
        v30 = MEMORY[0x1E0C81028];
      }
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        return 4294956421;
      *(_DWORD *)v47 = 136315394;
      *(_QWORD *)&v47[4] = "AUBeam2.cpp";
      *(_WORD *)&v47[12] = 1024;
      *(_DWORD *)&v47[14] = 441;
      v31 = "%25s:%-5d AUBeam2 Error: Converting mic spacing from tuning file";
      v42 = v30;
      v43 = OS_LOG_TYPE_DEBUG;
LABEL_122:
      v44 = 18;
      goto LABEL_123;
    }
    if ((valuePtr - 46) <= 0xFFFFFFDB)
    {
      if (AUBeam2LogScope(void)::once != -1)
        dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
      if (AUBeam2LogScope(void)::scope)
      {
        v20 = *(NSObject **)AUBeam2LogScope(void)::scope;
        if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
          return 4294956421;
      }
      else
      {
        v20 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v47 = 136315650;
        *(_QWORD *)&v47[4] = "AUBeam2.cpp";
        *(_WORD *)&v47[12] = 1024;
        *(_DWORD *)&v47[14] = 446;
        *(_WORD *)&v47[18] = 1024;
        *(_DWORD *)&v47[20] = valuePtr;
        v31 = "%25s:%-5d AUBeam2 Error: Invalid mic spacing %d";
        v42 = v20;
        v43 = OS_LOG_TYPE_DEBUG;
        v44 = 24;
LABEL_123:
        _os_log_impl(&dword_1B5ED0000, v42, v43, v31, v47, v44);
      }
      return 4294956421;
    }
  }
  v15 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0) + 88);
  if (v15 != 1718773105)
  {
    if (v15 == 1819304813 && *((_BYTE *)this + 548))
    {
      std::make_unique[abi:ne180100]<CmhBEAM>((uint64_t *)v47);
      v16 = *(_QWORD *)v47;
      *(_QWORD *)v47 = 0;
      std::unique_ptr<CmhBEAM>::reset[abi:ne180100]((uint64_t *)this + 69, v16);
      std::unique_ptr<CmhBEAM>::reset[abi:ne180100]((uint64_t *)v47, 0);
      if (AUBeam2LogScope(void)::once != -1)
        dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
      if (AUBeam2LogScope(void)::scope)
      {
        v17 = *(NSObject **)AUBeam2LogScope(void)::scope;
        if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        {
LABEL_67:
          v25 = (int32x2_t *)*((_QWORD *)this + 69);
          v26 = ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0);
          if (CmhBEAM::initialize(v25, (int)*(double *)(v26 + 80), valuePtr, *((_DWORD *)this + 133)))
          {
            if (AUBeam2LogScope(void)::once != -1)
              dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
            if (AUBeam2LogScope(void)::scope)
            {
              v27 = *(NSObject **)AUBeam2LogScope(void)::scope;
              if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
                return 4294956421;
            }
            else
            {
              v27 = MEMORY[0x1E0C81028];
            }
            if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              return 4294956421;
            *(_DWORD *)v47 = 136315394;
            *(_QWORD *)&v47[4] = "AUBeam2.cpp";
            *(_WORD *)&v47[12] = 1024;
            *(_DWORD *)&v47[14] = 463;
            v31 = "%25s:%-5d AUBeam2: Error: Failed initializing Beam2 object";
            goto LABEL_121;
          }
          std::__optional_destruct_base<BlockProcessor,false>::reset[abi:ne180100]((_BYTE *)this + 568);
          BlockProcessor::BlockProcessor((AUBeam2 *)((char *)this + 568), 1, (const unsigned int *)v50, 1, &v46, 256, (int (*)(void *, unsigned int, const AudioBufferList **, AudioBufferList **))AUBeam2::BlockProcessClassFunc, this);
          *((_BYTE *)this + 632) = 1;
          goto LABEL_96;
        }
      }
      else
      {
        v17 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v23 = *(_QWORD *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0) + 80);
        v24 = *((_DWORD *)this + 133);
        *(_DWORD *)v47 = 136316162;
        *(_QWORD *)&v47[4] = "AUBeam2.cpp";
        *(_WORD *)&v47[12] = 1024;
        *(_DWORD *)&v47[14] = 461;
        *(_WORD *)&v47[18] = 2048;
        *(_QWORD *)&v47[20] = v23;
        *(_WORD *)&v47[28] = 1024;
        *(_DWORD *)&v47[30] = 256;
        *(_WORD *)&v47[34] = 1024;
        *(_DWORD *)&v47[36] = v24;
        _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_DEBUG, "%25s:%-5d Initialize Beam object with: sample rate = %f, optimal frame size = %d, number of beams = %d", v47, 0x28u);
      }
      goto LABEL_67;
    }
    return 4294956428;
  }
  if (*((_BYTE *)this + 548))
    return 4294956428;
  if (!*((_BYTE *)this + 376))
  {
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
    if (AUBeam2LogScope(void)::scope)
    {
      v32 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        return 4294956445;
    }
    else
    {
      v32 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v47 = 136315394;
      *(_QWORD *)&v47[4] = "AUBeam2.cpp";
      *(_WORD *)&v47[12] = 1024;
      *(_DWORD *)&v47[14] = 478;
      _os_log_impl(&dword_1B5ED0000, v32, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error: AUBeam2N should have property kAudioUnitProperty_UsesFixedBlockSize set to 1 before initialize", v47, 0x12u);
    }
    return 4294956445;
  }
  std::make_unique[abi:ne180100]<CmhBEAM2NOpt>((CmhBEAM2NOpt **)v47);
  v21 = *(CmhBEAM2NOpt **)v47;
  *(_QWORD *)v47 = 0;
  std::unique_ptr<CmhBEAM2NOpt>::reset[abi:ne180100]((CmhBEAM2NOpt **)this + 70, v21);
  std::unique_ptr<CmhBEAM2NOpt>::reset[abi:ne180100]((CmhBEAM2NOpt **)v47, 0);
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    v22 = *(NSObject **)AUBeam2LogScope(void)::scope;
    if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
      goto LABEL_90;
  }
  else
  {
    v22 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
  {
    v33 = *(_QWORD *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0) + 80);
    v34 = *((_DWORD *)this + 134);
    v35 = *((_DWORD *)this + 84);
    v36 = *((_DWORD *)this + 133);
    *(_DWORD *)v47 = 136316418;
    *(_QWORD *)&v47[4] = "AUBeam2.cpp";
    *(_WORD *)&v47[12] = 1024;
    *(_DWORD *)&v47[14] = 483;
    *(_WORD *)&v47[18] = 2048;
    *(_QWORD *)&v47[20] = v33;
    *(_WORD *)&v47[28] = 1024;
    *(_DWORD *)&v47[30] = v34;
    *(_WORD *)&v47[34] = 1024;
    *(_DWORD *)&v47[36] = v35;
    v48 = 1024;
    v49 = v36;
    _os_log_impl(&dword_1B5ED0000, v22, OS_LOG_TYPE_DEBUG, "%25s:%-5d Initialize Beam2N object with: sample rate = %f, transform size = %d, frame size = %d, number of beams = %d", v47, 0x2Eu);
  }
LABEL_90:
  v37 = (CmhBEAM2NOpt *)*((_QWORD *)this + 70);
  v38 = ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0);
  if (CmhBEAM2NOpt::initialize(v37, (int)*(double *)(v38 + 80), *((_DWORD *)this + 134), *((_DWORD *)this + 84), valuePtr, *((_DWORD *)this + 133)))
  {
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
    if (AUBeam2LogScope(void)::scope)
    {
      v27 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        return 4294956421;
    }
    else
    {
      v27 = MEMORY[0x1E0C81028];
    }
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      return 4294956421;
    *(_DWORD *)v47 = 136315394;
    *(_QWORD *)&v47[4] = "AUBeam2.cpp";
    *(_WORD *)&v47[12] = 1024;
    *(_DWORD *)&v47[14] = 485;
    v31 = "%25s:%-5d AUBeam2: Error: Failed initializing Beam2N object";
LABEL_121:
    v42 = v27;
    v43 = OS_LOG_TYPE_ERROR;
    goto LABEL_122;
  }
LABEL_96:
  v39 = AUBeam2::SetDiffractionFilterAndPostEQ(this, v28, v29);
  if ((_DWORD)v39)
  {
    v5 = v39;
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
    if (AUBeam2LogScope(void)::scope)
    {
      v40 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        return v5;
    }
    else
    {
      v40 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v47 = 136315394;
      *(_QWORD *)&v47[4] = "AUBeam2.cpp";
      *(_WORD *)&v47[12] = 1024;
      *(_DWORD *)&v47[14] = 497;
      _os_log_impl(&dword_1B5ED0000, v40, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error: Failed setting diffraction filter and post EQ", v47, 0x12u);
    }
  }
  else
  {
    v41 = *((_DWORD *)this + 84);
    if (v41 <= 0x100)
      v41 = 256;
    std::valarray<float>::resize((uint64_t)this + 2760, 4 * v41, 0.0);
    *((_DWORD *)this + 136) = *((_DWORD *)this + 135);
    AUBeam2::ApplyParameterValues(this);
    if (*((_BYTE *)this + 701))
      AUBeam2::DumpDiffractionFilter((_BOOL8)this);
    if (*((_BYTE *)this + 702))
      AUBeam2::DumpPostEQ((_BOOL8)this);
    return 0;
  }
  return v5;
}

void AUBeam2::Cleanup(AUBeam2 *this)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  int v6;
  __int16 v7;
  AUBeam2 *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeam2LogScope(void)::scope + 8) & 1) != 0)
    {
      v2 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (*(_QWORD *)AUBeam2LogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeam2LogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          v3 = 136315650;
          v4 = "AUBeam2.cpp";
          v5 = 1024;
          v6 = 391;
          v7 = 2048;
          v8 = this;
          _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2::Cleanup (%p)", (uint8_t *)&v3, 0x1Cu);
        }
      }
    }
  }
  std::unique_ptr<CmhBEAM>::reset[abi:ne180100]((uint64_t *)this + 69, 0);
  std::unique_ptr<CmhBEAM2NOpt>::reset[abi:ne180100]((CmhBEAM2NOpt **)this + 70, 0);
  std::__optional_destruct_base<BlockProcessor,false>::reset[abi:ne180100]((_BYTE *)this + 568);
}

uint64_t AUBeam2::Reset(AUBeam2 *this)
{
  if (*((_BYTE *)this + 632))
    BlockProcessor::Reset((AUBeam2 *)((char *)this + 568));
  return 0;
}

uint64_t AUBeam2::GetPropertyInfo(AUBeam2 *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  unsigned int v7;
  unsigned int v8;

  if (a3)
    return 4294956417;
  switch(a2)
  {
    case 3700:
    case 3709:
      goto LABEL_10;
    case 3701:
    case 3704:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      goto LABEL_10;
    case 3702:
    case 3703:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      if (!*((_QWORD *)this + 70))
        goto LABEL_18;
      *a6 = 0;
      v8 = *((_DWORD *)this + 134);
      if (v8 <= 1)
        v7 = 0;
      else
        v7 = ((2 * v8) & 0xFFFFFFFC) - 4;
      goto LABEL_17;
    case 3705:
    case 3706:
    case 3707:
    case 3708:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      if (*((_QWORD *)this + 70))
      {
        *a6 = 0;
        v7 = 4 * *((_DWORD *)this + 134);
LABEL_17:
        result = 0;
        *a5 = v7;
      }
      else
      {
LABEL_18:
        result = 4294956429;
      }
      break;
    case 3710:
      *a6 = *((_BYTE *)this + 17) ^ 1;
      v7 = 8;
      goto LABEL_17;
    default:
      if (a2 != 21)
        return 4294956417;
LABEL_10:
      *a6 = 1;
      v7 = 4;
      goto LABEL_17;
  }
  return result;
}

uint64_t AUBeam2::GetProperty(AUBeam2 *this, int a2, int a3, unsigned int a4, _DWORD *__dst)
{
  uint64_t v5;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int *v18;
  int v19;
  int v20;
  uint64_t v21;
  const void **v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  size_t v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int *v35;
  int v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  int v40;

  if (a3)
    return 4294956417;
  switch(a2)
  {
    case 3700:
      v5 = 0;
      v7 = *((unsigned __int8 *)this + 376);
      goto LABEL_43;
    case 3701:
      v5 = *((unsigned __int8 *)this + 548);
      if (*((_BYTE *)this + 548))
        return 4294956417;
      v7 = *((_DWORD *)this + 134);
      goto LABEL_43;
    case 3702:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      v9 = *((_QWORD *)this + 70);
      if (!v9)
        return 4294956429;
      v10 = *((_DWORD *)this + 133);
      if (v10 == 2)
      {
        v31 = *(unsigned int *)(v9 + 8);
        v32 = *(_QWORD *)(v9 + 408);
        if ((int)v31 < 1)
        {
          v37 = 0;
        }
        else
        {
          v33 = 0;
          v34 = 0;
          v35 = (int *)(v32 + 108);
          do
          {
            v36 = *v35;
            v35 += 34;
            if (v36 == 1)
              v34 = v33;
            ++v33;
          }
          while (v31 != v33);
          v37 = v34;
        }
        if (!*(_DWORD *)(v32 + 136 * v37 + 108))
          return 4294956446;
      }
      else if (v10 == 1)
      {
        v11 = *(_DWORD *)(v9 + 8);
        if (v11 >= 1)
          v11 = 1;
        if (!*(_DWORD *)(*(_QWORD *)(v9 + 408) + 136 * v11 - 28))
          return 4294956446;
      }
      v38 = *((_DWORD *)this + 134);
      if (v38 < 2)
        return 0;
      v39 = *(_QWORD *)(v9 + 408);
      v40 = *(_DWORD *)(v9 + 8);
      if (v40 >= 1)
        v40 = 1;
LABEL_73:
      v24 = *(const void **)(v39 + 136 * v40 - 16);
      v29 = 4 * ((v38 >> 1) - 1);
LABEL_53:
      memcpy(__dst, v24, v29);
      return 0;
    case 3703:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      v12 = *((_QWORD *)this + 70);
      if (!v12)
        return 4294956429;
      v13 = *((_DWORD *)this + 133);
      if (v13 == 1)
        return 4294956417;
      if (v13 == 2)
      {
        v14 = *(unsigned int *)(v12 + 8);
        v15 = *(_QWORD *)(v12 + 408);
        if ((int)v14 < 1)
        {
          v20 = 0;
        }
        else
        {
          v16 = 0;
          v17 = 0;
          v18 = (int *)(v15 + 108);
          do
          {
            v19 = *v18;
            v18 += 34;
            if (v19 == 1)
              v17 = v16;
            ++v16;
          }
          while (v14 != v16);
          v20 = v17;
        }
        if (!*(_DWORD *)(v15 + 136 * v20 + 108))
          return 4294956446;
      }
      v38 = *((_DWORD *)this + 134);
      if (v38 < 2)
        return 0;
      v39 = *(_QWORD *)(v12 + 408);
      v40 = *(_DWORD *)(v12 + 8);
      if (v40 >= 2)
        v40 = 2;
      goto LABEL_73;
    case 3704:
      v5 = *((unsigned __int8 *)this + 548);
      if (*((_BYTE *)this + 548))
        return 4294956417;
      v7 = *((_DWORD *)this + 174);
LABEL_43:
      *__dst = v7;
      return v5;
    case 3705:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      v21 = *((_QWORD *)this + 70);
      if (!v21)
        return 4294956429;
      v22 = *(const void ***)(v21 + 784);
      goto LABEL_35;
    case 3706:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      v23 = *((_QWORD *)this + 70);
      if (!v23)
        return 4294956429;
      v22 = *(const void ***)(v23 + 792);
LABEL_35:
      v24 = *v22;
      goto LABEL_52;
    case 3707:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      v25 = *((_QWORD *)this + 70);
      if (!v25)
        return 4294956429;
      if (*((_DWORD *)this + 133) == 1)
        return 4294956417;
      v26 = *(_QWORD *)(v25 + 784);
      goto LABEL_48;
    case 3708:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      v25 = *((_QWORD *)this + 70);
      if (!v25)
        return 4294956429;
      if (*((_DWORD *)this + 133) == 1)
        return 4294956417;
      v26 = *(_QWORD *)(v25 + 792);
LABEL_48:
      v27 = *(_DWORD *)(v25 + 8);
      if (v27 > 2)
        v28 = 1;
      else
        v28 = v27 - 1;
      v24 = *(const void **)(v26 + 8 * v28);
LABEL_52:
      v29 = 4 * *((unsigned int *)this + 134);
      goto LABEL_53;
    case 3709:
      v5 = 0;
      v7 = *((unsigned __int8 *)this + 549);
      goto LABEL_43;
    case 3710:
      v5 = 0;
      *(_QWORD *)__dst = *((_QWORD *)this + 86);
      return v5;
    default:
      if (a2 != 21)
        return 4294956417;
      v8 = (*(uint64_t (**)(AUBeam2 *))(*(_QWORD *)this + 576))(this);
      v5 = 0;
      *__dst = v8;
      return v5;
  }
}

uint64_t AUBeam2::SetProperty(AUBeam2 *this, int a2, int a3, unsigned int a4, CFDictionaryRef *a5, unsigned int a6)
{
  uint64_t result;
  int v9;
  int v10;
  int v11;
  NSObject *v12;
  const void *v13;
  const void *Value;
  _BOOL4 v15;
  const char *v16;
  _BOOL4 v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a3)
    return 4294956417;
  switch(a2)
  {
    case 3700:
      if (a6 < 4)
        return 4294956445;
      result = 0;
      *((_BYTE *)this + 376) = *(_BYTE *)a5;
      return result;
    case 3701:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      if (a6 < 4)
        return 4294956445;
      result = 0;
      *((_DWORD *)this + 134) = *(_DWORD *)a5;
      return result;
    case 3702:
    case 3703:
    case 3705:
    case 3706:
    case 3707:
    case 3708:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      else
        return 4294956431;
    case 3704:
      if (*((_BYTE *)this + 548))
        return 4294956417;
      if (a6 < 4)
        return 4294956445;
      result = 0;
      *((_DWORD *)this + 174) = *(_DWORD *)a5 != 0;
      goto LABEL_20;
    case 3709:
      if (a6 < 4)
        return 4294956445;
      v11 = *(_DWORD *)a5;
      *((_BYTE *)this + 549) = *(_DWORD *)a5 != 0;
      if (v11)
      {
        if (AUBeam2LogScope(void)::once != -1)
          dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
        if (AUBeam2LogScope(void)::scope)
        {
          v12 = *(NSObject **)AUBeam2LogScope(void)::scope;
          if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
            return 0;
        }
        else
        {
          v12 = MEMORY[0x1E0C81028];
        }
        v15 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (v15)
        {
          v18 = 136315394;
          v19 = "AUBeam2.cpp";
          v20 = 1024;
          v21 = 2233;
          v16 = "%25s:%-5d AUBeam2::ReverseMicChannelFlag is set to 1 (AU input mic order {front/side,back}, will not fli"
                "p mic order for BF kernel) ";
LABEL_45:
          _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v18, 0x12u);
          return 0;
        }
      }
      else
      {
        if (AUBeam2LogScope(void)::once != -1)
          dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
        if (AUBeam2LogScope(void)::scope)
        {
          v12 = *(NSObject **)AUBeam2LogScope(void)::scope;
          if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
            return 0;
        }
        else
        {
          v12 = MEMORY[0x1E0C81028];
        }
        v17 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (v17)
        {
          v18 = 136315394;
          v19 = "AUBeam2.cpp";
          v20 = 1024;
          v21 = 2235;
          v16 = "%25s:%-5d AUBeam2::ReverseMicChannelFlag is set to 0 (AU input mic order {back,front/side}, will flip mi"
                "c order for BF kernel)";
          goto LABEL_45;
        }
      }
      return result;
    case 3710:
      if (*((_BYTE *)this + 17))
        return 4294956447;
      v13 = (const void *)*((_QWORD *)this + 86);
      if (v13)
        CFRelease(v13);
      Value = CFDictionaryGetValue(*a5, CFSTR("tuningdata"));
      *((_QWORD *)this + 86) = Value;
      CFRetain(Value);
      return 0;
    default:
      if (a2 != 21)
        return 4294956417;
      if (a6 < 4)
        return 4294956445;
      v9 = *(_DWORD *)a5;
      v10 = *(_DWORD *)a5 != 0;
      if (v10 != (*(unsigned int (**)(AUBeam2 *))(*(_QWORD *)this + 576))(this))
        *((_DWORD *)this + 132) = v9 != 0;
      result = 0;
LABEL_20:
      ++*((_DWORD *)this + 135);
      return result;
  }
}

uint64_t AUBeam2::SetParameter(AUBeam2 *this, unsigned int a2, int a3, uint64_t a4, float a5)
{
  NSObject *v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  uint64_t result;
  uint64_t v14;
  ausdk::AUElement *v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  ausdk::AUElement **v21;
  ausdk::AUElement **v22;
  float v23;
  float v24;
  double v25;
  double v26;
  uint64_t v27;
  CmhBEAM *v28;
  CmhBEAM2NOpt *v29;
  int v30;
  uint64_t v31;
  CmhMicCheck *v32;
  uint64_t v33;
  uint64_t v34;
  ausdk::AUElement *v35;
  uint64_t v36;
  ausdk::AUElement *v37;
  uint64_t v38;
  ausdk::AUElement *v39;
  uint64_t v40;
  ausdk::AUElement *v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  uint64_t v44;
  ausdk::AUElement *v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  uint64_t v50;
  ausdk::AUElement *v51;
  uint64_t v52;
  ausdk::AUElement *v53;
  uint64_t v54;
  ausdk::AUElement *v55;
  uint64_t v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  uint64_t v59;
  ausdk::AUElement *v60;
  uint64_t v61;
  ausdk::AUElement *v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  uint64_t v65;
  ausdk::AUElement *v66;
  uint64_t v67;
  ausdk::AUElement *v68;
  uint64_t v69;
  ausdk::AUElement *v70;
  uint64_t v71;
  ausdk::AUElement *v72;
  uint64_t v73;
  ausdk::AUElement *v74;
  uint64_t v75;
  ausdk::AUElement *v76;
  uint64_t v77;
  ausdk::AUElement *v78;
  uint64_t v79;
  ausdk::AUElement *v80;
  uint64_t v81;
  ausdk::AUElement *v82;
  uint64_t v83;
  ausdk::AUElement *v84;
  uint64_t v85;
  ausdk::AUElement *v86;
  uint64_t v87;
  ausdk::AUElement *v88;
  uint64_t v89;
  ausdk::AUElement *v90;
  uint64_t v91;
  ausdk::AUElement *v92;
  uint64_t v93;
  ausdk::AUElement *v94;
  uint64_t v95;
  ausdk::AUElement *v96;
  uint64_t v97;
  ausdk::AUElement *v98;
  uint64_t v99;
  ausdk::AUElement *v100;
  uint64_t v101;
  ausdk::AUElement *v102;
  uint64_t v103;
  ausdk::AUElement *v104;
  uint64_t v105;
  ausdk::AUElement *v106;
  NSObject *v107;
  uint64_t v108;
  uint64_t v109;
  ausdk::AUElement *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  _BOOL4 v152;
  int v153;
  uint64_t v154;
  int v155;
  int v156;
  uint64_t v157;
  _BOOL4 v158;
  int v159;
  uint64_t v160;
  int v161;
  uint64_t v162;
  uint64_t v163;
  int v164;
  float v165;
  unsigned int v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  unsigned int v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  unsigned int v191;
  int v192;
  uint64_t v193;
  uint64_t v194;
  ausdk::AUElement *v195;
  uint64_t v196;
  float Parameter;
  uint64_t v198;
  ausdk::AUElement *v199;
  uint64_t v200;
  float v201;
  vDSP_Length v202;
  uint64_t Element;
  unsigned int v204;
  vDSP_Length v205;
  float *v206;
  vDSP_Length v207;
  unsigned int v208;
  float *v209;
  vDSP_Length v210;
  float *v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  float v216;
  uint64_t v217;
  int *v218;
  int v219;
  int v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  _DWORD *v238;
  uint64_t v239;
  int v240;
  uint64_t v241;
  int v242;
  uint64_t v243;
  int v244;
  _BOOL4 v245;
  float v246;
  uint8_t buf[4];
  const char *v248;
  __int16 v249;
  int v250;
  __int16 v251;
  AUBeam2 *v252;
  __int16 v253;
  unsigned int v254;
  __int16 v255;
  int v256;
  __int16 v257;
  int v258;
  __int16 v259;
  double v260;
  uint64_t v261;

  v261 = *MEMORY[0x1E0C80C00];
  v246 = a5;
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeam2LogScope(void)::scope + 8) & 1) != 0)
    {
      v10 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (*(_QWORD *)AUBeam2LogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeam2LogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136316674;
          v248 = "AUBeam2.cpp";
          v249 = 1024;
          v250 = 1050;
          v251 = 2048;
          v252 = this;
          v253 = 1024;
          v254 = a2;
          v255 = 1024;
          v256 = a3;
          v257 = 1024;
          v258 = a4;
          v259 = 2048;
          v260 = a5;
          _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2::SetParameter (%p): id = %d, scope=%d, element=%d, inValue = %f", buf, 0x38u);
        }
      }
    }
  }
  v245 = 0;
  if (a3 == 4)
  {
    result = 4294956418;
    switch(a2)
    {
      case 1u:
        v34 = *((_QWORD *)this + 85);
        if (v34)
        {
          v35 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v34 + 32))(v34, a4);
        }
        else
        {
          v111 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v111) >> 3))
            v35 = 0;
          else
            v35 = *(ausdk::AUElement **)(v111 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v35, 1u, v246, 0);
        v149 = 552;
        if (!*((_BYTE *)this + 548))
          v149 = 560;
        if (!*(_QWORD *)((char *)this + v149))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if ((_DWORD)result)
        {
          *(float *)&v25 = v246;
          v245 = v246 != 0.0;
          if (*((_BYTE *)this + 548))
          {
            v28 = (CmhBEAM *)*((_QWORD *)this + 69);
            v29 = (CmhBEAM2NOpt *)&v245;
            v30 = 3;
            goto LABEL_46;
          }
          result = 0;
          *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 70) + 824) + 44) = v246 != 0.0;
        }
        return result;
      case 2u:
        v36 = *((_QWORD *)this + 85);
        if (v36)
        {
          v37 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v36 + 32))(v36, a4);
        }
        else
        {
          v112 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v112) >> 3))
            v37 = 0;
          else
            v37 = *(ausdk::AUElement **)(v112 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v37, 2u, v246, 0);
        v150 = 552;
        if (!*((_BYTE *)this + 548))
          v150 = 560;
        if (!*(_QWORD *)((char *)this + v150))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if ((_DWORD)result)
        {
          *(float *)&v25 = v246;
          v245 = v246 != 0.0;
          if (*((_BYTE *)this + 548))
          {
            v28 = (CmhBEAM *)*((_QWORD *)this + 69);
            v29 = (CmhBEAM2NOpt *)&v245;
            v30 = 66;
            goto LABEL_46;
          }
          result = 0;
          *(_DWORD *)(*((_QWORD *)this + 70) + 240) = v246 != 0.0;
        }
        return result;
      case 3u:
        v38 = *((_QWORD *)this + 85);
        if (v38)
        {
          v39 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v38 + 32))(v38, a4);
        }
        else
        {
          v113 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v113) >> 3))
            v39 = 0;
          else
            v39 = *(ausdk::AUElement **)(v113 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v39, 3u, v246, 0);
        v151 = 552;
        if (!*((_BYTE *)this + 548))
          v151 = 560;
        if (!*(_QWORD *)((char *)this + v151))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if ((_DWORD)result)
        {
          *(float *)&v25 = v246;
          v152 = v246 != 0.0;
          v245 = v152;
          v153 = *((_DWORD *)this + 133);
          if (*((_BYTE *)this + 548))
          {
            if (v153 == 1)
            {
              v28 = (CmhBEAM *)*((_QWORD *)this + 69);
              v29 = (CmhBEAM2NOpt *)&v245;
              v30 = 68;
            }
            else
            {
              if (v153 != 2)
                return 0;
              v28 = (CmhBEAM *)*((_QWORD *)this + 69);
              v29 = (CmhBEAM2NOpt *)&v245;
              v30 = 4;
            }
            goto LABEL_46;
          }
          if (v153 == 1)
          {
            result = 0;
            *(_DWORD *)(*((_QWORD *)this + 70) + 260) = v152;
          }
          else
          {
            if (v153 != 2)
              return 0;
            result = 0;
            v212 = *((_QWORD *)this + 70);
            *(_DWORD *)(v212 + 260) = v152;
            *(_DWORD *)(v212 + 264) = v152;
          }
        }
        return result;
      case 4u:
        v40 = *((_QWORD *)this + 85);
        if (v40)
        {
          v41 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v40 + 32))(v40, a4);
        }
        else
        {
          v114 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v114) >> 3))
            v41 = 0;
          else
            v41 = *(ausdk::AUElement **)(v114 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v41, 4u, v246, 0);
        v154 = 552;
        if (!*((_BYTE *)this + 548))
          v154 = 560;
        if (!*(_QWORD *)((char *)this + v154))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if ((_DWORD)result)
        {
          *(float *)&v25 = v246;
          v245 = v246 != 0.0;
          if (*((_BYTE *)this + 548))
          {
            v28 = (CmhBEAM *)*((_QWORD *)this + 69);
            v29 = (CmhBEAM2NOpt *)&v245;
            v30 = 5;
            goto LABEL_46;
          }
          result = 0;
          *(_DWORD *)(*((_QWORD *)this + 70) + 376) = v246 != 0.0;
        }
        return result;
      case 5u:
        v42 = *((_QWORD *)this + 85);
        if (v42)
        {
          v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v42 + 32))(v42, a4);
        }
        else
        {
          v115 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v115) >> 3))
            v43 = 0;
          else
            v43 = *(ausdk::AUElement **)(v115 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v43, 5u, v246, 0);
        result = 0;
        if (*((_BYTE *)this + 548))
        {
          if (*((_QWORD *)this + 69))
          {
            result = AUBeamNF::IsActivePart(this, a4);
            if ((_DWORD)result)
            {
              *(float *)&v25 = v246;
              v245 = v246 != 0.0;
              v155 = *((_DWORD *)this + 133);
              if (v155 == 1)
              {
                v28 = (CmhBEAM *)*((_QWORD *)this + 69);
                v29 = (CmhBEAM2NOpt *)&v245;
                v30 = 70;
              }
              else
              {
                if (v155 != 2)
                  return 0;
                v28 = (CmhBEAM *)*((_QWORD *)this + 69);
                v29 = (CmhBEAM2NOpt *)&v245;
                v30 = 6;
              }
              goto LABEL_46;
            }
          }
        }
        return result;
      case 6u:
        v44 = *((_QWORD *)this + 85);
        if (v44)
        {
          v45 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v44 + 32))(v44, a4);
        }
        else
        {
          v116 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v116) >> 3))
            v45 = 0;
          else
            v45 = *(ausdk::AUElement **)(v116 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v45, 6u, v246, 0);
        result = 0;
        if (*((_BYTE *)this + 548))
        {
          if (*((_QWORD *)this + 69))
          {
            result = AUBeamNF::IsActivePart(this, a4);
            if ((_DWORD)result)
            {
              v156 = *((_DWORD *)this + 133);
              if (v156 == 1)
              {
                v28 = (CmhBEAM *)*((_QWORD *)this + 69);
                v29 = (CmhBEAM2NOpt *)&v246;
                v30 = 72;
              }
              else
              {
                if (v156 != 2)
                  return 0;
                v28 = (CmhBEAM *)*((_QWORD *)this + 69);
                v29 = (CmhBEAM2NOpt *)&v246;
                v30 = 7;
              }
              goto LABEL_46;
            }
          }
        }
        return result;
      case 7u:
        v46 = *((_QWORD *)this + 85);
        if (v46)
        {
          v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v46 + 32))(v46, a4);
        }
        else
        {
          v117 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v117) >> 3))
            v47 = 0;
          else
            v47 = *(ausdk::AUElement **)(v117 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v47, 7u, v246, 0);
        v157 = 552;
        if (!*((_BYTE *)this + 548))
          v157 = 560;
        if (!*(_QWORD *)((char *)this + v157))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if ((_DWORD)result)
        {
          *(float *)&v25 = v246;
          v158 = v246 != 0.0;
          v245 = v158;
          v159 = *((_DWORD *)this + 133);
          if (*((_BYTE *)this + 548))
          {
            if (v159 == 1)
            {
              v28 = (CmhBEAM *)*((_QWORD *)this + 69);
              v29 = (CmhBEAM2NOpt *)&v245;
              v30 = 74;
            }
            else
            {
              if (v159 != 2)
                return 0;
              v28 = (CmhBEAM *)*((_QWORD *)this + 69);
              v29 = (CmhBEAM2NOpt *)&v245;
              v30 = 39;
            }
            goto LABEL_46;
          }
          if (v159 == 1)
          {
            result = 0;
            v241 = *((_QWORD *)this + 70);
            v242 = *(_DWORD *)(v241 + 8);
            if (v242 >= 1)
              v242 = 1;
            *(_DWORD *)(*(_QWORD *)(v241 + 408) + 136 * v242 - 28) = v158;
          }
          else
          {
            if (v159 != 2)
              return 0;
            v213 = *((_QWORD *)this + 70);
            v214 = *(_QWORD *)(v213 + 408);
            *(_DWORD *)(v214 + 108) = v158;
            if (*(int *)(v213 + 8) < 2)
              return 0;
            result = 0;
            *(_DWORD *)(v214 + 244) = v158;
          }
        }
        return result;
      case 8u:
        v48 = *((_QWORD *)this + 85);
        if (v48)
        {
          v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v48 + 32))(v48, a4);
        }
        else
        {
          v118 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v118) >> 3))
            v49 = 0;
          else
            v49 = *(ausdk::AUElement **)(v118 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v49, 8u, v246, 0);
        v160 = 552;
        if (!*((_BYTE *)this + 548))
          v160 = 560;
        if (!*(_QWORD *)((char *)this + v160))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if ((_DWORD)result)
        {
          v161 = *((_DWORD *)this + 133);
          if (*((_BYTE *)this + 548))
          {
            if (v161 == 1)
            {
              v28 = (CmhBEAM *)*((_QWORD *)this + 69);
              v29 = (CmhBEAM2NOpt *)&v246;
              v30 = 76;
            }
            else
            {
              if (v161 != 2)
                return 0;
              v28 = (CmhBEAM *)*((_QWORD *)this + 69);
              v29 = (CmhBEAM2NOpt *)&v246;
              v30 = 42;
            }
            goto LABEL_46;
          }
          if (v161 == 1)
          {
            result = 0;
            v243 = *((_QWORD *)this + 70);
            v244 = *(_DWORD *)(v243 + 8);
            if (v244 >= 1)
              v244 = 1;
            *(float *)(*(_QWORD *)(v243 + 408) + 136 * v244 - 24) = v246;
          }
          else
          {
            if (v161 != 2)
              return 0;
            v215 = *((_QWORD *)this + 70);
            v216 = v246;
            v217 = *(_QWORD *)(v215 + 408);
            *(float *)(v217 + 112) = v246;
            if (*(int *)(v215 + 8) < 2)
              return 0;
            result = 0;
            *(float *)(v217 + 248) = v216;
          }
        }
        return result;
      case 9u:
        v50 = *((_QWORD *)this + 85);
        if (v50)
        {
          v51 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v50 + 32))(v50, a4);
        }
        else
        {
          v119 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v119) >> 3))
            v51 = 0;
          else
            v51 = *(ausdk::AUElement **)(v119 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v51, 9u, v246, 0);
        v162 = 552;
        if (!*((_BYTE *)this + 548))
          v162 = 560;
        if (!*(_QWORD *)((char *)this + v162))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if ((_DWORD)result)
        {
          if (*((_BYTE *)this + 548))
          {
            v28 = (CmhBEAM *)*((_QWORD *)this + 69);
            v29 = (CmhBEAM2NOpt *)&v246;
            v30 = 35;
            goto LABEL_46;
          }
          CmhBEAM2NOpt::setWNG(*((CmhBEAM2NOpt **)this + 70), v246);
          return 0;
        }
        return result;
      case 0xAu:
      case 0x26u:
      case 0x27u:
        v14 = *((_QWORD *)this + 85);
        if (v14)
        {
          v15 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 32))(v14, a4);
        }
        else
        {
          v33 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v33) >> 3))
            v15 = 0;
          else
            v15 = *(ausdk::AUElement **)(v33 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v15, a2, v246, 0);
        if (AUBeam2LogScope(void)::once != -1)
          dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
        if (AUBeam2LogScope(void)::scope)
        {
          if ((*(_BYTE *)(AUBeam2LogScope(void)::scope + 8) & 1) != 0)
          {
            v107 = *(NSObject **)AUBeam2LogScope(void)::scope;
            if (*(_QWORD *)AUBeam2LogScope(void)::scope)
            {
              if (os_log_type_enabled(*(os_log_t *)AUBeam2LogScope(void)::scope, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136315650;
                v248 = "AUBeam2.cpp";
                v249 = 1024;
                v250 = 1597;
                v251 = 2048;
                v252 = this;
                _os_log_impl(&dword_1B5ED0000, v107, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2::SetBetaVector (%p)", buf, 0x1Cu);
              }
            }
          }
        }
        v108 = 552;
        if (!*((_BYTE *)this + 548))
          v108 = 560;
        if (!*(_QWORD *)((char *)this + v108))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if ((_DWORD)result)
        {
          v109 = *((_QWORD *)this + 85);
          if (v109)
          {
            v110 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v109 + 32))(v109, a4);
          }
          else
          {
            v148 = *((_QWORD *)this + 82);
            if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v148) >> 3))
              v110 = 0;
            else
              v110 = *(ausdk::AUElement **)(v148 + 8 * a4);
          }
          *(_DWORD *)buf = ausdk::AUElement::GetParameter(v110, 0xAu);
          v194 = *((_QWORD *)this + 85);
          if (v194)
          {
            v195 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v194 + 32))(v194, a4);
          }
          else
          {
            v196 = *((_QWORD *)this + 82);
            if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v196) >> 3))
              v195 = 0;
            else
              v195 = *(ausdk::AUElement **)(v196 + 8 * a4);
          }
          Parameter = ausdk::AUElement::GetParameter(v195, 0x27u);
          v198 = *((_QWORD *)this + 85);
          if (v198)
          {
            v199 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v198 + 32))(v198, a4);
          }
          else
          {
            v200 = *((_QWORD *)this + 82);
            if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v200) >> 3))
              v199 = 0;
            else
              v199 = *(ausdk::AUElement **)(v200 + 8 * a4);
          }
          v201 = ausdk::AUElement::GetParameter(v199, 0x26u);
          if (*((_BYTE *)this + 548))
          {
            v202 = *(unsigned int *)(*((_QWORD *)this + 69) + 140);
            vDSP_vfill((const float *)buf, *((float **)this + 345), 1, v202);
            Element = ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0);
            v26 = (float)(2 * v202 - 2);
            v25 = v201 / *(double *)(Element + 80) * v26;
            v204 = v25;
            v29 = (CmhBEAM2NOpt *)*((_QWORD *)this + 345);
            if (v202 > v25)
            {
              v205 = v202 - v204;
              v206 = (float *)((char *)v29 + 4 * v204);
              do
              {
                *v206++ = Parameter;
                --v205;
              }
              while (v205);
            }
            v28 = (CmhBEAM *)*((_QWORD *)this + 69);
            v30 = 46;
            goto LABEL_46;
          }
          v207 = *(unsigned int *)(*((_QWORD *)this + 70) + 28);
          vDSP_vfill((const float *)buf, *((float **)this + 345), 1, v207);
          v208 = (v201
                              / *(double *)(ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0) + 80)
                              * (float)*((unsigned int *)this + 134));
          v209 = (float *)*((_QWORD *)this + 345);
          if (v207 > v208)
          {
            v210 = v207 - v208;
            v211 = &v209[v208];
            do
            {
              *v211++ = Parameter;
              --v210;
            }
            while (v210);
          }
          CmhBEAM2NOpt::setABFVector(*((_QWORD *)this + 70), v209);
          return 0;
        }
        return result;
      case 0xBu:
        v52 = *((_QWORD *)this + 85);
        if (v52)
        {
          v53 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v52 + 32))(v52, a4);
        }
        else
        {
          v120 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v120) >> 3))
            v53 = 0;
          else
            v53 = *(ausdk::AUElement **)(v120 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v53, 0xBu, v246, 0);
        v163 = 552;
        if (!*((_BYTE *)this + 548))
          v163 = 560;
        if (!*(_QWORD *)((char *)this + v163))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if ((_DWORD)result)
        {
          *(float *)&v25 = v246;
          v164 = llroundf(v246);
          v245 = v164;
          if (*((_BYTE *)this + 548))
          {
            v28 = (CmhBEAM *)*((_QWORD *)this + 69);
            v29 = (CmhBEAM2NOpt *)&v245;
            v30 = 78;
            goto LABEL_46;
          }
          result = 0;
          v218 = (int *)*((_QWORD *)this + 70);
          v219 = (int)(float)((float)((float)v164 / (float)v218[3]) * (float)v218[4]);
          v218[8] = v164;
          v220 = v218[6] - 1;
          if (v220 >= v219)
            v220 = v219;
          v218[64] = v220;
        }
        return result;
      case 0xDu:
        v54 = *((_QWORD *)this + 85);
        if (v54)
        {
          v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v54 + 32))(v54, a4);
        }
        else
        {
          v121 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v121) >> 3))
            v55 = 0;
          else
            v55 = *(ausdk::AUElement **)(v121 + 8 * a4);
        }
        v165 = v246;
        v166 = 13;
        goto LABEL_295;
      case 0xEu:
        v56 = *((_QWORD *)this + 85);
        if (v56)
        {
          v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v56 + 32))(v56, a4);
        }
        else
        {
          v122 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v122) >> 3))
            v55 = 0;
          else
            v55 = *(ausdk::AUElement **)(v122 + 8 * a4);
        }
        v165 = v246;
        v166 = 14;
LABEL_295:
        ausdk::AUElement::SetParameter(v55, v166, v165, 0);
        return 0;
      case 0xFu:
        v57 = *((_QWORD *)this + 85);
        if (v57)
        {
          v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v57 + 32))(v57, a4);
        }
        else
        {
          v123 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v123) >> 3))
            v58 = 0;
          else
            v58 = *(ausdk::AUElement **)(v123 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v58, 0xFu, v246, 0);
        v167 = 552;
        if (!*((_BYTE *)this + 548))
          v167 = 560;
        if (!*(_QWORD *)((char *)this + v167))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 83;
          goto LABEL_46;
        }
        v221 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v221 + 464);
        *(float *)&v25 = v246;
        *(float *)(v221 + 504) = v246;
        goto LABEL_48;
      case 0x10u:
        v59 = *((_QWORD *)this + 85);
        if (v59)
        {
          v60 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v59 + 32))(v59, a4);
        }
        else
        {
          v124 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v124) >> 3))
            v60 = 0;
          else
            v60 = *(ausdk::AUElement **)(v124 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v60, 0x10u, v246, 0);
        v168 = 552;
        if (!*((_BYTE *)this + 548))
          v168 = 560;
        if (!*(_QWORD *)((char *)this + v168))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 84;
          goto LABEL_46;
        }
        v222 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v222 + 464);
        *(float *)&v25 = v246;
        *(float *)(v222 + 508) = v246;
        goto LABEL_48;
      case 0x11u:
        v61 = *((_QWORD *)this + 85);
        if (v61)
        {
          v62 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v61 + 32))(v61, a4);
        }
        else
        {
          v125 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v125) >> 3))
            v62 = 0;
          else
            v62 = *(ausdk::AUElement **)(v125 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v62, 0x11u, v246, 0);
        v169 = 552;
        if (!*((_BYTE *)this + 548))
          v169 = 560;
        if (!*(_QWORD *)((char *)this + v169))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 85;
          goto LABEL_46;
        }
        v223 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v223 + 464);
        *(float *)&v25 = v246;
        *(float *)(v223 + 512) = v246;
        goto LABEL_48;
      case 0x12u:
        v63 = *((_QWORD *)this + 85);
        if (v63)
        {
          v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v63 + 32))(v63, a4);
        }
        else
        {
          v126 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v126) >> 3))
            v64 = 0;
          else
            v64 = *(ausdk::AUElement **)(v126 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v64, 0x12u, v246, 0);
        v170 = 552;
        if (!*((_BYTE *)this + 548))
          v170 = 560;
        if (!*(_QWORD *)((char *)this + v170))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 86;
          goto LABEL_46;
        }
        v224 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v224 + 464);
        *(float *)&v25 = v246;
        *(float *)(v224 + 516) = v246;
        goto LABEL_48;
      case 0x13u:
        v65 = *((_QWORD *)this + 85);
        if (v65)
        {
          v66 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v65 + 32))(v65, a4);
        }
        else
        {
          v127 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v127) >> 3))
            v66 = 0;
          else
            v66 = *(ausdk::AUElement **)(v127 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v66, 0x13u, v246, 0);
        v171 = 552;
        if (!*((_BYTE *)this + 548))
          v171 = 560;
        if (!*(_QWORD *)((char *)this + v171))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 87;
          goto LABEL_46;
        }
        v225 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v225 + 464);
        *(float *)&v25 = v246;
        *(float *)(v225 + 520) = v246;
        goto LABEL_48;
      case 0x14u:
        v67 = *((_QWORD *)this + 85);
        if (v67)
        {
          v68 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v67 + 32))(v67, a4);
        }
        else
        {
          v128 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v128) >> 3))
            v68 = 0;
          else
            v68 = *(ausdk::AUElement **)(v128 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v68, 0x14u, v246, 0);
        v172 = 552;
        if (!*((_BYTE *)this + 548))
          v172 = 560;
        if (!*(_QWORD *)((char *)this + v172))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 88;
          goto LABEL_46;
        }
        v226 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v226 + 464);
        *(float *)&v25 = v246;
        *(float *)(v226 + 524) = v246;
        goto LABEL_48;
      case 0x15u:
        v69 = *((_QWORD *)this + 85);
        if (v69)
        {
          v70 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v69 + 32))(v69, a4);
        }
        else
        {
          v129 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v129) >> 3))
            v70 = 0;
          else
            v70 = *(ausdk::AUElement **)(v129 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v70, 0x15u, v246, 0);
        v173 = 552;
        if (!*((_BYTE *)this + 548))
          v173 = 560;
        if (!*(_QWORD *)((char *)this + v173))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 89;
          goto LABEL_46;
        }
        v227 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v227 + 464);
        *(float *)&v25 = v246;
        *(float *)(v227 + 528) = v246;
        goto LABEL_48;
      case 0x16u:
        v71 = *((_QWORD *)this + 85);
        if (v71)
        {
          v72 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v71 + 32))(v71, a4);
        }
        else
        {
          v130 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v130) >> 3))
            v72 = 0;
          else
            v72 = *(ausdk::AUElement **)(v130 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v72, 0x16u, v246, 0);
        v174 = 552;
        if (!*((_BYTE *)this + 548))
          v174 = 560;
        if (!*(_QWORD *)((char *)this + v174))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 90;
          goto LABEL_46;
        }
        v228 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v228 + 464);
        *(float *)&v25 = v246;
        *(float *)(v228 + 532) = v246;
        goto LABEL_48;
      case 0x17u:
        v73 = *((_QWORD *)this + 85);
        if (v73)
        {
          v74 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v73 + 32))(v73, a4);
        }
        else
        {
          v131 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v131) >> 3))
            v74 = 0;
          else
            v74 = *(ausdk::AUElement **)(v131 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v74, 0x17u, v246, 0);
        v175 = 552;
        if (!*((_BYTE *)this + 548))
          v175 = 560;
        if (!*(_QWORD *)((char *)this + v175))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 91;
          goto LABEL_46;
        }
        v229 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v229 + 464);
        *(float *)&v25 = v246;
        *(float *)(v229 + 536) = v246;
        goto LABEL_48;
      case 0x18u:
        v75 = *((_QWORD *)this + 85);
        if (v75)
        {
          v76 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v75 + 32))(v75, a4);
        }
        else
        {
          v132 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v132) >> 3))
            v76 = 0;
          else
            v76 = *(ausdk::AUElement **)(v132 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v76, 0x18u, v246, 0);
        v176 = 552;
        if (!*((_BYTE *)this + 548))
          v176 = 560;
        if (!*(_QWORD *)((char *)this + v176))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 92;
          goto LABEL_46;
        }
        v230 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v230 + 464);
        *(float *)&v25 = v246;
        *(float *)(v230 + 540) = v246;
        goto LABEL_48;
      case 0x19u:
        v77 = *((_QWORD *)this + 85);
        if (v77)
        {
          v78 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v77 + 32))(v77, a4);
        }
        else
        {
          v133 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v133) >> 3))
            v78 = 0;
          else
            v78 = *(ausdk::AUElement **)(v133 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v78, 0x19u, v246, 0);
        v177 = 552;
        if (!*((_BYTE *)this + 548))
          v177 = 560;
        if (!*(_QWORD *)((char *)this + v177))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 93;
          goto LABEL_46;
        }
        v231 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v231 + 464);
        *(float *)&v25 = v246;
        *(float *)(v231 + 544) = v246;
        goto LABEL_48;
      case 0x1Au:
        v79 = *((_QWORD *)this + 85);
        if (v79)
        {
          v80 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v79 + 32))(v79, a4);
        }
        else
        {
          v134 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v134) >> 3))
            v80 = 0;
          else
            v80 = *(ausdk::AUElement **)(v134 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v80, 0x1Au, v246, 0);
        v178 = 552;
        if (!*((_BYTE *)this + 548))
          v178 = 560;
        if (!*(_QWORD *)((char *)this + v178))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 94;
          goto LABEL_46;
        }
        v232 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v232 + 464);
        *(float *)&v25 = v246;
        *(float *)(v232 + 548) = v246;
        goto LABEL_48;
      case 0x1Bu:
        v81 = *((_QWORD *)this + 85);
        if (v81)
        {
          v82 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v81 + 32))(v81, a4);
        }
        else
        {
          v135 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v135) >> 3))
            v82 = 0;
          else
            v82 = *(ausdk::AUElement **)(v135 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v82, 0x1Bu, v246, 0);
        v179 = 552;
        if (!*((_BYTE *)this + 548))
          v179 = 560;
        if (!*(_QWORD *)((char *)this + v179))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 95;
          goto LABEL_46;
        }
        v233 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v233 + 464);
        *(float *)&v25 = v246;
        *(float *)(v233 + 552) = v246;
        goto LABEL_48;
      case 0x1Cu:
        v83 = *((_QWORD *)this + 85);
        if (v83)
        {
          v84 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v83 + 32))(v83, a4);
        }
        else
        {
          v136 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v136) >> 3))
            v84 = 0;
          else
            v84 = *(ausdk::AUElement **)(v136 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v84, 0x1Cu, v246, 0);
        v180 = 552;
        if (!*((_BYTE *)this + 548))
          v180 = 560;
        if (!*(_QWORD *)((char *)this + v180))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 96;
          goto LABEL_46;
        }
        v234 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v234 + 464);
        *(float *)&v25 = v246;
        *(float *)(v234 + 556) = v246;
        goto LABEL_48;
      case 0x1Du:
        v85 = *((_QWORD *)this + 85);
        if (v85)
        {
          v86 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v85 + 32))(v85, a4);
        }
        else
        {
          v137 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v137) >> 3))
            v86 = 0;
          else
            v86 = *(ausdk::AUElement **)(v137 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v86, 0x1Du, v246, 0);
        v181 = 552;
        if (!*((_BYTE *)this + 548))
          v181 = 560;
        if (!*(_QWORD *)((char *)this + v181))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 97;
          goto LABEL_46;
        }
        v235 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v235 + 464);
        *(float *)&v25 = v246;
        *(float *)(v235 + 560) = v246;
        goto LABEL_48;
      case 0x1Eu:
        v87 = *((_QWORD *)this + 85);
        if (v87)
        {
          v88 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v87 + 32))(v87, a4);
        }
        else
        {
          v138 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v138) >> 3))
            v88 = 0;
          else
            v88 = *(ausdk::AUElement **)(v138 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v88, 0x1Eu, v246, 0);
        v182 = 552;
        if (!*((_BYTE *)this + 548))
          v182 = 560;
        if (!*(_QWORD *)((char *)this + v182))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 98;
          goto LABEL_46;
        }
        v236 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v236 + 464);
        *(float *)&v25 = v246;
        *(float *)(v236 + 564) = v246;
        goto LABEL_48;
      case 0x1Fu:
        v89 = *((_QWORD *)this + 85);
        if (v89)
        {
          v90 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v89 + 32))(v89, a4);
        }
        else
        {
          v139 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v139) >> 3))
            v90 = 0;
          else
            v90 = *(ausdk::AUElement **)(v139 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v90, 0x1Fu, v246, 0);
        v183 = 552;
        if (!*((_BYTE *)this + 548))
          v183 = 560;
        if (!*(_QWORD *)((char *)this + v183))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 99;
          goto LABEL_46;
        }
        v237 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v237 + 464);
        *(float *)&v25 = v246;
        *(float *)(v237 + 568) = v246;
        goto LABEL_48;
      case 0x21u:
        v91 = *((_QWORD *)this + 85);
        if (v91)
        {
          v92 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v91 + 32))(v91, a4);
        }
        else
        {
          v140 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v140) >> 3))
            v92 = 0;
          else
            v92 = *(ausdk::AUElement **)(v140 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v92, 0x21u, v246, 0);
        v184 = 552;
        if (!*((_BYTE *)this + 548))
          v184 = 560;
        if (!*(_QWORD *)((char *)this + v184))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        *(float *)&v25 = v246;
        v185 = llroundf(v246);
        v245 = v185;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v245;
          v30 = 81;
          goto LABEL_46;
        }
        v238 = (_DWORD *)*((_QWORD *)this + 70);
        v238[34] = v185;
        v32 = (CmhMicCheck *)(v238 + 116);
        v238[143] = v185;
        goto LABEL_48;
      case 0x22u:
        v93 = *((_QWORD *)this + 85);
        if (v93)
        {
          v94 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v93 + 32))(v93, a4);
        }
        else
        {
          v141 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v141) >> 3))
            v94 = 0;
          else
            v94 = *(ausdk::AUElement **)(v141 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v94, 0x22u, v246, 0);
        v186 = 552;
        if (!*((_BYTE *)this + 548))
          v186 = 560;
        if (!*(_QWORD *)((char *)this + v186))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 103;
          goto LABEL_46;
        }
        result = 0;
        *(float *)(*((_QWORD *)this + 70) + 380) = v246;
        return result;
      case 0x23u:
        v95 = *((_QWORD *)this + 85);
        if (v95)
        {
          v96 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v95 + 32))(v95, a4);
        }
        else
        {
          v142 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v142) >> 3))
            v96 = 0;
          else
            v96 = *(ausdk::AUElement **)(v142 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v96, 0x23u, v246, 0);
        v187 = 552;
        if (!*((_BYTE *)this + 548))
          v187 = 560;
        if (!*(_QWORD *)((char *)this + v187))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 104;
          goto LABEL_46;
        }
        result = 0;
        v239 = *((_QWORD *)this + 70);
        v240 = (int)(float)((float)(v246 / (float)*(int *)(v239 + 12)) * (float)*(int *)(v239 + 16));
        if (*(_DWORD *)(v239 + 24) - 1 < v240)
          v240 = *(_DWORD *)(v239 + 24) - 1;
        *(float *)(v239 + 140) = v246;
        *(float *)(v239 + 384) = (float)v240;
        return result;
      case 0x24u:
        v97 = *((_QWORD *)this + 85);
        if (v97)
        {
          v98 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v97 + 32))(v97, a4);
        }
        else
        {
          v143 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v143) >> 3))
            v98 = 0;
          else
            v98 = *(ausdk::AUElement **)(v143 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v98, 0x24u, v246, 0);
        v188 = 552;
        if (!*((_BYTE *)this + 548))
          v188 = 560;
        if (!*(_QWORD *)((char *)this + v188))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 105;
          goto LABEL_46;
        }
        result = 0;
        *(float *)(*((_QWORD *)this + 70) + 388) = v246;
        return result;
      case 0x25u:
        v99 = *((_QWORD *)this + 85);
        if (v99)
        {
          v100 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v99 + 32))(v99, a4);
        }
        else
        {
          v144 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v144) >> 3))
            v100 = 0;
          else
            v100 = *(ausdk::AUElement **)(v144 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v100, 0x25u, v246, 0);
        v189 = 552;
        if (!*((_BYTE *)this + 548))
          v189 = 560;
        if (!*(_QWORD *)((char *)this + v189))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v246;
          v30 = 106;
          goto LABEL_46;
        }
        result = 0;
        *(float *)(*((_QWORD *)this + 70) + 392) = v246;
        return result;
      case 0x28u:
        v101 = *((_QWORD *)this + 85);
        if (v101)
        {
          v102 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v101 + 32))(v101, a4);
        }
        else
        {
          v145 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v145) >> 3))
            v102 = 0;
          else
            v102 = *(ausdk::AUElement **)(v145 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v102, 0x28u, v246, 0);
        v190 = 552;
        if (!*((_BYTE *)this + 548))
          v190 = 560;
        if (!*(_QWORD *)((char *)this + v190))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        *(float *)&v25 = v246;
        v191 = llroundf(v246);
        v245 = v191;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v245;
          v30 = 107;
          goto LABEL_46;
        }
        result = 0;
        *(_DWORD *)(*((_QWORD *)this + 70) + 144) = v191;
        return result;
      case 0x29u:
        v103 = *((_QWORD *)this + 85);
        if (v103)
        {
          v104 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v103 + 32))(v103, a4);
        }
        else
        {
          v146 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v146) >> 3))
            v104 = 0;
          else
            v104 = *(ausdk::AUElement **)(v146 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v104, 0x29u, v246, 0);
        result = 0;
        if (!*((_BYTE *)this + 548))
          return result;
        if (!*((_QWORD *)this + 69))
          return result;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        v192 = *((_DWORD *)this + 133);
        if (v192 != 1 && v192 != 2)
          return 0;
        v28 = (CmhBEAM *)*((_QWORD *)this + 69);
        v29 = (CmhBEAM2NOpt *)&v246;
        v30 = 101;
        goto LABEL_46;
      case 0x2Au:
        v105 = *((_QWORD *)this + 85);
        if (v105)
        {
          v106 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v105 + 32))(v105, a4);
        }
        else
        {
          v147 = *((_QWORD *)this + 82);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 83) - v147) >> 3))
            v106 = 0;
          else
            v106 = *(ausdk::AUElement **)(v147 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v106, 0x2Au, v246, 0);
        v193 = 552;
        if (!*((_BYTE *)this + 548))
          v193 = 560;
        if (!*(_QWORD *)((char *)this + v193))
          return 0;
        result = AUBeamNF::IsActivePart(this, a4);
        if (!(_DWORD)result)
          return result;
        *(float *)&v25 = v246;
        v245 = v246 != 0.0;
        if (*((_BYTE *)this + 548))
        {
          v28 = (CmhBEAM *)*((_QWORD *)this + 69);
          v29 = (CmhBEAM2NOpt *)&v245;
          v30 = 43;
          goto LABEL_46;
        }
        result = 0;
        *(_DWORD *)(*((_QWORD *)this + 70) + 284) = v246 != 0.0;
        break;
      default:
        return result;
    }
  }
  else if (a3)
  {
    return 4294956430;
  }
  else if (a2 == 32)
  {
    v16 = *((_QWORD *)this + 9);
    if (v16)
    {
      v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
    }
    else
    {
      v21 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v21)
        v17 = 0;
      else
        v17 = *v21;
    }
    v24 = 1.0;
    if (v246 == 0.0)
      v24 = 0.0;
    ausdk::AUElement::SetParameter(v17, 0x20u, v24, 0);
    result = 0;
    if (!*((_BYTE *)this + 548) && *((_QWORD *)this + 70))
    {
      result = 0;
      *(_DWORD *)(*((_QWORD *)this + 70) + 120) = v246 != 0.0;
    }
  }
  else if (a2 == 12)
  {
    v18 = *((_QWORD *)this + 9);
    if (v18)
    {
      v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
    }
    else
    {
      v22 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v22)
        v19 = 0;
      else
        v19 = *v22;
    }
    ausdk::AUElement::SetParameter(v19, 0xCu, v246, 0);
    v27 = 552;
    if (!*((_BYTE *)this + 548))
      v27 = 560;
    if (*(_QWORD *)((char *)this + v27))
    {
      if (*((_BYTE *)this + 548))
      {
        v28 = (CmhBEAM *)*((_QWORD *)this + 69);
        v29 = (CmhBEAM2NOpt *)&v246;
        v30 = 67;
LABEL_46:
        CmhBEAM::setParameter(v28, v30, v29, v25, v26);
      }
      else
      {
        v31 = *((_QWORD *)this + 70);
        v32 = (CmhMicCheck *)(v31 + 464);
        *(float *)&v25 = v246;
        *(float *)(v31 + 500) = v246;
LABEL_48:
        CmhMicCheck::init_check_mics(v32, v25, v26);
      }
    }
    return 0;
  }
  else if (a2)
  {
    return 4294956418;
  }
  else
  {
    v11 = *((_QWORD *)this + 9);
    if (v11)
    {
      v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
    }
    else
    {
      v20 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v20)
        v12 = 0;
      else
        v12 = *v20;
    }
    v23 = 1.0;
    if (v246 == 0.0)
      v23 = 0.0;
    ausdk::AUElement::SetParameter(v12, 0, v23, 0);
    result = 0;
    ++*((_DWORD *)this + 135);
  }
  return result;
}

uint64_t AUBeam2::CanScheduleParameters(AUBeam2 *this)
{
  return 0;
}

uint64_t AUBeam2::ProcessBufferLists(AUBeam2 *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, unsigned int a5)
{
  int v5;
  uint64_t v6;
  int v11;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  float v19;
  uint64_t v20;
  ausdk::AUElement *v21;
  ausdk::AUElement **v22;
  NSObject *v23;
  uint64_t Parameter;
  int v25;
  DSPSplitComplex v26;
  _BYTE buf[24];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = *((unsigned __int8 *)this + 548);
  v6 = 552;
  if (!*((_BYTE *)this + 548))
    v6 = 560;
  if (!*(_QWORD *)((char *)this + v6))
    return 4294956429;
  v11 = *((_DWORD *)this + 135);
  if (v11 != *((_DWORD *)this + 136))
  {
    AUBeam2::ApplyParameterValues(this);
    *((_DWORD *)this + 136) = v11;
    v5 = *((unsigned __int8 *)this + 548);
  }
  if (!v5)
  {
    if (*((_DWORD *)this + 84) == a5)
    {
      v13 = *((unsigned __int8 *)this + 549);
      *(_QWORD *)buf = a3->mBuffers[*((_BYTE *)this + 549) == 0].mData;
      *(_QWORD *)&buf[8] = *(_QWORD *)buf + 4 * a5;
      *(_QWORD *)&buf[16] = a3->mBuffers[v13].mData;
      v28 = *(_QWORD *)&buf[16] + 4 * a5;
      v26.realp = (float *)a4->mBuffers[0].mData;
      v26.imagp = &v26.realp[a5];
      CmhBEAM2NOpt::process(*((CmhBEAM2NOpt **)this + 70), (const DSPSplitComplex *)buf, &v26);
      goto LABEL_11;
    }
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
    if (AUBeam2LogScope(void)::scope)
    {
      v23 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        return 4294956418;
    }
    else
    {
      v23 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v25 = *((_DWORD *)this + 84);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "AUBeam2.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2317;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = a5;
      LOWORD(v28) = 1024;
      *(_DWORD *)((char *)&v28 + 2) = v25;
      _os_log_impl(&dword_1B5ED0000, v23, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error: inFramesToProcess != GetMaxFramesPerSlice(), inFramesToProcess = %d, GetMaxFramesPerSlice() = %d", buf, 0x1Eu);
    }
    return 4294956418;
  }
  *(_QWORD *)buf = a3;
  v26.realp = (float *)&a4->mNumberBuffers;
  BlockProcessor::Process((AUBeam2 *)((char *)this + 568), a5, (const AudioBufferList **)buf, (AudioBufferList **)&v26);
LABEL_11:
  if (*((_BYTE *)this + 548))
  {
    v14 = *((_QWORD *)this + 69);
    v15 = (int *)(v14 + 404);
    v16 = v14 + 1096;
  }
  else
  {
    v17 = *((_QWORD *)this + 70);
    v15 = (int *)(v17 + 132);
    v16 = v17 + 824;
  }
  v18 = *v15;
  v19 = *(float *)(*(_QWORD *)v16 + 16);
  v20 = *((_QWORD *)this + 9);
  if (v20)
  {
    v21 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 32))(v20, 0);
  }
  else
  {
    v22 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v22)
      v21 = 0;
    else
      v21 = *v22;
  }
  Parameter = ausdk::AUElement::GetParameter(v21, 0);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, uint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 14, 4, Parameter, 0, (float)v18);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, uint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 13, 4, Parameter, 0, v19 * 4.0);
  return 0;
}

uint64_t AUBeam2::ProcessMultipleBufferLists(AUBeam2 *this, unsigned int *a2, uint64_t a3, int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7)
{
  if (a4 == 1 && a6 == 1)
    return (*(uint64_t (**)(AUBeam2 *, unsigned int *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)this + 176))(this, a2, *a5, *a7, a3);
  else
    return 4294956428;
}

uint64_t AUBeam2::Render(AUBeam2 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUInputElement *Element;
  uint64_t result;
  uint64_t v10;
  uint64_t BufferList;
  uint64_t v12;
  uint64_t v13;

  if (!ausdk::AUBase::HasInput(this, 0))
    return 4294956420;
  Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0);
  result = ausdk::AUInputElement::PullInput(Element, a2, a3, 0, a4);
  if (!(_DWORD)result)
  {
    v10 = ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 80), 0);
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    v12 = ausdk::AUScope::SafeGetElement((AUBeam2 *)((char *)this + 128), 0);
    v13 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v12 + 144));
    return (*(uint64_t (**)(AUBeam2 *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 176))(this, a2, BufferList, v13, a4);
  }
  return result;
}

uint64_t AUBeam2::GetParameterInfo(AUBeam2 *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  AudioUnitParameterUnit v6;
  const __CFString *v8;
  AudioUnitParameterOptions v9;
  const __CFString *v10;
  AudioUnitParameterValue v11;
  const __CFString *v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  AudioUnitParameterOptions v16;
  AudioUnitParameterValue v17;
  uint64_t v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;

  buffer->flags = -1073741824;
  buffer->unitName = 0;
  if (a2 == 4)
  {
    result = 4294956418;
    switch(a3)
    {
      case 1:
        v8 = CFSTR("Front-end Calibration Enable");
        goto LABEL_67;
      case 2:
        v8 = CFSTR("Fixed Beamformer Enable");
        goto LABEL_67;
      case 3:
        v12 = CFSTR("Adaptive Beamformer Enable");
        goto LABEL_22;
      case 4:
        v8 = CFSTR("Electronic Wind Screen Enable");
        goto LABEL_67;
      case 5:
        if (!*((_BYTE *)this + 548))
          return result;
        v12 = CFSTR("Long-Term Noise Suppression Enable");
LABEL_22:
        buffer->cfNameString = v12;
        buffer->flags = -939524096;
        CFStringGetCString(v12, buffer->name, 52, 0x8000100u);
        result = 0;
        v6 = kAudioUnitParameterUnit_Boolean;
        goto LABEL_23;
      case 6:
        if (!*((_BYTE *)this + 548))
          return result;
        buffer->cfNameString = CFSTR("Long-Term Noise Suppression Min Gain");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Long-Term Noise Suppression Min Gain"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v13 = 0x3F8000003EB5C28FLL;
        goto LABEL_57;
      case 7:
        v12 = CFSTR("Spatial Noise Suppression Active");
        goto LABEL_22;
      case 8:
        buffer->cfNameString = CFSTR("Spatial Noise Suppression Max Attenuation");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Spatial Noise Suppression Max Attenuation"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v13 = 0x3F8000003E000000;
        goto LABEL_57;
      case 9:
        buffer->cfNameString = CFSTR("White Noise Gain");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("White Noise Gain"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x40400000C2C80000;
        v11 = -100.0;
        goto LABEL_69;
      case 10:
        v15 = CFSTR("Beta");
        goto LABEL_61;
      case 11:
        buffer->cfNameString = CFSTR("Adaptation End Frequency");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Adaptation End Frequency"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        goto LABEL_59;
      case 13:
        buffer->cfNameString = CFSTR("Front End Calibration Gain");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Front End Calibration Gain"), buffer->name, 52, 0x8000100u);
        result = 0;
        v16 = buffer->flags & 0x3FFF7FFF | 0x40008000;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x400000003F000000;
        v17 = 1.0;
        goto LABEL_31;
      case 14:
        buffer->cfNameString = CFSTR("Mic Status Name");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Mic Status Name"), buffer->name, 52, 0x8000100u);
        result = 0;
        v16 = buffer->flags & 0x3FFF7FFF | 0x40008000;
        buffer->unit = kAudioUnitParameterUnit_Indexed;
        *(_QWORD *)&buffer->minValue = 0x40A0000000000000;
        v17 = 5.0;
LABEL_31:
        buffer->defaultValue = v17;
        buffer->flags = v16;
        return result;
      case 15:
        v10 = CFSTR("Nominal Mic Programmable Gain");
        goto LABEL_12;
      case 16:
        buffer->cfNameString = CFSTR("Bad Mic Hysteresis");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Bad Mic Hysteresis"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x447A000000000000;
        v11 = 145.0;
        goto LABEL_69;
      case 17:
        buffer->cfNameString = CFSTR("Index for desired EWIND deflection coefficient");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Index for desired EWIND deflection coefficient"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x459C400000000000;
        v11 = 4.0;
        goto LABEL_69;
      case 18:
        buffer->cfNameString = CFSTR("Time-constant in s for log-spectrum estimation");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Time-constant in s for log-spectrum estimation"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v18 = 0x42C8000000000000;
        goto LABEL_68;
      case 19:
        buffer->cfNameString = CFSTR("Threshold for discriminating wind noise and occlusion");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Threshold for discriminating wind noise and occlusion"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x4348000000000000;
        v11 = 45.0;
        goto LABEL_69;
      case 20:
        buffer->cfNameString = CFSTR("High-frequency threshold for discriminating wind noise and occlusion");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("High-frequency threshold for discriminating wind noise and occlusion"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x4348000000000000;
        v11 = 90.0;
        goto LABEL_69;
      case 21:
        v19 = CFSTR("Threshold for difference noise envelopes during occlusion detection");
        goto LABEL_40;
      case 22:
        v19 = CFSTR("Threshold for difference noise envelopes during wind detection");
LABEL_40:
        buffer->cfNameString = v19;
        buffer->flags = -939524096;
        CFStringGetCString(v19, buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x461C400000000000;
        v11 = 3072.0;
        goto LABEL_69;
      case 23:
        buffer->cfNameString = CFSTR("Lower bound for spectral estimators");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Lower bound for spectral estimators"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
        v11 = 9.3132e-13;
        goto LABEL_69;
      case 24:
        v20 = CFSTR("Difference threshold between microphones");
        goto LABEL_46;
      case 25:
        buffer->cfNameString = CFSTR("Maximum absolute level allowed for inactive (failed) microphone");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Maximum absolute level allowed for inactive (failed) microphone"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x46C80000C6C80000;
        v11 = -2304.0;
        goto LABEL_69;
      case 26:
        buffer->cfNameString = CFSTR("R-statistic threshold relative full scale in Q8");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("R-statistic threshold relative full scale in Q8"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 3323740160;
        v11 = -512.0;
        goto LABEL_69;
      case 27:
        v20 = CFSTR("Difference threshold beam microphone and beam power");
LABEL_46:
        buffer->cfNameString = v20;
        buffer->flags = -939524096;
        CFStringGetCString(v20, buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x461C400000000000;
        v11 = 768.0;
        goto LABEL_69;
      case 28:
        buffer->cfNameString = CFSTR("Frequency for detection statistic of probability of occlusion");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Frequency for detection statistic of probability of occlusion"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x459C400000000000;
        v11 = 250.0;
        goto LABEL_69;
      case 29:
        buffer->cfNameString = CFSTR("Frequency for detection statistic of probability of occlusion");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Frequency for detection statistic of probability of occlusion"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x459C400000000000;
        v11 = 1625.0;
        goto LABEL_69;
      case 30:
        v21 = CFSTR("Frequency for detection statistic of probability of failed microphone");
        goto LABEL_51;
      case 31:
        v21 = CFSTR("Frequency for detection statistic of probability of occluded noisy microphone");
LABEL_51:
        buffer->cfNameString = v21;
        buffer->flags = -939524096;
        CFStringGetCString(v21, buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x459C400000000000;
        v11 = 800.0;
        goto LABEL_69;
      case 33:
        v22 = CFSTR("Default mic for ewind/occlusion");
        goto LABEL_63;
      case 34:
        v15 = CFSTR("Ewind cross-fade coefficient");
        goto LABEL_61;
      case 35:
        buffer->cfNameString = CFSTR("Ewind cross-fade start frequency");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Ewind cross-fade start frequency"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Hertz;
        *(_QWORD *)&buffer->minValue = 0x46BB800000000000;
        v11 = 2500.0;
        goto LABEL_69;
      case 36:
        buffer->cfNameString = CFSTR("Ewind cross-fade high thd");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Ewind cross-fade high thd"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
        v11 = 0.7;
        goto LABEL_69;
      case 37:
        buffer->cfNameString = CFSTR("Ewind cross-fade low thd");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Ewind cross-fade low thd"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v13 = 0x3F80000000000000;
LABEL_57:
        *(_QWORD *)&buffer->minValue = v13;
        v11 = 0.5;
        goto LABEL_69;
      case 38:
        buffer->cfNameString = CFSTR("Beta switch frequency");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Beta switch frequency"), buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Hertz;
LABEL_59:
        *(_QWORD *)&buffer->minValue = 0x46BB800000000000;
        v11 = 24000.0;
        goto LABEL_69;
      case 39:
        v15 = CFSTR("High-frequency beta");
LABEL_61:
        buffer->cfNameString = v15;
        buffer->flags = -939524096;
        CFStringGetCString(v15, buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v14 = 0x3F800000BF800000;
        goto LABEL_24;
      case 40:
        v22 = CFSTR("Mic choice above adaptation end frequency");
LABEL_63:
        buffer->cfNameString = v22;
        buffer->flags = -939524096;
        CFStringGetCString(v22, buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Indexed;
        v14 = 0x4000000000000000;
        goto LABEL_24;
      case 41:
        if (!*((_BYTE *)this + 548))
          return result;
        v8 = CFSTR("Frequency EQ Enable");
LABEL_67:
        buffer->cfNameString = v8;
        buffer->flags = -939524096;
        CFStringGetCString(v8, buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Boolean;
        v18 = 0x3F80000000000000;
LABEL_68:
        *(_QWORD *)&buffer->minValue = v18;
        v11 = 1.0;
        break;
      case 42:
        v8 = CFSTR("Use Standard Adaptive Beamformer");
        goto LABEL_67;
      default:
        return result;
    }
    goto LABEL_69;
  }
  if (a2)
    return 4294956430;
  if (a3 == 32)
  {
    buffer->cfNameString = CFSTR("Flag to say there is high far-end (echo) activity");
    buffer->flags = -939524096;
    CFStringGetCString(CFSTR("Flag to say there is high far-end (echo) activity"), buffer->name, 52, 0x8000100u);
    result = 0;
    buffer->unit = kAudioUnitParameterUnit_Generic;
    *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
    v9 = buffer->flags & 0x3FFF7FFF | 0x40008000;
    buffer->defaultValue = 0.0;
    buffer->flags = v9;
    return result;
  }
  if (a3 == 12)
  {
    v10 = CFSTR("Mic Programmable Gain");
LABEL_12:
    buffer->cfNameString = v10;
    buffer->flags = -939524096;
    CFStringGetCString(v10, buffer->name, 52, 0x8000100u);
    result = 0;
    buffer->unit = kAudioUnitParameterUnit_Generic;
    *(_QWORD *)&buffer->minValue = 0x42200000C2200000;
    v11 = 26.0;
LABEL_69:
    buffer->defaultValue = v11;
    return result;
  }
  if (a3)
    return 4294956418;
  buffer->cfNameString = CFSTR("Beam Index");
  buffer->flags = -939524096;
  CFStringGetCString(CFSTR("Beam Index"), buffer->name, 52, 0x8000100u);
  result = 0;
  v6 = kAudioUnitParameterUnit_Indexed;
LABEL_23:
  buffer->unit = v6;
  v14 = 0x3F80000000000000;
LABEL_24:
  *(_QWORD *)&buffer->minValue = v14;
  buffer->defaultValue = 0.0;
  return result;
}

UInt8 *AUBeam2::SaveExtendedScopes(AUBeam2 *this, __CFData *a2)
{
  ausdk::AUScope *Scope;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);
  return ausdk::AUScope::SaveState(Scope, a2);
}

uint64_t AUBeam2::RestoreState(OpaqueAudioComponentInstance **this, CFTypeRef cf)
{
  CFTypeID v4;
  uint64_t result;
  OpaqueAudioComponentInstance *v6;
  OpaqueAudioComponentInstance *Value;

  v4 = CFGetTypeID(cf);
  if (v4 != CFDictionaryGetTypeID())
    return 4294956445;
  if (CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("data")))
  {
    result = ausdk::AUBase::RestoreState(this, cf);
    if (!(_DWORD)result)
      ++*((_DWORD *)this + 135);
  }
  else
  {
    result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("tuningdata"));
    if (result)
    {
      if (*((_BYTE *)this + 17))
      {
        return 4294956447;
      }
      else
      {
        v6 = this[86];
        if (v6)
          CFRelease(v6);
        Value = (OpaqueAudioComponentInstance *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("tuningdata"));
        this[86] = Value;
        CFRetain(Value);
        return 0;
      }
    }
  }
  return result;
}

uint64_t AUBeam2::GetParameterValueStrings(AUBeam2 *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  const __CFArray *v6;
  void *values[3];

  values[2] = *(void **)MEMORY[0x1E0C80C00];
  if (a2)
    return 4294956430;
  result = 0;
  if (!a3)
  {
    if (a4)
    {
      values[0] = CFSTR("Front Beam");
      values[1] = CFSTR("Back Beam");
      v6 = CFArrayCreate(0, (const void **)values, 2, 0);
      result = 0;
      *a4 = v6;
    }
  }
  return result;
}

double AUBeam2::GetLatency(AUBeam2 *this)
{
  return 0.032;
}

double AUBeam2::GetTailTime(AUBeam2 *this)
{
  return 0.0;
}

uint64_t AUBeam2::SupportsTail(AUBeam2 *this)
{
  return 1;
}

BOOL AUBeam2::StreamFormatWritable(AUBeam2 *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUBeam2::SupportedNumChannels(AUBeam2 *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUBeam2::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

uint64_t AUBeam2::ValidFormat(AUBeam2 *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  uint64_t result;
  int v7;
  AudioFormatID mFormatID;
  BOOL v9;
  __int128 v10;
  unsigned int v11;
  unsigned int v12;
  _OWORD v13[2];
  uint64_t v14;
  BOOL v15;
  int v16;

  result = 0;
  v15 = 0;
  if (a4->mSampleRate >= 8000.0 && a4->mSampleRate <= 96000.0)
  {
    v7 = *((unsigned __int8 *)this + 548);
    mFormatID = a4->mFormatID;
    if (v7)
      v9 = mFormatID == 1819304813;
    else
      v9 = 1;
    if (v9 && (v7 || mFormatID == 1718773105))
    {
      if (v7)
      {
        result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
        if ((_DWORD)result)
          return (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
      }
      else
      {
        v10 = *(_OWORD *)&a4->mBytesPerPacket;
        v13[0] = *(_OWORD *)&a4->mSampleRate;
        v13[1] = v10;
        v14 = *(_QWORD *)&a4->mBitsPerChannel;
        DWORD2(v13[0]) = 1819304813;
        v16 = 0;
        v11 = CAStreamBasicDescription::IdentifyCommonPCMFormat(v13, &v16, &v15);
        if (v16 == 4)
          v12 = v11;
        else
          v12 = 0;
        if (v15)
          return 0;
        else
          return v12;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t AUBeam2::GetScopeExtended(AUBeam2 *this, int a2)
{
  if (a2 == 4)
    return (uint64_t)this + 640;
  else
    return 0;
}

BOOL AUBeam2::ShouldBypassEffect(AUBeam2 *this)
{
  return *((_DWORD *)this + 132) != 0;
}

void AUBeam2::ApplyParameterValues(AUBeam2 *this)
{
  NSObject *v2;
  uint64_t v3;
  ausdk::AUElement *v4;
  ausdk::AUElement **v5;
  float Parameter;
  unint64_t v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  double v11;
  double v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  uint64_t v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  uint64_t v31;
  ausdk::AUElement *v32;
  ausdk::AUElement **v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  uint64_t v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  double v61;
  double v62;
  CmhBEAM *v63;
  _DWORD *v64;
  unsigned int v65;
  const char *v66;
  __int16 v67;
  int v68;
  __int16 v69;
  AUBeam2 *v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeam2LogScope(void)::scope + 8) & 1) != 0)
    {
      v2 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (*(_QWORD *)AUBeam2LogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeam2LogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          v65 = 136315650;
          v66 = "AUBeam2.cpp";
          v67 = 1024;
          v68 = 1855;
          v69 = 2048;
          v70 = this;
          _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2::ApplyParameterValues (%p)", (uint8_t *)&v65, 0x1Cu);
        }
      }
    }
  }
  v3 = *((_QWORD *)this + 9);
  if (v3)
  {
    v4 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 32))(v3, 0);
  }
  else
  {
    v5 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v5)
      v4 = 0;
    else
      v4 = *v5;
  }
  Parameter = ausdk::AUElement::GetParameter(v4, 0);
  v7 = Parameter;
  v65 = Parameter;
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  *(float *)&v11 = ausdk::AUElement::GetParameter(v9, 0x20u);
  v13 = *(float *)&v11;
  v14 = 552;
  if (!*((_BYTE *)this + 548))
    v14 = 560;
  if (*(_QWORD *)((char *)this + v14))
  {
    if (*((_BYTE *)this + 548))
    {
      CmhBEAM::setParameter(*((CmhBEAM **)this + 69), 45, (CmhBEAM2NOpt *)&v65, v11, v12);
    }
    else if (v7 <= 1)
    {
      *(_DWORD *)(*((_QWORD *)this + 70) + 4) = v7;
    }
  }
  (*(void (**)(AUBeam2 *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 32, 0, 0, 0, (float)v13);
  v15 = *((_QWORD *)this + 85);
  if (v15)
  {
    v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v15 + 32))(v15, v7);
  }
  else
  {
    v17 = *((_QWORD *)this + 82);
    if (v7 >= (*((_QWORD *)this + 83) - v17) >> 3)
      v16 = 0;
    else
      v16 = *(ausdk::AUElement **)(v17 + 8 * v7);
  }
  v18 = ausdk::AUElement::GetParameter(v16, 1u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 1, 4, v7, 0, v18);
  v19 = ausdk::AUElement::GetParameter(v16, 2u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 2, 4, v7, 0, v19);
  v20 = ausdk::AUElement::GetParameter(v16, 3u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 3, 4, v7, 0, v20);
  v21 = ausdk::AUElement::GetParameter(v16, 0x2Au);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 42, 4, v7, 0, v21);
  v22 = ausdk::AUElement::GetParameter(v16, 4u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 4, 4, v7, 0, v22);
  if (*((_BYTE *)this + 548))
  {
    v23 = ausdk::AUElement::GetParameter(v16, 5u);
    (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 5, 4, v7, 0, v23);
    v24 = ausdk::AUElement::GetParameter(v16, 6u);
    (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 6, 4, v7, 0, v24);
    v25 = ausdk::AUElement::GetParameter(v16, 0x29u);
    (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 41, 4, v7, 0, v25);
  }
  v26 = ausdk::AUElement::GetParameter(v16, 7u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 7, 4, v7, 0, v26);
  v27 = ausdk::AUElement::GetParameter(v16, 8u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 8, 4, v7, 0, v27);
  v28 = ausdk::AUElement::GetParameter(v16, 9u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 9, 4, v7, 0, v28);
  v29 = ausdk::AUElement::GetParameter(v16, 0xAu);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 10, 4, v7, 0, v29);
  v30 = ausdk::AUElement::GetParameter(v16, 0xBu);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 11, 4, v7, 0, v30);
  v31 = *((_QWORD *)this + 9);
  if (v31)
  {
    v32 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v31 + 32))(v31, 0);
  }
  else
  {
    v33 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v33)
      v32 = 0;
    else
      v32 = *v33;
  }
  v34 = ausdk::AUElement::GetParameter(v32, 0xCu);
  (*(void (**)(AUBeam2 *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 12, 0, 0, 0, v34);
  v35 = ausdk::AUElement::GetParameter(v16, 0xFu);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 15, 4, v7, 0, v35);
  v36 = ausdk::AUElement::GetParameter(v16, 0x10u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 16, 4, v7, 0, v36);
  v37 = ausdk::AUElement::GetParameter(v16, 0x11u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 17, 4, v7, 0, v37);
  v38 = ausdk::AUElement::GetParameter(v16, 0x12u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 18, 4, v7, 0, v38);
  v39 = ausdk::AUElement::GetParameter(v16, 0x13u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 19, 4, v7, 0, v39);
  v40 = ausdk::AUElement::GetParameter(v16, 0x14u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 20, 4, v7, 0, v40);
  v41 = ausdk::AUElement::GetParameter(v16, 0x15u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 21, 4, v7, 0, v41);
  v42 = ausdk::AUElement::GetParameter(v16, 0x16u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 22, 4, v7, 0, v42);
  v43 = ausdk::AUElement::GetParameter(v16, 0x17u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 23, 4, v7, 0, v43);
  v44 = ausdk::AUElement::GetParameter(v16, 0x18u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 24, 4, v7, 0, v44);
  v45 = ausdk::AUElement::GetParameter(v16, 0x19u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 25, 4, v7, 0, v45);
  v46 = ausdk::AUElement::GetParameter(v16, 0x1Au);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 26, 4, v7, 0, v46);
  v47 = ausdk::AUElement::GetParameter(v16, 0x1Bu);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 27, 4, v7, 0, v47);
  v48 = ausdk::AUElement::GetParameter(v16, 0x1Cu);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 28, 4, v7, 0, v48);
  v49 = ausdk::AUElement::GetParameter(v16, 0x1Du);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 29, 4, v7, 0, v49);
  v50 = ausdk::AUElement::GetParameter(v16, 0x1Eu);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 30, 4, v7, 0, v50);
  v51 = ausdk::AUElement::GetParameter(v16, 0x1Fu);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 31, 4, v7, 0, v51);
  v52 = ausdk::AUElement::GetParameter(v16, 0x21u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 33, 4, v7, 0, v52);
  v53 = ausdk::AUElement::GetParameter(v16, 0x22u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 34, 4, v7, 0, v53);
  v54 = ausdk::AUElement::GetParameter(v16, 0x23u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, unint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 35, 4, v7, 0, v54);
  v55 = v65;
  v56 = ausdk::AUElement::GetParameter(v16, 0x24u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, uint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 36, 4, v55, 0, v56);
  v57 = ausdk::AUElement::GetParameter(v16, 0x25u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, uint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 37, 4, v55, 0, v57);
  v58 = ausdk::AUElement::GetParameter(v16, 0x26u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, uint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 38, 4, v55, 0, v58);
  v59 = ausdk::AUElement::GetParameter(v16, 0x27u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, uint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 39, 4, v55, 0, v59);
  v60 = ausdk::AUElement::GetParameter(v16, 0x28u);
  (*(void (**)(AUBeam2 *, uint64_t, uint64_t, uint64_t, _QWORD, float))(*(_QWORD *)this + 152))(this, 40, 4, v55, 0, v60);
  if (*((_BYTE *)this + 548))
  {
    v63 = (CmhBEAM *)*((_QWORD *)this + 69);
    if (v63)
      CmhBEAM::setParameter(v63, 51, (AUBeam2 *)((char *)this + 528), v61, v62);
  }
  else
  {
    v64 = (_DWORD *)*((_QWORD *)this + 70);
    if (v64)
    {
      v64[38] = *((_DWORD *)this + 132);
      v64[216] = 1;
      v64[10] = 0;
      v64[194] = *((_DWORD *)this + 174);
    }
  }
}

os_log_t ___ZL15AUBeam2LogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "beam2");
  *v0 = result;
  AUBeam2LogScope(void)::scope = (uint64_t)v0;
  return result;
}

uint64_t *std::unique_ptr<CmhBEAM>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t i;
  uint64_t v8;
  int v9;
  uint64_t j;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    if (*(_DWORD *)(v2 + 124))
    {
      if (*(_QWORD *)(v2 + 56))
      {
        v3 = *(_DWORD *)v2;
        if (*(int *)v2 >= 1)
        {
          v4 = 0;
          do
          {
            v5 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8 * v4);
            if (v5)
            {
              MEMORY[0x1BCC95CC8](v5, 0x1000C8052888210);
              v3 = *(_DWORD *)v2;
            }
            ++v4;
          }
          while (v4 < v3);
        }
      }
      if (*(_QWORD *)(v2 + 64))
      {
        v6 = *(_DWORD *)(v2 + 8);
        if (v6 >= 1)
        {
          for (i = 0; i < v6; ++i)
          {
            v8 = *(_QWORD *)(*(_QWORD *)(v2 + 64) + 8 * i);
            if (v8)
            {
              MEMORY[0x1BCC95CC8](v8, 0x1000C8052888210);
              v6 = *(_DWORD *)(v2 + 8);
            }
          }
        }
      }
      if (*(_QWORD *)(v2 + 72))
      {
        v9 = *(_DWORD *)(v2 + 4);
        if (v9 >= 1)
        {
          for (j = 0; j < v9; ++j)
          {
            v11 = *(_QWORD *)(*(_QWORD *)(v2 + 72) + 8 * j);
            if (v11)
            {
              MEMORY[0x1BCC95CC8](v11, 0x1000C8052888210);
              v9 = *(_DWORD *)(v2 + 4);
            }
          }
        }
      }
    }
    v12 = *(_QWORD *)(v2 + 56);
    if (v12)
      MEMORY[0x1BCC95CC8](v12, 0x80C80B8603338);
    *(_QWORD *)(v2 + 56) = 0;
    v13 = *(_QWORD *)(v2 + 64);
    if (v13)
      MEMORY[0x1BCC95CC8](v13, 0x80C80B8603338);
    *(_QWORD *)(v2 + 64) = 0;
    v14 = *(_QWORD *)(v2 + 72);
    if (v14)
      MEMORY[0x1BCC95CC8](v14, 0x80C80B8603338);
    *(_QWORD *)(v2 + 72) = 0;
    v15 = *(_QWORD *)(v2 + 80);
    if (v15)
      MEMORY[0x1BCC95CC8](v15, 0x1000C8052888210);
    v16 = *(_QWORD *)(v2 + 32);
    if (v16)
      MEMORY[0x1BCC95CC8](v16, 0x80C80B8603338);
    v17 = *(_QWORD *)(v2 + 40);
    if (v17)
      MEMORY[0x1BCC95CC8](v17, 0x80C80B8603338);
    v18 = *(_QWORD *)(v2 + 48);
    if (v18)
      MEMORY[0x1BCC95CC8](v18, 0x80C80B8603338);
    CmhBEAMprocOpt::deallocate_memory((_DWORD *)(v2 + 88));
    LPFilterBank::~LPFilterBank((LPFilterBank *)(v2 + 1480));
    if (*(_DWORD *)(v2 + 1144))
      Cns::deallocate_memory(v2 + 1144);
    CmhBEAM2NOpt::~CmhBEAM2NOpt((CmhBEAM2NOpt *)(v2 + 272));
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

CmhBEAM2NOpt *std::unique_ptr<CmhBEAM2NOpt>::reset[abi:ne180100](CmhBEAM2NOpt **a1, CmhBEAM2NOpt *a2)
{
  CmhBEAM2NOpt *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    CmhBEAM2NOpt::~CmhBEAM2NOpt(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

double std::make_unique[abi:ne180100]<CmhBEAM>(uint64_t *a1)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_QWORD *)(v2 + 80) = 0;
  *(_QWORD *)(v2 + 216) = 0;
  *(_QWORD *)(v2 + 248) = 0;
  *(_QWORD *)(v2 + 192) = 0;
  *(_QWORD *)(v2 + 200) = 0;
  *(_QWORD *)(v2 + 184) = 0;
  *(_QWORD *)(v2 + 224) = 0;
  *(_QWORD *)(v2 + 256) = 0;
  *(_QWORD *)(v2 + 264) = 0;
  CmhBEAM2NOpt::CmhBEAM2NOpt((CmhBEAM2NOpt *)(v2 + 272));
  *(_DWORD *)(v2 + 1160) = 1182400512;
  *(_QWORD *)(v2 + 1164) = 0x8000000040;
  *(_DWORD *)(v2 + 1196) = 0;
  *(_DWORD *)(v2 + 1208) = 1;
  *(_DWORD *)(v2 + 1172) = 2;
  *(_OWORD *)(v2 + 1144) = 0u;
  *(_OWORD *)(v2 + 1232) = 0u;
  *(_OWORD *)(v2 + 1248) = 0u;
  *(_OWORD *)(v2 + 1264) = 0u;
  *(_OWORD *)(v2 + 1280) = 0u;
  *(_OWORD *)(v2 + 1296) = 0u;
  *(_OWORD *)(v2 + 1312) = 0u;
  *(_OWORD *)(v2 + 1328) = 0u;
  *(_OWORD *)(v2 + 1344) = 0u;
  *(_OWORD *)(v2 + 1360) = 0u;
  *(_OWORD *)(v2 + 1376) = 0u;
  *(_OWORD *)(v2 + 1392) = 0u;
  *(_OWORD *)(v2 + 1216) = 0u;
  *(_QWORD *)(v2 + 1472) = 0;
  *(_OWORD *)(v2 + 1408) = 0u;
  *(_OWORD *)(v2 + 1424) = 0u;
  *(_OWORD *)(v2 + 1440) = 0u;
  *(_OWORD *)(v2 + 1456) = 0u;
  *(_QWORD *)(v2 + 1480) = &off_1E69CA758;
  *(_OWORD *)(v2 + 1488) = 0u;
  *(_OWORD *)(v2 + 1504) = 0u;
  *(_OWORD *)(v2 + 1520) = 0u;
  *(_OWORD *)(v2 + 1536) = 0u;
  *(_QWORD *)(v2 + 1552) = 0;
  *(_DWORD *)(v2 + 108) = 0;
  *(_QWORD *)(v2 + 124) = 0;
  *(_QWORD *)(v2 + 116) = 0;
  *(_QWORD *)&result = 2;
  *(_QWORD *)(v2 + 144) = 2;
  *(_QWORD *)(v2 + 80) = 0;
  *(_QWORD *)(v2 + 88) = 0;
  *(_QWORD *)(v2 + 100) = 2;
  *(_OWORD *)(v2 + 180) = 0u;
  *(_OWORD *)(v2 + 196) = 0u;
  *(_QWORD *)(v2 + 216) = 0;
  *(_QWORD *)(v2 + 224) = 0;
  *(_QWORD *)(v2 + 248) = 0;
  *(_QWORD *)(v2 + 256) = 0;
  *(_QWORD *)(v2 + 264) = 0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)v2 = 0u;
  *a1 = v2;
  return result;
}

void sub_1B655EAAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10F0C4034ED96B4);
  _Unwind_Resume(a1);
}

uint64_t AUBeam2::BlockProcessClassFunc(AUBeam2 *this, void *a2, const AudioBufferList ***a3, const AudioBufferList **a4, AudioBufferList **a5)
{
  AUBeam2::BlockProcessFunc(this, a2, *a3, (AudioBufferList **)(*a4)->mBuffers[0].mData);
  return 0;
}

void std::make_unique[abi:ne180100]<CmhBEAM2NOpt>(CmhBEAM2NOpt **a1)
{
  CmhBEAM2NOpt *v2;

  v2 = (CmhBEAM2NOpt *)operator new();
  CmhBEAM2NOpt::CmhBEAM2NOpt(v2);
  *a1 = v2;
}

void sub_1B655EB34(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10A0C40A62ED1A3);
  _Unwind_Resume(a1);
}

uint64_t AUBeam2::SetDiffractionFilterAndPostEQ(AUBeam2 *this, double a2, double a3)
{
  NSObject *v4;
  FILE *v5;
  unint64_t v6;
  const char *v7;
  unsigned int v8;
  BOOL v9;
  NSObject *v10;
  const char *v11;
  uint8_t *v12;
  CmhBEAM2NOpt **v13;
  CmhBEAM2NOpt **v14;
  unint64_t v15;
  unsigned int v16;
  NSObject *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFNumber *v20;
  uint64_t v21;
  const __CFAllocator *v22;
  const __CFAllocator *v23;
  CFStringRef v24;
  const __CFData *v25;
  int v26;
  const UInt8 *v27;
  uint64_t v28;
  CmhBEAM2NOpt *v29;
  unsigned int v30;
  NSObject *v31;
  NSObject *v32;
  const char *v33;
  NSObject *v34;
  uint32_t v35;
  CmhBEAM2NOpt *v36;
  unint64_t v37;
  unint64_t v38;
  unsigned int v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  CmhBEAM2NOpt *v47;
  double v48;
  double v49;
  double v50;
  CmhBEAM *v51;
  CmhBEAM2NOpt *v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  CmhBEAM2NOpt **v59;
  int v60;
  NSObject *v61;
  CmhBEAM2NOpt **v62;
  uint64_t v63;
  uint64_t v64;
  _DWORD *v65;
  char *v66;
  CmhBEAM2NOpt *v67;
  double v68;
  double v69;
  CmhBEAM2NOpt **v70;
  int v71;
  FILE *v72;
  uint64_t v73;
  char *v74;
  char v75;
  uint64_t v76;
  char v77;
  _QWORD *v78;
  _QWORD *v79;
  unint64_t v80;
  unsigned int v81;
  NSObject *v82;
  const char *v83;
  uint8_t *p_valuePtr;
  NSObject *v85;
  const __CFDictionary *v86;
  const __CFDictionary *Value;
  const __CFNumber *v88;
  uint64_t v89;
  const __CFAllocator *v90;
  const __CFAllocator *v91;
  char v92;
  char v93;
  CFStringRef v94;
  const __CFData *v95;
  int Length;
  const UInt8 *BytePtr;
  uint64_t v98;
  _DWORD *v99;
  unsigned int v100;
  NSObject *v101;
  NSObject *v102;
  const char *v103;
  NSObject *v104;
  uint32_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unsigned int v110;
  uint64_t v111;
  CmhBEAM2NOpt *v112;
  CmhBEAM *v113;
  int v114;
  uint64_t v115;
  int v116;
  CmhBEAM2NOpt **v118;
  CmhBEAM2NOpt **v119;
  uint64_t v120;
  char *v121;
  uint8_t v122[32];
  unsigned int valuePtr;
  const char *v124;
  __int16 v125;
  int v126;
  __int16 v127;
  char *v128;
  _BYTE buf[12];
  __int16 v130;
  int v131;
  __int16 v132;
  _QWORD v133[126];
  char *v134[3];

  v134[1] = *(char **)MEMORY[0x1E0C80C00];
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeam2LogScope(void)::scope + 8) & 1) != 0)
    {
      v4 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (*(_QWORD *)AUBeam2LogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeam2LogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "AUBeam2.cpp";
          v130 = 1024;
          v131 = 1628;
          v132 = 2048;
          v133[0] = this;
          _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2::SetDiffractionFilterAndPostEQ (%p)", buf, 0x1Cu);
        }
      }
    }
  }
  v118 = 0;
  v119 = 0;
  v120 = 0;
  if (!*((_BYTE *)this + 703))
    goto LABEL_60;
  v5 = fopen((const char *)this + 704, "r");
  if (v5)
  {
    if (fgets(buf, 1024, v5))
    {
      v134[0] = 0;
      if (buf[0])
      {
        v6 = 0;
        v7 = buf;
        while (1)
        {
          *(float *)&a2 = strtof(v7, v134);
          *(&valuePtr + v6) = LODWORD(a2);
          if (v7 == v134[0])
            break;
          v8 = v6 + 1;
          if (*v134[0])
            v9 = v6 >= 7;
          else
            v9 = 1;
          ++v6;
          v7 = v134[0];
          if (v9)
            goto LABEL_34;
        }
        v8 = v6;
LABEL_34:
        if (v8)
        {
          std::vector<std::valarray<float>>::resize((uint64_t)&v118, v8);
          v13 = v118;
          v14 = v119;
          if (v119 == v118)
          {
            v13 = v119;
          }
          else
          {
            v15 = 0;
            v16 = 1;
            do
            {
              std::valarray<float>::resize((uint64_t)&v13[2 * v15], 0x101uLL, 0.0);
              v13 = v118;
              *(_DWORD *)v118[2 * v15] = *(&valuePtr + v15);
              v15 = v16;
              v14 = v119;
              ++v16;
            }
            while (v15 < ((char *)v119 - (char *)v13) >> 4);
          }
          v36 = *v13;
          if ((unint64_t)(v13[1] - *v13) >= 5)
          {
            v37 = 1;
            do
            {
              if (v14 == v13)
              {
                v14 = v13;
              }
              else
              {
                v38 = 0;
                v39 = 1;
                do
                {
                  fscanf(v5, "%f", (char *)v13[2 * v38] + 4 * v37);
                  v38 = v39;
                  v13 = v118;
                  v14 = v119;
                  ++v39;
                }
                while (v38 < ((char *)v119 - (char *)v118) >> 4);
                v36 = *v118;
              }
              v37 = (v37 + 1);
            }
            while (v37 < (v13[1] - v36) >> 2);
          }
          fclose(v5);
LABEL_94:
          if (v119 == v118)
          {
            if (AUBeam2LogScope(void)::once != -1)
              dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
            if (AUBeam2LogScope(void)::scope)
            {
              v61 = *(NSObject **)AUBeam2LogScope(void)::scope;
              if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
                goto LABEL_115;
            }
            else
            {
              v61 = MEMORY[0x1E0C81028];
            }
            if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = "AUBeam2.cpp";
              v130 = 1024;
              v131 = 1755;
              _os_log_impl(&dword_1B5ED0000, v61, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2: Error no diffraction filter data", buf, 0x12u);
            }
          }
          else if (*((_BYTE *)this + 548))
          {
            *(float *)&v40 = CmhBEAM::setParameter(*((CmhBEAM **)this + 69), 15, *v118, a2, a3);
            *(float *)&v42 = CmhBEAM::setParameter(*((CmhBEAM **)this + 69), 16, v118[2], v40, v41);
            *(float *)&v44 = CmhBEAM::setParameter(*((CmhBEAM **)this + 69), 17, v118[4], v42, v43);
            *(float *)&v46 = CmhBEAM::setParameter(*((CmhBEAM **)this + 69), 18, v118[6], v44, v45);
            v47 = v118[6];
            *(_DWORD *)v47 = 1058642330;
            *(float *)&v49 = CmhBEAM::setParameter(*((CmhBEAM **)this + 69), 34, v47, v46, v48);
            v51 = (CmhBEAM *)*((_QWORD *)this + 69);
            v52 = v118[8];
            if ((char *)v119 - (char *)v118 == 128)
            {
              *(float *)&v53 = CmhBEAM::setParameter(v51, 21, v52, v49, v50);
              *(float *)&v55 = CmhBEAM::setParameter(*((CmhBEAM **)this + 69), 22, v118[10], v53, v54);
              *(float *)&v57 = CmhBEAM::setParameter(*((CmhBEAM **)this + 69), 23, v118[12], v55, v56);
              v59 = v118 + 14;
              v60 = 24;
            }
            else
            {
              *(float *)&v57 = CmhBEAM::setParameter(v51, 19, v52, v49, v50);
              v59 = v118 + 10;
              v60 = 20;
            }
            *(float *)&a2 = CmhBEAM::setParameter(*((CmhBEAM **)this + 69), v60, *v59, v57, v58);
          }
          else
          {
            CmhBEAM2NOpt::setModelSpatialFilterReal(*((CmhBEAM2NOpt **)this + 70), *v118, 0);
            CmhBEAM2NOpt::setModelSpatialFilterImag(*((CmhBEAM2NOpt **)this + 70), v118[2], 0);
            CmhBEAM2NOpt::setModelSpatialFilterReal(*((CmhBEAM2NOpt **)this + 70), v118[4], 1u);
            CmhBEAM2NOpt::setModelSpatialFilterImag(*((CmhBEAM2NOpt **)this + 70), v118[6], 1u);
            v62 = v118;
            *(_DWORD *)v118[6] = 1058642330;
            v63 = *((_QWORD *)this + 70);
            v64 = *(unsigned int *)(v63 + 8);
            if ((int)v64 >= 1)
            {
              v65 = (_DWORD *)(*(_QWORD *)(v63 + 408) + 64);
              do
              {
                *v65 = 1058642330;
                v65 += 34;
                --v64;
              }
              while (v64);
            }
            v66 = (char *)((char *)v119 - (char *)v62);
            v67 = v62[8];
            CmhBEAM2NOpt::setModelFreqCompVector((CmhBEAM2NOpt *)v63, v67, 0);
            if (v66 == (char *)128)
            {
              CmhBEAM2NOpt::interpolateFrequencyVector((uint64_t)v118[10], (float *)0x101, **(_QWORD **)(*((_QWORD *)this + 70) + 104), 93.75, (float *)*(unsigned int *)(*((_QWORD *)this + 70) + 28), (float)*(int *)(*((_QWORD *)this + 70) + 12) / (float)*(int *)(*((_QWORD *)this + 70) + 16));
              *(float *)&v68 = CmhBEAM2NOpt::setModelFreqCompVector(*((CmhBEAM2NOpt **)this + 70), v118[12], 1u);
              v70 = v118 + 14;
              v71 = 22;
            }
            else
            {
              *(float *)&v68 = CmhBEAM2NOpt::setModelFreqCompVector((CmhBEAM2NOpt *)v63, v67, 1u);
              v70 = v118 + 10;
              v71 = 18;
            }
            *(float *)&a2 = CmhBEAM2NOpt::setParameter(*((CmhBEAM2NOpt **)this + 70), v71, *v70, v68, v69);
          }
LABEL_115:
          memset(v122, 0, 24);
          if (!*((_BYTE *)this + 1728))
            goto LABEL_162;
          v72 = fopen((const char *)this + 1729, "r");
          if (v72)
          {
            if (fgets(buf, 1024, v72))
            {
              v121 = 0;
              if (buf[0])
              {
                v73 = 0;
                v74 = buf;
                v75 = 1;
                while (1)
                {
                  v76 = v73;
                  *(float *)&a2 = strtof(v74, &v121);
                  *((_DWORD *)v134 + v76) = LODWORD(a2);
                  if (v74 == v121)
                    break;
                  v77 = (*v121 != 0) & v75;
                  v73 = 1;
                  v74 = v121;
                  v75 = 0;
                  if ((v77 & 1) == 0)
                  {
                    LODWORD(v76) = v76 + 1;
                    break;
                  }
                }
                if ((_DWORD)v76)
                {
                  std::vector<std::valarray<float>>::resize((uint64_t)v122, v76);
                  v78 = *(_QWORD **)v122;
                  v79 = *(_QWORD **)&v122[8];
                  if (*(_QWORD *)&v122[8] == *(_QWORD *)v122)
                  {
                    v78 = *(_QWORD **)&v122[8];
                  }
                  else
                  {
                    v80 = 0;
                    v81 = 1;
                    do
                    {
                      std::valarray<float>::resize((uint64_t)&v78[2 * v80], 0x101uLL, 0.0);
                      v78 = *(_QWORD **)v122;
                      **(_DWORD **)(*(_QWORD *)v122 + 16 * v80) = *((_DWORD *)v134 + v80);
                      v80 = v81;
                      v79 = *(_QWORD **)&v122[8];
                      ++v81;
                    }
                    while (v80 < (uint64_t)(*(_QWORD *)&v122[8] - (_QWORD)v78) >> 4);
                  }
                  v107 = *v78;
                  if (v78[1] - *v78 >= 5uLL)
                  {
                    v108 = 1;
                    do
                    {
                      if (v79 == v78)
                      {
                        v79 = v78;
                      }
                      else
                      {
                        v109 = 0;
                        v110 = 1;
                        do
                        {
                          fscanf(v72, "%f", v78[2 * v109] + 4 * v108);
                          v109 = v110;
                          v78 = *(_QWORD **)v122;
                          v79 = *(_QWORD **)&v122[8];
                          ++v110;
                        }
                        while (v109 < (uint64_t)(*(_QWORD *)&v122[8] - *(_QWORD *)v122) >> 4);
                        v107 = **(_QWORD **)v122;
                      }
                      v108 = (v108 + 1);
                    }
                    while (v108 < (v78[1] - v107) >> 2);
                  }
                  fclose(v72);
                  goto LABEL_201;
                }
              }
              if (AUBeam2LogScope(void)::once != -1)
                dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
              if (AUBeam2LogScope(void)::scope)
              {
                v82 = *(NSObject **)AUBeam2LogScope(void)::scope;
                if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
                  goto LABEL_154;
              }
              else
              {
                v82 = MEMORY[0x1E0C81028];
              }
              if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
              {
                valuePtr = 136315650;
                v124 = "AUBeam2.cpp";
                v125 = 1024;
                v126 = 2506;
                v127 = 2080;
                v128 = (char *)this + 1729;
                v83 = "%25s:%-5d AUBeam2: Error: Could not read post EQ file %s";
LABEL_152:
                p_valuePtr = (uint8_t *)&valuePtr;
                goto LABEL_153;
              }
            }
            else
            {
              if (AUBeam2LogScope(void)::once != -1)
                dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
              if (AUBeam2LogScope(void)::scope)
              {
                v82 = *(NSObject **)AUBeam2LogScope(void)::scope;
                if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
                  goto LABEL_154;
              }
              else
              {
                v82 = MEMORY[0x1E0C81028];
              }
              if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
              {
                valuePtr = 136315650;
                v124 = "AUBeam2.cpp";
                v125 = 1024;
                v126 = 2491;
                v127 = 2080;
                v128 = (char *)this + 1729;
                v83 = "%25s:%-5d AUBeam2: Error: Could not read post EQ file %s";
                goto LABEL_152;
              }
            }
          }
          else
          {
            if (AUBeam2LogScope(void)::once != -1)
              dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
            if (AUBeam2LogScope(void)::scope)
            {
              v82 = *(NSObject **)AUBeam2LogScope(void)::scope;
              if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
                goto LABEL_154;
            }
            else
            {
              v82 = MEMORY[0x1E0C81028];
            }
            if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = "AUBeam2.cpp";
              v130 = 1024;
              v131 = 2480;
              v132 = 2080;
              v133[0] = (char *)this + 1729;
              v83 = "%25s:%-5d AUBeam2: Error: Could not open post EQ file %s";
              p_valuePtr = buf;
LABEL_153:
              _os_log_impl(&dword_1B5ED0000, v82, OS_LOG_TYPE_ERROR, v83, p_valuePtr, 0x1Cu);
            }
          }
LABEL_154:
          if (AUBeam2LogScope(void)::once != -1)
            dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
          if (AUBeam2LogScope(void)::scope)
          {
            v85 = *(NSObject **)AUBeam2LogScope(void)::scope;
            if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
              goto LABEL_162;
          }
          else
          {
            v85 = MEMORY[0x1E0C81028];
          }
          if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "AUBeam2.cpp";
            v130 = 1024;
            v131 = 1768;
            v132 = 2080;
            v133[0] = (char *)this + 1729;
            _os_log_impl(&dword_1B5ED0000, v85, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error loading post EQ file at %s", buf, 0x1Cu);
          }
LABEL_162:
          v86 = (const __CFDictionary *)*((_QWORD *)this + 86);
          if (v86 && CFDictionaryGetValue(v86, CFSTR("posteq")))
          {
            std::vector<std::valarray<float>>::resize((uint64_t)v122, 2uLL);
            Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 86), CFSTR("posteq"));
            valuePtr = 0;
            v88 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("length"));
            if (CFNumberGetValue(v88, kCFNumberIntType, &valuePtr))
            {
              v89 = 0;
              v90 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              v91 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
              v92 = 1;
              while (1)
              {
                v93 = v92;
                std::valarray<float>::resize(*(_QWORD *)v122 + 16 * v89, valuePtr, 0.0);
                v94 = CFStringCreateWithCStringNoCopy(v90, off_1E69EB010[v89], 0, v91);
                v95 = (const __CFData *)CFDictionaryGetValue(Value, v94);
                CFRelease(v94);
                if (v95)
                {
                  Length = CFDataGetLength(v95);
                  if (Length != 4 * valuePtr)
                  {
                    if (AUBeam2LogScope(void)::once != -1)
                      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
                    if (AUBeam2LogScope(void)::scope)
                    {
                      v102 = *(NSObject **)AUBeam2LogScope(void)::scope;
                      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
                      {
LABEL_224:
                        v106 = 4294956445;
                        goto LABEL_225;
                      }
                    }
                    else
                    {
                      v102 = MEMORY[0x1E0C81028];
                    }
                    if (!os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                      goto LABEL_224;
                    *(_DWORD *)buf = 136315906;
                    *(_QWORD *)&buf[4] = "AUBeam2.cpp";
                    v130 = 1024;
                    v131 = 1807;
                    v132 = 1024;
                    LODWORD(v133[0]) = 4 * valuePtr;
                    WORD2(v133[0]) = 1024;
                    *(_DWORD *)((char *)v133 + 6) = Length;
                    v103 = "%25s:%-5d AUBeam2 Error: Invalid post eq data vector length from tuning file (expected %d byt"
                           "es, actual %d bytes)";
                    v104 = v102;
                    v105 = 30;
LABEL_223:
                    _os_log_impl(&dword_1B5ED0000, v104, OS_LOG_TYPE_DEBUG, v103, buf, v105);
                    goto LABEL_224;
                  }
                  BytePtr = CFDataGetBytePtr(v95);
                  v98 = valuePtr;
                  if (valuePtr)
                  {
                    v99 = *(_DWORD **)(*(_QWORD *)v122 + 16 * v89);
                    do
                    {
                      v100 = *(_DWORD *)BytePtr;
                      BytePtr += 4;
                      *v99++ = bswap32(v100);
                      --v98;
                    }
                    while (v98);
                  }
                }
                v92 = 0;
                v89 = 1;
                if ((v93 & 1) == 0)
                  goto LABEL_201;
              }
            }
            if (AUBeam2LogScope(void)::once != -1)
              dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
            if (AUBeam2LogScope(void)::scope)
            {
              v101 = *(NSObject **)AUBeam2LogScope(void)::scope;
              if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
                goto LABEL_224;
            }
            else
            {
              v101 = MEMORY[0x1E0C81028];
            }
            if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
              goto LABEL_224;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "AUBeam2.cpp";
            v130 = 1024;
            v131 = 1786;
            v103 = "%25s:%-5d AUBeam2 Error: Converting eq vectors length from tuning file";
            v104 = v101;
            v105 = 18;
            goto LABEL_223;
          }
LABEL_201:
          v111 = *(_QWORD *)&v122[8] - *(_QWORD *)v122;
          if (*(_QWORD *)&v122[8] == *(_QWORD *)v122)
          {
            if (AUBeam2LogScope(void)::once != -1)
              dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
            if (AUBeam2LogScope(void)::scope)
            {
              v106 = *(_QWORD *)AUBeam2LogScope(void)::scope;
              if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
              {
LABEL_225:
                *(_QWORD *)buf = v122;
                std::vector<std::valarray<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
                goto LABEL_226;
              }
            }
            else
            {
              v106 = MEMORY[0x1E0C81028];
            }
            if (os_log_type_enabled((os_log_t)v106, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = "AUBeam2.cpp";
              v130 = 1024;
              v131 = 1848;
              _os_log_impl(&dword_1B5ED0000, (os_log_t)v106, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2: Error no post EQ data", buf, 0x12u);
            }
          }
          else
          {
            v112 = **(CmhBEAM2NOpt ***)v122;
            if (*((_BYTE *)this + 548))
            {
              v113 = (CmhBEAM *)*((_QWORD *)this + 69);
              if (v111 == 32)
              {
                *(float *)&a2 = CmhBEAM::setParameter(v113, 37, v112, a2, a3);
                v113 = (CmhBEAM *)*((_QWORD *)this + 69);
                v112 = *(CmhBEAM2NOpt **)(*(_QWORD *)v122 + 16);
                v114 = 38;
              }
              else
              {
                v114 = 36;
              }
              CmhBEAM::setParameter(v113, v114, v112, a2, a3);
            }
            else
            {
              v115 = *((_QWORD *)this + 70);
              if (v111 == 32)
              {
                CmhBEAM2NOpt::interpolateFrequencyVector(**(_QWORD **)v122, (float *)0x101, **(_QWORD **)(v115 + 112), 93.75, (float *)*(unsigned int *)(v115 + 28), (float)*(int *)(v115 + 12) / (float)*(int *)(v115 + 16));
                v115 = *((_QWORD *)this + 70);
                v112 = *(CmhBEAM2NOpt **)(*(_QWORD *)v122 + 16);
                v116 = 80;
              }
              else
              {
                v116 = 78;
              }
              CmhBEAM2NOpt::setParameter((CmhBEAM2NOpt *)v115, v116, v112, a2, a3);
            }
          }
          v106 = 0;
          goto LABEL_225;
        }
      }
      if (AUBeam2LogScope(void)::once != -1)
        dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
      if (AUBeam2LogScope(void)::scope)
      {
        v10 = *(NSObject **)AUBeam2LogScope(void)::scope;
        if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
          goto LABEL_52;
      }
      else
      {
        v10 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v122 = 136315650;
        *(_QWORD *)&v122[4] = "AUBeam2.cpp";
        *(_WORD *)&v122[12] = 1024;
        *(_DWORD *)&v122[14] = 2455;
        *(_WORD *)&v122[18] = 2080;
        *(_QWORD *)&v122[20] = (char *)this + 704;
        v11 = "%25s:%-5d AUBeam2: Error: Could not read diffraction filter file %s";
LABEL_50:
        v12 = v122;
        goto LABEL_51;
      }
    }
    else
    {
      if (AUBeam2LogScope(void)::once != -1)
        dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
      if (AUBeam2LogScope(void)::scope)
      {
        v10 = *(NSObject **)AUBeam2LogScope(void)::scope;
        if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
          goto LABEL_52;
      }
      else
      {
        v10 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v122 = 136315650;
        *(_QWORD *)&v122[4] = "AUBeam2.cpp";
        *(_WORD *)&v122[12] = 1024;
        *(_DWORD *)&v122[14] = 2440;
        *(_WORD *)&v122[18] = 2080;
        *(_QWORD *)&v122[20] = (char *)this + 704;
        v11 = "%25s:%-5d AUBeam2: Error: Could not read diffraction filter file %s";
        goto LABEL_50;
      }
    }
  }
  else
  {
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
    if (AUBeam2LogScope(void)::scope)
    {
      v10 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        goto LABEL_52;
    }
    else
    {
      v10 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "AUBeam2.cpp";
      v130 = 1024;
      v131 = 2429;
      v132 = 2080;
      v133[0] = (char *)this + 704;
      v11 = "%25s:%-5d AUBeam2: Error: Could not open diffraction filter file %s";
      v12 = buf;
LABEL_51:
      _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_ERROR, v11, v12, 0x1Cu);
    }
  }
LABEL_52:
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    v17 = *(NSObject **)AUBeam2LogScope(void)::scope;
    if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
      goto LABEL_60;
  }
  else
  {
    v17 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "AUBeam2.cpp";
    v130 = 1024;
    v131 = 1643;
    v132 = 2080;
    v133[0] = (char *)this + 704;
    _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error loading diffraction filter file at %s", buf, 0x1Cu);
  }
LABEL_60:
  v18 = (const __CFDictionary *)*((_QWORD *)this + 86);
  if (!v18 || !CFDictionaryGetValue(v18, CFSTR("diffr")))
    goto LABEL_94;
  std::vector<std::valarray<float>>::resize((uint64_t)&v118, 8uLL);
  v19 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 86), CFSTR("diffr"));
  valuePtr = 0;
  v20 = (const __CFNumber *)CFDictionaryGetValue(v19, CFSTR("length"));
  if (!CFNumberGetValue(v20, kCFNumberIntType, &valuePtr))
  {
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
    if (AUBeam2LogScope(void)::scope)
    {
      v31 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        goto LABEL_190;
    }
    else
    {
      v31 = MEMORY[0x1E0C81028];
    }
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
      goto LABEL_190;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "AUBeam2.cpp";
    v130 = 1024;
    v131 = 1661;
    v33 = "%25s:%-5d AUBeam2 Error: Converting diffraction filter vectors length from tuning file";
    v34 = v31;
    v35 = 18;
LABEL_189:
    _os_log_impl(&dword_1B5ED0000, v34, OS_LOG_TYPE_DEBUG, v33, buf, v35);
    goto LABEL_190;
  }
  v21 = 0;
  v22 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v23 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  while (1)
  {
    std::valarray<float>::resize((uint64_t)&v118[2 * v21], valuePtr, 0.0);
    v24 = CFStringCreateWithCStringNoCopy(v22, off_1E69EAFD0[v21], 0, v23);
    v25 = (const __CFData *)CFDictionaryGetValue(v19, v24);
    CFRelease(v24);
    if (v25)
      break;
LABEL_69:
    if (++v21 == 8)
      goto LABEL_94;
  }
  v26 = CFDataGetLength(v25);
  if (v26 == 4 * valuePtr)
  {
    v27 = CFDataGetBytePtr(v25);
    v28 = valuePtr;
    if (valuePtr)
    {
      v29 = v118[2 * v21];
      do
      {
        v30 = *(_DWORD *)v27;
        v27 += 4;
        *(_DWORD *)v29 = bswap32(v30);
        v29 = (CmhBEAM2NOpt *)((char *)v29 + 4);
        --v28;
      }
      while (v28);
    }
    goto LABEL_69;
  }
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (!AUBeam2LogScope(void)::scope)
  {
    v32 = MEMORY[0x1E0C81028];
    goto LABEL_187;
  }
  v32 = *(NSObject **)AUBeam2LogScope(void)::scope;
  if (*(_QWORD *)AUBeam2LogScope(void)::scope)
  {
LABEL_187:
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      goto LABEL_190;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "AUBeam2.cpp";
    v130 = 1024;
    v131 = 1688;
    v132 = 1024;
    LODWORD(v133[0]) = 4 * valuePtr;
    WORD2(v133[0]) = 1024;
    *(_DWORD *)((char *)v133 + 6) = v26;
    v33 = "%25s:%-5d AUBeam2 Error: Invalid diffraction filter data vector length from tuning file (expected %d bytes, actual %d bytes)";
    v34 = v32;
    v35 = 30;
    goto LABEL_189;
  }
LABEL_190:
  v106 = 4294956445;
LABEL_226:
  *(_QWORD *)buf = &v118;
  std::vector<std::valarray<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  return v106;
}

void sub_1B655FE04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15, uint64_t a16, uint64_t a17, uint64_t a18, void ***a19)
{
  a19 = &a15;
  std::vector<std::valarray<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  a15 = (void **)&a11;
  std::vector<std::valarray<float>>::__destroy_vector::operator()[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

void AUBeam2::DumpDiffractionFilter(_BOOL8 this)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  int *v4;
  NSObject *v5;
  unint64_t v6;
  unint64_t CurrentGregorianDate;
  double v8;
  double v9;
  uint64_t Element;
  FILE *v11;
  void **v12;
  unint64_t v13;
  unsigned int v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  void **v20;
  void **v21;
  uint64_t v22;
  char v23[5];
  void ***v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v1 = this;
  v31 = *MEMORY[0x1E0C80C00];
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeam2LogScope(void)::scope + 8) & 1) != 0)
    {
      v2 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (*(_QWORD *)AUBeam2LogScope(void)::scope)
      {
        this = os_log_type_enabled(*(os_log_t *)AUBeam2LogScope(void)::scope, OS_LOG_TYPE_DEBUG);
        if (this)
        {
          *(_DWORD *)buf = 136315650;
          v26 = "AUBeam2.cpp";
          v27 = 1024;
          v28 = 2528;
          v29 = 2048;
          v30 = v1;
          _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2::DumpDiffractionFilter (%p)", buf, 0x1Cu);
        }
      }
    }
  }
  v3 = 552;
  if (!*(_BYTE *)(v1 + 548))
    v3 = 560;
  if (*(_QWORD *)(v1 + v3))
  {
    if (*(_BYTE *)(v1 + 548))
      v4 = (int *)(*(_QWORD *)(v1 + 552) + 140);
    else
      v4 = (int *)(*(_QWORD *)(v1 + 560) + 28);
    v6 = *v4;
    if ((_DWORD)v6)
    {
LABEL_20:
      CurrentGregorianDate = CATimeUtilities::GetCurrentGregorianDate((CATimeUtilities *)this);
      v9 = v8;
      ausdk::ComponentBase::GetComponentDescription((ausdk::ComponentBase *)buf, *(OpaqueAudioComponentInstance **)(v1 + 8));
      v23[0] = BYTE3(v26);
      v23[1] = BYTE2(v26);
      v23[2] = BYTE1(v26);
      v23[3] = (char)v26;
      v23[4] = 0;
      Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 80), 0);
      snprintf((char *)buf, 0x200uLL, "/tmp/aubeam2-%s-diffr-%dHz-%02d%02d%02d.txt", v23, (int)*(double *)(Element + 80), (int)(CurrentGregorianDate >> 24) >> 24, SHIDWORD(CurrentGregorianDate) >> 24, (int)v9);
      v11 = fopen((const char *)buf, "w");
      if (v11)
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        std::vector<std::valarray<float>>::resize((uint64_t)&v20, 8uLL);
        v12 = v21;
        if (v21 != v20)
        {
          v13 = 0;
          v14 = 1;
          v12 = v20;
          do
          {
            std::valarray<float>::resize((uint64_t)&v12[2 * v13], v6, 0.0);
            v13 = v14;
            v12 = v20;
            ++v14;
          }
          while (v13 < ((char *)v21 - (char *)v20) >> 4);
        }
        v15 = *v12;
        if (*(_BYTE *)(v1 + 548))
        {
          memcpy(v15, *(const void **)(*(_QWORD *)(v1 + 552) + 472), 4 * v6);
          memcpy(v20[2], *(const void **)(*(_QWORD *)(v1 + 552) + 488), 4 * v6);
          memcpy(v20[4], *(const void **)(*(_QWORD *)(v1 + 552) + 480), 4 * v6);
          memcpy(v20[6], *(const void **)(*(_QWORD *)(v1 + 552) + 496), 4 * v6);
          memcpy(v20[8], **(const void ***)(*(_QWORD *)(v1 + 552) + 368), 4 * v6);
          memcpy(v20[10], **(const void ***)(*(_QWORD *)(v1 + 552) + 376), 4 * v6);
          memcpy(v20[12], *(const void **)(*(_QWORD *)(*(_QWORD *)(v1 + 552) + 368) + 8), 4 * v6);
          v16 = *(_QWORD *)(v1 + 552) + 376;
        }
        else
        {
          memcpy(v15, *(const void **)(*(_QWORD *)(v1 + 560) + 200), 4 * v6);
          memcpy(v20[2], *(const void **)(*(_QWORD *)(v1 + 560) + 216), 4 * v6);
          memcpy(v20[4], *(const void **)(*(_QWORD *)(v1 + 560) + 208), 4 * v6);
          memcpy(v20[6], *(const void **)(*(_QWORD *)(v1 + 560) + 224), 4 * v6);
          memcpy(v20[8], **(const void ***)(*(_QWORD *)(v1 + 560) + 96), 4 * v6);
          memcpy(v20[10], **(const void ***)(*(_QWORD *)(v1 + 560) + 104), 4 * v6);
          memcpy(v20[12], *(const void **)(*(_QWORD *)(*(_QWORD *)(v1 + 560) + 96) + 8), 4 * v6);
          v16 = *(_QWORD *)(v1 + 560) + 104;
        }
        memcpy(v20[14], *(const void **)(*(_QWORD *)v16 + 8), 4 * v6);
        if ((int)v6 >= 1)
        {
          v18 = 0;
          v19 = 4 * v6;
          do
          {
            fprintf(v11, "%.8f %.8f %.8f %.8f %.8f %.8f %.8f %.8f\n", *(float *)((char *)*v20 + v18), *(float *)((char *)v20[2] + v18), *(float *)((char *)v20[4] + v18), *(float *)((char *)v20[6] + v18), *(float *)((char *)v20[8] + v18), *(float *)((char *)v20[10] + v18), *(float *)((char *)v20[12] + v18), *(float *)((char *)v20[14] + v18));
            v18 += 4;
          }
          while (v19 != v18);
        }
        fclose(v11);
        v24 = &v20;
        std::vector<std::valarray<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v24);
      }
      return;
    }
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
    if (AUBeam2LogScope(void)::scope)
    {
      v17 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        goto LABEL_20;
    }
    else
    {
      v17 = MEMORY[0x1E0C81028];
    }
    this = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (this)
    {
      *(_DWORD *)buf = 136315394;
      v26 = "AUBeam2.cpp";
      v27 = 1024;
      v28 = 2543;
      _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error: Number of unique bands is zero, won't dump diffraction filter", buf, 0x12u);
    }
    goto LABEL_20;
  }
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    v5 = *(NSObject **)AUBeam2LogScope(void)::scope;
    if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
      return;
  }
  else
  {
    v5 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    v26 = "AUBeam2.cpp";
    v27 = 1024;
    v28 = 2531;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error: Beam object not initialized, won't dump diffraction filter", buf, 0x12u);
  }
}

void sub_1B6560454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void **a22)
{
  a22 = (void **)&a18;
  std::vector<std::valarray<float>>::__destroy_vector::operator()[abi:ne180100](&a22);
  _Unwind_Resume(a1);
}

void AUBeam2::DumpPostEQ(_BOOL8 this)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  int *v4;
  NSObject *v5;
  unint64_t v6;
  unint64_t CurrentGregorianDate;
  double v8;
  double v9;
  uint64_t Element;
  FILE *v11;
  void **v12;
  unint64_t v13;
  unsigned int v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  void **v20;
  void **v21;
  uint64_t v22;
  char v23[5];
  void ***v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v1 = this;
  v31 = *MEMORY[0x1E0C80C00];
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeam2LogScope(void)::scope + 8) & 1) != 0)
    {
      v2 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (*(_QWORD *)AUBeam2LogScope(void)::scope)
      {
        this = os_log_type_enabled(*(os_log_t *)AUBeam2LogScope(void)::scope, OS_LOG_TYPE_DEBUG);
        if (this)
        {
          *(_DWORD *)buf = 136315650;
          v26 = "AUBeam2.cpp";
          v27 = 1024;
          v28 = 2595;
          v29 = 2048;
          v30 = v1;
          _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUBeam2::DumpPostEQ (%p)", buf, 0x1Cu);
        }
      }
    }
  }
  v3 = 552;
  if (!*(_BYTE *)(v1 + 548))
    v3 = 560;
  if (*(_QWORD *)(v1 + v3))
  {
    if (*(_BYTE *)(v1 + 548))
      v4 = (int *)(*(_QWORD *)(v1 + 552) + 140);
    else
      v4 = (int *)(*(_QWORD *)(v1 + 560) + 28);
    v6 = *v4;
    if ((_DWORD)v6)
    {
LABEL_20:
      CurrentGregorianDate = CATimeUtilities::GetCurrentGregorianDate((CATimeUtilities *)this);
      v9 = v8;
      ausdk::ComponentBase::GetComponentDescription((ausdk::ComponentBase *)buf, *(OpaqueAudioComponentInstance **)(v1 + 8));
      v23[0] = BYTE3(v26);
      v23[1] = BYTE2(v26);
      v23[2] = BYTE1(v26);
      v23[3] = (char)v26;
      v23[4] = 0;
      Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 80), 0);
      snprintf((char *)buf, 0x200uLL, "/tmp/aubeam2-%s-eq-%dHz-%02d%02d%02d.txt", v23, (int)*(double *)(Element + 80), (int)(CurrentGregorianDate >> 24) >> 24, SHIDWORD(CurrentGregorianDate) >> 24, (int)v9);
      v11 = fopen((const char *)buf, "w");
      if (v11)
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        std::vector<std::valarray<float>>::resize((uint64_t)&v20, 2uLL);
        v12 = v21;
        if (v21 != v20)
        {
          v13 = 0;
          v14 = 1;
          v12 = v20;
          do
          {
            std::valarray<float>::resize((uint64_t)&v12[2 * v13], v6, 0.0);
            v13 = v14;
            v12 = v20;
            ++v14;
          }
          while (v13 < ((char *)v21 - (char *)v20) >> 4);
        }
        v15 = *v12;
        if (*(_BYTE *)(v1 + 548))
        {
          memcpy(v15, **(const void ***)(*(_QWORD *)(v1 + 552) + 384), 4 * v6);
          v16 = *(_QWORD *)(v1 + 552) + 384;
        }
        else
        {
          memcpy(v15, **(const void ***)(*(_QWORD *)(v1 + 560) + 112), 4 * v6);
          v16 = *(_QWORD *)(v1 + 560) + 112;
        }
        memcpy(v20[2], *(const void **)(*(_QWORD *)v16 + 8), 4 * v6);
        if ((int)v6 >= 1)
        {
          v18 = 0;
          v19 = 4 * v6;
          do
          {
            fprintf(v11, "%.8f %.8f\n", *(float *)((char *)*v20 + v18), *(float *)((char *)v20[2] + v18));
            v18 += 4;
          }
          while (v19 != v18);
        }
        fclose(v11);
        v24 = &v20;
        std::vector<std::valarray<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v24);
      }
      return;
    }
    if (AUBeam2LogScope(void)::once != -1)
      dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
    if (AUBeam2LogScope(void)::scope)
    {
      v17 = *(NSObject **)AUBeam2LogScope(void)::scope;
      if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
        goto LABEL_20;
    }
    else
    {
      v17 = MEMORY[0x1E0C81028];
    }
    this = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (this)
    {
      *(_DWORD *)buf = 136315394;
      v26 = "AUBeam2.cpp";
      v27 = 1024;
      v28 = 2610;
      _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error: Number of unique bands is zero, won't dump post EQ", buf, 0x12u);
    }
    goto LABEL_20;
  }
  if (AUBeam2LogScope(void)::once != -1)
    dispatch_once(&AUBeam2LogScope(void)::once, &__block_literal_global_22967);
  if (AUBeam2LogScope(void)::scope)
  {
    v5 = *(NSObject **)AUBeam2LogScope(void)::scope;
    if (!*(_QWORD *)AUBeam2LogScope(void)::scope)
      return;
  }
  else
  {
    v5 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    v26 = "AUBeam2.cpp";
    v27 = 1024;
    v28 = 2598;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d AUBeam2: Error: Beam object not initialized, won't dump post EQ", buf, 0x12u);
  }
}

void sub_1B65608CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void **a18)
{
  a18 = (void **)&a14;
  std::vector<std::valarray<float>>::__destroy_vector::operator()[abi:ne180100](&a18);
  _Unwind_Resume(a1);
}

void AUBeam2::BlockProcessFunc(AUBeam2 *this, unsigned int a2, const AudioBufferList **a3, AudioBufferList **a4)
{
  uint64_t v6;
  uint64_t v7;
  const AudioBufferList *v8;
  unsigned int v9;
  float **v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  float ***v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  float **v34;
  float **v35;
  unsigned int v36;
  float *v37;
  float *v38;
  float *v39;
  float *v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  float **v45;
  uint64_t v46;
  uint64_t v47;
  float v48;
  float *v49;
  float *v50;
  float *p_mNumberBuffers;
  const AudioBufferList *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v6 = 2;
  if (*((_BYTE *)this + 549))
    v7 = 2;
  else
    v7 = 4;
  if (*((_BYTE *)this + 549))
    v6 = 4;
  v8 = a3[v6];
  p_mNumberBuffers = (float *)&a3[v7]->mNumberBuffers;
  v52 = v8;
  v50 = (float *)a4;
  MEMORY[0x1E0C80A78](this);
  v12 = (float *)((char *)&v50 - v11);
  if (*(_BYTE *)(v13 + 700))
  {
    v14 = v9;
    if (v9)
    {
      v15 = 0;
      v16 = 4 * v9;
      do
      {
        v12[v15 / 4] = (float)((float)rand() * 4.6566e-10) + -0.5;
        v12[v14 + v15 / 4] = (float)((float)rand() * 4.6566e-10) + -0.5;
        v15 += 4;
      }
      while (v16 != v15);
    }
    p_mNumberBuffers = v12;
    v52 = (const AudioBufferList *)&v12[v14];
  }
  v17 = (float ***)*((_QWORD *)this + 69);
  v18 = *((int *)v17 + 29);
  if (*((_DWORD *)v17 + 6))
  {
    CmhBEAM::deinterleave((uint64_t)v17, &p_mNumberBuffers, v17[4], *(_DWORD *)v17);
    CmhBEAM::deinterleave((uint64_t)v17, &v50, v17[5], *((_DWORD *)v17 + 2));
    CmhBEAM::deinterleave((uint64_t)v17, 0, v17[6], *((_DWORD *)v17 + 1));
  }
  else
  {
    v19 = *(unsigned int *)v17;
    if ((int)v19 >= 1)
    {
      v20 = 0;
      v21 = 8 * v19;
      do
      {
        v17[4][v20 / 8] = (&p_mNumberBuffers)[v20 / 8];
        v20 += 8;
      }
      while (v21 != v20);
    }
    v22 = *((unsigned int *)v17 + 2);
    if ((int)v22 >= 1)
    {
      v23 = 0;
      v24 = 8 * v22;
      do
      {
        v17[5][v23 / 8] = (float *)a4;
        v23 += 8;
      }
      while (v24 != v23);
    }
  }
  v25 = *((unsigned int *)v17 + 30);
  if (!(_DWORD)v25)
  {
    v31 = *((_DWORD *)v17 + 31);
    if (!v31)
      return;
    v32 = *((unsigned int *)v17 + 4);
    if ((int)v32 <= 0)
    {
      v36 = *((_DWORD *)v17 + 7);
    }
    else
    {
      v33 = 0;
      v34 = v17[4];
      v35 = v17[7];
      v36 = *((_DWORD *)v17 + 7);
      v37 = *v34;
      v38 = v34[1];
      v39 = *v35;
      v40 = v35[1];
      v42 = *((_DWORD *)v17 + 1);
      v41 = *((unsigned int *)v17 + 2);
      v43 = (int)(v36 * v32);
      do
      {
        v44 = v33 + v43;
        v39[v33 + v43] = v37[v33];
        v40[v33 + v43] = v38[v33];
        if ((int)v41 >= 1)
        {
          v45 = v17[8];
          v10 = v17[5];
          v46 = v41;
          do
          {
            v47 = (uint64_t)*v45++;
            v48 = *(float *)(v47 + 4 * v44);
            v49 = *v10++;
            v49[v33] = v48;
            --v46;
          }
          while (v46);
        }
        if (v42 > 0)
          (*v17[9])[v44] = (*v17[6])[v33];
        ++v33;
      }
      while (v33 != v32);
    }
    *((_DWORD *)v17 + 7) = v36 + 1;
    if (v36 + 1 == v31)
    {
      if (CmhBEAMprocOpt::process((CmhBEAMprocOpt *)(v17 + 11), v17[7], v17[8], v10))
        return;
      *((_DWORD *)v17 + 7) = 0;
    }
    goto LABEL_44;
  }
  if ((int)v25 < 1)
  {
LABEL_44:
    if (*((_DWORD *)v17 + 6))
    {
      CmhBEAM::interleave((CmhBEAM *)v17, v17[4], &p_mNumberBuffers, *(_DWORD *)v17);
      CmhBEAM::interleave((CmhBEAM *)v17, v17[5], &v50, *((_DWORD *)v17 + 2));
      CmhBEAM::interleave((CmhBEAM *)v17, v17[6], 0, *((_DWORD *)v17 + 1));
    }
    return;
  }
  v26 = 0;
  while (1)
  {
    v27 = v26 * v18;
    *v17[7] = &(*v17[4])[v26 * v18];
    v17[7][1] = &v17[4][1][v26 * v18];
    v28 = *((unsigned int *)v17 + 2);
    if ((int)v28 >= 1)
    {
      v29 = 0;
      v30 = 8 * v28;
      do
      {
        v17[8][v29 / 8] = &v17[5][v29 / 8][v27];
        v29 += 8;
      }
      while (v30 != v29);
    }
    if (*((int *)v17 + 1) > 0)
      *v17[9] = &(*v17[6])[v27];
    if (CmhBEAMprocOpt::process((CmhBEAMprocOpt *)(v17 + 11), v17[7], v17[8], v10))
      break;
    if (++v26 == v25)
      goto LABEL_44;
  }
}

void sub_1B6560E28(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void AUReverbSuppressor::~AUReverbSuppressor(AUReverbSuppressor *this)
{
  AUReverbSuppressor::~AUReverbSuppressor(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void **v2;
  AUReverbSuppressor *v3;
  uint64_t v4;
  AUReverbSuppressor *v5;
  uint64_t v6;
  AUReverbSuppressor *v7;
  uint64_t v8;
  AUReverbSuppressor *v9;
  uint64_t v10;
  AUReverbSuppressor *v11;
  uint64_t v12;
  AUReverbSuppressor *v13;
  uint64_t v14;
  AUReverbSuppressor *v15;
  uint64_t v16;
  AUReverbSuppressor *v17;
  uint64_t v18;
  AUReverbSuppressor *v19;
  uint64_t v20;
  AUReverbSuppressor *v21;
  uint64_t v22;
  void *v23;
  void *v24;
  AUReverbSuppressor *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  AUReverbSuppressor *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;

  *(_QWORD *)this = &off_1E69EB070;
  v2 = (void **)((char *)this + 4472);
  *((_QWORD *)this + 559) = &off_1E69EB2C0;
  if (*((_QWORD *)this + 599))
    operator delete(*((void **)this + 597));
  v3 = (AUReverbSuppressor *)*((_QWORD *)this + 590);
  if (v3 == (AUReverbSuppressor *)((char *)this + 4696))
  {
    v4 = 4;
    v3 = (AUReverbSuppressor *)((char *)this + 4696);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  Trackable::~Trackable(v2);
  *((_QWORD *)this + 517) = &off_1E69EB2C0;
  if (*((_QWORD *)this + 557))
    operator delete(*((void **)this + 555));
  v5 = (AUReverbSuppressor *)*((_QWORD *)this + 548);
  if (v5 == (AUReverbSuppressor *)((char *)this + 4360))
  {
    v6 = 4;
    v5 = (AUReverbSuppressor *)((char *)this + 4360);
  }
  else
  {
    if (!v5)
      goto LABEL_15;
    v6 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v5 + 8 * v6))();
LABEL_15:
  Trackable::~Trackable((void **)this + 517);
  *((_QWORD *)this + 475) = &off_1E69EB2C0;
  if (*((_QWORD *)this + 515))
    operator delete(*((void **)this + 513));
  v7 = (AUReverbSuppressor *)*((_QWORD *)this + 506);
  if (v7 == (AUReverbSuppressor *)((char *)this + 4024))
  {
    v8 = 4;
    v7 = (AUReverbSuppressor *)((char *)this + 4024);
  }
  else
  {
    if (!v7)
      goto LABEL_22;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_22:
  Trackable::~Trackable((void **)this + 475);
  *((_QWORD *)this + 433) = &off_1E69EB2C0;
  if (*((_QWORD *)this + 473))
    operator delete(*((void **)this + 471));
  v9 = (AUReverbSuppressor *)*((_QWORD *)this + 464);
  if (v9 == (AUReverbSuppressor *)((char *)this + 3688))
  {
    v10 = 4;
    v9 = (AUReverbSuppressor *)((char *)this + 3688);
  }
  else
  {
    if (!v9)
      goto LABEL_29;
    v10 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v9 + 8 * v10))();
LABEL_29:
  Trackable::~Trackable((void **)this + 433);
  *((_QWORD *)this + 391) = &off_1E69EB300;
  if (*((_QWORD *)this + 431))
    operator delete(*((void **)this + 429));
  v11 = (AUReverbSuppressor *)*((_QWORD *)this + 422);
  if (v11 == (AUReverbSuppressor *)((char *)this + 3352))
  {
    v12 = 4;
    v11 = (AUReverbSuppressor *)((char *)this + 3352);
  }
  else
  {
    if (!v11)
      goto LABEL_36;
    v12 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
LABEL_36:
  Trackable::~Trackable((void **)this + 391);
  *((_QWORD *)this + 349) = &off_1E69EB300;
  if (*((_QWORD *)this + 389))
    operator delete(*((void **)this + 387));
  v13 = (AUReverbSuppressor *)*((_QWORD *)this + 380);
  if (v13 == (AUReverbSuppressor *)((char *)this + 3016))
  {
    v14 = 4;
    v13 = (AUReverbSuppressor *)((char *)this + 3016);
  }
  else
  {
    if (!v13)
      goto LABEL_43;
    v14 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v13 + 8 * v14))();
LABEL_43:
  Trackable::~Trackable((void **)this + 349);
  *((_QWORD *)this + 307) = &off_1E69EB300;
  if (*((_QWORD *)this + 347))
    operator delete(*((void **)this + 345));
  v15 = (AUReverbSuppressor *)*((_QWORD *)this + 338);
  if (v15 == (AUReverbSuppressor *)((char *)this + 2680))
  {
    v16 = 4;
    v15 = (AUReverbSuppressor *)((char *)this + 2680);
  }
  else
  {
    if (!v15)
      goto LABEL_50;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_50:
  Trackable::~Trackable((void **)this + 307);
  *((_QWORD *)this + 265) = &off_1E69EB300;
  if (*((_QWORD *)this + 305))
    operator delete(*((void **)this + 303));
  v17 = (AUReverbSuppressor *)*((_QWORD *)this + 296);
  if (v17 == (AUReverbSuppressor *)((char *)this + 2344))
  {
    v18 = 4;
    v17 = (AUReverbSuppressor *)((char *)this + 2344);
  }
  else
  {
    if (!v17)
      goto LABEL_57;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_57:
  Trackable::~Trackable((void **)this + 265);
  *((_QWORD *)this + 223) = &off_1E69EB300;
  if (*((_QWORD *)this + 263))
    operator delete(*((void **)this + 261));
  v19 = (AUReverbSuppressor *)*((_QWORD *)this + 254);
  if (v19 == (AUReverbSuppressor *)((char *)this + 2008))
  {
    v20 = 4;
    v19 = (AUReverbSuppressor *)((char *)this + 2008);
  }
  else
  {
    if (!v19)
      goto LABEL_64;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_64:
  Trackable::~Trackable((void **)this + 223);
  *((_QWORD *)this + 181) = &off_1E69EB300;
  if (*((_QWORD *)this + 221))
    operator delete(*((void **)this + 219));
  v21 = (AUReverbSuppressor *)*((_QWORD *)this + 212);
  if (v21 == (AUReverbSuppressor *)((char *)this + 1672))
  {
    v22 = 4;
    v21 = (AUReverbSuppressor *)((char *)this + 1672);
  }
  else
  {
    if (!v21)
      goto LABEL_71;
    v22 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_71:
  Trackable::~Trackable((void **)this + 181);
  *((_QWORD *)this + 132) = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector((_QWORD *)this + 177);
  v23 = (void *)*((_QWORD *)this + 174);
  if (v23)
  {
    *((_QWORD *)this + 175) = v23;
    operator delete(v23);
  }
  v24 = (void *)*((_QWORD *)this + 171);
  if (v24)
  {
    *((_QWORD *)this + 172) = v24;
    operator delete(v24);
  }
  v25 = (AUReverbSuppressor *)*((_QWORD *)this + 163);
  if (v25 == (AUReverbSuppressor *)((char *)this + 1280))
  {
    v26 = 4;
    v25 = (AUReverbSuppressor *)((char *)this + 1280);
  }
  else
  {
    if (!v25)
      goto LABEL_80;
    v26 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v25 + 8 * v26))();
LABEL_80:
  Trackable::~Trackable((void **)this + 132);
  *((_QWORD *)this + 83) = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector((_QWORD *)this + 128);
  v27 = (void *)*((_QWORD *)this + 125);
  if (v27)
  {
    *((_QWORD *)this + 126) = v27;
    operator delete(v27);
  }
  v28 = (void *)*((_QWORD *)this + 122);
  if (v28)
  {
    *((_QWORD *)this + 123) = v28;
    operator delete(v28);
  }
  v29 = (AUReverbSuppressor *)*((_QWORD *)this + 114);
  if (v29 == (AUReverbSuppressor *)((char *)this + 888))
  {
    v30 = 4;
    v29 = (AUReverbSuppressor *)((char *)this + 888);
  }
  else
  {
    if (!v29)
      goto LABEL_89;
    v30 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
LABEL_89:
  Trackable::~Trackable((void **)this + 83);
  v31 = (void *)*((_QWORD *)this + 80);
  if (v31)
  {
    *((_QWORD *)this + 81) = v31;
    operator delete(v31);
  }
  v32 = (void *)*((_QWORD *)this + 77);
  if (v32)
  {
    *((_QWORD *)this + 78) = v32;
    operator delete(v32);
  }
  v33 = (void *)*((_QWORD *)this + 72);
  if (v33)
  {
    *((_QWORD *)this + 73) = v33;
    operator delete(v33);
  }
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned int>>>>::destroy(*((_QWORD **)this + 70));
  v34 = *((_QWORD *)this + 68);
  *((_QWORD *)this + 68) = 0;
  if (v34)
    (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUReverbSuppressor::Initialize(AUReverbSuppressor *this)
{
  uint64_t Element;
  int v3;
  unsigned int Global;
  void *v7;
  unsigned __int16 v8;
  char v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  double *v13;
  double v14;
  int64x2_t v15;
  __int128 v16;
  uint64_t v17;
  int64x2_t v18;
  int64x2_t v19;
  uint64_t v20;
  void *v21;
  char *v22;
  _QWORD *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  char *v30;
  char *v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;
  _QWORD *v45;
  void **v46;
  void **v47;
  uint64_t v48;
  uint64_t v49;
  void **v50;
  uint64_t v51;
  const char *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  void *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  BOOL v64;
  unint64_t v65;
  unint64_t v66;
  _QWORD *v67;
  void *v68;
  void *v69;
  uint64_t v70;
  _QWORD *exception;
  std::string v72;
  UInt32 ioDataSize[2];
  void *v74;
  uint64_t v75;
  void *v76;
  _BYTE __p[12];
  __int16 v78;
  _BYTE v79[18];
  uint64_t v80;
  int64x2_t v81;
  uint64_t v82;
  uint64_t v83;
  std::string v84;
  char v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  _QWORD v94[3];
  _QWORD *v95;
  __int128 v96;
  uint64_t v97;
  __int128 v98;
  uint64_t v99;
  void *v100;
  void *v101;
  void *v102;
  void *v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  void *outData[2];
  void **v108;
  void **v109;
  void *v110;
  void *v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  Element = ausdk::AUScope::SafeGetElement((AUReverbSuppressor *)((char *)this + 80), 0);
  v3 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUReverbSuppressor *)((char *)this + 128), 0) + 108);
  if (*(_DWORD *)(Element + 108) != 1 || v3 != 1)
    return 4294956428;
  Global = AUReverbSuppressor::GetGlobalProperty<($_0)14>(*((OpaqueAudioComponentInstance **)this + 1));
  outData[0] = 0;
  ioDataSize[0] = 8;
  if (AudioUnitGetProperty(*((AudioUnit *)this + 1), 2u, 0, 0, outData, ioDataSize))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__p = 136315650;
      *(_QWORD *)&__p[4] = "AUReverbSuppressor.cpp";
      v78 = 1024;
      *(_DWORD *)v79 = 467;
      *(_WORD *)&v79[4] = 2080;
      *(_QWORD *)&v79[6] = "SampleRate";
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d AudioUnitGetProperty failed for %s", __p, 0x1Cu);
    }
    exception = __cxa_allocate_exception(8uLL);
    *exception = MEMORY[0x1E0DE5060] + 16;
  }
  v7 = outData[0];
  v76 = outData[0];
  std::string::basic_string[abi:ne180100]<0>(__p, "com.apple.coreaudio");
  std::string::basic_string[abi:ne180100]<0>(outData, "ReverbSuppressor_disable");
  v8 = GetPreference<BOOL>(__p, (const UInt8 *)outData);
  if (SHIBYTE(v108) < 0)
    operator delete(outData[0]);
  if ((v79[9] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  if (v8 <= 0x100u)
    v9 = 0;
  else
    v9 = v8;
  AutoValue<BOOL,(LogTypes)0>::Set((AUReverbSuppressor *)((char *)this + 3464), v9);
  if (*((_DWORD *)this + 616))
  {
    *((_DWORD *)this + 616) = 0;
    Trackable::Uninitialize((AUReverbSuppressor *)((char *)this + 2456));
  }
  *((_QWORD *)this + 339) = 0;
  *((_QWORD *)this + 315) = 0;
  if (*((_DWORD *)this + 700))
  {
    *((_DWORD *)this + 700) = 0;
    Trackable::Uninitialize((AUReverbSuppressor *)((char *)this + 2792));
  }
  *((_QWORD *)this + 381) = 0;
  *((_QWORD *)this + 357) = 0;
  if (*((_DWORD *)this + 784))
  {
    *((_DWORD *)this + 784) = 0;
    Trackable::Uninitialize((AUReverbSuppressor *)((char *)this + 3128));
  }
  *((_QWORD *)this + 423) = 0;
  *((_QWORD *)this + 399) = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, "com.apple.coreaudio");
  std::string::basic_string[abi:ne180100]<0>(outData, "ReverbSuppressor_pass1GainFloor");
  v10 = GetPreference<float>(__p, (const UInt8 *)outData);
  if (SHIBYTE(v108) < 0)
    operator delete(outData[0]);
  if ((v79[9] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  if (HIDWORD(v10))
    AutoValue<float,(LogTypes)0>::Set((AUReverbSuppressor *)((char *)this + 2456), *(float *)&v10);
  std::string::basic_string[abi:ne180100]<0>(__p, "com.apple.coreaudio");
  std::string::basic_string[abi:ne180100]<0>(outData, "ReverbSuppressor_pass2GainFloor");
  v11 = GetPreference<float>(__p, (const UInt8 *)outData);
  if (SHIBYTE(v108) < 0)
    operator delete(outData[0]);
  if ((v79[9] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  if (HIDWORD(v11))
    AutoValue<float,(LogTypes)0>::Set((AUReverbSuppressor *)((char *)this + 2792), *(float *)&v11);
  std::string::basic_string[abi:ne180100]<0>(__p, "com.apple.coreaudio");
  std::string::basic_string[abi:ne180100]<0>(outData, "ReverbSuppressor_reverbTailGain");
  v12 = GetPreference<float>(__p, (const UInt8 *)outData);
  if (SHIBYTE(v108) < 0)
    operator delete(outData[0]);
  if ((v79[9] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  if (HIDWORD(v12))
    AutoValue<float,(LogTypes)0>::Set((AUReverbSuppressor *)((char *)this + 3128), *(float *)&v12);
  *(_QWORD *)ioDataSize = 0;
  v74 = 0;
  v75 = 0;
  v13 = (double *)*((_QWORD *)this + 70);
  if (!v13)
LABEL_44:
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      v14 = v13[4];
      if (*(double *)&v7 >= v14)
        break;
      v13 = *(double **)v13;
      if (!v13)
        goto LABEL_44;
    }
    if (v14 >= *(double *)&v7)
      break;
    v13 = (double *)*((_QWORD *)v13 + 1);
    if (!v13)
      goto LABEL_44;
  }
  if (ioDataSize != (UInt32 *)(v13 + 5))
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)ioDataSize, *((char **)v13 + 5), *((_QWORD *)v13 + 6), (uint64_t)(*((_QWORD *)v13 + 6) - *((_QWORD *)v13 + 5)) >> 2);
  AutoValue<BOOL,(LogTypes)0>::Set((AUReverbSuppressor *)((char *)this + 4136), 0);
  *(_DWORD *)__p = 0;
  std::vector<float>::resize((uint64_t)this + 576, Global, __p);
  DSPSplitComplexV<float>::DSPSplitComplexV(__p, Global);
  v15 = *(int64x2_t *)&v79[2];
  v16 = *(_OWORD *)((char *)this + 616);
  *(_OWORD *)&v79[2] = v16;
  v17 = *((_QWORD *)this + 79);
  *((_QWORD *)this + 79) = v80;
  v80 = v17;
  v18 = v81;
  v19 = *((int64x2_t *)this + 40);
  *((int64x2_t *)this + 40) = v81;
  v81 = v19;
  v20 = *((_QWORD *)this + 82);
  *((_QWORD *)this + 82) = v82;
  v82 = v20;
  *(int64x2_t *)((char *)this + 600) = vzip1q_s64(v15, v18);
  *(int64x2_t *)((char *)this + 616) = v15;
  if (v19.i64[0])
  {
    v81.i64[1] = v19.i64[0];
    operator delete((void *)v19.i64[0]);
    v21 = *(void **)&v79[2];
    if (!*(_QWORD *)&v79[2])
      goto LABEL_50;
    goto LABEL_49;
  }
  v21 = (void *)v16;
  if ((_QWORD)v16)
  {
LABEL_49:
    *(_QWORD *)&v79[10] = v21;
    operator delete(v21);
  }
LABEL_50:
  v22 = (char *)this + 664;
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::PreAllocate<unsigned int const&>((uint64_t)this + 664, Global);
  AUReverbSuppressor::UpdateState(this);
  v23 = (_QWORD *)operator new();
  std::string::basic_string[abi:ne180100]<0>(__p, "dereverb");
  outData[0] = (void *)Global;
  v72.__r_.__value_.__r.__words[0] = 2 * Global;
  Dereverb::Dereverb<float,(Dereverb::FirstPassTypes)0,(LogTypes)0>::Dereverb((uint64_t)v23, (uint64_t)__p, (unint64_t *)outData, (unint64_t *)&v72, (double *)&v76, (uint64_t)this + 664, (uint64_t)this + 2792, (uint64_t)this + 3128, (uint64_t)ioDataSize);
  *v23 = &off_1E69EB480;
  if ((v79[9] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  v24 = *((_QWORD *)this + 68);
  *((_QWORD *)this + 68) = v23;
  if (v24)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
  std::string::basic_string[abi:ne180100]<0>(&v72, "OutFrameNode");
  v25 = (void *)*((_QWORD *)this + 68);
  *(_QWORD *)__p = &off_1E69EB2E0;
  v79[10] = 0;
  v80 = 0;
  v81 = 0uLL;
  v83 = 0;
  if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v84, v72.__r_.__value_.__l.__data_, v72.__r_.__value_.__l.__size_);
  else
    v84 = v72;
  v85 = 0;
  v86 = 0u;
  v87 = 0u;
  v88 = 0u;
  v89 = 0u;
  v90 = 0u;
  v91 = 0u;
  v92 = 0u;
  v93 = 0;
  v27 = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(1uLL);
  v28 = &v27[v26];
  *v27 = v22;
  v29 = v27 + 1;
  v31 = (char *)*((_QWORD *)&v87 + 1);
  v30 = (char *)v88;
  v32 = v27;
  if ((_QWORD)v88 != *((_QWORD *)&v87 + 1))
  {
    do
    {
      v33 = *((_QWORD *)v30 - 1);
      v30 -= 8;
      *--v32 = v33;
    }
    while (v30 != v31);
    v30 = (char *)*((_QWORD *)&v87 + 1);
  }
  *((_QWORD *)&v87 + 1) = v32;
  *(_QWORD *)&v88 = v27 + 1;
  *((_QWORD *)&v88 + 1) = &v27[v26];
  if (v30)
  {
    operator delete(v30);
    v28 = (_QWORD *)*((_QWORD *)&v88 + 1);
  }
  *(_QWORD *)&v88 = v27 + 1;
  if (v29 >= v28)
  {
    v35 = ((uint64_t)v29 - *((_QWORD *)&v87 + 1)) >> 3;
    if ((unint64_t)(v35 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v36 = (uint64_t)v28 - *((_QWORD *)&v87 + 1);
    v37 = v36 >> 2;
    if (v36 >> 2 <= (unint64_t)(v35 + 1))
      v37 = v35 + 1;
    if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
      v38 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v38 = v37;
    if (v38)
      v38 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v38);
    else
      v39 = 0;
    v40 = (_QWORD *)(v38 + 8 * v35);
    v41 = v38 + 8 * v39;
    *v40 = v25;
    v34 = v40 + 1;
    v43 = (char *)*((_QWORD *)&v87 + 1);
    v42 = (char *)v88;
    if ((_QWORD)v88 != *((_QWORD *)&v87 + 1))
    {
      do
      {
        v44 = *((_QWORD *)v42 - 1);
        v42 -= 8;
        *--v40 = v44;
      }
      while (v42 != v43);
      v42 = (char *)*((_QWORD *)&v87 + 1);
    }
    *((_QWORD *)&v87 + 1) = v40;
    *(_QWORD *)&v88 = v34;
    *((_QWORD *)&v88 + 1) = v41;
    if (v42)
      operator delete(v42);
  }
  else
  {
    v27[1] = v25;
    v34 = v27 + 2;
  }
  *(_QWORD *)&v88 = v34;
  v82 = 0;
  *(_DWORD *)&__p[8] = 0;
  *(_QWORD *)__p = &off_1E69EB320;
  v45 = v94;
  v95 = 0;
  *(_QWORD *)&v96 = 0;
  DSPSplitComplexV<float>::DSPSplitComplexV(outData, 0);
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(&v98, 1uLL, (uint64_t)outData);
  if (v110)
  {
    v111 = v110;
    operator delete(v110);
  }
  if (v108)
  {
    v109 = v108;
    operator delete(v108);
  }
  v106 = 0;
  v46 = (void **)operator new(0x20uLL);
  *v46 = &off_1E69EBD70;
  v46[1] = AU::ReverbSuppressor::ApplyGainVector<float>;
  v46[2] = v22;
  v46[3] = v25;
  v109 = v46;
  std::__function::__value_func<DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::swap[abi:ne180100](outData, v94);
  v47 = v109;
  if (v109 == outData)
  {
    v48 = 4;
    v47 = outData;
  }
  else
  {
    if (!v109)
      goto LABEL_89;
    v48 = 5;
  }
  (*((void (**)(void))*v47 + v48))();
LABEL_89:
  *(_DWORD *)&__p[8] = 0;
  *((_QWORD *)&v96 + 1) = 0;
  v97 = 0;
  *(_QWORD *)&v79[2] = 0;
  Trackable::operator=((uint64_t)this + 1056, (uint64_t)__p);
  v49 = (uint64_t)v95;
  if (!v95)
  {
LABEL_92:
    v109 = (void **)v49;
    goto LABEL_94;
  }
  if (v95 != v94)
  {
    v49 = (*(uint64_t (**)(void))(*v95 + 16))();
    goto LABEL_92;
  }
  v109 = outData;
  (*(void (**)(_QWORD *, void **))(v94[0] + 24))(v94, outData);
LABEL_94:
  std::__function::__value_func<DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::swap[abi:ne180100](outData, (_QWORD *)this + 160);
  v50 = v109;
  if (v109 == outData)
  {
    v51 = 4;
    v50 = outData;
  }
  else
  {
    if (!v109)
      goto LABEL_99;
    v51 = 5;
  }
  (*((void (**)(void))*v50 + v51))();
LABEL_99:
  *((_OWORD *)this + 82) = v96;
  *((_QWORD *)this + 166) = v97;
  *(_OWORD *)((char *)this + 1336) = v98;
  DSPSplitComplexV<float>::operator=((uint64_t)this + 1352, (uint64_t)&v99);
  if (__p != (char *)this + 1056)
  {
    v53 = v104;
    v54 = v105;
    if (v105 <= *((_QWORD *)this + 179))
    {
      v59 = *((_QWORD *)this + 177);
      v60 = *((_QWORD *)this + 178);
      v61 = v60 - v105;
      if (v60 >= v105)
      {
        if (v105)
        {
          v65 = v105;
          do
          {
            DSPSplitComplexV<float>::operator=(v59, v53);
            v53 += 64;
            v59 += 64;
            --v65;
          }
          while (v65);
        }
        if (v60 != v54)
        {
          v66 = v54 - v60;
          v67 = (_QWORD *)(v59 + 24);
          do
          {
            v68 = (void *)v67[2];
            if (v68)
            {
              v67[3] = v68;
              operator delete(v68);
            }
            v69 = (void *)*(v67 - 1);
            if (v69)
            {
              *v67 = v69;
              operator delete(v69);
            }
            v67 += 8;
            v64 = __CFADD__(v66++, 1);
          }
          while (!v64);
        }
      }
      else
      {
        if (v60)
        {
          v62 = *((_QWORD *)this + 178);
          do
          {
            DSPSplitComplexV<float>::operator=(v59, v53);
            v53 += 64;
            v59 += 64;
            --v62;
          }
          while (v62);
        }
        if (v54 != v60)
        {
          v63 = 0;
          do
          {
            DSPSplitComplexV<float>::DSPSplitComplexV(v59 + v63, v53 + v63);
            v63 += 64;
            v64 = __CFADD__(v61++, 1);
          }
          while (!v64);
        }
      }
      *((_QWORD *)this + 178) = v54;
    }
    else
    {
      v55 = v105 << 6;
      if (v105 << 6 >= 0x7FFFFFFFFFFFFFC1)
        boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v52);
      v56 = operator new(v105 << 6);
      v57 = (void *)*((_QWORD *)this + 177);
      if (v57)
      {
        boost::container::vector<DSPSplitComplexV<float>,void,void>::priv_destroy_all((_QWORD *)this + 177);
        operator delete(v57);
      }
      v58 = 0;
      *((_QWORD *)this + 177) = v56;
      *((_QWORD *)this + 179) = v54;
      *((_QWORD *)this + 178) = 0;
      do
      {
        DSPSplitComplexV<float>::DSPSplitComplexV((uint64_t)v56 + v58, v53 + v58);
        v58 += 64;
      }
      while (v55 != v58);
      *((_QWORD *)this + 178) += v58 >> 6;
    }
  }
  *((_QWORD *)this + 180) = v106;
  *(_QWORD *)__p = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector(&v104);
  if (v102)
  {
    v103 = v102;
    operator delete(v102);
  }
  if (v100)
  {
    v101 = v100;
    operator delete(v100);
  }
  if (v95 == v94)
  {
    v70 = 4;
    goto LABEL_136;
  }
  if (v95)
  {
    v70 = 5;
    v45 = v95;
LABEL_136:
    (*(void (**)(_QWORD *))(*v45 + 8 * v70))(v45);
  }
  Trackable::~Trackable((void **)__p);
  if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v72.__r_.__value_.__l.__data_);
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::PreAllocate<unsigned int const&>((uint64_t)this + 1056, Global);
  Trackable::Initialize((uint64_t)this + 1056);
  AutoValue<BOOL,(LogTypes)0>::Set((AUReverbSuppressor *)((char *)this + 3800), 0);
  Trackable::Initialize((uint64_t)this + 4472);
  (*(void (**)(AUReverbSuppressor *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
  if (*(_QWORD *)ioDataSize)
  {
    v74 = *(void **)ioDataSize;
    operator delete(*(void **)ioDataSize);
  }
  return 0;
}

void sub_1B6561900(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, __int128 buf,uint64_t a21,uint64_t a22,void *__p,uint64_t a24)
{
  uint64_t v24;

  if (a2)
  {
    if (__p)
    {
      a24 = (uint64_t)__p;
      operator delete(__p);
    }
    if (a15 < 0)
      operator delete(a10);
    __cxa_begin_catch(exception_object);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315394;
      *(_QWORD *)((char *)&buf + 4) = "AUReverbSuppressor.cpp";
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = 310;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d ReverbSuppressor object failed to instantiate; AU going into soft bypass mode.",
        (uint8_t *)&buf,
        0x12u);
    }
    AutoValue<BOOL,(LogTypes)0>::Set((Trackable *)(v24 + 3800), 1);
    __cxa_end_catch();
    JUMPOUT(0x1B65617C8);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B6561A9C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  if (a2)
  {
    AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::~AutoValue((uint64_t)va);
    JUMPOUT(0x1B6561B80);
  }
  JUMPOUT(0x1B6561D24);
}

void sub_1B6561B14()
{
  JUMPOUT(0x1B6561D24);
}

void sub_1B6561B1C(void *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  void *v7;

  if (a2)
  {
    __cxa_begin_catch(a1);
    if (v3 != v2)
    {
      v5 = (_QWORD *)(v2 + 24);
      do
      {
        v6 = (void *)v5[2];
        if (v6)
        {
          v5[3] = v6;
          operator delete(v6);
        }
        v7 = (void *)*(v5 - 1);
        if (v7)
        {
          *v5 = v7;
          operator delete(v7);
        }
        v5 += 8;
        v4 -= 64;
      }
      while (v4);
    }
    __cxa_rethrow();
  }
  JUMPOUT(0x1B6561D24);
}

void sub_1B6561B6C(uint64_t a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    JUMPOUT(0x1B6561B78);
  }
  JUMPOUT(0x1B6561D24);
}

void sub_1B6561C14()
{
  __cxa_end_catch();
  JUMPOUT(0x1B6561D14);
}

void sub_1B6561CF0()
{
  __cxa_end_catch();
  JUMPOUT(0x1B6561D14);
}

void sub_1B6561D00(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x1B6561D24);
}

uint64_t AUReverbSuppressor::Reset(AUReverbSuppressor *this)
{
  AUReverbSuppressor::UpdateState(this);
  return 0;
}

uint64_t AUReverbSuppressor::GetPropertyInfo(OpaqueAudioComponentInstance **this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  unsigned int v8;

  if (a3)
    return 4294956417;
  switch(a2)
  {
    case 5101:
      *a6 = 0;
      v8 = 4 * AUReverbSuppressor::GetGlobalProperty<($_0)14>(this[1]);
LABEL_10:
      result = 0;
      *a5 = v8;
      return result;
    case 3700:
      *a6 = 0;
      goto LABEL_9;
    case 21:
      *a6 = 1;
LABEL_9:
      v8 = 4;
      goto LABEL_10;
  }
  return 4294956417;
}

uint64_t AUReverbSuppressor::GetProperty(AUReverbSuppressor *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  int v8;
  uint64_t v9;
  uint64_t v10;

  if (a3)
    return 4294956417;
  switch(a2)
  {
    case 5101:
      if (!*((_QWORD *)this + 68)
        || *((_DWORD *)this + 134) == 1
        || *(_BYTE *)AutoValue<BOOL,(LogTypes)0>::Get((uint64_t)this + 4472))
      {
        result = AUReverbSuppressor::GetGlobalProperty<($_0)14>(*((OpaqueAudioComponentInstance **)this + 1));
        if (!(_DWORD)result)
          return result;
        memset_pattern16(a5, &unk_1B6627B80, 4 * result);
      }
      else
      {
        v9 = AutoValue<std::vector<float>,(LogTypes)0>::Get(*((_QWORD *)this + 68), 0);
        v10 = *(_QWORD *)(v9 + 8);
        if (v10 != *(_QWORD *)v9)
          memmove(a5, *(const void **)v9, v10 - *(_QWORD *)v9);
      }
      return 0;
    case 3700:
      result = 0;
      v8 = *((unsigned __int8 *)this + 376);
      goto LABEL_14;
    case 21:
      result = 0;
      v8 = *((_DWORD *)this + 134);
LABEL_14:
      *a5 = v8;
      return result;
  }
  return 4294956417;
}

uint64_t AUReverbSuppressor::SetProperty(AUReverbSuppressor *this, int a2, int a3, unsigned int a4, const __CFDictionary **a5)
{
  uint64_t result;
  const void *v7;
  const void *v8;
  CFTypeID v9;
  uint64_t **v10;
  unint64_t v11;
  uint64_t v12;
  const void *v14;
  const __CFData *v15;
  const UInt8 *BytePtr;
  CFIndex Length;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  unsigned __int16 *v24;
  BOOL v25;
  std::string::size_type size;
  double v27;
  uint64_t *v28;
  uint64_t **v29;
  uint64_t **v30;
  double v31;
  void *v32;
  uint64_t v33;
  uint64_t *v34;
  _QWORD *v35;
  std::logic_error *exception;
  std::runtime_error *v37;
  std::runtime_error *v38;
  uint64_t v39;
  std::string theData;
  std::string v41;
  CFTypeRef cf;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  _BYTE *v46;
  void *v47;
  void *v48;
  CFDictionaryRef theDict;
  char v50;
  char v51;
  char v52;
  _BYTE __p[28];
  __int16 v54;
  double v55;
  __int16 v56;
  double v57;
  _BYTE buf[24];
  uint64_t v59;
  void *v60;
  void *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (a3)
    return 4294956417;
  switch(a2)
  {
    case 5100:
      if (!a5)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "AUReverbSuppressor.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 502;
          _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d The CFDictionaryRef passed to SetProperty is null.", buf, 0x12u);
        }
        return 4294956445;
      }
      v7 = applesauce::CF::details::at_key<char const(&)[12]>(*a5, "ReverbTails");
      if (v7)
      {
        v8 = v7;
        CFRetain(v7);
        v9 = CFGetTypeID(v8);
        if (v9 == CFDictionaryGetTypeID())
        {
          theDict = (CFDictionaryRef)v8;
          v50 = 1;
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "AUReverbSuppressor.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 519;
            _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO, "%25s:%-5d 'ReverbTails' dictionary found in Plist.", buf, 0x12u);
          }
          v10 = (uint64_t **)((char *)this + 560);
          std::__tree<std::__value_type<unsigned int,std::vector<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned int>>>>::destroy(*((_QWORD **)this + 70));
          *((_QWORD *)this + 69) = (char *)this + 560;
          *((_QWORD *)this + 71) = 0;
          *((_QWORD *)this + 70) = 0;
          applesauce::CF::DictionaryRef_iterator<std::string,applesauce::CF::DataRef>::DictionaryRef_iterator((uint64_t)buf, theDict);
          applesauce::CF::DictionaryRef_iterator<std::string,applesauce::CF::DataRef>::DictionaryRef_iterator((uint64_t)&v43, theDict);
          v44 = (v46 - (_BYTE *)v45) >> 3;
          v39 = MEMORY[0x1E0DE5060] + 16;
          while (1)
          {
            if (*(_QWORD *)buf && (v11 = *(_QWORD *)&buf[8], *(_QWORD *)&buf[8] != (v59 - *(_QWORD *)&buf[16]) >> 3))
            {
              v12 = v43;
            }
            else
            {
              v12 = v43;
              if (!v43 || v44 == (v46 - (_BYTE *)v45) >> 3)
                goto LABEL_83;
              v11 = *(_QWORD *)&buf[8];
            }
            if (*(_QWORD *)buf == v12 && v11 == v44)
            {
LABEL_83:
              if (v47)
              {
                v48 = v47;
                operator delete(v47);
              }
              if (v45)
              {
                v46 = v45;
                operator delete(v45);
              }
              if (v60)
              {
                v61 = v60;
                operator delete(v60);
              }
              if (*(_QWORD *)&buf[16])
              {
                v59 = *(_QWORD *)&buf[16];
                operator delete(*(void **)&buf[16]);
              }
              goto LABEL_91;
            }
            if ((v11 & 0x8000000000000000) != 0 || v11 >= (v59 - *(_QWORD *)&buf[16]) >> 3)
            {
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(exception, "DictionaryRef_iterator iterator out of range.");
              exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
            }
            applesauce::CF::convert_to<std::string,0>(*(const __CFString **)(*(_QWORD *)&buf[16] + 8 * v11), (uint64_t)__p);
            v14 = (const void *)*((_QWORD *)v60 + *(_QWORD *)&buf[8]);
            if (!v14)
            {
              v41 = *(std::string *)__p;
              cf = 0;
LABEL_94:
              v37 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v37, "Could not construct");
            }
            CFRetain(*((CFTypeRef *)v60 + *(_QWORD *)&buf[8]));
            applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&theData, v14);
            v15 = (const __CFData *)theData.__r_.__value_.__r.__words[0];
            v41 = *(std::string *)__p;
            cf = (CFTypeRef)theData.__r_.__value_.__r.__words[0];
            if (!theData.__r_.__value_.__r.__words[0])
              goto LABEL_94;
            BytePtr = CFDataGetBytePtr((CFDataRef)theData.__r_.__value_.__l.__data_);
            Length = CFDataGetLength(v15);
            if ((Length & 3) != 0)
            {
              v38 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v38, "de-serialization data size mismatch");
            }
            memset(__p, 0, 24);
            std::vector<float>::__init_with_size[abi:ne180100]<float const*,float const*>(__p, BytePtr, (uint64_t)&BytePtr[Length & 0xFFFFFFFFFFFFFFFCLL], Length >> 2);
            v18 = *(char **)__p;
            v19 = *(_QWORD *)&__p[8];
            memset(__p, 0, 24);
            v20 = v19 - (_QWORD)v18;
            if ((char *)v19 != v18)
            {
              v21 = v20 >> 2;
              if ((unint64_t)(v20 >> 2) <= 1)
                v21 = 1;
              v22 = (unsigned int *)v18;
              do
              {
                *v22 = bswap32(*v22);
                ++v22;
                --v21;
              }
              while (v21);
              if (*(_QWORD *)__p)
              {
                *(_QWORD *)&__p[8] = *(_QWORD *)__p;
                operator delete(*(void **)__p);
              }
            }
            if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
              std::string::__init_copy_ctor_external(&theData, v41.__r_.__value_.__l.__data_, v41.__r_.__value_.__l.__size_);
            else
              theData = v41;
            std::string::basic_string((std::string *)__p, &theData, 0, 2uLL, (std::allocator<char> *)&v51);
            v23 = __p[23];
            if (__p[23] < 0)
              v23 = *(_QWORD *)&__p[8];
            if (v23 != 2)
              break;
            v24 = *(unsigned __int16 **)__p;
            if (__p[23] >= 0)
              v24 = (unsigned __int16 *)__p;
            v25 = *v24 == 29542;
            if ((__p[23] & 0x80000000) != 0)
              goto LABEL_47;
LABEL_48:
            if (!v25)
            {
              v35 = __cxa_allocate_exception(8uLL);
              *v35 = v39;
            }
            if ((theData.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              size = HIBYTE(theData.__r_.__value_.__r.__words[2]);
            else
              size = theData.__r_.__value_.__l.__size_;
            std::string::basic_string((std::string *)__p, &theData, 2uLL, size, (std::allocator<char> *)&v52);
            v27 = std::stod((const std::string *)__p, 0);
            if ((__p[23] & 0x80000000) != 0)
              operator delete(*(void **)__p);
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)__p = 136316162;
              *(_QWORD *)&__p[4] = "AUReverbSuppressor.cpp";
              *(_WORD *)&__p[12] = 1024;
              *(_DWORD *)&__p[14] = 557;
              *(_WORD *)&__p[18] = 2048;
              *(_QWORD *)&__p[20] = v20 >> 2;
              v54 = 2048;
              v55 = (double)(unint64_t)(v20 >> 2) / v27 * 1000.0;
              v56 = 2048;
              v57 = v27;
              _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO, "%25s:%-5d Found a %zu-element (%gms) reverb tail for the %gHz sample-rate.", __p, 0x30u);
            }
            v28 = *v10;
            v29 = (uint64_t **)((char *)this + 560);
            v30 = (uint64_t **)((char *)this + 560);
            if (*v10)
            {
              while (1)
              {
                while (1)
                {
                  v30 = (uint64_t **)v28;
                  v31 = *((double *)v28 + 4);
                  if (v27 >= v31)
                    break;
                  v28 = (uint64_t *)*v28;
                  v29 = v30;
                  if (!*v30)
                    goto LABEL_63;
                }
                if (v31 >= v27)
                  break;
                v28 = (uint64_t *)v28[1];
                if (!v28)
                {
                  v29 = v30 + 1;
                  goto LABEL_63;
                }
              }
              v32 = v28;
            }
            else
            {
LABEL_63:
              v32 = operator new(0x40uLL);
              *((double *)v32 + 4) = v27;
              *((_QWORD *)v32 + 6) = 0;
              *((_QWORD *)v32 + 7) = 0;
              *((_QWORD *)v32 + 5) = 0;
              *(_QWORD *)v32 = 0;
              *((_QWORD *)v32 + 1) = 0;
              *((_QWORD *)v32 + 2) = v30;
              *v29 = (uint64_t *)v32;
              v33 = **((_QWORD **)this + 69);
              v34 = (uint64_t *)v32;
              if (v33)
              {
                *((_QWORD *)this + 69) = v33;
                v34 = *v29;
              }
              std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 70), v34);
              ++*((_QWORD *)this + 71);
            }
            std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)v32 + 40, v18, v19, v20 >> 2);
            if (SHIBYTE(theData.__r_.__value_.__r.__words[2]) < 0)
              operator delete(theData.__r_.__value_.__l.__data_);
            if (v18)
              operator delete(v18);
            if (cf)
              CFRelease(cf);
            if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v41.__r_.__value_.__l.__data_);
            ++*(_QWORD *)&buf[8];
          }
          v25 = 0;
          if ((__p[23] & 0x80000000) == 0)
            goto LABEL_48;
LABEL_47:
          operator delete(*(void **)__p);
          goto LABEL_48;
        }
        CFRelease(v8);
      }
      LOBYTE(theDict) = 0;
      v50 = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "AUReverbSuppressor.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 515;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%25s:%-5d 'ReverbTails' dictionary is not present in Plist.", buf, 0x12u);
      }
LABEL_91:
      std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&theDict);
      return 0;
    case 3700:
      result = 0;
      *((_BYTE *)this + 376) = *(_BYTE *)a5;
      break;
    case 21:
      result = 0;
      *((_DWORD *)this + 134) = *(_DWORD *)a5;
      break;
    default:
      return 4294956417;
  }
  return result;
}

void sub_1B65626E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  void *v35;
  uint64_t v36;

  if (a20 < 0)
    operator delete(__p);
  if (v35)
    operator delete(v35);
  std::pair<std::string,applesauce::CF::DataRef>::~pair((uint64_t)&a22);
  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::~DictionaryRef_iterator(&a27);
  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::~DictionaryRef_iterator((_QWORD *)(v36 - 192));
  std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a35);
  _Unwind_Resume(a1);
}

void sub_1B656278C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a40 < 0)
    operator delete(__p);
  JUMPOUT(0x1B656276CLL);
}

void sub_1B65627A4(uint64_t a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x1B6562784);
}

uint64_t AUReverbSuppressor::SetParameter(AUReverbSuppressor *this, unsigned int a2, int a3, float a4)
{
  uint64_t result;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;

  if (a3)
    return 4294956418;
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  ausdk::AUElement::SetParameter(v9, a2, a4, 0);
  result = 0;
  ++*((_DWORD *)this + 132);
  return result;
}

uint64_t AUReverbSuppressor::CanScheduleParameters(AUReverbSuppressor *this)
{
  return 0;
}

uint64_t AUReverbSuppressor::ProcessMultipleBufferLists(AUReverbSuppressor *this, unsigned int *a2, unsigned int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  int v12;
  uint64_t v13;
  AudioBufferList *v14;
  char *mData;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  const void **v19;
  const void **v20;
  const void *v21;
  char *v22;
  char *v23;
  AudioBufferList *v24;
  unint64_t mDataByteSize;
  void *v26;
  uint64_t v27;
  unint64_t v28;

  v12 = *((_DWORD *)this + 132);
  if (*((_DWORD *)this + 133) != v12)
  {
    AUReverbSuppressor::UpdateState(this);
    *((_DWORD *)this + 133) = v12;
  }
  v13 = a3;
  if (a3 != (uint64_t)(*((_QWORD *)this + 73) - *((_QWORD *)this + 72)) >> 2)
    __assert_rtn("ProcessMultipleBufferLists", "AUReverbSuppressor.cpp", 691, "inFramesToProcess == mInputBlockVector.size()");
  if (DSPSplitComplexV<float>::size((_QWORD *)this + 75) != a3)
    __assert_rtn("ProcessMultipleBufferLists", "AUReverbSuppressor.cpp", 692, "inFramesToProcess == mInputFrameVector.size()");
  if (*((_DWORD *)this + 134) == 1 || *(_BYTE *)AutoValue<BOOL,(LogTypes)0>::Get((uint64_t)this + 4472))
  {
    if (a6 && *a7 && 2 * a3)
      memmove((*a7)->mBuffers[0].mData, (*a5)->mBuffers[0].mData, 8 * a3);
    if (a6 >= 2)
    {
      v14 = a7[1];
      if (v14)
        vDSP_vfill(AUReverbSuppressor::ProcessMultipleBufferLists(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**)::kOnef, (float *)v14->mBuffers[0].mData, 1, (unint64_t)v14->mBuffers[0].mDataByteSize >> 2);
    }
  }
  else
  {
    if (a3)
    {
      mData = (char *)(*a5)->mBuffers[0].mData;
      v16 = &mData[4 * a3];
      memmove(*((void **)this + 75), mData, 4 * a3);
      memmove(*((void **)this + 76), v16, 4 * a3);
    }
    ++*((_QWORD *)this + 85);
    v17 = *((_QWORD *)this + 118);
    if (*((_QWORD *)this + 119) < v17)
      __assert_rtn("DecrementCirc", "AutoValue.h", 491, "index <= _C");
    if (!v17)
      v17 = *((_QWORD *)this + 119);
    v18 = v17 - 1;
    *((_QWORD *)this + 118) = v18;
    if (*((_QWORD *)this + 129) <= v18)
      __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
    DSPSplitComplexV<float>::operator=(*((_QWORD *)this + 128) + (v18 << 6), (uint64_t)this + 600);
    if (*((_DWORD *)this + 168) != 1)
    {
      *((_DWORD *)this + 168) = 1;
      Trackable::Uninitialize((AUReverbSuppressor *)((char *)this + 664));
    }
    *((_QWORD *)this + 115) = 0;
    *((_QWORD *)this + 91) = 0;
    v19 = (const void **)AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::Get((uint64_t)this + 1056);
    if (a3 && a6 && *a7)
    {
      v20 = v19;
      v21 = *v19;
      v22 = (char *)(*a7)->mBuffers[0].mData;
      v23 = &v22[4 * a3];
      memmove(v22, v21, 4 * v13);
      memmove(v23, v20[1], 4 * v13);
    }
    if (a6 >= 2)
    {
      v24 = a7[1];
      if (v24)
      {
        mDataByteSize = v24->mBuffers[0].mDataByteSize;
        v26 = v24->mBuffers[0].mData;
        v27 = AutoValue<std::vector<float>,(LogTypes)0>::Get(*((_QWORD *)this + 68), 0);
        v28 = (uint64_t)(*(_QWORD *)(v27 + 8) - *(_QWORD *)v27) >> 2;
        if (v28 >= mDataByteSize >> 2)
          v28 = mDataByteSize >> 2;
        if (v28)
          memmove(v26, *(const void **)v27, 4 * v28);
      }
    }
  }
  return 0;
}

uint64_t AUReverbSuppressor::Render(AUReverbSuppressor *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  ausdk::AUInputElement *Element;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  size_t v18;
  uint64_t v19;
  ausdk::AUIOElement *v20;
  _BYTE v21[12];
  unsigned int v22;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  v22 = 0;
  v8 = (AUReverbSuppressor *)((char *)this + 80);
  Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUReverbSuppressor *)((char *)this + 80), 0);
  result = ausdk::AUInputElement::PullInput(Element, &v22, a3, 0, a4);
  if (!(_DWORD)result)
  {
    v11 = ausdk::AUScope::SafeGetElement(v8, 0);
    v23[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v11 + 144));
    v12 = *((_QWORD *)this + 21);
    if (v12)
    {
      v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
      LODWORD(v13) = v12;
    }
    else
    {
      v13 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
    }
    v14 = v13;
    MEMORY[0x1E0C80A78](v12);
    v17 = &v21[-v16];
    if (v15 >= 0x200)
      v18 = 512;
    else
      v18 = v15;
    bzero(&v21[-v16], v18);
    if ((_DWORD)v13)
    {
      v19 = 0;
      do
      {
        v20 = (ausdk::AUIOElement *)ausdk::AUScope::SafeGetElement((AUReverbSuppressor *)((char *)this + 128), v19);
        *(_QWORD *)&v17[8 * v19++] = ausdk::AUIOElement::PrepareBuffer(v20, a4);
      }
      while (v14 != v19);
    }
    return (*(uint64_t (**)(AUReverbSuppressor *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, _BYTE *))(*(_QWORD *)this + 184))(this, a2, a4, 1, v23, v14, v17);
  }
  return result;
}

BOOL AUReverbSuppressor::BusCountWritable(AUReverbSuppressor *this, int a2)
{
  return (a2 - 1) <= 1 && *((_BYTE *)this + 17) == 0;
}

uint64_t AUReverbSuppressor::SetBusCount(AUReverbSuppressor *this, int a2, unsigned int a3)
{
  int64x2_t *v4;
  unsigned int v5;
  NSObject *v7;
  const char *v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  unsigned int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
  {
    if (a3 - 1 <= 1)
    {
      v4 = (int64x2_t *)((char *)this + 128);
      v5 = a3;
      goto LABEL_7;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return 4294956445;
    v9 = 136315650;
    v10 = "AUReverbSuppressor.cpp";
    v11 = 1024;
    v12 = 381;
    v13 = 1024;
    v14 = a3;
    v7 = MEMORY[0x1E0C81028];
    v8 = "%25s:%-5d Invalid number (%u) of output buses requested. We only support 12 buses.";
    goto LABEL_13;
  }
  if (a2 != 1)
    return 4294956430;
  if (a3 == 1)
  {
    v4 = (int64x2_t *)((char *)this + 80);
    v5 = 1;
LABEL_7:
    ausdk::AUScope::SetNumberOfElements(v4, v5);
    return 0;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v9 = 136315650;
    v10 = "AUReverbSuppressor.cpp";
    v11 = 1024;
    v12 = 372;
    v13 = 1024;
    v14 = a3;
    v7 = MEMORY[0x1E0C81028];
    v8 = "%25s:%-5d Invalid number (%u) of input buses requested. We only support 1 bus.";
LABEL_13:
    _os_log_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v9, 0x18u);
  }
  return 4294956445;
}

uint64_t AUReverbSuppressor::GetParameterList(AUReverbSuppressor *this, int a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int v4;
  uint64_t result;

  if (a2)
  {
    v4 = 0;
    result = 4294956418;
  }
  else
  {
    result = 0;
    if (a3)
    {
      *(_QWORD *)a3 = 0x100000000;
      a3[2] = 2;
    }
    v4 = 3;
  }
  *a4 = v4;
  return result;
}

uint64_t AUReverbSuppressor::GetParameterInfo(AUReverbSuppressor *this, int a2, int a3, AudioUnitParameterInfo *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  const __CFString *v8;
  uint64_t v9;
  AudioUnitParameterValue v10;
  _QWORD v11[5];

  if (a2)
    return 4294956430;
  v11[3] = v4;
  v11[4] = v5;
  switch(a3)
  {
    case 2:
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)v11, "Reverb tail gain (dB)");
      v8 = (const __CFString *)v11[0];
      qmemcpy(a4, "Reverb tail gain (dB)", 21);
      v9 = 0x41F00000C1F00000;
      v10 = 0.0;
      goto LABEL_9;
    case 1:
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)v11, "Pass 2 Gain floor (dB)");
      v8 = (const __CFString *)v11[0];
      qmemcpy(a4, "Pass 2 Gain floor (dB)", 22);
      v9 = 3259498496;
      v10 = -18.0;
      goto LABEL_9;
    case 0:
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)v11, "Pass 1 Gain floor (dB)");
      v8 = (const __CFString *)v11[0];
      qmemcpy(a4, "Pass 1 Gain floor (dB)", 22);
      v9 = 3259498496;
      v10 = -24.0;
LABEL_9:
      result = 0;
      a4->cfNameString = v8;
      a4->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&a4->minValue = v9;
      a4->defaultValue = v10;
      a4->flags = -939524080;
      return result;
  }
  return 4294956418;
}

uint64_t AUReverbSuppressor::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
    ++*((_DWORD *)this + 132);
  return result;
}

double AUReverbSuppressor::GetLatency(AUReverbSuppressor *this)
{
  return 0.0;
}

double AUReverbSuppressor::GetTailTime(AUReverbSuppressor *this)
{
  return 0.0;
}

uint64_t AUReverbSuppressor::SupportsTail(AUReverbSuppressor *this)
{
  return 1;
}

BOOL AUReverbSuppressor::StreamFormatWritable(AUReverbSuppressor *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUReverbSuppressor::SupportedNumChannels(AUReverbSuppressor *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUReverbSuppressor::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

BOOL AUReverbSuppressor::ValidFormat(AUReverbSuppressor *this, const AudioStreamBasicDescription *a2, int a3, AudioStreamBasicDescription *a4)
{
  _BOOL4 v5;
  UInt32 mBytesPerPacket;
  UInt32 mChannelsPerFrame;
  UInt32 mBytesPerFrame;
  UInt32 mBitsPerChannel;
  BOOL v10;
  BOOL v12;
  _BOOL8 result;
  AudioFormatFlags mFormatFlags;

  if ((_DWORD)a2 == 2 && a3 == 1)
  {
    if (ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2))
      v5 = (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
    else
      v5 = 0;
    return a4->mChannelsPerFrame == 1 && v5;
  }
  else
  {
    mBytesPerPacket = a4->mBytesPerPacket;
    mBytesPerFrame = a4->mBytesPerFrame;
    mChannelsPerFrame = a4->mChannelsPerFrame;
    mBitsPerChannel = a4->mBitsPerChannel;
    v10 = a4->mFramesPerPacket == 1 && mBytesPerFrame == mBytesPerPacket;
    v12 = !v10 || mBitsPerChannel >> 3 > mBytesPerFrame || mChannelsPerFrame == 0;
    if (!v12
      && ((mFormatFlags = a4->mFormatFlags, (mFormatFlags & 0x20) != 0)
       || (v10 = mBytesPerPacket == mBytesPerPacket / mChannelsPerFrame * mChannelsPerFrame,
           mBytesPerPacket /= mChannelsPerFrame,
           v10)))
    {
      result = 0;
      if ((mFormatFlags & 2) == 0 && 8 * mBytesPerPacket == mBitsPerChannel && (a4->mFormatFlags & 1) != 0)
      {
        result = 0;
        if ((mFormatFlags & 0x1F84) == 0 && mBytesPerPacket == 8 && mChannelsPerFrame == 1)
          return a4->mFormatID == 1718773105;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void AUReverbSuppressor::UpdateState(AUReverbSuppressor *this)
{
  Trackable *v2;
  uint64_t v3;
  ausdk::AUElement *v4;
  ausdk::AUElement **v5;
  float Parameter;
  uint64_t v7;
  ausdk::AUElement *v8;
  ausdk::AUElement **v9;
  float v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  float v14;

  v2 = (AUReverbSuppressor *)((char *)this + 1448);
  v3 = *((_QWORD *)this + 9);
  if (v3)
  {
    v4 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 32))(v3, 0);
  }
  else
  {
    v5 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v5)
      v4 = 0;
    else
      v4 = *v5;
  }
  Parameter = ausdk::AUElement::GetParameter(v4, 0);
  AutoValue<float,(LogTypes)0>::Set(v2, Parameter);
  v7 = *((_QWORD *)this + 9);
  if (v7)
  {
    v8 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
  }
  else
  {
    v9 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v9)
      v8 = 0;
    else
      v8 = *v9;
  }
  v10 = ausdk::AUElement::GetParameter(v8, 1u);
  AutoValue<float,(LogTypes)0>::Set((AUReverbSuppressor *)((char *)this + 1784), v10);
  v11 = *((_QWORD *)this + 9);
  if (v11)
  {
    v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
  }
  else
  {
    v13 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v13)
      v12 = 0;
    else
      v12 = *v13;
  }
  v14 = ausdk::AUElement::GetParameter(v12, 2u);
  AutoValue<float,(LogTypes)0>::Set((AUReverbSuppressor *)((char *)this + 2120), v14);
}

uint64_t DSPSplitComplexV<float>::size(_QWORD *a1)
{
  uint64_t result;

  result = (uint64_t)(a1[3] - a1[2]) >> 2;
  if (result != (uint64_t)(a1[6] - a1[5]) >> 2)
    __assert_rtn("size", "VectorUtils.h", 300, "mRealVector.size() == mImagVector.size()");
  return result;
}

unint64_t AutoValue<BOOL,(LogTypes)0>::Get(uint64_t a1)
{
  _QWORD *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  char v12;
  std::locale v14;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"WARNING: Calling Get() on an AutoValue ('", 41);
    v3 = *(char *)(a1 + 95);
    if (v3 >= 0)
      v4 = a1 + 72;
    else
      v4 = *(_QWORD *)(a1 + 72);
    if (v3 >= 0)
      v5 = *(unsigned __int8 *)(a1 + 95);
    else
      v5 = *(_QWORD *)(a1 + 80);
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, v4, v5);
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"') without initializing first. Initializing now.", 48);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v14);
    std::ostream::put();
    std::ostream::flush();
    Trackable::Initialize(a1);
  }
  v9 = *(_DWORD *)(a1 + 8);
  if (v9 == 2)
  {
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 272) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      v12 = *(_BYTE *)AutoValue<BOOL,(LogTypes)0>::Get(*(_QWORD *)(a1 + 256));
      *(_BYTE *)AutoValue<BOOL,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280)) = v12;
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 16);
    }
  }
  else if (v9 != 1)
  {
    if (!*(_BYTE *)(a1 + 24))
      __assert_rtn("Get", "AutoValue.h", 668, "_isInitialized == true");
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 264) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a1 + 16);
      v10 = AutoValue<BOOL,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
      v11 = *(_QWORD *)(a1 + 248);
      if (!v11)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)v11 + 48))(v11, v10);
    }
  }
  return AutoValue<BOOL,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
}

void sub_1B65633CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::Get(uint64_t a1)
{
  _QWORD *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  std::locale v15;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"WARNING: Calling Get() on an AutoValue ('", 41);
    v3 = *(char *)(a1 + 95);
    if (v3 >= 0)
      v4 = a1 + 72;
    else
      v4 = *(_QWORD *)(a1 + 72);
    if (v3 >= 0)
      v5 = *(unsigned __int8 *)(a1 + 95);
    else
      v5 = *(_QWORD *)(a1 + 80);
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, v4, v5);
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"') without initializing first. Initializing now.", 48);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v15, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v15);
    std::ostream::put();
    std::ostream::flush();
    Trackable::Initialize(a1);
  }
  v9 = *(_DWORD *)(a1 + 8);
  if (v9 == 2)
  {
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 272) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      v12 = AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::Get(*(_QWORD *)(a1 + 256));
      v13 = AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
      DSPSplitComplexV<float>::operator=(v13, v12);
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 16);
    }
  }
  else if (v9 != 1)
  {
    if (!*(_BYTE *)(a1 + 24))
      __assert_rtn("Get", "AutoValue.h", 668, "_isInitialized == true");
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 264) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a1 + 16);
      v10 = AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
      v11 = *(_QWORD *)(a1 + 248);
      if (!v11)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, v10);
    }
  }
  return AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
}

void sub_1B65635A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t AutoValue<std::vector<float>,(LogTypes)0>::Get(uint64_t a1, unint64_t a2)
{
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  const std::locale::facet *v10;
  int v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::locale v21;

  if (*(_QWORD *)(a1 + 344) < a2)
    __assert_rtn("Get", "AutoValue.h", 655, "delay <= _C");
  if (!*(_BYTE *)(a1 + 24))
  {
    v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"WARNING: Calling Get() on an AutoValue ('", 41);
    v5 = *(char *)(a1 + 95);
    if (v5 >= 0)
      v6 = a1 + 72;
    else
      v6 = *(_QWORD *)(a1 + 72);
    if (v5 >= 0)
      v7 = *(unsigned __int8 *)(a1 + 95);
    else
      v7 = *(_QWORD *)(a1 + 80);
    v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, v6, v7);
    v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"') without initializing first. Initializing now.", 48);
    std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
    v10 = std::locale::use_facet(&v21, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
    std::locale::~locale(&v21);
    std::ostream::put();
    std::ostream::flush();
    Trackable::Initialize(a1);
  }
  v11 = *(_DWORD *)(a1 + 8);
  if (v11 == 2)
  {
    Trackable::GetRevision((Trackable *)a1);
    v13 = *(_QWORD *)(a1 + 272);
    v14 = *(_QWORD *)(a1 + 16);
    if (a2)
      goto LABEL_20;
    if (v13 < v14)
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      v15 = AutoValue<std::vector<float>,(LogTypes)0>::Get(*(_QWORD *)(a1 + 256), 0);
      v16 = (char *)AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280), 0);
      if (v16 != (char *)v15)
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v16, *(char **)v15, *(_QWORD *)(v15 + 8), (uint64_t)(*(_QWORD *)(v15 + 8) - *(_QWORD *)v15) >> 2);
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 16);
    }
LABEL_26:
    v12 = (unint64_t *)(a1 + 280);
    v17 = 0;
    return AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::operator[](v12, v17);
  }
  if (v11 == 1)
  {
    v12 = (unint64_t *)(a1 + 280);
LABEL_22:
    v17 = a2;
    return AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::operator[](v12, v17);
  }
  if (!*(_BYTE *)(a1 + 24))
    __assert_rtn("Get", "AutoValue.h", 668, "_isInitialized == true");
  Trackable::GetRevision((Trackable *)a1);
  v13 = *(_QWORD *)(a1 + 264);
  v14 = *(_QWORD *)(a1 + 16);
  if (!a2)
  {
    if (v13 < v14)
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a1 + 16);
      v18 = AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280), 0);
      v19 = *(_QWORD *)(a1 + 248);
      if (!v19)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v19 + 48))(v19, v18);
    }
    goto LABEL_26;
  }
LABEL_20:
  v12 = (unint64_t *)(a1 + 280);
  if (v13 >= v14)
    goto LABEL_22;
  v17 = a2 - 1;
  return AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::operator[](v12, v17);
}

void sub_1B65637F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t Trackable::Initialize(uint64_t this)
{
  uint64_t v1;
  int v2;
  Trackable **v3;
  Trackable **v4;
  Trackable *v5;
  unint64_t v6;
  Trackable **v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  Trackable **v15;
  char *v16;
  char *v17;
  Trackable *v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;

  if (!*(_BYTE *)(this + 24))
  {
    v1 = this;
    if (!*(_BYTE *)(this + 96))
    {
      v2 = *(_DWORD *)(this + 8);
      if ((v2 | 2) == 2)
      {
        *(_QWORD *)(this + 160) = *(_QWORD *)(this + 152);
        *(_QWORD *)(this + 112) = *(_QWORD *)(this + 104);
        *(_QWORD *)(this + 40) = *(_QWORD *)(this + 32);
        v3 = *(Trackable ***)(this + 128);
        v4 = *(Trackable ***)(this + 136);
        if (v3 != v4)
        {
          do
          {
            v5 = *v3;
            Trackable::RegisterWith(*v3, (Trackable *)v1);
            v7 = *(Trackable ***)(v1 + 184);
            v6 = *(_QWORD *)(v1 + 192);
            if ((unint64_t)v7 >= v6)
            {
              v9 = *(_QWORD *)(v1 + 176);
              v10 = ((uint64_t)v7 - v9) >> 3;
              if ((unint64_t)(v10 + 1) >> 61)
                goto LABEL_46;
              v11 = v6 - v9;
              v12 = v11 >> 2;
              if (v11 >> 2 <= (unint64_t)(v10 + 1))
                v12 = v10 + 1;
              if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
                v13 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v13 = v12;
              if (v13)
                v13 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v13);
              else
                v14 = 0;
              v15 = (Trackable **)(v13 + 8 * v10);
              *v15 = v5;
              v8 = v15 + 1;
              v17 = *(char **)(v1 + 176);
              v16 = *(char **)(v1 + 184);
              if (v16 != v17)
              {
                do
                {
                  v18 = (Trackable *)*((_QWORD *)v16 - 1);
                  v16 -= 8;
                  *--v15 = v18;
                }
                while (v16 != v17);
                v16 = *(char **)(v1 + 176);
              }
              *(_QWORD *)(v1 + 176) = v15;
              *(_QWORD *)(v1 + 184) = v8;
              *(_QWORD *)(v1 + 192) = v13 + 8 * v14;
              if (v16)
                operator delete(v16);
            }
            else
            {
              *v7 = v5;
              v8 = v7 + 1;
            }
            *(_QWORD *)(v1 + 184) = v8;
            *(_BYTE *)(v1 + 96) = 1;
            Trackable::Initialize(v5);
            *(_BYTE *)(v1 + 96) = 0;
            ++v3;
          }
          while (v3 != v4);
          v2 = *(_DWORD *)(v1 + 8);
        }
        if (!v2 && *(_QWORD *)(v1 + 136) == *(_QWORD *)(v1 + 128))
          ++*(_QWORD *)(v1 + 16);
        this = *(_QWORD *)(v1 + 64);
        if (this)
        {
          Trackable::RegisterWith((Trackable *)this, (Trackable *)v1);
          v20 = *(_QWORD **)(v1 + 184);
          v19 = *(_QWORD *)(v1 + 192);
          if ((unint64_t)v20 >= v19)
          {
            v22 = *(_QWORD *)(v1 + 176);
            v23 = ((uint64_t)v20 - v22) >> 3;
            if ((unint64_t)(v23 + 1) >> 61)
LABEL_46:
              std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
            v24 = v19 - v22;
            v25 = v24 >> 2;
            if (v24 >> 2 <= (unint64_t)(v23 + 1))
              v25 = v23 + 1;
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
              v26 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v26 = v25;
            if (v26)
              v26 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v26);
            else
              v27 = 0;
            v28 = (_QWORD *)(v26 + 8 * v23);
            v29 = v26 + 8 * v27;
            *v28 = *(_QWORD *)(v1 + 64);
            v21 = v28 + 1;
            v31 = *(char **)(v1 + 176);
            v30 = *(char **)(v1 + 184);
            if (v30 != v31)
            {
              do
              {
                v32 = *((_QWORD *)v30 - 1);
                v30 -= 8;
                *--v28 = v32;
              }
              while (v30 != v31);
              v30 = *(char **)(v1 + 176);
            }
            *(_QWORD *)(v1 + 176) = v28;
            *(_QWORD *)(v1 + 184) = v21;
            *(_QWORD *)(v1 + 192) = v29;
            if (v30)
              operator delete(v30);
          }
          else
          {
            *v20 = *(_QWORD *)(v1 + 64);
            v21 = v20 + 1;
          }
          *(_QWORD *)(v1 + 184) = v21;
          *(_BYTE *)(v1 + 96) = 1;
          this = Trackable::Initialize(*(Trackable **)(v1 + 64));
          *(_BYTE *)(v1 + 96) = 0;
        }
      }
      *(_BYTE *)(v1 + 24) = 1;
    }
  }
  return this;
}

uint64_t Trackable::GetRevision(Trackable *this)
{
  _QWORD *v2;
  int v3;
  char *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t Revision;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  std::locale v24;

  if (!*((_BYTE *)this + 24))
  {
    v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"WARNING: Calling GetRevision() on a Trackable ('", 48);
    v3 = *((char *)this + 95);
    if (v3 >= 0)
      v4 = (char *)this + 72;
    else
      v4 = (char *)*((_QWORD *)this + 9);
    if (v3 >= 0)
      v5 = *((unsigned __int8 *)this + 95);
    else
      v5 = *((_QWORD *)this + 10);
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)v4, v5);
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"') without initializing first. Initializing now.", 48);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v24, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v24);
    std::ostream::put();
    std::ostream::flush();
    Trackable::Initialize((uint64_t)this);
  }
  if (*((_DWORD *)this + 2) != 1)
  {
    v9 = *((_QWORD *)this + 19);
    if (*((_QWORD *)this + 20) == v9)
    {
      v12 = (_QWORD *)*((_QWORD *)this + 13);
    }
    else
    {
      v10 = 0;
      do
      {
        Revision = Trackable::GetRevision(*(Trackable **)(v9 + 8 * v10));
        v12 = (_QWORD *)*((_QWORD *)this + 13);
        v12[v10++] = Revision;
        v9 = *((_QWORD *)this + 19);
      }
      while (v10 < (*((_QWORD *)this + 20) - v9) >> 3);
    }
    v13 = *((_QWORD *)this + 14);
    v14 = *((_QWORD *)this + 4);
    v15 = *((_QWORD *)this + 5);
    v16 = (v13 - (uint64_t)v12) >> 3;
    v17 = v15 - v14;
    v18 = (v15 - v14) >> 3;
    if (v18 >= v16)
      v19 = (v13 - (uint64_t)v12) >> 3;
    else
      v19 = (v15 - v14) >> 3;
    if (v19 < 1)
    {
LABEL_22:
      if (v16 < v18)
        goto LABEL_28;
    }
    else
    {
      v20 = (_QWORD *)*((_QWORD *)this + 4);
      while (*v12 == *v20)
      {
        ++v12;
        ++v20;
        if (!--v19)
          goto LABEL_22;
      }
      if (*v12 < *v20)
LABEL_28:
        __assert_rtn("GetRevision", "AutoValue.h", 381, "_newArgRevisions >= _oldArgRevisions");
    }
    v21 = *((_QWORD *)this + 13);
    if (v13 - v21 != v17 || memcmp(*((const void **)this + 13), *((const void **)this + 4), v17))
    {
      ++*((_QWORD *)this + 2);
      *((_QWORD *)this + 4) = v21;
      *((_QWORD *)this + 5) = v13;
      *((_QWORD *)this + 13) = v14;
      *((_QWORD *)this + 14) = v15;
      v22 = *((_QWORD *)this + 6);
      *((_QWORD *)this + 6) = *((_QWORD *)this + 15);
      *((_QWORD *)this + 15) = v22;
    }
  }
  return *((_QWORD *)this + 2);
}

void sub_1B6563C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::operator[](unint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t i;

  v2 = a1[1];
  if (v2 <= a2)
    __assert_rtn("operator[]", "AutoValue.h", 562, "index < _C");
  for (i = *a1; a2; --a2)
  {
    if (v2 <= i)
      __assert_rtn("IncrementCirc", "AutoValue.h", 505, "index < _C");
    if (v2 - 1 > i)
      ++i;
    else
      i = 0;
  }
  if (i >= v2)
    __assert_rtn("operator[]", "AutoValue.h", 569, "theIndex < _C");
  if (a1[6] <= i)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  return a1[5] + 24 * i;
}

uint64_t *AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong(uint64_t *result)
{
  uint64_t v1;

  v1 = *result;
  if (result[1] < (unint64_t)*result)
    __assert_rtn("DecrementCirc", "AutoValue.h", 491, "index <= _C");
  if (!v1)
    v1 = result[1];
  *result = v1 - 1;
  return result;
}

void Trackable::RegisterWith(Trackable *this, Trackable *a2)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  int v18;
  Trackable **v19;
  Trackable **v20;
  Trackable *v21;
  Trackable **v22;
  Trackable **v23;
  Trackable *v24;

  if (a2 != this)
  {
    v5 = (_QWORD *)*((_QWORD *)this + 26);
    v4 = *((_QWORD *)this + 27);
    if ((unint64_t)v5 >= v4)
    {
      v7 = *((_QWORD *)this + 25);
      v8 = ((uint64_t)v5 - v7) >> 3;
      if ((unint64_t)(v8 + 1) >> 61)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v9 = v4 - v7;
      v10 = v9 >> 2;
      if (v9 >> 2 <= (unint64_t)(v8 + 1))
        v10 = v8 + 1;
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
        v11 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v11 = v10;
      if (v11)
        v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v11);
      else
        v12 = 0;
      v13 = (_QWORD *)(v11 + 8 * v8);
      v14 = v11 + 8 * v12;
      *v13 = a2;
      v6 = v13 + 1;
      v16 = (char *)*((_QWORD *)this + 25);
      v15 = (char *)*((_QWORD *)this + 26);
      if (v15 != v16)
      {
        do
        {
          v17 = *((_QWORD *)v15 - 1);
          v15 -= 8;
          *--v13 = v17;
        }
        while (v15 != v16);
        v15 = (char *)*((_QWORD *)this + 25);
      }
      *((_QWORD *)this + 25) = v13;
      *((_QWORD *)this + 26) = v6;
      *((_QWORD *)this + 27) = v14;
      if (v15)
        operator delete(v15);
    }
    else
    {
      *v5 = a2;
      v6 = v5 + 1;
    }
    *((_QWORD *)this + 26) = v6;
    v18 = *((_DWORD *)this + 2);
    switch(v18)
    {
      case 2:
        v23 = (Trackable **)*((_QWORD *)this + 19);
        v22 = (Trackable **)*((_QWORD *)this + 20);
        while (v23 != v22)
        {
          v24 = *v23++;
          Trackable::Append(a2, v24);
        }
        break;
      case 1:
        goto LABEL_29;
      case 0:
        v19 = (Trackable **)*((_QWORD *)this + 19);
        v20 = (Trackable **)*((_QWORD *)this + 20);
        while (v19 != v20)
        {
          v21 = *v19++;
          Trackable::Append(a2, v21);
        }
        if (*((_QWORD *)this + 17) == *((_QWORD *)this + 16))
LABEL_29:
          Trackable::Append(a2, this);
        break;
    }
  }
}

void Trackable::Append(_QWORD *a1, Trackable *a2)
{
  Trackable **v4;
  Trackable **v5;
  Trackable **v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  Trackable **v14;
  unint64_t v15;
  char *v16;
  char *v17;
  Trackable *v18;
  unint64_t v19;
  char *v20;
  _QWORD *v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  BOOL v26;
  unint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  _QWORD *v34;
  char *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  unint64_t v42;
  uint64_t v43;
  Trackable **v44;
  Trackable **v45;
  Trackable *v46;

  v4 = (Trackable **)a1[19];
  v5 = (Trackable **)a1[20];
  if (v4 == v5)
  {
LABEL_5:
    v7 = a1[21];
    if ((unint64_t)v5 >= v7)
    {
      v9 = v5 - v4;
      if ((unint64_t)(v9 + 1) >> 61)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v10 = v7 - (_QWORD)v4;
      v11 = v10 >> 2;
      if (v10 >> 2 <= (unint64_t)(v9 + 1))
        v11 = v9 + 1;
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
        v12 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      if (v12)
        v12 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v12);
      else
        v13 = 0;
      v14 = (Trackable **)(v12 + 8 * v9);
      v15 = v12 + 8 * v13;
      *v14 = a2;
      v8 = v14 + 1;
      v17 = (char *)a1[19];
      v16 = (char *)a1[20];
      if (v16 != v17)
      {
        do
        {
          v18 = (Trackable *)*((_QWORD *)v16 - 1);
          v16 -= 8;
          *--v14 = v18;
        }
        while (v16 != v17);
        v16 = (char *)a1[19];
      }
      a1[19] = v14;
      a1[20] = v8;
      a1[21] = v15;
      if (v16)
        operator delete(v16);
    }
    else
    {
      *v5 = a2;
      v8 = v5 + 1;
    }
    a1[20] = v8;
    v20 = (char *)a1[5];
    v19 = a1[6];
    if ((unint64_t)v20 >= v19)
    {
      v22 = (char *)a1[4];
      v23 = (v20 - v22) >> 3;
      v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 61)
        goto LABEL_55;
      v25 = v19 - (_QWORD)v22;
      if (v25 >> 2 > v24)
        v24 = v25 >> 2;
      v26 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8;
      v27 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v26)
        v27 = v24;
      if (v27)
      {
        v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v27);
        v22 = (char *)a1[4];
        v20 = (char *)a1[5];
      }
      else
      {
        v28 = 0;
      }
      v29 = (_QWORD *)(v27 + 8 * v23);
      v30 = v27 + 8 * v28;
      *v29 = 0;
      v21 = v29 + 1;
      while (v20 != v22)
      {
        v31 = *((_QWORD *)v20 - 1);
        v20 -= 8;
        *--v29 = v31;
      }
      a1[4] = v29;
      a1[5] = v21;
      a1[6] = v30;
      if (v22)
        operator delete(v22);
    }
    else
    {
      *(_QWORD *)v20 = 0;
      v21 = v20 + 8;
    }
    a1[5] = v21;
    v33 = (char *)a1[14];
    v32 = a1[15];
    if ((unint64_t)v33 < v32)
    {
      *(_QWORD *)v33 = 0;
      v34 = v33 + 8;
LABEL_51:
      a1[14] = v34;
      v45 = (Trackable **)a1[25];
      v44 = (Trackable **)a1[26];
      while (v45 != v44)
      {
        v46 = *v45++;
        Trackable::Append(v46, a2);
      }
      return;
    }
    v35 = (char *)a1[13];
    v36 = (v33 - v35) >> 3;
    v37 = v36 + 1;
    if (!((unint64_t)(v36 + 1) >> 61))
    {
      v38 = v32 - (_QWORD)v35;
      if (v38 >> 2 > v37)
        v37 = v38 >> 2;
      v26 = (unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8;
      v39 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v26)
        v39 = v37;
      if (v39)
      {
        v39 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v39);
        v35 = (char *)a1[13];
        v33 = (char *)a1[14];
      }
      else
      {
        v40 = 0;
      }
      v41 = (_QWORD *)(v39 + 8 * v36);
      v42 = v39 + 8 * v40;
      *v41 = 0;
      v34 = v41 + 1;
      while (v33 != v35)
      {
        v43 = *((_QWORD *)v33 - 1);
        v33 -= 8;
        *--v41 = v43;
      }
      a1[13] = v41;
      a1[14] = v34;
      a1[15] = v42;
      if (v35)
        operator delete(v35);
      goto LABEL_51;
    }
LABEL_55:
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
  v6 = (Trackable **)a1[19];
  while (*v6 != a2)
  {
    if (++v6 == v5)
      goto LABEL_5;
  }
}

uint64_t AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::operator[](unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;

  v1 = a1[1];
  if (!v1)
    __assert_rtn("operator[]", "AutoValue.h", 562, "index < _C");
  v2 = *a1;
  if (*a1 >= v1)
    __assert_rtn("operator[]", "AutoValue.h", 569, "theIndex < _C");
  if (a1[11] <= v2)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  return a1[10] + (v2 << 6);
}

uint64_t DSPSplitComplexV<float>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != a2)
  {
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 16), *(char **)(a2 + 16), *(_QWORD *)(a2 + 24), (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 40), *(char **)(a2 + 40), *(_QWORD *)(a2 + 48), (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 2);
  }
  v4 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)a1 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  return a1;
}

void Trackable::Uninitialize(Trackable *this)
{
  _BYTE *v2;
  _BYTE *v3;
  int64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t i;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (*((_BYTE *)this + 24))
  {
    *((_BYTE *)this + 24) = 0;
    *((_QWORD *)this + 14) = *((_QWORD *)this + 13);
    *((_QWORD *)this + 5) = *((_QWORD *)this + 4);
    v3 = (_BYTE *)*((_QWORD *)this + 25);
    v2 = (_BYTE *)*((_QWORD *)this + 26);
    v4 = v2 - v3;
    if (v2 == v3)
    {
      v5 = 0;
    }
    else
    {
      if (v4 < 0)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v5 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v4 >> 3);
      memmove(v5, v3, v4);
      v6 = 8 * (v4 >> 3);
      if (v6)
      {
        for (i = 0; i != v6; i += 8)
          Trackable::Uninitialize(*(Trackable **)&v5[i]);
      }
    }
    *((_QWORD *)this + 26) = *((_QWORD *)this + 25);
    v8 = (uint64_t *)*((_QWORD *)this + 22);
    v9 = (uint64_t *)*((_QWORD *)this + 23);
    if (v8 != v9)
    {
      do
      {
        v10 = *v8;
        v12 = *(_QWORD *)(*v8 + 200);
        v11 = *(_QWORD *)(*v8 + 208);
        if (v11 != v12)
        {
          v13 = 0;
          v14 = (v11 - v12) >> 3;
          if (v14 <= 1)
            v14 = 1;
          while (*(Trackable **)(v12 + 8 * v13) != this)
          {
            if (v14 == ++v13)
              goto LABEL_19;
          }
          v15 = v12 + 8 * v13;
          v16 = v11 - (v15 + 8);
          if (v11 != v15 + 8)
            memmove((void *)(v12 + 8 * v13), (const void *)(v15 + 8), v11 - (v15 + 8));
          *(_QWORD *)(v10 + 208) = v15 + v16;
        }
LABEL_19:
        ++v8;
      }
      while (v8 != v9);
      v8 = (uint64_t *)*((_QWORD *)this + 22);
    }
    *((_QWORD *)this + 23) = v8;
    *((_QWORD *)this + 20) = *((_QWORD *)this + 19);
    if (v5)
      operator delete(v5);
  }
}

void sub_1B656437C(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

unint64_t AutoValue<BOOL,(LogTypes)0>::CircularBuffer::operator[](unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;

  v1 = a1[1];
  if (!v1)
    __assert_rtn("operator[]", "AutoValue.h", 562, "index < _C");
  v2 = *a1;
  if (*a1 >= v1)
    __assert_rtn("operator[]", "AutoValue.h", 569, "theIndex < _C");
  if (a1[4] <= v2)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  return a1[3] + v2;
}

void AutoValue<float,(LogTypes)0>::Set(Trackable *this, float a2)
{
  unint64_t v2;
  unint64_t v4;

  ++*((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 35);
  if (*((_QWORD *)this + 36) < v2)
    __assert_rtn("DecrementCirc", "AutoValue.h", 491, "index <= _C");
  if (!v2)
    v2 = *((_QWORD *)this + 36);
  v4 = v2 - 1;
  *((_QWORD *)this + 35) = v4;
  if (*((_QWORD *)this + 39) <= v4)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  *(float *)(*((_QWORD *)this + 38) + 4 * v4) = a2;
  if (*((_DWORD *)this + 2) != 1)
  {
    *((_DWORD *)this + 2) = 1;
    Trackable::Uninitialize(this);
  }
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
}

uint64_t applesauce::CF::DictionaryRef_iterator<std::string,applesauce::CF::DataRef>::DictionaryRef_iterator(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v3;
  CFIndex Count;

  *(_QWORD *)a1 = theDict;
  *(_OWORD *)(a1 + 40) = 0u;
  v3 = a1 + 40;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 56) = 0;
  if (theDict)
  {
    Count = CFDictionaryGetCount(theDict);
    std::vector<void const*>::resize(a1 + 16, Count);
    std::vector<void const*>::resize(v3, Count);
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)a1, *(const void ***)(a1 + 16), *(const void ***)(a1 + 40));
  }
  return a1;
}

uint64_t std::pair<std::string,applesauce::CF::DataRef>::~pair(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t AUReverbSuppressor::GetGlobalProperty<($_0)14>(OpaqueAudioComponentInstance *a1)
{
  _QWORD *exception;
  UInt32 ioDataSize;
  unsigned int outData;
  uint8_t buf[4];
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  ioDataSize = 4;
  outData = 0;
  if (AudioUnitGetProperty(a1, 0xEu, 0, 0, &outData, &ioDataSize))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v6 = "AUReverbSuppressor.cpp";
      v7 = 1024;
      v8 = 467;
      v9 = 2080;
      v10 = "MaximumFramesPerSlice";
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d AudioUnitGetProperty failed for %s", buf, 0x1Cu);
    }
    exception = __cxa_allocate_exception(8uLL);
    *exception = MEMORY[0x1E0DE5060] + 16;
  }
  return outData;
}

void AutoValue<BOOL,(LogTypes)0>::Set(Trackable *this, char a2)
{
  unint64_t v2;
  unint64_t v4;

  ++*((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 35);
  if (*((_QWORD *)this + 36) < v2)
    __assert_rtn("DecrementCirc", "AutoValue.h", 491, "index <= _C");
  if (!v2)
    v2 = *((_QWORD *)this + 36);
  v4 = v2 - 1;
  *((_QWORD *)this + 35) = v4;
  if (*((_QWORD *)this + 39) <= v4)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  *(_BYTE *)(*((_QWORD *)this + 38) + v4) = a2;
  if (*((_DWORD *)this + 2) != 1)
  {
    *((_DWORD *)this + 2) = 1;
    Trackable::Uninitialize(this);
  }
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
}

uint64_t GetPreference<float>(const UInt8 *a1, const UInt8 *a2)
{
  int v4;
  const UInt8 *v5;
  CFIndex v6;
  const __CFString *v7;
  int v8;
  const UInt8 *v9;
  CFIndex v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFNumber *v13;
  float v14;
  const UInt8 *v15;
  const UInt8 *v16;
  std::string *p_p;
  float v18;
  const UInt8 *v19;
  const UInt8 *v20;
  uint64_t v21;
  std::runtime_error *exception;
  std::runtime_error *v24;
  std::string __p;
  float v26;
  const __CFNumber *v27;
  std::bad_cast v28;
  _BYTE buf[12];
  __int16 v30;
  int v31;
  __int16 v32;
  const UInt8 *v33;
  __int16 v34;
  const UInt8 *v35;
  __int16 v36;
  std::string *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = *((char *)a1 + 23);
  if (v4 >= 0)
    v5 = a1;
  else
    v5 = *(const UInt8 **)a1;
  if (v4 >= 0)
    v6 = a1[23];
  else
    v6 = *((_QWORD *)a1 + 1);
  v7 = CFStringCreateWithBytes(0, v5, v6, 0x8000100u, 0);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
  if (!v7)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  v8 = *((char *)a2 + 23);
  if (v8 >= 0)
    v9 = a2;
  else
    v9 = *(const UInt8 **)a2;
  if (v8 >= 0)
    v10 = a2[23];
  else
    v10 = *((_QWORD *)a2 + 1);
  v11 = CFStringCreateWithBytes(0, v9, v10, 0x8000100u, 0);
  v12 = v11;
  *(_QWORD *)buf = v11;
  if (!v11)
  {
    v24 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v24, "Could not construct");
  }
  v13 = (const __CFNumber *)CFPreferencesCopyAppValue(v11, v7);
  v27 = v13;
  CFRelease(v12);
  CFRelease(v7);
  if (v13)
  {
    v14 = applesauce::CF::convert_to<float,0>(v13);
    v26 = v14;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a1 + 23) >= 0)
        v15 = a1;
      else
        v15 = *(const UInt8 **)a1;
      if (*((char *)a2 + 23) >= 0)
        v16 = a2;
      else
        v16 = *(const UInt8 **)a2;
      memset(&__p, 0, sizeof(__p));
      if (!boost::conversion::detail::try_lexical_convert<std::string,float>(&v26, &__p))
      {
        std::bad_cast::bad_cast(&v28);
        v28.__vftable = (std::bad_cast_vtbl *)&unk_1E69B5650;
        boost::throw_exception<boost::bad_lexical_cast>();
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = "CFPrefHelper.h";
      v30 = 1024;
      v31 = 124;
      v32 = 2080;
      v33 = v15;
      v34 = 2080;
      v35 = v16;
      v36 = 2080;
      v37 = p_p;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%25s:%-5d Preference '%s %s' retrieved as %s", buf, 0x30u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v18 = v26;
    }
    else
    {
      v18 = v14;
    }
    v21 = 0x100000000;
    CFRelease(v13);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)a1 + 23) >= 0)
        v19 = a1;
      else
        v19 = *(const UInt8 **)a1;
      if (*((char *)a2 + 23) >= 0)
        v20 = a2;
      else
        v20 = *(const UInt8 **)a2;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "CFPrefHelper.h";
      v30 = 1024;
      v31 = 133;
      v32 = 2080;
      v33 = v19;
      v34 = 2080;
      v35 = v20;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%25s:%-5d Preference: '%s %s' does not exist.", buf, 0x26u);
    }
    v21 = 0;
    v18 = 0.0;
  }
  return v21 & 0x100000000 | LODWORD(v18);
}

void sub_1B6564AD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::exception a17, __int128 buf, __int128 a19)
{
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v22;
  uint64_t *v23;

  if (a2)
  {
    std::exception::~exception(&a17);
    if (a14 < 0)
      operator delete(__p);
    __cxa_begin_catch(exception_object);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      if (*((char *)v20 + 23) >= 0)
        v22 = v20;
      else
        v22 = (uint64_t *)*v20;
      if (*((char *)v19 + 23) >= 0)
        v23 = v19;
      else
        v23 = (uint64_t *)*v19;
      LODWORD(buf) = 136315906;
      *(_QWORD *)((char *)&buf + 4) = "CFPrefHelper.h";
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = 128;
      WORD1(a19) = 2080;
      *(_QWORD *)((char *)&a19 + 4) = v22;
      WORD6(a19) = 2080;
      *(_QWORD *)((char *)&a19 + 14) = v23;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to get Preference: '%s %s'. It exists, but is it the right type?", (uint8_t *)&buf, 0x26u);
    }
    __cxa_end_catch();
    if (!a16)
      JUMPOUT(0x1B6564A00);
    JUMPOUT(0x1B65649F8);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B6564C20(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  if (a2)
  {
    applesauce::CF::StringRef::~StringRef((const void **)va);
    JUMPOUT(0x1B6564C3CLL);
  }
  JUMPOUT(0x1B6564C10);
}

void sub_1B6564C48(uint64_t a1, int a2)
{
  if (a2)
    JUMPOUT(0x1B6564C50);
  JUMPOUT(0x1B6564C10);
}

void sub_1B6564D00()
{
  JUMPOUT(0x1B6564C10);
}

_QWORD *DSPSplitComplexV<float>::DSPSplitComplexV(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;
  int v6;
  int v7;

  v7 = 0;
  std::vector<float>::vector(a1 + 2, a2, &v7);
  v6 = 0;
  std::vector<float>::vector(a1 + 5, a2, &v6);
  v4 = a1[5];
  *a1 = a1[2];
  a1[1] = v4;
  return a1;
}

void sub_1B6564D70(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::PreAllocate<unsigned int const&>(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  __int128 v4;
  int64x2_t v5;
  uint64_t v6;
  int64x2_t v7;
  __int128 v8;
  uint64_t v9;
  void *v10[2];
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  _OWORD v15[2];
  void *v16[2];
  _BYTE __p[32];
  _QWORD v18[3];

  v3 = *(_QWORD *)(a1 + 384) + 1;
  DSPSplitComplexV<float>::DSPSplitComplexV(v10, a2);
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v15, v3, (uint64_t)v10);
  v4 = v15[0];
  v5 = *(int64x2_t *)v16;
  v6 = *(_QWORD *)__p;
  v7 = *(int64x2_t *)&__p[8];
  v8 = *(_OWORD *)(a1 + 328);
  *(_OWORD *)v16 = *(_OWORD *)(a1 + 312);
  *(_OWORD *)__p = v8;
  v9 = *(_QWORD *)&__p[24];
  *(_OWORD *)&__p[16] = *(_OWORD *)(a1 + 344);
  *(int64x2_t *)(a1 + 312) = v5;
  *(_QWORD *)(a1 + 328) = v6;
  *(int64x2_t *)(a1 + 336) = v7;
  *(_QWORD *)(a1 + 352) = v9;
  *(_OWORD *)(a1 + 280) = v4;
  *(int64x2_t *)(a1 + 296) = vzip1q_s64(v5, v7);
  if (v15 != (_OWORD *)(a1 + 280))
    boost::container::vector<DSPSplitComplexV<float>,void,void>::priv_move_assign<void>(a1 + 360, v18);
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector(v18);
  if (*(_QWORD *)&__p[8])
  {
    *(_QWORD *)&__p[16] = *(_QWORD *)&__p[8];
    operator delete(*(void **)&__p[8]);
  }
  if (v16[0])
  {
    v16[1] = v16[0];
    operator delete(v16[0]);
  }
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  if (v11)
  {
    v12 = v11;
    operator delete(v11);
  }
}

void sub_1B6564E90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::~DictionaryRef_iterator((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t Dereverb::Dereverb<float,(Dereverb::FirstPassTypes)0,(LogTypes)0>::Dereverb(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t *a4, double *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  size_t v16;
  uint64_t (***v17)();
  const void *v18;
  size_t v19;
  uint64_t (***v20)();
  const void *v21;
  size_t v22;
  uint64_t (***v23)();
  const void *v24;
  size_t v25;
  __int128 *v26;
  const void *v27;
  double v28;
  unint64_t v29;
  _DWORD *v30;
  double *v31;
  uint64_t (***v32)();
  unint64_t *v33;
  uint64_t v34;
  size_t v35;
  uint64_t (***v36)();
  const void *v37;
  size_t v38;
  uint64_t (***v39)();
  const void *v40;
  float v41;
  size_t v42;
  uint64_t (***v43)();
  const void *v44;
  size_t v45;
  uint64_t (***v46)();
  const void *v47;
  size_t v48;
  uint64_t (***v49)();
  _QWORD *v50;
  const void *v51;
  size_t v52;
  uint64_t (***v53)();
  const void *v54;
  size_t v55;
  uint64_t (***v56)();
  const void *v57;
  float v58;
  size_t v59;
  uint64_t (***v60)();
  const void *v61;
  size_t v62;
  uint64_t (***v63)();
  const void *v64;
  size_t v65;
  uint64_t (***v66)();
  const void *v67;
  size_t v68;
  uint64_t (***v69)();
  const void *v70;
  size_t v71;
  void **v72;
  const void *v73;
  unint64_t v74;
  double v75;
  size_t v76;
  __int128 *v77;
  void **v78;
  float v79;
  float v80;
  float v81;
  size_t v82;
  uint64_t (***v83)();
  __int128 *v84;
  size_t v85;
  uint64_t (***v86)();
  __int128 *v87;
  size_t v88;
  uint64_t (***v89)();
  __int128 *v90;
  size_t v91;
  __int128 *v92;
  __int128 *v93;
  _DWORD *v94;
  __int128 v95;
  uint64_t (***v96)();
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t (***v101)();
  uint64_t v102;
  size_t v103;
  __int128 *v104;
  size_t v105;
  uint64_t (***v106)();
  __int128 *v107;
  size_t v108;
  uint64_t (***v109)();
  __int128 *v110;
  size_t v111;
  uint64_t (***v112)();
  __int128 *v113;
  size_t v114;
  uint64_t (***v115)();
  __int128 *v116;
  size_t v117;
  uint64_t (***v118)();
  void **v119;
  size_t v120;
  uint64_t (***v121)();
  void **v122;
  size_t v123;
  uint64_t (***v124)();
  void **v125;
  size_t v126;
  uint64_t (***v127)();
  uint64_t v128;
  void **v129;
  _QWORD *v130;
  size_t v131;
  __int128 *v132;
  _DWORD *v133;
  void **v134;
  _QWORD *v135;
  void **v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t (***v140)();
  uint64_t v141;
  size_t v142;
  uint64_t (***v143)();
  void **v144;
  float v145;
  size_t v146;
  uint64_t (***v147)();
  void **v148;
  float v149;
  size_t v150;
  uint64_t (***v151)();
  void **v152;
  uint64_t v154;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  _QWORD *v160;
  Trackable *v161;
  uint64_t v162;
  uint64_t v163;
  _QWORD *v164;
  _QWORD *v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  _QWORD *v170;
  Trackable *v171;
  uint64_t v172;
  uint64_t v173;
  unint64_t *v174;
  void *__p[2];
  unsigned __int8 v176;
  __int128 v177;
  unsigned __int8 v178;
  __int128 v179;
  uint64_t v180;
  uint64_t (**v181)();
  __int128 v182;
  void **v183;
  uint64_t v184;

  v184 = *MEMORY[0x1E0C80C00];
  *AutoValue<std::vector<float>,(LogTypes)0>::AutoValue((_QWORD *)a1, (__int128 *)a2) = &off_1E69EB4A0;
  if (*(char *)(a2 + 23) >= 0)
    v16 = *(unsigned __int8 *)(a2 + 23);
  else
    v16 = *(_QWORD *)(a2 + 8);
  v17 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v16 + 19);
  if (v182 < 0)
    v17 = (uint64_t (***)())v181;
  if (v16)
  {
    if (*(char *)(a2 + 23) >= 0)
      v18 = (const void *)a2;
    else
      v18 = *(const void **)a2;
    memmove(v17, v18, v16);
  }
  strcpy((char *)v17 + v16, "_gain2SmoothingCoef");
  AutoValue<float,(LogTypes)0>::AutoValue(a1 + 352, (__int128 *)&v181);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v19 = *(unsigned __int8 *)(a2 + 23);
  else
    v19 = *(_QWORD *)(a2 + 8);
  v20 = &v181;
  v161 = (Trackable *)(a1 + 352);
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v19 + 15);
  if (v182 < 0)
    v20 = (uint64_t (***)())v181;
  if (v19)
  {
    if (*(char *)(a2 + 23) >= 0)
      v21 = (const void *)a2;
    else
      v21 = *(const void **)a2;
    memmove(v20, v21, v19);
  }
  strcpy((char *)v20 + v19, "_reverbTailGain");
  AutoValue<float,(LogTypes)0>::AutoValue<float const& ()(float &,AutoValue<float,(LogTypes)0>&),float>(a1 + 688, (__int128 *)&v181, (uint64_t)dBToLinear<float,(LogTypes)0>::Compute_dBToLinear, a8);
  *(_QWORD *)(a1 + 688) = &off_1E69EB4E0;
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v22 = *(unsigned __int8 *)(a2 + 23);
  else
    v22 = *(_QWORD *)(a2 + 8);
  v23 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v22 + 10);
  v171 = (Trackable *)(a1 + 1024);
  if (v182 < 0)
    v23 = (uint64_t (***)())v181;
  if (v22)
  {
    if (*(char *)(a2 + 23) >= 0)
      v24 = (const void *)a2;
    else
      v24 = *(const void **)a2;
    memmove(v23, v24, v22);
  }
  strcpy((char *)v23 + v22, "_psBeta_TC");
  AutoValue<float,(LogTypes)0>::AutoValue((uint64_t)v171, (__int128 *)&v181);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v25 = *(unsigned __int8 *)(a2 + 23);
  else
    v25 = *(_QWORD *)(a2 + 8);
  v26 = &v179;
  std::string::basic_string[abi:ne180100]((uint64_t)&v179, v25 + 7);
  v169 = a1 + 1360;
  if (v180 < 0)
    v26 = (__int128 *)v179;
  if (v25)
  {
    if (*(char *)(a2 + 23) >= 0)
      v27 = (const void *)a2;
    else
      v27 = *(const void **)a2;
    memmove(v26, v27, v25);
  }
  strcpy((char *)v26 + v25, "_psBeta");
  v28 = *a5;
  v174 = a3;
  v29 = *a3;
  Trackable::Trackable<AutoValue<float,(LogTypes)0>>(v169, &v179, (uint64_t)v171);
  *(_QWORD *)(a1 + 1360) = &off_1E69EB300;
  *(_QWORD *)(a1 + 1640) = 0;
  *(_QWORD *)(a1 + 1616) = 0;
  *(_QWORD *)(a1 + 1608) = 0;
  *(_QWORD *)(a1 + 1648) = 1;
  *(_DWORD *)(a1 + 1656) = 0;
  *(_QWORD *)(a1 + 1664) = 0;
  *(_OWORD *)(a1 + 1672) = xmmword_1B66A0DC0;
  v30 = operator new(4uLL);
  *(_QWORD *)(a1 + 1664) = v30;
  *v30 = 0;
  *(_OWORD *)(a1 + 1680) = xmmword_1B66A0DC0;
  v31 = (double *)operator new(0x28uLL);
  *(_QWORD *)v31 = &off_1E69EB568;
  *((_QWORD *)v31 + 1) = TCToCoef<float,(LogTypes)0>::Compute_CoefFromTC_curry;
  v31[2] = v28;
  *((_QWORD *)v31 + 3) = v29;
  *((_QWORD *)v31 + 4) = v171;
  v183 = (void **)v31;
  std::__function::__value_func<float const& ()(float &)>::swap[abi:ne180100](&v181, (_QWORD *)(a1 + 1584));
  v32 = (uint64_t (***)())v183;
  if (v183 == (void **)&v181)
  {
    v34 = 4;
    v32 = &v181;
    v33 = v174;
  }
  else
  {
    v33 = v174;
    if (!v183)
      goto LABEL_52;
    v34 = 5;
  }
  (*v32)[v34]();
LABEL_52:
  *(_DWORD *)(a1 + 1368) = 0;
  *(_QWORD *)(a1 + 1376) = 0;
  *(_QWORD *)(a1 + 1632) = 0;
  *(_QWORD *)(a1 + 1624) = 0;
  *(_QWORD *)(a1 + 1360) = &off_1E69EB548;
  if (SHIBYTE(v180) < 0)
    operator delete((void *)v179);
  if (*(char *)(a2 + 23) >= 0)
    v35 = *(unsigned __int8 *)(a2 + 23);
  else
    v35 = *(_QWORD *)(a2 + 8);
  v36 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v35 + 6);
  v172 = a1 + 1696;
  if (v182 < 0)
    v36 = (uint64_t (***)())v181;
  if (v35)
  {
    if (*(char *)(a2 + 23) >= 0)
      v37 = (const void *)a2;
    else
      v37 = *(const void **)a2;
    memmove(v36, v37, v35);
  }
  strcpy((char *)v36 + v35, "_inpPs");
  SpectralMagnitude<float,(LogTypes)0>::SpectralMagnitude(v172, (__int128 *)&v181, *v33, a6);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v38 = *(unsigned __int8 *)(a2 + 23);
  else
    v38 = *(_QWORD *)(a2 + 8);
  v39 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v38 + 10);
  v170 = (_QWORD *)(a1 + 2048);
  if (v182 < 0)
    v39 = (uint64_t (***)())v181;
  if (v38)
  {
    if (*(char *)(a2 + 23) >= 0)
      v40 = (const void *)a2;
    else
      v40 = *(const void **)a2;
    memmove(v39, v40, v38);
  }
  strcpy((char *)v39 + v38, "_inpPs_brk");
  v41 = *a5;
  Filterbank::ToBark<float,(LogTypes)0>::ToBark(v170, (__int128 *)&v181, *v33, v172, v41);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v42 = *(unsigned __int8 *)(a2 + 23);
  else
    v42 = *(_QWORD *)(a2 + 8);
  v43 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v42 + 11);
  v168 = a1 + 3104;
  if (v182 < 0)
    v43 = (uint64_t (***)())v181;
  if (v42)
  {
    if (*(char *)(a2 + 23) >= 0)
      v44 = (const void *)a2;
    else
      v44 = *(const void **)a2;
    memmove(v43, v44, v42);
  }
  strcpy((char *)v43 + v42, "_inpPs_prev");
  v166 = a1 + 18240;
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue&<float,(LogTypes)0>),std::vector<float>,std::vector<float>,std::vector<float>,float>(v168, (__int128 *)&v181, v168, v172, a1 + 18240, v169);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v45 = *(unsigned __int8 *)(a2 + 23);
  else
    v45 = *(_QWORD *)(a2 + 8);
  v46 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v45 + 15);
  v167 = a1 + 3456;
  if (v182 < 0)
    v46 = (uint64_t (***)())v181;
  if (v45)
  {
    if (*(char *)(a2 + 23) >= 0)
      v47 = (const void *)a2;
    else
      v47 = *(const void **)a2;
    memmove(v46, v47, v45);
  }
  strcpy((char *)v46 + v45, "_inpPs_prev_brk");
  v160 = (_QWORD *)(a1 + 16832);
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue&<float,(LogTypes)0>),std::vector<float>,std::vector<float>,std::vector<float>,float>(v167, (__int128 *)&v181, v167, (uint64_t)v170, a1 + 16832, v169);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v48 = *(unsigned __int8 *)(a2 + 23);
  else
    v48 = *(_QWORD *)(a2 + 8);
  v49 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v48 + 12);
  v50 = (_QWORD *)(a1 + 3808);
  if (v182 < 0)
    v49 = (uint64_t (***)())v181;
  if (v48)
  {
    if (*(char *)(a2 + 23) >= 0)
      v51 = (const void *)a2;
    else
      v51 = *(const void **)a2;
    memmove(v49, v51, v48);
  }
  strcpy((char *)v49 + v48, "_pass1Output");
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::AutoValue((_QWORD *)(a1 + 3808), (__int128 *)&v181);
  *v50 = &off_1E69EB710;
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(a1 + 3808, *v174);
  if (v50 == (_QWORD *)a6)
    __assert_rtn("Set", "AutoValue.h", 757, "&theAutoValue != this");
  if (*(_QWORD *)(a1 + 4064) != a6)
  {
    *(_QWORD *)(a1 + 4064) = a6;
    *(_QWORD *)(a1 + 3872) = a6;
    *(_QWORD *)(a1 + 3864) = 0;
    if (*(_DWORD *)(a1 + 3816) != 2)
    {
      *(_DWORD *)(a1 + 3816) = 2;
      Trackable::Uninitialize((Trackable *)(a1 + 3808));
    }
  }
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v52 = *(unsigned __int8 *)(a2 + 23);
  else
    v52 = *(_QWORD *)(a2 + 8);
  v53 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v52 + 13);
  if (v182 < 0)
    v53 = (uint64_t (***)())v181;
  if (v52)
  {
    if (*(char *)(a2 + 23) >= 0)
      v54 = (const void *)a2;
    else
      v54 = *(const void **)a2;
    memmove(v53, v54, v52);
  }
  strcpy((char *)v53 + v52, "_reverbEst2Ps");
  v154 = a1 + 4200;
  ReverbEstimator<float,true,(LogTypes)0>::ReverbEstimator(a1 + 4200, (uint64_t)&v181, *v174, *a4, a9, a1 + 3808, a8);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v55 = *(unsigned __int8 *)(a2 + 23);
  else
    v55 = *(_QWORD *)(a2 + 8);
  v56 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v55 + 17);
  if (v182 < 0)
    v56 = (uint64_t (***)())v181;
  if (v55)
  {
    if (*(char *)(a2 + 23) >= 0)
      v57 = (const void *)a2;
    else
      v57 = *(const void **)a2;
    memmove(v56, v57, v55);
  }
  strcpy((char *)v56 + v55, "_reverbEst2Ps_brk");
  v58 = *a5;
  Filterbank::ToBark<float,(LogTypes)0>::ToBark((_QWORD *)(a1 + 6304), (__int128 *)&v181, *v174, v154, v58);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v59 = *(unsigned __int8 *)(a2 + 23);
  else
    v59 = *(_QWORD *)(a2 + 8);
  v60 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v59 + 13);
  v165 = (_QWORD *)(a1 + 7360);
  if (v182 < 0)
    v60 = (uint64_t (***)())v181;
  if (v59)
  {
    if (*(char *)(a2 + 23) >= 0)
      v61 = (const void *)a2;
    else
      v61 = *(const void **)a2;
    memmove(v60, v61, v59);
  }
  strcpy((char *)v60 + v59, "_postSNR2_lin");
  NoiseSuppression::SNR::Post<float,(LogTypes)0>::Post(v165, (uint64_t)&v181, *v174, v172, v154);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v62 = *(unsigned __int8 *)(a2 + 23);
  else
    v62 = *(_QWORD *)(a2 + 8);
  v63 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v62 + 13);
  v164 = (_QWORD *)(a1 + 8064);
  if (v182 < 0)
    v63 = (uint64_t (***)())v181;
  if (v62)
  {
    if (*(char *)(a2 + 23) >= 0)
      v64 = (const void *)a2;
    else
      v64 = *(const void **)a2;
    memmove(v63, v64, v62);
  }
  strcpy((char *)v63 + v62, "_postSNR2_brk");
  NoiseSuppression::SNR::Post<float,(LogTypes)0>::Post(v164, (uint64_t)&v181, 0x18uLL, (uint64_t)v170, a1 + 6304);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v65 = *(unsigned __int8 *)(a2 + 23);
  else
    v65 = *(_QWORD *)(a2 + 8);
  v66 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v65 + 14);
  v159 = a1 + 8768;
  if (v182 < 0)
    v66 = (uint64_t (***)())v181;
  if (v65)
  {
    if (*(char *)(a2 + 23) >= 0)
      v67 = (const void *)a2;
    else
      v67 = *(const void **)a2;
    memmove(v66, v67, v65);
  }
  strcpy((char *)v66 + v65, "_priorSNR2_lin");
  NoiseSuppression::SNR::Prior<float,(LogTypes)0>::Prior(v159, (__int128 *)&v181, *v174, v168, v154, (uint64_t)v165);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v68 = *(unsigned __int8 *)(a2 + 23);
  else
    v68 = *(_QWORD *)(a2 + 8);
  v69 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v68 + 14);
  v173 = a1 + 10176;
  if (v182 < 0)
    v69 = (uint64_t (***)())v181;
  if (v68)
  {
    if (*(char *)(a2 + 23) >= 0)
      v70 = (const void *)a2;
    else
      v70 = *(const void **)a2;
    memmove(v69, v70, v68);
  }
  strcpy((char *)v69 + v68, "_priorSNR2_brk");
  NoiseSuppression::SNR::Prior<float,(LogTypes)0>::Prior(v173, (__int128 *)&v181, 0x18uLL, v167, a1 + 6304, (uint64_t)v164);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if (*(char *)(a2 + 23) >= 0)
    v71 = *(unsigned __int8 *)(a2 + 23);
  else
    v71 = *(_QWORD *)(a2 + 8);
  v72 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v71 + 9);
  if ((v176 & 0x80u) != 0)
    v72 = (void **)__p[0];
  if (v71)
  {
    if (*(char *)(a2 + 23) >= 0)
      v73 = (const void *)a2;
    else
      v73 = *(const void **)a2;
    memmove(v72, v73, v71);
  }
  strcpy((char *)v72 + v71, "_gainRule");
  v74 = *v174;
  v75 = *a5;
  *(_QWORD *)(a1 + 11584) = &off_1E69EBBD0;
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue&<float,(LogTypes)0>),std::vector<float>,float>(a1 + 11584, (__int128 *)__p, (uint64_t)NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::SmoothGain2, a1 + 18944, (uint64_t)v161);
  *(_QWORD *)(a1 + 11584) = &off_1E69EBBD0;
  if ((v176 & 0x80u) == 0)
    v76 = v176;
  else
    v76 = (size_t)__p[1];
  v77 = &v177;
  v156 = a1 + 11584;
  std::string::basic_string[abi:ne180100]((uint64_t)&v177, v76 + 11);
  v162 = a1 + 11936;
  if ((v178 & 0x80u) != 0)
    v77 = (__int128 *)v177;
  if (v76)
  {
    if ((v176 & 0x80u) == 0)
      v78 = __p;
    else
      v78 = (void **)__p[0];
    memmove(v77, v78, v76);
  }
  strcpy((char *)v77 + v76, "_gain2_bark");
  v79 = v75 / (double)v74;
  v80 = expf(-1.0 / (float)(v79 * 0.005));
  v81 = expf(-1.0 / (float)(v79 * 0.01));
  *(_QWORD *)(a1 + 11936) = &off_1E69EBBF0;
  v157 = a1 + 14720;
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>,std::vector<float>,std::vector<float>>(v162, &v177, (uint64_t)NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::Compute_gain, v173, a1 + 15072, a1 + 14720);
  *(_QWORD *)(a1 + 11936) = &off_1E69EBBF0;
  if ((v178 & 0x80u) == 0)
    v82 = v178;
  else
    v82 = *((_QWORD *)&v177 + 1);
  v83 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v82 + 17);
  if (v182 < 0)
    v83 = (uint64_t (***)())v181;
  if (v82)
  {
    if ((v178 & 0x80u) == 0)
      v84 = &v177;
    else
      v84 = (__int128 *)v177;
    memmove(v83, v84, v82);
  }
  strcpy((char *)v83 + v82, "_zetaBark_maxPart");
  *(_QWORD *)&v179 = NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeZetaBarkMaxPart;
  *((_QWORD *)&v179 + 1) = LODWORD(v81);
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&>,std::vector<float>,std::vector<float>>(a1 + 12288, (__int128 *)&v181, &v179, a1 + 12992, v173);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v178 & 0x80u) == 0)
    v85 = v178;
  else
    v85 = *((_QWORD *)&v177 + 1);
  v86 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v85 + 17);
  v163 = a1 + 12640;
  if (v182 < 0)
    v86 = (uint64_t (***)())v181;
  if (v85)
  {
    if ((v178 & 0x80u) == 0)
      v87 = &v177;
    else
      v87 = (__int128 *)v177;
    memmove(v86, v87, v85);
  }
  strcpy((char *)v86 + v85, "_zetaBark_minPart");
  *(_QWORD *)&v179 = NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeZetaBarkMinPart;
  *((_QWORD *)&v179 + 1) = LODWORD(v80);
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&>,std::vector<float>,std::vector<float>>(v163, (__int128 *)&v181, &v179, a1 + 12992, v173);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v178 & 0x80u) == 0)
    v88 = v178;
  else
    v88 = *((_QWORD *)&v177 + 1);
  v89 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v88 + 9);
  if (v182 < 0)
    v89 = (uint64_t (***)())v181;
  if (v88)
  {
    if ((v178 & 0x80u) == 0)
      v90 = &v177;
    else
      v90 = (__int128 *)v177;
    memmove(v89, v90, v88);
  }
  strcpy((char *)v89 + v88, "_zetaBark");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>,std::vector<float>,std::vector<float>>(a1 + 12992, (__int128 *)&v181, (uint64_t)NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeZetaBark, a1 + 12288, v163, v173);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v178 & 0x80u) == 0)
    v91 = v178;
  else
    v91 = *((_QWORD *)&v177 + 1);
  v92 = &v179;
  std::string::basic_string[abi:ne180100]((uint64_t)&v179, v91 + 4);
  v158 = a1 + 13344;
  if (v180 < 0)
    v92 = (__int128 *)v179;
  if (v91)
  {
    if ((v178 & 0x80u) == 0)
      v93 = &v177;
    else
      v93 = (__int128 *)v177;
    memmove(v92, v93, v91);
  }
  strcpy((char *)v92 + v91, "_snr");
  Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>>(v158, &v179, a1 + 12992);
  *(_QWORD *)(a1 + 13344) = &off_1E69EB300;
  *(_QWORD *)(a1 + 13624) = 0;
  *(_QWORD *)(a1 + 13600) = 0;
  *(_QWORD *)(a1 + 13592) = 0;
  *(_QWORD *)(a1 + 13632) = 1;
  *(_DWORD *)(a1 + 13640) = 0;
  *(_QWORD *)(a1 + 13648) = 0;
  *(_OWORD *)(a1 + 13656) = xmmword_1B66A0DC0;
  v94 = operator new(4uLL);
  *(_QWORD *)(a1 + 13648) = v94;
  *v94 = 0;
  *(_OWORD *)(a1 + 13664) = xmmword_1B66A0DC0;
  *(_QWORD *)&v95 = NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::Compute_snr;
  *((_QWORD *)&v95 + 1) = a1 + 12992;
  v181 = &off_1E69EBCA0;
  v182 = v95;
  v96 = &v181;
  v183 = (void **)&v181;
  std::__function::__value_func<float const& ()(float &)>::swap[abi:ne180100](&v181, (_QWORD *)(a1 + 13568));
  v101 = (uint64_t (***)())v183;
  if (v183 == (void **)&v181)
  {
    v102 = 4;
    v101 = &v181;
  }
  else
  {
    if (!v183)
      goto LABEL_261;
    v102 = 5;
  }
  ((void (*)(uint64_t (***)(), uint64_t, uint64_t, uint64_t, uint64_t))(*v101)[v102])(v101, v97, v98, v99, v100);
LABEL_261:
  *(_DWORD *)(a1 + 13352) = 0;
  *(_QWORD *)(a1 + 13360) = 0;
  *(_QWORD *)(a1 + 13616) = 0;
  *(_QWORD *)(a1 + 13608) = 0;
  if (SHIBYTE(v180) < 0)
    operator delete((void *)v179);
  if ((v178 & 0x80u) == 0)
    v103 = v178;
  else
    v103 = *((_QWORD *)&v177 + 1);
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v103 + 7);
  if (v182 < 0)
    v96 = (uint64_t (***)())v181;
  if (v103)
  {
    if ((v178 & 0x80u) == 0)
      v104 = &v177;
    else
      v104 = (__int128 *)v177;
    memmove(v96, v104, v103);
  }
  strcpy((char *)v96 + v103, "_Pframe");
  AutoValue<float,(LogTypes)0>::AutoValue<float const& ()(float &,AutoValue<float,(LogTypes)0>&),float>(a1 + 13680, (__int128 *)&v181, (uint64_t)NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputePframe, v158);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v178 & 0x80u) == 0)
    v105 = v178;
  else
    v105 = *((_QWORD *)&v177 + 1);
  v106 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v105 + 3);
  if (v182 < 0)
    v106 = (uint64_t (***)())v181;
  if (v105)
  {
    if ((v178 & 0x80u) == 0)
      v107 = &v177;
    else
      v107 = (__int128 *)v177;
    memmove(v106, v107, v105);
  }
  *(_DWORD *)((char *)v106 + v105) = 3231839;
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>>(a1 + 14016, (__int128 *)&v181, (uint64_t)NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeP1, a1 + 12992);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v178 & 0x80u) == 0)
    v108 = v178;
  else
    v108 = *((_QWORD *)&v177 + 1);
  v109 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v108 + 2);
  if (v182 < 0)
    v109 = (uint64_t (***)())v181;
  if (v108)
  {
    if ((v178 & 0x80u) == 0)
      v110 = &v177;
    else
      v110 = (__int128 *)v177;
    memmove(v109, v110, v108);
  }
  strcpy((char *)v109 + v108, "_Q");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue&<float,(LogTypes)0>),std::vector<float>,float>(a1 + 14368, (__int128 *)&v181, (uint64_t)NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeQ, a1 + 14016, a1 + 13680);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v178 & 0x80u) == 0)
    v111 = v178;
  else
    v111 = *((_QWORD *)&v177 + 1);
  v112 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v111 + 7);
  if (v182 < 0)
    v112 = (uint64_t (***)())v181;
  if (v111)
  {
    if ((v178 & 0x80u) == 0)
      v113 = &v177;
    else
      v113 = (__int128 *)v177;
    memmove(v112, v113, v111);
  }
  strcpy((char *)v112 + v111, "_QRatio");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>>(v157, (__int128 *)&v181, (uint64_t)NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeQRatio, a1 + 14368);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v178 & 0x80u) == 0)
    v114 = v178;
  else
    v114 = *((_QWORD *)&v177 + 1);
  v115 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v114 + 14);
  if (v182 < 0)
    v115 = (uint64_t (***)())v181;
  if (v114)
  {
    if ((v178 & 0x80u) == 0)
      v116 = &v177;
    else
      v116 = (__int128 *)v177;
    memmove(v115, v116, v114);
  }
  strcpy((char *)v115 + v114, "_expTheta_bark");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>>(a1 + 15072, (__int128 *)&v181, (uint64_t)NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeExpTheta, a1 + 17184);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(a1 + 14016, 0x18uLL);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(a1 + 14368, 0x18uLL);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v157, 0x18uLL);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(a1 + 15072, 0x18uLL);
  *(_QWORD *)(a1 + 13336) = 1;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(a1 + 12992, 0x18uLL);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(a1 + 12288, 0x18uLL);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v163, 0x18uLL);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v162, 0x18uLL);
  if ((char)v178 < 0)
    operator delete((void *)v177);
  if ((v176 & 0x80u) == 0)
    v117 = v176;
  else
    v117 = (size_t)__p[1];
  v118 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v117 + 9);
  if (v182 < 0)
    v118 = (uint64_t (***)())v181;
  if (v117)
  {
    if ((v176 & 0x80u) == 0)
      v119 = __p;
    else
      v119 = (void **)__p[0];
    memmove(v118, v119, v117);
  }
  strcpy((char *)v118 + v117, "_gain_lin");
  NoiseSuppression::Gain::Gain<float,(LogTypes)0>::Gain((_QWORD *)(a1 + 15424), (uint64_t)&v181, v74, v159, (uint64_t)v165);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v176 & 0x80u) == 0)
    v120 = v176;
  else
    v120 = (size_t)__p[1];
  v121 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v120 + 10);
  if (v182 < 0)
    v121 = (uint64_t (***)())v181;
  if (v120)
  {
    if ((v176 & 0x80u) == 0)
      v122 = __p;
    else
      v122 = (void **)__p[0];
    memmove(v121, v122, v120);
  }
  strcpy((char *)v121 + v120, "_gain_bark");
  NoiseSuppression::Gain::Gain<float,(LogTypes)0>::Gain(v160, (uint64_t)&v181, 0x18uLL, v173, (uint64_t)v164);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v176 & 0x80u) == 0)
    v123 = v176;
  else
    v123 = (size_t)__p[1];
  v124 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v123 + 11);
  if (v182 < 0)
    v124 = (uint64_t (***)())v181;
  if (v123)
  {
    if ((v176 & 0x80u) == 0)
      v125 = __p;
    else
      v125 = (void **)__p[0];
    memmove(v124, v125, v123);
  }
  strcpy((char *)v124 + v123, "_GainNoClip");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>,std::vector<float>>(v166, (__int128 *)&v181, (uint64_t)NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::ComputeGainNoClip, a1 + 15424, a1 + 19296);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v176 & 0x80u) == 0)
    v126 = v176;
  else
    v126 = (size_t)__p[1];
  v127 = &v181;
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v126 + 9);
  v128 = a1 + 18592;
  if (v182 < 0)
    v127 = (uint64_t (***)())v181;
  if (v126)
  {
    if ((v176 & 0x80u) == 0)
      v129 = __p;
    else
      v129 = (void **)__p[0];
    memmove(v127, v129, v126);
  }
  strcpy((char *)v127 + v126, "_GainSqrt");
  v130 = (_QWORD *)(a1 + 20000);
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue&<float,(LogTypes)0>),std::vector<float>,float>(a1 + 18592, (__int128 *)&v181, (uint64_t)NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::ComputeSqrtGain, v166, a1 + 20000);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v176 & 0x80u) == 0)
    v131 = v176;
  else
    v131 = (size_t)__p[1];
  v132 = &v179;
  std::string::basic_string[abi:ne180100]((uint64_t)&v179, v131 + 10);
  v133 = (_DWORD *)(a1 + 18952);
  if (v180 < 0)
    v132 = (__int128 *)v179;
  if (v131)
  {
    if ((v176 & 0x80u) == 0)
      v134 = __p;
    else
      v134 = (void **)__p[0];
    memmove(v132, v134, v131);
  }
  strcpy((char *)v132 + v131, "_gain2_raw");
  *(_QWORD *)(a1 + 18944) = &off_1E69EB2E0;
  *(_BYTE *)(a1 + 18968) = 0;
  *(_QWORD *)(a1 + 18984) = 0;
  *(_QWORD *)(a1 + 18992) = 0;
  *(_QWORD *)(a1 + 18976) = 0;
  *(_QWORD *)(a1 + 19008) = 0;
  if (SHIBYTE(v180) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 19016), (const std::string::value_type *)v179, *((std::string::size_type *)&v179 + 1));
  }
  else
  {
    *(_OWORD *)(a1 + 19016) = v179;
    *(_QWORD *)(a1 + 19032) = v180;
  }
  *(_BYTE *)(a1 + 19040) = 0;
  *(_OWORD *)(a1 + 19048) = 0u;
  *(_QWORD *)(a1 + 19160) = 0;
  *(_OWORD *)(a1 + 19064) = 0u;
  *(_OWORD *)(a1 + 19080) = 0u;
  *(_OWORD *)(a1 + 19096) = 0u;
  *(_OWORD *)(a1 + 19112) = 0u;
  *(_OWORD *)(a1 + 19128) = 0u;
  *(_OWORD *)(a1 + 19144) = 0u;
  v135 = operator new(8uLL);
  *v135 = v128;
  *(_QWORD *)(a1 + 19072) = v135;
  *(_QWORD *)(a1 + 19080) = v135 + 1;
  *(_QWORD *)(a1 + 19088) = v135 + 1;
  Trackable::BuildDepsList<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<float,(LogTypes)0>>((void **)(a1 + 19072), a1 + 19648, a1 + 20000);
  *(_QWORD *)(a1 + 19000) = 0;
  *v133 = 0;
  *(_QWORD *)(a1 + 18944) = &off_1E69EB4C0;
  *(_QWORD *)(a1 + 19200) = 0;
  *(_QWORD *)(a1 + 19192) = 0;
  v181 = 0;
  v182 = 0uLL;
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer((_QWORD *)(a1 + 19224), 1uLL, (uint64_t)&v181);
  *(_QWORD *)(a1 + 19288) = 0;
  v136 = (void **)operator new(0x28uLL);
  *v136 = &off_1E69EBD08;
  v136[1] = NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::ComputeGain2;
  v136[2] = (void *)v128;
  v136[3] = (void *)(a1 + 19648);
  v136[4] = v130;
  v183 = v136;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](&v181, (_QWORD *)(a1 + 19168));
  v140 = (uint64_t (***)())v183;
  if (v183 == (void **)&v181)
  {
    v141 = 4;
    v140 = &v181;
  }
  else
  {
    if (!v183)
      goto LABEL_391;
    v141 = 5;
  }
  ((void (*)(uint64_t (***)(), uint64_t, uint64_t, uint64_t))(*v140)[v141])(v140, v137, v138, v139);
LABEL_391:
  *v133 = 0;
  *(_QWORD *)(a1 + 18960) = 0;
  *(_QWORD *)(a1 + 19216) = 0;
  *(_QWORD *)(a1 + 19208) = 0;
  if (SHIBYTE(v180) < 0)
    operator delete((void *)v179);
  if ((v176 & 0x80u) == 0)
    v142 = v176;
  else
    v142 = (size_t)__p[1];
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v142 + 19);
  if (v182 >= 0)
    v143 = &v181;
  else
    v143 = (uint64_t (***)())v181;
  if (v142)
  {
    if ((v176 & 0x80u) == 0)
      v144 = __p;
    else
      v144 = (void **)__p[0];
    memmove(v143, v144, v142);
  }
  strcpy((char *)v143 + v142, "_bark2lin_gain_bark");
  v145 = v75;
  Filterbank::ToLinear<float,(LogTypes)0>::ToLinear((_QWORD *)(a1 + 19296), (__int128 *)&v181, v74, (uint64_t)v160, v145);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v176 & 0x80u) == 0)
    v146 = v176;
  else
    v146 = (size_t)__p[1];
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v146 + 20);
  if (v182 >= 0)
    v147 = &v181;
  else
    v147 = (uint64_t (***)())v181;
  if (v146)
  {
    if ((v176 & 0x80u) == 0)
      v148 = __p;
    else
      v148 = (void **)__p[0];
    memmove(v147, v148, v146);
  }
  strcpy((char *)v147 + v146, "_bark2lin_gain2_bark");
  v149 = v75;
  Filterbank::ToLinear<float,(LogTypes)0>::ToLinear((_QWORD *)(a1 + 19648), (__int128 *)&v181, v74, v162, v149);
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  if ((v176 & 0x80u) == 0)
    v150 = v176;
  else
    v150 = (size_t)__p[1];
  std::string::basic_string[abi:ne180100]((uint64_t)&v181, v150 + 14);
  if (v182 >= 0)
    v151 = &v181;
  else
    v151 = (uint64_t (***)())v181;
  if (v150)
  {
    if ((v176 & 0x80u) == 0)
      v152 = __p;
    else
      v152 = (void **)__p[0];
    memmove(v151, v152, v150);
  }
  strcpy((char *)v151 + v150, "_gainFloor_lin");
  AutoValue<float,(LogTypes)0>::AutoValue<float const& ()(float &,AutoValue<float,(LogTypes)0>&),float>(a1 + 20000, (__int128 *)&v181, (uint64_t)dBToLinear<float,(LogTypes)0>::Compute_dBToLinear, a7);
  *v130 = &off_1E69EB4E0;
  if (SHIBYTE(v182) < 0)
    operator delete(v181);
  *(_QWORD *)(a1 + 18584) = 1;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v166, v74);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(a1 + 18592, v74);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(a1 + 18944, v74);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v156, v74);
  if ((char)v176 < 0)
    operator delete(__p[0]);
  if (*(_QWORD *)(a1 + 256) != v156)
  {
    *(_QWORD *)(a1 + 256) = v156;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = v156;
    if (*(_DWORD *)(a1 + 8) != 2)
    {
      *(_DWORD *)(a1 + 8) = 2;
      Trackable::Uninitialize((Trackable *)a1);
    }
  }
  LODWORD(v181) = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>(a1, *v174, &v181);
  LODWORD(v181) = 0;
  *(_QWORD *)(a1 + 2040) = 1;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>(v172, *v174, &v181);
  LODWORD(v181) = 0;
  *(_QWORD *)(a1 + 2392) = 1;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<int,float>((uint64_t)v170, 24, &v181);
  LODWORD(v181) = 0;
  *(_QWORD *)(a1 + 3448) = 1;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>(v168, *v174, &v181);
  LODWORD(v181) = 0;
  *(_QWORD *)(a1 + 3800) = 1;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<int,float>(v167, 24, &v181);
  AutoValue<float,(LogTypes)0>::Set(v171, 0.007456);
  AutoValue<float,(LogTypes)0>::Set(v161, 0.25);
  return a1;
}

void sub_1B6566BA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void **a11, Trackable *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, Trackable *a18, uint64_t a19, uint64_t a20,void **a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void **a32,uint64_t a33,void **a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v47;

  v47 = *(void **)(v43 + 18976);
  if (v47)
  {
    *(_QWORD *)(v43 + 18984) = v47;
    operator delete(v47);
  }
  if (*(char *)(v45 - 161) < 0)
    operator delete(*(void **)(v45 - 184));
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v44);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a26);
  NoiseSuppression::Gain::Gain<float,(LogTypes)0>::~Gain(a20);
  NoiseSuppression::Gain::Gain<float,(LogTypes)0>::~Gain(a27);
  NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::~Gain2(a22);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a16);
  if (a43 < 0)
    operator delete(__p);
  NoiseSuppression::SNR::Prior<float,(LogTypes)0>::~Prior(a36);
  NoiseSuppression::SNR::Prior<float,(LogTypes)0>::~Prior(a19);
  NoiseSuppression::SNR::Post<float,(LogTypes)0>::~Post(a24);
  NoiseSuppression::SNR::Post<float,(LogTypes)0>::~Post(a25);
  Filterbank::ToBark<float,(LogTypes)0>::~ToBark(a9);
  ReverbEstimator<float,true,(LogTypes)0>::~ReverbEstimator(a14);
  Dereverb::FirstPass<float,(Dereverb::FirstPassTypes)0,(LogTypes)0>::~FirstPass(a10);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a30);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a31);
  Filterbank::ToBark<float,(LogTypes)0>::~ToBark(a33);
  SpectralMagnitude<float,(LogTypes)0>::~SpectralMagnitude(a35);
  TCToCoef<float,(LogTypes)0>::~TCToCoef(a32);
  AutoValue<float,(LogTypes)0>::~AutoValue(a34);
  dBToLinear<float,(LogTypes)0>::~dBToLinear(a11);
  AutoValue<float,(LogTypes)0>::~AutoValue(a21);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v43);
  _Unwind_Resume(a1);
}

DSPSplitComplex *AU::ReverbSuppressor::ApplyGainVector<float>(DSPSplitComplex *a1, uint64_t a2, uint64_t a3)
{
  DSPSplitComplex *v5;
  const float **v6;
  uint64_t v7;
  uint64_t v8;
  const float *v9;
  const float **v10;
  vDSP_Length v11;

  v5 = (DSPSplitComplex *)AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::Get(a2);
  v6 = (const float **)AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v7 = DSPSplitComplexV<float>::size(a1);
  if (v7 != DSPSplitComplexV<float>::size(v5))
    __assert_rtn("MultiplyCVectorRVector", "VectorUtils.h", 375, "result.size() == a.size()");
  v8 = DSPSplitComplexV<float>::size(a1);
  v10 = v6;
  v9 = *v6;
  if (v8 != v10[1] - v9)
    __assert_rtn("MultiplyCVectorRVector", "VectorUtils.h", 376, "result.size() == b.size()");
  v11 = DSPSplitComplexV<float>::size(a1);
  vDSP_zrvmul(v5, 1, v9, 1, a1, 1, v11);
  return a1;
}

uint64_t Trackable::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v3;

  v3 = *(_OWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v3;
  if (a1 == a2)
  {
    std::string::operator=((std::string *)(a1 + 72), (const std::string *)(a1 + 72));
  }
  else
  {
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((_QWORD *)(a1 + 32), *(char **)(a2 + 32), *(char **)(a2 + 40), (uint64_t)(*(_QWORD *)(a2 + 40) - *(_QWORD *)(a2 + 32)) >> 3);
    *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
    std::string::operator=((std::string *)(a1 + 72), (const std::string *)(a2 + 72));
    *(_BYTE *)(a1 + 96) = *(_BYTE *)(a2 + 96);
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((_QWORD *)(a1 + 104), *(char **)(a2 + 104), *(char **)(a2 + 112), (uint64_t)(*(_QWORD *)(a2 + 112) - *(_QWORD *)(a2 + 104)) >> 3);
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((_QWORD *)(a1 + 128), *(char **)(a2 + 128), *(char **)(a2 + 136), (uint64_t)(*(_QWORD *)(a2 + 136) - *(_QWORD *)(a2 + 128)) >> 3);
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((_QWORD *)(a1 + 152), *(char **)(a2 + 152), *(char **)(a2 + 160), (uint64_t)(*(_QWORD *)(a2 + 160) - *(_QWORD *)(a2 + 152)) >> 3);
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((_QWORD *)(a1 + 176), *(char **)(a2 + 176), *(char **)(a2 + 184), (uint64_t)(*(_QWORD *)(a2 + 184) - *(_QWORD *)(a2 + 176)) >> 3);
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((_QWORD *)(a1 + 200), *(char **)(a2 + 200), *(char **)(a2 + 208), (uint64_t)(*(_QWORD *)(a2 + 208) - *(_QWORD *)(a2 + 200)) >> 3);
  }
  return a1;
}

_QWORD *boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  void *v4;
  void *v5;

  v2 = a1[1];
  if (v2)
  {
    v3 = (_QWORD *)(*a1 + 24);
    do
    {
      v4 = (void *)v3[2];
      if (v4)
      {
        v3[3] = v4;
        operator delete(v4);
      }
      v5 = (void *)*(v3 - 1);
      if (v5)
      {
        *v3 = v5;
        operator delete(v5);
      }
      v3 += 8;
      --v2;
    }
    while (v2);
  }
  if (a1[2])
    operator delete((void *)*a1);
  return a1;
}

void Trackable::~Trackable(void **this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  *this = &off_1E69EB2E0;
  Trackable::Uninitialize((Trackable *)this);
  v2 = this[25];
  if (v2)
  {
    this[26] = v2;
    operator delete(v2);
  }
  v3 = this[22];
  if (v3)
  {
    this[23] = v3;
    operator delete(v3);
  }
  v4 = this[19];
  if (v4)
  {
    this[20] = v4;
    operator delete(v4);
  }
  v5 = this[16];
  if (v5)
  {
    this[17] = v5;
    operator delete(v5);
  }
  v6 = this[13];
  if (v6)
  {
    this[14] = v6;
    operator delete(v6);
  }
  if (*((char *)this + 95) < 0)
    operator delete(this[9]);
  v7 = this[4];
  if (v7)
  {
    this[5] = v7;
    operator delete(v7);
  }
}

{
  Trackable::~Trackable(this);
  JUMPOUT(0x1BCC95CECLL);
}

void AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::~AutoValue(uint64_t a1)
{
  void *v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector((_QWORD *)(a1 + 360));
  v2 = *(void **)(a1 + 336);
  if (v2)
  {
    *(_QWORD *)(a1 + 344) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 312);
  if (v3)
  {
    *(_QWORD *)(a1 + 320) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 248);
  if (v4 == (_QWORD *)(a1 + 224))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 224);
    goto LABEL_9;
  }
  if (v4)
  {
    v5 = 5;
LABEL_9:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  void *v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector((_QWORD *)(a1 + 360));
  v2 = *(void **)(a1 + 336);
  if (v2)
  {
    *(_QWORD *)(a1 + 344) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 312);
  if (v3)
  {
    *(_QWORD *)(a1 + 320) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 248);
  if (v4 == (_QWORD *)(a1 + 224))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 224);
  }
  else
  {
    if (!v4)
    {
LABEL_10:
      Trackable::~Trackable((void **)a1);
      JUMPOUT(0x1BCC95CECLL);
    }
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
  goto LABEL_10;
}

{
  void *v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector((_QWORD *)(a1 + 360));
  v2 = *(void **)(a1 + 336);
  if (v2)
  {
    *(_QWORD *)(a1 + 344) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 312);
  if (v3)
  {
    *(_QWORD *)(a1 + 320) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 248);
  if (v4 == (_QWORD *)(a1 + 224))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 224);
    goto LABEL_9;
  }
  if (v4)
  {
    v5 = 5;
LABEL_9:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  Trackable::~Trackable((void **)a1);
}

void boost::container::vector<DSPSplitComplexV<float>,void,void>::priv_destroy_all(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  void *v4;
  void *v5;

  v2 = a1[1];
  if (v2)
  {
    v3 = (_QWORD *)(*a1 + 24);
    do
    {
      v4 = (void *)v3[2];
      if (v4)
      {
        v3[3] = v4;
        operator delete(v4);
      }
      v5 = (void *)*(v3 - 1);
      if (v5)
      {
        *v3 = v5;
        operator delete(v5);
      }
      v3 += 8;
      --v2;
    }
    while (v2);
  }
  a1[1] = 0;
}

uint64_t DSPSplitComplexV<float>::DSPSplitComplexV(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  if (a2 != a1)
  {
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 16), *(char **)(a2 + 16), *(_QWORD *)(a2 + 24), (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 40), *(char **)(a2 + 40), *(_QWORD *)(a2 + 48), (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 2);
    v4 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)a1 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 8) = v4;
  }
  return a1;
}

void sub_1B6567804(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 48) = v5;
    operator delete(v5);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__value_func<DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1B6567998(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  size_t v13;
  void **v14;
  _BYTE *v15;
  unint64_t v16;
  char *v17;
  void *v18;

  v6 = __src;
  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (a4 > (v8 - *result) >> 3)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      goto LABEL_23;
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v10;
    if (v11 >> 61)
LABEL_23:
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    result = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v11);
    v9 = (char *)result;
    *v7 = result;
    v7[1] = result;
    v7[2] = &result[v12];
    v13 = a3 - v6;
    if (v13)
      result = memmove(result, v6, v13);
    v14 = (void **)(v7 + 1);
    goto LABEL_22;
  }
  v14 = (void **)(result + 1);
  v15 = (_BYTE *)result[1];
  v16 = (v15 - v9) >> 3;
  if (v16 >= a4)
  {
    v13 = a3 - __src;
    if (a3 == __src)
      goto LABEL_22;
    v18 = (void *)*result;
LABEL_21:
    result = memmove(v18, __src, v13);
    goto LABEL_22;
  }
  v17 = &__src[8 * v16];
  if (v15 != v9)
  {
    result = memmove((void *)*result, __src, v15 - v9);
    v9 = (char *)*v14;
  }
  v13 = a3 - v17;
  if (v13)
  {
    v18 = v9;
    __src = v17;
    goto LABEL_21;
  }
LABEL_22:
  *v14 = &v9[v13];
  return result;
}

_QWORD *AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(_QWORD *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  const char *v6;
  void *v7;
  uint64_t v8;

  v4 = a2;
  *a1 = 0;
  a1[1] = a2;
  DSPSplitComplexV<float>::DSPSplitComplexV((uint64_t)(a1 + 2), a3);
  a1[10] = 0;
  a1[11] = v4;
  a1[12] = 0;
  if (v4)
  {
    if (v4 >> 57)
      boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v6);
    v7 = operator new(v4 << 6);
    v8 = 0;
    a1[10] = v7;
    a1[12] = v4;
    do
    {
      DSPSplitComplexV<float>::DSPSplitComplexV((uint64_t)v7 + v8, a3);
      v8 += 64;
      --v4;
    }
    while (v4);
  }
  return a1;
}

void sub_1B6567B84()
{
  __break(1u);
}

void sub_1B6567BD4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  __cxa_end_catch();
  if (*(_QWORD *)(v2 + 96))
    operator delete(*(void **)(v2 + 80));
  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::~DictionaryRef_iterator(v1);
  _Unwind_Resume(a1);
}

_QWORD *AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::~CircularBuffer(_QWORD *a1)
{
  void *v2;
  void *v3;

  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector(a1 + 10);
  v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  return a1;
}

void std::__function::__func<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>,std::reference_wrapper<std::vector<float>>>,std::vector<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>,std::reference_wrapper<std::vector<float>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>,std::reference_wrapper<std::vector<float>>>,std::vector<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>,std::reference_wrapper<std::vector<float>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E69EBD70;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>,std::reference_wrapper<std::vector<float>>>,std::vector<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>,std::reference_wrapper<std::vector<float>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EBD70;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>,std::reference_wrapper<std::vector<float>>>,std::vector<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>,std::reference_wrapper<std::vector<float>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

void AU::ReverbSuppressor::Algorithm::~Algorithm(AU::ReverbSuppressor::Algorithm *this)
{
  Dereverb::Dereverb<float,(Dereverb::FirstPassTypes)0,(LogTypes)0>::~Dereverb((uint64_t)this);
  JUMPOUT(0x1BCC95CECLL);
}

void Dereverb::Dereverb<float,(Dereverb::FirstPassTypes)0,(LogTypes)0>::~Dereverb(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;
  _QWORD *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  void *v35;
  _QWORD *v36;
  uint64_t v37;

  *(_QWORD *)a1 = &off_1E69EB4A0;
  NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::~GainRule(a1 + 11584);
  NoiseSuppression::SNR::Prior<float,(LogTypes)0>::~Prior(a1 + 10176);
  NoiseSuppression::SNR::Prior<float,(LogTypes)0>::~Prior(a1 + 8768);
  *(_QWORD *)(a1 + 8064) = &off_1E69EBAB8;
  *(_QWORD *)(a1 + 8416) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 8736));
  v2 = *(void **)(a1 + 8712);
  if (v2)
  {
    *(_QWORD *)(a1 + 8720) = v2;
    operator delete(v2);
  }
  v3 = *(_QWORD **)(a1 + 8664);
  if (v3 == (_QWORD *)(a1 + 8640))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 8640);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
  Trackable::~Trackable((void **)(a1 + 8416));
  *(_QWORD *)(a1 + 8064) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 8384));
  v5 = *(void **)(a1 + 8360);
  if (v5)
  {
    *(_QWORD *)(a1 + 8368) = v5;
    operator delete(v5);
  }
  v6 = *(_QWORD **)(a1 + 8312);
  if (v6 == (_QWORD *)(a1 + 8288))
  {
    v7 = 4;
    v6 = (_QWORD *)(a1 + 8288);
  }
  else
  {
    if (!v6)
      goto LABEL_15;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_15:
  Trackable::~Trackable((void **)(a1 + 8064));
  *(_QWORD *)(a1 + 7360) = &off_1E69EBAB8;
  *(_QWORD *)(a1 + 7712) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 8032));
  v8 = *(void **)(a1 + 8008);
  if (v8)
  {
    *(_QWORD *)(a1 + 8016) = v8;
    operator delete(v8);
  }
  v9 = *(_QWORD **)(a1 + 7960);
  if (v9 == (_QWORD *)(a1 + 7936))
  {
    v10 = 4;
    v9 = (_QWORD *)(a1 + 7936);
  }
  else
  {
    if (!v9)
      goto LABEL_22;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_22:
  Trackable::~Trackable((void **)(a1 + 7712));
  *(_QWORD *)(a1 + 7360) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 7680));
  v11 = *(void **)(a1 + 7656);
  if (v11)
  {
    *(_QWORD *)(a1 + 7664) = v11;
    operator delete(v11);
  }
  v12 = *(_QWORD **)(a1 + 7608);
  if (v12 == (_QWORD *)(a1 + 7584))
  {
    v13 = 4;
    v12 = (_QWORD *)(a1 + 7584);
  }
  else
  {
    if (!v12)
      goto LABEL_29;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_29:
  Trackable::~Trackable((void **)(a1 + 7360));
  Filterbank::ToBark<float,(LogTypes)0>::~ToBark(a1 + 6304);
  ReverbEstimator<float,true,(LogTypes)0>::~ReverbEstimator(a1 + 4200);
  *(_QWORD *)(a1 + 3808) = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector((_QWORD *)(a1 + 4168));
  v14 = *(void **)(a1 + 4144);
  if (v14)
  {
    *(_QWORD *)(a1 + 4152) = v14;
    operator delete(v14);
  }
  v15 = *(void **)(a1 + 4120);
  if (v15)
  {
    *(_QWORD *)(a1 + 4128) = v15;
    operator delete(v15);
  }
  v16 = *(_QWORD **)(a1 + 4056);
  if (v16 == (_QWORD *)(a1 + 4032))
  {
    v17 = 4;
    v16 = (_QWORD *)(a1 + 4032);
  }
  else
  {
    if (!v16)
      goto LABEL_38;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_38:
  Trackable::~Trackable((void **)(a1 + 3808));
  *(_QWORD *)(a1 + 3456) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 3776));
  v18 = *(void **)(a1 + 3752);
  if (v18)
  {
    *(_QWORD *)(a1 + 3760) = v18;
    operator delete(v18);
  }
  v19 = *(_QWORD **)(a1 + 3704);
  if (v19 == (_QWORD *)(a1 + 3680))
  {
    v20 = 4;
    v19 = (_QWORD *)(a1 + 3680);
  }
  else
  {
    if (!v19)
      goto LABEL_45;
    v20 = 5;
  }
  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_45:
  Trackable::~Trackable((void **)(a1 + 3456));
  *(_QWORD *)(a1 + 3104) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 3424));
  v21 = *(void **)(a1 + 3400);
  if (v21)
  {
    *(_QWORD *)(a1 + 3408) = v21;
    operator delete(v21);
  }
  v22 = *(_QWORD **)(a1 + 3352);
  if (v22 == (_QWORD *)(a1 + 3328))
  {
    v23 = 4;
    v22 = (_QWORD *)(a1 + 3328);
  }
  else
  {
    if (!v22)
      goto LABEL_52;
    v23 = 5;
  }
  (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_52:
  Trackable::~Trackable((void **)(a1 + 3104));
  Filterbank::ToBark<float,(LogTypes)0>::~ToBark(a1 + 2048);
  *(_QWORD *)(a1 + 1696) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 2016));
  v24 = *(void **)(a1 + 1992);
  if (v24)
  {
    *(_QWORD *)(a1 + 2000) = v24;
    operator delete(v24);
  }
  v25 = *(_QWORD **)(a1 + 1944);
  if (v25 == (_QWORD *)(a1 + 1920))
  {
    v26 = 4;
    v25 = (_QWORD *)(a1 + 1920);
  }
  else
  {
    if (!v25)
      goto LABEL_59;
    v26 = 5;
  }
  (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_59:
  Trackable::~Trackable((void **)(a1 + 1696));
  *(_QWORD *)(a1 + 1360) = &off_1E69EB300;
  if (*(_QWORD *)(a1 + 1680))
    operator delete(*(void **)(a1 + 1664));
  v27 = *(_QWORD **)(a1 + 1608);
  if (v27 == (_QWORD *)(a1 + 1584))
  {
    v28 = 4;
    v27 = (_QWORD *)(a1 + 1584);
  }
  else
  {
    if (!v27)
      goto LABEL_66;
    v28 = 5;
  }
  (*(void (**)(void))(*v27 + 8 * v28))();
LABEL_66:
  Trackable::~Trackable((void **)(a1 + 1360));
  *(_QWORD *)(a1 + 1024) = &off_1E69EB300;
  if (*(_QWORD *)(a1 + 1344))
    operator delete(*(void **)(a1 + 1328));
  v29 = *(_QWORD **)(a1 + 1272);
  if (v29 == (_QWORD *)(a1 + 1248))
  {
    v30 = 4;
    v29 = (_QWORD *)(a1 + 1248);
  }
  else
  {
    if (!v29)
      goto LABEL_73;
    v30 = 5;
  }
  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_73:
  Trackable::~Trackable((void **)(a1 + 1024));
  *(_QWORD *)(a1 + 688) = &off_1E69EB300;
  if (*(_QWORD *)(a1 + 1008))
    operator delete(*(void **)(a1 + 992));
  v31 = *(_QWORD **)(a1 + 936);
  if (v31 == (_QWORD *)(a1 + 912))
  {
    v32 = 4;
    v31 = (_QWORD *)(a1 + 912);
  }
  else
  {
    if (!v31)
      goto LABEL_80;
    v32 = 5;
  }
  (*(void (**)(void))(*v31 + 8 * v32))();
LABEL_80:
  Trackable::~Trackable((void **)(a1 + 688));
  *(_QWORD *)(a1 + 352) = &off_1E69EB300;
  if (*(_QWORD *)(a1 + 672))
    operator delete(*(void **)(a1 + 656));
  v33 = *(_QWORD **)(a1 + 600);
  if (v33 == (_QWORD *)(a1 + 576))
  {
    v34 = 4;
    v33 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v33)
      goto LABEL_87;
    v34 = 5;
  }
  (*(void (**)(void))(*v33 + 8 * v34))();
LABEL_87:
  Trackable::~Trackable((void **)(a1 + 352));
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v35 = *(void **)(a1 + 296);
  if (v35)
  {
    *(_QWORD *)(a1 + 304) = v35;
    operator delete(v35);
  }
  v36 = *(_QWORD **)(a1 + 248);
  if (v36 == (_QWORD *)(a1 + 224))
  {
    v37 = 4;
    v36 = (_QWORD *)(a1 + 224);
    goto LABEL_93;
  }
  if (v36)
  {
    v37 = 5;
LABEL_93:
    (*(void (**)(void))(*v36 + 8 * v37))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  Dereverb::Dereverb<float,(Dereverb::FirstPassTypes)0,(LogTypes)0>::~Dereverb(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::~GainRule(uint64_t a1)
{
  void **v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;
  _QWORD *v12;
  uint64_t v13;
  void *v14;
  _QWORD *v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  uint64_t v22;

  *(_QWORD *)a1 = &off_1E69EBBD0;
  v2 = (void **)(a1 + 8416);
  *(_QWORD *)(a1 + 8416) = &off_1E69EB300;
  if (*(_QWORD *)(a1 + 8736))
    operator delete(*(void **)(a1 + 8720));
  v3 = *(_QWORD **)(a1 + 8664);
  if (v3 == (_QWORD *)(a1 + 8640))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 8640);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)(a1 + 8064) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 8384));
  v5 = *(void **)(a1 + 8360);
  if (v5)
  {
    *(_QWORD *)(a1 + 8368) = v5;
    operator delete(v5);
  }
  v6 = *(_QWORD **)(a1 + 8312);
  if (v6 == (_QWORD *)(a1 + 8288))
  {
    v7 = 4;
    v6 = (_QWORD *)(a1 + 8288);
  }
  else
  {
    if (!v6)
      goto LABEL_15;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_15:
  Trackable::~Trackable((void **)(a1 + 8064));
  *(_QWORD *)(a1 + 7712) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 8032));
  v8 = *(void **)(a1 + 8008);
  if (v8)
  {
    *(_QWORD *)(a1 + 8016) = v8;
    operator delete(v8);
  }
  v9 = *(_QWORD **)(a1 + 7960);
  if (v9 == (_QWORD *)(a1 + 7936))
  {
    v10 = 4;
    v9 = (_QWORD *)(a1 + 7936);
  }
  else
  {
    if (!v9)
      goto LABEL_22;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_22:
  Trackable::~Trackable((void **)(a1 + 7712));
  *(_QWORD *)(a1 + 7360) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 7680));
  v11 = *(void **)(a1 + 7656);
  if (v11)
  {
    *(_QWORD *)(a1 + 7664) = v11;
    operator delete(v11);
  }
  v12 = *(_QWORD **)(a1 + 7608);
  if (v12 == (_QWORD *)(a1 + 7584))
  {
    v13 = 4;
    v12 = (_QWORD *)(a1 + 7584);
  }
  else
  {
    if (!v12)
      goto LABEL_29;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_29:
  Trackable::~Trackable((void **)(a1 + 7360));
  *(_QWORD *)(a1 + 7008) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 7328));
  v14 = *(void **)(a1 + 7304);
  if (v14)
  {
    *(_QWORD *)(a1 + 7312) = v14;
    operator delete(v14);
  }
  v15 = *(_QWORD **)(a1 + 7256);
  if (v15 == (_QWORD *)(a1 + 7232))
  {
    v16 = 4;
    v15 = (_QWORD *)(a1 + 7232);
  }
  else
  {
    if (!v15)
      goto LABEL_36;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_36:
  Trackable::~Trackable((void **)(a1 + 7008));
  *(_QWORD *)(a1 + 6656) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 6976));
  v17 = *(void **)(a1 + 6952);
  if (v17)
  {
    *(_QWORD *)(a1 + 6960) = v17;
    operator delete(v17);
  }
  v18 = *(_QWORD **)(a1 + 6904);
  if (v18 == (_QWORD *)(a1 + 6880))
  {
    v19 = 4;
    v18 = (_QWORD *)(a1 + 6880);
  }
  else
  {
    if (!v18)
      goto LABEL_43;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_43:
  Trackable::~Trackable((void **)(a1 + 6656));
  NoiseSuppression::Gain::Gain<float,(LogTypes)0>::~Gain(a1 + 5248);
  NoiseSuppression::Gain::Gain<float,(LogTypes)0>::~Gain(a1 + 3840);
  NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::~Gain2(a1 + 352);
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v20 = *(void **)(a1 + 296);
  if (v20)
  {
    *(_QWORD *)(a1 + 304) = v20;
    operator delete(v20);
  }
  v21 = *(_QWORD **)(a1 + 248);
  if (v21 == (_QWORD *)(a1 + 224))
  {
    v22 = 4;
    v21 = (_QWORD *)(a1 + 224);
    goto LABEL_49;
  }
  if (v21)
  {
    v22 = 5;
LABEL_49:
    (*(void (**)(void))(*v21 + 8 * v22))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::~GainRule(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void NoiseSuppression::SNR::Prior<float,(LogTypes)0>::~Prior(uint64_t a1)
{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;
  uint64_t v14;

  *(_QWORD *)a1 = &off_1E69EBB68;
  v2 = (void **)(a1 + 1056);
  *(_QWORD *)(a1 + 1056) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 1376));
  v3 = *(void **)(a1 + 1352);
  if (v3)
  {
    *(_QWORD *)(a1 + 1360) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 1304);
  if (v4 == (_QWORD *)(a1 + 1280))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 1280);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)(a1 + 704) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 1024));
  v6 = *(void **)(a1 + 1000);
  if (v6)
  {
    *(_QWORD *)(a1 + 1008) = v6;
    operator delete(v6);
  }
  v7 = *(_QWORD **)(a1 + 952);
  if (v7 == (_QWORD *)(a1 + 928))
  {
    v8 = 4;
    v7 = (_QWORD *)(a1 + 928);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_15:
  Trackable::~Trackable((void **)(a1 + 704));
  *(_QWORD *)(a1 + 352) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 672));
  v9 = *(void **)(a1 + 648);
  if (v9)
  {
    *(_QWORD *)(a1 + 656) = v9;
    operator delete(v9);
  }
  v10 = *(_QWORD **)(a1 + 600);
  if (v10 == (_QWORD *)(a1 + 576))
  {
    v11 = 4;
    v10 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v10)
      goto LABEL_22;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_22:
  Trackable::~Trackable((void **)(a1 + 352));
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v12 = *(void **)(a1 + 296);
  if (v12)
  {
    *(_QWORD *)(a1 + 304) = v12;
    operator delete(v12);
  }
  v13 = *(_QWORD **)(a1 + 248);
  if (v13 == (_QWORD *)(a1 + 224))
  {
    v14 = 4;
    v13 = (_QWORD *)(a1 + 224);
    goto LABEL_28;
  }
  if (v13)
  {
    v14 = 5;
LABEL_28:
    (*(void (**)(void))(*v13 + 8 * v14))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  NoiseSuppression::SNR::Prior<float,(LogTypes)0>::~Prior(a1);
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *boost::container::vector<std::vector<float>,void,void>::~vector(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  void *v4;

  v2 = a1[1];
  if (v2)
  {
    v3 = (_QWORD *)(*a1 + 8);
    do
    {
      v4 = (void *)*(v3 - 1);
      if (v4)
      {
        *v3 = v4;
        operator delete(v4);
      }
      v3 += 3;
      --v2;
    }
    while (v2);
  }
  if (a1[2])
    operator delete((void *)*a1);
  return a1;
}

void Filterbank::ToBark<float,(LogTypes)0>::~ToBark(uint64_t a1)
{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  _QWORD *v10;
  uint64_t v11;

  *(_QWORD *)a1 = &off_1E69EB618;
  v2 = (void **)(a1 + 704);
  *(_QWORD *)(a1 + 704) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 1024));
  v3 = *(void **)(a1 + 1000);
  if (v3)
  {
    *(_QWORD *)(a1 + 1008) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 952);
  if (v4 == (_QWORD *)(a1 + 928))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 928);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)(a1 + 352) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 672));
  v6 = *(void **)(a1 + 648);
  if (v6)
  {
    *(_QWORD *)(a1 + 656) = v6;
    operator delete(v6);
  }
  v7 = *(_QWORD **)(a1 + 600);
  if (v7 == (_QWORD *)(a1 + 576))
  {
    v8 = 4;
    v7 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_15:
  Trackable::~Trackable((void **)(a1 + 352));
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v9 = *(void **)(a1 + 296);
  if (v9)
  {
    *(_QWORD *)(a1 + 304) = v9;
    operator delete(v9);
  }
  v10 = *(_QWORD **)(a1 + 248);
  if (v10 == (_QWORD *)(a1 + 224))
  {
    v11 = 4;
    v10 = (_QWORD *)(a1 + 224);
    goto LABEL_21;
  }
  if (v10)
  {
    v11 = 5;
LABEL_21:
    (*(void (**)(void))(*v10 + 8 * v11))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  Filterbank::ToBark<float,(LogTypes)0>::~ToBark(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void ReverbEstimator<float,true,(LogTypes)0>::~ReverbEstimator(uint64_t a1)
{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;

  *(_QWORD *)a1 = &off_1E69EB730;
  v2 = (void **)(a1 + 1752);
  *(_QWORD *)(a1 + 1752) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 2072));
  v3 = *(void **)(a1 + 2048);
  if (v3)
  {
    *(_QWORD *)(a1 + 2056) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 2000);
  if (v4 == (_QWORD *)(a1 + 1976))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 1976);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  Convolver<float,true,(LogTypes)0>::~Convolver(a1 + 688);
  *(_QWORD *)(a1 + 352) = &off_1E69EB300;
  if (*(_QWORD *)(a1 + 672))
    operator delete(*(void **)(a1 + 656));
  v6 = *(_QWORD **)(a1 + 600);
  if (v6 == (_QWORD *)(a1 + 576))
  {
    v7 = 4;
    v6 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v6)
      goto LABEL_15;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_15:
  Trackable::~Trackable((void **)(a1 + 352));
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v8 = *(void **)(a1 + 296);
  if (v8)
  {
    *(_QWORD *)(a1 + 304) = v8;
    operator delete(v8);
  }
  v9 = *(_QWORD **)(a1 + 248);
  if (v9 == (_QWORD *)(a1 + 224))
  {
    v10 = 4;
    v9 = (_QWORD *)(a1 + 224);
    goto LABEL_21;
  }
  if (v9)
  {
    v10 = 5;
LABEL_21:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  ReverbEstimator<float,true,(LogTypes)0>::~ReverbEstimator(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void AutoValue<float,(LogTypes)0>::~AutoValue(void **this)
{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB300;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
    goto LABEL_7;
  }
  if (v2)
  {
    v3 = 5;
LABEL_7:
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
  Trackable::~Trackable(this);
}

{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB300;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
  }
  else
  {
    if (!v2)
    {
LABEL_8:
      Trackable::~Trackable(this);
      JUMPOUT(0x1BCC95CECLL);
    }
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  goto LABEL_8;
}

void Convolver<float,true,(LogTypes)0>::~Convolver(uint64_t a1)
{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;
  void **v11;

  *(_QWORD *)a1 = &off_1E69EB798;
  v2 = (void **)(a1 + 704);
  *(_QWORD *)(a1 + 704) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 1024));
  v3 = *(void **)(a1 + 1000);
  if (v3)
  {
    *(_QWORD *)(a1 + 1008) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 952);
  if (v4 == (_QWORD *)(a1 + 928))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 928);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)(a1 + 352) = off_1E69EB800;
  boost::container::vector<std::vector<std::vector<float>>,void,void>::~vector(a1 + 672);
  v11 = (void **)(a1 + 648);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  v6 = *(_QWORD **)(a1 + 600);
  if (v6 == (_QWORD *)(a1 + 576))
  {
    v7 = 4;
    v6 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v6)
      goto LABEL_13;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_13:
  Trackable::~Trackable((void **)(a1 + 352));
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v8 = *(void **)(a1 + 296);
  if (v8)
  {
    *(_QWORD *)(a1 + 304) = v8;
    operator delete(v8);
  }
  v9 = *(_QWORD **)(a1 + 248);
  if (v9 == (_QWORD *)(a1 + 224))
  {
    v10 = 4;
    v9 = (_QWORD *)(a1 + 224);
    goto LABEL_19;
  }
  if (v9)
  {
    v10 = 5;
LABEL_19:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  Convolver<float,true,(LogTypes)0>::~Convolver(a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t boost::container::vector<std::vector<std::vector<float>>,void,void>::~vector(uint64_t a1)
{
  uint64_t v2;
  void **v3;
  void **v5;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(void ***)a1;
    do
    {
      --v2;
      v5 = v3;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
      v3 += 3;
    }
    while (v2);
  }
  if (*(_QWORD *)(a1 + 16))
    operator delete(*(void **)a1);
  return a1;
}

void AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::~AutoValue(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)a1 = off_1E69EB800;
  boost::container::vector<std::vector<std::vector<float>>,void,void>::~vector(a1 + 320);
  v4 = (void **)(a1 + 296);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v2 = *(_QWORD **)(a1 + 248);
  if (v2 == (_QWORD *)(a1 + 224))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 224);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  Trackable::~Trackable((void **)a1);
}

uint64_t AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::~AutoValue(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void **v5;

  *(_QWORD *)a1 = off_1E69EB800;
  boost::container::vector<std::vector<std::vector<float>>,void,void>::~vector(a1 + 320);
  v5 = (void **)(a1 + 296);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v2 = *(_QWORD **)(a1 + 248);
  if (v2 == (_QWORD *)(a1 + 224))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 224);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  Trackable::~Trackable((void **)a1);
  return MEMORY[0x1BCC95CEC]();
}

void AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v2 = *(void **)(a1 + 296);
  if (v2)
  {
    *(_QWORD *)(a1 + 304) = v2;
    operator delete(v2);
  }
  v3 = *(_QWORD **)(a1 + 248);
  if (v3 == (_QWORD *)(a1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 224);
    goto LABEL_7;
  }
  if (v3)
  {
    v4 = 5;
LABEL_7:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v2 = *(void **)(a1 + 296);
  if (v2)
  {
    *(_QWORD *)(a1 + 304) = v2;
    operator delete(v2);
  }
  v3 = *(_QWORD **)(a1 + 248);
  if (v3 == (_QWORD *)(a1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 224);
  }
  else
  {
    if (!v3)
    {
LABEL_8:
      Trackable::~Trackable((void **)a1);
      JUMPOUT(0x1BCC95CECLL);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_8;
}

{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v2 = *(void **)(a1 + 296);
  if (v2)
  {
    *(_QWORD *)(a1 + 304) = v2;
    operator delete(v2);
  }
  v3 = *(_QWORD **)(a1 + 248);
  if (v3 == (_QWORD *)(a1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 224);
    goto LABEL_7;
  }
  if (v3)
  {
    v4 = 5;
LABEL_7:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  Trackable::~Trackable((void **)a1);
}

void NoiseSuppression::SNR::Post<float,(LogTypes)0>::~Post(uint64_t a1)
{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;

  *(_QWORD *)a1 = &off_1E69EBAB8;
  v2 = (void **)(a1 + 352);
  *(_QWORD *)(a1 + 352) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 672));
  v3 = *(void **)(a1 + 648);
  if (v3)
  {
    *(_QWORD *)(a1 + 656) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 600);
  if (v4 == (_QWORD *)(a1 + 576))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v6 = *(void **)(a1 + 296);
  if (v6)
  {
    *(_QWORD *)(a1 + 304) = v6;
    operator delete(v6);
  }
  v7 = *(_QWORD **)(a1 + 248);
  if (v7 == (_QWORD *)(a1 + 224))
  {
    v8 = 4;
    v7 = (_QWORD *)(a1 + 224);
    goto LABEL_14;
  }
  if (v7)
  {
    v8 = 5;
LABEL_14:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;

  *(_QWORD *)a1 = &off_1E69EBAB8;
  v2 = (void **)(a1 + 352);
  *(_QWORD *)(a1 + 352) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 672));
  v3 = *(void **)(a1 + 648);
  if (v3)
  {
    *(_QWORD *)(a1 + 656) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 600);
  if (v4 == (_QWORD *)(a1 + 576))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v6 = *(void **)(a1 + 296);
  if (v6)
  {
    *(_QWORD *)(a1 + 304) = v6;
    operator delete(v6);
  }
  v7 = *(_QWORD **)(a1 + 248);
  if (v7 == (_QWORD *)(a1 + 224))
  {
    v8 = 4;
    v7 = (_QWORD *)(a1 + 224);
  }
  else
  {
    if (!v7)
    {
LABEL_15:
      Trackable::~Trackable((void **)a1);
      JUMPOUT(0x1BCC95CECLL);
    }
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
  goto LABEL_15;
}

void NoiseSuppression::Gain::Gain<float,(LogTypes)0>::~Gain(uint64_t a1)
{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;
  uint64_t v14;

  *(_QWORD *)a1 = &off_1E69EBCE8;
  v2 = (void **)(a1 + 1056);
  *(_QWORD *)(a1 + 1056) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 1376));
  v3 = *(void **)(a1 + 1352);
  if (v3)
  {
    *(_QWORD *)(a1 + 1360) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 1304);
  if (v4 == (_QWORD *)(a1 + 1280))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 1280);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)(a1 + 704) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 1024));
  v6 = *(void **)(a1 + 1000);
  if (v6)
  {
    *(_QWORD *)(a1 + 1008) = v6;
    operator delete(v6);
  }
  v7 = *(_QWORD **)(a1 + 952);
  if (v7 == (_QWORD *)(a1 + 928))
  {
    v8 = 4;
    v7 = (_QWORD *)(a1 + 928);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_15:
  Trackable::~Trackable((void **)(a1 + 704));
  *(_QWORD *)(a1 + 352) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 672));
  v9 = *(void **)(a1 + 648);
  if (v9)
  {
    *(_QWORD *)(a1 + 656) = v9;
    operator delete(v9);
  }
  v10 = *(_QWORD **)(a1 + 600);
  if (v10 == (_QWORD *)(a1 + 576))
  {
    v11 = 4;
    v10 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v10)
      goto LABEL_22;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_22:
  Trackable::~Trackable((void **)(a1 + 352));
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v12 = *(void **)(a1 + 296);
  if (v12)
  {
    *(_QWORD *)(a1 + 304) = v12;
    operator delete(v12);
  }
  v13 = *(_QWORD **)(a1 + 248);
  if (v13 == (_QWORD *)(a1 + 224))
  {
    v14 = 4;
    v13 = (_QWORD *)(a1 + 224);
    goto LABEL_28;
  }
  if (v13)
  {
    v14 = 5;
LABEL_28:
    (*(void (**)(void))(*v13 + 8 * v14))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  NoiseSuppression::Gain::Gain<float,(LogTypes)0>::~Gain(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::~Gain2(uint64_t a1)
{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  uint64_t v27;
  void *v28;
  _QWORD *v29;
  uint64_t v30;

  *(_QWORD *)a1 = &off_1E69EBBF0;
  v2 = (void **)(a1 + 3136);
  *(_QWORD *)(a1 + 3136) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 3456));
  v3 = *(void **)(a1 + 3432);
  if (v3)
  {
    *(_QWORD *)(a1 + 3440) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 3384);
  if (v4 == (_QWORD *)(a1 + 3360))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 3360);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)(a1 + 2784) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 3104));
  v6 = *(void **)(a1 + 3080);
  if (v6)
  {
    *(_QWORD *)(a1 + 3088) = v6;
    operator delete(v6);
  }
  v7 = *(_QWORD **)(a1 + 3032);
  if (v7 == (_QWORD *)(a1 + 3008))
  {
    v8 = 4;
    v7 = (_QWORD *)(a1 + 3008);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_15:
  Trackable::~Trackable((void **)(a1 + 2784));
  *(_QWORD *)(a1 + 2432) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 2752));
  v9 = *(void **)(a1 + 2728);
  if (v9)
  {
    *(_QWORD *)(a1 + 2736) = v9;
    operator delete(v9);
  }
  v10 = *(_QWORD **)(a1 + 2680);
  if (v10 == (_QWORD *)(a1 + 2656))
  {
    v11 = 4;
    v10 = (_QWORD *)(a1 + 2656);
  }
  else
  {
    if (!v10)
      goto LABEL_22;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_22:
  Trackable::~Trackable((void **)(a1 + 2432));
  *(_QWORD *)(a1 + 2080) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 2400));
  v12 = *(void **)(a1 + 2376);
  if (v12)
  {
    *(_QWORD *)(a1 + 2384) = v12;
    operator delete(v12);
  }
  v13 = *(_QWORD **)(a1 + 2328);
  if (v13 == (_QWORD *)(a1 + 2304))
  {
    v14 = 4;
    v13 = (_QWORD *)(a1 + 2304);
  }
  else
  {
    if (!v13)
      goto LABEL_29;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_29:
  Trackable::~Trackable((void **)(a1 + 2080));
  *(_QWORD *)(a1 + 1744) = &off_1E69EB300;
  if (*(_QWORD *)(a1 + 2064))
    operator delete(*(void **)(a1 + 2048));
  v15 = *(_QWORD **)(a1 + 1992);
  if (v15 == (_QWORD *)(a1 + 1968))
  {
    v16 = 4;
    v15 = (_QWORD *)(a1 + 1968);
  }
  else
  {
    if (!v15)
      goto LABEL_36;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_36:
  Trackable::~Trackable((void **)(a1 + 1744));
  *(_QWORD *)(a1 + 1408) = &off_1E69EB300;
  if (*(_QWORD *)(a1 + 1728))
    operator delete(*(void **)(a1 + 1712));
  v17 = *(_QWORD **)(a1 + 1656);
  if (v17 == (_QWORD *)(a1 + 1632))
  {
    v18 = 4;
    v17 = (_QWORD *)(a1 + 1632);
  }
  else
  {
    if (!v17)
      goto LABEL_43;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_43:
  Trackable::~Trackable((void **)(a1 + 1408));
  *(_QWORD *)(a1 + 1056) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 1376));
  v19 = *(void **)(a1 + 1352);
  if (v19)
  {
    *(_QWORD *)(a1 + 1360) = v19;
    operator delete(v19);
  }
  v20 = *(_QWORD **)(a1 + 1304);
  if (v20 == (_QWORD *)(a1 + 1280))
  {
    v21 = 4;
    v20 = (_QWORD *)(a1 + 1280);
  }
  else
  {
    if (!v20)
      goto LABEL_50;
    v21 = 5;
  }
  (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_50:
  Trackable::~Trackable((void **)(a1 + 1056));
  *(_QWORD *)(a1 + 704) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 1024));
  v22 = *(void **)(a1 + 1000);
  if (v22)
  {
    *(_QWORD *)(a1 + 1008) = v22;
    operator delete(v22);
  }
  v23 = *(_QWORD **)(a1 + 952);
  if (v23 == (_QWORD *)(a1 + 928))
  {
    v24 = 4;
    v23 = (_QWORD *)(a1 + 928);
  }
  else
  {
    if (!v23)
      goto LABEL_57;
    v24 = 5;
  }
  (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_57:
  Trackable::~Trackable((void **)(a1 + 704));
  *(_QWORD *)(a1 + 352) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 672));
  v25 = *(void **)(a1 + 648);
  if (v25)
  {
    *(_QWORD *)(a1 + 656) = v25;
    operator delete(v25);
  }
  v26 = *(_QWORD **)(a1 + 600);
  if (v26 == (_QWORD *)(a1 + 576))
  {
    v27 = 4;
    v26 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v26)
      goto LABEL_64;
    v27 = 5;
  }
  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_64:
  Trackable::~Trackable((void **)(a1 + 352));
  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v28 = *(void **)(a1 + 296);
  if (v28)
  {
    *(_QWORD *)(a1 + 304) = v28;
    operator delete(v28);
  }
  v29 = *(_QWORD **)(a1 + 248);
  if (v29 == (_QWORD *)(a1 + 224))
  {
    v30 = 4;
    v29 = (_QWORD *)(a1 + 224);
    goto LABEL_70;
  }
  if (v29)
  {
    v30 = 5;
LABEL_70:
    (*(void (**)(void))(*v29 + 8 * v30))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::~Gain2(a1);
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *AutoValue<std::vector<float>,(LogTypes)0>::AutoValue(_QWORD *a1, __int128 *a2)
{
  _QWORD *v3;
  _QWORD v5[3];

  v3 = (_QWORD *)Trackable::Trackable<>((uint64_t)a1, a2);
  *v3 = &off_1E69EB4C0;
  a1[31] = 0;
  a1[32] = 0;
  memset(v5, 0, sizeof(v5));
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v3 + 35, 1uLL, (uint64_t)v5);
  a1[43] = 0;
  a1[2] = 0;
  a1[33] = 0;
  a1[34] = 0;
  return a1;
}

void sub_1B65696E8(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;

  v3 = *(_QWORD **)(v1 + 248);
  if (v3 == (_QWORD *)(v1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(v1 + 224);
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  Trackable::~Trackable((void **)v1);
  _Unwind_Resume(a1);
}

uint64_t AutoValue<float,(LogTypes)0>::AutoValue(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  _DWORD *v4;

  v3 = Trackable::Trackable<>(a1, a2);
  *(_QWORD *)v3 = &off_1E69EB300;
  *(_QWORD *)(v3 + 248) = 0;
  *(_QWORD *)(v3 + 256) = 0;
  *(_QWORD *)(v3 + 280) = 0;
  *(_QWORD *)(v3 + 288) = 1;
  *(_DWORD *)(v3 + 296) = 0;
  *(_QWORD *)(v3 + 304) = 0;
  *(_OWORD *)(v3 + 312) = xmmword_1B66A0DC0;
  v4 = operator new(4uLL);
  *(_QWORD *)(a1 + 304) = v4;
  *v4 = 0;
  *(_OWORD *)(a1 + 320) = xmmword_1B66A0DC0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B65697AC(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;

  v3 = *(_QWORD **)(v1 + 248);
  if (v3 == (_QWORD *)(v1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(v1 + 224);
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  Trackable::~Trackable((void **)v1);
  _Unwind_Resume(a1);
}

float *dBToLinear<float,(LogTypes)0>::Compute_dBToLinear(float *a1, uint64_t a2)
{
  float *v3;

  v3 = (float *)AutoValue<float,(LogTypes)0>::Get(a2);
  *a1 = __exp10f(*v3 / 20.0);
  return a1;
}

uint64_t AutoValue<float,(LogTypes)0>::AutoValue<float const& ()(float &,AutoValue<float,(LogTypes)0>&),float>(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  _QWORD *v8;
  _DWORD *v9;
  __int128 v10;
  uint64_t (***v11)();
  uint64_t v12;
  uint64_t (**v14)();
  __int128 v15;
  uint64_t (***v16)();
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v7 = Trackable::Trackable<AutoValue<float,(LogTypes)0>>(a1, a2, a4);
  *(_QWORD *)v7 = &off_1E69EB300;
  v8 = (_QWORD *)(v7 + 224);
  *(_QWORD *)(v7 + 248) = 0;
  *(_QWORD *)(v7 + 256) = 0;
  *(_QWORD *)(v7 + 280) = 0;
  *(_QWORD *)(v7 + 288) = 1;
  *(_DWORD *)(v7 + 296) = 0;
  *(_QWORD *)(v7 + 304) = 0;
  *(_OWORD *)(v7 + 312) = xmmword_1B66A0DC0;
  v9 = operator new(4uLL);
  *(_QWORD *)(a1 + 304) = v9;
  *v9 = 0;
  *(_OWORD *)(a1 + 320) = xmmword_1B66A0DC0;
  *(_QWORD *)&v10 = a3;
  *((_QWORD *)&v10 + 1) = a4;
  v14 = &off_1E69EB500;
  v15 = v10;
  v16 = &v14;
  std::__function::__value_func<float const& ()(float &)>::swap[abi:ne180100](&v14, v8);
  v11 = v16;
  if (v16 == &v14)
  {
    v12 = 4;
    v11 = &v14;
    goto LABEL_5;
  }
  if (v16)
  {
    v12 = 5;
LABEL_5:
    (*v11)[v12]();
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B656995C(_Unwind_Exception *a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;

  if ((_QWORD *)*v3 == v2)
  {
    v5 = 4;
  }
  else
  {
    if (!*v3)
      goto LABEL_6;
    v5 = 5;
    v2 = (_QWORD *)*v3;
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v5))(v2);
LABEL_6:
  Trackable::~Trackable(v1);
  _Unwind_Resume(a1);
}

float *TCToCoef<float,(LogTypes)0>::Compute_CoefFromTC_curry(float *a1, uint64_t a2, unint64_t a3, double a4)
{
  float v5;
  float *v6;

  v5 = a4 / (double)a3;
  v6 = (float *)AutoValue<float,(LogTypes)0>::Get(a2);
  *a1 = expf(-1.0 / (float)(*v6 * v5));
  return a1;
}

uint64_t SpectralMagnitude<float,(LogTypes)0>::SpectralMagnitude(uint64_t a1, __int128 *a2, unint64_t a3, uint64_t a4)
{
  __int128 v7;
  _QWORD *v8;
  _BYTE *v9;
  __int128 v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  void *v15;
  int v17;
  void *v18[3];
  _BYTE v19[32];
  uint64_t v20;
  _QWORD v21[4];

  v21[3] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 72), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v7 = *a2;
    *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 72) = v7;
  }
  *(_BYTE *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  v8 = operator new(8uLL);
  *v8 = a4;
  *(_QWORD *)(a1 + 128) = v8;
  *(_QWORD *)(a1 + 136) = v8 + 1;
  *(_QWORD *)(a1 + 144) = v8 + 1;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E69EB4C0;
  *(_QWORD *)(a1 + 248) = 0;
  v9 = (_BYTE *)(a1 + 280);
  *(_QWORD *)(a1 + 256) = 0;
  memset(v19, 0, 24);
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer((_QWORD *)(a1 + 280), 1uLL, (uint64_t)v19);
  *(_QWORD *)&v10 = SpectralMagnitude<float,(LogTypes)0>::ComputeMagnitude;
  *((_QWORD *)&v10 + 1) = a4;
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)v19 = &off_1E69EB5D0;
  *(_OWORD *)&v19[8] = v10;
  *(_QWORD *)&v19[24] = v19;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](v19, (_QWORD *)(a1 + 224));
  v11 = *(_QWORD **)&v19[24];
  if (*(_BYTE **)&v19[24] == v19)
  {
    v12 = 4;
    v11 = v19;
  }
  else
  {
    if (!*(_QWORD *)&v19[24])
      goto LABEL_9;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_9:
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)a1 = &off_1E69EB5B0;
  v17 = 0;
  v13 = *(_QWORD *)(a1 + 344);
  std::vector<float>::vector(v18, a3, &v17);
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v19, v13 + 1, (uint64_t)v18);
  *(_OWORD *)v9 = *(_OWORD *)v19;
  v14 = (_QWORD *)(a1 + 296);
  v15 = *(void **)(a1 + 296);
  if (v15)
  {
    *(_QWORD *)(a1 + 304) = v15;
    operator delete(v15);
    *v14 = 0;
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 312) = 0;
  }
  *(_OWORD *)v14 = *(_OWORD *)&v19[16];
  *(_QWORD *)(a1 + 312) = v20;
  *(_QWORD *)&v19[24] = 0;
  v20 = 0;
  *(_QWORD *)&v19[16] = 0;
  if (v19 != v9)
    boost::container::vector<std::vector<float>,void,void>::priv_move_assign<void>(a1 + 320, v21);
  boost::container::vector<std::vector<float>,void,void>::~vector(v21);
  if (*(_QWORD *)&v19[16])
  {
    *(_QWORD *)&v19[24] = *(_QWORD *)&v19[16];
    operator delete(*(void **)&v19[16]);
  }
  if (v18[0])
  {
    v18[1] = v18[0];
    operator delete(v18[0]);
  }
  return a1;
}

void sub_1B6569C60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  uint64_t v12;
  void **v13;
  void *v15;

  v15 = *v13;
  if (*v13)
  {
    *(_QWORD *)(v12 + 40) = v15;
    operator delete(v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Filterbank::ToBark<float,(LogTypes)0>::ToBark(_QWORD *a1, __int128 *a2, std::vector<int>::size_type a3, uint64_t a4, float a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  char *v20;
  _QWORD *v21;
  uint64_t v22;
  std::vector<int>::size_type v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  void *v39;
  __int128 v40;
  uint64_t v41;
  std::vector<int>::size_type v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  _QWORD *v63;
  _QWORD *v64;
  void *v65;
  void *v66;
  _QWORD *v67;
  void *v68[2];
  uint64_t v69;
  __int128 v70;
  uint64_t v71;
  void *v72[2];
  uint64_t v73;
  __int128 v74;
  uint64_t v75;
  void *v76[2];
  uint64_t v77;
  __int128 v78;
  uint64_t v79;
  void *v80[2];
  uint64_t v81;
  void *v82;
  __int128 v83;
  uint64_t v84;
  __int128 v85;
  uint64_t v86;
  __int128 v87;
  uint64_t v88;
  __int128 v89;
  uint64_t v90;
  __int128 v91;
  uint64_t v92;
  __int128 v93;
  uint64_t v94;
  __int128 v95;
  uint64_t v96;
  void *v97[3];
  void *v98[3];
  void *v99[3];
  void *v100[3];
  void *v101[3];
  void *v102[3];
  void *v103[3];
  void *v104;
  __int128 v105;
  uint64_t (*v106)(_QWORD *, uint64_t, uint64_t);
  __int128 v107;
  void *v108;
  __int128 v109;
  void *v110;
  __int128 v111;
  void *v112;
  __int128 v113;
  void *v114;
  __int128 v115;
  void *v116;
  __int128 v117;
  void *v118;
  __int128 __p;
  void *v120;
  __int128 v121;
  _QWORD v122[3];
  _QWORD *v123;
  uint64_t v124;

  v124 = *MEMORY[0x1E0C80C00];
  *a1 = &off_1E69EB618;
  Filterbank::BarkCore<float>::BarkCore((uint64_t *)v68, a3, 0x18uLL, a5);
  v60 = v68[0];
  v83 = *(_OWORD *)v68;
  v82 = Filterbank::ToBark<float,(LogTypes)0>::ComputeBark_curry;
  v84 = v69;
  v68[0] = 0;
  v68[1] = 0;
  v57 = (void *)v70;
  v85 = v70;
  v10 = v71;
  v69 = 0;
  v70 = 0uLL;
  v71 = 0;
  v54 = v72[0];
  v87 = *(_OWORD *)v72;
  v86 = v10;
  v88 = v73;
  v72[0] = 0;
  v72[1] = 0;
  v51 = (void *)v74;
  v89 = v74;
  v11 = v75;
  v73 = 0;
  v74 = 0uLL;
  v75 = 0;
  v48 = v76[0];
  v91 = *(_OWORD *)v76;
  v90 = v11;
  v92 = v77;
  v76[0] = 0;
  v76[1] = 0;
  v45 = (void *)v78;
  v93 = v78;
  v12 = v79;
  v77 = 0;
  v78 = 0uLL;
  v79 = 0;
  v44 = v80[0];
  v95 = *(_OWORD *)v80;
  v94 = v12;
  v96 = v81;
  v80[0] = 0;
  v80[1] = 0;
  v81 = 0;
  Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<std::vector<float>,(LogTypes)0>>((uint64_t)a1, a2, (uint64_t)(a1 + 44), (uint64_t)(a1 + 88));
  *a1 = &off_1E69EB4C0;
  a1[31] = 0;
  v64 = a1 + 28;
  a1[32] = 0;
  v107 = 0uLL;
  v106 = 0;
  v67 = a1;
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(a1 + 35, 1uLL, (uint64_t)&v106);
  v41 = a4;
  v42 = a3;
  a1[43] = 0;
  v97[0] = Filterbank::ToBark<float,(LogTypes)0>::ComputeBark_curry;
  Filterbank::BarkCore<float>::BarkCore(&v97[1], (uint64_t)&v83);
  v63 = a1 + 44;
  *(_QWORD *)&v105 = a1 + 44;
  v43 = a1 + 88;
  *((_QWORD *)&v105 + 1) = a1 + 88;
  v40 = *(_OWORD *)&v97[1];
  v107 = *(_OWORD *)&v97[1];
  v13 = v97[0];
  v106 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t))v97[0];
  v39 = v98[0];
  v108 = v98[0];
  v97[2] = 0;
  memset(v98, 0, sizeof(v98));
  v97[1] = 0;
  v38 = *(_OWORD *)&v98[1];
  v109 = *(_OWORD *)&v98[1];
  v37 = *(_OWORD *)&v99[1];
  v111 = *(_OWORD *)&v99[1];
  v14 = v99[0];
  v15 = v100[0];
  v110 = v99[0];
  v112 = v100[0];
  memset(v99, 0, sizeof(v99));
  memset(v100, 0, sizeof(v100));
  v36 = *(_OWORD *)&v100[1];
  v113 = *(_OWORD *)&v100[1];
  v35 = *(_OWORD *)&v101[1];
  v115 = *(_OWORD *)&v101[1];
  v16 = v101[0];
  v17 = v102[0];
  v114 = v101[0];
  v116 = v102[0];
  memset(v101, 0, sizeof(v101));
  memset(v102, 0, sizeof(v102));
  v34 = *(_OWORD *)&v102[1];
  v117 = *(_OWORD *)&v102[1];
  v33 = *(_OWORD *)&v103[1];
  __p = *(_OWORD *)&v103[1];
  v18 = v103[0];
  v19 = v104;
  v118 = v103[0];
  v120 = v104;
  memset(v103, 0, sizeof(v103));
  v104 = 0;
  v121 = v105;
  v20 = (char *)operator new(0xC8uLL);
  *(_QWORD *)v20 = &off_1E69EB638;
  *((_QWORD *)v20 + 1) = v13;
  *((_OWORD *)v20 + 1) = v40;
  *((_QWORD *)v20 + 4) = v39;
  v108 = 0;
  v107 = 0uLL;
  *(_OWORD *)(v20 + 40) = v38;
  *((_QWORD *)v20 + 7) = v14;
  v110 = 0;
  v109 = 0uLL;
  *((_OWORD *)v20 + 4) = v37;
  *((_QWORD *)v20 + 10) = v15;
  v112 = 0;
  v111 = 0uLL;
  *(_OWORD *)(v20 + 88) = v36;
  *((_QWORD *)v20 + 13) = v16;
  v113 = 0uLL;
  v114 = 0;
  *((_OWORD *)v20 + 7) = v35;
  *((_QWORD *)v20 + 16) = v17;
  v116 = 0;
  v115 = 0uLL;
  *(_OWORD *)(v20 + 136) = v34;
  *((_QWORD *)v20 + 19) = v18;
  v118 = 0;
  v117 = 0uLL;
  *((_OWORD *)v20 + 10) = v33;
  *((_QWORD *)v20 + 22) = v19;
  __p = 0uLL;
  v120 = 0;
  *(_OWORD *)(v20 + 184) = v105;
  v123 = v20;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](v122, v64);
  v21 = v123;
  if (v123 == v122)
  {
    v27 = 4;
    v21 = v122;
    v22 = (uint64_t)v67;
    v23 = v42;
    v24 = (uint64_t)v43;
    v25 = (uint64_t)v63;
    v26 = v41;
  }
  else
  {
    v22 = (uint64_t)v67;
    v23 = v42;
    v24 = (uint64_t)v43;
    v25 = (uint64_t)v63;
    v26 = v41;
    if (!v123)
      goto LABEL_6;
    v27 = 5;
  }
  (*(void (**)(void))(*v21 + 8 * v27))();
LABEL_6:
  if ((_QWORD)__p)
  {
    *((_QWORD *)&__p + 1) = __p;
    operator delete((void *)__p);
  }
  if ((_QWORD)v117)
  {
    *((_QWORD *)&v117 + 1) = v117;
    operator delete((void *)v117);
  }
  if ((_QWORD)v115)
    operator delete((void *)v115);
  if ((_QWORD)v113)
    operator delete((void *)v113);
  if ((_QWORD)v111)
    operator delete((void *)v111);
  if ((_QWORD)v109)
    operator delete((void *)v109);
  if ((_QWORD)v107)
    operator delete((void *)v107);
  if (v103[1])
  {
    v103[2] = v103[1];
    operator delete(v103[1]);
  }
  if (v102[1])
  {
    v102[2] = v102[1];
    operator delete(v102[1]);
  }
  if (v101[1])
  {
    v101[2] = v101[1];
    operator delete(v101[1]);
  }
  if (v100[1])
  {
    v100[2] = v100[1];
    operator delete(v100[1]);
  }
  if (v99[1])
  {
    v99[2] = v99[1];
    operator delete(v99[1]);
  }
  if (v98[1])
  {
    v98[2] = v98[1];
    operator delete(v98[1]);
  }
  if (v97[1])
  {
    v97[2] = v97[1];
    operator delete(v97[1]);
  }
  *(_DWORD *)(v22 + 8) = 0;
  *(_QWORD *)(v22 + 16) = 0;
  *(_QWORD *)(v22 + 264) = 0;
  *(_QWORD *)(v22 + 272) = 0;
  if (v44)
  {
    *((_QWORD *)&v95 + 1) = v44;
    operator delete(v44);
  }
  if (v45)
  {
    *((_QWORD *)&v93 + 1) = v45;
    operator delete(v45);
  }
  if (v48)
  {
    *((_QWORD *)&v91 + 1) = v48;
    operator delete(v48);
  }
  if (v51)
  {
    *((_QWORD *)&v89 + 1) = v51;
    operator delete(v51);
  }
  if (v54)
  {
    *((_QWORD *)&v87 + 1) = v54;
    operator delete(v54);
  }
  if (v57)
  {
    *((_QWORD *)&v85 + 1) = v57;
    operator delete(v57);
  }
  if (v60)
  {
    *((_QWORD *)&v83 + 1) = v60;
    operator delete(v60);
  }
  if (v80[0])
  {
    v80[1] = v80[0];
    operator delete(v80[0]);
  }
  if ((_QWORD)v78)
  {
    *((_QWORD *)&v78 + 1) = v78;
    operator delete((void *)v78);
  }
  if (v76[0])
  {
    v76[1] = v76[0];
    operator delete(v76[0]);
  }
  if ((_QWORD)v74)
  {
    *((_QWORD *)&v74 + 1) = v74;
    operator delete((void *)v74);
  }
  if (v72[0])
  {
    v72[1] = v72[0];
    operator delete(v72[0]);
  }
  if ((_QWORD)v70)
  {
    *((_QWORD *)&v70 + 1) = v70;
    operator delete((void *)v70);
  }
  if (v68[0])
  {
    v68[1] = v68[0];
    operator delete(v68[0]);
  }
  *(_QWORD *)v22 = &off_1E69EB618;
  std::string::basic_string[abi:ne180100]<0>(&v82, "filterLeftTimesPS");
  Filterbank::BarkCore<float>::BarkCore((uint64_t *)v97, v23, 0x18uLL, a5);
  v65 = v97[0];
  v107 = *(_OWORD *)v97;
  v28 = v98[2];
  v106 = Filterbank::ToBark<float,(LogTypes)0>::ComputeFilterLeftTimesPS_curry;
  v108 = v97[2];
  memset(v97, 0, sizeof(v97));
  v61 = v98[0];
  v109 = *(_OWORD *)v98;
  memset(v98, 0, sizeof(v98));
  v58 = v99[0];
  v111 = *(_OWORD *)v99;
  v29 = v100[2];
  v110 = v28;
  v112 = v99[2];
  memset(v99, 0, sizeof(v99));
  v55 = v100[0];
  v113 = *(_OWORD *)v100;
  memset(v100, 0, sizeof(v100));
  v52 = v101[0];
  v115 = *(_OWORD *)v101;
  v30 = v102[2];
  v114 = v29;
  v116 = v101[2];
  memset(v101, 0, sizeof(v101));
  v49 = v102[0];
  v117 = *(_OWORD *)v102;
  memset(v102, 0, sizeof(v102));
  v46 = v103[0];
  __p = *(_OWORD *)v103;
  v118 = v30;
  v120 = v103[2];
  memset(v103, 0, sizeof(v103));
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>>,std::vector<float>>(v25, (__int128 *)&v82, (uint64_t *)&v106, v26);
  if (v46)
  {
    *((_QWORD *)&__p + 1) = v46;
    operator delete(v46);
  }
  if (v49)
  {
    *((_QWORD *)&v117 + 1) = v49;
    operator delete(v49);
  }
  if (v52)
  {
    *((_QWORD *)&v115 + 1) = v52;
    operator delete(v52);
  }
  if (v55)
  {
    *((_QWORD *)&v113 + 1) = v55;
    operator delete(v55);
  }
  if (v58)
  {
    *((_QWORD *)&v111 + 1) = v58;
    operator delete(v58);
  }
  if (v61)
  {
    *((_QWORD *)&v109 + 1) = v61;
    operator delete(v61);
  }
  if (v65)
  {
    *((_QWORD *)&v107 + 1) = v65;
    operator delete(v65);
  }
  if (v103[0])
  {
    v103[1] = v103[0];
    operator delete(v103[0]);
  }
  if (v102[0])
  {
    v102[1] = v102[0];
    operator delete(v102[0]);
  }
  if (v101[0])
  {
    v101[1] = v101[0];
    operator delete(v101[0]);
  }
  if (v100[0])
  {
    v100[1] = v100[0];
    operator delete(v100[0]);
  }
  if (v99[0])
  {
    v99[1] = v99[0];
    operator delete(v99[0]);
  }
  if (v98[0])
  {
    v98[1] = v98[0];
    operator delete(v98[0]);
  }
  if (v97[0])
  {
    v97[1] = v97[0];
    operator delete(v97[0]);
  }
  if (SHIBYTE(v83) < 0)
    operator delete(v82);
  std::string::basic_string[abi:ne180100]<0>(&v82, "filterRightTimesPS");
  Filterbank::BarkCore<float>::BarkCore((uint64_t *)v97, v23, 0x18uLL, a5);
  v106 = Filterbank::ToBark<float,(LogTypes)0>::ComputeFilterRightTimesPS_curry;
  v108 = v97[2];
  v110 = v98[2];
  v112 = v99[2];
  v31 = v102[2];
  v114 = v100[2];
  v116 = v101[2];
  v66 = v97[0];
  v107 = *(_OWORD *)v97;
  memset(v97, 0, sizeof(v97));
  v62 = v98[0];
  v109 = *(_OWORD *)v98;
  memset(v98, 0, sizeof(v98));
  v59 = v99[0];
  v111 = *(_OWORD *)v99;
  memset(v99, 0, sizeof(v99));
  v56 = v100[0];
  v113 = *(_OWORD *)v100;
  memset(v100, 0, sizeof(v100));
  v53 = v101[0];
  v115 = *(_OWORD *)v101;
  memset(v101, 0, sizeof(v101));
  v50 = v102[0];
  v117 = *(_OWORD *)v102;
  memset(v102, 0, sizeof(v102));
  v47 = v103[0];
  __p = *(_OWORD *)v103;
  v118 = v31;
  v120 = v103[2];
  memset(v103, 0, sizeof(v103));
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>>,std::vector<float>>(v24, (__int128 *)&v82, (uint64_t *)&v106, v26);
  if (v47)
  {
    *((_QWORD *)&__p + 1) = v47;
    operator delete(v47);
  }
  if (v50)
  {
    *((_QWORD *)&v117 + 1) = v50;
    operator delete(v50);
  }
  if (v53)
  {
    *((_QWORD *)&v115 + 1) = v53;
    operator delete(v53);
  }
  if (v56)
  {
    *((_QWORD *)&v113 + 1) = v56;
    operator delete(v56);
  }
  if (v59)
  {
    *((_QWORD *)&v111 + 1) = v59;
    operator delete(v59);
  }
  if (v62)
  {
    *((_QWORD *)&v109 + 1) = v62;
    operator delete(v62);
  }
  if (v66)
  {
    *((_QWORD *)&v107 + 1) = v66;
    operator delete(v66);
  }
  if (v103[0])
  {
    v103[1] = v103[0];
    operator delete(v103[0]);
  }
  if (v102[0])
  {
    v102[1] = v102[0];
    operator delete(v102[0]);
  }
  if (v101[0])
  {
    v101[1] = v101[0];
    operator delete(v101[0]);
  }
  if (v100[0])
  {
    v100[1] = v100[0];
    operator delete(v100[0]);
  }
  if (v99[0])
  {
    v99[1] = v99[0];
    operator delete(v99[0]);
  }
  if (v98[0])
  {
    v98[1] = v98[0];
    operator delete(v98[0]);
  }
  if (v97[0])
  {
    v97[1] = v97[0];
    operator delete(v97[0]);
  }
  if (SHIBYTE(v83) < 0)
    operator delete(v82);
  LODWORD(v106) = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>(v22, 0x18uLL, &v106);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v25, v23);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v24, v23);
  return v22;
}

void sub_1B656A820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,Trackable *a52)
{
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a32);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a48);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue((uint64_t)a52);
  _Unwind_Resume(a1);
}

uint64_t Dereverb::Dereverb<float,(Dereverb::FirstPassTypes)0,(LogTypes)0>::ComputeInpPsPrev(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  float v14;
  float __D;
  float __B;

  v9 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 1uLL);
  v10 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 1uLL);
  v11 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a4, 1uLL);
  v12 = (float *)AutoValue<float,(LogTypes)0>::Get(a5);
  v13 = SquareVector<float>(a1, *(const float **)v11, *(_QWORD *)(v11 + 8));
  MultiplyVectorVector<float>(v13, *(const float **)a1, *(_QWORD *)(a1 + 8), *(const float **)v9, *(_QWORD *)(v9 + 8));
  v14 = *v12;
  __D = 1.0 - *v12;
  __B = v14;
  if ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2 != (uint64_t)(*(_QWORD *)(v10 + 8) - *(_QWORD *)v10) >> 2)
    __assert_rtn("AddMultiplyVectorScalarMultiplyVectorScalar", "VectorUtils.h", 896, "result.size() == A.size()");
  vDSP_vsmsma(*(const float **)v10, 1, &__B, *(const float **)a1, 1, &__D, *(float **)a1, 1, (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  return a1;
}

uint64_t AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue&<float,(LogTypes)0>),std::vector<float>,std::vector<float>,std::vector<float>,float>(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  std::string *v11;
  __int128 v12;
  void **v13;
  _QWORD *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD v37[3];
  _QWORD *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  v11 = (std::string *)(a1 + 72);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v12 = *a2;
    v11->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
  }
  *(_OWORD *)(a1 + 104) = 0u;
  *(_BYTE *)(a1 + 96) = 0;
  v13 = (void **)(a1 + 128);
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  v14 = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(1uLL);
  v16 = (char *)&v14[v15];
  *v14 = a3;
  v17 = (char *)(v14 + 1);
  v19 = *(char **)(a1 + 128);
  v18 = *(char **)(a1 + 136);
  v20 = v14;
  if (v18 != v19)
  {
    do
    {
      v21 = *((_QWORD *)v18 - 1);
      v18 -= 8;
      *--v20 = v21;
    }
    while (v18 != v19);
    v18 = (char *)*v13;
  }
  *(_QWORD *)(a1 + 128) = v20;
  *(_QWORD *)(a1 + 136) = v17;
  *(_QWORD *)(a1 + 144) = v16;
  if (v18)
  {
    operator delete(v18);
    v16 = *(char **)(a1 + 144);
  }
  *(_QWORD *)(a1 + 136) = v17;
  if (v17 >= v16)
  {
    v23 = (v17 - (_BYTE *)*v13) >> 3;
    if ((unint64_t)(v23 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v24 = v16 - (_BYTE *)*v13;
    v25 = v24 >> 2;
    if (v24 >> 2 <= (unint64_t)(v23 + 1))
      v25 = v23 + 1;
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
      v26 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v26 = v25;
    if (v26)
      v26 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v26);
    else
      v27 = 0;
    v28 = (_QWORD *)(v26 + 8 * v23);
    v29 = v26 + 8 * v27;
    *v28 = a4;
    v22 = v28 + 1;
    v31 = *(char **)(a1 + 128);
    v30 = *(char **)(a1 + 136);
    if (v30 != v31)
    {
      do
      {
        v32 = *((_QWORD *)v30 - 1);
        v30 -= 8;
        *--v28 = v32;
      }
      while (v30 != v31);
      v30 = (char *)*v13;
    }
    *(_QWORD *)(a1 + 128) = v28;
    *(_QWORD *)(a1 + 136) = v22;
    *(_QWORD *)(a1 + 144) = v29;
    if (v30)
      operator delete(v30);
  }
  else
  {
    v14[1] = a4;
    v22 = v14 + 2;
  }
  *(_QWORD *)(a1 + 136) = v22;
  Trackable::BuildDepsList<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<float,(LogTypes)0>>((void **)(a1 + 128), a5, a6);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E69EB4C0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  memset(v37, 0, sizeof(v37));
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer((_QWORD *)(a1 + 280), 1uLL, (uint64_t)v37);
  *(_QWORD *)(a1 + 344) = 0;
  v33 = operator new(0x30uLL);
  *v33 = &off_1E69EB6C8;
  v33[1] = Dereverb::Dereverb<float,(Dereverb::FirstPassTypes)0,(LogTypes)0>::ComputeInpPsPrev;
  v33[2] = a3;
  v33[3] = a4;
  v33[4] = a5;
  v33[5] = a6;
  v38 = v33;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](v37, (_QWORD *)(a1 + 224));
  v34 = v38;
  if (v38 == v37)
  {
    v35 = 4;
    v34 = v37;
    goto LABEL_29;
  }
  if (v38)
  {
    v35 = 5;
LABEL_29:
    (*(void (**)(_QWORD *))(*v34 + 8 * v35))(v34);
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B656AD04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  void **v10;
  void *v12;

  v12 = *v10;
  if (*v10)
  {
    *(_QWORD *)(v9 + 40) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ReverbEstimator<float,true,(LogTypes)0>::ReverbEstimator(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  size_t v12;
  __int128 *p_p;
  const void *v14;
  size_t v15;
  void **v16;
  const void *v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  char *v22;
  char *v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  Trackable **v33;
  unint64_t v34;
  char *v35;
  char *v36;
  Trackable *v37;
  _QWORD *v38;
  __int128 *v39;
  uint64_t v40;
  size_t v41;
  __int128 *v42;
  void **v43;
  _QWORD *v44;
  size_t v45;
  __int128 *v46;
  void **v47;
  _QWORD *v48;
  uint64_t v49;
  _QWORD *v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t (****v57)(Trackable *);
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  unint64_t v64;
  char *v65;
  char *v66;
  uint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t (****v73)(Trackable *);
  unint64_t v74;
  char *v75;
  char *v76;
  uint64_t (***v77)(Trackable *);
  _QWORD *v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  _QWORD *v83;
  unint64_t v84;
  char *v85;
  char *v86;
  uint64_t v87;
  __int128 *v88;
  __int128 *v89;
  __int128 *v90;
  uint64_t v91;
  size_t size;
  std::string *v93;
  size_t v94;
  __int128 *v95;
  std::string *v96;
  size_t v97;
  __int128 *v98;
  std::string *v99;
  size_t v100;
  __int128 *v101;
  std::string *v102;
  size_t v103;
  __int128 *v104;
  std::string *v105;
  size_t v106;
  std::string *v107;
  std::string *v108;
  _QWORD *v109;
  _QWORD *v110;
  __int128 *v111;
  __int128 *v112;
  uint64_t v113;
  size_t v114;
  std::string *v115;
  size_t v116;
  __int128 *v117;
  std::string *v118;
  size_t v119;
  std::string *v120;
  std::string *v121;
  uint64_t v122;
  _QWORD *v123;
  _QWORD *v124;
  _QWORD *v125;
  char *v126;
  char *v127;
  _QWORD *v128;
  uint64_t v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t v134;
  uint64_t v135;
  _QWORD *v136;
  unint64_t v137;
  char *v138;
  char *v139;
  uint64_t v140;
  _QWORD *v141;
  __int128 *v142;
  uint64_t v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t *v146;
  uint64_t v147;
  unint64_t v148;
  _QWORD *v149;
  std::string::size_type v150;
  unint64_t v151;
  uint64_t v152;
  void **v153;
  unint64_t *v154;
  uint64_t *v155;
  __int128 v156;
  unint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  uint64_t **v169;
  uint64_t *v170;
  uint64_t *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  float *v176;
  float v177;
  _BOOL4 v178;
  BOOL v179;
  unint64_t v180;
  uint64_t v181;
  size_t v182;
  __int128 *v183;
  const void *v184;
  uint64_t v185;
  void *v186;
  _QWORD *v189;
  uint64_t v190;
  uint64_t v191;
  Trackable *v193;
  _QWORD *v194;
  Trackable *v195;
  void *v196[2];
  uint64_t v197;
  uint64_t *v198;
  uint64_t *v199;
  void *v200;
  void *v201;
  uint64_t v202;
  std::string v203;
  unint64_t v204;
  uint64_t v205;
  std::string v206;
  std::string *v207;
  char v208;
  __int128 __p;
  __int128 v210;
  uint64_t v211;
  _QWORD v212[4];
  std::string v213;
  char v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  uint64_t v222;
  _QWORD v223[3];
  __int128 *v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  __int128 v229;
  uint64_t v230;
  void *v231;
  __int128 v232;
  uint64_t v233;
  _BYTE v234[336];
  _BYTE v235[336];
  _BYTE v236[336];
  uint64_t (**v237)(Trackable *);
  int v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  __int128 v245;
  int v246;
  _DWORD *v247;
  _BYTE v248[24];
  _BYTE v249[336];
  void (**v250)(Trackable *__hidden);
  int v251;
  uint64_t v252;
  char v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  std::string v259;
  char v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  uint64_t v268;
  _QWORD v269[10];
  _QWORD *v270;
  _BYTE v271[24];
  _BYTE v272[336];
  _QWORD v273[44];
  uint64_t (**v274)();
  int v275;
  uint64_t v276;
  char v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  std::string v283;
  char v284;
  __int128 v285;
  __int128 v286;
  __int128 v287;
  __int128 v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  uint64_t v292;
  _QWORD v293[7];
  _QWORD v294[9];
  __int128 v295;
  __int128 v296;
  uint64_t v297;
  void *v298;
  __int128 v299;
  uint64_t v300;

  v300 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = &off_1E69EB730;
  v190 = a1 + 688;
  v191 = a1 + 352;
  *(_QWORD *)AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue&<float,(LogTypes)0>),std::vector<float>,float>(a1, (__int128 *)a2, (uint64_t)ReverbEstimator<float,true,(LogTypes)0>::ApplyGainScalar, a1 + 688, a1 + 352) = &off_1E69EB730;
  if (*(char *)(a2 + 23) >= 0)
    v12 = *(unsigned __int8 *)(a2 + 23);
  else
    v12 = *(_QWORD *)(a2 + 8);
  p_p = &__p;
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v12 + 15);
  if (SBYTE7(v210) < 0)
    p_p = (__int128 *)__p;
  if (v12)
  {
    if (*(char *)(a2 + 23) >= 0)
      v14 = (const void *)a2;
    else
      v14 = *(const void **)a2;
    memmove(p_p, v14, v12);
  }
  strcpy((char *)p_p + v12, "_reverbTailGain");
  *(_QWORD *)AutoValue<float,(LogTypes)0>::AutoValue<float const& ()(float &,AutoValue<float,(LogTypes)0>&),float>(v191, &__p, (uint64_t)dBToLinear<float,(LogTypes)0>::Compute_dBToLinear, a7) = &off_1E69EB4E0;
  if (SBYTE7(v210) < 0)
    operator delete((void *)__p);
  if (*(char *)(a2 + 23) >= 0)
    v15 = *(unsigned __int8 *)(a2 + 23);
  else
    v15 = *(_QWORD *)(a2 + 8);
  v16 = v196;
  std::string::basic_string[abi:ne180100]((uint64_t)v196, v15 + 10);
  if (v197 < 0)
    v16 = (void **)v196[0];
  if (v15)
  {
    if (*(char *)(a2 + 23) >= 0)
      v17 = (const void *)a2;
    else
      v17 = *(const void **)a2;
    memmove(v16, v17, v15);
  }
  strcpy((char *)v16 + v15, "_convolver");
  *(_QWORD *)(a1 + 688) = &off_1E69EB2E0;
  *(_BYTE *)(a1 + 712) = 0;
  *(_QWORD *)(a1 + 728) = 0;
  *(_QWORD *)(a1 + 736) = 0;
  *(_QWORD *)(a1 + 720) = 0;
  *(_QWORD *)(a1 + 752) = 0;
  if (SHIBYTE(v197) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 760), (const std::string::value_type *)v196[0], (std::string::size_type)v196[1]);
  }
  else
  {
    *(_OWORD *)(a1 + 760) = *(_OWORD *)v196;
    *(_QWORD *)(a1 + 776) = v197;
  }
  *(_BYTE *)(a1 + 784) = 0;
  *(_OWORD *)(a1 + 792) = 0u;
  *(_QWORD *)(a1 + 904) = 0;
  *(_OWORD *)(a1 + 808) = 0u;
  *(_OWORD *)(a1 + 824) = 0u;
  *(_OWORD *)(a1 + 840) = 0u;
  *(_OWORD *)(a1 + 856) = 0u;
  *(_OWORD *)(a1 + 872) = 0u;
  *(_OWORD *)(a1 + 888) = 0u;
  v18 = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(1uLL);
  v20 = &v18[v19];
  v193 = (Trackable *)(a1 + 1040);
  *v18 = a1 + 1040;
  v21 = v18 + 1;
  v22 = *(char **)(a1 + 824);
  v23 = *(char **)(a1 + 816);
  v24 = v18;
  if (v22 != v23)
  {
    do
    {
      v25 = *((_QWORD *)v22 - 1);
      v22 -= 8;
      *--v24 = v25;
    }
    while (v22 != v23);
    v22 = *(char **)(a1 + 816);
  }
  v195 = (Trackable *)(a1 + 1392);
  *(_QWORD *)(a1 + 816) = v24;
  *(_QWORD *)(a1 + 824) = v21;
  *(_QWORD *)(a1 + 832) = v20;
  if (v22)
  {
    operator delete(v22);
    v20 = *(_QWORD **)(a1 + 832);
  }
  *(_QWORD *)(a1 + 824) = v21;
  if (v21 >= v20)
  {
    v27 = *(_QWORD *)(a1 + 816);
    v28 = ((uint64_t)v21 - v27) >> 3;
    if ((unint64_t)(v28 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v29 = (uint64_t)v20 - v27;
    v30 = v29 >> 2;
    if (v29 >> 2 <= (unint64_t)(v28 + 1))
      v30 = v28 + 1;
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8)
      v31 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v31 = v30;
    if (v31)
      v31 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v31);
    else
      v32 = 0;
    v33 = (Trackable **)(v31 + 8 * v28);
    v34 = v31 + 8 * v32;
    *v33 = v195;
    v26 = v33 + 1;
    v35 = *(char **)(a1 + 824);
    v36 = *(char **)(a1 + 816);
    if (v35 != v36)
    {
      do
      {
        v37 = (Trackable *)*((_QWORD *)v35 - 1);
        v35 -= 8;
        *--v33 = v37;
      }
      while (v35 != v36);
      v35 = *(char **)(a1 + 816);
    }
    *(_QWORD *)(a1 + 816) = v33;
    *(_QWORD *)(a1 + 824) = v26;
    *(_QWORD *)(a1 + 832) = v34;
    if (v35)
      operator delete(v35);
  }
  else
  {
    v18[1] = v195;
    v26 = v18 + 2;
  }
  *(_QWORD *)(a1 + 824) = v26;
  *(_QWORD *)(a1 + 744) = 0;
  *(_DWORD *)(a1 + 696) = 0;
  *(_QWORD *)(a1 + 688) = &off_1E69EB4C0;
  *(_QWORD *)(a1 + 944) = 0;
  *(_QWORD *)(a1 + 936) = 0;
  __p = 0uLL;
  *(_QWORD *)&v210 = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer((_QWORD *)(a1 + 968), 1uLL, (uint64_t)&__p);
  *(_QWORD *)(a1 + 1032) = 0;
  v38 = operator new(0x28uLL);
  *v38 = &off_1E69EB7B8;
  v38[1] = Convolver<float,true,(LogTypes)0>::Convolve;
  v38[2] = a1 + 1744;
  v38[3] = v193;
  v38[4] = v195;
  *((_QWORD *)&v210 + 1) = v38;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](&__p, (_QWORD *)(a1 + 912));
  v39 = (__int128 *)*((_QWORD *)&v210 + 1);
  if (*((__int128 **)&v210 + 1) == &__p)
  {
    v40 = 4;
    v39 = &__p;
  }
  else
  {
    if (!*((_QWORD *)&v210 + 1))
      goto LABEL_52;
    v40 = 5;
  }
  (*(void (**)(__int128 *))(*(_QWORD *)v39 + 8 * v40))(v39);
LABEL_52:
  *(_DWORD *)(a1 + 696) = 0;
  *(_QWORD *)(a1 + 704) = 0;
  *(_QWORD *)(a1 + 960) = 0;
  *(_QWORD *)(a1 + 952) = 0;
  *(_QWORD *)(a1 + 688) = &off_1E69EB798;
  if (v197 >= 0)
    v41 = HIBYTE(v197);
  else
    v41 = (size_t)v196[1];
  v42 = &v295;
  std::string::basic_string[abi:ne180100]((uint64_t)&v295, v41 + 2);
  if (SBYTE7(v296) < 0)
    v42 = (__int128 *)v295;
  if (v41)
  {
    if (v197 >= 0)
      v43 = v196;
    else
      v43 = (void **)v196[0];
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "_H");
  Trackable::Trackable<>((uint64_t)v193, &v295);
  *(_QWORD *)(a1 + 1040) = off_1E69EB800;
  *(_QWORD *)(a1 + 1296) = 0;
  *(_QWORD *)(a1 + 1288) = 0;
  __p = 0uLL;
  *(_QWORD *)&v210 = 0;
  *(_OWORD *)(a1 + 1320) = xmmword_1B6626830;
  *(_QWORD *)(a1 + 1336) = 0;
  *(_QWORD *)(a1 + 1352) = 0;
  *(_QWORD *)(a1 + 1344) = 0;
  std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((_QWORD *)(a1 + 1336), 0, 0, 0);
  *(_QWORD *)(a1 + 1360) = 0;
  *(_OWORD *)(a1 + 1368) = xmmword_1B66A0DC0;
  v44 = operator new(0x18uLL);
  *(_QWORD *)(a1 + 1360) = v44;
  *(_QWORD *)(a1 + 1376) = 1;
  v44[1] = 0;
  v44[2] = 0;
  *v44 = 0;
  std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v44, __p, *((uint64_t *)&__p + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)&__p + 1) - __p) >> 3));
  v206.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v206);
  *(_QWORD *)(a1 + 1384) = 0;
  *(_QWORD *)(a1 + 1056) = 0;
  *(_QWORD *)(a1 + 1312) = 0;
  *(_QWORD *)(a1 + 1304) = 0;
  if (SBYTE7(v296) < 0)
    operator delete((void *)v295);
  if (v197 >= 0)
    v45 = HIBYTE(v197);
  else
    v45 = (size_t)v196[1];
  v46 = &__p;
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v45 + 2);
  if (SBYTE7(v210) < 0)
    v46 = (__int128 *)__p;
  if (v45)
  {
    if (v197 >= 0)
      v47 = v196;
    else
      v47 = (void **)v196[0];
    memmove(v46, v47, v45);
  }
  strcpy((char *)v46 + v45, "_X");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue(v195, &__p);
  if (SBYTE7(v210) < 0)
    operator delete((void *)__p);
  std::string::basic_string[abi:ne180100]<0>(&v203, "tempTransformer");
  v200 = 0;
  v201 = 0;
  v202 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v200, *(const void **)a5, *(_QWORD *)(a5 + 8), (uint64_t)(*(_QWORD *)(a5 + 8) - *(_QWORD *)a5) >> 2);
  v204 = a4;
  v205 = a3;
  *(_QWORD *)&__p = &off_1E69EB2E0;
  BYTE8(v210) = 0;
  v211 = 0;
  v212[0] = 0;
  v212[1] = 0;
  v212[3] = 0;
  if (SHIBYTE(v203.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v213, v203.__r_.__value_.__l.__data_, v203.__r_.__value_.__l.__size_);
  else
    v213 = v203;
  v214 = 0;
  v215 = 0u;
  v216 = 0u;
  v217 = 0u;
  v218 = 0u;
  v219 = 0u;
  v220 = 0u;
  v221 = 0u;
  v222 = 0;
  v48 = operator new(8uLL);
  *v48 = &v274;
  *((_QWORD *)&v216 + 1) = v48;
  *(_QWORD *)&v217 = v48 + 1;
  *((_QWORD *)&v217 + 1) = v48 + 1;
  v50 = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(2uLL);
  v50[1] = v234;
  v51 = (char *)(v50 + 1);
  v52 = (char *)&v50[v49];
  v53 = (char *)(v50 + 2);
  v55 = (char *)*((_QWORD *)&v216 + 1);
  v54 = (char *)v217;
  if ((_QWORD)v217 != *((_QWORD *)&v216 + 1))
  {
    do
    {
      v56 = *((_QWORD *)v54 - 1);
      v54 -= 8;
      *((_QWORD *)v51 - 1) = v56;
      v51 -= 8;
    }
    while (v54 != v55);
    v54 = (char *)*((_QWORD *)&v216 + 1);
  }
  *((_QWORD *)&v216 + 1) = v51;
  *(_QWORD *)&v217 = v50 + 2;
  *((_QWORD *)&v217 + 1) = &v50[v49];
  if (v54)
  {
    operator delete(v54);
    v52 = (char *)*((_QWORD *)&v217 + 1);
  }
  *(_QWORD *)&v217 = v50 + 2;
  if (v53 >= v52)
  {
    v58 = (uint64_t)&v53[-*((_QWORD *)&v216 + 1)] >> 3;
    if ((unint64_t)(v58 + 1) >> 61)
      goto LABEL_368;
    v59 = (uint64_t)&v52[-*((_QWORD *)&v216 + 1)];
    v60 = v59 >> 2;
    if (v59 >> 2 <= (unint64_t)(v58 + 1))
      v60 = v58 + 1;
    if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8)
      v61 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v61 = v60;
    if (v61)
      v61 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v61);
    else
      v62 = 0;
    v63 = (_QWORD *)(v61 + 8 * v58);
    v64 = v61 + 8 * v62;
    *v63 = v235;
    v57 = (uint64_t (****)(Trackable *))(v63 + 1);
    v66 = (char *)*((_QWORD *)&v216 + 1);
    v65 = (char *)v217;
    if ((_QWORD)v217 != *((_QWORD *)&v216 + 1))
    {
      do
      {
        v67 = *((_QWORD *)v65 - 1);
        v65 -= 8;
        *--v63 = v67;
      }
      while (v65 != v66);
      v65 = (char *)*((_QWORD *)&v216 + 1);
    }
    *((_QWORD *)&v216 + 1) = v63;
    *(_QWORD *)&v217 = v57;
    *((_QWORD *)&v217 + 1) = v64;
    if (v65)
      operator delete(v65);
  }
  else
  {
    v50[2] = v235;
    v57 = (uint64_t (****)(Trackable *))(v50 + 3);
  }
  *(_QWORD *)&v217 = v57;
  if ((unint64_t)v57 >= *((_QWORD *)&v217 + 1))
  {
    v69 = ((uint64_t)v57 - *((_QWORD *)&v216 + 1)) >> 3;
    if ((unint64_t)(v69 + 1) >> 61)
      goto LABEL_368;
    v70 = (uint64_t)(*((_QWORD *)&v217 + 1) - *((_QWORD *)&v216 + 1)) >> 2;
    if (v70 <= v69 + 1)
      v70 = v69 + 1;
    if (*((_QWORD *)&v217 + 1) - *((_QWORD *)&v216 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
      v71 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v71 = v70;
    if (v71)
      v71 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v71);
    else
      v72 = 0;
    v73 = (uint64_t (****)(Trackable *))(v71 + 8 * v69);
    v74 = v71 + 8 * v72;
    *v73 = &v237;
    v68 = v73 + 1;
    v76 = (char *)*((_QWORD *)&v216 + 1);
    v75 = (char *)v217;
    if ((_QWORD)v217 != *((_QWORD *)&v216 + 1))
    {
      do
      {
        v77 = (uint64_t (***)(Trackable *))*((_QWORD *)v75 - 1);
        v75 -= 8;
        *--v73 = v77;
      }
      while (v75 != v76);
      v75 = (char *)*((_QWORD *)&v216 + 1);
    }
    *((_QWORD *)&v216 + 1) = v73;
    *(_QWORD *)&v217 = v68;
    *((_QWORD *)&v217 + 1) = v74;
    if (v75)
      operator delete(v75);
  }
  else
  {
    *v57 = &v237;
    v68 = v57 + 1;
  }
  *(_QWORD *)&v217 = v68;
  if ((unint64_t)v68 < *((_QWORD *)&v217 + 1))
  {
    *v68 = v236;
    v78 = v68 + 1;
    goto LABEL_132;
  }
  v79 = ((uint64_t)v68 - *((_QWORD *)&v216 + 1)) >> 3;
  if ((unint64_t)(v79 + 1) >> 61)
LABEL_368:
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  v80 = (uint64_t)(*((_QWORD *)&v217 + 1) - *((_QWORD *)&v216 + 1)) >> 2;
  if (v80 <= v79 + 1)
    v80 = v79 + 1;
  if (*((_QWORD *)&v217 + 1) - *((_QWORD *)&v216 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
    v81 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v81 = v80;
  if (v81)
    v81 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v81);
  else
    v82 = 0;
  v83 = (_QWORD *)(v81 + 8 * v79);
  v84 = v81 + 8 * v82;
  *v83 = v236;
  v78 = v83 + 1;
  v86 = (char *)*((_QWORD *)&v216 + 1);
  v85 = (char *)v217;
  if ((_QWORD)v217 != *((_QWORD *)&v216 + 1))
  {
    do
    {
      v87 = *((_QWORD *)v85 - 1);
      v85 -= 8;
      *--v83 = v87;
    }
    while (v85 != v86);
    v85 = (char *)*((_QWORD *)&v216 + 1);
  }
  *((_QWORD *)&v216 + 1) = v83;
  *(_QWORD *)&v217 = v78;
  *((_QWORD *)&v217 + 1) = v84;
  if (v85)
    operator delete(v85);
LABEL_132:
  *(_QWORD *)&v217 = v78;
  v212[2] = 0;
  DWORD2(__p) = 0;
  *(_QWORD *)&__p = &off_1E69EB938;
  v225 = 0;
  v224 = 0;
  v295 = 0uLL;
  *(_QWORD *)&v296 = 0;
  v88 = &v295;
  v189 = AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::CircularBuffer(&v228, 1uLL, (uint64_t *)&v295);
  v206.__r_.__value_.__r.__words[0] = (std::string::size_type)&v295;
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v206);
  v233 = 0;
  v89 = (__int128 *)operator new(0x38uLL);
  *(_QWORD *)v89 = &off_1E69EB958;
  *((_QWORD *)v89 + 1) = Transformer::WholeSignalForward<float>::Transform;
  *((_QWORD *)v89 + 2) = &v274;
  *((_QWORD *)v89 + 3) = v234;
  *((_QWORD *)v89 + 4) = v235;
  *((_QWORD *)v89 + 5) = &v237;
  *((_QWORD *)v89 + 6) = v236;
  *((_QWORD *)&v296 + 1) = v89;
  v90 = v224;
  if (v224 == (__int128 *)v223)
  {
    v90 = &v295;
    (*(void (**)(_QWORD *, __int128 *))(v223[0] + 24))(v223, &v295);
    (*(void (**)(__int128 *))(*(_QWORD *)v224 + 32))(v224);
    v224 = (__int128 *)*((_QWORD *)&v296 + 1);
    *((_QWORD *)&v296 + 1) = &v295;
    v91 = 4;
  }
  else
  {
    *((_QWORD *)&v296 + 1) = v224;
    v224 = v89;
    if (v90 == &v295)
    {
      v91 = 4;
      v90 = &v295;
    }
    else
    {
      if (!v90)
        goto LABEL_139;
      v91 = 5;
    }
  }
  (*(void (**)(__int128 *))(*(_QWORD *)v90 + 8 * v91))(v90);
LABEL_139:
  DWORD2(__p) = 0;
  v227 = 0;
  *(_QWORD *)&v210 = 0;
  v226 = 0;
  *(_QWORD *)&__p = &off_1E69EB820;
  if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v203.__r_.__value_.__r.__words[2]);
  else
    size = v203.__r_.__value_.__l.__size_;
  std::string::basic_string[abi:ne180100]((uint64_t)&v295, size + 10);
  if (SBYTE7(v296) < 0)
    v88 = (__int128 *)v295;
  if (size)
  {
    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v93 = &v203;
    else
      v93 = (std::string *)v203.__r_.__value_.__r.__words[0];
    memmove(v88, v93, size);
  }
  strcpy((char *)v88 + size, "_blockSize");
  AutoValue<unsigned long,(LogTypes)0>::AutoValue((uint64_t)v234, &v295);
  if (SBYTE7(v296) < 0)
    operator delete((void *)v295);
  if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v94 = HIBYTE(v203.__r_.__value_.__r.__words[2]);
  else
    v94 = v203.__r_.__value_.__l.__size_;
  v95 = &v295;
  std::string::basic_string[abi:ne180100]((uint64_t)&v295, v94 + 8);
  if (SBYTE7(v296) < 0)
    v95 = (__int128 *)v295;
  if (v94)
  {
    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v96 = &v203;
    else
      v96 = (std::string *)v203.__r_.__value_.__r.__words[0];
    memmove(v95, v96, v94);
  }
  strcpy((char *)v95 + v94, "_fftSize");
  AutoValue<unsigned long,(LogTypes)0>::AutoValue((uint64_t)v235, &v295);
  if (SBYTE7(v296) < 0)
    operator delete((void *)v295);
  if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v97 = HIBYTE(v203.__r_.__value_.__r.__words[2]);
  else
    v97 = v203.__r_.__value_.__l.__size_;
  v98 = &v295;
  std::string::basic_string[abi:ne180100]((uint64_t)&v295, v97 + 8);
  if (SBYTE7(v296) < 0)
    v98 = (__int128 *)v295;
  if (v97)
  {
    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v99 = &v203;
    else
      v99 = (std::string *)v203.__r_.__value_.__r.__words[0];
    memmove(v98, v99, v97);
  }
  strcpy((char *)v98 + v97, "_zeroPad");
  AutoValue<BOOL,(LogTypes)0>::AutoValue((uint64_t)v236, &v295);
  if (SBYTE7(v296) < 0)
    operator delete((void *)v295);
  if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v100 = HIBYTE(v203.__r_.__value_.__r.__words[2]);
  else
    v100 = v203.__r_.__value_.__l.__size_;
  v101 = &v295;
  std::string::basic_string[abi:ne180100]((uint64_t)&v295, v100 + 11);
  if (SBYTE7(v296) < 0)
    v101 = (__int128 *)v295;
  if (v100)
  {
    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v102 = &v203;
    else
      v102 = (std::string *)v203.__r_.__value_.__r.__words[0];
    memmove(v101, v102, v100);
  }
  strcpy((char *)v101 + v100, "_windowType");
  Trackable::Trackable<>((uint64_t)&v237, &v295);
  v237 = &off_1E69EB9C0;
  v242 = 0;
  v241 = 0;
  v245 = xmmword_1B6626830;
  v246 = 0;
  v247 = 0;
  *(_OWORD *)v248 = xmmword_1B66A0DC0;
  v247 = operator new(4uLL);
  *v247 = 0;
  *(_OWORD *)&v248[8] = xmmword_1B66A0DC0;
  v239 = 0;
  v244 = 0;
  v243 = 0;
  if (SBYTE7(v296) < 0)
    operator delete((void *)v295);
  if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v103 = HIBYTE(v203.__r_.__value_.__r.__words[2]);
  else
    v103 = v203.__r_.__value_.__l.__size_;
  v104 = &v295;
  std::string::basic_string[abi:ne180100]((uint64_t)&v295, v103 + 9);
  if (SBYTE7(v296) < 0)
    v104 = (__int128 *)v295;
  if (v103)
  {
    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v105 = &v203;
    else
      v105 = (std::string *)v203.__r_.__value_.__r.__words[0];
    memmove(v104, v105, v103);
  }
  strcpy((char *)v104 + v103, "_overlapX");
  AutoValue<unsigned long,(LogTypes)0>::AutoValue<unsigned long const& ()(unsigned long &,AutoValue<unsigned long,(LogTypes)0>&,AutoValue<unsigned long,(LogTypes)0>&),unsigned long,unsigned long>((uint64_t)v249, &v295, (uint64_t)Transformer::ComputeOverlapXA<unsigned long>, (uint64_t)v235, (uint64_t)v234);
  if (SBYTE7(v296) < 0)
    operator delete((void *)v295);
  if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v106 = HIBYTE(v203.__r_.__value_.__r.__words[2]);
  else
    v106 = v203.__r_.__value_.__l.__size_;
  v107 = &v206;
  std::string::basic_string[abi:ne180100]((uint64_t)&v206, v106 + 16);
  if ((v206.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v107 = (std::string *)v206.__r_.__value_.__r.__words[0];
  if (v106)
  {
    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v108 = &v203;
    else
      v108 = (std::string *)v203.__r_.__value_.__r.__words[0];
    memmove(v107, v108, v106);
  }
  strcpy((char *)v107 + v106, "_numOutputFrames");
  v250 = &off_1E69EB2E0;
  v253 = 0;
  v255 = 0;
  v256 = 0;
  v254 = 0;
  v258 = 0;
  if (SHIBYTE(v206.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v259, v206.__r_.__value_.__l.__data_, v206.__r_.__value_.__l.__size_);
  else
    v259 = v206;
  v260 = 0;
  v261 = 0u;
  v262 = 0u;
  v263 = 0u;
  v264 = 0u;
  v265 = 0u;
  v266 = 0u;
  v267 = 0u;
  v268 = 0;
  v109 = operator new(8uLL);
  *v109 = v273;
  *((_QWORD *)&v262 + 1) = v109;
  *(_QWORD *)&v263 = v109 + 1;
  *((_QWORD *)&v263 + 1) = v109 + 1;
  Trackable::BuildDepsList<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<float,(LogTypes)0>>((void **)&v262 + 1, (uint64_t)v234, (uint64_t)v249);
  v257 = 0;
  v251 = 0;
  v250 = (void (**)(Trackable *__hidden))&off_1E69EB9A0;
  v269[7] = 0;
  v269[4] = 0;
  v269[3] = 0;
  v269[8] = 1;
  v270 = 0;
  v269[9] = 0;
  *(_OWORD *)v271 = xmmword_1B66A0DC0;
  v270 = operator new(8uLL);
  *v270 = 0;
  *(_OWORD *)&v271[8] = xmmword_1B66A0DC0;
  v110 = operator new(0x28uLL);
  *v110 = &off_1E69EBA28;
  v110[1] = Transformer::WholeSignalForward<float>::ComputeNumberOfWholeFrames;
  v110[2] = v273;
  v110[3] = v234;
  v110[4] = v249;
  *((_QWORD *)&v296 + 1) = v110;
  v111 = &v295;
  std::__function::__value_func<unsigned long const& ()(unsigned long &)>::swap[abi:ne180100](&v295, v269);
  v112 = (__int128 *)*((_QWORD *)&v296 + 1);
  if (*((__int128 **)&v296 + 1) == &v295)
  {
    v113 = 4;
    v112 = &v295;
  }
  else
  {
    if (!*((_QWORD *)&v296 + 1))
      goto LABEL_217;
    v113 = 5;
  }
  (*(void (**)(__int128 *))(*(_QWORD *)v112 + 8 * v113))(v112);
LABEL_217:
  v251 = 0;
  v252 = 0;
  v269[6] = 0;
  v269[5] = 0;
  if (SHIBYTE(v206.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v206.__r_.__value_.__l.__data_);
  if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v114 = HIBYTE(v203.__r_.__value_.__r.__words[2]);
  else
    v114 = v203.__r_.__value_.__l.__size_;
  std::string::basic_string[abi:ne180100]((uint64_t)&v295, v114 + 17);
  if (SBYTE7(v296) < 0)
    v111 = (__int128 *)v295;
  if (v114)
  {
    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v115 = &v203;
    else
      v115 = (std::string *)v203.__r_.__value_.__r.__words[0];
    memmove(v111, v115, v114);
  }
  strcpy((char *)v111 + v114, "_numOutputSamples");
  AutoValue<unsigned long,(LogTypes)0>::AutoValue<unsigned long const& ()(unsigned long &,AutoValue<unsigned long,(LogTypes)0>&,AutoValue<unsigned long,(LogTypes)0>&),unsigned long,unsigned long>((uint64_t)v272, &v295, (uint64_t)Transformer::MultiplyAVAV<unsigned long>, (uint64_t)v234, (uint64_t)&v250);
  if (SBYTE7(v296) < 0)
    operator delete((void *)v295);
  if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v116 = HIBYTE(v203.__r_.__value_.__r.__words[2]);
  else
    v116 = v203.__r_.__value_.__l.__size_;
  v117 = &v295;
  std::string::basic_string[abi:ne180100]((uint64_t)&v295, v116 + 2);
  if (SBYTE7(v296) < 0)
    v117 = (__int128 *)v295;
  if (v116)
  {
    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v118 = &v203;
    else
      v118 = (std::string *)v203.__r_.__value_.__r.__words[0];
    memmove(v117, v118, v116);
  }
  strcpy((char *)v117 + v116, "_x");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue(v273, &v295);
  if (SBYTE7(v296) < 0)
    operator delete((void *)v295);
  if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v119 = HIBYTE(v203.__r_.__value_.__r.__words[2]);
  else
    v119 = v203.__r_.__value_.__l.__size_;
  v120 = &v206;
  std::string::basic_string[abi:ne180100]((uint64_t)&v206, v119 + 10);
  if ((v206.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v120 = (std::string *)v206.__r_.__value_.__r.__words[0];
  if (v119)
  {
    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v121 = &v203;
    else
      v121 = (std::string *)v203.__r_.__value_.__r.__words[0];
    memmove(v120, v121, v119);
  }
  strcpy((char *)v120 + v119, "_xExtended");
  v274 = (uint64_t (**)())&off_1E69EB2E0;
  v277 = 0;
  v279 = 0;
  v280 = 0;
  v278 = 0;
  v282 = 0;
  if (SHIBYTE(v206.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v283, v206.__r_.__value_.__l.__data_, v206.__r_.__value_.__l.__size_);
  else
    v283 = v206;
  v284 = 0;
  v285 = 0u;
  v286 = 0u;
  v287 = 0u;
  v288 = 0u;
  v289 = 0u;
  v290 = 0u;
  v291 = 0u;
  v292 = 0;
  v123 = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(1uLL);
  v124 = &v123[v122];
  *v123 = v273;
  v125 = v123 + 1;
  v126 = (char *)v287;
  v127 = (char *)*((_QWORD *)&v286 + 1);
  v128 = v123;
  if ((_QWORD)v287 != *((_QWORD *)&v286 + 1))
  {
    do
    {
      v129 = *((_QWORD *)v126 - 1);
      v126 -= 8;
      *--v128 = v129;
    }
    while (v126 != v127);
    v126 = (char *)*((_QWORD *)&v286 + 1);
  }
  *((_QWORD *)&v286 + 1) = v128;
  *(_QWORD *)&v287 = v123 + 1;
  *((_QWORD *)&v287 + 1) = &v123[v122];
  if (v126)
  {
    operator delete(v126);
    v124 = (_QWORD *)*((_QWORD *)&v287 + 1);
  }
  *(_QWORD *)&v287 = v123 + 1;
  if (v125 >= v124)
  {
    v131 = ((uint64_t)v125 - *((_QWORD *)&v286 + 1)) >> 3;
    if ((unint64_t)(v131 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v132 = (uint64_t)v124 - *((_QWORD *)&v286 + 1);
    v133 = v132 >> 2;
    if (v132 >> 2 <= (unint64_t)(v131 + 1))
      v133 = v131 + 1;
    if ((unint64_t)v132 >= 0x7FFFFFFFFFFFFFF8)
      v134 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v134 = v133;
    if (v134)
      v134 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v134);
    else
      v135 = 0;
    v136 = (_QWORD *)(v134 + 8 * v131);
    v137 = v134 + 8 * v135;
    *v136 = v272;
    v130 = v136 + 1;
    v138 = (char *)v287;
    v139 = (char *)*((_QWORD *)&v286 + 1);
    if ((_QWORD)v287 != *((_QWORD *)&v286 + 1))
    {
      do
      {
        v140 = *((_QWORD *)v138 - 1);
        v138 -= 8;
        *--v136 = v140;
      }
      while (v138 != v139);
      v138 = (char *)*((_QWORD *)&v286 + 1);
    }
    *((_QWORD *)&v286 + 1) = v136;
    *(_QWORD *)&v287 = v130;
    *((_QWORD *)&v287 + 1) = v137;
    if (v138)
      operator delete(v138);
  }
  else
  {
    v123[1] = v272;
    v130 = v123 + 2;
  }
  *(_QWORD *)&v287 = v130;
  v281 = 0;
  v275 = 0;
  v274 = &off_1E69EB4C0;
  v293[4] = 0;
  v293[3] = 0;
  v295 = 0uLL;
  *(_QWORD *)&v296 = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v294, 1uLL, (uint64_t)&v295);
  v294[8] = 0;
  v141 = operator new(0x20uLL);
  *v141 = &off_1E69EBA70;
  v141[1] = Transformer::WholeSignalForward<float>::ExtendWithZeros;
  v141[2] = v273;
  v141[3] = v272;
  *((_QWORD *)&v296 + 1) = v141;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](&v295, v293);
  v142 = (__int128 *)*((_QWORD *)&v296 + 1);
  if (*((__int128 **)&v296 + 1) == &v295)
  {
    v143 = 4;
    v142 = &v295;
  }
  else
  {
    if (!*((_QWORD *)&v296 + 1))
      goto LABEL_282;
    v143 = 5;
  }
  (*(void (**)(__int128 *))(*(_QWORD *)v142 + 8 * v143))(v142);
LABEL_282:
  v275 = 0;
  v276 = 0;
  v293[6] = 0;
  v293[5] = 0;
  if (SHIBYTE(v206.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v206.__r_.__value_.__l.__data_);
  AutoValue<unsigned long,(LogTypes)0>::Set((Trackable *)v234, &v205);
  AutoValue<unsigned long,(LogTypes)0>::Set((Trackable *)v235, &v204);
  AutoValue<BOOL,(LogTypes)0>::Set((Trackable *)v236, 0);
  ++v239;
  v144 = v245;
  if (*((_QWORD *)&v245 + 1) < (unint64_t)v245)
    __assert_rtn("DecrementCirc", "AutoValue.h", 491, "index <= _C");
  if (!(_QWORD)v245)
    v144 = *((_QWORD *)&v245 + 1);
  v145 = v144 - 1;
  *(_QWORD *)&v245 = v145;
  if (*(_QWORD *)v248 <= v145)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  v247[v145] = 1;
  if (v238 != 1)
  {
    v238 = 1;
    Trackable::Uninitialize((Trackable *)&v237);
  }
  v242 = 0;
  v240 = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::Set((Trackable *)v273, (uint64_t)&v200);
  Trackable::Initialize((uint64_t)v272);
  v146 = (unint64_t *)AutoValue<unsigned long,(LogTypes)0>::Get((uint64_t)&v250);
  v194 = (_QWORD *)(a1 + 296);
  v147 = v233;
  v148 = *v146;
  memset(&v206, 0, sizeof(v206));
  v207 = &v206;
  v208 = 0;
  if (v148)
  {
    std::vector<DSPSplitComplexV<float>>::__vallocate[abi:ne180100](&v206, v148);
    v149 = (_QWORD *)v206.__r_.__value_.__l.__size_;
    v150 = v206.__r_.__value_.__l.__size_ + (v148 << 6);
    v151 = v148 << 6;
    do
    {
      DSPSplitComplexV<float>::DSPSplitComplexV(v149, 0);
      v149 += 8;
      v151 -= 64;
    }
    while (v151);
    v206.__r_.__value_.__l.__size_ = v150;
  }
  AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::CircularBuffer(&v295, v147 + 1, (uint64_t *)&v206);
  *(_OWORD *)v189 = v295;
  std::vector<DSPSplitComplexV<float>>::__vdeallocate(&v229);
  v229 = v296;
  v230 = v297;
  v297 = 0;
  v296 = 0uLL;
  v152 = v232;
  if ((_QWORD)v232)
  {
    v153 = (void **)v231;
    do
    {
      --v152;
      v207 = (std::string *)v153;
      std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v207);
      v153 += 3;
    }
    while (v152);
  }
  *(_QWORD *)&v232 = 0;
  if (v231)
    operator delete(v231);
  v231 = v298;
  v232 = v299;
  v299 = 0uLL;
  v298 = 0;
  boost::container::vector<std::vector<DSPSplitComplexV<float>>,void,void>::~vector((uint64_t)&v298);
  v207 = (std::string *)&v296;
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v207);
  v207 = &v206;
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v207);
  v154 = (unint64_t *)AutoValue<unsigned long,(LogTypes)0>::Get((uint64_t)v272);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>((uint64_t)&v274, *v154);
  if (v200)
  {
    v201 = v200;
    operator delete(v200);
  }
  if (SHIBYTE(v203.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v203.__r_.__value_.__l.__data_);
  Trackable::Initialize((uint64_t)&__p);
  v155 = (uint64_t *)AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::Get((uint64_t)&__p);
  v295 = 0uLL;
  *(_QWORD *)&v296 = 0;
  std::vector<DSPSplitComplexV<float>>::__init_with_size[abi:ne180100]<DSPSplitComplexV<float>*,DSPSplitComplexV<float>*>(&v295, *v155, v155[1], (v155[1] - *v155) >> 6);
  v156 = v295;
  v157 = DSPSplitComplexV<float>::size((_QWORD *)v295);
  LODWORD(v203.__r_.__value_.__l.__data_) = 0;
  std::vector<float>::vector(&v206, v157, &v203);
  std::vector<std::vector<float>>::vector(&v198, (uint64_t)(*((_QWORD *)&v156 + 1) - v156) >> 6, (uint64_t)&v206);
  if (v206.__r_.__value_.__r.__words[0])
  {
    v206.__r_.__value_.__l.__size_ = v206.__r_.__value_.__r.__words[0];
    operator delete(v206.__r_.__value_.__l.__data_);
  }
  v158 = v295;
  if (*((_QWORD *)&v295 + 1) != (_QWORD)v295)
  {
    v159 = 0;
    v160 = 0;
    v161 = 0;
    do
    {
      if (0xAAAAAAAAAAAAAAABLL * (v199 - v198) <= v161)
        std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
      SquareMagFreqVector<float>((uint64_t)&v198[v159], (DSPSplitComplex *)(v158 + v160));
      ++v161;
      v158 = v295;
      v160 += 64;
      v159 += 3;
    }
    while (v161 < (uint64_t)(*((_QWORD *)&v295 + 1) - v295) >> 6);
  }
  v206.__r_.__value_.__r.__words[0] = (std::string::size_type)&v295;
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v206);
  Transformer::WholeSignalForward<float>::~WholeSignalForward((uint64_t)&__p);
  v162 = (uint64_t)v198;
  v163 = (uint64_t)v199;
  v165 = *v198;
  v164 = v198[1];
  ++*(_QWORD *)(a1 + 1056);
  v166 = *(_QWORD *)(a1 + 1320);
  if (*(_QWORD *)(a1 + 1328) < v166)
    __assert_rtn("DecrementCirc", "AutoValue.h", 491, "index <= _C");
  if (!v166)
    v166 = *(_QWORD *)(a1 + 1328);
  v167 = v166 - 1;
  *(_QWORD *)(a1 + 1320) = v167;
  if (*(_QWORD *)(a1 + 1368) <= v167)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  v168 = 0xAAAAAAAAAAAAAAABLL * ((v163 - v162) >> 3);
  v169 = (uint64_t **)(*(_QWORD *)(a1 + 1360) + 24 * v167);
  if (v169 != &v198)
    std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((uint64_t)v169, v162, v163, 0xAAAAAAAAAAAAAAABLL * ((v163 - v162) >> 3));
  if (*(_DWORD *)(a1 + 1048) != 1)
  {
    *(_DWORD *)(a1 + 1048) = 1;
    Trackable::Uninitialize(v193);
  }
  *(_QWORD *)(a1 + 1296) = 0;
  *(_QWORD *)(a1 + 1104) = 0;
  Trackable::Initialize((uint64_t)v193);
  v170 = v198;
  v171 = v199;
  if (v198 != v199)
  {
    v172 = 0;
    while (1)
    {
      std::vector<float>::vector(&__p, (v170[1] - *v170) >> 2);
      v174 = *v170;
      v173 = v170[1];
      if (v173 - *v170 != *((_QWORD *)&__p + 1) - (_QWORD)__p)
        break;
      if (v174 != v173)
      {
        v175 = v174 + 4;
        v176 = (float *)__p;
        do
        {
          v177 = *v176++;
          v178 = *(float *)(v175 - 4) == v177;
          v179 = *(float *)(v175 - 4) != v177 || v175 == v173;
          v175 += 4;
        }
        while (!v179);
LABEL_329:
        if (!(_QWORD)__p)
          goto LABEL_331;
LABEL_330:
        *((_QWORD *)&__p + 1) = __p;
        operator delete((void *)__p);
        goto LABEL_331;
      }
      v178 = 1;
      if ((_QWORD)__p)
        goto LABEL_330;
LABEL_331:
      if (v178)
      {
        ++v172;
        v170 += 3;
        if (v170 != v171)
          continue;
      }
      goto LABEL_337;
    }
    v178 = 0;
    goto LABEL_329;
  }
  v172 = 0;
LABEL_337:
  v180 = (v164 - v165) >> 2;
  *(_QWORD *)(a1 + 1744) = v172;
  *(_QWORD *)(a1 + 1736) = v168;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>((uint64_t)v195, v180);
  v181 = a1 + 1752;
  if (*(_QWORD *)(a1 + 1648) != a1 + 1752)
  {
    *(_QWORD *)(a1 + 1648) = v181;
    *(_QWORD *)(a1 + 1456) = v181;
    *(_QWORD *)(a1 + 1448) = 0;
    if (*(_DWORD *)(a1 + 1400) != 2)
    {
      *(_DWORD *)(a1 + 1400) = 2;
      Trackable::Uninitialize(v195);
    }
  }
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v190, v180);
  *(_QWORD *)&__p = &v198;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  if (SHIBYTE(v197) < 0)
    operator delete(v196[0]);
  if (*(char *)(a2 + 23) >= 0)
    v182 = *(unsigned __int8 *)(a2 + 23);
  else
    v182 = *(_QWORD *)(a2 + 8);
  v183 = &__p;
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v182 + 15);
  if (SBYTE7(v210) < 0)
    v183 = (__int128 *)__p;
  if (v182)
  {
    if (*(char *)(a2 + 23) >= 0)
      v184 = (const void *)a2;
    else
      v184 = *(const void **)a2;
    memmove(v183, v184, v182);
  }
  strcpy((char *)v183 + v182, "_inputMagnitude");
  SpectralMagnitude<float,(LogTypes)0>::SpectralMagnitude(a1 + 1752, &__p, a4 >> 1, a6);
  if (SBYTE7(v210) < 0)
    operator delete((void *)__p);
  LODWORD(v206.__r_.__value_.__l.__data_) = 0;
  v185 = *(_QWORD *)(a1 + 344);
  std::vector<float>::vector(&v295, a4 >> 1, &v206);
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(&__p, v185 + 1, (uint64_t)&v295);
  *(_OWORD *)(a1 + 280) = __p;
  v186 = *(void **)(a1 + 296);
  if (v186)
  {
    *(_QWORD *)(a1 + 304) = v186;
    operator delete(v186);
    *v194 = 0;
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 312) = 0;
  }
  *(_OWORD *)v194 = v210;
  *(_QWORD *)(a1 + 312) = v211;
  v211 = 0;
  v210 = 0uLL;
  if (&__p != (__int128 *)(a1 + 280))
    boost::container::vector<std::vector<float>,void,void>::priv_move_assign<void>(a1 + 320, v212);
  boost::container::vector<std::vector<float>,void,void>::~vector(v212);
  if ((_QWORD)v210)
  {
    *((_QWORD *)&v210 + 1) = v210;
    operator delete((void *)v210);
  }
  if ((_QWORD)v295)
  {
    *((_QWORD *)&v295 + 1) = v295;
    operator delete((void *)v295);
  }
  return a1;
}

void sub_1B656C848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, void **a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, void **a19, uint64_t a20,uint64_t a21,void **a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,uint64_t a52,uint64_t a53,char a54)
{
  uint64_t v54;
  void **v55;
  void **v56;
  void **v57;
  void *v59;

  v59 = (void *)STACK[0xD30];
  if (STACK[0xD30])
  {
    STACK[0xD38] = (unint64_t)v59;
    operator delete(v59);
  }
  if (a51 < 0)
    operator delete(a46);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a12);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(v55);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(a17);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(a19);
  AutoValue<Transformer::windowTypes,(LogTypes)0>::~AutoValue(v57);
  AutoValue<BOOL,(LogTypes)0>::~AutoValue(a22);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(a13);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(v56);
  AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::~AutoValue((uint64_t)&a54);
  if (a35)
    operator delete(a35);
  if (a43 < 0)
    operator delete(a38);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a25);
  AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::~AutoValue(a21);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a11);
  if (a31 < 0)
    operator delete(a26);
  dBToLinear<float,(LogTypes)0>::~dBToLinear(a14);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v54);
  _Unwind_Resume(a1);
}

void sub_1B656C854(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  void *v45;

  v45 = (void *)STACK[0x930];
  if (STACK[0x930])
  {
    STACK[0x938] = (unint64_t)v45;
    operator delete(v45);
  }
  if (a45 < 0)
    operator delete(a40);
  JUMPOUT(0x1B656CF5CLL);
}

void sub_1B656C860(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50)
{
  if (__p)
    operator delete(__p);
  JUMPOUT(0x1B656CF90);
}

void sub_1B656C868()
{
  uint64_t v0;
  void *v1;

  v1 = *(void **)(v0 + 720);
  if (v1)
  {
    *(_QWORD *)(v0 + 728) = v1;
    operator delete(v1);
  }
  JUMPOUT(0x1B656CFC8);
}

void sub_1B656C870(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void **a43)
{
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&a43);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a18);
  JUMPOUT(0x1B656CF44);
}

void sub_1B656C87C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  uint64_t v50;
  uint64_t v51;
  void *v52;

  v52 = *(void **)(v51 - 160);
  if (v52)
  {
    *(_QWORD *)(v51 - 152) = v52;
    operator delete(v52);
  }
  SpectralMagnitude<float,(LogTypes)0>::~SpectralMagnitude(v50);
  Convolver<float,true,(LogTypes)0>::~Convolver(a11);
  JUMPOUT(0x1B656CFD8);
}

void sub_1B656C8CC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  uint64_t v45;

  if (__p)
  {
    a41 = (uint64_t)__p;
    operator delete(__p);
  }
  __p = (void *)(v45 - 160);
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  Transformer::WholeSignalForward<float>::~WholeSignalForward((uint64_t)&a45);
  JUMPOUT(0x1B656CFB0);
}

void sub_1B656C8E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45)
{
  uint64_t v45;

  a40 = v45 - 160;
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&a40);
  Transformer::WholeSignalForward<float>::~WholeSignalForward(&a45);
  JUMPOUT(0x1B656CFB0);
}

void sub_1B656C8F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43)
{
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&a43);
  JUMPOUT(0x1B656CF3CLL);
}

void sub_1B656C900(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void **a18)
{
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;

  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::~CircularBuffer(v18);
  if ((_QWORD *)STACK[0xE08] == v19)
  {
    v20 = 4;
  }
  else
  {
    if (!STACK[0xE08])
    {
LABEL_6:
      Trackable::~Trackable(a18);
      JUMPOUT(0x1B656CD24);
    }
    v20 = 5;
    v19 = (_QWORD *)STACK[0xE08];
  }
  (*(void (**)(_QWORD *))(*v19 + 8 * v20))(v19);
  goto LABEL_6;
}

void sub_1B656C958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, Trackable *a13, Trackable *a14, uint64_t a15, uint64_t a16, Trackable *a17, uint64_t a18, Trackable *a19, uint64_t a20,uint64_t a21,Trackable *a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  uint64_t v51;
  Trackable *v52;
  Trackable *v53;
  Trackable *v54;

  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a12);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(v52);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(a17);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(a19);
  AutoValue<Transformer::windowTypes,(LogTypes)0>::~AutoValue(v54);
  AutoValue<BOOL,(LogTypes)0>::~AutoValue(a22);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(a13);
  AutoValue<unsigned long,(LogTypes)0>::~AutoValue(v53);
  AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::~AutoValue(&a51);
  if (a35)
    operator delete(a35);
  if (a43 < 0)
    operator delete(a38);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a25);
  AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::~AutoValue(a21);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(a11);
  if (a31 < 0)
    operator delete(a26);
  dBToLinear<float,(LogTypes)0>::~dBToLinear(a14);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v51);
  _Unwind_Resume(a1);
}

void sub_1B656C964()
{
  uint64_t v0;

  if (*(char *)(v0 - 137) < 0)
    operator delete(*(void **)(v0 - 160));
  JUMPOUT(0x1B656CF4CLL);
}

void sub_1B656C980()
{
  JUMPOUT(0x1B656CF4CLL);
}

void sub_1B656C98C()
{
  uint64_t v0;

  if (*(char *)(v0 - 137) < 0)
    operator delete(*(void **)(v0 - 160));
  JUMPOUT(0x1B656CF54);
}

void sub_1B656C9A4()
{
  JUMPOUT(0x1B656CF54);
}

void sub_1B656C9AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  void *v17;
  _QWORD *v18;
  uint64_t v19;

  operator delete(v17);
  if ((_QWORD *)STACK[0xA08] == v18)
  {
    v19 = 4;
  }
  else
  {
    if (!STACK[0xA08])
    {
LABEL_6:
      Trackable::~Trackable(a17);
      JUMPOUT(0x1B656CE30);
    }
    v19 = 5;
    v18 = (_QWORD *)STACK[0xA08];
  }
  (*(void (**)(_QWORD *))(*v18 + 8 * v19))(v18);
  goto LABEL_6;
}

void sub_1B656C9FC()
{
  JUMPOUT(0x1B656CF5CLL);
}

void sub_1B656CA04()
{
  uint64_t v0;

  if (*(char *)(v0 - 137) < 0)
    operator delete(*(void **)(v0 - 160));
  JUMPOUT(0x1B656CF68);
}

void sub_1B656CA1C()
{
  JUMPOUT(0x1B656CF68);
}

void sub_1B656CA24()
{
  void **v0;
  uint64_t v1;
  unint64_t *v2;
  uint64_t v3;

  v2 = (unint64_t *)STACK[0x768];
  if ((unint64_t *)STACK[0x768] == &STACK[0x750])
  {
    v3 = 4;
    v2 = &STACK[0x750];
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  Trackable::~Trackable(v0);
  if (*(char *)(v1 - 137) < 0)
    operator delete(*(void **)(v1 - 160));
  JUMPOUT(0x1B656CF70);
}

void sub_1B656CA80()
{
  JUMPOUT(0x1B656CF70);
}

void sub_1B656CA88()
{
  uint64_t v0;

  if (*(char *)(v0 - 137) < 0)
    operator delete(*(void **)(v0 - 160));
  JUMPOUT(0x1B656CF78);
}

void sub_1B656CAA0()
{
  JUMPOUT(0x1B656CF78);
}

void sub_1B656CAA8()
{
  uint64_t v0;

  if (*(char *)(v0 - 137) < 0)
    operator delete(*(void **)(v0 - 160));
  JUMPOUT(0x1B656CF80);
}

void sub_1B656CAC0()
{
  JUMPOUT(0x1B656CF80);
}

void sub_1B656CAC8()
{
  uint64_t v0;

  if (*(char *)(v0 - 137) < 0)
    operator delete(*(void **)(v0 - 160));
  JUMPOUT(0x1B656CF88);
}

void sub_1B656CAE0()
{
  JUMPOUT(0x1B656CF88);
}

void sub_1B656CAE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45)
{
  _QWORD *v45;
  uint64_t v46;

  AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::~CircularBuffer(a10);
  if ((_QWORD *)STACK[0x218] == v45)
  {
    v46 = 4;
  }
  else
  {
    if (!STACK[0x218])
    {
LABEL_6:
      Trackable::~Trackable(&a45);
      JUMPOUT(0x1B656CF90);
    }
    v46 = 5;
    v45 = (_QWORD *)STACK[0x218];
  }
  (*(void (**)(_QWORD *))(*v45 + 8 * v46))(v45);
  goto LABEL_6;
}

void sub_1B656CB44()
{
  JUMPOUT(0x1B656CFA0);
}

void sub_1B656CB4C()
{
  JUMPOUT(0x1B656CFB0);
}

void sub_1B656CB54(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a50 < 0)
    operator delete(__p);
  JUMPOUT(0x1B656CFB8);
}

void sub_1B656CB6C()
{
  JUMPOUT(0x1B656CFB8);
}

void sub_1B656CB74(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    __cxa_rethrow();
  }
  JUMPOUT(0x1B656CFE8);
}

void sub_1B656CB8C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void **a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;

  __cxa_end_catch();
  if (*(_QWORD *)(v45 + 1376))
    operator delete(*(void **)(v45 + 1360));
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a40);
  a40 = &a45;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a40);
  v47 = *(_QWORD **)(v45 + 1288);
  if (v47 == (_QWORD *)(v45 + 1264))
  {
    v48 = 4;
    v47 = (_QWORD *)(v45 + 1264);
  }
  else
  {
    if (!v47)
      goto LABEL_8;
    v48 = 5;
  }
  (*(void (**)(void))(*v47 + 8 * v48))();
LABEL_8:
  Trackable::~Trackable(a21);
  if (*(char *)(v46 - 137) < 0)
    operator delete(*(void **)(v46 - 160));
  JUMPOUT(0x1B656CFC0);
}

void sub_1B656CC28()
{
  JUMPOUT(0x1B656CFC0);
}

void sub_1B656CC30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void **a11)
{
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;

  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::~CircularBuffer(v13);
  v14 = *(_QWORD **)(v11 + 936);
  if (v14 == v12)
  {
    v15 = 4;
  }
  else
  {
    if (!v14)
    {
LABEL_6:
      Trackable::~Trackable(a11);
      JUMPOUT(0x1B656CFC8);
    }
    v15 = 5;
    v12 = *(_QWORD **)(v11 + 936);
  }
  (*(void (**)(_QWORD *))(*v12 + 8 * v15))(v12);
  goto LABEL_6;
}

void sub_1B656CC84()
{
  JUMPOUT(0x1B656CFD8);
}

void sub_1B656CC8C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a50 < 0)
    operator delete(__p);
  JUMPOUT(0x1B656CFE0);
}

void sub_1B656CCA4()
{
  JUMPOUT(0x1B656CFE0);
}

void sub_1B656CCAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;

  v45 = (void *)STACK[0xDD8];
  if (STACK[0xDD8])
  {
    STACK[0xDE0] = (unint64_t)v45;
    operator delete(v45);
  }
  v46 = (void *)STACK[0xDC0];
  if (STACK[0xDC0])
  {
    STACK[0xDC8] = (unint64_t)v46;
    operator delete(v46);
  }
  v47 = (void *)STACK[0xDA8];
  if (STACK[0xDA8])
  {
    STACK[0xDB0] = (unint64_t)v47;
    operator delete(v47);
  }
  v48 = (void *)STACK[0xD90];
  if (STACK[0xD90])
  {
    STACK[0xD98] = (unint64_t)v48;
    operator delete(v48);
  }
  v49 = (void *)STACK[0xD78];
  if (STACK[0xD78])
  {
    STACK[0xD80] = (unint64_t)v49;
    operator delete(v49);
  }
  if (SLOBYTE(STACK[0xD6F]) < 0)
    operator delete((void *)STACK[0xD58]);
  v50 = (void *)STACK[0xD30];
  if (STACK[0xD30])
  {
    STACK[0xD38] = (unint64_t)v50;
    operator delete(v50);
  }
  if (a45 < 0)
    operator delete(a40);
  JUMPOUT(0x1B656CF44);
}

void sub_1B656CD38()
{
  uint64_t v0;
  void **v1;
  void **v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v3 = *(void **)(v0 + 888);
  if (v3)
  {
    *(_QWORD *)(v0 + 896) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(v0 + 864);
  if (v4)
  {
    *(_QWORD *)(v0 + 872) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(v0 + 840);
  if (v5)
  {
    *(_QWORD *)(v0 + 848) = v5;
    operator delete(v5);
  }
  v6 = *(void **)(v0 + 816);
  if (v6)
  {
    *(_QWORD *)(v0 + 824) = v6;
    operator delete(v6);
  }
  v7 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v0 + 800) = v7;
    operator delete(v7);
  }
  if (*(char *)(v0 + 783) < 0)
    operator delete(*v1);
  v8 = *(void **)(v0 + 720);
  if (v8)
  {
    *(_QWORD *)(v0 + 728) = v8;
    operator delete(v8);
  }
  JUMPOUT(0x1B656CFC8);
}

void sub_1B656CDB4()
{
  JUMPOUT(0x1B656CEE8);
}

void sub_1B656CDBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;

  v45 = (void *)STACK[0x9D8];
  if (STACK[0x9D8])
  {
    STACK[0x9E0] = (unint64_t)v45;
    operator delete(v45);
  }
  v46 = (void *)STACK[0x9C0];
  if (STACK[0x9C0])
  {
    STACK[0x9C8] = (unint64_t)v46;
    operator delete(v46);
  }
  v47 = (void *)STACK[0x9A8];
  if (STACK[0x9A8])
  {
    STACK[0x9B0] = (unint64_t)v47;
    operator delete(v47);
  }
  v48 = (void *)STACK[0x990];
  if (STACK[0x990])
  {
    STACK[0x998] = (unint64_t)v48;
    operator delete(v48);
  }
  v49 = (void *)STACK[0x978];
  if (STACK[0x978])
  {
    STACK[0x980] = (unint64_t)v49;
    operator delete(v49);
  }
  if (SLOBYTE(STACK[0x96F]) < 0)
    operator delete((void *)STACK[0x958]);
  v50 = (void *)STACK[0x930];
  if (STACK[0x930])
  {
    STACK[0x938] = (unint64_t)v50;
    operator delete(v50);
  }
  if (a45 < 0)
    operator delete(a40);
  JUMPOUT(0x1B656CF5CLL);
}

void sub_1B656CE44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  void *a64;
  void *a67;
  void *a70;
  void *__p;

  if (__p)
    operator delete(__p);
  if (a70)
    operator delete(a70);
  if (a67)
    operator delete(a67);
  if (a64)
    operator delete(a64);
  if (a61)
    operator delete(a61);
  if (a59 < 0)
    operator delete(a54);
  if (a49)
    operator delete(a49);
  JUMPOUT(0x1B656CF90);
}

void sub_1B656CEC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void **a40)
{
  a40 = (void **)&a29;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a40);
  JUMPOUT(0x1B656CED8);
}

void sub_1B656CEF4()
{
  JUMPOUT(0x1B656CEFCLL);
}

void sub_1B656CF10(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x1B656CFE8);
}

void sub_1B656CF20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  *(_QWORD *)(v29 - 160) = &a29;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v29 - 160));
  JUMPOUT(0x1B656CFB0);
}

_QWORD *NoiseSuppression::SNR::Post<float,(LogTypes)0>::Post(_QWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  size_t v10;
  void **v11;
  const void *v12;
  void *__p[2];
  char v15;

  v9 = (uint64_t)(a1 + 44);
  *a1 = &off_1E69EBAB8;
  *(_QWORD *)AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>,std::vector<float>>((uint64_t)a1, (__int128 *)a2, (uint64_t)NoiseSuppression::SNR::Post<float,(LogTypes)0>::ComputePost, a4, (uint64_t)(a1 + 44)) = &off_1E69EBAB8;
  if (*(char *)(a2 + 23) >= 0)
    v10 = *(unsigned __int8 *)(a2 + 23);
  else
    v10 = *(_QWORD *)(a2 + 8);
  v11 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v10 + 9);
  if (v15 < 0)
    v11 = (void **)__p[0];
  if (v10)
  {
    if (*(char *)(a2 + 23) >= 0)
      v12 = (const void *)a2;
    else
      v12 = *(const void **)a2;
    memmove(v11, v12, v10);
  }
  strcpy((char *)v11 + v10, "_noiseReg");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>>(v9, (__int128 *)__p, (uint64_t)NoiseSuppression::SNR::Post<float,(LogTypes)0>::ComputeNoiseReg, a5);
  if (v15 < 0)
    operator delete(__p[0]);
  LODWORD(__p[0]) = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>((uint64_t)a1, a3, __p);
  LODWORD(__p[0]) = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>(v9, a3, __p);
  return a1;
}

void sub_1B656D124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v14;
  uint64_t v15;

  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v15);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v14);
  _Unwind_Resume(a1);
}

uint64_t NoiseSuppression::SNR::Prior<float,(LogTypes)0>::Prior(uint64_t a1, __int128 *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  std::string *v9;
  __int128 v10;
  void **v11;
  _QWORD *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  unint64_t v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 *v32;
  __int128 *p_p;
  uint64_t v34;
  size_t v35;
  __int128 *v36;
  const std::string::value_type *v37;
  size_t v38;
  __int128 *v39;
  const std::string::value_type *v40;
  size_t v41;
  __int128 *v42;
  const std::string::value_type *v43;
  __int128 __p;
  uint64_t v49;
  __int128 *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  v9 = (std::string *)(a1 + 72);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v10 = *a2;
    v9->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
  *(_OWORD *)(a1 + 104) = 0u;
  *(_BYTE *)(a1 + 96) = 0;
  v11 = (void **)(a1 + 128);
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  v12 = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(1uLL);
  v14 = (char *)&v12[v13];
  *v12 = a1 + 704;
  v15 = (char *)(v12 + 1);
  v17 = *(char **)(a1 + 128);
  v16 = *(char **)(a1 + 136);
  v18 = v12;
  if (v16 != v17)
  {
    do
    {
      v19 = *((_QWORD *)v16 - 1);
      v16 -= 8;
      *--v18 = v19;
    }
    while (v16 != v17);
    v16 = (char *)*v11;
  }
  v20 = a1 + 1056;
  *(_QWORD *)(a1 + 128) = v18;
  *(_QWORD *)(a1 + 136) = v15;
  *(_QWORD *)(a1 + 144) = v14;
  if (v16)
  {
    operator delete(v16);
    v14 = *(char **)(a1 + 144);
  }
  *(_QWORD *)(a1 + 136) = v15;
  if (v15 >= v14)
  {
    v22 = (v15 - (_BYTE *)*v11) >> 3;
    if ((unint64_t)(v22 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v23 = v14 - (_BYTE *)*v11;
    v24 = v23 >> 2;
    if (v23 >> 2 <= (unint64_t)(v22 + 1))
      v24 = v22 + 1;
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
      v25 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v25 = v24;
    if (v25)
      v25 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v25);
    else
      v26 = 0;
    v27 = (uint64_t *)(v25 + 8 * v22);
    v28 = v25 + 8 * v26;
    *v27 = v20;
    v21 = v27 + 1;
    v30 = *(char **)(a1 + 128);
    v29 = *(char **)(a1 + 136);
    if (v29 != v30)
    {
      do
      {
        v31 = *((_QWORD *)v29 - 1);
        v29 -= 8;
        *--v27 = v31;
      }
      while (v29 != v30);
      v29 = (char *)*v11;
    }
    *(_QWORD *)(a1 + 128) = v27;
    *(_QWORD *)(a1 + 136) = v21;
    *(_QWORD *)(a1 + 144) = v28;
    if (v29)
      operator delete(v29);
  }
  else
  {
    v12[1] = v20;
    v21 = v12 + 2;
  }
  *(_QWORD *)(a1 + 136) = v21;
  Trackable::BuildDepsList<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<float,(LogTypes)0>>((void **)(a1 + 128), a4, a1 + 352);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E69EB4C0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  __p = 0uLL;
  v49 = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer((_QWORD *)(a1 + 280), 1uLL, (uint64_t)&__p);
  *(_QWORD *)(a1 + 344) = 0;
  v32 = (__int128 *)operator new(0x30uLL);
  *(_QWORD *)v32 = &off_1E69EBB88;
  *((_QWORD *)v32 + 1) = NoiseSuppression::SNR::Prior<float,(LogTypes)0>::ComputePrior;
  *((_QWORD *)v32 + 2) = a1 + 704;
  *((_QWORD *)v32 + 3) = v20;
  *((_QWORD *)v32 + 4) = a4;
  *((_QWORD *)v32 + 5) = a1 + 352;
  v50 = v32;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](&__p, (_QWORD *)(a1 + 224));
  p_p = v50;
  if (v50 == &__p)
  {
    v34 = 4;
    p_p = &__p;
  }
  else
  {
    if (!v50)
      goto LABEL_30;
    v34 = 5;
  }
  (*(void (**)(__int128 *))(*(_QWORD *)p_p + 8 * v34))(p_p);
LABEL_30:
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)a1 = &off_1E69EBB68;
  if (*((char *)a2 + 23) >= 0)
    v35 = *((unsigned __int8 *)a2 + 23);
  else
    v35 = *((_QWORD *)a2 + 1);
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v35 + 9);
  if (v49 >= 0)
    v36 = &__p;
  else
    v36 = (__int128 *)__p;
  if (v35)
  {
    if (*((char *)a2 + 23) >= 0)
      v37 = (const std::string::value_type *)a2;
    else
      v37 = *(const std::string::value_type **)a2;
    memmove(v36, v37, v35);
  }
  strcpy((char *)v36 + v35, "_noiseReg");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>>(a1 + 352, &__p, (uint64_t)NoiseSuppression::SNR::Prior<float,(LogTypes)0>::ComputeNoiseReg, a5);
  if (SHIBYTE(v49) < 0)
    operator delete((void *)__p);
  if (*((char *)a2 + 23) >= 0)
    v38 = *((unsigned __int8 *)a2 + 23);
  else
    v38 = *((_QWORD *)a2 + 1);
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v38 + 6);
  if (v49 >= 0)
    v39 = &__p;
  else
    v39 = (__int128 *)__p;
  if (v38)
  {
    if (*((char *)a2 + 23) >= 0)
      v40 = (const std::string::value_type *)a2;
    else
      v40 = *(const std::string::value_type **)a2;
    memmove(v39, v40, v38);
  }
  strcpy((char *)v39 + v38, "_gamma");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>,std::vector<float>>(a1 + 704, &__p, (uint64_t)NoiseSuppression::SNR::Prior<float,(LogTypes)0>::ComputeGamma, a4, a1 + 352);
  if (SHIBYTE(v49) < 0)
    operator delete((void *)__p);
  if (*((char *)a2 + 23) >= 0)
    v41 = *((unsigned __int8 *)a2 + 23);
  else
    v41 = *((_QWORD *)a2 + 1);
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v41 + 12);
  if (v49 >= 0)
    v42 = &__p;
  else
    v42 = (__int128 *)__p;
  if (v41)
  {
    if (*((char *)a2 + 23) >= 0)
      v43 = (const std::string::value_type *)a2;
    else
      v43 = *(const std::string::value_type **)a2;
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "_postClipped");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>>(a1 + 1056, &__p, (uint64_t)NoiseSuppression::SNR::Prior<float,(LogTypes)0>::MaxXAgainstZero, a6);
  if (SHIBYTE(v49) < 0)
    operator delete((void *)__p);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(a1, a3);
  LODWORD(__p) = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>(a1 + 352, a3, &__p);
  LODWORD(__p) = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>(a1 + 704, a3, &__p);
  LODWORD(__p) = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>(a1 + 1056, a3, &__p);
  return a1;
}

void sub_1B656D658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v19;
  void **v20;
  void *v22;

  v22 = *v20;
  if (*v20)
  {
    *(_QWORD *)(v19 + 40) = v22;
    operator delete(v22);
  }
  _Unwind_Resume(exception_object);
}

void AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v4;
  _QWORD *v5;
  void *v6;
  void *v7[3];
  __int128 v8;
  void *__p[2];
  uint64_t v10;
  _QWORD v11[3];

  v4 = *(_QWORD *)(a1 + 344) + 1;
  std::vector<float>::vector(v7, a2, a3);
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(&v8, v4, (uint64_t)v7);
  *(_OWORD *)(a1 + 280) = v8;
  v5 = (_QWORD *)(a1 + 296);
  v6 = *(void **)(a1 + 296);
  if (v6)
  {
    *(_QWORD *)(a1 + 304) = v6;
    operator delete(v6);
    *v5 = 0;
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 312) = 0;
  }
  *(_OWORD *)v5 = *(_OWORD *)__p;
  *(_QWORD *)(a1 + 312) = v10;
  __p[1] = 0;
  v10 = 0;
  __p[0] = 0;
  if (&v8 != (__int128 *)(a1 + 280))
    boost::container::vector<std::vector<float>,void,void>::priv_move_assign<void>(a1 + 320, v11);
  boost::container::vector<std::vector<float>,void,void>::~vector(v11);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v7[0])
  {
    v7[1] = v7[0];
    operator delete(v7[0]);
  }
}

void sub_1B656D89C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<int,float>(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v4;
  _QWORD *v5;
  void *v6;
  void *v7[3];
  __int128 v8;
  void *__p[2];
  uint64_t v10;
  _QWORD v11[3];

  v4 = *(_QWORD *)(a1 + 344) + 1;
  std::vector<float>::vector(v7, a2, a3);
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(&v8, v4, (uint64_t)v7);
  *(_OWORD *)(a1 + 280) = v8;
  v5 = (_QWORD *)(a1 + 296);
  v6 = *(void **)(a1 + 296);
  if (v6)
  {
    *(_QWORD *)(a1 + 304) = v6;
    operator delete(v6);
    *v5 = 0;
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 312) = 0;
  }
  *(_OWORD *)v5 = *(_OWORD *)__p;
  *(_QWORD *)(a1 + 312) = v10;
  __p[1] = 0;
  v10 = 0;
  __p[0] = 0;
  if (&v8 != (__int128 *)(a1 + 280))
    boost::container::vector<std::vector<float>,void,void>::priv_move_assign<void>(a1 + 320, v11);
  boost::container::vector<std::vector<float>,void,void>::~vector(v11);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v7[0])
  {
    v7[1] = v7[0];
    operator delete(v7[0]);
  }
}

void sub_1B656D994(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Dereverb::FirstPass<float,(Dereverb::FirstPassTypes)0,(LogTypes)0>::~FirstPass(uint64_t a1)
{
  void *v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector((_QWORD *)(a1 + 360));
  v2 = *(void **)(a1 + 336);
  if (v2)
  {
    *(_QWORD *)(a1 + 344) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 312);
  if (v3)
  {
    *(_QWORD *)(a1 + 320) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 248);
  if (v4 == (_QWORD *)(a1 + 224))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 224);
    goto LABEL_9;
  }
  if (v4)
  {
    v5 = 5;
LABEL_9:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  void *v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector((_QWORD *)(a1 + 360));
  v2 = *(void **)(a1 + 336);
  if (v2)
  {
    *(_QWORD *)(a1 + 344) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 312);
  if (v3)
  {
    *(_QWORD *)(a1 + 320) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 248);
  if (v4 == (_QWORD *)(a1 + 224))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 224);
  }
  else
  {
    if (!v4)
    {
LABEL_10:
      Trackable::~Trackable((void **)a1);
      JUMPOUT(0x1BCC95CECLL);
    }
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
  goto LABEL_10;
}

void SpectralMagnitude<float,(LogTypes)0>::~SpectralMagnitude(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v2 = *(void **)(a1 + 296);
  if (v2)
  {
    *(_QWORD *)(a1 + 304) = v2;
    operator delete(v2);
  }
  v3 = *(_QWORD **)(a1 + 248);
  if (v3 == (_QWORD *)(a1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 224);
    goto LABEL_7;
  }
  if (v3)
  {
    v4 = 5;
LABEL_7:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v2 = *(void **)(a1 + 296);
  if (v2)
  {
    *(_QWORD *)(a1 + 304) = v2;
    operator delete(v2);
  }
  v3 = *(_QWORD **)(a1 + 248);
  if (v3 == (_QWORD *)(a1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 224);
  }
  else
  {
    if (!v3)
    {
LABEL_8:
      Trackable::~Trackable((void **)a1);
      JUMPOUT(0x1BCC95CECLL);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_8;
}

void TCToCoef<float,(LogTypes)0>::~TCToCoef(void **this)
{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB300;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
    goto LABEL_7;
  }
  if (v2)
  {
    v3 = 5;
LABEL_7:
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
  Trackable::~Trackable(this);
}

{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB300;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
  }
  else
  {
    if (!v2)
    {
LABEL_8:
      Trackable::~Trackable(this);
      JUMPOUT(0x1BCC95CECLL);
    }
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  goto LABEL_8;
}

void dBToLinear<float,(LogTypes)0>::~dBToLinear(void **this)
{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB300;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
    goto LABEL_7;
  }
  if (v2)
  {
    v3 = 5;
LABEL_7:
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
  Trackable::~Trackable(this);
}

{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB300;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
  }
  else
  {
    if (!v2)
    {
LABEL_8:
      Trackable::~Trackable(this);
      JUMPOUT(0x1BCC95CECLL);
    }
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  goto LABEL_8;
}

_QWORD *AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(_QWORD *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  const char *v6;
  char *v7;
  uint64_t v8;
  char *v9;

  v4 = a2;
  *a1 = 0;
  a1[1] = a2;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1 + 2, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
  a1[5] = 0;
  a1[6] = v4;
  a1[7] = 0;
  if (v4)
  {
    if (v4 >= 0x555555555555556)
      boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v6);
    v7 = (char *)operator new(24 * v4);
    v8 = 0;
    a1[5] = v7;
    a1[7] = v4;
    do
    {
      v9 = &v7[v8];
      *(_QWORD *)v9 = 0;
      *((_QWORD *)v9 + 1) = 0;
      *((_QWORD *)v9 + 2) = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v7[v8], *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
      v8 += 24;
      --v4;
    }
    while (v4);
  }
  return a1;
}

void sub_1B656DCCC()
{
  __break(1u);
}

void sub_1B656DD0C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  __cxa_end_catch();
  if (*(_QWORD *)(v1 + 56))
    operator delete(*(void **)(v1 + 40));
  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

__n128 boost::container::vector<std::vector<float>,void,void>::priv_move_assign<void>(uint64_t a1, _QWORD *a2)
{
  __n128 result;

  if ((_QWORD *)a1 == a2 && a2[1])
    __assert_rtn("priv_move_assign", "vector.hpp", 2480, "this != &x || x.size() == 0");
  boost::container::vector<std::vector<float>,void,void>::priv_destroy_all((_QWORD *)a1);
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  *(_QWORD *)a1 = *a2;
  result = *(__n128 *)(a2 + 1);
  *(__n128 *)(a1 + 8) = result;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

void boost::container::vector<std::vector<float>,void,void>::priv_destroy_all(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  void *v4;

  v2 = a1[1];
  if (v2)
  {
    v3 = (_QWORD *)(*a1 + 8);
    do
    {
      v4 = (void *)*(v3 - 1);
      if (v4)
      {
        *v3 = v4;
        operator delete(v4);
      }
      v3 += 3;
      --v2;
    }
    while (v2);
  }
  a1[1] = 0;
}

uint64_t NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::SmoothGain2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  float v6;
  uint64_t v7;
  float __B;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = *(float *)AutoValue<float,(LogTypes)0>::Get(a3);
  __B = v6;
  v7 = *(_QWORD *)(v5 + 8);
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 != v7 - *(_QWORD *)v5)
    __assert_rtn("SmoothVector", "VectorUtils.h", 912, "result.size() == input.size()");
  if (v5 == a1)
    __assert_rtn("SmoothVector", "VectorUtils.h", 913, "&result != &input");
  MultiplyVectorScalar<float>(a1, *(const float **)v5, v7, (float)(v6 * -2.0) + 1.0);
  vDSP_vsma((const float *)(*(_QWORD *)v5 + 4), 1, &__B, *(const float **)a1, 1, *(float **)a1, 1, ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2) - 1);
  vDSP_vsma(*(const float **)v5, 1, &__B, (const float *)(*(_QWORD *)a1 + 4), 1, (float *)(*(_QWORD *)a1 + 4), 1, ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2) - 1);
  return a1;
}

uint64_t AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue&<float,(LogTypes)0>),std::vector<float>,float>(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 72), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v9 = *a2;
    *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 72) = v9;
  }
  *(_OWORD *)(a1 + 104) = 0u;
  *(_BYTE *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  Trackable::BuildDepsList<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<float,(LogTypes)0>>((void **)(a1 + 128), a4, a5);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E69EB4C0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  memset(v14, 0, sizeof(v14));
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer((_QWORD *)(a1 + 280), 1uLL, (uint64_t)v14);
  *(_QWORD *)(a1 + 344) = 0;
  v10 = operator new(0x20uLL);
  *v10 = &off_1E69EB750;
  v10[1] = a3;
  v10[2] = a4;
  v10[3] = a5;
  v15 = v10;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](v14, (_QWORD *)(a1 + 224));
  v11 = v15;
  if (v15 == v14)
  {
    v12 = 4;
    v11 = v14;
    goto LABEL_8;
  }
  if (v15)
  {
    v12 = 5;
LABEL_8:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B656E0DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 40) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *NoiseSuppression::Gain::Gain<float,(LogTypes)0>::Gain(_QWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  void **v13;
  const void *v14;
  size_t v15;
  void **v16;
  const void *v17;
  size_t v18;
  void **v19;
  const void *v20;
  void *__p[2];
  char v23;

  v10 = (uint64_t)(a1 + 132);
  *a1 = &off_1E69EBCE8;
  v11 = (uint64_t)(a1 + 88);
  *(_QWORD *)AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>,std::vector<float>>((uint64_t)a1, (__int128 *)a2, (uint64_t)NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeEMGain, (uint64_t)(a1 + 132), (uint64_t)(a1 + 88)) = &off_1E69EBCE8;
  if (*(char *)(a2 + 23) >= 0)
    v12 = *(unsigned __int8 *)(a2 + 23);
  else
    v12 = *(_QWORD *)(a2 + 8);
  v13 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v12 + 6);
  if (v23 < 0)
    v13 = (void **)__p[0];
  if (v12)
  {
    if (*(char *)(a2 + 23) >= 0)
      v14 = (const void *)a2;
    else
      v14 = *(const void **)a2;
    memmove(v13, v14, v12);
  }
  strcpy((char *)v13 + v12, "_theta");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>,std::vector<float>>((uint64_t)(a1 + 44), (__int128 *)__p, (uint64_t)NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeTheta, v10, a5);
  if (v23 < 0)
    operator delete(__p[0]);
  if (*(char *)(a2 + 23) >= 0)
    v15 = *(unsigned __int8 *)(a2 + 23);
  else
    v15 = *(_QWORD *)(a2 + 8);
  v16 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v15 + 3);
  if (v23 < 0)
    v16 = (void **)__p[0];
  if (v15)
  {
    if (*(char *)(a2 + 23) >= 0)
      v17 = (const void *)a2;
    else
      v17 = *(const void **)a2;
    memmove(v16, v17, v15);
  }
  *(_DWORD *)((char *)v16 + v15) = 5066079;
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>>(v11, (__int128 *)__p, (uint64_t)NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeHypergeometricGain, (uint64_t)(a1 + 44));
  if (v23 < 0)
    operator delete(__p[0]);
  if (*(char *)(a2 + 23) >= 0)
    v18 = *(unsigned __int8 *)(a2 + 23);
  else
    v18 = *(_QWORD *)(a2 + 8);
  v19 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v18 + 11);
  if (v23 < 0)
    v19 = (void **)__p[0];
  if (v18)
  {
    if (*(char *)(a2 + 23) >= 0)
      v20 = (const void *)a2;
    else
      v20 = *(const void **)a2;
    memmove(v19, v20, v18);
  }
  strcpy((char *)v19 + v18, "_priorRatio");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>>(v10, (__int128 *)__p, (uint64_t)NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputePriorRatio, a4);
  if (v23 < 0)
    operator delete(__p[0]);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v11, a3);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>((uint64_t)(a1 + 44), a3);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(v10, a3);
  a1[43] = 1;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>((uint64_t)a1, a3);
  return a1;
}

void sub_1B656E440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a14 < 0)
    operator delete(__p);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v16);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v15);
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v14);
  _Unwind_Resume(a1);
}

float **NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::ComputeGainNoClip(float **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  float **v6;
  float *v7;
  float *v8;
  unint64_t v9;
  float *v10;
  float v11;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v6 = (float **)AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  MultiplyVectorScalar<float>((uint64_t)a1, *(const float **)v5, *(_QWORD *)(v5 + 8), 3.0);
  v7 = *a1;
  v8 = a1[1];
  v9 = v8 - *a1;
  v10 = *v6;
  if (v9 != v6[1] - *v6)
    __assert_rtn("MinVectorVector", "VectorUtils.h", 666, "result.size() == b.size()");
  if (v8 != v7)
  {
    if (v9 <= 1)
      v9 = 1;
    do
    {
      v11 = *v10++;
      *v7 = fminf(*v7, v11);
      ++v7;
      --v9;
    }
    while (v9);
  }
  return a1;
}

uint64_t AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>,std::vector<float>>(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v9 = (_QWORD *)Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<std::vector<float>,(LogTypes)0>>(a1, a2, a4, a5);
  *v9 = &off_1E69EB4C0;
  v9[31] = 0;
  v10 = v9 + 28;
  v9[32] = 0;
  memset(v15, 0, sizeof(v15));
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v9 + 35, 1uLL, (uint64_t)v15);
  *(_QWORD *)(a1 + 344) = 0;
  v11 = operator new(0x20uLL);
  *v11 = &off_1E69EBAD8;
  v11[1] = a3;
  v11[2] = a4;
  v11[3] = a5;
  v16 = v11;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](v15, v10);
  v12 = v16;
  if (v16 == v15)
  {
    v13 = 4;
    v12 = v15;
    goto LABEL_5;
  }
  if (v16)
  {
    v13 = 5;
LABEL_5:
    (*(void (**)(void))(*v12 + 8 * v13))();
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B656E6B0(_Unwind_Exception *a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v6;

  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::~CircularBuffer(v3);
  if ((_QWORD *)*v4 == v2)
  {
    v6 = 4;
  }
  else
  {
    if (!*v4)
      goto LABEL_6;
    v6 = 5;
    v2 = (_QWORD *)*v4;
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v6))(v2);
LABEL_6:
  Trackable::~Trackable(v1);
  _Unwind_Resume(a1);
}

float **NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::ComputeSqrtGain(float **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  float *v6;
  float *v7;
  int v9;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = (float *)AutoValue<float,(LogTypes)0>::Get(a3);
  MaxVectorScalar<float>((uint64_t)a1, *(const float **)v5, *(_QWORD *)(v5 + 8), *v6);
  v7 = *a1;
  v9 = (unint64_t)((char *)a1[1] - (char *)*a1) >> 2;
  vvsqrtf(v7, v7, &v9);
  return a1;
}

uint64_t NoiseSuppression::Gain::GainRule<float,(LogTypes)0>::ComputeGain2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  float v9;
  uint64_t v10;
  uint64_t v11;

  v7 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v8 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v9 = sqrtf(*(float *)AutoValue<float,(LogTypes)0>::Get(a4));
  v10 = AddMultiplyVectorScalarScalar<float>(a1, *(const float **)v8, *(_QWORD *)(v8 + 8), -v9, v9);
  v11 = AddMultiplyVectorVectorVector<float>(v10, *(const float **)v8, *(_QWORD *)(v8 + 8), *(const float **)v7, *(_QWORD *)(v7 + 8), *(const float **)a1, *(_QWORD *)(a1 + 8));
  return SquareVector<float>(v11, *(const float **)a1, *(_QWORD *)(a1 + 8));
}

_QWORD *Filterbank::ToLinear<float,(LogTypes)0>::ToLinear(_QWORD *a1, __int128 *a2, std::vector<int>::size_type a3, uint64_t a4, float a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20[2];
  uint64_t v21;
  void *v22[2];
  uint64_t v23;
  void *v24[2];
  uint64_t v25;
  void *v26[2];
  uint64_t v27;
  void *v28[2];
  uint64_t v29;
  void *v30[2];
  uint64_t v31;
  void *__p[2];
  uint64_t v33;
  uint64_t *(*v34)(uint64_t *, uint64_t, uint64_t *);
  __int128 v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  __int128 v45;
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  Filterbank::BarkCore<float>::BarkCore((uint64_t *)v20, a3, 0x18uLL, a5);
  v19 = v20[0];
  v35 = *(_OWORD *)v20;
  v34 = Filterbank::ToLinear<float,(LogTypes)0>::ComputeLinear_curry;
  v36 = v21;
  v20[0] = 0;
  v20[1] = 0;
  v18 = v22[0];
  v37 = *(_OWORD *)v22;
  v9 = v23;
  v21 = 0;
  v22[0] = 0;
  v22[1] = 0;
  v23 = 0;
  v17 = v24[0];
  v39 = *(_OWORD *)v24;
  v38 = v9;
  v40 = v25;
  v24[0] = 0;
  v24[1] = 0;
  v16 = v26[0];
  v41 = *(_OWORD *)v26;
  v10 = v27;
  v25 = 0;
  v26[0] = 0;
  v26[1] = 0;
  v27 = 0;
  v15 = v28[0];
  v43 = *(_OWORD *)v28;
  v42 = v10;
  v44 = v29;
  v28[0] = 0;
  v28[1] = 0;
  v14 = v30[0];
  v45 = *(_OWORD *)v30;
  v11 = v31;
  v29 = 0;
  v30[0] = 0;
  v30[1] = 0;
  v31 = 0;
  v13 = __p[0];
  v47 = *(_OWORD *)__p;
  v46 = v11;
  v48 = v33;
  __p[0] = 0;
  __p[1] = 0;
  v33 = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>>,std::vector<float>>((uint64_t)a1, a2, (uint64_t *)&v34, a4);
  if (v13)
    operator delete(v13);
  if (v14)
    operator delete(v14);
  if (v15)
    operator delete(v15);
  if (v16)
    operator delete(v16);
  if (v17)
    operator delete(v17);
  if (v18)
    operator delete(v18);
  if (v19)
    operator delete(v19);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v30[0])
  {
    v30[1] = v30[0];
    operator delete(v30[0]);
  }
  if (v28[0])
  {
    v28[1] = v28[0];
    operator delete(v28[0]);
  }
  if (v26[0])
  {
    v26[1] = v26[0];
    operator delete(v26[0]);
  }
  if (v24[0])
  {
    v24[1] = v24[0];
    operator delete(v24[0]);
  }
  if (v22[0])
  {
    v22[1] = v22[0];
    operator delete(v22[0]);
  }
  if (v20[0])
  {
    v20[1] = v20[0];
    operator delete(v20[0]);
  }
  *a1 = &off_1E69EBD50;
  LODWORD(v34) = 0;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>((uint64_t)a1, a3, &v34);
  return a1;
}

void sub_1B656EA50(_Unwind_Exception *a1)
{
  uint64_t v1;

  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue(v1);
  _Unwind_Resume(a1);
}

void AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  _QWORD *v4;
  void *v5;
  void *v6[3];
  __int128 v7;
  void *__p[2];
  uint64_t v9;
  _QWORD v10[3];

  v3 = *(_QWORD *)(a1 + 344) + 1;
  std::vector<float>::vector(v6, a2);
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(&v7, v3, (uint64_t)v6);
  *(_OWORD *)(a1 + 280) = v7;
  v4 = (_QWORD *)(a1 + 296);
  v5 = *(void **)(a1 + 296);
  if (v5)
  {
    *(_QWORD *)(a1 + 304) = v5;
    operator delete(v5);
    *v4 = 0;
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 312) = 0;
  }
  *(_OWORD *)v4 = *(_OWORD *)__p;
  *(_QWORD *)(a1 + 312) = v9;
  __p[1] = 0;
  v9 = 0;
  __p[0] = 0;
  if (&v7 != (__int128 *)(a1 + 280))
    boost::container::vector<std::vector<float>,void,void>::priv_move_assign<void>(a1 + 320, v10);
  boost::container::vector<std::vector<float>,void,void>::~vector(v10);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_1B656EB54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Filterbank::ToLinear<float,(LogTypes)0>::~ToLinear(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v2 = *(void **)(a1 + 296);
  if (v2)
  {
    *(_QWORD *)(a1 + 304) = v2;
    operator delete(v2);
  }
  v3 = *(_QWORD **)(a1 + 248);
  if (v3 == (_QWORD *)(a1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 224);
    goto LABEL_7;
  }
  if (v3)
  {
    v4 = 5;
LABEL_7:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 320));
  v2 = *(void **)(a1 + 296);
  if (v2)
  {
    *(_QWORD *)(a1 + 304) = v2;
    operator delete(v2);
  }
  v3 = *(_QWORD **)(a1 + 248);
  if (v3 == (_QWORD *)(a1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 224);
  }
  else
  {
    if (!v3)
    {
LABEL_8:
      Trackable::~Trackable((void **)a1);
      JUMPOUT(0x1BCC95CECLL);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_8;
}

uint64_t *Filterbank::BarkCore<float>::BarkCore(uint64_t *a1, std::vector<int>::size_type a2, std::vector<int>::size_type a3, float a4)
{
  std::vector<int> *v8;
  const float **v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;
  float v14;
  float v15;
  int v16;
  float v17;
  float v18;
  float v19;
  int v20;
  float v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const float *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  float v40;
  std::vector<int>::value_type __x;

  __x = 0;
  v8 = std::vector<int>::vector((std::vector<int> *)a1, a2, &__x);
  __x = 0;
  std::vector<int>::vector(v8 + 1, a2, &__x);
  __x = 0;
  std::vector<float>::vector(a1 + 6, a2, &__x);
  __x = 0;
  std::vector<float>::vector(a1 + 9, a2, &__x);
  __x = 0;
  std::vector<int>::vector((std::vector<int> *)a1 + 4, a3, &__x);
  __x = 0;
  std::vector<int>::vector((std::vector<int> *)a1 + 5, a3, &__x);
  v9 = (const float **)(a1 + 18);
  __x = 0;
  std::vector<float>::vector(a1 + 18, a3, &__x);
  v10 = a4 * 0.5;
  v11 = atanf((float)(a4 * 0.5) * 0.00074);
  v12 = atanf((float)(v10 * v10) * 0.0000000185);
  if (a2)
  {
    v13 = 0;
    v40 = a4 / (float)(2 * a2);
    v14 = (float)((float)(v12 * 2.24) + (float)(v11 * 13.1)) + (float)(v10 * 0.0001);
    v15 = v14 / (float)(a3 - 1);
    v16 = a3 - 2;
    while (1)
    {
      v17 = v40 * (float)v13;
      v18 = atanf(v17 * 0.00074);
      v19 = (float)((float)(atanf((float)(v17 * v17) * 0.0000000185) * 2.24) + (float)(v18 * 13.1))
          + (float)(v17 * 0.0001);
      if (v19 > v14)
        break;
      v20 = vcvtms_s32_f32(v19 / v15);
      v21 = 1.0;
      v22 = v16;
      if (v16 >= v20)
      {
        v21 = (float)(v19 - (float)((float)v20 * v15)) / v15;
        v22 = v20;
      }
      v23 = *a1;
      *(_DWORD *)(*a1 + 4 * v13) = v22;
      v24 = v22 + 1;
      v25 = a1[3];
      *(_DWORD *)(v25 + 4 * v13) = v24;
      v26 = a1[6];
      *(float *)(v26 + 4 * v13) = 1.0 - v21;
      v27 = a1[9];
      *(float *)(v27 + 4 * v13++) = v21;
      if (a2 == v13)
        goto LABEL_10;
    }
    v23 = *a1;
    v25 = a1[3];
    v26 = a1[6];
    v27 = a1[9];
LABEL_10:
    v29 = 0;
    v28 = *v9;
    do
    {
      v30 = *(int *)(v25 + 4 * v29);
      v28[*(int *)(v23 + 4 * v29)] = *(float *)(v26 + 4 * v29) + v28[*(int *)(v23 + 4 * v29)];
      v28[v30] = *(float *)(v27 + 4 * v29++) + v28[v30];
    }
    while (a2 > v29);
  }
  else
  {
    v28 = *v9;
  }
  DivideScalarVector<float>((uint64_t)(a1 + 18), v28, a1[19]);
  if (a2)
  {
    v31 = 0;
    LODWORD(v32) = 0;
    v33 = 0;
    v34 = *a1;
    v35 = (a1[1] - *a1) >> 2;
    while (v35 != v31)
    {
      if (*(_DWORD *)(v34 + 4 * v31) == v33)
      {
        v36 = a1[15];
        if (v32 >= (unint64_t)((a1[16] - v36) >> 2))
          break;
        ++*(_DWORD *)(v36 + 4 * v32);
      }
      else
      {
        v32 = (v32 + 1);
        v37 = a1[12];
        if (v32 >= (a1[13] - v37) >> 2)
          break;
        *(_DWORD *)(v37 + 4 * v32) = v31;
        v38 = a1[15];
        if (v32 >= (a1[16] - v38) >> 2)
          break;
        ++v33;
        *(_DWORD *)(v38 + 4 * v32) = 1;
      }
      if (a2 == ++v31)
        return a1;
    }
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
  return a1;
}

void sub_1B656EF10(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void **v7;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  v9 = *v7;
  if (*v7)
  {
    *(_QWORD *)(v1 + 152) = v9;
    operator delete(v9);
  }
  v10 = *v6;
  if (*v6)
  {
    *(_QWORD *)(v1 + 128) = v10;
    operator delete(v10);
  }
  v11 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 104) = v11;
    operator delete(v11);
  }
  v12 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v12;
    operator delete(v12);
  }
  v13 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 56) = v13;
    operator delete(v13);
  }
  v14 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v14;
    operator delete(v14);
  }
  v15 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v15;
    operator delete(v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *Filterbank::ToLinear<float,(LogTypes)0>::ComputeLinear_curry(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float v16;

  v5 = (uint64_t *)AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = *a3;
  v7 = a3[1];
  v8 = (v7 - *a3) >> 2;
  v9 = *a1;
  if (v8 != (a1[1] - *a1) >> 2)
    __assert_rtn("ComputeLinear_curry", "BarkFilterbank.h", 138, "result.size() == frameSize");
  v10 = *v5;
  if (v5[1] - *v5 != 96)
    __assert_rtn("ComputeLinear_curry", "BarkFilterbank.h", 139, "barkIn.size() == 24");
  if (v7 != v6)
  {
    v11 = 0;
    v12 = a3[3];
    v13 = a3[6];
    v14 = a3[9];
    do
    {
      v15 = *(unsigned int *)(v12 + 4 * v11);
      v16 = *(float *)(v10 + 4 * *(unsigned int *)(v6 + 4 * v11)) * *(float *)(v13 + 4 * v11);
      *(float *)(v9 + 4 * v11) = v16;
      *(float *)(v9 + 4 * v11) = v16 + (float)(*(float *)(v10 + 4 * v15) * *(float *)(v14 + 4 * v11));
      ++v11;
    }
    while (v8 > v11);
  }
  return a1;
}

uint64_t AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>>,std::vector<float>>(uint64_t a1, __int128 *a2, uint64_t *a3, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  void *v34[2];
  uint64_t v35;
  void *v36[2];
  uint64_t v37;
  void *v38[2];
  uint64_t v39;
  void *v40[2];
  uint64_t v41;
  __int128 v42;
  uint64_t v43;
  void *v44[2];
  uint64_t v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __int128 v50;
  uint64_t v51;
  __int128 v52;
  uint64_t v53;
  __int128 v54;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  __int128 v60;
  uint64_t v61;
  __int128 __p;
  uint64_t v63;
  uint64_t v64;
  _QWORD v65[3];
  _QWORD *v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v7 = (_QWORD *)Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>>(a1, a2, a4);
  *v7 = &off_1E69EB4C0;
  v7[31] = 0;
  v31 = a1;
  v32 = v7 + 28;
  v7[32] = 0;
  v49 = 0;
  v50 = 0uLL;
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v7 + 35, 1uLL, (uint64_t)&v49);
  v8 = *a3;
  *(_QWORD *)(a1 + 344) = 0;
  v33 = v8;
  Filterbank::BarkCore<float>::BarkCore(v34, (uint64_t)(a3 + 1));
  v29 = *(_OWORD *)v34;
  v50 = *(_OWORD *)v34;
  v9 = v35;
  v48 = a4;
  v49 = v33;
  v51 = v35;
  v34[1] = 0;
  v35 = 0;
  v34[0] = 0;
  v28 = *(_OWORD *)v36;
  v52 = *(_OWORD *)v36;
  v10 = a4;
  v11 = v37;
  v36[0] = 0;
  v36[1] = 0;
  v27 = *(_OWORD *)v38;
  v54 = *(_OWORD *)v38;
  v12 = v39;
  v53 = v37;
  v55 = v39;
  v37 = 0;
  v38[0] = 0;
  v38[1] = 0;
  v39 = 0;
  v26 = *(_OWORD *)v40;
  v56 = *(_OWORD *)v40;
  v13 = v41;
  v40[0] = 0;
  v40[1] = 0;
  v25 = v42;
  v58 = v42;
  v14 = v43;
  v57 = v41;
  v59 = v43;
  v41 = 0;
  v42 = 0uLL;
  v43 = 0;
  v24 = *(_OWORD *)v44;
  v60 = *(_OWORD *)v44;
  v44[0] = 0;
  v44[1] = 0;
  v23 = v46;
  __p = v46;
  v15 = v45;
  v16 = v47;
  v61 = v45;
  v63 = v47;
  v45 = 0;
  v46 = 0uLL;
  v47 = 0;
  v30 = v10;
  v64 = v10;
  v17 = (char *)operator new(0xC0uLL);
  *(_QWORD *)v17 = &off_1E69EB680;
  *((_QWORD *)v17 + 1) = v33;
  *((_OWORD *)v17 + 1) = v29;
  *((_QWORD *)v17 + 4) = v9;
  v51 = 0;
  v50 = 0uLL;
  *(_OWORD *)(v17 + 40) = v28;
  *((_QWORD *)v17 + 7) = v11;
  v53 = 0;
  v52 = 0uLL;
  *((_OWORD *)v17 + 4) = v27;
  *((_QWORD *)v17 + 10) = v12;
  v55 = 0;
  v54 = 0uLL;
  *(_OWORD *)(v17 + 88) = v26;
  *((_QWORD *)v17 + 13) = v13;
  v56 = 0uLL;
  v57 = 0;
  *((_OWORD *)v17 + 7) = v25;
  *((_QWORD *)v17 + 16) = v14;
  v59 = 0;
  v58 = 0uLL;
  *(_OWORD *)(v17 + 136) = v24;
  *((_QWORD *)v17 + 19) = v15;
  v61 = 0;
  v60 = 0uLL;
  *((_OWORD *)v17 + 10) = v23;
  __p = 0uLL;
  v63 = 0;
  *((_QWORD *)v17 + 22) = v16;
  *((_QWORD *)v17 + 23) = v30;
  v66 = v17;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](v65, v32);
  v19 = v66;
  if (v66 == v65)
  {
    v21 = 4;
    v19 = v65;
    v20 = v31;
  }
  else
  {
    v20 = v31;
    if (!v66)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(_QWORD *, uint64_t))(*v19 + 8 * v21))(v19, v18);
LABEL_6:
  if ((_QWORD)__p)
    operator delete((void *)__p);
  if ((_QWORD)v60)
    operator delete((void *)v60);
  if ((_QWORD)v58)
    operator delete((void *)v58);
  if ((_QWORD)v56)
    operator delete((void *)v56);
  if ((_QWORD)v54)
    operator delete((void *)v54);
  if ((_QWORD)v52)
    operator delete((void *)v52);
  if ((_QWORD)v50)
    operator delete((void *)v50);
  if ((_QWORD)v46)
  {
    *((_QWORD *)&v46 + 1) = v46;
    operator delete((void *)v46);
  }
  if (v44[0])
  {
    v44[1] = v44[0];
    operator delete(v44[0]);
  }
  if ((_QWORD)v42)
  {
    *((_QWORD *)&v42 + 1) = v42;
    operator delete((void *)v42);
  }
  if (v40[0])
  {
    v40[1] = v40[0];
    operator delete(v40[0]);
  }
  if (v38[0])
  {
    v38[1] = v38[0];
    operator delete(v38[0]);
  }
  if (v36[0])
  {
    v36[1] = v36[0];
    operator delete(v36[0]);
  }
  if (v34[0])
  {
    v34[1] = v34[0];
    operator delete(v34[0]);
  }
  *(_DWORD *)(v20 + 8) = 0;
  *(_QWORD *)(v20 + 16) = 0;
  *(_QWORD *)(v20 + 264) = 0;
  *(_QWORD *)(v20 + 272) = 0;
  return v20;
}

void sub_1B656F444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _QWORD *a9, _QWORD *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void **a27,_QWORD *a28)
{
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;

  Filterbank::BarkCore<float>::~BarkCore(v28);
  Filterbank::BarkCore<float>::~BarkCore(v29);
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::~CircularBuffer(a9);
  if ((_QWORD *)*a10 == a28)
  {
    v31 = 4;
  }
  else
  {
    if (!*a10)
      goto LABEL_6;
    v31 = 5;
    a28 = (_QWORD *)*a10;
  }
  (*(void (**)(void))(*a28 + 8 * v31))();
LABEL_6:
  Trackable::~Trackable(a27);
  _Unwind_Resume(a1);
}

uint64_t Filterbank::BarkCore<float>::~BarkCore(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = *(void **)(a1 + 144);
  if (v2)
  {
    *(_QWORD *)(a1 + 152) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 120);
  if (v3)
  {
    *(_QWORD *)(a1 + 128) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 96);
  if (v4)
  {
    *(_QWORD *)(a1 + 104) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 72);
  if (v5)
  {
    *(_QWORD *)(a1 + 80) = v5;
    operator delete(v5);
  }
  v6 = *(void **)(a1 + 48);
  if (v6)
  {
    *(_QWORD *)(a1 + 56) = v6;
    operator delete(v6);
  }
  v7 = *(void **)(a1 + 24);
  if (v7)
  {
    *(_QWORD *)(a1 + 32) = v7;
    operator delete(v7);
  }
  v8 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v8;
    operator delete(v8);
  }
  return a1;
}

uint64_t Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>>(uint64_t a1, __int128 *a2, uint64_t a3)
{
  __int128 v5;
  _QWORD *v6;

  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 72), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 72) = v5;
  }
  *(_BYTE *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  v6 = operator new(8uLL);
  *v6 = a3;
  *(_QWORD *)(a1 + 128) = v6;
  *(_QWORD *)(a1 + 136) = v6 + 1;
  *(_QWORD *)(a1 + 144) = v6 + 1;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void sub_1B656F694(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 40) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *Filterbank::BarkCore<float>::BarkCore(_QWORD *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(a1, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(a1 + 3, *(const void **)(a2 + 24), *(_QWORD *)(a2 + 32), (uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 2);
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1 + 6, *(const void **)(a2 + 48), *(_QWORD *)(a2 + 56), (uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 2);
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1 + 9, *(const void **)(a2 + 72), *(_QWORD *)(a2 + 80), (uint64_t)(*(_QWORD *)(a2 + 80) - *(_QWORD *)(a2 + 72)) >> 2);
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(a1 + 12, *(const void **)(a2 + 96), *(_QWORD *)(a2 + 104), (uint64_t)(*(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96)) >> 2);
  a1[15] = 0;
  a1[16] = 0;
  a1[17] = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(a1 + 15, *(const void **)(a2 + 120), *(_QWORD *)(a2 + 128), (uint64_t)(*(_QWORD *)(a2 + 128) - *(_QWORD *)(a2 + 120)) >> 2);
  a1[18] = 0;
  a1[19] = 0;
  a1[20] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1 + 18, *(const void **)(a2 + 144), *(_QWORD *)(a2 + 152), (uint64_t)(*(_QWORD *)(a2 + 152) - *(_QWORD *)(a2 + 144)) >> 2);
  return a1;
}

void sub_1B656F7DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v8 = *v6;
  if (*v6)
  {
    *(_QWORD *)(v1 + 128) = v8;
    operator delete(v8);
  }
  v9 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 104) = v9;
    operator delete(v9);
  }
  v10 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v10;
    operator delete(v10);
  }
  v11 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 56) = v11;
    operator delete(v11);
  }
  v12 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v12;
    operator delete(v12);
  }
  v13 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::~CircularBuffer(_QWORD *a1)
{
  void *v2;

  boost::container::vector<std::vector<float>,void,void>::~vector(a1 + 5);
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

_QWORD *std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1B656FA10(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E69EB680;
  Filterbank::BarkCore<float>::~BarkCore((uint64_t)(a1 + 2));
  return a1;
}

void std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E69EB680;
  Filterbank::BarkCore<float>::~BarkCore((uint64_t)(a1 + 2));
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0xC0uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_1E69EB680;
  v2[1] = v3;
  Filterbank::BarkCore<float>::BarkCore(v2 + 2, a1 + 16);
  v2[23] = *(_QWORD *)(a1 + 184);
  return v2;
}

void sub_1B656FAD8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *result;

  v4 = *(_QWORD *)(a1 + 8);
  *a2 = &off_1E69EB680;
  a2[1] = v4;
  result = Filterbank::BarkCore<float>::BarkCore(a2 + 2, a1 + 16);
  a2[23] = *(_QWORD *)(a1 + 184);
  return result;
}

uint64_t std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::destroy(uint64_t a1)
{
  return Filterbank::BarkCore<float>::~BarkCore(a1 + 16);
}

void std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::destroy_deallocate(void *a1)
{
  Filterbank::BarkCore<float>::~BarkCore((uint64_t)a1 + 16);
  operator delete(a1);
}

uint64_t std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1 + 8))(a2, *(_QWORD *)(a1 + 184), a1 + 16);
}

uint64_t DivideScalarVector<float>(uint64_t a1, const float *a2, uint64_t a3)
{
  vDSP_Length v3;
  float __A;

  __A = 1.0;
  v3 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v3 != (a3 - (uint64_t)a2) >> 2)
    __assert_rtn("DivideScalarVector", "VectorUtils.h", 536, "result.size() == theVector.size()");
  vDSP_svdiv(&__A, a2, 1, *(float **)a1, 1, v3);
  return a1;
}

void std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E69EBD08;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EBD08;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
}

void Trackable::BuildDepsList<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<float,(LogTypes)0>>(void **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v7 = a1[1];
  v6 = (unint64_t)a1[2];
  if ((unint64_t)v7 >= v6)
  {
    v9 = ((char *)v7 - (_BYTE *)*a1) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      goto LABEL_34;
    v10 = v6 - (_QWORD)*a1;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v12 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v12);
    else
      v13 = 0;
    v14 = (_QWORD *)(v12 + 8 * v9);
    v15 = v12 + 8 * v13;
    *v14 = a2;
    v8 = v14 + 1;
    v17 = (char *)*a1;
    v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v8;
    a1[2] = (void *)v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v7 = a2;
    v8 = v7 + 1;
  }
  a1[1] = v8;
  v19 = (unint64_t)a1[2];
  if ((unint64_t)v8 < v19)
  {
    *v8 = a3;
    v20 = v8 + 1;
    goto LABEL_33;
  }
  v21 = ((char *)v8 - (_BYTE *)*a1) >> 3;
  if ((unint64_t)(v21 + 1) >> 61)
LABEL_34:
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  v22 = v19 - (_QWORD)*a1;
  v23 = v22 >> 2;
  if (v22 >> 2 <= (unint64_t)(v21 + 1))
    v23 = v21 + 1;
  if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
    v24 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v24 = v23;
  if (v24)
    v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v24);
  else
    v25 = 0;
  v26 = (_QWORD *)(v24 + 8 * v21);
  v27 = v24 + 8 * v25;
  *v26 = a3;
  v20 = v26 + 1;
  v29 = (char *)*a1;
  v28 = (char *)a1[1];
  if (v28 != *a1)
  {
    do
    {
      v30 = *((_QWORD *)v28 - 1);
      v28 -= 8;
      *--v26 = v30;
    }
    while (v28 != v29);
    v28 = (char *)*a1;
  }
  *a1 = v26;
  a1[1] = v20;
  a1[2] = (void *)v27;
  if (v28)
    operator delete(v28);
LABEL_33:
  a1[1] = v20;
}

uint64_t AutoValue<float,(LogTypes)0>::Get(uint64_t a1)
{
  _QWORD *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  std::locale v14;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"WARNING: Calling Get() on an AutoValue ('", 41);
    v3 = *(char *)(a1 + 95);
    if (v3 >= 0)
      v4 = a1 + 72;
    else
      v4 = *(_QWORD *)(a1 + 72);
    if (v3 >= 0)
      v5 = *(unsigned __int8 *)(a1 + 95);
    else
      v5 = *(_QWORD *)(a1 + 80);
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, v4, v5);
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"') without initializing first. Initializing now.", 48);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v14);
    std::ostream::put();
    std::ostream::flush();
    Trackable::Initialize(a1);
  }
  v9 = *(_DWORD *)(a1 + 8);
  if (v9 == 2)
  {
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 272) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      v12 = *(_DWORD *)AutoValue<float,(LogTypes)0>::Get(*(_QWORD *)(a1 + 256));
      *(_DWORD *)AutoValue<float,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280)) = v12;
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 16);
    }
  }
  else if (v9 != 1)
  {
    if (!*(_BYTE *)(a1 + 24))
      __assert_rtn("Get", "AutoValue.h", 668, "_isInitialized == true");
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 264) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a1 + 16);
      v10 = AutoValue<float,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
      v11 = *(_QWORD *)(a1 + 248);
      if (!v11)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, v10);
    }
  }
  return AutoValue<float,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
}

void sub_1B656FFB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t AddMultiplyVectorScalarScalar<float>(uint64_t a1, const float *__A, uint64_t a3, float a4, float a5)
{
  vDSP_Length v5;
  float __C;
  float __B;

  __C = a5;
  __B = a4;
  v5 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v5 != (a3 - (uint64_t)__A) >> 2)
    __assert_rtn("AddMultiplyVectorScalarScalar", "VectorUtils.h", 776, "result.size() == theVector.size()");
  vDSP_vsmsa(__A, 1, &__B, &__C, *(float **)a1, 1, v5);
  return a1;
}

uint64_t AddMultiplyVectorVectorVector<float>(uint64_t a1, const float *__A, uint64_t a3, const float *__B, uint64_t a5, const float *__C, uint64_t a7)
{
  uint64_t v7;

  v7 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v7 != (a3 - (uint64_t)__A) >> 2)
    __assert_rtn("AddMultiplyVectorVectorVector", "VectorUtils.h", 818, "result.size() == a.size()");
  if (v7 != (a5 - (uint64_t)__B) >> 2)
    __assert_rtn("AddMultiplyVectorVectorVector", "VectorUtils.h", 819, "result.size() == b.size()");
  if (v7 != (a7 - (uint64_t)__C) >> 2)
    __assert_rtn("AddMultiplyVectorVectorVector", "VectorUtils.h", 820, "result.size() == c.size()");
  vDSP_vma(__A, 1, __B, 1, __C, 1, *(float **)a1, 1, (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  return a1;
}

uint64_t SquareVector<float>(uint64_t a1, const float *__A, uint64_t a3)
{
  vDSP_Length v3;

  v3 = (a3 - (uint64_t)__A) >> 2;
  if (v3 != (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2)
    __assert_rtn("SquareVector", "VectorUtils.h", 467, "a.size() == result.size()");
  vDSP_vsq(__A, 1, *(float **)a1, 1, v3);
  return a1;
}

uint64_t AutoValue<float,(LogTypes)0>::CircularBuffer::operator[](unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;

  v1 = a1[1];
  if (!v1)
    __assert_rtn("operator[]", "AutoValue.h", 562, "index < _C");
  v2 = *a1;
  if (*a1 >= v1)
    __assert_rtn("operator[]", "AutoValue.h", 569, "theIndex < _C");
  if (a1[4] <= v2)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  return a1[3] + 4 * v2;
}

uint64_t MaxVectorScalar<float>(uint64_t a1, const float *__A, uint64_t a3, float a4)
{
  vDSP_Length v4;
  float __B;

  __B = a4;
  v4 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v4 != (a3 - (uint64_t)__A) >> 2)
    __assert_rtn("MaxVectorScalar", "VectorUtils.h", 635, "result.size() == theVector.size()");
  vDSP_vthr(__A, 1, &__B, *(float **)a1, 1, v4);
  return a1;
}

uint64_t Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<std::vector<float>,(LogTypes)0>>(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4)
{
  __int128 v7;

  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 72), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v7 = *a2;
    *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 72) = v7;
  }
  *(_OWORD *)(a1 + 104) = 0u;
  *(_BYTE *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  Trackable::BuildDepsList<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<float,(LogTypes)0>>((void **)(a1 + 128), a3, a4);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void sub_1B6570374(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 40) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E69EBAD8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EBAD8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

uint64_t MultiplyVectorScalar<float>(uint64_t a1, const float *__A, uint64_t a3, float a4)
{
  vDSP_Length v4;
  float __B;

  __B = a4;
  v4 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v4 != (a3 - (uint64_t)__A) >> 2)
    __assert_rtn("MultiplyVectorScalar", "VectorUtils.h", 592, "result.size() == theVector.size()");
  vDSP_vsmul(__A, 1, &__B, *(float **)a1, 1, v4);
  return a1;
}

uint64_t NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeEMGain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v7 = *(_QWORD *)(v6 + 8);
  v8 = (v7 - *(_QWORD *)v6) >> 2;
  v9 = *(_QWORD *)(v5 + 8);
  if (v8 != (v9 - *(_QWORD *)v5) >> 2)
    __assert_rtn("ComputeEMGain", "GainRule.h", 339, "MM.size() == priorRatio.size()");
  if (v8 != (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2)
    __assert_rtn("ComputeEMGain", "GainRule.h", 340, "MM.size() == result.size()");
  v10 = MultiplyVectorVector<float>(a1, *(const float **)v5, v9, *(const float **)v6, v7);
  return MinVectorScalar<float>(v10, *(const float **)a1, *(_QWORD *)(a1 + 8), 1.0);
}

uint64_t NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeTheta(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v7 = (uint64_t)(*(_QWORD *)(v5 + 8) - *(_QWORD *)v5) >> 2;
  v8 = *(_QWORD *)(v6 + 8);
  if (v7 != (v8 - *(_QWORD *)v6) >> 2)
    __assert_rtn("ComputeTheta", "GainRule.h", 358, "priorRatio.size() == post.size()");
  v9 = *(_QWORD *)(a1 + 8);
  if (v7 != (v9 - *(_QWORD *)a1) >> 2)
    __assert_rtn("ComputeTheta", "GainRule.h", 359, "priorRatio.size() == result.size()");
  AddVectorScalar<float>(*(float **)a1, v9, *(const float **)v6, v8, 1.0);
  return MultiplyVectorVector<float>(a1, *(const float **)a1, *(_QWORD *)(a1 + 8), *(const float **)v5, *(_QWORD *)(v5 + 8));
}

uint64_t NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeHypergeometricGain(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  float *v4;
  float *v5;
  unint64_t v6;
  float *v7;
  float v8;
  float v9;
  float v10;

  v3 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v4 = *(float **)v3;
  v5 = *(float **)(v3 + 8);
  v6 = ((uint64_t)v5 - *(_QWORD *)v3) >> 2;
  v7 = *(float **)a1;
  if (v6 != (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2)
    __assert_rtn("ComputeHypergeometricGain", "GainRule.h", 310, "x.size() == result.size()");
  if (v5 != v4)
  {
    if (v6 <= 1)
      v6 = 1;
    do
    {
      v8 = *v4;
      v9 = floorf(v8 + v8);
      v10 = 1.0;
      if (v9 >= 0.0)
      {
        if (v9 <= 19.0)
          v10 = (float)((float)((float)-(float)(v9 - (float)(v8 * 2.0))
                              * *((float *)&NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeHypergeometricGain(std::vector<float> &,AutoValue<std::vector<float>,(LogTypes)0> &)::table
                                + v9
                                + 1))
                      + (float)((float)(1.0 - (float)-(float)(v9 - (float)(v8 * 2.0)))
                              * *((float *)&NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputeHypergeometricGain(std::vector<float> &,AutoValue<std::vector<float>,(LogTypes)0> &)::table
                                + v9)))
              / sqrtf(v8 + 0.0001);
        else
          v10 = (float)(0.1296 / v8) + 1.0;
      }
      *v7++ = v10;
      ++v4;
      --v6;
    }
    while (v6);
  }
  return a1;
}

uint64_t AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>>(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  _QWORD *v8;
  __int128 v9;
  uint64_t (***v10)();
  uint64_t v11;
  uint64_t (**v13)();
  __int128 v14;
  uint64_t (***v15)();
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v7 = (_QWORD *)Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>>(a1, a2, a4);
  *v7 = &off_1E69EB4C0;
  v7[31] = 0;
  v8 = v7 + 28;
  v7[32] = 0;
  v13 = 0;
  v14 = 0uLL;
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v7 + 35, 1uLL, (uint64_t)&v13);
  *(_QWORD *)&v9 = a3;
  *((_QWORD *)&v9 + 1) = a4;
  *(_QWORD *)(a1 + 344) = 0;
  v13 = &off_1E69EBB20;
  v14 = v9;
  v15 = &v13;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](&v13, v8);
  v10 = v15;
  if (v15 == &v13)
  {
    v11 = 4;
    v10 = &v13;
    goto LABEL_5;
  }
  if (v15)
  {
    v11 = 5;
LABEL_5:
    (*v10)[v11]();
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B657089C(_Unwind_Exception *a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;

  if ((_QWORD *)*v3 == v2)
  {
    v5 = 4;
  }
  else
  {
    if (!*v3)
      goto LABEL_6;
    v5 = 5;
    v2 = (_QWORD *)*v3;
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v5))(v2);
LABEL_6:
  Trackable::~Trackable(v1);
  _Unwind_Resume(a1);
}

uint64_t NoiseSuppression::Gain::Gain<float,(LogTypes)0>::ComputePriorRatio(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v4 = *(_QWORD *)(v3 + 8);
  v5 = *(_QWORD *)(a1 + 8);
  if (v4 - *(_QWORD *)v3 != v5 - *(_QWORD *)a1)
    __assert_rtn("ComputePriorRatio", "GainRule.h", 374, "prior.size() == result.size()");
  AddVectorScalar<float>(*(float **)a1, v5, *(const float **)v3, v4, 1.0);
  return DivideVectorVector<float>(a1, *(const float **)v3, *(_QWORD *)(v3 + 8), *(const float **)a1, *(_QWORD *)(a1 + 8));
}

void AddVectorScalar<float>(float *__C, uint64_t a2, const float *__A, uint64_t a4, float a5)
{
  vDSP_Length v5;
  float __B;

  __B = a5;
  v5 = (a2 - (uint64_t)__C) >> 2;
  if (v5 != (a4 - (uint64_t)__A) >> 2)
    __assert_rtn("AddVectorScalar", "VectorUtils.h", 557, "result.size() == a.size()");
  vDSP_vsadd(__A, 1, &__B, __C, 1, v5);
}

uint64_t DivideVectorVector<float>(uint64_t a1, const float *__A, uint64_t a3, const float *__B, uint64_t a5)
{
  vDSP_Length v5;

  v5 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v5 != (a3 - (uint64_t)__A) >> 2)
    __assert_rtn("DivideVectorVector", "VectorUtils.h", 514, "result.size() == theVector.size()");
  if (v5 != (a5 - (uint64_t)__B) >> 2)
    __assert_rtn("DivideVectorVector", "VectorUtils.h", 515, "result.size() == theDivisor.size()");
  vDSP_vdiv(__B, 1, __A, 1, *(float **)a1, 1, v5);
  return a1;
}

void std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69EBB20;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EBB20;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16));
}

uint64_t MultiplyVectorVector<float>(uint64_t a1, const float *__A, uint64_t a3, const float *__B, uint64_t a5)
{
  vDSP_Length v5;

  v5 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v5 != (a3 - (uint64_t)__A) >> 2)
    __assert_rtn("MultiplyVectorVector", "VectorUtils.h", 355, "result.size() == a.size()");
  if (v5 != (a5 - (uint64_t)__B) >> 2)
    __assert_rtn("MultiplyVectorVector", "VectorUtils.h", 356, "result.size() == b.size()");
  vDSP_vmul(__A, 1, __B, 1, *(float **)a1, 1, v5);
  return a1;
}

uint64_t MinVectorScalar<float>(uint64_t a1, const float *a2, uint64_t a3, float a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = NegateVector<float>(a1, a2, a3);
  v6 = MaxVectorScalar<float>(v5, *(const float **)v5, *(_QWORD *)(v5 + 8), -a4);
  return NegateVector<float>(v6, *(const float **)v6, *(_QWORD *)(v6 + 8));
}

uint64_t NegateVector<float>(uint64_t a1, const float *__A, uint64_t a3)
{
  vDSP_Length v3;

  v3 = (a3 - (uint64_t)__A) >> 2;
  if (v3 != (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2)
    __assert_rtn("NegateVector", "VectorUtils.h", 613, "theVector.size() == result.size()");
  vDSP_vneg(__A, 1, *(float **)a1, 1, v3);
  return a1;
}

uint64_t NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::Compute_gain(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  const float **v9;
  uint64_t v10;
  uint64_t v11;
  const float **v12;
  uint64_t v13;
  uint64_t v14;

  v7 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a4, 0);
  v8 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v9 = (const float **)AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v10 = v9[1] - *v9;
  v11 = *(_QWORD *)(v8 + 8);
  if (v10 != (v11 - *(_QWORD *)v8) >> 2)
    __assert_rtn("Compute_gain", "GainRule.h", 154, "expTheta.size() == prior.size()");
  if (v10 != (uint64_t)(*(_QWORD *)(v7 + 8) - *(_QWORD *)v7) >> 2)
    __assert_rtn("Compute_gain", "GainRule.h", 155, "expTheta.size() == QRatio.size()");
  v12 = v9;
  v13 = *(_QWORD *)(a1 + 8);
  if (v10 != (v13 - *(_QWORD *)a1) >> 2)
    __assert_rtn("Compute_gain", "GainRule.h", 156, "expTheta.size() == result.size()");
  AddVectorScalar<float>(*(float **)a1, v13, *(const float **)v8, v11, 1.0);
  v14 = MultiplyVectorVector<float>(a1, *(const float **)a1, *(_QWORD *)(a1 + 8), *(const float **)v7, *(_QWORD *)(v7 + 8));
  MultiplyVectorVector<float>(v14, *(const float **)a1, *(_QWORD *)(a1 + 8), *v12, (uint64_t)v12[1]);
  AddVectorScalar<float>(*(float **)a1, *(_QWORD *)(a1 + 8), *(const float **)a1, *(_QWORD *)(a1 + 8), 1.0);
  return DivideScalarVector<float>(a1, *(const float **)a1, *(_QWORD *)(a1 + 8));
}

uint64_t AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::vector<float> const& ()(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&),std::vector<float>,std::vector<float>,std::vector<float>>(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD v17[3];
  _QWORD *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 72), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v11 = *a2;
    *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 72) = v11;
  }
  *(_OWORD *)(a1 + 104) = 0u;
  *(_BYTE *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  v12 = operator new(8uLL);
  *v12 = a4;
  *(_QWORD *)(a1 + 128) = v12;
  *(_QWORD *)(a1 + 136) = v12 + 1;
  *(_QWORD *)(a1 + 144) = v12 + 1;
  Trackable::BuildDepsList<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<float,(LogTypes)0>>((void **)(a1 + 128), a5, a6);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E69EB4C0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  memset(v17, 0, sizeof(v17));
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer((_QWORD *)(a1 + 280), 1uLL, (uint64_t)v17);
  *(_QWORD *)(a1 + 344) = 0;
  v13 = operator new(0x28uLL);
  *v13 = &off_1E69EBC10;
  v13[1] = a3;
  v13[2] = a4;
  v13[3] = a5;
  v13[4] = a6;
  v18 = v13;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](v17, (_QWORD *)(a1 + 224));
  v14 = v18;
  if (v18 == v17)
  {
    v15 = 4;
    v14 = v17;
    goto LABEL_8;
  }
  if (v18)
  {
    v15 = 5;
LABEL_8:
    (*(void (**)(void))(*v14 + 8 * v15))();
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B6570F28(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 40) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeZetaBarkMaxPart(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v7 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 1uLL);
  v8 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v9 = AddMultiplyVectorScalarVector<float>(a1, *(const float **)v8, *(_QWORD *)(v8 + 8), *(const float **)v7, *(_QWORD *)(v7 + 8));
  v10 = MaxVectorScalar<float>(v9, *(const float **)a1, *(_QWORD *)(a1 + 8), 0.0);
  return MultiplyVectorScalar<float>(v10, *(const float **)a1, *(_QWORD *)(a1 + 8), a4);
}

uint64_t AutoValue<std::vector<float>,(LogTypes)0>::AutoValue<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0>&,AutoValue<std::vector<float>,(LogTypes)0>&,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&>,std::vector<float>,std::vector<float>>(uint64_t a1, __int128 *a2, _OWORD *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v9;
  _QWORD *v10;
  char *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v9 = (_QWORD *)Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<std::vector<float>,(LogTypes)0>>(a1, a2, a4, a5);
  *v9 = &off_1E69EB4C0;
  v9[31] = 0;
  v10 = v9 + 28;
  v9[32] = 0;
  memset(v15, 0, sizeof(v15));
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v9 + 35, 1uLL, (uint64_t)v15);
  *(_QWORD *)(a1 + 344) = 0;
  v11 = (char *)operator new(0x28uLL);
  *(_QWORD *)v11 = &off_1E69EBC58;
  *(_OWORD *)(v11 + 8) = *a3;
  *((_QWORD *)v11 + 3) = a4;
  *((_QWORD *)v11 + 4) = a5;
  v16 = v11;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](v15, v10);
  v12 = v16;
  if (v16 == v15)
  {
    v13 = 4;
    v12 = v15;
    goto LABEL_5;
  }
  if (v16)
  {
    v13 = 5;
LABEL_5:
    (*(void (**)(void))(*v12 + 8 * v13))();
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B657119C(_Unwind_Exception *a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v6;

  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::~CircularBuffer(v3);
  if ((_QWORD *)*v4 == v2)
  {
    v6 = 4;
  }
  else
  {
    if (!*v4)
      goto LABEL_6;
    v6 = 5;
    v2 = (_QWORD *)*v4;
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v6))(v2);
LABEL_6:
  Trackable::~Trackable(v1);
  _Unwind_Resume(a1);
}

uint64_t NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeZetaBarkMinPart(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v7 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 1uLL);
  v8 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v9 = AddMultiplyVectorScalarVector<float>(a1, *(const float **)v8, *(_QWORD *)(v8 + 8), *(const float **)v7, *(_QWORD *)(v7 + 8));
  v10 = MinVectorScalar<float>(v9, *(const float **)a1, *(_QWORD *)(a1 + 8), 0.0);
  return MultiplyVectorScalar<float>(v10, *(const float **)a1, *(_QWORD *)(a1 + 8), a4);
}

uint64_t NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeZetaBark(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  const float **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const float **v13;
  uint64_t v14;

  v7 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v8 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v9 = (const float **)AutoValue<std::vector<float>,(LogTypes)0>::Get(a4, 0);
  v10 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v10 != v9[1] - *v9)
    __assert_rtn("ComputeZetaBark", "GainRule.h", 91, "result.size() == prior_bark.size()");
  v11 = *(_QWORD *)(v7 + 8);
  if (v10 != (v11 - *(_QWORD *)v7) >> 2)
    __assert_rtn("ComputeZetaBark", "GainRule.h", 92, "result.size() == zetaBark_maxPart.size()");
  v12 = *(_QWORD *)(v8 + 8);
  if (v10 != (v12 - *(_QWORD *)v8) >> 2)
    __assert_rtn("ComputeZetaBark", "GainRule.h", 93, "result.size() == zetaBark_minPart.size()");
  v13 = v9;
  v14 = AddVectorVector<float>(a1, *(const float **)v7, v11, *(const float **)v8, v12);
  return AddVectorVector<float>(v14, *(const float **)a1, *(_QWORD *)(a1 + 8), *v13, (uint64_t)v13[1]);
}

float *NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::Compute_snr(float *a1, uint64_t a2)
{
  uint64_t v3;
  float *v4;
  float *v5;
  float v6;

  v3 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  *a1 = 0.0;
  v4 = *(float **)v3;
  v5 = *(float **)(v3 + 8);
  v6 = 0.0;
  if (*(float **)v3 != v5)
  {
    do
    {
      if (*v4 > 3.0)
      {
        v6 = *v4 + v6;
        *a1 = v6;
      }
      ++v4;
    }
    while (v4 != v5);
  }
  *a1 = v6 / 24.0;
  return a1;
}

float *NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputePframe(float *a1, uint64_t a2)
{
  float *v3;

  v3 = (float *)AutoValue<float,(LogTypes)0>::Get(a2);
  *a1 = (float)((float)(*v3 / (float)(*v3 + 0.5)) * 0.899) + 0.1;
  return a1;
}

uint64_t NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeP1(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(v3 + 8);
  if (v4 - *(_QWORD *)a1 != v5 - *(_QWORD *)v3)
    __assert_rtn("ComputeP1", "GainRule.h", 206, "result.size() == zetaBark.size()");
  AddVectorScalar<float>(*(float **)a1, v4, *(const float **)v3, v5, 0.5);
  v6 = DivideVectorVector<float>(a1, *(const float **)v3, *(_QWORD *)(v3 + 8), *(const float **)a1, *(_QWORD *)(a1 + 8));
  return AddMultiplyVectorScalarScalar<float>(v6, *(const float **)a1, *(_QWORD *)(a1 + 8), 0.899, 0.1);
}

uint64_t NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeQ(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  float *v6;
  uint64_t v7;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = (float *)AutoValue<float,(LogTypes)0>::Get(a3);
  v7 = *(_QWORD *)(v5 + 8);
  if (a1[1] - *a1 != v7 - *(_QWORD *)v5)
    __assert_rtn("ComputeQ", "GainRule.h", 225, "result.size() == P1.size()");
  return AddMultiplyVectorScalarScalar<float>((uint64_t)a1, *(const float **)v5, v7, -*v6, 1.0);
}

uint64_t NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeQRatio(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v4 = *(_QWORD *)(v3 + 8);
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 != v4 - *(_QWORD *)v3)
    __assert_rtn("ComputeQRatio", "GainRule.h", 191, "result.size() == Q.size()");
  v5 = v3;
  v6 = AddMultiplyVectorScalarScalar<float>(a1, *(const float **)v3, v4, -1.0, 1.0);
  return DivideVectorVector<float>(v6, *(const float **)v5, *(_QWORD *)(v5 + 8), *(const float **)a1, *(_QWORD *)(a1 + 8));
}

uint64_t NoiseSuppression::Gain::Gain2<float,(LogTypes)0>::ComputeExpTheta(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  float *v4;
  unint64_t v5;
  float *v6;
  float *v7;
  uint64_t v8;
  float v9;

  v3 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v4 = *(float **)a1;
  v5 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  v7 = *(float **)v3;
  v6 = *(float **)(v3 + 8);
  if (v5 != ((uint64_t)v6 - *(_QWORD *)v3) >> 2)
    __assert_rtn("ComputeExpTheta", "GainRule.h", 179, "result.size() == theta.size()");
  if (v6 != v7)
  {
    if (v5 <= 1)
      v8 = 1;
    else
      v8 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
    do
    {
      v9 = *v7++;
      *v4++ = expf(-v9);
      --v8;
    }
    while (v8);
  }
  return a1;
}

_QWORD *std::__function::__value_func<float const& ()(float &)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1B65717C0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void std::__function::__func<std::__bind<float const& (&)(float &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<float const& (&)(float &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,float const& ()(float &)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<float const& (&)(float &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<float const& (&)(float &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69EBCA0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<float const& (&)(float &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<float const& (&)(float &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EBCA0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<float const& (&)(float &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<float const& (&)(float &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,float const& ()(float &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16));
}

uint64_t AddVectorVector<float>(uint64_t a1, const float *__A, uint64_t a3, const float *__B, uint64_t a5)
{
  vDSP_Length v5;

  v5 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v5 != (a3 - (uint64_t)__A) >> 2)
    __assert_rtn("AddVectorVector", "VectorUtils.h", 696, "result.size() == a.size()");
  if (v5 != (a5 - (uint64_t)__B) >> 2)
    __assert_rtn("AddVectorVector", "VectorUtils.h", 697, "result.size() == b.size()");
  vDSP_vadd(__A, 1, __B, 1, *(float **)a1, 1, v5);
  return a1;
}

uint64_t AddMultiplyVectorScalarVector<float>(uint64_t a1, const float *__A, uint64_t a3, const float *a4, uint64_t a5)
{
  vDSP_Length v5;
  float __B;

  __B = -1.0;
  v5 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v5 != (a3 - (uint64_t)__A) >> 2)
    __assert_rtn("AddMultiplyVectorScalarVector", "VectorUtils.h", 798, "result.size() == theVector.size()");
  if (v5 != (a5 - (uint64_t)a4) >> 2)
    __assert_rtn("AddMultiplyVectorScalarVector", "VectorUtils.h", 799, "result.size() == theAddand.size()");
  vDSP_vsma(__A, 1, &__B, a4, 1, *(float **)a1, 1, v5);
  return a1;
}

void std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E69EBC58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EBC58;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,float),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,float const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, float))(a1 + 8))(a2, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(float *)(a1 + 16));
}

void std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E69EBC10;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EBC10;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
}

void std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E69EB750;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB750;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

uint64_t NoiseSuppression::SNR::Prior<float,(LogTypes)0>::ComputePrior(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  vDSP_Length v13;
  float __C;
  float __B;

  v9 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a4, 0);
  v10 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  AddMultiplyVectorScalarScalar<float>(a1, *(const float **)v10, *(_QWORD *)(v10 + 8), -1.0, 1.0);
  v11 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a5, 0);
  DivideVectorVector<float>(a1, *(const float **)a1, *(_QWORD *)(a1 + 8), *(const float **)v11, *(_QWORD *)(v11 + 8));
  v12 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v13 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (v13 != (uint64_t)(*(_QWORD *)(v10 + 8) - *(_QWORD *)v10) >> 2)
    __assert_rtn("AddMultiplyVectorVectorMultiplyVectorVector", "VectorUtils.h", 841, "result.size() == a.size()");
  if (v13 != (uint64_t)(*(_QWORD *)(v12 + 8) - *(_QWORD *)v12) >> 2)
    __assert_rtn("AddMultiplyVectorVectorMultiplyVectorVector", "VectorUtils.h", 842, "result.size() == b.size()");
  if (v13 != (uint64_t)(*(_QWORD *)(v9 + 8) - *(_QWORD *)v9) >> 2)
    __assert_rtn("AddMultiplyVectorVectorMultiplyVectorVector", "VectorUtils.h", 843, "result.size() == c.size()");
  vDSP_vmma(*(const float **)v10, 1, *(const float **)v12, 1, *(const float **)v9, 1, *(const float **)a1, 1, *(float **)a1, 1, v13);
  __B = -1.0e20;
  __C = 100.0;
  vDSP_vclip(*(const float **)a1, 1, &__B, &__C, *(float **)a1, 1, (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  return a1;
}

uint64_t NoiseSuppression::SNR::Prior<float,(LogTypes)0>::ComputeNoiseReg(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  AddVectorScalar<float>(*(float **)a1, *(_QWORD *)(a1 + 8), *(const float **)v3, *(_QWORD *)(v3 + 8), 1.0e-20);
  return a1;
}

uint64_t NoiseSuppression::SNR::Prior<float,(LogTypes)0>::ComputeGamma(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v7 = AddVectorVector<float>(a1, *(const float **)v5, *(_QWORD *)(v5 + 8), *(const float **)v6, *(_QWORD *)(v6 + 8));
  v8 = DivideVectorVector<float>(v7, *(const float **)v5, *(_QWORD *)(v5 + 8), *(const float **)a1, *(_QWORD *)(a1 + 8));
  v9 = SquareVector<float>(v8, *(const float **)a1, *(_QWORD *)(a1 + 8));
  MultiplyVectorScalar<float>(v9, *(const float **)a1, *(_QWORD *)(a1 + 8), 0.89);
  AddVectorScalar<float>(*(float **)a1, *(_QWORD *)(a1 + 8), *(const float **)a1, *(_QWORD *)(a1 + 8), 0.1);
  return a1;
}

uint64_t NoiseSuppression::SNR::Prior<float,(LogTypes)0>::MaxXAgainstZero(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  return MaxVectorScalar<float>(a1, *(const float **)v3, *(_QWORD *)(v3 + 8), 0.0);
}

void std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1E69EBB88;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E69EBB88;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t NoiseSuppression::SNR::Post<float,(LogTypes)0>::ComputePost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  DivideVectorVector<float>(a1, *(const float **)v5, *(_QWORD *)(v5 + 8), *(const float **)v6, *(_QWORD *)(v6 + 8));
  AddVectorScalar<float>(*(float **)a1, *(_QWORD *)(a1 + 8), *(const float **)a1, *(_QWORD *)(a1 + 8), -1.0);
  return MinVectorScalar<float>(a1, *(const float **)a1, *(_QWORD *)(a1 + 8), 100.0);
}

uint64_t NoiseSuppression::SNR::Post<float,(LogTypes)0>::ComputeNoiseReg(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  AddVectorScalar<float>(*(float **)a1, *(_QWORD *)(a1 + 8), *(const float **)v3, *(_QWORD *)(v3 + 8), 1.0e-20);
  return a1;
}

uint64_t ReverbEstimator<float,true,(LogTypes)0>::ApplyGainScalar(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  float v6;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = *(float *)AutoValue<float,(LogTypes)0>::Get(a3);
  return MultiplyVectorScalar<float>(a1, *(const float **)v5, *(_QWORD *)(v5 + 8), v6);
}

uint64_t Convolver<float,true,(LogTypes)0>::Convolve(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v18;

  v7 = (_QWORD *)AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::Get(a2);
  v8 = (v7[1] - *v7) / 24;
  v9 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  v18 = 0;
  std::vector<float>::assign((char **)a1, v9, &v18);
  AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  if (v8 > a4)
  {
    v10 = 24 * a4;
    do
    {
      v11 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, a4);
      v12 = *(_QWORD *)(a1 + 8);
      v13 = (v12 - *(_QWORD *)a1) >> 2;
      v14 = *v7 + v10;
      v15 = *(_QWORD *)(v14 + 8);
      if (v13 != (v15 - *(_QWORD *)v14) >> 2)
        __assert_rtn("Convolve", "Convolver.h", 168, "result.size() == H[a].size()");
      v16 = *(_QWORD *)(v11 + 8);
      if (v13 != (v16 - *(_QWORD *)v11) >> 2)
        __assert_rtn("Convolve", "Convolver.h", 169, "result.size() == X.size()");
      AddMultiplyVectorVectorVector<float>(a1, *(const float **)v14, v15, *(const float **)v11, v16, *(const float **)a1, v12);
      ++a4;
      v10 += 24;
    }
    while (v8 != a4);
  }
  return a1;
}

void AutoValue<std::vector<float>,(LogTypes)0>::Set(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
    __assert_rtn("Set", "AutoValue.h", 757, "&theAutoValue != this");
  if (*(_QWORD *)(a1 + 256) != a2)
  {
    *(_QWORD *)(a1 + 256) = a2;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = a2;
    if (*(_DWORD *)(a1 + 8) != 2)
    {
      *(_DWORD *)(a1 + 8) = 2;
      Trackable::Uninitialize((Trackable *)a1);
    }
  }
}

uint64_t AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::Get(uint64_t a1)
{
  _QWORD *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  std::locale v29;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"WARNING: Calling Get() on an AutoValue ('", 41);
    v3 = *(char *)(a1 + 95);
    if (v3 >= 0)
      v4 = a1 + 72;
    else
      v4 = *(_QWORD *)(a1 + 72);
    if (v3 >= 0)
      v5 = *(unsigned __int8 *)(a1 + 95);
    else
      v5 = *(_QWORD *)(a1 + 80);
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, v4, v5);
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"') without initializing first. Initializing now.", 48);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v29, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v29);
    std::ostream::put();
    std::ostream::flush();
    Trackable::Initialize(a1);
  }
  v9 = *(_DWORD *)(a1 + 8);
  if (v9 == 2)
  {
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 272) >= *(_QWORD *)(a1 + 16))
      return AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
    AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
    v12 = (uint64_t *)AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::Get(*(_QWORD *)(a1 + 256));
    v13 = (uint64_t *)AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
    if (v13 != v12)
    {
      v14 = v13;
      v16 = *v12;
      v15 = v12[1];
      v17 = v15 - *v12;
      v18 = v17 >> 6;
      v19 = *v13;
      if (v17 >> 6 <= (unint64_t)((v13[2] - *v13) >> 6))
      {
        v24 = (_QWORD *)v13[1];
        v25 = ((uint64_t)v24 - v19) >> 6;
        if (v25 >= v18)
        {
          if (v16 != v15)
          {
            do
            {
              DSPSplitComplexV<float>::operator=(v19, v16);
              v16 += 64;
              v19 += 64;
            }
            while (v16 != v15);
            v24 = (_QWORD *)v14[1];
          }
          while (v24 != (_QWORD *)v19)
          {
            v24 -= 8;
            std::__destroy_at[abi:ne180100]<DSPSplitComplexV<float>,0>(v24);
          }
          v14[1] = v19;
          goto LABEL_38;
        }
        v26 = v16 + (v25 << 6);
        if (v24 != (_QWORD *)v19)
        {
          v27 = v25 << 6;
          do
          {
            DSPSplitComplexV<float>::operator=(v19, v16);
            v16 += 64;
            v19 += 64;
            v27 -= 64;
          }
          while (v27);
          v19 = v14[1];
        }
        v23 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DSPSplitComplexV<float>>,DSPSplitComplexV<float>*,DSPSplitComplexV<float>*,DSPSplitComplexV<float>*>(v26, v15, v19);
      }
      else
      {
        std::vector<DSPSplitComplexV<float>>::__vdeallocate(v13);
        if (v17 < 0)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v20 = v14[2] - *v14;
        v21 = v20 >> 5;
        if (v20 >> 5 <= v18)
          v21 = v17 >> 6;
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFC0)
          v22 = 0x3FFFFFFFFFFFFFFLL;
        else
          v22 = v21;
        std::vector<DSPSplitComplexV<float>>::__vallocate[abi:ne180100](v14, v22);
        v23 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DSPSplitComplexV<float>>,DSPSplitComplexV<float>*,DSPSplitComplexV<float>*,DSPSplitComplexV<float>*>(v16, v15, v14[1]);
      }
      v14[1] = v23;
    }
LABEL_38:
    *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 16);
    return AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
  }
  if (v9 != 1)
  {
    if (!*(_BYTE *)(a1 + 24))
      __assert_rtn("Get", "AutoValue.h", 668, "_isInitialized == true");
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 264) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a1 + 16);
      v10 = AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
      v11 = *(_QWORD *)(a1 + 248);
      if (!v11)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, v10);
    }
  }
  return AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
}

void sub_1B657243C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<DSPSplitComplexV<float>>::__init_with_size[abi:ne180100]<DSPSplitComplexV<float>*,DSPSplitComplexV<float>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<DSPSplitComplexV<float>>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DSPSplitComplexV<float>>,DSPSplitComplexV<float>*,DSPSplitComplexV<float>*,DSPSplitComplexV<float>*>(a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B65724C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t SquareMagFreqVector<float>(uint64_t a1, DSPSplitComplex *a2)
{
  uint64_t v4;
  unint64_t v5;
  float v6;
  int v8;

  v4 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (DSPSplitComplexV<float>::size(a2) != v4 >> 2)
    __assert_rtn("SquareMagFreqVector", "VectorUtils.h", 412, "result.size() == a.size()");
  v5 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  v8 = 0;
  std::vector<float>::assign((char **)a1, v5, &v8);
  v6 = *a2->realp;
  vDSP_zaspec(a2, *(float **)a1, (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  **(float **)a1 = v6 * v6;
  return a1;
}

void std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 8;
        std::__destroy_at[abi:ne180100]<DSPSplitComplexV<float>,0>(v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void Transformer::WholeSignalForward<float>::~WholeSignalForward(uint64_t a1)
{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  void **v25;

  *(_QWORD *)a1 = &off_1E69EB820;
  v2 = (void **)(a1 + 3056);
  *(_QWORD *)(a1 + 3056) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 3376));
  v3 = *(void **)(a1 + 3352);
  if (v3)
  {
    *(_QWORD *)(a1 + 3360) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 3304);
  if (v4 == (_QWORD *)(a1 + 3280))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 3280);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)(a1 + 2704) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 3024));
  v6 = *(void **)(a1 + 3000);
  if (v6)
  {
    *(_QWORD *)(a1 + 3008) = v6;
    operator delete(v6);
  }
  v7 = *(_QWORD **)(a1 + 2952);
  if (v7 == (_QWORD *)(a1 + 2928))
  {
    v8 = 4;
    v7 = (_QWORD *)(a1 + 2928);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_15:
  Trackable::~Trackable((void **)(a1 + 2704));
  *(_QWORD *)(a1 + 2368) = &off_1E69EB9A0;
  if (*(_QWORD *)(a1 + 2688))
    operator delete(*(void **)(a1 + 2672));
  v9 = *(_QWORD **)(a1 + 2616);
  if (v9 == (_QWORD *)(a1 + 2592))
  {
    v10 = 4;
    v9 = (_QWORD *)(a1 + 2592);
  }
  else
  {
    if (!v9)
      goto LABEL_22;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_22:
  Trackable::~Trackable((void **)(a1 + 2368));
  *(_QWORD *)(a1 + 2032) = &off_1E69EB9A0;
  if (*(_QWORD *)(a1 + 2352))
    operator delete(*(void **)(a1 + 2336));
  v11 = *(_QWORD **)(a1 + 2280);
  if (v11 == (_QWORD *)(a1 + 2256))
  {
    v12 = 4;
    v11 = (_QWORD *)(a1 + 2256);
  }
  else
  {
    if (!v11)
      goto LABEL_29;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_29:
  Trackable::~Trackable((void **)(a1 + 2032));
  *(_QWORD *)(a1 + 1696) = &off_1E69EB9A0;
  if (*(_QWORD *)(a1 + 2016))
    operator delete(*(void **)(a1 + 2000));
  v13 = *(_QWORD **)(a1 + 1944);
  if (v13 == (_QWORD *)(a1 + 1920))
  {
    v14 = 4;
    v13 = (_QWORD *)(a1 + 1920);
  }
  else
  {
    if (!v13)
      goto LABEL_36;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_36:
  Trackable::~Trackable((void **)(a1 + 1696));
  *(_QWORD *)(a1 + 1360) = &off_1E69EB9C0;
  if (*(_QWORD *)(a1 + 1680))
    operator delete(*(void **)(a1 + 1664));
  v15 = *(_QWORD **)(a1 + 1608);
  if (v15 == (_QWORD *)(a1 + 1584))
  {
    v16 = 4;
    v15 = (_QWORD *)(a1 + 1584);
  }
  else
  {
    if (!v15)
      goto LABEL_43;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_43:
  Trackable::~Trackable((void **)(a1 + 1360));
  *(_QWORD *)(a1 + 1024) = &off_1E69EB2C0;
  if (*(_QWORD *)(a1 + 1344))
    operator delete(*(void **)(a1 + 1328));
  v17 = *(_QWORD **)(a1 + 1272);
  if (v17 == (_QWORD *)(a1 + 1248))
  {
    v18 = 4;
    v17 = (_QWORD *)(a1 + 1248);
  }
  else
  {
    if (!v17)
      goto LABEL_50;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_50:
  Trackable::~Trackable((void **)(a1 + 1024));
  *(_QWORD *)(a1 + 688) = &off_1E69EB9A0;
  if (*(_QWORD *)(a1 + 1008))
    operator delete(*(void **)(a1 + 992));
  v19 = *(_QWORD **)(a1 + 936);
  if (v19 == (_QWORD *)(a1 + 912))
  {
    v20 = 4;
    v19 = (_QWORD *)(a1 + 912);
  }
  else
  {
    if (!v19)
      goto LABEL_57;
    v20 = 5;
  }
  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_57:
  Trackable::~Trackable((void **)(a1 + 688));
  *(_QWORD *)(a1 + 352) = &off_1E69EB9A0;
  if (*(_QWORD *)(a1 + 672))
    operator delete(*(void **)(a1 + 656));
  v21 = *(_QWORD **)(a1 + 600);
  if (v21 == (_QWORD *)(a1 + 576))
  {
    v22 = 4;
    v21 = (_QWORD *)(a1 + 576);
  }
  else
  {
    if (!v21)
      goto LABEL_64;
    v22 = 5;
  }
  (*(void (**)(void))(*v21 + 8 * v22))();
LABEL_64:
  Trackable::~Trackable((void **)(a1 + 352));
  *(_QWORD *)a1 = &off_1E69EB938;
  boost::container::vector<std::vector<DSPSplitComplexV<float>>,void,void>::~vector(a1 + 320);
  v25 = (void **)(a1 + 296);
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&v25);
  v23 = *(_QWORD **)(a1 + 248);
  if (v23 == (_QWORD *)(a1 + 224))
  {
    v24 = 4;
    v23 = (_QWORD *)(a1 + 224);
    goto LABEL_68;
  }
  if (v23)
  {
    v24 = 5;
LABEL_68:
    (*(void (**)(void))(*v23 + 8 * v24))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  Transformer::WholeSignalForward<float>::~WholeSignalForward(a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t boost::container::vector<std::vector<DSPSplitComplexV<float>>,void,void>::~vector(uint64_t a1)
{
  uint64_t v2;
  void **v3;
  void **v5;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(void ***)a1;
    do
    {
      --v2;
      v5 = v3;
      std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
      v3 += 3;
    }
    while (v2);
  }
  if (*(_QWORD *)(a1 + 16))
    operator delete(*(void **)a1);
  return a1;
}

void AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::~AutoValue(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)a1 = &off_1E69EB938;
  boost::container::vector<std::vector<DSPSplitComplexV<float>>,void,void>::~vector(a1 + 320);
  v4 = (void **)(a1 + 296);
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v2 = *(_QWORD **)(a1 + 248);
  if (v2 == (_QWORD *)(a1 + 224))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 224);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  _QWORD *v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)a1 = &off_1E69EB938;
  boost::container::vector<std::vector<DSPSplitComplexV<float>>,void,void>::~vector(a1 + 320);
  v4 = (void **)(a1 + 296);
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v2 = *(_QWORD **)(a1 + 248);
  if (v2 == (_QWORD *)(a1 + 224))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 224);
  }
  else
  {
    if (!v2)
    {
LABEL_6:
      Trackable::~Trackable((void **)a1);
      JUMPOUT(0x1BCC95CECLL);
    }
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
  goto LABEL_6;
}

{
  _QWORD *v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)a1 = &off_1E69EB938;
  boost::container::vector<std::vector<DSPSplitComplexV<float>>,void,void>::~vector(a1 + 320);
  v4 = (void **)(a1 + 296);
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v2 = *(_QWORD **)(a1 + 248);
  if (v2 == (_QWORD *)(a1 + 224))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 224);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  Trackable::~Trackable((void **)a1);
}

void AutoValue<BOOL,(LogTypes)0>::~AutoValue(void **this)
{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB2C0;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
    goto LABEL_7;
  }
  if (v2)
  {
    v3 = 5;
LABEL_7:
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
  Trackable::~Trackable(this);
}

{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB2C0;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
  }
  else
  {
    if (!v2)
    {
LABEL_8:
      Trackable::~Trackable(this);
      JUMPOUT(0x1BCC95CECLL);
    }
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  goto LABEL_8;
}

void AutoValue<Transformer::windowTypes,(LogTypes)0>::~AutoValue(void **this)
{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB9C0;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
    goto LABEL_7;
  }
  if (v2)
  {
    v3 = 5;
LABEL_7:
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
  Trackable::~Trackable(this);
}

{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB9C0;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
  }
  else
  {
    if (!v2)
    {
LABEL_8:
      Trackable::~Trackable(this);
      JUMPOUT(0x1BCC95CECLL);
    }
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  goto LABEL_8;
}

void AutoValue<unsigned long,(LogTypes)0>::~AutoValue(void **this)
{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB9A0;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
    goto LABEL_7;
  }
  if (v2)
  {
    v3 = 5;
LABEL_7:
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
  Trackable::~Trackable(this);
}

{
  Trackable *v2;
  uint64_t v3;

  *this = &off_1E69EB9A0;
  if (this[40])
    operator delete(this[38]);
  v2 = (Trackable *)this[31];
  if (v2 == (Trackable *)(this + 28))
  {
    v3 = 4;
    v2 = (Trackable *)(this + 28);
  }
  else
  {
    if (!v2)
    {
LABEL_8:
      Trackable::~Trackable(this);
      JUMPOUT(0x1BCC95CECLL);
    }
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  goto LABEL_8;
}

void std::__destroy_at[abi:ne180100]<DSPSplitComplexV<float>,0>(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
}

char *std::vector<DSPSplitComplexV<float>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;

  if (a2 >> 58)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  result = (char *)operator new(a2 << 6);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[64 * a2];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DSPSplitComplexV<float>>,DSPSplitComplexV<float>*,DSPSplitComplexV<float>*,DSPSplitComplexV<float>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  if (a1 != a2)
  {
    v6 = 0;
    do
    {
      DSPSplitComplexV<float>::DSPSplitComplexV(a3 + v6, a1 + v6);
      v6 += 64;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

uint64_t AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::operator[](unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;

  v1 = a1[1];
  if (!v1)
    __assert_rtn("operator[]", "AutoValue.h", 562, "index < _C");
  v2 = *a1;
  if (*a1 >= v1)
    __assert_rtn("operator[]", "AutoValue.h", 569, "theIndex < _C");
  if (a1[6] <= v2)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  return a1[5] + 24 * v2;
}

void std::vector<DSPSplitComplexV<float>>::__vdeallocate(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v3;
  _QWORD *v4;

  v1 = (_QWORD *)*a1;
  if (*a1)
  {
    v3 = (_QWORD *)a1[1];
    v4 = (_QWORD *)*a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 8;
        std::__destroy_at[abi:ne180100]<DSPSplitComplexV<float>,0>(v3);
      }
      while (v3 != v1);
      v4 = (_QWORD *)*a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *Transformer::WholeSignalForward<float>::Transform(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  unsigned __int8 *v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  vDSP_DFT_SetupStruct *Setup;
  unint64_t v19;
  int64x2_t v20;
  int64x2_t v21;
  int64x2_t v22;
  char *v23;
  uint64_t v24;
  vDSP_Length v25;
  int64x2_t v26;
  int64x2_t v27;
  void **v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  __int128 *v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t (**v36)(uint64_t, uint64_t, uint64_t, unsigned int *);
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void **v42;
  uint64_t v43;
  size_t v44;
  _BYTE *v45;
  void **v46;
  size_t v47;
  _BYTE *v48;
  void **v49;
  float v50;
  size_t v51;
  void **v52;
  void **v53;
  _QWORD *v54;
  void *v55;
  void (*v56)(uint64_t, DSPSplitComplex *, uint64_t);
  uint64_t v57;
  _QWORD *v58;
  uint64_t (**v59)(uint64_t, uint64_t, uint64_t);
  uint64_t v60;
  uint64_t v61;
  void (**v62)(uint64_t, DSPSplitComplex *, uint64_t);
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  void *v68;
  unint64_t v69;
  _QWORD *v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  char *v80;
  BOOL v81;
  unint64_t v82;
  unint64_t v83;
  _QWORD *v84;
  void *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  _DWORD *v90;
  int *v91;
  unint64_t v92;
  int v93;
  uint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  CAXException *exception;
  unint64_t v99;
  unint64_t v100;
  _QWORD *v101;
  int v102;
  unint64_t v103;
  __int128 v104;
  unint64_t v105;
  void *v106[2];
  unsigned __int8 v107;
  __int128 __p;
  uint64_t v109;
  _QWORD v110[7];
  _QWORD v111[14];
  _QWORD v112[3];
  uint64_t v113[4];
  __int128 v114;
  uint64_t v115;
  __int128 v116;
  char v117[24];
  void *v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t v121;
  _QWORD v122[44];
  void *v123[28];
  _BYTE v124[24];
  _BYTE *v125;
  void *v126;
  void *v127;
  uint64_t v128[4];
  _BYTE buf[24];
  int64x2_t v130;
  int64x2_t v131;
  _BYTE v132[160];
  _QWORD v133[3];
  _QWORD *v134;
  __int128 v135;
  uint64_t v136;
  __int128 v137;
  void *__src;
  _BYTE *v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  void *v143[2];
  char v144;
  void **v145;
  uint64_t (*v146)(uint64_t, uint64_t, uint64_t);
  _QWORD v147[2];
  uint64_t (**v148)(uint64_t, uint64_t, uint64_t);
  _QWORD *v149;
  uint64_t (*v150)(uint64_t, uint64_t, uint64_t, unsigned int *);
  void *v151;
  void *v152[2];
  void *v153[4];
  void (*v154)(uint64_t, DSPSplitComplex *, uint64_t);
  __int128 v155;
  int64x2_t v156;
  int64x2_t v157;
  _QWORD v158[4];
  float *v159;
  float *v160;
  float **v161;
  uint64_t v162;

  v162 = *MEMORY[0x1E0C80C00];
  v11 = (_QWORD *)AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v12 = *(_QWORD *)AutoValue<unsigned long,(LogTypes)0>::Get(a3);
  v13 = *(_QWORD *)AutoValue<unsigned long,(LogTypes)0>::Get(a4);
  AutoValue<Transformer::windowTypes,(LogTypes)0>::Get(a5);
  v14 = (unsigned __int8 *)AutoValue<BOOL,(LogTypes)0>::Get(a6);
  v15 = (uint64_t)(v11[1] - *v11) >> 2;
  if (v15 / v12 != (uint64_t)(a1[1] - *a1) >> 6)
    __assert_rtn("Transform", "Transformer.h", 542, "result.size() == numFrames");
  v16 = *v14;
  std::string::basic_string[abi:ne180100]<0>(&__p, "tempInputBlock");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue(v123, &__p);
  if (SHIBYTE(v109) < 0)
    operator delete((void *)__p);
  std::string::basic_string[abi:ne180100]<0>(v106, "tempTransformer");
  v99 = v15 / v12;
  *(_QWORD *)&__p = &off_1E69EB840;
  v17 = v13 << v16;
  v145 = 0;
  Setup = vDSP_DFT_zrop_CreateSetup(0, v13 << v16, vDSP_DFT_FORWARD);
  v105 = v13 << v16;
  if (!Setup)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "VectorUtils.h";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 987;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v13 << v16;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d FFT object failed to Initialize() with block-size %u.", buf, 0x18u);
    }
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "FFT object failed to initialize.", -1);
  }
  v19 = v17 >> 1;
  DSPSplitComplexV<float>::DSPSplitComplexV(&v150, v17 >> 1);
  v154 = FFT_Forward<float>;
  vDSP_DFT_SetupObject<float,(TransformDirections)0>::vDSP_DFT_SetupObject((vDSP_Length *)&v155, v13 << v16);
  v20 = *(int64x2_t *)v152;
  v157 = *(int64x2_t *)v152;
  v158[0] = v153[0];
  v21 = *(int64x2_t *)&v153[1];
  *(_OWORD *)v152 = 0u;
  memset(v153, 0, sizeof(v153));
  *(int64x2_t *)&v158[1] = v21;
  v158[3] = v153[3];
  v156 = vzip1q_s64(v20, v21);
  *(_QWORD *)buf = v154;
  vDSP_DFT_SetupObject<float,(TransformDirections)0>::vDSP_DFT_SetupObject((vDSP_Length *)&buf[8], v155);
  v131 = v157;
  v157 = 0u;
  *(_QWORD *)v132 = v158[0];
  v22 = *(int64x2_t *)&v158[1];
  memset(v158, 0, sizeof(v158));
  *(int64x2_t *)&v132[8] = v22;
  *(_QWORD *)&v132[24] = v158[3];
  v130 = vzip1q_s64(v131, v22);
  v161 = 0;
  v23 = (char *)operator new(0x60uLL);
  v24 = *(_QWORD *)buf;
  v25 = *(_QWORD *)&buf[8];
  *(_QWORD *)v23 = &off_1E69EB860;
  *((_QWORD *)v23 + 1) = v24;
  vDSP_DFT_SetupObject<float,(TransformDirections)0>::vDSP_DFT_SetupObject((vDSP_Length *)v23 + 2, v25);
  v26 = v131;
  v131 = 0u;
  *((_QWORD *)v23 + 8) = *(_QWORD *)v132;
  v27 = *(int64x2_t *)&v132[8];
  *(_OWORD *)v132 = 0u;
  *(int64x2_t *)(v23 + 72) = v27;
  *((_QWORD *)v23 + 11) = *(_QWORD *)&v132[24];
  *(_OWORD *)&v132[16] = 0u;
  *((int64x2_t *)v23 + 2) = vzip1q_s64(v26, v27);
  *((int64x2_t *)v23 + 3) = v26;
  v161 = (float **)v23;
  v28 = v145;
  if (v145 == v143)
  {
    v28 = (void **)&v159;
    (*((void (**)(void **, float **))v143[0] + 3))(v143, &v159);
    (*((void (**)(void **))*v145 + 4))(v145);
    v145 = (void **)v161;
    v161 = &v159;
    v29 = 4;
  }
  else
  {
    v161 = (float **)v145;
    v145 = (void **)v23;
    if (v28 == (void **)&v159)
    {
      v29 = 4;
      v28 = (void **)&v159;
    }
    else
    {
      if (!v28)
        goto LABEL_12;
      v29 = 5;
    }
  }
  (*((void (**)(void **))*v28 + v29))(v28);
LABEL_12:
  if (*(_QWORD *)&v132[8])
  {
    *(_QWORD *)&v132[16] = *(_QWORD *)&v132[8];
    operator delete(*(void **)&v132[8]);
  }
  if (v131.i64[0])
  {
    v131.i64[1] = v131.i64[0];
    operator delete((void *)v131.i64[0]);
  }
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)&buf[16]);
  if (v158[1])
  {
    v158[2] = v158[1];
    operator delete((void *)v158[1]);
  }
  if (v157.i64[0])
  {
    v157.i64[1] = v157.i64[0];
    operator delete((void *)v157.i64[0]);
  }
  vDSP_DFT_DestroySetup(*((vDSP_DFT_Setup *)&v155 + 1));
  if (v153[1])
  {
    v153[2] = v153[1];
    operator delete(v153[1]);
  }
  if (v152[0])
  {
    v152[1] = v152[0];
    operator delete(v152[0]);
  }
  vDSP_DFT_DestroySetup(Setup);
  v103 = v19;
  v146 = Transformer::Forward<float>::ComputeForwardOneFrame_curry;
  v30 = v147;
  std::__function::__value_func<void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::__value_func[abi:ne180100]((uint64_t)v147, (uint64_t)v143);
  Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>>((uint64_t)&__p, (__int128 *)v106, (uint64_t)v112);
  v110[3] = 0;
  v110[4] = 0;
  *(_QWORD *)&__p = &off_1E69EB320;
  DSPSplitComplexV<float>::DSPSplitComplexV(buf, 0);
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v111, 1uLL, (uint64_t)buf);
  if (v131.i64[0])
  {
    v131.i64[1] = v131.i64[0];
    operator delete((void *)v131.i64[0]);
  }
  v102 = v16;
  if (*(_QWORD *)&buf[16])
  {
    v130.i64[0] = *(_QWORD *)&buf[16];
    operator delete(*(void **)&buf[16]);
  }
  v111[13] = 0;
  v31 = (uint64_t)v149;
  v154 = (void (*)(uint64_t, DSPSplitComplex *, uint64_t))v146;
  v32 = &v155;
  if (!v149)
    goto LABEL_31;
  if (v149 != v147)
  {
    v31 = (*(uint64_t (**)(void))(*v149 + 16))();
LABEL_31:
    v156.i64[1] = v31;
    goto LABEL_33;
  }
  v156.i64[1] = (uint64_t)&v155;
  (*(void (**)(_QWORD *, __int128 *))(v147[0] + 24))(v147, &v155);
LABEL_33:
  v100 = v15;
  v101 = v11;
  v157.i64[0] = (uint64_t)v112;
  *(_QWORD *)buf = v154;
  v33 = &buf[8];
  std::__function::__value_func<void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v155);
  v131.i64[0] = v157.i64[0];
  v34 = operator new(0x38uLL);
  v35 = *(_QWORD *)buf;
  *v34 = &off_1E69EB8A8;
  v34[1] = v35;
  std::__function::__value_func<void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::__value_func[abi:ne180100]((uint64_t)(v34 + 2), (uint64_t)&buf[8]);
  v34[6] = v131.i64[0];
  v152[1] = v34;
  std::__function::__value_func<DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::swap[abi:ne180100](&v150, v110);
  v36 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned int *))v152[1];
  if (v152[1] == &v150)
  {
    v38 = 4;
    v36 = &v150;
    v37 = v105;
  }
  else
  {
    v37 = v105;
    if (!v152[1])
      goto LABEL_38;
    v38 = 5;
  }
  (*((void (**)(void))*v36 + v38))();
LABEL_38:
  if ((_BYTE *)v130.i64[1] == &buf[8])
  {
    v39 = 4;
  }
  else
  {
    if (!v130.i64[1])
      goto LABEL_43;
    v39 = 5;
    v33 = (_QWORD *)v130.i64[1];
  }
  (*(void (**)(_QWORD *))(*v33 + 8 * v39))(v33);
LABEL_43:
  if ((__int128 *)v156.i64[1] == &v155)
  {
    v40 = 4;
  }
  else
  {
    if (!v156.i64[1])
      goto LABEL_48;
    v40 = 5;
    v32 = (__int128 *)v156.i64[1];
  }
  (*(void (**)(__int128 *))(*(_QWORD *)v32 + 8 * v40))(v32);
LABEL_48:
  DWORD2(__p) = 0;
  v110[5] = 0;
  v110[6] = 0;
  v109 = 0;
  if (v149 == v147)
  {
    v41 = 4;
  }
  else
  {
    if (!v149)
      goto LABEL_53;
    v41 = 5;
    v30 = v149;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v41))(v30);
LABEL_53:
  v42 = v145;
  if (v145 == v143)
  {
    v43 = 4;
    v42 = v143;
  }
  else
  {
    if (!v145)
      goto LABEL_58;
    v43 = 5;
  }
  (*((void (**)(void))*v42 + v43))();
LABEL_58:
  *(_QWORD *)&__p = &off_1E69EB840;
  if ((v107 & 0x80u) == 0)
    v44 = v107;
  else
    v44 = (size_t)v106[1];
  std::string::basic_string[abi:ne180100]((uint64_t)buf, v44 + 16);
  if (buf[23] >= 0)
    v45 = buf;
  else
    v45 = *(_BYTE **)buf;
  if (v44)
  {
    if ((v107 & 0x80u) == 0)
      v46 = v106;
    else
      v46 = (void **)v106[0];
    memmove(v45, v46, v44);
  }
  strcpy(&v45[v44], "_transformBuffer");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue(v112, (__int128 *)buf);
  if ((buf[23] & 0x80000000) != 0)
    operator delete(*(void **)buf);
  if ((v107 & 0x80u) == 0)
    v47 = v107;
  else
    v47 = (size_t)v106[1];
  std::string::basic_string[abi:ne180100]((uint64_t)buf, v47 + 2);
  if (buf[23] >= 0)
    v48 = buf;
  else
    v48 = *(_BYTE **)buf;
  if (v47)
  {
    if ((v107 & 0x80u) == 0)
      v49 = v106;
    else
      v49 = (void **)v106[0];
    memmove(v48, v49, v47);
  }
  strcpy(&v48[v47], "_x");
  AutoValue<std::vector<float>,(LogTypes)0>::AutoValue(v122, (__int128 *)buf);
  if ((buf[23] & 0x80000000) != 0)
    operator delete(*(void **)buf);
  AutoValue<std::vector<float>,(LogTypes)0>::Set((uint64_t)v122, (uint64_t)v123);
  *(_DWORD *)buf = 0;
  v122[43] = v13 / v12;
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&,float>((uint64_t)v122, v12, buf);
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::PreAllocate<unsigned long const&>((uint64_t)&__p, v103);
  *(_DWORD *)buf = 0;
  std::vector<float>::vector(&v159, v13, buf);
  CreateMagicalWindow((uint64_t)v159, (unint64_t)((char *)v160 - (char *)v159) >> 2);
  *(_DWORD *)buf = 0;
  std::vector<float>::resize((uint64_t)&v159, v37, buf);
  v50 = sqrt((double)((v13 / v12) >> 1));
  *(float *)buf = v50;
  vDSP_vsdiv(v159, 1, (const float *)buf, v159, 1, v160 - v159);
  if (v102)
    SquareVector<float>((uint64_t)&v159, v159, (uint64_t)v160);
  if ((v107 & 0x80u) == 0)
    v51 = v107;
  else
    v51 = (size_t)v106[1];
  std::string::basic_string[abi:ne180100]((uint64_t)v143, v51 + 16);
  if (v144 >= 0)
    v52 = v143;
  else
    v52 = (void **)v143[0];
  if (v51)
  {
    if ((v107 & 0x80u) == 0)
      v53 = v106;
    else
      v53 = (void **)v106[0];
    memmove(v52, v53, v51);
  }
  strcpy((char *)v52 + v51, "_transformBuffer");
  v150 = Transformer::Forward<float>::PrepareForwardTransformBuffer_curry;
  v151 = 0;
  v152[1] = 0;
  v152[0] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v151, v159, (uint64_t)v160, v160 - v159);
  v153[0] = (void *)(v13 / v12);
  Trackable::Trackable<AutoValue<std::vector<float>,(LogTypes)0>>((uint64_t)buf, (__int128 *)v143, (uint64_t)v122);
  *(_QWORD *)&v135 = 0;
  v54 = v133;
  *(_QWORD *)buf = &off_1E69EB4C0;
  v134 = 0;
  v154 = 0;
  v155 = 0uLL;
  AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(&v137, 1uLL, (uint64_t)&v154);
  v142 = 0;
  v154 = (void (*)(uint64_t, DSPSplitComplex *, uint64_t))v150;
  v155 = 0uLL;
  v156.i64[0] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v155, v151, (uint64_t)v152[0], ((char *)v152[0] - (char *)v151) >> 2);
  v55 = v153[0];
  v156.i64[1] = (uint64_t)v153[0];
  v157.i64[0] = (uint64_t)v122;
  v104 = v155;
  v56 = v154;
  v57 = v156.i64[0];
  v156.i64[0] = 0;
  v155 = 0uLL;
  v58 = operator new(0x38uLL);
  *v58 = &off_1E69EB8F0;
  v58[1] = v56;
  *((_OWORD *)v58 + 1) = v104;
  v58[4] = v57;
  v58[5] = v55;
  v58[6] = v122;
  v148 = (uint64_t (**)(uint64_t, uint64_t, uint64_t))v58;
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](&v146, v133);
  v59 = v148;
  if (v148 == &v146)
  {
    v60 = 4;
    v59 = &v146;
  }
  else
  {
    if (!v148)
      goto LABEL_102;
    v60 = 5;
  }
  (*((void (**)(uint64_t (**)(uint64_t, uint64_t, uint64_t)))*v59 + v60))(v59);
LABEL_102:
  if ((_QWORD)v155)
  {
    *((_QWORD *)&v155 + 1) = v155;
    operator delete((void *)v155);
  }
  *(_DWORD *)&buf[8] = 0;
  v136 = 0;
  *(_QWORD *)&buf[16] = 0;
  *((_QWORD *)&v135 + 1) = 0;
  Trackable::operator=((uint64_t)v112, (uint64_t)buf);
  v61 = (uint64_t)v134;
  if (!v134)
    goto LABEL_107;
  if (v134 != v133)
  {
    v61 = (*(uint64_t (**)(_QWORD *))(*v134 + 16))(v134);
LABEL_107:
    v156.i64[0] = v61;
    goto LABEL_109;
  }
  v156.i64[0] = (uint64_t)&v154;
  (*(void (**)(_QWORD *, void (**)(uint64_t, DSPSplitComplex *, uint64_t)))(v133[0] + 24))(v133, &v154);
LABEL_109:
  std::__function::__value_func<std::vector<float> const& ()(std::vector<float>&)>::swap[abi:ne180100](&v154, v113);
  v62 = (void (**)(uint64_t, DSPSplitComplex *, uint64_t))v156.i64[0];
  if ((void (**)(uint64_t, DSPSplitComplex *, uint64_t))v156.i64[0] == &v154)
  {
    v63 = 4;
    v62 = &v154;
  }
  else
  {
    if (!v156.i64[0])
      goto LABEL_114;
    v63 = 5;
  }
  (*((void (**)(void (**)(uint64_t, DSPSplitComplex *, uint64_t)))*v62 + v63))(v62);
LABEL_114:
  v114 = v135;
  v115 = v136;
  v116 = v137;
  std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v117, (char *)__src, (uint64_t)v139, (v139 - (_BYTE *)__src) >> 2);
  v65 = v140;
  v66 = v141;
  if (v141 <= v120)
  {
    v75 = (char *)v118;
    v76 = v119;
    v77 = v119 - v141;
    if (v119 >= v141)
    {
      if (v141)
      {
        v82 = v141;
        do
        {
          if ((char *)v65 != v75)
            std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v75, *(char **)v65, *(_QWORD *)(v65 + 8), (uint64_t)(*(_QWORD *)(v65 + 8) - *(_QWORD *)v65) >> 2);
          v65 += 24;
          v75 += 24;
          --v82;
        }
        while (v82);
      }
      if (v76 != v66)
      {
        v83 = v66 - v76;
        v84 = v75 + 8;
        do
        {
          v85 = (void *)*(v84 - 1);
          if (v85)
          {
            *v84 = v85;
            operator delete(v85);
          }
          v84 += 3;
          v81 = __CFADD__(v83++, 1);
        }
        while (!v81);
      }
    }
    else
    {
      if (v119)
      {
        v78 = v119;
        do
        {
          if ((char *)v65 != v75)
            std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v75, *(char **)v65, *(_QWORD *)(v65 + 8), (uint64_t)(*(_QWORD *)(v65 + 8) - *(_QWORD *)v65) >> 2);
          v65 += 24;
          v75 += 24;
          --v78;
        }
        while (v78);
      }
      if (v66 != v76)
      {
        v79 = 0;
        do
        {
          v80 = &v75[v79];
          *(_QWORD *)v80 = 0;
          *((_QWORD *)v80 + 1) = 0;
          *((_QWORD *)v80 + 2) = 0;
          std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v75[v79], *(const void **)(v65 + v79), *(_QWORD *)(v65 + v79 + 8), (uint64_t)(*(_QWORD *)(v65 + v79 + 8) - *(_QWORD *)(v65 + v79)) >> 2);
          v79 += 24;
          v81 = __CFADD__(v77++, 1);
        }
        while (!v81);
      }
    }
    v119 = v66;
  }
  else
  {
    if (v141 >= 0x555555555555556)
      boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v64);
    v67 = (char *)operator new(24 * v141);
    v68 = v118;
    if (v118)
    {
      v69 = v119;
      if (v119)
      {
        v70 = (char *)v118 + 8;
        do
        {
          v71 = (void *)*(v70 - 1);
          if (v71)
          {
            *v70 = v71;
            operator delete(v71);
          }
          v70 += 3;
          --v69;
        }
        while (v69);
      }
      v119 = 0;
      operator delete(v68);
    }
    v72 = 0;
    v118 = v67;
    v120 = v66;
    v119 = 0;
    do
    {
      v73 = v65 + v72;
      v74 = &v67[v72];
      *(_QWORD *)v74 = 0;
      *((_QWORD *)v74 + 1) = 0;
      *((_QWORD *)v74 + 2) = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v67[v72], *(const void **)(v65 + v72), *(_QWORD *)(v65 + v72 + 8), (uint64_t)(*(_QWORD *)(v65 + v72 + 8) - *(_QWORD *)(v65 + v72)) >> 2);
      v72 += 24;
    }
    while (v73 + 24 != v65 + 24 * v66);
    v119 -= 0x5555555555555555 * (v72 >> 3);
  }
  v121 = v142;
  *(_QWORD *)buf = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector(&v140);
  if (__src)
  {
    v139 = __src;
    operator delete(__src);
  }
  if (v134 == v133)
  {
    v86 = 4;
  }
  else
  {
    if (!v134)
      goto LABEL_156;
    v86 = 5;
    v54 = v134;
  }
  (*(void (**)(_QWORD *))(*v54 + 8 * v86))(v54);
LABEL_156:
  Trackable::~Trackable((void **)buf);
  if (v151)
  {
    v152[0] = v151;
    operator delete(v151);
  }
  if (v144 < 0)
    operator delete(v143[0]);
  AutoValue<std::vector<float>,(LogTypes)0>::PreAllocate<unsigned long const&>((uint64_t)v112, v105);
  if (v159)
  {
    v160 = v159;
    operator delete(v159);
  }
  if ((char)v107 < 0)
    operator delete(v106[0]);
  Trackable::Initialize((uint64_t)&__p);
  if (v12 <= v100)
  {
    v87 = 0;
    v88 = 0;
    if (v99 <= 1)
      v89 = 1;
    else
      v89 = v99;
    do
    {
      LODWORD(v154) = 0;
      std::vector<float>::vector(buf, v12, &v154);
      v90 = *(_DWORD **)buf;
      v91 = (int *)(*v101 + v87);
      v92 = v12;
      do
      {
        v93 = *v91++;
        *v90++ = v93;
        --v92;
      }
      while (v92);
      AutoValue<std::vector<float>,(LogTypes)0>::Set((Trackable *)v123, (uint64_t)buf);
      v94 = AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::Get((uint64_t)&__p);
      DSPSplitComplexV<float>::operator=(*a1 + (v88 << 6), v94);
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)&buf[8] = *(_QWORD *)buf;
        operator delete(*(void **)buf);
      }
      ++v88;
      v87 += 4 * v12;
    }
    while (v88 != v89);
  }
  Transformer::Forward<float>::~Forward((uint64_t)&__p);
  v123[0] = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector(v128);
  if (v126)
  {
    v127 = v126;
    operator delete(v126);
  }
  v95 = v125;
  if (v125 == v124)
  {
    v96 = 4;
    v95 = v124;
    goto LABEL_179;
  }
  if (v125)
  {
    v96 = 5;
LABEL_179:
    (*(void (**)(_QWORD *))(*v95 + 8 * v96))(v95);
  }
  Trackable::~Trackable(v123);
  return a1;
}

void sub_1B6573E9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  void *v26;
  unint64_t *v27;
  uint64_t v28;

  __cxa_free_exception(v26);
  v27 = (unint64_t *)STACK[0x7A0];
  if ((unint64_t *)STACK[0x7A0] == &STACK[0x788])
  {
    v28 = 4;
    v27 = &STACK[0x788];
  }
  else
  {
    if (!v27)
      goto LABEL_6;
    v28 = 5;
  }
  (*(void (**)(void))(*v27 + 8 * v28))();
LABEL_6:
  if (a26 < 0)
    operator delete(__p);
  JUMPOUT(0x1B657429CLL);
}

void sub_1B657415C()
{
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue((uint64_t)&STACK[0x620]);
  JUMPOUT(0x1B6574214);
}

void sub_1B657416C(void *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  void *v6;

  if (a2)
  {
    __cxa_begin_catch(a1);
    if (v3 != v2)
    {
      v5 = (_QWORD *)(v2 + 8);
      do
      {
        v6 = (void *)*(v5 - 1);
        if (v6)
        {
          *v5 = v6;
          operator delete(v6);
        }
        v5 += 3;
        v4 -= 24;
      }
      while (v4);
    }
    __cxa_rethrow();
  }
  JUMPOUT(0x1B65742A4);
}

void sub_1B65741AC()
{
  __cxa_end_catch();
  AutoValue<std::vector<float>,(LogTypes)0>::~AutoValue((uint64_t)&STACK[0x620]);
  JUMPOUT(0x1B6574214);
}

void sub_1B65741C4(void *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  void *v6;

  if (a2)
  {
    __cxa_begin_catch(a1);
    if (v3 != v2)
    {
      v5 = (_QWORD *)(v2 + 8);
      do
      {
        v6 = (void *)*(v5 - 1);
        if (v6)
        {
          *v5 = v6;
          operator delete(v6);
        }
        v5 += 3;
        v4 -= 24;
      }
      while (v4);
    }
    __cxa_rethrow();
  }
  JUMPOUT(0x1B65742A4);
}

void sub_1B6574204()
{
  __cxa_end_catch();
  JUMPOUT(0x1B657420CLL);
}

void sub_1B6574270(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t AutoValue<unsigned long,(LogTypes)0>::AutoValue(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  _QWORD *v4;

  v3 = Trackable::Trackable<>(a1, a2);
  *(_QWORD *)v3 = &off_1E69EB9A0;
  *(_QWORD *)(v3 + 248) = 0;
  *(_QWORD *)(v3 + 256) = 0;
  *(_QWORD *)(v3 + 280) = 0;
  *(_QWORD *)(v3 + 288) = 1;
  *(_QWORD *)(v3 + 296) = 0;
  *(_QWORD *)(v3 + 304) = 0;
  *(_OWORD *)(v3 + 312) = xmmword_1B66A0DC0;
  v4 = operator new(8uLL);
  *(_QWORD *)(a1 + 304) = v4;
  *v4 = 0;
  *(_OWORD *)(a1 + 320) = xmmword_1B66A0DC0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B6574328(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;

  v3 = *(_QWORD **)(v1 + 248);
  if (v3 == (_QWORD *)(v1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(v1 + 224);
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  Trackable::~Trackable((void **)v1);
  _Unwind_Resume(a1);
}

uint64_t AutoValue<BOOL,(LogTypes)0>::AutoValue(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  _BYTE *v4;

  v3 = Trackable::Trackable<>(a1, a2);
  *(_QWORD *)v3 = &off_1E69EB2C0;
  *(_QWORD *)(v3 + 248) = 0;
  *(_QWORD *)(v3 + 256) = 0;
  *(_QWORD *)(v3 + 280) = 0;
  *(_QWORD *)(v3 + 288) = 1;
  *(_BYTE *)(v3 + 296) = 0;
  *(_QWORD *)(v3 + 304) = 0;
  *(_OWORD *)(v3 + 312) = xmmword_1B66A0DC0;
  v4 = operator new(1uLL);
  *(_QWORD *)(a1 + 304) = v4;
  *v4 = 0;
  *(_OWORD *)(a1 + 320) = xmmword_1B66A0DC0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B65743EC(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;

  v3 = *(_QWORD **)(v1 + 248);
  if (v3 == (_QWORD *)(v1 + 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(v1 + 224);
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  Trackable::~Trackable((void **)v1);
  _Unwind_Resume(a1);
}

_QWORD *Transformer::ComputeOverlapXA<unsigned long>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;

  v5 = (_QWORD *)AutoValue<unsigned long,(LogTypes)0>::Get(a2);
  *a1 = *v5 / *(_QWORD *)AutoValue<unsigned long,(LogTypes)0>::Get(a3);
  return a1;
}

uint64_t AutoValue<unsigned long,(LogTypes)0>::AutoValue<unsigned long const& ()(unsigned long &,AutoValue<unsigned long,(LogTypes)0>&,AutoValue<unsigned long,(LogTypes)0>&),unsigned long,unsigned long>(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 72), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v9 = *a2;
    *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 72) = v9;
  }
  *(_OWORD *)(a1 + 104) = 0u;
  *(_BYTE *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  Trackable::BuildDepsList<AutoValue<std::vector<float>,(LogTypes)0>,AutoValue<float,(LogTypes)0>>((void **)(a1 + 128), a4, a5);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E69EB9A0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 1;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 312) = xmmword_1B66A0DC0;
  v10 = operator new(8uLL);
  *(_QWORD *)(a1 + 304) = v10;
  *v10 = 0;
  *(_OWORD *)(a1 + 320) = xmmword_1B66A0DC0;
  v11 = operator new(0x20uLL);
  *v11 = &off_1E69EB9E0;
  v11[1] = a3;
  v11[2] = a4;
  v11[3] = a5;
  v16 = v11;
  std::__function::__value_func<unsigned long const& ()(unsigned long &)>::swap[abi:ne180100](v15, (_QWORD *)(a1 + 224));
  v12 = v16;
  if (v16 == v15)
  {
    v13 = 4;
    v12 = v15;
    goto LABEL_8;
  }
  if (v16)
  {
    v13 = 5;
LABEL_8:
    (*(void (**)(void))(*v12 + 8 * v13))();
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  return a1;
}

void sub_1B6574640(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 40) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *Transformer::WholeSignalForward<float>::ComputeNumberOfWholeFrames(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  unint64_t *v8;

  v7 = (_QWORD *)AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v8 = (unint64_t *)AutoValue<unsigned long,(LogTypes)0>::Get(a3);
  *a1 = (unint64_t)(float)(ceilf((float)(unint64_t)((uint64_t)(v7[1] - *v7) >> 2) / (float)*v8)
                                + (float)(unint64_t)(*(_QWORD *)AutoValue<unsigned long,(LogTypes)0>::Get(a4)
                                                          - 1));
  return a1;
}

_QWORD *Transformer::MultiplyAVAV<unsigned long>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  v5 = *(_QWORD *)AutoValue<unsigned long,(LogTypes)0>::Get(a2);
  *a1 = *(_QWORD *)AutoValue<unsigned long,(LogTypes)0>::Get(a3) * v5;
  return a1;
}

uint64_t Transformer::WholeSignalForward<float>::ExtendWithZeros(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  int64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = (_QWORD *)AutoValue<unsigned long,(LogTypes)0>::Get(a3);
  v7 = *(_QWORD *)(v5 + 8) - *(_QWORD *)v5;
  if (*v6 < (unint64_t)(v7 >> 2))
    __assert_rtn("ExtendWithZeros", "Transformer.h", 578, "x.size() <= newLength");
  v8 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (*v6 != v8 >> 2)
    __assert_rtn("ExtendWithZeros", "Transformer.h", 581, "result.size() == newLength");
  if (v8 < (unint64_t)v7)
    __assert_rtn("CopyVector", "VectorUtils.h", 882, "result.size() >= input.size()");
  memcpy(*(void **)a1, *(const void **)v5, v7);
  v9 = *(_QWORD *)(v5 + 8) - *(_QWORD *)v5;
  v10 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v10 > v9)
    bzero((void *)(*(_QWORD *)a1 + v9), v10 - v9);
  return a1;
}

void AutoValue<unsigned long,(LogTypes)0>::Set(Trackable *this, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v4;

  ++*((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 35);
  if (*((_QWORD *)this + 36) < v2)
    __assert_rtn("DecrementCirc", "AutoValue.h", 491, "index <= _C");
  if (!v2)
    v2 = *((_QWORD *)this + 36);
  v4 = v2 - 1;
  *((_QWORD *)this + 35) = v4;
  if (*((_QWORD *)this + 39) <= v4)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  *(_QWORD *)(*((_QWORD *)this + 38) + 8 * v4) = *a2;
  if (*((_DWORD *)this + 2) != 1)
  {
    *((_DWORD *)this + 2) = 1;
    Trackable::Uninitialize(this);
  }
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
}

void AutoValue<std::vector<float>,(LogTypes)0>::Set(Trackable *this, uint64_t a2)
{
  unint64_t v2;
  unint64_t v4;
  char *v5;

  ++*((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 35);
  if (*((_QWORD *)this + 36) < v2)
    __assert_rtn("DecrementCirc", "AutoValue.h", 491, "index <= _C");
  if (!v2)
    v2 = *((_QWORD *)this + 36);
  v4 = v2 - 1;
  *((_QWORD *)this + 35) = v4;
  if (*((_QWORD *)this + 41) <= v4)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  v5 = (char *)(*((_QWORD *)this + 40) + 24 * v4);
  if (v5 != (char *)a2)
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v5, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  if (*((_DWORD *)this + 2) != 1)
  {
    *((_DWORD *)this + 2) = 1;
    Trackable::Uninitialize(this);
  }
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 8) = 0;
}

uint64_t AutoValue<unsigned long,(LogTypes)0>::Get(uint64_t a1)
{
  _QWORD *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::locale v14;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"WARNING: Calling Get() on an AutoValue ('", 41);
    v3 = *(char *)(a1 + 95);
    if (v3 >= 0)
      v4 = a1 + 72;
    else
      v4 = *(_QWORD *)(a1 + 72);
    if (v3 >= 0)
      v5 = *(unsigned __int8 *)(a1 + 95);
    else
      v5 = *(_QWORD *)(a1 + 80);
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, v4, v5);
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"') without initializing first. Initializing now.", 48);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v14);
    std::ostream::put();
    std::ostream::flush();
    Trackable::Initialize(a1);
  }
  v9 = *(_DWORD *)(a1 + 8);
  if (v9 == 2)
  {
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 272) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      v12 = *(_QWORD *)AutoValue<unsigned long,(LogTypes)0>::Get(*(_QWORD *)(a1 + 256));
      *(_QWORD *)AutoValue<unsigned long,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280)) = v12;
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 16);
    }
  }
  else if (v9 != 1)
  {
    if (!*(_BYTE *)(a1 + 24))
      __assert_rtn("Get", "AutoValue.h", 668, "_isInitialized == true");
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 264) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a1 + 16);
      v10 = AutoValue<unsigned long,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
      v11 = *(_QWORD *)(a1 + 248);
      if (!v11)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, v10);
    }
  }
  return AutoValue<unsigned long,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
}

void sub_1B6574C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

_QWORD *AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::CircularBuffer(_QWORD *a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v4;
  const char *v6;
  char *v7;
  uint64_t v8;
  char *v9;

  v4 = a2;
  *a1 = 0;
  a1[1] = a2;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  std::vector<DSPSplitComplexV<float>>::__init_with_size[abi:ne180100]<DSPSplitComplexV<float>*,DSPSplitComplexV<float>*>(a1 + 2, *a3, a3[1], (a3[1] - *a3) >> 6);
  a1[5] = 0;
  a1[6] = v4;
  a1[7] = 0;
  if (v4)
  {
    if (v4 >= 0x555555555555556)
      boost::container::throw_length_error((boost::container *)"get_next_capacity, allocator's max size reached", v6);
    v7 = (char *)operator new(24 * v4);
    v8 = 0;
    a1[5] = v7;
    a1[7] = v4;
    do
    {
      v9 = &v7[v8];
      *(_QWORD *)v9 = 0;
      *((_QWORD *)v9 + 1) = 0;
      *((_QWORD *)v9 + 2) = 0;
      std::vector<DSPSplitComplexV<float>>::__init_with_size[abi:ne180100]<DSPSplitComplexV<float>*,DSPSplitComplexV<float>*>(&v7[v8], *a3, a3[1], (a3[1] - *a3) >> 6);
      v8 += 24;
      --v4;
    }
    while (v4);
  }
  return a1;
}

void sub_1B6574DB8()
{
  __break(1u);
}

void sub_1B6574DF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  __cxa_end_catch();
  if (*(_QWORD *)(v2 + 56))
    operator delete(*(void **)(v2 + 40));
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t AutoValue<unsigned long,(LogTypes)0>::CircularBuffer::operator[](unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;

  v1 = a1[1];
  if (!v1)
    __assert_rtn("operator[]", "AutoValue.h", 562, "index < _C");
  v2 = *a1;
  if (*a1 >= v1)
    __assert_rtn("operator[]", "AutoValue.h", 569, "theIndex < _C");
  if (a1[4] <= v2)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  return a1[3] + 8 * v2;
}

void std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E69EBA70;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EBA70;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

_QWORD *std::__function::__value_func<unsigned long const& ()(unsigned long &)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1B65750BC(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void std::__function::__func<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>>>,unsigned long const& ()(unsigned long &)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>>>,unsigned long const& ()(unsigned long &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E69EBA28;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>>>,unsigned long const& ()(unsigned long &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EBA28;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>>>,unsigned long const& ()(unsigned long &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
}

void std::__function::__func<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<unsigned long,(LogTypes)0> &,AutoValue<unsigned long,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>>,std::allocator<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<unsigned long,(LogTypes)0> &,AutoValue<unsigned long,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>>>,unsigned long const& ()(unsigned long &)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<unsigned long,(LogTypes)0> &,AutoValue<unsigned long,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>>,std::allocator<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<unsigned long,(LogTypes)0> &,AutoValue<unsigned long,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>>>,unsigned long const& ()(unsigned long &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E69EB9E0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<unsigned long,(LogTypes)0> &,AutoValue<unsigned long,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>>,std::allocator<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<unsigned long,(LogTypes)0> &,AutoValue<unsigned long,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>>>,unsigned long const& ()(unsigned long &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB9E0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<unsigned long,(LogTypes)0> &,AutoValue<unsigned long,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>>,std::allocator<std::__bind<unsigned long const& (&)(unsigned long &,AutoValue<unsigned long,(LogTypes)0> &,AutoValue<unsigned long,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>,std::reference_wrapper<AutoValue<unsigned long,(LogTypes)0>>>>,unsigned long const& ()(unsigned long &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

uint64_t Trackable::Trackable<>(uint64_t a1, __int128 *a2)
{
  std::string *v3;
  __int128 v4;

  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  v3 = (std::string *)(a1 + 72);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    v3->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = v4;
  }
  *(_BYTE *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 8) = 1;
  return a1;
}

void sub_1B6575290(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 40) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AutoValue<std::vector<DSPSplitComplexV<float>>,(LogTypes)0>::CircularBuffer::~CircularBuffer(uint64_t a1)
{
  void **v3;

  boost::container::vector<std::vector<DSPSplitComplexV<float>>,void,void>::~vector(a1 + 40);
  v3 = (void **)(a1 + 16);
  std::vector<DSPSplitComplexV<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

void std::__function::__func<std::__bind<std::vector<DSPSplitComplexV<float>> const& (&)(std::vector<DSPSplitComplexV<float>>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<Transformer::windowTypes,(LogTypes)0>,AutoValue&<BOOL,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<Transformer::windowTypes>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<DSPSplitComplexV<float>> const& (&)(std::vector<DSPSplitComplexV<float>>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<Transformer::windowTypes,(LogTypes)0>,AutoValue&<BOOL,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<Transformer::windowTypes>,std::reference_wrapper<AutoValue&>>>,std::vector<DSPSplitComplexV<float>> const& ()(std::vector<DSPSplitComplexV<float>>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<DSPSplitComplexV<float>> const& (&)(std::vector<DSPSplitComplexV<float>>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<Transformer::windowTypes,(LogTypes)0>,AutoValue&<BOOL,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<Transformer::windowTypes>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<DSPSplitComplexV<float>> const& (&)(std::vector<DSPSplitComplexV<float>>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<Transformer::windowTypes,(LogTypes)0>,AutoValue&<BOOL,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<Transformer::windowTypes>,std::reference_wrapper<AutoValue&>>>,std::vector<DSPSplitComplexV<float>> const& ()(std::vector<DSPSplitComplexV<float>>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x38uLL);
  *(_QWORD *)v2 = &off_1E69EB958;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<DSPSplitComplexV<float>> const& (&)(std::vector<DSPSplitComplexV<float>>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<Transformer::windowTypes,(LogTypes)0>,AutoValue&<BOOL,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<Transformer::windowTypes>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<DSPSplitComplexV<float>> const& (&)(std::vector<DSPSplitComplexV<float>>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<Transformer::windowTypes,(LogTypes)0>,AutoValue&<BOOL,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<Transformer::windowTypes>,std::reference_wrapper<AutoValue&>>>,std::vector<DSPSplitComplexV<float>> const& ()(std::vector<DSPSplitComplexV<float>>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E69EB958;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<DSPSplitComplexV<float>> const& (&)(std::vector<DSPSplitComplexV<float>>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<Transformer::windowTypes,(LogTypes)0>,AutoValue&<BOOL,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<Transformer::windowTypes>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<DSPSplitComplexV<float>> const& (&)(std::vector<DSPSplitComplexV<float>>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<unsigned long,(LogTypes)0>,AutoValue&<Transformer::windowTypes,(LogTypes)0>,AutoValue&<BOOL,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<AutoValue&>,std::reference_wrapper<Transformer::windowTypes>,std::reference_wrapper<AutoValue&>>>,std::vector<DSPSplitComplexV<float>> const& ()(std::vector<DSPSplitComplexV<float>>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
}

uint64_t AutoValue<Transformer::windowTypes,(LogTypes)0>::Get(uint64_t a1)
{
  _QWORD *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  std::locale v14;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"WARNING: Calling Get() on an AutoValue ('", 41);
    v3 = *(char *)(a1 + 95);
    if (v3 >= 0)
      v4 = a1 + 72;
    else
      v4 = *(_QWORD *)(a1 + 72);
    if (v3 >= 0)
      v5 = *(unsigned __int8 *)(a1 + 95);
    else
      v5 = *(_QWORD *)(a1 + 80);
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, v4, v5);
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"') without initializing first. Initializing now.", 48);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v14);
    std::ostream::put();
    std::ostream::flush();
    Trackable::Initialize(a1);
  }
  v9 = *(_DWORD *)(a1 + 8);
  if (v9 == 2)
  {
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 272) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      v12 = *(_DWORD *)AutoValue<Transformer::windowTypes,(LogTypes)0>::Get(*(_QWORD *)(a1 + 256));
      *(_DWORD *)AutoValue<Transformer::windowTypes,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280)) = v12;
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 16);
    }
  }
  else if (v9 != 1)
  {
    if (!*(_BYTE *)(a1 + 24))
      __assert_rtn("Get", "AutoValue.h", 668, "_isInitialized == true");
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 264) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a1 + 16);
      v10 = AutoValue<Transformer::windowTypes,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
      v11 = *(_QWORD *)(a1 + 248);
      if (!v11)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, v10);
    }
  }
  return AutoValue<Transformer::windowTypes,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
}

void sub_1B6575554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

void Transformer::Forward<float>::~Forward(uint64_t a1)
{
  void **v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  _QWORD *v11;
  uint64_t v12;

  *(_QWORD *)a1 = &off_1E69EB840;
  v2 = (void **)(a1 + 744);
  *(_QWORD *)(a1 + 744) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 1064));
  v3 = *(void **)(a1 + 1040);
  if (v3)
  {
    *(_QWORD *)(a1 + 1048) = v3;
    operator delete(v3);
  }
  v4 = *(_QWORD **)(a1 + 992);
  if (v4 == (_QWORD *)(a1 + 968))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 968);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  Trackable::~Trackable(v2);
  *(_QWORD *)(a1 + 392) = &off_1E69EB4C0;
  boost::container::vector<std::vector<float>,void,void>::~vector((_QWORD *)(a1 + 712));
  v6 = *(void **)(a1 + 688);
  if (v6)
  {
    *(_QWORD *)(a1 + 696) = v6;
    operator delete(v6);
  }
  v7 = *(_QWORD **)(a1 + 640);
  if (v7 == (_QWORD *)(a1 + 616))
  {
    v8 = 4;
    v7 = (_QWORD *)(a1 + 616);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_15:
  Trackable::~Trackable((void **)(a1 + 392));
  *(_QWORD *)a1 = &off_1E69EB320;
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector((_QWORD *)(a1 + 360));
  v9 = *(void **)(a1 + 336);
  if (v9)
  {
    *(_QWORD *)(a1 + 344) = v9;
    operator delete(v9);
  }
  v10 = *(void **)(a1 + 312);
  if (v10)
  {
    *(_QWORD *)(a1 + 320) = v10;
    operator delete(v10);
  }
  v11 = *(_QWORD **)(a1 + 248);
  if (v11 == (_QWORD *)(a1 + 224))
  {
    v12 = 4;
    v11 = (_QWORD *)(a1 + 224);
    goto LABEL_23;
  }
  if (v11)
  {
    v12 = 5;
LABEL_23:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
  Trackable::~Trackable((void **)a1);
}

{
  Transformer::Forward<float>::~Forward(a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t Transformer::Forward<float>::ComputeForwardOneFrame_curry(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = *(_QWORD *)(a3 + 24);
  if (!v6)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 48))(v6, a1, v5);
  return a1;
}

uint64_t std::__function::__value_func<void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

void AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::PreAllocate<unsigned long const&>(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  __int128 v4;
  int64x2_t v5;
  uint64_t v6;
  int64x2_t v7;
  __int128 v8;
  uint64_t v9;
  void *v10[2];
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  _OWORD v15[2];
  void *v16[2];
  _BYTE __p[32];
  _QWORD v18[3];

  v3 = *(_QWORD *)(a1 + 384) + 1;
  DSPSplitComplexV<float>::DSPSplitComplexV(v10, a2);
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(v15, v3, (uint64_t)v10);
  v4 = v15[0];
  v5 = *(int64x2_t *)v16;
  v6 = *(_QWORD *)__p;
  v7 = *(int64x2_t *)&__p[8];
  v8 = *(_OWORD *)(a1 + 328);
  *(_OWORD *)v16 = *(_OWORD *)(a1 + 312);
  *(_OWORD *)__p = v8;
  v9 = *(_QWORD *)&__p[24];
  *(_OWORD *)&__p[16] = *(_OWORD *)(a1 + 344);
  *(int64x2_t *)(a1 + 312) = v5;
  *(_QWORD *)(a1 + 328) = v6;
  *(int64x2_t *)(a1 + 336) = v7;
  *(_QWORD *)(a1 + 352) = v9;
  *(_OWORD *)(a1 + 280) = v4;
  *(int64x2_t *)(a1 + 296) = vzip1q_s64(v5, v7);
  if (v15 != (_OWORD *)(a1 + 280))
    boost::container::vector<DSPSplitComplexV<float>,void,void>::priv_move_assign<void>(a1 + 360, v18);
  boost::container::vector<DSPSplitComplexV<float>,void,void>::~vector(v18);
  if (*(_QWORD *)&__p[8])
  {
    *(_QWORD *)&__p[16] = *(_QWORD *)&__p[8];
    operator delete(*(void **)&__p[8]);
  }
  if (v16[0])
  {
    v16[1] = v16[0];
    operator delete(v16[0]);
  }
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  if (v11)
  {
    v12 = v11;
    operator delete(v11);
  }
}

void sub_1B6575894(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::~DictionaryRef_iterator((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t Transformer::Forward<float>::PrepareForwardTransformBuffer_curry(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;

  v6 = *a4;
  if ((_DWORD)v6)
  {
    v8 = 0;
    v9 = *a4;
    do
    {
      v10 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, (v9 - 1));
      v11 = *(_QWORD *)(v10 + 8) - *(_QWORD *)v10;
      v12 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
      v13 = (v11 >> 2) * v6;
      if (v12 != v13 && v12 != 2 * v13)
        __assert_rtn("LayFlat_curry", "Transformer.h", 234, "(result.size() == numItems * itemSize) || (result.size() == numItems * itemSize * 2)");
      memcpy((void *)(*(_QWORD *)a1 + 4 * (v11 >> 2) * v8++), *(const void **)v10, v11);
      --v9;
    }
    while (v9);
  }
  return MultiplyVectorVector<float>(a1, *(const float **)a1, *(_QWORD *)(a1 + 8), *(const float **)a3, *(_QWORD *)(a3 + 8));
}

_QWORD *std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E69EB8F0;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E69EB8F0;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1BCC95CECLL);
}

char *std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  const void *v3;
  uint64_t v4;

  v2 = (char *)operator new(0x38uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(const void **)(a1 + 16);
  *(_QWORD *)v2 = &off_1E69EB8F0;
  *((_QWORD *)v2 + 1) = v4;
  *((_QWORD *)v2 + 3) = 0;
  *((_QWORD *)v2 + 4) = 0;
  *((_QWORD *)v2 + 2) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)v2 + 2, v3, *(_QWORD *)(a1 + 24), (uint64_t)(*(_QWORD *)(a1 + 24) - (_QWORD)v3) >> 2);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  return v2;
}

void sub_1B6575AD0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *result;

  v4 = *(_QWORD *)(a1 + 8);
  *a2 = &off_1E69EB8F0;
  a2[1] = v4;
  a2[3] = 0;
  a2[4] = 0;
  a2[2] = 0;
  result = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a2 + 2, *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 2);
  a2[5] = *(_QWORD *)(a1 + 40);
  a2[6] = *(_QWORD *)(a1 + 48);
  return result;
}

void std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::destroy(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(a1 + 24) = v2;
    operator delete(v2);
  }
}

void std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::destroy_deallocate(_QWORD *__p)
{
  void *v2;

  v2 = (void *)__p[2];
  if (v2)
  {
    __p[3] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

uint64_t std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,std::vector<float> const&,unsigned int const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::vector<float>&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(_QWORD *a1, uint64_t a2)
{
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD *, int *);
  uint64_t v4;
  int v6;

  v3 = (uint64_t (*)(uint64_t, uint64_t, _QWORD *, int *))a1[1];
  v4 = a1[6];
  v6 = a1[5];
  return v3(a2, v4, a1 + 2, &v6);
}

__n128 boost::container::vector<DSPSplitComplexV<float>,void,void>::priv_move_assign<void>(uint64_t a1, _QWORD *a2)
{
  __n128 result;

  if ((_QWORD *)a1 == a2 && a2[1])
    __assert_rtn("priv_move_assign", "vector.hpp", 2480, "this != &x || x.size() == 0");
  boost::container::vector<DSPSplitComplexV<float>,void,void>::priv_destroy_all((_QWORD *)a1);
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  *(_QWORD *)a1 = *a2;
  result = *(__n128 *)(a2 + 1);
  *(__n128 *)(a1 + 8) = result;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

_QWORD *std::__function::__func<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E69EB8A8;
  v2 = a1 + 2;
  v3 = (_QWORD *)a1[5];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E69EB8A8;
  v1 = a1 + 2;
  v2 = (_QWORD *)a1[5];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x38uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_1E69EB8A8;
  v2[1] = v3;
  std::__function::__value_func<void ()(std::vector<long long> const&)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  v2[6] = *(_QWORD *)(a1 + 48);
  return v2;
}

void sub_1B6575D50(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 8);
  *a2 = &off_1E69EB8A8;
  a2[1] = v4;
  result = std::__function::__value_func<void ()(std::vector<long long> const&)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
  a2[6] = *(_QWORD *)(a1 + 48);
  return result;
}

_QWORD *std::__function::__func<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::destroy(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 16);
  result = *(_QWORD **)(a1 + 40);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 16;
  v3 = (char *)*((_QWORD *)__p + 5);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

uint64_t std::__function::__func<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<DSPSplitComplexV<float> const& (&)(DSPSplitComplexV<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,Transformer::MultiRadixRealTransformer<float,(TransformDirections)0>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,DSPSplitComplexV<float> const& ()(DSPSplitComplexV<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1 + 8))(a2, *(_QWORD *)(a1 + 48), a1 + 16);
}

void FFT_Forward<float>(uint64_t a1, DSPSplitComplex *a2, uint64_t a3)
{
  vDSP_Length v6;
  unint64_t v7;
  uint64_t v8;
  vDSP_Length v9;
  float __B;

  v6 = DSPSplitComplexV<float>::size(a2);
  v7 = (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2;
  if (v6 != v7 >> 1)
    __assert_rtn("FFT_Forward", "VectorUtils.h", 1053, "result.size() == (input.size() / 2)");
  if (*(_QWORD *)a1 != v7)
    __assert_rtn("FFT_Forward", "VectorUtils.h", 1054, "setup.size() == input.size()");
  vDSP_ctoz(*(const DSPComplex **)a3, 2, a2, 1, v6);
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(a1 + 8), a2->realp, a2->imagp, a2->realp, a2->imagp);
  __B = 0.5;
  v8 = DSPSplitComplexV<float>::size(a2);
  if (v8 != DSPSplitComplexV<float>::size(a2))
    __assert_rtn("MultiplyCVectorRScalar", "VectorUtils.h", 391, "result.size() == a.size()");
  v9 = DSPSplitComplexV<float>::size(a2);
  vDSP_zrvmul(a2, 1, &__B, 0, a2, 1, v9);
}

vDSP_Length *vDSP_DFT_SetupObject<float,(TransformDirections)0>::vDSP_DFT_SetupObject(vDSP_Length *a1, vDSP_Length a2)
{
  vDSP_DFT_Setup Setup;
  vDSP_Length v5;
  CAXException *exception;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *a1 = a2;
  Setup = vDSP_DFT_zrop_CreateSetup(0, a2, vDSP_DFT_FORWARD);
  a1[1] = (vDSP_Length)Setup;
  if (!Setup)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v5 = *a1;
      v7 = 136315650;
      v8 = "VectorUtils.h";
      v9 = 1024;
      v10 = 1000;
      v11 = 1024;
      v12 = v5;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d FFT object failed to Initialize() with block-size %u.", (uint8_t *)&v7, 0x18u);
    }
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "FFT object failed to initialize.", -1);
  }
  return a1;
}

void sub_1B6576088(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>::~__bind(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(_QWORD *)(a1 + 72) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 40);
  if (v3)
  {
    *(_QWORD *)(a1 + 48) = v3;
    operator delete(v3);
  }
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)(a1 + 16));
  return a1;
}

uint64_t std::__function::__func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::~__func(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = &off_1E69EB860;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 48);
  if (v3)
  {
    *(_QWORD *)(a1 + 56) = v3;
    operator delete(v3);
  }
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)(a1 + 24));
  return a1;
}

void std::__function::__func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::~__func(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = &off_1E69EB860;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 48);
  if (v3)
  {
    *(_QWORD *)(a1 + 56) = v3;
    operator delete(v3);
  }
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)(a1 + 24));
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x60uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_1E69EB860;
  v2[1] = v3;
  std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul>,vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1>,std::placeholders::__ph<2>,DSPSplitComplexV<float>>::__tuple_impl(v2 + 2, (vDSP_Length *)(a1 + 16));
  return v2;
}

void sub_1B65761F4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

vDSP_Length *std::__function::__func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_1E69EB860;
  a2[1] = v2;
  return std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul>,vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1>,std::placeholders::__ph<2>,DSPSplitComplexV<float>>::__tuple_impl(a2 + 2, (vDSP_Length *)(a1 + 16));
}

void std::__function::__func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::destroy(uint64_t a1)
{
  std::__function::__alloc_func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::destroy[abi:ne180100](a1 + 8);
}

void std::__function::__func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::destroy[abi:ne180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

uint64_t std::__function::__func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8))(a1 + 16, a2, a3, a1 + 32);
}

void std::__function::__alloc_func<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>,std::allocator<std::__bind<void (&)(vDSP_DFT_SetupObject<float,(TransformDirections)0> &,DSPSplitComplexV<float> &,std::vector<float> const&,DSPSplitComplexV<float> &),vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,DSPSplitComplexV<float>>>,void ()(DSPSplitComplexV<float> &,std::vector<float> const&)>::destroy[abi:ne180100](uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(_QWORD *)(a1 + 72) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 40);
  if (v3)
  {
    *(_QWORD *)(a1 + 48) = v3;
    operator delete(v3);
  }
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)(a1 + 16));
}

vDSP_Length *std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul>,vDSP_DFT_SetupObject<float,(TransformDirections)0>,std::placeholders::__ph<1>,std::placeholders::__ph<2>,DSPSplitComplexV<float>>::__tuple_impl(vDSP_Length *a1, vDSP_Length *a2)
{
  uint64_t v3;
  vDSP_Length *v4;

  v3 = (uint64_t)(a2 + 2);
  v4 = vDSP_DFT_SetupObject<float,(TransformDirections)0>::vDSP_DFT_SetupObject(a1, *a2);
  DSPSplitComplexV<float>::DSPSplitComplexV((uint64_t)(v4 + 2), v3);
  return a1;
}

void sub_1B65762EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tuple_leaf<0ul,vDSP_DFT_SetupObject<float,(TransformDirections)0>,false>::~__tuple_leaf(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__tuple_leaf<0ul,vDSP_DFT_SetupObject<float,(TransformDirections)0>,false>::~__tuple_leaf(uint64_t a1)
{
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)(a1 + 8));
  return a1;
}

uint64_t AutoValue<Transformer::windowTypes,(LogTypes)0>::CircularBuffer::operator[](unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;

  v1 = a1[1];
  if (!v1)
    __assert_rtn("operator[]", "AutoValue.h", 562, "index < _C");
  v2 = *a1;
  if (*a1 >= v1)
    __assert_rtn("operator[]", "AutoValue.h", 569, "theIndex < _C");
  if (a1[4] <= v2)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  return a1[3] + 4 * v2;
}

void std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<std::vector<float>>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::reference_wrapper<unsigned long>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<std::vector<float>>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<std::vector<float>>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::reference_wrapper<unsigned long>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<std::vector<float>>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<std::vector<float>>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::reference_wrapper<unsigned long>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<std::vector<float>>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<std::vector<float>>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::reference_wrapper<unsigned long>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<std::vector<float>>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E69EB7B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<std::vector<float>>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::reference_wrapper<unsigned long>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<std::vector<float>>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<std::vector<float>>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::reference_wrapper<unsigned long>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<std::vector<float>>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB7B8;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<std::vector<float>>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::reference_wrapper<unsigned long>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<std::vector<float>>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<std::vector<float>>,(LogTypes)0> &,AutoValue&<std::vector<float>,(LogTypes)0>,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::reference_wrapper<unsigned long>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<std::vector<float>>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), **(_QWORD **)(a1 + 16));
}

uint64_t AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::Get(uint64_t a1)
{
  _QWORD *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  std::locale v15;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"WARNING: Calling Get() on an AutoValue ('", 41);
    v3 = *(char *)(a1 + 95);
    if (v3 >= 0)
      v4 = a1 + 72;
    else
      v4 = *(_QWORD *)(a1 + 72);
    if (v3 >= 0)
      v5 = *(unsigned __int8 *)(a1 + 95);
    else
      v5 = *(_QWORD *)(a1 + 80);
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, v4, v5);
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"') without initializing first. Initializing now.", 48);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v15, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v15);
    std::ostream::put();
    std::ostream::flush();
    Trackable::Initialize(a1);
  }
  v9 = *(_DWORD *)(a1 + 8);
  if (v9 == 2)
  {
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 272) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      v12 = (uint64_t *)AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::Get(*(_QWORD *)(a1 + 256));
      v13 = AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
      if ((uint64_t *)v13 != v12)
        std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v13, *v12, v12[1], 0xAAAAAAAAAAAAAAABLL * ((v12[1] - *v12) >> 3));
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 16);
    }
  }
  else if (v9 != 1)
  {
    if (!*(_BYTE *)(a1 + 24))
      __assert_rtn("Get", "AutoValue.h", 668, "_isInitialized == true");
    Trackable::GetRevision((Trackable *)a1);
    if (*(_QWORD *)(a1 + 264) < *(_QWORD *)(a1 + 16))
    {
      AutoValue<std::vector<float>,(LogTypes)0>::CircularBuffer::ShuffleAlong((uint64_t *)(a1 + 280));
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a1 + 16);
      v10 = AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
      v11 = *(_QWORD *)(a1 + 248);
      if (!v11)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, v10);
    }
  }
  return AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::CircularBuffer::operator[]((unint64_t *)(a1 + 280));
}

void sub_1B6576640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t AutoValue<std::vector<std::vector<float>>,(LogTypes)0>::CircularBuffer::operator[](unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;

  v1 = a1[1];
  if (!v1)
    __assert_rtn("operator[]", "AutoValue.h", 562, "index < _C");
  v2 = *a1;
  if (*a1 >= v1)
    __assert_rtn("operator[]", "AutoValue.h", 569, "theIndex < _C");
  if (a1[6] <= v2)
    __assert_rtn("operator[]", "vector.hpp", 1655, "this->m_holder.m_size > n");
  return a1[5] + 24 * v2;
}

_QWORD *AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::AutoValue(_QWORD *a1, __int128 *a2)
{
  _QWORD *v3;
  void *v5[2];
  void *v6;
  void *v7;
  void *__p;
  void *v9;

  v3 = (_QWORD *)Trackable::Trackable<>((uint64_t)a1, a2);
  *v3 = &off_1E69EB320;
  v3[31] = 0;
  v3[32] = 0;
  DSPSplitComplexV<float>::DSPSplitComplexV(v5, 0);
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::CircularBuffer::CircularBuffer(a1 + 35, 1uLL, (uint64_t)v5);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
  if (v6)
  {
    v7 = v6;
    operator delete(v6);
  }
  a1[48] = 0;
  a1[2] = 0;
  a1[33] = 0;
  a1[34] = 0;
  return a1;
}

void sub_1B657678C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void **v9;
  _QWORD **v10;
  _QWORD *v12;
  uint64_t v13;

  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::~DictionaryRef_iterator(&a9);
  v12 = *v10;
  if (*v10 == v9 + 28)
  {
    v13 = 4;
    v12 = v9 + 28;
  }
  else
  {
    if (!v12)
      goto LABEL_6;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_6:
  Trackable::~Trackable(v9);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1E69EB6C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E69EB6C8;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue&<float,(LogTypes)0>),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue&>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t *Filterbank::ToBark<float,(LogTypes)0>::ComputeBark_curry(uint64_t *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  float v19;
  float v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float v28;
  uint64_t v29;
  float *v30;
  float v31;

  v7 = (uint64_t *)AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v8 = (uint64_t *)AutoValue<std::vector<float>,(LogTypes)0>::Get(a3, 0);
  v9 = a4[12];
  v10 = (a4[13] - v9) >> 2;
  if (a4[13] != v9)
  {
    v11 = 0;
    v12 = *a1;
    v13 = a4[15];
    v14 = *v7;
    do
    {
      *(_DWORD *)(v12 + 4 * v11) = 0;
      v15 = *(unsigned int *)(v9 + 4 * v11);
      v16 = (*(_DWORD *)(v13 + 4 * v11) + v15);
      if (v15 < v16)
      {
        v17 = v16 - v15;
        v18 = (float *)(v14 + 4 * v15);
        v19 = 0.0;
        do
        {
          v20 = *v18++;
          v19 = v20 + v19;
          *(float *)(v12 + 4 * v11) = v19;
          --v17;
        }
        while (v17);
      }
      ++v11;
    }
    while (v10 > v11);
  }
  v21 = v10 - 1;
  if (v21)
  {
    v22 = 0;
    v23 = a4[15];
    v24 = *v8;
    v25 = *a1;
    do
    {
      v26 = *(unsigned int *)(v9 + 4 * v22);
      v27 = (*(_DWORD *)(v23 + 4 * v22++) + v26);
      if (v26 < v27)
      {
        v28 = *(float *)(v25 + 4 * v22);
        v29 = v27 - v26;
        v30 = (float *)(v24 + 4 * v26);
        do
        {
          v31 = *v30++;
          v28 = v31 + v28;
          *(float *)(v25 + 4 * v22) = v28;
          --v29;
        }
        while (v29);
      }
    }
    while (v21 > v22);
  }
  return a1;
}

uint64_t Filterbank::ToBark<float,(LogTypes)0>::ComputeFilterLeftTimesPS_curry(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = *(_QWORD *)(v5 + 8);
  if (a1[1] - *a1 != v6 - *(_QWORD *)v5)
    __assert_rtn("ComputeFilterLeftTimesPS_curry", "BarkFilterbank.h", 223, "result.size() == ps.size()");
  return MultiplyVectorVector<float>((uint64_t)a1, *(const float **)v5, v6, *(const float **)(a3 + 48), *(_QWORD *)(a3 + 56));
}

uint64_t Filterbank::ToBark<float,(LogTypes)0>::ComputeFilterRightTimesPS_curry(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = AutoValue<std::vector<float>,(LogTypes)0>::Get(a2, 0);
  v6 = *(_QWORD *)(v5 + 8);
  if (a1[1] - *a1 != v6 - *(_QWORD *)v5)
    __assert_rtn("ComputeFilterRightTimesPS_curry", "BarkFilterbank.h", 235, "result.size() == ps.size()");
  return MultiplyVectorVector<float>((uint64_t)a1, *(const float **)v5, v6, *(const float **)(a3 + 72), *(_QWORD *)(a3 + 80));
}

_QWORD *std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E69EB638;
  Filterbank::BarkCore<float>::~BarkCore((uint64_t)(a1 + 2));
  return a1;
}

void std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E69EB638;
  Filterbank::BarkCore<float>::~BarkCore((uint64_t)(a1 + 2));
  JUMPOUT(0x1BCC95CECLL);
}

char *std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  uint64_t v3;

  v2 = (char *)operator new(0xC8uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v2 = &off_1E69EB638;
  *((_QWORD *)v2 + 1) = v3;
  Filterbank::BarkCore<float>::BarkCore((_QWORD *)v2 + 2, a1 + 16);
  *(_OWORD *)(v2 + 184) = *(_OWORD *)(a1 + 184);
  return v2;
}

void sub_1B6576BC0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __n128 result;

  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_1E69EB638;
  *(_QWORD *)(a2 + 8) = v4;
  Filterbank::BarkCore<float>::BarkCore((_QWORD *)(a2 + 16), a1 + 16);
  result = *(__n128 *)(a1 + 184);
  *(__n128 *)(a2 + 184) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::destroy(uint64_t a1)
{
  return Filterbank::BarkCore<float>::~BarkCore(a1 + 16);
}

void std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::destroy_deallocate(void *a1)
{
  Filterbank::BarkCore<float>::~BarkCore((uint64_t)a1 + 16);
  operator delete(a1);
}

uint64_t std::__function::__func<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<std::vector<float>,(LogTypes)0> &,AutoValue<std::vector<float>,(LogTypes)0> &,Filterbank::BarkCore<float> const&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,Filterbank::BarkCore<float>> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>,std::reference_wrapper<AutoValue<std::vector<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(a1 + 8))(a2, *(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 192), a1 + 16);
}

uint64_t SpectralMagnitude<float,(LogTypes)0>::ComputeMagnitude(_QWORD *a1, uint64_t a2)
{
  DSPSplitComplex *v3;
  uint64_t v4;

  v3 = (DSPSplitComplex *)AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::Get(a2);
  v4 = a1[1] - *a1;
  if (DSPSplitComplexV<float>::size(v3) != v4 >> 2)
    __assert_rtn("ComputeMagnitude", "SpectralMagnitude.h", 35, "result.size() == input.size()");
  return SquareMagFreqVector<float>((uint64_t)a1, v3);
}

void std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69EB5D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB5D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>>,std::allocator<std::__bind<std::vector<float> const& (&)(std::vector<float>&,AutoValue<DSPSplitComplexV<float>,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<DSPSplitComplexV<float>,(LogTypes)0>>>>,std::vector<float> const& ()(std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16));
}

uint64_t Trackable::Trackable<AutoValue<float,(LogTypes)0>>(uint64_t a1, __int128 *a2, uint64_t a3)
{
  __int128 v5;
  _QWORD *v6;

  *(_QWORD *)a1 = &off_1E69EB2E0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 72), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 72) = v5;
  }
  *(_BYTE *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  v6 = operator new(8uLL);
  *v6 = a3;
  *(_QWORD *)(a1 + 128) = v6;
  *(_QWORD *)(a1 + 136) = v6 + 1;
  *(_QWORD *)(a1 + 144) = v6 + 1;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void sub_1B6576F18(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 40) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<std::__bind<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &,double,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,double const&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &,double,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,double const&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &,double,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,double const&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &,double,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,double const&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E69EB568;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &,double,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,double const&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &,double,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,double const&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB568;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &,double,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,double const&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &,double,unsigned long),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,double const&,unsigned long const&> const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, double))(a1 + 8))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 24), *(double *)(a1 + 16));
}

void std::__function::__func<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69EB500;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB500;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<float const& (&)(float &,AutoValue<float,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16));
}

BOOL *IfAnyNode::IfAnyFun<AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &>(BOOL *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = *(_BYTE *)AutoValue<BOOL,(LogTypes)0>::Get(a4);
  *a1 = (*(unsigned __int8 *)AutoValue<BOOL,(LogTypes)0>::Get(a3) | *a1) != 0;
  *a1 = (*(unsigned __int8 *)AutoValue<BOOL,(LogTypes)0>::Get(a2) | *a1) != 0;
  return a1;
}

void IfAnyNode::~IfAnyNode(void **this)
{
  IfAnyNode *v2;
  uint64_t v3;

  *this = &off_1E69EB2C0;
  if (this[40])
    operator delete(this[38]);
  v2 = (IfAnyNode *)this[31];
  if (v2 == (IfAnyNode *)(this + 28))
  {
    v3 = 4;
    v2 = (IfAnyNode *)(this + 28);
    goto LABEL_7;
  }
  if (v2)
  {
    v3 = 5;
LABEL_7:
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
  Trackable::~Trackable(this);
}

{
  IfAnyNode *v2;
  uint64_t v3;

  *this = &off_1E69EB2C0;
  if (this[40])
    operator delete(this[38]);
  v2 = (IfAnyNode *)this[31];
  if (v2 == (IfAnyNode *)(this + 28))
  {
    v3 = 4;
    v2 = (IfAnyNode *)(this + 28);
  }
  else
  {
    if (!v2)
    {
LABEL_8:
      Trackable::~Trackable(this);
      JUMPOUT(0x1BCC95CECLL);
    }
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  goto LABEL_8;
}

void std::__function::__func<std::__bind<BOOL const& (&)(BOOL &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>>,std::allocator<std::__bind<BOOL const& (&)(BOOL &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>>>,BOOL const& ()(BOOL &)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<BOOL const& (&)(BOOL &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>>,std::allocator<std::__bind<BOOL const& (&)(BOOL &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>>>,BOOL const& ()(BOOL &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E69EB438;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<BOOL const& (&)(BOOL &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>>,std::allocator<std::__bind<BOOL const& (&)(BOOL &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>>>,BOOL const& ()(BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB438;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<BOOL const& (&)(BOOL &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>>,std::allocator<std::__bind<BOOL const& (&)(BOOL &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &),std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>,std::reference_wrapper<AutoValue<BOOL,(LogTypes)0>>>>,BOOL const& ()(BOOL &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
}

void std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_2 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_2 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_2 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_2 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69EB3D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_2 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_2 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB3D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_DWORD *std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_2 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_2 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::operator()(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)AutoValue<float,(LogTypes)0>::Get(*(_QWORD *)(a1 + 16));
  return a2;
}

void std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_1 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_1 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_1 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_1 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69EB388;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_1 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_1 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB388;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_DWORD *std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_1 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_1 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::operator()(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)AutoValue<float,(LogTypes)0>::Get(*(_QWORD *)(a1 + 16));
  return a2;
}

void std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_0 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_0 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_0 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_0 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69EB340;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_0 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_0 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69EB340;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_DWORD *std::__function::__func<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_0 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>,std::allocator<std::__bind<AUReverbSuppressor::AUReverbSuppressor(OpaqueAudioComponentInstance *)::$_0 const&,std::placeholders::__ph<1> const&,std::reference_wrapper<AutoValue<float,(LogTypes)0>>>>,float const& ()(float &)>::operator()(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)AutoValue<float,(LogTypes)0>::Get(*(_QWORD *)(a1 + 16));
  return a2;
}

NSString *removePortUIDSuffix(NSString *a1)
{
  NSString *v1;
  void *v2;
  NSString *v3;
  NSString *v4;

  v1 = a1;
  -[NSString componentsSeparatedByString:](v1, "componentsSeparatedByString:", CFSTR("-"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v2, "count") == 2)
  {
    objc_msgSend(v2, "objectAtIndexedSubscript:", 0);
    v3 = (NSString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v3 = v1;
  }
  v4 = v3;

  return v4;
}

void sub_1B65779D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

unint64_t va::PersonalAudioInterface::isPersonalMediaEnabled(va::PersonalAudioInterface *this)
{
  void *v1;
  void *v2;
  unint64_t v3;

  if (!objc_opt_class())
    return 0;
  objc_msgSend(MEMORY[0x1E0D70A80], "sharedInstance");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v1, "personalMediaEnabled"))
  {
    objc_msgSend(MEMORY[0x1E0D70A80], "sharedInstance");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = ((unint64_t)objc_msgSend(v2, "personalAudioAccommodationTypes") >> 1) & 1;

  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_1B6577A68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

unint64_t va::PersonalAudioInterface::isPersonalMediaEnabled(NSString **a1)
{
  void *v2;
  void *v3;
  void *v4;
  unint64_t v5;

  if (!objc_opt_class())
    return 0;
  removePortUIDSuffix(*a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D70A80], "sharedInstance");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v3, "personalMediaEnabledForRouteUID:", v2))
  {
    objc_msgSend(MEMORY[0x1E0D70A80], "sharedInstance");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = ((unint64_t)objc_msgSend(v4, "accommodationTypesForRouteUID:", v2) >> 1) & 1;

  }
  else
  {
    v5 = 0;
  }

  return v5;
}

void sub_1B6577B20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void va::PersonalAudioInterface::getPreset(va::PersonalAudioInterface *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  id cf;

  if (objc_opt_class())
  {
    objc_msgSend(MEMORY[0x1E0D70A80], "sharedInstance");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "personalMediaConfiguration");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "presetAdjustments");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "objectForKey:", *MEMORY[0x1E0D70A88]);
    v5 = (void *)objc_claimAutoreleasedReturnValue();

    cf = v5;
    if (cf)
      CFRetain(cf);
    applesauce::CF::DictionaryRef::DictionaryRef(this, cf);

  }
  else
  {
    *(_QWORD *)this = 0;
  }
}

void sub_1B6577C28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void va::PersonalAudioInterface::getPreset(applesauce::CF::DictionaryRef *a1, NSString **a2)
{
  void *v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  id v9;

  if (objc_opt_class())
  {
    removePortUIDSuffix(*a2);
    v9 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0D70A80], "sharedInstance");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "personalMediaConfigurationForRouteUID:", v9);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "preset");
    v6 = (void *)objc_claimAutoreleasedReturnValue();

    v7 = v6;
    v8 = v7;
    if (v7)
      CFRetain(v7);
    applesauce::CF::DictionaryRef::DictionaryRef(a1, v8);

  }
  else
  {
    *(_QWORD *)a1 = 0;
  }
}

void sub_1B6577D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t CmhMicCheck::initialize(CmhMicCheck *this, int a2, int a3, int a4, float **a5, float **a6)
{
  int v9;
  int v10;
  double v11;
  double v12;
  uint64_t v13;
  float *v14;
  float *v15;
  float *v16;
  float *v17;
  uint64_t v18;
  _DWORD *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  size_t v32;
  const std::nothrow_t *v33;
  void *v34;
  size_t v35;
  char *v36;

  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  *((float *)this + 2) = (float)a2 / (float)a3;
  v9 = 2 * a4 - 2;
  *((_DWORD *)this + 3) = v9;
  *((_DWORD *)this + 4) = a4;
  v10 = (int)(float)((float)(2500.0 / (float)a2) * (float)v9);
  if (v10 <= 1)
    v10 = 1;
  *((_DWORD *)this + 5) = v10;
  CmhMicCheck::deallocate_memory((uint64_t)this);
  if (*((_DWORD *)this + 8))
  {
    LODWORD(v13) = *((_DWORD *)this + 5);
  }
  else
  {
    *((_DWORD *)this + 8) = 1;
    v28 = operator new[](8uLL, MEMORY[0x1E0DE4E10]);
    *((_QWORD *)this + 20) = v28;
    if (!v28)
      return 4294967294;
    *v28 = 0;
    v29 = operator new[](8uLL, MEMORY[0x1E0DE4E10]);
    *((_QWORD *)this + 21) = v29;
    if (!v29)
      return 4294967294;
    *v29 = 0;
    v30 = operator new[](0x20uLL, MEMORY[0x1E0DE4E10]);
    *((_QWORD *)this + 14) = v30;
    if (!v30)
      return 4294967294;
    v31 = 0;
    v13 = *((unsigned int *)this + 5);
    v32 = (int)v13 < 0 ? -1 : 4 * (int)v13;
    v33 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
    do
    {
      *(_QWORD *)(*((_QWORD *)this + 14) + v31) = operator new[](v32, v33);
      if ((int)v13 >= 1)
        memset_pattern16(*(void **)(*((_QWORD *)this + 14) + v31), &unk_1B66A2BA0, 4 * v13);
      v31 += 8;
    }
    while (v31 != 32);
    v34 = operator new[](v32, MEMORY[0x1E0DE4E10]);
    *((_QWORD *)this + 15) = v34;
    if (!v34)
      return 4294967294;
    v35 = (int)v13 < 0 ? -1 : 8 * (int)v13;
    v36 = (char *)operator new[](v35, MEMORY[0x1E0DE4E10]);
    *((_QWORD *)this + 16) = v36;
    if (!v36)
      return 4294967294;
    *((_QWORD *)this + 17) = &v36[4 * (int)v13];
    bzero(v36, 8 * (int)v13);
  }
  if ((int)v13 >= 1)
  {
    v14 = *a5;
    v15 = a5[1];
    v16 = *a6;
    v17 = a6[1];
    v18 = v13;
    LODWORD(v11) = 1.0;
    v19 = (_DWORD *)*((_QWORD *)this + 15);
    do
    {
      v20 = *v14++;
      v21 = v20;
      v22 = *v15++;
      v23 = v22;
      v24 = *v16++;
      v25 = v24;
      v26 = *v17++;
      *(float *)&v12 = 1.0
                     / sqrtf((float)((float)((float)(v23 * v25) + (float)(v21 * v26))* (float)((float)(v23 * v25) + (float)(v21 * v26)))+ (float)((float)(1.0 - (float)((float)(v21 * v23) - (float)(v25 * v26)))* (float)(1.0 - (float)((float)(v21 * v23) - (float)(v25 * v26)))));
      *v19++ = LODWORD(v12);
      --v18;
    }
    while (v18);
  }
  CmhMicCheck::init_check_mics(this, v11, v12);
  return 0;
}

uint64_t CmhMicCheck::deallocate_memory(uint64_t this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  if (*(_DWORD *)(this + 32))
  {
    v1 = (_QWORD *)this;
    *(_DWORD *)(this + 32) = 0;
    v2 = *(_QWORD *)(this + 160);
    if (v2)
      MEMORY[0x1BCC95CC8](v2, 0x1000C8052888210);
    v3 = v1[21];
    if (v3)
      MEMORY[0x1BCC95CC8](v3, 0x1000C8052888210);
    for (i = 0; i != 32; i += 8)
    {
      v5 = *(_QWORD *)(v1[14] + i);
      if (v5)
        MEMORY[0x1BCC95CC8](v5, 0x1000C8052888210);
    }
    v6 = v1[14];
    if (v6)
      MEMORY[0x1BCC95CC8](v6, 0x80C80B8603338);
    v1[14] = 0;
    v7 = v1[15];
    if (v7)
      MEMORY[0x1BCC95CC8](v7, 0x1000C8052888210);
    v9 = v1[16];
    v8 = v1 + 16;
    this = v9;
    *(v8 - 1) = 0;
    if (v9)
    {
      this = MEMORY[0x1BCC95CC8](this, 0x1000C8052888210);
      *v8 = 0;
      v8[1] = 0;
    }
  }
  return this;
}

int32x2_t CmhMicCheck::init_check_mics(CmhMicCheck *this, double a2, double a3)
{
  float v4;
  float v5;
  float v6;
  int32x2_t v7;
  __int32 v8;
  float v9;
  float v10;
  float v11;
  float v12;
  __int128 v13;
  float v14;
  int v15;
  int32x2_t result;

  v4 = *((float *)this + 9);
  v5 = *((float *)this + 10);
  *((float *)this + 57) = v4;
  *((float *)this + 58) = v5;
  v6 = v5 - v4;
  *((float *)this + 36) = v5 - v4;
  v7 = vcvt_s32_f32(*(float32x2_t *)((char *)this + 44));
  *((_DWORD *)this + 59) = v7.i32[0];
  *((int32x2_t *)this + 30) = v7;
  v8 = v7.i32[0];
  v9 = *((float *)this + 13);
  v10 = 0.0;
  if (v9 > 0.0)
    v10 = exp(-1.0 / (v9 * *((float *)this + 2)));
  v11 = *((float *)this + 14) - v6;
  *((float *)this + 62) = v10;
  *((float *)this + 63) = v11;
  *((_OWORD *)this + 16) = *(_OWORD *)((char *)this + 60);
  v12 = *((float *)this + 20);
  *((_DWORD *)this + 68) = *((_DWORD *)this + 19);
  *((float *)this + 69) = v12 + (float)(v6 * -256.0);
  *((_QWORD *)this + 35) = *(_QWORD *)((char *)this + 84);
  v13 = *(_OWORD *)((char *)this + 92);
  *((_OWORD *)this + 18) = v13;
  *((_DWORD *)this + 50) = 5;
  *(float *)&a3 = (float)*(int *)this;
  v14 = (float)*((int *)this + 3);
  v15 = (int)(float)((float)(*(float *)&v13 / *(float *)&a3) * v14);
  *((_QWORD *)this + 24) = 0x500000005;
  if (v15 <= 1)
    v15 = 1;
  *((_DWORD *)this + 53) = v15;
  *((_DWORD *)this + 54) = (int)(float)((float)(*((float *)&v13 + 1) / *(float *)&a3) * v14);
  *((_DWORD *)this + 37) = v8;
  *((_DWORD *)this + 38) = 0;
  result = vmin_s32(vdup_n_s32(*((_DWORD *)this + 5) - 1), vcvt_s32_f32(vmul_n_f32(vdiv_f32(*(float32x2_t *)((char *)this + 296), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0)), v14)));
  *(int32x2_t *)((char *)this + 220) = result;
  return result;
}

void CmhMicCheck::process(CmhMicCheck *this, const DSPSplitComplex *a2, const DSPSplitComplex *a3, const DSPSplitComplex *a4, const DSPSplitComplex *a5, const float **a6, const float **a7)
{
  const float **v7;
  uint64_t v10;
  float **v15;
  float *v16;
  float v17;
  uint64_t v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float *v23;
  float v24;
  uint64_t v25;
  float v26;
  float v27;
  float v28;
  float v29;
  int v30;
  float *v31;
  float v32;
  float *v33;
  float *v34;
  uint64_t v35;
  float v36;
  float v37;
  float v38;
  float v39;
  uint64_t *v40;
  uint64_t v41;
  int v42;
  float v43;
  float *v44;
  uint64_t v45;
  float *v46;
  float *v47;
  float v48;
  float v49;
  float v50;
  float v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  float v56;
  float *v57;
  float *v58;
  float v59;
  float v60;
  float v61;
  uint64_t v62;
  uint64_t v63;
  float v64;
  float v65;
  float v66;
  float v67;
  int v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  BOOL v76;
  BOOL v77;
  BOOL v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  char v85;
  char v86;
  BOOL v87;
  float v88;
  int v89;
  float v90;
  float v91;
  float v92;
  int v93;
  int v94;
  float v95;
  float v96;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  float v103;

  v7 = a7;
  v10 = *((unsigned int *)this + 5);
  if ((int)v10 >= 1)
  {
    v15 = (float **)*((_QWORD *)this + 14);
    v16 = *v15;
    v17 = *((float *)this + 62);
    v18 = *((unsigned int *)this + 5);
    do
    {
      v19 = *(float *)&a2->realp;
      a2 = (const DSPSplitComplex *)((char *)a2 + 4);
      v20 = v19;
      v21 = *(float *)&a3->realp;
      a3 = (const DSPSplitComplex *)((char *)a3 + 4);
      v22 = log10f(*((float *)this + 67) + (float)((float)(v21 * v21) + (float)(v20 * v20)));
      *v16 = (float)(v22 * 10.0) + (float)(v17 * (float)(*v16 - (float)(v22 * 10.0)));
      ++v16;
      --v18;
    }
    while (v18);
    v23 = v15[1];
    v24 = *((float *)this + 62);
    v25 = v10;
    v7 = a7;
    do
    {
      v26 = *(float *)&a4->realp;
      a4 = (const DSPSplitComplex *)((char *)a4 + 4);
      v27 = v26;
      v28 = *(float *)&a5->realp;
      a5 = (const DSPSplitComplex *)((char *)a5 + 4);
      v29 = log10f(*((float *)this + 67) + (float)((float)(v28 * v28) + (float)(v27 * v27)));
      *v23 = (float)(v29 * 10.0) + (float)(v24 * (float)(*v23 - (float)(v29 * 10.0)));
      ++v23;
      --v25;
    }
    while (v25);
  }
  vDSP_vmul(*((const float **)this + 15), 1, *a6, 1, *((float **)this + 16), 1, (int)v10);
  vDSP_vmul(*((const float **)this + 15), 1, a6[1], 1, *((float **)this + 17), 1, *((int *)this + 5));
  v30 = *((_DWORD *)this + 5);
  if (v30 >= 1)
  {
    v31 = *(float **)(*((_QWORD *)this + 14) + 16);
    v32 = *((float *)this + 62);
    v33 = (float *)*((_QWORD *)this + 16);
    v34 = (float *)*((_QWORD *)this + 17);
    v35 = *((unsigned int *)this + 5);
    do
    {
      v36 = *v33++;
      v37 = v36;
      v38 = *v34++;
      v39 = log10f(*((float *)this + 67) + (float)((float)(v38 * v38) + (float)(v37 * v37)));
      *v31 = (float)(v39 * 10.0) + (float)(v32 * (float)(*v31 - (float)(v39 * 10.0)));
      ++v31;
      --v35;
    }
    while (v35);
  }
  vDSP_vmul(*((const float **)this + 15), 1, *v7, 1, *((float **)this + 16), 1, v30);
  vDSP_vmul(*((const float **)this + 15), 1, v7[1], 1, *((float **)this + 17), 1, *((int *)this + 5));
  v40 = (uint64_t *)*((_QWORD *)this + 14);
  v41 = v40[3];
  v42 = *((_DWORD *)this + 5);
  if (v42 >= 1)
  {
    v43 = *((float *)this + 62);
    v44 = (float *)v40[3];
    v45 = *((unsigned int *)this + 5);
    v46 = (float *)*((_QWORD *)this + 16);
    v47 = (float *)*((_QWORD *)this + 17);
    do
    {
      v48 = *v46++;
      v49 = v48;
      v50 = *v47++;
      v51 = log10f(*((float *)this + 67) + (float)((float)(v50 * v50) + (float)(v49 * v49)));
      *v44 = (float)(v51 * 10.0) + (float)(v43 * (float)(*v44 - (float)(v51 * 10.0)));
      ++v44;
      --v45;
    }
    while (v45);
  }
  v52 = *v40;
  v53 = v40[1];
  v54 = *((int *)this + 53);
  v55 = *((int *)this + 54);
  v56 = *(float *)(*v40 + 4 * v54) + 90.31;
  v57 = (float *)*((_QWORD *)this + 20);
  v58 = (float *)*((_QWORD *)this + 21);
  *v57 = v56;
  v59 = *(float *)(v53 + 4 * v54) + 90.31;
  v57[1] = v59;
  v60 = *(float *)(v52 + 4 * v55) + 90.31;
  *v58 = v60;
  v61 = *(float *)(v53 + 4 * v55) + 90.31;
  v58[1] = v61;
  v62 = *((int *)this + 55);
  v63 = *((int *)this + 56);
  v64 = (float)(*(float *)(v52 + 4 * v63) + *(float *)(v52 + 4 * (v42 - 1))) * 0.5;
  *((float *)this + 44) = v64;
  v65 = (float)(*(float *)(v53 + 4 * v63) + *(float *)(v53 + 4 * (v42 - 1))) * 0.5;
  *((float *)this + 45) = v65;
  v66 = (float)(*(float *)(v40[2] + 4 * v63) + *(float *)(v40[2] + 4 * (v42 - 1))) * 0.5;
  *((float *)this + 46) = v66;
  v67 = (float)(*(float *)(v41 + 4 * v63) + *(float *)(v41 + 4 * (v42 - 1))) * 0.5;
  *((float *)this + 47) = v67;
  v68 = *((_DWORD *)this + 76);
  if (v68)
  {
    v69 = v64;
    if (v68 != 1)
    {
      v69 = v65;
      v64 = v65;
    }
  }
  else
  {
    v69 = v65;
  }
  v70 = *(float *)(v52 + 4 * v62);
  v71 = *(float *)(v53 + 4 * v62);
  v72 = *((float *)this + 39);
  v73 = 0.0;
  if (v72 > 1.0)
    v73 = (float)(log10f(v72) * 20.0) * 256.0;
  v74 = *v57;
  v75 = *((float *)this + 63);
  v76 = *v57 <= v75 || v57[1] >= v75;
  v77 = v74 >= v75 || v57[1] <= v75;
  v78 = v74 <= v75 || v57[1] <= v75;
  v79 = (v70 + 90.31) * 256.0;
  v80 = (v71 + 90.31) * 256.0;
  v81 = *v58;
  v82 = v58[1];
  v83 = vabds_f32(*v58, v82);
  v84 = *((float *)this + 64);
  v85 = v76 && v77;
  if (v83 > v84)
    v85 = 1;
  v86 = v85 & v78;
  if (v81 >= v82)
    v81 = v58[1];
  v87 = v81 < 5.0 && v83 > v84;
  if ((v86 & 1) != 0 || v87 || *((int *)this + 38) >= 1)
  {
    v88 = *((float *)this + 65);
    *((float *)this + 52) = v88;
    v89 = 1;
    *((_DWORD *)this + 51) = 1;
    v90 = v58[1];
    v91 = *v58 - v90;
    v92 = v90 - *v58;
    v93 = 4;
    v94 = 4;
  }
  else
  {
    v89 = 0;
    v88 = *((float *)this + 66);
    *((float *)this + 52) = v88;
    *((_DWORD *)this + 51) = 0;
    v103 = v57[1];
    v91 = *v57 - v103;
    v92 = v103 - *v57;
    v94 = 3;
    v93 = 2;
  }
  v95 = *((float *)this + 68);
  if ((float)(v79 - v80) <= v95 || *((float *)this + 69) <= v80)
  {
    if ((float)(v80 - v79) > v95 && *((float *)this + 69) > v79)
    {
      v93 = 0;
      *((_DWORD *)this + 49) = 0;
      goto LABEL_55;
    }
    if (v73 < (float)(*((float *)this + 70) + 23040.0))
    {
      if ((float)(v91 * 256.0) > v88)
        goto LABEL_54;
      if ((float)(v92 * 256.0) > v88)
      {
        *((_DWORD *)this + 49) = v94;
        v93 = v94;
        goto LABEL_55;
      }
    }
    v96 = *((float *)this + 71);
    if ((float)((float)(v66 - v64) * 256.0) <= v96 && (float)((float)(v67 - v69) * 256.0) <= v96)
      v93 = 5;
    goto LABEL_54;
  }
  v93 = 1;
LABEL_54:
  *((_DWORD *)this + 49) = v93;
LABEL_55:
  if (v93 == *((_DWORD *)this + 50))
  {
    v98 = *((_DWORD *)this + 37);
    if (v98 >= 2)
      v99 = v98 - 1;
    else
      v99 = 0;
    *((_DWORD *)this + 37) = v99;
    if (v99)
      goto LABEL_60;
  }
  else
  {
    v100 = *((_DWORD *)this + 59);
    *((_DWORD *)this + 37) = v100;
    *((_DWORD *)this + 50) = v93;
    if (v100)
    {
LABEL_60:
      v93 = *((_DWORD *)this + 48);
      goto LABEL_63;
    }
  }
  *((_DWORD *)this + 48) = v93;
LABEL_63:
  if (v93 >= 5)
    v89 = 0;
  if (v89 == 1)
  {
    v101 = *((_DWORD *)this + 60);
  }
  else
  {
    if (v93 != 5)
      return;
    v102 = *((_DWORD *)this + 38);
    if (v102 >= 2)
      v101 = v102 - 1;
    else
      v101 = 0;
  }
  *((_DWORD *)this + 38) = v101;
}

void HRTFConvolution::~HRTFConvolution(void **this)
{
  void **v1;

  *this = &off_1E69EBDB8;
  v1 = this + 2;
  ConvolutionFilter::~ConvolutionFilter(this + 7);
  ConvolutionFilter::~ConvolutionFilter(v1);
}

{
  void **v1;

  *this = &off_1E69EBDB8;
  v1 = this + 2;
  ConvolutionFilter::~ConvolutionFilter(this + 7);
  ConvolutionFilter::~ConvolutionFilter(v1);
  JUMPOUT(0x1BCC95CECLL);
}

void HRTFConvolution::Process(HRTFConvolution *this, float *a2, float **a3, unsigned int a4, int a5, float a6, float a7, float a8)
{
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  BOOL v21;
  float i;
  double v23;
  double v24;
  double v25;
  unsigned int v26;
  float *v27;
  float *v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  unsigned int v36;
  uint64_t v37;
  float v38;
  float v39;
  unsigned int v40;
  uint64_t v41;
  float *v42;
  float *v43;
  const float **v44;
  uint64_t v45;
  float **v46;
  const float **v47;
  uint64_t v48;
  float **v49;
  float v50;
  float v51;
  float __Step;
  float __Start;

  if (HRTFConvolution::sIsInitialized == 1)
  {
    v13 = a6 * 0.0174532925;
    v14 = *((double *)this + 12);
    v15 = v13 - v14;
    if (v13 - v14 <= 3.14159265)
    {
      if (v15 < -3.14159265)
      {
        v14 = v14 + -6.28318531;
        v15 = v13 - v14;
        if (v13 - v14 < -3.14159265)
        {
          v17 = *((double *)this + 17);
          do
          {
            v14 = v14 + -6.28318531;
            v17 = v17 + -6.28318531;
            v15 = v13 - v14;
          }
          while (v13 - v14 < -3.14159265);
          *((double *)this + 17) = v17;
        }
      }
    }
    else
    {
      v14 = v14 + 6.28318531;
      v15 = v13 - v14;
      if (v13 - v14 > 3.14159265)
      {
        v16 = *((double *)this + 17);
        do
        {
          v14 = v14 + 6.28318531;
          v16 = v16 + 6.28318531;
          v15 = v13 - v14;
        }
        while (v13 - v14 > 3.14159265);
        *((double *)this + 17) = v16;
      }
    }
    v18 = v14 + v15 * 0.1;
    *((double *)this + 12) = v18;
    v19 = a7;
    if (*((_DWORD *)this + 38)
      || ((v20 = vabdd_f64(*((double *)this + 18), v19), vabdd_f64(*((double *)this + 17), v18) <= 0.0174532925)
        ? (v21 = v20 <= 1.0)
        : (v21 = 0),
          !v21))
    {
      *((_DWORD *)this + 38) = 0;
      *((double *)this + 17) = v18;
      *((double *)this + 18) = v19;
      for (i = v18 * 57.2957795; i < -180.0; i = i + 360.0)
        ;
      for (; i >= 180.0; i = i + -360.0)
        ;
      v23 = i * 0.0174532925;
      if (v19 * 0.0174532925 == 0.0)
      {
        v24 = 3.14159265 - v23;
        if (v23 <= 1.57079633)
          v24 = v23;
        v25 = 0.0;
        if (v24 < -1.57079633)
          v24 = -3.14159265 - v24;
      }
      else
      {
        v26 = (int)((v19 * 0.0174532925 + 1.57079633) * 100.0 / 3.14159265) & ~((int)((v19 * 0.0174532925 + 1.57079633)
                                                                                    * 100.0
                                                                                    / 3.14159265) >> 31);
        if (v26 >= 0x63)
          v26 = 99;
        v27 = (float *)((char *)&azimuthCoeffs + 16 * v26);
        v28 = (float *)((char *)&elevationCoeffs + 16 * v26);
        if (v23 <= 1.57079633)
        {
          v29 = v23;
          if (v23 < -1.57079633)
            v29 = -3.14159265 - v23;
        }
        else
        {
          v29 = 3.14159265 - v23;
        }
        v30 = v29 * v29;
        v31 = v29 * (v29 * v29);
        v32 = v29 * v31;
        v33 = v29 * (v29 * v31);
        v34 = v29 * v33;
        v24 = v31 * v27[1] + *v27 * v29 + v27[2] * v33 + v27[3] * (v29 * (v29 * v33));
        v25 = *v28 + v28[1] * v30 + v28[2] * v32 + v28[3] * v34;
      }
      if (fabs(v23) <= 1.57079633)
        v35 = v25;
      else
        v35 = 3.14159265 - v25;
      v36 = (int)((v35 * 57.2957795 + 45.0) * 0.177777778) & ~((int)((v35 * 57.2957795 + 45.0) * 0.177777778) >> 31);
      if (v36 >= 0x31)
        v36 = 49;
      v37 = HRTFConvolution::sHRTF[v36];
      v38 = v24;
      v39 = v38 / 3.14159265 + 0.5;
      v40 = (int)(v39 * 37.0) & ~((int)(v39 * 37.0) >> 31);
      if (v40 >= 0x24)
        v40 = 36;
      v41 = v37
          + 16
          * HRTFElevation::GetHRTF(float,ConvolutionKernel *&,ConvolutionKernel *&,float &,float &)::transform[v40];
      *((_QWORD *)this + 15) = v41 + 3208;
      *((_QWORD *)this + 16) = v41 + 8328;
    }
    v42 = *a3;
    if (a5 == 1)
      v43 = a3[1];
    else
      v43 = v42 + 1;
    v44 = (const float **)*((_QWORD *)this + 13);
    v45 = *((_QWORD *)this + 15);
    v46 = (float **)((char *)this + 16);
    if (!v44 || v44 == (const float **)v45)
      FIRFilter::Process((uint64_t)v46, (char *)a2, *a3, a4, *((_QWORD *)this + 15));
    else
      FIRFilter::Process2(v46, (char *)a2, *a3, a4, v44, v45);
    v47 = (const float **)*((_QWORD *)this + 14);
    v48 = *((_QWORD *)this + 16);
    v49 = (float **)((char *)this + 56);
    if (!v47 || v47 == (const float **)v48)
      FIRFilter::Process((uint64_t)v49, (char *)a2, v43, a4, *((_QWORD *)this + 16));
    else
      FIRFilter::Process2(v49, (char *)a2, v43, a4, v47, v48);
    *(_OWORD *)((char *)this + 104) = *(_OWORD *)((char *)this + 120);
    if (a4)
    {
      v50 = a8 * 10.0;
      v51 = *((float *)this + 39);
      __Step = fminf(1.0 / (float)a4, 0.001) * (float)(v50 - v51);
      __Start = v51;
      vDSP_vrampmul(v42, a5, &__Start, &__Step, v42, a5, a4);
      __Start = v51;
      vDSP_vrampmul(v43, a5, &__Start, &__Step, v43, a5, a4);
      *((float *)this + 39) = __Start;
    }
  }
}

void HRTFConvolution::Reset(void **this)
{
  bzero(this[3], *((int *)this + 12));
  bzero(this[4], *((int *)this + 12));
  bzero(this[5], *((int *)this + 12));
  bzero(this[8], *((int *)this + 22));
  bzero(this[9], *((int *)this + 22));
  bzero(this[10], *((int *)this + 22));
}

void AUAuxVPDownlink::~AUAuxVPDownlink(AUAuxVPDownlink *this)
{
  *(_QWORD *)this = &off_1E69EBDE8;
  ausdk::AUBase::~AUBase(this);
}

{
  *(_QWORD *)this = &off_1E69EBDE8;
  ausdk::AUBase::~AUBase(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AUAuxVP::CanScheduleParameters(AUAuxVP *this)
{
  return 0;
}

uint64_t AUAuxVPDownlink::GetParameterInfo(AUAuxVPDownlink *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v6;
  const __CFString *v7;
  AudioUnitParameterValue v8;
  uint64_t v9;
  AudioUnitParameterOptions v10;
  const __CFString *v11;
  const __CFString *v12;
  AudioUnitParameterOptions v13;

  buffer->flags = 0x40000000;
  buffer->unitName = 0;
  if (a2)
    return 4294956418;
  switch(a3)
  {
    case 0:
      v6 = CFSTR("Final Gain Channel 0");
      goto LABEL_15;
    case 1:
      buffer->cfNameString = CFSTR("DL Mix Block Size");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("DL Mix Block Size"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_SampleFrames;
      *(_QWORD *)&buffer->minValue = 0x470000003F800000;
      buffer->defaultValue = 480.0;
      return result;
    case 2:
      v7 = CFSTR("Min Mix Gain");
      goto LABEL_8;
    case 3:
      v7 = CFSTR("Max Mix Gain");
LABEL_8:
      buffer->cfNameString = v7;
      buffer->flags = 1207959552;
      CFStringGetCString(v7, buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&buffer->minValue = 3266576384;
      v8 = -15.0;
      goto LABEL_13;
    case 4:
      buffer->cfNameString = CFSTR("Noise Threshold for Vol Boost");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("Noise Threshold for Vol Boost"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x42C8000000000000;
      v8 = 100.0;
      goto LABEL_13;
    case 5:
      buffer->cfNameString = CFSTR("Min Boosting Level");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("Min Boosting Level"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v9 = 0x3F80000000000000;
      break;
    case 6:
      buffer->cfNameString = CFSTR("Boost Amount");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("Boost Amount"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v9 = 0x3F00000000000000;
      break;
    case 7:
      buffer->cfNameString = CFSTR("Max Non Boosting Level");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("Max Non Boosting Level"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      v8 = 1.0;
LABEL_13:
      v10 = buffer->flags | 0x80000000;
      buffer->defaultValue = v8;
      buffer->flags = v10;
      return result;
    case 8:
      v6 = CFSTR("Final Gain Channel 1");
LABEL_15:
      buffer->cfNameString = v6;
      buffer->flags = 1207959552;
      CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      v9 = 0x42700000C3988000;
      break;
    case 9:
      v11 = CFSTR("FEV Gain at Min. Volume");
      goto LABEL_18;
    case 10:
      v11 = CFSTR("FEV Gain at Max Volume");
LABEL_18:
      buffer->cfNameString = v11;
      buffer->flags = 1207959552;
      CFStringGetCString(v11, buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      v9 = 0x41F00000C2B40000;
      break;
    case 11:
      v12 = CFSTR("DL AGC Target in Music");
      goto LABEL_22;
    case 12:
      buffer->cfNameString = CFSTR("DL AGC Max Gain in Music");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("DL AGC Max Gain in Music"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      v9 = 0x41F00000C1F00000;
      break;
    case 13:
      v12 = CFSTR("Threshold for music presence detection");
LABEL_22:
      buffer->cfNameString = v12;
      buffer->flags = 1207959552;
      CFStringGetCString(v12, buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      v9 = 3266576384;
      break;
    case 14:
      buffer->cfNameString = CFSTR("Hold time for switching DL AGC params");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("Hold time for switching DL AGC params"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v9 = 0x43FA000000000000;
      break;
    case 15:
      buffer->cfNameString = CFSTR("Scaling for volume matching");
      buffer->flags = 1207959552;
      CFStringGetCString(CFSTR("Scaling for volume matching"), buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v9 = 0x4248000000000000;
      break;
    default:
      return 4294956418;
  }
  *(_QWORD *)&buffer->minValue = v9;
  v13 = buffer->flags | 0x80000000;
  buffer->defaultValue = 0.0;
  buffer->flags = v13;
  return result;
}

void AUAuxVPUplink::~AUAuxVPUplink(AUAuxVPUplink *this)
{
  *(_QWORD *)this = &off_1E69EC038;
  ausdk::AUBase::~AUBase(this);
}

{
  *(_QWORD *)this = &off_1E69EC038;
  ausdk::AUBase::~AUBase(this);
  JUMPOUT(0x1BCC95CECLL);
}

double AUAuxVPUplink::GetParameterInfo(AUAuxVPUplink *this, int a2, int a3, AudioUnitParameterInfo *buffer, double result)
{
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  AudioUnitParameterValue v10;
  AudioUnitParameterOptions v11;
  AudioUnitParameterOptions v12;

  buffer->flags = -1073741824;
  buffer->unitName = 0;
  if (!a2)
  {
    switch(a3)
    {
      case 0:
        buffer->cfNameString = CFSTR("PreProcessingGain");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("PreProcessingGain"), buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Decibels;
        result = 8.58993956e10;
        goto LABEL_19;
      case 1:
        buffer->cfNameString = CFSTR("PostProcessingGain");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("PostProcessingGain"), buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Decibels;
        result = 4294970400.0;
        goto LABEL_19;
      case 2:
        buffer->cfNameString = CFSTR("ECRefMicDelayMilliSec");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("ECRefMicDelayMilliSec"), buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Milliseconds;
        result = 134217728.0;
        *(_QWORD *)&buffer->minValue = 0x41A0000000000000;
        buffer->defaultValue = 10.0;
        return result;
      case 3:
        v6 = CFSTR("Echo Latency Correction 8000Hz");
        goto LABEL_10;
      case 4:
        v6 = CFSTR("Echo Latency Correction 11025Hz");
        goto LABEL_10;
      case 5:
        v6 = CFSTR("Echo Latency Correction 12000Hz");
        goto LABEL_10;
      case 6:
        v6 = CFSTR("Echo Latency Correction 16000Hz");
LABEL_10:
        buffer->cfNameString = v6;
        buffer->flags = -939524096;
        CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Generic;
        result = 2.18573879e27;
        goto LABEL_19;
      case 7:
        v7 = CFSTR("Echo Latency Correction 22050Hz");
        goto LABEL_13;
      case 8:
        v7 = CFSTR("Echo Latency Correction 24000Hz");
LABEL_13:
        buffer->cfNameString = v7;
        buffer->flags = -939524096;
        CFStringGetCString(v7, buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Generic;
        result = 8.51084142e27;
        goto LABEL_19;
      case 9:
        v8 = CFSTR("Echo Latency Correction 32000Hz");
        goto LABEL_17;
      case 10:
        v8 = CFSTR("Echo Latency Correction 44100Hz");
        goto LABEL_17;
      case 11:
        v8 = CFSTR("Echo Latency Correction 48000Hz");
LABEL_17:
        buffer->cfNameString = v8;
        buffer->flags = -939524096;
        CFStringGetCString(v8, buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Generic;
        result = 5.59549132e29;
        goto LABEL_19;
      case 12:
        buffer->cfNameString = CFSTR("Echo Centroid Offset");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Echo Centroid Offset"), buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Milliseconds;
        result = 134217728.0;
LABEL_19:
        *(double *)&buffer->minValue = result;
        buffer->defaultValue = 0.0;
        return result;
      case 13:
        v9 = CFSTR("HW Ref Block Size");
        goto LABEL_24;
      case 14:
        v9 = CFSTR("HW Mic Block Size");
        goto LABEL_24;
      case 15:
        v9 = CFSTR("Echo Processing Block Size");
        goto LABEL_24;
      case 16:
        v9 = CFSTR("UpSampling Output Block Size");
LABEL_24:
        buffer->cfNameString = v9;
        buffer->flags = -939524096;
        CFStringGetCString(v9, buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_SampleFrames;
        result = 1.03845962e34;
        *(_QWORD *)&buffer->minValue = 0x470000003F800000;
        v10 = 480.0;
        goto LABEL_26;
      case 17:
        buffer->cfNameString = CFSTR("To enable or disable clip detection, disable==0");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("To enable or disable clip detection, disable==0"), buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Boolean;
        result = 1.03845937e34;
        *(_QWORD *)&buffer->minValue = 0x4700000000000000;
        v10 = 1.0;
LABEL_26:
        v11 = buffer->flags & 0x7FFFFFFF;
        buffer->defaultValue = v10;
        buffer->flags = v11;
        break;
      case 18:
        buffer->cfNameString = CFSTR("Driver Processing Mode");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Driver Processing Mode"), buffer->name, 52, 0x8000100u);
        buffer->unit = kAudioUnitParameterUnit_Indexed;
        result = 0.0078125;
        *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
        v12 = buffer->flags & 0x7FFFFFFF;
        buffer->defaultValue = 0.0;
        buffer->flags = v12;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t AUAuxVP::GetPropertyInfo(AUAuxVP *this, int a2, int a3, int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  BOOL v7;

  if (a3)
    return 4294956430;
  if (a4)
    return 4294956419;
  if (a2 == 3999)
  {
    v7 = 1;
    goto LABEL_9;
  }
  if (a2 == 3998)
  {
    v7 = 0;
LABEL_9:
    result = 0;
    *a6 = v7;
    *a5 = 16;
    return result;
  }
  return 4294956417;
}

uint64_t AUAuxVP::GetProperty(AUAuxVP *this, int a2, int a3, int a4, _QWORD *a5)
{
  uint64_t result;

  if (a3)
    return 4294956430;
  if (a4)
    return 4294956419;
  if (a2 == 3998)
  {
    result = 0;
    *a5 = this;
    a5[1] = AUAuxVP::UpdateParameterValue;
  }
  else if (a2 == 3999)
  {
    result = 0;
    *(_OWORD *)a5 = *((_OWORD *)this + 33);
  }
  else
  {
    return 4294956417;
  }
  return result;
}

__n128 AUAuxVP::SetProperty(__n128 *this, int a2, int a3, int a4, __n128 *a5, unsigned int a6)
{
  __n128 result;

  if (!a3 && !a4 && a2 == 3999 && a6 >= 0x10)
  {
    result = *a5;
    this[33] = *a5;
  }
  return result;
}

uint64_t AUAuxVP::SetParameter(AUAuxVP *this, uint64_t a2, uint64_t a3, uint64_t a4, float a5, uint64_t a6)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  uint64_t (*v14)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, float);

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  v14 = (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, float))*((_QWORD *)this + 67);
  if (v14)
    return v14(*((_QWORD *)this + 66), *((_QWORD *)this + 1), a2, a3, a4, a6, a5);
  else
    return 0;
}

uint64_t AUAuxVP::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *Scope;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  ausdk::AUElement *v11;
  unsigned int v12;
  unsigned int *begin;
  std::vector<unsigned int>::pointer end;
  float Parameter;
  std::vector<unsigned int> v17;

  v3 = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)v3 && this[67])
  {
    v4 = 0;
    do
    {
      Scope = (_QWORD *)ausdk::AUBase::GetScope((ausdk::AUBase *)this, v4);
      v6 = Scope[5];
      if (v6)
      {
        LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
        if ((_DWORD)v7)
          goto LABEL_8;
      }
      else
      {
        v7 = (Scope[3] - Scope[2]) >> 3;
        if ((_DWORD)v7)
        {
LABEL_8:
          v8 = 0;
          v9 = v7;
          do
          {
            v10 = Scope[5];
            if (v10)
              v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 32))(v10, v8);
            else
              v11 = *(ausdk::AUElement **)(Scope[2] + 8 * v8);
            v12 = (*(uint64_t (**)(ausdk::AUElement *))(*(_QWORD *)v11 + 16))(v11);
            std::vector<unsigned int>::vector(&v17, v12);
            (*(void (**)(ausdk::AUElement *, std::vector<unsigned int>::pointer))(*(_QWORD *)v11 + 24))(v11, v17.__begin_);
            begin = v17.__begin_;
            end = v17.__end_;
            if (v17.__begin_ != v17.__end_)
            {
              do
              {
                Parameter = ausdk::AUElement::GetParameter(v11, *begin);
                ((void (*)(OpaqueAudioComponentInstance *, OpaqueAudioComponentInstance *, _QWORD, uint64_t, uint64_t, _QWORD, float))this[67])(this[66], this[1], *begin++, v4, v8, 0, Parameter);
              }
              while (begin != end);
              begin = v17.__begin_;
            }
            if (begin)
            {
              v17.__end_ = begin;
              operator delete(begin);
            }
            ++v8;
          }
          while (v8 != v9);
        }
      }
      v4 = (v4 + 1);
    }
    while ((_DWORD)v4 != 4);
  }
  return v3;
}

void sub_1B657977C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t AUAuxVP::StreamFormatWritable(AUAuxVP *this)
{
  return 0;
}

uint64_t AUAuxVP::UpdateParameterValue(AUAuxVP *this, void *a2, unsigned int a3, unsigned int a4, float a5)
{
  unsigned int v7;
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;

  v7 = a2;
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, v7, a5, 0);
  return 0;
}

uint64_t (*AUAuxVPLookup::Lookup(AUAuxVPLookup *this))(ausdk *__hidden this, void *)
{
  if (((_DWORD)this - 1) > 0x11)
    return 0;
  else
    return off_1E69EDA98[(int)this - 1];
}

void vp::CFNotificationDelegate::createDelegate(uint64_t **a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v12;
  unint64_t v13;
  unint64_t *p_shared_weak_owners;
  unint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t *v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t ***v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  __CFNotificationCenter *LocalCenter;
  int v30;
  const UInt8 *v31;
  CFIndex v32;
  const __CFString *v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t *v36;
  char v37;
  uint64_t **v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  NSObject *v41;
  uint64_t *v42;
  uint64_t **v43;
  uint64_t **v44;
  uint64_t *v45;
  BOOL v46;
  uint64_t **v47;
  uint64_t *v48;
  std::string *v49;
  __int128 v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  _QWORD *v59;
  uint64_t *v60;
  uint64_t *v61;
  uint64_t *v62;
  std::runtime_error *exception;
  uint64_t v64;
  uint64_t **v65;
  uint64_t **v66;
  uint64_t ***v67;
  std::__shared_weak_count *v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  uint64_t *v71;
  uint64_t **v72;
  _BYTE buf[18];
  __int16 v74;
  uint64_t *v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v6 = operator new();
  v7 = v6;
  *(_QWORD *)v6 = 0;
  *(_QWORD *)(v6 + 8) = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v6 + 16), *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)(v6 + 16) = *(_OWORD *)a2;
    *(_QWORD *)(v6 + 32) = *(_QWORD *)(a2 + 16);
  }
  v8 = a3 + 3;
  v9 = (_QWORD *)a3[3];
  if (!v9)
  {
    v8 = (_QWORD *)(v7 + 64);
    goto LABEL_8;
  }
  if (v9 != a3)
  {
    *(_QWORD *)(v7 + 64) = v9;
LABEL_8:
    *v8 = 0;
    goto LABEL_10;
  }
  *(_QWORD *)(v7 + 64) = v7 + 40;
  (*(void (**)(_QWORD *, uint64_t))(*a3 + 24))(a3, v7 + 40);
LABEL_10:
  *(_BYTE *)(v7 + 72) = 0;
  vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance((vp::CFNotificationDelegate::CFNotificationHandler *)(v7 + 80));
  *a1 = (uint64_t *)v7;
  *(_QWORD *)buf = v7;
  v10 = (std::__shared_weak_count *)operator new();
  v10->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69EC2C0;
  v10->__shared_weak_owners_ = 0;
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
  a1[1] = (uint64_t *)v10;
  v12 = *(std::__shared_weak_count **)(v7 + 8);
  if (v12)
  {
    if (v12->__shared_owners_ != -1)
      goto LABEL_23;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v15 = __ldxr(p_shared_weak_owners);
    while (__stxr(v15 + 1, p_shared_weak_owners));
    *(_QWORD *)v7 = v7;
    *(_QWORD *)(v7 + 8) = v10;
    std::__shared_weak_count::__release_weak(v12);
  }
  else
  {
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
    v17 = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
    *(_QWORD *)v7 = v7;
    *(_QWORD *)(v7 + 8) = v10;
  }
  do
    v19 = __ldaxr(p_shared_owners);
  while (__stlxr(v19 - 1, p_shared_owners));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
LABEL_23:
  v20 = *a1;
  v22 = **a1;
  v21 = (std::__shared_weak_count *)(*a1)[1];
  if (v21)
  {
    v23 = (unint64_t *)&v21->__shared_weak_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance((vp::CFNotificationDelegate::CFNotificationHandler *)&v67);
  if (!v21)
  {
    v28 = 0;
    v69 = 0;
    v70 = 0;
    goto LABEL_52;
  }
  v25 = v67;
  v26 = (unint64_t *)&v21->__shared_weak_owners_;
  do
    v27 = __ldxr(v26);
  while (__stxr(v27 + 1, v26));
  v69 = 0;
  v70 = 0;
  v28 = std::__shared_weak_count::lock(v21);
  v70 = v28;
  if (!v28 || (v69 = v22) == 0)
  {
LABEL_52:
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    if (VPLogScope(void)::scope)
    {
      v41 = *(NSObject **)VPLogScope(void)::scope;
      if (!*(_QWORD *)VPLogScope(void)::scope)
        goto LABEL_63;
    }
    else
    {
      v41 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)v20 + 39) >= 0)
        v42 = v20 + 2;
      else
        v42 = (uint64_t *)v20[2];
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpCFNotificationDelegate.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 59;
      v74 = 2080;
      v75 = v42;
      _os_log_impl(&dword_1B5ED0000, v41, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to add notification handle for notication with name [%s]", buf, 0x1Cu);
    }
LABEL_63:
    if (!v28)
      goto LABEL_99;
    goto LABEL_95;
  }
  std::mutex::lock((std::mutex *)(v25 + 3));
  v64 = v22;
  *((_BYTE *)v25 + 88) = 1;
  LocalCenter = CFNotificationCenterGetLocalCenter();
  v30 = *((char *)v20 + 39);
  if (v30 >= 0)
    v31 = (const UInt8 *)(v20 + 2);
  else
    v31 = (const UInt8 *)v20[2];
  if (v30 >= 0)
    v32 = *((unsigned __int8 *)v20 + 39);
  else
    v32 = v20[3];
  v33 = CFStringCreateWithBytes(0, v31, v32, 0x8000100u, 0);
  *(_QWORD *)buf = v33;
  if (!v33)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  CFNotificationCenterAddObserver(LocalCenter, v25, (CFNotificationCallback)vp::cfNotificationCallback, v33, 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  CFRelease(v33);
  v35 = (uint64_t *)(v25 + 1);
  v34 = (uint64_t *)v25[1];
  if (v34)
  {
    v36 = (uint64_t *)(v25 + 1);
    do
    {
      v37 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v34 + 4, (void **)v20 + 2);
      if (v37 >= 0)
        v38 = (uint64_t **)v34;
      else
        v38 = (uint64_t **)(v34 + 1);
      if (v37 >= 0)
        v36 = v34;
      v34 = *v38;
    }
    while (*v38);
    if (v36 == v35)
    {
      v44 = (uint64_t **)(v25 + 1);
    }
    else
    {
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v20 + 2, (void **)v36 + 4) & 0x80) == 0)
      {
        do
          v39 = __ldxr(v26);
        while (__stxr(v39 + 1, v26));
        v40 = (std::__shared_weak_count *)v36[8];
        v36[7] = v64;
        v36[8] = (uint64_t)v21;
        if (v40)
          std::__shared_weak_count::__release_weak(v40);
        goto LABEL_94;
      }
      v44 = (uint64_t **)(v25 + 1);
      if (v35 != v36)
      {
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v20 + 2, (void **)v36 + 4) & 0x80) == 0)
        {
          if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v36 + 4, (void **)v20 + 2) & 0x80) == 0)
          {
            v71 = v36;
            v72 = (uint64_t **)v36;
            v66 = &v71;
            if (!v36)
              goto LABEL_81;
            goto LABEL_94;
          }
          v59 = (_QWORD *)v36[1];
          if (v59)
          {
            v60 = (uint64_t *)v36[1];
            do
            {
              v61 = v60;
              v60 = (uint64_t *)*v60;
            }
            while (v60);
          }
          else
          {
            v62 = v36;
            do
            {
              v61 = (uint64_t *)v62[2];
              v46 = *v61 == (_QWORD)v62;
              v62 = v61;
            }
            while (!v46);
          }
          if (v61 == v35)
            goto LABEL_120;
          if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v20 + 2, (void **)v61 + 4) & 0x80) != 0)
          {
            v59 = (_QWORD *)v36[1];
LABEL_120:
            if (v59)
            {
              v72 = (uint64_t **)v61;
              v47 = (uint64_t **)v61;
            }
            else
            {
              v72 = (uint64_t **)v36;
              v47 = (uint64_t **)(v36 + 1);
            }
            goto LABEL_80;
          }
LABEL_75:
          v47 = (uint64_t **)std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__find_equal<std::string>((uint64_t)v25, &v72, (void **)v20 + 2);
          goto LABEL_80;
        }
        v44 = (uint64_t **)v36;
      }
    }
    v34 = *v44;
    v43 = v44;
  }
  else
  {
    v43 = (uint64_t **)(v25 + 1);
  }
  v65 = v43;
  if (*v25 != v43)
  {
    if (v34)
    {
      do
      {
        v43 = (uint64_t **)v34;
        v34 = (uint64_t *)v34[1];
      }
      while (v34);
    }
    else
    {
      v45 = (uint64_t *)v43;
      do
      {
        v43 = (uint64_t **)v45[2];
        v46 = *v43 == v45;
        v45 = (uint64_t *)v43;
      }
      while (v46);
    }
    if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v43 + 4, (void **)v20 + 2) & 0x80) == 0)
      goto LABEL_75;
    v34 = *v65;
  }
  if (v34)
  {
    v72 = v43;
    v47 = v43 + 1;
  }
  else
  {
    v47 = v65;
    v72 = v65;
  }
LABEL_80:
  v66 = v47;
  if (!*v47)
  {
LABEL_81:
    v48 = (uint64_t *)operator new(0x48uLL);
    *(_QWORD *)buf = v48;
    *(_QWORD *)&buf[8] = v25 + 1;
    buf[16] = 0;
    v49 = (std::string *)(v48 + 4);
    if (*((char *)v20 + 39) < 0)
    {
      std::string::__init_copy_ctor_external(v49, (const std::string::value_type *)v20[2], v20[3]);
    }
    else
    {
      v50 = *((_OWORD *)v20 + 1);
      v48[6] = v20[4];
      *(_OWORD *)&v49->__r_.__value_.__l.__data_ = v50;
    }
    v48[7] = v64;
    v48[8] = (uint64_t)v21;
    do
      v51 = __ldxr(v26);
    while (__stxr(v51 + 1, v26));
    buf[16] = 1;
    v52 = (uint64_t)v72;
    *v48 = 0;
    v48[1] = 0;
    v48[2] = v52;
    *v66 = v48;
    v53 = **v25;
    if (v53)
    {
      *v25 = (uint64_t **)v53;
      v48 = *v66;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v25[1], v48);
    v25[2] = (uint64_t **)((char *)v25[2] + 1);
    *(_QWORD *)buf = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,void *>>>>::reset[abi:ne180100]((uint64_t)buf);
  }
LABEL_94:
  std::mutex::unlock((std::mutex *)(v25 + 3));
LABEL_95:
  v54 = (unint64_t *)&v28->__shared_owners_;
  do
    v55 = __ldaxr(v54);
  while (__stlxr(v55 - 1, v54));
  if (!v55)
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
LABEL_99:
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
  v56 = v68;
  if (v68)
  {
    v57 = (unint64_t *)&v68->__shared_owners_;
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
}

void sub_1B6579F00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  std::__shared_weak_count *v19;
  uint64_t v20;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,void *>>>>::reset[abi:ne180100]((uint64_t)&a19);
  std::mutex::unlock(a11);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::__shared_weak_count::__release_weak(v19);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  if (v19)
    std::__shared_weak_count::__release_weak(v19);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v20);
  _Unwind_Resume(a1);
}

void vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance(vp::CFNotificationDelegate::CFNotificationHandler *this)
{
  unsigned __int8 v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;

  if ((v2 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))std::weak_ptr<vp::CFNotificationDelegate::CFNotificationHandler>::~weak_ptr, &vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance(void)::sWeakNotificationInstance, &dword_1B5ED0000);
  }
  if (qword_1EF1374A0)
  {
    v3 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_1EF1374A0);
    v4 = v3;
    if (v3 && vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance(void)::sWeakNotificationInstance)
    {
      *(_QWORD *)this = vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance(void)::sWeakNotificationInstance;
      *((_QWORD *)this + 1) = v3;
      return;
    }
  }
  else
  {
    v4 = 0;
  }
  v5 = operator new();
  *(_QWORD *)(v5 + 8) = 0;
  *(_QWORD *)v5 = v5 + 8;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)(v5 + 24) = 850045863;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_QWORD *)(v5 + 80) = 0;
  *(_BYTE *)(v5 + 88) = 1;
  *(_QWORD *)this = v5;
  v6 = (_QWORD *)operator new();
  v6[2] = 0;
  v7 = v6 + 2;
  *v6 = &off_1E69EC288;
  v6[1] = 0;
  v6[3] = v5;
  *((_QWORD *)this + 1) = v6;
  do
    v8 = __ldxr(v7);
  while (__stxr(v8 + 1, v7));
  v9 = (std::__shared_weak_count *)qword_1EF1374A0;
  vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance(void)::sWeakNotificationInstance = v5;
  qword_1EF1374A0 = (uint64_t)v6;
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1B657A1CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  std::unique_ptr<vp::CFNotificationDelegate::CFNotificationHandler>::reset[abi:ne180100]((vp::CFNotificationDelegate::CFNotificationHandler **)va1);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void vp::cfNotificationCallback(vp *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  uint64_t v8;
  std::mutex *v9;
  void **v10;
  void **v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  _QWORD *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *p_shared_weak_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::runtime_error *exception;
  CFTypeRef cf;
  void *__p[2];
  char v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  _QWORD *v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  const void *v40;

  vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance((vp::CFNotificationDelegate::CFNotificationHandler *)&v34);
  v8 = v34;
  if (a3)
    CFRetain(a3);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, a3);
  if (!cf)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)__p);
  v9 = (std::mutex *)(v8 + 24);
  std::mutex::lock((std::mutex *)(v8 + 24));
  if (*(_BYTE *)(v8 + 88))
  {
    v10 = std::__tree<std::__value_type<std::string,applesauce::CF::TypeRef>,std::__map_value_compare<std::string,std::__value_type<std::string,applesauce::CF::TypeRef>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,applesauce::CF::TypeRef>>>::find<std::string>(v8, __p);
    if ((void **)(v8 + 8) != v10)
    {
      v11 = v10;
      v12 = (std::__shared_weak_count *)v10[8];
      if (v12)
      {
        v13 = std::__shared_weak_count::lock(v12);
        v37 = v13;
        if (v13)
        {
          v14 = v13;
          v15 = v11[7];
          v36 = v15;
          if (v15)
          {
            v16 = (std::__shared_weak_count *)v15[1];
            if (v16)
            {
              v17 = *v15;
              p_shared_weak_owners = (unint64_t *)&v16->__shared_weak_owners_;
              do
                v19 = __ldxr(p_shared_weak_owners);
              while (__stxr(v19 + 1, p_shared_weak_owners));
              v20 = std::__shared_weak_count::lock(v16);
              v39 = v20;
              if (v20)
              {
                v21 = v20;
                v38 = v17;
                std::__shared_weak_count::__release_weak(v16);
                if (v17)
                {
                  v40 = a5;
                  v22 = *(_QWORD *)(v17 + 64);
                  if (!v22)
                    std::__throw_bad_function_call[abi:ne180100]();
                  (*(void (**)(uint64_t, const void **))(*(_QWORD *)v22 + 48))(v22, &v40);
                }
                p_shared_owners = (unint64_t *)&v21->__shared_owners_;
                do
                  v24 = __ldaxr(p_shared_owners);
                while (__stlxr(v24 - 1, p_shared_owners));
                if (v24)
                  goto LABEL_22;
                ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
              }
              else
              {
                v21 = v16;
              }
              std::__shared_weak_count::__release_weak(v21);
            }
          }
LABEL_22:
          v25 = (unint64_t *)&v14->__shared_owners_;
          do
            v26 = __ldaxr(v25);
          while (__stlxr(v26 - 1, v25));
          if (!v26)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
      }
    }
  }
  std::mutex::unlock(v9);
  if (v33 < 0)
    operator delete(__p[0]);
  if (cf)
    CFRelease(cf);
  v27 = v35;
  if (v35)
  {
    v28 = (unint64_t *)&v35->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
}

void sub_1B657A410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21)
{
  std::mutex *v21;

  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)&a21);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  std::mutex::unlock(v21);
  if (a16 < 0)
    operator delete(__p);
  applesauce::CF::StringRef::~StringRef(&a10);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::weak_ptr<vp::CFNotificationDelegate>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::weak_ptr<vp::CFNotificationDelegate>>,0>(uint64_t a1)
{
  std::__shared_weak_count *v2;

  v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::weak_ptr<vp::CFNotificationDelegate::CFNotificationHandler>::~weak_ptr(uint64_t a1)
{
  std::__shared_weak_count *v2;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

vp::CFNotificationDelegate::CFNotificationHandler *std::unique_ptr<vp::CFNotificationDelegate::CFNotificationHandler>::reset[abi:ne180100](vp::CFNotificationDelegate::CFNotificationHandler **a1)
{
  vp::CFNotificationDelegate::CFNotificationHandler *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    vp::CFNotificationDelegate::CFNotificationHandler::~CFNotificationHandler(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void vp::CFNotificationDelegate::CFNotificationHandler::~CFNotificationHandler(vp::CFNotificationDelegate::CFNotificationHandler *this)
{
  std::mutex *v2;

  v2 = (std::mutex *)((char *)this + 24);
  std::mutex::lock((std::mutex *)((char *)this + 24));
  *((_BYTE *)this + 88) = 0;
  std::mutex::unlock(v2);
  std::mutex::~mutex(v2);
  std::__tree<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>>>::destroy(*((_QWORD **)this + 1));
}

void std::__tree<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::weak_ptr<vp::CFNotificationDelegate>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::weak_ptr<vp::CFNotificationDelegate>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__shared_ptr_pointer<vp::CFNotificationDelegate::CFNotificationHandler *,std::shared_ptr<vp::CFNotificationDelegate::CFNotificationHandler>::__shared_ptr_default_delete<vp::CFNotificationDelegate::CFNotificationHandler,vp::CFNotificationDelegate::CFNotificationHandler>,std::allocator<vp::CFNotificationDelegate::CFNotificationHandler>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC95CECLL);
}

vp::CFNotificationDelegate::CFNotificationHandler *std::__shared_ptr_pointer<vp::CFNotificationDelegate::CFNotificationHandler *,std::shared_ptr<vp::CFNotificationDelegate::CFNotificationHandler>::__shared_ptr_default_delete<vp::CFNotificationDelegate::CFNotificationHandler,vp::CFNotificationDelegate::CFNotificationHandler>,std::allocator<vp::CFNotificationDelegate::CFNotificationHandler>>::__on_zero_shared(uint64_t a1)
{
  vp::CFNotificationDelegate::CFNotificationHandler *result;

  result = *(vp::CFNotificationDelegate::CFNotificationHandler **)(a1 + 24);
  if (result)
  {
    vp::CFNotificationDelegate::CFNotificationHandler::~CFNotificationHandler(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void **std::unique_ptr<vp::CFNotificationDelegate>::reset[abi:ne180100](void ***a1)
{
  void **result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    vp::CFNotificationDelegate::~CFNotificationDelegate(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void vp::CFNotificationDelegate::~CFNotificationDelegate(void **this)
{
  vp::CFNotificationDelegate *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  vp::CFNotificationDelegate::shutdown(this);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)(this + 10));
  v2 = (vp::CFNotificationDelegate *)this[8];
  if (v2 == (vp::CFNotificationDelegate *)(this + 5))
  {
    v3 = 4;
    v2 = (vp::CFNotificationDelegate *)(this + 5);
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
LABEL_6:
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  v4 = (std::__shared_weak_count *)this[1];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

void vp::CFNotificationDelegate::shutdown(void **this)
{
  uint64_t **v2;
  std::mutex *v3;
  void **v4;
  uint64_t *v5;
  __CFNotificationCenter *LocalCenter;
  int v7;
  const UInt8 *v8;
  CFIndex v9;
  const __CFString *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  uint64_t *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v19;
  std::mutex *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::runtime_error *exception;
  uint64_t v25;
  std::__shared_weak_count *v26;
  const __CFString *v27;

  vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance((vp::CFNotificationDelegate::CFNotificationHandler *)&v25);
  v2 = (uint64_t **)v25;
  v3 = (std::mutex *)(v25 + 24);
  std::mutex::lock((std::mutex *)(v25 + 24));
  v4 = std::__tree<std::__value_type<std::string,applesauce::CF::TypeRef>,std::__map_value_compare<std::string,std::__value_type<std::string,applesauce::CF::TypeRef>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,applesauce::CF::TypeRef>>>::find<std::string>((uint64_t)v2, this + 2);
  if (v2 + 1 != (uint64_t **)v4)
  {
    v5 = (uint64_t *)v4;
    LocalCenter = CFNotificationCenterGetLocalCenter();
    v7 = *((char *)this + 39);
    if (v7 >= 0)
      v8 = (const UInt8 *)(this + 2);
    else
      v8 = (const UInt8 *)this[2];
    if (v7 >= 0)
      v9 = *((unsigned __int8 *)this + 39);
    else
      v9 = (CFIndex)this[3];
    v10 = CFStringCreateWithBytes(0, v8, v9, 0x8000100u, 0);
    v27 = v10;
    if (!v10)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    CFNotificationCenterRemoveObserver(LocalCenter, v2, v10, 0);
    CFRelease(v10);
    v11 = (uint64_t *)v5[1];
    if (v11)
    {
      do
      {
        v12 = v11;
        v11 = (uint64_t *)*v11;
      }
      while (v11);
    }
    else
    {
      v13 = v5;
      do
      {
        v12 = (uint64_t *)v13[2];
        v14 = *v12 == (_QWORD)v13;
        v13 = v12;
      }
      while (!v14);
    }
    if (*v2 == v5)
      *v2 = v12;
    v15 = v2[1];
    v2[2] = (uint64_t *)((char *)v2[2] - 1);
    std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v15, v5);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::weak_ptr<vp::CFNotificationDelegate>>,0>((uint64_t)(v5 + 4));
    operator delete(v5);
  }
  if (!v2[2])
    *((_BYTE *)v2 + 88) = 0;
  std::mutex::unlock(v3);
  v16 = v26;
  if (v26)
  {
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  vp::CFNotificationDelegate::CFNotificationHandler::sharedInstance((vp::CFNotificationDelegate::CFNotificationHandler *)&v25);
  v19 = v25;
  v20 = (std::mutex *)(v25 + 24);
  std::mutex::lock((std::mutex *)(v25 + 24));
  *(_BYTE *)(v19 + 88) = 0;
  std::mutex::unlock(v20);
  v21 = v26;
  if (v26)
  {
    v22 = (unint64_t *)&v26->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_1B657A91C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  std::mutex *v12;

  std::mutex::unlock(v12);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<vp::CFNotificationDelegate *,std::shared_ptr<vp::CFNotificationDelegate>::__shared_ptr_default_delete<vp::CFNotificationDelegate,vp::CFNotificationDelegate>,std::allocator<vp::CFNotificationDelegate>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void **std::__shared_ptr_pointer<vp::CFNotificationDelegate *,std::shared_ptr<vp::CFNotificationDelegate>::__shared_ptr_default_delete<vp::CFNotificationDelegate,vp::CFNotificationDelegate>,std::allocator<vp::CFNotificationDelegate>>::__on_zero_shared(uint64_t a1)
{
  void **result;

  result = *(void ***)(a1 + 24);
  if (result)
  {
    vp::CFNotificationDelegate::~CFNotificationDelegate(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void aec_v4::aec_init(uint64_t **a1, unsigned int a2, int a3, int a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15, float a16, int a17, float a18, float a19, int a20,int a21,int a22,int a23,float a24,int a25,__int32 a26,__int32 a27,int a28,int a29,int a30,signed int a31,int a32,int a33,float a34)
{
  _QWORD *v47;
  _QWORD *v48;
  int v49;
  uint64_t *v50;
  _DWORD *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  size_t v56;
  _OWORD *v57;
  unsigned int v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  uint64_t v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  uint64_t v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  float *v89;
  int v90;
  vDSP_Length v91;
  size_t v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  void *v100;
  void *v101;
  size_t v102;
  void *v103;
  void *v104;
  uint64_t v105;
  size_t v106;
  void *v107;
  void *v108;
  void *v109;
  void *v110;
  uint64_t v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  void *v116;
  void *v117;
  void *v118;
  void *v119;
  uint64_t v120;
  _DWORD *v121;
  _DWORD *v122;
  uint64_t v123;
  void *v124;
  void *v125;
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  void *v132;
  void *v133;
  _QWORD *v134;
  void *v135;
  void *v136;
  uint64_t *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  int64_t v142;
  int v143;
  uint64_t v144;
  char *v145;
  char *v146;
  size_t v147;
  void *v148;
  int v149;
  void *v150;
  uint64_t v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  float v162;
  uint64_t v163;
  float v164;
  void *v165;
  void *v166;
  void *v167;
  void *v168;
  uint64_t v169;
  _DWORD *v170;
  _DWORD *v171;
  uint64_t v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  float v179;
  float *v180;
  int64_t i;
  uint64_t v182;
  float *v183;
  float v184;
  float *v185;
  uint64_t v186;
  float v187;
  uint64_t v188;
  __int128 v189;
  void *v190;
  void *v191;
  void *v192;
  void *v193;
  uint64_t v194;
  _DWORD *v195;
  _DWORD *v196;
  uint64_t v197;
  float v198;
  unsigned int v199;
  unsigned int v200;
  size_t v201;
  size_t v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  size_t v209;
  void *v210;
  void *v211;
  void *v212;
  void *v213;
  void *v214;
  void *v215;
  int32x2_t v216;
  uint32x2_t *v217;
  float32x2_t v218;
  uint32x2_t v223;
  float v224;
  unsigned int v225;
  float v226;
  unsigned int v227;
  float v228;
  unsigned int v229;
  unsigned int v230;
  unsigned int v231;
  unsigned int v232;
  size_t v233;
  void *v234;
  void *v236;
  uint64_t v237;
  uint64_t v238;
  _DWORD *v239;
  _DWORD *v240;
  uint64_t v241;
  _DWORD *v242;
  _DWORD *v243;
  unsigned int v244;
  float v245;
  uint64_t v246;
  float v247;
  uint64_t v248;
  uint64_t v249;
  void *v250;
  void *v251;
  int32x2_t v252;
  uint64_t v253;
  uint64_t v254;
  void *v255;
  void *v256;
  int32x2_t v257;
  uint64_t v258;
  int v259;
  int v260;
  int v261;
  int v262;
  int32x2_t v263;
  uint64_t v264;
  int32x2_t *v266;
  int v267;
  int v268;
  int v269;
  int32x2_t v270;
  int v271;
  void *v272;
  void *v274;
  void *v275;
  void *v277;
  void *v278;
  void *v280;
  void *v281;
  void *v283;
  int v284;
  void *v285;
  void *v286;
  void *v287;
  void *v288;
  void *v289;
  void *v290;
  void *v291;
  void *v292;
  float v293;
  uint64_t v294;
  size_t v295;
  void *v296;
  void *v297;
  void *v298;
  void *v299;
  void *v300;
  void *v301;
  void *v302;
  void *v303;
  uint64_t *v304;
  int *v305;
  vDSP_Length v306;
  uint64_t v307;
  uint64_t v308;
  void *v309;
  void *v310;
  void *v311;
  void *v312;
  void *v313;
  void *v314;
  void *v315;
  void *v316;
  void *v317;
  void *v318;
  void *v319;
  void *v320;
  void *v321;
  void *v322;
  void *v323;
  void *v324;
  void *v325;
  void *v326;
  uint64_t v327;
  _QWORD *v328;
  void *v329;
  void *v330;
  size_t v331;
  void *v332;
  void *v333;
  _QWORD *v334;
  uint64_t v335;
  _QWORD *v336;
  uint64_t v337;
  void *v338;
  void *v339;
  void *v340;
  void *v341;
  void *v342;
  void *v343;
  uint64_t v344;
  uint64_t v345;
  int v346;
  uint64_t v347;
  void *v348;
  void *v349;
  int v350;
  void *v351;
  void *v352;
  void *v353;
  void *v354;
  void *v355;
  void *v356;
  void *v357;
  void *v358;
  void *v359;
  void *v360;
  uint64_t v361;
  void *v362;
  void *v363;
  void *v364;
  void *v365;
  std::bad_alloc *exception;
  std::bad_alloc *v367;
  int v368;
  int v369;
  float v370;
  uint64_t v371;
  int v374;
  int v375;
  float v376;
  size_t size;
  uint64_t sizea;
  int v379;
  vDSP_Length v380;
  size_t v381;
  uint64_t v382;
  int v383;
  float __A;
  float __B;
  float v387[3];

  v47 = malloc_type_malloc(0x78uLL, 0x2C8E6D5CuLL);
  if (!v47)
    goto LABEL_289;
  v47[14] = 0;
  *((_OWORD *)v47 + 5) = 0u;
  *((_OWORD *)v47 + 6) = 0u;
  *((_OWORD *)v47 + 3) = 0u;
  *((_OWORD *)v47 + 4) = 0u;
  *((_OWORD *)v47 + 1) = 0u;
  *((_OWORD *)v47 + 2) = 0u;
  *(_OWORD *)v47 = 0u;
  *a1 = v47;
  v48 = malloc_type_malloc(0x178uLL, 0x2C8E6D5CuLL);
  if (!v48)
    goto LABEL_289;
  v48[46] = 0;
  *((_OWORD *)v48 + 21) = 0u;
  *((_OWORD *)v48 + 22) = 0u;
  *((_OWORD *)v48 + 19) = 0u;
  *((_OWORD *)v48 + 20) = 0u;
  *((_OWORD *)v48 + 17) = 0u;
  *((_OWORD *)v48 + 18) = 0u;
  *((_OWORD *)v48 + 15) = 0u;
  *((_OWORD *)v48 + 16) = 0u;
  *((_OWORD *)v48 + 13) = 0u;
  *((_OWORD *)v48 + 14) = 0u;
  *((_OWORD *)v48 + 11) = 0u;
  *((_OWORD *)v48 + 12) = 0u;
  *((_OWORD *)v48 + 9) = 0u;
  *((_OWORD *)v48 + 10) = 0u;
  *((_OWORD *)v48 + 7) = 0u;
  *((_OWORD *)v48 + 8) = 0u;
  *((_OWORD *)v48 + 5) = 0u;
  *((_OWORD *)v48 + 6) = 0u;
  *((_OWORD *)v48 + 3) = 0u;
  *((_OWORD *)v48 + 4) = 0u;
  *((_OWORD *)v48 + 1) = 0u;
  *((_OWORD *)v48 + 2) = 0u;
  *(_OWORD *)v48 = 0u;
  v49 = a3 / a4 <= 1 ? 1 : a3 / a4;
  (*a1)[7] = (uint64_t)v48;
  v383 = a4;
  v374 = a8;
  dft_v4::paramInit_v4(*a1, v49 * a4, a4, v49, a2, a7, a6, a8, a34, a5, a31, a32, a33);
  v50 = *a1;
  v51 = (_DWORD *)**a1;
  __A = 0.0;
  v52 = v51[9];
  v53 = (int)v51[34];
  v54 = v51[37];
  v380 = (int)v51[38];
  v381 = v51[11];
  v55 = (int)v51[18];
  v56 = (int)v51[32];
  v57 = malloc_type_malloc(0xA0uLL, 0x2C8E6D5CuLL);
  if (!v57)
    goto LABEL_289;
  v368 = a7;
  v379 = a6;
  v57[8] = 0u;
  v57[9] = 0u;
  v57[6] = 0u;
  v57[7] = 0u;
  v57[4] = 0u;
  v57[5] = 0u;
  v57[2] = 0u;
  v57[3] = 0u;
  *v57 = 0u;
  v57[1] = 0u;
  size = v56;
  v58 = v56 * v52;
  v50[1] = (uint64_t)v57;
  if ((_DWORD)v56 * v52 < 0)
    goto LABEL_289;
  v59 = malloc_type_malloc(4 * (v56 * v52), 0x2C8E6D5CuLL);
  v60 = v59;
  if (v58)
  {
    if (!v59)
      goto LABEL_289;
  }
  bzero(v59, 4 * v58);
  *(_QWORD *)v50[1] = v60;
  v61 = malloc_type_malloc(4 * v58, 0x2C8E6D5CuLL);
  v62 = v61;
  if (v58)
  {
    if (!v61)
      goto LABEL_289;
  }
  bzero(v61, 4 * v58);
  *(_QWORD *)(v50[1] + 8) = v62;
  v63 = malloc_type_malloc(8 * v53, 0x2C8E6D5CuLL);
  v64 = v63;
  if ((_DWORD)v53)
  {
    if (!v63)
      goto LABEL_289;
  }
  bzero(v63, 8 * v53);
  *(_QWORD *)(v50[1] + 32) = v64;
  *(_QWORD *)(v50[1] + 40) = *(_QWORD *)(v50[1] + 32);
  *(_QWORD *)(v50[1] + 48) = *(_QWORD *)(v50[1] + 32) + 4 * v53;
  if (v51[25])
  {
    *(_QWORD *)(v50[1] + 56) = 0;
    *(_QWORD *)(v50[1] + 64) = 0;
  }
  else
  {
    v65 = (int)v51[33];
    v66 = malloc_type_malloc(8 * v65, 0x2C8E6D5CuLL);
    v67 = v66;
    if ((_DWORD)v65 && !v66)
      goto LABEL_289;
    bzero(v66, 8 * v65);
    *(_QWORD *)(v50[1] + 56) = v67;
    v68 = malloc_type_malloc(8 * v65, 0x2C8E6D5CuLL);
    v69 = v68;
    if ((_DWORD)v65)
    {
      if (!v68)
        goto LABEL_289;
    }
    bzero(v68, 8 * v65);
    *(_QWORD *)(v50[1] + 64) = v69;
    v70 = (int)v51[19];
    v71 = malloc_type_malloc(4 * v70, 0x2C8E6D5CuLL);
    v72 = v71;
    if ((_DWORD)v70)
    {
      if (!v71)
        goto LABEL_289;
    }
    bzero(v71, 4 * v70);
    **(_QWORD **)(v50[1] + 56) = v72;
    v73 = malloc_type_malloc(4 * v70, 0x2C8E6D5CuLL);
    v74 = v73;
    if ((_DWORD)v70)
    {
      if (!v73)
        goto LABEL_289;
    }
    bzero(v73, 4 * v70);
    **(_QWORD **)(v50[1] + 64) = v74;
    v75 = v51[33];
    if (v75 >= 2)
    {
      v76 = 0;
      v77 = 8 * (v75 - 1);
      do
      {
        v78 = (_QWORD *)(*(_QWORD *)(v50[1] + 56) + v76);
        v78[1] = *v78 + 4 * v55;
        v79 = (_QWORD *)(*(_QWORD *)(v50[1] + 64) + v76);
        v79[1] = *v79 + 4 * v55;
        v76 += 8;
      }
      while (v77 != v76);
    }
  }
  v80 = v50[1];
  *(_DWORD *)(v80 + 112) = v51[11];
  *(_QWORD *)(v80 + 72) = 0;
  *(_DWORD *)(v80 + 80) = 0;
  if ((v381 & 0x80000000) != 0)
    goto LABEL_289;
  v81 = malloc_type_malloc(4 * v381, 0x2C8E6D5CuLL);
  v82 = v81;
  if ((_DWORD)v381)
  {
    if (!v81)
      goto LABEL_289;
  }
  bzero(v81, 4 * v381);
  *(_QWORD *)(v50[1] + 88) = v82;
  if ((v54 & 0x80000000) != 0)
    goto LABEL_289;
  v83 = malloc_type_malloc(4 * v54, 0x2C8E6D5CuLL);
  v84 = v83;
  if ((_DWORD)v54)
  {
    if (!v83)
      goto LABEL_289;
  }
  bzero(v83, 4 * v54);
  *(_QWORD *)(v50[1] + 16) = v84;
  v85 = malloc_type_malloc(4 * v54, 0x2C8E6D5CuLL);
  v86 = v85;
  if ((_DWORD)v54)
  {
    if (!v85)
      goto LABEL_289;
  }
  bzero(v85, 4 * v54);
  *(_QWORD *)(v50[1] + 24) = v86;
  if ((v380 & 0x80000000) != 0)
    goto LABEL_289;
  v87 = malloc_type_malloc(4 * v380, 0x2C8E6D5CuLL);
  v88 = v87;
  if ((_DWORD)v380)
  {
    if (!v87)
      goto LABEL_289;
  }
  bzero(v87, 4 * v380);
  *(_QWORD *)(v50[1] + 96) = v88;
  v89 = *(float **)(v50[1] + 96);
  __A = 9.0e-10;
  vDSP_vfill(&__A, v89, 1, v380);
  v90 = v56 * v381;
  if ((_DWORD)v56 * (_DWORD)v381 < 0)
    goto LABEL_289;
  v91 = v90;
  v92 = 4 * v90;
  v93 = malloc_type_malloc(v92, 0x2C8E6D5CuLL);
  v94 = v93;
  if ((_DWORD)v91)
  {
    if (!v93)
      goto LABEL_289;
  }
  bzero(v93, v92);
  *(_QWORD *)(v50[1] + 104) = v94;
  vDSP_vclr(*(float **)(v50[1] + 104), 1, v91);
  v95 = malloc_type_malloc(v56, 0x2C8E6D5CuLL);
  v96 = v95;
  if ((_DWORD)v56)
  {
    if (!v95)
      goto LABEL_289;
  }
  bzero(v95, v56);
  *(_QWORD *)(v50[1] + 120) = v96;
  v97 = malloc_type_malloc(v56, 0x2C8E6D5CuLL);
  v98 = v97;
  if ((_DWORD)v56)
  {
    if (!v97)
      goto LABEL_289;
    bzero(v97, v56);
    *(_QWORD *)(v50[1] + 128) = v98;
    v99 = malloc_type_malloc(v56, 0x2C8E6D5CuLL);
    if (!v99)
      goto LABEL_289;
    v100 = v99;
    bzero(v99, v56);
    *(_QWORD *)(v50[1] + 136) = v100;
    if ((v56 & 0x80000000) != 0)
      goto LABEL_289;
  }
  else
  {
    bzero(v97, v56);
    *(_QWORD *)(v50[1] + 128) = v98;
    v101 = malloc_type_malloc(v56, 0x2C8E6D5CuLL);
    bzero(v101, v56);
    *(_QWORD *)(v50[1] + 136) = v101;
  }
  v102 = 4 * v56;
  v103 = malloc_type_malloc(v102, 0x2C8E6D5CuLL);
  v104 = v103;
  if ((_DWORD)size)
  {
    if (!v103)
      goto LABEL_289;
  }
  bzero(v103, v102);
  *(_QWORD *)(v50[1] + 144) = v104;
  v105 = v50[1];
  if ((_DWORD)size)
  {
    memset(*(void **)(v105 + 120), 1, size);
    memset(*(void **)(v105 + 128), 1, size);
    bzero(*(void **)(v105 + 144), 4 * size);
  }
  *(_DWORD *)(v105 + 152) = v51[32];
  v106 = 4 * v383;
  v107 = malloc_type_malloc(v106, 0x2C8E6D5CuLL);
  v108 = v107;
  if (v383)
  {
    if (!v107)
      goto LABEL_289;
  }
  bzero(v107, v106);
  *(_QWORD *)(*a1)[7] = v108;
  v109 = malloc_type_malloc(v106, 0x2C8E6D5CuLL);
  v110 = v109;
  if (v383)
  {
    if (!v109)
      goto LABEL_289;
  }
  bzero(v109, v106);
  *(_QWORD *)((*a1)[7] + 8) = v110;
  v111 = *(int *)(**a1 + 136);
  v112 = malloc_type_malloc(8 * v111, 0x2C8E6D5CuLL);
  v113 = v112;
  if ((_DWORD)v111)
  {
    if (!v112)
      goto LABEL_289;
  }
  bzero(v112, 8 * v111);
  *(_QWORD *)((*a1)[7] + 16) = v113;
  *(_QWORD *)((*a1)[7] + 24) = *(_QWORD *)((*a1)[7] + 16) + 4 * v111;
  v114 = malloc_type_malloc(8 * v383, 0x2C8E6D5CuLL);
  v115 = v114;
  if (v383)
  {
    if (!v114)
      goto LABEL_289;
  }
  bzero(v114, 8 * v383);
  *(_QWORD *)((*a1)[7] + 32) = v115;
  *(_QWORD *)((*a1)[7] + 40) = *(_QWORD *)((*a1)[7] + 32) + 4 * v383;
  v116 = malloc_type_malloc(v106, 0x2C8E6D5CuLL);
  v117 = v116;
  if (v383)
  {
    if (!v116)
      goto LABEL_289;
  }
  bzero(v116, v106);
  *(_QWORD *)((*a1)[7] + 48) = v117;
  v118 = malloc_type_malloc(v106, 0x2C8E6D5CuLL);
  v119 = v118;
  if (v383)
  {
    if (!v118)
      goto LABEL_289;
  }
  bzero(v118, v106);
  *(_QWORD *)((*a1)[7] + 56) = v119;
  if (v383 >= 1)
  {
    v120 = (*a1)[7];
    v121 = *(_DWORD **)(v120 + 48);
    v122 = *(_DWORD **)(v120 + 56);
    v123 = v383;
    do
    {
      *v121++ = 0;
      *v122++ = 0;
      --v123;
    }
    while (v123);
  }
  v124 = malloc_type_malloc(v106, 0x2C8E6D5CuLL);
  v125 = v124;
  if (v383)
  {
    if (!v124)
      goto LABEL_289;
  }
  bzero(v124, v106);
  *(_QWORD *)((*a1)[7] + 64) = v125;
  v126 = malloc_type_malloc(v106, 0x2C8E6D5CuLL);
  v127 = v126;
  if (v383)
  {
    if (!v126)
      goto LABEL_289;
  }
  bzero(v126, v106);
  *(_QWORD *)((*a1)[7] + 72) = v127;
  v128 = malloc_type_malloc(v106, 0x2C8E6D5CuLL);
  v129 = v128;
  if (v383)
  {
    if (!v128)
      goto LABEL_289;
  }
  bzero(v128, v106);
  *(_QWORD *)((*a1)[7] + 80) = v129;
  v130 = malloc_type_malloc(v106, 0x2C8E6D5CuLL);
  v131 = v130;
  if (v383)
  {
    if (!v130)
      goto LABEL_289;
  }
  bzero(v130, v106);
  *(_QWORD *)((*a1)[7] + 112) = v131;
  v132 = malloc_type_malloc(8 * v383, 0x2C8E6D5CuLL);
  v133 = v132;
  if (v383)
  {
    if (!v132)
      goto LABEL_289;
  }
  v371 = v111;
  sizea = 4 * v383;
  bzero(v132, 8 * v383);
  *(_QWORD *)((*a1)[7] + 88) = v133;
  *(_QWORD *)((*a1)[7] + 96) = *(_QWORD *)((*a1)[7] + 88);
  *(_QWORD *)((*a1)[7] + 104) = *(_QWORD *)((*a1)[7] + 88) + sizea;
  v134 = malloc_type_malloc(0x18uLL, 0x2C8E6D5CuLL);
  if (!v134)
    goto LABEL_289;
  v382 = 8 * v111;
  *v134 = 0;
  v134[1] = 0;
  v134[2] = 0;
  (*a1)[8] = (uint64_t)v134;
  v135 = malloc_type_malloc(4 * a31, 0x2C8E6D5CuLL);
  v136 = v135;
  if (a31)
  {
    if (!v135)
      goto LABEL_289;
  }
  bzero(v135, 4 * a31);
  *(_QWORD *)(*a1)[8] = v136;
  lmsfilt_v4::initLmsFilter(a28, a29, a30, **a1, (float ***)*a1 + 11, a31);
  (*a1)[2] = (*a1)[11];
  (*a1)[4] = (*a1)[11];
  lmsfilt_v4::initLmsFilter(a28, a29, a30, **a1, (float ***)*a1 + 12, a31);
  (*a1)[3] = (*a1)[12];
  v137 = *a1;
  *(_QWORD *)((*a1)[3] + 56) = 0x100000001;
  v138 = *v137;
  v139 = *(int *)(*v137 + 144);
  v140 = *(int *)(*v137 + 40);
  v141 = *(int *)(*v137 + 44);
  v142 = *(int *)(*v137 + 156);
  v369 = *(_DWORD *)(*v137 + 36);
  v143 = *(_DWORD *)(*v137 + 16);
  v144 = *(int *)(*v137 + 128);
  v145 = (char *)malloc_type_malloc(0x280uLL, 0x2C8E6D5CuLL);
  if (!v145)
    goto LABEL_289;
  v146 = v145;
  bzero(v145 + 1, 0x27FuLL);
  v137[6] = (uint64_t)v146;
  *v146 = 1;
  *((_DWORD *)v146 + 1) = 813694978;
  v147 = 4 * v144;
  v148 = malloc_type_malloc(4 * v144, 0x2C8E6D5CuLL);
  v149 = v144;
  v150 = v148;
  v375 = v149;
  if (v149)
  {
    if (!v148)
      goto LABEL_289;
  }
  bzero(v148, v147);
  *(_QWORD *)(v137[6] + 8) = v150;
  v151 = v137[6];
  *(_OWORD *)(v151 + 16) = xmmword_1B66A1280;
  *(int32x2_t *)(v151 + 32) = vdup_n_s32(0x30800002u);
  *(_DWORD *)(v151 + 40) = 813694978;
  v152 = malloc_type_malloc(4 * v140, 0x2C8E6D5CuLL);
  v153 = v152;
  if ((_DWORD)v140)
  {
    if (!v152)
      goto LABEL_289;
  }
  bzero(v152, 4 * v140);
  *(_QWORD *)(v137[6] + 48) = v153;
  v154 = malloc_type_malloc(4 * v139, 0x2C8E6D5CuLL);
  v155 = v154;
  if ((_DWORD)v139)
  {
    if (!v154)
      goto LABEL_289;
  }
  bzero(v154, 4 * v139);
  *(_QWORD *)(v137[6] + 56) = v155;
  v156 = malloc_type_malloc(4 * v140, 0x2C8E6D5CuLL);
  v157 = v156;
  if ((_DWORD)v140)
  {
    if (!v156)
      goto LABEL_289;
  }
  bzero(v156, 4 * v140);
  *(_QWORD *)(v137[6] + 64) = v157;
  if ((v140 & 0x80000000) != 0)
    goto LABEL_289;
  v158 = malloc_type_malloc(4 * v140, 0x2C8E6D5CuLL);
  v159 = v158;
  if ((_DWORD)v140)
  {
    if (!v158)
      goto LABEL_289;
  }
  bzero(v158, 4 * v140);
  *(_QWORD *)(v137[6] + 72) = v159;
  v160 = malloc_type_malloc(4 * v140, 0x2C8E6D5CuLL);
  v161 = v160;
  if ((_DWORD)v140)
  {
    if (!v160)
      goto LABEL_289;
  }
  v370 = (float)a2;
  v162 = (float)v143 / (float)a2;
  bzero(v160, 4 * v140);
  *(_QWORD *)(v137[6] + 80) = v161;
  v163 = v137[6];
  *(int32x2_t *)(v163 + 88) = vdup_n_s32(0x30800002u);
  v164 = a2 >> 6 >= 0x177 ? 1.0 - expf(v162 / -0.65) : (float)v369 / 8000.0;
  *(float *)(v163 + 128) = v164;
  *(float *)(v163 + 132) = v162 + v162;
  *(float *)(v163 + 136) = v162 * 0.5;
  *(_QWORD *)(v163 + 148) = 0;
  *(_QWORD *)(v163 + 140) = 0;
  v165 = malloc_type_malloc(4 * (int)v140, 0x2C8E6D5CuLL);
  v166 = v165;
  if (v140 << 34)
  {
    if (!v165)
      goto LABEL_289;
  }
  bzero(v165, 4 * (int)v140);
  *(_QWORD *)(v137[6] + 112) = v166;
  v167 = malloc_type_malloc(4 * (int)v140, 0x2C8E6D5CuLL);
  v168 = v167;
  if (v140 << 34)
  {
    if (!v167)
      goto LABEL_289;
  }
  bzero(v167, 4 * (int)v140);
  *(_QWORD *)(v137[6] + 96) = v168;
  if ((_DWORD)v140)
  {
    v169 = v137[6];
    v170 = *(_DWORD **)(v169 + 112);
    v171 = *(_DWORD **)(v169 + 96);
    v172 = v140;
    do
    {
      *v170++ = 813130719;
      *v171++ = 813130719;
      --v172;
    }
    while (v172);
  }
  v173 = malloc_type_malloc(4 * v142, 0x2C8E6D5CuLL);
  v174 = v173;
  if ((_DWORD)v142)
  {
    if (!v173)
      goto LABEL_289;
  }
  bzero(v173, 4 * v142);
  *(_QWORD *)(v137[6] + 120) = v174;
  v387[0] = 0.0;
  vDSP_vfill(v387, *(float **)(v137[6] + 120), 1, v142);
  v175 = malloc_type_malloc(4 * v142, 0x2C8E6D5CuLL);
  v176 = v175;
  if ((_DWORD)v142)
  {
    if (!v175)
      goto LABEL_289;
  }
  bzero(v175, 4 * v142);
  *(_QWORD *)(v137[6] + 104) = v176;
  v177 = malloc_type_malloc(4 * v142, 0x2C8E6D5CuLL);
  v178 = v177;
  if ((_DWORD)v142)
  {
    if (!v177)
      goto LABEL_289;
  }
  bzero(v177, 4 * v142);
  *(_QWORD *)(v137[6] + 632) = v178;
  v179 = expf(-2.4 / (float)*(int *)(v138 + 44));
  v180 = *(float **)(v137[6] + 104);
  if ((int)v142 >= 1)
  {
    for (i = 0; i < v142; i += v141)
      v180[i] = 0.7;
  }
  v387[0] = 0.0;
  if (v375 < 1)
  {
    v184 = 0.0;
  }
  else
  {
    v182 = 0;
    v183 = v180 + 1;
    v184 = 0.0;
    do
    {
      v184 = v184 + v180[v182 * v141];
      v387[0] = v184;
      if ((int)v141 >= 2)
      {
        v185 = v183;
        v186 = v141 - 1;
        do
        {
          v187 = v179 * *(v185 - 1);
          *v185++ = v187;
          v184 = v187 + v387[0];
          v387[0] = v184;
          --v186;
        }
        while (v186);
      }
      ++v182;
      v183 += v141;
    }
    while (v182 != v375);
  }
  __B = 1.0 / v184;
  vDSP_vsmul(v180, 1, &__B, v180, 1, v142);
  *(_QWORD *)(v137[6] + 160) = 0;
  *(_QWORD *)(v137[6] + 168) = 0;
  *(_QWORD *)(v137[6] + 176) = 0;
  *(_QWORD *)(v137[6] + 184) = 0;
  *(_QWORD *)(v137[6] + 192) = 0;
  *(_QWORD *)(v137[6] + 200) = 0;
  *(_QWORD *)(v137[6] + 208) = 0;
  v188 = v137[6];
  *(int32x2_t *)(v188 + 216) = vdup_n_s32(0x30800002u);
  *(_DWORD *)(v188 + 224) = 0;
  *(_OWORD *)(v188 + 228) = xmmword_1B66A1290;
  *(_QWORD *)&v189 = 0x100000001;
  *((_QWORD *)&v189 + 1) = 0x100000001;
  *(_OWORD *)(v188 + 244) = v189;
  *(_QWORD *)(v188 + 296) = 0;
  *(_QWORD *)(v188 + 268) = 0;
  *(_QWORD *)(v188 + 276) = 0;
  *(_QWORD *)(v188 + 260) = 0;
  *(_QWORD *)(v137[6] + 304) = 0;
  *(_QWORD *)(v137[6] + 284) = 0x3080000230800002;
  v190 = malloc_type_malloc(4 * v140, 0x2C8E6D5CuLL);
  v191 = v190;
  if ((_DWORD)v140)
  {
    if (!v190)
      goto LABEL_289;
  }
  bzero(v190, 4 * v140);
  *(_QWORD *)(v137[6] + 296) = v191;
  v192 = malloc_type_malloc(4 * v140, 0x2C8E6D5CuLL);
  v193 = v192;
  if ((_DWORD)v140)
  {
    if (!v192)
      goto LABEL_289;
  }
  bzero(v192, 4 * v140);
  *(_QWORD *)(v137[6] + 304) = v193;
  v194 = v137[6];
  if ((_DWORD)v140)
  {
    v195 = *(_DWORD **)(v194 + 296);
    v196 = *(_DWORD **)(v194 + 304);
    v197 = v140;
    do
    {
      *v195++ = 0;
      *v196++ = 0;
      --v197;
    }
    while (v197);
  }
  v198 = floorf(a9 / *(float *)(v138 + 24));
  if (v198 <= 1.0)
    v198 = 1.0;
  v199 = v198;
  *(_DWORD *)(v194 + 236) = v198;
  v200 = 2 * *(_DWORD *)(v138 + 44);
  if (v200 > v198)
  {
    v199 = v200 | 1;
    *(_DWORD *)(v194 + 236) = v200 | 1;
  }
  v201 = 8 * v383;
  if (v199 < 5)
  {
    v199 = 5;
LABEL_137:
    *(_DWORD *)(v194 + 236) = v199;
    goto LABEL_138;
  }
  if (v199 >= 0x51)
  {
    v199 = 80;
    goto LABEL_137;
  }
LABEL_138:
  v202 = 4 * v199;
  v203 = malloc_type_malloc(v202, 0x2C8E6D5CuLL);
  if (!v203)
    goto LABEL_289;
  v204 = v203;
  bzero(v203, v202);
  *(_QWORD *)(v137[6] + 192) = v204;
  v205 = malloc_type_malloc(v202, 0x2C8E6D5CuLL);
  if (!v205)
    goto LABEL_289;
  v206 = v205;
  bzero(v205, v202);
  *(_QWORD *)(v137[6] + 200) = v206;
  v207 = malloc_type_malloc(v202, 0x2C8E6D5CuLL);
  if (!v207)
    goto LABEL_289;
  v208 = v207;
  bzero(v207, v202);
  *(_QWORD *)(v137[6] + 208) = v208;
  v209 = (4 * *(_DWORD *)(v137[6] + 236));
  v210 = malloc_type_malloc(v209, 0x2C8E6D5CuLL);
  v211 = v210;
  if ((_DWORD)v209)
  {
    if (!v210)
      goto LABEL_289;
  }
  bzero(v210, v209);
  *(_QWORD *)(v137[6] + 160) = v211;
  v212 = malloc_type_malloc(v209, 0x2C8E6D5CuLL);
  v213 = v212;
  if ((_DWORD)v209)
  {
    if (!v212)
      goto LABEL_289;
  }
  v376 = v162;
  bzero(v212, v209);
  *(_QWORD *)(v137[6] + 168) = v213;
  v214 = malloc_type_malloc(v209, 0x2C8E6D5CuLL);
  v215 = v214;
  if ((_DWORD)v209)
  {
    if (!v214)
      goto LABEL_289;
  }
  bzero(v214, v209);
  *(_QWORD *)(v137[6] + 176) = v215;
  v216.i32[0] = *(_DWORD *)(v138 + 24);
  v217 = (uint32x2_t *)v137[6];
  v218 = vrndm_f32(vdiv_f32((float32x2_t)__PAIR64__(LODWORD(a11), LODWORD(a10)), (float32x2_t)vdup_lane_s32(v216, 0)));
  __asm { FMOV            V10.2S, #1.0 }
  v223 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcge_f32(_D10, v218), (int8x8_t)_D10, (int8x8_t)v218));
  v224 = floorf(a12 / *(float *)v216.i32);
  if (v224 <= 1.0)
    v224 = 1.0;
  v225 = v224;
  v226 = floorf(a19 / *(float *)v216.i32);
  if (v226 <= 1.0)
    v226 = 1.0;
  v227 = v226;
  v228 = floorf(a13 / *(float *)v216.i32);
  if (v228 <= 1.0)
    v228 = 1.0;
  v229 = v228;
  if (v200 > v228)
  {
    v229 = v200;
    if (a13 > a9)
      v229 = v200 + 2;
  }
  v230 = v217[29].u32[1];
  v217[30] = vmin_u32((uint32x2_t)vdup_n_s32(v230), v223);
  if (v230 < v225)
    v225 = v230;
  if (v230 < v227)
    v227 = v230;
  v217[32].i32[0] = v227;
  v231 = v229 >= v230 + 1 ? v230 + 1 : v229;
  v217[31].i32[0] = v225;
  v217[31].i32[1] = v231;
  v232 = v231 <= v230 ? v230 : v231;
  v233 = 4 * v232;
  v234 = malloc_type_malloc(v233, 0x2C8E6D5CuLL);
  if (!v234 && (_DWORD)v233 != 0)
    goto LABEL_289;
  v236 = v234;
  bzero(v234, v233);
  *(_QWORD *)(v137[6] + 184) = v236;
  v237 = v137[6];
  v238 = *(unsigned int *)(v237 + 236);
  if ((_DWORD)v238)
  {
    v239 = *(_DWORD **)(v237 + 184);
    v240 = *(_DWORD **)(v237 + 192);
    v241 = *(unsigned int *)(v237 + 236);
    v242 = *(_DWORD **)(v237 + 200);
    v243 = *(_DWORD **)(v237 + 208);
    do
    {
      *v239++ = 1;
      *v240++ = 1;
      *v242++ = 1;
      *v243++ = 1;
      --v241;
    }
    while (v241);
  }
  v244 = *(_DWORD *)(v237 + 252);
  if (v238 < v244)
    memset_pattern16((void *)(*(_QWORD *)(v237 + 184) + 4 * v238), &unk_1B66A2BB0, 4 * (v244 + ~(_DWORD)v238) + 4);
  v245 = __exp10f(a14 / 10.0);
  v246 = v137[6];
  *(float *)(v246 + 260) = v245;
  *(float *)(v246 + 264) = a15;
  *(float *)(v246 + 268) = a16;
  *(_DWORD *)(v246 + 272) = a17;
  v247 = __exp10f(a18 / 10.0);
  v248 = v137[6];
  *(float *)(v248 + 276) = v247;
  *(_QWORD *)(v248 + 320) = 0;
  *(_QWORD *)(v248 + 372) = 0;
  *(_OWORD *)(v248 + 336) = 0u;
  *(_OWORD *)(v248 + 352) = 0u;
  v249 = *(int *)(v138 + 128);
  v250 = malloc_type_malloc(4 * v249, 0x2C8E6D5CuLL);
  v251 = v250;
  if ((_DWORD)v249)
  {
    if (!v250)
      goto LABEL_289;
  }
  bzero(v250, 4 * v249);
  *(_QWORD *)(v137[6] + 328) = v251;
  v253 = v137[6];
  *(_QWORD *)(v253 + 380) = 0;
  *(_DWORD *)(v253 + 388) = 1022739087;
  *(_QWORD *)(v253 + 312) = 0;
  if (!*(_DWORD *)(v138 + 100))
  {
    v254 = *(int *)(v138 + 128);
    v255 = malloc_type_malloc(4 * v254, 0x2C8E6D5CuLL);
    v256 = v255;
    if ((_DWORD)v254 && !v255)
      goto LABEL_289;
    bzero(v255, 4 * v254);
    *(_QWORD *)(v137[6] + 312) = v256;
    v258 = v137[6];
    *(_DWORD *)(v258 + 320) = 0;
    *(_DWORD *)(v258 + 336) = a22;
    *(_DWORD *)(v258 + 340) = a23;
    *(_DWORD *)(v258 + 344) = a20;
    v259 = *(_DWORD *)(v138 + 44);
    *(_DWORD *)(v258 + 348) = a21;
    if ((float)(*(float *)(v138 + 24) * (float)v259) >= 0xC9)
    {
      *(_QWORD *)(v258 + 336) = 0x3E570A3D3F0CCCCDLL;
      *(_DWORD *)(v258 + 348) = 1048576000;
    }
    v260 = *(_DWORD *)(v138 + 80);
    *(float *)v257.i32 = v370 / (float)(2 * v260);
    if (a2 > 0xF9F)
    {
      v263 = vcvt_s32_f32(vrndm_f32(vdiv_f32((float32x2_t)0x44E1000043960000, (float32x2_t)vdup_lane_s32(v257, 0))));
      v262 = 1800;
      v261 = 300;
    }
    else
    {
      v261 = (int)*(float *)v257.i32;
      v262 = (int)-(*(float *)v257.i32 - v370 * 0.5);
      v263.i32[0] = 1;
      v263.i32[1] = v260 - 1;
    }
    *(_DWORD *)(v258 + 360) = v261;
    *(_DWORD *)(v258 + 364) = v262;
    *(int32x2_t *)(v258 + 352) = v263;
    *(float *)(v258 + 368) = a24 / 1000.0;
    *(float *)(v258 + 372) = expf((float)-v376 / (float)(a24 / 1000.0));
    *(_DWORD *)(v258 + 380) = 0;
    *(_DWORD *)(v258 + 384) = v259;
    *(_DWORD *)(v258 + 388) = a25;
    v201 = 8 * v383;
  }
  v264 = v137[6];
  __asm { FMOV            V2.4S, #1.0 }
  *(_OWORD *)(v264 + 392) = _Q2;
  *(float32x2_t *)(v264 + 408) = _D10;
  *(_DWORD *)(v264 + 416) = 1065353216;
  *(_QWORD *)(v264 + 448) = 0;
  *(_QWORD *)(v137[6] + 456) = 0;
  *(_QWORD *)(v137[6] + 464) = 0;
  *(_QWORD *)(v137[6] + 472) = 0;
  *(_QWORD *)(v137[6] + 496) = 0;
  *(_QWORD *)(v137[6] + 504) = 0;
  *(_QWORD *)(v137[6] + 480) = 0;
  *(_QWORD *)(v137[6] + 488) = 0;
  v266 = (int32x2_t *)v137[6];
  v266[53] = 0;
  v266[54] = 0;
  v266[55] = 0;
  v266[49].i32[0] = a26;
  v266[49].i32[1] = a27;
  if (a2 >> 3 >= 0x55F)
    v267 = 256;
  else
    v267 = 160;
  if (a2 >> 7 <= 0x7C)
    v268 = v267;
  else
    v268 = 320;
  if (a2 >> 4 <= 0x55E)
    v269 = v268;
  else
    v269 = 512;
  if (v269 <= *(_DWORD *)(v138 + 16))
    v269 = *(_DWORD *)(v138 + 16);
  v266[53].i32[0] = v269;
  v266[53].i32[1] = 2 * v269;
  v266[55].i32[0] = v269 + 1;
  *(float *)v252.i32 = v370 / (float)(2 * v269);
  v270 = vmin_s32(vadd_s32(vmax_s32(vcvt_s32_f32(vrndm_f32(vdiv_f32(vcvt_f32_s32(v266[45]), (float32x2_t)vdup_lane_s32(v252, 0)))), (int32x2_t)0x100000001), (int32x2_t)-1), vdup_n_s32((int)(float)((float)((float)(2 * v269) * 0.5) + -1.0)));
  v266[54] = v270;
  v266[55].i32[1] = v270.i32[1] + 1;
  v271 = 4 * (v270.i32[1] + 1);
  v272 = malloc_type_malloc(v271, 0x2C8E6D5CuLL);
  if (!v272 && v271 != 0)
    goto LABEL_289;
  v274 = v272;
  bzero(v272, v271);
  *(_QWORD *)(v137[6] + 496) = v274;
  v275 = malloc_type_malloc(v271, 0x2C8E6D5CuLL);
  if (v271 && v275 == 0)
    goto LABEL_289;
  v277 = v275;
  bzero(v275, v271);
  *(_QWORD *)(v137[6] + 504) = v277;
  v278 = malloc_type_malloc(v271, 0x2C8E6D5CuLL);
  if (v271 && v278 == 0)
    goto LABEL_289;
  v280 = v278;
  bzero(v278, v271);
  *(_QWORD *)(v137[6] + 480) = v280;
  v281 = malloc_type_malloc(v271, 0x2C8E6D5CuLL);
  if (v271 && v281 == 0)
    goto LABEL_289;
  v283 = v281;
  bzero(v281, v271);
  *(_QWORD *)(v137[6] + 488) = v283;
  v284 = 4 * *(_DWORD *)(v137[6] + 440);
  v285 = malloc_type_malloc(v284, 0x2C8E6D5CuLL);
  v286 = v285;
  if (v284)
  {
    if (!v285)
      goto LABEL_289;
  }
  bzero(v285, v284);
  *(_QWORD *)(v137[6] + 448) = v286;
  v287 = malloc_type_malloc(v284, 0x2C8E6D5CuLL);
  v288 = v287;
  if (v284)
  {
    if (!v287)
      goto LABEL_289;
  }
  bzero(v287, v284);
  *(_QWORD *)(v137[6] + 456) = v288;
  v289 = malloc_type_malloc(v284, 0x2C8E6D5CuLL);
  v290 = v289;
  if (v284)
  {
    if (!v289)
      goto LABEL_289;
  }
  bzero(v289, v284);
  *(_QWORD *)(v137[6] + 464) = v290;
  v291 = malloc_type_malloc(v284, 0x2C8E6D5CuLL);
  v292 = v291;
  if (v284)
  {
    if (!v291)
      goto LABEL_289;
  }
  bzero(v291, v284);
  *(_QWORD *)(v137[6] + 472) = v292;
  v293 = expf(v376 / -0.03);
  v294 = v137[6];
  *(float *)(v294 + 412) = v293;
  *(float *)(v294 + 416) = v293;
  *(float *)(v294 + 420) = 1.0 - expf(v376 * -2.0);
  *(_DWORD *)(v294 + 512) = 813694978;
  *(_DWORD *)(v294 + 548) = 0;
  *(_OWORD *)(v294 + 516) = 0u;
  *(_OWORD *)(v294 + 532) = 0u;
  *(_OWORD *)(v294 + 552) = xmmword_1B66A12A0;
  *(_QWORD *)(v294 + 568) = 0x3CCCCCCD00000000;
  *(_OWORD *)(v294 + 576) = xmmword_1B66A1290;
  *(_QWORD *)(v294 + 592) = 0;
  *(_QWORD *)(v294 + 600) = 0xC1A0000000000000;
  *(_OWORD *)(v294 + 608) = 0u;
  *(_DWORD *)(v294 + 624) = 0;
  *(_QWORD *)((*a1)[7] + 120) = 0;
  *(_QWORD *)((*a1)[7] + 128) = 0;
  *(_QWORD *)((*a1)[7] + 136) = 0;
  *(_QWORD *)((*a1)[7] + 144) = 0;
  *(_QWORD *)((*a1)[7] + 152) = 0;
  *(_QWORD *)((*a1)[7] + 160) = 0;
  *(_QWORD *)((*a1)[7] + 168) = 0;
  *(_QWORD *)((*a1)[7] + 176) = 0;
  *(_QWORD *)((*a1)[7] + 184) = 0;
  *(_QWORD *)((*a1)[7] + 192) = 0;
  *(_QWORD *)((*a1)[7] + 200) = 0;
  *(_QWORD *)((*a1)[7] + 208) = 0;
  *(_QWORD *)((*a1)[7] + 216) = 0;
  *(_QWORD *)((*a1)[7] + 224) = 0;
  *(_QWORD *)((*a1)[7] + 232) = 0;
  (*a1)[9] = 0;
  v295 = 4 * v383;
  v296 = malloc_type_malloc(sizea, 0x2C8E6D5CuLL);
  v297 = v296;
  if (v383)
  {
    if (!v296)
      goto LABEL_289;
  }
  bzero(v296, sizea);
  *(_QWORD *)((*a1)[7] + 240) = v297;
  v298 = malloc_type_malloc(sizea, 0x2C8E6D5CuLL);
  v299 = v298;
  if (v383)
  {
    if (!v298)
      goto LABEL_289;
  }
  bzero(v298, sizea);
  *(_QWORD *)((*a1)[7] + 248) = v299;
  v300 = malloc_type_malloc(v382, 0x2C8E6D5CuLL);
  v301 = v300;
  if ((_DWORD)v371)
  {
    if (!v300)
      goto LABEL_289;
  }
  bzero(v300, v382);
  *(_QWORD *)((*a1)[7] + 256) = v301;
  *(_QWORD *)((*a1)[7] + 264) = *(_QWORD *)((*a1)[7] + 256) + 4 * v371;
  v302 = malloc_type_malloc(v201, 0x2C8E6D5CuLL);
  v303 = v302;
  if (v383)
  {
    if (!v302)
      goto LABEL_289;
  }
  bzero(v302, v201);
  *(_QWORD *)((*a1)[7] + 272) = v303;
  *(_QWORD *)((*a1)[7] + 280) = *(_QWORD *)((*a1)[7] + 272) + 4 * v383;
  v304 = *a1;
  v305 = (int *)**a1;
  if (!v305[25])
  {
    v306 = v305[20];
    v307 = v305[33];
    v308 = 4 * v306;
    v309 = malloc_type_malloc(4 * v306, 0x2C8E6D5CuLL);
    v310 = v309;
    if ((_DWORD)v306 && !v309)
      goto LABEL_289;
    bzero(v309, 4 * v306);
    *(_QWORD *)((*a1)[7] + 120) = v310;
    v311 = malloc_type_malloc(4 * v306, 0x2C8E6D5CuLL);
    v312 = v311;
    if ((_DWORD)v306)
    {
      if (!v311)
        goto LABEL_289;
    }
    bzero(v311, 4 * v306);
    *(_QWORD *)((*a1)[7] + 128) = v312;
    v313 = malloc_type_malloc(4 * v306, 0x2C8E6D5CuLL);
    v314 = v313;
    if ((_DWORD)v306)
    {
      if (!v313)
        goto LABEL_289;
    }
    bzero(v313, 4 * v306);
    *(_QWORD *)((*a1)[7] + 136) = v314;
    v315 = malloc_type_malloc(4 * v306, 0x2C8E6D5CuLL);
    v316 = v315;
    if ((_DWORD)v306)
    {
      if (!v315)
        goto LABEL_289;
    }
    bzero(v315, 4 * v306);
    *(_QWORD *)((*a1)[7] + 176) = v316;
    v317 = malloc_type_malloc(4 * v306, 0x2C8E6D5CuLL);
    v318 = v317;
    if ((_DWORD)v306)
    {
      if (!v317)
        goto LABEL_289;
    }
    bzero(v317, 4 * v306);
    *(_QWORD *)((*a1)[7] + 184) = v318;
    v319 = malloc_type_malloc(8 * v306, 0x2C8E6D5CuLL);
    v320 = v319;
    if ((_DWORD)v306)
    {
      if (!v319)
        goto LABEL_289;
    }
    bzero(v319, 8 * v306);
    *(_QWORD *)((*a1)[7] + 192) = v320;
    *(_QWORD *)((*a1)[7] + 200) = *(_QWORD *)((*a1)[7] + 192) + 4 * v306;
    v321 = malloc_type_malloc(4 * v306, 0x2C8E6D5CuLL);
    v322 = v321;
    if ((_DWORD)v306)
    {
      if (!v321)
        goto LABEL_289;
    }
    bzero(v321, 4 * v306);
    *(_QWORD *)((*a1)[7] + 216) = v322;
    v323 = malloc_type_malloc(8 * v307, 0x2C8E6D5CuLL);
    v324 = v323;
    if ((_DWORD)v307)
    {
      if (!v323)
        goto LABEL_289;
    }
    bzero(v323, 8 * v307);
    *(_QWORD *)((*a1)[7] + 208) = v324;
    v325 = malloc_type_malloc(v308 * v307, 0x2C8E6D5CuLL);
    v326 = v325;
    if (v308 * v307)
    {
      if (!v325)
        goto LABEL_289;
    }
    bzero(v325, v308 * v307);
    **(_QWORD **)((*a1)[7] + 208) = v326;
    if ((int)v307 >= 2)
    {
      v327 = 0;
      do
      {
        v328 = (_QWORD *)(*(_QWORD *)((*a1)[7] + 208) + v327);
        v328[1] = *v328 + 4 * v306;
        v327 += 8;
      }
      while (8 * (v307 - 1) != v327);
    }
    v329 = malloc_type_malloc(16 * v307, 0x2C8E6D5CuLL);
    v330 = v329;
    if ((_DWORD)v307)
    {
      if (!v329)
        goto LABEL_289;
    }
    bzero(v329, 16 * v307);
    *(_QWORD *)((*a1)[7] + 224) = v330;
    v331 = 2 * v308 * v307;
    v332 = malloc_type_malloc(v331, 0x2C8E6D5CuLL);
    v333 = v332;
    if (v331)
    {
      if (!v332)
        goto LABEL_289;
    }
    bzero(v332, v331);
    **(_QWORD **)((*a1)[7] + 224) = v333;
    v334 = *(_QWORD **)((*a1)[7] + 224);
    v334[1] = *v334 + 4 * v306;
    if ((int)v307 >= 2)
    {
      v335 = 0;
      do
      {
        v336 = (_QWORD *)(*(_QWORD *)((*a1)[7] + 224) + v335);
        v336[2] = *v336 + 8 * v306;
        v337 = *(_QWORD *)((*a1)[7] + 224) + v335;
        *(_QWORD *)(v337 + 24) = *(_QWORD *)(v337 + 8) + 8 * v306;
        v335 += 16;
      }
      while (16 * (v307 - 1) != v335);
    }
    v338 = malloc_type_malloc(8 * v306, 0x2C8E6D5CuLL);
    v339 = v338;
    v295 = 4 * v383;
    if ((_DWORD)v306)
    {
      if (!v338)
        goto LABEL_289;
    }
    bzero(v338, 8 * v306);
    *(_QWORD *)((*a1)[7] + 144) = v339;
    *(_QWORD *)((*a1)[7] + 152) = *(_QWORD *)((*a1)[7] + 144) + 4 * v306;
    v340 = malloc_type_malloc(8 * v306, 0x2C8E6D5CuLL);
    v341 = v340;
    if ((_DWORD)v306)
    {
      if (!v340)
        goto LABEL_289;
    }
    bzero(v340, 8 * v306);
    *(_QWORD *)((*a1)[7] + 160) = v341;
    *(_QWORD *)((*a1)[7] + 168) = *(_QWORD *)((*a1)[7] + 160) + 4 * v306;
    v342 = malloc_type_malloc(4 * v306, 0x2C8E6D5CuLL);
    v343 = v342;
    if ((_DWORD)v306)
    {
      if (!v342)
        goto LABEL_289;
    }
    bzero(v342, 4 * v306);
    *(_QWORD *)((*a1)[7] + 232) = v343;
    vDSP_hann_window(*(float **)((*a1)[7] + 232), v306, 0);
    dft_v4::paramInit_v4(*a1 + 9, v306, v306, 2, a2, v368, v379, v374, a34, 0, a31, a32, a33);
    v304 = *a1;
  }
  *(_QWORD *)(v304[7] + 304) = 0;
  *(_QWORD *)((*a1)[7] + 312) = 0;
  *(_QWORD *)((*a1)[7] + 320) = 0;
  *(_QWORD *)((*a1)[7] + 328) = 0;
  *(_QWORD *)((*a1)[7] + 336) = 0;
  *(_QWORD *)((*a1)[7] + 344) = 0;
  *(_QWORD *)((*a1)[7] + 352) = 0;
  *(_QWORD *)((*a1)[7] + 360) = 0;
  *(_QWORD *)((*a1)[7] + 368) = 0;
  v344 = (*a1)[6];
  v345 = *(int *)(v344 + 428);
  v346 = (int)v345 >= 0 ? *(_DWORD *)(v344 + 428) : v345 + 1;
  v347 = *(int *)(v344 + 424);
  v348 = malloc_type_malloc(4 * v345, 0x2C8E6D5CuLL);
  v349 = v348;
  if ((_DWORD)v345)
  {
    if (!v348)
      goto LABEL_289;
  }
  v350 = v346 >> 1;
  bzero(v348, 4 * v345);
  *(_QWORD *)((*a1)[7] + 304) = v349;
  *(_QWORD *)((*a1)[7] + 312) = *(_QWORD *)((*a1)[7] + 304) + 4 * v350;
  v351 = malloc_type_malloc(4 * v345, 0x2C8E6D5CuLL);
  v352 = v351;
  if ((_DWORD)v345)
  {
    if (!v351)
      goto LABEL_289;
  }
  bzero(v351, 4 * v345);
  *(_QWORD *)((*a1)[7] + 320) = v352;
  *(_QWORD *)((*a1)[7] + 328) = *(_QWORD *)((*a1)[7] + 320) + 4 * v350;
  v353 = malloc_type_malloc(4 * v345, 0x2C8E6D5CuLL);
  v354 = v353;
  if ((_DWORD)v345)
  {
    if (!v353)
      goto LABEL_289;
  }
  bzero(v353, 4 * v345);
  *(_QWORD *)((*a1)[7] + 336) = v354;
  *(_QWORD *)((*a1)[7] + 344) = *(_QWORD *)((*a1)[7] + 336) + 4 * v350;
  v355 = malloc_type_malloc(4 * v347, 0x2C8E6D5CuLL);
  v356 = v355;
  if ((_DWORD)v347)
  {
    if (!v355)
      goto LABEL_289;
  }
  bzero(v355, 4 * v347);
  *(_QWORD *)((*a1)[7] + 352) = v356;
  v357 = malloc_type_malloc(4 * v347, 0x2C8E6D5CuLL);
  v358 = v357;
  if ((_DWORD)v347)
  {
    if (!v357)
      goto LABEL_289;
  }
  bzero(v357, 4 * v347);
  *(_QWORD *)((*a1)[7] + 360) = v358;
  v359 = malloc_type_malloc(4 * v347, 0x2C8E6D5CuLL);
  v360 = v359;
  if ((_DWORD)v347)
  {
    if (!v359)
      goto LABEL_289;
  }
  bzero(v359, 4 * v347);
  *(_QWORD *)((*a1)[7] + 368) = v360;
  dft_v4::paramInit_v4(*a1 + 10, v350, v350, 2, a2, 0, v379, v374, a34, 0, a31, a32, a33);
  (*a1)[13] = 0;
  (*a1)[14] = 0;
  v361 = **a1;
  if (*(int *)(v361 + 104) < 1)
    return;
  lmsfilt_v4::initLmsFilter(a28, a29, a30, v361, (float ***)*a1 + 13, a31);
  (*a1)[4] = (*a1)[13];
  lmsfilt_v4::initLmsFilter(a28, a29, a30, **a1, (float ***)*a1 + 14, a31);
  (*a1)[5] = (*a1)[14];
  v362 = malloc_type_malloc(v295, 0x2C8E6D5CuLL);
  v363 = v362;
  if (v383)
  {
    if (!v362)
      goto LABEL_289;
  }
  bzero(v362, v295);
  *(_QWORD *)((*a1)[7] + 288) = v363;
  v364 = malloc_type_malloc(v295, 0x2C8E6D5CuLL);
  v365 = v364;
  if (v383)
  {
    if (!v364)
    {
LABEL_289:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v367 = std::bad_alloc::bad_alloc(exception);
    }
  }
  bzero(v364, v295);
  *(_QWORD *)((*a1)[7] + 296) = v365;
}

void aec_v4::run_aec(uint64_t *a1, _DWORD *a2, float *a3, _DWORD *a4, _DWORD *a5, lmsfilt_v5 *a6, void *a7, float *a8, _DWORD *a9, int a10, _DWORD *a11, _DWORD *a12)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  DSPComplex *v19;
  vDSP_Length v20;
  uint64_t v21;
  float *v22;
  float v23;
  float v24;
  unsigned int v25;
  float *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  unsigned __int8 *v32;
  float *v33;
  int v35;
  char *v36;
  _BYTE *v37;
  float *v38;
  char v39;
  int v40;
  _BYTE *v41;
  char *v42;
  _BYTE *v43;
  float *v44;
  char v45;
  char *v46;
  _BYTE *v47;
  float *v48;
  char v49;
  int v50;
  _BOOL4 v51;
  lmsfilt_v5 *v52;
  const BOOL *v53;
  DSPSplitComplex *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  uint64_t v59;
  vDSP_Length v60;
  const BOOL *v61;
  int *v62;
  float *v63;
  vDSP_Length v64;
  float *v65;
  char **v66;
  vDSP_Length v67;
  vDSP_Length v68;
  int v69;
  char *v70;
  char *v71;
  char *v72;
  char *v73;
  int v74;
  char *v75;
  float *v76;
  float *v77;
  float *v78;
  int v79;
  float *v80;
  uint64_t v81;
  float *v82;
  float v83;
  MultiRadixRealFFT *v84;
  float v85;
  uint64_t v86;
  int v87;
  vDSP_Length v88;
  float v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  char **v93;
  uint64_t v94;
  int v95;
  int v96;
  int v97;
  float v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  float v102;
  int v103;
  uint64_t v104;
  float v105;
  int v106;
  uint64_t v107;
  unsigned int v108;
  size_t v109;
  lmsfilt_v5 *v110;
  vDSP_Length v111;
  uint64_t v112;
  uint64_t v113;
  vDSP_Length v114;
  unsigned int v115;
  void *v116;
  const BOOL *v117;
  char *v118;
  float *v119;
  DSPComplex *v120;
  const float *v121;
  char *v122;
  size_t v123;
  char *v124;
  float *v125;
  int v126;
  vDSP_Length v127;
  int v128;
  uint64_t v129;
  float v130;
  DSPSplitComplex *v131;
  vDSP_Length v132;
  uint64_t v133;
  vDSP_Length v134;
  int v135;
  const float *v136;
  int v137;
  uint64_t v138;
  float v139;
  uint64_t v140;
  int v141;
  int v142;
  float v143;
  uint64_t v144;
  int v145;
  float v146;
  float *v147;
  int v148;
  float *v149;
  float v150;
  float v151;
  float v152;
  float v153;
  float v154;
  float v155;
  DSPComplex *v156;
  const float *v157;
  vDSP_Length v158;
  DSPSplitComplex v159;
  float *v160;
  int v161;
  int v162;
  float v163;
  int v164;
  float *v165;
  int v166;
  float *v167;
  float *v168;
  float v169;
  double v170;
  float v171;
  float v172;
  float v173;
  int *v174;
  float *v175;
  int v176;
  float v177;
  int v178;
  float v179;
  uint64_t v180;
  float v181;
  float v182;
  float v183;
  int v184;
  int v185;
  float v186;
  int v187;
  int v188;
  int v189;
  float v190;
  float v191;
  int v192;
  int v193;
  const float *v194;
  vDSP_Length v195;
  _DWORD *v196;
  uint64_t v197;
  uint64_t v198;
  unint64_t v199;
  uint64_t v200;
  int v201;
  float v202;
  uint64_t v203;
  float v204;
  int v205;
  float v206;
  float v207;
  float v208;
  void *v209;
  float *v210;
  uint64_t v211;
  int v212;
  DSPComplex *v213;
  unsigned int v214;
  int v215;
  unsigned int v216;
  float v217;
  float v218;
  float v219;
  float v220;
  float v221;
  uint64_t v222;
  float v223;
  unsigned int v224;
  float v225;
  float v226;
  int v227;
  vDSP_Length v228;
  uint64_t v229;
  _DWORD *v230;
  _DWORD *v231;
  _DWORD *v232;
  int v233;
  float v234;
  float v235;
  double v236;
  float v237;
  double v238;
  double v239;
  double v240;
  float v241;
  float v242;
  float v243;
  float v244;
  float v245;
  float v246;
  float v247;
  float v248;
  int v249;
  float *v250;
  float *v251;
  _BOOL4 *v252;
  float *v253;
  _DWORD *v254;
  _DWORD *v255;
  unsigned int v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  int v260;
  unsigned int v261;
  _DWORD *v262;
  _DWORD *v263;
  _BOOL4 *v264;
  float *v265;
  float *v266;
  float *v267;
  float v269;
  _BOOL4 v270;
  _BOOL4 v271;
  _BOOL4 *v272;
  int v273;
  int v274;
  uint64_t v275;
  int v276;
  unsigned int v277;
  BOOL v278;
  BOOL v279;
  size_t v280;
  DSPComplex *v281;
  void *v282;
  int v283;
  size_t v284;
  size_t v285;
  size_t v286;
  int *v287;
  int v288;
  int v289;
  int *v290;
  uint64_t v291;
  int v292;
  int v293;
  int v294;
  uint64_t v295;
  int v296;
  int v297;
  int v298;
  uint64_t v299;
  int v300;
  float v301;
  BOOL v302;
  BOOL v303;
  int v305;
  size_t v306;
  size_t v307;
  int v308;
  int v309;
  int v310;
  int *v311;
  uint64_t v312;
  int v313;
  vDSP_Length v314;
  uint64_t v315;
  DSPComplex *v316;
  DSPComplex *v317;
  DSPComplex *v318;
  uint64_t v319;
  int v320;
  DSPSplitComplex v321;
  vDSP_Length v322;
  float *v323;
  float *v324;
  float *imagp;
  float *realp;
  uint64_t v327;
  float *v328;
  float *v329;
  float *v330;
  float *v331;
  float *v332;
  float *v333;
  float *v334;
  float v335;
  float v336;
  vDSP_Length v337;
  int v338;
  float v339;
  float v340;
  int v341;
  vDSP_Length v342;
  const float *v343;
  float *v344;
  float *v345;
  float v346;
  float v347;
  float v348;
  float v349;
  float v350;
  float v351;
  float v352;
  float v353;
  float v354;
  float v355;
  float v357;
  float v358;
  float v359;
  int v360;
  uint64_t v361;
  uint64_t v362;
  int *v363;
  float v364;
  int v365;
  uint64_t v366;
  uint64_t v367;
  float *v368;
  uint64_t v369;
  DSPComplex *v370;
  float v371;
  float *v372;
  float *v373;
  uint64_t v374;
  float *v375;
  vDSP_Length v376;
  vDSP_Length v377;
  uint64_t v378;
  vDSP_Length v379;
  int v380;
  uint64_t v381;
  float v382;
  size_t v383;
  int v384;
  float v385;
  uint64_t j;
  float v387;
  int v388;
  float v389;
  float *v390;
  float v391;
  float v392;
  float v393;
  float v394;
  float v395;
  float v396;
  float v397;
  float v398;
  int v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  vDSP_Length v409;
  uint64_t v410;
  int v411;
  float *v412;
  float v413;
  char *v414;
  char *v415;
  float v416;
  float v417;
  size_t v418;
  float *v419;
  size_t v420;
  size_t v421;
  uint64_t v422;
  uint64_t v423;
  float v424;
  float v425;
  float v426;
  float v427;
  float *v428;
  uint64_t v429;
  int v430;
  uint64_t v431;
  uint64_t v432;
  int v433;
  vDSP_Length v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  float *v438;
  uint64_t v439;
  uint64_t i;
  BOOL v441;
  uint64_t v442;
  float *v443;
  _BOOL4 v444;
  _BOOL4 v445;
  uint64_t v446;
  DSPComplex *v447;
  DSPComplex *v448;
  DSPSplitComplex *v449;
  DSPSplitComplex *v450;
  float v451;
  vDSP_Length v452;
  float v453;
  float v454;
  int v455;
  int v456;
  signed int v457;
  unsigned int v458;
  int *v459;
  float v460;
  float *v461;
  float v462;
  uint64_t v463;
  char **v464;
  size_t v465;
  float *v466;
  uint64_t v467;
  float *v468;
  vDSP_Length v469;
  int v470;
  float v471;
  double v472;
  float v473;
  float v474;
  float v475;
  float v476;
  size_t v477;
  float v478;
  float v479;
  _BOOL4 v480;
  _BOOL4 v481;
  float v482;
  float v483;
  float v484;
  float v485;
  float v486;
  const float **v487;
  vDSP_Length v488;
  uint64_t v489;
  float *v490;
  float *v491;
  float *v492;
  float *v493;
  float v494;
  float v495;
  int v496;
  unsigned int v497;
  unsigned int v498;
  signed int v499;
  int v500;
  int v501;
  unsigned int v502;
  int v503;
  int v504;
  float *v505;
  float *v506;
  float *v507;
  float *v508;
  int *v509;
  int *v510;
  int *v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  size_t v515;
  uint64_t v516;
  uint64_t v517;
  const BOOL *v518;
  const BOOL *v519;
  const BOOL *v520;
  float *v521;
  uint64_t v524;
  int v525;
  int v526;
  void *__dst;
  _BOOL4 v528;
  lmsfilt_v4 *v529;
  lmsfilt_v4 *v530;
  lmsfilt_v4 *v531;
  float *v532;
  DSPSplitComplex *v533;
  DSPSplitComplex *v534;
  int v535;
  _DWORD *v536;
  uint64_t v538;
  float *v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v544;
  float *v545;
  DSPComplex *v546;
  DSPComplex *v547;
  float *v548;
  float *v549;
  DSPSplitComplex v550;
  uint64_t v551;
  char **v552;
  DSPComplex *v553;
  uint64_t v554;
  int v555;
  float v556;
  uint64_t v557;
  uint64_t v558;
  float *v559;
  uint64_t v560;
  int v561;
  float *__B;
  float *__Ba;
  float *__Bb;
  size_t __srca;
  uint64_t __na;
  size_t __nb;
  size_t __nc;
  int v571;
  int v572;
  uint64_t v573;
  uint64_t __len;
  float *__lena;
  float *__lenb;
  size_t __lenc;
  uint64_t v578;
  uint64_t v579;
  float v580;
  float *v581;
  float *v582;
  DSPSplitComplex v583;
  float v584;
  float *v585;
  vDSP_Length v586;
  float *v587;
  float *__D;
  float *__Da;
  float __Db;
  float *__Dc;
  int __Dd;
  vDSP_Length v593;
  float v594;
  int v595;
  vDSP_Length v596;
  vDSP_Length __N;
  int __Na;
  float __Nb;
  vDSP_Length __Nc;
  float *__Nd;
  vDSP_Length v602;
  vDSP_Length v603;
  vDSP_Length v604;
  float v605;
  vDSP_Length v606;
  unsigned int v607;
  _BOOL4 v608;
  vDSP_Length v609;
  int *v610;
  DSPComplex *__C;
  vDSP_Length __Ca;
  _BOOL4 __Cb;
  vDSP_Length __Cc;
  DSPComplex *__Cd;
  vDSP_Length v616;
  uint64_t v617;
  unsigned __int8 v618;
  DSPSplitComplex v619;
  uint64_t v620;
  float v621;
  float v622;
  DSPSplitComplex v623;
  DSPSplitComplex v624;
  DSPSplitComplex __Z;
  DSPSplitComplex __A;

  v14 = *a1;
  v15 = a1[1];
  v17 = a1[6];
  v16 = a1[7];
  v18 = a1[8];
  v578 = a1[9];
  v524 = a1[4];
  v548 = *(float **)(v16 + 8);
  v549 = *(float **)v16;
  v550 = *(DSPSplitComplex *)(v16 + 48);
  v19 = *(DSPComplex **)(v16 + 64);
  v539 = *(float **)(v16 + 72);
  v540 = a1[3];
  v552 = (char **)a1[2];
  v553 = *(DSPComplex **)(v16 + 80);
  v20 = *(int *)(*a1 + 16);
  v554 = *(int *)(*a1 + 136);
  v21 = *(unsigned int *)(*a1 + 28);
  v551 = *(int *)(*a1 + 36);
  v22 = (float *)*(unsigned int *)(*a1 + 128);
  *(_DWORD *)(v17 + 604) = 0;
  v23 = *(float *)(v17 + 568);
  v616 = v20;
  v24 = (float)(int)v20;
  v545 = (float *)(v17 + 28);
  v546 = v19;
  if (v23 < 100.0 && (float)(*(float *)(v17 + 28) / v24) > 0.00000001)
  {
    v23 = v23 + *(float *)(v14 + 20);
    *(float *)(v17 + 568) = v23;
  }
  v25 = *(_DWORD *)(v14 + 160);
  if (v25 == 2)
  {
    if ((int)v22 <= 0)
    {
      *(_DWORD *)(v15 + 152) = 0;
    }
    else
    {
      v26 = 0;
      v27 = *(_QWORD *)(v15 + 120);
      v28 = *(_QWORD *)(v15 + 144);
      do
      {
        if (*((_BYTE *)v26 + v27))
        {
          *(_DWORD *)(v28 + 4 * (_QWORD)v26) = 0;
          *((_BYTE *)v26 + *(_QWORD *)(v15 + 128)) = 1;
        }
        else
        {
          v29 = *(_DWORD *)(v28 + 4 * (_QWORD)v26);
          v30 = *(_DWORD *)(v14 + 44) - 1;
          if (v29 == v30)
            *((_BYTE *)v26 + *(_QWORD *)(v15 + 128)) = 0;
          if (v29 < v30)
            *(_DWORD *)(v28 + 4 * (_QWORD)v26) = v29 + 1;
        }
        v26 = (float *)((char *)v26 + 1);
      }
      while (v22 != v26);
      v31 = 0;
      *(_DWORD *)(v15 + 152) = 0;
      v32 = *(unsigned __int8 **)(v15 + 128);
      v33 = v22;
      do
      {
        if (*v32++)
          *(_DWORD *)(v15 + 152) = ++v31;
        v33 = (float *)((char *)v33 - 1);
      }
      while (v33);
      if (v31 >= 1)
      {
        *(_DWORD *)(v14 + 168) = 0;
LABEL_23:
        v25 = *(_DWORD *)(v14 + 160);
        goto LABEL_24;
      }
    }
    v35 = *(_DWORD *)(v14 + 168);
    if (v35 <= 1)
      *(_DWORD *)(v14 + 168) = v35 + 1;
    goto LABEL_23;
  }
LABEL_24:
  if (v25 < 2)
  {
    v41 = *(_BYTE **)(v15 + 136);
    *v41 = 1;
    v40 = (_DWORD)v22 - 1;
    if ((int)v22 > 1)
      goto LABEL_33;
  }
  else if (v25 == 2)
  {
    if ((int)v22 >= 1)
    {
      v42 = *(char **)(v15 + 128);
      v43 = *(_BYTE **)(v15 + 136);
      v44 = v22;
      do
      {
        v45 = *v42++;
        *v43++ = v45;
        v44 = (float *)((char *)v44 - 1);
      }
      while (v44);
    }
  }
  else if (v25 == 3)
  {
    if ((int)v22 >= 1)
    {
      v36 = *(char **)(v15 + 128);
      v37 = *(_BYTE **)(v15 + 136);
      v38 = v22;
      do
      {
        v39 = *v36++;
        *v37++ = v39;
        v38 = (float *)((char *)v38 - 1);
      }
      while (v38);
    }
    v40 = *(_DWORD *)(v14 + 164);
    if (v40 >= 1)
    {
      v41 = *(_BYTE **)(v15 + 136);
LABEL_33:
      bzero(v41 + 1, v40);
    }
  }
  else if ((int)v22 >= 1)
  {
    v46 = *(char **)(v15 + 128);
    v47 = *(_BYTE **)(v15 + 136);
    v48 = v22;
    do
    {
      v49 = *v46++;
      *v47++ = v49;
      v48 = (float *)((char *)v48 - 1);
    }
    while (v48);
  }
  v542 = v17 + 284;
  v50 = *(_DWORD *)(v14 + 104);
  if (v50 < 1 || *(int *)(v15 + 152) < 1)
  {
    v528 = 0;
  }
  else
  {
    v51 = v50 > 1 || v23 < (float)(*(float *)(v17 + 552) + 2.0);
    v528 = v51;
  }
  *(_BYTE *)v17 = a10 == 0;
  *(_DWORD *)(v17 + 516) = *(_DWORD *)(v17 + 40);
  *(_DWORD *)(v17 + 556) = *(_DWORD *)(v17 + 408);
  *(_QWORD *)(v17 + 532) = *(_QWORD *)(v17 + 524);
  *(_DWORD *)(v17 + 592) = 0;
  v617 = v15;
  v610 = (int *)v14;
  v557 = v17;
  v558 = v16;
  v544 = v21;
  v559 = v22;
  v532 = a8;
  v536 = a4;
  v538 = v18;
  if (*(_DWORD *)(v14 + 100) || *(_DWORD *)(v17 + 148))
  {
    *(_DWORD *)(v17 + 376) = *(_DWORD *)(v17 + 4);
    v52 = a6;
    memcpy(*(void **)(v16 + 112), a6, 4 * *(int *)(v14 + 16));
    goto LABEL_51;
  }
  v106 = *(_DWORD *)(v14 + 132);
  v572 = *(_DWORD *)(v14 + 72);
  if (v106 < 1)
  {
    v561 = *(_DWORD *)(v14 + 132);
  }
  else
  {
    v107 = 0;
    v108 = *(_DWORD *)(v14 + 72) - v616;
    v109 = (4 * v616);
    v110 = a6;
    do
    {
      v111 = v616;
      if (*(_BYTE *)(*(_QWORD *)(v15 + 136) + v107))
      {
        v112 = *(_QWORD *)(*(_QWORD *)(v15 + 64) + 8 * v107);
        v113 = *(_QWORD *)(*(_QWORD *)(v15 + 56) + 8 * v107);
        v114 = v616;
        if (v572 != (_DWORD)v616)
        {
          v115 = 0;
          do
          {
            memcpy((void *)(v113 + 4 * v115), (const void *)(v113 + 4 * (v616 + v115)), v109);
            memcpy((void *)(v112 + 4 * v115), (const void *)(v112 + 4 * (v616 + v115)), v109);
            v115 += v616;
            v114 = v616;
          }
          while (v115 < v108);
        }
        v116 = (void *)(v113 + 4 * (int)v108);
        memcpy(v116, v110, v109);
        vDSP_vsq((const float *)v116, 1, (float *)(v112 + 4 * (int)v108), 1, v114);
        v14 = (uint64_t)v610;
        v106 = v610[33];
        v15 = v617;
        v111 = v114;
        v22 = v559;
      }
      v110 = (lmsfilt_v5 *)((char *)v110 + 4 * v111);
      ++v107;
    }
    while (v107 < v106);
    v561 = v106;
    v572 = *(_DWORD *)(v14 + 72);
  }
  __Ba = *(float **)(v15 + 56);
  v531 = *(lmsfilt_v4 **)(v15 + 64);
  v534 = *(DSPSplitComplex **)(v15 + 136);
  v117 = (const BOOL *)*(int *)(v14 + 16);
  __Ca = *(int *)(v578 + 16);
  HIDWORD(v620) = *(_DWORD *)(v17 + 372);
  *(float *)&v620 = 1.0 - *((float *)&v620 + 1);
  v603 = *(int *)(v17 + 356);
  v118 = *(char **)(v16 + 120);
  v119 = *(float **)(v16 + 184);
  v619 = *(DSPSplitComplex *)(v16 + 160);
  v120 = *(DSPComplex **)(v16 + 136);
  v121 = *(const float **)(v16 + 232);
  v518 = v117;
  v122 = &v118[4 * (_QWORD)v117];
  v123 = 4 * (int)v117;
  memcpy(v118, v122, v123);
  v124 = v122;
  v16 = v558;
  v515 = v123;
  memcpy(v124, a7, v123);
  v125 = *(float **)(v558 + 216);
  vDSP_vmul((const float *)v118, 1, v121, 1, (float *)v120, 1, __Ca);
  dft_v5::dftGenericAnalysis2ndHalf(v120, v619.realp, v619.imagp, v578, 0);
  vDSP_zvmags(&v619, 1, v119, 1, v603);
  vDSP_vsmul(v119, 1, (const float *)&v620, v119, 1, v603);
  __lena = v119;
  v521 = v125;
  vDSP_vsma(v125, 1, (const float *)&v620 + 1, v119, 1, v125, 1, v603);
  v126 = v561;
  if (v561 <= 0)
  {
    v176 = 0;
    v174 = *(int **)(v17 + 328);
    v179 = 0.0;
    v18 = v538;
LABEL_134:
    v178 = v572;
    v183 = sqrtf(v179);
    if (v183 <= 1.0)
      v177 = v183;
    else
      v177 = 1.0;
    v174 += v176;
    goto LABEL_138;
  }
  v127 = 0;
  v128 = 0;
  __dst = *(void **)(v558 + 128);
  v129 = v561;
  v526 = v572 - __Ca;
  v525 = (int)(float)((float)((float)(v572 - (int)__Ca) / 3.0) + (float)((float)(v572 - (int)__Ca) / 3.0));
  v130 = 0.0;
  v131 = v534;
  v132 = __Ca;
  do
  {
    if (*((_BYTE *)&v131->realp + v127))
    {
      __Na = v128;
      v133 = *(_QWORD *)&__Ba[2 * v127];
      v134 = *((_QWORD *)v531 + v127);
      __Da = *(float **)(*(_QWORD *)(v16 + 208) + 8 * v127);
      v593 = v127;
      v583 = *(DSPSplitComplex *)(*(_QWORD *)(v16 + 224) + 16 * v127);
      v135 = *(_DWORD *)(v14 + 68);
      v136 = *(const float **)(v16 + 120);
      v137 = v526 - v135;
      LODWORD(__A.realp) = 0;
      LODWORD(__Z.realp) = 0;
      LODWORD(v624.realp) = 0;
      if (v526 - v135 >= v525)
        v138 = (v137 - v525 + 1) & ~((v137 - v525 + 1) >> 31);
      else
        v138 = 0;
      v604 = v134;
      vDSP_sve((const float *)(v134 + 4 * v138), 1, (float *)&__Z, v132);
      vDSP_dotpr(v136, 1, v136, 1, (float *)&__A, v132);
      v139 = *(float *)&__Z.realp;
      v140 = (v137 + 2);
      if ((int)v138 >= (int)v140)
      {
        v145 = v138;
      }
      else
      {
        v141 = v138 + v132 - v135;
        v142 = v138 - v135;
        v143 = 0.0;
        v144 = v138;
        v145 = v138;
        do
        {
          vDSP_dotpr((const float *)(v133 + 4 * v144), 1, v136, 1, (float *)&v624, __Ca);
          if (v144 <= v138)
          {
            v146 = *(float *)&__Z.realp;
          }
          else
          {
            v146 = *(float *)&__Z.realp;
            if (v144 >= v135 && v135 >= 1)
            {
              v147 = (float *)(v604 + 4 * v142);
              v148 = v135;
              v149 = (float *)(v604 + 4 * v141);
              do
              {
                v150 = *v147++;
                v151 = v146 - v150;
                v152 = *v149++;
                v146 = v151 + v152;
                --v148;
              }
              while (v148);
              *(float *)&__Z.realp = v146;
            }
          }
          v153 = *(float *)&v624.realp / (sqrtf(v146 * *(float *)&__A.realp) + 2.2204e-16);
          v154 = fabsf(v153);
          if (v154 > v143)
          {
            v139 = v146;
            v143 = v154;
            v145 = v144;
          }
          v144 += v135;
          v141 += v135;
          v142 += v135;
        }
        while (v144 < v140);
      }
      memcpy(__dst, (const void *)(v133 + 4 * v145), 4 * __Ca);
      *(float *)(v557 + 376) = v139;
      *(_DWORD *)(v557 + 324) = v145;
      __A = v583;
      v156 = *(DSPComplex **)(v558 + 128);
      v157 = *(const float **)(v558 + 232);
      v158 = *(int *)(v578 + 16);
      v159 = *(DSPSplitComplex *)(v558 + 160);
      v624 = *(DSPSplitComplex *)(v558 + 144);
      __Z = v159;
      v160 = *(float **)(v558 + 176);
      v623 = *(DSPSplitComplex *)(v558 + 192);
      v161 = *(_DWORD *)(v557 + 352);
      v162 = *(_DWORD *)(v557 + 356);
      v622 = *(float *)(v557 + 372);
      v621 = 1.0 - v622;
      vDSP_vmul((const float *)v156, 1, v157, 1, (float *)v156, 1, v158);
      dft_v5::dftGenericAnalysis2ndHalf(v156, v624.realp, v624.imagp, v578, 0);
      vDSP_zvmags(&v624, 1, v160, 1, v162);
      vDSP_zvcmul(&__Z, 1, &v624, 1, &v623, 1, v162);
      vDSP_vsmul(v160, 1, &v621, v160, 1, v162);
      vDSP_vsma(__Da, 1, &v622, v160, 1, __Da, 1, v162);
      vDSP_vsmul(v623.realp, 1, &v621, v623.realp, 1, v162);
      vDSP_vsmul(v623.imagp, 1, &v621, v623.imagp, 1, v162);
      vDSP_vsmul(v583.realp, 1, &v622, v583.realp, 1, v162);
      vDSP_vsmul(v583.imagp, 1, &v622, v583.imagp, 1, v162);
      vDSP_zvadd(&__A, 1, &v623, 1, &__A, 1, v162);
      vDSP_zvabs(&__A, 1, __lena, 1, v162);
      v163 = 0.0;
      v164 = v162 - v161;
      v15 = v617;
      v22 = v559;
      if (v162 >= v161)
      {
        v165 = &__Da[v161 - 1];
        v166 = v164 + 1;
        v167 = &v521[v161 - 1];
        v168 = &__lena[v161 - 1];
        do
        {
          v169 = *v168++;
          v170 = v169;
          v171 = *v167++;
          v172 = v171;
          v173 = *v165++;
          v163 = v170 / (sqrtf(v172 * v173) + 0.00000001) + v163;
          --v166;
        }
        while (v166);
      }
      v130 = v130 + v139;
      v128 = __Na + 1;
      v155 = v163 / (float)(v164 + 1);
      v14 = (uint64_t)v610;
      v132 = __Ca;
      v17 = v557;
      v16 = v558;
      v126 = v561;
      v131 = v534;
      v129 = v561;
      v127 = v593;
    }
    else
    {
      v145 = 0;
      v155 = 0.0;
    }
    v174 = *(int **)(v17 + 328);
    v174[v127] = v145;
    v175 = *(float **)(v17 + 312);
    v175[v127++] = v155;
  }
  while (v127 != v129);
  v18 = v538;
  if (v128 >= 2)
    *(float *)(v17 + 376) = v130 / (float)v128;
  if (v126 != 1)
  {
    v180 = 0;
    v176 = 0;
    v181 = 0.0;
    v179 = 0.0;
    do
    {
      if (*((_BYTE *)&v131->realp + v180))
      {
        v182 = v175[v180];
        if (v182 > v181)
        {
          v176 = v180;
          v181 = v175[v180];
        }
        v179 = v179 + (float)(v182 * v182);
      }
      ++v180;
    }
    while (v129 != v180);
    goto LABEL_134;
  }
  v176 = 0;
  v177 = *v175;
  v178 = v572;
LABEL_138:
  v184 = v178 - (_DWORD)v518;
  v185 = *v174;
  if (v185 >= v184)
    v185 = v184;
  memcpy(*(void **)(v16 + 112), (const void *)(*(_QWORD *)&__Ba[2 * v176] + 4 * v185), v515);
  *(float *)(v17 + 320) = v177;
  v52 = a6;
LABEL_51:
  v54 = (DSPSplitComplex *)(v16 + 16);
  v533 = (DSPSplitComplex *)(v16 + 32);
  v55 = *(_DWORD *)(v15 + 80);
  v56 = *(_QWORD *)(v15 + 32);
  v57 = *(_QWORD *)(v16 + 88);
  v58 = v55 == 0;
  if (v55)
    v59 = v56 + 4 * v554;
  else
    v59 = *(_QWORD *)(v15 + 32);
  if (v58)
  {
    v56 += 4 * v554;
    v60 = *(_QWORD *)(v16 + 88);
  }
  else
  {
    v60 = v57 + 4 * v616;
  }
  if (v58)
    v57 += 4 * v616;
  *(_QWORD *)(v15 + 40) = v59;
  *(_QWORD *)(v15 + 48) = v56;
  *(_QWORD *)(v16 + 96) = v60;
  *(_QWORD *)(v16 + 104) = v57;
  lmsfilt_v5::preemphasisFilter(v52, (const float *)*(unsigned int *)(v14 + 16), *(float **)v18, *(float **)(v15 + 40), v22, *(unsigned __int8 **)(v15 + 120), v53);
  v618 = 1;
  lmsfilt_v5::preemphasisFilter((lmsfilt_v5 *)a7, (const float *)*(unsigned int *)(v14 + 16), (float *)(v18 + 8), *(float **)(v16 + 96), (float *)1, &v618, v61);
  v62 = (int *)*(unsigned int *)(v15 + 72);
  *(_DWORD *)(v15 + 76) = (_DWORD)v62;
  dft_v3::GetIndexSequence(*(signed int **)(v15 + 88), v62, *(_DWORD *)(v14 + 44), *(_DWORD *)(v14 + 48));
  __C = *(DSPComplex **)(v15 + 40);
  v63 = *(float **)(v17 + 56);
  v64 = *(int *)(v14 + 16);
  v65 = (float *)*(unsigned int *)(v14 + 128);
  v66 = (char **)v15;
  v68 = *(int *)(v14 + 36);
  v67 = *(int *)(v14 + 40);
  v69 = *((_DWORD *)v66 + 19);
  v70 = v66[2];
  v71 = v66[3];
  v72 = *v66;
  v73 = v66[1];
  v74 = *(_DWORD *)(v14 + 44);
  v75 = v66[12];
  v76 = (float *)v66[13];
  LODWORD(v624.realp) = 1065353216;
  __D = v65;
  if ((int)v65 < 1)
  {
    v92 = v557;
    v91 = v558;
    v93 = v552;
    v94 = v617;
  }
  else
  {
    v529 = (lmsfilt_v4 *)v54;
    v77 = 0;
    v78 = (float *)&v75[4 * v69 * (int)v67];
    v602 = v64;
    v79 = v69 * v64;
    v80 = (float *)&v71[4 * v79];
    __srca = 4 * (int)v68;
    __na = 4 * v68;
    v81 = v14;
    __B = (float *)(v14 + 88);
    v560 = (int)v67 - 1;
    v571 = v74;
    __len = 4 * (v74 - 1);
    v579 = v74 - 1;
    v555 = v67 - 2;
    v82 = (float *)&v70[4 * v79];
    v582 = (float *)(4 * v67);
    v586 = v67;
    __N = v68;
    do
    {
      if (*((_BYTE *)v77 + *(_QWORD *)(v617 + 128)))
      {
        memcpy(v82, v72, __srca);
        memcpy(v80, v73, __srca);
        __Z.realp = &v82[__N];
        __Z.imagp = &v80[__N];
        vDSP_ctoz(__C, 2, &__Z, 1, __N);
        memcpy(v72, &v82[__N], __na);
        memcpy(v73, &v80[__N], __na);
        __Z.realp = v82;
        __Z.imagp = v80;
        v84 = (MultiRadixRealFFT *)*((_QWORD *)v610 + 1);
        if (v84)
          MultiRadixRealFFT::RealInPlaceTransform(v84, &__Z, 1, v83);
        vDSP_vsmul(v82, 1, __B, v82, 1, (uint64_t)*v610 >> 1);
        vDSP_vsmul(v80, 1, __B, v80, 1, (uint64_t)*v610 >> 1);
        __A.realp = v82;
        __A.imagp = v80;
        vDSP_zvmags(&__A, 1, v63, 1, v602);
        *v63 = *v82 * *v82;
        v63[v602] = *v80 * *v80;
        v85 = *((float *)v610 + 43);
        *v78 = v85 + *v63;
        v78[v560] = v85 + v63[v560];
        if ((int)v586 >= 3)
        {
          v86 = 1;
          v87 = v555;
          do
          {
            v78[v86] = v85 + (float)((float)((float)(v63[v86] + v63[v86 - 1]) + v63[v86 + 1]) * 0.33333);
            ++v86;
            --v87;
          }
          while (v87);
        }
        if (v571 == 1)
        {
          vDSP_vfill((const float *)&v624, v76, 1, 1uLL);
        }
        else
        {
          LODWORD(__A.realp) = 0;
          vDSP_sve(v78, 1, (float *)&__A, v586);
          v89 = log10f(*(float *)&__A.realp) * 10.0;
          memmove(v76, v76 + 1, __len);
          v76[v579] = v89;
        }
        v88 = __N;
        v14 = (uint64_t)v610;
      }
      else
      {
        v14 = v81;
        vDSP_vclr(v82, 1, *(int *)(v81 + 16));
        vDSP_vclr(v80, 1, *(int *)(v14 + 16));
        v88 = __N;
        vDSP_vclr((float *)v72, 1, __N);
        vDSP_vclr((float *)v73, 1, __N);
        vDSP_vclr(v63, 1, v586);
        vDSP_vclr(v78, 1, *(int *)(v14 + 40));
        memmove(v76, v76 + 1, __len);
        v76[v579] = -90.458;
      }
      v90 = *(int *)(v14 + 60);
      v82 += v90;
      v80 += v90;
      v72 += 4 * v88;
      v73 += 4 * v88;
      __C = (DSPComplex *)((char *)__C + 4 * v602);
      v63 = (float *)((char *)v582 + (_QWORD)v63);
      v78 += *(int *)(v14 + 56);
      v81 = v14;
      v77 = (float *)((char *)v77 + 1);
      v76 += *(int *)(v14 + 44);
    }
    while (v77 != __D);
    v74 = *(_DWORD *)(v14 + 44);
    v92 = v557;
    v91 = v558;
    v93 = v552;
    v54 = (DSPSplitComplex *)v529;
    v94 = v617;
  }
  if (*((_DWORD *)v93 + 17) == 1)
  {
    if (*(_DWORD *)(v92 + 148) != 1)
    {
LABEL_172:
      if (*(int *)(v14 + 104) >= 1)
        *(_QWORD *)(a1[5] + 72) = v93[9];
      goto LABEL_174;
    }
    v530 = (lmsfilt_v4 *)v54;
    v95 = v74;
    LODWORD(__A.realp) = 0;
    v97 = *((_DWORD *)v93 + 18);
    v96 = *((_DWORD *)v93 + 19);
    v98 = 1.0;
    if (v74 < 1)
    {
      v100 = 0;
      v103 = 0;
      v102 = 0.0;
LABEL_146:
      v186 = *(float *)(v92 + 608) * 0.95;
      *(float *)(v92 + 608) = v186;
      if ((float)(v102 * 0.9) <= v186)
      {
        v100 = *(_DWORD *)(v92 + 612);
      }
      else
      {
        *(_DWORD *)(v92 + 612) = v100;
        *(float *)(v92 + 608) = v102;
      }
      v187 = (v100 - *((_DWORD *)v93 + 20)) & ~((v100 - *((_DWORD *)v93 + 20)) >> 31);
      if (v187 + *((_DWORD *)v93 + 21) >= v74)
        v188 = v74;
      else
        v188 = v187 + *((_DWORD *)v93 + 21);
      vDSP_sve((const float *)(*(_QWORD *)(v92 + 120) + 4 * v187), 1, (float *)&__A, v188 - v187);
      v189 = v188 - 1 - v187 + v103;
      if (v189 <= 1)
        v189 = 1;
      v190 = v102 / (float)((float)(v98 * (float)(*(float *)&__A.realp - v102)) / (float)v189);
      v191 = *(float *)(v92 + 568);
      if (v191 <= 2.0 || v190 <= 5.0)
      {
        v14 = (uint64_t)v610;
        v91 = v558;
        if (v191 <= 2.0)
        {
          v94 = v617;
        }
        else
        {
          v94 = v617;
          if (v190 < 3.0)
          {
            ++v96;
            --v97;
          }
        }
      }
      else
      {
        if (v97 <= v187)
          v192 = 0;
        else
          v192 = -1;
        if (v97 < v187)
          v192 = 1;
        v97 += v192;
        if (v96 >= v188 - 1)
          v96 -= v96 >= v188;
        else
          ++v96;
        v94 = v617;
        v14 = (uint64_t)v610;
        v91 = v558;
      }
      v193 = v95 - 1;
      if (v96 < v95)
        v193 = v96;
      *((_DWORD *)v93 + 18) = v97 & ~(v97 >> 31);
      *((_DWORD *)v93 + 19) = v193;
      v54 = (DSPSplitComplex *)v530;
      goto LABEL_172;
    }
    v99 = 0;
    v100 = 0;
    v101 = *(_QWORD *)(v92 + 120);
    v102 = 0.0;
    do
    {
      if (*(float *)(v101 + 4 * v99) > v102)
      {
        v100 = v99;
        v102 = *(float *)(v101 + 4 * v99);
      }
      ++v99;
    }
    while (v74 != v99);
    v103 = 0;
    if (v74 < 4 || *(float *)(v14 + 24) >= 12.0)
      goto LABEL_146;
    v104 = v100 + 1;
    if ((_DWORD)v104 == v74)
    {
      v105 = *(float *)(v101 + 4 * v100 - 4);
    }
    else
    {
      if (v100)
      {
        v102 = v102 + (float)((float)(*(float *)(v101 + 4 * v100 - 4) + *(float *)(v101 + 4 * v104)) * 0.5);
LABEL_145:
        v98 = 2.0;
        v103 = -1;
        goto LABEL_146;
      }
      v105 = *(float *)(v101 + 4);
    }
    v102 = v102 + v105;
    goto LABEL_145;
  }
LABEL_174:
  HIDWORD(v505) = *(_DWORD *)(v14 + 60);
  LODWORD(v509) = *((_DWORD *)v93 + 9);
  LODWORD(v505) = (_DWORD)v559;
  lmsfilt_v4::runLmsFilter_v4(v54, v533, (DSPSplitComplex *)*(unsigned int *)(v14 + 16), (uint64_t)v93[2], (int *)v93[3], *(_QWORD *)(v94 + 16), *(float **)(v94 + 24), *(float **)(v94 + 88), (float *)v93[9], v505, v509, *(unsigned __int8 **)(v94 + 128), v512, SHIDWORD(v512), v515, SHIDWORD(v515), v518);
  dft_v5::dftSynthesis(*(float **)(v91 + 32), *(float **)(v91 + 40), v14);
  aec_v5::get_EchoEst_Err(v546, (float *)v553, (float *)(*(_QWORD *)(v91 + 32) + 4 * v551), (float *)(*(_QWORD *)(v91 + 40) + 4 * v551), *(const float **)(v91 + 96), v14);
  v194 = *(const float **)(v91 + 96);
  v195 = *(int *)(v14 + 16);
  vDSP_svesq(*(const float **)(v94 + 40), 1, (float *)(v92 + 4), v195);
  vDSP_svesq(v194, 1, v545, v195);
  v196 = *(_DWORD **)(v92 + 8);
  *v196 = *(_DWORD *)(v92 + 4);
  v197 = *(unsigned int *)(v14 + 132);
  if ((int)v197 <= 1)
  {
    if ((int)v559 > 1)
      bzero(v196 + 1, 4 * ((_DWORD)v559 - 1));
  }
  else
  {
    v198 = 0;
    v199 = 0;
    v200 = 0;
    v201 = 0;
    v202 = 0.0;
    v203 = 4 * v197;
    do
    {
      if (*(_BYTE *)(*(_QWORD *)(v94 + 136) + v200))
      {
        ++v201;
        vDSP_svesq((const float *)(*(_QWORD *)(v94 + 40) + v198), 1, (float *)&v196[v199 / 4], v610[4]);
        v196 = *(_DWORD **)(v92 + 8);
        v202 = v202 + *(float *)&v196[v199 / 4];
      }
      else
      {
        v196[v199 / 4] = 0;
      }
      ++v200;
      v199 += 4;
      v198 += 4 * v616;
    }
    while (v203 != v199);
    *(float *)(v92 + 4) = v202 / (float)v201;
    v14 = (uint64_t)v610;
    v91 = v558;
  }
  v204 = *(float *)(v92 + 28);
  v205 = *(_DWORD *)(v14 + 16);
  v206 = log10((float)(*(float *)(v92 + 4) / (float)v205) + 1.0e-20) * 10.0;
  *(float *)(v92 + 16) = v206;
  learnrate_v4::updateStatistics_echo(v205, (const float *)v553, (const float *)v546, (float *)v92);
  v207 = *(float *)(v92 + 24);
  v208 = (v207 + 1.0e-13) / (*(float *)(v92 + 36) + 1.0e-13);
  *(float *)(v92 + 604) = log10f(v208) * 10.0;
  v209 = *(void **)(v91 + 80);
  v210 = *(float **)(v91 + 64);
  v211 = v540;
  if (*(int *)(v94 + 152) < 1)
  {
    v227 = *(_DWORD *)(v14 + 168);
    if (v227 == 1)
    {
      v228 = *(int *)(v92 + 236);
      vDSP_vclr(*(float **)(v92 + 160), 1, v228);
      vDSP_vclr(*(float **)(v92 + 168), 1, v228);
      vDSP_vclr(*(float **)(v92 + 176), 1, v228);
      if ((int)v228 >= 1)
      {
        v229 = v228;
        v230 = *(_DWORD **)(v92 + 192);
        v231 = *(_DWORD **)(v92 + 200);
        v232 = *(_DWORD **)(v92 + 208);
        do
        {
          *v230++ = 1;
          *v231++ = 1;
          *v232++ = 1;
          --v229;
        }
        while (v229);
      }
      v233 = *(_DWORD *)(v92 + 236);
      if (v233 <= *(_DWORD *)(v92 + 252))
        v233 = *(_DWORD *)(v92 + 252);
      if (v233 >= 1)
        memset_pattern16(*(void **)(v92 + 184), &unk_1B66A2BB0, 4 * v233);
      vDSP_vclr(**(float ***)(v94 + 56), 1, *(int *)(v14 + 76));
      vDSP_vclr(**(float ***)(v94 + 64), 1, *(int *)(v14 + 76));
      vDSP_vclr(*(float **)(v91 + 120), 1, *(int *)(v14 + 80));
      vDSP_vclr(**(float ***)(v91 + 208), 1, *(int *)(v14 + 128) * (uint64_t)*(int *)(v14 + 80));
      vDSP_vclr(*(float **)(v91 + 216), 1, *(int *)(v14 + 80));
      vDSP_vclr(**(float ***)(v91 + 224), 1, 2 * *(int *)(v14 + 80) * (uint64_t)*(int *)(v14 + 128));
      v227 = *(_DWORD *)(v14 + 168);
    }
    if (v227 >= 1)
    {
      *(_DWORD *)(v92 + 568) = 0;
      *(_QWORD *)(v92 + 148) = 0;
    }
    goto LABEL_275;
  }
  v212 = 0;
  v213 = *(DSPComplex **)(v91 + 240);
  v587 = *(float **)(v91 + 248);
  v214 = *(_DWORD *)(v14 + 128);
  v215 = *((_DWORD *)v93 + 9);
  v216 = *(_DWORD *)(v14 + 60);
  v217 = *(float *)(v92 + 260);
  v218 = *(float *)(v92 + 264);
  v219 = *(float *)(v92 + 268);
  v220 = *(float *)(v92 + 272);
  v221 = *(float *)(v92 + 276);
  v222 = *(int *)(v14 + 36);
  v223 = *(float *)(v14 + 32);
  *(_DWORD *)(v540 + 60) = 0;
  v224 = *(_DWORD *)(v92 + 232);
  if (v224 <= 1)
  {
    if (v224 != 1)
      goto LABEL_188;
    v212 = 2;
  }
  *(_DWORD *)(v92 + 232) = v212;
LABEL_188:
  v225 = v223 * v207;
  if (*(_DWORD *)(v540 + 56) == 1)
  {
    *(_QWORD *)(v540 + 56) = 0x100000000;
    **(_DWORD **)(v92 + 192) = 1;
    v226 = 0.0;
  }
  else
  {
    __Db = v219;
    v594 = v220;
    __Nb = v223 * v207;
    v605 = v221;
    v556 = v204;
    v580 = v24;
    LODWORD(v510) = v215;
    lmsfilt_v4::runLmsFilter_v4((DSPSplitComplex *)(v91 + 256), (DSPSplitComplex *)(v91 + 272), (DSPSplitComplex *)*(unsigned int *)(v14 + 16), *(_QWORD *)(v540 + 16), *(int **)(v540 + 24), *(_QWORD *)(v94 + 16), *(float **)(v94 + 24), *(float **)(v94 + 88), *(float **)(v540 + 72), (float *)__PAIR64__(v216, v214), v510, *(unsigned __int8 **)(v94 + 128), v513, SHIDWORD(v513), v516, SHIDWORD(v516), v519);
    dft_v5::dftSynthesis(*(float **)(v91 + 272), *(float **)(v91 + 280), v14);
    aec_v5::get_EchoEst_Err(v213, v587, (float *)(*(_QWORD *)(v91 + 272) + 4 * v222), (float *)(*(_QWORD *)(v91 + 280) + 4 * v222), *(const float **)(v91 + 96), v14);
    vDSP_svesq(v587, 1, (float *)(v92 + 216), *(int *)(v14 + 16));
    v234 = *(float *)(v92 + 216);
    *(float *)(v92 + 220) = v234;
    v235 = (float)((float)*(int *)v14 * 100.0) * 9.3132e-10;
    if (v234 < v235)
      *(float *)(v92 + 216) = v234 + v235;
    LODWORD(__A.realp) = 0;
    vDSP_svesq((const float *)v213, 1, (float *)&__A, *(int *)(v14 + 16));
    v236 = *(float *)(v92 + 220) + 1.0e-13;
    v237 = (*(float *)&__A.realp + 1.0e-13) / v236;
    v584 = log10f(v237);
    v238 = *(float *)(v92 + 36) + 1.0e-13;
    v239 = *(float *)(v92 + 28) + 0.000000001;
    v240 = v217;
    v241 = v238 / v239 + v217;
    v242 = log10f(v241) * 10.0;
    v243 = v236 / v239 + v240;
    v244 = log10f(v243) * 10.0;
    v245 = v238 / (*(float *)(v92 + 24) + 0.000000001) + v240;
    v246 = log10f(v245);
    v247 = 10.0;
    v248 = v246 * 10.0;
    v249 = *(_DWORD *)(v92 + 236);
    v251 = *(float **)(v92 + 160);
    v250 = *(float **)(v92 + 168);
    v253 = *(float **)(v92 + 176);
    v252 = *(_BOOL4 **)(v92 + 184);
    v255 = *(_DWORD **)(v92 + 192);
    v254 = *(_DWORD **)(v92 + 200);
    v256 = v249 - 1;
    if (v249 != 1)
    {
      v257 = 0;
      v258 = *(_QWORD *)(v92 + 208);
      v259 = v258 + 4 * v256;
      v260 = v249 - 2;
      v261 = v256 - 1;
      v262 = &v254[v256];
      v263 = &v255[v256];
      v264 = &v252[v256];
      v265 = &v253[v256];
      v266 = &v250[v256];
      v267 = &v251[v256];
      do
      {
        v267[v257] = v251[(v260 + v257)];
        v266[v257] = v250[(v260 + v257)];
        v265[v257] = v253[(v260 + v257)];
        v264[v257] = v252[(v260 + v257)];
        v263[v257] = v255[(v260 + v257)];
        v262[v257] = v254[(v260 + v257)];
        *(_DWORD *)(v259 + 4 * v257) = *(_DWORD *)(v258 + 4 * (v260 + v257));
      }
      while (v261 + (_DWORD)v257--);
    }
    *v251 = v242 - v244;
    *v250 = v242;
    *v253 = v248;
    v269 = *v251;
    v270 = (float)(v218 + *v251) < 0.0;
    v221 = v605;
    v225 = __Nb;
    if (__Nb < v605)
      v270 = 1;
    *v252 = v270;
    *v255 = v269 < __Db;
    *v254 = *(float *)(v92 + 36) > *(float *)(v92 + 220);
    v211 = v540;
    v271 = v248 < v594 && *(float *)(v92 + 16) < -9.0;
    v24 = v580;
    v204 = v556;
    v272 = *(_BOOL4 **)(v92 + 208);
    *v272 = v271;
    v273 = *(_DWORD *)(v92 + 252);
    if (v273 > *(_DWORD *)(v92 + 236))
      goto LABEL_228;
    if (v273 < 1)
    {
      v274 = 0;
    }
    else
    {
      v274 = 0;
      v275 = *(unsigned int *)(v92 + 252);
      do
      {
        v276 = *v252++;
        v274 += v276;
        --v275;
      }
      while (v275);
    }
    v277 = *(_DWORD *)(v92 + 228);
    v278 = v277 >= 2 && v274 == 0;
    v279 = v278 || v277 >= v273;
    if (v279 && *(_BYTE *)v92)
    {
      v280 = 4 * *((_DWORD *)v93 + 22);
      memcpy(*v93, *(const void **)v540, v280);
      memcpy(v93[1], *(const void **)(v540 + 8), v280);
      memcpy(v93[2], *(const void **)(v540 + 16), v280);
      memcpy(v93[3], *(const void **)(v540 + 24), v280);
      memcpy(v93[6], *(const void **)(v540 + 48), v280);
      v93[9] = *(char **)(v540 + 72);
      *(_DWORD *)(v92 + 232) = 1;
      v281 = v213;
      v210 = *(float **)(v91 + 240);
      v282 = *(void **)(v91 + 248);
      v283 = 4 * *(_DWORD *)(v14 + 136);
      v284 = 4 * *(_DWORD *)(v14 + 16);
      memcpy(v209, v587, v284);
      v285 = v283;
      v91 = v558;
      memcpy(*(void **)(v558 + 16), *(const void **)(v558 + 256), v285);
      memcpy(*(void **)(v91 + 24), *(const void **)(v91 + 264), v285);
      memcpy(*(void **)(v91 + 32), *(const void **)(v91 + 272), v284);
      memcpy(*(void **)(v91 + 40), *(const void **)(v91 + 280), v284);
      *(_QWORD *)(v92 + 88) = *(_QWORD *)v542;
      v286 = 4 * *(_DWORD *)(v14 + 40);
      memcpy(*(void **)(v92 + 72), *(const void **)(v92 + 296), v286);
      memcpy(*(void **)(v92 + 80), *(const void **)(v92 + 304), v286);
      v247 = 10.0;
      **(_DWORD **)(v92 + 184) = 1;
      v211 = v540;
      *(_DWORD *)(v92 + 228) = 0;
      v209 = v282;
      v213 = v281;
    }
    else
    {
LABEL_228:
      v287 = *(int **)(v92 + 192);
      v288 = *(_DWORD *)(v92 + 244);
      if (v288 < 1)
      {
        v289 = 0;
      }
      else
      {
        v289 = 0;
        v290 = *(int **)(v92 + 192);
        v291 = *(unsigned int *)(v92 + 244);
        do
        {
          v292 = *v290++;
          v289 += v292;
          --v291;
        }
        while (v291);
      }
      v293 = *(_DWORD *)(v92 + 248);
      if (v293 < 1)
      {
        v294 = 0;
      }
      else
      {
        v294 = 0;
        v295 = *(unsigned int *)(v92 + 248);
        do
        {
          v296 = *v287++;
          v294 += v296;
          --v295;
        }
        while (v295);
      }
      v297 = *(_DWORD *)(v92 + 256);
      if (v297 < 1)
      {
        v298 = 0;
      }
      else
      {
        v298 = 0;
        v299 = *(unsigned int *)(v92 + 256);
        do
        {
          v300 = *v272++;
          v298 += v300;
          --v299;
        }
        while (v299);
      }
      v301 = v250[1];
      if (*v250 < v301 || v301 < v250[2])
      {
        v302 = *(_BYTE *)v92 && v289 == v288;
        v303 = v302 && v298 == v297;
        if (v303 && (float)((float)v294 * 1.5) > (float)v293)
          *(_DWORD *)(v540 + 60) = 1;
      }
    }
    v226 = v584 * v247;
  }
  v305 = *(_DWORD *)(v211 + 60);
  if (v305 == 1)
  {
    *(_DWORD *)(v92 + 224) = 0;
    v306 = 4 * *(_DWORD *)(v211 + 88);
    memcpy(*(void **)v211, *v93, v306);
    memcpy(*(void **)(v211 + 8), v93[1], v306);
    memcpy(*(void **)(v211 + 16), v93[2], v306);
    memcpy(*(void **)(v211 + 24), v93[3], v306);
    memcpy(*(void **)(v211 + 48), v93[6], v306);
    *(_QWORD *)(v211 + 72) = v93[9];
    *(_QWORD *)v542 = *(_QWORD *)(v92 + 88);
    v307 = 4 * *(_DWORD *)(v14 + 40);
    memcpy(*(void **)(v92 + 296), *(const void **)(v92 + 72), v307);
    memcpy(*(void **)(v92 + 304), *(const void **)(v92 + 80), v307);
    **(_DWORD **)(v92 + 184) = 0;
    **(_DWORD **)(v92 + 192) = 0;
    **(_DWORD **)(v92 + 200) = 0;
    **(_DWORD **)(v92 + 208) = 0;
    v308 = *(_DWORD *)(v92 + 624);
    if (v308 <= 3)
      *(_DWORD *)(v92 + 624) = v308 + 1;
  }
  else
  {
    if (!*(_BYTE *)v92)
      goto LABEL_263;
    *(float *)(v92 + 224) = *(float *)(v92 + 224) + 1.0;
  }
  v305 = *(_DWORD *)(v211 + 60);
LABEL_263:
  if (v305)
  {
LABEL_275:
    v587 = (float *)v209;
    v581 = v210;
    goto LABEL_276;
  }
  v309 = *(_DWORD *)(v92 + 240);
  if (v309 < 1)
  {
    v310 = 0;
  }
  else
  {
    v310 = 0;
    v311 = *(int **)(v92 + 200);
    v312 = *(unsigned int *)(v92 + 240);
    do
    {
      v313 = *v311++;
      v310 += v313;
      --v312;
    }
    while (v312);
  }
  if (v310 != v309)
  {
    *(_DWORD *)(v92 + 228) = 0;
    goto LABEL_275;
  }
  v581 = (float *)v213;
  *(_DWORD *)(v92 + 36) = *(_DWORD *)(v92 + 220);
  if (v225 >= v221 && *(_BYTE *)v92)
    ++*(_DWORD *)(v92 + 228);
  *(_DWORD *)(v92 + 232) = 1;
  *(float *)(v92 + 604) = v226;
LABEL_276:
  v585 = (float *)(v92 + 408);
  dft_v5::dftGenericAnalysis2ndHalf(v553, v550.realp, v550.imagp, v14, 1);
  dft_v5::dftGenericAnalysis2ndHalf_dsc((const void *)(*(_QWORD *)(v91 + 32) + 4 * v551), (const void *)(*(_QWORD *)(v91 + 40) + 4 * v551), v549, v548, (int *)v14);
  v314 = a1[10];
  v315 = v14;
  v317 = *(DSPComplex **)(v91 + 352);
  v316 = *(DSPComplex **)(v91 + 360);
  v318 = *(DSPComplex **)(v91 + 368);
  v319 = *(int *)(v315 + 16);
  v320 = *(_DWORD *)(v92 + 424) - v319;
  v321 = *(DSPSplitComplex *)(v91 + 304);
  v624 = *(DSPSplitComplex *)(v91 + 320);
  __Z = v321;
  v623 = *(DSPSplitComplex *)(v91 + 336);
  __Nc = *(int *)(v92 + 432);
  v606 = v314;
  v595 = *(_DWORD *)(v92 + 436);
  v322 = *(int *)(v92 + 444);
  v324 = *(float **)(v92 + 496);
  v323 = *(float **)(v92 + 504);
  __lenb = *(float **)(v92 + 480);
  __Dc = *(float **)(v92 + 488);
  LODWORD(v619.realp) = *(_DWORD *)(v92 + 416);
  v622 = 1.0 - *(float *)&v619.realp;
  if (v320 >= 1)
  {
    memmove(v317, (char *)v317 + 4 * v319, 4 * v320);
    memmove(v316, (char *)v316 + 4 * v319, 4 * v320);
    memmove(v318, (char *)v318 + 4 * v319, 4 * v320);
  }
  memcpy((char *)v317 + 4 * v320, *(const void **)(v558 + 96), 4 * v319);
  memcpy((char *)v316 + 4 * v320, *(const void **)(v558 + 64), 4 * v319);
  memcpy((char *)v318 + 4 * v320, *(const void **)(v558 + 80), 4 * v319);
  dft_v5::dftGenericAnalysis2ndHalf(v317, __Z.realp, __Z.imagp, v606, 0);
  dft_v5::dftGenericAnalysis2ndHalf(v316, v624.realp, v624.imagp, v606, 0);
  realp = v623.realp;
  imagp = v623.imagp;
  vDSP_zvmags(&__Z, 1, v324, 1, v322);
  vDSP_vsmul(v324, 1, &v622, realp, 1, v322);
  vDSP_vsmul(v323, 1, (const float *)&v619, imagp, 1, v322);
  vDSP_vadd(realp, 1, imagp, 1, v323, 1, v322);
  vDSP_zvcmul(&__Z, 1, &v624, 1, &v623, 1, v322);
  vDSP_zvabs(&v623, 1, __lenb, 1, v322);
  vDSP_vsmul(__lenb, 1, &v622, realp, 1, v322);
  vDSP_vsmul(__Dc, 1, (const float *)&v619, imagp, 1, v322);
  vDSP_vadd(realp, 1, imagp, 1, __Dc, 1, v322);
  v621 = 2.2204e-16;
  vDSP_vsadd(v323, 1, &v621, realp, 1, v322);
  vDSP_vdiv(realp, 1, __Dc, 1, imagp, 1, v322);
  vDSP_meanv(&imagp[__Nc], 1, v585, v595 - (int)__Nc + 1);
  v327 = v557;
  *(float *)(v557 + 408) = fmaxf(fminf(*(float *)(v557 + 408), 1.0), 0.0);
  dft_v5::dftGenericAnalysis2ndHalf(v318, v623.realp, v623.imagp, v606, 0);
  v328 = v623.realp;
  v329 = v623.imagp;
  v331 = v624.realp;
  v330 = v624.imagp;
  v332 = *(float **)(v557 + 448);
  v333 = *(float **)(v557 + 456);
  v334 = *(float **)(v557 + 472);
  __Nd = *(float **)(v557 + 464);
  v620 = 0;
  v335 = *(float *)(v557 + 412);
  v336 = *(float *)(v557 + 420);
  v337 = *(int *)(v557 + 424);
  v338 = *(_DWORD *)(v557 + 428);
  v607 = *(_DWORD *)(v557 + 440);
  __A = v623;
  vDSP_zvmags(&__A, 1, v333, 1, v337);
  *v333 = *v328 * *v328;
  v333[v337] = *v329 * *v329;
  __A.realp = v331;
  __A.imagp = v330;
  vDSP_zvmags(&__A, 1, v332, 1, v337);
  *v332 = *v331 * *v331;
  v332[v337] = *v330 * *v330;
  learnrate_v3::crossCorrSpec_raw((learnrate_v3 *)v333, v334, v332, __Nd, (const float *)&v620 + 1, (float *)&v620, (float *)((v338 >> 1) + 1));
  v339 = sqrtf(*(float *)&v620);
  v340 = (float)(*((float *)&v620 + 1) / v339) / (float)(v339 + v621);
  if (v340 <= 0.001)
    v340 = 0.001;
  *(float *)(v557 + 400) = v340;
  *(float *)(v557 + 404) = (float)((float)(1.0 - v335) * v340) + (float)(v335 * *(float *)(v557 + 404));
  VPEchoGateV3::GatesmoothPowerSpectrum((VPEchoGateV3 *)v334, v333, (const float *)v607, v336);
  VPEchoGateV3::GatesmoothPowerSpectrum((VPEchoGateV3 *)__Nd, v332, (const float *)v607, v336);
  *a11 = *(_DWORD *)(v557 + 408);
  v341 = *v610;
  LODWORD(__Z.realp) = 0;
  LODWORD(v624.realp) = 0;
  v342 = v610[4];
  v343 = (const float *)v610[10];
  v344 = *(float **)(v557 + 48);
  __A = v550;
  vDSP_zvmags(&__A, 1, v344, 1, v342);
  *v344 = *v550.realp * *v550.realp;
  v344[v342] = *v550.imagp * *v550.imagp;
  v345 = *(float **)(v557 + 64);
  __A.realp = v549;
  __A.imagp = v548;
  vDSP_zvmags(&__A, 1, v345, 1, v342);
  *v345 = *v549 * *v549;
  v345[v342] = *v548 * *v548;
  learnrate_v3::crossCorrSpec_raw(*(learnrate_v3 **)(v557 + 48), *(const float **)(v557 + 72), *(const float **)(v557 + 64), *(const float **)(v557 + 80), (const float *)&__Z, (float *)&v624, (float *)((v341 >> 1) + 1));
  v346 = sqrtf(*(float *)&v624.realp);
  v347 = *(float *)(v557 + 24);
  v348 = *(float *)(v557 + 136);
  v349 = *(float *)(v557 + 132) * v347;
  v350 = *(float *)(v557 + 32);
  if (v349 > (float)(v348 * v350))
    v349 = v348 * v350;
  v351 = v349 / v350;
  if (v350 < 9.3132e-19)
    v351 = *(float *)(v557 + 136);
  v352 = (float)((float)(*(float *)&__Z.realp / v346) * v351) + (float)((float)(1.0 - v351) * *(float *)(v557 + 88));
  v353 = (float)(v351 * v346) + (float)((float)(1.0 - v351) * *(float *)(v557 + 92));
  if (v353 < 9.3132e-10)
    v353 = 9.3132e-10;
  if (v352 >= (float)(v353 * 0.005))
    v354 = v352;
  else
    v354 = v353 * 0.005;
  if (v354 <= v353)
    v355 = v354;
  else
    v355 = v353;
  *(float *)&v624.realp = v346;
  *(float *)&__Z.realp = *(float *)&__Z.realp / v346;
  *(float *)(v557 + 88) = v352;
  *(float *)(v557 + 92) = v353;
  if (v352 < (float)(v353 * 0.005) || v354 > v353)
    *(float *)(v557 + 88) = v355;
  v357 = v355 / v353;
  v358 = (float)((float)(v347 * (float)(v357 * 3.0)) + (float)(*(float *)(v557 + 4) * 0.0001)) / v350;
  v359 = (float)(*(float *)(v557 + 20) * *(float *)(v557 + 20)) / (float)((float)(v350 * v347) + 8.6736e-19);
  if (v358 >= v359)
    v359 = v358;
  if (v359 > 0.5)
    v359 = 0.5;
  *(float *)(v557 + 140) = v357;
  *(float *)(v557 + 144) = v359;
  v360 = *(_DWORD *)(v557 + 148);
  v361 = v617;
  v362 = v544;
  if (v360)
  {
    if (v360 != 1)
      goto LABEL_312;
    if (*(float *)(v557 + 404) < *(float *)(v557 + 392) && *(float *)(v557 + 408) < *(float *)(v557 + 396))
      *(_DWORD *)(v557 + 144) = 0;
  }
  else
  {
    if (*(float *)(v557 + 152) <= (float)v610[11] || v357 <= *(float *)(v557 + 388))
      goto LABEL_312;
    *(_DWORD *)(v557 + 148) = 1;
  }
  if (v610[26] == 3 && v357 > 0.0631)
  {
    *(_QWORD *)(v557 + 148) = 0;
    v363 = v610;
    vDSP_vclr(**(float ***)(v617 + 64), 1, v610[19]);
    vDSP_vclr(**(float ***)(v617 + 56), 1, v610[19]);
    vDSP_vclr(*(float **)(v558 + 120), 1, v610[20]);
    vDSP_vclr(**(float ***)(v558 + 208), 1, v363[32] * (uint64_t)v363[20]);
    vDSP_vclr(*(float **)(v558 + 216), 1, v610[20]);
    vDSP_vclr(**(float ***)(v558 + 224), 1, 2 * v363[20] * (uint64_t)v363[32]);
  }
LABEL_312:
  learnrate_v4::getAdaptationRate4_v6(v557);
  VPEchoGateV3::GatesmoothPowerSpectrum(*(VPEchoGateV3 **)(v557 + 72), *(const float **)(v557 + 48), v343, *(float *)(v557 + 128));
  VPEchoGateV3::GatesmoothPowerSpectrum(*(VPEchoGateV3 **)(v557 + 80), *(const float **)(v557 + 64), v343, *(float *)(v557 + 128));
  if (!a10)
  {
    v368 = *(float **)(v557 + 104);
    v369 = v610[11];
    v370 = (DSPComplex *)(int)v369;
    if (v610[25])
    {
      v371 = -0.1;
    }
    else if (*(_DWORD *)(v557 + 148))
    {
      v371 = flt_1B662D220[*(float *)(v557 + 404) > 2.6];
    }
    else
    {
      v371 = 0.65;
    }
    v375 = *(float **)(v617 + 104);
    v376 = v610[4];
    v377 = v610[39];
    v378 = *(_QWORD *)(v557 + 632);
    v379 = *(_QWORD *)(v617 + 128);
    v380 = *(_DWORD *)(v617 + 152);
    v381 = *(_QWORD *)(v557 + 120);
    v382 = *((float *)v610 + 6);
    v383 = *((int *)v552 + 9);
    LODWORD(__A.realp) = 0;
    LODWORD(__Z.realp) = 0;
    LODWORD(v623.realp) = 1065353216;
    if ((_DWORD)v369 == 1)
    {
      vDSP_vfill((const float *)&v623, v368, 1, v377);
      *a3 = v382 * 0.5;
LABEL_384:
      __Cd = (DSPComplex *)v610[14];
      v434 = v610[10];
      v435 = v610[11];
      v436 = v610[32];
      LODWORD(__A.realp) = 0;
      v437 = *(_QWORD *)(v361 + 96);
      v438 = *(float **)(v327 + 96);
      v439 = *(_QWORD *)(v327 + 104);
      vDSP_vclr(v438, 1, v434);
      if ((int)v436 >= 1)
      {
        for (i = 0; i != v436; ++i)
        {
          if (*(_BYTE *)(*(_QWORD *)(v617 + 128) + i))
            v441 = (int)v435 < 1;
          else
            v441 = 1;
          if (!v441)
          {
            v442 = 0;
            do
            {
              LODWORD(__A.realp) = *(_DWORD *)(v439 + v442);
              if (*(float *)&__A.realp != 0.0)
                vDSP_vsma((const float *)(v437 + 4 * *(_DWORD *)(*(_QWORD *)(v617 + 88) + v442) * (int)v434), 1, (const float *)&__A, v438, 1, v438, 1, v434);
              v442 += 4;
            }
            while (4 * v435 != v442);
          }
          v437 += 4 * (_QWORD)__Cd;
          v439 += 4 * v435;
        }
      }
      LODWORD(__Z.realp) = 1065353216;
      vDSP_svdiv((const float *)&__Z, v438, 1, v438, 1, v434);
      v361 = v617;
      v327 = v557;
      v373 = v539;
      v443 = v587;
      if (*(int *)(v617 + 152) < 1)
        goto LABEL_419;
      v444 = *(float *)(v557 + 568) < *(float *)(v557 + 552) || *(_DWORD *)(v557 + 148) == 0;
      v445 = *(float *)(v557 + 404) > 0.15 && *v585 > 0.65;
      v365 = v445;
      if (v610[26] == 3)
        v365 = *v585 > 0.9 || v445;
      if ((v528 & (v444 | v365)) != 1)
      {
LABEL_419:
        learnrate_v4::adaptLmsFilter_v4((uint64_t)v550.realp);
        v364 = *(float *)(v557 + 36);
        v372 = v532;
        v374 = v538;
        v362 = v544;
        v461 = v545;
        goto LABEL_471;
      }
      __Cb = v444;
      v608 = v445;
      v367 = v524;
      a1[2] = v524;
      v366 = (uint64_t)v552;
      a1[4] = (uint64_t)v552;
      learnrate_v4::adaptLmsFilter_v4((uint64_t)v550.realp);
      v364 = *(float *)(v557 + 36);
LABEL_408:
      v327 = v557;
      v446 = v558;
      v448 = *(DSPComplex **)(v558 + 288);
      v447 = *(DSPComplex **)(v558 + 296);
      v449 = (DSPSplitComplex *)(v558 + 256);
      v450 = (DSPSplitComplex *)(v558 + 272);
      *(_QWORD *)(v557 + 576) = 0;
      v451 = *(float *)(v557 + 40) + 1.0e-20;
      *(float *)(v557 + 540) = log10f(v451 / (float)(*(float *)(v557 + 28) + 1.0e-20)) * 10.0;
      *(_DWORD *)(v557 + 548) = 0;
      HIDWORD(v506) = v610[15];
      LODWORD(v510) = *(_DWORD *)(v367 + 36);
      LODWORD(v506) = (_DWORD)v559;
      lmsfilt_v4::runLmsFilter_v4((DSPSplitComplex *)(v558 + 256), (DSPSplitComplex *)(v558 + 272), (DSPSplitComplex *)v610[4], *(_QWORD *)(v367 + 16), *(int **)(v367 + 24), *(_QWORD *)(v617 + 16), *(float **)(v617 + 24), *(float **)(v617 + 88), *(float **)(v367 + 72), v506, v510, *(unsigned __int8 **)(v617 + 128), v513, SHIDWORD(v513), v516, SHIDWORD(v516), v519);
      dft_v5::dftSynthesis(*(float **)(v446 + 272), *(float **)(v446 + 280), (uint64_t)v610);
      aec_v5::get_EchoEst_Err(v448, (float *)v447, (float *)(*(_QWORD *)(v446 + 272) + 4 * v551), (float *)(*(_QWORD *)(v446 + 280) + 4 * v551), *(const float **)(v446 + 96), (uint64_t)v610);
      v452 = v610[4];
      vDSP_svesq((const float *)v447, 1, (float *)(v557 + 512), v452);
      vDSP_svesq((const float *)v448, 1, (float *)(v557 + 564), v452);
      v453 = *(float *)(v557 + 512);
      *(float *)(v557 + 544) = log10f((float)(v453 + 1.0e-20) / (float)(*(float *)(v557 + 28) + 1.0e-20)) * 10.0;
      v454 = log10f((float)(v453 + 1.0e-20) / v451) * -10.0;
      *(float *)(v557 + 596) = v454;
      v455 = *(_DWORD *)(v557 + 40);
      *(float *)(v557 + 40) = v453;
      if (*(_DWORD *)(v557 + 148) == 1)
      {
        v373 = v539;
        if (*(float *)(v557 + 568) <= *(float *)(v557 + 552))
        {
          v552 = (char **)v367;
        }
        else
        {
          if (*(float *)(v557 + 540) >= -20.0 || v454 >= -2.0)
          {
            v552 = (char **)v367;
          }
          else
          {
            *(_DWORD *)(v557 + 580) = 1;
            v457 = v610[12];
            if (v457 <= 1)
              v458 = 1;
            else
              v458 = v610[12];
            v456 = *(_DWORD *)(v617 + 72) - 1;
            LODWORD(v459) = v456
                          + v457
                          + v457
                          * (((v456 & ~(v456 >> 31)) - (v456 + (v456 >> 31))) / v458
                           + (v456 >> 31));
            do
              v459 = (int *)((_DWORD)v459 - v457);
            while ((int)v459 >= v457);
            *(_DWORD *)(v617 + 76) = (_DWORD)v459;
            dft_v3::GetIndexSequence(*(signed int **)(v617 + 88), v459, v610[11], v457);
            HIDWORD(v507) = v610[15];
            LODWORD(v511) = *(_DWORD *)(v367 + 36);
            LODWORD(v507) = (_DWORD)v559;
            lmsfilt_v4::runLmsFilter_v4(v449, v450, (DSPSplitComplex *)v610[4], *(_QWORD *)(v367 + 16), *(int **)(v367 + 24), *(_QWORD *)(v617 + 16), *(float **)(v617 + 24), *(float **)(v617 + 88), *(float **)(v367 + 72), v507, v511, *(unsigned __int8 **)(v617 + 128), v514, SHIDWORD(v514), v517, SHIDWORD(v517), v520);
            dft_v5::dftSynthesis(*(float **)(v558 + 272), *(float **)(v558 + 280), (uint64_t)v610);
            aec_v5::get_EchoEst_Err(v448, (float *)v447, (float *)(*(_QWORD *)(v558 + 272) + 4 * v551), (float *)(*(_QWORD *)(v558 + 280) + 4 * v551), *(const float **)(v558 + 104), (uint64_t)v610);
            LODWORD(__A.realp) = 0;
            vDSP_svesq((const float *)v447, 1, (float *)&__A, v616);
            v460 = log10f((float)(*(float *)&__A.realp + 1.0e-20) / (float)(*(float *)(v557 + 516) + 1.0e-20)) * -10.0;
            *(float *)(v557 + 600) = v460;
            if (v460 >= -0.5)
            {
              v366 = v367;
            }
            else
            {
              *(_DWORD *)(v557 + 576) = 1;
              a1[2] = v366;
              a1[4] = v367;
              *(_DWORD *)(v557 + 40) = v455;
              *(_DWORD *)(v557 + 512) = v455;
            }
            v373 = v539;
            v552 = (char **)v366;
          }
          v327 = v557;
        }
      }
      else
      {
        v552 = (char **)v367;
        v373 = v539;
      }
      *(_DWORD *)(v327 + 584) = 0;
      if (*(_DWORD *)(v327 + 580))
        goto LABEL_427;
      if (__Cb)
      {
        if (*(float *)(v327 + 404) > 0.02 || v610[26] == 3)
          goto LABEL_433;
      }
      else if ((v365 & 1) != 0)
      {
LABEL_433:
        *(_DWORD *)(v327 + 584) = 1;
        v463 = a1[5];
        if (*(_DWORD *)(v327 + 588) == 1)
        {
          *(_DWORD *)(v327 + 588) = 0;
          v464 = v552;
          v465 = 4 * *(_DWORD *)(v463 + 88);
          memcpy(*(void **)v463, *v552, v465);
          memcpy(*(void **)(v463 + 8), v552[1], v465);
          memcpy(*(void **)(v463 + 16), v552[2], v465);
          memcpy(*(void **)(v463 + 24), v552[3], v465);
          memcpy(*(void **)(v463 + 48), v552[6], v465);
          v466 = (float *)v552[9];
          *(_QWORD *)(v463 + 72) = v466;
          v467 = v558;
        }
        else
        {
          v466 = *(float **)(v463 + 72);
          v467 = v558;
          v464 = v552;
        }
        HIDWORD(v508) = v610[15];
        LODWORD(v511) = *((_DWORD *)v464 + 9);
        LODWORD(v508) = (_DWORD)v559;
        lmsfilt_v4::runLmsFilter_v4(v449, v450, (DSPSplitComplex *)v610[4], *(_QWORD *)(v463 + 16), *(int **)(v463 + 24), *(_QWORD *)(v617 + 16), *(float **)(v617 + 24), *(float **)(v617 + 88), v466, v508, v511, *(unsigned __int8 **)(v617 + 128), v514, SHIDWORD(v514), v517, SHIDWORD(v517), v520);
        dft_v5::dftSynthesis(*(float **)(v467 + 272), *(float **)(v467 + 280), (uint64_t)v610);
        aec_v5::get_EchoEst_Err(v448, (float *)v447, (float *)(*(_QWORD *)(v467 + 272) + 4 * v551), (float *)(*(_QWORD *)(v467 + 280) + 4 * v551), *(const float **)(v467 + 96), (uint64_t)v610);
        v468 = (float *)(v327 + 560);
        v469 = v610[4];
        v470 = 1;
        vDSP_svesq((const float *)v447, 1, (float *)(v327 + 520), v469);
        vDSP_svesq((const float *)v448, 1, (float *)(v327 + 560), v469);
        v471 = *(float *)(v327 + 520);
        v472 = v471 + 1.0e-20;
        v473 = log10(v472 / (*(float *)(v327 + 36) + 1.0e-20)) * 10.0;
        *(float *)(v327 + 524) = v473;
        v474 = log10(v472 / (*(float *)(v327 + 220) + 1.0e-20)) * 10.0;
        *(float *)(v327 + 528) = v474;
        *(_DWORD *)(v327 + 548) = 0;
        v475 = 0.0;
        if (v473 >= -1.0)
        {
          v361 = v617;
        }
        else
        {
          if (v474 < -1.0)
          {
            if (*(float *)(v542 + 248) >= 0.0
              || *(float *)(v327 + 536) >= 0.0
              || (float)(*v468 / v24) <= 0.0000001
              || *v468 >= (float)(*(float *)(v327 + 24) * 10.0))
            {
              v470 = 1;
            }
            else
            {
              v470 = 0;
              *(_DWORD *)(v327 + 548) = 1065353216;
              v475 = 1.0;
            }
          }
          v361 = v617;
        }
        if (v610[26] == 3
          && v473 < -0.25
          && v475 == 0.0
          && v474 < -0.25
          && *(float *)(v542 + 248) < 0.0
          && *(float *)(v327 + 536) < 0.0)
        {
          *(_DWORD *)(v327 + 548) = 1065353216;
        }
        else if (v475 != 1.0)
        {
LABEL_455:
          if (v473 <= 4.0)
          {
            learnrate_v4::updateStatistics_echo(v610[4], (const float *)v447, (const float *)v448, (float *)v327);
            dft_v5::dftGenericAnalysis2ndHalf(v447, v550.realp, v550.imagp, (uint64_t)v610, 1);
            dft_v5::dftGenericAnalysis2ndHalf_dsc((const void *)(*(_QWORD *)(v558 + 272) + 4 * v551), (const void *)(*(_QWORD *)(v558 + 280) + 4 * v551), v549, v548, v610);
            v478 = *(float *)(v327 + 144) * 2.5;
            v479 = 0.5;
            v480 = v478 <= 0.5;
            v481 = v478 < 1.0 || v478 <= 0.5;
            if (v478 >= 1.0)
              v480 = 1;
            if (!v481)
              v479 = 1.0;
            if (v480)
              v478 = v479;
            *(float *)(v327 + 140) = fminf(*(float *)(v327 + 140) * 2.5, 1.0);
            *(float *)(v327 + 144) = v478;
            learnrate_v4::getAdaptationRate4_v6(v327);
            learnrate_v4::adaptLmsFilter_v4((uint64_t)v550.realp);
          }
          else if (((v470 | !v608) & 1) == 0)
          {
            v477 = 4 * *(_DWORD *)(v463 + 88);
            memcpy(*(void **)v463, *v552, v477);
            memcpy(*(void **)(v463 + 8), v552[1], v477);
            memcpy(*(void **)(v463 + 16), v552[2], v477);
            memcpy(*(void **)(v463 + 24), v552[3], v477);
            memcpy(*(void **)(v463 + 48), v552[6], v477);
            *(_QWORD *)(v463 + 72) = v552[9];
          }
          v372 = v532;
          v374 = v538;
          v373 = v539;
          goto LABEL_469;
        }
        v476 = (*(float *)(v327 + 560) + 1.0e-13) / (v471 + 1.0e-13);
        *(float *)(v327 + 604) = log10f(v476) * 10.0;
        *(_DWORD *)(v327 + 592) = 1;
        v587 = (float *)v447;
        v581 = (float *)v448;
        v364 = v471;
        goto LABEL_455;
      }
LABEL_427:
      *(_DWORD *)(v327 + 588) = 1;
      v361 = v617;
      v372 = v532;
      v374 = v538;
LABEL_469:
      v362 = v544;
      goto LABEL_470;
    }
    if ((int)v369 <= 1)
    {
      v384 = 0;
      v387 = *v375;
    }
    else
    {
      v384 = 0;
      v385 = *v368;
      for (j = 1; j != v369; ++j)
      {
        if (v368[j] >= v385)
        {
          v384 = j;
          v385 = v368[j];
        }
      }
      v387 = v375[v384];
      v388 = v384 - 1;
      if (v384 >= 1)
      {
        v389 = v375[v388];
        if (v384 == 1)
        {
          v384 = 1;
          v462 = v375[v388];
        }
        else
        {
          v462 = v375[v384 - 2];
        }
        goto LABEL_334;
      }
    }
    v389 = v387;
    v462 = v387;
LABEL_334:
    v390 = &v375[v384];
    v391 = v387;
    if (v384 < (int)v370 - 1)
      v391 = v390[1];
    v392 = v391;
    if (v384 < (int)v370 - 2)
      v392 = v390[2];
    v393 = vabds_f32(v462, v389);
    v394 = vabds_f32(v389, v387);
    v395 = vabds_f32(v387, v391);
    v396 = vabds_f32(v391, v392);
    v397 = vabds_f32(v391, v389);
    v398 = vabds_f32(v462, v387);
    if (vabds_f32(v387, v392) <= 10.0
      && v398 <= 10.0
      && v397 <= 10.0
      && v396 <= 8.0
      && v395 <= 8.0
      && v394 <= 8.0
      && v393 <= 8.0)
    {
      __nb = v383;
      v609 = v379;
      __Cc = v376;
      v535 = v380;
      v547 = v370;
      v541 = v378;
      __Bb = v368;
      LODWORD(v624.realp) = 0;
      v405 = *((_DWORD *)v552 + 18);
      __lenc = v405;
      __Dd = *((_DWORD *)v552 + 19);
      v596 = v405;
      v406 = v381;
      if (*((_DWORD *)v552 + 17) == 1 && (int)v559 >= 1)
      {
        v407 = 0;
        v408 = 4 * (_QWORD)v370;
        v409 = ((_DWORD)v370 - (__Dd + 1));
        v410 = v381 + 4 * (__Dd + 1);
        v411 = (int)v559;
        v412 = &v368[__Dd + 1];
        do
        {
          if (v405 >= 1)
          {
            vDSP_vfill((const float *)&v624, (float *)((char *)__Bb + v407), 1, v596);
            v405 = v596;
            vDSP_vfill((const float *)&v624, (float *)(v406 + v407), 1, v596);
          }
          if ((int)v409 >= 1)
          {
            vDSP_vfill((const float *)&v624, (float *)((char *)v412 + v407), 1, v409);
            vDSP_vfill((const float *)&v624, (float *)(v410 + v407), 1, v409);
          }
          v407 += v408;
          --v411;
        }
        while (v411);
      }
      v413 = v24;
      v414 = *v552;
      v415 = v552[1];
      ++learnrate_v4::adjustProp_v4(float *,float *,float *,float *,LMS_FILTER4 *,float *,int,float,int,int,int,float,int,int,float *,BOOL *,int)::count;
      v416 = 0.0;
      v417 = 0.0;
      v418 = __lenc;
      if ((int)v559 >= 1)
      {
        v419 = 0;
        v420 = v541 + 4 * __lenc;
        v421 = v406 + 4 * __lenc;
        __nc = 4 * __nb;
        v573 = 4 * (_QWORD)v547;
        do
        {
          if ((int)v418 <= __Dd)
          {
            v422 = 0;
            v423 = 4 * (int)__lenc * (int)__Cc;
            do
            {
              vDSP_svesq((const float *)&v414[v423], 1, (float *)&__A, __Cc);
              vDSP_svesq((const float *)&v415[v423], 1, (float *)&__Z, __Cc);
              v424 = *(float *)&__A.realp + *(float *)&__Z.realp;
              *(float *)(v421 + 4 * v422) = (float)(*(float *)&__A.realp + *(float *)&__Z.realp) + 1.0e-20;
              v425 = sqrtf((float)(1.0 / (float)(int)__Cc) * v424) + 0.02;
              *(float *)(v420 + 4 * v422) = v425;
              if (!v419)
              {
                v417 = v417 + (float)((float)((int)v596 + v422) * v424);
                *(float *)&v624.realp = v424 + *(float *)&v624.realp;
              }
              if (!*((_BYTE *)v419 + v609))
                v425 = -0.0;
              v416 = v416 + v425;
              ++v422;
              v423 += 4 * __Cc;
            }
            while ((_DWORD)v596 + ~__Dd + (_DWORD)v422);
          }
          v419 = (float *)((char *)v419 + 1);
          v418 = __lenc;
          v420 += v573;
          v421 += v573;
          v415 += __nc;
          v414 += __nc;
        }
        while (v419 != v559);
      }
      v426 = *(float *)&v624.realp;
      *a2 = v624.realp;
      v427 = (float)((float)((float)(int)v547 + -0.5) - (float)(v417 * (float)(1.0 / (float)(v426 + 1.0e-20)))) * v382;
      if (v427 < 0.0)
        v427 = 0.0;
      *a3 = v427;
      v361 = v617;
      v327 = v557;
      v24 = v413;
      v428 = __Bb;
      v429 = v541;
      if ((int)v559 >= 1)
      {
        v430 = 0;
        v431 = 4 * (_QWORD)v547;
        do
        {
          if ((int)v418 <= __Dd)
          {
            v432 = v418;
            v433 = __Dd - v596 + 1;
            do
            {
              v428[v432] = (float)((float)(1.0 - v371) / (float)((float)(v535 * (int)v547) + (float)(v535 * (int)v547)))
                         + (float)((float)((float)(v371 + 1.0) / (float)(v416 + v416)) * *(float *)(v429 + v432 * 4));
              ++v432;
              --v433;
            }
            while (v433);
          }
          ++v430;
          v428 = (float *)((char *)v428 + v431);
          v429 += v431;
        }
        while (v430 != (_DWORD)v559);
      }
    }
    goto LABEL_384;
  }
  v364 = *(float *)(v557 + 36);
  if (v528)
  {
    v608 = 0;
    LOBYTE(v365) = 0;
    __Cb = 0;
    v366 = v524;
    v367 = (uint64_t)v552;
    goto LABEL_408;
  }
  v372 = v532;
  v374 = v538;
  v373 = v539;
LABEL_470:
  v461 = v545;
  v443 = v587;
LABEL_471:
  v482 = *v461;
  v483 = *v461 * 3.0;
  if (v364 > v483)
    v443 = *(float **)(v558 + 96);
  if (v610[31] >= 1)
  {
    if (*(float *)(v327 + 40) <= v483
      || *(float *)(v327 + 604) <= -3.0
      || *(float *)(v327 + 16) <= -70.0
      || (v484 = *(float *)(v327 + 24), v484 <= (float)(v482 * 8.0))
      || (float)(v204 / v24) <= 0.00000001
      || *(int *)(v327 + 624) < 2)
    {
      *(_QWORD *)(v327 + 616) = 0;
    }
    else
    {
      v485 = *((float *)v610 + 6);
      v486 = v485 + *(float *)(v327 + 616);
      *(float *)(v327 + 616) = v486;
      if (v484 > (float)(v482 * 32.0))
        *(float *)(v327 + 620) = v485 + *(float *)(v327 + 620);
      if (v486 > 100.0)
      {
        LODWORD(__A.realp) = 1056964608;
        if (*(float *)(v327 + 620) > 100.0)
          LODWORD(__A.realp) = 1048576000;
        v487 = (const float **)v552;
        v488 = *((int *)v552 + 22);
        vDSP_vsmul((const float *)*v552, 1, (const float *)&__A, (float *)*v552, 1, v488);
        vDSP_vsmul(v487[1], 1, (const float *)&__A, (float *)v487[1], 1, v488);
        vDSP_vsmul(v487[2], 1, (const float *)&__A, (float *)v487[2], 1, v488);
        vDSP_vsmul(v487[3], 1, (const float *)&__A, (float *)v487[3], 1, v488);
        vDSP_vsmul(v487[6], 1, (const float *)&__A, (float *)v487[6], 1, v488);
        *(_QWORD *)(v327 + 616) = 0;
        v373 = v539;
      }
    }
  }
  *v373 = *v581 + (float)(*(float *)(v374 + 16) * 0.9);
  *v372 = *v443 + (float)(*(float *)(v374 + 12) * 0.9);
  if ((int)v362 > 1)
  {
    v489 = v362 - 1;
    v490 = v581 + 1;
    v491 = v443 + 1;
    v492 = v373 + 1;
    v493 = v372 + 1;
    do
    {
      v494 = *v490++;
      *v492 = v494 + (float)(*(v492 - 1) * 0.9);
      ++v492;
      v495 = *v491++;
      *v493 = v495 + (float)(*(v493 - 1) * 0.9);
      ++v493;
      --v489;
    }
    while (v489);
  }
  *(float *)(v374 + 16) = v373[(int)v362 - 1];
  *(float *)(v374 + 12) = v372[(int)v362 - 1];
  *v536 = *(_DWORD *)(v327 + 148);
  *a5 = *(_DWORD *)(v327 + 376);
  *a9 = *(_DWORD *)(v327 + 604);
  *a12 = *(_DWORD *)(v327 + 140);
  v497 = v610[12];
  if (v497 <= 1)
    v498 = 1;
  else
    v498 = v610[12];
  v496 = *(_DWORD *)(v361 + 72) + 1;
  v499 = v496
       + v497
       + v497 * (((v496 & ~(v496 >> 31)) - (v496 + (v496 >> 31))) / v498 + (v496 >> 31));
  do
    v499 -= v497;
  while (v499 >= (int)v497);
  *(_DWORD *)(v361 + 72) = v499;
  v500 = *(_DWORD *)(v361 + 80);
  v501 = v500 + 1;
  v502 = (((v500 + 1) & ~((v500 + 1) >> 31))
        - (v500
         + 1
         + ((v500 + 1) >> 31))
        + 2 * ((v500 + 1) >> 31)) & 0xFFFFFFFE;
  v503 = v500 + v502;
  v504 = v502 + v501;
  if (v504 >= 1)
    v504 = 1;
  *(_DWORD *)(v361 + 80) = v503 - ((v503 - v504 + 2) & 0xFFFFFFFE) + 1;
}

void AUMozartCompressorSingleBand::~AUMozartCompressorSingleBand(AUMozartCompressorSingleBand *this)
{
  AUDspLib::~AUDspLib(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AUMozartCompressorSingleBand::Reset(AUMozartCompressorSingleBand *this)
{
  caulk::pooled_semaphore_mutex *v2;
  uint64_t v3;
  char *v4;
  DspLib::MozartCompressor::Algorithm *v5;

  if (*((_BYTE *)this + 17))
  {
    v2 = (AUMozartCompressorSingleBand *)((char *)this + 1824);
    caulk::pooled_semaphore_mutex::_lock((AUMozartCompressorSingleBand *)((char *)this + 1824));
    v3 = 0;
    v4 = (char *)this + 528;
    do
    {
      v5 = *(DspLib::MozartCompressor::Algorithm **)&v4[v3];
      if (v5)
        DspLib::MozartCompressor::Algorithm::clearAudioBuffers(v5);
      v3 += 56;
    }
    while (v3 != 1008);
    caulk::pooled_semaphore_mutex::_unlock(v2);
  }
  return 0;
}

void sub_1B6580020(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex *v1;

  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUMozartCompressorSingleBand::GetPropertyInfo(AUMozartCompressorSingleBand *this, int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if (a2 != 6625 || a3 != 0)
    return AUDspLib::GetPropertyInfo(this, a2, a3, a4, a5, a6);
  *a6 = 1;
  *a5 = 4;
  return 0;
}

uint64_t AUMozartCompressorSingleBand::GetProperty(AUMozartCompressorSingleBand *this, int a2, unsigned int a3, unsigned int a4, CFDictionaryRef *a5, int *a6)
{
  uint64_t v8;

  if (a2 != 6625 || a3 != 0)
    return AUDspLib::GetProperty(this, a2, a3, a4, a5, a6);
  v8 = *((_QWORD *)this + 66);
  if (v8)
    LODWORD(v8) = *(_DWORD *)(v8 + 1228);
  *(_DWORD *)a5 = v8;
  return 0;
}

uint64_t AUMozartCompressorSingleBand::SetProperty(AUMozartCompressorSingleBand *this, int a2, int a3, unsigned int a4, int *a5, void *a6, int *a7)
{
  uint64_t v9;
  unsigned int v10;
  char *v11;
  DspLib::MozartCompressor::Algorithm *v12;

  if (a2 != 6625 || a3 != 0)
    return AUDspLib::SetProperty(this, a2, a3, a4, a5, a6, a7);
  v9 = 0;
  v10 = *a5;
  v11 = (char *)this + 528;
  do
  {
    v12 = *(DspLib::MozartCompressor::Algorithm **)&v11[v9];
    if (v12)
      DspLib::MozartCompressor::Algorithm::setExcludeChannelMask(v12, v10);
    v9 += 56;
  }
  while (v9 != 1008);
  return 0;
}

uint64_t AUMozartCompressorSingleBand::SupportedNumChannels(AUMozartCompressorSingleBand *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUMozartCompressorSingleBand::SupportedNumChannels(AUChannelInfo const**)::kSupportedNumChannels;
  return 32;
}

uint64_t AUMozartCompressorSingleBand::Version(AUMozartCompressorSingleBand *this)
{
  return 131844;
}

DspLib::MozartCompressor::Algorithm *AUMozartCompressorSingleBand::newDspLibAlgorithm(AUMozartCompressorSingleBand *this)
{
  DspLib::MozartCompressor::Algorithm *v1;

  v1 = (DspLib::MozartCompressor::Algorithm *)operator new();
  DspLib::MozartCompressor::Algorithm::Algorithm(v1);
  return v1;
}

void sub_1B6580150(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10E1C4023950F3FLL);
  _Unwind_Resume(a1);
}

void SoundIsolationGraphAdapter::CreateProcessingAUs(std::string *this, std::vector<std::string> *a2, int a3, uint64_t a4, int a5, unsigned int a6, int a7, uint64_t a8, int a9, int a10)
{
  std::string *v12;
  unsigned int v13;
  NSObject *v14;
  std::vector<std::string>::size_type v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  NSObject *v20;
  std::string *v21;
  std::string::size_type v22;
  char v23;
  std::vector<std::string>::pointer begin;
  int v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  std::vector<std::string> *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  std::string *v35;
  std::string::size_type v36;
  char v37;
  std::string *v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  NSObject *v43;
  std::string *v44;
  std::string *v46;
  _BYTE __p[32];
  _BYTE v48[12];
  std::string __str;
  uint64_t v50;

  v12 = this;
  v50 = *MEMORY[0x1E0C80C00];
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    *this = *(std::string *)a4;
  if ((*(_BYTE *)(a8 + 12) & 0x20) != 0)
    v13 = *(_DWORD *)(a8 + 28);
  else
    v13 = 1;
  v46 = v12;
  if (a10 != 1)
  {
    if (getAUSoundIsolationLog(void)::onceToken != -1)
      dispatch_once(&getAUSoundIsolationLog(void)::onceToken, &__block_literal_global_23570);
    v20 = getAUSoundIsolationLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSoundIsolationLog(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__p = 136316418;
      *(_QWORD *)&__p[4] = "SoundIsolationGraphAdapter.cpp";
      *(_WORD *)&__p[12] = 1024;
      *(_DWORD *)&__p[14] = 304;
      *(_WORD *)&__p[18] = 1024;
      *(_DWORD *)&__p[20] = a10;
      *(_WORD *)&__p[24] = 1024;
      *(_DWORD *)&__p[26] = a6;
      *(_WORD *)&__p[30] = 1024;
      *(_DWORD *)v48 = v13;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = a9;
      _os_log_debug_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_DEBUG, "%s:%i processing AUs: minibatch version (minibatch > 1) (batch size %u, numIOchannels %u, numInternalIOchannels %u, and block size %u)", __p, 0x2Au);
    }
    std::vector<std::string>::resize(a2 + 1, 1uLL);
    std::to_string((std::string *)__p, 0);
    v21 = std::string::insert((std::string *)__p, 0, "processingAU_", 0xDuLL);
    v22 = v21->__r_.__value_.__r.__words[0];
    __str.__r_.__value_.__r.__words[0] = v21->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v21->__r_.__value_.__r.__words[1] + 7);
    v23 = HIBYTE(v21->__r_.__value_.__r.__words[2]);
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    begin = a2[1].__begin_;
    if (SHIBYTE(begin->__r_.__value_.__r.__words[2]) < 0)
      operator delete(begin->__r_.__value_.__l.__data_);
    begin->__r_.__value_.__r.__words[0] = v22;
    begin->__r_.__value_.__l.__size_ = __str.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&begin->__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
    *((_BYTE *)&begin->__r_.__value_.__s + 23) = v23;
    if ((__p[23] & 0x80000000) != 0)
      operator delete(*(void **)__p);
    v12 = v46;
    DSPGraph::Graph::add();
    v25 = *(_DWORD *)(a8 + 12);
    v26 = *(_QWORD *)(a8 + 32);
    if ((v25 & 0x20) != 0)
    {
      v27 = 1;
    }
    else
    {
      v27 = *(_DWORD *)(a8 + 28);
      if (!v27)
      {
        v28 = (v26 + 7) >> 3;
LABEL_33:
        if ((v25 & 0x20) != 0)
          v29 = 1;
        else
          v29 = a6;
        *(_QWORD *)__p = *(_QWORD *)a8;
        *(_DWORD *)&__p[8] = *(_DWORD *)(a8 + 8);
        *(_DWORD *)&__p[12] = v25;
        *(_DWORD *)&__p[16] = v28 * v29;
        *(_DWORD *)&__p[20] = 1;
        *(_DWORD *)&__p[24] = v28 * v29;
        *(_DWORD *)&__p[28] = a6;
        *(_QWORD *)v48 = v26;
        *(_DWORD *)&v48[8] = a9;
        DSPGraph::Graph::connect();
        std::string::operator=(v46, a2[1].__begin_);
        goto LABEL_62;
      }
    }
    v28 = *(_DWORD *)(a8 + 24) / v27;
    goto LABEL_33;
  }
  if (getAUSoundIsolationLog(void)::onceToken != -1)
    dispatch_once(&getAUSoundIsolationLog(void)::onceToken, &__block_literal_global_23570);
  v14 = getAUSoundIsolationLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSoundIsolationLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__p = 136316418;
    *(_QWORD *)&__p[4] = "SoundIsolationGraphAdapter.cpp";
    *(_WORD *)&__p[12] = 1024;
    *(_DWORD *)&__p[14] = 261;
    *(_WORD *)&__p[18] = 1024;
    *(_DWORD *)&__p[20] = 1;
    *(_WORD *)&__p[24] = 1024;
    *(_DWORD *)&__p[26] = a6;
    *(_WORD *)&__p[30] = 1024;
    *(_DWORD *)v48 = v13;
    *(_WORD *)&v48[4] = 1024;
    *(_DWORD *)&v48[6] = a9;
    _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "%s:%i processing AUs: default (minibatch = 1) (batch size %u, numIOchannels %u, numInternalIOchannels %u, and block size %u)", __p, 0x2Au);
  }
  if (v13 != 1 && v13 != a6)
    __assert_rtn("CreateProcessingAUs", "SoundIsolationGraphAdapter.cpp", 264, "(numInternalIOChannels == 1 || numInternalIOChannels == numIOChannels) && \"number of internal IO channels must be equal to one or the same number of IO channels (when internal batch size = 1)\"");
  v15 = a6 / v13;
  if (v15 <= 1)
    goto LABEL_44;
  std::string::basic_string[abi:ne180100]<0>(&__str, "inputSplitter");
  std::string::basic_string[abi:ne180100]<0>(__p, "split");
  DSPGraph::NewBoxRegistry::newBox();
  DSPGraph::Graph::add();
  if ((__p[23] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  v16 = *(_DWORD *)(a8 + 12);
  v17 = *(_QWORD *)(a8 + 32);
  if ((v16 & 0x20) != 0)
  {
    v18 = 1;
  }
  else
  {
    v18 = *(_DWORD *)(a8 + 28);
    if (!v18)
    {
      v19 = (v17 + 7) >> 3;
      goto LABEL_39;
    }
  }
  v19 = *(_DWORD *)(a8 + 24) / v18;
LABEL_39:
  if ((v16 & 0x20) != 0)
    v30 = 1;
  else
    v30 = a6;
  *(_QWORD *)__p = *(_QWORD *)a8;
  *(_DWORD *)&__p[8] = *(_DWORD *)(a8 + 8);
  *(_DWORD *)&__p[12] = v16;
  *(_DWORD *)&__p[16] = v19 * v30;
  *(_DWORD *)&__p[20] = 1;
  *(_DWORD *)&__p[24] = v19 * v30;
  *(_DWORD *)&__p[28] = a6;
  *(_QWORD *)v48 = v17;
  *(_DWORD *)&v48[8] = a9;
  DSPGraph::Graph::connect();
  std::string::operator=(v12, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
LABEL_44:
  v31 = a2 + 1;
  std::vector<std::string>::resize(v31, v15);
  if (v13 <= a6)
  {
    v32 = 0;
    v33 = 0;
    if (v15 <= 1)
      v34 = 1;
    else
      v34 = v15;
    do
    {
      std::to_string((std::string *)__p, v33);
      v35 = std::string::insert((std::string *)__p, 0, "processingAU_", 0xDuLL);
      v36 = v35->__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = v35->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v35->__r_.__value_.__r.__words[1] + 7);
      v37 = HIBYTE(v35->__r_.__value_.__r.__words[2]);
      v35->__r_.__value_.__l.__size_ = 0;
      v35->__r_.__value_.__r.__words[2] = 0;
      v35->__r_.__value_.__r.__words[0] = 0;
      v38 = &v31->__begin_[v32];
      if (SHIBYTE(v38->__r_.__value_.__r.__words[2]) < 0)
        operator delete(v38->__r_.__value_.__l.__data_);
      v38->__r_.__value_.__r.__words[0] = v36;
      v38->__r_.__value_.__l.__size_ = __str.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
      *((_BYTE *)&v38->__r_.__value_.__s + 23) = v37;
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
      v12 = v46;
      DSPGraph::Graph::add();
      v39 = *(_OWORD *)(a8 + 16);
      *(_OWORD *)__p = *(_OWORD *)a8;
      *(_OWORD *)&__p[16] = v39;
      *(_QWORD *)v48 = *(_QWORD *)(a8 + 32);
      *(_DWORD *)&v48[8] = a9;
      DSPGraph::Graph::connect();
      ++v33;
      ++v32;
    }
    while (v34 != v33);
  }
  if (a6 / v13 == 1)
  {
    std::string::operator=(v12, v31->__begin_);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&__str, "outputJoiner");
    std::string::basic_string[abi:ne180100]<0>(__p, "join");
    DSPGraph::NewBoxRegistry::newBox();
    DSPGraph::Graph::add();
    if ((__p[23] & 0x80000000) != 0)
      operator delete(*(void **)__p);
    if (a6)
    {
      v40 = 0;
      v41 = 0;
      do
      {
        v42 = *(_OWORD *)(a8 + 16);
        *(_OWORD *)__p = *(_OWORD *)a8;
        *(_OWORD *)&__p[16] = v42;
        *(_QWORD *)v48 = *(_QWORD *)(a8 + 32);
        *(_DWORD *)&v48[8] = a9;
        DSPGraph::Graph::connect();
        ++v41;
        v40 += 24;
      }
      while (a6 != v41);
    }
    std::string::operator=(v12, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
  }
LABEL_62:
  if (getAUSoundIsolationLog(void)::onceToken != -1)
    dispatch_once(&getAUSoundIsolationLog(void)::onceToken, &__block_literal_global_23570);
  v43 = getAUSoundIsolationLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSoundIsolationLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    if ((v12->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v44 = v12;
    else
      v44 = (std::string *)v12->__r_.__value_.__r.__words[0];
    *(_DWORD *)__p = 136315650;
    *(_QWORD *)&__p[4] = "SoundIsolationGraphAdapter.cpp";
    *(_WORD *)&__p[12] = 1024;
    *(_DWORD *)&__p[14] = 322;
    *(_WORD *)&__p[18] = 2080;
    *(_QWORD *)&__p[20] = v44;
    _os_log_debug_impl(&dword_1B5ED0000, v43, OS_LOG_TYPE_DEBUG, "%s:%i processing section output: %s", __p, 0x1Cu);
  }
}

void sub_1B65808E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0)
    operator delete(__p);
  if (*(char *)(a13 + 23) < 0)
    operator delete(*(void **)a13);
  _Unwind_Resume(exception_object);
}

os_log_t ___Z22getAUSoundIsolationLogv_block_invoke_23577()
{
  os_log_t result;

  result = os_log_create("com.apple.coreaudio", "AUSoundIsolation");
  getAUSoundIsolationLog(void)::gLog = (uint64_t)result;
  return result;
}

void AUMultiBandDynamicsProcessorV2::~AUMultiBandDynamicsProcessorV2(AUMultiBandDynamicsProcessorV2 *this)
{
  AUMultiBandDynamicsProcessorV2::~AUMultiBandDynamicsProcessorV2(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  AudioBufferList **v2;
  OSStatus v3;
  uint64_t i;
  uint64_t v5;
  char *v6;
  OpaqueAudioComponentInstance *v7;
  void *v8;
  void *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t j;
  char *v15;
  _BYTE *v16;
  _BYTE *v17;
  _QWORD *v18;
  uint64_t k;
  char *v20;
  _BYTE *v21;
  _BYTE *v22;
  _QWORD *v23;
  void **v24;

  *(_QWORD *)this = &off_1E69EC848;
  *((_QWORD *)this + 172) = *((_QWORD *)this + 171);
  *((_QWORD *)this + 175) = *((_QWORD *)this + 174);
  AUMultiBandDynamicsProcessorV2::UnInitializeUnderlyingAUs(this);
  AUMultiBandDynamicsProcessorV2::DeAllocateIntermediateBuffer((unsigned int **)this + 110, v2);
  v3 = 0;
  for (i = 816; i != 848; i += 8)
  {
    if (*(_QWORD *)((char *)this + i))
    {
      v3 = AudioComponentInstanceDispose(*(AudioComponentInstance *)((char *)this + i));
      *(_QWORD *)((char *)this + i) = 0;
    }
  }
  if (!v3)
  {
    v5 = 0;
    v6 = (char *)this + 688;
    do
    {
      if (*(_QWORD *)&v6[v5])
      {
        v3 = AudioComponentInstanceDispose(*(AudioComponentInstance *)&v6[v5]);
        *(_QWORD *)&v6[v5] = 0;
      }
      v5 += 8;
    }
    while (v5 != 128);
    if (!v3)
    {
      v7 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 106);
      if (v7)
      {
        AudioComponentInstanceDispose(v7);
        *((_QWORD *)this + 106) = 0;
      }
    }
  }
  v8 = (void *)*((_QWORD *)this + 174);
  if (v8)
  {
    *((_QWORD *)this + 175) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 171);
  if (v9)
  {
    *((_QWORD *)this + 172) = v9;
    operator delete(v9);
  }
  v24 = (void **)((char *)this + 1336);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v24);
  v10 = (_BYTE *)*((_QWORD *)this + 153);
  if (v10)
  {
    v11 = (_BYTE *)*((_QWORD *)this + 154);
    if (v11 != v10)
      *((_QWORD *)this + 154) = &v11[(v10 - v11 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    operator delete(v10);
    *((_QWORD *)this + 153) = 0;
    *((_QWORD *)this + 154) = 0;
  }
  v12 = (_BYTE *)*((_QWORD *)this + 148);
  if (v12)
  {
    v13 = (_BYTE *)*((_QWORD *)this + 149);
    if (v13 != v12)
      *((_QWORD *)this + 149) = &v13[(v12 - v13 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    operator delete(v12);
    *((_QWORD *)this + 148) = 0;
    *((_QWORD *)this + 149) = 0;
  }
  for (j = 0; j != -128; j -= 16)
  {
    v15 = (char *)this + j;
    v16 = *(_BYTE **)((char *)this + j + 1144);
    if (v16)
    {
      v17 = (_BYTE *)*((_QWORD *)v15 + 144);
      if (v17 != v16)
        *((_QWORD *)v15 + 144) = &v17[(v16 - v17 + 3) & 0xFFFFFFFFFFFFFFFCLL];
      v18 = v15 + 1144;
      operator delete(v16);
      *v18 = 0;
      v18[1] = 0;
    }
  }
  for (k = 0; k != -128; k -= 16)
  {
    v20 = (char *)this + k;
    v21 = *(_BYTE **)((char *)this + k + 1016);
    if (v21)
    {
      v22 = (_BYTE *)*((_QWORD *)v20 + 128);
      if (v22 != v21)
        *((_QWORD *)v20 + 128) = &v22[(v21 - v22 + 3) & 0xFFFFFFFFFFFFFFFCLL];
      v23 = v20 + 1016;
      operator delete(v21);
      *v23 = 0;
      v23[1] = 0;
    }
  }
  CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set((_QWORD *)this + 112, 0);
  CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set((_QWORD *)this + 111, 0);
  ausdk::AUBase::~AUBase(this);
}

const void **AUMultiBandDynamicsProcessorV2::CreateExtendedElements(AUMultiBandDynamicsProcessorV2 *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  ausdk::AUScope::Initialize((int64x2_t *)((char *)this + 1320), this, 4, 2);
  v2 = *((_QWORD *)this + 170);
  if (v2)
  {
    v3 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v4 = (uint64_t *)*((_QWORD *)this + 167);
    if (*((uint64_t **)this + 168) == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  ausdk::Owned<__CFString const*>::operator=((const void **)(v3 + 72), CFSTR("Left/Mono Speaker Settings"));
  v5 = *((_QWORD *)this + 170);
  if (v5)
  {
    v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 32))(v5, 1);
  }
  else
  {
    v7 = *((_QWORD *)this + 167);
    if ((unint64_t)(*((_QWORD *)this + 168) - v7) < 9)
      v6 = 0;
    else
      v6 = *(_QWORD *)(v7 + 8);
  }
  return ausdk::Owned<__CFString const*>::operator=((const void **)(v6 + 72), CFSTR("Right Speaker Settings"));
}

uint64_t AUMultiBandDynamicsProcessorV2::Initialize(AUMultiBandDynamicsProcessorV2 *this)
{
  uint64_t Element;
  uint64_t v3;
  const AudioStreamBasicDescription *v4;
  int32x2_t *v5;
  unsigned int v6;
  unsigned int v7;
  __int128 v10;
  __int128 v11;
  unsigned int AppIntegerValue;
  unsigned int v13;
  uint64_t result;
  _DWORD *v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  float Parameter;
  double v20;
  double mSampleRate;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  ausdk::AUElement *v29;
  unsigned int v30;
  ausdk::AUElement **v31;
  float v32;
  unsigned int v33;
  BOOL v34;
  int v35;
  _BYTE *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  int v47;
  void *v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  int v55;
  void *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  double v63;
  unint64_t v64;
  unint64_t v65;
  char *v66;
  _QWORD *v67;
  int v68;
  uint64_t v69;
  AudioBufferList **v70;
  uint64_t v71;
  int v72;
  _DWORD *v73;
  _DWORD *v74;
  uint64_t v75;
  size_t v76;
  void *v77;
  void *v78;
  uint64_t v79;
  _BOOL4 AppBooleanValue;
  double v81;
  float v82;
  uint64_t i;
  uint64_t j;
  uint64_t v85;
  ausdk::AUElement *v86;
  float v87;
  ausdk::AUElement **v88;
  float v89;
  uint64_t v90;
  __int128 v91;
  uint64_t v92;
  OpaqueAudioComponentInstance *v93;
  uint64_t v94;
  OpaqueAudioComponentInstance *v95;
  uint64_t v96;
  OpaqueAudioComponentInstance *v97;
  __int128 v98;
  char v99;
  uint64_t v100;
  ausdk::AUElement *v101;
  ausdk::AUElement **v102;
  uint64_t v103;
  ausdk::AUElement *v104;
  ausdk::AUElement **v105;
  std::bad_alloc *exception;
  std::bad_alloc *v107;
  unsigned int v108;
  BOOL v109[16];
  __int128 v110;
  uint64_t v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;

  Element = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 80), 0);
  v3 = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
  v4 = (const AudioStreamBasicDescription *)(v3 + 80);
  if (*(double *)(Element + 80) != *(double *)(v3 + 80))
    return 4294956428;
  v5 = (int32x2_t *)v3;
  v6 = *(_DWORD *)(Element + 108);
  v7 = *(_DWORD *)(v3 + 108);
  if (v6 >= 2 && v6 != v7)
    return 4294956428;
  if (v6 == 1 && v7 > 2)
    return 4294956428;
  v10 = *(_OWORD *)(Element + 96);
  v112 = *(_OWORD *)(Element + 80);
  v113 = v10;
  v114 = *(_QWORD *)(Element + 112);
  v11 = *(_OWORD *)(v3 + 96);
  *(_OWORD *)v109 = *(_OWORD *)&v4->mSampleRate;
  v110 = v11;
  v111 = *(_QWORD *)(v3 + 112);
  SimpleMeters::Initialize((AUMultiBandDynamicsProcessorV2 *)((char *)this + 1368), (const CAStreamBasicDescription *)&v112, (const CAStreamBasicDescription *)v109);
  *((_DWORD *)this + 318) = AUMultiBandDynamicsProcessorV2::DetermineBandsToProcess(this);
  v109[0] = 0;
  AppIntegerValue = CACFPreferencesGetAppIntegerValue(CFSTR("mbdp_max_bands"), CFSTR("com.apple.coreaudio"), v109);
  if (v109[0])
  {
    v13 = *((_DWORD *)this + 318);
    if (v13 < AppIntegerValue)
    {
      *((_DWORD *)this + 318) = AppIntegerValue;
      v13 = AppIntegerValue;
    }
  }
  else
  {
    v13 = *((_DWORD *)this + 318);
  }
  if (v13 <= *((_DWORD *)this + 137))
    v13 = *((_DWORD *)this + 137);
  if (v13 >= 4)
    v13 = 4;
  *((_DWORD *)this + 138) = v13;
  v15 = (_DWORD *)((char *)this + 1244);
  *(int32x2_t *)((char *)this + 1244) = vrev64_s32(v5[13]);
  v16 = *((_QWORD *)this + 9);
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  Parameter = ausdk::AUElement::GetParameter(v17, 0xDDu);
  if (*((_DWORD *)this + 215) && *((_BYTE *)this + 376))
  {
    v20 = Parameter;
    mSampleRate = v4->mSampleRate;
    v22 = llround(v4->mSampleRate * v20 / 1000.0);
    v23 = (v22 + (v22 < 0 ? 3 : 0)) & 0xFFFFFFFC;
    v24 = *((_DWORD *)this + 84);
    do
    {
      v25 = v24;
      v24 /= 2;
      v26 = v24 - v23;
      if ((int)(v24 - v23) < 0)
        v26 = v23 - v24;
      v27 = v25 - v23;
      if ((int)(v25 - v23) < 0)
        v27 = v23 - v25;
    }
    while (v26 < v27);
    *((_DWORD *)this + 313) = v25;
    v28 = *((_QWORD *)this + 9);
    if (v28)
    {
      v29 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 32))(v28, 0);
      mSampleRate = v4->mSampleRate;
    }
    else
    {
      v31 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v31)
        v29 = 0;
      else
        v29 = *v31;
    }
    v32 = (float)v25 * 1000.0 / mSampleRate;
    ausdk::AUElement::SetParameter(v29, 0xDDu, v32, 0);
    v30 = *((_DWORD *)this + 313);
  }
  else
  {
    v30 = vcvtad_u64_f64(v4->mSampleRate * Parameter / 1000.0);
  }
  v33 = v30 & 0xFFFFFFFC;
  *((_DWORD *)this + 313) = v30 & 0xFFFFFFFC;
  v34 = *((_BYTE *)this + 376) != 0;
  if (*((_BYTE *)this + 376))
  {
    v35 = *((_DWORD *)this + 84) % v33;
    v36 = (char *)this + 1256;
    *((_BYTE *)this + 1256) = v35 == 0;
    if (!v35)
      v34 = 0;
  }
  else
  {
    v36 = (char *)this + 1256;
    *((_BYTE *)this + 1256) = 0;
  }
  *((_BYTE *)this + 1257) = v34;
  v37 = operator new();
  *(_DWORD *)v37 = 0;
  *(_QWORD *)(v37 + 8) = 0;
  *(_QWORD *)(v37 + 16) = 0;
  CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set((_QWORD *)this + 112, v37);
  ausdk::AUBufferList::Allocate(*((ausdk::AUBufferList **)this + 112), v4, *((_DWORD *)this + 313));
  if (*((_DWORD *)this + 138) >= 3u)
  {
    v39 = operator new();
    *(_DWORD *)v39 = 0;
    *(_QWORD *)(v39 + 8) = 0;
    *(_QWORD *)(v39 + 16) = 0;
    CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set((_QWORD *)this + 111, v39);
    ausdk::AUBufferList::Allocate(*((ausdk::AUBufferList **)this + 111), v4, *((_DWORD *)this + 313));
  }
  if (!*v36)
  {
    v40 = *((_DWORD *)this + 313);
    if (!*((_BYTE *)this + 1257))
      goto LABEL_72;
    v41 = *((_DWORD *)this + 84);
    if (v40)
    {
      v42 = *((_DWORD *)this + 313);
      v43 = *((_DWORD *)this + 84);
      do
      {
        v44 = v42;
        v42 = v43 % v42;
        v43 = v44;
      }
      while (v42);
    }
    else
    {
      v44 = *((_DWORD *)this + 84);
    }
    v45 = (v40 / v44 - 1) * v44;
    v46 = v45 + v41;
    v47 = *((_DWORD *)this + 311);
    *((_DWORD *)this + 290) = v45 + v41;
    *((_DWORD *)this + 291) = v47;
    *((_DWORD *)this + 294) = 0;
    *((_QWORD *)this + 146) = 0;
    v48 = (void *)*((_QWORD *)this + 148);
    v49 = *((_QWORD *)this + 149) - (_QWORD)v48;
    v50 = (v46 * v47);
    if (v50 == v49 >> 2)
    {
      if (v49 < 1)
        goto LABEL_61;
      v51 = (unint64_t)v49 >> 2;
      v52 = ((unint64_t)v49 >> 2) + 1;
      bzero(*((void **)this + 148), 4 * (v52 - ((unint64_t)v49 > 3)));
    }
    else
    {
      std::valarray<float>::resize((uint64_t)this + 1184, v50, 0.0);
      v48 = (void *)*((_QWORD *)this + 148);
      v53 = *((_QWORD *)this + 149) - (_QWORD)v48;
      if (v53 < 1)
        goto LABEL_61;
      v51 = (unint64_t)v53 >> 2;
      v52 = ((unint64_t)v53 >> 2) + 1;
    }
    bzero(v48, 4 * (v52 - (v51 != 0)));
LABEL_61:
    *((_DWORD *)this + 292) = 0;
    *((_DWORD *)this + 294) = 0;
    v54 = *((_DWORD *)this + 84) + v45;
    v55 = *((_DWORD *)this + 311);
    *((_DWORD *)this + 300) = v54;
    *((_DWORD *)this + 301) = v55;
    *((_DWORD *)this + 304) = 0;
    *((_QWORD *)this + 151) = 0;
    v56 = (void *)*((_QWORD *)this + 153);
    v57 = *((_QWORD *)this + 154) - (_QWORD)v56;
    v58 = v55 * v54;
    if (v58 == v57 >> 2)
    {
      if (v57 < 1)
        goto LABEL_67;
      v108 = v45;
      v59 = (unint64_t)v57 >> 2;
      v60 = ((unint64_t)v57 >> 2) + 1;
      bzero(v56, 4 * (v60 - ((unint64_t)v57 > 3)));
    }
    else
    {
      std::valarray<float>::resize((uint64_t)this + 1224, v58, 0.0);
      v56 = (void *)*((_QWORD *)this + 153);
      v61 = *((_QWORD *)this + 154) - (_QWORD)v56;
      if (v61 < 1)
        goto LABEL_67;
      v108 = v45;
      v59 = (unint64_t)v61 >> 2;
      v60 = ((unint64_t)v61 >> 2) + 1;
    }
    bzero(v56, 4 * (v60 - (v59 != 0)));
    v45 = v108;
LABEL_67:
    if (v45 >= v54)
      v62 = v54;
    else
      v62 = v45;
    *((_DWORD *)this + 302) = v62;
    *((_DWORD *)this + 304) = v62;
    if (*((_BYTE *)this + 1257))
    {
      LODWORD(v38) = *((_DWORD *)this + 313);
      v63 = (double)v38;
      goto LABEL_73;
    }
LABEL_72:
    v63 = v4->mSampleRate * 0.100000001;
LABEL_73:
    if (*v15)
    {
      v64 = 0;
      v65 = v63;
      v66 = (char *)this + 1032;
      do
      {
        std::valarray<float>::resize((uint64_t)(v66 - 128), v65, 0.0);
        std::valarray<float>::resize((uint64_t)v66, v40 + v65, 0.0);
        ++v64;
        v66 += 16;
      }
      while (v64 < *v15);
    }
    goto LABEL_76;
  }
  v40 = 0;
LABEL_76:
  *((_DWORD *)this + 315) = 0;
  *((_DWORD *)this + 316) = v40;
  *((_DWORD *)this + 317) = 0;
  v67 = (_QWORD *)((char *)this + 880);
  v68 = *((_DWORD *)this + 313);
  v69 = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
  v72 = *(_DWORD *)(v69 + 104);
  v71 = *(unsigned int *)(v69 + 108);
  if (*((_QWORD *)this + 110))
    AUMultiBandDynamicsProcessorV2::DeAllocateIntermediateBuffer((unsigned int **)this + 110, v70);
  v73 = malloc_type_malloc((16 * (_DWORD)v71) | 8u, 0x2C8E6D5CuLL);
  if (!v73)
    goto LABEL_126;
  v74 = v73;
  bzero(v73, (16 * (_DWORD)v71) | 8u);
  *v67 = v74;
  if (v68)
  {
    *v74 = v71;
    if ((_DWORD)v71)
    {
      v75 = 0;
      v76 = (v72 * v68);
      while (1)
      {
        v77 = malloc_type_malloc(v76, 0x2C8E6D5CuLL);
        v78 = v77;
        if ((_DWORD)v76)
        {
          if (!v77)
            break;
        }
        bzero(v77, v76);
        v79 = *v67 + v75;
        *(_DWORD *)(v79 + 8) = 1;
        *(_DWORD *)(v79 + 12) = v76;
        *(_QWORD *)(v79 + 16) = v78;
        v75 += 16;
        if (16 * v71 == v75)
          goto LABEL_85;
      }
LABEL_126:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v107 = std::bad_alloc::bad_alloc(exception);
    }
  }
LABEL_85:
  (*(void (**)(AUMultiBandDynamicsProcessorV2 *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
  AppBooleanValue = CACFPreferencesGetAppBooleanValue(CFSTR("mbdp_allow_lookahead"), CFSTR("com.apple.coreaudio"), v109);
  if (v109[0])
    *((_DWORD *)this + 216) = AppBooleanValue;
  v81 = (float)((float)*((unsigned int *)this + 313) * 1000.0);
  v82 = v81
      / *(double *)(ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0) + 80);
  for (i = 816; i != 848; i += 8)
  {
    AudioUnitSetProperty(*(AudioUnit *)((char *)this + i), 0xFA01u, 0, 0, (char *)this + 864, 4u);
    AudioUnitSetProperty(*(AudioUnit *)((char *)this + i), 0xEu, 0, 0, (char *)this + 1252, 4u);
    AudioUnitSetParameter(*(AudioUnit *)((char *)this + i), 9u, 0, 0, v82, 0);
  }
  for (j = 688; j != 816; j += 8)
    AudioUnitSetProperty(*(AudioUnit *)((char *)this + j), 0xEu, 0, 0, (char *)this + 1252, 4u);
  AudioUnitSetProperty(*((AudioUnit *)this + 106), 0xFA01u, 0, 0, (char *)this + 864, 4u);
  AudioUnitSetProperty(*((AudioUnit *)this + 106), 0xEu, 0, 0, (char *)this + 1252, 4u);
  AudioUnitSetParameter(*((AudioUnit *)this + 106), 9u, 0, 0, v82, 0);
  *((_DWORD *)this + 133) = *((_DWORD *)this + 132);
  *((_DWORD *)this + 135) = *((_DWORD *)this + 134);
  if (*((_BYTE *)this + 1314))
  {
    v85 = *((_QWORD *)this + 9);
    if (v85)
    {
      v86 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v85 + 32))(v85, 0);
    }
    else
    {
      v88 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v88)
        v86 = 0;
      else
        v86 = *v88;
    }
    v89 = ausdk::AUElement::GetParameter(v86, 6u);
    v87 = __exp10f(v89 / 20.0);
  }
  else
  {
    v87 = 1.0;
  }
  *((float *)this + 219) = v87;
  AUMultiBandDynamicsProcessorV2::UpdateMBDPState(this);
  if (*((_QWORD *)this + 106))
  {
    v90 = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
    v91 = *(_OWORD *)(v90 + 96);
    v112 = *(_OWORD *)(v90 + 80);
    v113 = v91;
    v114 = *(_QWORD *)(v90 + 112);
    if (*((_DWORD *)this + 138))
    {
      v92 = 0;
      while (1)
      {
        v93 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + v92 + 102);
        if (!v93)
          break;
        result = SetUpAudioUnit(v93, (const CAStreamBasicDescription *)&v112, 1);
        if ((_DWORD)result)
          return result;
        if (++v92 >= (unint64_t)*((unsigned int *)this + 138))
          goto LABEL_105;
      }
    }
    else
    {
LABEL_105:
      v94 = 0;
      while (1)
      {
        v95 = *(OpaqueAudioComponentInstance **)((char *)this + v94 + 688);
        if (!v95)
          break;
        result = SetUpAudioUnit(v95, (const CAStreamBasicDescription *)&v112, 0);
        if ((_DWORD)result)
          return result;
        v94 += 8;
        if (v94 == 128)
        {
          v96 = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
          v97 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 106);
          v98 = *(_OWORD *)(v96 + 96);
          v112 = *(_OWORD *)(v96 + 80);
          v113 = v98;
          v114 = *(_QWORD *)(v96 + 112);
          result = SetUpAudioUnit(v97, (const CAStreamBasicDescription *)&v112, 1);
          if (!(_DWORD)result)
          {
            *((_OWORD *)this + 37) = 0u;
            *((_OWORD *)this + 38) = 0u;
            *((_OWORD *)this + 35) = 0u;
            *((_OWORD *)this + 36) = 0u;
            *((_DWORD *)this + 154) = 1;
            *((_OWORD *)this + 39) = 0u;
            *((_OWORD *)this + 40) = 0u;
            *((_OWORD *)this + 41) = 0u;
            *((_OWORD *)this + 42) = 0u;
            *((_DWORD *)this + 170) = 1;
            v99 = *((_BYTE *)this + 1314);
            if (v99)
            {
              v100 = *((_QWORD *)this + 9);
              if (v100)
              {
                v101 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v100 + 32))(v100, 0);
              }
              else
              {
                v102 = (ausdk::AUElement **)*((_QWORD *)this + 6);
                if (*((ausdk::AUElement ***)this + 7) == v102)
                  v101 = 0;
                else
                  v101 = *v102;
              }
              if (ausdk::AUElement::GetParameter(v101, 3u) == 0.0)
              {
                v99 = 0;
              }
              else
              {
                v103 = *((_QWORD *)this + 9);
                if (v103)
                {
                  v104 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v103 + 32))(v103, 0);
                }
                else
                {
                  v105 = (ausdk::AUElement **)*((_QWORD *)this + 6);
                  if (*((ausdk::AUElement ***)this + 7) == v105)
                    v104 = 0;
                  else
                    v104 = *v105;
                }
                v99 = ausdk::AUElement::GetParameter(v104, 2u) != 0.0;
              }
            }
            result = 0;
            *((_BYTE *)this + 1312) = v99;
          }
          return result;
        }
      }
    }
  }
  return 4294956421;
}

void AUMultiBandDynamicsProcessorV2::Cleanup(AUMultiBandDynamicsProcessorV2 *this)
{
  AudioBufferList **v2;

  *((_QWORD *)this + 172) = *((_QWORD *)this + 171);
  *((_QWORD *)this + 175) = *((_QWORD *)this + 174);
  AUMultiBandDynamicsProcessorV2::UnInitializeUnderlyingAUs(this);
  AUMultiBandDynamicsProcessorV2::DeAllocateIntermediateBuffer((unsigned int **)this + 110, v2);
}

uint64_t AUMultiBandDynamicsProcessorV2::Reset(AUMultiBandDynamicsProcessorV2 *this)
{
  int v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  void *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  void *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  _DWORD *v31;
  unint64_t v32;
  void **v33;
  uint64_t i;
  uint64_t v35;
  char *v36;
  uint64_t result;

  SimpleMeters::Reset((uint64_t)this + 1368);
  if (!*((_BYTE *)this + 1256))
  {
    v2 = *((_DWORD *)this + 311);
    if (v2)
    {
      v3 = (_QWORD *)((char *)this + 1040);
      v4 = *((unsigned int *)this + 311);
      do
      {
        v5 = (void *)*(v3 - 17);
        v6 = *(v3 - 16) - (_QWORD)v5;
        if (v6 >= 1)
          bzero(v5, 4 * (((unint64_t)v6 >> 2) - ((unint64_t)v6 > 3)) + 4);
        v7 = (void *)*(v3 - 1);
        v8 = *v3 - (_QWORD)v7;
        if (v8 >= 1)
          bzero(v7, 4 * (((unint64_t)v8 >> 2) - ((unint64_t)v8 > 3)) + 4);
        v3 += 2;
        --v4;
      }
      while (v4);
    }
    if (!*((_BYTE *)this + 1257))
      goto LABEL_31;
    v9 = *((_DWORD *)this + 84);
    v10 = *((_DWORD *)this + 313);
    if (v10)
    {
      v11 = *((_DWORD *)this + 313);
      v12 = *((_DWORD *)this + 84);
      do
      {
        v13 = v11;
        v11 = v12 % v11;
        v12 = v13;
      }
      while (v11);
    }
    else
    {
      v13 = *((_DWORD *)this + 84);
    }
    v14 = (v10 / v13 - 1) * v13;
    v15 = v14 + v9;
    *((_DWORD *)this + 290) = v14 + v9;
    *((_DWORD *)this + 291) = v2;
    *((_DWORD *)this + 294) = 0;
    *((_QWORD *)this + 146) = 0;
    v16 = (void *)*((_QWORD *)this + 148);
    v17 = *((_QWORD *)this + 149) - (_QWORD)v16;
    v18 = (v15 * v2);
    if (v18 == v17 >> 2)
    {
      if (v17 < 1)
        goto LABEL_21;
      v19 = (unint64_t)v17 >> 2;
      v20 = ((unint64_t)v17 >> 2) + 1;
      bzero(*((void **)this + 148), 4 * (v20 - ((unint64_t)v17 > 3)));
    }
    else
    {
      std::valarray<float>::resize((uint64_t)this + 1184, v18, 0.0);
      v16 = (void *)*((_QWORD *)this + 148);
      v21 = *((_QWORD *)this + 149) - (_QWORD)v16;
      if (v21 < 1)
        goto LABEL_21;
      v19 = (unint64_t)v21 >> 2;
      v20 = ((unint64_t)v21 >> 2) + 1;
    }
    bzero(v16, 4 * (v20 - (v19 != 0)));
LABEL_21:
    *((_DWORD *)this + 292) = 0;
    *((_DWORD *)this + 294) = 0;
    v22 = *((_DWORD *)this + 84) + v14;
    v23 = *((_DWORD *)this + 311);
    *((_DWORD *)this + 300) = v22;
    *((_DWORD *)this + 301) = v23;
    *((_DWORD *)this + 304) = 0;
    *((_QWORD *)this + 151) = 0;
    v24 = (void *)*((_QWORD *)this + 153);
    v25 = *((_QWORD *)this + 154) - (_QWORD)v24;
    v26 = v23 * v22;
    if (v26 == v25 >> 2)
    {
      if (v25 >= 1)
      {
        v27 = (unint64_t)v25 >> 2;
        v28 = ((unint64_t)v25 >> 2) + 1;
        bzero(*((void **)this + 153), 4 * (v28 - ((unint64_t)v25 > 3)));
LABEL_26:
        bzero(v24, 4 * (v28 - (v27 != 0)));
      }
    }
    else
    {
      std::valarray<float>::resize((uint64_t)this + 1224, v26, 0.0);
      v24 = (void *)*((_QWORD *)this + 153);
      v29 = *((_QWORD *)this + 154) - (_QWORD)v24;
      if (v29 >= 1)
      {
        v27 = (unint64_t)v29 >> 2;
        v28 = ((unint64_t)v29 >> 2) + 1;
        goto LABEL_26;
      }
    }
    if (v14 >= v22)
      v30 = v22;
    else
      v30 = v14;
    *((_DWORD *)this + 302) = v30;
    *((_DWORD *)this + 304) = v30;
LABEL_31:
    *((_DWORD *)this + 315) = 0;
    *((_QWORD *)this + 158) = *((unsigned int *)this + 313);
  }
  v31 = (_DWORD *)*((_QWORD *)this + 110);
  if (v31 && *v31)
  {
    v32 = 0;
    v33 = (void **)(v31 + 4);
    do
    {
      bzero(*v33, *((unsigned int *)v33 - 1));
      ++v32;
      v33 += 2;
    }
    while (v32 < *v31);
  }
  AudioUnitReset(*((AudioUnit *)this + 106), 0, 0);
  for (i = 0; i != 32; i += 8)
    AudioUnitReset(*(AudioUnit *)((char *)this + i + 816), 0, 0);
  v35 = 0;
  v36 = (char *)this + 688;
  do
  {
    result = AudioUnitReset(*(AudioUnit *)&v36[v35], 0, 0);
    v35 += 8;
  }
  while (v35 != 128);
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::GetPropertyInfo(AUMultiBandDynamicsProcessorV2 *this, int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t v6;
  BOOL v7;
  unsigned int v8;
  uint64_t result;

  if (a2 == 3007)
  {
    v7 = 1;
    v8 = 4;
LABEL_12:
    result = 0;
    *a5 = v8;
    *a6 = v7;
    return result;
  }
  if (a2 == 3099)
  {
    if (a3 > 1)
      v6 = 0;
    else
      v6 = (uint64_t)(*((_QWORD *)this + 172) - *((_QWORD *)this + 171)) >> 7;
    if ((a3 & 0xFFFFFFFD) == 0)
      v6 += (uint64_t)(*((_QWORD *)this + 175) - *((_QWORD *)this + 174)) >> 7;
    v7 = 0;
    v8 = 16 * v6;
    goto LABEL_12;
  }
  if (a3)
    return 4294956417;
  switch(a2)
  {
    case 64003:
    case 64004:
    case 64005:
    case 64006:
      break;
    default:
      if (a2 != 3700 && a2 != 21)
        return 4294956417;
      break;
  }
  result = 0;
  *a6 = 1;
  *a5 = 4;
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::GetProperty(AUMultiBandDynamicsProcessorV2 *this, int a2, unsigned int a3, unsigned int a4, _DWORD *a5, int *a6)
{
  uint64_t result;
  int v11;
  unsigned int v12;

  v12 = 0;
  if (!SimpleMeters::HandleGetProperty((AUMultiBandDynamicsProcessorV2 *)((char *)this + 1368), a2, a3, a5, &v12, a6))
  {
    switch(a2)
    {
      case 64003:
        result = 0;
        v11 = *((_DWORD *)this + 137);
        goto LABEL_13;
      case 64004:
        result = 0;
        v11 = *((_DWORD *)this + 214);
        goto LABEL_13;
      case 64005:
        result = 0;
        v11 = *((_DWORD *)this + 215);
        goto LABEL_13;
      case 64006:
        result = 0;
        v11 = *((_DWORD *)this + 216);
        goto LABEL_13;
      default:
        if (a2 == 3700)
        {
          result = 0;
          v11 = *((unsigned __int8 *)this + 376);
LABEL_13:
          *a5 = v11;
          return result;
        }
        if (a2 != 21)
          return 4294956417;
        if (a3)
          return 4294956430;
        *a5 = *((_DWORD *)this + 136);
        break;
    }
  }
  return v12;
}

uint64_t AUMultiBandDynamicsProcessorV2::SetProperty(AUMultiBandDynamicsProcessorV2 *this, int a2, int a3, unsigned int a4, int *a5, void *a6, int *a7)
{
  unsigned int v7;
  uint64_t result;
  int v13;
  int v14;
  unsigned int v15;

  v7 = a6;
  v15 = 0;
  if (SimpleMeters::HandleSetProperty((AUMultiBandDynamicsProcessorV2 *)((char *)this + 1368), a2, a3, a5, a6, (int *)&v15, a7))
  {
    return v15;
  }
  if (a3)
    return 4294956417;
  result = 0;
  if (a2 <= 64002)
  {
    switch(a2)
    {
      case 21:
        if (v7 >= 4)
        {
          result = 0;
          v13 = *((_DWORD *)this + 136);
          v14 = *a5;
          *((_DWORD *)this + 136) = *a5 != 0;
          if (v13)
          {
            if (!v14)
            {
              result = 0;
              *((_BYTE *)this + 1240) = 1;
            }
          }
          return result;
        }
        break;
      case 3700:
        if (v7 >= 4)
        {
          result = 0;
          *((_BYTE *)this + 376) = *(_BYTE *)a5;
          return result;
        }
        break;
      case 64002:
        return result;
      default:
        return 4294956417;
    }
    return 4294956445;
  }
  if ((a2 - 64004) >= 3)
  {
    if (a2 == 64003)
    {
      if (*a5 <= 4)
      {
        result = 0;
        *((_DWORD *)this + 137) = *a5;
        return result;
      }
      return 4294956445;
    }
    return 4294956417;
  }
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::GetParameter(AUMultiBandDynamicsProcessorV2 *this, unsigned int a2, unsigned int a3, unsigned int a4, float *a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  float Parameter;
  uint64_t result;

  if (a2 > 0x257)
    return 4294956418;
  if ((unsigned __int16)a2 % 0x64u - 28 <= 2)
    *((_BYTE *)this + 1313) = 1;
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  Parameter = ausdk::AUElement::GetParameter(Element, a2);
  result = 0;
  *a5 = Parameter;
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::SetParameter(AUMultiBandDynamicsProcessorV2 *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  int v10;
  ausdk::AUScope *Scope;
  ausdk::AUElement *v12;
  int v13;
  uint64_t result;
  uint64_t v15;
  ausdk::AUElement *v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement *Element;
  ausdk::AUElement **v27;
  ausdk::AUElement **v28;

  if (!a3)
  {
    if (a2 > 0x257)
      return 4294956418;
    if (a2 <= 0x63)
    {
      switch(a2)
      {
        case 0u:
          v24 = *((_QWORD *)this + 9);
          if (v24)
          {
            v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
          }
          else
          {
            v28 = (ausdk::AUElement **)*((_QWORD *)this + 6);
            if (*((ausdk::AUElement ***)this + 7) == v28)
              v25 = 0;
            else
              v25 = *v28;
          }
          if (ausdk::AUElement::GetParameter(v25, 0) == a5)
            return 0;
          ausdk::AUBase::SetParameter(this, 0, 0, a4, a5);
          result = 0;
          ++*((_DWORD *)this + 134);
          return result;
        case 7u:
          Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 32), a4);
          ausdk::AUElement::SetParameter(Element, 7u, a5, 0);
          ++*((_DWORD *)this + 132);
          break;
        case 5u:
          v15 = *((_QWORD *)this + 9);
          if (v15)
          {
            v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
          }
          else
          {
            v27 = (ausdk::AUElement **)*((_QWORD *)this + 6);
            if (*((ausdk::AUElement ***)this + 7) == v27)
              v16 = 0;
            else
              v16 = *v27;
          }
          if (ausdk::AUElement::GetParameter(v16, 5u) == a5)
            return 0;
          ausdk::AUBase::SetParameter(this, 5u, 0, a4, a5);
          break;
        default:
          goto LABEL_2;
      }
      AUMultiBandDynamicsProcessorV2::CalculateVolCompGainOffset(this);
      return 0;
    }
    v17 = a2 / 0x64;
    if (a2 % 0x64 == 37 && a5 != 0.0)
    {
      v18 = *((_DWORD *)this + 138);
      if ((v18 + 1) >= 2)
      {
        v19 = 2;
        v20 = 237;
        do
        {
          if (v17 != v19)
          {
            v21 = *((_QWORD *)this + 9);
            if (v21)
            {
              v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
            }
            else
            {
              v23 = (ausdk::AUElement **)*((_QWORD *)this + 6);
              if (*((ausdk::AUElement ***)this + 7) == v23)
                v22 = 0;
              else
                v22 = *v23;
            }
            ausdk::AUElement::SetParameter(v22, v20, 0.0, 0);
            v18 = *((_DWORD *)this + 138);
          }
          ++v19;
          v20 += 100;
        }
        while (v19 <= v18 + 1);
      }
    }
  }
LABEL_2:
  v10 = AUMultiBandDynamicsProcessorV2::DetermineBandsToProcess(this);
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  v12 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(v12, a2, a5, 0);
  ++*((_DWORD *)this + 132);
  v13 = AUMultiBandDynamicsProcessorV2::DetermineBandsToProcess(this);
  result = 0;
  if (v10 != v13)
  {
    (*(void (**)(AUMultiBandDynamicsProcessorV2 *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 432))(this, 3, 0, 0);
    return 0;
  }
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::CanScheduleParameters(AUMultiBandDynamicsProcessorV2 *this)
{
  return 0;
}

uint64_t AUMultiBandDynamicsProcessorV2::ProcessMultipleBufferLists(AUMultiBandDynamicsProcessorV2 *this, unsigned int *a2, unsigned int a3, unsigned int a4, AudioBufferList **a5, unsigned int a6, const AudioBufferList **a7)
{
  AudioBufferList *v13;
  SimpleMeters *v14;
  uint64_t result;
  _OWORD *v16;
  void *v17;
  uint64_t v18;
  const AudioBufferList *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t mNumberBuffers;
  int v24;
  __int128 v25;
  __int128 v26;
  unsigned int v27;
  unsigned int v28;
  const AudioBufferList *v29;
  uint64_t v30;
  AudioBufferList *v31;
  size_t v32;
  uint64_t v33;
  UInt32 v34;
  void **p_mData;
  void **v36;
  char *v37;
  unsigned int v38;
  _DWORD *exception;
  uint64_t v40;
  SimpleMeters *v41;
  AudioTimeStamp v42;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v13 = *a5;
  v14 = (AUMultiBandDynamicsProcessorV2 *)((char *)this + 1368);
  result = SimpleMeters::ProcessInputBufferList((AUMultiBandDynamicsProcessorV2 *)((char *)this + 1368), a3, *a5);
  if (!(_DWORD)result)
  {
    v16 = (_OWORD *)((char *)this + 560);
    v17 = AUMultiBandDynamicsProcessorV2::DoBlockProcess((uint64_t)this, a2, (const AudioTimeStamp *)((char *)this + 560), a3, v13, v13);
    if (a4 >= 2
      && a5[1]
      && ((v18 = *((_QWORD *)this + 15)) == 0
        ? (v17 = (void *)((*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3))
        : (v17 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18)),
          (_DWORD)v17 == 2))
    {
      v19 = a5[1];
      vDSP_vadd((const float *)v19->mBuffers[0].mData, 1, (const float *)v13->mBuffers[0].mData, 1, (float *)(*a7)->mBuffers[0].mData, 1, a3);
      if (*((_DWORD *)this + 311) >= 2u)
        vDSP_vadd((const float *)v19->mBuffers[v19->mNumberBuffers > 1].mData, 1, (const float *)v13->mBuffers[v13->mNumberBuffers > 1].mData, 1, *(float **)&(*a7)[1].mBuffers[0].mNumberChannels, 1, a3);
    }
    else if ((*a7)->mBuffers[0].mData != v13->mBuffers[0].mData)
    {
      v20 = *((unsigned int *)this + 311);
      if ((_DWORD)v20)
      {
        v21 = 0;
        v22 = 16;
        do
        {
          if (v21 < (*a7)->mNumberBuffers)
          {
            mNumberBuffers = v13->mNumberBuffers;
            if ((_DWORD)mNumberBuffers)
            {
              v24 = mNumberBuffers - 1;
              if (v21 < mNumberBuffers)
                v24 = v21;
              v17 = memcpy(*(void **)((char *)&(*a7)->mNumberBuffers + v22), v13->mBuffers[v24].mData, *((_DWORD *)this + 312) * a3);
              v20 = *((unsigned int *)this + 311);
            }
          }
          ++v21;
          v22 += 16;
        }
        while (v21 < v20);
      }
    }
    if (*((_DWORD *)this + 311) == 1 && (*a7)->mNumberBuffers == 2)
      v17 = memcpy(*(void **)&(*a7)[1].mBuffers[0].mNumberChannels, (*a7)->mBuffers[0].mData, (*a7)->mBuffers[0].mDataByteSize);
    if (*((_BYTE *)this + 1256))
    {
      v41 = v14;
      v25 = *((_OWORD *)this + 36);
      *(_OWORD *)&v42.mSampleTime = *v16;
      *(_OWORD *)&v42.mRateScalar = v25;
      v26 = *((_OWORD *)this + 38);
      *(_OWORD *)&v42.mSMPTETime.mSubframes = *((_OWORD *)this + 37);
      *(_OWORD *)&v42.mSMPTETime.mHours = v26;
      if (a3)
      {
        v27 = 0;
        v28 = a3;
        do
        {
          v29 = *a7;
          if ((*a7)->mNumberBuffers - 65 <= 0xFFFFFFBF)
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315394;
              v44 = "AUMultiBandDynamicsProcessorV2.cpp";
              v45 = 1024;
              v46 = 1997;
              _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  STACK_ABL: invalid number of buffers", buf, 0x12u);
            }
            exception = __cxa_allocate_exception(0x10uLL);
            *(_QWORD *)exception = &off_1E69EE218;
            exception[2] = -50;
          }
          MEMORY[0x1E0C80A78](v17);
          v31 = (AudioBufferList *)((char *)&v40 - v30);
          bzero((char *)&v40 - v30, v32);
          v31->mNumberBuffers = v29->mNumberBuffers;
          v33 = v29->mNumberBuffers;
          v34 = *((_DWORD *)this + 313);
          if ((_DWORD)v33)
          {
            p_mData = &v31->mBuffers[0].mData;
            v36 = &v29->mBuffers[0].mData;
            do
            {
              *((_DWORD *)p_mData - 2) = 1;
              *((_DWORD *)p_mData - 1) = 4 * v34;
              v37 = (char *)*v36;
              v36 += 2;
              *p_mData = &v37[4 * v27];
              p_mData += 2;
              --v33;
            }
            while (v33);
          }
          v17 = (void *)AUMultiBandDynamicsProcessorV2::DoCombinerLimiter(this, a2, &v42, v34, v31);
          if ((_DWORD)v17)
            break;
          v38 = *((_DWORD *)this + 313);
          v27 += v38;
          v42.mSampleTime = v42.mSampleTime + (double)v38;
          v28 -= v38;
        }
        while (v28);
      }
      v14 = v41;
    }
    *(double *)v16 = *(double *)v16 + (double)a3;
    return SimpleMeters::ProcessOutputBufferList(v14, a3, *a7);
  }
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::Render(AUMultiBandDynamicsProcessorV2 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  ausdk::AUInputElement *Element;
  uint64_t v10;
  unsigned int *BufferList;
  uint64_t v12;
  void **v13;
  SimpleMeters *v14;
  uint64_t result;
  _OWORD *v16;
  void *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  __int128 v23;
  __int128 v24;
  unsigned int v25;
  int v26;
  unsigned int *v27;
  uint64_t v28;
  uint64_t v29;
  AudioBufferList *v30;
  size_t v31;
  uint64_t v32;
  UInt32 v33;
  char *v34;
  unsigned int v35;
  _DWORD *exception;
  char *v37;
  SimpleMeters *v38;
  AudioTimeStamp v39;
  unsigned int v40;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v40 = 0;
  v8 = (AUMultiBandDynamicsProcessorV2 *)((char *)this + 80);
  Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 80), 0);
  ausdk::AUInputElement::PullInput(Element, &v40, a3, 0, a4);
  v10 = ausdk::AUScope::SafeGetElement(v8, 0);
  BufferList = (unsigned int *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
  v12 = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
  v13 = (void **)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v12 + 144));
  v14 = (AUMultiBandDynamicsProcessorV2 *)((char *)this + 1368);
  result = SimpleMeters::ProcessInputBufferList((AUMultiBandDynamicsProcessorV2 *)((char *)this + 1368), a4, (const AudioBufferList *)BufferList);
  if (!(_DWORD)result)
  {
    v16 = (_OWORD *)((char *)this + 560);
    v17 = AUMultiBandDynamicsProcessorV2::DoBlockProcess((uint64_t)this, a2, (const AudioTimeStamp *)((char *)this + 560), a4, (const AudioBufferList *)BufferList, (AudioBufferList *)BufferList);
    if (!(_DWORD)v17)
    {
      if (*((_DWORD *)this + 311))
      {
        v18 = 0;
        v19 = 2;
        do
        {
          v20 = *BufferList;
          if (v18 >= v20)
            v21 = v20 - 1;
          else
            v21 = v18;
          v17 = memcpy(v13[v19], *(const void **)&BufferList[4 * v21 + 4], (*((_DWORD *)this + 312) * a4));
          ++v18;
          v22 = *((unsigned int *)this + 311);
          v19 += 2;
        }
        while (v18 < v22);
        if ((_DWORD)v22 == 1 && *(_DWORD *)v13 > 1u)
          v17 = memcpy(v13[4], *((const void **)BufferList + 2), (*((_DWORD *)this + 312) * a4));
      }
      if (*((_BYTE *)this + 1256))
      {
        v37 = (char *)this + 560;
        v38 = (AUMultiBandDynamicsProcessorV2 *)((char *)this + 1368);
        v23 = *((_OWORD *)this + 36);
        *(_OWORD *)&v39.mSampleTime = *v16;
        *(_OWORD *)&v39.mRateScalar = v23;
        v24 = *((_OWORD *)this + 38);
        *(_OWORD *)&v39.mSMPTETime.mSubframes = *((_OWORD *)this + 37);
        *(_OWORD *)&v39.mSMPTETime.mHours = v24;
        if ((_DWORD)a4)
        {
          v25 = 0;
          v26 = a4;
          do
          {
            v27 = a2;
            v28 = *(unsigned int *)v13;
            if ((v28 - 65) <= 0xFFFFFFBF)
            {
              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315394;
                v42 = "AUMultiBandDynamicsProcessorV2.cpp";
                v43 = 1024;
                v44 = 2067;
                _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  STACK_ABL: invalid number of buffers", buf, 0x12u);
              }
              exception = __cxa_allocate_exception(0x10uLL);
              *(_QWORD *)exception = &off_1E69EE218;
              exception[2] = -50;
            }
            MEMORY[0x1E0C80A78](v17);
            v30 = (AudioBufferList *)((char *)&v37 - v29);
            bzero((char *)&v37 - v29, v31);
            v32 = 0;
            v30->mNumberBuffers = v28;
            v33 = *((_DWORD *)this + 313);
            do
            {
              v34 = (char *)v30 + v32 * 8;
              *((_DWORD *)v34 + 2) = 1;
              *((_DWORD *)v34 + 3) = 4 * v33;
              *((_QWORD *)v34 + 2) = (char *)v13[v32 + 2] + 4 * v25;
              v32 += 2;
            }
            while (2 * v28 != v32);
            a2 = v27;
            v17 = (void *)AUMultiBandDynamicsProcessorV2::DoCombinerLimiter(this, v27, &v39, v33, v30);
            if ((_DWORD)v17)
              break;
            v35 = *((_DWORD *)this + 313);
            v25 += v35;
            v39.mSampleTime = v39.mSampleTime + (double)v35;
            v26 -= v35;
          }
          while (v26);
        }
        v16 = v37;
        v14 = v38;
      }
    }
    *(double *)v16 = *(double *)v16 + (double)a4;
    return SimpleMeters::ProcessOutputBufferList(v14, a4, (const AudioBufferList *)v13);
  }
  return result;
}

BOOL AUMultiBandDynamicsProcessorV2::BusCountWritable(AUMultiBandDynamicsProcessorV2 *this, int a2)
{
  return a2 == 1;
}

uint64_t AUMultiBandDynamicsProcessorV2::SetBusCount(int64x2_t *this, int a2, unsigned int a3)
{
  uint64_t result;

  result = 4294956445;
  if (a2 == 1 && a3 - 1 <= 1)
  {
    ausdk::AUScope::SetNumberOfElements(this + 5, a3);
    return 0;
  }
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::GetParameterList(AUMultiBandDynamicsProcessorV2 *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v13;
  unsigned int v14;
  unsigned int i;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  int j;
  uint64_t v21;
  uint64_t k;
  unsigned int v23;
  uint64_t v24;

  if (a2)
    return 4294956430;
  v8 = AUMultiBandDynamicsProcessorV2::DetermineBandsToProcess(this);
  if (*((_BYTE *)this + 1314))
  {
    v9 = 0;
    v10 = 0;
    do
    {
      if ((v9 & 7) != 3 && v9 != 2 && v9 != 4)
      {
        if (a3)
          a3[v10] = v9;
        ++v10;
      }
      ++v9;
    }
    while (v9 != 13);
    if (a3)
    {
      a3[v10] = 22;
      a3[v10 + 1] = 23;
      a3[v10 + 2] = 24;
    }
    v13 = 0;
    v14 = v10 + 3;
    do
    {
      if (v13 * 4)
      {
        if (a3)
          a3[v14] = dword_1B66894A0[v13];
        ++v14;
      }
      ++v13;
    }
    while (v13 != 12);
    for (i = 100; i != 140; ++i)
    {
      v16 = 0;
      while (i != dword_1B66894A0[v16])
      {
        if (++v16 == 12)
        {
          if (i != 137)
          {
            if (a3)
              a3[v14] = i;
            ++v14;
          }
          break;
        }
      }
    }
    if (*((_DWORD *)this + 138))
    {
      v17 = 0;
      do
      {
        v18 = 0;
        v19 = 100 * v17 + 100;
        do
        {
          if (a3)
            a3[v14 + v18] = v19 + dword_1B66894A0[v18];
          ++v18;
        }
        while (v18 != 12);
        v14 += 12;
        for (j = 100; j != 140; ++j)
        {
          v21 = 0;
          while (j != dword_1B66894A0[v21])
          {
            if (++v21 == 12)
            {
              if (a3)
                a3[v14] = v19 + j;
              ++v14;
              break;
            }
          }
        }
        ++v17;
      }
      while (v17 < *((_DWORD *)this + 138));
    }
  }
  else
  {
    for (k = 0; k != 3; ++k)
    {
      if (a3)
        a3[k] = k + 8;
    }
    if (*((_DWORD *)this + 138))
    {
      v14 = 3;
      v23 = 1;
      do
      {
        v24 = 2 * (v8 == 1);
        do
        {
          if (a3)
            a3[v14] = dword_1B66894A0[v24] + 100 * v23;
          ++v14;
          ++v24;
        }
        while (v24 != 12);
        ++v23;
      }
      while (v23 <= *((_DWORD *)this + 138));
    }
    else
    {
      v14 = 3;
    }
  }
  result = 0;
  *a4 = v14;
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::GetParameterInfo(AUMultiBandDynamicsProcessorV2 *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t Property;
  unsigned int v6;
  unsigned int v7;
  const __CFString *v8;
  AudioUnitParameterOptions flags;
  UInt32 v10;
  unsigned int v11;
  OpaqueAudioComponentInstance **v12;
  OpaqueAudioComponentInstance *v13;
  const __CFString *v14;
  const __CFString *v15;
  AudioUnitParameterOptions v16;
  uint64_t v17;
  const __CFString *v18;
  int v19;
  uint64_t v20;
  AudioUnitParameterValue v21;
  AudioUnitParameterOptions v22;
  AudioUnitParameterOptions v23;
  const __CFString *v24;
  const __CFString *v25;
  uint64_t v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  AudioUnitParameterOptions v30;
  const __CFString *v31;
  const __CFString *v32;
  const __CFString *v33;
  AudioUnitParameterOptions v34;
  int v35;
  const __CFString *v36;
  const __CFString *v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  const __CFString *v42;
  AudioUnitParameterOptions v43;
  int v44;
  const __CFString *v45;
  const __CFString *v46;
  const __CFString *v47;
  uint64_t v48;
  const __CFString *v49;
  UInt32 ioDataSize;

  ioDataSize = 104;
  buffer->flags = -1073741824;
  buffer->unitName = 0;
  if (a2)
    return 4294956430;
  if (a3 > 0x257)
    return 4294956418;
  v6 = a3 / 0x64;
  v7 = a3 % 0x64;
  if (a3 <= 0x63)
  {
    Property = 4294956418;
    v8 = CFSTR("Crossover 1");
    switch(v7)
    {
      case 0u:
        buffer->cfNameString = CFSTR("Volume");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Volume"), buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        goto LABEL_21;
      case 1u:
        buffer->cfNameString = CFSTR("Speaker Trim");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Speaker Trim"), buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        v16 = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v17 = 0x41A00000C1A00000;
        goto LABEL_18;
      case 2u:
        v18 = CFSTR("Allow Speaker Protection");
        goto LABEL_15;
      case 3u:
        v18 = CFSTR("Enable Speaker Protection");
LABEL_15:
        buffer->cfNameString = v18;
        buffer->flags = -939524096;
        CFStringGetCString(v18, buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 8;
        flags = buffer->flags;
        *(_QWORD *)&buffer->unit = 2;
        buffer->maxValue = 0.0;
        goto LABEL_46;
      case 4u:
        buffer->cfNameString = CFSTR("Tone detected");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Tone detected"), buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 8;
        v16 = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v17 = 0x3F80000000000000;
        goto LABEL_18;
      case 5u:
        buffer->cfNameString = CFSTR("DL Gain Target");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("DL Gain Target"), buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        v16 = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v17 = 0x40C00000C1400000;
LABEL_18:
        *(_QWORD *)&buffer->minValue = v17;
        buffer->defaultValue = 0.0;
        flags = v16 & 0x7FFFFFFF;
        v19 = 1140883456;
        goto LABEL_48;
      case 6u:
        buffer->cfNameString = CFSTR("Gain (dB)");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Gain (dB)"), buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Decibels;
        v20 = 0x41F00000C2C00000;
        goto LABEL_45;
      case 7u:
        buffer->cfNameString = CFSTR("Gain before C/L");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Gain before C/L"), buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Boolean;
LABEL_21:
        *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
        v21 = 1.0;
        goto LABEL_39;
      case 8u:
        goto LABEL_24;
      case 9u:
        v8 = CFSTR("Crossover 2");
        goto LABEL_24;
      case 0xAu:
        v8 = CFSTR("Crossover 3");
LABEL_24:
        buffer->cfNameString = v8;
        buffer->flags = -939524096;
        CFStringGetCString(v8, buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 2;
        v22 = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Hertz;
        *(_QWORD *)&buffer->minValue = 0x46BB800041A00000;
        buffer->defaultValue = 24000.0;
        v23 = v22 | 0xC0100000;
        goto LABEL_120;
      case 0xCu:
        v24 = CFSTR("A-Weighting Enabled");
        goto LABEL_41;
      case 0xDu:
        v25 = CFSTR("Primary Ducking Level (dB)");
        goto LABEL_29;
      case 0xEu:
        v25 = CFSTR("Game Audio Ducking Level (dB)");
        goto LABEL_29;
      case 0xFu:
        v25 = CFSTR("Other Audio Ducking Level (dB)");
LABEL_29:
        buffer->cfNameString = v25;
        buffer->flags = -939524096;
        CFStringGetCString(v25, buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v26 = 3267362816;
        goto LABEL_38;
      case 0x10u:
        v27 = CFSTR("System Sound Ducking Threshold (dB)");
        goto LABEL_32;
      case 0x11u:
        v27 = CFSTR("Primary Ducking Threshold (dB)");
LABEL_32:
        buffer->cfNameString = v27;
        buffer->flags = -939524096;
        CFStringGetCString(v27, buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 3259498496;
        v21 = -40.0;
        goto LABEL_39;
      case 0x12u:
        buffer->cfNameString = CFSTR("Primary Ducking Min Level (dB)");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Primary Ducking Min Level (dB)"), buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 3267362816;
        v21 = -30.0;
        goto LABEL_39;
      case 0x13u:
        v28 = CFSTR("Game Audio Ducking Min Level (dB)");
        goto LABEL_36;
      case 0x14u:
        v28 = CFSTR("Other Audio Ducking Min Level (dB)");
LABEL_36:
        buffer->cfNameString = v28;
        buffer->flags = -939524096;
        CFStringGetCString(v28, buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        *(_QWORD *)&buffer->minValue = 3267362816;
        v21 = -45.0;
        goto LABEL_39;
      case 0x15u:
        buffer->cfNameString = CFSTR("Other Audio RMS Limit (dB)");
        buffer->flags = -939524096;
        CFStringGetCString(CFSTR("Other Audio RMS Limit (dB)"), buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v26 = 3276275712;
LABEL_38:
        *(_QWORD *)&buffer->minValue = v26;
        v21 = -18.0;
LABEL_39:
        buffer->defaultValue = v21;
        goto LABEL_47;
      case 0x16u:
        v24 = CFSTR("Higher Order Crossover Enabled");
LABEL_41:
        buffer->cfNameString = v24;
        buffer->flags = -939524096;
        CFStringGetCString(v24, buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Boolean;
        v20 = 0x3F80000000000000;
        goto LABEL_45;
      case 0x17u:
        v29 = CFSTR("Band LookAhead (ms)");
        goto LABEL_44;
      case 0x18u:
        v29 = CFSTR("Combiner LookAhead (ms)");
LABEL_44:
        buffer->cfNameString = v29;
        buffer->flags = -939524096;
        CFStringGetCString(v29, buffer->name, 52, 0x8000100u);
        Property = 0;
        buffer->clumpID = 1;
        flags = buffer->flags;
        buffer->unit = kAudioUnitParameterUnit_Generic;
        v20 = 0x4120000000000000;
LABEL_45:
        *(_QWORD *)&buffer->minValue = v20;
LABEL_46:
        buffer->defaultValue = 0.0;
LABEL_47:
        v19 = -1006632960;
LABEL_48:
        v30 = flags | v19;
        goto LABEL_119;
      default:
        return Property;
    }
  }
  v10 = v6 + 2;
  v11 = a3 - 100;
  v12 = (OpaqueAudioComponentInstance **)((char *)this + 8 * v6 + 800);
  if (a3 - 100 < 0x64)
    v12 = (OpaqueAudioComponentInstance **)((char *)this + 848);
  v13 = *v12;
  switch(v7)
  {
    case 0u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 1u, buffer, &ioDataSize);
      v14 = CFSTR("RMS Limit");
      v15 = CFSTR("Combiner RMS Limit");
      goto LABEL_73;
    case 1u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 2u, buffer, &ioDataSize);
      v14 = CFSTR("Max Noise Rel Gain");
      v15 = CFSTR("Combiner Max Noise Rel Gain");
      goto LABEL_73;
    case 2u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 3u, buffer, &ioDataSize);
      v14 = CFSTR("Max Noise Abs Gain");
      v15 = CFSTR("Combiner Max Noise Abs Gain");
      goto LABEL_73;
    case 3u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 5u, buffer, &ioDataSize);
      v14 = CFSTR("Max Noise Thresh");
      v15 = CFSTR("Combiner Max Noise Thresh");
      goto LABEL_73;
    case 4u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 5u, buffer, &ioDataSize);
      v31 = CFSTR("Max Noise Thresh (Scaled)");
      v32 = CFSTR("Combiner Max Noise Thresh (Scaled)");
      goto LABEL_55;
    case 5u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 4u, buffer, &ioDataSize);
      v14 = CFSTR("Min Sound Thresh");
      v15 = CFSTR("Combiner Min Sound Thresh");
      goto LABEL_73;
    case 6u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 4u, buffer, &ioDataSize);
      v31 = CFSTR("Min Sound Thresh (Scaled)");
      v32 = CFSTR("Combiner Min Sound Thresh (Scaled)");
LABEL_55:
      if (v11 >= 0x64)
        v33 = v31;
      else
        v33 = v32;
      buffer->cfNameString = v33;
      buffer->flags |= 0x8000000u;
      CFStringGetCString(v33, buffer->name, 52, 0x8000100u);
      v34 = buffer->flags & 0x3BFF7FFF;
      v35 = 1140883456;
      goto LABEL_77;
    case 7u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 6u, buffer, &ioDataSize);
      *(int32x2_t *)&buffer->minValue = vrev64_s32((int32x2_t)vmul_f32(vdiv_f32((float32x2_t)vdup_n_s32(0x447A0000u), *(float32x2_t *)&buffer->minValue), (float32x2_t)vdup_n_s32(0x3D75C28Fu)));
      buffer->defaultValue = (float)(1000.0 / buffer->defaultValue) * 0.06;
      v36 = CFSTR("Release Time (ms)");
      v37 = CFSTR("Combiner Release Time (ms)");
      goto LABEL_65;
    case 8u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 7u, buffer, &ioDataSize);
      *(float32x2_t *)&buffer->minValue = vmul_f32(vdiv_f32((float32x2_t)vdup_n_s32(0x447A0000u), *(float32x2_t *)&buffer->minValue), (float32x2_t)vdup_n_s32(0xBD75C28F));
      buffer->defaultValue = (float)(1000.0 / buffer->defaultValue) * -0.06;
      v36 = CFSTR("Attack Time (ms)");
      v37 = CFSTR("Combiner Attack Time (ms)");
      goto LABEL_65;
    case 9u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x28u, buffer, &ioDataSize);
      v36 = CFSTR("Upwards Threshold");
      v37 = CFSTR("Combiner Upwards Threshold");
      goto LABEL_65;
    case 0xAu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x29u, buffer, &ioDataSize);
      v36 = CFSTR("Downwards Threshold");
      v37 = CFSTR("Combiner Downwards Threshold");
      goto LABEL_65;
    case 0xBu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x10u, buffer, &ioDataSize);
      v36 = CFSTR("Upwards Ratio");
      v37 = CFSTR("Combiner Upwards Ratio");
      goto LABEL_65;
    case 0xCu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x33u, buffer, &ioDataSize);
      v36 = CFSTR("Downwards Ratio");
      v37 = CFSTR("Combiner Downwards Ratio");
LABEL_65:
      if (v11 >= 0x64)
        v38 = v36;
      else
        v38 = v37;
      buffer->cfNameString = v38;
      buffer->flags |= 0x8000000u;
      CFStringGetCString(v38, buffer->name, 52, 0x8000100u);
      v30 = buffer->flags | 0xC0000000;
      break;
    case 0xDu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0xBu, buffer, &ioDataSize);
      buffer->cfNameString = CFSTR("Max Volume");
      buffer->flags |= 0x8000000u;
      CFStringGetCString(CFSTR("Max Volume"), buffer->name, 52, 0x8000100u);
      if (v11 >= 0x64)
        v39 = CFSTR("Max Volume");
      else
        v39 = CFSTR("Combiner Max Volume");
      goto LABEL_76;
    case 0xEu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0xAu, buffer, &ioDataSize);
      v14 = CFSTR("Min Volume");
      v15 = CFSTR("Combiner Min Volume");
LABEL_73:
      if (v11 >= 0x64)
        v39 = v14;
      else
        v39 = v15;
LABEL_76:
      buffer->cfNameString = v39;
      buffer->flags |= 0x8000000u;
      CFStringGetCString(v39, buffer->name, 52, 0x8000100u);
      v34 = buffer->flags;
      v35 = -1006632960;
LABEL_77:
      v30 = v34 | v35;
      break;
    case 0xFu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x14u, buffer, &ioDataSize);
      v40 = CFSTR("Low  Volume Knee X");
      v41 = CFSTR("Combiner Low  Volume Knee X");
      goto LABEL_112;
    case 0x10u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x15u, buffer, &ioDataSize);
      v40 = CFSTR("High Volume Knee X");
      v41 = CFSTR("Combiner High Volume Knee X");
      goto LABEL_112;
    case 0x11u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x1Eu, buffer, &ioDataSize);
      v40 = CFSTR("Low  Volume Knee Y");
      v41 = CFSTR("Combiner Low  Volume Knee Y");
      goto LABEL_112;
    case 0x12u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x1Fu, buffer, &ioDataSize);
      v40 = CFSTR("High Volume Knee Y");
      v41 = CFSTR("Combiner High Volume Knee Y");
      goto LABEL_112;
    case 0x13u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0, buffer, &ioDataSize);
      if (v11 >= 0x64)
        v42 = CFSTR("Sound Gain");
      else
        v42 = CFSTR("Combiner Sound Gain");
      buffer->cfNameString = v42;
      buffer->flags |= 0x8000000u;
      CFStringGetCString(v42, buffer->name, 52, 0x8000100u);
      v43 = buffer->flags & 0x3BFF7FFF;
      v44 = 1140883456;
      goto LABEL_116;
    case 0x14u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 8u, buffer, &ioDataSize);
      v40 = CFSTR("Smooth Win (ms)");
      v41 = CFSTR("Combiner Smooth Win (ms)");
      goto LABEL_112;
    case 0x15u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 9u, buffer, &ioDataSize);
      v40 = CFSTR("BlockSize (ms)");
      v41 = CFSTR("Combiner BlockSize (ms)");
      goto LABEL_112;
    case 0x16u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x41u, buffer, &ioDataSize);
      v40 = CFSTR("Short Win Enabled");
      v41 = CFSTR("Combiner Short Win Enabled");
      goto LABEL_112;
    case 0x17u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x42u, buffer, &ioDataSize);
      v40 = CFSTR("Short Win PeakDetector");
      v41 = CFSTR("Combiner Short Win PeakDetector");
      goto LABEL_112;
    case 0x18u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x43u, buffer, &ioDataSize);
      v40 = CFSTR("Short Win (ms)");
      v41 = CFSTR("Combiner Short Win (ms)");
      goto LABEL_112;
    case 0x19u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x44u, buffer, &ioDataSize);
      *(float32x2_t *)&buffer->minValue = vmul_f32(*(float32x2_t *)&buffer->minValue, (float32x2_t)vdup_n_s32(0x447A0000u));
      buffer->defaultValue = buffer->defaultValue * 1000.0;
      v40 = CFSTR("Short Win Attack (ms)");
      v41 = CFSTR("Combiner Short Win Attack (ms)");
      goto LABEL_112;
    case 0x1Au:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x45u, buffer, &ioDataSize);
      *(float32x2_t *)&buffer->minValue = vmul_f32(*(float32x2_t *)&buffer->minValue, (float32x2_t)vdup_n_s32(0x447A0000u));
      buffer->defaultValue = buffer->defaultValue * 1000.0;
      v40 = CFSTR("Short Win Release (ms)");
      v41 = CFSTR("Combiner Short Win Release (ms)");
      goto LABEL_112;
    case 0x1Bu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x46u, buffer, &ioDataSize);
      v40 = CFSTR("Short Win Max dBRMS");
      v41 = CFSTR("Combiner Short Win Max dBRMS");
      goto LABEL_112;
    case 0x1Cu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x3Eu, buffer, &ioDataSize);
      v45 = CFSTR("Compression Amount");
      v46 = CFSTR("Combiner Compression Amount");
      goto LABEL_97;
    case 0x1Du:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x3Fu, buffer, &ioDataSize);
      v45 = CFSTR("Input Amplitude");
      v46 = CFSTR("Combiner Input Amplitude");
      goto LABEL_97;
    case 0x1Eu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x40u, buffer, &ioDataSize);
      v45 = CFSTR("Output Amplitude");
      v46 = CFSTR("Combiner Output Amplitude");
LABEL_97:
      if (v11 >= 0x64)
        v47 = v45;
      else
        v47 = v46;
      buffer->cfNameString = v47;
      buffer->flags |= 0x8000000u;
      CFStringGetCString(v47, buffer->name, 52, 0x8000100u);
      v43 = buffer->flags & 0x7FFFFFFF;
      v44 = 1073774592;
      goto LABEL_116;
    case 0x1Fu:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x48u, buffer, &ioDataSize);
      v40 = CFSTR("Long Win Enabled");
      v41 = CFSTR("Combiner Long Win Enabled");
      goto LABEL_112;
    case 0x20u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x49u, buffer, &ioDataSize);
      v40 = CFSTR("Long Win Sec");
      v41 = CFSTR("Combiner Long Win Sec");
      goto LABEL_112;
    case 0x21u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x4Au, buffer, &ioDataSize);
      *(float32x2_t *)&buffer->minValue = vmul_f32(*(float32x2_t *)&buffer->minValue, (float32x2_t)vdup_n_s32(0x447A0000u));
      buffer->defaultValue = buffer->defaultValue * 1000.0;
      v40 = CFSTR("Long Win Attack (ms)");
      v41 = CFSTR("Combiner Long Win Attack (ms)");
      goto LABEL_112;
    case 0x22u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x4Bu, buffer, &ioDataSize);
      *(float32x2_t *)&buffer->minValue = vmul_f32(*(float32x2_t *)&buffer->minValue, (float32x2_t)vdup_n_s32(0x447A0000u));
      buffer->defaultValue = buffer->defaultValue * 1000.0;
      v40 = CFSTR("Long Win Release (ms)");
      v41 = CFSTR("Combiner Long Win Release (ms)");
      goto LABEL_112;
    case 0x23u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x4Cu, buffer, &ioDataSize);
      v40 = CFSTR("Long Win Max dBRMS");
      v41 = CFSTR("Combiner Long Win Max dBRMS");
      goto LABEL_112;
    case 0x24u:
      buffer->cfNameString = CFSTR("Make Up Gain");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Make Up Gain"), buffer->name, 52, 0x8000100u);
      Property = 0;
      buffer->unit = kAudioUnitParameterUnit_Generic;
      v48 = 0x41A0000000000000;
      goto LABEL_109;
    case 0x25u:
      buffer->cfNameString = CFSTR("Monitor Band");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Monitor Band"), buffer->name, 52, 0x8000100u);
      Property = 0;
      buffer->unit = kAudioUnitParameterUnit_Boolean;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      v30 = buffer->flags | 0xD0000000;
      goto LABEL_110;
    case 0x26u:
      buffer->cfNameString = CFSTR("Bypass Band Comp");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Bypass Band Comp"), buffer->name, 52, 0x8000100u);
      Property = 0;
      buffer->unit = kAudioUnitParameterUnit_Boolean;
      v48 = 0x3F80000000000000;
LABEL_109:
      *(_QWORD *)&buffer->minValue = v48;
      v30 = buffer->flags | 0xC0000000;
LABEL_110:
      buffer->defaultValue = 0.0;
      goto LABEL_117;
    case 0x27u:
      Property = AudioUnitGetProperty(v13, 4u, 0, 0x47u, buffer, &ioDataSize);
      v40 = CFSTR("Short Win Max dBFs");
      v41 = CFSTR("Combiner Short Win Max dbFS");
LABEL_112:
      if (v11 >= 0x64)
        v49 = v40;
      else
        v49 = v41;
      buffer->cfNameString = v49;
      buffer->flags |= 0x8000000u;
      CFStringGetCString(v49, buffer->name, 52, 0x8000100u);
      v43 = buffer->flags;
      v44 = -1006632960;
LABEL_116:
      v30 = v43 | v44;
LABEL_117:
      buffer->flags = v30;
      break;
    default:
      Property = 4294956418;
      v30 = -1073741824;
      break;
  }
  buffer->clumpID = v10;
LABEL_119:
  v23 = v30 | 0x100000;
LABEL_120:
  buffer->flags = v23;
  return Property;
}

UInt8 *AUMultiBandDynamicsProcessorV2::SaveExtendedScopes(AUMultiBandDynamicsProcessorV2 *this, __CFData *a2)
{
  ausdk::AUScope *Scope;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);
  return ausdk::AUScope::SaveState(Scope, a2);
}

uint64_t AUMultiBandDynamicsProcessorV2::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
    ++*((_DWORD *)this + 132);
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::CopyClumpName(AUMultiBandDynamicsProcessorV2 *this, int a2, int a3, unsigned int a4, __CFString **a5)
{
  uint64_t result;
  __CFString *v7;

  if (a2)
    return 4294956430;
  if ((a3 - 1) > 7)
    return 4294956418;
  v7 = off_1E69ECA88[a3 - 1];
  CFRetain(v7);
  result = 0;
  *a5 = v7;
  return result;
}

void AUMultiBandDynamicsProcessorV2::GetLatency(AUMultiBandDynamicsProcessorV2 *this)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  _QWORD *v4;
  uint64_t v5;
  ausdk::AUElement *v6;
  ausdk::AUElement **v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;

  if (*((_BYTE *)this + 17) && !*((_BYTE *)this + 1256))
  {
    v2 = *((_QWORD *)this + 9);
    if (v2)
    {
      v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD, double))(*(_QWORD *)v2 + 32))(v2, 0, 0.0);
    }
    else
    {
      v4 = (_QWORD *)*((_QWORD *)this + 6);
      v3 = *((_QWORD **)this + 7) == v4 ? 0 : (ausdk::AUElement *)*v4;
    }
    ausdk::AUElement::GetParameter(v3, 0xDDu);
    if (*((_DWORD *)this + 216))
    {
      v5 = *((_QWORD *)this + 9);
      if (v5)
      {
        v6 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
      }
      else
      {
        v7 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v7)
          v6 = 0;
        else
          v6 = *v7;
      }
      ausdk::AUElement::GetParameter(v6, 0x17u);
      v8 = *((_QWORD *)this + 9);
      if (v8)
      {
        v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
      }
      else
      {
        v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v10)
          v9 = 0;
        else
          v9 = *v10;
      }
      ausdk::AUElement::GetParameter(v9, 0x18u);
    }
  }
}

double AUMultiBandDynamicsProcessorV2::GetTailTime(AudioUnit *this)
{
  UInt32 ioDataSize;
  double v4;
  double outData;

  v4 = 0.05;
  outData = 0.05;
  ioDataSize = 8;
  AudioUnitGetProperty(this[102], 0x14u, 0, 0, &outData, &ioDataSize);
  AudioUnitGetProperty(this[86], 0x14u, 0, 0, &v4, &ioDataSize);
  return outData + outData + v4;
}

uint64_t AUMultiBandDynamicsProcessorV2::SupportsTail(AUMultiBandDynamicsProcessorV2 *this)
{
  return 1;
}

BOOL AUMultiBandDynamicsProcessorV2::StreamFormatWritable(AUMultiBandDynamicsProcessorV2 *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUMultiBandDynamicsProcessorV2::SupportedNumChannels(AUMultiBandDynamicsProcessorV2 *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUMultiBandDynamicsProcessorV2::SupportedNumChannels(AUChannelInfo const**)::chans;
  return 7;
}

uint64_t AUMultiBandDynamicsProcessorV2::ValidFormat(AUMultiBandDynamicsProcessorV2 *this, unsigned int a2, int a3, const AudioStreamBasicDescription *a4)
{
  UInt32 mChannelsPerFrame;
  unsigned int v5;
  BOOL v6;

  mChannelsPerFrame = a4->mChannelsPerFrame;
  v5 = (LOBYTE(a4->mFormatFlags) >> 5) & 1;
  if (mChannelsPerFrame == 1)
    v5 = 1;
  if (a3)
    v6 = 0;
  else
    v6 = mChannelsPerFrame >= 9;
  if (v6)
    return 0;
  else
    return v5;
}

uint64_t AUMultiBandDynamicsProcessorV2::GetScopeExtended(AUMultiBandDynamicsProcessorV2 *this, int a2)
{
  if (a2 == 4)
    return (uint64_t)this + 1320;
  else
    return 0;
}

uint64_t AUMultiBandDynamicsProcessorV2::DetermineBandsToProcess(AUMultiBandDynamicsProcessorV2 *this)
{
  float v2;
  uint64_t i;
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  float Parameter;
  uint64_t v8;
  float v9;
  uint64_t result;
  BOOL v11;
  _DWORD v12[5];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *(double *)(ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0) + 80)
     * 0.49000001;
  v12[0] = 0;
  *(float *)&v12[4] = v2;
  for (i = 1; i != 4; ++i)
  {
    v4 = *((_QWORD *)this + 9);
    if (v4)
    {
      v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
    }
    else
    {
      v6 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v6)
        v5 = 0;
      else
        v5 = *v6;
    }
    Parameter = ausdk::AUElement::GetParameter(v5, i + 7);
    if (Parameter > v2)
      Parameter = v2;
    *(float *)&v12[i] = Parameter;
  }
  v8 = 0;
  v9 = 0.0;
  do
  {
    result = v8;
    if (v8 == 4)
      break;
    if (v9 >= v2)
      break;
    ++v8;
    v11 = (float)(v2 - v9) < (float)((float)(*(float *)&v12[result + 1] - v9) * 0.35);
    v9 = *(float *)&v12[result + 1];
  }
  while (!v11);
  return result;
}

uint64_t *AUMultiBandDynamicsProcessorV2::DoBlockProcess(uint64_t this, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, const AudioBufferList *a5, AudioBufferList *a6)
{
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  float Parameter;
  AudioUnitParameterValue v17;
  unint64_t v18;
  __int128 v20;
  __int128 v21;
  unsigned int v22;
  double mSampleTime;
  uint64_t v24;
  size_t v25;
  uint64_t v26;
  AudioBufferList *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t mNumberBuffers;
  unint64_t v32;
  int v33;
  int v34;
  int v35;
  char *v36;
  char *v37;
  ausdk::AUBufferList *v38;
  const AudioStreamBasicDescription *Element;
  _DWORD *v40;
  AudioBufferList *v41;
  unsigned int v42;
  _DWORD *exception;
  ausdk::AUScope *v44;
  unsigned int *v45;
  AudioTimeStamp v46;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  int v50;
  uint64_t v51;

  v45 = a2;
  v10 = this;
  v51 = *MEMORY[0x1E0C80C00];
  v11 = *(_DWORD *)(this + 528);
  if (v11 != *(_DWORD *)(this + 532))
  {
    AUMultiBandDynamicsProcessorV2::UpdateMBDPState((AUMultiBandDynamicsProcessorV2 *)this);
    *(_DWORD *)(v10 + 532) = v11;
  }
  v12 = *(_DWORD *)(v10 + 536);
  if (v12 != *(_DWORD *)(v10 + 540))
  {
    v13 = *(_QWORD *)(v10 + 72);
    if (v13)
    {
      v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
    }
    else
    {
      v15 = *(ausdk::AUElement ***)(v10 + 48);
      if (*(ausdk::AUElement ***)(v10 + 56) == v15)
        v14 = 0;
      else
        v14 = *v15;
    }
    Parameter = ausdk::AUElement::GetParameter(v14, 0);
    if (*(_DWORD *)(v10 + 552))
    {
      v17 = Parameter;
      v18 = 0;
      do
        this = AudioUnitSetParameter(*(AudioUnit *)(v10 + 816 + 8 * v18++), 0xCu, 0, 0, v17, 0);
      while (v18 < *(unsigned int *)(v10 + 552));
    }
    *(_DWORD *)(v10 + 540) = v12;
  }
  if (*(_DWORD *)(v10 + 544))
  {
    CopyBufferList(&a5->mNumberBuffers, a6, *(_DWORD *)(v10 + 1248) * a4);
    return 0;
  }
  v20 = *(_OWORD *)&a3->mRateScalar;
  *(_OWORD *)&v46.mSampleTime = *(_OWORD *)&a3->mSampleTime;
  *(_OWORD *)&v46.mRateScalar = v20;
  v21 = *(_OWORD *)&a3->mSMPTETime.mHours;
  *(_OWORD *)&v46.mSMPTETime.mSubframes = *(_OWORD *)&a3->mSMPTETime.mSubframes;
  *(_OWORD *)&v46.mSMPTETime.mHours = v21;
  if (*(_BYTE *)(v10 + 1256))
  {
    if (a4)
    {
      v22 = 0;
      mSampleTime = v46.mSampleTime;
      v44 = (ausdk::AUScope *)(v10 + 128);
      do
      {
        v24 = *(unsigned int *)(v10 + 1244);
        if ((v24 - 65) <= 0xFFFFFFBF)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            v48 = "AUMultiBandDynamicsProcessorV2.cpp";
            v49 = 1024;
            v50 = 2149;
            _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  STACK_ABL: invalid number of buffers", buf, 0x12u);
          }
          exception = __cxa_allocate_exception(0x10uLL);
          *(_QWORD *)exception = &off_1E69EE218;
          exception[2] = -50;
        }
        v25 = 16 * (v24 - 1) + 24;
        MEMORY[0x1E0C80A78](this);
        v27 = (AudioBufferList *)((char *)&v44 - ((v26 + 39) & 0x1FFFFFFFF0));
        bzero(v27, v25);
        v27->mNumberBuffers = v24;
        MEMORY[0x1E0C80A78](v28);
        bzero(v27, v25);
        v29 = 0;
        v30 = 0;
        v27->mNumberBuffers = v24;
        mNumberBuffers = a5->mNumberBuffers;
        v32 = a6->mNumberBuffers;
        v33 = 4 * *(_DWORD *)(v10 + 1252);
        do
        {
          if (v30 >= mNumberBuffers)
            v34 = mNumberBuffers - 1;
          else
            v34 = v30;
          if (v30 >= v32)
            v35 = v32 - 1;
          else
            v35 = v30;
          v36 = (char *)v27 + v29;
          v37 = (char *)v27 + v29;
          *((_DWORD *)v36 + 2) = 1;
          *((_DWORD *)v36 + 3) = v33;
          *((_DWORD *)v37 + 2) = 1;
          *((_DWORD *)v37 + 3) = v33;
          *((_QWORD *)v37 + 2) = (char *)a5->mBuffers[v34].mData + 4 * v22;
          *((_QWORD *)v36 + 2) = (char *)a6->mBuffers[v35].mData + 4 * v22;
          ++v30;
          v29 += 16;
        }
        while (v24 != v30);
        v38 = *(ausdk::AUBufferList **)(v10 + 896);
        Element = (const AudioStreamBasicDescription *)ausdk::AUScope::SafeGetElement(v44, 0);
        v40 = (_DWORD *)ausdk::AUBufferList::PrepareBuffer(v38, Element + 2, *(_DWORD *)(v10 + 1252));
        CopyBufferList(&v27->mNumberBuffers, v40, (*(_DWORD *)(v10 + 1248) * *(_DWORD *)(v10 + 1252)));
        this = AUMultiBandDynamicsProcessorV2::DoCoreProcess((AUMultiBandDynamicsProcessorV2 *)v10, v45, &v46, *(unsigned int *)(v10 + 1252), v27, v41);
        v42 = *(_DWORD *)(v10 + 1252);
        v22 += v42;
        mSampleTime = mSampleTime + (double)v42;
        v46.mSampleTime = mSampleTime;
        a4 -= v42;
      }
      while (a4);
    }
    return 0;
  }
  if (*(_BYTE *)(v10 + 1257))
    return (uint64_t *)AUMultiBandDynamicsProcessorV2::DoFixedBlockLatencyProcess((AUMultiBandDynamicsProcessorV2 *)v10, v45, &v46, a4, a5, a6);
  else
    return AUMultiBandDynamicsProcessorV2::DoVariableBlockLatencyProcess((uint64_t *)v10, v45, &v46, a4, a5, a6);
}

uint64_t AUMultiBandDynamicsProcessorV2::DoCombinerLimiter(AUMultiBandDynamicsProcessorV2 *this, unsigned int *a2, const AudioTimeStamp *a3, UInt32 inNumberFrames, AudioBufferList *ioData)
{
  uint64_t result;
  float v9;
  unint64_t v10;
  uint64_t v11;
  float __B;

  if (!*((_BYTE *)this + 1276) || *((_DWORD *)this + 136))
    return 0;
  if (*((_BYTE *)this + 1284)
    || (result = AudioUnitProcess(*((AudioUnit *)this + 106), a2, a3, inNumberFrames, ioData), !(_DWORD)result))
  {
    AUMultiBandDynamicsProcessorV2::GetVolCompState(this, *((AudioUnit *)this + 106), 0);
    v9 = *((float *)this + 323);
    if (v9 != 0.0)
    {
      __B = __exp10f(v9 / 20.0);
      if (ioData->mNumberBuffers)
      {
        v10 = 0;
        v11 = 16;
        do
        {
          vDSP_vsmul(*(const float **)((char *)&ioData->mNumberBuffers + v11), 1, &__B, *(float **)((char *)&ioData->mNumberBuffers + v11), 1, inNumberFrames);
          ++v10;
          v11 += 16;
        }
        while (v10 < ioData->mNumberBuffers);
      }
    }
    return 0;
  }
  return result;
}

void AUMultiBandDynamicsProcessorV2::GetVolCompState(AUMultiBandDynamicsProcessorV2 *this, AudioUnit inUnit, int a3)
{
  uint64_t v6;
  ausdk::AUElement *v7;
  _QWORD *v8;
  uint64_t v9;
  ausdk::AUElement *v10;
  _QWORD *v11;
  uint64_t v12;
  ausdk::AUElement *v13;
  _QWORD *v14;
  float Parameter;
  float v16;
  uint64_t v17;
  ausdk::AUElement *v18;
  _QWORD *v19;
  uint64_t v20;
  ausdk::AUElement *v21;
  ausdk::AUElement **v22;
  uint64_t v23;
  ausdk::AUElement *v24;
  ausdk::AUElement **v25;
  uint64_t v26;
  ausdk::AUElement *v27;
  ausdk::AUElement **v28;
  AudioUnitParameterValue outValue;

  if (*((_BYTE *)this + 1313))
  {
    outValue = 0.0;
    AudioUnitGetParameter(inUnit, 0x3Eu, 0, 0, &outValue);
    v6 = *((_QWORD *)this + 9);
    if (v6)
    {
      v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
    }
    else
    {
      v8 = (_QWORD *)*((_QWORD *)this + 6);
      v7 = *((_QWORD **)this + 7) == v8 ? 0 : (ausdk::AUElement *)*v8;
    }
    ausdk::AUElement::SetParameter(v7, a3 + 128, outValue, 0);
    AudioUnitGetParameter(inUnit, 0x3Fu, 0, 0, &outValue);
    v9 = *((_QWORD *)this + 9);
    if (v9)
    {
      v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
    }
    else
    {
      v11 = (_QWORD *)*((_QWORD *)this + 6);
      v10 = *((_QWORD **)this + 7) == v11 ? 0 : (ausdk::AUElement *)*v11;
    }
    ausdk::AUElement::SetParameter(v10, a3 + 129, outValue, 0);
    AudioUnitGetParameter(inUnit, 0x40u, 0, 0, &outValue);
    v12 = *((_QWORD *)this + 9);
    if (v12)
    {
      v13 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, 0);
    }
    else
    {
      v14 = (_QWORD *)*((_QWORD *)this + 6);
      v13 = *((_QWORD **)this + 7) == v14 ? 0 : (ausdk::AUElement *)*v14;
    }
    Parameter = ausdk::AUElement::GetParameter(v13, a3 + 136);
    v16 = Parameter + outValue;
    outValue = v16;
    v17 = *((_QWORD *)this + 9);
    if (v17)
    {
      v18 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 32))(v17, 0);
      v16 = outValue;
    }
    else
    {
      v19 = (_QWORD *)*((_QWORD *)this + 6);
      v18 = *((_QWORD **)this + 7) == v19 ? 0 : (ausdk::AUElement *)*v19;
    }
    ausdk::AUElement::SetParameter(v18, a3 + 130, v16, 0);
    if (*((_BYTE *)this + 1314))
    {
      AudioUnitGetParameter(inUnit, 0x3Du, 0, 0, &outValue);
      v20 = *((_QWORD *)this + 9);
      if (v20)
      {
        v21 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 32))(v20, 0);
      }
      else
      {
        v22 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v22)
          v21 = 0;
        else
          v21 = *v22;
      }
      ausdk::AUElement::SetParameter(v21, a3 + 104, outValue, 0);
      AudioUnitGetParameter(inUnit, 0x3Cu, 0, 0, &outValue);
      v23 = *((_QWORD *)this + 9);
      if (v23)
      {
        v24 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
      }
      else
      {
        v25 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v25)
          v24 = 0;
        else
          v24 = *v25;
      }
      ausdk::AUElement::SetParameter(v24, a3 + 106, outValue, 0);
      AudioUnitGetParameter(inUnit, 0, 0, 0, &outValue);
      v26 = *((_QWORD *)this + 9);
      if (v26)
      {
        v27 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 32))(v26, 0);
      }
      else
      {
        v28 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v28)
          v27 = 0;
        else
          v27 = *v28;
      }
      ausdk::AUElement::SetParameter(v27, a3 + 119, outValue, 0);
    }
  }
}

void AUMultiBandDynamicsProcessorV2::UpdateMBDPState(AUMultiBandDynamicsProcessorV2 *this)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  OpaqueAudioComponentInstance *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  char v13;
  ausdk::AUElement **v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  _QWORD *v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  _QWORD *v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  _QWORD *v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  float Parameter;
  uint64_t v34;
  ausdk::AUElement *v35;
  ausdk::AUElement **v36;
  float v37;

  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v4 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  if (ausdk::AUElement::GetParameter(v3, 0x16u) == 1)
    v5 = 4;
  else
    v5 = 2;
  *((_DWORD *)this + 214) = v5;
  *((_DWORD *)this + 320) = 0;
  if (*((_DWORD *)this + 138))
  {
    v6 = 0;
    v7 = 100;
    do
    {
      v8 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + v6++ + 102);
      AUMultiBandDynamicsProcessorV2::UpdateVolComp(this, v8, v7);
      v7 += 100;
    }
    while (v6 < *((unsigned int *)this + 138));
  }
  if (*((_BYTE *)this + 1314))
    AUMultiBandDynamicsProcessorV2::UpdateVolComp(this, *((OpaqueAudioComponentInstance **)this + 106), 0);
  AUMultiBandDynamicsProcessorV2::CalculateVolCompGainOffset(this);
  v9 = AUMultiBandDynamicsProcessorV2::DetermineBandsToProcess(this);
  v10 = *((_DWORD *)this + 138);
  if (v10 >= v9)
    v10 = v9;
  *((_DWORD *)this + 318) = v10;
  if (*((_DWORD *)this + 320) > v10)
    *((_DWORD *)this + 320) = 0;
  AUMultiBandDynamicsProcessorV2::UpdateCrossOverEQs((uint64_t)this);
  if (*((_BYTE *)this + 1314) && *((_DWORD *)this + 318) <= 1u)
  {
    v11 = *((_QWORD *)this + 9);
    if (v11)
    {
      v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
    }
    else
    {
      v14 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v14)
        v12 = 0;
      else
        v12 = *v14;
    }
    if (ausdk::AUElement::GetParameter(v12, 7u) == 0.0)
    {
      v15 = *((_QWORD *)this + 9);
      if (v15)
      {
        v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
      }
      else
      {
        v17 = (_QWORD *)*((_QWORD *)this + 6);
        v16 = *((_QWORD **)this + 7) == v17 ? 0 : (ausdk::AUElement *)*v17;
      }
      if (ausdk::AUElement::GetParameter(v16, 6u) > 0.0)
        goto LABEL_60;
    }
    v18 = *((_QWORD *)this + 9);
    if (v18)
    {
      v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
    }
    else
    {
      v20 = (_QWORD *)*((_QWORD *)this + 6);
      v19 = *((_QWORD **)this + 7) == v20 ? 0 : (ausdk::AUElement *)*v20;
    }
    if (ausdk::AUElement::GetParameter(v19, 0x6Fu) != 1.0)
      goto LABEL_60;
    v21 = *((_QWORD *)this + 9);
    if (v21)
    {
      v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
    }
    else
    {
      v23 = (_QWORD *)*((_QWORD *)this + 6);
      v22 = *((_QWORD **)this + 7) == v23 ? 0 : (ausdk::AUElement *)*v23;
    }
    if (ausdk::AUElement::GetParameter(v22, 0x70u) == 1.0
      && ((v24 = *((_QWORD *)this + 9)) == 0
        ? ((v26 = (ausdk::AUElement **)*((_QWORD *)this + 6), *((ausdk::AUElement ***)this + 7) == v26)
         ? (v25 = 0)
         : (v25 = *v26))
        : (v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0)),
          ausdk::AUElement::GetParameter(v25, 0x7Au) == 0.0
       && ((v27 = *((_QWORD *)this + 9)) == 0
         ? ((v29 = (ausdk::AUElement **)*((_QWORD *)this + 6), *((ausdk::AUElement ***)this + 7) == v29)
          ? (v28 = 0)
          : (v28 = *v29))
         : (v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0)),
           ausdk::AUElement::GetParameter(v28, 0x83u) == 0.0)))
    {
      v13 = *((_BYTE *)this + 1314);
      if (v13)
      {
        v30 = *((_QWORD *)this + 9);
        if (v30)
        {
          v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
        }
        else
        {
          v32 = (ausdk::AUElement **)*((_QWORD *)this + 6);
          if (*((ausdk::AUElement ***)this + 7) == v32)
            v31 = 0;
          else
            v31 = *v32;
        }
        Parameter = ausdk::AUElement::GetParameter(v31, 0xC8u);
        v34 = *((_QWORD *)this + 9);
        if (v34)
        {
          v35 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v34 + 32))(v34, 0);
        }
        else
        {
          v36 = (ausdk::AUElement **)*((_QWORD *)this + 6);
          if (*((ausdk::AUElement ***)this + 7) == v36)
            v35 = 0;
          else
            v35 = *v36;
        }
        v37 = ausdk::AUElement::GetParameter(v35, 0x64u);
        if (v37 < Parameter)
          AudioUnitSetParameter(*((AudioUnit *)this + 102), 1u, 0, 0, v37, 0);
        v13 = 0;
      }
    }
    else
    {
LABEL_60:
      v13 = 1;
    }
  }
  else
  {
    v13 = *((_BYTE *)this + 1314) != 0;
  }
  *((_BYTE *)this + 1276) = v13;
}

unsigned int *CopyBufferList(unsigned int *result, _DWORD *a2, size_t __n)
{
  unint64_t v3;
  unsigned int v5;
  unsigned int *v7;
  uint64_t v8;
  unint64_t v9;
  size_t v10;

  v3 = *result;
  if (v3 == *a2 && v3 != 0)
  {
    v5 = __n;
    v7 = result;
    v8 = 0;
    v9 = 0;
    v10 = __n;
    do
    {
      if (v7[v8 + 3] >= v5 && a2[v8 + 3] >= v5)
      {
        result = (unsigned int *)memcpy(*(void **)&a2[v8 + 4], *(const void **)&v7[v8 + 4], v10);
        v3 = *v7;
      }
      ++v9;
      v8 += 4;
    }
    while (v9 < v3);
  }
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::DoCoreProcess(AUMultiBandDynamicsProcessorV2 *this, unsigned int *a2, const AudioTimeStamp *a3, vDSP_Length a4, AudioBufferList *a5, AudioBufferList *a6)
{
  vDSP_Length v7;
  __int128 v11;
  __int128 v12;
  _DWORD *v13;
  unint64_t v14;
  void **v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  float Parameter;
  BOOL v19;
  ausdk::AUElement **v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  float v23;
  ausdk::AUElement **v24;
  char v25;
  uint64_t BufferList;
  float v27;
  float v28;
  float v29;
  uint64_t Element;
  float v31;
  double v32;
  float v33;
  float v34;
  char v35;
  unint64_t v36;
  float **v37;
  float *v38;
  float v39;
  unint64_t v40;
  float **v41;
  float *v42;
  unsigned int *v43;
  unint64_t v44;
  uint64_t v45;
  float v46;
  unint64_t v47;
  __int128 v48;
  __int128 v49;
  UInt32 v50;
  vDSP_Length v51;
  unint64_t v52;
  uint64_t v53;
  BOOL v54;
  unsigned int *v55;
  unint64_t v56;
  float *v57;
  uint64_t v58;
  float v59;
  __int128 v60;
  __int128 v61;
  ausdk::AUBufferList *v62;
  const AudioStreamBasicDescription *v63;
  unsigned int *v64;
  AudioBufferList *v65;
  int v66;
  AUMultiBandDynamicsProcessorV2 *v67;
  unsigned int *v68;
  AudioBufferList *v69;
  unsigned int v70;
  __int128 v71;
  __int128 v72;
  ausdk::AUBufferList *v73;
  const AudioStreamBasicDescription *v74;
  unsigned int *v75;
  AudioBufferList *v76;
  int v77;
  char v78;
  float v79;
  float v80;
  float v81;
  uint64_t v82;
  float v83;
  double v84;
  float v85;
  float v86;
  int v87;
  unint64_t v88;
  uint64_t v89;
  float v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t result;
  BOOL v94;
  char v95;
  char *v96;
  float __Start;
  AudioTimeStamp inTimeStamp;
  float __Step;
  AudioTimeStamp __B;

  v7 = a4;
  if (*((_BYTE *)this + 1240))
  {
    (*(void (**)(AUMultiBandDynamicsProcessorV2 *, _QWORD, _QWORD, vDSP_Length, AudioBufferList *, AudioBufferList *))(*(_QWORD *)this + 72))(this, 0, 0, a4, a5, a6);
    *((_BYTE *)this + 1240) = 0;
  }
  v11 = *(_OWORD *)&a3->mRateScalar;
  *(_OWORD *)&inTimeStamp.mSampleTime = *(_OWORD *)&a3->mSampleTime;
  *(_OWORD *)&inTimeStamp.mRateScalar = v11;
  v12 = *(_OWORD *)&a3->mSMPTETime.mHours;
  *(_OWORD *)&inTimeStamp.mSMPTETime.mSubframes = *(_OWORD *)&a3->mSMPTETime.mSubframes;
  *(_OWORD *)&inTimeStamp.mSMPTETime.mHours = v12;
  v13 = (_DWORD *)*((_QWORD *)this + 110);
  if (*v13)
  {
    v14 = 0;
    v15 = (void **)(v13 + 4);
    do
    {
      bzero(*v15, *((unsigned int *)v15 - 1));
      ++v14;
      v15 += 2;
    }
    while (v14 < *v13);
  }
  if (*((_BYTE *)this + 1314))
  {
    v16 = *((_QWORD *)this + 9);
    if (v16)
    {
      v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD, const AudioTimeStamp *, vDSP_Length, AudioBufferList *, AudioBufferList *))(*(_QWORD *)v16 + 32))(v16, 0, a3, a4, a5, a6);
    }
    else
    {
      v20 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v20)
        v17 = 0;
      else
        v17 = *v20;
    }
    Parameter = ausdk::AUElement::GetParameter(v17, 6u);
    if (*((_BYTE *)this + 1314))
    {
      v21 = *((_QWORD *)this + 9);
      if (v21)
      {
        v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
      }
      else
      {
        v24 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v24)
          v22 = 0;
        else
          v22 = *v24;
      }
      v23 = ausdk::AUElement::GetParameter(v22, 7u);
    }
    else
    {
      v23 = 1.0;
    }
    v19 = v23 != 0.0;
    if (Parameter != 0.0)
    {
      v25 = 1;
      if (v23 == 0.0)
      {
        v19 = 0;
        goto LABEL_43;
      }
LABEL_26:
      BufferList = ausdk::AUBufferList::GetBufferList(*((ausdk::AUBufferList **)this + 112));
      v27 = __exp10f(Parameter / 20.0);
      *(float *)&__B.mSampleTime = v27;
      v28 = *((float *)this + 219);
      if (v28 == v27)
      {
        if (*((_DWORD *)this + 311))
        {
          v36 = 0;
          v37 = (float **)(BufferList + 16);
          do
          {
            v38 = *v37;
            v37 += 2;
            vDSP_vsmul(v38, 1, (const float *)&__B, v38, 1, v7);
            ++v36;
          }
          while (v36 < *((unsigned int *)this + 311));
        }
        goto LABEL_42;
      }
      v29 = v27;
      Element = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
      v31 = (float)v7;
      v32 = 1000.0 / *(double *)(Element + 80);
      if (v29 <= v28)
      {
        v39 = v32 * (float)((float)(v28 * 0.98855) - v28);
        __Step = v39;
        v34 = *((float *)this + 219);
        if ((float)(v34 + (float)(v39 * v31)) >= v29)
          goto LABEL_29;
      }
      else
      {
        v33 = v32 * (float)((float)(v28 * 1.0116) - v28);
        __Step = v33;
        v34 = *((float *)this + 219);
        if ((float)(v34 + (float)(v33 * v31)) <= v29)
        {
LABEL_29:
          v35 = 0;
LABEL_36:
          if (*((_DWORD *)this + 311))
          {
            v40 = 0;
            v41 = (float **)(BufferList + 16);
            do
            {
              __Start = *((float *)this + 219);
              v42 = *v41;
              v41 += 2;
              vDSP_vrampmul(v42, 1, &__Start, &__Step, v42, 1, v7);
              ++v40;
            }
            while (v40 < *((unsigned int *)this + 311));
            v34 = __Start;
          }
          *((float *)this + 219) = v34;
          if ((v35 & 1) != 0)
            *((_DWORD *)this + 219) = LODWORD(__B.mSampleTime);
LABEL_42:
          v19 = 1;
          goto LABEL_43;
        }
      }
      __Step = (float)(v29 - v34) / v31;
      v35 = 1;
      goto LABEL_36;
    }
  }
  else
  {
    Parameter = 0.0;
    v19 = 1;
  }
  v25 = 0;
  if (*((float *)this + 219) != 1.0 && v19)
    goto LABEL_26;
LABEL_43:
  v43 = (unsigned int *)ausdk::AUBufferList::GetBufferList(*((ausdk::AUBufferList **)this + 112));
  switch(*((_DWORD *)this + 318))
  {
    case 0:
      CopyBufferList(v43, *((_DWORD **)this + 110), (*((_DWORD *)this + 312) * v7));
      break;
    case 1:
      CopyBufferList(v43, a5, (*((_DWORD *)this + 312) * v7));
      if (*((_BYTE *)this + 1285))
        goto LABEL_46;
      result = AudioUnitProcess(*((AudioUnit *)this + 102), a2, &inTimeStamp, v7, a5);
      if ((_DWORD)result)
        return result;
      AUMultiBandDynamicsProcessorV2::GetVolCompState(this, *((AudioUnit *)this + 102), 100);
LABEL_46:
      if (*((_DWORD *)this + 311))
      {
        v44 = 0;
        v45 = 16;
        do
        {
          v46 = *((float *)this + 324);
          if (v46 == 0.0)
          {
            vDSP_vadd(*(const float **)((char *)&a5->mNumberBuffers + v45), 1, *(const float **)(*((_QWORD *)this + 110) + v45), 1, *(float **)(*((_QWORD *)this + 110) + v45), 1, v7);
          }
          else
          {
            LODWORD(__B.mSampleTime) = 0;
            LODWORD(__B.mSampleTime) = __exp10f(v46 / 20.0);
            vDSP_vsma(*(const float **)((char *)&a5->mNumberBuffers + v45), 1, (const float *)&__B, *(const float **)(*((_QWORD *)this + 110) + v45), 1, *(float **)(*((_QWORD *)this + 110) + v45), 1, v7);
          }
          ++v44;
          v45 += 16;
        }
        while (v44 < *((unsigned int *)this + 311));
      }
      break;
    case 2:
      v94 = v19;
      v95 = v25;
      v47 = 0;
      v48 = *(_OWORD *)&a3->mRateScalar;
      *(_OWORD *)&__B.mSampleTime = *(_OWORD *)&a3->mSampleTime;
      *(_OWORD *)&__B.mRateScalar = v48;
      v49 = *(_OWORD *)&a3->mSMPTETime.mHours;
      *(_OWORD *)&__B.mSMPTETime.mSubframes = *(_OWORD *)&a3->mSMPTETime.mSubframes;
      *(_OWORD *)&__B.mSMPTETime.mHours = v49;
      v96 = (char *)this + 816;
      v50 = v7;
      v51 = v7;
      do
      {
        v52 = v47;
        v53 = *((unsigned int *)this + 320);
        ++v47;
        if ((_DWORD)v53)
          v54 = v47 == v53;
        else
          v54 = 1;
        if (v54)
        {
          v55 = (unsigned int *)ausdk::AUBufferList::GetBufferList(*((ausdk::AUBufferList **)this + 112));
          CopyBufferList(v55, a5, *((_DWORD *)this + 312) * v50);
          AudioUnitProcess(*((AudioUnit *)this + v52 + 86), a2, &__B, v50, a5);
          if (!*((_BYTE *)this + v47 + 1284))
          {
            AudioUnitProcess(*(AudioUnit *)&v96[8 * v52], a2, &__B, v50, a5);
            AUMultiBandDynamicsProcessorV2::GetVolCompState(this, *(AudioUnit *)&v96[8 * v52], 100 * v47);
          }
          if (*((_DWORD *)this + 311))
          {
            v56 = 0;
            v57 = (float *)((char *)this + 4 * v47 + 1292);
            v58 = 16;
            do
            {
              v59 = *v57;
              if (*v57 == 0.0 || *((_BYTE *)this + v47 + 1284))
              {
                vDSP_vadd(*(const float **)((char *)&a5->mNumberBuffers + v58), 1, *(const float **)(*((_QWORD *)this + 110) + v58), 1, *(float **)(*((_QWORD *)this + 110) + v58), 1, v51);
              }
              else
              {
                __Step = 0.0;
                __Step = __exp10f(v59 / 20.0);
                vDSP_vsma(*(const float **)((char *)&a5->mNumberBuffers + v58), 1, &__Step, *(const float **)(*((_QWORD *)this + 110) + v58), 1, *(float **)(*((_QWORD *)this + 110) + v58), 1, v51);
              }
              ++v56;
              v58 += 16;
            }
            while (v56 < *((unsigned int *)this + 311));
          }
        }
      }
      while (v47 < *((unsigned int *)this + 318));
      LODWORD(v7) = v50;
      v19 = v94;
      v25 = v95;
      break;
    case 3:
      v60 = *(_OWORD *)&a3->mRateScalar;
      *(_OWORD *)&__B.mSampleTime = *(_OWORD *)&a3->mSampleTime;
      *(_OWORD *)&__B.mRateScalar = v60;
      v61 = *(_OWORD *)&a3->mSMPTETime.mHours;
      *(_OWORD *)&__B.mSMPTETime.mSubframes = *(_OWORD *)&a3->mSMPTETime.mSubframes;
      *(_OWORD *)&__B.mSMPTETime.mHours = v61;
      v62 = (ausdk::AUBufferList *)*((_QWORD *)this + 111);
      v63 = (const AudioStreamBasicDescription *)ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
      ausdk::AUBufferList::PrepareBuffer(v62, v63 + 2, v7);
      v64 = (unsigned int *)ausdk::AUBufferList::GetBufferList(*((ausdk::AUBufferList **)this + 112));
      CopyBufferList(v64, a5, (*((_DWORD *)this + 312) * v7));
      AudioUnitProcess(*((AudioUnit *)this + 86), a2, &__B, v7, a5);
      v65 = (AudioBufferList *)ausdk::AUBufferList::GetBufferList(*((ausdk::AUBufferList **)this + 111));
      CopyBufferList(&a5->mNumberBuffers, v65, (*((_DWORD *)this + 312) * v7));
      if (*((_DWORD *)this + 320) <= 1u)
      {
        AUMultiBandDynamicsProcessorV2::ApplyAllpassFilter((AudioUnit *)this, a2, &__B, v65, a5, 2u, 3, v7);
        AUMultiBandDynamicsProcessorV2::ApplyDynamicsToBand(this, a2, &__B, a5, 0, v7);
      }
      CopyBufferList(v64, a5, (*((_DWORD *)this + 312) * v7));
      AudioUnitProcess(*((AudioUnit *)this + 87), a2, &__B, v7, a5);
      CopyBufferList(&a5->mNumberBuffers, v65, (*((_DWORD *)this + 312) * v7));
      v66 = *((_DWORD *)this + 320);
      if ((v66 | 2) == 2)
      {
        AudioUnitProcess(*((AudioUnit *)this + 90), a2, &__B, v7, a5);
        AUMultiBandDynamicsProcessorV2::ApplyDynamicsToBand(this, a2, &__B, a5, 1u, v7);
        v66 = *((_DWORD *)this + 320);
      }
      if (v66 != 3 && v66)
        break;
      AudioUnitProcess(*((AudioUnit *)this + 91), a2, &__B, v7, v65);
      v67 = this;
      v68 = a2;
      v69 = v65;
      v70 = 2;
      goto LABEL_86;
    case 4:
      v71 = *(_OWORD *)&a3->mRateScalar;
      *(_OWORD *)&__B.mSampleTime = *(_OWORD *)&a3->mSampleTime;
      *(_OWORD *)&__B.mRateScalar = v71;
      v72 = *(_OWORD *)&a3->mSMPTETime.mHours;
      *(_OWORD *)&__B.mSMPTETime.mSubframes = *(_OWORD *)&a3->mSMPTETime.mSubframes;
      *(_OWORD *)&__B.mSMPTETime.mHours = v72;
      v73 = (ausdk::AUBufferList *)*((_QWORD *)this + 111);
      v74 = (const AudioStreamBasicDescription *)ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
      ausdk::AUBufferList::PrepareBuffer(v73, v74 + 2, v7);
      v75 = (unsigned int *)ausdk::AUBufferList::GetBufferList(*((ausdk::AUBufferList **)this + 112));
      CopyBufferList(v75, a5, (*((_DWORD *)this + 312) * v7));
      AudioUnitProcess(*((AudioUnit *)this + 86), a2, &__B, v7, a5);
      v76 = (AudioBufferList *)ausdk::AUBufferList::GetBufferList(*((ausdk::AUBufferList **)this + 111));
      CopyBufferList(&a5->mNumberBuffers, v76, (*((_DWORD *)this + 312) * v7));
      AUMultiBandDynamicsProcessorV2::ApplyAllpassFilter((AudioUnit *)this, a2, &__B, v76, a5, 2u, 3, v7);
      CopyBufferList(&a5->mNumberBuffers, v76, (*((_DWORD *)this + 312) * v7));
      AudioUnitProcess(*((AudioUnit *)this + 92), a2, &__B, v7, a5);
      if (*((_DWORD *)this + 320) <= 1u)
        AUMultiBandDynamicsProcessorV2::ApplyDynamicsToBand(this, a2, &__B, a5, 0, v7);
      AudioUnitProcess(*((AudioUnit *)this + 93), a2, &__B, v7, v76);
      if ((*((_DWORD *)this + 320) | 2) == 2)
        AUMultiBandDynamicsProcessorV2::ApplyDynamicsToBand(this, a2, &__B, v76, 1u, v7);
      CopyBufferList(v75, a5, (*((_DWORD *)this + 312) * v7));
      AudioUnitProcess(*((AudioUnit *)this + 87), a2, &__B, v7, a5);
      CopyBufferList(&a5->mNumberBuffers, v76, (*((_DWORD *)this + 312) * v7));
      AUMultiBandDynamicsProcessorV2::ApplyAllpassFilter((AudioUnit *)this, a2, &__B, v76, a5, 4u, 5, v7);
      CopyBufferList(&a5->mNumberBuffers, v76, (*((_DWORD *)this + 312) * v7));
      AudioUnitProcess(*((AudioUnit *)this + 94), a2, &__B, v7, a5);
      v77 = *((_DWORD *)this + 320);
      if (v77 == 3 || !v77)
        AUMultiBandDynamicsProcessorV2::ApplyDynamicsToBand(this, a2, &__B, a5, 2u, v7);
      AudioUnitProcess(*((AudioUnit *)this + 95), a2, &__B, v7, v76);
      if ((*((_DWORD *)this + 320) | 4) != 4)
        break;
      v67 = this;
      v68 = a2;
      v69 = v76;
      v70 = 3;
LABEL_86:
      AUMultiBandDynamicsProcessorV2::ApplyDynamicsToBand(v67, v68, &__B, v69, v70, v7);
      break;
    default:
      break;
  }
  if ((v25 & 1) == 0)
  {
    v78 = *((float *)this + 219) == 1.0 || v19;
    if ((v78 & 1) != 0)
      goto LABEL_111;
LABEL_94:
    v79 = __exp10f(Parameter / 20.0);
    *(float *)&__B.mSampleTime = v79;
    v80 = *((float *)this + 219);
    if (v80 == v79)
    {
      if (*((_DWORD *)this + 311))
      {
        v88 = 0;
        v89 = 16;
        do
        {
          vDSP_vsmul(*(const float **)(*((_QWORD *)this + 110) + v89), 1, (const float *)&__B, *(float **)(*((_QWORD *)this + 110) + v89), 1, v7);
          ++v88;
          v89 += 16;
        }
        while (v88 < *((unsigned int *)this + 311));
      }
      goto LABEL_111;
    }
    v81 = v79;
    v82 = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
    v83 = (float)v7;
    v84 = 1000.0 / *(double *)(v82 + 80);
    if (v81 <= v80)
    {
      v90 = v84 * (float)((float)(v80 * 0.98855) - v80);
      __Step = v90;
      v86 = *((float *)this + 219);
      if ((float)(v86 + (float)(v90 * v83)) >= v81)
        goto LABEL_97;
    }
    else
    {
      v85 = v84 * (float)((float)(v80 * 1.0116) - v80);
      __Step = v85;
      v86 = *((float *)this + 219);
      if ((float)(v86 + (float)(v85 * v83)) <= v81)
      {
LABEL_97:
        v87 = 0;
LABEL_104:
        if (*((_DWORD *)this + 311))
        {
          v91 = 0;
          v92 = 16;
          do
          {
            __Start = *((float *)this + 219);
            vDSP_vrampmul(*(const float **)(*((_QWORD *)this + 110) + v92), 1, &__Start, &__Step, *(float **)(*((_QWORD *)this + 110) + v92), 1, v7);
            ++v91;
            v92 += 16;
          }
          while (v91 < *((unsigned int *)this + 311));
          v86 = __Start;
        }
        if (v87)
          v86 = v81;
        *((float *)this + 219) = v86;
        goto LABEL_111;
      }
    }
    __Step = (float)(v81 - v86) / v83;
    v87 = 1;
    goto LABEL_104;
  }
  if (!v19)
    goto LABEL_94;
LABEL_111:
  CopyBufferList(*((unsigned int **)this + 110), a5, (*((_DWORD *)this + 312) * v7));
  return 0;
}

uint64_t *AUMultiBandDynamicsProcessorV2::DoVariableBlockLatencyProcess(uint64_t *this, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, const AudioBufferList *a5, AudioBufferList *a6)
{
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t *v11;
  int v12;
  unsigned int i;
  unsigned int v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  AudioBufferList *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  char *v22;
  char *v23;
  ausdk::AUBufferList *v24;
  const AudioStreamBasicDescription *Element;
  _DWORD *v26;
  AudioBufferList *v27;
  uint64_t v28;
  unint64_t v29;
  size_t v30;
  uint64_t *v31;
  uint64_t v32;
  unint64_t mNumberBuffers;
  int v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  size_t v40;
  AudioBufferList *v41;
  uint64_t *v42;
  unint64_t v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  _DWORD *exception;
  uint64_t v48;
  uint64_t v49;
  const AudioBufferList *v50;
  uint64_t v51;
  uint64_t *v52;
  AudioBufferList *v53;
  unsigned int v54;
  unsigned int v55;
  ausdk::AUScope *v56;
  AudioTimeStamp v57;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  int v61;
  uint64_t v62;

  v54 = 0;
  v55 = a4;
  v8 = (uint64_t)this;
  v62 = *MEMORY[0x1E0C80C00];
  v9 = *(_OWORD *)&a3->mRateScalar;
  *(_OWORD *)&v57.mSampleTime = *(_OWORD *)&a3->mSampleTime;
  *(_OWORD *)&v57.mRateScalar = v9;
  v10 = *(_OWORD *)&a3->mSMPTETime.mHours;
  *(_OWORD *)&v57.mSMPTETime.mSubframes = *(_OWORD *)&a3->mSMPTETime.mSubframes;
  *(_OWORD *)&v57.mSMPTETime.mHours = v10;
  v56 = (ausdk::AUScope *)(this + 16);
  v11 = this + 113;
  v52 = this + 129;
  v53 = a6;
  do
  {
    v12 = *(_DWORD *)(v8 + 1260);
    for (i = *(_DWORD *)(v8 + 1252); ; v57.mSampleTime = v57.mSampleTime + (double)i)
    {
      v14 = i - v12;
      if (i != v12)
        break;
      v15 = *(unsigned int *)(v8 + 1244);
      if ((v15 - 65) <= 0xFFFFFFBF)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v59 = "AUMultiBandDynamicsProcessorV2.cpp";
          v60 = 1024;
          v61 = 2196;
          _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  STACK_ABL: invalid number of buffers", buf, 0x12u);
        }
        exception = __cxa_allocate_exception(0x10uLL);
        *(_QWORD *)exception = &off_1E69EE218;
        exception[2] = -50;
      }
      v16 = 16 * (v15 - 1) + 24;
      MEMORY[0x1E0C80A78](this);
      v18 = (AudioBufferList *)((char *)&v48 - ((v17 + 39) & 0x1FFFFFFFF0));
      bzero(v18, v16);
      v18->mNumberBuffers = v15;
      MEMORY[0x1E0C80A78](v19);
      bzero(v18, v16);
      v20 = 0;
      v18->mNumberBuffers = v15;
      v21 = 4 * i;
      do
      {
        v22 = (char *)v18 + v20 * 8;
        v23 = (char *)v18 + v20 * 8;
        *((_DWORD *)v22 + 2) = 1;
        *((_DWORD *)v22 + 3) = v21;
        *((_DWORD *)v23 + 2) = 1;
        *((_DWORD *)v23 + 3) = v21;
        *((_QWORD *)v23 + 2) = v11[v20];
        *((_QWORD *)v22 + 2) = v11[v20 + 16];
        v20 += 2;
      }
      while (2 * v15 != v20);
      v24 = *(ausdk::AUBufferList **)(v8 + 896);
      Element = (const AudioStreamBasicDescription *)ausdk::AUScope::SafeGetElement(v56, 0);
      v26 = (_DWORD *)ausdk::AUBufferList::PrepareBuffer(v24, Element + 2, *(_DWORD *)(v8 + 1252));
      CopyBufferList(&v18->mNumberBuffers, v26, (*(_DWORD *)(v8 + 1248) * *(_DWORD *)(v8 + 1252)));
      this = (uint64_t *)AUMultiBandDynamicsProcessorV2::DoCoreProcess((AUMultiBandDynamicsProcessorV2 *)v8, a2, &v57, *(unsigned int *)(v8 + 1252), v18, v27);
      if ((_DWORD)this)
        return this;
      this = (uint64_t *)AUMultiBandDynamicsProcessorV2::DoCombinerLimiter((AUMultiBandDynamicsProcessorV2 *)v8, a2, &v57, *(_DWORD *)(v8 + 1252), v18);
      if ((_DWORD)this)
        return this;
      v12 = 0;
      *(_DWORD *)(v8 + 1260) = 0;
      *(_DWORD *)(v8 + 1268) = 0;
      i = *(_DWORD *)(v8 + 1252);
      *(_DWORD *)(v8 + 1264) += i;
    }
    if (v55 >= v14)
      v28 = v14;
    else
      v28 = v55;
    if (*(_DWORD *)(v8 + 1244))
    {
      v29 = 0;
      v51 = v28;
      v30 = 4 * v28;
      v31 = v11;
      v32 = v54;
      do
      {
        mNumberBuffers = a5->mNumberBuffers;
        if (v29 >= mNumberBuffers)
          v34 = mNumberBuffers - 1;
        else
          v34 = v29;
        v35 = *v31;
        v31 += 2;
        this = (uint64_t *)memcpy((void *)(v35 + 4 * *(unsigned int *)(v8 + 1260)), (char *)a5->mBuffers[v34].mData + 4 * v32, v30);
        ++v29;
        v36 = *(unsigned int *)(v8 + 1244);
      }
      while (v29 < v36);
      LODWORD(v28) = v51;
      *(_DWORD *)(v8 + 1260) += v51;
      v37 = *(_DWORD *)(v8 + 1264);
      if (v37 >= v28)
        v38 = v28;
      else
        v38 = v37;
      if ((_DWORD)v36)
      {
        v49 = v38;
        v50 = a5;
        v39 = 0;
        v40 = 4 * v38;
        v42 = v52;
        v41 = v53;
        do
        {
          v43 = v41->mNumberBuffers;
          if (v39 >= v43)
            v44 = v43 - 1;
          else
            v44 = v39;
          v45 = *v42;
          v42 += 2;
          this = (uint64_t *)memcpy((char *)v41->mBuffers[v44].mData + 4 * v32, (const void *)(v45 + 4 * *(unsigned int *)(v8 + 1268)), v40);
          ++v39;
        }
        while (v39 < *(unsigned int *)(v8 + 1244));
        v37 = *(_DWORD *)(v8 + 1264);
        a5 = v50;
        LODWORD(v28) = v51;
        LODWORD(v38) = v49;
      }
    }
    else
    {
      *(_DWORD *)(v8 + 1260) = v12 + v28;
      v37 = *(_DWORD *)(v8 + 1264);
      if (v37 >= v28)
        LODWORD(v38) = v28;
      else
        LODWORD(v38) = *(_DWORD *)(v8 + 1264);
    }
    *(_DWORD *)(v8 + 1268) += v38;
    *(_DWORD *)(v8 + 1264) = v37 - v38;
    v46 = v55;
    v54 += v28;
    v55 -= v28;
  }
  while (v46 > v14);
  return 0;
}

uint64_t AUMultiBandDynamicsProcessorV2::DoFixedBlockLatencyProcess(AUMultiBandDynamicsProcessorV2 *this, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, const AudioBufferList *a5, AudioBufferList *a6)
{
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v13;
  _DWORD *v14;
  size_t v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t mNumberBuffers;
  unsigned int v20;
  char *v21;
  int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  unint64_t v26;
  unsigned int v27;
  uint64_t v28;
  const void **v29;
  const void *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  BOOL v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  char *v42;
  unsigned int *v43;
  uint64_t v44;
  size_t v45;
  uint64_t v46;
  AudioBufferList *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  char *v51;
  char *v52;
  unsigned int v53;
  unint64_t v54;
  unsigned int v55;
  unsigned int v56;
  uint64_t v57;
  size_t v58;
  void **p_mData;
  void **v60;
  void *v61;
  unint64_t v62;
  unsigned int v63;
  uint64_t v64;
  unint64_t v65;
  char *v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  ausdk::AUBufferList *v70;
  const AudioStreamBasicDescription *Element;
  _DWORD *v72;
  AudioBufferList *v73;
  unsigned int v74;
  int v75;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  uint64_t v79;
  unint64_t v80;
  void **v81;
  const void **v82;
  const void *v83;
  unint64_t v84;
  unint64_t v85;
  char *v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  uint64_t v93;
  unint64_t v94;
  void **v95;
  void *v96;
  unint64_t v97;
  unint64_t v98;
  void **v99;
  char *v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int v103;
  NSObject *v105;
  _DWORD *exception;
  AudioBufferList *v107;
  unsigned int v108;
  uint64_t v109;
  unsigned int v110;
  unsigned int *v111;
  ausdk::AUScope *v112;
  AudioTimeStamp v113;
  uint8_t buf[4];
  const char *v115;
  __int16 v116;
  int v117;
  uint64_t v118;

  v111 = a2;
  v118 = *MEMORY[0x1E0C80C00];
  v6 = *(_OWORD *)&a3->mRateScalar;
  *(_OWORD *)&v113.mSampleTime = *(_OWORD *)&a3->mSampleTime;
  *(_OWORD *)&v113.mRateScalar = v6;
  v7 = *(_OWORD *)&a3->mSMPTETime.mHours;
  *(_OWORD *)&v113.mSMPTETime.mSubframes = *(_OWORD *)&a3->mSMPTETime.mSubframes;
  *(_OWORD *)&v113.mSMPTETime.mHours = v7;
  v8 = *((unsigned int *)this + 311);
  if ((v8 - 65) <= 0xFFFFFFBF)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
LABEL_98:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &off_1E69EE218;
      exception[2] = -50;
    }
    *(_DWORD *)buf = 136315394;
    v115 = "AUMultiBandDynamicsProcessorV2.cpp";
    v116 = 1024;
    v117 = 2261;
    v105 = MEMORY[0x1E0C81028];
LABEL_97:
    _os_log_impl(&dword_1B5ED0000, v105, OS_LOG_TYPE_ERROR, "%25s:%-5d  STACK_ABL: invalid number of buffers", buf, 0x12u);
    goto LABEL_98;
  }
  MEMORY[0x1E0C80A78](this);
  v14 = (_DWORD *)((char *)&v107 - v13);
  bzero((char *)&v107 - v13, v15);
  v17 = 0;
  *v14 = v8;
  v18 = v14 + 4;
  mNumberBuffers = a5->mNumberBuffers;
  do
  {
    if (v17 <= mNumberBuffers)
      v20 = v17;
    else
      v20 = mNumberBuffers - 1;
    v21 = (char *)a5 + 16 * v20;
    v22 = *((_DWORD *)v21 + 3);
    *((_DWORD *)v18 - 2) = 1;
    *((_DWORD *)v18 - 1) = v22;
    *v18 = *((_QWORD *)v21 + 2);
    v18 += 2;
    ++v17;
  }
  while (v8 != v17);
  if ((_DWORD)v8 == *((_DWORD *)this + 291))
  {
    v23 = 0;
    if (a4)
    {
      v24 = *((_DWORD *)this + 290);
      v25 = v24 - *((_DWORD *)this + 292);
      if (v25)
      {
        v26 = 0;
        if (v25 >= a4)
          v23 = a4;
        else
          v23 = v24 - *((_DWORD *)this + 292);
        v27 = v24 - *((_DWORD *)this + 294);
        if (v27 >= v23)
          v28 = v23;
        else
          v28 = v27;
        v29 = (const void **)(v14 + 4);
        do
        {
          v30 = *v29;
          v29 += 2;
          v16 = (uint64_t)memcpy((void *)(*((_QWORD *)this + 148)+ 4 * (*((_DWORD *)this + 294) + *((_DWORD *)this + 290) * v26++)), v30, 4 * v28);
          v31 = *((unsigned int *)this + 291);
        }
        while (v26 < v31);
        if (v23 > v27 && (_DWORD)v31)
        {
          v32 = 0;
          v33 = (uint64_t *)(v14 + 4);
          do
          {
            v34 = *v33;
            v33 += 2;
            v16 = (uint64_t)memcpy((void *)(*((_QWORD *)this + 148) + 4 * (*((_DWORD *)this + 290) * v32++)), (const void *)(v34 + 4 * v28), 4 * (v23 - v28));
          }
          while (v32 < *((unsigned int *)this + 291));
        }
        *((_DWORD *)this + 292) += v23;
        v35 = *((_DWORD *)this + 294) + v23;
        *((_DWORD *)this + 294) = v35;
        v36 = *((_DWORD *)this + 290);
        v37 = v35 >= v36;
        v38 = v35 - v36;
        if (v37)
          *((_DWORD *)this + 294) = v38;
      }
    }
  }
  else
  {
    v23 = 0;
  }
  v39 = *((_DWORD *)this + 315) + v23;
  *((_DWORD *)this + 315) = v39;
  v40 = *((_DWORD *)this + 313);
  if (v39 < v40)
  {
    v41 = 0;
    if (a4)
      goto LABEL_76;
    goto LABEL_94;
  }
  v107 = a6;
  v108 = a4;
  v112 = (AUMultiBandDynamicsProcessorV2 *)((char *)this + 128);
  v42 = (char *)this + 904;
  v43 = v111;
  while (1)
  {
    v44 = *((unsigned int *)this + 311);
    if ((v44 - 65) <= 0xFFFFFFBF)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_98;
      *(_DWORD *)buf = 136315394;
      v115 = "AUMultiBandDynamicsProcessorV2.cpp";
      v116 = 1024;
      v117 = 2279;
      v105 = MEMORY[0x1E0C81028];
      goto LABEL_97;
    }
    v45 = 16 * (v44 - 1) + 24;
    MEMORY[0x1E0C80A78](v16);
    v47 = (AudioBufferList *)((char *)&v107 - ((v46 + 39) & 0x1FFFFFFFF0));
    bzero(v47, v45);
    v47->mNumberBuffers = v44;
    MEMORY[0x1E0C80A78](v48);
    bzero(v47, v45);
    v49 = 0;
    v47->mNumberBuffers = v44;
    v50 = 4 * v40;
    do
    {
      v51 = (char *)v47 + v49;
      v52 = (char *)v47 + v49;
      *((_DWORD *)v51 + 2) = 1;
      *((_DWORD *)v51 + 3) = v50;
      *((_DWORD *)v52 + 2) = 1;
      *((_DWORD *)v52 + 3) = v50;
      *((_QWORD *)v52 + 2) = *(_QWORD *)&v42[v49];
      *((_QWORD *)v51 + 2) = *(_QWORD *)&v42[v49 + 128];
      v49 += 16;
    }
    while (16 * v44 != v49);
    if (v40)
    {
      if ((_DWORD)v44 == *((_DWORD *)this + 291))
      {
        v53 = *((_DWORD *)this + 292);
        if (v53)
        {
          v54 = 0;
          if (v53 >= v40)
            v55 = v40;
          else
            v55 = *((_DWORD *)this + 292);
          v56 = *((_DWORD *)this + 290) - *((_DWORD *)this + 293);
          v110 = v55;
          if (v56 >= v55)
            v57 = v55;
          else
            v57 = v56;
          v109 = v57;
          v58 = 4 * v57;
          p_mData = &v47->mBuffers[0].mData;
          v60 = &v47->mBuffers[0].mData;
          do
          {
            v61 = *v60;
            v60 += 2;
            memcpy(v61, (const void *)(*((_QWORD *)this + 148)+ 4 * (*((_DWORD *)this + 293) + *((_DWORD *)this + 290) * v54++)), v58);
            v62 = *((unsigned int *)this + 291);
          }
          while (v54 < v62);
          v63 = v110;
          v64 = v109;
          if (v110 > v56 && (_DWORD)v62)
          {
            v65 = 0;
            do
            {
              v66 = (char *)*p_mData;
              p_mData += 2;
              memcpy(&v66[4 * v64], (const void *)(*((_QWORD *)this + 148) + 4 * (*((_DWORD *)this + 290) * v65++)), 4 * (v63 - v64));
            }
            while (v65 < *((unsigned int *)this + 291));
          }
          *((_DWORD *)this + 292) -= v63;
          v67 = *((_DWORD *)this + 293) + v63;
          *((_DWORD *)this + 293) = v67;
          v68 = *((_DWORD *)this + 290);
          v37 = v67 >= v68;
          v69 = v67 - v68;
          v43 = v111;
          if (v37)
            *((_DWORD *)this + 293) = v69;
        }
      }
    }
    *((_DWORD *)this + 315) -= *((_DWORD *)this + 313);
    v70 = (ausdk::AUBufferList *)*((_QWORD *)this + 112);
    Element = (const AudioStreamBasicDescription *)ausdk::AUScope::SafeGetElement(v112, 0);
    v72 = (_DWORD *)ausdk::AUBufferList::PrepareBuffer(v70, Element + 2, *((_DWORD *)this + 313));
    CopyBufferList(&v47->mNumberBuffers, v72, (*((_DWORD *)this + 312) * *((_DWORD *)this + 313)));
    v16 = AUMultiBandDynamicsProcessorV2::DoCoreProcess(this, v43, &v113, *((unsigned int *)this + 313), v47, v73);
    if ((_DWORD)v16)
      break;
    v16 = AUMultiBandDynamicsProcessorV2::DoCombinerLimiter(this, v43, &v113, *((_DWORD *)this + 313), v47);
    if ((_DWORD)v16)
      break;
    if (v47->mNumberBuffers == *((_DWORD *)this + 301))
    {
      v74 = *((_DWORD *)this + 313);
      if (v74)
      {
        v75 = *((_DWORD *)this + 300);
        v76 = v75 - *((_DWORD *)this + 302);
        if (v76)
        {
          if (v76 >= v74)
            v77 = *((_DWORD *)this + 313);
          else
            v77 = v75 - *((_DWORD *)this + 302);
          v78 = v75 - *((_DWORD *)this + 304);
          if (v78 >= v77)
            v79 = v77;
          else
            v79 = v78;
          if (v47->mNumberBuffers)
          {
            v80 = 0;
            v81 = &v47->mBuffers[0].mData;
            v82 = (const void **)&v47->mBuffers[0].mData;
            do
            {
              v83 = *v82;
              v82 += 2;
              v16 = (uint64_t)memcpy((void *)(*((_QWORD *)this + 153)+ 4 * (*((_DWORD *)this + 304) + *((_DWORD *)this + 300) * v80++)), v83, 4 * v79);
              v84 = *((unsigned int *)this + 301);
            }
            while (v80 < v84);
            v43 = v111;
            if (v77 > v78)
            {
              if ((_DWORD)v84)
              {
                v85 = 0;
                do
                {
                  v86 = (char *)*v81;
                  v81 += 2;
                  v16 = (uint64_t)memcpy((void *)(*((_QWORD *)this + 153)+ 4 * (*((_DWORD *)this + 300) * v85++)), &v86[4 * v79], 4 * (v77 - v79));
                }
                while (v85 < *((unsigned int *)this + 301));
              }
            }
          }
          *((_DWORD *)this + 302) += v77;
          v87 = *((_DWORD *)this + 304) + v77;
          *((_DWORD *)this + 304) = v87;
          v88 = *((_DWORD *)this + 300);
          v37 = v87 >= v88;
          v89 = v87 - v88;
          if (v37)
            *((_DWORD *)this + 304) = v89;
        }
      }
    }
    v40 = *((_DWORD *)this + 313);
    *((_DWORD *)this + 316) += v40;
    v113.mSampleTime = v113.mSampleTime + (double)v40;
    if (*((_DWORD *)this + 315) < v40)
    {
      v41 = 0;
      goto LABEL_75;
    }
  }
  v41 = v16;
LABEL_75:
  a4 = v108;
  a6 = v107;
  if (v108)
  {
LABEL_76:
    if (a6->mNumberBuffers == *((_DWORD *)this + 301))
    {
      v90 = *((_DWORD *)this + 302);
      if (v90)
      {
        if (v90 >= a4)
          v91 = a4;
        else
          v91 = *((_DWORD *)this + 302);
        v92 = *((_DWORD *)this + 300) - *((_DWORD *)this + 303);
        if (v92 >= v91)
          v93 = v91;
        else
          v93 = v92;
        if (a6->mNumberBuffers)
        {
          v94 = 0;
          v95 = &a6->mBuffers[0].mData;
          do
          {
            v96 = *v95;
            v95 += 2;
            memcpy(v96, (const void *)(*((_QWORD *)this + 153)+ 4 * (*((_DWORD *)this + 303) + *((_DWORD *)this + 300) * v94++)), 4 * v93);
            v97 = *((unsigned int *)this + 301);
          }
          while (v94 < v97);
          if (v91 > v92 && (_DWORD)v97)
          {
            v98 = 0;
            v99 = &a6->mBuffers[0].mData;
            do
            {
              v100 = (char *)*v99;
              v99 += 2;
              memcpy(&v100[4 * v93], (const void *)(*((_QWORD *)this + 153) + 4 * (*((_DWORD *)this + 300) * v98++)), 4 * (v91 - v93));
            }
            while (v98 < *((unsigned int *)this + 301));
          }
        }
        *((_DWORD *)this + 302) -= v91;
        v101 = *((_DWORD *)this + 303) + v91;
        *((_DWORD *)this + 303) = v101;
        v102 = *((_DWORD *)this + 300);
        v37 = v101 >= v102;
        v103 = v101 - v102;
        if (v37)
          *((_DWORD *)this + 303) = v103;
      }
    }
  }
LABEL_94:
  *((_DWORD *)this + 316) -= a4;
  return v41;
}

void AUMultiBandDynamicsProcessorV2::ApplyAllpassFilter(AudioUnit *this, unsigned int *a2, const AudioTimeStamp *a3, AudioBufferList *a4, AudioBufferList *a5, unsigned int a6, int a7, UInt32 inNumberFrames)
{
  char *v15;
  unint64_t v16;
  void **p_mData;
  void **v18;
  float *v19;
  float *v20;
  const float *v21;

  v15 = (char *)(this + 86);
  AudioUnitProcess(this[a6 + 86], a2, a3, inNumberFrames, a5);
  AudioUnitProcess(*(AudioUnit *)&v15[8 * a7], a2, a3, inNumberFrames, a4);
  if (*((_DWORD *)this + 311))
  {
    v16 = 0;
    p_mData = &a4->mBuffers[0].mData;
    v18 = &a5->mBuffers[0].mData;
    do
    {
      v20 = (float *)*v18;
      v18 += 2;
      v19 = v20;
      v21 = (const float *)*p_mData;
      p_mData += 2;
      vDSP_vadd(v19, 1, v21, 1, v19, 1, inNumberFrames);
      ++v16;
    }
    while (v16 < *((unsigned int *)this + 311));
  }
}

void AUMultiBandDynamicsProcessorV2::ApplyDynamicsToBand(AUMultiBandDynamicsProcessorV2 *this, unsigned int *a2, const AudioTimeStamp *a3, AudioBufferList *ioData, unsigned int a5, vDSP_Length __N)
{
  unsigned int v6;
  uint64_t v9;
  char *v10;
  AudioUnit *v11;
  unint64_t v12;
  _BYTE *v13;
  float *v14;
  uint64_t v15;
  float v16;
  float __B;

  v6 = __N;
  v9 = a5 + 1;
  v10 = (char *)this + v9;
  if (!*((_BYTE *)this + v9 + 1284))
  {
    v11 = (AudioUnit *)((char *)this + 8 * a5);
    AudioUnitProcess(v11[102], a2, a3, __N, ioData);
    AUMultiBandDynamicsProcessorV2::GetVolCompState(this, v11[102], 100 * v9);
  }
  if (*((_DWORD *)this + 311))
  {
    v12 = 0;
    v13 = v10 + 1284;
    v14 = (float *)((char *)this + 4 * v9 + 1292);
    v15 = 16;
    do
    {
      v16 = *v14;
      if (*v14 == 0.0 || *v13)
      {
        vDSP_vadd(*(const float **)((char *)&ioData->mNumberBuffers + v15), 1, *(const float **)(*((_QWORD *)this + 110) + v15), 1, *(float **)(*((_QWORD *)this + 110) + v15), 1, v6);
      }
      else
      {
        __B = 0.0;
        __B = __exp10f(v16 / 20.0);
        vDSP_vsma(*(const float **)((char *)&ioData->mNumberBuffers + v15), 1, &__B, *(const float **)(*((_QWORD *)this + 110) + v15), 1, *(float **)(*((_QWORD *)this + 110) + v15), 1, v6);
      }
      ++v12;
      v15 += 16;
    }
    while (v12 < *((unsigned int *)this + 311));
  }
}

void AUMultiBandDynamicsProcessorV2::UpdateVolComp(AUMultiBandDynamicsProcessorV2 *this, OpaqueAudioComponentInstance *a2, unsigned int a3)
{
  int v6;
  uint64_t v7;
  ausdk::AUElement *v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  ausdk::AUElement **v11;
  float Parameter;
  uint64_t v13;
  ausdk::AUElement *v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  ausdk::AUElement **v18;
  float v19;
  uint64_t v20;
  ausdk::AUElement *v21;
  ausdk::AUElement **v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t v25;
  ausdk::AUElement *v26;
  ausdk::AUElement **v27;
  float v28;
  float v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  float v33;
  float v34;
  uint64_t v35;
  ausdk::AUElement *v36;
  ausdk::AUElement **v37;
  float v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  float v42;
  uint64_t v43;
  ausdk::AUElement *v44;
  ausdk::AUElement **v45;
  float v46;
  uint64_t v47;
  ausdk::AUElement *v48;
  ausdk::AUElement **v49;
  float v50;
  OpaqueAudioComponentInstance *v51;
  AudioUnitParameterID v52;
  float v53;
  uint64_t v54;
  ausdk::AUElement **v55;
  float v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  ausdk::AUElement **v59;
  float v60;
  uint64_t v61;
  ausdk::AUElement *v62;
  ausdk::AUElement **v63;
  uint64_t v64;
  ausdk::AUElement *v65;
  ausdk::AUElement **v66;
  float v67;
  uint64_t v68;
  ausdk::AUElement *v69;
  ausdk::AUElement **v70;
  float v71;
  uint64_t v72;
  ausdk::AUElement *v73;
  ausdk::AUElement **v74;
  float v75;
  uint64_t v76;
  ausdk::AUElement *v77;
  ausdk::AUElement **v78;
  float v79;
  uint64_t v80;
  ausdk::AUElement *v81;
  ausdk::AUElement **v82;
  float v83;
  float v84;
  uint64_t v85;
  ausdk::AUElement *v86;
  ausdk::AUElement **v87;
  float v88;
  float v89;
  uint64_t v90;
  ausdk::AUElement *v91;
  ausdk::AUElement **v92;
  float v93;
  uint64_t v94;
  ausdk::AUElement *v95;
  ausdk::AUElement **v96;
  float v97;
  uint64_t v98;
  ausdk::AUElement *v99;
  ausdk::AUElement **v100;
  float v101;
  uint64_t v102;
  ausdk::AUElement *v103;
  ausdk::AUElement **v104;
  float v105;
  uint64_t v106;
  ausdk::AUElement *v107;
  ausdk::AUElement **v108;
  float v109;
  uint64_t v110;
  ausdk::AUElement *v111;
  ausdk::AUElement **v112;
  float v113;
  uint64_t v114;
  ausdk::AUElement *v115;
  ausdk::AUElement **v116;
  float v117;
  uint64_t v118;
  ausdk::AUElement *v119;
  ausdk::AUElement **v120;
  float v121;
  uint64_t v122;
  ausdk::AUElement *v123;
  ausdk::AUElement **v124;
  float v125;
  uint64_t v126;
  ausdk::AUElement *v127;
  ausdk::AUElement **v128;
  float v129;
  uint64_t v130;
  ausdk::AUElement *v131;
  ausdk::AUElement **v132;
  float v133;
  uint64_t v134;
  ausdk::AUElement *v135;
  ausdk::AUElement **v136;
  float v137;
  uint64_t v138;
  ausdk::AUElement *v139;
  ausdk::AUElement **v140;
  float v141;
  uint64_t v142;
  ausdk::AUElement *v143;
  ausdk::AUElement **v144;
  float v145;
  uint64_t v146;
  ausdk::AUElement *v147;
  ausdk::AUElement **v148;
  double v149;
  AudioUnitParameterValue v150;
  uint64_t v151;
  ausdk::AUElement *v152;
  ausdk::AUElement **v153;
  float v154;
  uint64_t v155;
  ausdk::AUElement *v156;
  ausdk::AUElement **v157;
  float v158;
  uint64_t v159;
  ausdk::AUElement *v160;
  ausdk::AUElement **v161;
  float v162;
  uint64_t v163;
  ausdk::AUElement *v164;
  ausdk::AUElement **v165;
  float v166;
  uint64_t v167;
  ausdk::AUElement *v168;
  ausdk::AUElement **v169;
  float v170;
  uint64_t v171;
  ausdk::AUElement *v172;
  ausdk::AUElement **v173;
  float v174;
  uint64_t v175;
  ausdk::AUElement *v176;
  ausdk::AUElement **v177;
  float v178;
  uint64_t v179;
  ausdk::AUElement *v180;
  ausdk::AUElement **v181;
  float v182;
  uint64_t v183;
  ausdk::AUElement *v184;
  ausdk::AUElement **v185;
  float v186;
  uint64_t v187;
  ausdk::AUElement *v188;
  ausdk::AUElement **v189;
  uint64_t v190;
  ausdk::AUElement *v191;
  ausdk::AUElement **v192;
  __n128 v193;
  uint64_t v194;
  ausdk::AUElement *v195;
  ausdk::AUElement **v196;
  AudioUnitParameterValue outValue;

  v6 = *((unsigned __int8 *)this + 1314);
  v7 = *((_QWORD *)this + 9);
  if (v6)
  {
    if (v7)
    {
      v8 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
    }
    else
    {
      v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v10)
        v8 = 0;
      else
        v8 = *v10;
    }
    Parameter = ausdk::AUElement::GetParameter(v8, 0);
    if (a3)
    {
      AudioUnitSetParameter(a2, 0xCu, 0, 0, Parameter, 0);
      v13 = *((_QWORD *)this + 9);
      if (v13)
      {
        v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
      }
      else
      {
        v17 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v17)
          v14 = 0;
        else
          v14 = *v17;
      }
      v19 = ausdk::AUElement::GetParameter(v14, 0xCu);
      AudioUnitSetParameter(a2, 0x11u, 0, 0, v19, 0);
      v20 = *((_QWORD *)this + 9);
      if (v20)
      {
        v21 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 32))(v20, 0);
      }
      else
      {
        v22 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v22)
          v21 = 0;
        else
          v21 = *v22;
      }
      v23 = 23;
    }
    else
    {
      v15 = *((_QWORD *)this + 9);
      if (v15)
      {
        v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD, float))(*(_QWORD *)v15 + 32))(v15, 0, Parameter);
      }
      else
      {
        v18 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v18)
          v16 = 0;
        else
          v16 = *v18;
      }
      v53 = ausdk::AUElement::GetParameter(v16, 0xCu);
      AudioUnitSetParameter(a2, 0x11u, 0, 0, v53, 0);
      v54 = *((_QWORD *)this + 9);
      if (v54)
      {
        v21 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v54 + 32))(v54, 0);
      }
      else
      {
        v55 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v55)
          v21 = 0;
        else
          v21 = *v55;
      }
      v23 = 24;
    }
    v56 = ausdk::AUElement::GetParameter(v21, v23);
    if (*((_DWORD *)this + 216) != 1)
      v56 = 0.0;
    AudioUnitSetParameter(a2, 0x12u, 0, 0, v56, 0);
    v57 = *((_QWORD *)this + 9);
    if (v57)
    {
      v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v57 + 32))(v57, 0);
    }
    else
    {
      v59 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v59)
        v58 = 0;
      else
        v58 = *v59;
    }
    v60 = ausdk::AUElement::GetParameter(v58, a3 + 100);
    AudioUnitSetParameter(a2, 1u, 0, 0, v60, 0);
    AudioUnitSetParameter(a2, 0xFu, 0, 0, 0.0, 0);
    if (a3)
    {
      if (a3 == 100)
        *((_DWORD *)this + 218) = 0;
      else
        *((_DWORD *)this + 217) = 0;
    }
    v61 = *((_QWORD *)this + 9);
    if (v61)
    {
      v62 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v61 + 32))(v61, 0);
    }
    else
    {
      v63 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v63)
        v62 = 0;
      else
        v62 = *v63;
    }
    v24 = a3 / 0x64uLL;
    *((float *)this + v24 + 323) = ausdk::AUElement::GetParameter(v62, a3 + 136);
    v64 = *((_QWORD *)this + 9);
    if (v64)
    {
      v65 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v64 + 32))(v64, 0);
    }
    else
    {
      v66 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v66)
        v65 = 0;
      else
        v65 = *v66;
    }
    v67 = ausdk::AUElement::GetParameter(v65, a3 + 101);
    AudioUnitSetParameter(a2, 2u, 0, 0, v67, 0);
    v68 = *((_QWORD *)this + 9);
    if (v68)
    {
      v69 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v68 + 32))(v68, 0);
    }
    else
    {
      v70 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v70)
        v69 = 0;
      else
        v69 = *v70;
    }
    v71 = ausdk::AUElement::GetParameter(v69, a3 + 102);
    AudioUnitSetParameter(a2, 3u, 0, 0, v71, 0);
    v72 = *((_QWORD *)this + 9);
    if (v72)
    {
      v73 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v72 + 32))(v72, 0);
    }
    else
    {
      v74 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v74)
        v73 = 0;
      else
        v73 = *v74;
    }
    v75 = ausdk::AUElement::GetParameter(v73, a3 + 105);
    AudioUnitSetParameter(a2, 4u, 0, 0, v75, 0);
    v76 = *((_QWORD *)this + 9);
    if (v76)
    {
      v77 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v76 + 32))(v76, 0);
    }
    else
    {
      v78 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v78)
        v77 = 0;
      else
        v77 = *v78;
    }
    v79 = ausdk::AUElement::GetParameter(v77, a3 + 103);
    AudioUnitSetParameter(a2, 5u, 0, 0, v79, 0);
    v80 = *((_QWORD *)this + 9);
    if (v80)
    {
      v81 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v80 + 32))(v80, 0);
    }
    else
    {
      v82 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v82)
        v81 = 0;
      else
        v81 = *v82;
    }
    v83 = ausdk::AUElement::GetParameter(v81, a3 + 107);
    if (v83 >= 6.0)
      v84 = (float)(1000.0 / v83) * 0.06;
    else
      v84 = 0.6;
    AudioUnitSetParameter(a2, 6u, 0, 0, v84, 0);
    v85 = *((_QWORD *)this + 9);
    if (v85)
    {
      v86 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v85 + 32))(v85, 0);
    }
    else
    {
      v87 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v87)
        v86 = 0;
      else
        v86 = *v87;
    }
    v88 = ausdk::AUElement::GetParameter(v86, a3 + 108);
    if (v88 >= 0.0)
    {
      v89 = (float)(1000.0 / v88) * -0.06;
    }
    else
    {
      AudioUnitSetParameter(a2, 6u, 0, 0, 0.6, 0);
      v89 = -0.6;
    }
    AudioUnitSetParameter(a2, 7u, 0, 0, v89, 0);
    v90 = *((_QWORD *)this + 9);
    if (v90)
    {
      v91 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v90 + 32))(v90, 0);
    }
    else
    {
      v92 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v92)
        v91 = 0;
      else
        v91 = *v92;
    }
    v93 = ausdk::AUElement::GetParameter(v91, a3 + 111);
    AudioUnitSetParameter(a2, 0x10u, 0, 0, v93, 0);
    v94 = *((_QWORD *)this + 9);
    if (v94)
    {
      v95 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v94 + 32))(v94, 0);
    }
    else
    {
      v96 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v96)
        v95 = 0;
      else
        v95 = *v96;
    }
    v97 = ausdk::AUElement::GetParameter(v95, a3 + 120);
    AudioUnitSetParameter(a2, 8u, 0, 0, v97, 0);
    v98 = *((_QWORD *)this + 9);
    if (v98)
    {
      v99 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v98 + 32))(v98, 0);
    }
    else
    {
      v100 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v100)
        v99 = 0;
      else
        v99 = *v100;
    }
    v101 = ausdk::AUElement::GetParameter(v99, a3 + 113);
    AudioUnitSetParameter(a2, 0xBu, 0, 0, v101, 0);
    v102 = *((_QWORD *)this + 9);
    if (v102)
    {
      v103 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v102 + 32))(v102, 0);
    }
    else
    {
      v104 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v104)
        v103 = 0;
      else
        v103 = *v104;
    }
    v105 = ausdk::AUElement::GetParameter(v103, a3 + 114);
    AudioUnitSetParameter(a2, 0xAu, 0, 0, v105, 0);
    v106 = *((_QWORD *)this + 9);
    if (v106)
    {
      v107 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v106 + 32))(v106, 0);
    }
    else
    {
      v108 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v108)
        v107 = 0;
      else
        v107 = *v108;
    }
    v109 = ausdk::AUElement::GetParameter(v107, a3 + 115);
    AudioUnitSetParameter(a2, 0x14u, 0, 0, v109, 0);
    v110 = *((_QWORD *)this + 9);
    if (v110)
    {
      v111 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v110 + 32))(v110, 0);
    }
    else
    {
      v112 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v112)
        v111 = 0;
      else
        v111 = *v112;
    }
    v113 = ausdk::AUElement::GetParameter(v111, a3 + 116);
    AudioUnitSetParameter(a2, 0x15u, 0, 0, v113, 0);
    v114 = *((_QWORD *)this + 9);
    if (v114)
    {
      v115 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v114 + 32))(v114, 0);
    }
    else
    {
      v116 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v116)
        v115 = 0;
      else
        v115 = *v116;
    }
    v117 = ausdk::AUElement::GetParameter(v115, a3 + 117);
    AudioUnitSetParameter(a2, 0x1Eu, 0, 0, v117, 0);
    v118 = *((_QWORD *)this + 9);
    if (v118)
    {
      v119 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v118 + 32))(v118, 0);
    }
    else
    {
      v120 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v120)
        v119 = 0;
      else
        v119 = *v120;
    }
    v121 = ausdk::AUElement::GetParameter(v119, a3 + 118);
    AudioUnitSetParameter(a2, 0x1Fu, 0, 0, v121, 0);
    v122 = *((_QWORD *)this + 9);
    if (v122)
    {
      v123 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v122 + 32))(v122, 0);
    }
    else
    {
      v124 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v124)
        v123 = 0;
      else
        v123 = *v124;
    }
    v125 = ausdk::AUElement::GetParameter(v123, a3 + 109);
    if (v125 < v75)
      v125 = v75;
    AudioUnitSetParameter(a2, 0x28u, 0, 0, v125, 0);
    v126 = *((_QWORD *)this + 9);
    if (v126)
    {
      v127 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v126 + 32))(v126, 0);
    }
    else
    {
      v128 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v128)
        v127 = 0;
      else
        v127 = *v128;
    }
    v129 = ausdk::AUElement::GetParameter(v127, a3 + 110);
    if (v129 < v75)
      v129 = v75;
    AudioUnitSetParameter(a2, 0x29u, 0, 0, v129, 0);
    v130 = *((_QWORD *)this + 9);
    if (v130)
    {
      v131 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v130 + 32))(v130, 0);
    }
    else
    {
      v132 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v132)
        v131 = 0;
      else
        v131 = *v132;
    }
    v133 = ausdk::AUElement::GetParameter(v131, a3 + 112);
    AudioUnitSetParameter(a2, 0x33u, 0, 0, v133, 0);
    v134 = *((_QWORD *)this + 9);
    if (v134)
    {
      v135 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v134 + 32))(v134, 0);
    }
    else
    {
      v136 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v136)
        v135 = 0;
      else
        v135 = *v136;
    }
    v137 = ausdk::AUElement::GetParameter(v135, a3 + 111);
    AudioUnitSetParameter(a2, 0x10u, 0, 0, v137, 0);
    v138 = *((_QWORD *)this + 9);
    if (v138)
    {
      v139 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v138 + 32))(v138, 0);
    }
    else
    {
      v140 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v140)
        v139 = 0;
      else
        v139 = *v140;
    }
    v141 = ausdk::AUElement::GetParameter(v139, a3 + 122);
    AudioUnitSetParameter(a2, 0x41u, 0, 0, v141, 0);
    v142 = *((_QWORD *)this + 9);
    if (v142)
    {
      v143 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v142 + 32))(v142, 0);
    }
    else
    {
      v144 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v144)
        v143 = 0;
      else
        v143 = *v144;
    }
    v145 = ausdk::AUElement::GetParameter(v143, a3 + 123);
    AudioUnitSetParameter(a2, 0x42u, 0, 0, v145, 0);
    v146 = *((_QWORD *)this + 9);
    if (v146)
    {
      v147 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v146 + 32))(v146, 0);
    }
    else
    {
      v148 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v148)
        v147 = 0;
      else
        v147 = *v148;
    }
    ausdk::AUElement::GetParameter(v147, a3 + 121);
    v149 = (float)((float)*((unsigned int *)this + 313) * 1000.0);
    v150 = v149
         / *(double *)(ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0) + 80);
    AudioUnitSetParameter(a2, 9u, 0, 0, v150, 0);
    v151 = *((_QWORD *)this + 9);
    if (v151)
    {
      v152 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v151 + 32))(v151, 0);
    }
    else
    {
      v153 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v153)
        v152 = 0;
      else
        v152 = *v153;
    }
    v154 = ausdk::AUElement::GetParameter(v152, a3 + 124);
    AudioUnitSetParameter(a2, 0x43u, 0, 0, v154, 0);
    v155 = *((_QWORD *)this + 9);
    if (v155)
    {
      v156 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v155 + 32))(v155, 0);
    }
    else
    {
      v157 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v157)
        v156 = 0;
      else
        v156 = *v157;
    }
    v158 = ausdk::AUElement::GetParameter(v156, a3 + 125);
    AudioUnitSetParameter(a2, 0x44u, 0, 0, v158 * 0.001, 0);
    v159 = *((_QWORD *)this + 9);
    if (v159)
    {
      v160 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v159 + 32))(v159, 0);
    }
    else
    {
      v161 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v161)
        v160 = 0;
      else
        v160 = *v161;
    }
    v162 = ausdk::AUElement::GetParameter(v160, a3 + 126);
    AudioUnitSetParameter(a2, 0x45u, 0, 0, v162 * 0.001, 0);
    v163 = *((_QWORD *)this + 9);
    if (v163)
    {
      v164 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v163 + 32))(v163, 0);
    }
    else
    {
      v165 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v165)
        v164 = 0;
      else
        v164 = *v165;
    }
    v166 = ausdk::AUElement::GetParameter(v164, a3 + 127);
    AudioUnitSetParameter(a2, 0x46u, 0, 0, v166, 0);
    v167 = *((_QWORD *)this + 9);
    if (v167)
    {
      v168 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v167 + 32))(v167, 0);
    }
    else
    {
      v169 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v169)
        v168 = 0;
      else
        v168 = *v169;
    }
    v170 = ausdk::AUElement::GetParameter(v168, a3 + 139);
    AudioUnitSetParameter(a2, 0x47u, 0, 0, v170, 0);
    v171 = *((_QWORD *)this + 9);
    if (v171)
    {
      v172 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v171 + 32))(v171, 0);
    }
    else
    {
      v173 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v173)
        v172 = 0;
      else
        v172 = *v173;
    }
    v174 = ausdk::AUElement::GetParameter(v172, a3 + 131);
    AudioUnitSetParameter(a2, 0x48u, 0, 0, v174, 0);
    v175 = *((_QWORD *)this + 9);
    if (v175)
    {
      v176 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v175 + 32))(v175, 0);
    }
    else
    {
      v177 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v177)
        v176 = 0;
      else
        v176 = *v177;
    }
    v178 = ausdk::AUElement::GetParameter(v176, a3 + 132);
    AudioUnitSetParameter(a2, 0x49u, 0, 0, v178, 0);
    v179 = *((_QWORD *)this + 9);
    if (v179)
    {
      v180 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v179 + 32))(v179, 0);
    }
    else
    {
      v181 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v181)
        v180 = 0;
      else
        v180 = *v181;
    }
    v182 = ausdk::AUElement::GetParameter(v180, a3 + 133);
    AudioUnitSetParameter(a2, 0x4Au, 0, 0, v182 * 0.001, 0);
    v183 = *((_QWORD *)this + 9);
    if (v183)
    {
      v184 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v183 + 32))(v183, 0);
    }
    else
    {
      v185 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v185)
        v184 = 0;
      else
        v184 = *v185;
    }
    v186 = ausdk::AUElement::GetParameter(v184, a3 + 134);
    AudioUnitSetParameter(a2, 0x4Bu, 0, 0, v186 * 0.001, 0);
    v187 = *((_QWORD *)this + 9);
    if (v187)
    {
      v188 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v187 + 32))(v187, 0);
    }
    else
    {
      v189 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v189)
        v188 = 0;
      else
        v188 = *v189;
    }
    v50 = ausdk::AUElement::GetParameter(v188, a3 + 135);
    v51 = a2;
    v52 = 76;
  }
  else
  {
    if (v7)
    {
      v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
    }
    else
    {
      v11 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v11)
        v9 = 0;
      else
        v9 = *v11;
    }
    v24 = a3 / 0x64uLL;
    *((float *)this + v24 + 323) = ausdk::AUElement::GetParameter(v9, a3 + 136);
    v25 = *((_QWORD *)this + 9);
    if (v25)
    {
      v26 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, 0);
    }
    else
    {
      v27 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v27)
        v26 = 0;
      else
        v26 = *v27;
    }
    v28 = ausdk::AUElement::GetParameter(v26, a3 + 107);
    if (v28 >= 6.0)
      v29 = (float)(1000.0 / v28) * 0.06;
    else
      v29 = 0.6;
    AudioUnitSetParameter(a2, 6u, 0, 0, v29, 0);
    v30 = *((_QWORD *)this + 9);
    if (v30)
    {
      v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
    }
    else
    {
      v32 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v32)
        v31 = 0;
      else
        v31 = *v32;
    }
    v33 = ausdk::AUElement::GetParameter(v31, a3 + 108);
    if (v33 <= 0.0)
    {
      AudioUnitSetParameter(a2, 6u, 0, 0, 0.6, 0);
      v34 = -0.6;
    }
    else
    {
      v34 = (float)(1000.0 / v33) * -0.06;
    }
    AudioUnitSetParameter(a2, 7u, 0, 0, v34, 0);
    outValue = 0.0;
    AudioUnitGetParameter(a2, 4u, 0, 0, &outValue);
    v35 = *((_QWORD *)this + 9);
    if (v35)
    {
      v36 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 32))(v35, 0);
    }
    else
    {
      v37 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v37)
        v36 = 0;
      else
        v36 = *v37;
    }
    v38 = ausdk::AUElement::GetParameter(v36, a3 + 109);
    if (v38 < outValue)
      v38 = outValue;
    AudioUnitSetParameter(a2, 0x28u, 0, 0, v38, 0);
    v39 = *((_QWORD *)this + 9);
    if (v39)
    {
      v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
    }
    else
    {
      v41 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v41)
        v40 = 0;
      else
        v40 = *v41;
    }
    v42 = ausdk::AUElement::GetParameter(v40, a3 + 110);
    if (v42 < outValue)
      v42 = outValue;
    AudioUnitSetParameter(a2, 0x29u, 0, 0, v42, 0);
    v43 = *((_QWORD *)this + 9);
    if (v43)
    {
      v44 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v43 + 32))(v43, 0);
    }
    else
    {
      v45 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v45)
        v44 = 0;
      else
        v44 = *v45;
    }
    v46 = ausdk::AUElement::GetParameter(v44, a3 + 112);
    AudioUnitSetParameter(a2, 0x33u, 0, 0, v46, 0);
    v47 = *((_QWORD *)this + 9);
    if (v47)
    {
      v48 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v47 + 32))(v47, 0);
    }
    else
    {
      v49 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v49)
        v48 = 0;
      else
        v48 = *v49;
    }
    v50 = ausdk::AUElement::GetParameter(v48, a3 + 111);
    v51 = a2;
    v52 = 16;
  }
  AudioUnitSetParameter(v51, v52, 0, 0, v50, 0);
  v190 = *((_QWORD *)this + 9);
  if (v190)
  {
    v191 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v190 + 32))(v190, 0);
  }
  else
  {
    v192 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v192)
      v191 = 0;
    else
      v191 = *v192;
  }
  v193.n128_f32[0] = ausdk::AUElement::GetParameter(v191, a3 + 137);
  if (a3 && v193.n128_f32[0] != 0.0)
    *((_DWORD *)this + 320) = v24;
  v194 = *((_QWORD *)this + 9);
  if (v194)
  {
    v195 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v194 + 32))(v194, 0, v193);
  }
  else
  {
    v196 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v196)
      v195 = 0;
    else
      v195 = *v196;
  }
  *((_BYTE *)this + v24 + 1284) = ausdk::AUElement::GetParameter(v195, a3 + 138) != 0.0;
}

void AUMultiBandDynamicsProcessorV2::CalculateVolCompGainOffset(AUMultiBandDynamicsProcessorV2 *this)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  float v5;
  uint64_t v6;
  ausdk::AUElement *v7;
  ausdk::AUElement **v8;
  float v9;
  uint64_t v10;

  if (*((_BYTE *)this + 1314))
  {
    v2 = *((_QWORD *)this + 9);
    if (v2)
    {
      v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
    }
    else
    {
      v4 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v4)
        v3 = 0;
      else
        v3 = *v4;
    }
    v5 = ausdk::AUElement::GetParameter(v3, 1u) + 0.0;
    v6 = *((_QWORD *)this + 9);
    if (v6)
    {
      v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
    }
    else
    {
      v8 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v8)
        v7 = 0;
      else
        v7 = *v8;
    }
    v9 = v5 + ausdk::AUElement::GetParameter(v7, 5u);
    if (v9 != *((float *)this + 217))
    {
      v10 = 0;
      *((float *)this + 217) = v9;
      do
      {
        AudioUnitSetParameter(*(AudioUnit *)((char *)this + v10 + 824), 0xFu, 0, 0, v9, 0);
        v10 += 8;
      }
      while (v10 != 24);
    }
    if (v9 != *((float *)this + 218))
    {
      *((float *)this + 218) = v9;
      AudioUnitSetParameter(*((AudioUnit *)this + 102), 0xFu, 0, 0, v9, 0);
    }
  }
}

uint64_t AUMultiBandDynamicsProcessorV2::UpdateCrossOverEQs(uint64_t this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t i;
  int v5;
  uint64_t v6;
  ausdk::AUElement *v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v12;
  ausdk::AUElement **v13;
  ausdk::AUElement **v14;
  float v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  float Parameter;
  unsigned int v20;
  float v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  float v25;
  unsigned int v26;
  float v27;
  uint64_t v28;
  ausdk::AUElement *v29;
  ausdk::AUElement **v30;
  float v31;
  unsigned int v32;

  if ((*(_DWORD *)(this + 1272) - 5) >= 0xFFFFFFFD)
  {
    v1 = this;
    v2 = 0;
    v3 = this + 688;
    do
    {
      for (i = 0; i != 128; i += 8)
        AudioUnitSetParameter(*(AudioUnit *)(v3 + i), v2 + 1000, 0, 0, 1.0, 0);
      ++v2;
    }
    while (v2 != 8);
    v5 = *(_DWORD *)(v1 + 1272);
    if (v5 == 2)
    {
      v8 = *(_QWORD *)(v1 + 72);
      if (v8)
      {
        v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
      }
      else
      {
        v13 = *(ausdk::AUElement ***)(v1 + 48);
        if (*(ausdk::AUElement ***)(v1 + 56) == v13)
          v9 = 0;
        else
          v9 = *v13;
      }
      Parameter = ausdk::AUElement::GetParameter(v9, 8u);
      this = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
      if (*(double *)(this + 80) * 0.49000001 < Parameter)
      {
        this = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
        Parameter = *(double *)(this + 80) * 0.49000001;
      }
      if (*(_DWORD *)(v1 + 856))
      {
        v20 = 0;
        do
        {
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v20 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v20 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v20 + 3000, 0, 0, Parameter, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v20 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v20 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v20 + 3000, 0, 0, Parameter, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v20 + 2000, 0, 0, 1.0, 0);
          this = AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v20 + 2000, 0, 0, 2.0, 0);
          ++v20;
        }
        while (v20 < *(_DWORD *)(v1 + 856));
      }
    }
    else if (v5 == 3)
    {
      v6 = *(_QWORD *)(v1 + 72);
      if (v6)
      {
        v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
      }
      else
      {
        v12 = *(ausdk::AUElement ***)(v1 + 48);
        if (*(ausdk::AUElement ***)(v1 + 56) == v12)
          v7 = 0;
        else
          v7 = *v12;
      }
      v15 = ausdk::AUElement::GetParameter(v7, 8u);
      if (*(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0) + 80) * 0.49000001 < v15)
        v15 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0) + 80) * 0.49000001;
      v16 = *(_QWORD *)(v1 + 72);
      if (v16)
      {
        v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
      }
      else
      {
        v18 = *(ausdk::AUElement ***)(v1 + 48);
        if (*(ausdk::AUElement ***)(v1 + 56) == v18)
          v17 = 0;
        else
          v17 = *v18;
      }
      v25 = ausdk::AUElement::GetParameter(v17, 9u);
      this = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
      if (*(double *)(this + 80) * 0.49000001 < v25)
      {
        this = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
        v25 = *(double *)(this + 80) * 0.49000001;
      }
      if (*(_DWORD *)(v1 + 856))
      {
        v26 = 0;
        do
        {
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v26 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v26 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v26 + 3000, 0, 0, v15, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v26 + 2000, 0, 0, 1.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v26 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v26 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v26 + 3000, 0, 0, v15, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v26 + 2000, 0, 0, 2.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 704), v26 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 704), v26 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 704), v26 + 3000, 0, 0, v25, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 704), v26 + 2000, 0, 0, 2.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 712), v26 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 712), v26 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 712), v26 + 3000, 0, 0, v25, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 712), v26 + 2000, 0, 0, 1.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 720), v26 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 720), v26 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 720), v26 + 3000, 0, 0, v25, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 720), v26 + 2000, 0, 0, 1.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 728), v26 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 728), v26 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 728), v26 + 3000, 0, 0, v25, 0);
          this = AudioUnitSetParameter(*(AudioUnit *)(v1 + 728), v26 + 2000, 0, 0, 2.0, 0);
          ++v26;
        }
        while (v26 < *(_DWORD *)(v1 + 856));
      }
    }
    else
    {
      v10 = *(_QWORD *)(v1 + 72);
      if (v10)
      {
        v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
      }
      else
      {
        v14 = *(ausdk::AUElement ***)(v1 + 48);
        if (*(ausdk::AUElement ***)(v1 + 56) == v14)
          v11 = 0;
        else
          v11 = *v14;
      }
      v21 = ausdk::AUElement::GetParameter(v11, 8u);
      if (*(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0) + 80) * 0.49000001 < v21)
        v21 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0) + 80) * 0.49000001;
      v22 = *(_QWORD *)(v1 + 72);
      if (v22)
      {
        v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
      }
      else
      {
        v24 = *(ausdk::AUElement ***)(v1 + 48);
        if (*(ausdk::AUElement ***)(v1 + 56) == v24)
          v23 = 0;
        else
          v23 = *v24;
      }
      v27 = ausdk::AUElement::GetParameter(v23, 9u);
      if (*(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0) + 80) * 0.49000001 < v27)
        v27 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0) + 80) * 0.49000001;
      v28 = *(_QWORD *)(v1 + 72);
      if (v28)
      {
        v29 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 32))(v28, 0);
      }
      else
      {
        v30 = *(ausdk::AUElement ***)(v1 + 48);
        if (*(ausdk::AUElement ***)(v1 + 56) == v30)
          v29 = 0;
        else
          v29 = *v30;
      }
      v31 = ausdk::AUElement::GetParameter(v29, 0xAu);
      this = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
      if (*(double *)(this + 80) * 0.49000001 < v31)
      {
        this = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
        v31 = *(double *)(this + 80) * 0.49000001;
      }
      if (*(_DWORD *)(v1 + 856))
      {
        v32 = 0;
        do
        {
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v32 + 3000, 0, 0, v27, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 688), v32 + 2000, 0, 0, 1.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v32 + 3000, 0, 0, v27, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 696), v32 + 2000, 0, 0, 2.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 704), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 704), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 704), v32 + 3000, 0, 0, v31, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 704), v32 + 2000, 0, 0, 2.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 712), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 712), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 712), v32 + 3000, 0, 0, v31, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 712), v32 + 2000, 0, 0, 1.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 720), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 720), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 720), v32 + 3000, 0, 0, v21, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 720), v32 + 2000, 0, 0, 2.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 728), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 728), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 728), v32 + 3000, 0, 0, v21, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 728), v32 + 2000, 0, 0, 1.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 736), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 736), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 736), v32 + 3000, 0, 0, v21, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 736), v32 + 2000, 0, 0, 1.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 744), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 744), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 744), v32 + 3000, 0, 0, v21, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 744), v32 + 2000, 0, 0, 2.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 752), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 752), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 752), v32 + 3000, 0, 0, v31, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 752), v32 + 2000, 0, 0, 1.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 760), v32 + 4000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 760), v32 + 1000, 0, 0, 0.0, 0);
          AudioUnitSetParameter(*(AudioUnit *)(v1 + 760), v32 + 3000, 0, 0, v31, 0);
          this = AudioUnitSetParameter(*(AudioUnit *)(v1 + 760), v32 + 2000, 0, 0, 2.0, 0);
          ++v32;
        }
        while (v32 < *(_DWORD *)(v1 + 856));
      }
    }
  }
  return this;
}

OpaqueAudioComponentInstance *AUMultiBandDynamicsProcessorV2::UnInitializeUnderlyingAUs(AUMultiBandDynamicsProcessorV2 *this)
{
  unint64_t v2;
  unint64_t i;
  OpaqueAudioComponentInstance *v4;
  uint64_t v5;
  OpaqueAudioComponentInstance *v6;
  BOOL v7;
  OpaqueAudioComponentInstance *result;

  v2 = *((unsigned int *)this + 138);
  if ((_DWORD)v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + i + 102);
      if (v4)
      {
        if (AudioUnitUninitialize(v4))
          goto LABEL_16;
        v2 = *((unsigned int *)this + 138);
      }
    }
  }
  v5 = 0;
  do
  {
    while (1)
    {
      v6 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + v5 + 86);
      if (v6)
        break;
      if (++v5 == 16)
        goto LABEL_16;
    }
    ++v5;
    if (AudioUnitUninitialize(v6))
      v7 = 1;
    else
      v7 = v5 == 16;
  }
  while (!v7);
LABEL_16:
  result = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 106);
  if (result)
    return (OpaqueAudioComponentInstance *)AudioUnitUninitialize(result);
  return result;
}

void AUMultiBandDynamicsProcessorV2::DeAllocateIntermediateBuffer(unsigned int **this, AudioBufferList **a2)
{
  unsigned int *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v3 = *this;
  if (v3)
  {
    v4 = *v3;
    if ((_DWORD)v4)
    {
      v5 = 0;
      v6 = 4;
      do
      {
        if (*(_QWORD *)&v3[v6])
        {
          free(*(void **)&v3[v6]);
          v3 = *this;
          v4 = **this;
        }
        ++v5;
        v6 += 4;
      }
      while (v5 < v4);
    }
    free(v3);
    *this = 0;
  }
}

uint64_t SetUpAudioUnit(OpaqueAudioComponentInstance *a1, const CAStreamBasicDescription *a2, int a3)
{
  uint64_t result;
  int inData;

  inData = a3;
  result = AudioUnitUninitialize(a1);
  if (!(_DWORD)result)
  {
    result = AudioUnitSetProperty(a1, 8u, 1u, 0, a2, 0x28u);
    if (!(_DWORD)result)
    {
      result = AudioUnitSetProperty(a1, 8u, 2u, 0, a2, 0x28u);
      if (!(_DWORD)result)
      {
        if (!a3 || (result = AudioUnitSetProperty(a1, 0xE74u, 0, 0, &inData, 4u), !(_DWORD)result))
        {
          result = SetDoNotAllocateInternalBuffers(a1);
          if (!(_DWORD)result)
            return AudioUnitInitialize(a1);
        }
      }
    }
  }
  return result;
}

uint64_t AUMultiBandDynamicsProcessorV2::SetVolCompParameters(AUMultiBandDynamicsProcessorV2 *this, AudioUnit inUnit, int a3)
{
  uint64_t v6;
  ausdk::AUElement *v7;
  float v8;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  ausdk::AUElement **v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  uint64_t v25;
  ausdk::AUElement *v26;
  ausdk::AUElement **v27;
  uint64_t v28;
  ausdk::AUElement *v29;
  ausdk::AUElement **v30;
  float v31;
  uint64_t v32;
  ausdk::AUElement *v33;
  ausdk::AUElement **v34;
  float v35;
  uint64_t v36;
  ausdk::AUElement *v37;
  ausdk::AUElement **v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  ausdk::AUElement **v44;
  uint64_t v45;
  ausdk::AUElement *v46;
  ausdk::AUElement **v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  ausdk::AUElement **v50;
  uint64_t v51;
  ausdk::AUElement *v52;
  ausdk::AUElement **v53;
  uint64_t v54;
  ausdk::AUElement *v55;
  ausdk::AUElement **v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  ausdk::AUElement **v59;
  uint64_t v60;
  ausdk::AUElement *v61;
  ausdk::AUElement **v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  ausdk::AUElement **v65;
  uint64_t v66;
  ausdk::AUElement *v67;
  ausdk::AUElement **v68;
  uint64_t v69;
  ausdk::AUElement *v70;
  ausdk::AUElement **v71;
  uint64_t v72;
  ausdk::AUElement *v73;
  ausdk::AUElement **v74;
  uint64_t v75;
  ausdk::AUElement *v76;
  ausdk::AUElement **v77;
  uint64_t v78;
  ausdk::AUElement *v79;
  ausdk::AUElement **v80;
  uint64_t v81;
  ausdk::AUElement *v82;
  ausdk::AUElement **v83;
  uint64_t v84;
  ausdk::AUElement *v85;
  ausdk::AUElement **v86;
  uint64_t v87;
  ausdk::AUElement *v88;
  ausdk::AUElement **v89;
  float v90;
  uint64_t v91;
  ausdk::AUElement *v92;
  ausdk::AUElement **v93;
  float v94;
  uint64_t v95;
  ausdk::AUElement *v96;
  ausdk::AUElement **v97;
  uint64_t v98;
  ausdk::AUElement *v99;
  ausdk::AUElement **v100;
  uint64_t v101;
  ausdk::AUElement *v102;
  ausdk::AUElement **v103;
  uint64_t v104;
  ausdk::AUElement *v105;
  ausdk::AUElement **v106;
  uint64_t v107;
  ausdk::AUElement *v108;
  ausdk::AUElement **v109;
  float v110;
  uint64_t v111;
  ausdk::AUElement *v112;
  ausdk::AUElement **v113;
  float v114;
  uint64_t v115;
  ausdk::AUElement *v116;
  ausdk::AUElement **v117;
  uint64_t Parameter;
  uint64_t v119;
  ausdk::AUElement *v120;
  ausdk::AUElement **v121;
  unsigned int v122;
  float v123;
  uint64_t v124;
  ausdk::AUElement *v125;
  ausdk::AUElement **v126;
  uint64_t v127;
  ausdk::AUElement *v128;
  ausdk::AUElement **v129;
  uint64_t v130;
  ausdk::AUElement *v131;
  ausdk::AUElement **v132;
  uint64_t v133;
  ausdk::AUElement *v134;
  ausdk::AUElement **v135;
  uint64_t v136;
  ausdk::AUElement **v137;
  uint64_t v138;
  ausdk::AUElement *v139;
  ausdk::AUElement **v140;
  uint64_t v141;
  ausdk::AUElement *v142;
  ausdk::AUElement **v143;
  uint64_t v144;
  ausdk::AUElement *v145;
  ausdk::AUElement **v146;
  float v147;
  uint64_t v148;
  ausdk::AUElement *v149;
  ausdk::AUElement **v150;
  uint64_t v151;
  ausdk::AUElement *v152;
  float v153;
  ausdk::AUElement **v154;
  uint64_t v155;
  ausdk::AUElement *v156;
  ausdk::AUElement **v157;
  AudioUnitParameterValue outValue[2];

  *(_QWORD *)outValue = 0;
  if (*((_BYTE *)this + 1314))
  {
    AudioUnitGetParameter(inUnit, 1u, 0, 0, &outValue[1]);
    v6 = *((_QWORD *)this + 9);
    if (v6)
    {
      v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
    }
    else
    {
      v11 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v11)
        v7 = 0;
      else
        v7 = *v11;
    }
    ausdk::AUElement::SetParameter(v7, a3 + 100, outValue[1], 0);
    AudioUnitGetParameter(inUnit, 2u, 0, 0, &outValue[1]);
    v13 = *((_QWORD *)this + 9);
    if (v13)
    {
      v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
    }
    else
    {
      v15 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v15)
        v14 = 0;
      else
        v14 = *v15;
    }
    ausdk::AUElement::SetParameter(v14, a3 + 101, outValue[1], 0);
    AudioUnitGetParameter(inUnit, 3u, 0, 0, &outValue[1]);
    v16 = *((_QWORD *)this + 9);
    if (v16)
    {
      v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
    }
    else
    {
      v18 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v18)
        v17 = 0;
      else
        v17 = *v18;
    }
    ausdk::AUElement::SetParameter(v17, a3 + 102, outValue[1], 0);
    AudioUnitGetParameter(inUnit, 4u, 0, 0, &outValue[1]);
    v19 = *((_QWORD *)this + 9);
    if (v19)
    {
      v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
    }
    else
    {
      v21 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v21)
        v20 = 0;
      else
        v20 = *v21;
    }
    ausdk::AUElement::SetParameter(v20, a3 + 105, outValue[1], 0);
    v22 = *((_QWORD *)this + 9);
    if (v22)
    {
      v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
    }
    else
    {
      v24 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v24)
        v23 = 0;
      else
        v23 = *v24;
    }
    ausdk::AUElement::SetParameter(v23, a3 + 106, outValue[1], 0);
    AudioUnitGetParameter(inUnit, 5u, 0, 0, &outValue[1]);
    v25 = *((_QWORD *)this + 9);
    if (v25)
    {
      v26 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, 0);
    }
    else
    {
      v27 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v27)
        v26 = 0;
      else
        v26 = *v27;
    }
    ausdk::AUElement::SetParameter(v26, a3 + 103, outValue[1], 0);
    v28 = *((_QWORD *)this + 9);
    if (v28)
    {
      v29 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 32))(v28, 0);
    }
    else
    {
      v30 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v30)
        v29 = 0;
      else
        v29 = *v30;
    }
    ausdk::AUElement::SetParameter(v29, a3 + 104, outValue[1], 0);
    AudioUnitGetParameter(inUnit, 6u, 0, 0, &outValue[1]);
    v31 = (float)(1000.0 / outValue[1]) * 0.06;
    outValue[1] = v31;
    v32 = *((_QWORD *)this + 9);
    if (v32)
    {
      v33 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v32 + 32))(v32, 0);
      v31 = outValue[1];
    }
    else
    {
      v34 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v34)
        v33 = 0;
      else
        v33 = *v34;
    }
    ausdk::AUElement::SetParameter(v33, a3 + 107, v31, 0);
    AudioUnitGetParameter(inUnit, 7u, 0, 0, &outValue[1]);
    v35 = (float)(1000.0 / outValue[1]) * -0.06;
    outValue[1] = v35;
    v36 = *((_QWORD *)this + 9);
    if (v36)
    {
      v37 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v36 + 32))(v36, 0);
      v35 = outValue[1];
    }
    else
    {
      v38 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v38)
        v37 = 0;
      else
        v37 = *v38;
    }
    ausdk::AUElement::SetParameter(v37, a3 + 108, v35, 0);
    AudioUnitGetParameter(inUnit, 0x10u, 0, 0, &outValue[1]);
    v39 = *((_QWORD *)this + 9);
    if (v39)
    {
      v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
    }
    else
    {
      v41 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v41)
        v40 = 0;
      else
        v40 = *v41;
    }
    ausdk::AUElement::SetParameter(v40, a3 + 111, outValue[1], 0);
    AudioUnitGetParameter(inUnit, 8u, 0, 0, &outValue[1]);
    v42 = *((_QWORD *)this + 9);
    if (v42)
    {
      v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v42 + 32))(v42, 0);
    }
    else
    {
      v44 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v44)
        v43 = 0;
      else
        v43 = *v44;
    }
    ausdk::AUElement::SetParameter(v43, a3 + 120, outValue[1], 0);
    AudioUnitGetParameter(inUnit, 0xBu, 0, 0, &outValue[1]);
    v45 = *((_QWORD *)this + 9);
    if (v45)
    {
      v46 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v45 + 32))(v45, 0);
    }
    else
    {
      v47 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v47)
        v46 = 0;
      else
        v46 = *v47;
    }
    ausdk::AUElement::SetParameter(v46, a3 + 113, outValue[1], 0);
    AudioUnitGetParameter(inUnit, 0xAu, 0, 0, &outValue[1]);
    v48 = *((_QWORD *)this + 9);
    if (v48)
    {
      v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v48 + 32))(v48, 0);
    }
    else
    {
      v50 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v50)
        v49 = 0;
      else
        v49 = *v50;
    }
    ausdk::AUElement::SetParameter(v49, a3 + 114, outValue[1], 0);
    AudioUnitSetParameter(inUnit, 0xCu, 0, 0, 1.0, 0);
    AudioUnitGetParameter(inUnit, 0x14u, 0, 0, outValue);
    v51 = *((_QWORD *)this + 9);
    if (v51)
    {
      v52 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v51 + 32))(v51, 0);
    }
    else
    {
      v53 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v53)
        v52 = 0;
      else
        v52 = *v53;
    }
    ausdk::AUElement::SetParameter(v52, a3 + 115, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x15u, 0, 0, outValue);
    v54 = *((_QWORD *)this + 9);
    if (v54)
    {
      v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v54 + 32))(v54, 0);
    }
    else
    {
      v56 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v56)
        v55 = 0;
      else
        v55 = *v56;
    }
    ausdk::AUElement::SetParameter(v55, a3 + 116, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x1Eu, 0, 0, outValue);
    v57 = *((_QWORD *)this + 9);
    if (v57)
    {
      v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v57 + 32))(v57, 0);
    }
    else
    {
      v59 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v59)
        v58 = 0;
      else
        v58 = *v59;
    }
    ausdk::AUElement::SetParameter(v58, a3 + 117, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x1Fu, 0, 0, outValue);
    v60 = *((_QWORD *)this + 9);
    if (v60)
    {
      v61 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v60 + 32))(v60, 0);
    }
    else
    {
      v62 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v62)
        v61 = 0;
      else
        v61 = *v62;
    }
    ausdk::AUElement::SetParameter(v61, a3 + 118, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x28u, 0, 0, outValue);
    v63 = *((_QWORD *)this + 9);
    if (v63)
    {
      v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v63 + 32))(v63, 0);
    }
    else
    {
      v65 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v65)
        v64 = 0;
      else
        v64 = *v65;
    }
    ausdk::AUElement::SetParameter(v64, a3 + 109, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x29u, 0, 0, outValue);
    v66 = *((_QWORD *)this + 9);
    if (v66)
    {
      v67 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v66 + 32))(v66, 0);
    }
    else
    {
      v68 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v68)
        v67 = 0;
      else
        v67 = *v68;
    }
    ausdk::AUElement::SetParameter(v67, a3 + 110, outValue[0], 0);
    AudioUnitSetParameter(inUnit, 0x32u, 0, 0, 1.0, 0);
    AudioUnitGetParameter(inUnit, 0x33u, 0, 0, outValue);
    v69 = *((_QWORD *)this + 9);
    if (v69)
    {
      v70 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v69 + 32))(v69, 0);
    }
    else
    {
      v71 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v71)
        v70 = 0;
      else
        v70 = *v71;
    }
    ausdk::AUElement::SetParameter(v70, a3 + 112, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x10u, 0, 0, outValue);
    v72 = *((_QWORD *)this + 9);
    if (v72)
    {
      v73 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v72 + 32))(v72, 0);
    }
    else
    {
      v74 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v74)
        v73 = 0;
      else
        v73 = *v74;
    }
    ausdk::AUElement::SetParameter(v73, a3 + 111, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0, 0, 0, outValue);
    v75 = *((_QWORD *)this + 9);
    if (v75)
    {
      v76 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v75 + 32))(v75, 0);
    }
    else
    {
      v77 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v77)
        v76 = 0;
      else
        v76 = *v77;
    }
    ausdk::AUElement::SetParameter(v76, a3 + 119, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x41u, 0, 0, outValue);
    v78 = *((_QWORD *)this + 9);
    if (v78)
    {
      v79 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v78 + 32))(v78, 0);
    }
    else
    {
      v80 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v80)
        v79 = 0;
      else
        v79 = *v80;
    }
    ausdk::AUElement::SetParameter(v79, a3 + 122, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x42u, 0, 0, outValue);
    v81 = *((_QWORD *)this + 9);
    if (v81)
    {
      v82 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v81 + 32))(v81, 0);
    }
    else
    {
      v83 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v83)
        v82 = 0;
      else
        v82 = *v83;
    }
    ausdk::AUElement::SetParameter(v82, a3 + 123, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 9u, 0, 0, outValue);
    v84 = *((_QWORD *)this + 9);
    if (v84)
    {
      v85 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v84 + 32))(v84, 0);
    }
    else
    {
      v86 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v86)
        v85 = 0;
      else
        v85 = *v86;
    }
    ausdk::AUElement::SetParameter(v85, a3 + 121, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x43u, 0, 0, outValue);
    v87 = *((_QWORD *)this + 9);
    if (v87)
    {
      v88 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v87 + 32))(v87, 0);
    }
    else
    {
      v89 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v89)
        v88 = 0;
      else
        v88 = *v89;
    }
    ausdk::AUElement::SetParameter(v88, a3 + 124, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x44u, 0, 0, outValue);
    v90 = outValue[0] * 1000.0;
    outValue[0] = outValue[0] * 1000.0;
    v91 = *((_QWORD *)this + 9);
    if (v91)
    {
      v92 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v91 + 32))(v91, 0);
      v90 = outValue[0];
    }
    else
    {
      v93 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v93)
        v92 = 0;
      else
        v92 = *v93;
    }
    ausdk::AUElement::SetParameter(v92, a3 + 125, v90, 0);
    AudioUnitGetParameter(inUnit, 0x45u, 0, 0, outValue);
    v94 = outValue[0] * 1000.0;
    outValue[0] = outValue[0] * 1000.0;
    v95 = *((_QWORD *)this + 9);
    if (v95)
    {
      v96 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v95 + 32))(v95, 0);
      v94 = outValue[0];
    }
    else
    {
      v97 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v97)
        v96 = 0;
      else
        v96 = *v97;
    }
    ausdk::AUElement::SetParameter(v96, a3 + 126, v94, 0);
    AudioUnitGetParameter(inUnit, 0x46u, 0, 0, outValue);
    v98 = *((_QWORD *)this + 9);
    if (v98)
    {
      v99 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v98 + 32))(v98, 0);
    }
    else
    {
      v100 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v100)
        v99 = 0;
      else
        v99 = *v100;
    }
    ausdk::AUElement::SetParameter(v99, a3 + 127, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x47u, 0, 0, outValue);
    v101 = *((_QWORD *)this + 9);
    if (v101)
    {
      v102 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v101 + 32))(v101, 0);
    }
    else
    {
      v103 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v103)
        v102 = 0;
      else
        v102 = *v103;
    }
    ausdk::AUElement::SetParameter(v102, a3 + 139, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x48u, 0, 0, outValue);
    v104 = *((_QWORD *)this + 9);
    if (v104)
    {
      v105 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v104 + 32))(v104, 0);
    }
    else
    {
      v106 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v106)
        v105 = 0;
      else
        v105 = *v106;
    }
    ausdk::AUElement::SetParameter(v105, a3 + 131, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x49u, 0, 0, outValue);
    v107 = *((_QWORD *)this + 9);
    if (v107)
    {
      v108 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v107 + 32))(v107, 0);
    }
    else
    {
      v109 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v109)
        v108 = 0;
      else
        v108 = *v109;
    }
    ausdk::AUElement::SetParameter(v108, a3 + 132, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x4Au, 0, 0, outValue);
    v110 = outValue[0] * 1000.0;
    outValue[0] = outValue[0] * 1000.0;
    v111 = *((_QWORD *)this + 9);
    if (v111)
    {
      v112 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v111 + 32))(v111, 0);
      v110 = outValue[0];
    }
    else
    {
      v113 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v113)
        v112 = 0;
      else
        v112 = *v113;
    }
    ausdk::AUElement::SetParameter(v112, a3 + 133, v110, 0);
    AudioUnitGetParameter(inUnit, 0x4Bu, 0, 0, outValue);
    v114 = outValue[0] * 1000.0;
    outValue[0] = outValue[0] * 1000.0;
    v115 = *((_QWORD *)this + 9);
    if (v115)
    {
      v116 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v115 + 32))(v115, 0);
      v114 = outValue[0];
    }
    else
    {
      v117 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v117)
        v116 = 0;
      else
        v116 = *v117;
    }
    ausdk::AUElement::SetParameter(v116, a3 + 134, v114, 0);
    Parameter = AudioUnitGetParameter(inUnit, 0x4Cu, 0, 0, outValue);
    v119 = *((_QWORD *)this + 9);
    if (v119)
    {
      v120 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v119 + 32))(v119, 0);
    }
    else
    {
      v121 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v121)
        v120 = 0;
      else
        v120 = *v121;
    }
    v122 = a3 + 135;
  }
  else
  {
    AudioUnitGetParameter(inUnit, 6u, 0, 0, &outValue[1]);
    v8 = (float)(1000.0 / outValue[1]) * 0.06;
    outValue[1] = v8;
    v9 = *((_QWORD *)this + 9);
    if (v9)
    {
      v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
      v8 = outValue[1];
    }
    else
    {
      v12 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v12)
        v10 = 0;
      else
        v10 = *v12;
    }
    ausdk::AUElement::SetParameter(v10, a3 + 107, v8, 0);
    AudioUnitGetParameter(inUnit, 7u, 0, 0, &outValue[1]);
    v123 = (float)(1000.0 / outValue[1]) * -0.06;
    outValue[1] = v123;
    v124 = *((_QWORD *)this + 9);
    if (v124)
    {
      v125 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v124 + 32))(v124, 0);
      v123 = outValue[1];
    }
    else
    {
      v126 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v126)
        v125 = 0;
      else
        v125 = *v126;
    }
    ausdk::AUElement::SetParameter(v125, a3 + 108, v123, 0);
    AudioUnitGetParameter(inUnit, 0x28u, 0, 0, outValue);
    v127 = *((_QWORD *)this + 9);
    if (v127)
    {
      v128 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v127 + 32))(v127, 0);
    }
    else
    {
      v129 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v129)
        v128 = 0;
      else
        v128 = *v129;
    }
    ausdk::AUElement::SetParameter(v128, a3 + 109, outValue[0], 0);
    AudioUnitGetParameter(inUnit, 0x29u, 0, 0, outValue);
    v130 = *((_QWORD *)this + 9);
    if (v130)
    {
      v131 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v130 + 32))(v130, 0);
    }
    else
    {
      v132 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v132)
        v131 = 0;
      else
        v131 = *v132;
    }
    ausdk::AUElement::SetParameter(v131, a3 + 110, outValue[0], 0);
    AudioUnitSetParameter(inUnit, 0x32u, 0, 0, 1.0, 0);
    AudioUnitGetParameter(inUnit, 0x33u, 0, 0, outValue);
    v133 = *((_QWORD *)this + 9);
    if (v133)
    {
      v134 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v133 + 32))(v133, 0);
    }
    else
    {
      v135 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v135)
        v134 = 0;
      else
        v134 = *v135;
    }
    ausdk::AUElement::SetParameter(v134, a3 + 112, outValue[0], 0);
    Parameter = AudioUnitGetParameter(inUnit, 0x10u, 0, 0, outValue);
    v136 = *((_QWORD *)this + 9);
    if (v136)
    {
      v120 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v136 + 32))(v136, 0);
    }
    else
    {
      v137 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v137)
        v120 = 0;
      else
        v120 = *v137;
    }
    v122 = a3 + 111;
  }
  ausdk::AUElement::SetParameter(v120, v122, outValue[0], 0);
  v138 = *((_QWORD *)this + 9);
  if (v138)
  {
    v139 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v138 + 32))(v138, 0);
  }
  else
  {
    v140 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v140)
      v139 = 0;
    else
      v139 = *v140;
  }
  ausdk::AUElement::SetParameter(v139, a3 + 136, 0.0, 0);
  v141 = *((_QWORD *)this + 9);
  if (v141)
  {
    v142 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v141 + 32))(v141, 0);
  }
  else
  {
    v143 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v143)
      v142 = 0;
    else
      v142 = *v143;
  }
  ausdk::AUElement::SetParameter(v142, a3 + 137, 0.0, 0);
  v144 = *((_QWORD *)this + 9);
  if (v144)
  {
    v145 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v144 + 32))(v144, 0);
  }
  else
  {
    v146 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v146)
      v145 = 0;
    else
      v145 = *v146;
  }
  v147 = 0.0;
  ausdk::AUElement::SetParameter(v145, a3 + 138, 0.0, 0);
  outValue[0] = 0.0;
  v148 = *((_QWORD *)this + 9);
  if (v148)
  {
    v149 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v148 + 32))(v148, 0);
    v147 = outValue[0];
  }
  else
  {
    v150 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v150)
      v149 = 0;
    else
      v149 = *v150;
  }
  ausdk::AUElement::SetParameter(v149, a3 + 128, v147, 0);
  outValue[0] = -90.0;
  v151 = *((_QWORD *)this + 9);
  if (v151)
  {
    v152 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v151 + 32))(v151, 0);
    v153 = outValue[0];
  }
  else
  {
    v154 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v154)
      v152 = 0;
    else
      v152 = *v154;
    v153 = -90.0;
  }
  ausdk::AUElement::SetParameter(v152, a3 + 129, v153, 0);
  v155 = *((_QWORD *)this + 9);
  if (v155)
  {
    v156 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v155 + 32))(v155, 0);
  }
  else
  {
    v157 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v157)
      v156 = 0;
    else
      v156 = *v157;
  }
  ausdk::AUElement::SetParameter(v156, a3 + 130, outValue[0], 0);
  return Parameter;
}

uint64_t AUMultiBandDynamicsProcessorV2::RenderCallbackVolComp(AUMultiBandDynamicsProcessorV2 *this, void *a2, unsigned int *a3, const AudioTimeStamp *a4, int a5, _DWORD *a6, AudioBufferList *a7)
{
  uint64_t Element;
  unsigned int *BufferList;

  Element = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 128), 0);
  BufferList = (unsigned int *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
  CopyBufferList(BufferList, a6, (*((_DWORD *)this + 312) * a5));
  return 0;
}

uint64_t AUMultiBandDynamicsProcessorV2::RenderCallbackNBandEQ(AUMultiBandDynamicsProcessorV2 *this, void *a2, unsigned int *a3, const AudioTimeStamp *a4, int a5, _DWORD *a6, AudioBufferList *a7)
{
  uint64_t Element;
  unsigned int *BufferList;

  Element = ausdk::AUScope::SafeGetElement((AUMultiBandDynamicsProcessorV2 *)((char *)this + 80), 0);
  BufferList = (unsigned int *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
  CopyBufferList(BufferList, a6, (*((_DWORD *)this + 312) * a5));
  return 0;
}

void FeatureAudioAdaptor::FeatureAudioAdaptor(FeatureAudioAdaptor *this, const CAStreamBasicDescription *a2, const CAStreamBasicDescription *a3, unsigned int a4, unsigned int a5, int (*a6)(void *, unsigned int, const AudioBufferList **, AudioBufferList **), void *a7)
{
  double v9;
  double v10;
  BlockProcessor *v11;
  double v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;

  v9 = *(double *)a2;
  v10 = *(double *)a3;
  *(_QWORD *)this = *(_QWORD *)a2;
  *((double *)this + 1) = v10;
  *((_DWORD *)this + 4) = a4;
  *((_DWORD *)this + 5) = a5;
  *((double *)this + 3) = (double)a4 / v9;
  *((double *)this + 4) = (double)a5 / v10;
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 48) = 0;
  v11 = (FeatureAudioAdaptor *)((char *)this + 48);
  *((_BYTE *)this + 112) = 0;
  v12 = *(double *)a2;
  v13 = *(double *)a3;
  *((_BYTE *)this + 120) = *(double *)a2 == *(double *)a3;
  *((_BYTE *)this + 121) = (v10 * (double)a4 / v9) == a5;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  if (v12 != v13)
  {
    AT::Resampler::create((AT::Resampler *)0x6E6F726D, v12, v13, 0.0);
    v14 = v18;
    v18 = 0;
    v15 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = v14;
    if (v15)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
      v16 = v18;
      v18 = 0;
      if (v16)
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
    }
    if (!*((_BYTE *)this + 121))
      goto LABEL_9;
LABEL_4:
    *((_QWORD *)this + 16) = a6;
    *((_QWORD *)this + 17) = FeaturesDSPWrapper::RebufferingProcessAdaptor;
    return;
  }
  if ((v10 * (double)a4 / v9) == a5)
    goto LABEL_4;
LABEL_9:
  v17 = 1;
  std::__optional_destruct_base<BlockProcessor,false>::reset[abi:ne180100](v11);
  BlockProcessor::BlockProcessor(v11, 1, &v17, 1, &v17, *((_DWORD *)this + 5), (int (*)(void *, unsigned int, const AudioBufferList **, AudioBufferList **))FeaturesDSPWrapper::RebufferingProcessAdaptor, a6);
  *((_BYTE *)this + 112) = 1;
}

void sub_1B6589574(_Unwind_Exception *a1)
{
  uint64_t v1;
  _BYTE *v2;
  uint64_t v4;

  std::__optional_destruct_base<BlockProcessor,false>::~__optional_destruct_base[abi:ne180100](v2);
  v4 = *(_QWORD *)(v1 + 40);
  *(_QWORD *)(v1 + 40) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

MicSenseUtils::GainsToFIR *MicSenseUtils::GainsToFIR::GainsToFIR(MicSenseUtils::GainsToFIR *this, unint64_t a2)
{
  char **v4;
  char **v5;
  uint64_t *v6;
  char **v7;
  char **v8;
  char **v9;
  char **v10;
  unint64_t v11;
  _QWORD *v12;
  vDSP_Length v13;
  float v14;
  float __B;

  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  v4 = (char **)((char *)this + 104);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_OWORD *)((char *)this + 152) = 0u;
  v5 = (char **)((char *)this + 152);
  *((_DWORD *)this + 12) = 1056964608;
  *((_QWORD *)this + 31) = 0;
  v6 = (uint64_t *)((char *)this + 248);
  v7 = (char **)((char *)this + 80);
  v8 = (char **)((char *)this + 128);
  *(_OWORD *)((char *)this + 72) = 0u;
  v9 = (char **)((char *)this + 176);
  v10 = (char **)((char *)this + 224);
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = (a2 >> 1) + 1;
  *((_QWORD *)this + 3) = 1;
  __B = 0.0;
  std::vector<float>::assign((char **)this + 7, a2, &__B);
  __B = 0.0;
  std::vector<float>::assign(v7, a2, &__B);
  __B = 0.0;
  std::vector<float>::assign(v4, a2, &__B);
  __B = 0.0;
  std::vector<float>::assign(v8, a2, &__B);
  __B = 0.0;
  std::vector<float>::assign(v5, a2, &__B);
  __B = 0.0;
  std::vector<float>::assign(v10, a2, &__B);
  v11 = *((_QWORD *)this + 2);
  __B = 0.0;
  std::vector<float>::assign(v9, v11, &__B);
  v12 = (_QWORD *)operator new();
  *v12 = 0;
  v12[1] = 0;
  std::unique_ptr<vp::vx::Control_Center_Manager>::reset[abi:ne180100](v6, (uint64_t)v12);
  MultiRadixRealFFT::Initialize(*((MultiRadixRealFFT **)this + 31), *((_DWORD *)this + 2));
  v13 = *((_QWORD *)this + 2);
  v14 = 6.28318531
      / (float)*((unint64_t *)this + 1)
      * (float)((float)((float)*((unint64_t *)this + 1) + -1.0) * -0.5);
  __B = v14;
  vDSP_vramp(&MicSenseUtils::kZerof, &__B, *((float **)this + 22), 1, v13);
  return this;
}

void sub_1B6589774(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void **v7;
  void **v8;
  uint64_t *v9;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  std::unique_ptr<vp::vx::Control_Center_Manager>::reset[abi:ne180100](v9, 0);
  v11 = *v8;
  if (*v8)
  {
    v1[29] = v11;
    operator delete(v11);
  }
  v12 = (void *)v1[25];
  if (v12)
  {
    v1[26] = v12;
    operator delete(v12);
  }
  v13 = *v7;
  if (*v7)
  {
    v1[23] = v13;
    operator delete(v13);
  }
  v14 = *v6;
  if (*v6)
  {
    v1[20] = v14;
    operator delete(v14);
  }
  v15 = *v5;
  if (*v5)
  {
    v1[17] = v15;
    operator delete(v15);
  }
  v16 = *v4;
  if (*v4)
  {
    v1[14] = v16;
    operator delete(v16);
  }
  v17 = *v3;
  if (*v3)
  {
    v1[11] = v17;
    operator delete(v17);
  }
  v18 = *v2;
  if (*v2)
  {
    v1[8] = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

void MicSenseUtils::GainsToFIR::gainsToLinearPhaseFilter(int *a1, uint64_t a2, float **a3, vDSP_Length a4, uint64_t a5)
{
  const int *v5;
  float *v11;
  uint64_t v12;
  vDSP_Length v13;
  vDSP_Length v14;
  uint64_t v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  float __B;
  DSPSplitComplex v20;

  v5 = a1 + 4;
  if (*((_QWORD *)a1 + 2) != (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2)
    __assert_rtn("gainsToLinearPhaseFilter", "MicSenseGainsToFIR.cpp", 61, "gains.size() == mCplxVectorSize");
  v11 = (float *)*((_QWORD *)a1 + 13);
  v20.realp = (float *)*((_QWORD *)a1 + 10);
  v20.imagp = v11;
  vvcosf(v20.realp, *((const float **)a1 + 22), v5);
  vvsinf(v11, *((const float **)a1 + 22), v5);
  vDSP_vmul(*(const float **)a2, 1, v20.realp, 1, v20.realp, 1, *((_QWORD *)a1 + 2));
  vDSP_vmul(*(const float **)a2, 1, v11, 1, v11, 1, *((_QWORD *)a1 + 2));
  *v11 = v20.realp[*((_QWORD *)a1 + 2) - 1];
  __B = 1.0 / (float)*((unint64_t *)a1 + 1);
  MultiRadixRealFFT::RealOutOfPlaceInverseTransform(*((const vDSP_DFT_SetupStruct ****)a1 + 31), &v20, *((DSPComplex **)a1 + 7));
  vDSP_vsmul(*((const float **)a1 + 7), 1, &__B, *((float **)a1 + 7), 1, (uint64_t)(*((_QWORD *)a1 + 8) - *((_QWORD *)a1 + 7)) >> 2);
  if (*((_QWORD *)a1 + 4) == a4)
  {
    v12 = *((_QWORD *)a1 + 5);
  }
  else
  {
    v12 = -1;
    *((_QWORD *)a1 + 4) = a4;
    *((_QWORD *)a1 + 5) = -1;
  }
  v13 = (a4 >> 1) - a5;
  if (a5)
  {
    if (v12 != v13)
    {
      *((_QWORD *)a1 + 5) = v13;
      vDSP_hann_window(*((float **)a1 + 28), 2 * v13, 0);
      v14 = a4 - *((_QWORD *)a1 + 5);
      vDSP_hann_window(*((float **)a1 + 10), 2 * v14, 0);
      v15 = *((_QWORD *)a1 + 10);
      v16 = (const void *)(v15 + 4 * v14);
      v17 = v15 + 8 * v14 - 4;
      v12 = *((_QWORD *)a1 + 5);
      if ((const void *)v17 != v16)
      {
        memmove((void *)(*((_QWORD *)a1 + 28) + 4 * v12 + 4), v16, v17 - (_QWORD)v16);
        v12 = *((_QWORD *)a1 + 5);
      }
    }
    v18 = ~v12 + (*((_QWORD *)a1 + 1) >> 1);
  }
  else
  {
    if (v12 != v13)
    {
      *((_QWORD *)a1 + 5) = v13;
      vDSP_hann_window(*((float **)a1 + 28), a4, 0);
    }
    v18 = ~(a4 >> 1) + (*((_QWORD *)a1 + 1) >> 1);
  }
  vDSP_vmul((const float *)(*((_QWORD *)a1 + 7) + 4 * v18), 1, *((const float **)a1 + 28), 1, *a3, 1, a4);
}

void MicSenseUtils::GainsToFIR::gainsToMinimumPhaseFilter(uint64_t a1, uint64_t a2, float **a3, vDSP_Length a4)
{
  uint64_t v4;
  float *v9;
  float *v10;
  const void *v11;
  int64_t v12;
  vDSP_Length v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  float v17;
  float *v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  DSPSplitComplex __D;
  float __B;
  vDSP_Length __N;

  v4 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  if (v4 >> 2 != *(_QWORD *)(a1 + 16))
    __assert_rtn("gainsToMinimumPhaseFilter", "MicSenseGainsToFIR.cpp", 159, "gains.size() == mCplxVectorSize");
  LODWORD(__N) = (unint64_t)v4 >> 2;
  __B = (float)*(unint64_t *)(a1 + 8);
  vDSP_vthr(*(const float **)(a1 + 80), 1, &MicSenseUtils::kepsf, *(float **)(a1 + 80), 1, v4 >> 2);
  vvlogf(*(float **)(a1 + 80), *(const float **)a2, (const int *)&__N);
  vDSP_vsdiv(*(const float **)(a1 + 80), 1, &__B, *(float **)(a1 + 80), 1, *(_QWORD *)(a1 + 16));
  v9 = *(float **)(a1 + 80);
  v10 = *(float **)(a1 + 152);
  *v10 = v9[*(_QWORD *)(a1 + 16) - 1];
  __D.realp = v9;
  __D.imagp = v10;
  MultiRadixRealFFT::RealOutOfPlaceInverseTransform(*(const vDSP_DFT_SetupStruct ****)(a1 + 248), &__D, *(DSPComplex **)(a1 + 56));
  v11 = *(const void **)(a1 + 56);
  v12 = *(_QWORD *)(a1 + 64) - (_QWORD)v11;
  v13 = ((unint64_t)(v12 >> 2) >> 1) + 1;
  memcpy(*(void **)(a1 + 80), v11, v12);
  vDSP_vadd((const float *)(*(_QWORD *)(a1 + 56) + 4), 1, (const float *)(*(_QWORD *)(a1 + 80) + v12 - 4), -1, (float *)(*(_QWORD *)(a1 + 56) + 4), 1, v13);
  vDSP_vclr((float *)(*(_QWORD *)(a1 + 56) + 4 * v13), 1, (v12 >> 2) - ((unint64_t)(v12 >> 2) >> 1) - 2);
  if (*(_QWORD *)(a1 + 24))
  {
    v14 = *(_QWORD *)(a1 + 56);
    v15 = *(_QWORD *)(a1 + 64) - v14;
    v16 = ((unint64_t)(v15 >> 2) >> 1) + 1;
    v17 = (float)(int)(float)((float)(*(float *)(a1 + 48) * (float)v16) + 0.5);
    if ((float)v16 < v17)
      v17 = (float)v16;
    vDSP_vclr((float *)(v14 + 4 * (unint64_t)v17 + 4), 1, ~(unint64_t)v17 + (v15 >> 2));
  }
  v18 = *(float **)(a1 + 104);
  __D.realp = *(float **)(a1 + 80);
  __D.imagp = v18;
  MultiRadixRealFFT::RealOutOfPlaceForwardTransform(*(MultiRadixRealFFT **)(a1 + 248), *(DSPComplex **)(a1 + 56), &__D, 1.0);
  LODWORD(__N) = *(_DWORD *)(a1 + 16) - 1;
  if ((v19 & 1) == 0
  {
    MicSenseUtils::GainsToFIR::cepstrumToFrequency(std::vector<float> const&,DSPSplitComplex &,std::vector<float>&)::kMaxValue = 1118925336;
  }
  if ((v20 & 1) == 0
  {
    *(float *)&MicSenseUtils::GainsToFIR::cepstrumToFrequency(std::vector<float> const&,DSPSplitComplex &,std::vector<float>&)::kMinValue = -*(float *)&MicSenseUtils::GainsToFIR::cepstrumToFrequency(std::vector<float> const&,DSPSplitComplex &,std::vector<float>&)::kMaxValue;
  }
  vDSP_vclip(__D.realp, 1, (const float *)&MicSenseUtils::GainsToFIR::cepstrumToFrequency(std::vector<float> const&,DSPSplitComplex &,std::vector<float>&)::kMinValue, (const float *)&MicSenseUtils::GainsToFIR::cepstrumToFrequency(std::vector<float> const&,DSPSplitComplex &,std::vector<float>&)::kMaxValue, __D.realp, 1, *(_QWORD *)(a1 + 16) - 1);
  vvexpf(*(float **)(a1 + 128), __D.realp, (const int *)&__N);
  vvcosf(__D.realp, __D.imagp, (const int *)&__N);
  vvsinf(__D.imagp, __D.imagp, (const int *)&__N);
  vDSP_zrvmul(&__D, 1, *(const float **)(a1 + 128), 1, &__D, 1, (int)__N);
  __B = 1.0 / (float)*(unint64_t *)(a1 + 8);
  vDSP_vsmul(__D.realp, 1, &__B, __D.realp, 1, (int)__N);
  vDSP_vsmul(__D.imagp, 1, &__B, __D.imagp, 1, (int)__N);
  MultiRadixRealFFT::RealOutOfPlaceInverseTransform(*(const vDSP_DFT_SetupStruct ****)(a1 + 248), &__D, *(DSPComplex **)(a1 + 56));
  vDSP_hann_window(*(float **)(a1 + 80), 2 * a4, 0);
  vDSP_vmul(*(const float **)(a1 + 56), 1, (const float *)(*(_QWORD *)(a1 + 80) + 4 * a4), 1, *a3, 1, a4);
}

uint64_t MRRingBuffer<StateEvent>::GetSample(uint64_t a1, int a2)
{
  int v2;

  if (a2 < 0)
    v2 = *(_DWORD *)(a1 + 8) + ~((*(_DWORD *)(a1 + 8) - a2 + ~*(_DWORD *)(a1 + 12)) % *(_DWORD *)(a1 + 8));
  else
    v2 = (*(_DWORD *)(a1 + 12) + a2) % *(_DWORD *)(a1 + 8);
  return *(_QWORD *)(*(_QWORD *)a1 + 16 * v2);
}

void vec::init<DSPSplitComplex>(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  size_t v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  int64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  void *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t *v39;
  void *__p;
  char *v41;

  v5 = a2;
  std::vector<DSPSplitComplex>::vector(&__p, a3);
  v6 = a1[2];
  v7 = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - *a1) >> 3) < a2)
  {
    if (v7)
    {
      std::vector<std::vector<float>>::__clear[abi:ne180100](a1);
      operator delete((void *)*a1);
      v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    v8 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    v9 = 2 * v8;
    if (2 * v8 <= v5)
      v9 = v5;
    if (v8 >= 0x555555555555555)
      v10 = 0xAAAAAAAAAAAAAAALL;
    else
      v10 = v9;
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](a1, v10);
    v11 = (_QWORD *)a1[1];
    v12 = 3 * v5;
    v13 = &v11[3 * v5];
    v14 = 8 * v12;
    do
    {
      *v11 = 0;
      v11[1] = 0;
      v11[2] = 0;
      std::vector<DSPSplitComplex>::__init_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(v11, __p, (uint64_t)v41, (v41 - (_BYTE *)__p) >> 4);
      v11 += 3;
      v14 -= 24;
    }
    while (v14);
    goto LABEL_43;
  }
  v38 = v5;
  v39 = a1;
  v37 = (a1[1] - v7) / 24;
  if (v37 >= v5)
    v15 = v5;
  else
    v15 = (a1[1] - v7) / 24;
  if (v15)
  {
    v16 = v7 + 8;
    while ((void **)(v16 - 8) == &__p)
    {
LABEL_39:
      v7 += 24;
      v16 += 24;
      if (!--v15)
        goto LABEL_40;
    }
    v17 = (char *)__p;
    v18 = v41;
    v19 = v41 - (_BYTE *)__p;
    v20 = (v41 - (_BYTE *)__p) >> 4;
    v21 = *(_QWORD *)(v16 + 8);
    v22 = *(char **)(v16 - 8);
    if (v20 > (v21 - (uint64_t)v22) >> 4)
    {
      if (v22)
      {
        *(_QWORD *)v16 = v22;
        operator delete(v22);
        v21 = 0;
        *(_QWORD *)(v16 - 8) = 0;
        *(_QWORD *)v16 = 0;
        *(_QWORD *)(v16 + 8) = 0;
      }
      if ((v19 & 0x8000000000000000) != 0)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v23 = v21 >> 3;
      if (v21 >> 3 <= v20)
        v23 = v20;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0)
        v24 = 0xFFFFFFFFFFFFFFFLL;
      else
        v24 = v23;
      std::vector<DSPSplitComplex>::__vallocate[abi:ne180100]((_QWORD *)(v16 - 8), v24);
      v22 = *(char **)v16;
      if (v18 != v17)
        memmove(*(void **)v16, v17, v19);
      v25 = (_QWORD *)v16;
      goto LABEL_38;
    }
    v25 = (_QWORD *)(v7 + 8);
    v26 = *(_QWORD *)v16 - (_QWORD)v22;
    v27 = v26 >> 4;
    if (v26 >> 4 >= v20)
    {
      if (v41 == __p)
      {
LABEL_38:
        *v25 = &v22[v19];
        goto LABEL_39;
      }
      v29 = *(char **)(v16 - 8);
      v28 = (char *)__p;
    }
    else
    {
      if (*(char **)v16 != v22)
      {
        memmove(*(void **)(v16 - 8), __p, v26);
        v22 = *(char **)v16;
      }
      v28 = &v17[16 * v27];
      v19 = v18 - v28;
      if (v18 == v28)
        goto LABEL_38;
      v29 = v22;
    }
    memmove(v29, v28, v19);
    goto LABEL_38;
  }
LABEL_40:
  if (v38 > v37)
  {
    a1 = v39;
    v30 = (_QWORD *)v39[1];
    v13 = &v30[3 * (v38 - v37)];
    v31 = 24 * v38 - 24 * v37;
    do
    {
      *v30 = 0;
      v30[1] = 0;
      v30[2] = 0;
      std::vector<DSPSplitComplex>::__init_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(v30, __p, (uint64_t)v41, (v41 - (_BYTE *)__p) >> 4);
      v30 += 3;
      v31 -= 24;
    }
    while (v31);
LABEL_43:
    a1[1] = (uint64_t)v13;
    goto LABEL_50;
  }
  v32 = v39[1];
  v33 = *v39 + 24 * v38;
  if (v32 != v33)
  {
    v34 = v39[1];
    do
    {
      v36 = *(void **)(v34 - 24);
      v34 -= 24;
      v35 = v36;
      if (v36)
      {
        *(_QWORD *)(v32 - 16) = v35;
        operator delete(v35);
      }
      v32 = v34;
    }
    while (v34 != v33);
  }
  v39[1] = v33;
LABEL_50:
  if (__p)
  {
    v41 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1B658A0F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void vec::init<float>(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v4;
  void *__p[3];
  int v6;

  v6 = 0;
  v4 = a2;
  std::vector<float>::vector(__p, a3, &v6);
  std::vector<std::vector<float>>::assign(a1, v4, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1B658A184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MCLP_FLSL_Joint_OS_vDSP::ProcessBufferList(MCLP_FLSL_Joint_OS_vDSP *this, const AudioBufferList *a2, const AudioBufferList *a3, AudioBufferList *a4, AudioBufferList *a5, int a6, int a7, int a8, unsigned int *a9)
{
  unint64_t v15;
  unint64_t v16;
  void **p_mData;
  float v18;
  float v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  float v24;
  float v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  void **v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  void **v33;
  unsigned int v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t i;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t j;
  uint64_t v43;
  uint64_t v44;
  unint64_t k;
  unint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unsigned int v59;
  uint64_t v60;
  float *v61;
  float *v62;
  const DSPSplitComplex *v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t m;
  uint64_t v72;
  unint64_t n;
  BOOL v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unsigned int v81;
  uint64_t v82;
  unint64_t v83;
  unsigned int v84;
  unint64_t v85;
  unint64_t v86;
  void **v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  void **v91;
  unint64_t v92;
  void **v93;
  void **v94;
  void *v95;
  void *v96;
  void *v97;
  unint64_t v98;
  unint64_t v100;
  void **v101;
  void **v102;
  void *v103;
  void *v104;
  void *v105;
  float32x4_t **__N;
  int v107;
  const AudioBufferList *v108;
  AudioBufferList *v109;
  const AudioBufferList *v110;
  AudioBufferList *v111;
  float *v112;
  const float *v114;
  DSPSplitComplex *v116;
  DSPSplitComplex v117;

  LODWORD(v15) = *((_DWORD *)this + 10);
  *((_DWORD *)this + 35) = v15;
  if (!(_DWORD)v15)
  {
    v23 = 0;
LABEL_10:
    v24 = 0.0;
    v25 = 0.0;
    goto LABEL_11;
  }
  v16 = 0;
  p_mData = &a2->mBuffers[0].mData;
  v18 = 0.0;
  do
  {
    v19 = cblas_sdot(2 * *((_DWORD *)this + 11) - 2, (const float *)*p_mData, 1, (const float *)*p_mData, 1);
    v20 = *((_QWORD *)this + 18);
    *(_QWORD *)(v20 + 8 * (v16 >> 6)) &= ~(1 << v16);
    v15 = *((unsigned int *)this + 10);
    v21 = (unint64_t)(v16 + v15) >> 6;
    v22 = 1 << (v16 + v15);
    *(_QWORD *)(v20 + 8 * v21) &= ~v22;
    if (v19 == 0.0)
    {
      --*((_DWORD *)this + 35);
      *(_QWORD *)(v20 + 8 * (v16 >> 6)) |= 1 << v16;
      *(_QWORD *)(v20 + 8 * v21) |= v22;
    }
    else
    {
      v18 = v18 + v19;
    }
    ++v16;
    p_mData += 2;
  }
  while (v16 < v15);
  v23 = *((_DWORD *)this + 35);
  if (!v23)
    goto LABEL_10;
  v24 = *((float *)this + 22) / (float)v23;
  v25 = v18 * v24;
LABEL_11:
  *((float *)this + 25) = v24 / *((float *)this + 24);
  *((float *)this + 23) = v24;
  if (v25 <= *((float *)this + 4) || v23 < 2 || (LODWORD(v25) & 0x7FFFFFFFu) >= 0x7F800000)
  {
    if ((_DWORD)v15)
    {
      v92 = 0;
      v93 = &a2->mBuffers[0].mData;
      v94 = &a4->mBuffers[0].mData;
      do
      {
        v96 = *v94;
        v94 += 2;
        v95 = v96;
        v97 = *v93;
        v93 += 2;
        memcpy(v95, v97, 4 * (2 * *((_DWORD *)this + 11) - 2));
        ++v92;
        v98 = *((unsigned int *)this + 10);
      }
      while (v92 < v98);
      if (*((_BYTE *)this + 36) && (_DWORD)v98 != 0)
      {
        v100 = 0;
        v101 = &a3->mBuffers[0].mData;
        v102 = &a5->mBuffers[0].mData;
        do
        {
          v104 = *v102;
          v102 += 2;
          v103 = v104;
          v105 = *v101;
          v101 += 2;
          memcpy(v103, v105, 4 * (2 * *((_DWORD *)this + 11) - 2));
          ++v100;
        }
        while (v100 < *((unsigned int *)this + 10));
      }
    }
  }
  else
  {
    v107 = a8;
    vDSP_zvmov(**((const DSPSplitComplex ***)this + 37), 1, **((const DSPSplitComplex ***)this + 46), 1, (*((_DWORD *)this + 19) * *((_DWORD *)this + 18)));
    v26 = *((unsigned int *)this + 10);
    if ((_DWORD)v26)
    {
      v27 = 0;
      v28 = 0;
      v29 = &a2->mBuffers[0].mData;
      do
      {
        if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v28 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v28) & 1) == 0)
        {
          vDSP_vsmul((const float *)v29[v27 / 8], 1, (const float *)this + 33, *(float **)(*((_QWORD *)this + 28) + v27), 1, *((unsigned int *)this + 11));
          vDSP_vsmul((const float *)v29[v27 / 8] + *((unsigned int *)this + 11), 1, (const float *)this + 33, (float *)(*(_QWORD *)(*((_QWORD *)this + 28) + v27 + 8) + 4), 1, (*((_DWORD *)this + 11) - 2));
          vDSP_zvmov((const DSPSplitComplex *)(*((_QWORD *)this + 28) + v27), 1, (const DSPSplitComplex *)(**((_QWORD **)this + 37) + v27), 1, *((unsigned int *)this + 11));
          v26 = *((unsigned int *)this + 10);
        }
        ++v28;
        v27 += 16;
      }
      while (v28 < v26);
    }
    if (*((_BYTE *)this + 36))
    {
      vDSP_zvmov(**((const DSPSplitComplex ***)this + 120), 1, **((const DSPSplitComplex ***)this + 129), 1, (*((_DWORD *)this + 19) * *((_DWORD *)this + 18)));
      v30 = *((unsigned int *)this + 10);
      if ((_DWORD)v30)
      {
        v31 = 0;
        v32 = 0;
        v33 = &a3->mBuffers[0].mData;
        do
        {
          if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v32 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v32) & 1) == 0)
          {
            vDSP_vsmul((const float *)v33[v31 / 8], 1, (const float *)this + 33, *(float **)(*((_QWORD *)this + 111) + v31), 1, *((unsigned int *)this + 11));
            vDSP_vsmul((const float *)v33[v31 / 8] + *((unsigned int *)this + 11), 1, (const float *)this + 33, (float *)(*(_QWORD *)(*((_QWORD *)this + 111) + v31 + 8) + 4), 1, (*((_DWORD *)this + 11) - 2));
            vDSP_zvmov((const DSPSplitComplex *)(*((_QWORD *)this + 111) + v31), 1, (const DSPSplitComplex *)(**((_QWORD **)this + 120) + v31), 1, *((unsigned int *)this + 11));
            v30 = *((unsigned int *)this + 10);
          }
          ++v32;
          v31 += 16;
        }
        while (v32 < v30);
      }
    }
    v108 = a2;
    v109 = a4;
    v110 = a3;
    v111 = a5;
    v114 = (const float *)((char *)this + 88);
    vDSP_vfill((const float *)this + 22, *((float **)this + 102), 1, *((unsigned int *)this + 11));
    if (a7)
      vDSP_vclr(*((float **)this + 61), 1, *((unsigned int *)this + 10));
    v34 = *((_DWORD *)this + 42);
    if (v34 >= *((_DWORD *)this + 18))
      v34 = *((_DWORD *)this + 18);
    if (v34)
    {
      v35 = 0;
      v116 = (DSPSplitComplex *)((char *)this + 680);
      v112 = (float *)((char *)this + 84);
      do
      {
        if (!v35)
        {
          vDSP_vclr(*((float **)this + 93), 1, *((unsigned int *)this + 11));
          v36 = *((unsigned int *)this + 10);
          if ((_DWORD)v36)
          {
            v37 = 0;
            for (i = 0; i < v36; ++i)
            {
              if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((i >> 3) & 0x1FFFFFFFFFFFFFF8)) >> i) & 1) == 0)
              {
                vDSP_zvmgsa((const DSPSplitComplex *)(*((_QWORD *)this + 28) + v37), 1, *((const float **)this + 93), 1, *((float **)this + 93), 1, *((unsigned int *)this + 11));
                v36 = *((unsigned int *)this + 10);
              }
              v37 += 16;
            }
          }
          vDSP_vsmul(*((const float **)this + 93), 1, (const float *)this + 23, *((float **)this + 93), 1, *((unsigned int *)this + 11));
        }
        vDSP_vthr(*((const float **)this + 93), 1, (const float *)this + 5, *((float **)this + 93), 1, *((unsigned int *)this + 11));
        if (*((float *)this + 8) != 0.0)
          vvpowsf(*((float **)this + 93), (const float *)this + 26, *((const float **)this + 93), (const int *)this + 12);
        vDSP_svdiv((const float *)this + 24, *((const float **)this + 93), 1, *((float **)this + 87), 1, *((unsigned int *)this + 11));
        memcpy((void *)(*((_QWORD *)this + 87) + 4 * *((unsigned int *)this + 11)), *((const void **)this + 87), 4 * *((unsigned int *)this + 11));
        vDSP_vfill(v114, *((float **)this + 99), 1, *((unsigned int *)this + 16));
        v39 = *((unsigned int *)this + 10);
        if (!(_DWORD)v39)
          goto LABEL_84;
        v40 = 0;
        v41 = 0;
        for (j = 0; j < v39; ++j)
        {
          if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((j >> 3) & 0x1FFFFFFFFFFFFFF8)) >> j) & 1) == 0)
          {
            vDSP_zvmov((const DSPSplitComplex *)(*((_QWORD *)this + 28) + v41), 1, *(const DSPSplitComplex **)(*((_QWORD *)this + 73) + v40), 1, *((unsigned int *)this + 11));
            vDSP_zvmov((const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 46) + 24 * v35) + v41), 1, (const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 73) + v40) + 16), 1, *((unsigned int *)this + 11));
            vDSP_zvmov((const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 46) + 24 * v35) + v41), 1, *(const DSPSplitComplex **)(*((_QWORD *)this + 73) + 24 * (j + *((_DWORD *)this + 10))), 1, *((unsigned int *)this + 11));
            vDSP_zvmov((const DSPSplitComplex *)(*((_QWORD *)this + 28) + v41), 1, (const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 73)+ 24 * (j + *((_DWORD *)this + 10)))+ 16), 1, *((unsigned int *)this + 11));
            v39 = *((unsigned int *)this + 10);
          }
          v41 += 16;
          v40 += 24;
        }
        if (*((_BYTE *)this + 36))
        {
          if (!v39)
            goto LABEL_84;
          v43 = 0;
          v44 = 0;
          for (k = 0; k < v39; ++k)
          {
            if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((k >> 3) & 0x1FFFFFFFFFFFFFF8)) >> k) & 1) == 0)
            {
              vDSP_zvmov((const DSPSplitComplex *)(*((_QWORD *)this + 111) + v44), 1, *(const DSPSplitComplex **)(*((_QWORD *)this + 138) + v43), 1, *((unsigned int *)this + 11));
              vDSP_zvmov((const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 129) + 24 * v35) + v44), 1, (const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 138) + v43) + 16), 1, *((unsigned int *)this + 11));
              vDSP_zvmov((const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 129) + 24 * v35) + v44), 1, *(const DSPSplitComplex **)(*((_QWORD *)this + 138) + 24 * (k + *((_DWORD *)this + 10))), 1, *((unsigned int *)this + 11));
              vDSP_zvmov((const DSPSplitComplex *)(*((_QWORD *)this + 111) + v44), 1, (const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 138)+ 24 * (k + *((_DWORD *)this + 10)))+ 16), 1, *((unsigned int *)this + 11));
              v39 = *((unsigned int *)this + 10);
            }
            v44 += 16;
            v43 += 24;
          }
          if (!v39)
            goto LABEL_84;
          v46 = 0;
          v47 = -1;
          v48 = 24;
          v49 = 1;
          do
          {
            v50 = v46 + 1;
            if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v46 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v46) & 1) == 0)
            {
              v51 = *((unsigned int *)this + 15);
              if (v50 < v51)
              {
                v52 = 0;
                v53 = v48;
                do
                {
                  if (((*(_QWORD *)(*((_QWORD *)this + 18)
                                   + (((unint64_t)(v49 + v52) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v49 + v52)) & 1) == 0)
                  {
                    vDSP_zvma((const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 55) + 24 * v35)+ 16* (v52+ (_DWORD)v46 * *((_DWORD *)this + 10)+ ((v46 * (v47 + v51)) >> 1))), 1, *(const DSPSplitComplex **)(*((_QWORD *)this + 138) + 24 * v46), 1, *(const DSPSplitComplex **)(*((_QWORD *)this + 138) + v53), 1, *(const DSPSplitComplex **)(*((_QWORD *)this + 138) + v53), 1, *((unsigned int *)this + 16));
                    LODWORD(v51) = *((_DWORD *)this + 15);
                  }
                  v53 += 24;
                  ++v52;
                }
                while (v49 + v52 < (unint64_t)v51);
                v39 = *((unsigned int *)this + 10);
              }
            }
            ++v49;
            v48 += 24;
            --v47;
            ++v46;
          }
          while (v50 < v39);
        }
        if (v39)
        {
          v54 = 0;
          v55 = 24;
          v56 = 1;
          do
          {
            if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v54 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v54) & 1) != 0)
            {
              v57 = v54 + 1;
            }
            else
            {
              v117.realp = 0;
              v117.imagp = 0;
              v117 = *(DSPSplitComplex *)*(_QWORD *)(*((_QWORD *)this + 73) + 24 * v54);
              vDSP_zvmags(&v117, 1, *((float **)this + 76), 1, *((unsigned int *)this + 16));
              vDSP_vmul(*((const float **)this + 99), 1, *((const float **)this + 76), 1, *((float **)this + 76), 1, *((unsigned int *)this + 16));
              v58 = *((_QWORD *)this + 58);
              if (a6)
              {
                v59 = *((_DWORD *)this + 16);
                v60 = ((_DWORD)v54 + *((_DWORD *)this + 10) * (_DWORD)v35) * v59;
                v61 = (float *)(v58 + 4 * v60);
                v62 = (float *)(v58 + 4 * (v60 + *((_DWORD *)this + 11)));
              }
              else
              {
                v61 = (float *)*((_QWORD *)this + 64);
                v62 = &v61[*((unsigned int *)this + 11)];
                v59 = *((_DWORD *)this + 16);
                v60 = ((_DWORD)v54 + *((_DWORD *)this + 10) * (_DWORD)v35) * v59;
              }
              vDSP_vsmul((const float *)(v58 + 4 * v60), 1, (const float *)this + 6, v61, 1, v59);
              vDSP_vma(*((const float **)this + 76), 1, *((const float **)this + 87), 1, v61, 1, v61, 1, *((unsigned int *)this + 16));
              vDSP_vthr(v61, 1, (const float *)this + 4, v61, 1, *((unsigned int *)this + 16));
              if (a7)
                vDSP_meanv(&v62[*((unsigned int *)this + 30)], 1, (float *)(*((_QWORD *)this + 61) + 4 * v54), *((unsigned int *)this + 32));
              vDSP_vdiv(v61, 1, *((const float **)this + 87), 1, *((float **)this + 90), 1, *((unsigned int *)this + 16));
              vDSP_vneg(*((const float **)this + 90), 1, *((float **)this + 90), 1, *((unsigned int *)this + 16));
              v63 = (const DSPSplitComplex *)((char *)this + 680);
              vDSP_zrvmul(&v117, 1, *((const float **)this + 90), 1, v116, 1, *((unsigned int *)this + 16));
              vDSP_zrvmul(v63, 1, *((const float **)this + 99), 1, v63, 1, *((unsigned int *)this + 16));
              vDSP_zvconj(v63, 1, v63, 1, *((unsigned int *)this + 16));
              vDSP_vmsa(*((const float **)this + 90), 1, *((const float **)this + 76), 1, v114, *((float **)this + 96), 1, *((unsigned int *)this + 16));
              vDSP_vthr(*((const float **)this + 96), 1, v112, *((float **)this + 96), 1, *((unsigned int *)this + 16));
              vDSP_vmul(*((const float **)this + 99), 1, *((const float **)this + 96), 1, *((float **)this + 99), 1, *((unsigned int *)this + 16));
              v57 = v54 + 1;
              v64 = *((unsigned int *)this + 15);
              if (a6)
              {
                if (v57 < v64)
                {
                  v65 = v55;
                  v66 = v56;
                  do
                  {
                    if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v66 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v66) & 1) == 0)
                    {
                      __N = (float32x4_t **)(*(_QWORD *)(*((_QWORD *)this + 55) + 24 * v35)
                                           + 16
                                           * ((_DWORD)v66
                                            - (_DWORD)v54
                                            + *((_DWORD *)this + 10) * (_DWORD)v54
                                            + (((v64 - v57) * v54) >> 1)
                                            - 1));
                      aDSP_zvmama((float32x4_t *)&v117, 1, __N, 1, *(float32x4_t ***)(*((_QWORD *)this + 73) + v65), 1, (float32x4_t **)v116, 1, __N, 1, *((unsigned int *)this + 16));
                      LODWORD(v64) = *((_DWORD *)this + 15);
                    }
                    ++v66;
                    v65 += 24;
                  }
                  while (v66 < v64);
                }
              }
              else if (v57 < v64)
              {
                v67 = v55;
                v68 = v56;
                do
                {
                  if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v68 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v68) & 1) == 0)
                  {
                    vDSP_zvma(&v117, 1, (const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 55) + 24 * v35)+ 16* ((_DWORD)v68- (_DWORD)v54+ *((_DWORD *)this + 10) * (_DWORD)v54+ (((v64 - v57) * v54) >> 1)- 1)), 1, *(const DSPSplitComplex **)(*((_QWORD *)this + 73) + v67), 1, *(const DSPSplitComplex **)(*((_QWORD *)this + 73) + v67), 1, *((unsigned int *)this + 16));
                    LODWORD(v64) = *((_DWORD *)this + 15);
                  }
                  ++v68;
                  v67 += 24;
                }
                while (v68 < v64);
              }
              v39 = *((unsigned int *)this + 10);
            }
            ++v56;
            v55 += 24;
            v54 = v57;
          }
          while (v57 < v39);
        }
LABEL_84:
        vDSP_vthr(*((const float **)this + 99), 1, v112, *((float **)this + 99), 1, *((unsigned int *)this + 16));
        vvsqrtf(*((float **)this + 99), *((const float **)this + 99), (const int *)this + 13);
        vDSP_vmul((const float *)(*((_QWORD *)this + 99) + 4 * *((unsigned int *)this + 11)), 1, *((const float **)this + 102), 1, *((float **)this + 102), 1, *((unsigned int *)this + 11));
        v69 = *((unsigned int *)this + 10);
        if ((_DWORD)v69)
        {
          v70 = 0;
          for (m = 0; m < v69; ++m)
          {
            if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((m >> 3) & 0x1FFFFFFFFFFFFFF8)) >> m) & 1) == 0)
            {
              vDSP_zrvmul((const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 73) + 24 * (m + v69)) + 16), 1, (const float *)(*((_QWORD *)this + 99) + 4 * *((unsigned int *)this + 11)), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 28) + v70), 1, *((unsigned int *)this + 11));
              v69 = *((unsigned int *)this + 10);
            }
            v70 += 16;
          }
          if (v35 >= (*((_DWORD *)this + 18) - 1))
            goto LABEL_95;
          if (v69)
          {
            v72 = 0;
            for (n = 0; n < v69; ++n)
            {
              if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((n >> 3) & 0x1FFFFFFFFFFFFFF8)) >> n) & 1) == 0)
              {
                vDSP_zrvmul(*(const DSPSplitComplex **)(*((_QWORD *)this + 73) + 24 * (n + v69)), 1, *((const float **)this + 99), 1, (const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 37) + 24 * (v35 + 1)) + v72), 1, *((unsigned int *)this + 11));
                v69 = *((unsigned int *)this + 10);
              }
              v72 += 16;
            }
LABEL_95:
            if (*((_BYTE *)this + 36))
              v74 = v69 == 0;
            else
              v74 = 1;
            if (!v74)
            {
              v75 = 0;
              v76 = 0;
              do
              {
                if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v76 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v76) & 1) == 0)
                {
                  vDSP_zrvmul((const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 138) + 24 * (v76 + v69))+ 16), 1, (const float *)(*((_QWORD *)this + 99) + 4 * *((unsigned int *)this + 11)), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 111) + v75), 1, *((unsigned int *)this + 11));
                  v69 = *((unsigned int *)this + 10);
                }
                ++v76;
                v75 += 16;
              }
              while (v76 < v69);
              if (v35 < (*((_DWORD *)this + 18) - 1) && v69 != 0)
              {
                v78 = 0;
                v79 = 0;
                do
                {
                  if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v79 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v79) & 1) == 0)
                  {
                    vDSP_zrvmul(*(const DSPSplitComplex **)(*((_QWORD *)this + 138) + 24 * (v79 + v69)), 1, *((const float **)this + 99), 1, (const DSPSplitComplex *)(*(_QWORD *)(*((_QWORD *)this + 120) + 24 * (v35 + 1)) + v78), 1, *((unsigned int *)this + 11));
                    v69 = *((unsigned int *)this + 10);
                  }
                  ++v79;
                  v78 += 16;
                }
                while (v79 < v69);
              }
            }
          }
        }
        vDSP_vsq(*((const float **)this + 99), 1, *((float **)this + 99), 1, *((unsigned int *)this + 11));
        vDSP_vneg(*((const float **)this + 99), 1, *((float **)this + 99), 1, *((unsigned int *)this + 11));
        vDSP_vsadd(*((const float **)this + 99), 1, v114, *((float **)this + 99), 1, *((unsigned int *)this + 11));
        vDSP_vsmul(*((const float **)this + 99), 1, (const float *)this + 25, *((float **)this + 99), 1, *((unsigned int *)this + 11));
        vDSP_vmul(*((const float **)this + 99), 1, *((const float **)this + 93), 1, *((float **)this + 93), 1, *((unsigned int *)this + 11));
        if ((a7 & 1) != 0)
        {
          LODWORD(v117.realp) = 0;
          vDSP_maxv(*((const float **)this + 61), 1, (float *)&v117, *((unsigned int *)this + 10));
          *a9 = ++v35;
          if (*(float *)&v117.realp > *((float *)this + 7))
            break;
        }
        else
        {
          ++v35;
        }
        LODWORD(v80) = *((_DWORD *)this + 42);
        v81 = *((_DWORD *)this + 18);
        if (v80 >= v81)
          v80 = v81;
        else
          v80 = v80;
      }
      while (v35 < v80);
    }
    if (v107 && *((_DWORD *)this + 10))
    {
      v82 = 0;
      v83 = 0;
      do
      {
        if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v83 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v83) & 1) == 0)
        {
          vDSP_zrvmul((const DSPSplitComplex *)(*((_QWORD *)this + 28) + v82), 1, *((const float **)this + 102), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 28) + v82), 1, *((unsigned int *)this + 11));
          if (*((_BYTE *)this + 36))
            vDSP_zrvmul((const DSPSplitComplex *)(*((_QWORD *)this + 111) + v82), 1, *((const float **)this + 102), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 111) + v82), 1, *((unsigned int *)this + 11));
        }
        ++v83;
        v82 += 16;
      }
      while (v83 < *((unsigned int *)this + 10));
    }
    v84 = *((_DWORD *)this + 42);
    if (v84 < *((_DWORD *)this + 18))
      *((_DWORD *)this + 42) = v84 + 1;
    if (*((_DWORD *)this + 10))
    {
      v85 = 0;
      v86 = 0;
      v87 = &v109->mBuffers[0].mData;
      do
      {
        if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v86 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v86) & 1) != 0)
        {
          memcpy(v87[v85 / 8], v108->mBuffers[v85 / 0x10].mData, 4 * (2 * *((_DWORD *)this + 11) - 2));
        }
        else
        {
          vDSP_vsmul(*(const float **)(*((_QWORD *)this + 28) + v85), 1, (const float *)this + 34, (float *)v87[v85 / 8], 1, *((unsigned int *)this + 11));
          vDSP_vsmul((const float *)(*(_QWORD *)(*((_QWORD *)this + 28) + v85 + 8) + 4), 1, (const float *)this + 34, (float *)v87[v85 / 8] + *((unsigned int *)this + 11), 1, (*((_DWORD *)this + 11) - 2));
        }
        ++v86;
        v88 = *((unsigned int *)this + 10);
        v85 += 16;
      }
      while (v86 < v88);
      if (*((_BYTE *)this + 36) && (_DWORD)v88)
      {
        v89 = 0;
        v90 = 0;
        v91 = &v111->mBuffers[0].mData;
        do
        {
          if (((*(_QWORD *)(*((_QWORD *)this + 18) + ((v90 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v90) & 1) != 0)
          {
            memcpy(v91[v89 / 8], v110->mBuffers[v89 / 0x10].mData, 4 * (2 * *((_DWORD *)this + 11) - 2));
          }
          else
          {
            vDSP_vsmul(*(const float **)(*((_QWORD *)this + 111) + v89), 1, (const float *)this + 34, (float *)v91[v89 / 8], 1, *((unsigned int *)this + 11));
            vDSP_vsmul((const float *)(*(_QWORD *)(*((_QWORD *)this + 111) + v89 + 8) + 4), 1, (const float *)this + 34, (float *)v91[v89 / 8] + *((unsigned int *)this + 11), 1, (*((_DWORD *)this + 11) - 2));
          }
          ++v90;
          v89 += 16;
        }
        while (v90 < *((unsigned int *)this + 10));
      }
    }
  }
}

Beamformer_BeamNF::CmhBEAM2NOpt *Beamformer_BeamNF::CmhBEAM2NOpt::CmhBEAM2NOpt(Beamformer_BeamNF::CmhBEAM2NOpt *this)
{
  uint64_t v2;
  _OWORD *v3;

  v2 = 0;
  *((_QWORD *)this + 62) = 0;
  *((_QWORD *)this + 63) = 0;
  *((_DWORD *)this + 128) = 0;
  *((_QWORD *)this + 77) = 0;
  *((_QWORD *)this + 76) = 0;
  *((_QWORD *)this + 65) = 0x100000000;
  *((_DWORD *)this + 132) = 0;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((_OWORD *)this + 47) = 0u;
  *((_OWORD *)this + 48) = 0u;
  *((_OWORD *)this + 49) = 0u;
  *((_QWORD *)this + 100) = 0;
  do
  {
    *(_DWORD *)((char *)this + v2 * 4 + 532) = MC_default_param[v2];
    ++v2;
  }
  while ((_DWORD)(v2 * 4) != 76);
  *((_QWORD *)this + 107) = 0;
  v3 = (_OWORD *)operator new[]();
  v3[8] = 0u;
  v3[9] = 0u;
  v3[6] = 0u;
  v3[7] = 0u;
  v3[4] = 0u;
  v3[5] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 107) = v3;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 202) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 13) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *((_OWORD *)this + 52) = 0u;
  *((_DWORD *)this + 111) = 0;
  *(_OWORD *)((char *)this + 252) = 0u;
  *(_OWORD *)((char *)this + 236) = 0u;
  *(_OWORD *)((char *)this + 220) = 0u;
  *(_OWORD *)((char *)this + 204) = 0u;
  *(_OWORD *)((char *)this + 188) = 0u;
  *(_OWORD *)((char *)this + 156) = 0u;
  *(_OWORD *)((char *)this + 172) = 0u;
  *(_OWORD *)((char *)this + 412) = 0u;
  *(_OWORD *)((char *)this + 428) = 0u;
  *(_OWORD *)((char *)this + 380) = 0u;
  *(_OWORD *)((char *)this + 396) = 0u;
  *(_OWORD *)((char *)this + 348) = 0u;
  *(_OWORD *)((char *)this + 364) = 0u;
  *(_OWORD *)((char *)this + 316) = 0u;
  *(_OWORD *)((char *)this + 332) = 0u;
  *(_OWORD *)((char *)this + 284) = 0u;
  *(_OWORD *)((char *)this + 300) = 0u;
  *(_OWORD *)((char *)this + 268) = 0u;
  *(_OWORD *)((char *)this + 4) = xmmword_1B66A11C0;
  *((_OWORD *)this + 2) = xmmword_1B66A11D0;
  *((_QWORD *)this + 35) = 0x12EDBE6FFLL;
  *((_DWORD *)this + 38) = 0;
  *((_DWORD *)this + 72) = 1031798784;
  *((_DWORD *)this + 90) = 1065353216;
  *(_QWORD *)((char *)this + 388) = 0x3F0000003F333333;
  *(_OWORD *)((char *)this + 120) = xmmword_1B66A11E0;
  *((_DWORD *)this + 34) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 224) = 0;
  return this;
}

void sub_1B658B460(_Unwind_Exception *a1)
{
  uint64_t v1;

  CmhMicCheck::deallocate_memory(v1);
  _Unwind_Resume(a1);
}

uint64_t Beamformer_BeamNF::CmhBEAM2NOpt::deallocate_memory(uint64_t this)
{
  uint64_t v1;
  int v2;
  uint64_t i;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  char v50;
  char v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  char v56;
  uint64_t v57;
  uint64_t v58;

  if (*(_DWORD *)this)
  {
    v1 = this;
    *(_DWORD *)this = 0;
    if (*(_QWORD *)(this + 160))
    {
      v2 = *(_DWORD *)(this + 44);
      if (v2 < 1)
        goto LABEL_9;
      for (i = 0; i < v2; ++i)
      {
        v4 = *(_QWORD *)(*(_QWORD *)(v1 + 160) + 8 * i);
        if (v4)
        {
          MEMORY[0x1BCC95CC8](v4, 0x1000C8052888210);
          v2 = *(_DWORD *)(v1 + 44);
        }
      }
      if (*(_QWORD *)(v1 + 160))
LABEL_9:
        MEMORY[0x1BCC95CC8]();
      *(_QWORD *)(v1 + 160) = 0;
    }
    v5 = 0;
    v6 = 1;
    do
    {
      v7 = v6;
      v8 = v1 + 16 * v5;
      v11 = *(_QWORD *)(v8 + 168);
      v10 = (_QWORD *)(v8 + 168);
      v9 = v11;
      if (v11)
        MEMORY[0x1BCC95CC8](v9, 0x1000C8052888210);
      v6 = 0;
      *v10 = 0;
      v10[1] = 0;
      v5 = 1;
    }
    while ((v7 & 1) != 0);
    if (*(_QWORD *)(v1 + 440))
    {
      if (*(int *)(v1 + 8) < 1)
        goto LABEL_36;
      v12 = 0;
      v13 = 0;
      do
      {
        v14 = *(_QWORD *)(v1 + 440);
        v15 = *(_QWORD *)(v14 + v12);
        if (v15)
        {
          MEMORY[0x1BCC95CC8](v15, 0x1000C8052888210);
          v14 = *(_QWORD *)(v1 + 440);
          v16 = (_QWORD *)(v14 + v12);
          *v16 = 0;
          v16[1] = 0;
        }
        v17 = *(_QWORD *)(v14 + v12 + 16);
        if (v17)
        {
          MEMORY[0x1BCC95CC8](v17, 0x1000C8052888210);
          v14 = *(_QWORD *)(v1 + 440);
        }
        v18 = *(_QWORD *)(v14 + v12 + 24);
        if (v18)
        {
          MEMORY[0x1BCC95CC8](v18, 0x1000C8052888210);
          v14 = *(_QWORD *)(v1 + 440);
        }
        v19 = *(_QWORD *)(v14 + v12 + 32);
        if (v19)
        {
          MEMORY[0x1BCC95CC8](v19, 0x1000C8052888210);
          v14 = *(_QWORD *)(v1 + 440);
        }
        v20 = *(_QWORD *)(v14 + v12 + 40);
        if (v20)
        {
          MEMORY[0x1BCC95CC8](v20, 0x1000C8052888210);
          v14 = *(_QWORD *)(v1 + 440);
        }
        v21 = *(_QWORD *)(v14 + v12 + 48);
        if (v21)
        {
          MEMORY[0x1BCC95CC8](v21, 0x1000C8052888210);
          *(_QWORD *)(*(_QWORD *)(v1 + 440) + v12 + 48) = 0;
          v14 = *(_QWORD *)(v1 + 440);
        }
        v22 = *(_QWORD *)(v14 + v12 + 56);
        if (v22)
        {
          MEMORY[0x1BCC95CC8](v22, 0x1000C8052888210);
          *(_QWORD *)(*(_QWORD *)(v1 + 440) + v12 + 56) = 0;
          v14 = *(_QWORD *)(v1 + 440);
        }
        v23 = *(_QWORD *)(v14 + v12 + 120);
        if (v23)
          MEMORY[0x1BCC95CC8](v23, 0x1000C8052888210);
        ++v13;
        v12 += 136;
      }
      while (v13 < *(int *)(v1 + 8));
      if (*(_QWORD *)(v1 + 440))
LABEL_36:
        MEMORY[0x1BCC95CC8]();
      *(_QWORD *)(v1 + 440) = 0;
    }
    v24 = *(_QWORD *)(v1 + 448);
    if (v24)
    {
      MEMORY[0x1BCC95CC8](v24, 0x1000C8052888210);
      *(_QWORD *)(v1 + 448) = 0;
    }
    v25 = *(_QWORD *)(v1 + 456);
    if (v25)
    {
      MEMORY[0x1BCC95CC8](v25, 0x1000C8052888210);
      *(_QWORD *)(v1 + 456) = 0;
    }
    v26 = *(_QWORD *)(v1 + 464);
    if (v26)
    {
      MEMORY[0x1BCC95CC8](v26, 0x1000C8052888210);
      *(_QWORD *)(v1 + 464) = 0;
    }
    v27 = *(_QWORD *)(v1 + 472);
    if (v27)
    {
      MEMORY[0x1BCC95CC8](v27, 0x1000C8052888210);
      *(_QWORD *)(v1 + 472) = 0;
    }
    v28 = *(_QWORD *)(v1 + 480);
    if (v28)
    {
      MEMORY[0x1BCC95CC8](v28, 0x1000C8052888210);
      *(_QWORD *)(v1 + 480) = 0;
    }
    v29 = *(_QWORD *)(v1 + 488);
    if (v29)
    {
      MEMORY[0x1BCC95CC8](v29, 0x1000C8052888210);
      *(_QWORD *)(v1 + 488) = 0;
    }
    v30 = *(_QWORD *)(v1 + 248);
    if (v30)
      MEMORY[0x1BCC95CC8](v30, 0x1000C8052888210);
    v31 = *(_QWORD *)(v1 + 296);
    if (v31)
      MEMORY[0x1BCC95CC8](v31, 0x1000C8052888210);
    v32 = *(_QWORD *)(v1 + 304);
    if (v32)
      MEMORY[0x1BCC95CC8](v32, 0x1000C8052888210);
    v33 = *(_QWORD *)(v1 + 312);
    if (v33)
      MEMORY[0x1BCC95CC8](v33, 0x1000C8052888210);
    v34 = *(_QWORD *)(v1 + 320);
    if (v34)
      MEMORY[0x1BCC95CC8](v34, 0x1000C8052888210);
    v35 = *(_QWORD *)(v1 + 352);
    if (v35)
      MEMORY[0x1BCC95CC8](v35, 0x1000C8052888210);
    v36 = *(_QWORD *)(v1 + 328);
    if (v36)
      MEMORY[0x1BCC95CC8](v36, 0x1000C8052888210);
    v37 = *(_QWORD *)(v1 + 336);
    if (v37)
      MEMORY[0x1BCC95CC8](v37, 0x1000C8052888210);
    v38 = *(_QWORD *)(v1 + 344);
    if (v38)
      MEMORY[0x1BCC95CC8](v38, 0x1000C8052888210);
    v39 = *(_QWORD *)(v1 + 200);
    if (v39)
    {
      MEMORY[0x1BCC95CC8](v39, 0x1000C8052888210);
      v40 = *(_QWORD *)(v1 + 208);
      if (v40)
        MEMORY[0x1BCC95CC8](v40, 0x1000C8052888210);
    }
    v41 = *(_QWORD *)(v1 + 216);
    if (v41)
    {
      MEMORY[0x1BCC95CC8](v41, 0x1000C8052888210);
      v42 = *(_QWORD *)(v1 + 224);
      if (v42)
        MEMORY[0x1BCC95CC8](v42, 0x1000C8052888210);
    }
    v43 = *(_QWORD **)(v1 + 232);
    if (v43)
    {
      if (*v43)
      {
        MEMORY[0x1BCC95CC8](*v43, 0x1000C8052888210);
        v43 = *(_QWORD **)(v1 + 232);
      }
      if (!v43[1] || (MEMORY[0x1BCC95CC8](v43[1], 0x1000C8052888210), *(_QWORD *)(v1 + 232)))
        MEMORY[0x1BCC95CC8]();
      *(_QWORD *)(v1 + 232) = 0;
    }
    v44 = *(_QWORD **)(v1 + 96);
    if (v44)
    {
      if (*v44)
      {
        MEMORY[0x1BCC95CC8](*v44, 0x1000C8052888210);
        v44 = *(_QWORD **)(v1 + 96);
      }
      if (!v44[1] || (MEMORY[0x1BCC95CC8](v44[1], 0x1000C8052888210), *(_QWORD *)(v1 + 96)))
        MEMORY[0x1BCC95CC8]();
      *(_QWORD *)(v1 + 96) = 0;
    }
    v45 = *(_QWORD **)(v1 + 104);
    if (v45)
    {
      if (*v45)
      {
        MEMORY[0x1BCC95CC8](*v45, 0x1000C8052888210);
        v45 = *(_QWORD **)(v1 + 104);
      }
      if (!v45[1] || (MEMORY[0x1BCC95CC8](v45[1], 0x1000C8052888210), *(_QWORD *)(v1 + 104)))
        MEMORY[0x1BCC95CC8]();
      *(_QWORD *)(v1 + 104) = 0;
    }
    v46 = *(_QWORD **)(v1 + 112);
    if (v46)
    {
      if (*v46)
      {
        MEMORY[0x1BCC95CC8](*v46, 0x1000C8052888210);
        v46 = *(_QWORD **)(v1 + 112);
      }
      if (!v46[1] || (MEMORY[0x1BCC95CC8](v46[1], 0x1000C8052888210), *(_QWORD *)(v1 + 112)))
        MEMORY[0x1BCC95CC8]();
      *(_QWORD *)(v1 + 112) = 0;
    }
    v47 = *(_QWORD *)(v1 + 272);
    if (v47)
      MEMORY[0x1BCC95CC8](v47, 0x1000C8052888210);
    v48 = *(_QWORD **)(v1 + 840);
    if (v48)
    {
      if (*v48)
      {
        MEMORY[0x1BCC95CC8](*v48, 0x1000C8052888210);
        v48 = *(_QWORD **)(v1 + 840);
      }
      if (!v48[1] || (MEMORY[0x1BCC95CC8](v48[1], 0x1000C8052888210), *(_QWORD *)(v1 + 840)))
        MEMORY[0x1BCC95CC8]();
      *(_QWORD *)(v1 + 840) = 0;
    }
    if (*(_QWORD *)(v1 + 816))
    {
      v49 = 0;
      v50 = 1;
      do
      {
        v51 = v50;
        v52 = *(_QWORD *)(*(_QWORD *)(v1 + 816) + 8 * v49);
        if (v52)
          MEMORY[0x1BCC95CC8](v52, 0x1000C8052888210);
        v50 = 0;
        v49 = 1;
      }
      while ((v51 & 1) != 0);
      v53 = *(_QWORD *)(v1 + 816);
      if (v53)
        MEMORY[0x1BCC95CC8](v53, 0x80C80B8603338);
      *(_QWORD *)(v1 + 816) = 0;
    }
    if (*(_QWORD *)(v1 + 824))
    {
      v54 = 0;
      v55 = 1;
      do
      {
        v56 = v55;
        v57 = *(_QWORD *)(*(_QWORD *)(v1 + 824) + 8 * v54);
        if (v57)
          MEMORY[0x1BCC95CC8](v57, 0x1000C8052888210);
        v55 = 0;
        v54 = 1;
      }
      while ((v56 & 1) != 0);
      v58 = *(_QWORD *)(v1 + 824);
      if (v58)
        MEMORY[0x1BCC95CC8](v58, 0x80C80B8603338);
      *(_QWORD *)(v1 + 824) = 0;
    }
    this = *(_QWORD *)(v1 + 832);
    if (this)
    {
      if (*(_QWORD *)this)
      {
        MEMORY[0x1BCC95CC8](*(_QWORD *)this, 0x1000C8052888210);
        this = *(_QWORD *)(v1 + 832);
      }
      if (!*(_QWORD *)(this + 8)
        || (MEMORY[0x1BCC95CC8](*(_QWORD *)(this + 8), 0x1000C8052888210), (this = *(_QWORD *)(v1 + 832)) != 0))
      {
        this = MEMORY[0x1BCC95CC8]();
      }
      *(_QWORD *)(v1 + 832) = 0;
    }
  }
  return this;
}

void Beamformer_BeamNF::CmhBEAM2NOpt::~CmhBEAM2NOpt(Beamformer_BeamNF::CmhBEAM2NOpt *this)
{
  uint64_t v2;

  Beamformer_BeamNF::CmhBEAM2NOpt::deallocate_memory((uint64_t)this);
  v2 = *((_QWORD *)this + 107);
  if (v2)
    MEMORY[0x1BCC95CC8](v2, 0x1000C804247E4FDLL);
  CmhMicCheck::deallocate_memory((uint64_t)this + 496);
}

uint64_t Beamformer_BeamNF::CmhBEAM2NOpt::initialize(Beamformer_BeamNF::CmhBEAM2NOpt *this, int a2, int a3, int a4, int a5, int a6)
{
  float v12;
  int v13;
  double v14;
  double v15;
  float v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  float v22;
  float v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  double v28;
  double v29;
  float v30;
  int v31;
  int v32;
  int v33;
  int v34;
  float v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  float *v40;
  float *v41;
  float v42;
  float v43;
  uint64_t v44;
  int **v45;
  uint64_t v46;
  int *v47;
  int *v48;
  _DWORD *v49;
  _DWORD *v50;
  uint64_t v51;
  int v52;
  int v53;
  void **v54;
  size_t v55;
  void **v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  uint64_t v62;
  float v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  float *v67;
  int v68;
  float *v69;
  int v70;
  _DWORD *v71;
  uint64_t v72;
  double v73;
  long double v74;
  int64_t v75;
  size_t v76;
  void *v77;
  uint64_t v78;
  size_t v79;
  char *v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  size_t v84;
  const std::nothrow_t *v85;
  void *v86;
  uint64_t v87;
  size_t v88;
  int v89;
  unsigned int v90;
  uint64_t v91;
  char v92;
  const std::nothrow_t *v93;
  char v94;
  char *v95;
  char *v96;
  int64_t v97;
  uint64_t v98;
  const std::nothrow_t *v99;
  uint64_t v100;
  size_t v101;
  char *v102;
  uint64_t v103;
  int v104;
  unsigned int v105;
  size_t v106;
  uint64_t v107;
  uint64_t v108;
  void *v109;
  uint64_t v110;
  uint64_t v111;
  void *v112;
  void *v113;
  int v114;
  int v115;
  int v116;
  size_t v117;
  size_t v118;
  void *v119;
  uint64_t v120;
  size_t v121;
  void *v122;
  int v123;
  size_t v124;
  void *v125;
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  uint64_t v131;
  size_t v132;
  void *v133;
  uint64_t v134;
  void *v135;
  void *v136;
  void *v137;
  void *v138;
  float v139;
  uint64_t v140;
  int v141;
  int32x2_t v142;
  signed int v143;
  int32x2_t v144;
  int32x2_t v145;
  float *v146;
  float32x2_t v147;
  uint64x2_t v148;
  int32x2_t v149;
  uint64_t v150;
  int32x2_t v151;
  int64x2_t v152;
  float *v153;
  float32x2_t v154;
  float32x2_t v155;
  int64x2_t v161;
  int32x2_t v162;
  float32x2_t v163;
  float *v164;
  uint64_t v165;
  float *v166;
  float *v167;
  uint64_t v168;
  double v169;
  float v170;
  uint64_t v171;
  float *v172;
  float *v173;
  double v174;
  float v175;
  int32x2_t v176;
  int v177;
  int v178;
  int v179;
  int v180;
  float32x2_t v181;
  int8x8_t v182;
  int8x16_t v183;
  int32x2_t v186;
  double v187;
  double v188;
  double v189;
  float v190;
  float v191;
  double v192;
  double v193;
  uint64_t v194;
  float v195;
  float v196;
  float v197;
  long double v198;
  uint64_t v199;
  float v200;
  char v201;
  int32x2_t v202;
  uint64_t v203;
  char v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  int v208;
  int v209;
  uint64_t v210;
  void *v212;
  void *v213;
  void *v214;
  void *v215;
  uint64_t v216;
  size_t v217;
  void *v218;
  size_t v219;
  void *v220;
  void *v221;
  void *v222;
  size_t v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  void *v232;
  const std::nothrow_t *v233;
  const std::nothrow_t *v234;
  uint64_t v235;
  char v236;
  char v237;
  void *v238;
  void *v239;
  void *v240;
  void *v241;
  void *v242;
  _QWORD *v243;
  _QWORD *v244;
  uint64_t v245;
  size_t v246;
  const std::nothrow_t *v247;
  void *v248;
  void *v249;
  void *v250;
  void *v251;
  uint64_t v252;
  char v253;
  const std::nothrow_t *v254;
  char v255;
  void *v256;
  void *v257;
  uint64_t v258;
  uint64_t __len;
  size_t v260;
  float v261;
  uint64_t v262;
  int32x2_t __szb;
  float __sz;
  size_t __sza;

  Beamformer_BeamNF::CmhBEAM2NOpt::deallocate_memory((uint64_t)this);
  *((_DWORD *)this + 4) = a3;
  *((_DWORD *)this + 5) = a4;
  *((_DWORD *)this + 12) = a5;
  v12 = (double)a5 * 0.001;
  *((float *)this + 13) = v12;
  *((_DWORD *)this + 2) = a6;
  *((_DWORD *)this + 3) = a2;
  if (a3 >= 0)
    v13 = a3;
  else
    v13 = a3 + 1;
  *((int32x2_t *)this + 3) = vadd_s32(vdup_n_s32(v13 >> 1), (int32x2_t)0x1FFFFFFFFLL);
  Beamformer_BeamNF::CmhBEAM2NOpt::deallocate_memory((uint64_t)this);
  if (*(_DWORD *)this)
  {
LABEL_5:
    CmhBEAM2NOpt::calc_cr_ci_vect(this, *((float **)this + 25), *((float **)this + 27));
    CmhBEAM2NOpt::calc_cr_ci_vect(this, *((float **)this + 26), *((float **)this + 28));
    *((_QWORD *)this + 7) = 0x40A0000041C00000;
    v14 = __exp10(1.2);
    v15 = __exp10(*((float *)this + 15) * 0.05);
    v16 = *((float *)this + 13);
    v18 = *((_DWORD *)this + 3);
    v17 = *((_DWORD *)this + 4);
    if (v17 >= 0)
      v19 = *((_DWORD *)this + 4);
    else
      v19 = v17 + 1;
    v20 = v19 >> 1;
    if (v17 >= -1)
    {
      v21 = 0;
      v22 = v16 * 6.28318531 * (double)v18 / (double)(343 * v17);
      v23 = v14;
      v24 = (uint64_t *)*((_QWORD *)this + 29);
      v25 = *v24;
      v26 = v24[1];
      while (1)
      {
        v27 = sinf(v22 * (float)(int)v21);
        v28 = (float)(v27 + v27);
        if (v28 > 0.032)
          break;
        v28 = 0.032;
        v29 = v23;
        if (v23 > 31.25)
          goto LABEL_14;
LABEL_15:
        v30 = v29;
        *(float *)(v25 + 4 * v21) = v30;
        *(float *)(v26 + 4 * v21++) = v30;
        if (v20 + 1 == v21)
        {
          v16 = *((float *)this + 13);
          goto LABEL_17;
        }
      }
      v29 = v23;
      if (1.0 / v28 >= v23)
        goto LABEL_15;
LABEL_14:
      v29 = 1.0 / v28;
      goto LABEL_15;
    }
LABEL_17:
    v31 = vcvtmd_s64_f64(343.0 / (float)(v16 + v16) * 0.9 / (float)((float)v18 / (float)v17));
    v32 = *((_DWORD *)this + 6);
    v33 = v31 & ~(v31 >> 31);
    v34 = v32 - 1;
    if (v32 > v33)
      v34 = v33;
    *((_DWORD *)this + 64) = v34;
    *((_DWORD *)this + 8) = 24000;
    if (v34 <= v20)
    {
      v35 = v15;
      v36 = (uint64_t *)*((_QWORD *)this + 29);
      v38 = *v36;
      v37 = v36[1];
      v39 = v20 - v34 + 1;
      v40 = (float *)(v37 + 4 * v34);
      v41 = (float *)(v38 + 4 * v34);
      do
      {
        v42 = *v41;
        if (*v41 >= v35)
          v42 = v15;
        *v41++ = v42;
        v43 = *v40;
        if (*v40 >= v35)
          v43 = v15;
        *v40++ = v43;
        --v39;
      }
      while (v39);
    }
    v44 = *((unsigned int *)this + 7);
    if ((int)v44 >= 1)
    {
      v45 = (int **)*((_QWORD *)this + 29);
      v46 = *((_QWORD *)this + 12);
      v47 = *v45;
      v48 = v45[1];
      v49 = *(_DWORD **)v46;
      v50 = *(_DWORD **)(v46 + 8);
      v51 = *((unsigned int *)this + 7);
      do
      {
        v52 = *v47++;
        *v49++ = v52;
        v53 = *v48++;
        *v50++ = v53;
        --v51;
      }
      while (v51);
      v54 = (void **)*((_QWORD *)this + 13);
      v55 = 4 * v44;
      memset_pattern16(*v54, &unk_1B6627B80, 4 * v44);
      memset_pattern16(v54[1], &unk_1B6627B80, v55);
      v56 = (void **)*((_QWORD *)this + 14);
      memset_pattern16(*v56, &unk_1B6627B80, v55);
      memset_pattern16(v56[1], &unk_1B6627B80, v55);
    }
    if (*((int *)this + 2) <= 0)
    {
      v73 = (double)(v18 / *((_DWORD *)this + 5));
    }
    else
    {
      v57 = 0;
      v58 = *((_QWORD *)this + 55);
      do
      {
        *(_QWORD *)(v58 + 136 * v57 + 64) = 0x3F0000003F000000;
        v59 = *((_DWORD *)this + 4);
        if (v59 >= 0)
          v60 = *((_DWORD *)this + 4);
        else
          v60 = v59 + 1;
        v61 = v60 >> 1;
        if (v59 < 2)
        {
          v71 = *(_DWORD **)(v58 + 136 * v57 + 48);
        }
        else
        {
          v62 = 0;
          v63 = 32767.0 / (double)v59 * 0.0000305175781;
          v64 = *(_QWORD *)(v58 + 136 * v57 + 16);
          do
            *(float *)(v64 + 4 * v62++) = v63;
          while (v61 != (_DWORD)v62);
          v65 = 0;
          v66 = *(_QWORD *)(v58 + 136 * v57 + 24);
          do
            *(float *)(v66 + 4 * v65++) = v63;
          while (v61 != (_DWORD)v65);
          v67 = *(float **)(v58 + 136 * v57 + 32);
          v68 = v61;
          do
          {
            *v67++ = v63;
            --v68;
          }
          while (v68);
          v69 = *(float **)(v58 + 136 * v57 + 40);
          v70 = v61;
          do
          {
            *v69++ = v63;
            --v70;
          }
          while (v70);
          v71 = *(_DWORD **)(v58 + 136 * v57 + 48);
          memset_pattern16(v71, &unk_1B66A2BC0, 4 * (v61 - 1) + 4);
        }
        *v71 = 0;
        bzero(*(void **)(v58 + 136 * v57 + 56), 4 * v61);
        v58 = *((_QWORD *)this + 55);
        v72 = v58 + 136 * v57;
        *(_DWORD *)(v72 + 76) = 1048600;
        *(_OWORD *)(v72 + 80) = xmmword_1B66A11F0;
        *(_DWORD *)(v72 + 96) = 1065353216;
        v73 = (double)(*((_DWORD *)this + 3) / *((_DWORD *)this + 5));
        v74 = exp(-1.0 / (v73 * 0.3));
        *(float *)&v74 = v74;
        *(int32x2_t *)(v72 + 100) = vdup_lane_s32(*(int32x2_t *)&v74, 0);
        ++v57;
      }
      while (v57 < *((int *)this + 2));
    }
    v139 = exp(-1.0 / (v73 * 0.123745791));
    *((float *)this + 16) = v139;
    CmhBEAM2NOpt::calc_wng_beta_bound((void **)this, *((float *)this + 70));
    v140 = *((unsigned int *)this + 6);
    *((_DWORD *)this + 93) = v140;
    *(_QWORD *)((char *)this + 364) = 0x3F0000003E800000;
    v141 = *((_DWORD *)this + 5);
    *(float *)v142.i32 = (float)*((int *)this + 4);
    v143 = *((_DWORD *)this + 3);
    *(float *)v144.i32 = (float)v143;
    v145 = vcvt_s32_f32(vdiv_f32(vmul_n_f32((float32x2_t)0x43FA000042FA0000, *(float *)v142.i32), (float32x2_t)vdup_lane_s32(v144, 0)));
    *((_QWORD *)this + 51) = 0x3980000000000000;
    *((int32x2_t *)this + 52) = v145;
    *((_DWORD *)this + 106) = vsub_s32(vdup_lane_s32(v145, 1), v145).u32[0] + 1;
    *(float32x2_t *)((char *)this + 428) = vcvt_f32_f64(vdivq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66A2930, (float)v141), (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)v143), 0)));
    if ((int)v140 >= 1)
    {
      __szb = v142;
      memset_pattern16(*((void **)this + 40), &unk_1B6627B80, 4 * v140);
      *(float *)v144.i32 = (float)v143;
      v142 = __szb;
    }
    v146 = (float *)*((unsigned int *)this + 7);
    if ((int)v146 >= 1)
    {
      v147 = (float32x2_t)vdup_lane_s32(v142, 0);
      v148 = (uint64x2_t)vdupq_n_s64((unint64_t)v146 - 1);
      v149 = vdup_n_s32(v143);
      v150 = ((unint64_t)v146 + 1) & 0x1FFFFFFFELL;
      v151 = (int32x2_t)0x100000000;
      v152 = (int64x2_t)xmmword_1B6626830;
      v153 = (float *)(*((_QWORD *)this + 43) + 4);
      v154 = (float32x2_t)vdup_n_s32(0xBA15CBEC);
      v155 = (float32x2_t)vdup_n_s32(0x3F524925u);
      __asm { FMOV            V7.2S, #0.75 }
      v161 = vdupq_n_s64(2uLL);
      do
      {
        v162 = vmovn_s64((int64x2_t)vcgeq_u64(v148, (uint64x2_t)v152));
        v163 = vminnm_f32(vmla_f32(v155, v154, vdiv_f32(vcvt_f32_s32(vmul_s32(v149, v151)), v147)), _D7);
        if ((v162.i8[0] & 1) != 0)
          *(v153 - 1) = fmaxf(v163.f32[0], 0.25);
        if ((v162.i8[4] & 1) != 0)
          *v153 = fmaxf(v163.f32[1], 0.25);
        v152 = vaddq_s64(v152, v161);
        v151 = vadd_s32(v151, (int32x2_t)0x200000002);
        v153 += 2;
        v150 -= 2;
      }
      while (v150);
    }
    CmhBEAM2NOpt::interpolateFrequencyVector((uint64_t)&model_env_tc_vector_attack_sec, (float *)0x41, *((_QWORD *)this + 42), 125.0, v146, *(float *)v144.i32 / *(float *)v142.i32);
    v164 = (float *)*((unsigned int *)this + 7);
    v165 = *((_QWORD *)this + 42);
    if ((int)v164 >= 1)
    {
      v166 = (float *)*((_QWORD *)this + 41);
      v167 = (float *)*((_QWORD *)this + 42);
      v168 = *((unsigned int *)this + 7);
      do
      {
        v169 = 0.0;
        if (*v167 > 0.0)
          v169 = exp(-1.0 / (*v167 * (double)(*((_DWORD *)this + 3) / *((_DWORD *)this + 5))));
        v170 = v169;
        *v166 = v170;
        v166 += 2;
        ++v167;
        --v168;
      }
      while (v168);
    }
    CmhBEAM2NOpt::interpolateFrequencyVector((uint64_t)&model_env_tc_vector_decay_sec, (float *)0x41, v165, 125.0, v164, (float)*((int *)this + 3) / (float)*((int *)this + 4));
    v171 = *((unsigned int *)this + 7);
    if ((int)v171 >= 1)
    {
      v172 = (float *)*((_QWORD *)this + 42);
      v173 = (float *)(*((_QWORD *)this + 41) + 4);
      do
      {
        v174 = 0.0;
        if (*v172 > 0.0)
          v174 = exp(-1.0 / (*v172 * (double)(*((_DWORD *)this + 3) / *((_DWORD *)this + 5))));
        v175 = v174;
        *v173 = v175;
        v173 += 2;
        ++v172;
        --v171;
      }
      while (v171);
    }
    CmhBEAM2NOpt::loadRVSSSuppressionLimits(this);
    v177 = *((_DWORD *)this + 3);
    v178 = *((_DWORD *)this + 4);
    if (v177 >= 0)
      v179 = *((_DWORD *)this + 3);
    else
      v179 = v177 + 1;
    *((float *)this + 35) = (float)(v179 >> 1);
    *((float *)this + 96) = (float)*((int *)this + 7);
    *(float *)v176.i32 = (float)v177;
    v180 = *((_DWORD *)this + 5);
    __sz = (float)v177;
    v181 = vmul_n_f32(vdiv_f32((float32x2_t)0x437A000043BB8000, (float32x2_t)vdup_lane_s32(v176, 0)), (float)v178);
    v261 = (float)v178;
    v182 = vmvn_s8((int8x8_t)vcgez_f32(v181));
    v183.i64[0] = v182.i32[0];
    v183.i64[1] = v182.i32[1];
    __asm
    {
      FMOV            V2.2D, #0.5
      FMOV            V3.2D, #-0.5
    }
    v186 = vmovn_s64(vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8(v183, _Q3, _Q2), vcvtq_f64_f32(v181))));
    *((int32x2_t *)this + 108) = v186;
    *(float *)v182.i32 = (float)(1200.0 / (float)v177) * (float)v178;
    v187 = *(float *)v182.i32;
    if (*(float *)v182.i32 >= 0.0)
      v188 = 0.5;
    else
      v188 = -0.5;
    *((_DWORD *)this + 218) = (int)(v188 + v187) - v186.i32[1] + 1;
    *((_DWORD *)this + 219) = v178 / 2 - 1;
    v189 = (double)(v177 / v180);
    v190 = exp(-1.0 / (v189 * 0.123745791));
    *((float *)this + 220) = v190;
    v191 = (float)(200.0 / __sz) * v261;
    v192 = v191;
    if (v191 >= 0.0)
      v193 = 0.5;
    else
      v193 = -0.5;
    *((_DWORD *)this + 221) = (int)(v193 + v192);
    v194 = *((_QWORD *)this + 107);
    v195 = exp(-1.0 / (v189 * 0.01));
    v196 = exp(-1.0 / (v189 * 0.1));
    v197 = exp(-1.0 / (v189 * 0.03));
    v198 = exp(-1.0 / (v189 + v189));
    v199 = 0;
    v200 = v198;
    v201 = 1;
    v202 = vdup_n_s32(0x39400000u);
    do
    {
      v203 = v194 + 80 * v199;
      *(_DWORD *)v203 = 0;
      v204 = v201;
      *(float *)(v203 + 4) = v195;
      *(float *)(v203 + 8) = v196;
      *(_OWORD *)(v203 + 12) = xmmword_1B66A1200;
      *(_DWORD *)(v203 + 28) = 0;
      *(_DWORD *)(v203 + 32) = 0;
      *(float *)(v203 + 36) = v195;
      *(float *)(v203 + 40) = v197;
      *(int32x2_t *)(v203 + 48) = v202;
      *(float *)(v203 + 56) = v200;
      *(_DWORD *)(v203 + 76) = 0;
      *(_OWORD *)(v203 + 60) = xmmword_1B66A2940;
      v199 = 1;
      v201 = 0;
    }
    while ((v204 & 1) != 0);
    *(_DWORD *)(v194 + 44) = 0;
    *(_DWORD *)(v194 + 124) = 1;
    CmhBEAM2NOpt::interpolateFrequencyVector((uint64_t)&sns_gain_table, (float *)0x3F, *((_QWORD *)this + 31), 125.0, (float *)*((unsigned int *)this + 6), __sz / v261);
    v205 = *((unsigned int *)this + 2);
    v206 = *((_QWORD *)this + 55);
    if ((int)v205 >= 1)
    {
      v207 = 0;
      v208 = *((_DWORD *)this + 6);
      do
      {
        *(_QWORD *)(v206 + 136 * v207 + 108) = 0x3F00000000000000;
        if (v208 >= 1)
        {
          v209 = 0;
          v210 = *(_QWORD *)(v206 + 136 * v207 + 120);
          do
            *(_DWORD *)(v210 + 4 * (unsigned __int16)v209++) = 1065353216;
          while (v208 > (unsigned __int16)v209);
        }
        *(_QWORD *)(v206 + 136 * v207++ + 128) = 0x3F8000003DE38E39;
      }
      while (v207 != v205);
    }
    *((_DWORD *)this + 60) = 1;
    *(_QWORD *)((char *)this + 260) = 0;
    *((_DWORD *)this + 94) = 0;
    *(_QWORD *)((char *)this + 396) = 0;
    *((_DWORD *)this + 101) = *(_DWORD *)(v206 + 108);
    return CmhMicCheck::initialize((Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496), *((_DWORD *)this + 3), *((_DWORD *)this + 5), *((_DWORD *)this + 4) / 2 + 1, (float **)this + 25, (float **)this + 27);
  }
  else
  {
    *(_DWORD *)this = 1;
    v75 = *((int *)this + 2);
    if (is_mul_ok(v75, 0x88uLL))
      v76 = 136 * v75;
    else
      v76 = -1;
    v77 = operator new[](v76, MEMORY[0x1E0DE4E10]);
    *((_QWORD *)this + 55) = v77;
    if (v77)
    {
      v78 = *((int *)this + 11);
      v79 = (int)v78 < 0 ? -1 : 8 * v78;
      v80 = (char *)operator new[](v79, MEMORY[0x1E0DE4E10]);
      *((_QWORD *)this + 20) = v80;
      if (v80)
      {
        v81 = v80;
        bzero(v80, 8 * (int)v78);
        v82 = *((unsigned int *)this + 4);
        if ((int)v78 <= 0)
        {
LABEL_65:
          v87 = 0;
          if ((int)v82 < 0)
            v88 = -1;
          else
            v88 = 4 * (int)v82;
          if ((int)v82 >= 0)
            v89 = v82;
          else
            v89 = v82 + 1;
          v90 = v89 >> 1;
          v91 = (uint64_t)v89 >> 1;
          v92 = 1;
          v93 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
          while (1)
          {
            v94 = v92;
            v95 = (char *)operator new[](v88, v93);
            v96 = (char *)this + 16 * v87;
            *((_QWORD *)v96 + 21) = v95;
            if (!v95)
              break;
            *((_QWORD *)v96 + 22) = &v95[4 * v91];
            bzero(v95, 4 * (int)v82);
            v92 = 0;
            v87 = 1;
            if ((v94 & 1) == 0)
            {
              if ((int)v75 < 1)
              {
LABEL_113:
                if ((int)v82 < -1)
                  v124 = -1;
                else
                  v124 = 4 * v91;
                v125 = operator new[](v124, MEMORY[0x1E0DE4E10]);
                *((_QWORD *)this + 56) = v125;
                if (v125)
                {
                  v126 = operator new[](v124, MEMORY[0x1E0DE4E10]);
                  *((_QWORD *)this + 57) = v126;
                  if (v126)
                  {
                    v127 = operator new[](v124, MEMORY[0x1E0DE4E10]);
                    *((_QWORD *)this + 58) = v127;
                    if (v127)
                    {
                      v128 = operator new[](v124, MEMORY[0x1E0DE4E10]);
                      *((_QWORD *)this + 59) = v128;
                      if (v128)
                      {
                        v129 = operator new[](v124, MEMORY[0x1E0DE4E10]);
                        *((_QWORD *)this + 60) = v129;
                        if (v129)
                        {
                          v130 = operator new[](v124, MEMORY[0x1E0DE4E10]);
                          *((_QWORD *)this + 61) = v130;
                          if (v130)
                          {
                            v131 = *((int *)this + 6);
                            v132 = (int)v131 < 0 ? -1 : 4 * v131;
                            v133 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                            *((_QWORD *)this + 31) = v133;
                            if (v133)
                            {
                              v134 = v131;
                              if ((int)v131 < 1)
                              {
                                v212 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                                *((_QWORD *)this + 37) = v212;
                                if (!v212)
                                  return 4294967294;
                                v213 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                                *((_QWORD *)this + 38) = v213;
                                if (!v213)
                                  return 4294967294;
                                v214 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                                *((_QWORD *)this + 39) = v214;
                                if (!v214)
                                  return 4294967294;
                                v215 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                                *((_QWORD *)this + 40) = v215;
                                if (!v215)
                                  return 4294967294;
                              }
                              else
                              {
                                bzero(v133, 4 * v131);
                                v135 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                                *((_QWORD *)this + 37) = v135;
                                if (!v135)
                                  return 4294967294;
                                bzero(v135, 4 * v131);
                                v136 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                                *((_QWORD *)this + 38) = v136;
                                if (!v136)
                                  return 4294967294;
                                bzero(v136, 4 * v131);
                                v137 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                                *((_QWORD *)this + 39) = v137;
                                if (!v137)
                                  return 4294967294;
                                bzero(v137, 4 * v131);
                                v138 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                                *((_QWORD *)this + 40) = v138;
                                if (!v138)
                                  return 4294967294;
                                bzero(v138, 4 * v131);
                              }
                              v216 = *((int *)this + 7);
                              if ((int)v216 < 0)
                                v217 = -1;
                              else
                                v217 = 8 * v216;
                              v218 = operator new[](v217, MEMORY[0x1E0DE4E10]);
                              *((_QWORD *)this + 41) = v218;
                              if (v218)
                              {
                                v262 = v216;
                                if ((int)v216 >= 1)
                                  bzero(v218, 4 * (2 * v216));
                                v219 = (int)v216 < 0 ? -1 : 4 * v216;
                                __sza = v219;
                                v220 = operator new[](v219, MEMORY[0x1E0DE4E10]);
                                *((_QWORD *)this + 42) = v220;
                                if (v220)
                                {
                                  if ((int)v216 < 1)
                                  {
                                    v222 = operator new[](__sza, MEMORY[0x1E0DE4E10]);
                                    *((_QWORD *)this + 44) = v222;
                                    if (!v222)
                                      return 4294967294;
                                  }
                                  else
                                  {
                                    bzero(v220, 4 * v216);
                                    v221 = operator new[](__sza, MEMORY[0x1E0DE4E10]);
                                    *((_QWORD *)this + 44) = v221;
                                    if (!v221)
                                      return 4294967294;
                                    bzero(v221, 4 * v216);
                                  }
                                  if ((int)v82 < -3)
                                    v223 = -1;
                                  else
                                    v223 = 4 * (int)(v90 + 1);
                                  v260 = v223;
                                  v224 = operator new[](v223, MEMORY[0x1E0DE4E10]);
                                  *((_QWORD *)this + 43) = v224;
                                  if (v224)
                                  {
                                    if ((int)v82 >= -1)
                                      bzero(v224, 4 * (v90 + 1));
                                    v225 = operator new[](v260, MEMORY[0x1E0DE4E10]);
                                    *((_QWORD *)this + 25) = v225;
                                    if (v225)
                                    {
                                      v226 = v225;
                                      v227 = operator new[](v260, MEMORY[0x1E0DE4E10]);
                                      *((_QWORD *)this + 26) = v227;
                                      if (v227)
                                      {
                                        if ((int)v82 >= -1)
                                        {
                                          v228 = v227;
                                          bzero(v226, 4 * (v90 + 1));
                                          bzero(v228, 4 * (v90 + 1));
                                        }
                                        v229 = operator new[](v260, MEMORY[0x1E0DE4E10]);
                                        *((_QWORD *)this + 27) = v229;
                                        if (v229)
                                        {
                                          v230 = v229;
                                          v231 = operator new[](v260, MEMORY[0x1E0DE4E10]);
                                          *((_QWORD *)this + 28) = v231;
                                          if (v231)
                                          {
                                            v258 = 4 * (v90 + 1);
                                            if ((int)v82 >= -1)
                                            {
                                              v232 = v231;
                                              bzero(v230, v258);
                                              bzero(v232, v258);
                                            }
                                            v233 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
                                            *((_QWORD *)this + 29) = operator new[](0x10uLL, MEMORY[0x1E0DE4E10]);
                                            *((_QWORD *)this + 12) = operator new[](0x10uLL, v233);
                                            *((_QWORD *)this + 13) = operator new[](0x10uLL, v233);
                                            v234 = v233;
                                            v235 = 0;
                                            *((_QWORD *)this + 14) = operator new[](0x10uLL, v233);
                                            __len = 4 * v262;
                                            v236 = 1;
                                            while (1)
                                            {
                                              v237 = v236;
                                              *(_QWORD *)(*((_QWORD *)this + 29) + 8 * v235) = operator new[](v260, v234);
                                              v238 = *(void **)(*((_QWORD *)this + 29) + 8 * v235);
                                              if (!v238)
                                                break;
                                              if ((int)v82 >= -1)
                                                bzero(v238, v258);
                                              *(_QWORD *)(*((_QWORD *)this + 12) + 8 * v235) = operator new[](__sza, v234);
                                              v239 = *(void **)(*((_QWORD *)this + 12) + 8 * v235);
                                              if (!v239)
                                                break;
                                              if ((int)v262 >= 1)
                                                bzero(v239, __len);
                                              *(_QWORD *)(*((_QWORD *)this + 13) + 8 * v235) = operator new[](__sza, v234);
                                              v240 = *(void **)(*((_QWORD *)this + 13) + 8 * v235);
                                              if (!v240)
                                                break;
                                              if ((int)v262 >= 1)
                                                bzero(v240, __len);
                                              *(_QWORD *)(*((_QWORD *)this + 14) + 8 * v235) = operator new[](__sza, v234);
                                              v241 = *(void **)(*((_QWORD *)this + 14) + 8 * v235);
                                              if (!v241)
                                                break;
                                              if ((int)v262 >= 1)
                                                bzero(v241, __len);
                                              v236 = 0;
                                              v235 = 1;
                                              if ((v237 & 1) == 0)
                                              {
                                                v242 = operator new[](v132, MEMORY[0x1E0DE4E10]);
                                                *((_QWORD *)this + 34) = v242;
                                                if (v242)
                                                {
                                                  if ((int)v134 >= 1)
                                                    bzero(v242, 4 * v134);
                                                  v243 = operator new[](0x10uLL, MEMORY[0x1E0DE4E10]);
                                                  *((_QWORD *)this + 102) = v243;
                                                  if (v243)
                                                  {
                                                    *v243 = 0;
                                                    v243[1] = 0;
                                                    v244 = operator new[](0x10uLL, MEMORY[0x1E0DE4E10]);
                                                    *((_QWORD *)this + 103) = v244;
                                                    if (v244)
                                                    {
                                                      *v244 = 0;
                                                      v244[1] = 0;
                                                      if ((int)v75 < 1)
                                                      {
LABEL_233:
                                                        v250 = operator new[](0x10uLL, MEMORY[0x1E0DE4E10]);
                                                        *((_QWORD *)this + 105) = v250;
                                                        if (v250)
                                                        {
                                                          v251 = operator new[](0x10uLL, MEMORY[0x1E0DE4E10]);
                                                          *((_QWORD *)this + 104) = v251;
                                                          if (v251)
                                                          {
                                                            v252 = 0;
                                                            v253 = 1;
                                                            v254 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
                                                            while (1)
                                                            {
                                                              v255 = v253;
                                                              *(_QWORD *)(*((_QWORD *)this + 105) + 8 * v252) = operator new[](__sza, v254);
                                                              v256 = *(void **)(*((_QWORD *)this + 105) + 8 * v252);
                                                              if (!v256)
                                                                break;
                                                              if ((int)v262 >= 1)
                                                                memset_pattern16(v256, &unk_1B6627B80, __len);
                                                              *(_QWORD *)(*((_QWORD *)this + 104) + 8 * v252) = operator new[](v124, v254);
                                                              v257 = *(void **)(*((_QWORD *)this + 104) + 8 * v252);
                                                              if (!v257)
                                                                break;
                                                              if ((int)v82 >= 2)
                                                                bzero(v257, 4 * v90);
                                                              v253 = 0;
                                                              v252 = 1;
                                                              if ((v255 & 1) == 0)
                                                                goto LABEL_5;
                                                            }
                                                          }
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v245 = 0;
                                                        if ((int)v82 < 0)
                                                          v246 = -1;
                                                        else
                                                          v246 = 4 * (int)v82;
                                                        v247 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
                                                        while (1)
                                                        {
                                                          *(_QWORD *)(*((_QWORD *)this + 102) + v245) = operator new[](v246, v247);
                                                          v248 = *(void **)(*((_QWORD *)this + 102) + v245);
                                                          if (!v248)
                                                            break;
                                                          if ((int)v82 >= 1)
                                                            bzero(v248, 4 * v82);
                                                          *(_QWORD *)(*((_QWORD *)this + 103) + v245) = operator new[](v246, v247);
                                                          v249 = *(void **)(*((_QWORD *)this + 103) + v245);
                                                          if (!v249)
                                                            break;
                                                          if ((int)v82 >= 1)
                                                            bzero(v249, 4 * v82);
                                                          v245 += 8;
                                                          if (8 * v75 == v245)
                                                            goto LABEL_233;
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                                return 4294967294;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              else
              {
                v97 = 0;
                v98 = 120;
                v99 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
                while (1)
                {
                  v100 = *((int *)this + 4);
                  v101 = (int)v100 < 0 ? -1 : 4 * v100;
                  v102 = (char *)operator new[](v101, v99);
                  v103 = *((_QWORD *)this + 55) + v98;
                  *(_QWORD *)(v103 - 120) = v102;
                  if (!v102)
                    break;
                  v104 = (int)v100 >= 0 ? v100 : (int)v100 + 1;
                  v105 = v104 >> 1;
                  *(_QWORD *)(v103 - 112) = &v102[4 * (v104 >> 1)];
                  bzero(v102, 4 * v100);
                  v106 = (int)v100 < -1 ? -1 : 4 * (int)v105;
                  *(_QWORD *)(v103 - 104) = operator new[](v106, v99);
                  v107 = *((_QWORD *)this + 55) + v98;
                  if (!*(_QWORD *)(v107 - 104))
                    break;
                  *(_QWORD *)(v107 - 96) = operator new[](v106, v99);
                  v108 = *((_QWORD *)this + 55);
                  v109 = *(void **)(v108 + v98 - 96);
                  if (!v109)
                    break;
                  if ((int)v100 >= 2)
                  {
                    bzero(*(void **)(v108 + v98 - 104), 4 * v105);
                    v99 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
                    bzero(v109, 4 * v105);
                  }
                  *(_QWORD *)(v108 + v98 - 88) = operator new[](v106, v99);
                  v110 = *((_QWORD *)this + 55) + v98;
                  if (!*(_QWORD *)(v110 - 88))
                    break;
                  *(_QWORD *)(v110 - 80) = operator new[](v106, v99);
                  v111 = *((_QWORD *)this + 55);
                  v112 = *(void **)(v111 + v98 - 80);
                  if (!v112)
                    break;
                  if ((int)v100 >= 2)
                  {
                    bzero(*(void **)(v111 + v98 - 88), 4 * v105);
                    v99 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
                    bzero(v112, 4 * v105);
                  }
                  *(_QWORD *)(v111 + v98 - 72) = operator new[](v106, v99);
                  v113 = *(void **)(*((_QWORD *)this + 55) + v98 - 72);
                  if (!v113)
                    break;
                  bzero(v113, 4 * (int)v105);
                  v114 = *((_DWORD *)this + 4);
                  v115 = v114 >= 0 ? *((_DWORD *)this + 4) : v114 + 1;
                  v116 = v115 >> 1;
                  v117 = 4 * v116;
                  v118 = v114 < -1 ? -1 : 4 * v116;
                  *(_QWORD *)(*((_QWORD *)this + 55) + v98 - 64) = operator new[](v118, v99);
                  v119 = *(void **)(*((_QWORD *)this + 55) + v98 - 64);
                  if (!v119)
                    break;
                  bzero(v119, v117);
                  v120 = *((int *)this + 6);
                  v121 = (int)v120 < 0 ? -1 : 4 * v120;
                  v122 = operator new[](v121, v99);
                  *(_QWORD *)(*((_QWORD *)this + 55) + v98) = v122;
                  if (!v122)
                    break;
                  if ((int)v120 >= 1)
                    bzero(v122, 4 * v120);
                  ++v97;
                  v75 = *((int *)this + 2);
                  v98 += 136;
                  if (v97 >= v75)
                  {
                    LODWORD(v82) = *((_DWORD *)this + 4);
                    if ((int)v82 >= 0)
                      v123 = *((_DWORD *)this + 4);
                    else
                      v123 = v82 + 1;
                    v90 = v123 >> 1;
                    v91 = (uint64_t)v123 >> 1;
                    goto LABEL_113;
                  }
                }
              }
              return 4294967294;
            }
          }
        }
        else
        {
          v83 = 0;
          if ((int)v82 < 0)
            v84 = -1;
          else
            v84 = 4 * (int)v82;
          v85 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
          while (1)
          {
            *(_QWORD *)&v81[v83] = operator new[](v84, v85);
            v81 = (char *)*((_QWORD *)this + 20);
            v86 = *(void **)&v81[v83];
            if (!v86)
              break;
            if ((int)v82 >= 1)
              bzero(v86, 4 * v82);
            v83 += 8;
            if (8 * v78 == v83)
              goto LABEL_65;
          }
        }
      }
    }
    return 4294967294;
  }
}

void Beamformer_BeamNF::CmhBEAM2NOpt::process(Beamformer_BeamNF::CmhBEAM2NOpt *this, const DSPSplitComplex *__A, DSPSplitComplex *__C)
{
  const DSPSplitComplex *v3;
  const DSPSplitComplex *v4;
  DSPSplitComplex v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float *realp;
  float *imagp;
  float v14;
  float v15;
  int v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  float *v29;
  float **v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  float *v34;
  float v35;
  float v36;
  float v37;
  float v38;
  double v39;
  double v40;
  _BOOL4 v41;
  float *v42;
  float v43;
  uint64_t v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v64;
  float v65;
  float *v66;
  float *v67;
  int v68;
  float v69;
  int v70;
  int v71;
  float *v72;
  float *v73;
  float *v74;
  float *v75;
  float *v76;
  float *v77;
  uint64_t v78;
  float *v79;
  float *v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  int v90;
  float *v91;
  float *v92;
  float v93;
  float v94;
  float v95;
  int v96;
  float *v97;
  float *v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  uint64_t v105;
  float **v106;
  float *v107;
  float v108;
  uint64_t v109;
  int v110;
  float v111;
  float **v112;
  Beamformer_BeamNF::CmhBEAM2NOpt *v113;
  const float **v114;
  const float **v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  float **p_imagp;
  int v126;
  uint64_t v127;
  uint64_t v128;
  void *v129;
  float **v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  uint64_t v135;
  void *v136;
  _QWORD *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  DSPSplitComplex *p_Aa;
  uint64_t v143;
  int v144;
  BOOL v145;
  uint64_t v147;
  int v148;
  DSPSplitComplex *v149;
  int v150;
  uint64_t *v151;
  uint64_t v152;
  uint64_t v153;
  float v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  float v161;
  uint64_t v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float *v169;
  float *v170;
  uint64_t v171;
  float *v172;
  float *v173;
  float *v174;
  float *v175;
  float v176;
  float v177;
  float v178;
  float v179;
  uint64_t v180;
  uint64_t v181;
  const float *v182;
  float *v183;
  float *v184;
  uint64_t v185;
  uint64_t v186;
  const float *v187;
  float *v188;
  float *v189;
  const float *v190;
  float *v191;
  _DWORD **v192;
  uint64_t v193;
  uint64_t v194;
  int v195;
  DSPSplitComplex v196;
  DSPSplitComplex __Aa;
  DSPSplitComplex v198;
  uint64_t v199;

  v199 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)this)
    return;
  v3 = __C;
  v4 = __A;
  if (*((_DWORD *)this + 38) == 1 || !*((_DWORD *)this + 60))
  {
    if (*((_DWORD *)this + 2) == 2)
    {
      v28 = 0;
      do
      {
        vDSP_zvmov(v4, 1, v3, 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
        ++v28;
        ++v3;
        ++v4;
      }
      while (v28 < *((int *)this + 2));
      if (!*((_DWORD *)this + 202))
        return;
      LODWORD(__Aa.realp) = 1065353216;
      vDSP_vfill((const float *)&__Aa, **((float ***)this + 102), 1, *((int *)this + 4));
      vDSP_vclr(**((float ***)this + 103), 1, *((int *)this + 4));
      vDSP_vclr(*(float **)(*((_QWORD *)this + 102) + 8), 1, *((int *)this + 4));
      v29 = *(float **)(*((_QWORD *)this + 103) + 8);
    }
    else
    {
      vDSP_zvmov(&__A[*((int *)this + 1)], 1, __C, 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
      if (!*((_DWORD *)this + 202))
        return;
      LODWORD(__Aa.realp) = 1065353216;
      v30 = (float **)*((_QWORD *)this + 102);
      if (!*((_DWORD *)this + 1))
      {
        vDSP_vfill((const float *)&__Aa, *v30, 1, *((int *)this + 4));
        vDSP_vclr(**((float ***)this + 103), 1, *((int *)this + 4));
        return;
      }
      vDSP_vclr(*v30, 1, *((int *)this + 4));
      v29 = (float *)**((_QWORD **)this + 103);
    }
    vDSP_vfill((const float *)&__Aa, v29, 1, *((int *)this + 4));
    return;
  }
  v6 = __A[1];
  __Aa = *__C;
  v198 = v6;
  vDSP_zvmov(__A, 1, __C, 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
  v7 = *((_QWORD *)this + 107);
  if (*(_DWORD *)(v7 + 44))
  {
    v8 = *((_QWORD *)this + 55);
    v9 = *(_QWORD *)(v8 + 24);
    v10 = *(_QWORD *)(v8 + 40);
    v11 = *((int *)this + 221);
    realp = __Aa.realp;
    imagp = __Aa.imagp;
    v14 = __Aa.realp[v11];
    v15 = v198.realp[v11];
    v16 = *((_DWORD *)this + 30);
    v17 = __Aa.imagp[v11];
    v18 = v198.imagp[v11];
    v19 = (float)(fabsf((float)(v14 + v15) * 0.5) + fabsf((float)(v17 + v18) * 0.5)) * 0.5;
    v20 = (float)(fabsf((float)(v14 - v15) * 0.5) + fabsf((float)(v17 - v18) * 0.5)) * 0.5;
    if (v19 >= 0.399987793)
      v21 = 0.39999;
    else
      v21 = v19;
    v22 = fmaxf(v21 + (float)(*(float *)(v7 + 36 + 4 * (*(float *)(v7 + 32) > v21)) * (float)(*(float *)(v7 + 32) - v21)), 0.00000030518);
    if (v20 >= 0.399987793)
      v20 = 0.39999;
    v23 = fmaxf(v20 + (float)(*(float *)(v7 + 36 + 4 * (*(float *)(v7 + 28) > v20)) * (float)(*(float *)(v7 + 28) - v20)), 0.00000030518);
    *(float *)(v7 + 28) = v23;
    *(float *)(v7 + 32) = v22;
    v24 = v22 - v23;
    if ((float)(v22 - v23) < 0.0)
      v24 = -(float)(v22 - v23);
    if (v22 > v23)
      v23 = v22;
    v25 = fminf(v24 / v23, 1.0);
    v26 = v25 * v25;
    v27 = 0.0;
    if (v26 > 0.25)
      v27 = v26 * *(float *)(v7 + 24);
    *(float *)(v7 + 20) = v27;
    if (v16)
    {
      *((_DWORD *)this + 222) = 0;
    }
    else
    {
      v31 = *((unsigned int *)this + 218);
      if ((int)v31 < 1)
      {
        v39 = 0.0;
        v40 = 0.0;
      }
      else
      {
        v32 = *((int *)this + 217);
        v33 = (float *)(v9 + 4 * v32 + 4);
        v34 = (float *)(v10 + 4 * v32 + 4);
        v35 = 0.0;
        v36 = 0.0;
        do
        {
          v37 = *v33++;
          v36 = v36 + v37;
          v38 = *v34++;
          v35 = v35 + v38;
          --v31;
        }
        while (v31);
        v39 = v36;
        v40 = v35;
      }
      v41 = v39 * 0.9 < v40;
      if (v40 * 0.9 >= v39)
        v41 = 0;
      *((_DWORD *)this + 222) = v41;
      if (v41)
      {
        v42 = (float *)*((_QWORD *)this + 107);
        v43 = v42[5];
LABEL_38:
        v44 = *((int *)this + 216);
        v45 = (float)(fabsf(v198.realp[v44]) + fabsf(v198.imagp[v44])) * 0.5;
        v46 = fmaxf(v45 + (float)(v42[(v42[20] > v45) + 21] * (float)(v42[20] - v45)), 0.00000030518);
        v42[20] = v46;
        v47 = *((float *)this + 220);
        v48 = (float)(fabsf(realp[v44]) + fabsf(imagp[v44])) * 0.5;
        v49 = fmaxf(v48 + (float)(v42[(*v42 > v48) + 1] * (float)(*v42 - v48)), 0.00000030518);
        *v42 = v49;
        v51 = v42[3];
        v50 = v42[4];
        v52 = v51 * v47;
        if (v49 > v51)
          v52 = v49;
        v53 = 0.00048828;
        if (v52 >= 0.00048828)
          v53 = v52;
        v42[3] = v53;
        v54 = v46 + (float)((float)(v50 * -4.0) * v49);
        v55 = v42[12];
        if (v43 <= 0.0075)
        {
          v58 = v42[13];
        }
        else
        {
          v56 = v42[14];
          v55 = v46 + (float)(v56 * (float)(v55 - v46));
          v57 = fabsf(v54);
          v58 = v57 + (float)(v56 * (float)(v42[13] - v57));
          v42[12] = v55;
          v42[13] = v58;
        }
        v59 = fmin(fmax(v58, 0.00000000305175781) / fmaxf(v55, 0.000015259), 1.0);
        v60 = v42[15];
        v61 = v60 * v46;
        v62 = v49 * v60;
        if (v49 > v61 || v62 < v46)
          v59 = v42[16] * v59;
        v64 = v50 + (float)((float)(v49 * (float)(v54 * (float)((float)(v43 / (float)(v53 * v53)) * v59))) * 0.25);
        v42[4] = v64;
        v42[19] = v59;
        v65 = v64 * 4.0;
        if (v65 <= v42[18])
          v65 = v42[18];
        if (v65 >= v42[17])
          v65 = v42[17];
        *(float *)&v196.realp = v65;
        vDSP_vsmul(realp, 1, (const float *)&v196, realp, 1, *((int *)this + 219) + 1);
        vDSP_vsmul(__Aa.imagp, 1, (const float *)&v196, __Aa.imagp, 1, *((int *)this + 219) + 1);
        goto LABEL_56;
      }
    }
    v42 = (float *)*((_QWORD *)this + 107);
    v42[5] = 0.0;
    v43 = 0.0;
    goto LABEL_38;
  }
LABEL_56:
  v66 = (float *)*((_QWORD *)this + 27);
  v196.realp = (float *)*((_QWORD *)this + 25);
  v196.imagp = v66;
  vDSP_zvmul(&v196, 1, &v198, 1, (const DSPSplitComplex *)((char *)this + 168), 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1, 1);
  vDSP_zvsub(&__Aa, 1, (const DSPSplitComplex *)((char *)this + 168), 1, (const DSPSplitComplex *)((char *)this + 168), 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
  v67 = (float *)*((_QWORD *)this + 28);
  v196.realp = (float *)*((_QWORD *)this + 26);
  v196.imagp = v67;
  vDSP_zvmul(&v196, 1, &__Aa, 1, (const DSPSplitComplex *)((char *)this + 184), 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1, 1);
  vDSP_zvsub(&v198, 1, (const DSPSplitComplex *)((char *)this + 184), 1, (const DSPSplitComplex *)((char *)this + 184), 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
  if (*((_DWORD *)this + 224))
  {
    v68 = 5;
  }
  else
  {
    v69 = *(float *)(*((_QWORD *)this + 39) + 4 * *((int *)this + 185)) * 32767.0;
    if (v69 > 32767.0)
      v69 = 32767.0;
    *((float *)this + 163) = v69;
    CmhMicCheck::process((Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496), (const DSPSplitComplex *)__Aa.realp, (const DSPSplitComplex *)__Aa.imagp, (const DSPSplitComplex *)v198.realp, (const DSPSplitComplex *)v198.imagp, (const float **)this + 21, (const float **)this + 23);
    v68 = *((_DWORD *)this + 172);
  }
  *((_DWORD *)this + 33) = v68;
  **((_DWORD **)this + 22) = 0;
  **((_DWORD **)this + 21) = 0;
  **((_DWORD **)this + 24) = 0;
  **((_DWORD **)this + 23) = 0;
  if (*((_DWORD *)this + 94))
  {
    v70 = *((_DWORD *)this + 6);
    if (v70 >= 1)
    {
      v71 = 0;
      v72 = (float *)*((_QWORD *)this + 37);
      v73 = (float *)*((_QWORD *)this + 38);
      v74 = v198.imagp + 1;
      v75 = __Aa.imagp + 1;
      v76 = v198.realp + 1;
      v77 = __Aa.realp + 1;
      v78 = *((_QWORD *)this + 41) + 8;
      v79 = v73;
      v80 = v72;
      do
      {
        v81 = fabsf(*v77 + *v76) + fabsf(*v75 + *v74);
        *v80 = fmaxf(v81 + (float)(*(float *)(v78 + 4 * (*v80 > v81)) * (float)(*v80 - v81)), 0.000091553);
        ++v80;
        v82 = *v76++;
        v83 = v82;
        v84 = *v77++;
        v85 = v84;
        v86 = *v74++;
        v87 = v86;
        v88 = *v75++;
        v89 = vabds_f32(v83, v85) + vabds_f32(v87, v88);
        *v79 = fmaxf(v89 + (float)(*(float *)(v78 + 4 * (*v79 > v89)) * (float)(*v79 - v89)), 0.000030518);
        ++v79;
        ++v71;
        v78 += 8;
      }
      while (v70 > (unsigned __int16)v71);
      v90 = 0;
      v91 = (float *)*((_QWORD *)this + 39);
      v92 = v91;
      do
      {
        v93 = *v72++;
        v94 = v93;
        v95 = *v73++;
        *v92++ = (float)(*((float *)this + 91) * v94) / v95;
        ++v90;
      }
      while (v70 > (unsigned __int16)v90);
      v96 = 0;
      v97 = (float *)*((_QWORD *)this + 40);
      v98 = (float *)(*((_QWORD *)this + 44) + 4);
      do
      {
        v99 = *v91++;
        v100 = v99;
        if (v99 > 0.708)
          v100 = *(float *)"}?5?";
        if (v100 < 0.125)
          v100 = 0.125;
        v101 = v100 * 108.2375 + -13.6263;
        if (v101 < 0.0)
          v101 = 0.0;
        if (v101 > 63.0)
          v101 = 63.0;
        v102 = rvss_table[v101];
        *v97 = v102;
        v103 = *v98++;
        v104 = v103;
        if (v103 > v102)
          v102 = v104;
        *v97++ = v102;
        ++v96;
      }
      while (v70 > (unsigned __int16)v96);
    }
  }
  if (*((int *)this + 11) >= 1)
  {
    v105 = 0;
    v106 = (float **)((char *)this + 176);
    do
    {
      vDSP_vmul(*(const float **)(*((_QWORD *)this + 29) + 8 * v105), 1, *(v106 - 1), 1, *(v106 - 1), 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
      v107 = *v106;
      v106 += 2;
      vDSP_vmul(*(const float **)(*((_QWORD *)this + 29) + 8 * v105++), 1, v107, 1, v107, 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
    }
    while (v105 < *((int *)this + 11));
  }
  memcpy(**((void ***)this + 104), *(const void **)(*((_QWORD *)this + 55) + 48), 4 * (*((int *)this + 4) >> 1));
  if (*((_DWORD *)this + 2) == 2)
  {
    memcpy(*(void **)(*((_QWORD *)this + 104) + 8), *(const void **)(*((_QWORD *)this + 55) + 184), 4 * (*((int *)this + 4) >> 1));
    if (*((_DWORD *)this + 2) == 2)
    {
      Beamformer_BeamNF::CmhBEAM2NOpt::abf((uint64_t)this, (const float **)this + 21, (const float **)this + 23, (float **)(*((_QWORD *)this + 55) + 136), *((_QWORD *)this + 55) + 136, 1);
      v109 = *((_QWORD *)this + 55);
      if (*((_DWORD *)this + 66))
        Beamformer_BeamNF::CmhBEAM2NOpt::abf((uint64_t)this, (const float **)this + 23, (const float **)this + 21, (float **)(v109 + 136), v109 + 136, 0);
      else
        CmhBEAM2NOpt::abf_output_only((uint64_t)this, *((_QWORD *)this + 23), *((_QWORD *)this + 24), *((_QWORD *)this + 21), *((_QWORD *)this + 22), (_QWORD *)(v109 + 136), v108);
      CmhBEAM2NOpt::sns((uint64_t)this, *((_QWORD *)this + 55) + 136);
      goto LABEL_92;
    }
  }
  v110 = *((_DWORD *)this + 1);
  if (!v110)
  {
LABEL_92:
    Beamformer_BeamNF::CmhBEAM2NOpt::abf((uint64_t)this, (const float **)this + 23, (const float **)this + 21, *((float ***)this + 55), *((_QWORD *)this + 55), 1);
    v112 = (float **)*((_QWORD *)this + 55);
    if (*((_DWORD *)this + 65))
    {
      v113 = this;
      v114 = (const float **)((char *)this + 168);
      v115 = (const float **)((char *)this + 184);
      goto LABEL_94;
    }
    v116 = *((_QWORD *)this + 21);
    v117 = *((_QWORD *)this + 22);
    v118 = *((_QWORD *)this + 23);
    v119 = *((_QWORD *)this + 24);
    goto LABEL_97;
  }
  if (v110 != 1)
  {
LABEL_102:
    vDSP_vmul(*(const float **)(*((_QWORD *)this + 13) + 8 * *((int *)this + 1)), 1, **((const float ***)this + 55), 1, **((float ***)this + 55), 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
    vDSP_vmul(*(const float **)(*((_QWORD *)this + 13) + 8 * *((int *)this + 1)), 1, *(const float **)(*((_QWORD *)this + 55) + 8), 1, *(float **)(*((_QWORD *)this + 55) + 8), 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
    LODWORD(v122) = *((_DWORD *)this + 2);
    goto LABEL_103;
  }
  Beamformer_BeamNF::CmhBEAM2NOpt::abf((uint64_t)this, (const float **)this + 21, (const float **)this + 23, *((float ***)this + 55), *((_QWORD *)this + 55), 1);
  v112 = (float **)*((_QWORD *)this + 55);
  if (*((_DWORD *)this + 65))
  {
    v113 = this;
    v114 = (const float **)((char *)this + 184);
    v115 = (const float **)((char *)this + 168);
LABEL_94:
    Beamformer_BeamNF::CmhBEAM2NOpt::abf((uint64_t)v113, v114, v115, v112, (uint64_t)v112, 0);
    goto LABEL_98;
  }
  v116 = *((_QWORD *)this + 23);
  v117 = *((_QWORD *)this + 24);
  v118 = *((_QWORD *)this + 21);
  v119 = *((_QWORD *)this + 22);
LABEL_97:
  CmhBEAM2NOpt::abf_output_only((uint64_t)this, v116, v117, v118, v119, v112, v111);
LABEL_98:
  CmhBEAM2NOpt::sns((uint64_t)this, *((_QWORD *)this + 55));
  if (*((_DWORD *)this + 2) != 2)
    goto LABEL_102;
  v120 = 0;
  v121 = 0;
  do
  {
    vDSP_vmul(*(const float **)(*((_QWORD *)this + 13) + 8 * v121), 1, *(const float **)(*((_QWORD *)this + 55) + v120), 1, *(float **)(*((_QWORD *)this + 55) + v120), 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
    vDSP_vmul(*(const float **)(*((_QWORD *)this + 13) + 8 * v121++), 1, *(const float **)(*((_QWORD *)this + 55) + v120 + 8), 1, *(float **)(*((_QWORD *)this + 55) + v120 + 8), 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
    v122 = *((int *)this + 2);
    v120 += 136;
  }
  while (v121 < v122);
LABEL_103:
  if ((_DWORD)v122 == 2)
  {
    v123 = 0;
    v124 = 0;
    p_imagp = &__Aa.imagp;
    while (1)
    {
      v126 = *((_DWORD *)this + 36);
      if (v126 == 1)
        break;
      if (v126)
      {
        memcpy((void *)(*(_QWORD *)(*((_QWORD *)this + 55) + v123) + 4 * (*((_DWORD *)this + 64) + 2)), &v198.realp[*((_DWORD *)this + 64) + 2], 4 * (*((_DWORD *)this + 6) + ~*((_DWORD *)this + 64)));
        v131 = *((int *)this + 64);
        v128 = v131 + 2;
        v129 = (void *)(*(_QWORD *)(*((_QWORD *)this + 55) + v123 + 8) + 4 * (v131 + 2));
        v130 = &v198.imagp;
        goto LABEL_110;
      }
      memcpy((void *)(*(_QWORD *)(*((_QWORD *)this + 55) + v123) + 4 * (*((_DWORD *)this + 64) + 2)), &(*(p_imagp - 1))[*((_DWORD *)this + 64) + 2], 4 * (*((_DWORD *)this + 6) + ~*((_DWORD *)this + 64)));
      v127 = *((int *)this + 64);
      v128 = v127 + 2;
      v129 = (void *)(*(_QWORD *)(*((_QWORD *)this + 55) + v123 + 8) + 4 * (v127 + 2));
      v130 = p_imagp;
LABEL_111:
      memcpy(v129, &(*v130)[v128], 4 * (*((_DWORD *)this + 6) + ~(_DWORD)v127));
      ++v124;
      v132 = *((int *)this + 2);
      v123 += 136;
      p_imagp += 2;
      if (v124 >= v132)
        goto LABEL_120;
    }
    memcpy((void *)(*(_QWORD *)(*((_QWORD *)this + 55) + v123) + 4 * (*((_DWORD *)this + 64) + 2)), &__Aa.realp[*((_DWORD *)this + 64) + 2], 4 * (*((_DWORD *)this + 6) + ~*((_DWORD *)this + 64)));
    v131 = *((int *)this + 64);
    v128 = v131 + 2;
    v129 = (void *)(*(_QWORD *)(*((_QWORD *)this + 55) + v123 + 8) + 4 * (v131 + 2));
    v130 = &__Aa.imagp;
LABEL_110:
    LODWORD(v127) = v131;
    goto LABEL_111;
  }
  v133 = *((_DWORD *)this + 36);
  if (v133 == 1)
  {
    memcpy((void *)(**((_QWORD **)this + 55) + 4 * (*((_DWORD *)this + 64) + 2)), &__Aa.realp[*((_DWORD *)this + 64) + 2], 4 * (*((_DWORD *)this + 6) + ~*((_DWORD *)this + 64)));
    v138 = *((int *)this + 64);
    v135 = v138 + 2;
    v136 = (void *)(*(_QWORD *)(*((_QWORD *)this + 55) + 8) + 4 * (v138 + 2));
    v137 = &__Aa.imagp;
  }
  else
  {
    if (!v133)
    {
      memcpy((void *)(**((_QWORD **)this + 55) + 4 * (*((_DWORD *)this + 64) + 2)), (const void *)(*((_QWORD *)&__Aa.realp + 2 * *((int *)this + 1)) + 4 * (*((_DWORD *)this + 64) + 2)), 4 * (*((_DWORD *)this + 6) + ~*((_DWORD *)this + 64)));
      v134 = *((int *)this + 64);
      v135 = v134 + 2;
      v136 = (void *)(*(_QWORD *)(*((_QWORD *)this + 55) + 8) + 4 * (v134 + 2));
      v137 = (_QWORD *)((unint64_t)(&__Aa + *((int *)this + 1)) | 8);
      goto LABEL_119;
    }
    memcpy((void *)(**((_QWORD **)this + 55) + 4 * (*((_DWORD *)this + 64) + 2)), &v198.realp[*((_DWORD *)this + 64) + 2], 4 * (*((_DWORD *)this + 6) + ~*((_DWORD *)this + 64)));
    v138 = *((int *)this + 64);
    v135 = v138 + 2;
    v136 = (void *)(*(_QWORD *)(*((_QWORD *)this + 55) + 8) + 4 * (v138 + 2));
    v137 = &v198.imagp;
  }
  LODWORD(v134) = v138;
LABEL_119:
  memcpy(v136, (const void *)(*v137 + 4 * v135), 4 * (*((_DWORD *)this + 6) + ~(_DWORD)v134));
  LODWORD(v132) = *((_DWORD *)this + 2);
LABEL_120:
  if (*((_DWORD *)this + 94) && (int)v132 >= 1)
  {
    v139 = 0;
    v140 = 0;
    do
    {
      v141 = *((_QWORD *)this + 55);
      *((_DWORD *)this + 31) = 1;
      if (*((_DWORD *)this + 32))
      {
        p_Aa = &v198;
        switch(*((_DWORD *)this + 33))
        {
          case 0:
          case 2:
            goto LABEL_126;
          case 1:
          case 3:
            goto LABEL_125;
          case 4:
            v144 = *((_DWORD *)this + 34);
            if (v144 == 1)
            {
LABEL_125:
              p_Aa = &__Aa;
            }
            else
            {
              p_Aa = &v198;
              if (!v144)
              {
                if ((_DWORD)v132 == 2)
                  v145 = v139 == 0;
                else
                  v145 = *((_DWORD *)this + 1) == 0;
                if (v145)
                  p_Aa = &__Aa;
                else
                  p_Aa = &v198;
              }
            }
LABEL_126:
            if ((DSPSplitComplex *)(v141 + v139) != p_Aa)
            {
              v143 = v141 + v139;
              memcpy(*(void **)(v141 + v139), p_Aa->realp, 4 * (*((_DWORD *)this + 4) / 2));
              memcpy(*(void **)(v143 + 8), p_Aa->imagp, 4 * (*((_DWORD *)this + 4) / 2));
              LODWORD(v132) = *((_DWORD *)this + 2);
            }
            break;
          default:
            goto LABEL_128;
        }
      }
      else
      {
LABEL_128:
        *((_DWORD *)this + 31) = 0;
      }
      ++v140;
      v139 += 136;
    }
    while (v140 < (int)v132);
    if (!*((_DWORD *)this + 31) && (int)v132 >= 1)
    {
      v147 = 0;
      v148 = *((_DWORD *)this + 34);
      while (1)
      {
        if (v148 == 1)
        {
LABEL_152:
          v149 = &__Aa;
          goto LABEL_153;
        }
        if (v148)
          break;
        if ((_DWORD)v132 == 2)
        {
          v149 = &__Aa + v147;
LABEL_153:
          v151 = (uint64_t *)(*((_QWORD *)this + 55) + 136 * v147);
          v152 = *((unsigned int *)this + 93);
          if ((int)v152 < 1)
          {
            v161 = 0.0;
          }
          else
          {
            v153 = 0;
            v154 = *((float *)this + 103);
            v155 = *((int *)this + 105);
            v156 = *(_QWORD *)(*((_QWORD *)this + 105) + 8 * (int)v147);
            v157 = v151[1] + 4;
            v158 = *v151 + 4;
            v159 = (uint64_t)(v149->imagp + 1);
            v160 = (uint64_t)(v149->realp + 1);
            v161 = 0.0;
            do
            {
              v162 = v153 + 1;
              if (v153 >= v155)
                v154 = 0.0;
              v163 = *(float *)(v158 + 4 * v153);
              v164 = (float)(v154 + (float)(fabsf(*(float *)(v160 + 4 * v153)) + fabsf(*(float *)(v159 + 4 * v153))))
                   / (float)(fabsf(v163) + fabsf(*(float *)(v157 + 4 * v153)));
              if (v153 < v155)
              {
                if (v162 >= *((int *)this + 104))
                  v165 = v164;
                else
                  v165 = -0.0;
                v161 = v161 + v165;
              }
              v166 = 1.0;
              if (v164 < *((float *)this + 92))
              {
                *(float *)(v158 + 4 * v153) = v163 * v164;
                *(float *)(v157 + 4 * v153) = v164 * *(float *)(v157 + 4 * v153);
                v166 = v164;
              }
              *(float *)(v156 + 4 * v153++) = v166;
            }
            while (v152 != v162);
          }
          v167 = *((float *)this + 102);
          if ((float)(1.0 - (float)(v161 / (float)*((int *)this + 106))) <= 0.0)
            v168 = fmaxf(v167 - *((float *)this + 108), 0.0);
          else
            v168 = fminf(*((float *)this + 107) + v167, 1.0);
          *((float *)this + 102) = v168;
          if ((int)v152 >= 1)
          {
            v169 = v149->realp;
            v170 = v149->imagp;
            v171 = *v151;
            v172 = (float *)(v151[1] + 4);
            v173 = v170 + 1;
            v174 = (float *)(v171 + 4);
            v175 = v169 + 1;
            do
            {
              v176 = *v175++;
              v177 = (float)(*((float *)this + 102) * v176) + (1.0 - *((float *)this + 102)) * *v174;
              *v174++ = v177;
              v178 = *v173++;
              v179 = (float)(*((float *)this + 102) * v178) + (1.0 - *((float *)this + 102)) * *v172;
              *v172++ = v179;
              --v152;
            }
            while (v152);
          }
          goto LABEL_173;
        }
        v150 = *((_DWORD *)this + 1);
        if (!v150)
          goto LABEL_152;
        v149 = &v198;
        if (v150 == 1)
          goto LABEL_153;
LABEL_173:
        if (++v147 == (int)v132)
        {
          v180 = 0;
          v181 = 0;
          do
          {
            v182 = (const float *)*((_QWORD *)this + 40);
            v183 = (float *)(*(_QWORD *)(*((_QWORD *)this + 55) + v180) + 4);
            vDSP_vmul(v183, 1, v182, 1, v183, 1, *((int *)this + 6));
            v184 = (float *)(*(_QWORD *)(*((_QWORD *)this + 55) + v180 + 8) + 4);
            vDSP_vmul(v184, 1, v182, 1, v184, 1, *((int *)this + 6));
            ++v181;
            v132 = *((int *)this + 2);
            v180 += 136;
          }
          while (v181 < v132);
          goto LABEL_176;
        }
      }
      v149 = &v198;
      goto LABEL_153;
    }
  }
LABEL_176:
  if (*((_DWORD *)this + 10))
  {
    if ((_DWORD)v132 == 2)
    {
      v185 = 0;
      v186 = 0;
      do
      {
        v187 = (const float *)(*(_QWORD *)(*((_QWORD *)this + 14) + 8 * v186) + 4);
        v188 = (float *)(*(_QWORD *)(*((_QWORD *)this + 55) + v185) + 4);
        vDSP_vmul(v188, 1, v187, 1, v188, 1, *((int *)this + 6));
        v189 = (float *)(*(_QWORD *)(*((_QWORD *)this + 55) + v185 + 8) + 4);
        vDSP_vmul(v189, 1, v187, 1, v189, 1, *((int *)this + 6));
        ++v186;
        v132 = *((int *)this + 2);
        v185 += 136;
      }
      while (v186 < v132);
    }
    else
    {
      v190 = (const float *)(*(_QWORD *)(*((_QWORD *)this + 14) + 8 * *((int *)this + 1)) + 4);
      vDSP_vmul((const float *)(**((_QWORD **)this + 55) + 4), 1, v190, 1, (float *)(**((_QWORD **)this + 55) + 4), 1, *((int *)this + 6));
      v191 = (float *)(*(_QWORD *)(*((_QWORD *)this + 55) + 8) + 4);
      vDSP_vmul(v191, 1, v190, 1, v191, 1, *((int *)this + 6));
      LODWORD(v132) = *((_DWORD *)this + 2);
    }
  }
  if ((int)v132 >= 1)
  {
    v132 = v132;
    v192 = (_DWORD **)(*((_QWORD *)this + 55) + 8);
    do
    {
      **v192 = 0;
      **(v192 - 1) = 0;
      v192 += 17;
      --v132;
    }
    while (v132);
    v193 = 0;
    v194 = 0;
    do
    {
      vDSP_zvmov((const DSPSplitComplex *)(*((_QWORD *)this + 55) + v193), 1, v3, 1, (uint64_t)(*((_DWORD *)this + 4) + (*((int *)this + 4) < 0)) >> 1);
      ++v194;
      v132 = *((int *)this + 2);
      ++v3;
      v193 += 136;
    }
    while (v194 < v132);
  }
  if (*((_DWORD *)this + 202))
  {
    if ((_DWORD)v132 == 2)
    {
      Beamformer_BeamNF::CmhBEAM2NOpt::getAuxVectors((uint64_t)this, 0);
      v195 = 1;
    }
    else
    {
      v195 = *((_DWORD *)this + 1);
    }
    Beamformer_BeamNF::CmhBEAM2NOpt::getAuxVectors((uint64_t)this, v195);
  }
}

void Beamformer_BeamNF::CmhBEAM2NOpt::abf(uint64_t a1, const float **a2, const float **a3, float **a4, uint64_t a5, int a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  float *v13;
  float *v14;
  float *v15;
  unsigned __int8 v16;
  int v17;
  int v18;
  uint64_t v19;
  float v20;
  int v21;
  int v22;
  int v23;
  unsigned __int16 v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  int v28;
  int v29;
  int v30;
  unsigned __int16 v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  uint64_t v35;
  _WORD *v36;
  float *v37;
  int v38;
  uint64_t v39;
  float *v40;
  float v41;
  uint64_t v42;
  const float **v43;
  const float *v44;
  int v45;
  const float **v46;
  uint64_t v47;
  int v48;
  int v49;
  float v50;
  float *v51;
  float *v52;
  _DWORD *v53;
  float v54;
  int v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  float v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  float v70;
  float v71;
  unsigned int v72;
  float v73;
  float v74;
  vDSP_Length v75;
  const float *v76;
  const float *v77;
  int v78;
  uint64_t v81;
  float __A;
  float __B;

  v10 = a6;
  v11 = a5 + 8 * a6;
  v14 = *(float **)(v11 + 32);
  v12 = (uint64_t *)(v11 + 32);
  v13 = v14;
  v15 = (float *)*(v12 - 2);
  if ((v16 & 1) == 0
  {
    Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kPeakDecay = *(_DWORD *)(a1 + 64);
  }
  v17 = *(_DWORD *)(a1 + 24);
  if (v17 >= 30)
    v18 = 30;
  else
    v18 = *(_DWORD *)(a1 + 24);
  v78 = v18;
  v81 = v10;
  v19 = a5 + 4 * v10;
  v20 = *(float *)(v19 + 64);
  __A = *(float *)(v19 + 88);
  __B = v20;
  vDSP_vabs(*a2, 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vabs(a2[1], 1, *(float **)(a1 + 456), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vasm(*(const float **)(a1 + 448), 1, *(const float **)(a1 + 456), 1, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kOneHalf, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vclip(v15, 1, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kMinThreshold, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kMaxThreshold, v15, 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vsmul(v15, 1, (const float *)&Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kPeakDecay, *(float **)(a1 + 456), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  v21 = *(_DWORD *)(a1 + 16);
  if (v21 >= 0)
    v22 = *(_DWORD *)(a1 + 16);
  else
    v22 = v21 + 1;
  v23 = v22 >> 1;
  if (v21 >= 2)
  {
    v24 = 0;
    v25 = *(_QWORD *)(a1 + 448);
    v26 = *(v12 - 2);
    do
    {
      v27 = *(float *)(v25 + 4 * v24);
      if (v27 <= *(float *)(v26 + 4 * v24))
        v27 = *(float *)(*(_QWORD *)(a1 + 456) + 4 * v24);
      *(float *)(v26 + 4 * v24++) = v27;
    }
    while (v23 > v24);
  }
  vDSP_vthr(v15, 1, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kPeakMinValue0, v15, 1, v23);
  vDSP_vabs(*a3, 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vabs(a3[1], 1, *(float **)(a1 + 456), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vasm(*(const float **)(a1 + 448), 1, *(const float **)(a1 + 456), 1, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kOneHalf, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vclip(v13, 1, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kMinThreshold, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kMaxThreshold, v13, 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vsmul(v13, 1, (const float *)&Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kPeakDecay, *(float **)(a1 + 456), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  v28 = *(_DWORD *)(a1 + 16);
  if (v28 >= 0)
    v29 = *(_DWORD *)(a1 + 16);
  else
    v29 = v28 + 1;
  v30 = v29 >> 1;
  if (v28 > 1)
  {
    v31 = 0;
    v32 = *(_QWORD *)(a1 + 448);
    v33 = *v12;
    do
    {
      v34 = *(float *)(v32 + 4 * v31);
      if (v34 <= *(float *)(v33 + 4 * v31))
        v34 = *(float *)(*(_QWORD *)(a1 + 456) + 4 * v31);
      *(float *)(v33 + 4 * v31++) = v34;
    }
    while (v30 > v31);
  }
  vDSP_vthr(v13, 1, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kPeakMinValue0, v13, 1, v30);
  v35 = a5 + 2 * v10;
  *(_WORD *)(v35 + 72) = 0;
  v36 = (_WORD *)(v35 + 72);
  vDSP_vsmsb(v15, 1, &__B, v13, 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  v37 = *(float **)(a1 + 448);
  if (v17 >= 1)
  {
    v38 = (unsigned __int16)*v36;
    if (v78 <= 1)
      v39 = 1;
    else
      v39 = v78;
    v40 = v37 + 1;
    do
    {
      v41 = *v40++;
      if (v41 < 0.0)
        ++v38;
      else
        --v38;
      --v39;
    }
    while (v39);
    *v36 = v38;
  }
  v42 = a5 + 8 * v10;
  v44 = *(const float **)(v42 + 48);
  v43 = (const float **)(v42 + 48);
  vDSP_vmul(v44, 1, *a3, 1, v37, 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vsub(*(const float **)(a1 + 448), 1, *a2, 1, *a4, 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vmul(*v43, 1, a3[1], 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vsub(*(const float **)(a1 + 448), 1, a2[1], 1, a4[1], 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vmax(v15, 1, v13, 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vthr(*(const float **)(a1 + 448), 1, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kPeakMinValue, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vsq(*(const float **)(a1 + 448), 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vfill(&__A, *(float **)(a1 + 456), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vdiv(*(const float **)(a1 + 448), 1, *(const float **)(a1 + 456), 1, *(float **)(a1 + 464), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  if (*v36 >= *(_WORD *)(a5 + 2 * v81 + 76))
  {
    v55 = *(_DWORD *)(a1 + 256);
    v48 = a6;
    if (v55 < 0)
    {
      v57 = 0;
      v47 = v81;
      v46 = a2;
    }
    else
    {
      v56 = 0;
      v57 = 0;
      v47 = v81;
      v46 = a2;
      v58 = *(_QWORD *)(a1 + 464);
      v59 = *(_QWORD *)(a1 + 472);
      v60 = *(_QWORD *)(a1 + 480);
      v61 = *(_QWORD *)(a1 + 488);
      do
      {
        v62 = v56 + 1;
        v63 = *(_DWORD *)(a5 + 4 * v81 + 96);
        *(_DWORD *)(v59 + 4 * v62) = *(_DWORD *)(v58 + 4 * v62);
        *(_DWORD *)(v60 + 4 * v62) = 0;
        *(_DWORD *)(v61 + 4 * v62) = v63;
        v56 = (unsigned __int16)++v57;
      }
      while (v55 >= (unsigned __int16)v57);
    }
    v64 = *(_DWORD *)(a1 + 24);
    if (v64 > (unsigned __int16)v57)
    {
      v65 = (unsigned __int16)v57;
      v66 = (float)a6;
      v67 = *(_QWORD *)(a1 + 472);
      v68 = *(_QWORD *)(a1 + 480);
      v69 = *(_QWORD *)(a1 + 488);
      do
      {
        v70 = *(float *)(a5 + 4 * v47 + 96);
        v71 = *(float *)(a5 + 104) * v66;
        v72 = v65 + 1;
        *(_DWORD *)(v67 + 4 * v72) = 0;
        *(float *)(v68 + 4 * v72) = v66;
        *(float *)(v69 + 4 * v72) = v71 + (float)((float)(1 - a6) * v70);
        v65 = (unsigned __int16)++v57;
      }
      while (v64 > (unsigned __int16)v57);
    }
  }
  else
  {
    v45 = *(_DWORD *)(a1 + 24);
    v47 = v81;
    v46 = a2;
    v48 = a6;
    if (v45 >= 1)
    {
      v49 = 0;
      v50 = (float)a6;
      v51 = (float *)(*(_QWORD *)(a1 + 488) + 4);
      v52 = (float *)(*(_QWORD *)(a1 + 480) + 4);
      v53 = (_DWORD *)(*(_QWORD *)(a1 + 472) + 4);
      do
      {
        v54 = (float)(*(float *)(a5 + 104) * v50) + (float)((float)(1 - a6) * *(float *)(a5 + 4 * v81 + 96));
        *v53++ = 0;
        *v52++ = v50;
        *v51++ = v54;
        ++v49;
      }
      while (v45 > (unsigned __int16)v49);
    }
  }
  vDSP_vmul(*a4, 1, *a3, 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vmul(a4[1], 1, a3[1], 1, *(float **)(a1 + 456), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vadd(*(const float **)(a1 + 448), 1, *(const float **)(a1 + 456), 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vmul(*(const float **)(a1 + 448), 1, *(const float **)(a1 + 472), 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vmul(*(const float **)(a1 + 488), 1, *v43, 1, *(float **)(a1 + 456), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vadd(*(const float **)(a1 + 448), 1, *(const float **)(a1 + 456), 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vmul(*(const float **)(a1 + 480), 1, *(const float **)(a1 + 488), 1, *(float **)(a1 + 456), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vsub(*(const float **)(a1 + 456), 1, *(const float **)(a1 + 480), 1, *(float **)(a1 + 456), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vadd(*(const float **)(a1 + 448), 1, *(const float **)(a1 + 456), 1, (float *)*v43, 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  vDSP_vclip(*v43, 1, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kLmsHMin, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kLmsHMax, (float *)*v43, 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  if (!v48)
  {
    vDSP_vmin(*v43 + 1, 1, *(const float **)(a1 + 272), 1, (float *)*v43 + 1, 1, *(_DWORD *)(a1 + 16) / 2 - 1);
    if (!*(_DWORD *)(a1 + 284))
      vDSP_vclip(*v43, 1, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::kLmsHMin, &Beamformer_BeamNF::CmhBEAM2NOpt::abf(DSPSplitComplex const&,DSPSplitComplex const&,DSPSplitComplex&,Beamformer_BeamNF::CmhBEAM2NOpt::DABF_STRUCT *,int)::zerof, (float *)*v43, 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  }
  v73 = *(float *)(a5 + 4 * v47 + 80) + -1.0;
  if (v73 >= (float)(*(_DWORD *)(a1 + 24) - 1))
    v73 = (float)(*(_DWORD *)(a1 + 24) - 1);
  v74 = v73 + 1.0;
  v75 = (int)v74;
  if ((int)v75 >= 1)
  {
    v76 = (const float *)(*(_QWORD *)(a1 + 200) + 4);
    v77 = (const float *)(*(_QWORD *)(a1 + 320) + 8);
    vDSP_vsmul(*v43 + 1, 1, v77, (float *)(*(_QWORD *)(a1 + 448) + 4), 1, (int)v74);
    vDSP_vsmul(v76, 1, v77, (float *)(*(_QWORD *)(a1 + 456) + 4), 1, v75);
    vDSP_vadd((const float *)(*(_QWORD *)(a1 + 448) + 4), 1, (const float *)(*(_QWORD *)(a1 + 456) + 4), 1, (float *)(*(_QWORD *)(a1 + 448) + 4), 1, v75);
    vDSP_vsub(v76, 1, (const float *)(*(_QWORD *)(a1 + 448) + 4), 1, (float *)(*(_QWORD *)(a1 + 456) + 4), 1, v75);
    vDSP_vmul((const float *)(*(_QWORD *)(a1 + 456) + 4), 1, *a3 + 1, 1, (float *)(*(_QWORD *)(a1 + 448) + 4), 1, v75);
    vDSP_vsub((const float *)(*(_QWORD *)(a1 + 448) + 4), 1, *v46 + 1, 1, *a4 + 1, 1, v75);
    vDSP_vmul((const float *)(*(_QWORD *)(a1 + 456) + 4), 1, a3[1] + 1, 1, (float *)(*(_QWORD *)(a1 + 448) + 4), 1, v75);
    vDSP_vsub((const float *)(*(_QWORD *)(a1 + 448) + 4), 1, v46[1] + 1, 1, a4[1] + 1, 1, v75);
  }
  if (!v48)
  {
    vDSP_vadd(*v46, 1, *a3, 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
    vDSP_vsmul(*(const float **)(a1 + 448), 1, (const float *)(a1 + 288), *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
    vDSP_vadd(*a4, 1, *(const float **)(a1 + 448), 1, *a4, 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
    vDSP_vadd(v46[1], 1, a3[1], 1, *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
    vDSP_vsmul(*(const float **)(a1 + 448), 1, (const float *)(a1 + 288), *(float **)(a1 + 448), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
    vDSP_vadd(a4[1], 1, *(const float **)(a1 + 448), 1, a4[1], 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  }
}

uint64_t Beamformer_BeamNF::CmhBEAM2NOpt::getAuxVectors(uint64_t this, int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  uint64_t v32;
  float v33;
  float v34;
  int v35;
  float v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float v53;
  int v54;
  _DWORD *v55;
  uint64_t v56;
  int v57;
  float v58;
  float v59;
  float v60;
  float v61;
  int v62;
  int v63;
  BOOL v64;
  float *v65;
  float *v66;
  uint64_t v67;
  BOOL v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  float *v72;
  uint64_t v73;

  v2 = *(_QWORD *)(this + 816);
  v3 = *(_DWORD *)(this + 8);
  v4 = v3 - 1;
  if (v3 - 1 >= a2)
    v5 = a2;
  else
    v5 = v3 - 1;
  v6 = (_QWORD *)(v2 + 8 * v5);
  v7 = *(unsigned int *)(this + 16);
  if ((int)v7 >= 0)
    v8 = *(_DWORD *)(this + 16);
  else
    v8 = v7 + 1;
  v9 = (uint64_t)v8 >> 1;
  v10 = *(_QWORD *)(this + 824);
  v11 = (_QWORD *)(v10 + 8 * v5);
  v12 = *(uint64_t **)(this + 232);
  v13 = *(_QWORD *)(this + 440) + 136 * v5;
  v14 = *(_QWORD *)(this + 320);
  if (v3 > 2)
    v4 = 1;
  v15 = (_QWORD *)(v10 + 8 * v4);
  v16 = (_QWORD *)(v2 + 8 * v4);
  if (a2 == 1)
  {
    v17 = *(_QWORD *)(this + 208);
  }
  else
  {
    v15 = v6;
    v16 = v11;
    v17 = *(_QWORD *)(this + 200);
  }
  if (a2 == 1)
    v18 = *(_QWORD *)(this + 224);
  else
    v18 = *(_QWORD *)(this + 216);
  if (a2 == 1)
    v19 = *(_QWORD *)(this + 200);
  else
    v19 = *(_QWORD *)(this + 208);
  if (a2 == 1)
    v20 = *(_QWORD *)(this + 216);
  else
    v20 = *(_QWORD *)(this + 224);
  if (a2 == 1)
    v21 = v12[1];
  else
    v21 = *v12;
  if (a2 == 1)
    v22 = *v12;
  else
    v22 = v12[1];
  v23 = *v16 + 4;
  v24 = v23 + 4 * v9;
  v25 = *v15 + 4;
  v26 = v25 + 4 * v9;
  v27 = *(_QWORD *)(this + 856);
  if (*(_DWORD *)(v27 + 44))
    v28 = *(float *)(v27 + 16) * 4.0;
  else
    v28 = 1.0;
  v29 = *(_QWORD *)(v13 + 48);
  v30 = *(_QWORD *)(*(_QWORD *)(this + 840) + 8 * v5);
  v73 = *(_QWORD *)(*(_QWORD *)(this + 112) + 8 * a2);
  v31 = *(float *)(v13 + 80);
  v32 = *(_QWORD *)(*(_QWORD *)(this + 104) + 8 * a2);
  v33 = *(float *)(v14 + 8);
  v34 = *(float *)(this + 288);
  if (!*(_DWORD *)(this + 124) || !*(_DWORD *)(this + 376))
  {
    v38 = *(unsigned int *)(this + 24);
    if ((int)v38 < 1)
      goto LABEL_77;
    v39 = 0;
    v40 = v5;
    v41 = *(_QWORD *)(this + 200) + 4;
    v42 = *(_QWORD *)(*(_QWORD *)(this + 832) + 8 * v5) + 4;
    v43 = v29 + 4;
    v44 = v32 + 4;
    v45 = v22 + 4;
    v46 = v21 + 4;
    v47 = v20 + 4;
    v48 = v19 + 4;
    v49 = v18 + 4;
    v50 = this + 4 * v40;
    v51 = *(int *)(this + 256);
    v52 = v17 + 4;
    v53 = -v34;
    v54 = *(_DWORD *)(this + 376);
    v55 = (_DWORD *)(v50 + 260);
    while (v39 > v51)
    {
      *(_DWORD *)(v25 + 4 * v39) = 1065353216;
      *(_DWORD *)(v26 + 4 * v39) = 0;
      *(_DWORD *)(v23 + 4 * v39) = 0;
      *(_DWORD *)(v24 + 4 * v39) = 0;
      if (v54)
        goto LABEL_58;
LABEL_61:
      if (v38 == ++v39)
      {
        v62 = v38;
        goto LABEL_71;
      }
    }
    if (v39 >= (int)v31)
    {
      v56 = *(_QWORD *)(this + 272);
      v57 = *(_DWORD *)(this + 284);
    }
    else
    {
      v56 = *(_QWORD *)(this + 272);
      v57 = *(_DWORD *)(this + 284);
      if (*v55 == 1)
      {
        v58 = *(float *)(v56 + 4 * v39);
        if (v58 >= *(float *)(v43 + 4 * v39))
          v58 = *(float *)(v43 + 4 * v39);
        v59 = fminf(v58, 0.0);
        if (!v57)
          v58 = v59;
        v60 = (float)(v58 * v33) - (float)(*(float *)(v41 + 4 * v39) * (float)(1.0 - v33));
        goto LABEL_53;
      }
    }
    v60 = *(float *)(v56 + 4 * v39);
    if (v60 >= *(float *)(v42 + 4 * v39))
      v60 = *(float *)(v42 + 4 * v39);
    v61 = fminf(v60, 0.0);
    if (!v57)
      v60 = v61;
LABEL_53:
    if (*(_DWORD *)(this + 240))
    {
      *(float *)(v25 + 4 * v39) = *(float *)(v46 + 4 * v39)
                                + (float)((float)(v60 * *(float *)(v48 + 4 * v39)) * *(float *)(v45 + 4 * v39));
      *(float *)(v26 + 4 * v39) = (float)(v60 * *(float *)(v47 + 4 * v39)) * *(float *)(v45 + 4 * v39);
      *(float *)(v23 + 4 * v39) = (float)-(float)(*(float *)(v46 + 4 * v39) * *(float *)(v52 + 4 * v39))
                                - (float)(*(float *)(v45 + 4 * v39) * v60);
      *(float *)(v24 + 4 * v39) = -(float)(*(float *)(v46 + 4 * v39) * *(float *)(v49 + 4 * v39));
      if (*v55 == 1)
      {
        *(float *)(v25 + 4 * v39) = *(float *)(v25 + 4 * v39)
                                  + (float)(v34
                                          * (float)(*(float *)(v46 + 4 * v39)
                                                  - (float)(*(float *)(v48 + 4 * v39) * *(float *)(v45 + 4 * v39))));
        *(float *)(v26 + 4 * v39) = *(float *)(v26 + 4 * v39)
                                  + (float)((float)(*(float *)(v47 + 4 * v39) * v53) * *(float *)(v45 + 4 * v39));
        *(float *)(v23 + 4 * v39) = *(float *)(v23 + 4 * v39)
                                  + (float)(v34
                                          * (float)(*(float *)(v45 + 4 * v39)
                                                  - (float)(*(float *)(v52 + 4 * v39) * *(float *)(v46 + 4 * v39))));
        *(float *)(v24 + 4 * v39) = *(float *)(v24 + 4 * v39)
                                  + (float)((float)(*(float *)(v49 + 4 * v39) * v53) * *(float *)(v46 + 4 * v39));
      }
    }
    else
    {
      *(_DWORD *)(v25 + 4 * v39) = 1065353216;
      *(_DWORD *)(v26 + 4 * v39) = 0;
      *(_DWORD *)(v23 + 4 * v39) = 0;
      *(_DWORD *)(v24 + 4 * v39) = 0;
    }
    *(float *)(v25 + 4 * v39) = *(float *)(v44 + 4 * v39) * *(float *)(v25 + 4 * v39);
    *(float *)(v26 + 4 * v39) = *(float *)(v44 + 4 * v39) * *(float *)(v26 + 4 * v39);
    *(float *)(v23 + 4 * v39) = *(float *)(v44 + 4 * v39) * *(float *)(v23 + 4 * v39);
    *(float *)(v24 + 4 * v39) = *(float *)(v44 + 4 * v39) * *(float *)(v24 + 4 * v39);
    if (!v54)
      goto LABEL_61;
LABEL_58:
    if (v39 < *(int *)(this + 372))
    {
      *(float *)(v25 + 4 * v39) = *(float *)(v30 + 4 * v39) * *(float *)(v25 + 4 * v39);
      *(float *)(v26 + 4 * v39) = *(float *)(v30 + 4 * v39) * *(float *)(v26 + 4 * v39);
      *(float *)(v23 + 4 * v39) = *(float *)(v30 + 4 * v39) * *(float *)(v23 + 4 * v39);
      *(float *)(v24 + 4 * v39) = *(float *)(v30 + 4 * v39) * *(float *)(v24 + 4 * v39);
    }
    *(float *)(v25 + 4 * v39) = *(float *)(v14 + 4 * v39) * *(float *)(v25 + 4 * v39);
    *(float *)(v26 + 4 * v39) = *(float *)(v14 + 4 * v39) * *(float *)(v26 + 4 * v39);
    *(float *)(v23 + 4 * v39) = *(float *)(v14 + 4 * v39) * *(float *)(v23 + 4 * v39);
    *(float *)(v24 + 4 * v39) = *(float *)(v14 + 4 * v39) * *(float *)(v24 + 4 * v39);
    goto LABEL_61;
  }
  v35 = *(_DWORD *)(this + 132);
  v36 = 0.0;
  v37 = 1.0;
  if (v35 != 4)
  {
    if (v35 != 2 && v35)
      goto LABEL_68;
LABEL_67:
    v36 = 1.0;
    v37 = 0.0;
    goto LABEL_68;
  }
  v63 = *(_DWORD *)(this + 136);
  if (v63 == 1)
    goto LABEL_68;
  if (v63)
    goto LABEL_67;
  if (v3 == 2)
    v64 = a2 == 0;
  else
    v64 = *(_DWORD *)(this + 4) == 0;
  if (v64)
    v37 = 1.0;
  else
    v37 = 0.0;
  if (!v64)
    v36 = 1.0;
LABEL_68:
  v62 = *(_DWORD *)(this + 24);
  if (v62 >= 1)
  {
    v65 = (float *)(*v6 + 4);
    v66 = (float *)(*v11 + 4);
    v67 = *(unsigned int *)(this + 24);
    do
    {
      *v65 = v37;
      v65[v9] = 0.0;
      *v66 = v36;
      v66[v9] = 0.0;
      ++v66;
      ++v65;
      --v67;
    }
    while (v67);
LABEL_71:
    if (*(_DWORD *)(this + 40))
      v68 = v62 < 1;
    else
      v68 = 1;
    if (!v68)
    {
      v69 = 0;
      v70 = v73 + 4;
      v71 = 4 * v62;
      do
      {
        *(float *)(v25 + v69) = *(float *)(v70 + v69) * *(float *)(v25 + v69);
        *(float *)(v26 + v69) = *(float *)(v70 + v69) * *(float *)(v26 + v69);
        *(float *)(v23 + v69) = *(float *)(v70 + v69) * *(float *)(v23 + v69);
        *(float *)(v24 + v69) = *(float *)(v70 + v69) * *(float *)(v24 + v69);
        v69 += 4;
      }
      while (v71 != v69);
    }
  }
LABEL_77:
  if ((int)v7 >= 1)
  {
    v72 = (float *)*v6;
    do
    {
      *v72 = v28 * *v72;
      ++v72;
      --v7;
    }
    while (v7);
  }
  return this;
}

float Beamformer_BeamNF::CmhBEAM2NOpt::setParameter(Beamformer_BeamNF::CmhBEAM2NOpt *this, int a2, CmhBEAM2NOpt *a3, double a4, double a5)
{
  float v6;
  CmhBEAM2NOpt *v7;
  unsigned int v8;
  CmhBEAM2NOpt *v9;
  unsigned int v10;
  CmhBEAM2NOpt *v11;
  unsigned int v12;
  CmhBEAM2NOpt *v13;
  unsigned int v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  int v18;
  float v19;
  CmhMicCheck *v20;
  float v21;
  int v22;
  int v23;
  int v24;
  float v25;
  float v26;
  int v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  CmhBEAM2NOpt *v31;
  unsigned int v32;

  switch(a2)
  {
    case 3:
      *(_DWORD *)(*((_QWORD *)this + 107) + 44) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 4:
      v6 = *(float *)a3;
      *((_DWORD *)this + 65) = *(_DWORD *)a3;
      goto LABEL_42;
    case 5:
      *((_DWORD *)this + 94) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 9:
      CmhBEAM2NOpt::setSpatialFilterReal((uint64_t)this, (float *)a3);
      return *(float *)&a4;
    case 10:
      CmhBEAM2NOpt::setSpatialFilterImag((uint64_t)this, (float *)a3);
      return *(float *)&a4;
    case 13:
      v7 = a3;
      v8 = 0;
      goto LABEL_10;
    case 14:
      v9 = a3;
      v10 = 0;
      goto LABEL_12;
    case 15:
      v7 = a3;
      v8 = 1;
LABEL_10:
      CmhBEAM2NOpt::setModelSpatialFilterReal(this, v7, v8);
      return *(float *)&a4;
    case 16:
      v9 = a3;
      v10 = 1;
LABEL_12:
      Beamformer_BeamNF::CmhBEAM2NOpt::setModelSpatialFilterImag(this, v9, v10);
      return *(float *)&a4;
    case 17:
      *(float *)&a4 = CmhBEAM2NOpt::setModelFreqCompVector(this, a3);
      return *(float *)&a4;
    case 18:
      CmhBEAM2NOpt::setModelOmniEQVector(this, a3);
      return *(float *)&a4;
    case 19:
      v11 = a3;
      v12 = 0;
      goto LABEL_18;
    case 20:
      v13 = a3;
      v14 = 0;
      goto LABEL_20;
    case 21:
      v11 = a3;
      v12 = 1;
LABEL_18:
      *(float *)&a4 = CmhBEAM2NOpt::setModelFreqCompVector(this, v11, v12);
      return *(float *)&a4;
    case 22:
      v13 = a3;
      v14 = 1;
LABEL_20:
      CmhBEAM2NOpt::setModelOmniEQVector(this, v13, v14);
      return *(float *)&a4;
    case 29:
      v15 = *((unsigned int *)this + 2);
      if ((int)v15 >= 1)
      {
        LODWORD(a4) = *(_DWORD *)a3;
        v16 = (_DWORD *)(*((_QWORD *)this + 55) + 64);
        do
        {
          *v16 = LODWORD(a4);
          v16 += 34;
          --v15;
        }
        while (v15);
      }
      return *(float *)&a4;
    case 30:
      CmhBEAM2NOpt::setWNG(this, *(float *)a3);
      return *(float *)&a4;
    case 31:
      v28 = *(float *)a3;
      v29 = *((_QWORD *)this + 55);
      *(_DWORD *)(v29 + 108) = *(_DWORD *)a3;
      if (*((int *)this + 2) >= 2)
        *(float *)(v29 + 244) = v28;
      return *(float *)&a4;
    case 34:
      LODWORD(a4) = *(_DWORD *)a3;
      v17 = *((_QWORD *)this + 55);
      *(_DWORD *)(v17 + 112) = *(_DWORD *)a3;
      if (*((int *)this + 2) >= 2)
        *(_DWORD *)(v17 + 248) = LODWORD(a4);
      return *(float *)&a4;
    case 35:
      *((_DWORD *)this + 71) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 36:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 72) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 37:
      if (*(_DWORD *)a3 <= 1u)
        *((_DWORD *)this + 1) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 38:
      *((_DWORD *)this + 30) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 39:
      Beamformer_BeamNF::CmhBEAM2NOpt::setABFVector((uint64_t)this, (float *)a3);
      return *(float *)&a4;
    case 40:
      v18 = 0;
      goto LABEL_34;
    case 41:
      v18 = 1;
LABEL_34:
      *(float *)&a4 = Beamformer_BeamNF::CmhBEAM2NOpt::setABFVector(this, v18, (float *)a3);
      return *(float *)&a4;
    case 44:
      *((_DWORD *)this + 38) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 45:
      *((_DWORD *)this + 32) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 46:
      *((_DWORD *)this + 31) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 47:
      *((_DWORD *)this + 33) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 48:
      v19 = *(float *)a3;
      *((_DWORD *)this + 34) = *(_DWORD *)a3;
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      *((float *)this + 151) = v19;
      goto LABEL_88;
    case 49:
      *((_DWORD *)this + 60) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 50:
      *((_DWORD *)this + 65) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 51:
      v6 = *(float *)a3;
LABEL_42:
      *((float *)this + 66) = v6;
      return *(float *)&a4;
    case 52:
      v21 = *(float *)a3;
      v22 = *((_DWORD *)this + 2);
      if (v22 >= 1)
        v22 = 1;
      goto LABEL_78;
    case 53:
      v21 = *(float *)a3;
      v22 = *((_DWORD *)this + 2);
      if (v22 >= 2)
        v22 = 2;
LABEL_78:
      *(float *)(*((_QWORD *)this + 55) + 136 * v22 - 28) = v21;
      return *(float *)&a4;
    case 54:
      LODWORD(a4) = *(_DWORD *)a3;
      v23 = *((_DWORD *)this + 2);
      if (v23 >= 1)
        v23 = 1;
      goto LABEL_49;
    case 55:
      LODWORD(a4) = *(_DWORD *)a3;
      v23 = *((_DWORD *)this + 2);
      if (v23 >= 2)
        v23 = 2;
LABEL_49:
      *(_DWORD *)(*((_QWORD *)this + 55) + 136 * v23 - 24) = LODWORD(a4);
      return *(float *)&a4;
    case 56:
      *(float *)&a4 = (float)((float)*(int *)a3 / (float)*((int *)this + 3)) * (float)*((int *)this + 4);
      *((_DWORD *)this + 8) = *(_DWORD *)a3;
      v24 = *((_DWORD *)this + 6) - 1;
      if (v24 >= (int)*(float *)&a4)
        v24 = (int)*(float *)&a4;
      *((_DWORD *)this + 64) = v24;
      return *(float *)&a4;
    case 58:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 133) = *(_DWORD *)a3;
      goto LABEL_88;
    case 59:
      v25 = __exp10((float)(*(float *)a3 / -20.0));
      *((float *)this + 90) = v25;
      CmhBEAM2NOpt::loadRVSSSuppressionLimits(this);
      return *(float *)&a4;
    case 60:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 134) = *(_DWORD *)a3;
      goto LABEL_88;
    case 61:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 135) = *(_DWORD *)a3;
      goto LABEL_88;
    case 62:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 136) = *(_DWORD *)a3;
      goto LABEL_88;
    case 63:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 137) = *(_DWORD *)a3;
      goto LABEL_88;
    case 64:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 138) = *(_DWORD *)a3;
      goto LABEL_88;
    case 65:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 139) = *(_DWORD *)a3;
      goto LABEL_88;
    case 66:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 140) = *(_DWORD *)a3;
      goto LABEL_88;
    case 67:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 141) = *(_DWORD *)a3;
      goto LABEL_88;
    case 68:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 142) = *(_DWORD *)a3;
      goto LABEL_88;
    case 69:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 143) = *(_DWORD *)a3;
      goto LABEL_88;
    case 70:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 144) = *(_DWORD *)a3;
      goto LABEL_88;
    case 71:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 145) = *(_DWORD *)a3;
      goto LABEL_88;
    case 72:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 146) = *(_DWORD *)a3;
      goto LABEL_88;
    case 73:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 147) = *(_DWORD *)a3;
      goto LABEL_88;
    case 74:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 148) = *(_DWORD *)a3;
      goto LABEL_88;
    case 75:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 149) = *(_DWORD *)a3;
      goto LABEL_88;
    case 76:
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 150) = *(_DWORD *)a3;
      goto LABEL_88;
    case 77:
      v30 = 0;
      do
      {
        LODWORD(a4) = *(_DWORD *)((char *)a3 + v30);
        *(_DWORD *)((char *)this + v30 + 532) = LODWORD(a4);
        v30 += 4;
      }
      while ((_DWORD)v30 != 76);
      v20 = (Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496);
LABEL_88:
      LODWORD(a4) = CmhMicCheck::init_check_mics(v20, a4, a5).u32[0];
      return *(float *)&a4;
    case 78:
      CmhBEAM2NOpt::setModelFreqEQVector(this, a3);
      return *(float *)&a4;
    case 79:
      v31 = a3;
      v32 = 0;
      goto LABEL_92;
    case 80:
      v31 = a3;
      v32 = 1;
LABEL_92:
      CmhBEAM2NOpt::setModelFreqEQVector(this, v31, v32);
      break;
    case 84:
      *((_DWORD *)this + 10) = *(_DWORD *)a3;
      break;
    case 85:
      *((_DWORD *)this + 202) = *(_DWORD *)a3;
      break;
    case 90:
      *((_DWORD *)this + 224) = *(_DWORD *)a3;
      break;
    case 91:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 95) = *(_DWORD *)a3;
      break;
    case 92:
      v26 = *(float *)a3;
      *((_DWORD *)this + 35) = *(_DWORD *)a3;
      v27 = (int)(float)((float)(v26 / (float)*((int *)this + 3)) * (float)*((int *)this + 4));
      if (*((_DWORD *)this + 6) - 1 < v27)
        v27 = *((_DWORD *)this + 6) - 1;
      *(float *)&a4 = (float)v27;
      *((float *)this + 96) = (float)v27;
      break;
    case 93:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 97) = *(_DWORD *)a3;
      break;
    case 94:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 98) = *(_DWORD *)a3;
      break;
    case 95:
      *((_DWORD *)this + 36) = *(_DWORD *)a3;
      break;
    default:
      return *(float *)&a4;
  }
  return *(float *)&a4;
}

uint64_t Beamformer_BeamNF::CmhBEAM2NOpt::setModelSpatialFilterImag(Beamformer_BeamNF::CmhBEAM2NOpt *this, CmhBEAM2NOpt *a2, unsigned int a3)
{
  float **v4;
  int v5;
  int v6;
  int v7;
  int v8;

  v4 = (float **)((char *)this + 216);
  CmhBEAM2NOpt::interpolateFrequencyVector((uint64_t)a2, (float *)0x101, *((_QWORD *)this + a3 + 27), 93.75, (float *)*((unsigned int *)this + 7), (float)*((int *)this + 3) / (float)*((int *)this + 4));
  v5 = *((_DWORD *)this + 3);
  v6 = *((_DWORD *)this + 4);
  v7 = (int)(float)((float)((float)*((int *)this + 8) / (float)v5) * (float)v6);
  v8 = *((_DWORD *)this + 5);
  if (*((_DWORD *)this + 6) - 1 < v7)
    v7 = *((_DWORD *)this + 6) - 1;
  *((_DWORD *)this + 64) = v7;
  *((_DWORD *)this + 9) = 1;
  return CmhMicCheck::initialize((Beamformer_BeamNF::CmhBEAM2NOpt *)((char *)this + 496), v5, v8, v6 / 2 + 1, (float **)this + 25, v4);
}

uint64_t Beamformer_BeamNF::CmhBEAM2NOpt::setABFVector(uint64_t this, float *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  float *v9;
  uint64_t v10;
  int v11;

  v2 = *(unsigned int *)(this + 8);
  if ((int)v2 >= 1)
  {
    v3 = 0;
    v4 = *(unsigned int *)(this + 24);
    do
    {
      if ((int)v4 >= 1)
      {
        v5 = *(_QWORD *)(this + 440) + 136 * v3;
        v6 = *(_QWORD *)(v5 + 48);
        v7 = (_DWORD *)(*(_QWORD *)(v5 + 56) + 4);
        v8 = (_DWORD *)(v6 + 4);
        v9 = a2;
        v10 = v4;
        do
        {
          *v8++ = *(_DWORD *)v9;
          v11 = *(_DWORD *)v9++;
          *v7++ = v11;
          --v10;
        }
        while (v10);
      }
      ++v3;
    }
    while (v3 != v2);
  }
  return this;
}

float Beamformer_BeamNF::CmhBEAM2NOpt::setABFVector(Beamformer_BeamNF::CmhBEAM2NOpt *this, int a2, float *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  float *v8;
  float v9;
  float result;

  v3 = *((unsigned int *)this + 6);
  if ((int)v3 >= 1)
  {
    v4 = *((_DWORD *)this + 2) - 1;
    if (v4 >= a2)
      v4 = a2;
    v5 = *((_QWORD *)this + 55) + 136 * v4;
    v6 = *(_QWORD *)(v5 + 48);
    v7 = (float *)(*(_QWORD *)(v5 + 56) + 4);
    v8 = (float *)(v6 + 4);
    do
    {
      *v8++ = *a3;
      v9 = *a3++;
      result = v9;
      *v7++ = v9;
      --v3;
    }
    while (v3);
  }
  return result;
}

void AUSMScopeDynamic::~AUSMScopeDynamic(AUSMScopeDynamic *this)
{
  AUScopeDynamic::~AUScopeDynamic(this);
  JUMPOUT(0x1BCC95CECLL);
}

void AUSMScopeDynamic::SetNumberOfElements(AUSMScopeDynamic *this, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  _BYTE v14[24];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = (*(uint64_t (**)(AUSMScopeDynamic *))(*(_QWORD *)this + 24))(this);
  if ((_DWORD)a2 && (v5 = v4, v4 > a2))
  {
    v6 = atomic_load((unsigned __int8 *)(*((_QWORD *)this + 15) + 7441));
    if ((v6 & 1) != 0)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v13 = getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v14 = 136315650;
        *(_QWORD *)&v14[4] = "SetNumberOfElements";
        *(_WORD *)&v14[12] = 1024;
        *(_DWORD *)&v14[14] = v5;
        *(_WORD *)&v14[18] = 1024;
        *(_DWORD *)&v14[20] = a2;
        _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEFAULT, "AUSMScopeDynamic::%s: Cannot reduce number of Elements (%u -> %u) after initialization.", v14, 0x18u);
      }
    }
    else
    {
      v7 = *((_QWORD *)this + 15);
      v8 = v7 + 3304;
      v9 = v7 + 3320;
      v10 = v7 + 3544;
      *(_QWORD *)v14 = v7 + 3304;
      *(_QWORD *)&v14[8] = v7 + 3320;
      *(_QWORD *)&v14[16] = v7 + 3544;
      std::__lock_first<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(0, v7 + 3304, v7 + 3320, v7 + 3544);
      (*(void (**)(AUSMScopeDynamic *))(*(_QWORD *)this + 40))(this);
      v11 = a2;
      do
      {
        v12 = (*(uint64_t (**)(AUSMScopeDynamic *, uint64_t))(*(_QWORD *)this + 32))(this, v11);
        if (v12)
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
        v11 = (v11 + 1);
      }
      while (v5 != (_DWORD)v11);
      *(_DWORD *)(*((_QWORD *)this + 3) + 12) = a2;
      caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v8);
      caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v9);
      caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v10);
    }
  }
  else
  {
    AUScopeDynamic::SetNumberOfElements(this, a2);
  }
}

void sub_1B658FDB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::__unlock_unpack[abi:ne180100]<0ul,1ul,2ul>(&a9);
  _Unwind_Resume(a1);
}

uint64_t VoiceProcessorV7::ProcessDSPChain_Uplink(uint64_t this, AudioTimeStamp *a2)
{
  VoiceProcessorV7 *v3;
  size_t v4;
  int v5;
  const AudioBufferList *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const AudioBufferList *v10;
  const AudioBufferList *v11;
  unsigned int v12;
  unsigned int *v13;
  void *v14;
  const void **v15;
  _QWORD *v16;
  NSObject *v17;
  int v18;
  int *v19;
  OpaqueAudioComponentInstance *v20;
  UInt64 v21;
  UInt64 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  AudioBufferList *v29;
  _DWORD *v30;
  unint64_t v31;
  uint64_t v32;
  AudioBufferList *v33;
  uint64_t v34;
  OpaqueAudioComponentInstance *v35;
  __int128 v36;
  __int128 v37;
  OpaqueAudioComponentInstance *v38;
  __int128 v39;
  __int128 v40;
  OpaqueAudioComponentInstance *v41;
  __int128 v42;
  __int128 v43;
  OpaqueAudioComponentInstance *v44;
  __int128 v45;
  __int128 v46;
  AudioBufferList *v47;
  uint64_t v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  OpaqueAudioComponentInstance *v57;
  __int128 v58;
  __int128 v59;
  OpaqueAudioComponentInstance *v60;
  __int128 v61;
  __int128 v62;
  OpaqueAudioComponentInstance *v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  __int128 v67;
  __int128 v68;
  AudioUnit v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  uint64_t v73;
  const AudioBufferList *v74;
  uint64_t v75;
  VPTimeFreqConverter *v76;
  uint64_t v77;
  uint64_t v78;
  const AudioBufferList *v79;
  uint64_t v80;
  VPTimeFreqConverter *v81;
  AudioUnitParameterID **v82;
  uint64_t v83;
  const AudioBufferList *v84;
  unsigned int v85;
  NSObject *v86;
  NSObject *v87;
  int v88;
  int *v89;
  uint64_t v90;
  OpaqueAudioComponentInstance *v91;
  uint64_t v92;
  uint64_t v93;
  const AudioBufferList *v94;
  uint64_t v95;
  uint64_t v96;
  const AudioBufferList *v97;
  uint64_t v98;
  uint64_t v99;
  const AudioBufferList *v100;
  OpaqueAudioComponentInstance *v101;
  void *v102;
  OSStatus Property;
  float *v104;
  uint64_t Parameter;
  uint64_t v106;
  VPTimeFreqConverter *v107;
  uint64_t v108;
  VPTimeFreqConverter *v109;
  uint64_t v110;
  VPTimeFreqConverter *v111;
  uint64_t v112;
  float *v113;
  float v114;
  UInt64 v115;
  UInt64 v116;
  __int128 v117;
  __int128 v118;
  uint64_t v119;
  const AudioBufferList *v120;
  int v121;
  _BOOL4 v122;
  uint64_t v123;
  int v124;
  _BOOL4 v125;
  uint64_t v126;
  uint64_t v127;
  OpaqueAudioComponentInstance *v128;
  float v129;
  uint64_t v130;
  uint64_t v131;
  Float64 v132;
  Float64 v133;
  UInt64 v134;
  __int128 v135;
  __int128 v136;
  AudioUnitParameterValue v137;
  __int128 v138;
  __int128 v139;
  uint64_t v140;
  const AudioBufferList *v141;
  AudioTimeStamp *p_inInputBufferLists;
  uint64_t v143;
  unsigned int v144;
  const AudioBufferList *v145;
  __int128 v146;
  __int128 v147;
  uint64_t v148;
  const AudioBufferList *v149;
  uint64_t v150;
  AudioBufferList *v151;
  const AudioBufferList *v152;
  AudioUnitParameterValue v153;
  OpaqueAudioComponentInstance *v154;
  __int128 v155;
  __int128 v156;
  const AudioBufferList *v157;
  uint64_t v158;
  BOOL *v159;
  __int128 v160;
  int v161;
  uint64_t v162;
  uint64_t v163;
  const AudioBufferList *v164;
  uint64_t v165;
  __int128 v166;
  __int128 v167;
  uint64_t v168;
  uint64_t v169;
  __int128 v170;
  __int128 v171;
  uint64_t v172;
  uint64_t v173;
  AudioBufferList *v174;
  __int128 v175;
  __int128 v176;
  uint64_t v177;
  AudioUnitParameterValue *v178;
  OpaqueAudioComponentInstance *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  __int128 v185;
  int v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  Float64 v191;
  UInt64 v192;
  __int128 v193;
  __int128 v194;
  uint64_t v195;
  const AudioBufferList *v196;
  _BOOL4 v197;
  _BOOL4 v198;
  int v199;
  AudioBufferList *v200;
  uint64_t v201;
  OpaqueAudioComponentInstance *v202;
  UInt64 v203;
  uint64_t v204;
  __int128 v205;
  __int128 v206;
  OpaqueAudioComponentInstance *v207;
  AudioUnitParameterID v208;
  OpaqueAudioComponentInstance *v209;
  UInt64 v210;
  uint64_t v211;
  __int128 v212;
  __int128 v213;
  int v214;
  uint64_t v215;
  OpaqueAudioComponentInstance *v216;
  _BOOL4 v217;
  int v218;
  __int128 v219;
  __int128 v220;
  uint64_t v221;
  void *v222;
  unsigned int v223;
  int v224;
  uint64_t *v225;
  uint64_t *v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  VPTimeFreqConverter *v231;
  VPTimeFreqConverter *v232;
  __int128 v233;
  __int128 v234;
  OSStatus v235;
  uint64_t v236;
  uint64_t v237;
  unsigned int v238;
  unsigned int v239;
  void *v240;
  OpaqueAudioComponentInstance *v241;
  UInt64 v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  int v246;
  OpaqueAudioComponentInstance *v247;
  uint64_t v248;
  void *v249;
  uint64_t v250;
  __int128 v251;
  __int128 v252;
  uint64_t v253;
  const AudioBufferList *v254;
  float *v256;
  uint64_t v257;
  _BOOL4 v258;
  unsigned int v259;
  char v260;
  const float *v261;
  float *v262;
  OpaqueAudioComponentInstance *v263;
  UInt64 v264;
  uint64_t v265;
  __int128 v266;
  __int128 v267;
  unsigned int v268;
  AudioUnitParameterValue v269;
  unsigned int v270;
  char v271;
  uint64_t v272;
  OpaqueAudioComponentInstance *v273;
  AudioUnitParameterID v274;
  OpaqueAudioComponentInstance *v275;
  unsigned int v276;
  OpaqueAudioComponentInstance *v277;
  __int128 v278;
  __int128 v279;
  OpaqueAudioComponentInstance *v280;
  __int128 v281;
  __int128 v282;
  OpaqueAudioComponentInstance *v283;
  __int128 v284;
  __int128 v285;
  uint64_t v286;
  OpaqueAudioComponentInstance *v287;
  __int128 v288;
  __int128 v289;
  OpaqueAudioComponentInstance *v290;
  __int128 v291;
  __int128 v292;
  int mSampleTime_low;
  OpaqueAudioComponentInstance *v294;
  uint64_t v296;
  uint64_t v297;
  AudioUnitParameterValue *v298;
  AudioUnitParameterValue *v299;
  AudioUnitParameterValue *v300;
  AudioUnitParameterValue *v301;
  AudioUnitParameterValue *v302;
  int v303;
  _BOOL4 v304;
  int v305;
  _BOOL4 v306;
  const AudioBufferList *v307;
  UInt64 v308;
  uint64_t *v309;
  const AudioBufferList *v310;
  AudioUnitParameterValue v311;
  char v312;
  AudioUnitParameterValue v313;
  DSPSplitComplex v314;
  BOOL v315;
  BOOL v316;
  BOOL v317;
  BOOL v318;
  __int16 v319;
  AudioUnitRenderActionFlags v320;
  AudioUnitParameterValue v321;
  uint64_t v322;
  int v323;
  uint64_t v324;
  int v325;
  uint64_t v326;
  int v327;
  const AudioBufferList *v328;
  int v329;
  AudioTimeStamp v330;
  AudioBufferList *v331;
  const AudioBufferList *v332;
  AudioBufferList v333;
  AudioBufferList *v334;
  uint64_t v335;
  UInt32 ioDataSize[2];
  const AudioBufferList *v337;
  AudioTimeStamp inInputBufferLists;
  AudioTimeStamp buf;
  uint64_t v340;

  v3 = (VoiceProcessorV7 *)this;
  v340 = *MEMORY[0x1E0C80C00];
  v4 = **(unsigned int **)(this + 1080);
  if ((_DWORD)v4)
    bzero(*(void **)(this + 1408), v4);
  if (*((_BYTE *)v3 + 1404))
    VoiceProcessorV2::PostSRCMicClipDetection(v3);
  if (!*((_BYTE *)v3 + 2083))
    VoiceProcessorV2::GetAbsoluteChIndexForEpmicAndApplyPreDigitalGain(v3);
  v5 = *((unsigned __int8 *)v3 + 15897);
  if (*((_BYTE *)v3 + 15897)
    && (VoiceProcessorV2::InjectionFilesReadSignal(v3, 7, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 134)),
        v5 = *((unsigned __int8 *)v3 + 15897),
        *((_BYTE *)v3 + 15897))
    && (VoiceProcessorV2::InjectionFilesReadSignal(v3, 8, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 135)),
        v5 = *((unsigned __int8 *)v3 + 15897),
        *((_BYTE *)v3 + 15897))
    && *((_BYTE *)v3 + 15896)
    || *((_BYTE *)v3 + 15899))
  {
    v6 = (const AudioBufferList *)*((_QWORD *)v3 + 134);
    if (v6->mNumberBuffers)
    {
      v7 = 0;
      v8 = 0;
      do
      {
        bzero(v6->mBuffers[v7].mData, v6->mBuffers[v7].mDataByteSize);
        ++v8;
        v6 = (const AudioBufferList *)*((_QWORD *)v3 + 134);
        ++v7;
      }
      while (v8 < v6->mNumberBuffers);
      v5 = *((unsigned __int8 *)v3 + 15897);
    }
  }
  else
  {
    v6 = (const AudioBufferList *)*((_QWORD *)v3 + 134);
  }
  v9 = *((unsigned int *)v3 + 127);
  if (v5 || *((_BYTE *)v3 + 15898))
  {
    this = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 4u, v9, v6, a2);
    v9 = *((unsigned int *)v3 + 127);
    v10 = (const AudioBufferList *)*((_QWORD *)v3 + 135);
    if (*((_BYTE *)v3 + 15897))
      goto LABEL_23;
  }
  else
  {
    v10 = (const AudioBufferList *)*((_QWORD *)v3 + 135);
  }
  if (!*((_BYTE *)v3 + 15898))
  {
    v11 = (const AudioBufferList *)*((_QWORD *)v3 + 177);
    goto LABEL_26;
  }
LABEL_23:
  this = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 5u, v9, v10, a2);
  v9 = *((unsigned int *)v3 + 127);
  v11 = (const AudioBufferList *)*((_QWORD *)v3 + 177);
  if (*((_BYTE *)v3 + 15897))
  {
LABEL_27:
    this = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Au, v9, v11, a2);
    goto LABEL_28;
  }
LABEL_26:
  if (*((_BYTE *)v3 + 15898))
    goto LABEL_27;
LABEL_28:
  v321 = 0.0;
  if (!*((_BYTE *)v3 + 2083) && !*((_BYTE *)v3 + 2085) && !*((_BYTE *)v3 + 472))
  {
    v25 = *((_QWORD *)v3 + 582);
    if (v25 || (*((_BYTE *)v3 + 4664) & 0x7F) != 0)
    {
      v320 = 0;
      *((_QWORD *)v3 + 2126) = 0;
      *((_QWORD *)v3 + 2127) = 0;
      *((_QWORD *)v3 + 2125) = 0;
      v308 = (UInt64)v3 + 17000;
      *((_DWORD *)v3 + 4250) = 1;
      *((_OWORD *)v3 + 1063) = *(_OWORD *)(*((_QWORD *)v3 + 134) + 8);
      if ((v25 & 1) != 0 && (*((_BYTE *)v3 + 4672) & 1) != 0)
      {
        this = *((_QWORD *)v3 + 347);
        if (this)
        {
          v26 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v26;
          v27 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v27;
          v320 = 512;
          this = AudioUnitProcess((AudioUnit)this, &v320, &buf, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 135));
        }
      }
      MEMORY[0x1E0C80A78](this);
      v29 = (AudioBufferList *)((char *)&v297 - ((v28 + 15) & 0x3FFFFFFFF0));
      v30 = (_DWORD *)*((_QWORD *)v3 + 135);
      if (*v30)
      {
        v31 = 0;
        v32 = 2;
        v33 = v29;
        do
        {
          *(_QWORD *)&v33->mNumberBuffers = 0;
          *(_QWORD *)&v33->mBuffers[0].mNumberChannels = 0;
          v33->mBuffers[0].mData = 0;
          v33->mNumberBuffers = 1;
          v33->mBuffers[0] = *(AudioBuffer *)&v30[v32];
          ++v31;
          v32 += 4;
          ++v33;
        }
        while (v31 < *v30);
      }
      v34 = *((_QWORD *)v3 + 582);
      if ((v34 & 2) != 0 && (*((_BYTE *)v3 + 4672) & 2) != 0)
      {
        v35 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 348);
        if (v35)
        {
          v36 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v36;
          v37 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v37;
          v320 = 512;
          AudioUnitProcess(v35, &v320, &buf, *((_DWORD *)v3 + 127), v29);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Bu, *((unsigned int *)v3 + 127), v29, &buf);
          CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 138), v29);
          v34 = *((_QWORD *)v3 + 582);
        }
      }
      if ((v34 & 4) != 0 && (*((_BYTE *)v3 + 4672) & 4) != 0)
      {
        v38 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 349);
        if (v38)
        {
          v39 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v39;
          v40 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v40;
          v320 = 512;
          AudioUnitProcess(v38, &v320, &buf, *((_DWORD *)v3 + 127), v29 + 1);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Cu, *((unsigned int *)v3 + 127), v29 + 1, &buf);
          CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 139), v29 + 1);
          v34 = *((_QWORD *)v3 + 582);
        }
      }
      if ((v34 & 8) != 0 && (*((_BYTE *)v3 + 4672) & 8) != 0)
      {
        v41 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 350);
        if (v41)
        {
          v42 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v42;
          v43 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v43;
          v320 = 512;
          AudioUnitProcess(v41, &v320, &buf, *((_DWORD *)v3 + 127), v29 + 2);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Du, *((unsigned int *)v3 + 127), v29 + 2, &buf);
          CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 140), v29 + 2);
          v34 = *((_QWORD *)v3 + 582);
        }
      }
      if ((v34 & 0x10) != 0 && (*((_BYTE *)v3 + 4672) & 0x10) != 0)
      {
        v44 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 351);
        if (v44)
        {
          v45 = *(_OWORD *)&a2->mRateScalar;
          *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
          *(_OWORD *)&buf.mRateScalar = v45;
          v46 = *(_OWORD *)&a2->mSMPTETime.mHours;
          *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
          *(_OWORD *)&buf.mSMPTETime.mHours = v46;
          v320 = 512;
          v47 = v29 + 3;
          AudioUnitProcess(v44, &v320, &buf, *((_DWORD *)v3 + 127), v47);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Eu, *((unsigned int *)v3 + 127), v47, &buf);
          CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 141), v47);
        }
      }
      v48 = *((_QWORD *)v3 + 135);
      v49 = *(_DWORD *)v48;
      v309 = &v297;
      if (v49 < 3)
      {
        *((_OWORD *)v3 + 1051) = *(_OWORD *)(v48 + 8);
        if (*(_DWORD *)v48 < 2u)
        {
          v54 = 0;
          v53 = 0;
          v52 = 0;
          v51 = 0;
        }
        else
        {
          v54 = 0;
          v53 = 0;
          if (*(_BYTE *)(v308 + 64))
          {
            v52 = 0;
            *((_OWORD *)v3 + 1051) = *(_OWORD *)(v48 + 24);
            *(_OWORD *)((char *)v3 + 16840) = *(_OWORD *)(v48 + 8);
            v51 = 1;
          }
          else
          {
            v51 = 0;
            *(_OWORD *)((char *)v3 + 16840) = *(_OWORD *)(v48 + 24);
            v52 = 1;
          }
        }
LABEL_115:
        v56 = *((_QWORD *)v3 + 582);
        if ((v56 & 0x40) != 0 && (*((_BYTE *)v3 + 4672) & 0x40) != 0)
        {
          v57 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 353);
          if (v57)
          {
            v58 = *(_OWORD *)&a2->mRateScalar;
            *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
            *(_OWORD *)&buf.mRateScalar = v58;
            v59 = *(_OWORD *)&a2->mSMPTETime.mHours;
            *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
            *(_OWORD *)&buf.mSMPTETime.mHours = v59;
            v320 = 512;
            AudioUnitProcess(v57, &v320, &buf, *((_DWORD *)v3 + 127), (AudioBufferList *)((char *)v3 + 16808));
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 6u, *((unsigned int *)v3 + 127), (const AudioBufferList *)((char *)v3 + 16808), &buf);
            v56 = *((_QWORD *)v3 + 582);
          }
        }
        if ((v56 & 0x80) != 0 && (*((_BYTE *)v3 + 4672) & 0x80) != 0)
        {
          v60 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 354);
          if (v60)
          {
            v61 = *(_OWORD *)&a2->mRateScalar;
            *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
            *(_OWORD *)&buf.mRateScalar = v61;
            v62 = *(_OWORD *)&a2->mSMPTETime.mHours;
            *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
            *(_OWORD *)&buf.mSMPTETime.mHours = v62;
            v320 = 512;
            AudioUnitProcess(v60, &v320, &buf, *((_DWORD *)v3 + 127), (AudioBufferList *)((char *)v3 + 16832));
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 7u, *((unsigned int *)v3 + 127), (const AudioBufferList *)((char *)v3 + 16832), &buf);
            v56 = *((_QWORD *)v3 + 582);
          }
        }
        if ((v56 & 0x200) != 0 && (*((_BYTE *)v3 + 4673) & 2) != 0)
        {
          v63 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 356);
          if (v63)
          {
            v64 = *(_OWORD *)&a2->mRateScalar;
            *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
            *(_OWORD *)&buf.mRateScalar = v64;
            v65 = *(_OWORD *)&a2->mSMPTETime.mHours;
            *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
            *(_OWORD *)&buf.mSMPTETime.mHours = v65;
            v320 = 512;
            AudioUnitProcess(v63, &v320, &buf, *((_DWORD *)v3 + 127), (AudioBufferList *)((char *)v3 + 16880));
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 9u, *((unsigned int *)v3 + 127), (const AudioBufferList *)((char *)v3 + 16880), &buf);
            v56 = *((_QWORD *)v3 + 582);
          }
        }
        if ((v56 & 0x400) != 0 && (*((_BYTE *)v3 + 4673) & 4) != 0)
        {
          v66 = *((_QWORD *)v3 + 357);
          if (v66)
          {
            MEMORY[0x1E0C80A78](v66);
            *(&v297 - 6) = 2;
            *(_OWORD *)(&v297 - 5) = *((_OWORD *)v3 + 1051);
            *(_OWORD *)(&v297 - 3) = *(_OWORD *)((char *)v3 + 16840);
            *(_QWORD *)&v330.mSampleTime = &v297 - 6;
            v330.mHostTime = 0;
            *(_QWORD *)&inInputBufferLists.mSampleTime = (char *)v3 + 16808;
            memset(&inInputBufferLists.mHostTime, 0, 24);
            v320 = 512;
            v67 = *(_OWORD *)&a2->mRateScalar;
            *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
            *(_OWORD *)&buf.mRateScalar = v67;
            v68 = *(_OWORD *)&a2->mSMPTETime.mHours;
            *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
            *(_OWORD *)&buf.mSMPTETime.mHours = v68;
            AudioUnitProcessMultiple(v69, &v320, &buf, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&v330, 4u, (AudioBufferList **)&inInputBufferLists);
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x63u, *((unsigned int *)v3 + 127), (const AudioBufferList *)((char *)v3 + 16808), &buf);
            v56 = *((_QWORD *)v3 + 582);
          }
        }
        v319 = 0;
        v70 = *(_OWORD *)&a2->mRateScalar;
        *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
        *(_OWORD *)&buf.mRateScalar = v70;
        v71 = *(_OWORD *)&a2->mSMPTETime.mHours;
        *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
        *(_OWORD *)&buf.mSMPTETime.mHours = v71;
        if ((v56 & 0x2000000) == 0 || (*((_BYTE *)v3 + 4675) & 2) == 0 || !*((_QWORD *)v3 + 372))
        {
LABEL_162:
          v318 = 0;
          if ((v56 & 0x4000000) == 0 || (*((_BYTE *)v3 + 4675) & 4) == 0 || !*((_QWORD *)v3 + 373))
            goto LABEL_179;
          v77 = *((_QWORD *)v3 + 2098);
          if ((unint64_t)(*((_QWORD *)v3 + 2099) - v77) <= 0x28)
            goto LABEL_690;
          ECApplicator::apply(*(AudioUnitParameterID **)(v77 + 40), &buf, v52, &v318, (float *)v3 + 1047, (float *)v3 + 1051, (float *)v3 + 1055, (float *)v3 + 1059, (float *)v3 + 1063, (float *)v3 + 1067);
          v78 = *((unsigned int *)v3 + 127);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          {
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x22u, v78, *((const AudioBufferList **)v3 + 136), &buf);
            v78 = *((unsigned int *)v3 + 127);
            v79 = (const AudioBufferList *)*((_QWORD *)v3 + 2137);
            if (*((_BYTE *)v3 + 15897))
              goto LABEL_172;
          }
          else
          {
            v79 = (const AudioBufferList *)*((_QWORD *)v3 + 2137);
          }
          if (!*((_BYTE *)v3 + 15898))
          {
LABEL_173:
            v80 = *((_QWORD *)v3 + 508);
            inInputBufferLists.mSampleTime = *(Float64 *)(v80 + 16);
            inInputBufferLists.mHostTime = *(_QWORD *)&inInputBufferLists.mSampleTime + 4 * v78;
            v81 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 2145);
            if (v81)
            {
              VPTimeFreqConverter::Analyze(v81, *(const float **)(*((_QWORD *)v3 + 2137) + 16), (DSPSplitComplex *)&inInputBufferLists);
              v78 = *((unsigned int *)v3 + 127);
              v80 = *((_QWORD *)v3 + 508);
            }
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x17u, v78, (const AudioBufferList *)v80, &buf);
            v56 = *((_QWORD *)v3 + 582);
LABEL_179:
            if ((v56 & 0x200000) != 0 && (*((_BYTE *)v3 + 4674) & 0x20) != 0 && *((_QWORD *)v3 + 368))
            {
              v82 = (AudioUnitParameterID **)*((_QWORD *)v3 + 2098);
              if (*((AudioUnitParameterID ***)v3 + 2099) == v82)
                goto LABEL_690;
              ECApplicator::apply(*v82, &buf, v51, (BOOL *)&v319 + 1, (float *)v3 + 1046, (float *)v3 + 1050, (float *)v3 + 1054, (float *)v3 + 1058, (float *)v3 + 1062, (float *)v3 + 1066);
              v83 = *((unsigned int *)v3 + 127);
              if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              {
                VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Cu, v83, (const AudioBufferList *)((char *)v3 + 16808), &buf);
                v83 = *((unsigned int *)v3 + 127);
                v84 = (const AudioBufferList *)*((_QWORD *)v3 + 418);
                if (*((_BYTE *)v3 + 15897))
                {
LABEL_219:
                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xCu, v83, v84, &buf);
                  goto LABEL_205;
                }
              }
              else
              {
                v84 = (const AudioBufferList *)*((_QWORD *)v3 + 418);
              }
              if (*((_BYTE *)v3 + 15898))
                goto LABEL_219;
            }
            else
            {
              v85 = 0;
              while (((*((_DWORD *)v3 + 116) >> v85) & 1) == 0)
              {
                if (++v85 == 32)
                {
                  v85 = 33;
                  break;
                }
              }
              if (v85 >= **((_DWORD **)v3 + 135))
              {
                LODWORD(v310) = v52;
                if (VPLogScope(void)::once != -1)
                  dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
                v86 = CALog::LogObjIfEnabled(1, VPLogScope(void)::scope);
                if (v86)
                {
                  v87 = v86;
                  if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                  {
                    v88 = **((_DWORD **)v3 + 135);
                    LODWORD(inInputBufferLists.mSampleTime) = 136315906;
                    *(_QWORD *)((char *)&inInputBufferLists.mSampleTime + 4) = "vpProcessUplink_v7.cpp";
                    WORD2(inInputBufferLists.mHostTime) = 1024;
                    *(_DWORD *)((char *)&inInputBufferLists.mHostTime + 6) = 328;
                    WORD1(inInputBufferLists.mRateScalar) = 1024;
                    HIDWORD(inInputBufferLists.mRateScalar) = v85;
                    LOWORD(inInputBufferLists.mWordClockTime) = 1024;
                    *(_DWORD *)((char *)&inInputBufferLists.mWordClockTime + 2) = v88;
                    _os_log_impl(&dword_1B5ED0000, v87, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", (uint8_t *)&inInputBufferLists, 0x1Eu);
                  }
                }
                v89 = (int *)*((_QWORD *)v3 + 1570);
                if (v89 && (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898)))
                {
                  if (VPLogScope(void)::once != -1)
                    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
                  CALegacyLog::log(v89, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v7/vpProcessUplink_v7.cpp", 328, "ProcessDSPChain_Uplink", "ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", v85, **((_DWORD **)v3 + 135));
                }
                v85 = 0;
                v52 = v310;
              }
              v90 = *((_QWORD *)v3 + 135) + 16 * v85;
              memcpy(*(void **)(*((_QWORD *)v3 + 136) + 16), *(const void **)(v90 + 16), *(unsigned int *)(v90 + 12));
            }
LABEL_205:
            if ((*((_BYTE *)v3 + 4664) & 0x20) != 0 && (*((_BYTE *)v3 + 4680) & 0x20) != 0)
            {
              v91 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 416);
              if (v91)
              {
                inInputBufferLists.mSampleTime = *((Float64 *)v3 + 135);
                inInputBufferLists.mHostTime = v308;
                v330.mSampleTime = *((Float64 *)v3 + 136);
                v320 = 512;
                AudioUnitProcessMultiple(v91, &v320, &buf, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&inInputBufferLists, 1u, (AudioBufferList **)&v330);
              }
            }
            v317 = 0;
            if ((*((_BYTE *)v3 + 4658) & 0x40) != 0 && (*((_BYTE *)v3 + 4674) & 0x40) != 0 && *((_QWORD *)v3 + 369))
            {
              v92 = *((_QWORD *)v3 + 2098);
              if ((unint64_t)(*((_QWORD *)v3 + 2099) - v92) <= 8)
                goto LABEL_690;
              ECApplicator::apply(*(AudioUnitParameterID **)(v92 + 8), &buf, v52, &v317, (float *)v3 + 1047, (float *)v3 + 1051, (float *)v3 + 1055, (float *)v3 + 1059, (float *)v3 + 1063, (float *)v3 + 1067);
              v93 = *((unsigned int *)v3 + 127);
              if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
              {
                VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Du, v93, (const AudioBufferList *)((char *)v3 + 16832), &buf);
                v93 = *((unsigned int *)v3 + 127);
                v94 = (const AudioBufferList *)*((_QWORD *)v3 + 419);
                if (*((_BYTE *)v3 + 15897))
                {
LABEL_222:
                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xDu, v93, v94, &buf);
                  goto LABEL_223;
                }
              }
              else
              {
                v94 = (const AudioBufferList *)*((_QWORD *)v3 + 419);
              }
              if (*((_BYTE *)v3 + 15898))
                goto LABEL_222;
            }
LABEL_223:
            v316 = 0;
            if ((*((_BYTE *)v3 + 4658) & 0x80) == 0 || (*((_BYTE *)v3 + 4674) & 0x80) == 0 || !*((_QWORD *)v3 + 370))
              goto LABEL_234;
            v95 = *((_QWORD *)v3 + 2098);
            if ((unint64_t)(*((_QWORD *)v3 + 2099) - v95) <= 0x10)
              goto LABEL_690;
            ECApplicator::apply(*(AudioUnitParameterID **)(v95 + 16), &buf, v54, &v316, (float *)v3 + 1048, (float *)v3 + 1052, (float *)v3 + 1056, (float *)v3 + 1060, (float *)v3 + 1064, (float *)v3 + 1068);
            v96 = *((unsigned int *)v3 + 127);
            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            {
              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Eu, v96, (const AudioBufferList *)((char *)v3 + 16856), &buf);
              v96 = *((unsigned int *)v3 + 127);
              v97 = (const AudioBufferList *)*((_QWORD *)v3 + 421);
              if (*((_BYTE *)v3 + 15897))
              {
LABEL_233:
                VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xEu, v96, v97, &buf);
LABEL_234:
                v315 = 0;
                if ((*((_BYTE *)v3 + 4659) & 1) == 0 || (*((_BYTE *)v3 + 4675) & 1) == 0 || !*((_QWORD *)v3 + 371))
                  goto LABEL_245;
                v98 = *((_QWORD *)v3 + 2098);
                if ((unint64_t)(*((_QWORD *)v3 + 2099) - v98) > 0x18)
                {
                  ECApplicator::apply(*(AudioUnitParameterID **)(v98 + 24), &buf, v53, &v315, (float *)v3 + 1049, (float *)v3 + 1053, (float *)v3 + 1057, (float *)v3 + 1061, (float *)v3 + 1065, (float *)v3 + 1069);
                  v99 = *((unsigned int *)v3 + 127);
                  if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                  {
                    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Fu, v99, (const AudioBufferList *)((char *)v3 + 16880), &buf);
                    v99 = *((unsigned int *)v3 + 127);
                    v100 = (const AudioBufferList *)*((_QWORD *)v3 + 420);
                    if (*((_BYTE *)v3 + 15897))
                    {
LABEL_244:
                      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xFu, v99, v100, &buf);
                      goto LABEL_245;
                    }
                  }
                  else
                  {
                    v100 = (const AudioBufferList *)*((_QWORD *)v3 + 420);
                  }
                  if (*((_BYTE *)v3 + 15898))
                    goto LABEL_244;
LABEL_245:
                  if ((*((_BYTE *)v3 + 8837) & 8) != 0 && (*((_BYTE *)v3 + 8845) & 8) != 0)
                  {
                    if (*((_QWORD *)v3 + 480))
                    {
                      *(_BYTE *)(v308 + 32) = 0;
                      if ((*((_BYTE *)v3 + 4658) & 0x80) != 0 && (*((_BYTE *)v3 + 4674) & 0x80) != 0)
                      {
                        v101 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 370);
                        if (v101)
                        {
                          if (*((_QWORD *)v3 + 2128))
                          {
                            LODWORD(inInputBufferLists.mSampleTime) = 0;
                            if (!AudioUnitGetPropertyInfo(v101, 0xF3Cu, 0, 0, (UInt32 *)&inInputBufferLists, 0)
                              && LODWORD(inInputBufferLists.mSampleTime) == 4 * *((unsigned int *)v3 + 127))
                            {
                              v102 = *(void **)(*((_QWORD *)v3 + 2128) + 16);
                              Property = AudioUnitGetProperty(*((AudioUnit *)v3 + 370), 0xF3Cu, 0, 0, v102, (UInt32 *)&inInputBufferLists);
                              if (*((_BYTE *)v3 + 481))
                                AudioUnitSetProperty(*((AudioUnit *)v3 + 480), 0xF3Cu, 0, 0, v102, LODWORD(inInputBufferLists.mSampleTime));
                              *(_BYTE *)(v308 + 32) = Property == 0;
                            }
                          }
                        }
                      }
                    }
                  }
                  v104 = (float *)(*(_QWORD *)(*((_QWORD *)v3 + 510) + 16) + 4 * *((unsigned int *)v3 + 127));
                  v314.realp = *(float **)(*((_QWORD *)v3 + 510) + 16);
                  v314.imagp = v104;
                  Parameter = *((_QWORD *)v3 + 518);
                  if (Parameter)
                    Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *((const float **)v3 + 2127), &v314);
                  if ((*((_BYTE *)v3 + 4658) & 0x20) != 0
                    && (*((_BYTE *)v3 + 4674) & 0x20) != 0
                    && *((_QWORD *)v3 + 368))
                  {
                    v106 = *((unsigned int *)v3 + 127);
                    v314.realp = *(float **)(*((_QWORD *)v3 + 428) + 16);
                    v314.imagp = &v314.realp[v106];
                    v107 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 512);
                    if (v107)
                    {
                      VPTimeFreqConverter::Analyze(v107, *((const float **)v3 + 2103), &v314);
                      v106 = *((unsigned int *)v3 + 127);
                    }
                    v314.realp = *(float **)(*((_QWORD *)v3 + 504) + 16);
                    v314.imagp = &v314.realp[v106];
                    Parameter = *((_QWORD *)v3 + 516);
                    if (Parameter)
                    {
                      Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *(const float **)(*((_QWORD *)v3 + 418) + 16), &v314);
                      v106 = *((unsigned int *)v3 + 127);
                    }
                    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                      Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x12u, v106, *((const AudioBufferList **)v3 + 428), &buf);
                  }
                  if ((*((_BYTE *)v3 + 4658) & 0x40) != 0
                    && (*((_BYTE *)v3 + 4674) & 0x40) != 0
                    && *((_QWORD *)v3 + 369))
                  {
                    v108 = *((unsigned int *)v3 + 127);
                    v314.realp = *(float **)(*((_QWORD *)v3 + 505) + 16);
                    v314.imagp = &v314.realp[v108];
                    v109 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 513);
                    if (v109)
                    {
                      VPTimeFreqConverter::Analyze(v109, *((const float **)v3 + 2106), &v314);
                      v108 = *((unsigned int *)v3 + 127);
                    }
                    v314.realp = *(float **)(*((_QWORD *)v3 + 504) + 32);
                    v314.imagp = &v314.realp[v108];
                    Parameter = *((_QWORD *)v3 + 517);
                    if (Parameter)
                    {
                      Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *(const float **)(*((_QWORD *)v3 + 419) + 16), &v314);
                      v108 = *((unsigned int *)v3 + 127);
                    }
                    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                      Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x13u, v108, *((const AudioBufferList **)v3 + 505), &buf);
                  }
                  if ((*((_BYTE *)v3 + 4659) & 1) != 0 && (*((_BYTE *)v3 + 4675) & 1) != 0 && *((_QWORD *)v3 + 371))
                  {
                    v110 = *((unsigned int *)v3 + 127);
                    v314.realp = *(float **)(*((_QWORD *)v3 + 506) + 16);
                    v314.imagp = &v314.realp[v110];
                    v111 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 515);
                    if (v111)
                    {
                      VPTimeFreqConverter::Analyze(v111, *((const float **)v3 + 2112), &v314);
                      v110 = *((unsigned int *)v3 + 127);
                    }
                    v314.realp = *(float **)(*((_QWORD *)v3 + 504) + 64);
                    v314.imagp = &v314.realp[v110];
                    Parameter = *((_QWORD *)v3 + 2096);
                    if (Parameter)
                    {
                      Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *(const float **)(*((_QWORD *)v3 + 420) + 16), &v314);
                      v110 = *((unsigned int *)v3 + 127);
                    }
                    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                      Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x15u, v110, *((const AudioBufferList **)v3 + 506), &buf);
                  }
                  v313 = 0.0;
                  v112 = *((_QWORD *)v3 + 582);
                  if ((v112 & 0x40000000000) != 0 && (*((_BYTE *)v3 + 4677) & 4) != 0)
                  {
                    Parameter = *((_QWORD *)v3 + 389);
                    if (Parameter)
                    {
                      Parameter = AudioUnitGetParameter((AudioUnit)Parameter, 0x2Bu, 0, 0, &v313);
                      v112 = *((_QWORD *)v3 + 582);
                    }
                  }
                  if ((v112 & 0x800000) != 0 && (*((_BYTE *)v3 + 4674) & 0x80) != 0)
                  {
                    if (*((_QWORD *)v3 + 370))
                    {
                      if (v313 == 1.0)
                      {
                        v113 = (float *)(*(_QWORD *)(*((_QWORD *)v3 + 504) + 48) + 4 * *((unsigned int *)v3 + 127));
                        v314.realp = *(float **)(*((_QWORD *)v3 + 504) + 48);
                        v314.imagp = v113;
                        Parameter = *((_QWORD *)v3 + 2132);
                        if (Parameter)
                        {
                          Parameter = VPTimeFreqConverter::Analyze((VPTimeFreqConverter *)Parameter, *(const float **)(*((_QWORD *)v3 + 421) + 16), &v314);
                          v112 = *((_QWORD *)v3 + 582);
                        }
                      }
                    }
                  }
                  if ((v112 & 0x80000000000) == 0
                    || (*((_BYTE *)v3 + 4677) & 8) == 0
                    || (Parameter = *((_QWORD *)v3 + 390)) == 0)
                  {
LABEL_313:
                    v312 = 0;
                    if ((v112 & 0x20000000) != 0 && (*((_BYTE *)v3 + 4675) & 0x20) != 0 && *((_QWORD *)v3 + 376))
                    {
                      v121 = 1;
                      v122 = 1;
                    }
                    else if ((v112 & 0x100000000) != 0 && (*((_BYTE *)v3 + 4676) & 1) != 0)
                    {
                      v121 = 0;
                      v122 = *((_QWORD *)v3 + 379) != 0;
                    }
                    else
                    {
                      v121 = 0;
                      v122 = 0;
                    }
                    v123 = v112 & 0x40000000;
                    if ((v112 & 0x40000000) != 0 && (*((_BYTE *)v3 + 4675) & 0x40) != 0 && *((_QWORD *)v3 + 377))
                    {
                      v124 = 1;
                      v121 = 1;
                      v125 = 1;
                      if ((v112 & 0x80000000) == 0)
                        goto LABEL_338;
                    }
                    else
                    {
                      if ((v112 & 0x80000000) == 0)
                      {
                        v125 = 0;
                        v124 = 1;
                        goto LABEL_338;
                      }
                      v124 = 1;
                      if ((*((_BYTE *)v3 + 4675) & 0x80) != 0)
                      {
                        v126 = *((_QWORD *)v3 + 378);
                        v125 = v126 != 0;
                        if (v126)
                          v124 = 2;
                        else
                          v124 = 1;
                      }
                      else
                      {
                        v125 = 0;
                      }
                    }
                    v127 = *((_QWORD *)v3 + 584);
                    if ((v127 & 0x80000000) != 0
                      && *((_QWORD *)v3 + 378)
                      && (v112 & v127 & 0x100000000) != 0
                      && *((_QWORD *)v3 + 379))
                    {
                      v121 = 2;
                      v124 = 2;
                    }
LABEL_338:
                    if ((v112 & 0x20000000) == 0)
                      goto LABEL_355;
                    if ((*((_BYTE *)v3 + 4675) & 0x20) == 0)
                      goto LABEL_355;
                    Parameter = *((_QWORD *)v3 + 376);
                    if (!Parameter)
                      goto LABEL_355;
                    AudioUnitSetProperty((AudioUnit)Parameter, 0x457u, 0, 0, (char *)v3 + 2316, 4u);
                    if ((*((_BYTE *)v3 + 4659) & 0x40) != 0 && (*((_BYTE *)v3 + 4675) & 0x40) != 0)
                    {
                      v128 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 376);
                      if (*((_QWORD *)v3 + 377))
                      {
                        v129 = (float)*((unsigned int *)v3 + 684);
LABEL_345:
                        AudioUnitSetParameter(v128, 0x1Bu, 0, 0, v129, 0);
                        v130 = *((_QWORD *)v3 + 582);
                        if ((v130 & 0x200000) != 0)
                        {
                          v131 = *((_QWORD *)v3 + 584);
                          if ((v131 & 0x200000) != 0
                            && *((_QWORD *)v3 + 368)
                            && (v130 & v131 & 0x400000) != 0
                            && *((_QWORD *)v3 + 369))
                          {
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 376), 0x3Fu, 0, 0, *((float *)v3 + 1054) * *((float *)v3 + 1055), 0);
                          }
                        }
                        *(_QWORD *)&v132 = *((_QWORD *)v3 + 138) + 24;
                        *(_QWORD *)&v133 = *((_QWORD *)v3 + 139) + 24;
                        if (**((_DWORD **)v3 + 135) <= 2u)
                        {
                          *(_QWORD *)&v330.mSampleTime = *((_QWORD *)v3 + 138) + 24;
                          *(Float64 *)&v330.mHostTime = v133;
                          v330.mRateScalar = 0.0;
                          v330.mWordClockTime = v308;
                          *(_OWORD *)&v330.mSMPTETime.mSubframes = *((_OWORD *)v3 + 209);
                        }
                        else
                        {
                          v134 = *((_QWORD *)v3 + 140) + 24;
                          v330.mWordClockTime = v308;
                          *(_OWORD *)&v330.mSMPTETime.mSubframes = *((_OWORD *)v3 + 209);
                          v330.mSampleTime = v133;
                          v330.mHostTime = v134;
                          v330.mRateScalar = v132;
                        }
                        *(_QWORD *)&v333.mNumberBuffers = 0;
                        v320 = 512;
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 376), 0x2Cu, 0, 0, *((AudioUnitParameterValue *)v3 + 1090), 0);
                        v135 = *(_OWORD *)&a2->mRateScalar;
                        *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                        *(_OWORD *)&inInputBufferLists.mRateScalar = v135;
                        v136 = *(_OWORD *)&a2->mSMPTETime.mHours;
                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v136;
                        Parameter = AudioUnitProcessMultiple(*((AudioUnit *)v3 + 376), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)&v330, 1u, (AudioBufferList **)&v333);
                        v112 = *((_QWORD *)v3 + 582);
                        v123 = v112 & 0x40000000;
LABEL_355:
                        if (v123 && (*((_BYTE *)v3 + 4675) & 0x40) != 0 && *((_QWORD *)v3 + 377))
                        {
                          memcpy(*(void **)(*((_QWORD *)v3 + 434) + 16 * *((unsigned int *)v3 + 1040) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
                          memcpy(*(void **)(*((_QWORD *)v3 + 434) + 16 * *((unsigned int *)v3 + 1041) + 16), *(const void **)(*((_QWORD *)v3 + 505) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
                          if (*((float *)v3 + 1066) == 0.0 && *((float *)v3 + 1067) == 0.0)
                            v137 = 0.0;
                          else
                            v137 = 1.0;
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 377), 0x20u, 0, 0, v137, 0);
                          v330.mSampleTime = *((Float64 *)v3 + 434);
                          *(_QWORD *)&v333.mNumberBuffers = *((_QWORD *)v3 + 429);
                          v138 = *(_OWORD *)&a2->mRateScalar;
                          *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                          *(_OWORD *)&inInputBufferLists.mRateScalar = v138;
                          v139 = *(_OWORD *)&a2->mSMPTETime.mHours;
                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v139;
                          v320 = 512;
                          AudioUnitProcessMultiple(*((AudioUnit *)v3 + 377), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)&v330, 1u, (AudioBufferList **)&v333);
                          ioDataSize[0] = 8 * *((_DWORD *)v3 + 127);
                          AudioUnitGetProperty(*((AudioUnit *)v3 + 377), 0xE7Au, 0, 0, *(void **)(*((_QWORD *)v3 + 537) + 16), ioDataSize);
                          ioDataSize[0] = 8 * *((_DWORD *)v3 + 127);
                          Parameter = AudioUnitGetProperty(*((AudioUnit *)v3 + 377), 0xE79u, 0, 0, *(void **)(*((_QWORD *)v3 + 537) + 32), ioDataSize);
                          v140 = *((unsigned int *)v3 + 127);
                          v141 = (const AudioBufferList *)*((_QWORD *)v3 + 429);
                          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                          {
                            p_inInputBufferLists = &inInputBufferLists;
                            v143 = (uint64_t)v3;
                            v144 = 10;
LABEL_364:
                            Parameter = VoiceProcessorV2::SaveFilesWriteSignal(v143, v144, v140, v141, p_inInputBufferLists);
                          }
LABEL_392:
                          MEMORY[0x1E0C80A78](Parameter);
                          v157 = (const AudioBufferList *)(&v297 - 8);
                          *((_OWORD *)&v297 - 3) = 0u;
                          *((_OWORD *)&v297 - 2) = 0u;
                          *((_OWORD *)&v297 - 4) = 0u;
                          *((_DWORD *)&v297 - 16) = 3;
                          *(double *)&v160 = MEMORY[0x1E0C80A78](v158);
                          v310 = (const AudioBufferList *)(&v297 - 8);
                          v296 = 0;
                          *((_OWORD *)&v297 - 3) = v160;
                          *((_OWORD *)&v297 - 2) = v160;
                          *((_OWORD *)&v297 - 4) = v160;
                          *((_DWORD *)&v297 - 16) = v161;
                          v162 = *((_QWORD *)v3 + 582);
                          if ((v162 & 0x200000000) != 0 && (*((_BYTE *)v3 + 4676) & 2) != 0 && *((_QWORD *)v3 + 380)
                            || (v162 & 0x400000000) != 0 && (*((_BYTE *)v3 + 4676) & 4) != 0 && *((_QWORD *)v3 + 381)
                            || (v162 & 0x1000000000) != 0
                            && (*((_BYTE *)v3 + 4676) & 0x10) != 0
                            && *((_QWORD *)v3 + 383))
                          {
                            *(_OWORD *)(&v297 - 7) = *(_OWORD *)(*((_QWORD *)v3 + 428) + 8);
                            *(_OWORD *)(&v297 - 5) = *(_OWORD *)(*((_QWORD *)v3 + 505) + 8);
                            *(_OWORD *)(&v297 - 3) = *(_OWORD *)(*((_QWORD *)v3 + 506) + 8);
                            v163 = *((_QWORD *)v3 + 504);
                            v164 = v310;
                            v310->mBuffers[0] = *(AudioBuffer *)(v163 + 8);
                            *(_OWORD *)&v164[1].mNumberBuffers = *(_OWORD *)(v163 + 24);
                            v160 = *(_OWORD *)(v163 + 56);
                            *(_OWORD *)&v164[1].mBuffers[0].mData = v160;
                          }
                          if ((v162 & 0x200000000) == 0 || (*((_BYTE *)v3 + 4676) & 2) == 0 || !*((_QWORD *)v3 + 380))
                          {
LABEL_415:
                            if ((v162 & 0x400000000) == 0
                              || (*((_BYTE *)v3 + 4676) & 4) == 0
                              || !*((_QWORD *)v3 + 381))
                            {
LABEL_428:
                              if ((v162 & 0x1000000000) == 0
                                || (*((_BYTE *)v3 + 4676) & 0x10) == 0
                                || !*((_QWORD *)v3 + 383))
                              {
LABEL_441:
                                if (v121 == 2)
                                {
                                  VoiceProcessorV4::SignalParamSwitchMixNF((AudioUnit *)v3, v125, v122, (BOOL *)&v312, *(AudioUnitParameterValue *)&v160);
                                }
                                else if (v121 == 1)
                                {
                                  VoiceProcessorV2::SignalParamSwitchMix((AudioUnit *)v3, v125, v122, &v312, v159);
                                }
                                if (v124 == 1)
                                  VoiceProcessorV2::TimeAlignedReferenceAndOtherHandling(v3, HIBYTE(v319) != 0, v317, v125, v312 != 0);
                                else
                                  VoiceProcessorV4::TimeAlignedReferenceAndOtherHandlingNF(v3, HIBYTE(v319) != 0, v315, v125, v312 != 0);
                                v179 = (OpaqueAudioComponentInstance *)memcpy(*(void **)(*((_QWORD *)v3 + 432) + 16), *(const void **)(*((_QWORD *)v3 + 504) + 16), *((unsigned int *)v3 + 1071));
                                v180 = *((_QWORD *)v3 + 582);
                                if ((v180 & 0x800000) != 0
                                  && (*((_BYTE *)v3 + 4674) & 0x80) != 0
                                  && *((_QWORD *)v3 + 370)
                                  && v313 == 1.0)
                                {
                                  v179 = (OpaqueAudioComponentInstance *)memcpy(*(void **)(*((_QWORD *)v3 + 2131) + 16), *(const void **)(*((_QWORD *)v3 + 504) + 48), *((unsigned int *)v3 + 1071));
                                  v180 = *((_QWORD *)v3 + 582);
                                }
                                if ((v180 & 0x200000000000) == 0
                                  || (v181 = *((_QWORD *)v3 + 584), (v181 & 0x200000000000) == 0)
                                  || !*((_QWORD *)v3 + 392))
                                {
LABEL_471:
                                  if ((v180 & 0x20000000000000) != 0
                                    && (*((_BYTE *)v3 + 4678) & 0x20) != 0
                                    && *((_QWORD *)v3 + 400))
                                  {
                                    v197 = 1;
                                  }
                                  else
                                  {
                                    v197 = (v180 & 0x80000000000000) != 0
                                        && (*((_BYTE *)v3 + 4678) & 0x80) != 0
                                        && *((_QWORD *)v3 + 402) != 0;
                                  }
                                  LODWORD(v331) = 0;
                                  LODWORD(v328) = 0;
                                  LODWORD(v326) = 0;
                                  AudioUnitGetParameter(*((AudioUnit *)v3 + 389), 0x1Du, 0, 0, (AudioUnitParameterValue *)&v331);
                                  v198 = *(float *)&v331 < 1.0 && v197;
                                  if (v197)
                                  {
                                    LODWORD(inInputBufferLists.mSampleTime) = 1065353216;
                                    if (*(float *)&v331 < 1.0)
                                      vDSP_vfill((const float *)&inInputBufferLists, *(float **)(*((_QWORD *)v3 + 501) + 16), 1, *((unsigned int *)v3 + 127));
                                    vDSP_vfill((const float *)&inInputBufferLists, *(float **)(*((_QWORD *)v3 + 499) + 16), 1, *((unsigned int *)v3 + 127));
                                  }
                                  else if ((*((_BYTE *)v3 + 4661) & 4) == 0
                                         || (*((_BYTE *)v3 + 4677) & 4) == 0
                                         || !*((_QWORD *)v3 + 389))
                                  {
                                    v199 = 0;
                                    goto LABEL_494;
                                  }
                                  if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x61u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 428), &buf);
                                  v199 = 1;
LABEL_494:
                                  v200 = (AudioBufferList *)*((_QWORD *)v3 + 500);
                                  v201 = *((_QWORD *)v3 + 582);
                                  if ((v201 & 0x20000000000000) != 0
                                    && (*((_BYTE *)v3 + 4678) & 0x20) != 0
                                    && (v202 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 400)) != 0)
                                  {
                                    v203 = *((_QWORD *)v3 + 499);
                                    v330.mSampleTime = *((Float64 *)v3 + 428);
                                    v330.mHostTime = v203;
                                    *(_QWORD *)&v330.mRateScalar = (char *)v3 + 16808;
                                    v204 = *((_QWORD *)v3 + 501);
                                    *(_QWORD *)&v333.mNumberBuffers = *((_QWORD *)v3 + 429);
                                    *(_QWORD *)&v333.mBuffers[0].mNumberChannels = v204;
                                    v333.mBuffers[0].mData = v200;
                                    v320 = 512;
                                    v205 = *(_OWORD *)&a2->mRateScalar;
                                    *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                    *(_OWORD *)&inInputBufferLists.mRateScalar = v205;
                                    v206 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                    *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                    *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v206;
                                    AudioUnitProcessMultiple(v202, &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 3u, (const AudioBufferList **)&v330, 3u, (AudioBufferList **)&v333);
                                    AudioUnitGetParameter(*((AudioUnit *)v3 + 400), 1u, 0, 0, (AudioUnitParameterValue *)&v328);
                                    if ((*((_BYTE *)v3 + 4664) & 2) == 0
                                      || (*((_BYTE *)v3 + 4680) & 2) == 0
                                      || !*((_QWORD *)v3 + 412))
                                    {
                                      goto LABEL_509;
                                    }
                                    v207 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 400);
                                    v208 = 2;
                                  }
                                  else
                                  {
                                    if ((v201 & 0x80000000000000) == 0
                                      || (*((_BYTE *)v3 + 4678) & 0x80) == 0
                                      || (v209 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 402)) == 0)
                                    {
                                      v214 = 1;
                                      goto LABEL_514;
                                    }
                                    AudioUnitSetParameter(v209, 0x14u, 0, 0, *((AudioUnitParameterValue *)v3 + 4172), 0);
                                    v210 = *((_QWORD *)v3 + 431);
                                    v330.mSampleTime = *((Float64 *)v3 + 428);
                                    v330.mHostTime = v210;
                                    v330.mRateScalar = *((Float64 *)v3 + 499);
                                    v330.mWordClockTime = (UInt64)v3 + 16808;
                                    v211 = *((_QWORD *)v3 + 436);
                                    *(_QWORD *)&v333.mNumberBuffers = *((_QWORD *)v3 + 429);
                                    *(_QWORD *)&v333.mBuffers[0].mNumberChannels = v211;
                                    v333.mBuffers[0].mData = (void *)*((_QWORD *)v3 + 501);
                                    v334 = v200;
                                    v212 = *(_OWORD *)&a2->mRateScalar;
                                    *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                    *(_OWORD *)&inInputBufferLists.mRateScalar = v212;
                                    v213 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                    *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                    *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v213;
                                    v320 = 512;
                                    AudioUnitProcessMultiple(*((AudioUnit *)v3 + 402), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 4u, (const AudioBufferList **)&v330, 4u, (AudioBufferList **)&v333);
                                    AudioUnitGetParameter(*((AudioUnit *)v3 + 402), 2u, 0, 0, (AudioUnitParameterValue *)&v328);
                                    if ((*((_BYTE *)v3 + 4664) & 2) == 0
                                      || (*((_BYTE *)v3 + 4680) & 2) == 0
                                      || !*((_QWORD *)v3 + 412))
                                    {
LABEL_509:
                                      if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x27u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 429), &inInputBufferLists);
                                      v214 = 0;
LABEL_514:
                                      v215 = *((_QWORD *)v3 + 582);
                                      if ((v215 & 0x200000000000000) != 0 && (*((_BYTE *)v3 + 4679) & 2) != 0)
                                      {
                                        v216 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 404);
                                        if (v216)
                                        {
                                          LODWORD(v310) = v214;
                                          v307 = v200;
                                          v217 = v198;
                                          v218 = v199;
                                          v330.mSampleTime = *((Float64 *)v3 + 428);
                                          *(_QWORD *)&v333.mNumberBuffers = 0;
                                          v219 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v219;
                                          v220 = *(_OWORD *)&a2->mRateScalar;
                                          *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                          *(_OWORD *)&inInputBufferLists.mRateScalar = v220;
                                          v320 = 512;
                                          v221 = *((_QWORD *)v3 + 502);
                                          v222 = *(void **)(v221 + 16);
                                          v223 = *(_DWORD *)(v221 + 12);
                                          if ((AudioUnitProcessMultiple(v216, &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)&v330, 1u, (AudioBufferList **)&v333)|| AudioUnitGetProperty(*((AudioUnit *)v3 + 404), 0x13EDu, 0, 0, *(void **)(*((_QWORD *)v3 + 502) + 16), (UInt32 *)(*((_QWORD *)v3 + 502) + 12)))&& v223 >= 4)
                                          {
                                            memset_pattern16(v222, &unk_1B6627B80, v223 & 0xFFFFFFFC);
                                          }
                                          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x52u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 502), &inInputBufferLists);
                                          v215 = *((_QWORD *)v3 + 582);
                                          v199 = v218;
                                          v198 = v217;
                                          v200 = (AudioBufferList *)v307;
                                          v214 = (int)v310;
                                        }
                                      }
                                      if ((v215 & 0x400000000000000) != 0 && (*((_BYTE *)v3 + 4679) & 4) != 0)
                                      {
                                        if (*((_QWORD *)v3 + 405))
                                        {
                                          v224 = *(_DWORD *)(v308 + 280);
                                          if (v224)
                                          {
                                            LODWORD(v310) = v214;
                                            if (v224 == 1)
                                            {
                                              v225 = (uint64_t *)((char *)v3 + 1104);
                                              v226 = (uint64_t *)((char *)v3 + 1128);
                                            }
                                            else
                                            {
                                              v225 = (uint64_t *)((char *)v3 + 1112);
                                              v226 = (uint64_t *)((char *)v3 + 1120);
                                            }
                                            v227 = *v226;
                                            v228 = *v225;
                                            v229 = *((_QWORD *)v3 + 2142);
                                            v230 = *((unsigned int *)v3 + 127);
                                            v330.mSampleTime = *(Float64 *)(v229 + 16);
                                            v330.mHostTime = *(_QWORD *)&v330.mSampleTime + 4 * v230;
                                            v231 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 2146);
                                            if (v231)
                                            {
                                              VPTimeFreqConverter::Analyze(v231, *(const float **)(v228 + 40), (DSPSplitComplex *)&v330);
                                              v229 = *((_QWORD *)v3 + 2142);
                                              v230 = *((unsigned int *)v3 + 127);
                                            }
                                            LODWORD(v308) = v199;
                                            v330.mSampleTime = *(Float64 *)(v229 + 32);
                                            v330.mHostTime = *(_QWORD *)&v330.mSampleTime + 4 * v230;
                                            v232 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 2147);
                                            if (v232)
                                            {
                                              VPTimeFreqConverter::Analyze(v232, *(const float **)(v227 + 40), (DSPSplitComplex *)&v330);
                                              v229 = *((_QWORD *)v3 + 2142);
                                              LODWORD(v230) = *((_DWORD *)v3 + 127);
                                            }
                                            *(_QWORD *)&v333.mNumberBuffers = v229;
                                            *(_QWORD *)ioDataSize = v229;
                                            v320 = 512;
                                            v233 = *(_OWORD *)&a2->mRateScalar;
                                            *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                            *(_OWORD *)&inInputBufferLists.mRateScalar = v233;
                                            v234 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                            *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                            *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v234;
                                            v235 = AudioUnitProcessMultiple(*((AudioUnit *)v3 + 405), &v320, &inInputBufferLists, v230, 1u, (const AudioBufferList **)&v333, 1u, (AudioBufferList **)ioDataSize);
                                            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x6Du, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 2142), &inInputBufferLists);
                                            v236 = *((_QWORD *)v3 + 2143);
                                            v239 = *(_DWORD *)(v236 + 12);
                                            v237 = v236 + 12;
                                            v238 = v239;
                                            v240 = *(void **)(v237 + 4);
                                            if ((v235
                                               || AudioUnitGetProperty(*((AudioUnit *)v3 + 405), 0x15FEu, 0, 0, *(void **)(v237 + 4), (UInt32 *)v237))&& v238 >= 4)
                                            {
                                              memset_pattern16(v240, &unk_1B6627B80, v238 & 0xFFFFFFFC);
                                            }
                                            LOBYTE(v199) = v308;
                                            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x6Eu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 2143), &inInputBufferLists);
                                            v215 = *((_QWORD *)v3 + 582);
                                            v214 = (int)v310;
                                          }
                                        }
                                      }
                                      if ((v215 & 0x40000000000) == 0)
                                        goto LABEL_586;
                                      if ((*((_BYTE *)v3 + 4677) & 4) == 0
                                        || (v241 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 389)) == 0)
                                      {
LABEL_578:
                                        if ((*((_BYTE *)v3 + 4677) & 4) != 0 && *((_QWORD *)v3 + 389) && v198)
                                        {
                                          v256 = *(float **)(*((_QWORD *)v3 + 501) + 16);
                                          vDSP_vmin(*(const float **)(*((_QWORD *)v3 + 499) + 16), 1, v256, 1, v256, 1, *((unsigned int *)v3 + 127));
                                          v257 = *((_QWORD *)v3 + 582);
                                          if ((v257 & 0x200000000000000) != 0
                                            && (*((_BYTE *)v3 + 4679) & 2) != 0
                                            && *((_QWORD *)v3 + 404))
                                          {
                                            vDSP_vmin(*(const float **)(*((_QWORD *)v3 + 502) + 16), 1, v256, 1, v256, 1, *((unsigned int *)v3 + 127));
                                            v257 = *((_QWORD *)v3 + 582);
                                          }
                                          v260 = v199;
                                          if ((v257 & 0x400000000000000) != 0
                                            && (*((_BYTE *)v3 + 4679) & 4) != 0
                                            && *((_QWORD *)v3 + 405))
                                          {
                                            vDSP_vmin(*(const float **)(*((_QWORD *)v3 + 2143) + 16), 1, v256, 1, v256, 1, *((unsigned int *)v3 + 127));
                                          }
                                          v261 = *(const float **)(*((_QWORD *)v3 + 428) + 16);
                                          v262 = *(float **)(*((_QWORD *)v3 + 429) + 16);
                                          vDSP_vmul(v261, 1, v256, 1, v262, 1, *((unsigned int *)v3 + 127));
                                          vDSP_vmul(&v261[*((unsigned int *)v3 + 127) + 1], 1, v256 + 1, 1, &v262[*((unsigned int *)v3 + 127) + 1], 1, (*((_DWORD *)v3 + 127) - 1));
                                          v261[*((unsigned int *)v3 + 127)] = v261[*((unsigned int *)v3 + 127)]
                                                                            * v256[*((_DWORD *)v3 + 127) - 1];
                                          if ((v260 & 1) != 0)
                                            goto LABEL_590;
                                          goto LABEL_602;
                                        }
                                        if ((*((_BYTE *)v3 + 4677) & 4) != 0)
                                        {
                                          v258 = *((_QWORD *)v3 + 389) != 0;
LABEL_587:
                                          if (!v258 && !v197)
                                          {
                                            LODWORD(inInputBufferLists.mSampleTime) = 1065353216;
                                            v259 = *((_DWORD *)v3 + 127);
                                            vDSP_vfill((const float *)&inInputBufferLists, *(float **)(*((_QWORD *)v3 + 501) + 16), 1, v259);
                                            memcpy(*(void **)(*((_QWORD *)v3 + 429) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 8 * v259);
                                          }
                                          if ((v199 & 1) != 0)
                                            goto LABEL_590;
LABEL_602:
                                          if ((*((_BYTE *)v3 + 4661) & 4) == 0
                                            || (*((_BYTE *)v3 + 4677) & 4) == 0
                                            || !*((_QWORD *)v3 + 389))
                                          {
LABEL_605:
                                            if ((*((_BYTE *)v3 + 4663) & 0x10) != 0
                                              && (*((_BYTE *)v3 + 4679) & 0x10) != 0)
                                            {
                                              v263 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 407);
                                              if (v263)
                                              {
                                                AudioUnitSetParameter(v263, 0, 0, 0, *((AudioUnitParameterValue *)v3 + 3117), 0);
                                                AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 4u, 0, 0, *((AudioUnitParameterValue *)v3 + 1046), 0);
                                                AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 0x13u, 0, 0, *((AudioUnitParameterValue *)v3 + 1050), 0);
                                                AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 3u, 0, 0, *(AudioUnitParameterValue *)&v328, 0);
                                                AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 0xEu, 0, 0, (float)*((int *)v3 + 576), 0);
                                                v264 = *((_QWORD *)v3 + 510);
                                                v330.mSampleTime = *((Float64 *)v3 + 418);
                                                v330.mHostTime = v264;
                                                v330.mRateScalar = *((Float64 *)v3 + 429);
                                                v265 = *((_QWORD *)v3 + 499);
                                                v330.mWordClockTime = *((_QWORD *)v3 + 509);
                                                *(_QWORD *)&v330.mSMPTETime.mSubframes = v265;
                                                *(_QWORD *)&v330.mSMPTETime.mType = *((_QWORD *)v3 + 501);
                                                *(_QWORD *)&v333.mNumberBuffers = *((_QWORD *)v3 + 136);
                                                v320 = 512;
                                                v266 = *(_OWORD *)&a2->mRateScalar;
                                                *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                                *(_OWORD *)&inInputBufferLists.mRateScalar = v266;
                                                v267 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                                *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                                *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v267;
                                                AudioUnitProcessMultiple(*((AudioUnit *)v3 + 407), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)&v330, 1u, (AudioBufferList **)&v333);
                                                ioDataSize[0] = 0;
                                                AudioUnitGetParameter(*((AudioUnit *)v3 + 407), 1u, 0, 0, (AudioUnitParameterValue *)ioDataSize);
                                                *((_DWORD *)v3 + 3118) = ioDataSize[0];
                                                if ((*((_BYTE *)v3 + 4664) & 2) != 0
                                                  && (*((_BYTE *)v3 + 4680) & 2) != 0
                                                  && *((_QWORD *)v3 + 412))
                                                {
                                                  AudioUnitGetParameter(*((AudioUnit *)v3 + 407), 2u, 0, 0, (AudioUnitParameterValue *)&v328);
                                                  AudioUnitSetParameter(*((AudioUnit *)v3 + 412), 0x23u, 0, 0, *(AudioUnitParameterValue *)&v328, 0);
                                                }
                                              }
                                            }
                                            goto LABEL_612;
                                          }
LABEL_590:
                                          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x60u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 429), &buf);
                                          goto LABEL_605;
                                        }
LABEL_586:
                                        v258 = 0;
                                        goto LABEL_587;
                                      }
                                      AudioUnitSetParameter(v241, 6u, 0, 0, *((AudioUnitParameterValue *)v3 + 1054), 0);
                                      AudioUnitSetParameter(*((AudioUnit *)v3 + 389), 7u, 0, 0, *((AudioUnitParameterValue *)v3 + 1058), 0);
                                      AudioUnitSetParameter(*((AudioUnit *)v3 + 389), 0xDu, 0, 0, *((AudioUnitParameterValue *)v3 + 1062), 0);
                                      v242 = *((_QWORD *)v3 + 432);
                                      v330.mSampleTime = *((Float64 *)v3 + 428);
                                      v330.mHostTime = v242;
                                      v330.mRateScalar = *((Float64 *)v3 + 511);
                                      v330.mWordClockTime = *((_QWORD *)v3 + 501);
                                      *(_QWORD *)&v330.mSMPTETime.mSubframes = v200;
                                      *(_QWORD *)&v330.mSMPTETime.mType = 0;
                                      if (!v198)
                                        v330.mWordClockTime = 0;
                                      v243 = *((_QWORD *)v3 + 509);
                                      *(_QWORD *)&v333.mNumberBuffers = 0;
                                      *(_QWORD *)&v333.mBuffers[0].mNumberChannels = v243;
                                      v333.mBuffers[0].mData = 0;
                                      v244 = *((_QWORD *)v3 + 582);
                                      if ((v244 & 0x2000000) != 0
                                        && (v245 = *((_QWORD *)v3 + 584), (v245 & 0x2000000) != 0)
                                        && (v247 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 372)) != 0
                                        && (v244 & v245 & 0x200000) != 0
                                        && *((_QWORD *)v3 + 368))
                                      {
                                        v246 = v214;
                                        LODWORD(inInputBufferLists.mSampleTime) = 0;
                                        *(_QWORD *)&v330.mSMPTETime.mType = *((_QWORD *)v3 + 507);
                                        AudioUnitGetParameter(v247, 0x2Du, 0, 0, (AudioUnitParameterValue *)&inInputBufferLists);
                                        AudioUnitSetParameter(*((AudioUnit *)v3 + 389), 0x2Au, 0, 0, *(AudioUnitParameterValue *)&inInputBufferLists.mSampleTime, 0);
                                        AudioUnitGetParameter(*((AudioUnit *)v3 + 368), 0x2Du, 0, 0, (AudioUnitParameterValue *)&inInputBufferLists);
                                        AudioUnitSetParameter(*((AudioUnit *)v3 + 389), 0x29u, 0, 0, *(AudioUnitParameterValue *)&inInputBufferLists.mSampleTime, 0);
                                      }
                                      else
                                      {
                                        v246 = v214;
                                        if ((v244 & 0x800000) != 0
                                          && (*((_BYTE *)v3 + 4674) & 0x80) != 0
                                          && *((_QWORD *)v3 + 370)
                                          && v313 == 1.0)
                                        {
                                          *(_QWORD *)&v330.mSMPTETime.mType = *((_QWORD *)v3 + 2131);
                                        }
                                      }
                                      v248 = 4008;
                                      if (v198)
                                        v248 = 3992;
                                      v249 = *(void **)((char *)v3 + v248);
                                      if (v198)
                                        v250 = 3448;
                                      else
                                        v250 = 3432;
                                      *(_QWORD *)&v333.mNumberBuffers = *(_QWORD *)((char *)v3 + v250);
                                      v333.mBuffers[0].mData = v249;
                                      v251 = *(_OWORD *)&a2->mRateScalar;
                                      *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                      *(_OWORD *)&inInputBufferLists.mRateScalar = v251;
                                      v252 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                      *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                      *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v252;
                                      v320 = 512;
                                      AudioUnitProcessMultiple(*((AudioUnit *)v3 + 389), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)&v330, 3u, (AudioBufferList **)&v333);
                                      if ((v246 | !v198) == 1)
                                        AudioUnitGetParameter(*((AudioUnit *)v3 + 389), 0x20u, 0, 0, (AudioUnitParameterValue *)&v328);
                                      v253 = *((unsigned int *)v3 + 127);
                                      if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                      {
                                        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x24u, v253, *(const AudioBufferList **)((char *)v3 + v250), &inInputBufferLists);
                                        v253 = *((unsigned int *)v3 + 127);
                                        v254 = (const AudioBufferList *)*((_QWORD *)v3 + 499);
                                        if (*((_BYTE *)v3 + 15897))
                                        {
LABEL_576:
                                          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Fu, v253, v254, &inInputBufferLists);
LABEL_577:
                                          if ((*((_BYTE *)v3 + 4661) & 4) == 0)
                                            goto LABEL_586;
                                          goto LABEL_578;
                                        }
                                      }
                                      else
                                      {
                                        v254 = (const AudioBufferList *)*((_QWORD *)v3 + 499);
                                      }
                                      if (!*((_BYTE *)v3 + 15898))
                                        goto LABEL_577;
                                      goto LABEL_576;
                                    }
                                    v207 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 402);
                                    v208 = 9;
                                  }
                                  AudioUnitGetParameter(v207, v208, 0, 0, (AudioUnitParameterValue *)&v326);
                                  AudioUnitSetParameter(*((AudioUnit *)v3 + 412), 0x12u, 0, 0, *(AudioUnitParameterValue *)&v326, 0);
                                  goto LABEL_509;
                                }
                                ioDataSize[0] = 1092616192;
                                if ((v180 & v181 & 0x80000000000000) != 0)
                                {
                                  v179 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 402);
                                  if (v179)
                                  {
                                    v179 = (OpaqueAudioComponentInstance *)AudioUnitGetParameter(v179, 9u, 0, 0, (AudioUnitParameterValue *)ioDataSize);
                                    v180 = *((_QWORD *)v3 + 582);
                                  }
                                }
                                if ((v180 & 0x80000000) != 0
                                  && (*((_BYTE *)v3 + 4675) & 0x80) != 0
                                  && *((_QWORD *)v3 + 378))
                                {
                                  LODWORD(inInputBufferLists.mSampleTime) = 0;
                                  LODWORD(v330.mSampleTime) = 0;
                                  v333.mNumberBuffers = 0;
                                  AudioUnitGetParameter(*((AudioUnit *)v3 + 379), 0x18u, 0, 0, (AudioUnitParameterValue *)&inInputBufferLists);
                                  AudioUnitGetParameter(*((AudioUnit *)v3 + 379), 0x19u, 0, 0, (AudioUnitParameterValue *)&v330);
                                  AudioUnitGetParameter(*((AudioUnit *)v3 + 379), 5u, 0, 0, (AudioUnitParameterValue *)&v333.mNumberBuffers);
                                  AudioUnitSetParameter(*((AudioUnit *)v3 + 392), 3u, 0, 0, *(AudioUnitParameterValue *)&inInputBufferLists.mSampleTime, 0);
                                  AudioUnitSetParameter(*((AudioUnit *)v3 + 392), 4u, 0, 0, *(AudioUnitParameterValue *)&v330.mSampleTime, 0);
                                  AudioUnitSetParameter(*((AudioUnit *)v3 + 392), 5u, 0, 0, *(AudioUnitParameterValue *)&v333.mNumberBuffers, 0);
                                  v179 = (OpaqueAudioComponentInstance *)AudioUnitSetParameter(*((AudioUnit *)v3 + 392), 6u, 0, 0, *(AudioUnitParameterValue *)ioDataSize, 0);
                                }
                                MEMORY[0x1E0C80A78](v179);
                                v296 = 0;
                                *((_OWORD *)&v297 - 3) = 0u;
                                *((_OWORD *)&v297 - 2) = 0u;
                                *((_DWORD *)&v297 - 12) = 2;
                                v182 = *((_QWORD *)v3 + 428);
                                *(&v297 - 4) = *(_QWORD *)(v182 + 16);
                                *(&v297 - 5) = *(_QWORD *)(v182 + 8);
                                v183 = *((_QWORD *)v3 + 431);
                                v296 = *(_QWORD *)(v183 + 16);
                                *(&v297 - 3) = *(_QWORD *)(v183 + 8);
                                *(double *)&v185 = MEMORY[0x1E0C80A78](v184);
                                *((_OWORD *)&v297 - 3) = v185;
                                *((_OWORD *)&v297 - 2) = v185;
                                *((_DWORD *)&v297 - 12) = v186;
                                MEMORY[0x1E0C80A78](v187);
                                *(&v297 - 3) = 0;
                                v296 = 0;
                                *(&v297 - 4) = 0;
                                *((_DWORD *)&v297 - 8) = 1;
                                v188 = *((_QWORD *)v3 + 432);
                                *(_QWORD *)(v189 - 32) = *(_QWORD *)(v188 + 16);
                                *(_QWORD *)(v189 - 40) = *(_QWORD *)(v188 + 8);
                                v190 = *((_QWORD *)v3 + 504);
                                *(_QWORD *)(v189 - 16) = *(_QWORD *)(v190 + 32);
                                *(_QWORD *)(v189 - 24) = *(_QWORD *)(v190 + 24);
                                v296 = *(_QWORD *)(v188 + 16);
                                *(&v297 - 3) = *(_QWORD *)(v188 + 8);
                                v330.mSampleTime = v191;
                                v330.mHostTime = v192;
                                *(Float64 *)&v333.mNumberBuffers = v191;
                                *(_QWORD *)&v333.mBuffers[0].mNumberChannels = &v297 - 4;
                                v193 = *(_OWORD *)&a2->mRateScalar;
                                *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                                *(_OWORD *)&inInputBufferLists.mRateScalar = v193;
                                v194 = *(_OWORD *)&a2->mSMPTETime.mHours;
                                *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                                *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v194;
                                v320 = 512;
                                AudioUnitProcessMultiple(*((AudioUnit *)v3 + 392), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&v330, 2u, (AudioBufferList **)&v333);
                                v195 = *((unsigned int *)v3 + 127);
                                if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                                {
                                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x81u, v195, *((const AudioBufferList **)v3 + 428), &inInputBufferLists);
                                  v195 = *((unsigned int *)v3 + 127);
                                  v196 = (const AudioBufferList *)*((_QWORD *)v3 + 431);
                                  if (*((_BYTE *)v3 + 15897))
                                    goto LABEL_469;
                                }
                                else
                                {
                                  v196 = (const AudioBufferList *)*((_QWORD *)v3 + 431);
                                }
                                if (!*((_BYTE *)v3 + 15898))
                                {
LABEL_470:
                                  v180 = *((_QWORD *)v3 + 582);
                                  goto LABEL_471;
                                }
LABEL_469:
                                VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x82u, v195, v196, &inInputBufferLists);
                                goto LABEL_470;
                              }
                              v307 = v157;
                              v303 = v124;
                              v304 = v125;
                              v305 = v121;
                              v306 = v122;
                              v173 = 0;
                              v174 = (AudioBufferList *)*((_QWORD *)v3 + 523);
                              v299 = (AudioUnitParameterValue *)((char *)v3 + 4184);
                              v331 = v174;
                              LODWORD(v332) = *((_DWORD *)v3 + 1049);
                              v300 = (AudioUnitParameterValue *)((char *)v3 + 4200);
                              v328 = (const AudioBufferList *)*((_QWORD *)v3 + 525);
                              v329 = *((_DWORD *)v3 + 1053);
                              v301 = (AudioUnitParameterValue *)((char *)v3 + 4216);
                              v326 = *((_QWORD *)v3 + 527);
                              v327 = *((_DWORD *)v3 + 1057);
                              v302 = (AudioUnitParameterValue *)((char *)v3 + 4232);
                              v324 = *((_QWORD *)v3 + 529);
                              v325 = *((_DWORD *)v3 + 1061);
                              v298 = (AudioUnitParameterValue *)((char *)v3 + 4248);
                              v322 = *((_QWORD *)v3 + 531);
                              v323 = *((_DWORD *)v3 + 1065);
                              do
                              {
                                AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x64u, 4u, v173, *((AudioUnitParameterValue *)&v331 + v173), 0);
                                AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x65u, 4u, v173, *((AudioUnitParameterValue *)&v328 + v173), 0);
                                AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x66u, 4u, v173, *((AudioUnitParameterValue *)&v326 + v173), 0);
                                AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x67u, 4u, v173, *((AudioUnitParameterValue *)&v324 + v173), 0);
                                AudioUnitSetParameter(*((AudioUnit *)v3 + 383), 0x68u, 4u, v173, *((AudioUnitParameterValue *)&v322 + v173), 0);
                                ++v173;
                              }
                              while (v173 != 3);
                              *(_QWORD *)&v333.mNumberBuffers = 1;
                              *(_QWORD *)&v333.mBuffers[0].mNumberChannels = 0;
                              v333.mBuffers[0].mData = 0;
                              v333.mBuffers[0] = *(AudioBuffer *)(*((_QWORD *)v3 + 504) + 8);
                              *(_QWORD *)ioDataSize = v307;
                              v337 = v310;
                              v330.mSampleTime = *((Float64 *)v3 + 428);
                              v330.mHostTime = (UInt64)&v333;
                              v330.mWordClockTime = 0;
                              v330.mRateScalar = 0.0;
                              v320 = 512;
                              v175 = *(_OWORD *)&a2->mRateScalar;
                              *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                              *(_OWORD *)&inInputBufferLists.mRateScalar = v175;
                              v176 = *(_OWORD *)&a2->mSMPTETime.mHours;
                              *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                              *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v176;
                              AudioUnitProcessMultiple(*((AudioUnit *)v3 + 383), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)ioDataSize, 4u, (AudioBufferList **)&v330);
                              v311 = 0.0;
                              AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0xAu, 0, 0, &v311);
                              v177 = *((unsigned int *)v3 + 127);
                              if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                              {
                                VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x64u, v177, *((const AudioBufferList **)v3 + 428), &inInputBufferLists);
                                v177 = *((unsigned int *)v3 + 127);
                                v121 = v305;
                                v122 = v306;
                                v124 = v303;
                                v125 = v304;
                                v178 = v298;
                                if (*((_BYTE *)v3 + 15897))
                                  goto LABEL_439;
                              }
                              else
                              {
                                v121 = v305;
                                v122 = v306;
                                v124 = v303;
                                v125 = v304;
                                v178 = v298;
                              }
                              if (!*((_BYTE *)v3 + 15898))
                              {
LABEL_440:
                                AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x64u, 4u, 0, v299);
                                AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x65u, 4u, 0, v300);
                                AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x66u, 4u, 0, v301);
                                AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x67u, 4u, 0, v302);
                                AudioUnitGetParameter(*((AudioUnit *)v3 + 383), 0x68u, 4u, 0, v178);
                                goto LABEL_441;
                              }
LABEL_439:
                              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x65u, v177, &v333, &inInputBufferLists);
                              goto LABEL_440;
                            }
                            v307 = v157;
                            v303 = v124;
                            v304 = v125;
                            v305 = v121;
                            v306 = v122;
                            v169 = 0;
                            *(_QWORD *)ioDataSize = *((_QWORD *)v3 + 523);
                            LODWORD(v337) = *((_DWORD *)v3 + 1049);
                            v331 = (AudioBufferList *)*((_QWORD *)v3 + 525);
                            LODWORD(v332) = *((_DWORD *)v3 + 1053);
                            v328 = (const AudioBufferList *)*((_QWORD *)v3 + 527);
                            v329 = *((_DWORD *)v3 + 1057);
                            v326 = *((_QWORD *)v3 + 529);
                            v327 = *((_DWORD *)v3 + 1061);
                            v324 = *((_QWORD *)v3 + 531);
                            v325 = *((_DWORD *)v3 + 1065);
                            do
                            {
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x12u, 4u, v169, *(AudioUnitParameterValue *)&ioDataSize[v169], 0);
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x13u, 4u, v169, *((AudioUnitParameterValue *)&v331 + v169), 0);
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x14u, 4u, v169, *((AudioUnitParameterValue *)&v328 + v169), 0);
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x15u, 4u, v169, *((AudioUnitParameterValue *)&v326 + v169), 0);
                              AudioUnitSetParameter(*((AudioUnit *)v3 + 381), 0x16u, 4u, v169, *((AudioUnitParameterValue *)&v324 + v169), 0);
                              ++v169;
                            }
                            while (v169 != 3);
                            v157 = v307;
                            *(_QWORD *)&v330.mSampleTime = v307;
                            v330.mHostTime = (UInt64)v310;
                            *(_QWORD *)&v333.mNumberBuffers = v307;
                            *(_QWORD *)&v333.mBuffers[0].mNumberChannels = v310;
                            v320 = 512;
                            v170 = *(_OWORD *)&a2->mRateScalar;
                            *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                            *(_OWORD *)&inInputBufferLists.mRateScalar = v170;
                            v171 = *(_OWORD *)&a2->mSMPTETime.mHours;
                            *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                            *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v171;
                            AudioUnitProcessMultiple(*((AudioUnit *)v3 + 381), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&v330, 2u, (AudioBufferList **)&v333);
                            v172 = *((unsigned int *)v3 + 127);
                            if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                            {
                              VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x6Bu, v172, v157, &inInputBufferLists);
                              v172 = *((unsigned int *)v3 + 127);
                              v121 = v305;
                              v122 = v306;
                              v124 = v303;
                              v125 = v304;
                              if (*((_BYTE *)v3 + 15897))
                                goto LABEL_426;
                            }
                            else
                            {
                              v121 = v305;
                              v122 = v306;
                              v124 = v303;
                              v125 = v304;
                            }
                            if (!*((_BYTE *)v3 + 15898))
                            {
LABEL_427:
                              v162 = *((_QWORD *)v3 + 582);
                              goto LABEL_428;
                            }
LABEL_426:
                            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x6Cu, v172, v310, &inInputBufferLists);
                            goto LABEL_427;
                          }
                          v307 = (const AudioBufferList *)(&v297 - 8);
                          v303 = v124;
                          v304 = v125;
                          v305 = v121;
                          v306 = v122;
                          v165 = 0;
                          *(_QWORD *)ioDataSize = *((_QWORD *)v3 + 523);
                          LODWORD(v337) = *((_DWORD *)v3 + 1049);
                          v331 = (AudioBufferList *)*((_QWORD *)v3 + 525);
                          LODWORD(v332) = *((_DWORD *)v3 + 1053);
                          v328 = (const AudioBufferList *)*((_QWORD *)v3 + 527);
                          v329 = *((_DWORD *)v3 + 1057);
                          v326 = *((_QWORD *)v3 + 529);
                          v327 = *((_DWORD *)v3 + 1061);
                          v324 = *((_QWORD *)v3 + 531);
                          v325 = *((_DWORD *)v3 + 1065);
                          do
                          {
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 9u, 4u, v165, *(AudioUnitParameterValue *)&ioDataSize[v165], 0);
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 0xAu, 4u, v165, *((AudioUnitParameterValue *)&v331 + v165), 0);
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 0xBu, 4u, v165, *((AudioUnitParameterValue *)&v328 + v165), 0);
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 0xCu, 4u, v165, *((AudioUnitParameterValue *)&v326 + v165), 0);
                            AudioUnitSetParameter(*((AudioUnit *)v3 + 380), 0xDu, 4u, v165, *((AudioUnitParameterValue *)&v324 + v165), 0);
                            ++v165;
                          }
                          while (v165 != 3);
                          v157 = v307;
                          *(_QWORD *)&v330.mSampleTime = v307;
                          v330.mHostTime = (UInt64)v310;
                          *(_QWORD *)&v333.mNumberBuffers = v307;
                          *(_QWORD *)&v333.mBuffers[0].mNumberChannels = v310;
                          v320 = 512;
                          v166 = *(_OWORD *)&a2->mRateScalar;
                          *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                          *(_OWORD *)&inInputBufferLists.mRateScalar = v166;
                          v167 = *(_OWORD *)&a2->mSMPTETime.mHours;
                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                          *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v167;
                          AudioUnitProcessMultiple(*((AudioUnit *)v3 + 380), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&v330, 2u, (AudioBufferList **)&v333);
                          v168 = *((unsigned int *)v3 + 127);
                          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                          {
                            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x69u, v168, v157, &inInputBufferLists);
                            v168 = *((unsigned int *)v3 + 127);
                            v121 = v305;
                            v122 = v306;
                            v124 = v303;
                            v125 = v304;
                            if (*((_BYTE *)v3 + 15897))
                              goto LABEL_413;
                          }
                          else
                          {
                            v121 = v305;
                            v122 = v306;
                            v124 = v303;
                            v125 = v304;
                          }
                          if (!*((_BYTE *)v3 + 15898))
                          {
LABEL_414:
                            v162 = *((_QWORD *)v3 + 582);
                            goto LABEL_415;
                          }
LABEL_413:
                          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x6Au, v168, v310, &inInputBufferLists);
                          goto LABEL_414;
                        }
                        if ((v112 & 0x80000000) == 0 || (*((_BYTE *)v3 + 4675) & 0x80) == 0 || !*((_QWORD *)v3 + 378))
                          goto LABEL_392;
                        memcpy(*(void **)(*((_QWORD *)v3 + 434) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 8 * *((unsigned int *)v3 + 127));
                        memcpy(*(void **)(*((_QWORD *)v3 + 434) + 32), *(const void **)(*((_QWORD *)v3 + 506) + 16), 8 * *((unsigned int *)v3 + 127));
                        v328 = (const AudioBufferList *)*((_QWORD *)v3 + 434);
                        v145 = (const AudioBufferList *)*((_QWORD *)v3 + 433);
                        *(_QWORD *)ioDataSize = *((_QWORD *)v3 + 429);
                        v337 = v145;
                        v146 = *(_OWORD *)&a2->mRateScalar;
                        *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                        *(_OWORD *)&inInputBufferLists.mRateScalar = v146;
                        v147 = *(_OWORD *)&a2->mSMPTETime.mHours;
                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                        *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v147;
                        Parameter = AudioUnitProcessMultiple(*((AudioUnit *)v3 + 378), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 1u, &v328, 2u, (AudioBufferList **)ioDataSize);
                        v148 = *((unsigned int *)v3 + 127);
                        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                        {
                          Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x18u, v148, *(const AudioBufferList **)ioDataSize, &inInputBufferLists);
                          v148 = *((unsigned int *)v3 + 127);
                          v149 = v337;
                          if (*((_BYTE *)v3 + 15897))
                            goto LABEL_377;
                        }
                        else
                        {
                          v149 = v337;
                        }
                        if (!*((_BYTE *)v3 + 15898))
                        {
LABEL_378:
                          if ((*((_BYTE *)v3 + 4660) & 1) == 0
                            || (*((_BYTE *)v3 + 4676) & 1) == 0
                            || !*((_QWORD *)v3 + 379))
                          {
                            goto LABEL_392;
                          }
                          memcpy(*(void **)(*((_QWORD *)v3 + 435) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
                          memcpy(*(void **)(*((_QWORD *)v3 + 430) + 16), *(const void **)(*((_QWORD *)v3 + 431) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
                          LODWORD(v326) = 1092616192;
                          v150 = *((_QWORD *)v3 + 433);
                          *(_QWORD *)&v333.mNumberBuffers = *((_QWORD *)v3 + 429);
                          *(_QWORD *)&v333.mBuffers[0].mNumberChannels = v150;
                          v151 = (AudioBufferList *)*((_QWORD *)v3 + 506);
                          v333.mBuffers[0].mData = (void *)*((_QWORD *)v3 + 435);
                          v334 = v151;
                          v335 = *((_QWORD *)v3 + 430);
                          v152 = (const AudioBufferList *)*((_QWORD *)v3 + 431);
                          v153 = 10.0;
                          v331 = (AudioBufferList *)*((_QWORD *)v3 + 428);
                          v332 = v152;
                          if ((*((_BYTE *)v3 + 4662) & 0x80) != 0 && (*((_BYTE *)v3 + 4678) & 0x80) != 0)
                          {
                            v154 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 402);
                            if (v154)
                            {
                              AudioUnitGetParameter(v154, 9u, 0, 0, (AudioUnitParameterValue *)&v326);
                              v153 = *(float *)&v326;
                            }
                          }
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 379), 0xAu, 0, 0, v153, 0);
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 379), 0x17u, 0, 0, *((AudioUnitParameterValue *)v3 + 4172), 0);
                          v155 = *(_OWORD *)&a2->mRateScalar;
                          *(_OWORD *)&v330.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                          *(_OWORD *)&v330.mRateScalar = v155;
                          v156 = *(_OWORD *)&a2->mSMPTETime.mHours;
                          *(_OWORD *)&v330.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                          *(_OWORD *)&v330.mSMPTETime.mHours = v156;
                          Parameter = AudioUnitProcessMultiple(*((AudioUnit *)v3 + 379), &v320, &v330, *((_DWORD *)v3 + 127), 5u, (const AudioBufferList **)&v333, 2u, &v331);
                          v140 = *((unsigned int *)v3 + 127);
                          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                          {
                            Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Au, v140, v331, &v330);
                            v140 = *((unsigned int *)v3 + 127);
                            v141 = v332;
                            if (*((_BYTE *)v3 + 15897))
                              goto LABEL_391;
                          }
                          else
                          {
                            v141 = v332;
                          }
                          if (!*((_BYTE *)v3 + 15898))
                            goto LABEL_392;
LABEL_391:
                          p_inInputBufferLists = &v330;
                          v143 = (uint64_t)v3;
                          v144 = 27;
                          goto LABEL_364;
                        }
LABEL_377:
                        Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x19u, v148, v149, &inInputBufferLists);
                        goto LABEL_378;
                      }
                    }
                    else
                    {
                      v128 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 376);
                    }
                    v129 = 2.0;
                    goto LABEL_345;
                  }
                  v114 = *((float *)v3 + 1055);
                  if (v114 == 0.0)
                  {
                    v115 = *(_QWORD *)(*((_QWORD *)v3 + 435) + 16) + 4 * *((unsigned int *)v3 + 127);
                    inInputBufferLists.mSampleTime = *(Float64 *)(*((_QWORD *)v3 + 435) + 16);
                    inInputBufferLists.mHostTime = v115;
                    if (*((_QWORD *)v3 + 2097))
                    {
                      VPTimeFreqConverter::Analyze(*((VPTimeFreqConverter **)v3 + 2097), *(const float **)(*((_QWORD *)v3 + 424) + 16), (DSPSplitComplex *)&inInputBufferLists);
                      v114 = *((float *)v3 + 1055);
                      Parameter = *((_QWORD *)v3 + 390);
                    }
                  }
                  AudioUnitSetParameter((AudioUnit)Parameter, 6u, 0, 0, v114, 0);
                  AudioUnitSetParameter(*((AudioUnit *)v3 + 390), 7u, 0, 0, *((AudioUnitParameterValue *)v3 + 1059), 0);
                  AudioUnitSetParameter(*((AudioUnit *)v3 + 390), 0xDu, 0, 0, *((AudioUnitParameterValue *)v3 + 1063), 0);
                  memcpy(*(void **)(*((_QWORD *)v3 + 433) + 16), *(const void **)(*((_QWORD *)v3 + 504) + 32), *((unsigned int *)v3 + 1071));
                  v116 = *((_QWORD *)v3 + 433);
                  v330.mSampleTime = *((Float64 *)v3 + 505);
                  v330.mHostTime = v116;
                  v330.mRateScalar = *((Float64 *)v3 + 511);
                  memset(&v330.mWordClockTime, 0, 24);
                  *(_QWORD *)&v333.mNumberBuffers = *((_QWORD *)v3 + 431);
                  *(_QWORD *)&v333.mBuffers[0].mNumberChannels = 0;
                  v333.mBuffers[0].mData = (void *)*((_QWORD *)v3 + 500);
                  v117 = *(_OWORD *)&a2->mRateScalar;
                  *(_OWORD *)&inInputBufferLists.mSampleTime = *(_OWORD *)&a2->mSampleTime;
                  *(_OWORD *)&inInputBufferLists.mRateScalar = v117;
                  v118 = *(_OWORD *)&a2->mSMPTETime.mHours;
                  *(_OWORD *)&inInputBufferLists.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
                  *(_OWORD *)&inInputBufferLists.mSMPTETime.mHours = v118;
                  v320 = 512;
                  Parameter = AudioUnitProcessMultiple(*((AudioUnit *)v3 + 390), &v320, &inInputBufferLists, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)&v330, 3u, (AudioBufferList **)&v333);
                  v119 = *((unsigned int *)v3 + 127);
                  if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                  {
                    Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x25u, v119, *((const AudioBufferList **)v3 + 431), &inInputBufferLists);
                    v119 = *((unsigned int *)v3 + 127);
                    v120 = (const AudioBufferList *)*((_QWORD *)v3 + 500);
                    if (*((_BYTE *)v3 + 15897))
                      goto LABEL_311;
                  }
                  else
                  {
                    v120 = (const AudioBufferList *)*((_QWORD *)v3 + 500);
                  }
                  if (!*((_BYTE *)v3 + 15898))
                  {
LABEL_312:
                    v112 = *((_QWORD *)v3 + 582);
                    goto LABEL_313;
                  }
LABEL_311:
                  Parameter = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x50u, v119, v120, &inInputBufferLists);
                  goto LABEL_312;
                }
LABEL_690:
                std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
              }
            }
            else
            {
              v97 = (const AudioBufferList *)*((_QWORD *)v3 + 421);
            }
            if (!*((_BYTE *)v3 + 15898))
              goto LABEL_234;
            goto LABEL_233;
          }
LABEL_172:
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x11u, v78, v79, &buf);
          v78 = *((unsigned int *)v3 + 127);
          goto LABEL_173;
        }
        v72 = *((_QWORD *)v3 + 2098);
        if ((unint64_t)(*((_QWORD *)v3 + 2099) - v72) <= 0x20)
          goto LABEL_690;
        ECApplicator::apply(*(AudioUnitParameterID **)(v72 + 32), &buf, v51, (BOOL *)&v319, (float *)v3 + 1047, (float *)v3 + 1051, (float *)v3 + 1055, (float *)v3 + 1059, (float *)v3 + 1063, (float *)v3 + 1067);
        v73 = *((unsigned int *)v3 + 127);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
        {
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x21u, v73, *((const AudioBufferList **)v3 + 136), &buf);
          v73 = *((unsigned int *)v3 + 127);
          v74 = (const AudioBufferList *)*((_QWORD *)v3 + 422);
          if (*((_BYTE *)v3 + 15897))
            goto LABEL_155;
        }
        else
        {
          v74 = (const AudioBufferList *)*((_QWORD *)v3 + 422);
        }
        if (!*((_BYTE *)v3 + 15898))
        {
LABEL_156:
          v75 = *((_QWORD *)v3 + 507);
          inInputBufferLists.mSampleTime = *(Float64 *)(v75 + 16);
          inInputBufferLists.mHostTime = *(_QWORD *)&inInputBufferLists.mSampleTime + 4 * v73;
          v76 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 2130);
          if (v76)
          {
            VPTimeFreqConverter::Analyze(v76, *(const float **)(*((_QWORD *)v3 + 422) + 16), (DSPSplitComplex *)&inInputBufferLists);
            v73 = *((unsigned int *)v3 + 127);
            v75 = *((_QWORD *)v3 + 507);
          }
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x16u, v73, (const AudioBufferList *)v75, &buf);
          v56 = *((_QWORD *)v3 + 582);
          goto LABEL_162;
        }
LABEL_155:
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x10u, v73, v74, &buf);
        v73 = *((unsigned int *)v3 + 127);
        goto LABEL_156;
      }
      v50 = *((_DWORD *)v3 + 3098);
      if (v49 != 3)
      {
        if (v50 == 2)
        {
          v51 = 0;
          *((_OWORD *)v3 + 1054) = *(_OWORD *)(v48 + 40);
          *(_OWORD *)((char *)v3 + 16888) = *(_OWORD *)(v48 + 56);
          v52 = 1;
          v53 = 3;
          v54 = 2;
LABEL_114:
          v55 = v48 + 8;
          *((_OWORD *)v3 + 1051) = *(_OWORD *)(v55 + 16 * v51);
          *(_OWORD *)((char *)v3 + 16840) = *(_OWORD *)(v55 + 16 * v52);
          goto LABEL_115;
        }
        v50 = *((_DWORD *)v3 + 3098);
        if (v50 <= 0xC && ((0x1028u >> v50) & 1) != 0)
        {
          v51 = 0;
          *((_OWORD *)v3 + 1054) = *(_OWORD *)(v48 + 24);
          *(_OWORD *)((char *)v3 + 16888) = *(_OWORD *)(v48 + 40);
          v52 = 3;
          v53 = 2;
          v54 = 1;
          goto LABEL_114;
        }
      }
      if (v50 == 9)
      {
        v51 = 0;
        *((_OWORD *)v3 + 1054) = *(_OWORD *)(v48 + 56);
        *(_OWORD *)((char *)v3 + 16888) = *(_OWORD *)(v48 + 40);
        v52 = 1;
        v53 = 2;
        v54 = 3;
      }
      else
      {
        v54 = 0;
        v53 = 0;
        v51 = 1;
        v52 = 2;
      }
      goto LABEL_114;
    }
  }
  v12 = 0;
  while (((*((_DWORD *)v3 + 116) >> v12) & 1) == 0)
  {
    if (++v12 == 32)
    {
      v12 = 33;
      break;
    }
  }
  v13 = (unsigned int *)*((_QWORD *)v3 + 135);
  if (v12 >= *v13)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v16 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v17 = (*v16 ? *v16 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v18 = **((_DWORD **)v3 + 135);
        LODWORD(buf.mSampleTime) = 136315906;
        *(_QWORD *)((char *)&buf.mSampleTime + 4) = "vpProcessUplink_v7.cpp";
        WORD2(buf.mHostTime) = 1024;
        *(_DWORD *)((char *)&buf.mHostTime + 6) = 51;
        WORD1(buf.mRateScalar) = 1024;
        HIDWORD(buf.mRateScalar) = v12;
        LOWORD(buf.mWordClockTime) = 1024;
        *(_DWORD *)((char *)&buf.mWordClockTime + 2) = v18;
        _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", (uint8_t *)&buf, 0x1Eu);
      }
    }
    v19 = (int *)*((_QWORD *)v3 + 1570);
    if (v19 && (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      CALegacyLog::log(v19, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v7/vpProcessUplink_v7.cpp", 51, "ProcessDSPChain_Uplink", "ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", v12, **((_DWORD **)v3 + 135));
    }
    v14 = *(void **)(*((_QWORD *)v3 + 136) + 16);
    v15 = (const void **)*((_QWORD *)v3 + 135);
  }
  else
  {
    v14 = *(void **)(*((_QWORD *)v3 + 136) + 16);
    v15 = (const void **)&v13[4 * v12];
  }
  memcpy(v14, v15[2], *((unsigned int *)v15 + 3));
  if (*((_BYTE *)v3 + 2085))
  {
    if ((*((_BYTE *)v3 + 4662) & 0x20) != 0 && (*((_BYTE *)v3 + 4678) & 0x20) != 0)
    {
      v20 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 400);
      if (v20)
      {
        v21 = *((_QWORD *)v3 + 499);
        inInputBufferLists.mSampleTime = *((Float64 *)v3 + 136);
        inInputBufferLists.mHostTime = v21;
        v22 = *((_QWORD *)v3 + 501);
        v330.mSampleTime = inInputBufferLists.mSampleTime;
        v330.mHostTime = v22;
        v23 = *(_OWORD *)&a2->mRateScalar;
        *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
        *(_OWORD *)&buf.mRateScalar = v23;
        v24 = *(_OWORD *)&a2->mSMPTETime.mHours;
        *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
        *(_OWORD *)&buf.mSMPTETime.mHours = v24;
        v333.mNumberBuffers = 512;
        AudioUnitProcessMultiple(v20, &v333.mNumberBuffers, &buf, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)&inInputBufferLists, 2u, (AudioBufferList **)&v330);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x27u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), &buf);
        if ((*((_BYTE *)v3 + 4664) & 2) != 0 && (*((_BYTE *)v3 + 4680) & 2) != 0 && *((_QWORD *)v3 + 412))
        {
          AudioUnitGetParameter(*((AudioUnit *)v3 + 400), 1u, 0, 0, &v321);
          AudioUnitSetParameter(*((AudioUnit *)v3 + 412), 0x23u, 0, 0, v321, 0);
        }
      }
    }
  }
LABEL_612:
  v333.mNumberBuffers = 0;
  v268 = VoiceProcessorV2::LocalVoiceDuckingForMediaChatEnabled(v3);
  v270 = v268;
  if (!*((_BYTE *)v3 + 2080))
  {
    if ((v268 & 1) == 0)
      goto LABEL_633;
    VoiceProcessorV2::DetectVoiceActivity(v3, a2, v269);
LABEL_621:
    v272 = *((_QWORD *)v3 + 582);
    if ((v272 & 0x2000000000000000) != 0
      && (*((_BYTE *)v3 + 4679) & 0x20) != 0
      && (v273 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 408)) != 0)
    {
      v274 = 1936748646;
    }
    else
    {
      if ((v272 & 0x1000000000000000) == 0
        || (*((_BYTE *)v3 + 4679) & 0x10) == 0
        || (v273 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 407)) == 0)
      {
        *(AudioUnitParameterValue *)&v333.mNumberBuffers = v321;
        goto LABEL_631;
      }
      v274 = 2;
    }
    AudioUnitGetParameter(v273, v274, 0, 0, (AudioUnitParameterValue *)&v333.mNumberBuffers);
    goto LABEL_631;
  }
  if (*((_QWORD *)v3 + 2054))
    v271 = 1;
  else
    v271 = v268;
  if ((v271 & 1) != 0)
  {
    VoiceProcessorV2::DetectVoiceActivity(v3, a2, v269);
    if ((v270 & 1) != 0)
      goto LABEL_621;
  }
LABEL_631:
  if (*((_BYTE *)v3 + 2080))
  {
    bzero(*(void **)(*((_QWORD *)v3 + 136) + 16), 4 * *((unsigned int *)v3 + 127));
    v333.mNumberBuffers = 0;
    goto LABEL_634;
  }
LABEL_633:
  *((_DWORD *)v3 + 4110) = 0;
LABEL_634:
  if ((*((_BYTE *)v3 + 8833) & 0x80) != 0 && (*((_BYTE *)v3 + 8841) & 0x80) != 0)
  {
    v275 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 452);
    v276 = v275 ? v270 : 0;
    if (v276 == 1)
      AudioUnitSetParameter(v275, 0x12u, 0, 0, *(AudioUnitParameterValue *)&v333.mNumberBuffers, 0);
  }
  if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Au, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
  if ((*((_BYTE *)v3 + 4663) & 8) != 0 && (*((_BYTE *)v3 + 4679) & 8) != 0)
  {
    v277 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 406);
    if (v277)
    {
      inInputBufferLists.mSampleTime = *((Float64 *)v3 + 136);
      v330.mSampleTime = inInputBufferLists.mSampleTime;
      LODWORD(v314.realp) = 512;
      v278 = *(_OWORD *)&a2->mRateScalar;
      *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
      *(_OWORD *)&buf.mRateScalar = v278;
      v279 = *(_OWORD *)&a2->mSMPTETime.mHours;
      *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
      *(_OWORD *)&buf.mSMPTETime.mHours = v279;
      AudioUnitProcessMultiple(v277, (AudioUnitRenderActionFlags *)&v314, &buf, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)&inInputBufferLists, 1u, (AudioBufferList **)&v330);
      if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x7Au, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), &buf);
    }
  }
  if (*((_BYTE *)v3 + 2085))
  {
    if ((*((_BYTE *)v3 + 4664) & 0x40) != 0 && (*((_BYTE *)v3 + 4680) & 0x40) != 0)
    {
      v280 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 417);
      if (v280)
      {
        inInputBufferLists.mSampleTime = *((Float64 *)v3 + 136);
        v330.mSampleTime = inInputBufferLists.mSampleTime;
        LODWORD(v314.realp) = 512;
        v281 = *(_OWORD *)&a2->mRateScalar;
        *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
        *(_OWORD *)&buf.mRateScalar = v281;
        v282 = *(_OWORD *)&a2->mSMPTETime.mHours;
        *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
        *(_OWORD *)&buf.mSMPTETime.mHours = v282;
        AudioUnitProcessMultiple(v280, (AudioUnitRenderActionFlags *)&v314, &buf, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)&inInputBufferLists, 1u, (AudioBufferList **)&v330);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x7Cu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), &buf);
      }
    }
  }
  if ((*((_QWORD *)v3 + 582) & 0x8000000000000000) != 0 && (*((_QWORD *)v3 + 584) & 0x8000000000000000) != 0)
  {
    v283 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 410);
    if (v283)
    {
      v284 = *(_OWORD *)&a2->mRateScalar;
      *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
      *(_OWORD *)&buf.mRateScalar = v284;
      v285 = *(_OWORD *)&a2->mSMPTETime.mHours;
      *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
      *(_OWORD *)&buf.mSMPTETime.mHours = v285;
      LODWORD(inInputBufferLists.mSampleTime) = 512;
      AudioUnitProcess(v283, (AudioUnitRenderActionFlags *)&inInputBufferLists, &buf, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
      if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Cu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), &buf);
    }
  }
  v286 = *((_QWORD *)v3 + 583);
  if ((v286 & 1) != 0 && (*((_BYTE *)v3 + 4680) & 1) != 0)
  {
    v287 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 411);
    if (v287)
    {
      v288 = *(_OWORD *)&a2->mRateScalar;
      *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
      *(_OWORD *)&buf.mRateScalar = v288;
      v289 = *(_OWORD *)&a2->mSMPTETime.mHours;
      *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
      *(_OWORD *)&buf.mSMPTETime.mHours = v289;
      LODWORD(inInputBufferLists.mSampleTime) = 512;
      AudioUnitProcess(v287, (AudioUnitRenderActionFlags *)&inInputBufferLists, &buf, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
      v286 = *((_QWORD *)v3 + 583);
    }
  }
  if ((v286 & 2) != 0
    && (*((_BYTE *)v3 + 4680) & 2) != 0
    && (v290 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 412)) != 0)
  {
    v291 = *(_OWORD *)&a2->mRateScalar;
    *(_OWORD *)&buf.mSampleTime = *(_OWORD *)&a2->mSampleTime;
    *(_OWORD *)&buf.mRateScalar = v291;
    v292 = *(_OWORD *)&a2->mSMPTETime.mHours;
    *(_OWORD *)&buf.mSMPTETime.mSubframes = *(_OWORD *)&a2->mSMPTETime.mSubframes;
    *(_OWORD *)&buf.mSMPTETime.mHours = v292;
    LODWORD(inInputBufferLists.mSampleTime) = 512;
    AudioUnitProcess(v290, (AudioUnitRenderActionFlags *)&inInputBufferLists, &buf, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Du, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), &buf);
    if ((*((_BYTE *)v3 + 4663) & 0x10) != 0 && (*((_BYTE *)v3 + 4679) & 0x10) != 0 && *((_QWORD *)v3 + 407))
    {
      LODWORD(v330.mSampleTime) = 0;
      AudioUnitGetParameter(*((AudioUnit *)v3 + 412), 1u, 0, 0, (AudioUnitParameterValue *)&v330);
      AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 0x11u, 0, 0, *(AudioUnitParameterValue *)&v330.mSampleTime, 0);
    }
    LODWORD(v330.mSampleTime) = 0;
    AudioUnitGetParameter(*((AudioUnit *)v3 + 412), 0x1Bu, 0, 0, (AudioUnitParameterValue *)&v330);
    mSampleTime_low = LODWORD(v330.mSampleTime);
    if (*((float *)v3 + 572) != *(float *)&v330.mSampleTime)
    {
      if ((*((_BYTE *)v3 + 4663) & 0x10) != 0 && (*((_BYTE *)v3 + 4679) & 0x10) != 0)
      {
        v294 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 407);
        if (v294)
        {
          AudioUnitSetParameter(v294, 0x12u, 0, 0, *(AudioUnitParameterValue *)&v330.mSampleTime, 0);
          mSampleTime_low = LODWORD(v330.mSampleTime);
        }
      }
      *((_DWORD *)v3 + 572) = mSampleTime_low;
    }
  }
  else if ((*((_BYTE *)v3 + 4663) & 0x40) != 0 && ((*((_BYTE *)v3 + 4679) & 0x40) != 0 || *((_BYTE *)v3 + 472)))
  {
    LODWORD(buf.mSampleTime) = __exp10f(*((float *)v3 + 1091) / 20.0);
    vDSP_vsmul(*(const float **)(*((_QWORD *)v3 + 136) + 16), 1, (const float *)&buf, *(float **)(*((_QWORD *)v3 + 136) + 16), 1, *((unsigned int *)v3 + 127));
    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Bu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
  }
  VoiceProcessorV6::ProcessLevelDrivenSuppressor((uint64_t)v3, a2);
  return 0;
}

uint64_t SVBasedProbability::UpdateModelsWithShapeParameter(SVBasedProbability *this, float a2)
{
  (*(void (**)(_QWORD))(**((_QWORD **)this + 72) + 32))(*((_QWORD *)this + 72));
  (*(void (**)(_QWORD, float))(**((_QWORD **)this + 73) + 32))(*((_QWORD *)this + 73), a2);
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 74) + 32))(*((_QWORD *)this + 74), a2);
}

uint64_t SVBasedProbability::UpdateModelsWithShapeParameter(_QWORD **a1, uint64_t a2)
{
  (*(void (**)(_QWORD *))(*a1[72] + 40))(a1[72]);
  (*(void (**)(_QWORD *, uint64_t))(*a1[73] + 40))(a1[73], a2);
  return (*(uint64_t (**)(_QWORD *, uint64_t))(*a1[74] + 40))(a1[74], a2);
}

float SVBasedProbability::EstimateSpatialProbabilities(SVBasedProbability *this)
{
  SpatialProbabilityBase::UpdatePriorProbabilities(this);
  SpatialProbabilityBase::UpdateShapeParameter(this);
  (*(void (**)(_QWORD, char *, char *))(**((_QWORD **)this + 72) + 48))(*((_QWORD *)this + 72), (char *)this + 544, (char *)this + 96);
  (*(void (**)(_QWORD, char *, char *))(**((_QWORD **)this + 73) + 48))(*((_QWORD *)this + 73), (char *)this + 544, (char *)this + 120);
  (*(void (**)(_QWORD, char *, char *))(**((_QWORD **)this + 74) + 48))(*((_QWORD *)this + 74), (char *)this + 544, (char *)this + 144);
  (*(void (**)(SVBasedProbability *))(*(_QWORD *)this + 96))(this);
  return SpatialProbabilityBase::UpdatePosteriorProbabilities(this);
}

void SVBasedProbability::~SVBasedProbability(SVBasedProbability *this)
{
  SVBasedProbability::~SVBasedProbability(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  *(_QWORD *)this = &off_1E69ECB18;
  v2 = *((_QWORD *)this + 74);
  *((_QWORD *)this + 74) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 72);
  *((_QWORD *)this + 72) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = (void *)*((_QWORD *)this + 68);
  if (v5)
  {
    *((_QWORD *)this + 69) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 65);
  if (v6)
  {
    *((_QWORD *)this + 66) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 62);
  if (v7)
  {
    *((_QWORD *)this + 63) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 59);
  if (v8)
  {
    *((_QWORD *)this + 60) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 56);
  if (v9)
  {
    *((_QWORD *)this + 57) = v9;
    operator delete(v9);
  }
  SpatialProbabilityBase::~SpatialProbabilityBase(this);
}

uint64_t SVBasedProbability::ProcessBufferList(SVBasedProbability *this, const AudioBufferList *a2)
{
  unint64_t v3;
  void **p_mData;
  char *v5;

  if (*((_DWORD *)this + 110))
  {
    v3 = 0;
    p_mData = &a2->mBuffers[0].mData;
    do
    {
      memcpy((void *)(*((_QWORD *)this + 68) + 4 * (*((_DWORD *)this + 2) * v3)), *p_mData, 4 * *((unsigned int *)this + 2));
      v5 = (char *)*p_mData;
      p_mData += 2;
      memcpy((void *)(*((_QWORD *)this + 68)+ 4 * (*((_DWORD *)this + 111) + *((_DWORD *)this + 2) * v3++)+ 4), &v5[4 * *((unsigned int *)this + 2)], 4 * (*((_DWORD *)this + 2) - 2));
    }
    while (v3 < *((unsigned int *)this + 110));
  }
  SVBasedProbability::NormalizeVector((uint64_t)this, (_QWORD *)this + 68);
  return (*(uint64_t (**)(SVBasedProbability *))(*(_QWORD *)this + 16))(this);
}

void SVBasedProbability::NormalizeLikelihoods(SVBasedProbability *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  float v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  float v14;
  float v15;
  unsigned int v16;
  uint64_t v17;
  float v18;
  unsigned int v19;
  uint64_t v20;

  v1 = *((unsigned int *)this + 2);
  if ((_DWORD)v1)
  {
    v2 = 0;
    v3 = *(unsigned int *)(*((_QWORD *)this + 73) + 124);
    v4 = *(unsigned int *)(*((_QWORD *)this + 72) + 124);
    v5 = *((_QWORD *)this + 12);
    v6 = *((_QWORD *)this + 18);
    v7 = *((_QWORD *)this + 15);
    v8 = *((_DWORD *)this + 2);
    do
    {
      v9 = *(float *)(v5 + 4 * v2);
      if (v4 >= 2)
      {
        v10 = v8;
        v11 = v4 - 1;
        v9 = *(float *)(v5 + 4 * v2);
        do
        {
          v9 = fmaxf(v9, *(float *)(v5 + 4 * v10));
          v10 += v1;
          --v11;
        }
        while (v11);
      }
      v12 = v2;
      v13 = v3;
      if ((_DWORD)v3)
      {
        do
        {
          v9 = fmaxf(v9, *(float *)(v7 + 4 * v12));
          v12 += v1;
          --v13;
        }
        while (v13);
      }
      v14 = fmaxf(v9, *(float *)(v6 + 4 * v2));
      *(float *)(v5 + 4 * v2) = expf(*(float *)(v5 + 4 * v2) - v14);
      *(float *)(v7 + 4 * v2) = expf(*(float *)(v7 + 4 * v2) - v14);
      *(float *)(v6 + 4 * v2) = expf(*(float *)(v6 + 4 * v2) - v14);
      if (v4 >= 2)
      {
        v15 = *(float *)(v5 + 4 * v2);
        v16 = v8;
        v17 = v4 - 1;
        do
        {
          v15 = v15 + expf(*(float *)(v5 + 4 * v16) - v14);
          *(float *)(v5 + 4 * v2) = v15;
          v16 += v1;
          --v17;
        }
        while (v17);
      }
      if (v3 >= 2)
      {
        v18 = *(float *)(v7 + 4 * v2);
        v19 = v8;
        v20 = v3 - 1;
        do
        {
          v18 = v18 + expf(*(float *)(v7 + 4 * v19) - v14);
          *(float *)(v7 + 4 * v2) = v18;
          v19 += v1;
          --v20;
        }
        while (v20);
      }
      ++v2;
      ++v8;
    }
    while (v2 != v1);
  }
}

void SVBasedProbability::SetSteeringVectorFromVectorOfVectors(uint64_t a1, _QWORD *a2, _QWORD *a3, unsigned int a4)
{
  uint64_t v7;
  unint64_t v8;
  size_t v9;

  if (*(_DWORD *)(a1 + 440))
  {
    v7 = 0;
    v8 = 0;
    v9 = 4 * a4;
    do
    {
      memcpy((void *)(*(_QWORD *)(a1 + 448) + 4 * (*(_DWORD *)(a1 + 8) * v8)), *(const void **)(*a2 + v7), v9);
      memcpy((void *)(*(_QWORD *)(a1 + 448) + 4 * (*(_DWORD *)(a1 + 444) + *(_DWORD *)(a1 + 8) * v8++)), *(const void **)(*a3 + v7), v9);
      v7 += 24;
    }
    while (v8 < *(unsigned int *)(a1 + 440));
  }
  SVBasedProbability::NormalizeVector(a1, (_QWORD *)(a1 + 448));
  vDSP_vneg((const float *)(*(_QWORD *)(a1 + 448) + 4 * *(unsigned int *)(a1 + 444)), 1, (float *)(*(_QWORD *)(a1 + 448) + 4 * *(unsigned int *)(a1 + 444)), 1, *(unsigned int *)(a1 + 444));
  CircularModelSV::SetTargetSV(*(_QWORD *)(a1 + 576), a1 + 448);
  CircularModelSV::SetTargetSV(*(_QWORD *)(a1 + 584), a1 + 448);
  CircularModelSV::SetTargetSV(*(_QWORD *)(a1 + 592), a1 + 448);
}

void SVBasedProbability::SetSteeringVectorOnline(SVBasedProbability *this, const float *a2, size_t __n)
{
  _QWORD *v4;

  v4 = (_QWORD *)((char *)this + 448);
  memcpy(*((void **)this + 56), a2, __n);
  SVBasedProbability::NormalizeVector((uint64_t)this, v4);
  vDSP_vneg((const float *)(*((_QWORD *)this + 56) + 4 * *((unsigned int *)this + 111)), 1, (float *)(*((_QWORD *)this + 56) + 4 * *((unsigned int *)this + 111)), 1, *((unsigned int *)this + 111));
  CircularModelSV::SetTargetSV(*((_QWORD *)this + 72), (uint64_t)v4);
  CircularModelSV::SetTargetSV(*((_QWORD *)this + 73), (uint64_t)v4);
  CircularModelSV::SetTargetSV(*((_QWORD *)this + 74), (uint64_t)v4);
}

void SVBasedProbability::NormalizeVector(uint64_t a1, _QWORD *a2)
{
  unsigned int v4;
  const float *v5;
  unsigned int v6;
  vDSP_Length v7;
  float *v8;
  float __B;
  int v10;

  vDSP_vclr(*(float **)(a1 + 496), 1, *(unsigned int *)(a1 + 8));
  if ((*(_DWORD *)(a1 + 440) & 0x7FFFFFFF) != 0)
  {
    v4 = 0;
    do
    {
      v5 = (const float *)(*a2 + 4 * *(_DWORD *)(a1 + 8) * v4);
      vDSP_vma(v5, 1, v5, 1, *(const float **)(a1 + 496), 1, *(float **)(a1 + 496), 1, *(unsigned int *)(a1 + 8));
      ++v4;
    }
    while (v4 < 2 * *(_DWORD *)(a1 + 440));
  }
  v10 = *(_DWORD *)(a1 + 8);
  vvsqrtf(*(float **)(a1 + 496), *(const float **)(a1 + 496), &v10);
  __B = 2.2204e-16;
  vDSP_vthr(*(const float **)(a1 + 496), 1, &__B, *(float **)(a1 + 496), 1, *(unsigned int *)(a1 + 8));
  vDSP_svdiv((const float *)(a1 + 404), *(const float **)(a1 + 496), 1, *(float **)(a1 + 496), 1, *(unsigned int *)(a1 + 8));
  if ((*(_DWORD *)(a1 + 440) & 0x7FFFFFFF) != 0)
  {
    v6 = 0;
    do
    {
      v7 = *(unsigned int *)(a1 + 8);
      v8 = (float *)(*a2 + 4 * v7 * v6);
      vDSP_vmul(v8, 1, *(const float **)(a1 + 496), 1, v8, 1, v7);
      ++v6;
    }
    while (v6 < 2 * *(_DWORD *)(a1 + 440));
  }
}

uint64_t CircularModelSVFactory::CreateModel(uint64_t *a1, int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t result;
  std::logic_error *exception;
  float __A;

  switch(a2)
  {
    case 0:
      v9 = operator new();
      CircularModelSV::CircularModelSV(v9, a3, a4, a5);
      *(_QWORD *)v9 = &off_1E69ECBB8;
      __A = 0.0001;
      vDSP_vfill(&__A, *(float **)(v9 + 48), 1, *(unsigned int *)(v9 + 12));
      (**(void (***)(uint64_t, float))v9)(v9, __A);
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 8))(v9, v9 + 48);
      break;
    case 1:
      v9 = operator new();
      CircularModelSV::CircularModelSV(v9, a3, a4, a5);
      *(_QWORD *)v9 = &off_1E69ECC48;
      __A = 0.0001;
      vDSP_vfill(&__A, *(float **)(v9 + 48), 1, *(unsigned int *)(v9 + 12));
      (**(void (***)(uint64_t, float))v9)(v9, __A);
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 8))(v9, v9 + 48);
      break;
    case 2:
      v9 = operator new();
      CircularModelSV::CircularModelSV(v9, a3, a4, a5);
      *(_QWORD *)v9 = &off_1E69ECC90;
      __A = 0.0;
      std::vector<float>::vector((_QWORD *)(v9 + 176), (2 * a3 * a4), &__A);
      *(_DWORD *)(v9 + 124) = *(_DWORD *)(v9 + 8);
      (*(void (**)(uint64_t, float))(*(_QWORD *)v9 + 32))(v9, 0.0001);
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 8))(v9, v9 + 48);
      break;
    case 3:
      v9 = operator new();
      CircularModelSV::CircularModelSV(v9, a3, a4, a5);
      *(_QWORD *)v9 = &off_1E69ECCD8;
      __A = 0.0001;
      vDSP_vfill(&__A, *(float **)(v9 + 48), 1, *(unsigned int *)(v9 + 12));
      (**(void (***)(uint64_t, float))v9)(v9, __A);
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 8))(v9, v9 + 48);
      break;
    case 4:
      v9 = operator new();
      CircularModelSV::CircularModelSV(v9, a3, a4, a5);
      *(_QWORD *)v9 = &off_1E69ECD20;
      __A = 0.0;
      std::vector<float>::vector((_QWORD *)(v9 + 176), (2 * a4), &__A);
      (*(void (**)(uint64_t, float))(*(_QWORD *)v9 + 32))(v9, 0.0001);
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 8))(v9, v9 + 48);
      break;
    case 5:
      v9 = operator new();
      CircularModelSV::CircularModelSV(v9, a3, a4, a5);
      *(_QWORD *)v9 = &off_1E69ECD68;
      __A = 0.0;
      std::vector<float>::vector((_QWORD *)(v9 + 176), (2 * a3 * a4), &__A);
      __A = 0.0;
      std::vector<float>::vector((_QWORD *)(v9 + 200), (2 * a4), &__A);
      __A = 0.0;
      std::vector<float>::vector((_QWORD *)(v9 + 224), (2 * a4), &__A);
      *(_DWORD *)(v9 + 124) = *(_DWORD *)(v9 + 8);
      (*(void (**)(uint64_t, float))(*(_QWORD *)v9 + 32))(v9, 0.0001);
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 8))(v9, v9 + 48);
      break;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "Unknown selected model!");
  }
  *a1 = v9;
  return result;
}

void sub_1B65942A8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CircularModelSV::CircularModelSV(uint64_t a1, int a2, int a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  int v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;
  int v15;

  *(_QWORD *)a1 = &unk_1E69ECC00;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 16) = a3 * a2;
  v15 = 0;
  std::vector<float>::vector((_QWORD *)(a1 + 24), (2 * a3 * a2), &v15);
  v6 = *(unsigned int *)(a1 + 12);
  v15 = 0;
  std::vector<float>::vector((_QWORD *)(a1 + 48), v6, &v15);
  v7 = *(unsigned int *)(a1 + 12);
  v15 = 1065353216;
  std::vector<float>::vector((_QWORD *)(a1 + 72), v7, &v15);
  *(_QWORD *)(a1 + 96) = 1065353216;
  v8 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 104) = v8;
  v9 = (float)*(unsigned int *)(a1 + 8);
  *(float *)(a1 + 108) = v9;
  v10 = powf(3.1416, v9);
  v11 = v10 + v10;
  *(float *)(a1 + 112) = v10 + v10;
  v12 = tgammaf(v9);
  *(float *)(a1 + 116) = v11 / v12;
  *(float *)(a1 + 120) = logf(v12);
  *(_DWORD *)(a1 + 124) = 1;
  v15 = 1065353216;
  std::vector<float>::vector((_QWORD *)(a1 + 128), (2 * v8), &v15);
  v13 = *(unsigned int *)(a1 + 12);
  v15 = 1065353216;
  std::vector<float>::vector((_QWORD *)(a1 + 152), v13, &v15);
  CircularModelSV::SetTargetSV(a1, a4);
  return a1;
}

void sub_1B65944F4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  v7 = *v5;
  if (*v5)
  {
    v1[17] = v7;
    operator delete(v7);
  }
  v8 = *v4;
  if (*v4)
  {
    v1[10] = v8;
    operator delete(v8);
  }
  v9 = *v3;
  if (*v3)
  {
    v1[7] = v9;
    operator delete(v9);
  }
  v10 = *v2;
  if (*v2)
  {
    v1[4] = v10;
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SVBasedProbability::SVBasedProbability(uint64_t a1, int a2, unsigned int a3, int a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, float a12, float a13, float a14)
{
  uint64_t v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v30;

  v18 = SpatialProbabilityBase::SpatialProbabilityBase(a1, a3, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  *(_QWORD *)v18 = &off_1E69ECB18;
  *(_DWORD *)(v18 + 440) = a2;
  v19 = *(_DWORD *)(v18 + 8) * a2;
  *(_DWORD *)(v18 + 444) = v19;
  v20 = v18 + 448;
  LODWORD(v30) = 0;
  std::vector<float>::vector((_QWORD *)(v18 + 448), (2 * v19), &v30);
  *(_QWORD *)(a1 + 472) = 0;
  *(_QWORD *)(a1 + 480) = 0;
  *(_QWORD *)(a1 + 488) = 0;
  v21 = *(unsigned int *)(a1 + 8);
  LODWORD(v30) = 0;
  std::vector<float>::vector((_QWORD *)(a1 + 496), v21, &v30);
  v22 = *(unsigned int *)(a1 + 8);
  LODWORD(v30) = 0;
  std::vector<float>::vector((_QWORD *)(a1 + 520), v22, &v30);
  v23 = (2 * *(_DWORD *)(a1 + 444));
  LODWORD(v30) = 0;
  std::vector<float>::vector((_QWORD *)(a1 + 544), v23, &v30);
  *(_DWORD *)(a1 + 568) = a4;
  *(_DWORD *)(a1 + 572) = a5;
  *(_QWORD *)(a1 + 576) = 0;
  *(_QWORD *)(a1 + 592) = 0;
  *(_QWORD *)(a1 + 584) = 0;
  CircularModelSVFactory::CreateModel(&v30, a4, *(_DWORD *)(a1 + 440), *(_DWORD *)(a1 + 8), v20);
  v24 = *(_QWORD *)(a1 + 576);
  *(_QWORD *)(a1 + 576) = v30;
  if (v24)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24);
  CircularModelSVFactory::CreateModel(&v30, *(_DWORD *)(a1 + 572), *(_DWORD *)(a1 + 440), *(_DWORD *)(a1 + 8), v20);
  v25 = *(_QWORD *)(a1 + 584);
  *(_QWORD *)(a1 + 584) = v30;
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25);
  CircularModelSVFactory::CreateModel(&v30, 3, *(_DWORD *)(a1 + 440), *(_DWORD *)(a1 + 8), v20);
  v26 = *(_QWORD *)(a1 + 592);
  *(_QWORD *)(a1 + 592) = v30;
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 24))(v26);
  v27 = *(_DWORD *)(a1 + 568);
  if (v27 == 5 || v27 == 2)
    std::vector<float>::resize(a1 + 96, *(unsigned int *)(a1 + 444));
  v28 = *(_DWORD *)(a1 + 572);
  if (v28 == 5 || v28 == 2)
    std::vector<float>::resize(a1 + 120, *(unsigned int *)(a1 + 444));
  return a1;
}

void sub_1B6594734(_Unwind_Exception *a1)
{
  SpatialProbabilityBase *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  uint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  v8 = *((_QWORD *)v1 + 74);
  *((_QWORD *)v1 + 74) = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  v9 = *((_QWORD *)v1 + 73);
  *((_QWORD *)v1 + 73) = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  v10 = *v6;
  *v6 = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  v11 = *v5;
  if (*v5)
  {
    *((_QWORD *)v1 + 69) = v11;
    operator delete(v11);
  }
  v12 = *v4;
  if (*v4)
  {
    *((_QWORD *)v1 + 66) = v12;
    operator delete(v12);
  }
  v13 = *v3;
  if (*v3)
  {
    *((_QWORD *)v1 + 63) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)v1 + 59);
  if (v14)
  {
    *((_QWORD *)v1 + 60) = v14;
    operator delete(v14);
  }
  v15 = *v2;
  if (*v2)
  {
    *((_QWORD *)v1 + 57) = v15;
    operator delete(v15);
  }
  SpatialProbabilityBase::~SpatialProbabilityBase(v1);
  _Unwind_Resume(a1);
}

void BeamformerFD::~BeamformerFD(BeamformerFD *this)
{
  BeamformerFD::~BeamformerFD(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  void *v30;

  v2 = (_QWORD *)((char *)this + 855928);
  *(_QWORD *)this = &off_1E69ECE38;
  *((_BYTE *)this + 16) = 0;
  v3 = *((_QWORD *)this + 107002);
  v2[11] = 0;
  if (v3)
    std::default_delete<SubbandDOACalculator>::operator()[abi:ne180100](v3);
  v4 = (void *)v2[7];
  if (v4)
  {
    v2[8] = v4;
    operator delete(v4);
  }
  v5 = (_QWORD *)((char *)this + 844408);
  v6 = (_QWORD *)((char *)this + 660088);
  v7 = (_QWORD *)((char *)this + 475784);
  v8 = (_QWORD *)((char *)this + 365192);
  v9 = (_QWORD *)((char *)this + 254600);
  v10 = (_QWORD *)((char *)this + 247688);
  v11 = (void *)v2[4];
  v12 = (_QWORD *)((char *)this + 240776);
  if (v11)
  {
    v2[5] = v11;
    operator delete(v11);
  }
  v13 = -11520;
  do
  {
    v14 = (void *)*(v2 - 1);
    if (v14)
    {
      *v2 = v14;
      operator delete(v14);
    }
    v2 -= 5;
    v13 += 40;
  }
  while (v13);
  v15 = -184320;
  v16 = -184320;
  do
  {
    v17 = (void *)*(v5 - 1);
    if (v17)
    {
      *v5 = v17;
      operator delete(v17);
    }
    v5 -= 5;
    v16 += 40;
  }
  while (v16);
  do
  {
    v18 = (void *)*(v6 - 1);
    if (v18)
    {
      *v6 = v18;
      operator delete(v18);
    }
    v6 -= 5;
    v15 += 40;
  }
  while (v15);
  v19 = -110592;
  do
  {
    v20 = (void *)*(v7 - 1);
    if (v20)
    {
      *v7 = v20;
      operator delete(v20);
    }
    v7 -= 3;
    v19 += 24;
  }
  while (v19);
  v21 = -110592;
  do
  {
    v22 = (void *)*(v8 - 1);
    if (v22)
    {
      *v8 = v22;
      operator delete(v22);
    }
    v8 -= 3;
    v21 += 24;
  }
  while (v21);
  v23 = -6912;
  do
  {
    v24 = (void *)*(v9 - 1);
    if (v24)
    {
      *v9 = v24;
      operator delete(v24);
    }
    v9 -= 3;
    v23 += 24;
  }
  while (v23);
  v25 = -6912;
  do
  {
    v26 = (void *)*(v10 - 1);
    if (v26)
    {
      *v10 = v26;
      operator delete(v26);
    }
    v10 -= 3;
    v25 += 24;
  }
  while (v25);
  v27 = -110592;
  do
  {
    v28 = (void *)*(v12 - 1);
    if (v28)
    {
      *v12 = v28;
      operator delete(v28);
    }
    v12 -= 3;
    v27 += 24;
  }
  while (v27);
  v29 = 110592;
  do
  {
    v30 = *(void **)((char *)this + v29 + 19584);
    if (v30)
    {
      *(_QWORD *)((char *)this + v29 + 19592) = v30;
      operator delete(v30);
    }
    v29 -= 24;
  }
  while (v29);
  BeamformerBase::~BeamformerBase(this);
}

uint64_t BeamformerFD::Initialize(BeamformerFD *this, double a2, unsigned int a3)
{
  double v4;
  int32x2_t v5;
  float v6;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  char *v10;
  void *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  float **v30;
  float *v31;
  float *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  BeamformerFD *v36;
  unint64_t v37;
  unint64_t v38;
  float *v39;
  float *v40;
  float *v41;
  float *v42;
  uint64_t v43;
  float v44;
  float *v45;
  uint64_t v46;
  int v47;
  int v48;
  unsigned int v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v55;
  float **v56;
  char *v57;
  BeamformerFD *v58;
  DSPSplitComplex __C;
  float v60;
  int v61;
  _BYTE __A[18];
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  *((double *)this + 3) = a2;
  *((_DWORD *)this + 8) = a3;
  v4 = (float)a3;
  v5 = (int32x2_t)vcvt_u32_f32(vrnda_f32(vcvt_f32_f64(vmulq_n_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)((char *)this + 88)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(a2 * 0.5), 0)), v4))));
  *(int32x2_t *)((char *)this + 36) = v5;
  *(float *)&v4 = *((float *)this + 39) / (a2 * 0.5) * v4;
  *((float *)this + 13) = roundf(*(float *)&v4);
  *((_DWORD *)this + 11) = vsub_s32(vdup_lane_s32(v5, 1), v5).u32[0] + 1;
  v6 = a2 / (double)a3;
  *((float *)this + 12) = expf(-1.0 / (float)(*((float *)this + 24) * v6));
  v7 = *((unsigned int *)this + 3);
  *(_DWORD *)__A = 0;
  std::vector<float>::resize((uint64_t)this + 19152, v7, __A);
  if (!*((_BYTE *)this + 17))
  {
    if (AUBeamItFDLogScope(void)::once != -1)
      dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
    if (AUBeamItFDLogScope(void)::scope)
    {
      v26 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
      if (!*(_QWORD *)AUBeamItFDLogScope(void)::scope)
        return 4294956421;
    }
    else
    {
      v26 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__A = 136315394;
      *(_QWORD *)&__A[4] = "BeamformerFD.cpp";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 111;
      _os_log_impl(&dword_1B5ED0000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d Initialization failed, top level plist is not set.", __A, 0x12u);
    }
    return 4294956421;
  }
  v8 = (char *)this + 130200;
  (*(void (**)(BeamformerFD *))(*(_QWORD *)this + 144))(this);
  v56 = (float **)((char *)this + 130200);
  if (*((_DWORD *)this + 3))
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    LODWORD(v12) = *((_DWORD *)this + 8);
    v13 = (char *)this + 660120;
    do
    {
      v57 = v13;
      if (*((_DWORD *)this + 2))
      {
        v14 = 0;
        v15 = v8;
        do
        {
          SpectralProfile::GetProfile((SpectralProfile *)__A, *((double *)this + 3), (uint64_t)(v13 - 184320), v12 + 1, 0.0, 2 * v12);
          if (v10)
            operator delete(v10);
          v10 = *(char **)__A;
          v16 = *(_QWORD *)&__A[8];
          SpectralProfile::GetProfile((SpectralProfile *)__A, *((double *)this + 3), (uint64_t)v13, *((_DWORD *)this + 8) + 1, 0.0, 2 * *((_DWORD *)this + 8));
          if (v11)
            operator delete(v11);
          v11 = *(void **)__A;
          v17 = *(_QWORD *)&__A[8];
          std::vector<float>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(v15 - 110592, v10, v16 - 4, (v16 - 4 - (uint64_t)v10) >> 2);
          std::vector<float>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(v15, (char *)v11, v17 - 4, (v17 - 4 - (uint64_t)v11) >> 2);
          v12 = *((unsigned int *)this + 8);
          v18 = *(_DWORD **)v15;
          v15 += 24;
          *v18 = *(_DWORD *)&v10[4 * v12];
          ++v14;
          v13 += 40;
        }
        while (v14 < *((unsigned int *)this + 2));
      }
      SpectralProfile::GetProfile((SpectralProfile *)__A, *((double *)this + 3), (uint64_t)this + 40 * v9 + 844440, v12 + 1, 0.0, 2 * v12);
      if (v10)
        operator delete(v10);
      v19 = 0;
      v10 = *(char **)__A;
      LODWORD(v12) = *((_DWORD *)this + 8);
      v20 = *((_QWORD *)this + 3 * v9 + 30099);
      v21 = v12 + 1;
      if ((v12 + 1) > 1)
        v22 = v12 + 1;
      else
        v22 = 1;
      v23 = 4 * v22;
      do
      {
        *(_DWORD *)(v20 + v19) = *(_DWORD *)&v10[v19];
        v19 += 4;
      }
      while (v23 != v19);
      if (v21 < 2 * (int)v12)
      {
        v24 = 0;
        v25 = v20 + 4 * v21;
        do
        {
          *(_DWORD *)(v25 + 4 * v24) = *(_DWORD *)&v10[4 * (v24 + 1)];
          ++v24;
        }
        while ((_DWORD)v12 - 1 != (_DWORD)v24);
      }
      ++v9;
      v8 += 384;
      v13 = v57 + 640;
    }
    while (v9 < *((unsigned int *)this + 3));
  }
  else
  {
    v11 = 0;
    v10 = 0;
  }
  if (*((_DWORD *)this + 19) == 2)
  {
    v27 = (2 * *((_DWORD *)this + 8));
    *(_DWORD *)__A = 0;
    std::vector<float>::assign((char **)this + 106998, v27, __A);
    if (*((_DWORD *)this + 3))
    {
      v28 = 0;
      v58 = this;
      do
      {
        vDSP_vclr(*((float **)this + 2388), 1, (*((_DWORD *)this + 8) + 1));
        vDSP_vclr(*((float **)this + 2391), 1, (*((_DWORD *)this + 8) + 1));
        if (*((_DWORD *)this + 2))
        {
          v29 = 0;
          v30 = v56;
          do
          {
            v31 = *(v30 - 13824);
            v32 = (float *)*((_QWORD *)this + 2388);
            *v32 = *v31 * *v31;
            v33 = (uint64_t)(*v30 + 1);
            v34 = *((unsigned int *)this + 8);
            v32[v34] = **v30 * **v30;
            *(_QWORD *)__A = v31 + 1;
            *(_QWORD *)&__A[8] = v33;
            vDSP_zvmags((const DSPSplitComplex *)__A, 1, v32 + 1, 1, (v34 - 1));
            vDSP_vadd(*((const float **)this + 2388), 1, *((const float **)this + 2391), 1, *((float **)this + 2391), 1, (*((_DWORD *)this + 8) + 1));
            ++v29;
            v30 += 3;
          }
          while (v29 < *((unsigned int *)this + 2));
        }
        v61 = *((_DWORD *)this + 8) + 1;
        vvsqrtf(*((float **)this + 2391), *((const float **)this + 2391), &v61);
        v60 = 1.0;
        vDSP_vsadd(*((const float **)this + 2391), 1, &BeamformerBase::eps, *((float **)this + 2391), 1, (*((_DWORD *)this + 8) + 1));
        vDSP_svdiv(&v60, *((const float **)this + 2391), 1, *((float **)this + 2391), 1, (*((_DWORD *)this + 8) + 1));
        v55 = v28;
        if (*((_DWORD *)this + 2))
        {
          v35 = 0;
          v36 = v58;
          do
          {
            v37 = *((unsigned int *)this + 8);
            *(_DWORD *)__A = 0;
            std::vector<float>::assign((char **)v36 + 31827, v37, __A);
            v38 = *((unsigned int *)this + 8);
            *(_DWORD *)__A = 0;
            std::vector<float>::assign((char **)v36 + 45651, v38, __A);
            v39 = (float *)*((_QWORD *)v36 + 2451);
            v40 = (float *)*((_QWORD *)this + 2391);
            v41 = (float *)*((_QWORD *)v36 + 31827);
            *v41 = *v39 * *v40;
            v42 = (float *)*((_QWORD *)v36 + 16275);
            v43 = *((unsigned int *)this + 8);
            v44 = v40[v43];
            v45 = (float *)*((_QWORD *)v36 + 45651);
            *v45 = *v42 * v44;
            *(_QWORD *)__A = v39 + 1;
            *(_QWORD *)&__A[8] = v42 + 1;
            __C.realp = v41 + 1;
            __C.imagp = v45 + 1;
            vDSP_zvconj((const DSPSplitComplex *)__A, 1, &__C, 1, (v43 - 1));
            vDSP_zrvmul(&__C, 1, (const float *)(*((_QWORD *)this + 2391) + 4), 1, &__C, 1, (*((_DWORD *)this + 8) - 1));
            ++v35;
            v36 = (BeamformerFD *)((char *)v36 + 24);
          }
          while (v35 < *((unsigned int *)this + 2));
        }
        v28 = v55 + 1;
        v56 += 48;
        v58 = (BeamformerFD *)((char *)v58 + 384);
      }
      while (v55 + 1 < (unint64_t)*((unsigned int *)this + 3));
    }
  }
  if (*((_BYTE *)this + 856008))
  {
    v46 = operator new();
    v47 = *((_DWORD *)this + 8);
    v48 = *((_DWORD *)this + 3);
    *(_DWORD *)v46 = v47;
    *(_DWORD *)(v46 + 4) = v48;
    *(_OWORD *)(v46 + 8) = 0u;
    *(_DWORD *)(v46 + 56) = 0;
    *(_OWORD *)(v46 + 64) = 0u;
    *(_OWORD *)(v46 + 112) = 0u;
    *(_OWORD *)(v46 + 24) = 0u;
    *(_OWORD *)(v46 + 40) = 0u;
    *(_OWORD *)(v46 + 80) = 0u;
    *(_OWORD *)(v46 + 96) = 0u;
    *(_OWORD *)(v46 + 128) = 0u;
    *(_OWORD *)(v46 + 144) = 0u;
    *(_DWORD *)__A = 0;
    std::vector<unsigned int>::assign((std::vector<unsigned int> *)(v46 + 8), (v47 + 1), (std::vector<unsigned int>::const_reference)__A);
    if (*(_DWORD *)(v46 + 4))
    {
      v49 = 0;
      do
      {
        std::vector<float>::vector(__A, (*(_DWORD *)v46 + 1));
        std::vector<std::vector<float>>::push_back[abi:ne180100]((uint64_t *)(v46 + 32), (uint64_t)__A);
        if (*(_QWORD *)__A)
        {
          *(_QWORD *)&__A[8] = *(_QWORD *)__A;
          operator delete(*(void **)__A);
        }
        ++v49;
      }
      while (v49 < *(_DWORD *)(v46 + 4));
    }
    v50 = (2 * *(_DWORD *)v46);
    *(_DWORD *)__A = 0;
    std::vector<float>::assign((char **)(v46 + 88), v50, __A);
    v51 = (*(_DWORD *)v46 + 1);
    *(_DWORD *)__A = 0;
    std::vector<float>::assign((char **)(v46 + 112), v51, __A);
    v52 = (*(_DWORD *)v46 + 1);
    *(_DWORD *)__A = 0;
    std::vector<float>::assign((char **)(v46 + 136), v52, __A);
    SubbandDOA::Reset((char **)(v46 + 56), *(_DWORD *)v46);
    v53 = *((_QWORD *)this + 107002);
    *((_QWORD *)this + 107002) = v46;
    if (v53)
      std::default_delete<SubbandDOACalculator>::operator()[abi:ne180100](v53);
  }
  LimitWindBoost::initialize((BeamformerFD *)((char *)this + 19200), *((_DWORD *)this + 3) + 1, *((_DWORD *)this + 8), *((double *)this + 3), -65536);
  *((_BYTE *)this + 16) = 1;
  if (v11)
    operator delete(v11);
  if (v10)
    operator delete(v10);
  return 0;
}

void sub_1B6594FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, void **a10, void **a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  void *v16;
  void *v17;
  _QWORD *v18;
  void **v19;
  void **v20;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  v22 = *a10;
  if (*a10)
  {
    v18[18] = v22;
    operator delete(v22);
  }
  v23 = *v20;
  if (*v20)
  {
    v18[15] = v23;
    operator delete(v23);
  }
  v24 = *a11;
  if (*a11)
  {
    v18[12] = v24;
    operator delete(v24);
  }
  v25 = *a9;
  if (*a9)
  {
    v18[9] = v25;
    operator delete(v25);
  }
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  v26 = *v19;
  if (*v19)
  {
    v18[2] = v26;
    operator delete(v26);
  }
  MEMORY[0x1BCC95CEC](v18, 0x10B0C4054D2F8FBLL);
  if (v17)
    operator delete(v17);
  if (v16)
    operator delete(v16);
  _Unwind_Resume(a1);
}

uint64_t BeamformerFD::Reset(BeamformerFD *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  std::vector<unsigned int>::size_type v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char **v9;
  unint64_t v10;
  uint64_t v11;
  std::vector<unsigned int>::value_type __u;

  *((_DWORD *)this + 27) = 0;
  *((_DWORD *)this + 28) = 0;
  vDSP_vclr(*((float **)this + 2394), 1, *((unsigned int *)this + 3));
  memset_pattern16((char *)this + 552, &unk_1B6629FB0, 0x480uLL);
  if (*((_BYTE *)this + 16))
  {
    if (*((_BYTE *)this + 19304))
    {
      v2 = *((unsigned int *)this + 4807);
      __u = 0;
      std::vector<float>::assign((char **)this + 2432, v2, &__u);
      v3 = *((unsigned int *)this + 4807);
      __u = 0;
      std::vector<float>::assign((char **)this + 2435, v3, &__u);
      v4 = *((unsigned int *)this + 4807);
      __u = 0;
      std::vector<float>::assign((char **)this + 2441, v4, &__u);
      v5 = *((unsigned int *)this + 4807);
      __u = 0;
      std::vector<unsigned int>::assign((std::vector<unsigned int> *)((char *)this + 19504), v5, &__u);
      if (*((_DWORD *)this + 4807))
      {
        v6 = 0;
        v7 = 0;
        v8 = 0;
        do
        {
          v9 = (char **)(*((_QWORD *)this + 2444) + v6);
          v10 = (2 * *((_DWORD *)this + 4806));
          __u = 1065353216;
          std::vector<float>::assign(v9, v10, &__u);
          v11 = *((_QWORD *)this + 2447) + v7;
          *(_DWORD *)(v11 + 16) = 0;
          *(_QWORD *)(v11 + 56) = 1;
          *(_DWORD *)(v11 + 64) = 0;
          ++v8;
          v7 += 72;
          v6 += 24;
        }
        while (v8 < *((unsigned int *)this + 4807));
      }
    }
  }
  return 0;
}

uint64_t BeamformerFD::Cleanup(BeamformerFD *this)
{
  *((_BYTE *)this + 16) = 0;
  return 0;
}

uint64_t BeamformerFD::SetProfile(BeamformerFD *this, CFDictionaryRef theDict)
{
  unint64_t v2;
  const __CFNumber *Value;
  NSObject *v5;
  const __CFNumber *v6;
  NSObject *v7;
  const __CFNumber *v8;
  NSObject *v9;
  unsigned int v10;
  const __CFNumber *v11;
  NSObject *v12;
  int *v13;
  unint64_t v14;
  std::string *v15;
  __int128 v16;
  void **v17;
  CFStringRef v18;
  const __CFDictionary *v19;
  NSObject *v20;
  void **v21;
  const __CFString *v22;
  NSObject *v23;
  const char *CStringPtr;
  const __CFNumber *v25;
  NSObject *v26;
  const __CFNumber *v27;
  NSObject *v28;
  float v29;
  float v30;
  const __CFNumber *v31;
  NSObject *v32;
  float v33;
  float v34;
  void **v35;
  void *v36;
  std::string *v37;
  int v38;
  double *v39;
  const __CFDictionary *v40;
  NSObject *v41;
  std::string *p_p;
  unint64_t v43;
  std::string *v44;
  std::string *v45;
  __int128 v46;
  const char *v47;
  const __CFString *v48;
  int v49;
  const __CFDictionary *v50;
  NSObject *v51;
  std::string *v52;
  unint64_t v53;
  std::string *v54;
  std::string *v55;
  __int128 v56;
  const char *v57;
  const __CFString *v58;
  int v59;
  int v60;
  NSObject *v61;
  void **v62;
  NSObject *v63;
  std::string *v64;
  NSObject *v65;
  NSObject *v66;
  std::string *v67;
  uint64_t result;
  NSObject *v69;
  CAXException *v70;
  NSObject *v71;
  CAXException *v72;
  NSObject *v73;
  CAXException *v74;
  NSObject *v75;
  CAXException *v76;
  NSObject *v77;
  CAXException *exception;
  NSObject *v79;
  CAXException *v80;
  NSObject *v81;
  CAXException *v82;
  CAXException *v83;
  NSObject *v84;
  CAXException *v85;
  std::string *v87;
  std::string *v88;
  std::string __p;
  std::string v90;
  double v91;
  double v92;
  float v93;
  void *v94[2];
  int64_t v95;
  int v96;
  unsigned int v97;
  int v98;
  int valuePtr;
  _BYTE buf[28];
  __int16 v101;
  int v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("SampleRate"));
  if (!CFNumberGetValue(Value, kCFNumberIntType, &valuePtr))
  {
    if (AUBeamItFDLogScope(void)::once != -1)
      dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
    if (AUBeamItFDLogScope(void)::scope)
    {
      if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
      {
        v77 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
        if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
        {
          if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 157;
            _os_log_impl(&dword_1B5ED0000, v77, OS_LOG_TYPE_DEBUG, "%25s:%-5d Failed to retrieve sample rate.\n", buf, 0x12u);
          }
        }
      }
    }
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "Failed to retrieve sample rate from input dictionary.", -1);
  }
  if (AUBeamItFDLogScope(void)::once != -1)
    dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
  if (AUBeamItFDLogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
    {
      v5 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
      if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 155;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = valuePtr;
          _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved sample rate (%iHz).\n", buf, 0x18u);
        }
      }
    }
  }
  v98 = 0;
  v6 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("nMicsUsed"));
  if (!CFNumberGetValue(v6, kCFNumberIntType, &v98))
  {
    if (AUBeamItFDLogScope(void)::once != -1)
      dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
    if (AUBeamItFDLogScope(void)::scope)
    {
      if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
      {
        v79 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
        if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
        {
          if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 171;
            _os_log_impl(&dword_1B5ED0000, v79, OS_LOG_TYPE_DEBUG, "%25s:%-5d Failed to retrieve number of mics used.\n", buf, 0x12u);
          }
        }
      }
    }
    v80 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v80, "Failed to retrieve number of mics used from input dictionary.", -1);
  }
  if (AUBeamItFDLogScope(void)::once != -1)
    dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
  if (AUBeamItFDLogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
    {
      v7 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
      if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 169;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v98;
          _os_log_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved number of mics used (%i).\n", buf, 0x18u);
        }
      }
    }
  }
  *((_DWORD *)this + 2) = v98;
  v97 = 0;
  v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("nBeams"));
  if (!CFNumberGetValue(v8, kCFNumberIntType, &v97))
  {
    if (AUBeamItFDLogScope(void)::once != -1)
      dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
    if (AUBeamItFDLogScope(void)::scope)
    {
      if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
      {
        v81 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
        if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
        {
          if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 186;
            _os_log_impl(&dword_1B5ED0000, v81, OS_LOG_TYPE_DEBUG, "%25s:%-5d Failed to retrieve number of beams.\n", buf, 0x12u);
          }
        }
      }
    }
    v82 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v82, "Failed to retrieve number of beams from input dictionary.", -1);
  }
  if (AUBeamItFDLogScope(void)::once != -1)
    dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
  if (AUBeamItFDLogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
    {
      v9 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
      if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 184;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v97;
          _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved number of beams (%i).\n", buf, 0x18u);
        }
      }
    }
  }
  v10 = v97;
  *((_DWORD *)this + 3) = v97;
  if (v10 > 0x120)
  {
    v83 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v83, "Too many beams.", -1);
  }
  v96 = 0;
  v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("nCoefficients"));
  if (!CFNumberGetValue(v11, kCFNumberIntType, &v96))
  {
    if (AUBeamItFDLogScope(void)::once != -1)
      dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
    if (AUBeamItFDLogScope(void)::scope)
    {
      if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
      {
        v84 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
        if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
        {
          if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 209;
            _os_log_impl(&dword_1B5ED0000, v84, OS_LOG_TYPE_DEBUG, "%25s:%-5d Failed to retrieve number of coefficients.\n", buf, 0x12u);
          }
        }
      }
    }
    v85 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v85, "Failed to retrieve number of coefficients from input dictionary.", -1);
  }
  if (AUBeamItFDLogScope(void)::once != -1)
    dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
  if (AUBeamItFDLogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
    {
      v12 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
      if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 207;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v96;
          _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved number of coefficients (%i).\n", buf, 0x18u);
        }
      }
    }
  }
  v13 = (int *)((char *)this + 19600);
  *((_DWORD *)this + 4900) = v96;
  if (!*((_DWORD *)this + 3))
  {
LABEL_175:
    result = 0;
    *((_BYTE *)this + 17) = 1;
    return result;
  }
  v14 = 0;
  v87 = (std::string *)((char *)this + 660120);
  v88 = (std::string *)((char *)this + 475800);
  while (1)
  {
    std::to_string((std::string *)buf, v14);
    v15 = std::string::insert((std::string *)buf, 0, "Beam", 4uLL);
    v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v95 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)v94 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    if ((buf[23] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v95 >= 0)
      v17 = v94;
    else
      v17 = (void **)v94[0];
    v18 = CFStringCreateWithCString(0, (const char *)v17, 0x8000100u);
    v19 = (const __CFDictionary *)CFDictionaryGetValue(theDict, v18);
    if (v19)
    {
      if (AUBeamItFDLogScope(void)::once != -1)
        dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
      if (AUBeamItFDLogScope(void)::scope)
      {
        if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
        {
          v20 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
          if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
          {
            if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
            {
              v21 = v94;
              if (v95 < 0)
                v21 = (void **)v94[0];
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 234;
              *(_WORD *)&buf[18] = 2080;
              *(_QWORD *)&buf[20] = v21;
              _os_log_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_DEBUG, "%25s:%-5d Found the dictionary: %s\n", buf, 0x1Cu);
            }
          }
        }
      }
      CFRelease(v18);
      v22 = (const __CFString *)CFDictionaryGetValue(v19, CFSTR("Description"));
      if (!v22)
      {
        if (AUBeamItFDLogScope(void)::once != -1)
          dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
        if (AUBeamItFDLogScope(void)::scope)
        {
          if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
          {
            v69 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
            if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
            {
              if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 243;
                _os_log_impl(&dword_1B5ED0000, v69, OS_LOG_TYPE_DEBUG, "%25s:%-5d Failed to retrieve the beam description.\n", buf, 0x12u);
              }
            }
          }
        }
        v70 = (CAXException *)__cxa_allocate_exception(0x110uLL);
        CAXException::CAXException(v70, "Failed to retrieve the beam description from input dictionary.", -1);
      }
      if (AUBeamItFDLogScope(void)::once != -1)
        dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
      if (AUBeamItFDLogScope(void)::scope)
      {
        if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
        {
          v23 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
          if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
          {
            if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
            {
              CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 241;
              *(_WORD *)&buf[18] = 2080;
              *(_QWORD *)&buf[20] = CStringPtr;
              v101 = 1024;
              v102 = v14;
              _os_log_impl(&dword_1B5ED0000, v23, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved the description (%s) for Beam %d.\n", buf, 0x22u);
            }
          }
        }
      }
      v93 = 0.0;
      v25 = (const __CFNumber *)CFDictionaryGetValue(v19, CFSTR("Distance"));
      if (!CFNumberGetValue(v25, kCFNumberFloat32Type, &v93))
      {
        if (AUBeamItFDLogScope(void)::once != -1)
          dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
        if (AUBeamItFDLogScope(void)::scope)
        {
          if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
          {
            v75 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
            if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
            {
              if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 256;
                _os_log_impl(&dword_1B5ED0000, v75, OS_LOG_TYPE_DEBUG, "%25s:%-5d Failed to retrieve beam distance.\n", buf, 0x12u);
              }
            }
          }
        }
        v76 = (CAXException *)__cxa_allocate_exception(0x110uLL);
        CAXException::CAXException(v76, "Failed to retrieve beam distance from input dictionary.", -1);
      }
      if (AUBeamItFDLogScope(void)::once != -1)
        dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
      if (AUBeamItFDLogScope(void)::scope)
      {
        if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
        {
          v26 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
          if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
          {
            if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 254;
              *(_WORD *)&buf[18] = 2048;
              *(double *)&buf[20] = v93;
              _os_log_impl(&dword_1B5ED0000, v26, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved beam distance (%0.2f).\n", buf, 0x1Cu);
            }
          }
        }
      }
      *((float *)this + v14 + 426) = v93;
      v92 = 0.0;
      v27 = (const __CFNumber *)CFDictionaryGetValue(v19, CFSTR("Azimuth"));
      if (!CFNumberGetValue(v27, kCFNumberFloat64Type, &v92))
      {
        if (AUBeamItFDLogScope(void)::once != -1)
          dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
        if (AUBeamItFDLogScope(void)::scope)
        {
          if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
          {
            v73 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
            if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
            {
              if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 270;
                _os_log_impl(&dword_1B5ED0000, v73, OS_LOG_TYPE_DEBUG, "%25s:%-5d Failed to retrieve beam azimuth.\n", buf, 0x12u);
              }
            }
          }
        }
        v74 = (CAXException *)__cxa_allocate_exception(0x110uLL);
        CAXException::CAXException(v74, "Failed to retrieve beam azimuth from input dictionary.", -1);
      }
      if (AUBeamItFDLogScope(void)::once != -1)
        dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
      if (AUBeamItFDLogScope(void)::scope)
      {
        if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
        {
          v28 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
          if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
          {
            if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
            {
              v29 = v92;
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 268;
              *(_WORD *)&buf[18] = 2048;
              *(double *)&buf[20] = v29;
              _os_log_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved beam azimuth (%0.2f).\n", buf, 0x1Cu);
            }
          }
        }
      }
      v30 = v92;
      *((float *)this + v14 + 714) = v30;
      v91 = 0.0;
      v31 = (const __CFNumber *)CFDictionaryGetValue(v19, CFSTR("Elevation"));
      if (!CFNumberGetValue(v31, kCFNumberFloat64Type, &v91))
      {
        if (AUBeamItFDLogScope(void)::once != -1)
          dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
        if (AUBeamItFDLogScope(void)::scope)
        {
          if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
          {
            v71 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
            if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
            {
              if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 284;
                _os_log_impl(&dword_1B5ED0000, v71, OS_LOG_TYPE_DEBUG, "%25s:%-5d Failed to retrieve beam elevation.\n", buf, 0x12u);
              }
            }
          }
        }
        v72 = (CAXException *)__cxa_allocate_exception(0x110uLL);
        CAXException::CAXException(v72, "Failed to retrieve beam elevation from input dictionary.", -1);
      }
      if (AUBeamItFDLogScope(void)::once != -1)
        dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
      if (AUBeamItFDLogScope(void)::scope)
      {
        if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
        {
          v32 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
          if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
          {
            if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
            {
              v33 = v91;
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 282;
              *(_WORD *)&buf[18] = 2048;
              *(double *)&buf[20] = v33;
              _os_log_impl(&dword_1B5ED0000, v32, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved beam elevation (%0.2f).\n", buf, 0x1Cu);
            }
          }
        }
      }
      v34 = v91;
      *((float *)this + v14 + 1002) = v34;
      BeamformerBase::ReadVectorFromDictionary((BeamformerBase *)buf, v19, CFSTR("NonZeroMics"));
      v35 = (void **)((char *)this + 24 * v14 + 247704);
      v36 = *v35;
      if (*v35)
      {
        *((_QWORD *)this + 3 * v14 + 30964) = v36;
        operator delete(v36);
        *v35 = 0;
        *((_QWORD *)this + 3 * v14 + 30964) = 0;
        *((_QWORD *)this + 3 * v14 + 30965) = 0;
      }
      *(_OWORD *)v35 = *(_OWORD *)buf;
      *((_QWORD *)this + 3 * v14 + 30965) = *(_QWORD *)&buf[16];
      BeamformerBase::ReadVectorFromDictionary((BeamformerBase *)&v90, v19, CFSTR("EQSelection"));
      v37 = (std::string *)((char *)this + 40 * v14 + 844440);
      LODWORD(v2) = valuePtr;
      v38 = *v13;
      if (v37 != &v90)
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)v37, v90.__r_.__value_.__l.__data_, v90.__r_.__value_.__l.__size_, (uint64_t)(v90.__r_.__value_.__l.__size_ - v90.__r_.__value_.__r.__words[0]) >> 2);
      v39 = (double *)((char *)this + 40 * v14 + 844440);
      v39[3] = (double)v2;
      *((_DWORD *)v39 + 8) = 2 * v38 - 2;
      v40 = (const __CFDictionary *)CFDictionaryGetValue(v19, CFSTR("RealCoefficients"));
      if (v40)
      {
        if (AUBeamItFDLogScope(void)::once != -1)
          dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
        if (AUBeamItFDLogScope(void)::scope)
        {
          if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
          {
            v41 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
            if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
            {
              if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
              {
                std::string::basic_string[abi:ne180100]<0>(&__p, "Found the dictionary RealCoefficients.");
                p_p = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 310;
                *(_WORD *)&buf[18] = 2080;
                *(_QWORD *)&buf[20] = p_p;
                _os_log_impl(&dword_1B5ED0000, v41, OS_LOG_TYPE_DEBUG, "%25s:%-5d %s\n", buf, 0x1Cu);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
              }
            }
          }
        }
        if (*((_DWORD *)this + 2))
        {
          v43 = 0;
          v44 = v88;
          do
          {
            std::to_string(&__p, v43);
            v45 = std::string::insert(&__p, 0, "Mic", 3uLL);
            v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
            *(_QWORD *)&buf[16] = *((_QWORD *)&v45->__r_.__value_.__l + 2);
            *(_OWORD *)buf = v46;
            v45->__r_.__value_.__l.__size_ = 0;
            v45->__r_.__value_.__r.__words[2] = 0;
            v45->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            if (buf[23] >= 0)
              v47 = buf;
            else
              v47 = *(const char **)buf;
            v48 = CFStringCreateWithCString(0, v47, 0x8000100u);
            BeamformerBase::ReadVectorFromDictionary((BeamformerBase *)&__p, v40, v48);
            if (v90.__r_.__value_.__r.__words[0])
            {
              v90.__r_.__value_.__l.__size_ = v90.__r_.__value_.__r.__words[0];
              operator delete(v90.__r_.__value_.__l.__data_);
            }
            v90 = __p;
            LODWORD(v2) = valuePtr;
            v49 = *v13;
            if (v44 != &v90)
              std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)v44, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_, (uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 2);
            *(double *)&v44[1].__r_.__value_.__l.__data_ = (double)v2;
            LODWORD(v44[1].__r_.__value_.__r.__words[1]) = 2 * v49 - 2;
            CFRelease(v48);
            if ((buf[23] & 0x80000000) != 0)
              operator delete(*(void **)buf);
            ++v43;
            v44 = (std::string *)((char *)v44 + 40);
          }
          while (v43 < *((unsigned int *)this + 2));
        }
        v50 = (const __CFDictionary *)CFDictionaryGetValue(v19, CFSTR("ImagCoefficients"));
        if (v50)
        {
          if (AUBeamItFDLogScope(void)::once != -1)
            dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
          if (AUBeamItFDLogScope(void)::scope)
          {
            if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
            {
              v51 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
              if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
              {
                if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
                {
                  std::string::basic_string[abi:ne180100]<0>(&__p, "Found the dictionary ImagCoefficients.");
                  v52 = &__p;
                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    v52 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = 329;
                  *(_WORD *)&buf[18] = 2080;
                  *(_QWORD *)&buf[20] = v52;
                  _os_log_impl(&dword_1B5ED0000, v51, OS_LOG_TYPE_DEBUG, "%25s:%-5d %s\n", buf, 0x1Cu);
                  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(__p.__r_.__value_.__l.__data_);
                }
              }
            }
          }
          if (*((_DWORD *)this + 2))
          {
            v53 = 0;
            v54 = v87;
            do
            {
              std::to_string(&__p, v53);
              v55 = std::string::insert(&__p, 0, "Mic", 3uLL);
              v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
              *(_QWORD *)&buf[16] = *((_QWORD *)&v55->__r_.__value_.__l + 2);
              *(_OWORD *)buf = v56;
              v55->__r_.__value_.__l.__size_ = 0;
              v55->__r_.__value_.__r.__words[2] = 0;
              v55->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__p.__r_.__value_.__l.__data_);
              if (buf[23] >= 0)
                v57 = buf;
              else
                v57 = *(const char **)buf;
              v58 = CFStringCreateWithCString(0, v57, 0x8000100u);
              BeamformerBase::ReadVectorFromDictionary((BeamformerBase *)&__p, v50, v58);
              if (v90.__r_.__value_.__r.__words[0])
              {
                v90.__r_.__value_.__l.__size_ = v90.__r_.__value_.__r.__words[0];
                operator delete(v90.__r_.__value_.__l.__data_);
              }
              v90 = __p;
              LODWORD(v2) = valuePtr;
              v59 = *v13;
              if (v54 != &v90)
                std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)v54, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_, (uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 2);
              *(double *)&v54[1].__r_.__value_.__l.__data_ = (double)v2;
              LODWORD(v54[1].__r_.__value_.__r.__words[1]) = 2 * v59 - 2;
              CFRelease(v58);
              if ((buf[23] & 0x80000000) != 0)
                operator delete(*(void **)buf);
              ++v53;
              v54 = (std::string *)((char *)v54 + 40);
            }
            while (v53 < *((unsigned int *)this + 2));
          }
          v60 = 0;
          goto LABEL_169;
        }
        if (AUBeamItFDLogScope(void)::once != -1)
          dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
        if (!AUBeamItFDLogScope(void)::scope
          || (*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) == 0
          || (v66 = *(NSObject **)AUBeamItFDLogScope(void)::scope) == 0
          || !os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
LABEL_168:
          v60 = 1;
LABEL_169:
          if (v90.__r_.__value_.__r.__words[0])
          {
            v90.__r_.__value_.__l.__size_ = v90.__r_.__value_.__r.__words[0];
            operator delete(v90.__r_.__value_.__l.__data_);
          }
          goto LABEL_171;
        }
        std::string::basic_string[abi:ne180100]<0>(&__p, "Missing dictionary ImagCoefficients");
        v67 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v67 = (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 324;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v67;
        v65 = v66;
      }
      else
      {
        if (AUBeamItFDLogScope(void)::once != -1)
          dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
        if (!AUBeamItFDLogScope(void)::scope)
          goto LABEL_168;
        if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) == 0)
          goto LABEL_168;
        v63 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
        if (!*(_QWORD *)AUBeamItFDLogScope(void)::scope
          || !os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          goto LABEL_168;
        }
        std::string::basic_string[abi:ne180100]<0>(&__p, "Missing dictionary RealCoefficients");
        v64 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v64 = (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 305;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v64;
        v65 = v63;
      }
      _os_log_impl(&dword_1B5ED0000, v65, OS_LOG_TYPE_DEBUG, "%25s:%-5d %s\n", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_168;
    }
    if (AUBeamItFDLogScope(void)::once != -1)
      dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
    if (AUBeamItFDLogScope(void)::scope)
    {
      if ((*(_BYTE *)(AUBeamItFDLogScope(void)::scope + 8) & 1) != 0)
      {
        v61 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
        if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
        {
          if (os_log_type_enabled(*(os_log_t *)AUBeamItFDLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
          {
            v62 = v94;
            if (v95 < 0)
              v62 = (void **)v94[0];
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "BeamformerFD.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 228;
            *(_WORD *)&buf[18] = 2080;
            *(_QWORD *)&buf[20] = v62;
            _os_log_impl(&dword_1B5ED0000, v61, OS_LOG_TYPE_DEBUG, "%25s:%-5d Missing dictionary: %s\n", buf, 0x1Cu);
          }
        }
      }
    }
    CFRelease(v18);
    v60 = 1;
LABEL_171:
    if (SHIBYTE(v95) < 0)
      operator delete(v94[0]);
    if (v60)
      return 4294956446;
    ++v14;
    v87 = (std::string *)((char *)v87 + 640);
    v88 = (std::string *)((char *)v88 + 640);
    if (v14 >= *((unsigned int *)this + 3))
      goto LABEL_175;
  }
}

void sub_1B65969B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (__p)
    operator delete(__p);
  if (a35 < 0)
    operator delete(a30);
  _Unwind_Resume(exception_object);
}

void BeamformerFD::CalculateSubbandDOA(BeamformerFD *this)
{
  unsigned int *v1;
  int v3;
  float v4;
  float v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  unsigned int v9;
  char *v10;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  float *v15;
  float *v16;
  const float *v17;
  float *v18;
  uint64_t v19;
  float v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  float *v28;
  float *v29;
  uint64_t i;
  uint64_t v31;
  unsigned int v32;
  float v33;
  float v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  float v38;
  float v39;
  float __D;
  float v41;
  float v42;
  DSPSplitComplex __B;

  if (*((_BYTE *)this + 856008))
  {
    v1 = (unsigned int *)*((_QWORD *)this + 107002);
    if (v1)
    {
      v3 = *((unsigned __int8 *)this + 104);
      v4 = *((float *)this + 12);
      v5 = *((float *)this + 25);
      v6 = *((_DWORD *)this + 20);
      v7 = *((_DWORD *)this + 21);
      v8 = *((unsigned int *)this + 10);
      v42 = v4;
      v9 = v1[1];
      if (v9 <= v6)
        __assert_rtn("CalculateSubbandDOA", "SubbandDOACalculator.cpp", 23, "beamsFrom < mNumBeams");
      if (v9 <= v7)
        __assert_rtn("CalculateSubbandDOA", "SubbandDOACalculator.cpp", 24, "beamsTo < mNumBeams");
      v10 = (char *)this + 5160;
      if (v4 <= 0.0 && v3 == 0)
      {
        if (v7 >= v6)
        {
          v22 = *v1;
          v23 = v6;
          do
          {
            v24 = v23;
            v25 = 3 * v23;
            v26 = &v10[8 * v25];
            v27 = *(_QWORD *)v26 + 4 * v22;
            v28 = (float *)(*(_QWORD *)v26 + 4);
            v29 = *(float **)(*((_QWORD *)v1 + 4) + 8 * v25);
            *v29 = **(float **)v26 * **(float **)v26;
            __B.realp = v28;
            __B.imagp = (float *)(v27 + 4);
            vDSP_zvmags(&__B, 1, v29 + 1, 1, (v8 - 1));
            if ((_DWORD)v8 == (_DWORD)v22)
              *(float *)(*(_QWORD *)(*((_QWORD *)v1 + 4) + 24 * v24) + 4 * v22) = *(float *)(*(_QWORD *)v26 + 4 * v22)
                                                                                  * *(float *)(*(_QWORD *)v26 + 4 * v22);
            v23 = v24 + 1;
          }
          while (v24 + 1 <= v7);
        }
      }
      else
      {
        if (v3)
          bzero(*((void **)v1 + 17), *((_QWORD *)v1 + 18) - *((_QWORD *)v1 + 17));
        if (v7 >= v6)
        {
          v12 = v6;
          while (1)
          {
            v13 = v12;
            v14 = 24 * v12;
            vDSP_vsq(*(const float **)&v10[v14], 1, *((float **)v1 + 11), 1, 2 * *v1);
            vDSP_vadd((const float *)(*((_QWORD *)v1 + 11) + 4), 1, (const float *)(*((_QWORD *)v1 + 11) + 4 + 4 * *v1), 1, (float *)(*((_QWORD *)v1 + 14) + 4), 1, *v1 - 1);
            v15 = *(float **)&v10[v14];
            v16 = (float *)*((_QWORD *)v1 + 14);
            *v16 = *v15 * *v15;
            v16[*v1] = v15[*v1] * v15[*v1];
            LODWORD(__B.realp) = 786163455;
            vDSP_vthr(v16, 1, (const float *)&__B, v16, 1, (uint64_t)(*((_QWORD *)v1 + 15) - (_QWORD)v16) >> 2);
            v41 = 1.0;
            v17 = (const float *)*((_QWORD *)v1 + 14);
            if (v42 > 0.0)
              break;
            v19 = *((_QWORD *)v1 + 4) + 24 * v13;
            vDSP_vdbcon(v17, 1, &v41, *(float **)v19, 1, (uint64_t)(*(_QWORD *)(v19 + 8) - *(_QWORD *)v19) >> 2, 0);
            if (v3)
              goto LABEL_17;
LABEL_18:
            v12 = v13 + 1;
            if (v13 + 1 > v7)
              goto LABEL_19;
          }
          vDSP_vdbcon(v17, 1, &v41, *((float **)v1 + 14), 1, (uint64_t)(*((_QWORD *)v1 + 15) - (_QWORD)v17) >> 2, 0);
          __D = 1.0 - v42;
          v18 = *(float **)(*((_QWORD *)v1 + 4) + 24 * v13);
          vDSP_vsmsma(v18, 1, &v42, *((const float **)v1 + 14), 1, &__D, v18, 1, *v1 + 1);
          if (!v3)
            goto LABEL_18;
LABEL_17:
          vDSP_vadd(*((const float **)v1 + 17), 1, *(const float **)(*((_QWORD *)v1 + 4) + 24 * v13), 1, *((float **)v1 + 17), 1, *v1 + 1);
          goto LABEL_18;
        }
LABEL_19:
        if (v3)
        {
          v20 = -1.0 / (double)(v7 - v6 + 1);
          *(float *)&__B.realp = v20;
          vDSP_vsmul(*((const float **)v1 + 17), 1, (const float *)&__B, *((float **)v1 + 17), 1, *v1 + 1);
          if (v7 >= v6)
          {
            v21 = v6;
            do
            {
              vDSP_vadd(*(const float **)(*((_QWORD *)v1 + 4) + 24 * v21), 1, *((const float **)v1 + 17), 1, *(float **)(*((_QWORD *)v1 + 4) + 24 * v21), 1, *v1 + 1);
              ++v21;
            }
            while (v21 <= v7);
          }
        }
      }
      if ((_DWORD)v8)
      {
        for (i = 0; i != v8; ++i)
        {
          if (v7 >= v6)
          {
            v31 = *((_QWORD *)v1 + 4);
            v32 = v6;
            v33 = v5;
            do
            {
              v34 = *(float *)(*(_QWORD *)(v31 + 24 * v32) + 4 * i);
              if (v34 > v33)
              {
                *(_DWORD *)(*((_QWORD *)v1 + 1) + 4 * i) = v32;
                v33 = v34;
              }
              ++v32;
            }
            while (v32 <= v7);
          }
        }
      }
      v35 = *((_QWORD *)v1 + 1);
      if (*((_QWORD *)v1 + 2) != v35)
      {
        v36 = 0;
        do
        {
          if (v36 >= v8)
          {
            v38 = 0.0;
            v39 = 0.0;
          }
          else
          {
            v37 = *(unsigned int *)(v35 + 4 * v36);
            v38 = *((float *)this + v37 + 714);
            v39 = *((float *)this + v37 + 1002);
          }
          SubbandDOA::Set((SubbandDOA *)(v1 + 14), v36++, v38, v39);
          v35 = *((_QWORD *)v1 + 1);
        }
        while (v36 < (*((_QWORD *)v1 + 2) - v35) >> 2);
      }
    }
  }
}

uint64_t BeamformerFD::SetSubbandDOACalcuationEnabled(BeamformerFD *this, char a2)
{
  NSObject *v2;
  uint64_t result;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 16))
  {
    result = 0;
    *((_BYTE *)this + 856008) = a2;
    return result;
  }
  if (AUBeamItFDLogScope(void)::once != -1)
    dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
  if (!AUBeamItFDLogScope(void)::scope)
  {
    v2 = MEMORY[0x1E0C81028];
LABEL_9:
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "BeamformerFD.cpp";
      v7 = 1024;
      v8 = 884;
      _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_ERROR, "%25s:%-5d SetSubbandDOACalcuationEnabled failed, subband DOA calculator is already initialized and this value cannot be changed.", (uint8_t *)&v5, 0x12u);
    }
    return 4294956447;
  }
  v2 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
  if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
    goto LABEL_9;
  return 4294956447;
}

uint64_t BeamformerFD::GetSubbandDOACalcuationEnabled(BeamformerFD *this)
{
  return *((unsigned __int8 *)this + 856008);
}

uint64_t BeamformerFD::BorrowSubbandDOA(BeamformerFD *this)
{
  uint64_t v1;
  NSObject *v3;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v1 = *((_QWORD *)this + 107002);
  if (v1)
    return v1 + 56;
  if (AUBeamItFDLogScope(void)::once != -1)
    dispatch_once(&AUBeamItFDLogScope(void)::once, &__block_literal_global_24087);
  if (!AUBeamItFDLogScope(void)::scope)
  {
    v3 = MEMORY[0x1E0C81028];
LABEL_9:
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = 136315394;
      v5 = "BeamformerFD.cpp";
      v6 = 1024;
      v7 = 871;
      _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d BorrowSubbandDOA failed, subband DOA calculator is not initialized.", (uint8_t *)&v4, 0x12u);
    }
    return 0;
  }
  v3 = *(NSObject **)AUBeamItFDLogScope(void)::scope;
  if (*(_QWORD *)AUBeamItFDLogScope(void)::scope)
    goto LABEL_9;
  return 0;
}

void BeamformerFD::MakeABeam(uint64_t a1, unsigned int *a2, float **a3, unsigned int a4)
{
  uint64_t v8;
  float *v9;
  float *v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  float **v14;
  uint64_t v15;
  float *v16;
  vDSP_Length v17;
  DSPSplitComplex v18;
  DSPSplitComplex __A;
  DSPSplitComplex v20;
  DSPSplitComplex __C;

  vDSP_vclr(*a3, 1, (2 * *(_DWORD *)(a1 + 32)));
  v8 = *(unsigned int *)(a1 + 32);
  v9 = (float *)(*(_QWORD *)(a1 + 19056) + 4 * v8);
  __C.realp = *(float **)(a1 + 19056);
  __C.imagp = v9;
  v10 = &(*a3)[v8];
  v20.realp = *a3;
  v20.imagp = v10;
  v11 = *a2;
  if ((_DWORD)v11)
  {
    v12 = 0;
    v13 = (_QWORD *)(a1 + 24 * a4 + 247704);
    v14 = (float **)(a1 + 384 * a4 + 130200);
    v15 = 4;
    do
    {
      if (*(float *)(*v13 + 4 * v12) == 1.0)
      {
        v16 = *v14;
        __A.realp = *(v14 - 13824);
        __A.imagp = v16;
        v17 = *(unsigned int *)(a1 + 32);
        v18.realp = *(float **)&a2[v15];
        v18.imagp = &v18.realp[v17];
        vDSP_zvmul(&__A, 1, &v18, 1, &__C, 1, v17, 1);
        *__C.realp = *__A.realp * *v18.realp;
        *__C.imagp = *__A.imagp * *v18.imagp;
        vDSP_zvadd(&v20, 1, &__C, 1, &v20, 1, *(unsigned int *)(a1 + 32));
        v11 = *a2;
      }
      ++v12;
      v15 += 4;
      v14 += 3;
    }
    while (v12 < v11);
  }
}

void BeamformerFD::CrossfadeBeams(uint64_t a1, const float **a2, uint64_t a3)
{
  const float *v4;
  const float *v5;
  float *v6;
  float *v8;
  float *v9;
  float __C;

  v4 = *a2;
  v5 = a2[1];
  v6 = *(float **)a3;
  if ((char *)v5 - (char *)*a2 == *(_QWORD *)(a3 + 8) - (_QWORD)v6)
  {
    if (v4 == v5)
      return;
    v8 = v6;
    v9 = (float *)*a2;
    while (*v9 == *v8)
    {
      ++v9;
      ++v8;
      if (v9 == v5)
        return;
    }
  }
  __C = 0.5;
  vDSP_vasm(v4, 1, v6, 1, &__C, v6, 1, (2 * *(_DWORD *)(a1 + 32)));
}

uint64_t BeamformerFD::MakeABeamWithCrossfade(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v6;
  uint64_t result;

  v6 = a4;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4, 0);
  if ((_DWORD)a5 != v6)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 80))(a1, a2, a1 + 19176, a5, 0);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 88))(a1, a1 + 19176, a3);
  }
  return result;
}

void BeamformerFD::ApplyEQ(uint64_t a1, const float **a2, float **a3, unsigned int a4, int a5)
{
  if (a5 == 1)
    vDSP_vmul(*a2, 1, *(const float **)(a1 + 24 * a4 + 240792), 1, *a3, 1, (2 * *(_DWORD *)(a1 + 32)));
  else
    memcpy(*a3, *a2, 4 * (2 * *(_DWORD *)(a1 + 32)));
}

void BeamformerFD::MakePHATBeam(uint64_t a1, unsigned int *a2, float **a3, float **a4, unsigned int a5)
{
  vDSP_Length v10;
  unsigned int v11;
  vDSP_Length v12;
  float *v13;
  vDSP_Length v14;
  uint64_t v15;
  float *v16;
  float *v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  vDSP_Length v21;
  float **v22;
  float **v23;
  uint64_t v24;
  float *v25;
  float *v26;
  DSPSplitComplex __B;
  DSPSplitComplex __A;
  DSPSplitComplex v29;
  DSPSplitComplex v30;
  DSPSplitComplex __C;
  float v32;
  float v33;

  v33 = 2.2204e-16;
  v32 = sqrtf(fmaxf((float)*(unsigned int *)(a1 + 44), 0.0)) * (float)*(unsigned int *)(a1 + 8);
  LODWORD(v10) = *(_DWORD *)(a1 + 32);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1))
  {
    v10 = *(unsigned int *)(a1 + 40);
    v11 = *(_DWORD *)(a1 + 32) - 1;
    if (v11 >= v10)
      v12 = v10;
    else
      v12 = v11;
    vDSP_vclr(*a3, 1, *(unsigned int *)(a1 + 40));
    vDSP_vclr(&(*a3)[*(unsigned int *)(a1 + 32) + 1], 1, v12);
    vDSP_vclr(*a4, 1, v10);
    v13 = &(*a4)[*(unsigned int *)(a1 + 32) + 1];
    v14 = v12;
  }
  else
  {
    vDSP_vclr(*a3, 1, (2 * *(_DWORD *)(a1 + 32)));
    v13 = *a4;
    v14 = (2 * *(_DWORD *)(a1 + 32));
  }
  vDSP_vclr(v13, 1, v14);
  v15 = *(unsigned int *)(a1 + 32);
  __C.realp = *(float **)(a1 + 19056);
  __C.imagp = &__C.realp[v15];
  v16 = &(*a3)[v15];
  v30.realp = *a3;
  v30.imagp = v16;
  v17 = &(*a4)[v15];
  v29.realp = *a4;
  v29.imagp = v17;
  v18 = *a2;
  if ((_DWORD)v18)
  {
    v19 = 0;
    v20 = (_QWORD *)(a1 + 24 * a5 + 247704);
    v21 = v10;
    v22 = (float **)(a1 + 855960);
    v23 = (float **)(a1 + 384 * a5 + 130200);
    v24 = 4;
    do
    {
      if (*(float *)(*v20 + 4 * v19) == 1.0)
      {
        v25 = *v23;
        __A.realp = *(v23 - 13824);
        __A.imagp = v25;
        v26 = (float *)(*(_QWORD *)&a2[v24] + 4 * *(unsigned int *)(a1 + 32));
        __B.realp = *(float **)&a2[v24];
        __B.imagp = v26;
        vDSP_zvmul(&__A, 1, &__B, 1, &__C, 1, v21, 1);
        *__C.realp = *__A.realp * *__B.realp;
        *__C.imagp = *__A.imagp * *__B.imagp;
        vDSP_zvadd(&v30, 1, &__C, 1, &v30, 1, v21);
        vDSP_zvabs(&__C, 1, *v22, 1, v21);
        vDSP_vsmsa(*v22, 1, &v32, &v33, *v22, 1, v21);
        vDSP_zrvdiv(&__C, 1, *v22, 1, &__C, 1, v21);
        *__C.realp = (float)(*__A.realp * *__B.realp) / (float)(v33 + (float)(v32 * fabsf(*__A.realp * *__B.realp)));
        *__C.imagp = (float)(*__A.imagp * *__B.imagp) / (float)(v33 + (float)(v32 * fabsf(*__A.imagp * *__B.imagp)));
        vDSP_zvadd(&v29, 1, &__C, 1, &v29, 1, v21);
        v18 = *a2;
      }
      ++v19;
      v24 += 4;
      v23 += 3;
    }
    while (v19 < v18);
  }
}

float BeamformerFD::MakeLSDDBeam(uint64_t a1, unsigned int *a2, float **a3, float **a4, uint64_t a5)
{
  uint64_t v9;
  vDSP_Length v10;
  uint64_t v11;
  float *v12;
  float *v13;
  unint64_t v14;
  unint64_t v15;
  float **v16;
  uint64_t v17;
  float *v18;
  float *v19;
  float *v20;
  float *v21;
  float v22;
  float v23;
  unsigned int *v24;
  unint64_t v25;
  unint64_t v26;
  float **v27;
  uint64_t v28;
  vDSP_Length __N;
  float *v30;
  uint64_t v31;
  float *v32;
  float *v33;
  float *v34;
  float *v35;
  float v36;
  float v37;
  uint64_t v38;
  const float *v39;
  float result;
  vDSP_Length v41;
  unsigned int v42;
  float *v43;
  uint64_t v44;
  float *v45;
  float **v46;
  _QWORD *v47;
  unsigned int *v48;
  DSPSplitComplex v49;
  DSPSplitComplex __A;
  DSPSplitComplex __B;
  DSPSplitComplex __D;
  DSPSplitComplex __C;
  float v54[3];

  v9 = a1;
  v54[0] = 2.2204e-16;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1))
    vDSP_vclr(*a3, 1, (2 * *(_DWORD *)(v9 + 32)));
  else
    (*(void (**)(uint64_t, unsigned int *, float **, uint64_t, _QWORD))(*(_QWORD *)v9 + 80))(v9, a2, a3, a5, 0);
  LODWORD(v10) = *(_DWORD *)(v9 + 32);
  v42 = a5;
  v46 = a4;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 64))(v9))
  {
    v10 = *(unsigned int *)(v9 + 40);
    vDSP_vclr(*a4, 1, v10);
    vDSP_vclr(&(*a4)[*(unsigned int *)(v9 + 32)], 1, v10);
    vDSP_vclr(*(float **)(v9 + 19056), 1, v10);
    vDSP_vclr((float *)(*(_QWORD *)(v9 + 19056) + 4 * *(unsigned int *)(v9 + 32)), 1, v10);
    vDSP_vclr(*(float **)(v9 + 855984), 1, v10);
    vDSP_vclr((float *)(*(_QWORD *)(v9 + 855984) + 4 * *(unsigned int *)(v9 + 32)), 1, v10);
    vDSP_vclr(*(float **)(v9 + 19128), 1, v10);
    v11 = *(unsigned int *)(v9 + 32);
    *(_DWORD *)(*(_QWORD *)(v9 + 19128) + 4 * v11) = 0;
  }
  else
  {
    vDSP_vclr(*a4, 1, (2 * *(_DWORD *)(v9 + 32)));
    vDSP_vclr(*(float **)(v9 + 19056), 1, (2 * *(_DWORD *)(v9 + 32)));
    vDSP_vclr(*(float **)(v9 + 855984), 1, (2 * *(_DWORD *)(v9 + 32)));
    vDSP_vclr(*(float **)(v9 + 19128), 1, (*(_DWORD *)(v9 + 32) + 1));
    v11 = *(unsigned int *)(v9 + 32);
  }
  v12 = *(float **)(v9 + 855984);
  v13 = &v12[v11];
  __C.realp = v12;
  __C.imagp = v13;
  __D.realp = v12 + 1;
  __D.imagp = v13 + 1;
  v48 = a2;
  v14 = *a2;
  if ((_DWORD)v14)
  {
    v15 = 0;
    v16 = (float **)(v9 + 384 * v42 + 365208);
    v17 = 4;
    do
    {
      if (*(float *)(*(_QWORD *)(v9 + 24 * v42 + 247704) + 4 * v15) == 1.0)
      {
        v18 = *(float **)&v48[v17];
        v19 = &v18[*(unsigned int *)(v9 + 32)];
        __B.realp = v18 + 1;
        __B.imagp = v19 + 1;
        v20 = *(v16 - 13824);
        v21 = *v16;
        v22 = *v20;
        __A.realp = v20 + 1;
        *v12 = *v12 + (float)(v22 * *v18);
        v23 = *v21;
        __A.imagp = v21 + 1;
        *v13 = *v13 + (float)(v23 * *v19);
        vDSP_zvcma(&__A, 1, &__B, 1, &__D, 1, &__D, 1, (v10 - 1));
        v14 = *v48;
      }
      ++v15;
      v16 += 3;
      v17 += 4;
    }
    while (v15 < v14);
  }
  v41 = v10;
  vDSP_zvneg(&__C, 1, &__C, 1, v10);
  v43 = *(float **)(v9 + 19056);
  v44 = *(unsigned int *)(v9 + 32);
  __B.realp = v43 + 1;
  __B.imagp = &v43[v44 + 1];
  v24 = v48;
  v45 = *v46;
  v25 = *v48;
  if ((_DWORD)v25)
  {
    v26 = 0;
    v47 = (_QWORD *)(v9 + 24 * v42 + 247704);
    v27 = (float **)(v9 + 384 * v42 + 365208);
    v28 = 4;
    __N = (v10 - 1);
    do
    {
      if (*(float *)(*v47 + 4 * v26) == 1.0)
      {
        v30 = *(float **)&v24[v28];
        v31 = v9;
        v32 = &v30[*(unsigned int *)(v9 + 32)];
        __A.realp = v30 + 1;
        __A.imagp = v32 + 1;
        v33 = *(v27 - 13824);
        v34 = *v27;
        v35 = *v27 + 1;
        v49.realp = v33 + 1;
        v49.imagp = v35;
        *v45 = *v45 + (float)(*v30 * *v30);
        v45[v44] = v45[v44] + (float)(*v32 * *v32);
        vDSP_zvmgsa(&__A, 1, v45 + 1, 1, v45 + 1, 1, __N);
        v36 = *v30;
        v24 = v48;
        *v43 = v36 + (float)(*__C.realp * *v33);
        v37 = *v32;
        v9 = v31;
        v43[v44] = v37 + (float)(*__C.imagp * *v34);
        vDSP_zvma(&__D, 1, &v49, 1, &__A, 1, &__B, 1, __N);
        v38 = *(_QWORD *)(v31 + 19128);
        *(float *)v38 = *(float *)v38 + (float)(*v43 * *v43);
        *(float *)(v38 + 4 * *(unsigned int *)(v31 + 32)) = *(float *)(v38 + 4 * *(unsigned int *)(v31 + 32))
                                                            + (float)(v43[v44] * v43[v44]);
        vDSP_zvmgsa(&__B, 1, (const float *)(v38 + 4), 1, (float *)(v38 + 4), 1, __N);
        v25 = *v48;
      }
      ++v26;
      v27 += 3;
      v28 += 4;
    }
    while (v26 < v25);
  }
  vDSP_vsadd(*(const float **)(v9 + 19128), 1, v54, *(float **)(v9 + 19128), 1, v41);
  v39 = *(const float **)(v9 + 19128);
  v39[*(unsigned int *)(v9 + 32)] = v39[*(unsigned int *)(v9 + 32)] + 2.2204e-16;
  vDSP_vdiv(v39, 1, v45, 1, v45, 1, v41);
  result = v45[v44] / *(float *)(*(_QWORD *)(v9 + 19128) + 4 * *(unsigned int *)(v9 + 32));
  v45[v44] = result;
  return result;
}

uint64_t BeamformerFD::ECMixSwitch(BeamformerFD *this)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  float *v5;
  unsigned int v6;
  float v7;
  float *v8;
  _QWORD *v9;
  float v10;
  float *v11;
  float *v12;
  uint64_t v13;
  float v14;
  float v15;
  float *v16;
  uint64_t v17;
  float v18;
  _QWORD *v19;
  float32x2_t v20;
  float v21;
  float32x2_t v22;
  float v23;
  float v24;
  float32x2_t v25;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x1E0C80C00];
  result = MEMORY[0x1E0C80A78](this);
  v5 = (float *)((char *)v26 - ((v4 + 15) & 0x7FFFFFFF0));
  if ((_DWORD)v3)
  {
    v6 = *(_DWORD *)(result + 108);
    v7 = (float)((float)*(unsigned int *)(result + 32) * 1000.0) / (*(double *)(result + 24) * 0.5);
    LODWORD(v2) = vcvtas_u32_f32(v7);
    v8 = *(float **)(result + 24 * v6 + 247704);
    v9 = (_QWORD *)(result + 384 * v6 + 130200);
    v10 = 2.2204e-16;
    v11 = v8;
    v12 = v5;
    v13 = v3;
    do
    {
      if (*v11 == 1.0)
      {
        v14 = *(float *)(*(v9 - 13824) + 4 * v2);
        v15 = (float)(*(float *)(*v9 + 4 * v2) * *(float *)(*v9 + 4 * v2)) + (float)(v14 * v14);
      }
      else
      {
        v15 = 0.0;
      }
      *v12++ = v15;
      v10 = v10 + v15;
      v9 += 3;
      ++v11;
      --v13;
    }
    while (v13);
    v16 = v5;
    v17 = v3;
    v18 = 1.0 / v10;
    do
    {
      *v16 = v18 * *v16;
      ++v16;
      --v17;
    }
    while (v17);
    v19 = (_QWORD *)(result + 240);
    v20 = 0;
    v21 = 1.0;
    v22 = 0;
    do
    {
      if (*v8 == 1.0)
        v21 = v21 * *((float *)v19 - 1);
      v23 = *v5++;
      v24 = v23;
      v20 = vmla_n_f32(v20, *(float32x2_t *)((char *)v19 - 12), v23);
      v25 = *(float32x2_t *)v19;
      v19 = (_QWORD *)((char *)v19 + 20);
      v22 = vmla_n_f32(v22, v25, v24);
      ++v8;
      --v3;
    }
    while (v3);
  }
  else
  {
    v20 = 0;
    v21 = 1.0;
    v22 = 0;
  }
  *(float32x2_t *)(result + 228) = v20;
  *(float32x2_t *)(result + 240) = v22;
  *(float *)(result + 236) = v21;
  return result;
}

void BeamformerFD::SelectBeam(float **this)
{
  vDSP_Length v2;
  char *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  float v7;
  const float *v8;
  const float *v9;
  vDSP_Length v10;
  int v11;
  int v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  const float *v19;
  vDSP_Length v20;
  uint64_t v21;
  vDSP_Length v22;
  int v23;
  uint64_t __B;
  vDSP_Length __I;
  float v26;
  uint64_t __C;

  v26 = 0.0;
  __B = 0;
  __I = 0;
  vDSP_vclr(this[2394], 1, *((unsigned int *)this + 3));
  if (*((_DWORD *)this + 3))
  {
    v2 = 0;
    v3 = (char *)(this + 69);
    v4 = (uint64_t *)(this + 645);
    do
    {
      __C = 0;
      v5 = *v4;
      v4 += 3;
      v6 = *((unsigned int *)this + 8);
      v7 = *(float *)(v5 + 4 * v6) * *(float *)(v5 + 4 * v6);
      v8 = (const float *)(v5 + 4 * *((unsigned int *)this + 9));
      v9 = &v8[v6];
      v10 = *((_DWORD *)this + 11) - (*((_DWORD *)this + 10) == (_DWORD)v6);
      vDSP_svesq(v8, 1, (float *)&__C + 1, v10);
      vDSP_svesq(v9, 1, (float *)&__C, v10);
      v11 = *((_DWORD *)this + 10);
      v12 = *((_DWORD *)this + 8);
      if (v11 == v12)
        v13 = v7;
      else
        v13 = -0.0;
      if (v11 == v12)
        v14 = 0.0;
      else
        v14 = v7;
      v15 = -v14;
      if (!*((_DWORD *)this + 9))
        v13 = v15;
      v16 = log10((float)((float)(*((float *)&__C + 1) + *(float *)&__C) + v13) + 1.0e-10) * 10.0;
      v17 = (float)(*((float *)this + 12) * *(float *)&v3[4 * v2]) + (1.0 - *((float *)this + 12)) * v16;
      *(float *)&v3[4 * v2] = v17;
      v18 = __exp10f(fmaxf(fminf(v17, 100.0), -100.0) / 10.0);
      v19 = this[2394];
      v19[v2++] = v18;
      v20 = *((unsigned int *)this + 3);
    }
    while (v2 < v20);
  }
  else
  {
    v20 = 0;
    v19 = this[2394];
  }
  vDSP_sve(v19, 1, (float *)&__B, v20);
  vDSP_vsdiv(this[2394], 1, (const float *)&__B, this[2394], 1, *((unsigned int *)this + 3));
  v21 = *((unsigned int *)this + 20);
  v22 = (*((_DWORD *)this + 21) - v21 + 1);
  if (*((_BYTE *)this + 104))
  {
    vDSP_meanv((const float *)this + v21 + 138, 1, (float *)&__B + 1, (*((_DWORD *)this + 21) - v21 + 1));
    *((float *)&__B + 1) = -*((float *)&__B + 1);
    vDSP_vsadd((const float *)this + v21 + 138, 1, (const float *)&__B + 1, (float *)this + v21 + 138, 1, v22);
  }
  vDSP_maxvi((const float *)this + v21 + 138, 1, &v26, &__I, v22);
  if (v26 <= *((float *)this + 25))
    v23 = *((_DWORD *)this + 28);
  else
    v23 = v21 + __I;
  *((_DWORD *)this + 27) = v23;
}

char *BeamformerFD::AllocateBlockSizeDependentVectors(BeamformerFD *this)
{
  unint64_t v2;
  char **v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char **v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char **v13;
  unint64_t v14;
  char **v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  int v26;

  if (*((_DWORD *)this + 3))
  {
    v2 = 0;
    v3 = (char **)((char *)this + 5160);
    do
    {
      v4 = (2 * *((_DWORD *)this + 8));
      v26 = 0;
      std::vector<float>::assign(v3, v4, &v26);
      ++v2;
      v5 = *((unsigned int *)this + 3);
      v3 += 3;
    }
    while (v2 < v5);
    if ((_DWORD)v5)
    {
      v6 = 0;
      v7 = (char **)((char *)this + 12072);
      do
      {
        v8 = (2 * *((_DWORD *)this + 8));
        v26 = 0;
        std::vector<float>::assign(v7, v8, &v26);
        ++v6;
        v7 += 3;
      }
      while (v6 < *((unsigned int *)this + 3));
    }
  }
  v9 = (2 * *((_DWORD *)this + 8));
  v26 = 0;
  std::vector<float>::assign((char **)this + 2373, v9, &v26);
  v10 = (2 * *((_DWORD *)this + 8));
  v26 = 0;
  std::vector<float>::assign((char **)this + 2376, v10, &v26);
  v11 = (2 * *((_DWORD *)this + 8));
  v26 = 0;
  std::vector<float>::assign((char **)this + 2397, v11, &v26);
  if (*((_DWORD *)this + 3))
  {
    v12 = 0;
    v13 = (char **)((char *)this + 130200);
    do
    {
      if (*((_DWORD *)this + 2))
      {
        v14 = 0;
        v15 = v13;
        do
        {
          v16 = *((unsigned int *)this + 8);
          v26 = 0;
          std::vector<float>::assign(v15 - 13824, v16, &v26);
          v17 = *((unsigned int *)this + 8);
          v26 = 0;
          std::vector<float>::assign(v15, v17, &v26);
          ++v14;
          v15 += 3;
        }
        while (v14 < *((unsigned int *)this + 2));
      }
      v18 = (2 * *((_DWORD *)this + 8));
      v26 = 0;
      std::vector<float>::assign((char **)this + 3 * v12++ + 30099, v18, &v26);
      v13 += 48;
    }
    while (v12 < *((unsigned int *)this + 3));
  }
  v19 = *((unsigned int *)this + 8);
  v26 = 0;
  std::vector<float>::assign((char **)this + 106995, v19, &v26);
  v20 = *((unsigned int *)this + 8);
  v26 = 0;
  std::vector<float>::assign((char **)this + 2385, v20, &v26);
  v21 = (2 * *((_DWORD *)this + 8));
  v26 = 0;
  std::vector<float>::assign((char **)this + 2382, v21, &v26);
  v22 = (*((_DWORD *)this + 8) + 1);
  v26 = 0;
  std::vector<float>::assign((char **)this + 2388, v22, &v26);
  v23 = (*((_DWORD *)this + 8) + 1);
  v26 = 0;
  std::vector<float>::assign((char **)this + 2391, v23, &v26);
  v24 = *((unsigned int *)this + 8);
  v26 = 0;
  return std::vector<float>::assign((char **)this + 2379, v24, &v26);
}

float BeamformerFD::CalculateEnergyInFullBand(uint64_t a1, const float **a2)
{
  float __C;

  __C = 0.0;
  vDSP_svesq(*a2, 1, &__C, (2 * *(_DWORD *)(a1 + 32)));
  return log10(__C + 1.0e-10) * 10.0;
}

os_log_t ___ZL18AUBeamItFDLogScopev_block_invoke_24091()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "aubmfd");
  *v0 = result;
  AUBeamItFDLogScope(void)::scope = (uint64_t)v0;
  return result;
}

uint64_t std::default_delete<SubbandDOACalculator>::operator()[abi:ne180100](uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void **v8;

  v2 = *(void **)(a1 + 136);
  if (v2)
  {
    *(_QWORD *)(a1 + 144) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 112);
  if (v3)
  {
    *(_QWORD *)(a1 + 120) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 88);
  if (v4)
  {
    *(_QWORD *)(a1 + 96) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 64);
  if (v5)
  {
    *(_QWORD *)(a1 + 72) = v5;
    operator delete(v5);
  }
  v8 = (void **)(a1 + 32);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v8);
  v6 = *(void **)(a1 + 8);
  if (v6)
  {
    *(_QWORD *)(a1 + 16) = v6;
    operator delete(v6);
  }
  return MEMORY[0x1BCC95CEC](a1, 0x10B0C4054D2F8FBLL);
}

uint64_t VoiceProcessorV2::SetupDownlink_SPP_SCi_J4xx(uint64_t this)
{
  uint64_t v1;
  unint64_t v2;
  unsigned int v3;
  unint64_t v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;
  uint64_t v8;

  v1 = this;
  if ((*(_DWORD *)(this + 72) & 0xFFFFFFFE) == 0x1C && (this = _os_feature_enabled_impl(), (_DWORD)this))
    v2 = *(_QWORD *)(v1 + 8832) & 0xFEFFFFFFFFFFFFFFLL;
  else
    v2 = *(_QWORD *)(v1 + 8832) | 0x100000000000000;
  v3 = *(_DWORD *)(v1 + 356);
  v4 = v2 & 0xF7BC798FFFFFFFFFLL | 0x20000000000;
  v5 = v2 | 0x60000000000;
  v6 = v3 > 1;
  if (v3 <= 1)
    v5 = v4;
  v7 = v5 & 0xF7BC7F8FFFFFFFFFLL;
  v8 = 0x41000000000000;
  if (v6)
    v8 = 0x43000000000000;
  *(_QWORD *)(v1 + 8832) = v7 | v8;
  return this;
}

char *VoiceProcessorV2::SetHwMicAndEpMicChannelConfig(_DWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  char *result;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;

  VPChannelConfig::SetChConfig((VPChannelConfig *)(a1 + 106), *(_DWORD *)a2, (const char *)(a2 + 4), 4u);
  result = VPChannelConfig::SetChConfig((VPChannelConfig *)(a1 + 112), *(_DWORD *)a3, (const char *)(a3 + 4), a4);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = a1[112];
  v12 = a1[106];
  do
  {
    if (((1 << v8) & v11) == 0 || ((1 << v8) & v12) == 0)
      v9 += ((v12 | v11) >> v8) & 1;
    else
      v10 |= 1 << v9++;
    ++v8;
  }
  while (v8 != 32);
  a1[105] = v10;
  return result;
}

void VoiceProcessorV2::DispatchVPRouteSetup(VoiceProcessorV2 *this, int a2, int a3)
{
  char *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t *v12;
  int v13;
  uint64_t *v14;
  uint64_t *v15;
  int v16;
  int v17;
  int v18;
  uint64_t *v19;
  int v20;
  uint64_t *v21;
  uint64_t *v22;
  int v23;
  int v24;
  int v25;
  uint64_t *v26;
  int v27;
  uint64_t *v28;
  uint64_t *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  _QWORD *v42;
  _QWORD **v43;
  _QWORD *v44;
  _QWORD *v45;
  _QWORD **v46;
  int v47;
  _QWORD **v48;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD **v51;
  unsigned int v52;
  _QWORD *v53;
  _QWORD *v54;
  _QWORD **v55;
  int v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD **v59;
  _QWORD *v60;
  _QWORD *v61;
  _QWORD **v62;
  _QWORD *v63;
  _QWORD *v64;
  _QWORD **v65;
  int v66;
  _DWORD *v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  _QWORD *v89;
  int v90;
  _QWORD *v91;
  _QWORD **v92;
  _QWORD *v93;
  _QWORD *v94;
  _QWORD **v95;
  int v96;
  _QWORD **v97;
  _QWORD *v98;
  _QWORD **v99;
  unsigned int v100;
  _QWORD *v101;
  _QWORD *v102;
  _QWORD *v103;
  _QWORD **v104;
  _QWORD *v105;
  _QWORD **v106;
  int v107;
  _QWORD **v108;
  _QWORD *v109;
  _QWORD **v110;
  _QWORD *v111;
  _QWORD *v112;
  _QWORD **v113;
  int v114;
  _QWORD *v115;
  _QWORD **v116;
  unsigned int v117;
  _QWORD *v118;
  _QWORD *v119;
  _QWORD **v120;
  _QWORD *v121;
  _QWORD *v122;
  _QWORD **v123;
  int v124;
  _QWORD *v125;
  _QWORD *v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  uint64_t *v134;
  int v135;
  uint64_t *v136;
  uint64_t *v137;
  int v138;
  int v139;
  int v140;
  int v141;
  uint64_t *v142;
  uint64_t *v143;
  uint64_t *v144;
  _QWORD *v145;
  int *v146;
  unsigned int v147;
  _QWORD **v148;
  _QWORD *v149;
  _QWORD *v150;
  _QWORD **v151;
  unsigned int v152;
  _QWORD *v153;
  _QWORD **v154;
  _QWORD *v155;
  _QWORD *v156;
  _QWORD *v157;
  _QWORD **v158;
  unsigned int v159;
  _QWORD *v160;
  _QWORD **v161;
  BOOL v162;
  _QWORD **v163;
  _QWORD *v164;
  NSObject *v165;
  _QWORD *v166;
  int v167;
  int v168;
  int *v169;
  const char *v170;
  std::string *v171;
  __int128 v172;
  std::string *v173;
  __int128 v174;
  std::string *v175;
  std::string::size_type size;
  std::string *v177;
  std::string::size_type v178;
  char v179;
  void **v180;
  void **v181;
  void *v182;
  _QWORD **v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int v190;
  uint64_t v191;
  unint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  _QWORD *v197;
  NSObject *v198;
  int v199;
  int v200;
  int *v201;
  _QWORD *v202;
  _QWORD **v203;
  unsigned int v204;
  _QWORD *v205;
  _QWORD *v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  unsigned int v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint8x8_t v215;
  uint8x8_t v216;
  unint64_t v217;
  uint64_t v218;
  unint64_t v219;
  uint64_t v220;
  uint64_t v221;
  int v222;
  unint64_t v223;
  unint64_t v224;
  NSObject *v225;
  NSObject *v226;
  int *v227;
  _QWORD **v228;
  _QWORD *v229[2];
  uint64_t *v230;
  _QWORD *v231;
  uint64_t v232;
  void *__p[2];
  char v234;
  std::string v235;
  std::string v236;
  std::string v237;
  void **v238;
  __int128 v239;
  _BYTE v240[32];
  __int128 v241;
  int v242;
  _BYTE buf[48];
  __int128 v244;
  int v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  _OWORD v250[5];
  _BYTE v251[148];
  int v252;
  _QWORD v253[5];

  v253[2] = *MEMORY[0x1E0C80C00];
  v246 = kVP_MicConfigPrimaryMicOnly;
  v247 = unk_1B6689648;
  v248 = xmmword_1B6689658;
  v249 = unk_1B6689668;
  LODWORD(v250[0]) = 0;
  *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigPrimaryMicOnly;
  memset((char *)&v250[1] + 4, 0, 52);
  *(_OWORD *)&v251[4] = kVP_MicConfigPrimaryMicOnly;
  *(_OWORD *)&v251[68] = v250[0];
  memset(&v251[20], 0, 48);
  *(_QWORD *)&v251[132] = unk_1B6689674;
  *(_OWORD *)&v251[116] = v250[3];
  *(_OWORD *)&v251[100] = v250[2];
  *(_OWORD *)&v251[84] = v250[1];
  *(_QWORD *)&v251[140] = 0x100000000;
  *(_DWORD *)v251 = 1;
  v252 = 21;
  v231 = 0;
  v232 = 0;
  v230 = (uint64_t *)&v231;
  std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int const,ProcessingChainInfo> const&>((uint64_t *)&v230, (uint64_t *)&v231, 1u, (uint64_t)v251);
  v6 = (char *)this + 15897;
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 18:
    case 47:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v7 = 29;
      else
        v7 = 21;
      v246 = kVP_MicConfigPrimaryMicOnly;
      v247 = unk_1B6689648;
      v248 = xmmword_1B6689658;
      v249 = unk_1B6689668;
      LODWORD(v250[0]) = 0;
      *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigPrimaryMicOnly;
      memset((char *)&v250[1] + 4, 0, 52);
      *(_OWORD *)&v251[4] = kVP_MicConfigPrimaryMicOnly;
      *(_OWORD *)&v251[68] = v250[0];
      memset(&v251[20], 0, 48);
      *(_QWORD *)&v251[132] = unk_1B6689674;
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[84] = v250[1];
      *(_QWORD *)&v251[140] = 0x100000000;
      *(_DWORD *)v251 = 0;
      v252 = v7;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      switch(a2)
      {
        case 0:
          if (**((_DWORD **)this + 292) != 1885892727 || *((_DWORD *)this + 596) != 1752709424)
            goto LABEL_463;
          v57 = v231;
          if (!v231)
            goto LABEL_168;
          v58 = v231;
          do
          {
            v59 = (_QWORD **)v58;
            v58 = (_QWORD *)*v58;
          }
          while (v58);
          if (v59 == &v231 || *((_DWORD *)v59 + 7))
LABEL_168:
            v59 = &v231;
          *((_DWORD *)v59 + 43) = 0;
          if (*((_BYTE *)this + 2244))
            v47 = 29;
          else
            v47 = 26;
          if (!v57)
            goto LABEL_261;
          do
          {
            v48 = (_QWORD **)v57;
            v57 = (_QWORD *)*v57;
          }
          while (v57);
LABEL_142:
          if (v48 == &v231 || *((_DWORD *)v48 + 7))
LABEL_261:
            v48 = &v231;
          *((_DWORD *)v48 + 44) = v47;
          goto LABEL_463;
        case 1:
          *((_DWORD *)this + 3116) = 1065353216;
          *((_DWORD *)this + 3119) = 1065353216;
          if ((a3 - 39) >= 0xA && (a3 & 0xFFFFFFFE) != 0x32)
            goto LABEL_463;
          v60 = v231;
          if (!v231)
            goto LABEL_182;
          v61 = v231;
          do
          {
            v62 = (_QWORD **)v61;
            v61 = (_QWORD *)*v61;
          }
          while (v61);
          if (v62 == &v231 || *((_DWORD *)v62 + 7))
LABEL_182:
            v62 = &v231;
          *((_DWORD *)v62 + 43) = 8;
          if (!v60)
            goto LABEL_187;
          do
          {
            v43 = (_QWORD **)v60;
            v60 = (_QWORD *)*v60;
          }
          while (v60);
LABEL_185:
          if (v43 == &v231 || *((_DWORD *)v43 + 7))
LABEL_187:
            v43 = &v231;
          v41 = 27;
LABEL_201:
          *((_DWORD *)v43 + 44) = v41;
          goto LABEL_463;
        case 2:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
          goto LABEL_463;
        case 3:
          v52 = (*(uint64_t (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this);
          v53 = v231;
          if (v52 >= 5)
          {
            if (v231)
            {
              v54 = v231;
              do
              {
                v55 = (_QWORD **)v54;
                v54 = (_QWORD *)*v54;
              }
              while (v54);
              if (v55 != &v231 && !*((_DWORD *)v55 + 7))
              {
                v56 = 11;
                goto LABEL_334;
              }
            }
            v56 = 11;
            goto LABEL_333;
          }
          if (!v231)
            goto LABEL_290;
          v89 = v231;
          do
          {
            v55 = (_QWORD **)v89;
            v89 = (_QWORD *)*v89;
          }
          while (v89);
          if (v55 == &v231 || (v56 = *((_DWORD *)v55 + 7)) != 0)
          {
LABEL_290:
            v56 = 0;
LABEL_333:
            v55 = &v231;
          }
LABEL_334:
          *((_DWORD *)v55 + 43) = v56;
          if (!v53)
            goto LABEL_338;
          do
          {
            v108 = (_QWORD **)v53;
            v53 = (_QWORD *)*v53;
          }
          while (v53);
          if (v108 == &v231 || *((_DWORD *)v108 + 7))
LABEL_338:
            v108 = &v231;
          *((_DWORD *)v108 + 44) = 20;
          *((_DWORD *)this + 3116) = 1065353216;
          *((_DWORD *)this + 3119) = 1065353216;
          break;
        case 4:
          v44 = v231;
          if (!v231)
            goto LABEL_136;
          v45 = v231;
          do
          {
            v46 = (_QWORD **)v45;
            v45 = (_QWORD *)*v45;
          }
          while (v45);
          if (v46 == &v231 || *((_DWORD *)v46 + 7))
LABEL_136:
            v46 = &v231;
          *((_DWORD *)v46 + 43) = 7;
          if (*((_BYTE *)this + 2244))
            v47 = 29;
          else
            v47 = 26;
          if (!v44)
            goto LABEL_261;
          do
          {
            v48 = (_QWORD **)v44;
            v44 = (_QWORD *)*v44;
          }
          while (v44);
          goto LABEL_142;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          if (*((_BYTE *)this + 2244))
            v8 = 29;
          else
            v8 = 25;
          v246 = kVP_MicConfigPrimaryMicOnly;
          v247 = unk_1B6689648;
          v248 = xmmword_1B6689658;
          v249 = unk_1B6689668;
          LODWORD(v250[0]) = 0;
          *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigPrimaryMicOnly;
          memset((char *)&v250[1] + 4, 0, 52);
          *(_QWORD *)&v251[132] = unk_1B6689674;
          *(_OWORD *)&v251[4] = kVP_MicConfigPrimaryMicOnly;
          *(_OWORD *)&v251[68] = v250[0];
          memset(&v251[20], 0, 48);
          *(_OWORD *)&v251[116] = v250[3];
          *(_OWORD *)&v251[100] = v250[2];
          *(_OWORD *)&v251[84] = v250[1];
          *(_QWORD *)&v251[140] = 0x100000000;
          *(_DWORD *)v251 = 1;
          v252 = v8;
          std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          goto LABEL_10;
        case 10:
          if (*((_BYTE *)this + 2244))
            v41 = 29;
          else
            v41 = 23;
          v42 = v231;
          if (!v231)
            goto LABEL_130;
          do
          {
            v43 = (_QWORD **)v42;
            v42 = (_QWORD *)*v42;
          }
          while (v42);
          if (v43 == &v231 || *((_DWORD *)v43 + 7))
LABEL_130:
            v43 = &v231;
          goto LABEL_201;
        case 11:
          v63 = v231;
          if (!v231)
            goto LABEL_194;
          v64 = v231;
          do
          {
            v65 = (_QWORD **)v64;
            v64 = (_QWORD *)*v64;
          }
          while (v64);
          if (v65 == &v231 || *((_DWORD *)v65 + 7))
LABEL_194:
            v65 = &v231;
          *((_DWORD *)v65 + 43) = 10;
          if (!v63)
            goto LABEL_199;
          do
          {
            v43 = (_QWORD **)v63;
            v63 = (_QWORD *)*v63;
          }
          while (v63);
          if (v43 == &v231 || *((_DWORD *)v43 + 7))
LABEL_199:
            v43 = &v231;
          v41 = 28;
          goto LABEL_201;
        case 18:
          v49 = v231;
          if (!v231)
            goto LABEL_150;
          v50 = v231;
          do
          {
            v51 = (_QWORD **)v50;
            v50 = (_QWORD *)*v50;
          }
          while (v50);
          if (v51 == &v231 || *((_DWORD *)v51 + 7))
LABEL_150:
            v51 = &v231;
          *((_DWORD *)v51 + 43) = 8;
          if (!v49)
            goto LABEL_187;
          do
          {
            v43 = (_QWORD **)v49;
            v49 = (_QWORD *)*v49;
          }
          while (v49);
          goto LABEL_185;
        default:
          if (a2 == 47)
          {
            std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
            v231 = 0;
            v232 = 0;
            v230 = (uint64_t *)&v231;
            if (*((_BYTE *)this + 2244))
              v40 = 29;
            else
              v40 = 21;
            v246 = kVP_MicConfigAllFour;
            v247 = unk_1B664ACC4;
            v248 = xmmword_1B664ACD4;
            v249 = unk_1B664ACE4;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigAllFour;
            *(_OWORD *)((char *)&v250[1] + 4) = unk_1B664ACC4;
            memset((char *)&v250[2] + 4, 0, 36);
            *(_OWORD *)&v251[4] = kVP_MicConfigAllFour;
            *(_OWORD *)&v251[68] = v250[0];
            *(_QWORD *)&v251[132] = unk_1B664ACF0;
            memset(&v251[36], 0, 32);
            *(_OWORD *)&v251[20] = unk_1B664ACC4;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_QWORD *)&v251[140] = 0x900000000;
            *(_DWORD *)v251 = 4;
            v252 = v40;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          }
          goto LABEL_463;
      }
      goto LABEL_463;
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v30 = 29;
      else
        v30 = 21;
      v246 = kVP_MicConfigBottom;
      v247 = *(_OWORD *)algn_1B6630D9C;
      v248 = xmmword_1B6630DAC;
      v249 = unk_1B6630DBC;
      LODWORD(v250[0]) = 0;
      *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottom;
      memset((char *)&v250[1] + 4, 0, 52);
      *(_QWORD *)&v251[132] = unk_1B6630DC8;
      *(_OWORD *)&v251[4] = kVP_MicConfigBottom;
      *(_OWORD *)&v251[68] = v250[0];
      memset(&v251[20], 0, 48);
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[84] = v250[1];
      *(_QWORD *)&v251[140] = 0x100000000;
      *(_DWORD *)v251 = 1;
      v252 = v30;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      LODWORD(v250[0]) = 0;
      v246 = kVP_MicConfigBottomBack;
      v247 = unk_1B6630DE0;
      v248 = xmmword_1B6630DF0;
      v249 = unk_1B6630E00;
      *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottom;
      memset((char *)&v250[1] + 4, 0, 48);
      *(_OWORD *)&v251[84] = v250[1];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[20] = unk_1B6630DE0;
      memset(&v251[36], 0, 32);
      *(_OWORD *)&v251[68] = v250[0];
      if (*((_BYTE *)this + 2244))
        v31 = 29;
      else
        v31 = 21;
      DWORD1(v250[4]) = 0;
      *(_QWORD *)&v251[132] = LODWORD(v250[4]);
      *(_OWORD *)&v251[4] = kVP_MicConfigBottomBack;
      *(_QWORD *)&v251[140] = 0x100000000;
      *(_DWORD *)v251 = 2;
      v252 = v31;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      LODWORD(v250[0]) = 0;
      v246 = kVP_MicConfigBottomBackFront;
      v247 = *(_OWORD *)"and front";
      v248 = xmmword_1B6630E34;
      v249 = unk_1B6630E44;
      *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottom;
      memset((char *)&v250[1] + 4, 0, 48);
      *(_OWORD *)&v251[84] = v250[1];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
      memset(&v251[36], 0, 32);
      *(_OWORD *)&v251[68] = v250[0];
      if (*((_BYTE *)this + 2244))
        v32 = 29;
      else
        v32 = 21;
      DWORD1(v250[4]) = 0;
      *(_QWORD *)&v251[132] = LODWORD(v250[4]);
      *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
      *(_QWORD *)&v251[140] = 0x100000000;
      *(_DWORD *)v251 = 3;
      v252 = v32;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      LODWORD(v250[0]) = 0;
      v246 = kVP_MicConfigBottomBackFront;
      v247 = *(_OWORD *)"and front";
      v248 = xmmword_1B6630E34;
      v249 = unk_1B6630E44;
      *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottom;
      memset((char *)&v250[1] + 4, 0, 48);
      *(_OWORD *)&v251[84] = v250[1];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
      memset(&v251[36], 0, 32);
      *(_OWORD *)&v251[68] = v250[0];
      if (*((_BYTE *)this + 2244))
        v33 = 29;
      else
        v33 = 21;
      DWORD1(v250[4]) = 0;
      *(_QWORD *)&v251[132] = LODWORD(v250[4]);
      *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
      *(_QWORD *)&v251[140] = 0x100000000;
      *(_DWORD *)v251 = 4;
      v252 = v33;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      switch(a2)
      {
        case 12:
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          v83 = *((_DWORD *)this + 22);
          if (v83 == 1986618467)
          {
            if (*((_BYTE *)this + 2244))
              v127 = 30;
            else
              v127 = 23;
            v246 = kVP_MicConfigBottomBackFront;
            v247 = *(_OWORD *)"and front";
            v248 = xmmword_1B6630E34;
            v249 = unk_1B6630E44;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFront;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)&v250[1] + 4) = *(_OWORD *)"and front";
            memset((char *)&v250[2] + 4, 0, 36);
            *(_OWORD *)&v251[68] = v250[0];
            *(_QWORD *)&v251[132] = unk_1B6630E50;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
            memset(&v251[36], 0, 32);
            *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_QWORD *)&v251[140] = 0x300000002;
            *(_DWORD *)v251 = 3;
            v252 = v127;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            if ((*(unsigned int (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this) >= 5)
            {
              if (VoiceProcessorV2::GetChatFlavor(this) == 2 && (*((_BYTE *)this + 16544) & 4) != 0)
              {
                if ((*(unsigned int (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this) <= 8)
                  v85 = 5;
                else
                  v85 = 12;
              }
              else
              {
                v85 = 5;
              }
              v162 = *((_BYTE *)this + 2244) == 0;
              LODWORD(v250[0]) = 0;
              if (v162)
                v141 = 23;
              else
                v141 = 30;
              goto LABEL_462;
            }
            if (*((_BYTE *)this + 2244))
              v139 = 30;
            else
              v139 = 23;
            v246 = kVP_MicConfigBottomBackFrontBottomLeft;
            v247 = unk_1B6630E68;
            v248 = xmmword_1B6630E78;
            v249 = unk_1B6630E88;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFront;
            *(_OWORD *)((char *)&v250[1] + 4) = *(_OWORD *)"and front";
            memset((char *)&v250[2] + 4, 0, 36);
            *(_QWORD *)&v251[132] = unk_1B6630E50;
            *(_OWORD *)&v251[84] = v250[1];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[116] = v250[3];
            strcpy(&v251[20], "front and bottom-left");
            memset(&v251[42], 0, 26);
            *(_OWORD *)&v251[68] = v250[0];
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFrontBottomLeft;
            *(_QWORD *)&v251[140] = 0x300000002;
            *(_DWORD *)v251 = 4;
            v252 = v139;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          }
          else if (v83 == 1987012963)
          {
            if (*((_BYTE *)this + 2244))
              v84 = 30;
            else
              v84 = 23;
            v246 = kVP_MicConfigBottomBackFront;
            v247 = *(_OWORD *)"and front";
            v248 = xmmword_1B6630E34;
            v249 = unk_1B6630E44;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFront;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)&v250[1] + 4) = *(_OWORD *)"and front";
            memset((char *)&v250[2] + 4, 0, 36);
            *(_OWORD *)&v251[68] = v250[0];
            *(_QWORD *)&v251[132] = unk_1B6630E50;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
            memset(&v251[36], 0, 32);
            *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_QWORD *)&v251[140] = 0x500000002;
            *(_DWORD *)v251 = 3;
            v252 = v84;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            if ((*(unsigned int (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this) >= 5)
            {
              if (VoiceProcessorV2::GetChatFlavor(this) == 2 && (*((_BYTE *)this + 16544) & 4) != 0)
              {
                if ((*(unsigned int (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this) <= 8)
                  v85 = 5;
                else
                  v85 = 12;
              }
              else
              {
                v85 = 5;
              }
              v162 = *((_BYTE *)this + 2244) == 0;
              LODWORD(v250[0]) = 0;
              if (v162)
                v141 = 23;
              else
                v141 = 30;
LABEL_462:
              v246 = kVP_MicConfigBottomBackFrontBottomLeft;
              v247 = unk_1B6630E68;
              *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFrontBottomLeft;
              strcpy((char *)&v250[1] + 4, "front and bottom-left");
              *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFrontBottomLeft;
              *(_OWORD *)&v251[68] = v250[0];
              v248 = xmmword_1B6630E78;
              v249 = unk_1B6630E88;
              WORD5(v250[2]) = 0;
              *(_QWORD *)((char *)&v250[2] + 12) = 0;
              memset((char *)&v250[3] + 4, 0, 20);
              *(_QWORD *)&v251[132] = unk_1B6630E94;
              memset(&v251[42], 0, 26);
              strcpy(&v251[20], "front and bottom-left");
              *(_OWORD *)&v251[116] = v250[3];
              *(_OWORD *)&v251[100] = v250[2];
              *(_OWORD *)&v251[84] = v250[1];
              *(_DWORD *)v251 = 4;
              *(_DWORD *)&v251[140] = 0;
              *(_DWORD *)&v251[144] = v85;
              v252 = v141;
              std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
              goto LABEL_463;
            }
            if (*((_BYTE *)this + 2244))
              v138 = 30;
            else
              v138 = 23;
            v246 = kVP_MicConfigBottomBackFrontBottomLeft;
            v247 = unk_1B6630E68;
            v248 = xmmword_1B6630E78;
            v249 = unk_1B6630E88;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFront;
            *(_OWORD *)((char *)&v250[1] + 4) = *(_OWORD *)"and front";
            memset((char *)&v250[2] + 4, 0, 36);
            *(_QWORD *)&v251[132] = unk_1B6630E50;
            *(_OWORD *)&v251[84] = v250[1];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[116] = v250[3];
            strcpy(&v251[20], "front and bottom-left");
            memset(&v251[42], 0, 26);
            *(_OWORD *)&v251[68] = v250[0];
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFrontBottomLeft;
            *(_QWORD *)&v251[140] = 0x500000002;
            *(_DWORD *)v251 = 4;
            v252 = v138;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          }
          else
          {
            if (*((_BYTE *)this + 2244))
              v128 = 30;
            else
              v128 = 23;
            v246 = kVP_MicConfigFront;
            v247 = *(_OWORD *)algn_1B6630EAC;
            v248 = xmmword_1B6630EBC;
            v249 = unk_1B6630ECC;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigFront;
            LODWORD(v250[0]) = 0;
            memset((char *)&v250[1] + 4, 0, 52);
            *(_OWORD *)&v251[68] = v250[0];
            *(_QWORD *)&v251[132] = unk_1B6630ED8;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[4] = kVP_MicConfigFront;
            memset(&v251[20], 0, 48);
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_QWORD *)&v251[140] = 0x100000002;
            *(_DWORD *)v251 = 1;
            v252 = v128;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            LODWORD(v250[0]) = 0;
            v246 = kVP_MicConfigBackFront;
            v247 = unk_1B6630EF0;
            v248 = xmmword_1B6630F00;
            v249 = unk_1B6630F10;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigFront;
            memset((char *)&v250[1] + 4, 0, 48);
            *(_OWORD *)&v251[84] = v250[1];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[20] = unk_1B6630EF0;
            memset(&v251[36], 0, 32);
            *(_OWORD *)&v251[68] = v250[0];
            if (*((_BYTE *)this + 2244))
              v129 = 30;
            else
              v129 = 23;
            DWORD1(v250[4]) = 0;
            *(_QWORD *)&v251[132] = LODWORD(v250[4]);
            *(_OWORD *)&v251[4] = kVP_MicConfigBackFront;
            *(_QWORD *)&v251[140] = 0x100000002;
            *(_DWORD *)v251 = 2;
            v252 = v129;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            LODWORD(v250[0]) = 0;
            v246 = kVP_MicConfigBottomBackFront;
            v247 = *(_OWORD *)"and front";
            v248 = xmmword_1B6630E34;
            v249 = unk_1B6630E44;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigFront;
            memset((char *)&v250[1] + 4, 0, 48);
            *(_OWORD *)&v251[84] = v250[1];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
            memset(&v251[36], 0, 32);
            *(_OWORD *)&v251[68] = v250[0];
            if (*((_BYTE *)this + 2244))
              v130 = 30;
            else
              v130 = 23;
            DWORD1(v250[4]) = 0;
            *(_QWORD *)&v251[132] = LODWORD(v250[4]);
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
            *(_QWORD *)&v251[140] = 0x100000002;
            *(_DWORD *)v251 = 3;
            v252 = v130;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            if ((*(unsigned int (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this) < 5)
            {
              if (*((_BYTE *)this + 2244))
                v140 = 30;
              else
                v140 = 23;
              v246 = kVP_MicConfigBottomBackFront;
              v247 = *(_OWORD *)"and front";
              v248 = xmmword_1B6630E34;
              v249 = unk_1B6630E44;
              LODWORD(v250[0]) = 0;
              *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigFront;
              memset((char *)&v250[1] + 4, 0, 52);
              *(_QWORD *)&v251[132] = unk_1B6630ED8;
              *(_OWORD *)&v251[84] = v250[1];
              *(_OWORD *)&v251[100] = v250[2];
              *(_OWORD *)&v251[116] = v250[3];
              *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
              memset(&v251[36], 0, 32);
              *(_OWORD *)&v251[68] = v250[0];
              *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
              *(_QWORD *)&v251[140] = 0x100000002;
              *(_DWORD *)v251 = 4;
              v252 = v140;
              std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            }
            else
            {
              v162 = *((_BYTE *)this + 2244) == 0;
              LODWORD(v250[0]) = 0;
              if (v162)
                v131 = 23;
              else
                v131 = 30;
              v246 = kVP_MicConfigBottomBackFrontBottomLeft;
              v247 = unk_1B6630E68;
              *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFrontBottomLeft;
              strcpy((char *)&v250[1] + 4, "front and bottom-left");
              *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFrontBottomLeft;
              *(_OWORD *)&v251[68] = v250[0];
              v248 = xmmword_1B6630E78;
              v249 = unk_1B6630E88;
              WORD5(v250[2]) = 0;
              *(_QWORD *)((char *)&v250[2] + 12) = 0;
              memset((char *)&v250[3] + 4, 0, 20);
              *(_QWORD *)&v251[132] = unk_1B6630E94;
              memset(&v251[42], 0, 26);
              strcpy(&v251[20], "front and bottom-left");
              *(_OWORD *)&v251[116] = v250[3];
              *(_OWORD *)&v251[100] = v250[2];
              *(_OWORD *)&v251[84] = v250[1];
              *(_QWORD *)&v251[140] = 0x500000000;
              *(_DWORD *)v251 = 4;
              v252 = v131;
              std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            }
          }
          break;
        case 13:
        case 16:
          v34 = *((_DWORD *)this + 22);
          if (v34 == 1986618467 || v34 == 1987012963)
          {
            std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
            v231 = 0;
            v232 = 0;
            v230 = (uint64_t *)&v231;
            v246 = kVP_MicConfigBottomBack;
            v247 = unk_1B6630DE0;
            v248 = xmmword_1B6630DF0;
            v249 = unk_1B6630E00;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBack;
            *(_OWORD *)((char *)&v250[1] + 4) = unk_1B6630DE0;
            memset((char *)&v250[2] + 4, 0, 36);
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBack;
            *(_OWORD *)&v251[68] = v250[0];
            memset(&v251[36], 0, 32);
            *(_OWORD *)&v251[20] = unk_1B6630DE0;
            *(_QWORD *)&v251[132] = unk_1B6630E0C;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_QWORD *)&v251[140] = 0x200000000;
            *(_DWORD *)v251 = 2;
            v252 = 21;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            v246 = kVP_MicConfigBottomBackFront;
            v247 = *(_OWORD *)"and front";
            v248 = xmmword_1B6630E34;
            v249 = unk_1B6630E44;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBack;
            *(_OWORD *)((char *)&v250[1] + 4) = unk_1B6630DE0;
            memset((char *)&v250[2] + 4, 0, 36);
            *(_QWORD *)&v251[132] = unk_1B6630E0C;
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_OWORD *)&v251[68] = v250[0];
            memset(&v251[36], 0, 32);
            *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
            *(_QWORD *)&v251[140] = 0x200000000;
            *(_DWORD *)v251 = 3;
            v252 = 21;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            v246 = kVP_MicConfigBottomBackFrontBottomLeft;
            v247 = unk_1B6630E68;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFrontBottomLeft;
            strcpy((char *)&v250[1] + 4, "front and bottom-left");
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFrontBottomLeft;
            *(_OWORD *)&v251[68] = v250[0];
            v248 = xmmword_1B6630E78;
            v249 = unk_1B6630E88;
            WORD5(v250[2]) = 0;
            *(_QWORD *)((char *)&v250[2] + 12) = 0;
            memset((char *)&v250[3] + 4, 0, 20);
            memset(&v251[42], 0, 26);
            strcpy(&v251[20], "front and bottom-left");
            *(_QWORD *)&v251[132] = unk_1B6630E94;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_QWORD *)&v251[140] = 0x200000000;
            *(_DWORD *)v251 = 4;
            v252 = 21;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          }
          goto LABEL_463;
        case 14:
        case 15:
          v38 = *((_DWORD *)this + 22);
          if (v38 == 1986618467)
          {
            std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
            v231 = 0;
            v232 = 0;
            v230 = (uint64_t *)&v231;
            *(_OWORD *)buf = xmmword_1B6630F24;
            *(_OWORD *)&buf[16] = *(_OWORD *)"and front";
            *(_OWORD *)&buf[32] = xmmword_1B6630F44;
            v244 = unk_1B6630F54;
            v245 = 0;
            v239 = xmmword_1B6630F24;
            *(_OWORD *)v240 = *(_OWORD *)"and front";
            *(_OWORD *)&v240[16] = xmmword_1B6630F44;
            v241 = unk_1B6630F54;
            v242 = 0;
            v87 = 3;
            if (VoiceProcessorV2::GetChatFlavor(this) == 2
              && (*((_BYTE *)this + 16544) & 4) != 0
              && (*(unsigned int (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this) >= 9)
            {
              v245 = 0;
              *(_OWORD *)buf = kVP_MicConfigBottomBackFrontBottomLeft;
              strcpy(&buf[16], "front and bottom-left");
              *(_WORD *)&buf[38] = 0;
              *(_QWORD *)&buf[40] = 0;
              v244 = unk_1B6630E88;
              v242 = 0;
              v239 = kVP_MicConfigBottomBackFrontBottomLeft;
              strcpy(v240, "front and bottom-left");
              *(_WORD *)&v240[22] = 0;
              *(_QWORD *)&v240[24] = 0;
              v241 = unk_1B6630E88;
              v87 = 12;
            }
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFront;
            *(_OWORD *)((char *)&v250[1] + 4) = *(_OWORD *)"and front";
            *(_OWORD *)&v251[68] = v250[0];
            if (*((_BYTE *)this + 2244))
              v88 = 29;
            else
              v88 = 21;
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
            v246 = kVP_MicConfigBottomBackFront;
            v247 = *(_OWORD *)"and front";
            v248 = xmmword_1B6630E34;
            v249 = unk_1B6630E44;
            memset((char *)&v250[2] + 4, 0, 36);
            memset(&v251[36], 0, 32);
            *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
            *(_QWORD *)&v251[132] = unk_1B6630E50;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_DWORD *)v251 = 3;
            *(_DWORD *)&v251[140] = 2;
            *(_DWORD *)&v251[144] = v87;
            v252 = v88;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            LODWORD(v250[0]) = v245;
            v248 = *(_OWORD *)&buf[32];
            v249 = v244;
            v246 = *(_OWORD *)buf;
            v247 = *(_OWORD *)&buf[16];
            *(_OWORD *)((char *)&v250[1] + 4) = *(_OWORD *)v240;
            *(_OWORD *)((char *)&v250[2] + 4) = *(_OWORD *)&v240[16];
            *(_OWORD *)((char *)&v250[3] + 4) = v241;
            *(_OWORD *)((char *)v250 + 4) = v239;
            *(_OWORD *)&v251[4] = *(_OWORD *)buf;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_OWORD *)&v251[68] = v250[0];
            *(_OWORD *)&v251[52] = v244;
            *(_OWORD *)&v251[36] = *(_OWORD *)&buf[32];
            DWORD1(v250[4]) = v242;
            *(_QWORD *)&v251[132] = *(_QWORD *)&v250[4];
            *(_OWORD *)&v251[20] = *(_OWORD *)&buf[16];
            *(_DWORD *)v251 = 4;
            *(_DWORD *)&v251[140] = 2;
            *(_DWORD *)&v251[144] = v87;
            v252 = v88;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          }
          else if (v38 == 1987012963 && VoiceProcessorV2::GetChatFlavor(this) == 2)
          {
            std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
            v231 = 0;
            v232 = 0;
            v230 = (uint64_t *)&v231;
            if ((*((_BYTE *)this + 16544) & 4) != 0)
            {
              if ((*(unsigned int (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this) <= 8)
                v39 = 1;
              else
                v39 = 12;
            }
            else
            {
              v39 = 1;
            }
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFront;
            *(_OWORD *)((char *)&v250[1] + 4) = *(_OWORD *)"and front";
            *(_OWORD *)&v251[68] = v250[0];
            if (*((_BYTE *)this + 2244))
              v132 = 29;
            else
              v132 = 21;
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
            v246 = kVP_MicConfigBottomBackFront;
            v247 = *(_OWORD *)"and front";
            v248 = xmmword_1B6630E34;
            v249 = unk_1B6630E44;
            memset((char *)&v250[2] + 4, 0, 36);
            memset(&v251[36], 0, 32);
            *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
            *(_QWORD *)&v251[132] = unk_1B6630E50;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_DWORD *)v251 = 3;
            *(_DWORD *)&v251[140] = 2;
            *(_DWORD *)&v251[144] = v39;
            v252 = v132;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
            if (*((_BYTE *)this + 2244))
              v133 = 29;
            else
              v133 = 21;
            v246 = kVP_MicConfigBottomBackFrontBottomLeft;
            v247 = unk_1B6630E68;
            v248 = xmmword_1B6630E78;
            v249 = unk_1B6630E88;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomBackFrontBottomLeft;
            strcpy((char *)&v250[1] + 4, "front and bottom-left");
            WORD5(v250[2]) = 0;
            *(_QWORD *)((char *)&v250[2] + 12) = 0;
            memset((char *)&v250[3] + 4, 0, 20);
            *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFrontBottomLeft;
            *(_OWORD *)&v251[68] = v250[0];
            memset(&v251[42], 0, 26);
            strcpy(&v251[20], "front and bottom-left");
            *(_QWORD *)&v251[132] = unk_1B6630E94;
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_DWORD *)v251 = 4;
            *(_DWORD *)&v251[140] = 2;
            *(_DWORD *)&v251[144] = v39;
            v252 = v133;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          }
          if (**((_DWORD **)this + 292) == 1885892727 && *((_DWORD *)this + 596) == 1752709424)
          {
            v134 = v230;
            if (v230 != (uint64_t *)&v231)
            {
              if (*((_BYTE *)this + 2244))
                v135 = 29;
              else
                v135 = 26;
              do
              {
                *((_DWORD *)v134 + 44) = v135;
                v136 = (uint64_t *)v134[1];
                if (v136)
                {
                  do
                  {
                    v137 = v136;
                    v136 = (uint64_t *)*v136;
                  }
                  while (v136);
                }
                else
                {
                  do
                  {
                    v137 = (uint64_t *)v134[2];
                    v162 = *v137 == (_QWORD)v134;
                    v134 = v137;
                  }
                  while (!v162);
                }
                v134 = v137;
              }
              while (v137 != (uint64_t *)&v231);
            }
          }
          goto LABEL_463;
        case 17:
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          if (*((_BYTE *)this + 2244))
            v86 = 29;
          else
            v86 = 25;
          v246 = kVP_MicConfigBottomBackFront;
          v247 = *(_OWORD *)"and front";
          v248 = xmmword_1B6630E34;
          v249 = unk_1B6630E44;
          LODWORD(v250[0]) = 0;
          *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottom;
          memset((char *)&v250[1] + 4, 0, 52);
          *(_QWORD *)&v251[132] = unk_1B6630DC8;
          *(_OWORD *)&v251[84] = v250[1];
          *(_OWORD *)&v251[100] = v250[2];
          *(_OWORD *)&v251[116] = v250[3];
          *(_OWORD *)&v251[20] = *(_OWORD *)"and front";
          memset(&v251[36], 0, 32);
          *(_OWORD *)&v251[68] = v250[0];
          *(_OWORD *)&v251[4] = kVP_MicConfigBottomBackFront;
          *(_QWORD *)&v251[140] = 0x100000000;
          *(_DWORD *)v251 = 4;
          v252 = v86;
          std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          goto LABEL_10;
        default:
          goto LABEL_463;
      }
      goto LABEL_463;
    case 19:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      *(_OWORD *)v251 = kVP_MicConfigAllThree;
      *(_OWORD *)&v251[16] = unk_1B6631460;
      memset(&v251[32], 0, 36);
      *(_OWORD *)&v251[68] = kVP_MicConfigAllThree;
      *(_OWORD *)&v251[84] = unk_1B6631460;
      memset(&v251[100], 0, 36);
      v67 = operator new(0xB8uLL);
      v67[7] = 3;
      v68 = *(_OWORD *)&v251[112];
      *((_OWORD *)v67 + 8) = *(_OWORD *)&v251[96];
      *((_OWORD *)v67 + 9) = v68;
      *((_QWORD *)v67 + 20) = *(_QWORD *)&v251[128];
      v69 = *(_OWORD *)&v251[48];
      *((_OWORD *)v67 + 4) = *(_OWORD *)&v251[32];
      *((_OWORD *)v67 + 5) = v69;
      v70 = *(_OWORD *)&v251[80];
      *((_OWORD *)v67 + 6) = *(_OWORD *)&v251[64];
      *((_OWORD *)v67 + 7) = v70;
      v71 = *(_OWORD *)&v251[16];
      *((_OWORD *)v67 + 2) = *(_OWORD *)v251;
      *((_OWORD *)v67 + 3) = v71;
      *((_QWORD *)v67 + 21) = 0xE00000003;
      v67[44] = 27;
      *(_QWORD *)v67 = 0;
      *((_QWORD *)v67 + 1) = 0;
      *((_QWORD *)v67 + 2) = &v231;
      v230 = (uint64_t *)v67;
      v231 = v67;
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v67, (uint64_t *)v67);
      ++v232;
      goto LABEL_463;
    case 20:
      if (*((_BYTE *)this + 2244))
      {
        v72 = *((_DWORD *)this + 22);
        v73 = 30;
        if (v72 != 1986618467)
        {
          if (v72 == 1987012963)
            v73 = 30;
          else
            v73 = 23;
        }
      }
      else
      {
        v73 = 23;
      }
      v103 = v231;
      if (!v231)
        goto LABEL_330;
      v104 = &v231;
      do
      {
        v105 = v103;
        v106 = v104;
        v107 = *((_DWORD *)v103 + 7);
        if (v107)
          v104 = (_QWORD **)v103;
        else
          ++v103;
        v103 = (_QWORD *)*v103;
      }
      while (v103);
      if (v104 == &v231)
        goto LABEL_330;
      if (!v107)
        v105 = v106;
      if (*((_DWORD *)v105 + 7) >= 2u)
LABEL_330:
        v104 = &v231;
      *((_DWORD *)v104 + 44) = v73;
      goto LABEL_341;
    case 21:
    case 22:
      goto LABEL_341;
    case 23:
      v66 = *((_DWORD *)this + 22);
      if (v66 == 1986618467 || v66 == 1987012963)
      {
        std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
        v231 = 0;
        v232 = 0;
        v230 = (uint64_t *)&v231;
        v246 = kVP_MicConfigBottomTop;
        v247 = unk_1B66868A0;
        v248 = xmmword_1B66868B0;
        v249 = unk_1B66868C0;
        LODWORD(v250[0]) = 0;
        *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigBottomTop;
        *(_OWORD *)((char *)&v250[1] + 4) = unk_1B66868A0;
        memset((char *)&v250[2] + 4, 0, 36);
        *(_OWORD *)&v251[4] = kVP_MicConfigBottomTop;
        *(_OWORD *)&v251[68] = v250[0];
        memset(&v251[36], 0, 32);
        *(_OWORD *)&v251[20] = unk_1B66868A0;
        *(_QWORD *)&v251[132] = unk_1B66868CC;
        *(_OWORD *)&v251[116] = v250[3];
        *(_OWORD *)&v251[100] = v250[2];
        *(_OWORD *)&v251[84] = v250[1];
        *(_QWORD *)&v251[140] = 0x200000000;
        *(_DWORD *)v251 = 2;
        v252 = 21;
        std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      }
LABEL_341:
      *((_WORD *)this + 2264) = 257;
      goto LABEL_463;
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v23 = 29;
      else
        v23 = 21;
      v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigTop;
      v247 = *(_OWORD *)algn_1B665D910;
      v248 = xmmword_1B665D920;
      v249 = unk_1B665D930;
      LODWORD(v250[0]) = 0;
      *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigTop;
      memset((char *)&v250[1] + 4, 0, 52);
      *(_QWORD *)&v251[132] = unk_1B665D93C;
      *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigTop;
      *(_OWORD *)&v251[68] = v250[0];
      memset(&v251[20], 0, 48);
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[84] = v250[1];
      *(_QWORD *)&v251[140] = 0x100000001;
      *(_DWORD *)v251 = 1;
      v252 = v23;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      if (*((_BYTE *)this + 2244))
        v24 = 29;
      else
        v24 = 21;
      v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
      v247 = *(_OWORD *)algn_1B665D954;
      v248 = xmmword_1B665D964;
      v249 = unk_1B665D974;
      LODWORD(v250[0]) = 0;
      *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigTop;
      memset((char *)&v250[1] + 4, 0, 52);
      *(_OWORD *)&v251[84] = v250[1];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[116] = v250[3];
      *(_QWORD *)&v251[132] = unk_1B665D93C;
      memset(&v251[20], 0, 48);
      *(_OWORD *)&v251[68] = v250[0];
      *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
      *(_QWORD *)&v251[140] = 0x100000001;
      *(_DWORD *)v251 = 2;
      v252 = v24;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      switch(a2)
      {
        case 24:
        case 25:
          if (*((_DWORD *)this + 22) == 1986618467)
          {
            std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
            v231 = 0;
            v232 = 0;
            v230 = (uint64_t *)&v231;
            if (*((_BYTE *)this + 2244))
              v25 = 29;
            else
              v25 = 21;
            v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
            v247 = *(_OWORD *)algn_1B665D954;
            v248 = xmmword_1B665D964;
            v249 = unk_1B665D974;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
            memset((char *)&v250[1] + 4, 0, 52);
            *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
            *(_OWORD *)&v251[68] = v250[0];
            *(_QWORD *)&v251[132] = unk_1B665D980;
            memset(&v251[20], 0, 48);
            *(_OWORD *)&v251[116] = v250[3];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[84] = v250[1];
            *(_QWORD *)&v251[140] = 0x300000001;
            *(_DWORD *)v251 = 2;
            v252 = v25;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          }
          if (**((_DWORD **)this + 292) == 1885892727 && *((_DWORD *)this + 596) == 1752709424)
          {
            v26 = v230;
            if (v230 != (uint64_t *)&v231)
            {
              if (*((_BYTE *)this + 2244))
                v27 = 29;
              else
                v27 = 26;
              do
              {
                *((_DWORD *)v26 + 44) = v27;
                v28 = (uint64_t *)v26[1];
                if (v28)
                {
                  do
                  {
                    v29 = v28;
                    v28 = (uint64_t *)*v28;
                  }
                  while (v28);
                }
                else
                {
                  do
                  {
                    v29 = (uint64_t *)v26[2];
                    v162 = *v29 == (_QWORD)v26;
                    v26 = v29;
                  }
                  while (!v162);
                }
                v26 = v29;
              }
              while (v29 != (uint64_t *)&v231);
            }
          }
          goto LABEL_463;
        case 26:
        case 27:
          v36 = *((_DWORD *)this + 22);
          switch(v36)
          {
            case 1987012963:
              goto LABEL_109;
            case 1986618467:
              std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
              v231 = 0;
              v232 = 0;
              v230 = (uint64_t *)&v231;
              if (*((_BYTE *)this + 2244))
                v37 = 30;
              else
                v37 = 23;
              goto LABEL_112;
            case 1835627363:
LABEL_109:
              std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
              v231 = 0;
              v232 = 0;
              v230 = (uint64_t *)&v231;
              if (*((_BYTE *)this + 2244))
                v37 = 30;
              else
                v37 = 23;
LABEL_112:
              v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
              v247 = *(_OWORD *)algn_1B665D954;
              v248 = xmmword_1B665D964;
              v249 = unk_1B665D974;
              LODWORD(v250[0]) = 0;
              *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
              memset((char *)&v250[1] + 4, 0, 52);
              *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
              *(_OWORD *)&v251[68] = v250[0];
              *(_QWORD *)&v251[132] = unk_1B665D980;
              memset(&v251[20], 0, 48);
              *(_OWORD *)&v251[116] = v250[3];
              *(_OWORD *)&v251[100] = v250[2];
              *(_OWORD *)&v251[84] = v250[1];
              *(_QWORD *)&v251[140] = 0x500000001;
              *(_DWORD *)v251 = 2;
              v252 = v37;
              std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
              goto LABEL_463;
          }
          if (*((_BYTE *)this + 2244))
            v90 = 30;
          else
            v90 = 23;
          v91 = v231;
          if (!v231)
            goto LABEL_307;
          v92 = &v231;
          v93 = v231;
          do
          {
            v94 = v93;
            v95 = v92;
            v96 = *((_DWORD *)v93 + 7);
            if (v96)
              v92 = (_QWORD **)v93;
            else
              ++v93;
            v93 = (_QWORD *)*v93;
          }
          while (v93);
          if (v92 == &v231)
            goto LABEL_307;
          if (!v96)
            v94 = v95;
          if (*((_DWORD *)v94 + 7) >= 2u)
LABEL_307:
            v92 = &v231;
          *((_DWORD *)v92 + 44) = v90;
          if (v91)
          {
            v97 = &v231;
            do
            {
              v98 = v91;
              v99 = v97;
              v100 = *((_DWORD *)v91 + 7);
              v101 = v91 + 1;
              if (v100 >= 2)
              {
                v101 = v98;
                v97 = (_QWORD **)v98;
              }
              v91 = (_QWORD *)*v101;
            }
            while (v91);
            if (v97 != &v231)
            {
              v102 = v100 >= 2 ? v98 : v99;
              if (*((_DWORD *)v102 + 7) < 3u)
                goto LABEL_393;
            }
          }
          goto LABEL_392;
        case 28:
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          if (*((_BYTE *)this + 2244))
            v80 = 30;
          else
            v80 = 23;
          goto LABEL_260;
        case 29:
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          if (*((_BYTE *)this + 2244))
            v82 = 29;
          else
            v82 = 21;
          *(_OWORD *)v251 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
          memset(&v251[16], 0, 52);
          *(_OWORD *)&v251[68] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J71(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kJ71_MicConfigBackTop;
          memset(&v251[84], 0, 52);
          *(_QWORD *)&v251[136] = 0x500000001;
          *(_DWORD *)&v251[144] = v82;
          std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<int,ProcessingChainInfo>(&v230, 0, (uint64_t)v251);
          goto LABEL_463;
        case 30:
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          if (*((_BYTE *)this + 2244))
            v80 = 29;
          else
            v80 = 21;
          goto LABEL_260;
        default:
          goto LABEL_463;
      }
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v16 = 29;
      else
        v16 = 21;
      v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kExtMicConfigFirst;
      v247 = *(_OWORD *)algn_1B668795C;
      v248 = xmmword_1B668796C;
      v249 = unk_1B668797C;
      LODWORD(v250[0]) = 0;
      *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kExtMicConfigFirst;
      memset((char *)&v250[1] + 4, 0, 52);
      *(_QWORD *)&v251[132] = unk_1B6687988;
      *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kExtMicConfigFirst;
      *(_OWORD *)&v251[68] = v250[0];
      memset(&v251[20], 0, 48);
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[84] = v250[1];
      *(_QWORD *)&v251[140] = 0x100000000;
      *(_DWORD *)v251 = 1;
      v252 = v16;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      LODWORD(v250[0]) = 0;
      v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
      v247 = *(_OWORD *)" right";
      v248 = xmmword_1B66879F4;
      v249 = unk_1B6687A04;
      *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeft;
      memset((char *)&v250[1] + 4, 0, 48);
      *(_OWORD *)&v251[84] = v250[1];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[20] = *(_OWORD *)" right";
      memset(&v251[36], 0, 32);
      *(_OWORD *)&v251[68] = v250[0];
      if (*((_BYTE *)this + 2244))
        v17 = 29;
      else
        v17 = 21;
      break;
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v9 = 29;
      else
        v9 = 21;
      v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kExtMicConfigFirst;
      v247 = *(_OWORD *)algn_1B668795C;
      v248 = xmmword_1B668796C;
      v249 = unk_1B668797C;
      LODWORD(v250[0]) = 0;
      *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kExtMicConfigFirst;
      memset((char *)&v250[1] + 4, 0, 52);
      *(_QWORD *)&v251[132] = unk_1B6687988;
      *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kExtMicConfigFirst;
      *(_OWORD *)&v251[68] = v250[0];
      memset(&v251[20], 0, 48);
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[84] = v250[1];
      *(_QWORD *)&v251[140] = 0x100000000;
      *(_DWORD *)v251 = 1;
      v252 = v9;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      LODWORD(v250[0]) = 0;
      v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
      v247 = *(_OWORD *)" right";
      v248 = xmmword_1B66879F4;
      v249 = unk_1B6687A04;
      *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeft;
      memset((char *)&v250[1] + 4, 0, 48);
      *(_OWORD *)&v251[84] = v250[1];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[20] = *(_OWORD *)" right";
      memset(&v251[36], 0, 32);
      *(_OWORD *)&v251[68] = v250[0];
      if (*((_BYTE *)this + 2244))
        v10 = 29;
      else
        v10 = 21;
      DWORD1(v250[4]) = 0;
      *(_QWORD *)&v251[132] = LODWORD(v250[4]);
      *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
      *(_QWORD *)&v251[140] = 0x100000000;
      *(_DWORD *)v251 = 5;
      v252 = v10;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      switch(a2)
      {
        case '&':
          v75 = *((_DWORD *)this + 22);
          if (v75 == 1986618467)
          {
            std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
            v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigAll;
            v247 = *(_OWORD *)algn_1B6687AF4;
            v248 = xmmword_1B6687B04;
            v249 = unk_1B6687B14;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopFrontSide;
            strcpy((char *)&v250[1] + 4, " right, front and side");
            BYTE11(v250[2]) = 0;
            *(_QWORD *)((char *)&v250[2] + 12) = 0;
            *(_OWORD *)((char *)&v250[3] + 4) = unk_1B6687AD0;
            *(_OWORD *)&v251[84] = v250[1];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[116] = v250[3];
            memset(&v251[20], 0, 48);
            *(_OWORD *)&v251[68] = v250[0];
            v231 = 0;
            v232 = 0;
            v230 = (uint64_t *)&v231;
            if (*((_BYTE *)this + 2244))
              v76 = 30;
            else
              v76 = 23;
          }
          else
          {
            if (v75 != 1987012963)
            {
              if (*((_BYTE *)this + 2244))
                v90 = 30;
              else
                v90 = 23;
              v109 = v231;
              if (!v231)
                goto LABEL_361;
              v110 = &v231;
              v111 = v231;
              do
              {
                v112 = v111;
                v113 = v110;
                v114 = *((_DWORD *)v111 + 7);
                if (v114)
                  v110 = (_QWORD **)v111;
                else
                  ++v111;
                v111 = (_QWORD *)*v111;
              }
              while (v111);
              if (v110 == &v231)
                goto LABEL_361;
              if (!v114)
                v112 = v113;
              if (*((_DWORD *)v112 + 7) >= 2u)
LABEL_361:
                v110 = &v231;
              *((_DWORD *)v110 + 44) = v90;
              if (v109)
              {
                v97 = &v231;
                do
                {
                  v115 = v109;
                  v116 = v97;
                  v117 = *((_DWORD *)v109 + 7);
                  v118 = v109 + 1;
                  if (v117 >= 5)
                  {
                    v118 = v115;
                    v97 = (_QWORD **)v115;
                  }
                  v109 = (_QWORD *)*v118;
                }
                while (v109);
                goto LABEL_387;
              }
              goto LABEL_392;
            }
            std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
            LODWORD(v250[0]) = 0;
            v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigAll;
            v247 = *(_OWORD *)algn_1B6687AF4;
            v248 = xmmword_1B6687B04;
            v249 = unk_1B6687B14;
            *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopFrontSide;
            strcpy((char *)&v250[1] + 4, " right, front and side");
            BYTE11(v250[2]) = 0;
            *(_QWORD *)((char *)&v250[2] + 12) = 0;
            *(_OWORD *)((char *)&v250[3] + 4) = unk_1B6687AD0;
            *(_OWORD *)&v251[84] = v250[1];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[116] = v250[3];
            memset(&v251[20], 0, 48);
            *(_OWORD *)&v251[68] = v250[0];
            v231 = 0;
            v232 = 0;
            v230 = (uint64_t *)&v231;
            if (*((_BYTE *)this + 2244))
              v76 = 30;
            else
              v76 = 23;
          }
          DWORD1(v250[4]) = 0;
          *(_QWORD *)&v251[132] = LODWORD(v250[4]);
          *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigAll;
          *(_QWORD *)&v251[140] = 0x500000000;
          *(_DWORD *)v251 = 5;
          v252 = v76;
          std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          break;
        case '\'':
        case '(':
          if (*((_DWORD *)this + 22) == 1986618467)
          {
            std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
            v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopFrontBack;
            v247 = unk_1B6687A28;
            v248 = xmmword_1B6687A38;
            v249 = unk_1B6687A48;
            LODWORD(v250[0]) = 0;
            *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigFrontBack;
            *(_OWORD *)((char *)&v250[1] + 4) = unk_1B6687A6C;
            memset((char *)&v250[2] + 4, 0, 32);
            *(_OWORD *)&v251[84] = v250[1];
            *(_OWORD *)&v251[100] = v250[2];
            *(_OWORD *)&v251[116] = v250[3];
            strcpy(&v251[20], " right, front and back");
            memset(&v251[43], 0, 25);
            *(_OWORD *)&v251[68] = v250[0];
            v231 = 0;
            v232 = 0;
            v230 = (uint64_t *)&v231;
            if (*((_BYTE *)this + 2244))
              v11 = 29;
            else
              v11 = 21;
            DWORD1(v250[4]) = 0;
            *(_QWORD *)&v251[132] = LODWORD(v250[4]);
            *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopFrontBack;
            *(_QWORD *)&v251[140] = 0x300000002;
            *(_DWORD *)v251 = 5;
            v252 = v11;
            std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
          }
          if (**((_DWORD **)this + 292) == 1885892727 && *((_DWORD *)this + 596) == 1752709424)
          {
            v12 = v230;
            if (v230 != (uint64_t *)&v231)
            {
              if (*((_BYTE *)this + 2244))
                v13 = 29;
              else
                v13 = 26;
              do
              {
                *((_DWORD *)v12 + 44) = v13;
                v14 = (uint64_t *)v12[1];
                if (v14)
                {
                  do
                  {
                    v15 = v14;
                    v14 = (uint64_t *)*v14;
                  }
                  while (v14);
                }
                else
                {
                  do
                  {
                    v15 = (uint64_t *)v12[2];
                    v162 = *v15 == (_QWORD)v12;
                    v12 = v15;
                  }
                  while (!v162);
                }
                v12 = v15;
              }
              while (v15 != (uint64_t *)&v231);
            }
          }
          break;
        case ')':
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          if (*((_BYTE *)this + 2244))
            v74 = 29;
          else
            v74 = 25;
LABEL_214:
          v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
          v247 = *(_OWORD *)" right";
          v248 = xmmword_1B66879F4;
          v249 = unk_1B6687A04;
          LODWORD(v250[0]) = 0;
          *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeft;
          memset((char *)&v250[1] + 4, 0, 52);
          *(_QWORD *)&v251[132] = unk_1B66879CC;
          *(_OWORD *)&v251[84] = v250[1];
          *(_OWORD *)&v251[100] = v250[2];
          *(_OWORD *)&v251[116] = v250[3];
          *(_OWORD *)&v251[20] = *(_OWORD *)" right";
          memset(&v251[36], 0, 32);
          *(_OWORD *)&v251[68] = v250[0];
          *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
          *(_QWORD *)&v251[140] = 0x100000000;
          *(_DWORD *)v251 = 5;
          v252 = v74;
          std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
LABEL_10:
          *((_DWORD *)this + 1112) = 127;
          break;
        case '*':
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          if (*((_BYTE *)this + 2244))
            v80 = 30;
          else
            v80 = 23;
          goto LABEL_260;
        case '+':
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          *(_OWORD *)v251 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigAll;
          memset(&v251[16], 0, 48);
          *(_OWORD *)&v251[68] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopFrontSide;
          strcpy(&v251[84], " right, front and side");
          v251[107] = 0;
          *(_QWORD *)&v251[108] = 0;
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          if (*((_BYTE *)this + 2244))
            v79 = 29;
          else
            v79 = 21;
          *(_DWORD *)&v251[64] = 0;
          memset(&v251[116], 0, 20);
          *(_QWORD *)&v251[136] = 0x500000000;
          *(_DWORD *)&v251[144] = v79;
          std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<int,ProcessingChainInfo>(&v230, 5u, (uint64_t)v251);
          break;
        case ',':
          std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
          v231 = 0;
          v232 = 0;
          v230 = (uint64_t *)&v231;
          if (*((_BYTE *)this + 2244))
            v80 = 29;
          else
            v80 = 21;
LABEL_260:
          *(_OWORD *)v251 = kVP_MicConfigPrimaryMicOnly;
          memset(&v251[16], 0, 52);
          *(_OWORD *)&v251[68] = kVP_MicConfigPrimaryMicOnly;
          memset(&v251[84], 0, 52);
          *(_QWORD *)&v251[136] = 0x100000000;
          *(_DWORD *)&v251[144] = v80;
          std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<int,ProcessingChainInfo>(&v230, 0, (uint64_t)v251);
          break;
        default:
          goto LABEL_463;
      }
      goto LABEL_463;
    case 45:
    case 46:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v35 = 29;
      else
        v35 = 26;
      v246 = kVP_MicConfigPrimaryMicOnly;
      v247 = unk_1B6689648;
      v248 = xmmword_1B6689658;
      v249 = unk_1B6689668;
      LODWORD(v250[0]) = 0;
      *(_OWORD *)((char *)v250 + 4) = kVP_MicConfigPrimaryMicOnly;
      memset((char *)&v250[1] + 4, 0, 52);
      *(_OWORD *)&v251[4] = kVP_MicConfigPrimaryMicOnly;
      *(_OWORD *)&v251[68] = v250[0];
      memset(&v251[20], 0, 48);
      *(_QWORD *)&v251[132] = unk_1B6689674;
      *(_OWORD *)&v251[116] = v250[3];
      *(_OWORD *)&v251[100] = v250[2];
      *(_OWORD *)&v251[84] = v250[1];
      *(_DWORD *)v251 = 0;
      *(_DWORD *)&v251[140] = 0;
      *(_DWORD *)&v251[144] = 0;
      v252 = v35;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      goto LABEL_463;
    default:
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v225 = CALog::LogObjIfEnabled(1, VPLogScope(void)::scope);
      if (v225)
      {
        v226 = v225;
        if (os_log_type_enabled(v225, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v251 = 136315650;
          *(_QWORD *)&v251[4] = "vpRouteSetup_v2.cpp";
          *(_WORD *)&v251[12] = 1024;
          *(_DWORD *)&v251[14] = 535;
          *(_WORD *)&v251[18] = 1024;
          *(_DWORD *)&v251[20] = a2;
          _os_log_impl(&dword_1B5ED0000, v226, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Unknown Route Type: %d", v251, 0x18u);
        }
      }
      v227 = (int *)*((_QWORD *)this + 1570);
      if (v227 && (*v6 || v6[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v227, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpRouteSetup/vpRouteSetup_v2.cpp", 535, "DispatchVPRouteSetup", "Unknown Route Type: %d", a2);
      }
      __assert_rtn("DispatchVPRouteSetup", "vpRouteSetup_v2.cpp", 536, "!\"Unknown Route Type!\"");
  }
  DWORD1(v250[4]) = 0;
  *(_QWORD *)&v251[132] = LODWORD(v250[4]);
  *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
  *(_QWORD *)&v251[140] = 0x100000000;
  *(_DWORD *)v251 = 5;
  v252 = v17;
  std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
  switch(a2)
  {
    case 31:
      v77 = *((_DWORD *)this + 22);
      if (v77 == 1986618467)
      {
        std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
        v231 = 0;
        v232 = 0;
        v230 = (uint64_t *)&v231;
        if (*((_BYTE *)this + 2244))
          v78 = 30;
        else
          v78 = 23;
        goto LABEL_229;
      }
      if (v77 == 1987012963)
      {
        std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
        v231 = 0;
        v232 = 0;
        v230 = (uint64_t *)&v231;
        if (*((_BYTE *)this + 2244))
          v78 = 30;
        else
          v78 = 23;
LABEL_229:
        v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
        v247 = *(_OWORD *)" right";
        v248 = xmmword_1B66879F4;
        v249 = unk_1B6687A04;
        LODWORD(v250[0]) = 0;
        *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
        *(_OWORD *)((char *)&v250[1] + 4) = *(_OWORD *)" right";
        memset((char *)&v250[2] + 4, 0, 36);
        *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
        *(_OWORD *)&v251[68] = v250[0];
        *(_QWORD *)&v251[132] = unk_1B6687A10;
        memset(&v251[36], 0, 32);
        *(_OWORD *)&v251[20] = *(_OWORD *)" right";
        *(_OWORD *)&v251[116] = v250[3];
        *(_OWORD *)&v251[100] = v250[2];
        *(_OWORD *)&v251[84] = v250[1];
        *(_QWORD *)&v251[140] = 0x500000000;
        *(_DWORD *)v251 = 5;
        v252 = v78;
        std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
        goto LABEL_463;
      }
      if (*((_BYTE *)this + 2244))
        v90 = 30;
      else
        v90 = 23;
      v119 = v231;
      if (!v231)
        goto LABEL_381;
      v120 = &v231;
      v121 = v231;
      do
      {
        v122 = v121;
        v123 = v120;
        v124 = *((_DWORD *)v121 + 7);
        if (v124)
          v120 = (_QWORD **)v121;
        else
          ++v121;
        v121 = (_QWORD *)*v121;
      }
      while (v121);
      if (v120 == &v231)
        goto LABEL_381;
      if (!v124)
        v122 = v123;
      if (*((_DWORD *)v122 + 7) >= 2u)
LABEL_381:
        v120 = &v231;
      *((_DWORD *)v120 + 44) = v90;
      if (!v119)
        goto LABEL_392;
      v97 = &v231;
      do
      {
        v115 = v119;
        v116 = v97;
        v117 = *((_DWORD *)v119 + 7);
        v125 = v119 + 1;
        if (v117 >= 5)
        {
          v125 = v115;
          v97 = (_QWORD **)v115;
        }
        v119 = (_QWORD *)*v125;
      }
      while (v119);
LABEL_387:
      if (v97 == &v231 || (v117 >= 5 ? (v126 = v115) : (v126 = v116), *((_DWORD *)v126 + 7) >= 6u))
LABEL_392:
        v97 = &v231;
LABEL_393:
      *((_DWORD *)v97 + 44) = v90;
LABEL_463:
      v229[0] = 0;
      v229[1] = 0;
      v228 = v229;
      v142 = v230;
      if (v230 == (uint64_t *)&v231)
      {
        v146 = (int *)((char *)this + 652);
      }
      else
      {
        do
        {
          std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int const,ProcessingChainInfo> const&>((uint64_t *)&v228, (uint64_t *)v229, *((_DWORD *)v142 + 7), (uint64_t)v142 + 28);
          v143 = (uint64_t *)v142[1];
          if (v143)
          {
            do
            {
              v144 = v143;
              v143 = (uint64_t *)*v143;
            }
            while (v143);
          }
          else
          {
            do
            {
              v144 = (uint64_t *)v142[2];
              v162 = *v144 == (_QWORD)v142;
              v142 = v144;
            }
            while (!v162);
          }
          v142 = v144;
        }
        while (v144 != (uint64_t *)&v231);
        v145 = v229[0];
        v146 = (int *)((char *)this + 652);
        if (v229[0])
        {
          v147 = *v146;
          v148 = v229;
          v149 = v229[0];
          do
          {
            v150 = v149;
            v151 = v148;
            v152 = *((_DWORD *)v149 + 7);
            if (v152 >= v147)
              v148 = (_QWORD **)v149;
            else
              ++v149;
            v149 = (_QWORD *)*v149;
          }
          while (v149);
          v153 = v229[0];
          if (v148 != v229)
          {
            if (v152 < v147)
              v150 = v151;
            v153 = v229[0];
            v154 = v229;
            v155 = v229[0];
            if (v147 >= *((_DWORD *)v150 + 7))
              goto LABEL_488;
          }
          do
          {
            v156 = v153;
            v153 = (_QWORD *)*v153;
          }
          while (v153);
          if (v156 != v229)
          {
            v154 = v229;
            v155 = v229[0];
            if (!*((_DWORD *)v156 + 7))
            {
LABEL_488:
              do
              {
                v157 = v155;
                v158 = v154;
                v159 = *((_DWORD *)v155 + 7);
                if (v159 >= v147)
                  v160 = v155;
                else
                  v160 = v155 + 1;
                if (v159 >= v147)
                  v154 = (_QWORD **)v155;
                v155 = (_QWORD *)*v160;
              }
              while (*v160);
              if (v154 == v229)
                goto LABEL_646;
              if (v159 < v147)
                v157 = v158;
              if (v147 < *((_DWORD *)v157 + 7))
              {
LABEL_646:
                do
                {
                  v161 = (_QWORD **)v145;
                  v145 = (_QWORD *)*v145;
                }
                while (v145);
                if (*((_DWORD *)v161 + 7))
                  v162 = 1;
                else
                  v162 = v161 == v229;
                if (v162)
                  v163 = v229;
                else
                  v163 = v161;
              }
              else
              {
                v163 = v229;
                do
                {
                  v202 = v145;
                  v203 = v163;
                  v204 = *((_DWORD *)v145 + 7);
                  v205 = v145 + 1;
                  if (v204 >= v147)
                  {
                    v205 = v202;
                    v163 = (_QWORD **)v202;
                  }
                  v145 = (_QWORD *)*v205;
                }
                while (v145);
                if (v163 == v229 || (v204 >= v147 ? (v206 = v202) : (v206 = v203), v147 < *((_DWORD *)v206 + 7)))
                  v163 = v229;
              }
              v183 = v163 + 4;
              v207 = *((_OWORD *)v163 + 3);
              v208 = *((_OWORD *)v163 + 5);
              *(_OWORD *)&v251[32] = *((_OWORD *)v163 + 4);
              *(_OWORD *)&v251[48] = v208;
              *(_DWORD *)&v251[64] = *((_DWORD *)v163 + 24);
              *(_OWORD *)v251 = *((_OWORD *)v163 + 2);
              *(_OWORD *)&v251[16] = v207;
              v209 = *(_OWORD *)((char *)v163 + 116);
              v210 = *(_OWORD *)((char *)v163 + 148);
              v248 = *(_OWORD *)((char *)v163 + 132);
              v249 = v210;
              v211 = *((_DWORD *)v163 + 42);
              LODWORD(v250[0]) = *((_DWORD *)v163 + 41);
              v246 = *(_OWORD *)((char *)v163 + 100);
              v247 = v209;
              VoiceProcessorV2::SetHwMicAndEpMicChannelConfig(this, (uint64_t)v251, (uint64_t)&v246, v211);
              v212 = *(uint64_t *)((char *)v163 + 172);
              *((_QWORD *)this + 1549) = v212;
              v213 = 43;
              v214 = 39;
              switch((int)v212)
              {
                case 0:
                  *(_QWORD *)buf = (char *)this + 4656;
                  *(_DWORD *)&buf[8] = 0;
                  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)buf);
                  goto LABEL_539;
                case 1:
                  goto LABEL_602;
                case 2:
                  goto LABEL_605;
                case 3:
                  v215 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)this + 112));
                  v215.i16[0] = vaddlv_u8(v215);
                  (*(void (**)(VoiceProcessorV2 *, _QWORD, _QWORD))(*(_QWORD *)this + 352))(this, v215.u32[0], 0);
                  goto LABEL_539;
                case 5:
                  v213 = 45;
                  goto LABEL_605;
                case 6:
                  *(_QWORD *)buf = (char *)this + 4656;
                  *(_DWORD *)&buf[8] = 0;
                  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)buf);
                  *((_QWORD *)this + 582) |= 0x4000000000000000uLL;
                  goto LABEL_539;
                case 7:
                  *(_QWORD *)buf = (char *)this + 4656;
                  *(_DWORD *)&buf[8] = 0;
                  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)buf);
                  *((_QWORD *)this + 583) |= 0x12uLL;
                  goto LABEL_539;
                case 8:
                  v214 = 41;
                  goto LABEL_602;
                case 9:
                  v213 = 46;
                  goto LABEL_605;
                case 10:
                  *(_QWORD *)buf = (char *)this + 4656;
                  *(_DWORD *)&buf[8] = 0;
                  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)buf);
                  *((int8x16_t *)this + 291) = vorrq_s8(*((int8x16_t *)this + 291), (int8x16_t)xmmword_1B66A2950);
                  goto LABEL_539;
                case 11:
                  *(_QWORD *)buf = (char *)this + 4656;
                  *(_DWORD *)&buf[8] = 0;
                  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)buf);
                  *((_QWORD *)this + 583) |= 0x20uLL;
                  if ((*(unsigned int (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this) == 8
                    || (*(unsigned int (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 112))(this) == 7)
                  {
                    *((_QWORD *)this + 582) |= 0x4000000000000000uLL;
                    *((_DWORD *)this + 1091) = 1092616192;
                  }
                  goto LABEL_539;
                case 12:
                  v213 = 47;
LABEL_605:
                  v216 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)this + 112));
                  v216.i16[0] = vaddlv_u8(v216);
                  (*(void (**)(VoiceProcessorV2 *, _QWORD))(*(_QWORD *)this + 8 * v213))(this, v216.u32[0]);
                  break;
                case 14:
                  v214 = 42;
LABEL_602:
                  (*(void (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 8 * v214))(this);
                  break;
                default:
                  goto LABEL_539;
              }
              goto LABEL_539;
            }
          }
        }
      }
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v164 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v165 = (*v164 ? *v164 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
        {
          v166 = (_QWORD *)((char *)this + 32);
          if (*((char *)this + 55) < 0)
            v166 = (_QWORD *)*v166;
          v167 = *((_DWORD *)this + 163);
          v168 = *((_DWORD *)this + 19);
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = "vpRouteSetup_v2.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 252;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v166;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v167;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v168;
          _os_log_impl(&dword_1B5ED0000, v165, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> _vp <SERIOUS ERROR> %s vp received %d built-in mic channels in mode %d?!!!!!That is Wrong!!!!!! Please file a radar against Audio - DSP Component!!!!!", buf, 0x28u);
        }
      }
      v169 = (int *)*((_QWORD *)this + 1570);
      if (v169 && (*v6 || *((_BYTE *)this + 15898)))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v170 = (char *)this + 32;
        if (*((char *)this + 55) < 0)
          v170 = *(const char **)v170;
        CALegacyLog::log(v169, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpRouteSetup/vpRouteSetup_v2.cpp", 252, "SetupMicsAndProcessingChain", "_vp <SERIOUS ERROR> %s vp received %d built-in mic channels in mode %d?!!!!!That is Wrong!!!!!! Please file a radar against Audio - DSP Component!!!!!", v170, *((_DWORD *)this + 163), *((_DWORD *)this + 19));
      }
      *(_QWORD *)&buf[8] = 0;
      *(_QWORD *)&buf[16] = 0;
      *(_QWORD *)buf = &buf[8];
      std::to_string(&v236, *v146);
      v171 = std::string::insert(&v236, 0, "vp received the wrong number of built-in mic channels ", 0x36uLL);
      v172 = *(_OWORD *)&v171->__r_.__value_.__l.__data_;
      v237.__r_.__value_.__r.__words[2] = v171->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v237.__r_.__value_.__l.__data_ = v172;
      v171->__r_.__value_.__l.__size_ = 0;
      v171->__r_.__value_.__r.__words[2] = 0;
      v171->__r_.__value_.__r.__words[0] = 0;
      v173 = std::string::append(&v237, " in mode ", 9uLL);
      v174 = *(_OWORD *)&v173->__r_.__value_.__l.__data_;
      *(_QWORD *)v240 = *((_QWORD *)&v173->__r_.__value_.__l + 2);
      v239 = v174;
      v173->__r_.__value_.__l.__size_ = 0;
      v173->__r_.__value_.__r.__words[2] = 0;
      v173->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v235, *((_DWORD *)this + 19));
      if ((v235.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v175 = &v235;
      else
        v175 = (std::string *)v235.__r_.__value_.__r.__words[0];
      if ((v235.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v235.__r_.__value_.__r.__words[2]);
      else
        size = v235.__r_.__value_.__l.__size_;
      v177 = std::string::append((std::string *)&v239, (const std::string::value_type *)v175, size);
      v178 = v177->__r_.__value_.__r.__words[0];
      v253[0] = v177->__r_.__value_.__l.__size_;
      *(_QWORD *)((char *)v253 + 7) = *(std::string::size_type *)((char *)&v177->__r_.__value_.__r.__words[1] + 7);
      v179 = HIBYTE(v177->__r_.__value_.__r.__words[2]);
      v177->__r_.__value_.__l.__size_ = 0;
      v177->__r_.__value_.__r.__words[2] = 0;
      v177->__r_.__value_.__r.__words[0] = 0;
      std::string::basic_string[abi:ne180100]<0>(__p, "vp_routing_setup_error");
      v238 = __p;
      v180 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)buf, __p, (_OWORD **)&v238);
      v181 = v180;
      if (*((char *)v180 + 79) < 0)
        operator delete(v180[7]);
      v182 = (void *)v253[0];
      v181[7] = (void *)v178;
      v181[8] = v182;
      *(void **)((char *)v181 + 71) = *(void **)((char *)v253 + 7);
      *((_BYTE *)v181 + 79) = v179;
      if (v234 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v235.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v235.__r_.__value_.__l.__data_);
      if ((v240[7] & 0x80000000) != 0)
        operator delete((void *)v239);
      if (SHIBYTE(v237.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v237.__r_.__value_.__l.__data_);
      if (SHIBYTE(v236.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v236.__r_.__value_.__l.__data_);
      AudioStatisticsHelperSendMessage(*((uint64_t **)this + 270), *((_DWORD *)this + 542), (const UInt8 **)buf, 6);
      VoiceProcessorV2::SetHwMicAndEpMicChannelConfig(this, (uint64_t)&kVP_MicConfigPrimaryMicOnly, (uint64_t)&kVP_MicConfigPrimaryMicOnly, 0);
      (*(void (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 312))(this);
      v183 = v228 + 4;
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(_QWORD **)&buf[8]);
LABEL_539:
      switch(*((_DWORD *)v183 + 36))
      {
        case 0x14:
          *(_QWORD *)buf = (char *)this + 8832;
          *(_DWORD *)&buf[8] = 0;
          std::__fill_n[abi:ne180100]<false,std::__bitset<1ul,62ul>>((uint64_t)buf);
          break;
        case 0x15:
          (*(void (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 400))(this);
          if (*((_DWORD *)this + 596) == 1781740087)
          {
            v194 = *((_QWORD *)this + 1104) | 0x2000000000000000;
            goto LABEL_563;
          }
          break;
        case 0x16:
          v187 = *((_QWORD *)this + 1104) | 0x1000000000;
          goto LABEL_545;
        case 0x17:
          v188 = *((_QWORD *)this + 1104);
          v189 = v188 | 0x1000000000;
          *((_QWORD *)this + 1104) = v188 | 0x1000000000;
          v190 = *((_DWORD *)this + 18);
          *(_DWORD *)buf = 1;
          LODWORD(v239) = 0;
          switch(v190)
          {
            case 1:
            case 2:
            case 3:
              *(_DWORD *)buf = 0;
              *((_QWORD *)this + 1104) = v188 | 0x100001000000000;
              AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1531, 0xFA02u, 0, 0, 4uLL, buf, 1);
              LODWORD(v239) = 1;
              AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1531, 0xFA04u, 0, 0, 4uLL, &v239, 1);
              v217 = *((_QWORD *)this + 1104) & 0xFFFFFFCFFFFFFFFFLL | 0x2000000000;
              *((_QWORD *)this + 1104) = v217;
              if (*((_DWORD *)this + 89) < 2u)
                goto LABEL_550;
              v192 = v217 & 0xFF8FFFEFF9FFFFFFLL;
              v193 = 0x70000004000000;
              goto LABEL_549;
            case 4:
            case 5:
            case 6:
            case 7:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              *(_DWORD *)buf = 0;
              *((_QWORD *)this + 1104) = v188 | 0x100001000000000;
              AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1531, 0xFA02u, 0, 0, 4uLL, buf, 1);
              LODWORD(v239) = 1;
              AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1531, 0xFA04u, 0, 0, 4uLL, &v239, 1);
              v191 = *((_QWORD *)this + 1104);
              *((_QWORD *)this + 1104) = v191 & 0xFFFFFFEFFFFFFFFFLL;
              if (*((_DWORD *)this + 89) < 2u)
                goto LABEL_550;
              v192 = v191 & 0xFFBFFFE3F9FFFFFFLL;
              v193 = 0x40000804000000;
LABEL_549:
              *((_QWORD *)this + 1104) = v192 | v193;
LABEL_550:
              *((_DWORD *)this + 1128) = 1;
              goto LABEL_551;
            case 8:
            case 34:
            case 35:
            case 36:
              *((_QWORD *)this + 1104) = v188 | 0x100001000000000;
              AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1531, 0xFA02u, 0, 0, 4uLL, buf, 1);
              goto LABEL_551;
            case 22:
            case 23:
              *((_QWORD *)this + 1104) = v188 & 0xFCFFFFEFFFFFFFFFLL | 0x200001000000000;
              AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1534, 0xFA02u, 0, 0, 4uLL, buf, 1);
              LODWORD(v237.__r_.__value_.__l.__data_) = 0;
              AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1534, 0xFA04u, 0, 0, 4uLL, &v237, 1);
              v218 = *((_QWORD *)this + 1104);
              if (*((_DWORD *)this + 89) <= 1u)
              {
                v219 = v218 & 0xF3BC798FFFFFFFFFLL;
              }
              else
              {
                *((_QWORD *)this + 1104) = v218 | 0x400000000000000;
                LODWORD(v236.__r_.__value_.__l.__data_) = 1;
                AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1537, 0xFA04u, 0, 0, 4uLL, &v236, 1);
                v219 = *((_QWORD *)this + 1104) & 0xF7BC798FFFFFFFFFLL;
                if (*((_DWORD *)this + 89) >= 2u)
                {
                  v220 = v219 | 0x60000000000;
                  v221 = 0x43000000000000;
                  goto LABEL_630;
                }
              }
              v220 = v219 | 0x20000000000;
              v221 = 0x41000000000000;
LABEL_630:
              v187 = v220 | v221;
              break;
            case 24:
            case 25:
              VoiceProcessorV2::SetupDownlink_SPP_SCi_J4xx((uint64_t)this);
              goto LABEL_551;
            case 26:
            case 27:
            case 28:
            case 29:
              VoiceProcessorV2::SetupDownlink_SPP_SCi_J4xx((uint64_t)this);
              v187 = *((_QWORD *)this + 1104) | 0x800000000000000;
              break;
            case 30:
            case 31:
            case 32:
              *((_QWORD *)this + 1104) = v188 | 0x100001000000000;
              AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1531, 0xFA02u, 0, 0, 4uLL, buf, 1);
              if (*((_BYTE *)this + 2245)
                && VoiceProcessorV2::GetFarEndVoiceMixChannelCount(this) >= 2
                && !*((_BYTE *)this + 2244))
              {
                *((_QWORD *)this + 1104) |= 0x8000000000uLL;
              }
              goto LABEL_626;
            case 33:
            case 37:
              goto LABEL_620;
            case 38:
              v222 = _os_feature_enabled_impl();
              v189 = *((_QWORD *)this + 1104);
              if (v222)
              {
                v223 = v189 & 0xFEFFFFFFFFFFFFFFLL;
              }
              else
              {
LABEL_620:
                *((_QWORD *)this + 1104) = v189 | 0x100000000000000;
                AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1531, 0xFA02u, 0, 0, 4uLL, buf, 1);
                v223 = *((_QWORD *)this + 1104);
              }
              v224 = v223 & 0xFFFFFFF3F9FFFFFFLL | 0x804000000;
              *((_QWORD *)this + 1104) = v224;
              if (*((_BYTE *)this + 2245))
              {
                if (VoiceProcessorV2::GetFarEndVoiceMixChannelCount(this) <= 1)
                {
LABEL_626:
                  v224 = *((_QWORD *)this + 1104);
                }
                else if (*((_BYTE *)this + 2244))
                {
                  v224 = *((_QWORD *)this + 1104);
                }
                else
                {
                  v224 = *((_QWORD *)this + 1104) | 0x10000000000;
                }
              }
              v187 = v224 & 0xFFFFFFEFFFFFFFFFLL;
              break;
            default:
              __assert_rtn("SetupDownlink_SPP_SCi", "vpRouteSetup_v2.cpp", 194, "false");
          }
LABEL_545:
          *((_QWORD *)this + 1104) = v187;
LABEL_551:
          *((_DWORD *)this + 1131) = -1061158912;
          break;
        case 0x18:
          *(_QWORD *)buf = (char *)this + 8832;
          *(_DWORD *)&buf[8] = 0;
          std::__fill_n[abi:ne180100]<false,std::__bitset<1ul,62ul>>((uint64_t)buf);
          v184 = *((_QWORD *)this + 1104);
          v185 = 0x800000028000000;
          goto LABEL_562;
        case 0x19:
          *(_QWORD *)buf = (char *)this + 8832;
          *(_DWORD *)&buf[8] = 0;
          std::__fill_n[abi:ne180100]<false,std::__bitset<1ul,62ul>>((uint64_t)buf);
          v184 = *((_QWORD *)this + 1104);
          v195 = 671088640;
          goto LABEL_561;
        case 0x1A:
          *(_QWORD *)buf = (char *)this + 8832;
          *(_DWORD *)&buf[8] = 0;
          std::__fill_n[abi:ne180100]<false,std::__bitset<1ul,62ul>>((uint64_t)buf);
          v184 = *((_QWORD *)this + 1104);
          v185 = 671088640;
          goto LABEL_562;
        case 0x1B:
          (*(void (**)(VoiceProcessorV2 *))(*(_QWORD *)this + 416))(this);
          break;
        case 0x1C:
          *(_QWORD *)buf = (char *)this + 8832;
          *(_DWORD *)&buf[8] = 0;
          std::__fill_n[abi:ne180100]<false,std::__bitset<1ul,62ul>>((uint64_t)buf);
          v184 = *((_QWORD *)this + 1104);
          v195 = 4;
LABEL_561:
          v185 = v195 & 0xFFFFFFFFFFFFLL | 0x1000000000000000;
LABEL_562:
          v194 = v184 | v185;
LABEL_563:
          *((_QWORD *)this + 1104) = v194;
          break;
        case 0x1D:
          *(_QWORD *)buf = (char *)this + 8832;
          *(_DWORD *)&buf[8] = 0;
          std::__fill_n[abi:ne180100]<false,std::__bitset<1ul,62ul>>((uint64_t)buf);
          v186 = *((_QWORD *)this + 1104);
          *((_QWORD *)this + 1104) = v186 | 0x3000C000;
          if (*((_DWORD *)this + 596) == 1781740087)
            *((_QWORD *)this + 1104) = v186 | 0x200000003000C000;
          break;
        case 0x1E:
          *(_QWORD *)buf = (char *)this + 8832;
          *(_DWORD *)&buf[8] = 0;
          std::__fill_n[abi:ne180100]<false,std::__bitset<1ul,62ul>>((uint64_t)buf);
          v196 = *((_QWORD *)this + 1104);
          *((_QWORD *)this + 1104) = v196 | 0x3000C000;
          if (*((_BYTE *)this + 2244) && *((_DWORD *)this + 89) >= 2u)
            *((_QWORD *)this + 1104) = v196 | 0x301FC000;
          break;
        default:
          break;
      }
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v197 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v198 = (*v197 ? *v197 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v198, OS_LOG_TYPE_DEFAULT))
        {
          v199 = *((_DWORD *)v183 + 35);
          v200 = *((_DWORD *)v183 + 36);
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "vpRouteSetup_v2.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 423;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v199;
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = v200;
          _os_log_impl(&dword_1B5ED0000, v198, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Setting up DSP Chains: Uplink: %d, Downlink: %d", buf, 0x1Eu);
        }
      }
      v201 = (int *)*((_QWORD *)this + 1570);
      if (v201 && (*v6 || v6[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v201, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpRouteSetup/vpRouteSetup_v2.cpp", 423, "SetupMicsAndProcessingChain", "Setting up DSP Chains: Uplink: %d, Downlink: %d", *((_DWORD *)v183 + 35), *((_DWORD *)v183 + 36));
      }
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v229[0]);
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      return;
    case 32:
    case 33:
      if (*((_DWORD *)this + 22) == 1986618467)
      {
        std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
        v246 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopFrontBack;
        v247 = unk_1B6687A28;
        v248 = xmmword_1B6687A38;
        v249 = unk_1B6687A48;
        LODWORD(v250[0]) = 0;
        *(_OWORD *)((char *)v250 + 4) = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigFrontBack;
        *(_OWORD *)((char *)&v250[1] + 4) = unk_1B6687A6C;
        memset((char *)&v250[2] + 4, 0, 32);
        *(_OWORD *)&v251[84] = v250[1];
        *(_OWORD *)&v251[100] = v250[2];
        *(_OWORD *)&v251[116] = v250[3];
        strcpy(&v251[20], " right, front and back");
        memset(&v251[43], 0, 25);
        *(_OWORD *)&v251[68] = v250[0];
        v231 = 0;
        v232 = 0;
        v230 = (uint64_t *)&v231;
        if (*((_BYTE *)this + 2244))
          v18 = 29;
        else
          v18 = 21;
        DWORD1(v250[4]) = 0;
        *(_QWORD *)&v251[132] = LODWORD(v250[4]);
        *(_OWORD *)&v251[4] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopFrontBack;
        *(_QWORD *)&v251[140] = 0x300000002;
        *(_DWORD *)v251 = 5;
        v252 = v18;
        std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(&v230, (int *)v251);
      }
      if (**((_DWORD **)this + 292) == 1885892727 && *((_DWORD *)this + 596) == 1752709424)
      {
        v19 = v230;
        if (v230 != (uint64_t *)&v231)
        {
          if (*((_BYTE *)this + 2244))
            v20 = 29;
          else
            v20 = 26;
          do
          {
            *((_DWORD *)v19 + 44) = v20;
            v21 = (uint64_t *)v19[1];
            if (v21)
            {
              do
              {
                v22 = v21;
                v21 = (uint64_t *)*v21;
              }
              while (v21);
            }
            else
            {
              do
              {
                v22 = (uint64_t *)v19[2];
                v162 = *v22 == (_QWORD)v19;
                v19 = v22;
              }
              while (!v162);
            }
            v19 = v22;
          }
          while (v22 != (uint64_t *)&v231);
        }
      }
      goto LABEL_463;
    case 34:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v74 = 29;
      else
        v74 = 25;
      goto LABEL_214;
    case 35:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v80 = 30;
      else
        v80 = 23;
      goto LABEL_260;
    case 36:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v81 = 29;
      else
        v81 = 21;
      *(_OWORD *)v251 = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
      *(_OWORD *)&v251[16] = *(_OWORD *)" right";
      memset(&v251[32], 0, 36);
      *(_OWORD *)&v251[68] = VoiceProcessorV2_RouteSetupHelper::GetDSPChainInfo_J417(VoiceProcessorV2 *,unsigned int,std::map<unsigned int,ProcessingChainInfo> &)::kMicConfigTopLeftRight;
      *(_OWORD *)&v251[84] = *(_OWORD *)" right";
      memset(&v251[100], 0, 36);
      *(_QWORD *)&v251[136] = 0x500000000;
      *(_DWORD *)&v251[144] = v81;
      std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<int,ProcessingChainInfo>(&v230, 5u, (uint64_t)v251);
      goto LABEL_463;
    case 37:
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v231);
      v231 = 0;
      v232 = 0;
      v230 = (uint64_t *)&v231;
      if (*((_BYTE *)this + 2244))
        v80 = 29;
      else
        v80 = 21;
      goto LABEL_260;
    default:
      goto LABEL_463;
  }
}

void sub_1B659C858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,_QWORD *a39,uint64_t a40,uint64_t a41,_QWORD *a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,void *a62,uint64_t a63)
{
  char a67;
  void *a69;
  char a72;
  _QWORD *a73;
  void *v73;
  int v74;

  if (a49 < 0)
    operator delete(__p);
  if (v74 < 0)
    operator delete(v73);
  if (a55 < 0)
    operator delete(a50);
  if (a72 < 0)
    operator delete(a69);
  if (a67 < 0)
    operator delete(a62);
  if (a61 < 0)
    operator delete(a56);
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a73);
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a39);
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a42);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int const,ProcessingChainInfo> const&>(uint64_t *result, uint64_t *a2, unsigned int a3, uint64_t a4)
{
  uint64_t **v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t **v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t **v14;
  uint64_t *v15;
  BOOL v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t *v20;
  unsigned int v21;
  char *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;

  v5 = (uint64_t **)result;
  v6 = (uint64_t **)(result + 1);
  if (result + 1 == a2 || (v7 = *((_DWORD *)a2 + 7), v7 > a3))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*result == a2)
    {
      v10 = a2;
LABEL_16:
      if (v8)
        v13 = (uint64_t **)v10;
      else
        v13 = (uint64_t **)a2;
      if (v8)
        v11 = (uint64_t **)(v10 + 1);
      else
        v11 = (uint64_t **)a2;
      goto LABEL_22;
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v15 = a2;
      do
      {
        v10 = (uint64_t *)v15[2];
        v16 = *v10 == (_QWORD)v15;
        v15 = v10;
      }
      while (v16);
    }
    if (*((_DWORD *)v10 + 7) < a3)
      goto LABEL_16;
    v17 = *v6;
    if (*v6)
    {
      while (1)
      {
        while (1)
        {
          v13 = (uint64_t **)v17;
          v18 = *((_DWORD *)v17 + 7);
          if (v18 <= a3)
            break;
          v17 = *v13;
          v6 = v13;
          if (!*v13)
            goto LABEL_44;
        }
        if (v18 >= a3)
          break;
        v6 = v13 + 1;
        v17 = v13[1];
        if (!v17)
          goto LABEL_44;
      }
LABEL_45:
      v11 = v6;
      goto LABEL_22;
    }
    goto LABEL_43;
  }
  if (v7 >= a3)
    return result;
  v11 = (uint64_t **)(a2 + 1);
  v12 = (uint64_t *)a2[1];
  if (v12)
  {
    do
    {
      v11 = (uint64_t **)v12;
      v12 = (uint64_t *)*v12;
      v13 = v11;
      v14 = v11;
    }
    while (v12);
  }
  else
  {
    v14 = (uint64_t **)a2;
    do
    {
      v19 = (uint64_t *)v14;
      v14 = (uint64_t **)v14[2];
    }
    while (*v14 != v19);
    v13 = (uint64_t **)a2;
  }
  if (v14 != v6 && *((_DWORD *)v14 + 7) <= a3)
  {
    v20 = *v6;
    if (*v6)
    {
      while (1)
      {
        while (1)
        {
          v13 = (uint64_t **)v20;
          v21 = *((_DWORD *)v20 + 7);
          if (v21 <= a3)
            break;
          v20 = *v13;
          v6 = v13;
          if (!*v13)
            goto LABEL_44;
        }
        if (v21 >= a3)
          goto LABEL_45;
        v6 = v13 + 1;
        v20 = v13[1];
        if (!v20)
          goto LABEL_44;
      }
    }
LABEL_43:
    v13 = (uint64_t **)(result + 1);
    goto LABEL_44;
  }
LABEL_22:
  v6 = v11;
  if (!*v11)
  {
LABEL_44:
    v22 = (char *)operator new(0xB8uLL);
    v23 = *(_OWORD *)(a4 + 112);
    *(_OWORD *)(v22 + 124) = *(_OWORD *)(a4 + 96);
    *(_OWORD *)(v22 + 140) = v23;
    *(_OWORD *)(v22 + 156) = *(_OWORD *)(a4 + 128);
    v24 = *(_OWORD *)(a4 + 48);
    *(_OWORD *)(v22 + 60) = *(_OWORD *)(a4 + 32);
    *(_OWORD *)(v22 + 76) = v24;
    v25 = *(_OWORD *)(a4 + 80);
    *(_OWORD *)(v22 + 92) = *(_OWORD *)(a4 + 64);
    *(_OWORD *)(v22 + 108) = v25;
    v26 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)(v22 + 28) = *(_OWORD *)a4;
    *(_QWORD *)(v22 + 172) = *(_QWORD *)(a4 + 144);
    *(_OWORD *)(v22 + 44) = v26;
    return std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(v5, (uint64_t)v13, v6, (uint64_t *)v22);
  }
  return result;
}

uint64_t Beamformer_BeamNF::CmhBEAMprocOpt::process(Beamformer_BeamNF::CmhBEAMprocOpt *this, float **a2, float **a3, float **a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v12;
  int v13;
  float *v14;
  float v15;
  int v16;
  float *v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t i;
  int v32;
  const float *v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  _DWORD *v37;
  uint64_t v38;
  float *v39;
  float *v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t j;
  int v47;
  const float *v48;
  float *v49;
  float *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _DWORD v54[2];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)this)
    return 1;
  if (*((_DWORD *)this + 30) == 1)
  {
    if (*((int *)this + 14) >= 1)
    {
      v7 = 0;
      v8 = 0;
      do
      {
        LPFilterBank::Analysis((Beamformer_BeamNF::CmhBEAMprocOpt *)((char *)this + 1424), v8, a2[v8], (DSPSplitComplex *)(*((_QWORD *)this + 19) + v7));
        ++v8;
        v7 += 16;
      }
      while (v8 < *((int *)this + 14));
    }
    if (*((_DWORD *)this + 3) == 2)
    {
      v9 = 0;
      v10 = 0;
      do
      {
        memcpy(*(void **)(*((_QWORD *)this + 18) + v9), *(const void **)(*((_QWORD *)this + 19) + v9), 4 * *((int *)this + 5));
        ++v10;
        v9 += 16;
      }
      while (v10 < *((int *)this + 3));
    }
    else
    {
      memcpy(**((void ***)this + 18), *(const void **)(*((_QWORD *)this + 19) + 16 * *((int *)this + 1)), 4 * *((int *)this + 5));
    }
    goto LABEL_61;
  }
  v12 = *((_DWORD *)this + 7);
  if (v12 >= 1)
  {
    v13 = 0;
    v14 = *a2;
    do
    {
      v15 = (float)(*((float *)this + 21) * (float)(*v14 - *((float *)this + 16)))
          + (float)(*((float *)this + 20) * *((float *)this + 17));
      *((float *)this + 17) = v15;
      *((float *)this + 16) = *v14;
      *v14++ = v15;
      ++v13;
    }
    while (v12 > (unsigned __int16)v13);
    v16 = 0;
    v17 = a2[1];
    do
    {
      v18 = (float)(*((float *)this + 21) * (float)(*v17 - *((float *)this + 18)))
          + (float)(*((float *)this + 20) * *((float *)this + 19));
      *((float *)this + 19) = v18;
      *((float *)this + 18) = *v17;
      *v17++ = v18;
      ++v16;
    }
    while (v12 > (unsigned __int16)v16);
  }
  if (*((int *)this + 14) >= 1)
  {
    v19 = 0;
    v20 = 0;
    do
    {
      LPFilterBank::Analysis((Beamformer_BeamNF::CmhBEAMprocOpt *)((char *)this + 1424), v20, a2[v20], (DSPSplitComplex *)(*((_QWORD *)this + 19) + v19));
      ++v20;
      v19 += 16;
    }
    while (v20 < *((int *)this + 14));
  }
  Beamformer_BeamNF::CmhBEAM2NOpt::process((Beamformer_BeamNF::CmhBEAMprocOpt *)((char *)this + 184), *((const DSPSplitComplex **)this + 19), *((DSPSplitComplex **)this + 18));
  v21 = (*((_DWORD *)this + 273) + *((_DWORD *)this + 279));
  v22 = *((_QWORD *)this + 137);
  if ((int)v21 < 1)
  {
    v25 = 0;
  }
  else
  {
    v23 = 0;
    v24 = 0;
    do
    {
      if (*(_DWORD *)(v22 + 4 * v23) == 1)
        v24 = v23;
      ++v23;
    }
    while (v21 != v23);
    v25 = v24;
  }
  if (*(_DWORD *)(v22 + 4 * v25))
  {
    if (*((int *)this + 3) >= 1)
    {
      v26 = 0;
      v27 = 0;
      do
      {
        vDSP_ztoc((const DSPSplitComplex *)(*((_QWORD *)this + 18) + v26), 1, *(DSPComplex **)(*((_QWORD *)this + 16) + 8 * v27++), 2, (uint64_t)(*((_DWORD *)this + 5) + (*((int *)this + 5) < 0)) >> 1);
        v26 += 16;
      }
      while (v27 < *((int *)this + 3));
    }
    Cns::process((uint64_t)this + 1088, *((float ***)this + 16));
    if (*((int *)this + 3) >= 1)
    {
      v28 = 0;
      v29 = 0;
      do
      {
        vDSP_ctoz(*(const DSPComplex **)(*((_QWORD *)this + 16) + 8 * v29++), 2, (const DSPSplitComplex *)(*((_QWORD *)this + 18) + v28), 1, (uint64_t)(*((_DWORD *)this + 5) + (*((int *)this + 5) < 0)) >> 1);
        v28 += 16;
      }
      while (v29 < *((int *)this + 3));
    }
  }
  if (*((_DWORD *)this + 2))
  {
    Beamformer_BeamNF::CmhBEAMprocOpt::post_res_ns_proc(this);
    *((_DWORD *)this + 76) = *((_DWORD *)this + 23);
  }
  else
  {
    v30 = *((_DWORD *)this + 3);
    if (v30 >= 1)
    {
      for (i = 0; i < v30; ++i)
      {
        v32 = *((_DWORD *)this + 279) + *((_DWORD *)this + 273) - 1;
        if (v32 >= (int)i)
          v32 = i;
        if (*(_DWORD *)(*((_QWORD *)this + 137) + 4 * v32))
        {
          v33 = (const float *)*((_QWORD *)this + 22);
          v34 = *((unsigned int *)this + 280);
          if ((int)v34 >= 1)
          {
            v35 = *(_QWORD *)(*((_QWORD *)this + 177) + 112 * (int)i + 16);
            v36 = (int *)*((_QWORD *)this + 165);
            v37 = (_DWORD *)*((_QWORD *)this + 22);
            do
            {
              v38 = *v36++;
              *v37++ = *(_DWORD *)(v35 + 4 * v38);
              --v34;
            }
            while (v34);
          }
          v39 = (float *)(*(_QWORD *)(*((_QWORD *)this + 18) + 16 * i) + 4);
          vDSP_vmul(v39, 1, v33, 1, v39, 1, *((int *)this + 12));
          v40 = (float *)(*(_QWORD *)(*((_QWORD *)this + 18) + 16 * i + 8) + 4);
          vDSP_vmul(v40, 1, v33, 1, v40, 1, *((int *)this + 12));
          v30 = *((_DWORD *)this + 3);
        }
      }
    }
  }
  if (*((_DWORD *)this + 77))
    goto LABEL_61;
  v41 = *((_DWORD *)this + 48);
  if (v41 >= 1)
    v42 = 1;
  else
    v42 = *((_DWORD *)this + 48);
  v43 = *((_QWORD *)this + 78);
  v54[0] = *(_DWORD *)(v43 + 136 * v42 - 28);
  v44 = *((_DWORD *)this + 3);
  if (v44 == 2)
  {
    if (v41 >= 2)
      v41 = 2;
    v54[1] = *(_DWORD *)(v43 + 136 * v41 - 28);
    goto LABEL_55;
  }
  if (v44 >= 1)
  {
LABEL_55:
    v45 = 0;
    for (j = 0; j < v44; ++j)
    {
      if (v54[j] == 1)
      {
        v47 = *((_DWORD *)this + 48) - 1;
        if (v47 >= (int)j)
          v47 = j;
        v48 = *(const float **)(*((_QWORD *)this + 78) + 136 * v47 + 120);
        v49 = (float *)(*(_QWORD *)(*((_QWORD *)this + 18) + v45) + 4);
        vDSP_vmul(v49, 1, v48, 1, v49, 1, *((int *)this + 12));
        v50 = (float *)(*(_QWORD *)(*((_QWORD *)this + 18) + v45 + 8) + 4);
        vDSP_vmul(v50, 1, v48, 1, v50, 1, *((int *)this + 12));
        v44 = *((_DWORD *)this + 3);
      }
      v45 += 16;
    }
  }
LABEL_61:
  if (*((int *)this + 3) >= 1)
  {
    v51 = 0;
    v52 = 0;
    do
    {
      v53 = *((_QWORD *)this + 18) + v51;
      **(_DWORD **)(v53 + 8) = 0;
      **(_DWORD **)v53 = 0;
      LPFilterBank::Synthesis((Beamformer_BeamNF::CmhBEAMprocOpt *)((char *)this + 1424), v52, (const DSPSplitComplex *)v53, a3[v52]);
      ++v52;
      v51 += 16;
    }
    while (v52 < *((int *)this + 3));
  }
  return 0;
}

void Beamformer_BeamNF::CmhBEAMprocOpt::post_res_ns_proc(Beamformer_BeamNF::CmhBEAMprocOpt *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  DSPSplitComplex __Z;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v2 = (*((_DWORD *)this + 273) + *((_DWORD *)this + 279));
  v3 = *((_QWORD *)this + 137);
  if ((int)v2 < 1)
  {
    v6 = 0;
  }
  else
  {
    v4 = 0;
    v5 = 0;
    do
    {
      if (*(_DWORD *)(v3 + 4 * v4) == 1)
        v5 = v4;
      ++v4;
    }
    while (v2 != v4);
    v6 = v5;
  }
  v7 = *((_QWORD *)this + 14);
  if (*(_DWORD *)(v3 + 4 * v6))
  {
    Cns::comf_noise(*(float **)v7, (float *)*((unsigned int *)this + 5));
    v7 = *((_QWORD *)this + 14);
  }
  else
  {
    v8 = *((unsigned int *)this + 5);
    if ((int)v8 >= 1)
      bzero(*(void **)v7, 4 * v8);
  }
  v9 = *((unsigned int *)this + 12);
  if ((int)v9 >= 1)
    memset_pattern16(*(void **)(v7 + 8), &unk_1B6627B80, 4 * v9);
  if (*((int *)this + 3) >= 1)
  {
    v10 = 0;
    do
    {
      v11 = *((_DWORD *)this + 279) + *((_DWORD *)this + 273) - 1;
      if (v11 >= (int)v10)
        v11 = v10;
      v12 = (float *)*((_QWORD *)this + 22);
      if (*(_DWORD *)(*((_QWORD *)this + 137) + 4 * v11) == 1)
      {
        v13 = *((unsigned int *)this + 280);
        if ((int)v13 >= 1)
        {
          v14 = *(_QWORD *)(*((_QWORD *)this + 177) + 112 * (int)v10 + 16);
          v15 = (int *)*((_QWORD *)this + 165);
          v16 = (_DWORD *)*((_QWORD *)this + 22);
          do
          {
            v17 = *v15++;
            *v16++ = *(_DWORD *)(v14 + 4 * v17);
            --v13;
          }
          while (v13);
        }
        LODWORD(v18) = *((_DWORD *)this + 12);
      }
      else
      {
        v18 = *((unsigned int *)this + 12);
        if ((int)v18 >= 1)
          memset_pattern16(*((void **)this + 22), &unk_1B6627B80, 4 * v18);
      }
      vDSP_vmul(v12, 1, *(const float **)(*((_QWORD *)this + 14) + 8), 1, v12, 1, (int)v18);
      v19 = (float *)(*(_QWORD *)(*((_QWORD *)this + 18) + 16 * v10) + 4);
      vDSP_vmul(v19, 1, v12, 1, v19, 1, *((int *)this + 12));
      v20 = (float *)(*(_QWORD *)(*((_QWORD *)this + 18) + 16 * v10 + 8) + 4);
      vDSP_vmul(v20, 1, v12, 1, v20, 1, *((int *)this + 12));
      MEMORY[0x1E0C80A78](v21);
      v22 = *((int *)this + 5);
      __Z.realp = (float *)((char *)&v25 - v23);
      __Z.imagp = (float *)((char *)&v25 + 4 * v22 - v23);
      if ((int)v22 >= 0)
        v24 = v22;
      else
        v24 = v22 + 1;
      vDSP_ctoz(**((const DSPComplex ***)this + 14), 2, &__Z, 1, (uint64_t)v24 >> 1);
      Cns::add_comf_noise((uint64_t)this + 1088, *(DSPSplitComplex **)(*((_QWORD *)this + 18) + 16 * v10), *(const DSPSplitComplex **)(*((_QWORD *)this + 18) + 16 * v10 + 8), __Z.realp, __Z.imagp, v12, v10);
      ++v10;
    }
    while (v10 < *((int *)this + 3));
  }
}

void InverseWithGramSchmidt::cleanup(InverseWithGramSchmidt *this)
{
  *((_DWORD *)this + 12) = *(_DWORD *)this;
  vec::fill<BOOL>(*((_QWORD *)this + 7), *((_QWORD *)this + 8), 0);
  vec::fill<float>(*((_QWORD *)this + 10), *((_QWORD *)this + 11), (_DWORD *)this + 4);
  vec::cleanup<float>((uint64_t *)this + 13);
  vec::cleanup<float>((uint64_t *)this + 16);
  bzero(*((void **)this + 22), *((_QWORD *)this + 23) - *((_QWORD *)this + 22));
  bzero(*((void **)this + 25), *((_QWORD *)this + 26) - *((_QWORD *)this + 25));
  bzero(*((void **)this + 31), *((_QWORD *)this + 32) - *((_QWORD *)this + 31));
  bzero(*((void **)this + 34), *((_QWORD *)this + 35) - *((_QWORD *)this + 34));
  bzero(*((void **)this + 37), *((_QWORD *)this + 38) - *((_QWORD *)this + 37));
  bzero(*((void **)this + 40), *((_QWORD *)this + 41) - *((_QWORD *)this + 40));
  bzero(*((void **)this + 43), *((_QWORD *)this + 44) - *((_QWORD *)this + 43));
}

os_log_t ___Z19getMatrixUtilityLogv_block_invoke_24325()
{
  os_log_t result;

  result = os_log_create("com.apple.coreaudio", "AudioDSPMatrixUtility");
  getMatrixUtilityLog(void)::gLog = (uint64_t)result;
  return result;
}

void InverseWithGramSchmidt::update_InvR(unsigned int *a1, const void **a2, float a3, float a4)
{
  unint64_t v6;
  unint64_t v7;
  const float *v8;
  uint64_t v9;
  const float *v10;
  uint64_t v11;
  unint64_t v12;
  float *v13;
  float *v14;
  float *v15;
  const float *v16;
  const float *v17;
  uint64_t v18;
  unint64_t v19;
  float32x4_t **__N;
  float __B;
  float v22;

  __B = a4;
  v22 = a3;
  memcpy(*((void **)a1 + 22), *a2, 4 * a1[2]);
  memcpy(*((void **)a1 + 25), (char *)*a2 + 4 * a1[2], 4 * a1[2]);
  vDSP_vfill(&InverseWithGramSchmidt::mOne, *((float **)a1 + 34), 1, a1[1]);
  v6 = *a1;
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = (const float *)(a1 + 5);
    v9 = 16;
    v10 = &InverseWithGramSchmidt::mOne;
    v11 = 1;
    do
    {
      if (((*(_QWORD *)(*((_QWORD *)a1 + 7) + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7) & 1) != 0)
      {
        v12 = v7 + 1;
      }
      else
      {
        vDSP_zvmags((const DSPSplitComplex *)(*((_QWORD *)a1 + 28) + 16 * v7), 1, *((float **)a1 + 31), 1, a1[1]);
        vDSP_vsmul(*((const float **)a1 + 34), 1, &__B, *((float **)a1 + 37), 1, a1[1]);
        v13 = *(float **)(*((_QWORD *)a1 + 10) + 24 * v7);
        vDSP_vsmul(v13, 1, &v22, v13, 1, a1[1]);
        v14 = *(float **)(*((_QWORD *)a1 + 10) + 24 * v7);
        vDSP_vma(*((const float **)a1 + 37), 1, *((const float **)a1 + 31), 1, v14, 1, v14, 1, a1[1]);
        v15 = *(float **)(*((_QWORD *)a1 + 10) + 24 * v7);
        vDSP_vthr(v15, 1, v8, v15, 1, a1[1]);
        vDSP_vneg(*((const float **)a1 + 37), 1, *((float **)a1 + 37), 1, a1[1]);
        vDSP_vdiv(*(const float **)(*((_QWORD *)a1 + 10) + 24 * v7), 1, *((const float **)a1 + 37), 1, *((float **)a1 + 37), 1, a1[1]);
        vDSP_zrvmul((const DSPSplitComplex *)(*((_QWORD *)a1 + 28) + 16 * v7), 1, *((const float **)a1 + 37), 1, (const DSPSplitComplex *)a1 + 23, 1, a1[1]);
        vDSP_zvconj((const DSPSplitComplex *)a1 + 23, 1, (const DSPSplitComplex *)a1 + 23, 1, a1[1]);
        vDSP_vmul(*((const float **)a1 + 37), 1, *((const float **)a1 + 31), 1, *((float **)a1 + 37), 1, a1[1]);
        vDSP_vsadd(*((const float **)a1 + 37), 1, v10, *((float **)a1 + 37), 1, a1[1]);
        vDSP_vthr(*((const float **)a1 + 37), 1, &InverseWithGramSchmidt::mZero, *((float **)a1 + 37), 1, a1[1]);
        vDSP_vmul(*((const float **)a1 + 34), 1, *((const float **)a1 + 37), 1, *((float **)a1 + 34), 1, a1[1]);
        v12 = v7 + 1;
        v6 = *a1;
        if (v7 + 1 < v6)
        {
          v16 = v10;
          v17 = v8;
          v18 = v9;
          v19 = v11;
          do
          {
            if (((*(_QWORD *)(*((_QWORD *)a1 + 7) + ((v19 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v19) & 1) == 0)
            {
              __N = (float32x4_t **)(*(_QWORD *)(*((_QWORD *)a1 + 19) + 24 * v7) + v18);
              aDSP_zvmama((float32x4_t *)(*((_QWORD *)a1 + 28) + 16 * v7), 1, __N, 1, (float32x4_t **)(*((_QWORD *)a1 + 28) + v18), 1, (float32x4_t **)a1 + 46, 1, __N, 1, a1[1]);
              v6 = *a1;
            }
            ++v19;
            v18 += 16;
          }
          while (v19 < v6);
          v8 = v17;
          v10 = v16;
        }
      }
      ++v11;
      v9 += 16;
      v7 = v12;
    }
    while (v12 < v6);
  }
}

void AUSilenceNonFiniteAnalyzer::~AUSilenceNonFiniteAnalyzer(AUSilenceNonFiniteAnalyzer *this)
{
  *(_QWORD *)this = &off_1E69ED018;
  ausdk::AUBase::~AUBase(this);
}

{
  *(_QWORD *)this = &off_1E69ED018;
  ausdk::AUBase::~AUBase(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AUSilenceNonFiniteAnalyzer::Initialize(AUSilenceNonFiniteAnalyzer *this)
{
  uint64_t Element;
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  const AudioStreamBasicDescription *v6;
  __int128 v7;
  NSObject *v9;
  AudioStreamBasicDescription v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  Element = ausdk::AUScope::SafeGetElement((AUSilenceNonFiniteAnalyzer *)((char *)this + 80), 0);
  v3 = *(_OWORD *)(Element + 96);
  v11 = *(_OWORD *)(Element + 80);
  v12 = v3;
  v13 = *(_QWORD *)(Element + 112);
  v4 = ausdk::AUScope::SafeGetElement((AUSilenceNonFiniteAnalyzer *)((char *)this + 128), 0);
  v5 = *(_OWORD *)(v4 + 96);
  *(_OWORD *)&v10.mSampleRate = *(_OWORD *)(v4 + 80);
  *(_OWORD *)&v10.mBytesPerPacket = v5;
  *(_QWORD *)&v10.mBitsPerChannel = *(_QWORD *)(v4 + 112);
  if (CAStreamBasicDescription::IsEquivalent((CAStreamBasicDescription *)&v11, &v10, v6))
  {
    *((_QWORD *)this + 75) = v13;
    v7 = v12;
    *(_OWORD *)((char *)this + 568) = v11;
    *(_OWORD *)((char *)this + 584) = v7;
    return (*(uint64_t (**)(AUSilenceNonFiniteAnalyzer *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
  }
  if (AUSilenceNonFiniteAnalyzerLogScope(void)::once != -1)
    dispatch_once(&AUSilenceNonFiniteAnalyzerLogScope(void)::once, &__block_literal_global_24352);
  if (!AUSilenceNonFiniteAnalyzerLogScope(void)::scope)
  {
    v9 = MEMORY[0x1E0C81028];
LABEL_9:
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315394;
      v15 = "AUSilenceNonFiniteAnalyzer.cpp";
      v16 = 1024;
      v17 = 120;
      _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d Can't handle different in/out formats\n", buf, 0x12u);
    }
    return 4294956428;
  }
  v9 = *(NSObject **)AUSilenceNonFiniteAnalyzerLogScope(void)::scope;
  if (*(_QWORD *)AUSilenceNonFiniteAnalyzerLogScope(void)::scope)
    goto LABEL_9;
  return 4294956428;
}

uint64_t AUSilenceNonFiniteAnalyzer::Reset(AUSilenceNonFiniteAnalyzer *this)
{
  unsigned int *v2;
  uint64_t v3;
  ausdk::AUElement *v4;
  float v5;
  ausdk::AUElement **v6;
  uint64_t v7;
  ausdk::AUElement *v8;
  ausdk::AUElement **v9;
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;

  v2 = (unsigned int *)((char *)this + 536);
  *(_OWORD *)((char *)this + 536) = 0u;
  *((_QWORD *)this + 69) = 0xBF80000000000000;
  *((_QWORD *)this + 70) = 0;
  *((_BYTE *)this + 530) = 1;
  v3 = *((_QWORD *)this + 9);
  if (v3)
  {
    v4 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 32))(v3, 0);
    v5 = (float)*v2;
  }
  else
  {
    v6 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    v5 = 0.0;
    if (*((ausdk::AUElement ***)this + 7) == v6)
      v4 = 0;
    else
      v4 = *v6;
  }
  ausdk::AUElement::SetParameter(v4, 0, v5, 0);
  v7 = *((_QWORD *)this + 9);
  if (v7)
  {
    v8 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
  }
  else
  {
    v9 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v9)
      v8 = 0;
    else
      v8 = *v9;
  }
  ausdk::AUElement::SetParameter(v8, 1u, (float)*((unsigned int *)this + 135), 0);
  v10 = *((_QWORD *)this + 9);
  if (v10)
  {
    v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
  }
  else
  {
    v12 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v12)
      v11 = 0;
    else
      v11 = *v12;
  }
  ausdk::AUElement::SetParameter(v11, 2u, (float)*((unsigned int *)this + 136), 0);
  v13 = *((_QWORD *)this + 9);
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  }
  else
  {
    v15 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v15)
      v14 = 0;
    else
      v14 = *v15;
  }
  ausdk::AUElement::SetParameter(v14, 3u, (float)*((unsigned int *)this + 137), 0);
  v16 = *((_QWORD *)this + 9);
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  ausdk::AUElement::SetParameter(v17, 4u, (float)*((unsigned int *)this + 140), 0);
  v19 = *((_QWORD *)this + 9);
  if (v19)
  {
    v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
  }
  else
  {
    v21 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v21)
      v20 = 0;
    else
      v20 = *v21;
  }
  ausdk::AUElement::SetParameter(v20, 5u, (float)*((unsigned int *)this + 141), 0);
  v22 = *((_QWORD *)this + 9);
  if (v22)
  {
    v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
  }
  else
  {
    v24 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v24)
      v23 = 0;
    else
      v23 = *v24;
  }
  ausdk::AUElement::SetParameter(v23, 6u, *((float *)this + 139), 0);
  return 0;
}

uint64_t AUSilenceNonFiniteAnalyzer::GetPropertyInfo(AUSilenceNonFiniteAnalyzer *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;

  if (a3)
    return 4294956417;
  if ((a2 - 64001) >= 3 && a2 != 21)
    return 4294956417;
  result = 0;
  *a6 = 1;
  *a5 = 4;
  return result;
}

uint64_t AUSilenceNonFiniteAnalyzer::GetProperty(AUSilenceNonFiniteAnalyzer *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  unsigned __int8 *v7;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 64001)
  {
    if (a2 == 64002)
    {
      v7 = (unsigned __int8 *)this + 532;
    }
    else
    {
      if (a2 != 64003)
        return result;
      v7 = (unsigned __int8 *)this + 534;
    }
  }
  else if (a2 == 21)
  {
    v7 = (unsigned __int8 *)this + 528;
  }
  else
  {
    if (a2 != 64001)
      return result;
    v7 = (unsigned __int8 *)this + 529;
  }
  result = 0;
  *a5 = *v7;
  return result;
}

uint64_t AUSilenceNonFiniteAnalyzer::SetProperty(AUSilenceNonFiniteAnalyzer *this, int a2, int a3, unsigned int a4, int *a5, unsigned int a6)
{
  uint64_t result;
  int v8;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 64001)
  {
    if (a2 != 64002)
    {
      if (a2 == 64003)
      {
        if (a6 >= 4)
        {
          result = 0;
          *((_BYTE *)this + 534) = *a5 != 0;
          return result;
        }
        return 4294956445;
      }
      return result;
    }
    if (a6 >= 4)
    {
      result = 0;
      *((_BYTE *)this + 532) = *a5 != 0;
      return result;
    }
    return 4294956445;
  }
  if (a2 == 21)
  {
    if (a6 >= 4)
    {
      v8 = *a5;
      *((_BYTE *)this + 528) = *a5 != 0;
      if (v8)
        (*(void (**)(AUSilenceNonFiniteAnalyzer *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
      return 0;
    }
    return 4294956445;
  }
  if (a2 == 64001)
  {
    if (a6 >= 4)
    {
      result = 0;
      *((_BYTE *)this + 529) = *a5 != 0;
      return result;
    }
    return 4294956445;
  }
  return result;
}

uint64_t AUSilenceNonFiniteAnalyzer::SetParameter(AUSilenceNonFiniteAnalyzer *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  switch(a2)
  {
    case 0u:
      *((_DWORD *)this + 134) = a5;
      break;
    case 1u:
      *((_DWORD *)this + 135) = a5;
      break;
    case 2u:
      *((_DWORD *)this + 136) = a5;
      break;
    case 3u:
      *((_DWORD *)this + 137) = a5;
      if (a5 == 0.0)
        *((_DWORD *)this + 138) = 0;
      break;
    case 4u:
      *((_DWORD *)this + 140) = a5;
      break;
    case 5u:
      *((_DWORD *)this + 141) = a5;
      break;
    case 6u:
      *((float *)this + 139) = a5;
      break;
    default:
      return 0;
  }
  return 0;
}

uint64_t AUSilenceNonFiniteAnalyzer::CanScheduleParameters(AUSilenceNonFiniteAnalyzer *this)
{
  return 0;
}

uint64_t AUSilenceNonFiniteAnalyzer::ProcessBufferLists(AUSilenceNonFiniteAnalyzer *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, unsigned int a5, __n128 a6)
{
  uint64_t result;
  unint64_t mNumberBuffers;
  uint64_t v12;
  unint64_t v13;
  size_t mDataByteSize;
  void *mData;
  void *v16;
  char v17;
  unint64_t v18;
  void **p_mData;
  const float *v20;
  vDSP_Length v21;
  int v22;
  int v23;
  uint64_t v24;
  char v25;
  char v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int32 *v30;
  unsigned __int32 *v31;
  unsigned int v32;
  char v33;
  unsigned int v34;
  uint64_t v35;
  ausdk::AUElement *v36;
  ausdk::AUElement **v37;
  unint64_t v38;
  unint64_t v39;
  BOOL v40;
  char *v41;
  uint64_t v42;
  unsigned __int32 *v43;
  char v44;
  unsigned int v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  int v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  BOOL v52;
  char *v53;
  uint64_t v54;
  unsigned __int32 *v55;
  unsigned int v56;
  double v57;
  unsigned int v58;
  double v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  AudioBuffer *mBuffers;
  uint64_t v64;
  ausdk::AUElement **v65;
  unsigned int v66;
  uint64_t v67;
  ausdk::AUElement *v68;
  ausdk::AUElement **v69;
  unint64_t v70;
  unint64_t v71;
  AudioBuffer *v72;
  uint64_t v73;
  unsigned int v74;
  unint64_t v75;
  uint64_t v76;
  BOOL v77;
  char *v78;
  uint64_t v79;
  float *v80;
  double v81;
  unsigned int v82;
  uint64_t v83;
  ausdk::AUElement *v84;
  ausdk::AUElement **v85;
  uint64_t v86;
  ausdk::AUElement *v87;
  ausdk::AUElement **v88;
  uint64_t v89;
  ausdk::AUElement *v90;
  ausdk::AUElement **v91;
  uint64_t v92;
  ausdk::AUElement *v93;
  ausdk::AUElement **v94;
  float __C;

  if (*((_DWORD *)this + 84) < a5)
    return 4294956422;
  mNumberBuffers = a3->mNumberBuffers;
  if (mNumberBuffers == a4->mNumberBuffers)
  {
    if (!a3->mNumberBuffers)
    {
      result = 0;
      if (*((_BYTE *)this + 528))
        return result;
      mNumberBuffers = 0;
      goto LABEL_22;
    }
    v12 = 0;
    v13 = 0;
    do
    {
      mDataByteSize = a3->mBuffers[v12].mDataByteSize;
      if ((_DWORD)mDataByteSize == a4->mBuffers[v12].mDataByteSize)
      {
        mData = a3->mBuffers[v12].mData;
        v16 = a4->mBuffers[v12].mData;
        if (mData != v16)
        {
          memcpy(v16, mData, mDataByteSize);
          mNumberBuffers = a3->mNumberBuffers;
        }
      }
      ++v13;
      ++v12;
    }
    while (v13 < mNumberBuffers);
  }
  if (*((_BYTE *)this + 528))
    return 0;
  if (!mNumberBuffers)
  {
LABEL_22:
    v17 = 0;
    goto LABEL_23;
  }
  v17 = 0;
  v18 = 0;
  p_mData = &a3->mBuffers[0].mData;
  do
  {
    if ((*((_BYTE *)this + 576) & 1) == 0)
      break;
    if (*((_DWORD *)this + 150) != 32)
      break;
    v20 = (const float *)*p_mData;
    if (!*p_mData)
      break;
    v21 = (unint64_t)*((unsigned int *)p_mData - 1) >> 2;
    __C = 0.0;
    vDSP_sve(v20, 1, &__C, v21);
    a6.n128_u32[0] = 2139095040;
    if (fabsf(__C) == INFINITY)
      v17 = 1;
    ++v18;
    mNumberBuffers = a3->mNumberBuffers;
    p_mData += 2;
  }
  while (v18 < mNumberBuffers);
LABEL_23:
  v22 = 0;
  v23 = 1;
  if (a5 && !*((_BYTE *)this + 529))
  {
    if (mNumberBuffers)
    {
      v24 = 0;
      v25 = 0;
      v26 = 1;
      do
      {
        v27 = (char *)a3 + 16 * v24;
        v28 = *((unsigned int *)v27 + 2);
        if ((_DWORD)v28)
        {
          v29 = 0;
          v30 = (unsigned __int32 *)*((_QWORD *)v27 + 2);
          do
          {
            v31 = v30;
            v32 = a5;
            while (1)
            {
              a6.n128_u32[0] = *v31;
              if (*(float *)v31 != 0.0)
                break;
              v31 += v28;
              if (!--v32)
              {
                v33 = 1;
                goto LABEL_34;
              }
            }
            v33 = 0;
LABEL_34:
            v25 = v33 | v25 & 1;
            v26 &= v33;
            ++v29;
            ++v30;
          }
          while (v29 != v28);
        }
        ++v24;
      }
      while (v24 != mNumberBuffers);
    }
    else
    {
      v25 = 0;
      v26 = 1;
    }
    v23 = v26 & 1;
    v22 = v25 & 1;
  }
  if (v17)
  {
    v34 = *((_DWORD *)this + 141) + 1;
    *((_DWORD *)this + 141) = v34;
    v35 = *((_QWORD *)this + 9);
    if (v35)
    {
      v36 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 32))(v35, 0);
      v34 = *((_DWORD *)this + 141);
    }
    else
    {
      v37 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v37)
        v36 = 0;
      else
        v36 = *v37;
    }
    ausdk::AUElement::SetParameter(v36, 5u, (float)v34, 0);
  }
  if (*((_BYTE *)this + 529))
    return 0;
  if (*((_BYTE *)this + 530))
  {
    if ((v23 & 1) != 0 || (v38 = a3->mNumberBuffers, !(_DWORD)v38))
    {
      v44 = 1;
    }
    else
    {
      v39 = 0;
      v40 = 0;
      while (1)
      {
        v41 = (char *)a3 + 16 * v39;
        v42 = *((unsigned int *)v41 + 2);
        if ((_DWORD)v42)
          break;
LABEL_55:
        ++v39;
        v44 = 1;
        v40 = v39 >= v38;
        if (v39 == v38)
          goto LABEL_59;
      }
      v43 = (unsigned __int32 *)*((_QWORD *)v41 + 2);
      while (1)
      {
        a6.n128_u32[0] = *v43;
        if (*(float *)v43 != 0.0)
          break;
        ++v43;
        if (!--v42)
          goto LABEL_55;
      }
      v44 = v40;
    }
LABEL_59:
    *((_BYTE *)this + 531) = v44 & 1;
    *((_BYTE *)this + 533) = *((_BYTE *)this + 532);
    *((_BYTE *)this + 530) = 0;
  }
  if (v23)
  {
    *((_DWORD *)this + 134) += a5;
    if (*((_BYTE *)this + 531))
    {
      v45 = *((_DWORD *)this + 136) + a5;
      *((_DWORD *)this + 136) = v45;
      v46 = *((_QWORD *)this + 9);
      if (v46)
      {
        v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 0);
        v45 = *((_DWORD *)this + 136);
      }
      else
      {
        v65 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v65)
          v47 = 0;
        else
          v47 = *v65;
      }
      ausdk::AUElement::SetParameter(v47, 2u, (float)v45, 0);
    }
    else if (!*((_BYTE *)this + 533))
    {
      v58 = *((_DWORD *)this + 138) + a5;
      *((_DWORD *)this + 138) = v58;
      if (v58 > *((_DWORD *)this + 137))
      {
        v59 = *((double *)this + 34);
        *((_DWORD *)this + 137) = v58;
        *((float *)this + 139) = (float)v59;
      }
    }
    goto LABEL_136;
  }
  v48 = *((unsigned __int8 *)this + 534);
  *((_DWORD *)this + 134) = 0;
  if (!v48)
  {
    *((_DWORD *)this + 138) = 0;
    *((_BYTE *)this + 531) = 0;
    if (!*((_BYTE *)this + 533) || !a5)
      goto LABEL_136;
    v60 = 0;
    v61 = a3->mNumberBuffers;
    while (1)
    {
      if ((_DWORD)v61)
      {
        if (fabsf(*((float *)a3->mBuffers[0].mData + v60)) >= 0.0001)
          break;
        v62 = 0;
        mBuffers = a3[1].mBuffers;
        do
        {
          if (v61 - 1 == v62)
            goto LABEL_95;
          v64 = *(_QWORD *)&mBuffers->mNumberChannels;
          ++mBuffers;
          ++v62;
        }
        while (fabsf(*(float *)(v64 + 4 * v60)) < 0.0001);
        if (v62 < v61)
          break;
      }
LABEL_95:
      if (++v60 == a5)
        goto LABEL_136;
    }
    *((_BYTE *)this + 533) = 0;
    goto LABEL_136;
  }
  LODWORD(v49) = 0;
  if (a5)
  {
    v50 = a3->mNumberBuffers;
    while (1)
    {
      if ((_DWORD)v50)
      {
        v51 = 0;
        v52 = 0;
        while (1)
        {
          v53 = (char *)a3 + 16 * v51;
          v54 = *((unsigned int *)v53 + 2);
          if ((_DWORD)v54)
            break;
LABEL_73:
          v52 = ++v51 >= v50;
          if (v51 == v50)
            goto LABEL_76;
        }
        v55 = (unsigned __int32 *)(*((_QWORD *)v53 + 2) + 4 * (v49 * v54));
        while (1)
        {
          a6.n128_u32[0] = *v55;
          if (*(float *)v55 != 0.0)
            break;
          ++v55;
          if (!--v54)
            goto LABEL_73;
        }
        if (!v52)
          break;
      }
LABEL_76:
      LODWORD(v49) = v49 + 1;
      if ((_DWORD)v49 == a5)
      {
        LODWORD(v49) = a5;
        break;
      }
    }
    if (!*((_BYTE *)this + 531))
    {
      if ((_DWORD)v49)
      {
        if (!*((_BYTE *)this + 533))
        {
          v56 = *((_DWORD *)this + 138) + v49;
          if (v56 > *((_DWORD *)this + 137))
          {
            v57 = *((double *)this + 34);
            *((_DWORD *)this + 137) = v56;
            *((float *)this + 139) = (float)v57;
          }
        }
      }
      goto LABEL_109;
    }
    goto LABEL_100;
  }
  if (*((_BYTE *)this + 531))
  {
LABEL_100:
    v66 = *((_DWORD *)this + 136) + v49;
    *((_DWORD *)this + 136) = v66;
    v67 = *((_QWORD *)this + 9);
    if (v67)
    {
      v68 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v67 + 32))(v67, 0, a6);
      v66 = *((_DWORD *)this + 136);
    }
    else
    {
      v69 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v69)
        v68 = 0;
      else
        v68 = *v69;
    }
    ausdk::AUElement::SetParameter(v68, 2u, (float)v66, 0);
    *((_BYTE *)this + 531) = 0;
  }
LABEL_109:
  *((_DWORD *)this + 138) = 0;
  if (!*((_BYTE *)this + 533) || v49 >= a5)
    goto LABEL_121;
  v70 = a3->mNumberBuffers;
  v49 = v49;
  while (!(_DWORD)v70)
  {
LABEL_118:
    if (++v49 == a5)
      goto LABEL_136;
  }
  if (fabsf(*((float *)a3->mBuffers[0].mData + v49)) < 0.0001)
  {
    v71 = 0;
    v72 = a3[1].mBuffers;
    while (v70 - 1 != v71)
    {
      v73 = *(_QWORD *)&v72->mNumberChannels;
      ++v72;
      ++v71;
      if (fabsf(*(float *)(v73 + 4 * v49)) >= 0.0001)
      {
        if (v71 < v70)
          goto LABEL_120;
        goto LABEL_118;
      }
    }
    goto LABEL_118;
  }
LABEL_120:
  *((_BYTE *)this + 533) = 0;
LABEL_121:
  if (v49 < a5)
  {
    v74 = 0;
    v75 = a3->mNumberBuffers;
    do
    {
      if (!(_DWORD)v75)
        goto LABEL_132;
      v76 = 0;
      v77 = 0;
      while (1)
      {
        v78 = (char *)a3 + 16 * v76;
        v79 = *((unsigned int *)v78 + 2);
        if ((_DWORD)v79)
          break;
LABEL_129:
        v77 = ++v76 >= v75;
        if (v76 == v75)
          goto LABEL_132;
      }
      v80 = (float *)(*((_QWORD *)v78 + 2) + 4 * (v49 * v79));
      while (*v80 == 0.0)
      {
        ++v80;
        if (!--v79)
          goto LABEL_129;
      }
      if (!v77)
      {
        v74 = 0;
        *((_DWORD *)this + 138) = 0;
      }
      else
      {
LABEL_132:
        *((_DWORD *)this + 138) = ++v74;
        if (v74 > *((_DWORD *)this + 137))
        {
          v81 = *((double *)this + 34) + (double)v49;
          *((_DWORD *)this + 137) = v74;
          *((float *)this + 139) = (float)v81;
        }
      }
      LODWORD(v49) = v49 + 1;
    }
    while ((_DWORD)v49 != a5);
  }
LABEL_136:
  if (v22)
    v82 = *((_DWORD *)this + 135) + a5;
  else
    v82 = 0;
  *((_DWORD *)this + 135) = v82;
  v83 = *((_QWORD *)this + 9);
  if (v83)
  {
    v84 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v83 + 32))(v83, 0);
  }
  else
  {
    v85 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v85)
      v84 = 0;
    else
      v84 = *v85;
  }
  ausdk::AUElement::SetParameter(v84, 0, (float)*((unsigned int *)this + 134), 0);
  v86 = *((_QWORD *)this + 9);
  if (v86)
  {
    v87 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v86 + 32))(v86, 0);
  }
  else
  {
    v88 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v88)
      v87 = 0;
    else
      v87 = *v88;
  }
  ausdk::AUElement::SetParameter(v87, 1u, (float)*((unsigned int *)this + 135), 0);
  v89 = *((_QWORD *)this + 9);
  if (v89)
  {
    v90 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v89 + 32))(v89, 0);
  }
  else
  {
    v91 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v91)
      v90 = 0;
    else
      v90 = *v91;
  }
  ausdk::AUElement::SetParameter(v90, 3u, (float)*((unsigned int *)this + 137), 0);
  v92 = *((_QWORD *)this + 9);
  if (v92)
  {
    v93 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v92 + 32))(v92, 0);
  }
  else
  {
    v94 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v94)
      v93 = 0;
    else
      v93 = *v94;
  }
  ausdk::AUElement::SetParameter(v93, 6u, *((float *)this + 139), 0);
  return 0;
}

uint64_t AUSilenceNonFiniteAnalyzer::Render(AUSilenceNonFiniteAnalyzer *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  uint64_t Element;
  uint64_t v10;
  ausdk::AUInputElement *v11;
  uint64_t result;
  uint64_t BufferList;
  uint64_t v14;
  unsigned int v15;

  v8 = (AUSilenceNonFiniteAnalyzer *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AUSilenceNonFiniteAnalyzer *)((char *)this + 80), 0);
  v10 = ausdk::AUScope::SafeGetElement((AUSilenceNonFiniteAnalyzer *)((char *)this + 128), 0);
  v15 = 0;
  v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  result = ausdk::AUInputElement::PullInput(v11, &v15, a3, 0, a4);
  if (!(_DWORD)result)
  {
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    v14 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    return (*(uint64_t (**)(AUSilenceNonFiniteAnalyzer *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 176))(this, a2, BufferList, v14, a4);
  }
  return result;
}

uint64_t AUSilenceNonFiniteAnalyzer::GetParameterList(AUSilenceNonFiniteAnalyzer *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;

  if (a2)
    return 4294956430;
  if (a3)
  {
    *(_OWORD *)a3 = xmmword_1B6626920;
    *((_QWORD *)a3 + 2) = 0x500000004;
    a3[6] = 6;
  }
  result = 0;
  *a4 = 7;
  return result;
}

uint64_t AUSilenceNonFiniteAnalyzer::GetParameterInfo(AUSilenceNonFiniteAnalyzer *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v6;
  AudioUnitParameterValue v7;
  AudioUnitParameterValue v8;

  buffer->flags = 0;
  buffer->unitName = 0;
  result = 4294956418;
  if (!a2 && a3 <= 6)
  {
    v6 = off_1E69ED298[a3];
    v7 = flt_1B668968C[a3];
    v8 = flt_1B66896A8[a3];
    buffer->cfNameString = v6;
    buffer->flags = 0x8000000;
    CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
    result = 0;
    buffer->unit = kAudioUnitParameterUnit_Generic;
    buffer->minValue = v7;
    buffer->maxValue = v8;
    buffer->defaultValue = v7;
    buffer->flags |= 0x40008000u;
  }
  return result;
}

double AUSilenceNonFiniteAnalyzer::GetLatency(AUSilenceNonFiniteAnalyzer *this)
{
  return 0.0;
}

double AUSilenceNonFiniteAnalyzer::GetTailTime(AUSilenceNonFiniteAnalyzer *this)
{
  return 0.0;
}

uint64_t AUSilenceNonFiniteAnalyzer::SupportsTail(AUSilenceNonFiniteAnalyzer *this)
{
  return 1;
}

BOOL AUSilenceNonFiniteAnalyzer::StreamFormatWritable(AUSilenceNonFiniteAnalyzer *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUSilenceNonFiniteAnalyzer::SupportedNumChannels(AUSilenceNonFiniteAnalyzer *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUSilenceNonFiniteAnalyzer::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

BOOL AUSilenceNonFiniteAnalyzer::ValidFormat(AUSilenceNonFiniteAnalyzer *this, int a2, int a3, const AudioStreamBasicDescription *a4)
{
  BOOL v6;

  v6 = (a2 - 1) <= 1 && a3 == 0 && a4->mFormatID == 1819304813 && a4->mFramesPerPacket == 1;
  return v6 && a4->mBytesPerPacket == a4->mBytesPerFrame && a4->mBitsPerChannel == 32;
}

os_log_t ___ZL34AUSilenceNonFiniteAnalyzerLogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "silence");
  *v0 = result;
  AUSilenceNonFiniteAnalyzerLogScope(void)::scope = (uint64_t)v0;
  return result;
}

void EqualPowerPanningSpatializer::~EqualPowerPanningSpatializer(EqualPowerPanningSpatializer *this)
{
  Spatializer::~Spatializer(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t EqualPowerPanningSpatializer::initialize(EqualPowerPanningSpatializer *this, float a2, unsigned int a3, int a4)
{
  uint64_t v5;
  NSObject *v6;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  __int128 v10;
  void **v11;
  double v14;
  double v15;
  double v16;
  float v17;
  std::string v19;
  std::string v20;
  void *__p[2];
  int64_t v22;
  uint8_t buf[4];
  void **v24;
  __int16 v25;
  unsigned int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a3 > 1)
  {
    *((float *)this + 2) = a2;
    *((_DWORD *)this + 3) = a4;
    v14 = a2 * 0.001953125 * 0.0219999999;
    if (v14 >= 2.22507386e-308)
      v15 = -6.90775528 / v14;
    else
      v15 = -INFINITY;
    v16 = exp(v15);
    if (v15 < -708.4)
      v16 = 0.0;
    v17 = v16;
    *((float *)this + 87) = v17;
    *((_DWORD *)this + 5) = (float)(a2 * 0.044);
    LODWORD(__p[0]) = 0;
    std::vector<float>::resize((uint64_t)this + 136, a3, __p);
    LODWORD(__p[0]) = 0;
    std::vector<float>::resize((uint64_t)this + 272, a3, __p);
    v5 = 0;
    *((_WORD *)this + 8) = 257;
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v5 = 4294900553;
    v6 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v19, "EqualPowerPanningSpatializer");
      v7 = std::string::append(&v19, "::", 2uLL);
      v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v20.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      v9 = std::string::append(&v20, "initialize", 0xAuLL);
      v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
      v22 = v9->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v10;
      v9->__r_.__value_.__l.__size_ = 0;
      v9->__r_.__value_.__r.__words[2] = 0;
      v9->__r_.__value_.__r.__words[0] = 0;
      v11 = __p;
      if (v22 < 0)
        v11 = (void **)__p[0];
      *(_DWORD *)buf = 136315394;
      v24 = v11;
      v25 = 1024;
      v26 = a3;
      _os_log_error_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_ERROR, "%s: cannot initialize with inNumOutputChannels = %d", buf, 0x12u);
      if (SHIBYTE(v22) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v20.__r_.__value_.__l.__data_);
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v19.__r_.__value_.__l.__data_);
    }
  }
  return v5;
}

void sub_1B659ED24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t EqualPowerPanningSpatializer::processAccumulating(EqualPowerPanningSpatializer *this, const float *__A, const float **a3, unsigned int a4, float *const *a5, unsigned int a6, vDSP_Length __N, float a8, IR::ComplexDataCircBuffer *a9)
{
  NSObject *v10;
  uint64_t result;
  int v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  float v25;
  float v26;
  float v27;
  vDSP_Length v28;
  NSObject *v29;
  float v30;
  int v31;
  float v32;
  float v33;
  vDSP_Length v34;
  std::string *v35;
  __int128 v36;
  std::string *v37;
  __int128 v38;
  std::string *p_Step;
  std::string *v40;
  std::string v41;
  std::string v42;
  std::string __Step;
  uint8_t buf[4];
  std::string *v45;
  __int16 v46;
  unsigned int v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (a4 <= 1)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v10 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      std::string::basic_string[abi:ne180100]<0>(&v41, "EqualPowerPanningSpatializer");
      v35 = std::string::append(&v41, "::", 2uLL);
      v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v36;
      v35->__r_.__value_.__l.__size_ = 0;
      v35->__r_.__value_.__r.__words[2] = 0;
      v35->__r_.__value_.__r.__words[0] = 0;
      v37 = std::string::append(&v42, "processAccumulating", 0x13uLL);
      v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      __Step.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__Step.__r_.__value_.__l.__data_ = v38;
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      p_Step = &__Step;
      if ((__Step.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_Step = (std::string *)__Step.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315394;
      v45 = p_Step;
      v46 = 1024;
      v47 = a4;
      _os_log_debug_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEBUG, "%s: ERROR, cannot process with %d output channels", buf, 0x12u);
      if (SHIBYTE(__Step.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__Step.__r_.__value_.__l.__data_);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v42.__r_.__value_.__l.__data_);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
    }
    return 4294956445;
  }
  if (*((_BYTE *)this + 16))
  {
    v15 = *((unsigned __int8 *)this + 132);
    v16 = 0.0;
    if (!*((_BYTE *)this + 132))
      a8 = 0.0;
    v17 = 0.0;
    if (*((_BYTE *)this + 132))
    {
      v18 = *((float *)this + 12);
      v19 = *((float *)this + 14);
      if (v18 == *((float *)this + 46)
        && v19 == *((float *)this + 48)
        && *((float *)this + 31) == *((float *)this + 65)
        && !*((_BYTE *)this + 17))
      {
        v25 = *((float *)this + 83);
        v26 = *((float *)this + 84);
      }
      else
      {
        v20 = *((float *)this + 31);
        *((float *)this + 46) = v18;
        *((float *)this + 48) = v19;
        v21 = llroundf(v18);
        *((float *)this + 65) = v20;
        v22 = v21
            + 360 * (((v21 & ~(v21 >> 31)) - (v21 + (v21 >> 31))) / 0x168 + (v21 >> 31));
        if (v22 <= 359)
          v23 = 359;
        else
          v23 = v22;
        v24 = v22 - 360 * (((3054198967u * (unint64_t)v23) >> 32) >> 8);
        v25 = gPanTable[v24];
        *((float *)this + 83) = v25;
        v26 = gPanTable[360 - v24];
        *((float *)this + 84) = v26;
        if (v19 < v20)
        {
          v27 = (float)(v20 - v19) / v20;
          v25 = v25 + (float)(v27 * (float)(0.70711 - v25));
          *((float *)this + 83) = v25;
          v26 = v26 + (float)(v27 * (float)(0.70711 - v26));
          *((float *)this + 84) = v26;
        }
      }
      v16 = v25 * a8;
      v17 = v26 * a8;
    }
    if (*((_BYTE *)this + 17))
    {
      *((float *)this + 85) = v16;
      *((float *)this + 86) = v17;
      *((_BYTE *)this + 268) = v15;
      *((_BYTE *)this + 17) = 0;
LABEL_22:
      v28 = __N;
      vDSP_vsma(__A, 1, (const float *)this + 85, *a3, 1, (float *)*a3, 1, __N);
      vDSP_vsma(__A, 1, (const float *)this + 86, a3[1], 1, (float *)a3[1], 1, v28);
      return 0;
    }
    if (v15 == *((unsigned __int8 *)this + 268))
    {
      v30 = *((float *)this + 85);
      if (v30 == v16 || vabds_f32(v30, v16) < 0.0001)
      {
        v31 = 0;
        *((float *)this + 85) = v16;
      }
      else
      {
        if (!*((_DWORD *)this + 81))
          v16 = v16 + (float)((float)(v30 - v16) * *((float *)this + 87));
        v31 = 1;
      }
      v32 = *((float *)this + 86);
      if (v32 == v17 || vabds_f32(v32, v17) < 0.0001)
      {
        *((float *)this + 86) = v17;
        if (!v31)
          goto LABEL_22;
      }
      else if (!*((_DWORD *)this + 81))
      {
        v17 = v17 + (float)((float)(v32 - v17) * *((float *)this + 87));
      }
    }
    else
    {
      *((_BYTE *)this + 268) = v15;
    }
    if ((_DWORD)__N)
    {
      v33 = 1.0 / (float)__N;
      *(float *)&__Step.__r_.__value_.__l.__data_ = v33 * (float)(v16 - *((float *)this + 85));
      *(float *)&v42.__r_.__value_.__l.__data_ = v33 * (float)(v17 - *((float *)this + 86));
      v34 = __N;
      vDSP_vrampmuladd(__A, 1, (float *)this + 85, (const float *)&__Step, (float *)*a3, 1, __N);
      vDSP_vrampmuladd(__A, 1, (float *)this + 86, (const float *)&v42, (float *)a3[1], 1, v34);
    }
    result = 0;
    *((float *)this + 85) = v16;
    *((float *)this + 86) = v17;
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v29 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      std::string::basic_string[abi:ne180100]<0>(&v41, "EqualPowerPanningSpatializer");
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("::", &v41, &v42);
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("processAccumulating", &v42, &__Step);
      if ((__Step.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v40 = &__Step;
      else
        v40 = (std::string *)__Step.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315138;
      v45 = v40;
      _os_log_debug_impl(&dword_1B5ED0000, v29, OS_LOG_TYPE_DEBUG, "%s: ERROR, not intialized", buf, 0xCu);
      if (SHIBYTE(__Step.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__Step.__r_.__value_.__l.__data_);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v42.__r_.__value_.__l.__data_);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
    }
    return 4294956429;
  }
  return result;
}

void sub_1B659F2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t *std::list<int>::~list(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v3 = *a1;
    v2 = (uint64_t *)a1[1];
    v4 = *v2;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        v5 = (uint64_t *)v2[1];
        operator delete(v2);
        v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void CDelaunayTriangles3D::~CDelaunayTriangles3D(CDelaunayTriangles3D *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  CDelaunayTriangles3D *v7;
  uint64_t v8;
  uint64_t v9;
  CDelaunayTriangles3D *v10;

  if (*((_QWORD *)this + 5))
  {
    v2 = (char *)this + 24;
    v4 = *((_QWORD *)this + 3);
    v3 = (char *)*((_QWORD *)this + 4);
    v5 = *(_QWORD *)v3;
    *(_QWORD *)(v5 + 8) = *(_QWORD *)(v4 + 8);
    **(_QWORD **)(v4 + 8) = v5;
    *((_QWORD *)this + 5) = 0;
    if (v3 != (char *)this + 24)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v3 + 1);
        operator delete(v3);
        v3 = v6;
      }
      while (v6 != v2);
    }
  }
  if (*((_QWORD *)this + 2))
  {
    v8 = *(_QWORD *)this;
    v7 = (CDelaunayTriangles3D *)*((_QWORD *)this + 1);
    v9 = *(_QWORD *)v7;
    *(_QWORD *)(v9 + 8) = *(_QWORD *)(*(_QWORD *)this + 8);
    **(_QWORD **)(v8 + 8) = v9;
    *((_QWORD *)this + 2) = 0;
    if (v7 != this)
    {
      do
      {
        v10 = (CDelaunayTriangles3D *)*((_QWORD *)v7 + 1);
        operator delete(v7);
        v7 = v10;
      }
      while (v10 != this);
    }
  }
}

_QWORD *CDelaunayTriangles3D::check_avail_vertices(_QWORD *result, unint64_t a2, int a3)
{
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  _QWORD *v9;
  int v10;

  v4 = result;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = HIDWORD(a2);
  v9 = result;
  while (1)
  {
    v9 = (_QWORD *)v9[1];
    if (v9 == result)
      break;
    v10 = *((_DWORD *)v9 + 4);
    if (v10 == (_DWORD)a2 || *((_DWORD *)v9 + 5) == (_DWORD)a2)
      v7 = 1;
    if (v10 == HIDWORD(a2) || *((_DWORD *)v9 + 5) == HIDWORD(a2))
      v5 = 1;
    if (v10 == a3 || *((_DWORD *)v9 + 5) == a3)
      v6 = 1;
    if (v7 && v5 && v6)
      return result;
  }
  if (v7)
  {
    if (v5)
      goto LABEL_18;
  }
  else
  {
    result = std::list<int>::remove(result + 3, a2);
    if (v5)
    {
LABEL_18:
      if (v6)
        return result;
      return std::list<int>::remove(v4 + 3, a3);
    }
  }
  result = std::list<int>::remove(v4 + 3, v8);
  if (!v6)
    return std::list<int>::remove(v4 + 3, a3);
  return result;
}

_QWORD *std::list<int>::remove(_QWORD *result, int a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *__p;
  uint64_t v21;

  v19 = &v19;
  __p = &v19;
  v2 = (_QWORD *)result[1];
  if (v2 == result)
    return result;
  v21 = 0;
  if (&v19 == result)
  {
    while (1)
    {
      v12 = (_QWORD *)v2[1];
      if (*((_DWORD *)v2 + 4) == a2)
        break;
LABEL_19:
      v2 = v12;
      if (v12 == result)
        return result;
    }
    if (v12 == result)
    {
      v13 = 1;
    }
    else
    {
      if (*((_DWORD *)v12 + 4) != a2)
      {
LABEL_25:
        v13 = 0;
        if (v2 == v12)
        {
LABEL_30:
          if (!v13)
            v12 = (_QWORD *)v12[1];
          goto LABEL_19;
        }
LABEL_29:
        v14 = *v12;
        v15 = *v2;
        *(_QWORD *)(v15 + 8) = *(_QWORD *)(*v12 + 8);
        **(_QWORD **)(v14 + 8) = v15;
        v16 = *result;
        *(_QWORD *)(v16 + 8) = v2;
        *v2 = v16;
        *result = v14;
        *(_QWORD *)(v14 + 8) = result;
        goto LABEL_30;
      }
      while (1)
      {
        v12 = (_QWORD *)v12[1];
        v13 = v12 == result;
        if (v12 == result)
          break;
        if (*((_DWORD *)v12 + 4) != a2)
          goto LABEL_25;
      }
    }
    v12 = result;
    if (v2 == result)
      goto LABEL_30;
    goto LABEL_29;
  }
  v3 = 0;
  v4 = &v19;
  do
  {
    v5 = (_QWORD *)v2[1];
    if (*((_DWORD *)v2 + 4) == a2)
    {
      if (v5 == result)
      {
LABEL_9:
        v6 = 1;
        v5 = result;
      }
      else
      {
        while (1)
        {
          v6 = *((_DWORD *)v5 + 4) == a2;
          if (*((_DWORD *)v5 + 4) != a2)
            break;
          v5 = (_QWORD *)v5[1];
          if (v5 == result)
            goto LABEL_9;
        }
      }
      if (v2 != v5)
      {
        v4 = (_QWORD *)*v5;
        if ((_QWORD *)*v5 == v2)
        {
          v9 = 1;
        }
        else
        {
          v7 = -1;
          v8 = v2;
          do
          {
            v8 = (_QWORD *)v8[1];
            ++v7;
          }
          while (v8 != v4);
          v9 = v7 + 2;
        }
        result[2] -= v9;
        v3 += v9;
        v10 = *v2;
        *(_QWORD *)(v10 + 8) = v4[1];
        *(_QWORD *)v4[1] = v10;
        v11 = v19;
        v19[1] = v2;
        *v2 = v11;
        v19 = v4;
        v4[1] = &v19;
      }
      if (!v6)
        v5 = (_QWORD *)v5[1];
    }
    v2 = v5;
  }
  while (v5 != result);
  if (v3)
  {
    result = __p;
    v17 = *(_QWORD *)__p;
    *(_QWORD *)(v17 + 8) = v4[1];
    *(_QWORD *)v4[1] = v17;
    v21 = 0;
    if (result != &v19)
    {
      do
      {
        v18 = (_QWORD *)result[1];
        operator delete(result);
        result = v18;
      }
      while (v18 != &v19);
    }
  }
  return result;
}

_QWORD *std::list<std::array<int,2ul>>::remove(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *__p;
  uint64_t v21;

  v19 = &v19;
  __p = &v19;
  v21 = 0;
  v2 = (_QWORD *)result[1];
  if (v2 != result)
  {
    if (&v19 == result)
    {
      do
      {
        v12 = (_QWORD *)v2[1];
        if (v2[2] == *a2)
        {
          while (v12 != result)
          {
            v13 = v12[2] == *a2;
            if (v12[2] != *a2)
            {
              if (v2 == v12)
                goto LABEL_29;
              goto LABEL_28;
            }
            v12 = (_QWORD *)v12[1];
          }
          v13 = 1;
          v12 = result;
          if (v2 != result)
          {
LABEL_28:
            v14 = *v12;
            v15 = *v2;
            *(_QWORD *)(v15 + 8) = *(_QWORD *)(*v12 + 8);
            **(_QWORD **)(v14 + 8) = v15;
            v16 = *result;
            *(_QWORD *)(v16 + 8) = v2;
            *v2 = v16;
            *result = v14;
            *(_QWORD *)(v14 + 8) = result;
          }
LABEL_29:
          if (!v13)
            v12 = (_QWORD *)v12[1];
        }
        v2 = v12;
      }
      while (v12 != result);
    }
    else
    {
      v3 = 0;
      v4 = &v19;
      do
      {
        v5 = (_QWORD *)v2[1];
        if (v2[2] == *a2)
        {
          while (1)
          {
            if (v5 == result)
            {
              v6 = 1;
              v5 = result;
              if (v2 == result)
                goto LABEL_11;
              goto LABEL_14;
            }
            v6 = v5[2] == *a2;
            if (v5[2] != *a2)
              break;
            v5 = (_QWORD *)v5[1];
          }
          if (v2 == v5)
          {
LABEL_11:
            if (v6)
              goto LABEL_4;
            goto LABEL_20;
          }
LABEL_14:
          v4 = (_QWORD *)*v5;
          if ((_QWORD *)*v5 == v2)
          {
            v9 = 1;
          }
          else
          {
            v7 = -1;
            v8 = v2;
            do
            {
              v8 = (_QWORD *)v8[1];
              ++v7;
            }
            while (v8 != v4);
            v9 = v7 + 2;
          }
          result[2] -= v9;
          v3 += v9;
          v21 = v3;
          v10 = *v2;
          *(_QWORD *)(v10 + 8) = v4[1];
          *(_QWORD *)v4[1] = v10;
          v11 = v19;
          v19[1] = v2;
          *v2 = v11;
          v19 = v4;
          v4[1] = &v19;
          if (!v6)
LABEL_20:
            v5 = (_QWORD *)v5[1];
        }
LABEL_4:
        v2 = v5;
      }
      while (v5 != result);
      if (v3)
      {
        result = __p;
        v17 = *(_QWORD *)__p;
        *(_QWORD *)(v17 + 8) = v4[1];
        *(_QWORD *)v4[1] = v17;
        v21 = 0;
        if (result != &v19)
        {
          do
          {
            v18 = (_QWORD *)result[1];
            operator delete(result);
            result = v18;
          }
          while (v18 != &v19);
        }
      }
    }
  }
  return result;
}

uint64_t CDelaunayTriangles3D::find_one_delaunay3(CDelaunayTriangles3D *this, const double *a2, const double *a3, const double *a4, int *a5, int a6)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  char *v13;
  CDelaunayTriangles3D *v14;
  int v15;
  uint64_t v16;
  float64x2_t v18;
  double v19;
  uint64_t v20;
  double v21;
  float64x2_t v22;
  double v23;
  double v24;
  float64x2_t v25;
  double v26;
  double v27;
  float64x2_t v28;
  int v29;
  CDelaunayTriangles3D *v30;
  int v31;
  uint64_t v33;
  float64x2_t v34;
  float64x2_t v35;
  int8x16_t v36;
  int8x16_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  int64x2_t v46;
  int64x2_t v47;

  v6 = *((_QWORD *)this + 5);
  if (!v6)
    return 0xFFFFFFFFLL;
  if (v6 != 1)
  {
    v13 = (char *)this + 24;
    v14 = (CDelaunayTriangles3D *)*((_QWORD *)this + 4);
    if (v14 != (CDelaunayTriangles3D *)((char *)this + 24))
    {
      v15 = 0;
      v16 = *((_QWORD *)this + 4);
      do
      {
        result = *(unsigned int *)(v16 + 16);
        if ((_DWORD)result != (_DWORD)a5 && (_DWORD)result != a6)
        {
          v18.f64[0] = a2[(int)a5];
          v19 = a2[a6];
          v20 = (int)result;
          v21 = a2[v20];
          v22.f64[0] = a3[(int)a5];
          v23 = a3[a6];
          v24 = a3[v20];
          v25.f64[0] = a4[(int)a5];
          v26 = a4[a6];
          v27 = a4[v20];
          if (-(v23 * v21 - v24 * v19) * v25.f64[0]
             + -(v26 * v24 - v27 * v23) * v18.f64[0]
             + -(v27 * v19 - v26 * v21) * v22.f64[0] > 0.0)
          {
            v28.f64[0] = v18.f64[0] * v18.f64[0] + v22.f64[0] * v22.f64[0] + v25.f64[0] * v25.f64[0];
            v28.f64[1] = v19 * v19 + v23 * v23 + v26 * v26;
            v18.f64[1] = a2[a6];
            v22.f64[1] = a3[a6];
            v25.f64[1] = a4[a6];
            v29 = v15;
            v30 = v14;
            while (1)
            {
              if (v29)
              {
                v31 = *((_DWORD *)v30 + 4);
                if (v31 != (_DWORD)a5 && v31 != a6)
                {
                  v33 = v31;
                  v34.f64[0] = v21 * v21 + v24 * v24 + v27 * v27;
                  v34.f64[1] = a2[v33] * a2[v33] + a3[v33] * a3[v33] + a4[v33] * a4[v33];
                  v35.f64[0] = v21;
                  v35.f64[1] = a2[v33];
                  *(double *)v36.i64 = v24;
                  *(double *)&v36.i64[1] = a3[v33];
                  *(double *)v37.i64 = v27;
                  *(double *)&v37.i64[1] = a4[v33];
                  v38 = (float64x2_t)vextq_s8(v36, (int8x16_t)v22, 8uLL);
                  v39 = (float64x2_t)vextq_s8((int8x16_t)v22, v36, 8uLL);
                  v40 = (float64x2_t)vextq_s8(v37, (int8x16_t)v25, 8uLL);
                  v41 = (float64x2_t)vextq_s8((int8x16_t)v25, v37, 8uLL);
                  v42 = vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v39, v40)), v41, v38), v35);
                  v43 = (float64x2_t)vextq_s8((int8x16_t)v35, (int8x16_t)v18, 8uLL);
                  v44 = (float64x2_t)vextq_s8((int8x16_t)v18, (int8x16_t)v35, 8uLL);
                  v45 = vmlaq_f64(vmlaq_f64(v42, v44, vmlaq_f64(vnegq_f64(vmulq_f64(v38, (float64x2_t)v37)), v40, (float64x2_t)v36)), v43, vmlaq_f64(vnegq_f64(vmulq_f64((float64x2_t)v36, v41)), (float64x2_t)v37, v39));
                  v46 = (int64x2_t)vmulq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v38, v41)), v40, v39), v18), v43, vmlaq_f64(vnegq_f64(vmulq_f64(v39, v25)), v41, v22)), v44, vmlaq_f64(vnegq_f64(vmulq_f64(v22, v40)), v25, v38)), v34);
                  v47 = (int64x2_t)vmulq_f64(v45, v28);
                  if (vaddvq_f64(vsubq_f64((float64x2_t)vzip1q_s64(v47, v46), (float64x2_t)vzip2q_s64(v47, v46))) > 1.0e-13)
                    break;
                }
              }
              v30 = (CDelaunayTriangles3D *)*((_QWORD *)v30 + 1);
              --v29;
              if (v30 == (CDelaunayTriangles3D *)v13)
                return result;
            }
          }
        }
        v16 = *(_QWORD *)(v16 + 8);
        ++v15;
      }
      while ((char *)v16 != v13);
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_DWORD *)(*((_QWORD *)this + 4) + 16);
  if (v7 == (_DWORD)a5 || v7 == a6)
    return 0xFFFFFFFFLL;
  v9 = (int)a5;
  v10 = a6;
  v11 = (int)v7;
  if (-(a3[v10] * a2[v11] - a3[v11] * a2[v10]) * a4[v9]
     + -(a4[v10] * a3[v11] - a4[v11] * a3[v10]) * a2[v9]
     + -(a4[v11] * a2[v10] - a4[v10] * a2[v11]) * a3[v9] <= 0.0)
    return 0xFFFFFFFFLL;
  else
    return v7;
}

uint64_t CDelaunayTriangles3D::find_delaunay_triangles(CDelaunayTriangles3D *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::vector<int> *this, unsigned int a6)
{
  unint64_t v12;
  std::vector<int>::pointer begin;
  int *end;
  unint64_t v15;
  uint64_t v16;
  CDelaunayTriangles3D *v17;
  uint64_t v18;
  uint64_t v19;
  CDelaunayTriangles3D *v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  double v42;
  uint64_t v43;
  double v44;
  double v45;
  BOOL v46;
  int v47;
  _QWORD *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int one_delaunay3;
  int v53;
  unint64_t v54;
  std::vector<int>::pointer v55;
  uint64_t v56;
  _QWORD *v57;
  unint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  CDelaunayTriangles3D *v65;
  CDelaunayTriangles3D *v66;
  int *v67;
  unsigned int v68;
  unsigned int v69;
  std::vector<int>::pointer v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  unint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t result;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unsigned int v83;
  std::vector<int> *v84;
  int *v85;
  unint64_t v86;

  v83 = 2 * a6 - 4;
  v12 = 3 * v83;
  begin = this->__begin_;
  end = this->__end_;
  v15 = end - this->__begin_;
  if (v12 <= v15)
  {
    if (v12 < v15)
    {
      end = &begin[v12];
      this->__end_ = end;
    }
  }
  else
  {
    std::vector<int>::__append(this, v12 - v15);
    begin = this->__begin_;
    end = this->__end_;
  }
  v16 = (char *)end - (char *)begin;
  if (v16 >= 1)
    bzero(begin, 4 * (((unint64_t)v16 >> 2) - ((unint64_t)v16 > 3)) + 4);
  v84 = this;
  if (*((_QWORD *)a1 + 2))
  {
    v18 = *(_QWORD *)a1;
    v17 = (CDelaunayTriangles3D *)*((_QWORD *)a1 + 1);
    v19 = *(_QWORD *)v17;
    *(_QWORD *)(v19 + 8) = *(_QWORD *)(*(_QWORD *)a1 + 8);
    **(_QWORD **)(v18 + 8) = v19;
    *((_QWORD *)a1 + 2) = 0;
    if (v17 != a1)
    {
      do
      {
        v20 = (CDelaunayTriangles3D *)*((_QWORD *)v17 + 1);
        operator delete(v17);
        v17 = v20;
      }
      while (v20 != a1);
    }
  }
  v21 = (_QWORD *)((char *)a1 + 24);
  v22 = *((_QWORD *)a1 + 5);
  v23 = v22 - a6;
  if (v22 <= a6)
  {
    if (v22 < a6)
    {
      v25 = operator new(0x18uLL);
      v26 = v25;
      *v25 = 0;
      v25[1] = 0;
      *((_DWORD *)v25 + 4) = 0;
      if (~v22 + a6)
      {
        v27 = v23 + 1;
        v28 = v25;
        do
        {
          v25 = operator new(0x18uLL);
          *v25 = v28;
          v25[1] = 0;
          v28[1] = v25;
          v28 = v25;
          *((_DWORD *)v25 + 4) = 0;
        }
        while (!__CFADD__(v27++, 1));
        v30 = a6 - v22;
      }
      else
      {
        v30 = 1;
      }
      v25[1] = v21;
      v36 = *((_QWORD *)a1 + 3);
      *v26 = v36;
      *(_QWORD *)(v36 + 8) = v26;
      *((_QWORD *)a1 + 3) = v25;
      *((_QWORD *)a1 + 5) = v30 + v22;
    }
  }
  else
  {
    if (a6 <= v22 >> 1)
    {
      v24 = (_QWORD *)*((_QWORD *)a1 + 4);
      if (a6)
      {
        v31 = a6 + 1;
        do
        {
          v24 = (_QWORD *)v24[1];
          --v31;
        }
        while (v31 > 1);
      }
    }
    else if (v23 < 1)
    {
      v32 = a6 - v22 + 1;
      v24 = (_QWORD *)((char *)a1 + 24);
      do
      {
        v24 = (_QWORD *)v24[1];
        --v32;
      }
      while (v32 > 1);
    }
    else
    {
      v24 = (_QWORD *)((char *)a1 + 24);
      do
      {
        v24 = (_QWORD *)*v24;
        --v23;
      }
      while (v23);
    }
    if (v24 != v21)
    {
      v33 = *v21;
      v34 = (_QWORD *)*v24;
      v34[1] = *(_QWORD *)(*v21 + 8);
      **(_QWORD **)(v33 + 8) = v34;
      do
      {
        v35 = (_QWORD *)v24[1];
        --*((_QWORD *)a1 + 5);
        operator delete(v24);
        v24 = v35;
      }
      while (v35 != v21);
    }
  }
  v37 = *((_QWORD *)a1 + 4);
  if ((_QWORD *)v37 != v21)
  {
    v38 = 0;
    do
    {
      *(_DWORD *)(v37 + 16) = v38;
      v37 = *(_QWORD *)(v37 + 8);
      ++v38;
    }
    while ((_QWORD *)v37 != v21);
  }
  v39 = a6 - 1;
  if ((int)v39 < 2)
  {
    v47 = 1;
  }
  else
  {
    v40 = 0;
    v41 = 0;
    v42 = (*(double *)a3 - *(double *)(a3 + 8)) * (*(double *)a3 - *(double *)(a3 + 8))
        + (*(double *)a2 - *(double *)(a2 + 8)) * (*(double *)a2 - *(double *)(a2 + 8))
        + (*(double *)a4 - *(double *)(a4 + 8)) * (*(double *)a4 - *(double *)(a4 + 8));
    v43 = v39 - 1;
    do
    {
      v44 = *(double *)a4 - *(double *)(a4 + 16 + 8 * v40);
      v45 = (*(double *)a2 - *(double *)(a2 + 16 + 8 * v40)) * (*(double *)a2 - *(double *)(a2 + 16 + 8 * v40))
          + (*(double *)a3 - *(double *)(a3 + 16 + 8 * v40)) * (*(double *)a3 - *(double *)(a3 + 16 + 8 * v40))
          + v44 * v44;
      v46 = v45 < v42;
      v42 = fmin(v45, v42);
      ++v40;
      if (v46)
        v41 = v40;
    }
    while (v43 != v40);
    v47 = v41 + 1;
  }
  LODWORD(v85) = 0;
  HIDWORD(v85) = v47;
  v48 = operator new(0x18uLL);
  v49 = (unint64_t)v85;
  v48[1] = a1;
  v48[2] = v49;
  v50 = *(_QWORD *)a1;
  *v48 = *(_QWORD *)a1;
  *(_QWORD *)(v50 + 8) = v48;
  *(_QWORD *)a1 = v48;
  v51 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v51 + 1;
  one_delaunay3 = CDelaunayTriangles3D::find_one_delaunay3(a1, (const double *)a2, (const double *)a3, (const double *)a4, (int *)HIDWORD(v49), v49);
  if (one_delaunay3 < 0)
  {
    v53 = CDelaunayTriangles3D::find_one_delaunay3(a1, (const double *)a2, (const double *)a3, (const double *)a4, (int *)v49, SHIDWORD(v49));
    v54 = HIDWORD(v49);
    if (v53 >= 1)
      goto LABEL_46;
LABEL_69:
    LODWORD(v64) = 0;
    goto LABEL_70;
  }
  v53 = one_delaunay3;
  v54 = v49;
  v49 >>= 32;
  if (one_delaunay3 < 1)
    goto LABEL_69;
LABEL_46:
  v55 = v84->__begin_;
  *v55 = v49;
  v55[1] = v54;
  v55[2] = v53;
  v86 = __PAIR64__(v53, v54);
  std::list<std::array<int,2ul>>::remove(a1, &v86);
  v56 = *((_QWORD *)a1 + 2);
  if (v56 == v51 + 1)
  {
    v86 = __PAIR64__(v54, v53);
    v57 = operator new(0x18uLL);
    v58 = v86;
    v57[1] = a1;
    v57[2] = v58;
    v59 = *(_QWORD *)a1;
    *v57 = *(_QWORD *)a1;
    *(_QWORD *)(v59 + 8) = v57;
    *(_QWORD *)a1 = v57;
    v56 = v51 + 2;
    *((_QWORD *)a1 + 2) = v51 + 2;
  }
  v86 = __PAIR64__(v49, v53);
  std::list<std::array<int,2ul>>::remove(a1, &v86);
  if (*((_QWORD *)a1 + 2) == v56)
  {
    v86 = __PAIR64__(v53, v49);
    v60 = operator new(0x18uLL);
    v61 = v86;
    v60[1] = a1;
    v60[2] = v61;
    v62 = *(_QWORD *)a1;
    *v60 = *(_QWORD *)a1;
    *(_QWORD *)(v62 + 8) = v60;
    *(_QWORD *)a1 = v60;
    *((_QWORD *)a1 + 2) = v56 + 1;
  }
  CDelaunayTriangles3D::check_avail_vertices(a1, v49 | (v54 << 32), v53);
  if (!*((_QWORD *)a1 + 5))
  {
    LODWORD(v64) = 1;
    goto LABEL_73;
  }
  if (v83 <= 1)
    v63 = 1;
  else
    v63 = v83;
  v82 = v63;
  v64 = 1;
  do
  {
    if (!*((_QWORD *)a1 + 2))
      break;
    v65 = (CDelaunayTriangles3D *)*((_QWORD *)a1 + 1);
    if (v65 == a1)
      break;
    v66 = a1;
    while (1)
    {
      v66 = *(CDelaunayTriangles3D **)v66;
      v67 = (int *)*((_QWORD *)v66 + 2);
      v68 = CDelaunayTriangles3D::find_one_delaunay3(a1, (const double *)a2, (const double *)a3, (const double *)a4, v67, SHIDWORD(v67));
      if ((v68 & 0x80000000) == 0)
        break;
      if (v66 == v65)
        goto LABEL_70;
    }
    v85 = v67;
    if (v64 == v82)
    {
      LODWORD(v64) = v82;
      break;
    }
    v69 = v68;
    v70 = v84->__begin_;
    v84->__begin_[(3 * v64)] = (int)v67;
    v70[(3 * v64 + 1)] = HIDWORD(v67);
    v70[(3 * v64 + 2)] = v68;
    std::list<std::array<int,2ul>>::remove(a1, &v85);
    v71 = *((_QWORD *)a1 + 2);
    v86 = __PAIR64__(v69, HIDWORD(v67));
    std::list<std::array<int,2ul>>::remove(a1, &v86);
    v72 = *((_QWORD *)a1 + 2);
    if (v72 == v71)
    {
      v86 = __PAIR64__(HIDWORD(v67), v69);
      v73 = operator new(0x18uLL);
      v74 = v86;
      v73[1] = a1;
      v73[2] = v74;
      v75 = *(_QWORD *)a1;
      *v73 = *(_QWORD *)a1;
      *(_QWORD *)(v75 + 8) = v73;
      *(_QWORD *)a1 = v73;
      v72 = v71 + 1;
      *((_QWORD *)a1 + 2) = v71 + 1;
    }
    v86 = __PAIR64__(v67, v69);
    std::list<std::array<int,2ul>>::remove(a1, &v86);
    if (*((_QWORD *)a1 + 2) == v72)
    {
      v86 = __PAIR64__(v69, v67);
      v76 = operator new(0x18uLL);
      v77 = v86;
      v76[1] = a1;
      v76[2] = v77;
      v78 = *(_QWORD *)a1;
      *v76 = *(_QWORD *)a1;
      *(_QWORD *)(v78 + 8) = v76;
      *(_QWORD *)a1 = v76;
      *((_QWORD *)a1 + 2) = v72 + 1;
    }
    ++v64;
    v81 = v81 & 0xFFFFFFFF00000000 | v69;
    CDelaunayTriangles3D::check_avail_vertices(a1, (unint64_t)v67, v69);
  }
  while (*((_QWORD *)a1 + 5));
LABEL_70:
  if ((_DWORD)v64 == v83)
    return 1;
LABEL_73:
  v80 = v84->__end_ - v84->__begin_;
  if (v64 <= v80)
  {
    result = 0;
    if (v64 < v80)
      v84->__end_ = &v84->__begin_[v64];
  }
  else
  {
    std::vector<int>::__append(v84, v64 - v80);
    return 0;
  }
  return result;
}

void sub_1B65A0174(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  __cxa_begin_catch(a1);
  do
  {
    v2 = (_QWORD *)*v1;
    operator delete(v1);
    v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1B65A0194(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t CDelaunayTriangles3D::find_subtriangle_containment(unint64_t this, double a2, double a3, double a4)
{
  int v4;
  uint64_t v5;
  double v6;
  double v7;
  double v8;
  char *v9;
  char v10;
  NSObject *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  BOOL v17;
  _BOOL4 v18;
  double v19;
  double v20;
  double v21;
  uint64_t v22;
  double *v23;
  double v24;
  uint64_t v25;
  double *v26;
  double v27;
  double v29;
  double v30;
  double v31;
  double v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if ((this & 0x8000000000000000) != 0)
    return 0xFFFFFFFFLL;
  if (a3 <= -0.00000011920929)
    v4 = 4 * (a2 > -0.00000011920929);
  else
    v4 = (4 * (a2 > -0.00000011920929)) | 2;
  v5 = v4 | (a4 > -0.00000011920929);
  if (this)
  {
    v5 = ((_DWORD)v5 << (2 * this));
    v6 = fabs(a4);
    v7 = fabs(a3);
    v8 = fabs(a2);
    v9 = (char *)(this + 1);
    v10 = 2 * this - 2;
    v11 = MEMORY[0x1E0C81028];
    do
    {
      v12 = v8 - (v6 + v7);
      v13 = v7 + v7;
      v14 = v6 + v6;
      v15 = fmin(v6 + v6, fmin(v7 + v7, v12));
      v16 = fmin(v6 - (v7 + v8), fmin(v7 + v7, v8 + v8));
      v17 = v15 < v16;
      v18 = v15 < v16;
      v29 = v15;
      v30 = v16;
      v19 = fmin(v6 + v6, fmin(v7 - (v8 + v6), v8 + v8));
      v20 = fmin(v7 + v8 - v6, fmin(v8 - v7 + v6, v6 + v7 - v8));
      v31 = v19;
      v32 = v20;
      v21 = fmax(v15, v16);
      v22 = 8 * v18;
      if (v17)
        v23 = &v30;
      else
        v23 = &v29;
      v24 = fmax(v21, v19);
      if (v21 < v19)
      {
        v22 = 16;
        v23 = &v31;
      }
      if (v24 >= v20)
        v25 = v22;
      else
        v25 = 24;
      if (v24 >= v20)
        v26 = v23;
      else
        v26 = &v32;
      v27 = *(double *)((char *)&v29 + v25);
      if (v27 <= -0.00000011920929)
      {
LABEL_22:
        if (v27 <= -0.0000011920929)
        {
LABEL_25:
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v34 = "DelaunayTriangles3D.cpp";
            v35 = 1024;
            v36 = 476;
            v37 = 2080;
            v38 = "find_subtriangle_containment";
            v39 = 1024;
            v40 = 476;
            _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: subtriangle still not found in computing rank with relaxed test!", buf, 0x22u);
          }
          v12 = v8;
          v13 = v7;
          v14 = v6;
        }
        else
        {
          switch(v26 - &v29)
          {
            case 0:
              break;
            case 1:
              goto LABEL_24;
            case 2:
              goto LABEL_27;
            case 3:
              goto LABEL_28;
            default:
              goto LABEL_25;
          }
        }
      }
      else
      {
        switch(v26 - &v29)
        {
          case 0:
            break;
          case 1:
LABEL_24:
            v5 = ((1 << v10) + v5);
            v12 = v8 + v8;
            v14 = v6 - (v7 + v8);
            break;
          case 2:
LABEL_27:
            v5 = ((2 << v10) + v5);
            v12 = v8 + v8;
            v13 = v7 - (v8 + v6);
            break;
          case 3:
LABEL_28:
            v5 = ((3 << v10) + v5);
            v12 = v6 + v7 - v8;
            v13 = v8 - v7 + v6;
            v14 = v7 + v8 - v6;
            break;
          default:
            goto LABEL_22;
        }
      }
      --v9;
      v10 -= 2;
      v6 = v14;
      v7 = v13;
      v8 = v12;
    }
    while ((unint64_t)v9 > 1);
  }
  return v5;
}

unint64_t CDelaunayTriangles3D::calculate_triangle_bins(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, void **a5)
{
  uint64_t *v6;
  uint64_t *v7;
  unint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  float64x2_t v14;
  uint64_t v15;
  uint64_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  unsigned int v44;
  uint64_t v45;
  float64x2_t v46;
  float64x2_t v47;
  float64x2_t v48;
  float64x2_t v49;
  unint64_t v50;
  float64x2_t v51;
  unint64_t v52;
  float64x2_t v53;
  float64x2_t *v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  float64x2_t *v58;
  float64x2_t v59;
  float64x2_t v60;
  float64x2_t v61;
  float64x2_t v62;
  float64x2_t v63;
  float64x2_t v64;
  float64x2_t v65;
  float64x2_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  float64x2_t v71;
  float64x2_t v72;
  float64x2_t v73;
  float64x2_t v74;
  float64x2_t v75;
  unint64_t v76;
  float64x2_t v78;
  float64x2_t v79;
  float64x2_t v80;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  float64x2_t v86;
  double v87;
  float64x2_t v88;
  unint64_t v89;
  char *v90;
  char *v91;
  unint64_t v92;
  unint64_t v93;
  _BYTE *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  char *v98;
  char *v99;
  char *v100;
  unint64_t v101;
  char *v102;
  unint64_t v103;
  double *v104;
  uint64_t v105;
  __int128 v106;
  __int128 v107;
  float64_t v108;
  double *v109;
  double *v110;
  char *v111;
  uint64_t v112;
  char *v113;
  uint64_t *v114;
  char *v115;
  uint64_t v116;
  uint64_t *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  char *v121;
  char *v122;
  char *v123;
  uint64_t v124;
  uint64_t v125;
  char *v126;
  char *v127;
  unint64_t v128;
  void **v129;
  uint64_t *v130;
  uint64_t *v131;
  uint64_t *v132;
  uint64_t *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t *v136;
  unint64_t v137;
  double *v138;
  uint64_t v139;
  __int128 v140;
  __int128 v141;
  float64_t v142;
  double *v143;
  double *v144;
  uint64_t v145;
  unsigned int v146;
  unsigned int v147;
  unsigned int v148;
  uint64_t v149;
  int subtriangle_containment;
  uint64_t v151;
  float64x2_t v152;
  int v153;
  uint64_t v154;
  float64x2_t v155;
  float64x2_t v156;
  int v157;
  _DWORD *v158;
  unint64_t v159;
  _DWORD *v160;
  _DWORD *v162;
  _QWORD *v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  _BOOL4 v170;
  _BOOL4 v171;
  BOOL v172;
  char v173;
  char *v174;
  _DWORD *v175;
  char *v176;
  uint64_t v177;
  _QWORD *v178;
  uint64_t v179;
  uint64_t v180;
  _QWORD *v181;
  _DWORD *v182;
  _QWORD *v183;
  int v184;
  char *v185;
  _DWORD *v186;
  char *v187;
  uint64_t v188;
  _QWORD *v189;
  uint64_t v190;
  int v191;
  _QWORD *v192;
  uint64_t v193;
  _QWORD *v194;
  BOOL v195;
  uint64_t v196;
  _QWORD *v197;
  uint64_t v198;
  uint64_t v199;
  _QWORD *v200;
  _QWORD *v201;
  uint64_t v202;
  _QWORD *v203;
  int64x2_t v204;
  int64x2_t v205;
  int64x2_t v206;
  char *v207;
  float64x2_t v208;
  float64x2_t v209;
  int64x2_t v210;
  float64x2_t v211;
  int64x2_t v212;
  int64x2_t v213;
  int8x16_t v214;
  int v215;
  float64x2_t *v216;
  float64x2_t v217;
  float64x2_t v218;
  float64x2_t v219;
  float64x2_t v220;
  float64x2_t v221;
  int64x2_t v222;
  int64x2_t v223;
  int64x2_t v224;
  float64x2_t v225;
  float64x2_t v226;
  float64x2_t v227;
  float64x2_t v228;
  float64x2_t v229;
  int8x16_t v230;
  float64x2_t v231;
  double v232;
  float64x2_t v233;
  float64x2_t v234;
  float64x2_t v235;
  double v236;
  float64x2_t v237;
  float64x2_t v238;
  float64x2_t v239;
  double v240;
  float64x2_t v241;
  float64x2_t v242;
  float64x2_t v243;
  double v244;
  float64x2_t v245;
  float64x2_t v246;
  float64x2_t v247;
  float64x2_t v248;
  double v249;
  float64x2_t v250;
  float64x2_t v251;
  float64x2_t v252;
  double v253;
  float64x2_t v254;
  float64x2_t v255;
  float64x2_t v256;
  double v257;
  float64x2_t v258;
  float64x2_t v259;
  float64x2_t v260;
  double v261;
  float64x2_t v262;
  float64x2_t v263;
  float64x2_t v264;
  double v265;
  int32x2_t v266;
  float64x2_t v267;
  float64x2_t v268;
  float64x2_t v269;
  float64x2_t v270;
  float64x2_t v271;
  float64x2_t v272;
  float64x2_t v273;
  float64x2_t v274;
  float64x2_t v275;
  float64x2_t v276;
  BOOL v277;
  BOOL v278;
  int8x16_t v279;
  int8x16_t v280;
  unint64_t v281;
  int8x16_t v282;
  float64x2_t v283;
  float64x2_t v284;
  float64x2_t v285;
  float64x2_t v286;
  float64x2_t v287;
  double v288;
  float64x2_t v289;
  BOOL v290;
  _DWORD *v292;
  char *v293;
  uint64_t v294;
  _QWORD *v295;
  _DWORD *v296;
  uint64_t v297;
  _QWORD *v298;
  _QWORD *v299;
  _DWORD *v300;
  uint64_t v301;
  _QWORD *v302;
  unsigned int v304;
  int v305;
  int v306;
  int v307;
  unint64_t v308;
  float64x2_t v309;
  unint64_t v310;
  unint64_t v311;
  uint64_t v312;
  int v313;
  unsigned int v314;
  unsigned int v315;
  int v316;
  char *v317;
  void **v322;
  float64x2_t v323;
  float64x2_t v324;
  unint64_t v325;
  float64x2_t v326;
  float64x2_t v327;
  float64x2_t v328;
  float64x2_t v329;
  float64x2_t v330;
  double v331;
  float64x2_t v332;
  double v333;
  int64x2_t v334;
  float64x2_t v335;
  float64x2_t v336;
  int64x2_t v337;
  double v338;
  double v339;
  int64x2_t v340;
  float64x2_t v341;
  double v342;
  float64x2_t v343;
  double v344;
  double v345;
  double v346;
  float64x2_t v347;
  int64x2_t v348;
  float64x2_t v349;
  _DWORD *v350;
  _QWORD *v351;
  uint64_t v352;
  _DWORD *v353;
  _QWORD *v354;
  unint64_t v355;
  _QWORD *v356;
  _QWORD *v357;
  uint64_t v358;
  float64x2x3_t v359;
  float64x2x3_t v360;

  v7 = (uint64_t *)*a5;
  v6 = (uint64_t *)a5[1];
  if (v6 != *a5)
  {
    do
    {
      v25 = v6 - 3;
      if (*(v6 - 1))
      {
        v27 = *(v6 - 3);
        v26 = (uint64_t *)*(v6 - 2);
        v28 = *v26;
        *(_QWORD *)(v28 + 8) = *(_QWORD *)(v27 + 8);
        **(_QWORD **)(v27 + 8) = v28;
        *(v6 - 1) = 0;
        if (v26 != v25)
        {
          do
          {
            v29 = (uint64_t *)v26[1];
            operator delete(v26);
            v26 = v29;
          }
          while (v29 != v25);
        }
      }
      v6 = v25;
    }
    while (v25 != v7);
  }
  v322 = a5;
  a5[1] = v7;
  v8 = ((uint64_t)(a4[1] - *a4) >> 2) / 3uLL;
  v9 = vcvtmd_s64_f64(log((float)v8 * 0.125) * 0.72134752);
  v313 = v9;
  if (v9 >= 6)
    v10 = 6;
  else
    v10 = v9;
  v11 = 2 * (v10 & ~(v10 >> 31));
  v12 = 8 << (2 * (v10 & ~(v10 >> 31)));
  v13 = (char *)operator new(96 << (2 * (v10 & ~(v10 >> 31)) + 3));
  bzero(v13, 96 * (((96 << (2 * (v10 & ~(v10 >> 31)) + 3)) - 96) / 0x60uLL) + 96);
  v15 = 0;
  if (v12 <= 1)
    v16 = 1;
  else
    v16 = v12;
  v18 = *(float64x2_t *)MEMORY[0x1E0C83FD0];
  v17 = *(float64x2_t *)(MEMORY[0x1E0C83FD0] + 16);
  v20 = *(float64x2_t *)(MEMORY[0x1E0C83FD0] + 32);
  v19 = *(float64x2_t *)(MEMORY[0x1E0C83FD0] + 48);
  v22 = *(float64x2_t *)(MEMORY[0x1E0C83FD0] + 64);
  v21 = *(float64x2_t *)(MEMORY[0x1E0C83FD0] + 80);
  v23 = (float64x2_t)vdupq_n_s64(0x416312D000000000uLL);
  v24 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
  v14.f64[0] = 0.0000001;
  do
  {
    v34 = v18;
    __asm { FMOV            V19.2D, #1.0 }
    v349 = _Q19;
    v39 = v17;
    v40 = v20;
    v41 = v19;
    v42 = v22;
    v43 = v21;
    v44 = v15;
    v45 = v10 & ~(v10 >> 31);
    if (v10 >= 1)
    {
      do
      {
        switch(v44 & 3)
        {
          case 2u:
            __asm { FMOV            V27.2D, #0.5 }
            v71 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v34, 1), _Q27, v39);
            v72 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v40, 1), _Q27, v41);
            v73 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(_Q27, v40.f64[0]), (float64x2_t)xmmword_1B66A2960, v40, 1), (float64x2_t)xmmword_1B66A2970, v41.f64[0]);
            v74 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v42, 1), _Q27, v43);
            v75 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(_Q27, v42.f64[0]), (float64x2_t)xmmword_1B66A2960, v42, 1), (float64x2_t)xmmword_1B66A2970, v43.f64[0]);
            v76 = vextq_s8((int8x16_t)v75, (int8x16_t)v75, 8uLL).u64[0];
            v34 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(_Q27, v34.f64[0]), (float64x2_t)xmmword_1B66A2960, v34, 1), (float64x2_t)xmmword_1B66A2970, v39.f64[0]);
            break;
          case 1u:
            __asm { FMOV            V27.2D, #0.5 }
            v78 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v34, _Q27), _Q27, v34, 1), v349, v39);
            v79 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66A2980, v34.f64[0]), (float64x2_t)xmmword_1B66A2970, v34, 1), (float64x2_t)0, v39.f64[0]);
            v72 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v40, _Q27), _Q27, v40, 1), v349, v41);
            v80 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66A2980, v40.f64[0]), (float64x2_t)xmmword_1B66A2970, v40, 1), (float64x2_t)0, v41.f64[0]);
            v74 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v42, _Q27), _Q27, v42, 1), v349, v43);
            v75 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66A2980, v42.f64[0]), (float64x2_t)xmmword_1B66A2970, v42, 1), (float64x2_t)0, v43.f64[0]);
LABEL_31:
            v76 = vextq_s8((int8x16_t)v75, (int8x16_t)v75, 8uLL).u64[0];
            v34 = v79;
            v39 = v78;
            v40 = v80;
            goto LABEL_32;
          case 0u:
            __asm { FMOV            V28.2D, #0.5 }
            v71 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v34, 1), _Q28, v39);
            v72 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v40, 1), _Q28, v41);
            v73 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66271B0, v40.f64[0]), _Q28, v40, 1), (float64x2_t)xmmword_1B66A2980, v41.f64[0]);
            v74 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v42, 1), _Q28, v43);
            v75 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66271B0, v42.f64[0]), _Q28, v42, 1), (float64x2_t)xmmword_1B66A2980, v43.f64[0]);
            v76 = vextq_s8((int8x16_t)v75, (int8x16_t)v75, 8uLL).u64[0];
            v34 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66271B0, v34.f64[0]), _Q28, v34, 1), (float64x2_t)xmmword_1B66A2980, v39.f64[0]);
            break;
          default:
            __asm { FMOV            V27.2D, #0.5 }
            v78 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v34, _Q27), _Q27, v34, 1), (float64x2_t)0, v39);
            v79 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66A2970, v34.f64[0]), (float64x2_t)xmmword_1B66A2980, v34, 1), _Q27, v39.f64[0]);
            v72 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v40, _Q27), _Q27, v40, 1), (float64x2_t)0, v41);
            v80 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66A2970, v40.f64[0]), (float64x2_t)xmmword_1B66A2980, v40, 1), _Q27, v41.f64[0]);
            v74 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v42, _Q27), _Q27, v42, 1), (float64x2_t)0, v43);
            v75 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_1B66A2970, v42.f64[0]), (float64x2_t)xmmword_1B66A2980, v42, 1), _Q27, v43.f64[0]);
            goto LABEL_31;
        }
        v39 = v71;
        v40 = v73;
LABEL_32:
        v41 = v72;
        v83 = vabsq_f64(v39);
        v83.f64[0] = vaddvq_f64(vabsq_f64(v34)) + v83.f64[0];
        if (v83.f64[0] > 0.0)
        {
          v83.f64[0] = 1.0 / v83.f64[0];
          v39 = vmulq_f64(v83, v39);
          *(_QWORD *)&v34.f64[1] = vextq_s8((int8x16_t)v34, (int8x16_t)v34, 8uLL).u64[0];
          v34 = vmulq_n_f64(v34, v83.f64[0]);
        }
        v84 = vabsq_f64(v72);
        v84.f64[0] = vaddvq_f64(vabsq_f64(v40)) + v84.f64[0];
        if (v84.f64[0] > 0.0)
        {
          v84.f64[0] = 1.0 / v84.f64[0];
          v41 = vmulq_f64(v84, v72);
          *(_QWORD *)&v40.f64[1] = vextq_s8((int8x16_t)v40, (int8x16_t)v40, 8uLL).u64[0];
          v40 = vmulq_n_f64(v40, v84.f64[0]);
        }
        v85.f64[0] = v75.f64[0];
        *(_QWORD *)&v85.f64[1] = v76;
        v86 = vabsq_f64(v74);
        v87 = vaddvq_f64(vabsq_f64(v85)) + v86.f64[0];
        if (v87 > 0.0)
        {
          v86.f64[0] = 1.0 / v87;
          v43 = vmulq_f64(v86, v74);
          *(_QWORD *)&v75.f64[1] = v76;
          v42 = vmulq_n_f64(v75, v86.f64[0]);
        }
        else
        {
          *(_QWORD *)&v75.f64[1] = v76;
          v42 = v75;
          v43 = v74;
        }
        v44 >>= 2;
        --v45;
      }
      while (v45);
    }
    v46 = vmulq_f64(v39, v39);
    v46.f64[0] = 1.0 / sqrt(vaddvq_f64(vmulq_f64(v34, v34)) + v46.f64[0]);
    v47 = vmulq_f64(v41, v41);
    v47.f64[0] = 1.0 / sqrt(vaddvq_f64(vmulq_f64(v40, v40)) + v47.f64[0]);
    v48 = vmulq_f64(v43, v43);
    v49 = vmulq_f64(v42, v42);
    v48.f64[0] = 1.0 / sqrt(vaddvq_f64(v49) + v48.f64[0]);
    v49.f64[0] = 10000000.0;
    v50 = *(_OWORD *)&vmulq_f64(v47, vmulq_f64(v41, v49));
    v51 = vmulq_f64(vmulq_n_f64(v40, v47.f64[0]), v23);
    v52 = *(_OWORD *)&vmulq_f64(v48, vmulq_f64(v43, v49));
    v53 = vmulq_f64(vmulq_n_f64(v42, v48.f64[0]), v23);
    v54 = (float64x2_t *)&v13[96 * v15];
    v30 = vrndxq_f64(vmulq_f64(vmulq_n_f64(v34, v46.f64[0]), v23));
    v55 = vrndxq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmulq_f64(v46, vmulq_f64(v39, v49)));
    v56 = vrndxq_f64(v51);
    v57 = vmulq_f64(v56, v24);
    v54[2] = v57;
    v58 = v54 + 2;
    v59 = vrndxq_f64((float64x2_t)v50);
    v60 = vrndxq_f64(v53);
    v61 = vmulq_f64(v60, v24);
    v54[4] = v61;
    v62 = vrndxq_f64((float64x2_t)v52);
    v63 = vmulq_f64(v55, v14);
    v64 = vmulq_f64(v30, v24);
    v65 = vmulq_f64(v59, v14);
    *v54 = v64;
    v54[1] = v63;
    v66 = vmulq_f64(v62, v14);
    v54[3] = v65;
    v54[5] = v66;
    v67 = vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL).u64[0];
    v68 = vextq_s8((int8x16_t)v56, (int8x16_t)v56, 8uLL).u64[0];
    v69 = vextq_s8((int8x16_t)v60, (int8x16_t)v60, 8uLL).u64[0];
    switch(v44 & 7)
    {
      case 0u:
        *v54 = vnegq_f64(v64);
        v54[1] = vnegq_f64(v63);
        v54[2] = vnegq_f64(v57);
        v54[3] = vnegq_f64(v65);
        v54[4] = vnegq_f64(v61);
        v54[5] = vnegq_f64(v66);
        break;
      case 1u:
        *(_QWORD *)&v30.f64[1] = v67;
        v31 = (float64x2_t)vdupq_n_s64(0xBE7AD7F29ABCAF48);
        goto LABEL_15;
      case 2u:
        *(_QWORD *)&v30.f64[1] = v67;
        v88 = (float64x2_t)xmmword_1B66A29A0;
        goto LABEL_40;
      case 3u:
        *(_QWORD *)&v30.f64[1] = v67;
        v31 = (float64x2_t)xmmword_1B66A29A0;
        goto LABEL_15;
      case 4u:
        *(_QWORD *)&v30.f64[1] = v67;
        v88 = (float64x2_t)xmmword_1B66A2990;
LABEL_40:
        v61.f64[0] = -0.0000001;
        *v54 = vmulq_f64(v30, v88);
        v54[1] = vmulq_f64(v55, v61);
        *(_QWORD *)&v56.f64[1] = v68;
        *v58 = vmulq_f64(v56, v88);
        v54[3] = vmulq_f64(v59, v61);
        *(_QWORD *)&v60.f64[1] = v69;
        v32 = vmulq_f64(v60, v88);
        v33 = vmulq_f64(v62, v61);
        goto LABEL_16;
      case 5u:
        *(_QWORD *)&v30.f64[1] = v67;
        v31 = (float64x2_t)xmmword_1B66A2990;
LABEL_15:
        *v54 = vmulq_f64(v30, v31);
        v54[1] = vmulq_f64(v55, v14);
        *(_QWORD *)&v56.f64[1] = v68;
        *v58 = vmulq_f64(v56, v31);
        v54[3] = vmulq_f64(v59, v14);
        *(_QWORD *)&v60.f64[1] = v69;
        v32 = vmulq_f64(v60, v31);
        v33 = vmulq_f64(v62, v14);
        goto LABEL_16;
      case 6u:
        *(_QWORD *)&v30.f64[1] = v67;
        v57.f64[0] = -0.0000001;
        *v54 = vmulq_f64(v30, v24);
        v54[1] = vmulq_f64(v55, v57);
        *(_QWORD *)&v56.f64[1] = v68;
        *v58 = vmulq_f64(v56, v24);
        v54[3] = vmulq_f64(v59, v57);
        *(_QWORD *)&v60.f64[1] = v69;
        v32 = vmulq_f64(v60, v24);
        v33 = vmulq_f64(v62, v57);
LABEL_16:
        v54[4] = v32;
        v54[5] = v33;
        break;
      default:
        break;
    }
    ++v15;
  }
  while (v15 != v16);
  v325 = v10 & ~(v10 >> 31);
  v89 = 0xAAAAAAAAAAAAAAABLL
      * ((uint64_t)(96 * (((96 << (2 * (v10 & ~(v10 >> 31)) + 3)) - 96) / 0x60uLL)
                 + 96) >> 5);
  v91 = (char *)*a5;
  v90 = (char *)v322[1];
  v92 = 0xAAAAAAAAAAAAAAABLL * ((v90 - (_BYTE *)*v322) >> 3);
  v93 = v89 - v92;
  if (v89 > v92)
  {
    v94 = v322[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v94 - v90) >> 3) < v93)
    {
      if (v89 > 0xAAAAAAAAAAAAAAALL)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v95 = 0xAAAAAAAAAAAAAAABLL * ((v94 - v91) >> 3);
      v96 = 2 * v95;
      if (2 * v95 <= v89)
        v96 = v89;
      if (v95 >= 0x555555555555555)
        v97 = 0xAAAAAAAAAAAAAAALL;
      else
        v97 = v96;
      if (v97 > 0xAAAAAAAAAAAAAAALL)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v98 = (char *)operator new(24 * v97);
      v99 = &v98[24 * v92];
      v100 = &v98[24 * v89];
      v101 = 24 * v93 - 24;
      v102 = v99;
      if (v101 >= 0x48)
      {
        v103 = v101 / 0x18 + 1;
        v19 = 0uLL;
        v104 = (double *)&v98[24 * v92];
        v105 = v103 & 0x1FFFFFFFFFFFFFFCLL;
        do
        {
          *(_QWORD *)&v106 = v104;
          *((_QWORD *)&v106 + 1) = v104 + 3;
          v107 = v106;
          *(_QWORD *)&v108 = v104 + 9;
          v109 = v104 + 12;
          vst3q_f64(v104, *(float64x2x3_t *)(&v19 - 2));
          v110 = v104 + 6;
          *(_QWORD *)&v359.val[0].f64[0] = v110;
          v359.val[0].f64[1] = v108;
          v359.val[1] = v359.val[0];
          v359.val[2] = 0uLL;
          vst3q_f64(v110, v359);
          v104 = v109;
          v105 -= 4;
        }
        while (v105);
        if (v103 == (v103 & 0x1FFFFFFFFFFFFFFCLL))
          goto LABEL_59;
        v102 = &v99[24 * (v103 & 0x1FFFFFFFFFFFFFFCLL)];
      }
      do
      {
        *(_QWORD *)v102 = v102;
        *((_QWORD *)v102 + 1) = v102;
        *((_QWORD *)v102 + 2) = 0;
        v102 += 24;
      }
      while (v102 != v100);
LABEL_59:
      v111 = &v98[24 * v97];
      if (v90 != v91)
      {
        v112 = 0;
        do
        {
          v113 = &v99[v112];
          v114 = (uint64_t *)(v113 - 24);
          v115 = &v90[v112];
          *((_QWORD *)v113 - 3) = v113 - 24;
          *((_QWORD *)v113 - 2) = v113 - 24;
          *((_QWORD *)v113 - 1) = 0;
          v116 = *(_QWORD *)&v90[v112 - 8];
          if (v116)
          {
            v118 = *((_QWORD *)v115 - 3);
            v117 = (uint64_t *)*((_QWORD *)v115 - 2);
            v119 = *v117;
            *(_QWORD *)(v119 + 8) = *(_QWORD *)(v118 + 8);
            **(_QWORD **)(v118 + 8) = v119;
            v120 = *v114;
            *(_QWORD *)(v120 + 8) = v117;
            *v117 = v120;
            *v114 = v118;
            *(_QWORD *)(v118 + 8) = v114;
            *((_QWORD *)v113 - 1) = v116;
            *((_QWORD *)v115 - 1) = 0;
          }
          v112 -= 24;
        }
        while (&v90[v112] != v91);
        v99 += v112;
      }
      v131 = (uint64_t *)*v322;
      v130 = (uint64_t *)v322[1];
      *v322 = v99;
      v322[1] = v100;
      v322[2] = v111;
      if (v130 != v131)
      {
        do
        {
          v132 = v130 - 3;
          if (*(v130 - 1))
          {
            v134 = *(v130 - 3);
            v133 = (uint64_t *)*(v130 - 2);
            v135 = *v133;
            *(_QWORD *)(v135 + 8) = *(_QWORD *)(v134 + 8);
            **(_QWORD **)(v134 + 8) = v135;
            *(v130 - 1) = 0;
            if (v133 != v132)
            {
              do
              {
                v136 = (uint64_t *)v133[1];
                operator delete(v133);
                v133 = v136;
              }
              while (v136 != v132);
            }
          }
          v130 = v132;
        }
        while (v132 != v131);
      }
      if (v131)
        operator delete(v131);
LABEL_79:
      if (!(_DWORD)v8)
        goto LABEL_194;
      goto LABEL_92;
    }
    v127 = &v90[24 * v93];
    v128 = 24 * v93 - 24;
    if (v128 >= 0x48)
    {
      v137 = v128 / 0x18 + 1;
      v19 = 0uLL;
      v138 = (double *)v322[1];
      v139 = v137 & 0x1FFFFFFFFFFFFFFCLL;
      v129 = v322;
      do
      {
        *(_QWORD *)&v140 = v138;
        *((_QWORD *)&v140 + 1) = v138 + 3;
        v141 = v140;
        *(_QWORD *)&v142 = v138 + 9;
        v143 = v138 + 12;
        vst3q_f64(v138, *(float64x2x3_t *)(&v19 - 2));
        v144 = v138 + 6;
        *(_QWORD *)&v360.val[0].f64[0] = v144;
        v360.val[0].f64[1] = v142;
        v360.val[1] = v360.val[0];
        v360.val[2] = 0uLL;
        vst3q_f64(v144, v360);
        v138 = v143;
        v139 -= 4;
      }
      while (v139);
      if (v137 == (v137 & 0x1FFFFFFFFFFFFFFCLL))
      {
LABEL_91:
        v129[1] = v127;
        if ((_DWORD)v8)
          goto LABEL_92;
        goto LABEL_194;
      }
      v90 += 24 * (v137 & 0x1FFFFFFFFFFFFFFCLL);
    }
    else
    {
      v129 = v322;
    }
    do
    {
      *(_QWORD *)v90 = v90;
      *((_QWORD *)v90 + 1) = v90;
      *((_QWORD *)v90 + 2) = 0;
      v90 += 24;
    }
    while (v90 != v127);
    goto LABEL_91;
  }
  if (v89 >= v92)
    goto LABEL_79;
  v121 = &v91[24 * v89];
  if (v90 != v121)
  {
    do
    {
      v122 = v90 - 24;
      if (*((_QWORD *)v90 - 1))
      {
        v124 = *((_QWORD *)v90 - 3);
        v123 = (char *)*((_QWORD *)v90 - 2);
        v125 = *(_QWORD *)v123;
        *(_QWORD *)(v125 + 8) = *(_QWORD *)(v124 + 8);
        **(_QWORD **)(v124 + 8) = v125;
        *((_QWORD *)v90 - 1) = 0;
        if (v123 != v122)
        {
          do
          {
            v126 = (char *)*((_QWORD *)v123 + 1);
            operator delete(v123);
            v123 = v126;
          }
          while (v126 != v122);
        }
      }
      v90 = v122;
    }
    while (v122 != v121);
  }
  v322[1] = v121;
  if ((_DWORD)v8)
  {
LABEL_92:
    v145 = 0;
    v314 = ~(-1 << v11);
    v315 = ((7 << v11) >> 2) | (7 << v11);
    v307 = (7 << v11) | (v315 >> 2);
    v146 = ((7 << v11) >> 2) | v307;
    v147 = v146 >> 2;
    v148 = (v146 >> 2) | v146;
    v304 = (7 << v11) | (((v148 >> 2) | v148) >> 2);
    v306 = v147 | (7 << v11);
    v305 = (v148 >> 2) | (7 << v11);
    v316 = v89 - 1;
    v317 = v13;
    while (1)
    {
      v149 = 8 * *(int *)(*a4 + 12 * v145);
      v19.f64[0] = *(float64_t *)(a3 + v149);
      v339 = *(double *)(a1 + v149);
      v346 = *(double *)(a2 + v149);
      v347 = v19;
      subtriangle_containment = CDelaunayTriangles3D::find_subtriangle_containment(v325, v339, v346, v19.f64[0]);
      v151 = 8 * *(int *)(12 * v145 + *a4 + 4);
      v152.f64[0] = *(float64_t *)(a3 + v151);
      v333 = *(double *)(a1 + v151);
      v344 = *(double *)(a2 + v151);
      v332 = v152;
      v153 = CDelaunayTriangles3D::find_subtriangle_containment(v325, v333, v344, v152.f64[0]);
      v154 = 8 * *(int *)(12 * v145 + *a4 + 8);
      v155.f64[0] = *(float64_t *)(a1 + v154);
      v156.f64[0] = *(float64_t *)(a3 + v154);
      v324 = v155;
      v342 = *(double *)(a2 + v154);
      v323 = v156;
      v157 = CDelaunayTriangles3D::find_subtriangle_containment(v325, v155.f64[0], v342, v156.f64[0]);
      v353 = &v353;
      v354 = &v353;
      v355 = 0;
      v158 = operator new(0x18uLL);
      v158[4] = subtriangle_containment;
      *(_QWORD *)v158 = &v353;
      *((_QWORD *)v158 + 1) = &v353;
      v353 = v158;
      v354 = v158;
      v159 = 1;
      v160 = v158;
      v355 = 1;
      if (v153 != subtriangle_containment)
      {
        v160 = operator new(0x18uLL);
        v160[4] = v153;
        *(_QWORD *)v160 = v158;
        *((_QWORD *)v160 + 1) = &v353;
        *((_QWORD *)v158 + 1) = v160;
        v159 = 2;
        v353 = v160;
        v355 = 2;
      }
      if (v157 != subtriangle_containment && v157 != v153)
      {
        v162 = operator new(0x18uLL);
        v162[4] = v157;
        *(_QWORD *)v162 = v160;
        *((_QWORD *)v162 + 1) = &v353;
        *((_QWORD *)v160 + 1) = v162;
        ++v159;
        v353 = v162;
        v355 = v159;
      }
      std::list<int>::__sort<std::__less<void,void>>((uint64_t)v158, (uint64_t)&v353, v159);
      v163 = v354;
      v164 = *((_DWORD *)v354 + 4);
      v13 = v317;
      if (v355 >= 2)
        break;
      v174 = (char *)*v322;
      v175 = operator new(0x18uLL);
      v176 = &v174[24 * v164];
      v175[4] = v145;
      *((_QWORD *)v175 + 1) = v176;
      v177 = *(_QWORD *)v176;
      *(_QWORD *)v175 = *(_QWORD *)v176;
      *(_QWORD *)(v177 + 8) = v175;
      *(_QWORD *)v176 = v175;
      ++*((_QWORD *)v176 + 2);
LABEL_190:
      if (v355)
      {
        v300 = v353;
        v299 = v354;
        v301 = *v354;
        *(_QWORD *)(v301 + 8) = *((_QWORD *)v353 + 1);
        **((_QWORD **)v300 + 1) = v301;
        v355 = 0;
        if (v299 != &v353)
        {
          do
          {
            v302 = (_QWORD *)v299[1];
            operator delete(v299);
            v299 = v302;
          }
          while (v302 != &v353);
        }
      }
      if (++v145 == v8)
        goto LABEL_194;
    }
    v165 = 0;
    v166 = v353[4] ^ v164;
    if (((7 << v11) & v166) != 0)
    {
      v167 = v316;
    }
    else
    {
      v167 = v316;
      if (v313 >= 1)
      {
        v168 = ~(-1 << v11);
        v169 = 7 << v11;
        if ((v315 & v166) == 0)
        {
          v168 = ~(-1 << v11);
          v169 = 7 << v11;
          if (v325 >= 2)
          {
            v168 = v314 >> 2;
            v169 = ((7 << v11) >> 2) | (7 << v11);
            if ((v307 & v166) == 0)
            {
              v168 = v314 >> 2;
              v169 = ((7 << v11) >> 2) | (7 << v11);
              if (v325 >= 3)
              {
                v168 = v314 >> 4;
                v169 = (7 << v11) | (v315 >> 2);
                if ((v306 & v166) == 0)
                {
                  v168 = v314 >> 4;
                  v169 = (7 << v11) | (v315 >> 2);
                  if (v325 >= 4)
                  {
                    v168 = v314 >> 6;
                    v169 = v306;
                    if ((v305 & v166) == 0)
                    {
                      v168 = v314 >> 6;
                      v169 = v306;
                      if (v325 >= 5)
                      {
                        v170 = v325 > 5;
                        v169 = v304;
                        v171 = (v304 & v166) == 0;
                        v172 = !v171 || !v170;
                        v173 = v171 && v170 ? 10 : 8;
                        v168 = v314 >> v173;
                        if (v172)
                          v169 = v305;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v165 = v169 & v164;
        v167 = v168 | v164;
      }
    }
    v178 = &v350;
    v350 = &v350;
    v351 = &v350;
    v352 = 0;
    if (v167 - v165 != -1)
    {
      v179 = 0;
      v180 = v167 - v165 + 1;
      v181 = &v350;
      do
      {
        v182 = operator new(0x18uLL);
        v182[4] = 0;
        *(_QWORD *)v182 = v181;
        *((_QWORD *)v182 + 1) = &v350;
        v181[1] = v182;
        ++v179;
        v181 = v182;
        v350 = v182;
        v352 = v179;
      }
      while (v180 != v179);
      v178 = v351;
      if (v351 == &v350)
      {
        v178 = &v350;
      }
      else
      {
        v183 = v351;
        do
        {
          *((_DWORD *)v183 + 4) = v165;
          v183 = (_QWORD *)v183[1];
          ++v165;
        }
        while (v183 != &v350);
      }
    }
    if (v163 == &v353)
    {
      if (v178 == &v350)
      {
LABEL_187:
        if (v352)
        {
          v296 = v350;
          v295 = v351;
          v297 = *v351;
          *(_QWORD *)(v297 + 8) = *((_QWORD *)v350 + 1);
          **((_QWORD **)v296 + 1) = v297;
          v352 = 0;
          if (v295 != &v350)
          {
            do
            {
              v298 = (_QWORD *)v295[1];
              operator delete(v295);
              v295 = v298;
            }
            while (v298 != &v350);
          }
        }
        goto LABEL_190;
      }
    }
    else
    {
      do
      {
        v184 = *((_DWORD *)v163 + 4);
        v185 = (char *)*v322;
        v186 = operator new(0x18uLL);
        v187 = &v185[24 * v184];
        v186[4] = v145;
        *((_QWORD *)v186 + 1) = v187;
        v188 = *(_QWORD *)v187;
        *(_QWORD *)v186 = *(_QWORD *)v187;
        *(_QWORD *)(v188 + 8) = v186;
        *(_QWORD *)v187 = v186;
        ++*((_QWORD *)v187 + 2);
        v356 = &v356;
        v357 = &v356;
        v189 = v351;
        if (v351 != &v350)
        {
          v190 = 0;
          v358 = 0;
          v191 = *((_DWORD *)v163 + 4);
          v192 = &v356;
          v193 = v352;
          do
          {
            v194 = (_QWORD *)v189[1];
            if (*((_DWORD *)v189 + 4) == v191)
            {
              while (v194 != &v350)
              {
                v195 = *((_DWORD *)v194 + 4) == v191;
                if (*((_DWORD *)v194 + 4) != v191)
                  goto LABEL_141;
                v194 = (_QWORD *)v194[1];
              }
              v195 = 1;
              v194 = &v350;
LABEL_141:
              if (v189 != v194)
              {
                v192 = (_QWORD *)*v194;
                if ((_QWORD *)*v194 == v189)
                {
                  v198 = 1;
                }
                else
                {
                  v196 = -1;
                  v197 = v189;
                  do
                  {
                    v197 = (_QWORD *)v197[1];
                    ++v196;
                  }
                  while (v197 != v192);
                  v198 = v196 + 2;
                }
                v193 -= v198;
                v352 = v193;
                v190 += v198;
                v199 = *v189;
                *(_QWORD *)(v199 + 8) = v192[1];
                *(_QWORD *)v192[1] = v199;
                v200 = v356;
                v356[1] = v189;
                *v189 = v200;
                v356 = v192;
                v192[1] = &v356;
              }
              if (!v195)
                v194 = (_QWORD *)v194[1];
            }
            v189 = v194;
          }
          while (v194 != &v350);
          if (v190)
          {
            v201 = v357;
            v202 = *v357;
            *(_QWORD *)(v202 + 8) = v192[1];
            *(_QWORD *)v192[1] = v202;
            if (v201 != &v356)
            {
              do
              {
                v203 = (_QWORD *)v201[1];
                operator delete(v201);
                v201 = v203;
              }
              while (v203 != &v356);
            }
          }
        }
        v163 = (_QWORD *)v163[1];
      }
      while (v163 != &v353);
      v178 = v351;
      if (v351 == &v350)
        goto LABEL_187;
    }
    *(double *)v204.i64 = v339;
    *(double *)&v204.i64[1] = v346;
    *(double *)v205.i64 = v333;
    *(double *)&v205.i64[1] = v344;
    v206.i64[0] = *(_QWORD *)&v324.f64[0];
    *(double *)&v206.i64[1] = v342;
    v207 = (char *)*v322;
    v208.f64[0] = v347.f64[0];
    v208.f64[1] = v339;
    v209.f64[0] = v332.f64[0];
    v209.f64[1] = v333;
    v210 = (int64x2_t)vmlaq_f64(vnegq_f64(vmulq_f64(v209, (float64x2_t)v204)), v208, (float64x2_t)v205);
    *(_QWORD *)&v345 = *(_OWORD *)&vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v347, (float64x2_t)v205, 1)), v332, (float64x2_t)v204, 1);
    v343 = (float64x2_t)vdupq_lane_s64(v210.i64[0], 0);
    v341 = (float64x2_t)vdupq_laneq_s64(v210, 1);
    v211.f64[0] = v323.f64[0];
    v211.f64[1] = v324.f64[0];
    v212 = (int64x2_t)vmlaq_f64(vnegq_f64(vmulq_f64(v211, (float64x2_t)v205)), v209, (float64x2_t)v206);
    *(_QWORD *)&v338 = *(_OWORD *)&vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v332, (float64x2_t)v206, 1)), v323, (float64x2_t)v205, 1);
    v336 = (float64x2_t)vdupq_lane_s64(v212.i64[0], 0);
    v334 = v205;
    v335 = (float64x2_t)vdupq_laneq_s64(v212, 1);
    v213 = (int64x2_t)vmlaq_f64(vnegq_f64(vmulq_f64(v211, (float64x2_t)v204)), v208, (float64x2_t)v206);
    v214 = (int8x16_t)vzip1q_s64((int64x2_t)v347, (int64x2_t)v332);
    *(_QWORD *)&v331 = *(_OWORD *)&vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v347, (float64x2_t)v206, 1)), v323, (float64x2_t)v204, 1);
    v329 = (float64x2_t)vdupq_laneq_s64(v213, 1);
    v330 = (float64x2_t)vdupq_lane_s64(v213.i64[0], 0);
    v340 = v204;
    v337 = (int64x2_t)*(unint64_t *)&v347.f64[0];
    v326 = (float64x2_t)vzip1q_s64((int64x2_t)*(unint64_t *)&v347.f64[0], (int64x2_t)*(unint64_t *)&v332.f64[0]);
    v327 = (float64x2_t)vzip2q_s64(v204, v205);
    v328 = (float64x2_t)vzip1q_s64(v204, v205);
    v310 = vextq_s8((int8x16_t)v327, (int8x16_t)v327, 8uLL).u64[0];
    v311 = vextq_s8((int8x16_t)v328, (int8x16_t)v328, 8uLL).u64[0];
    v348 = v206;
    v312 = v214.i64[0];
    v308 = vextq_s8(v214, v214, 8uLL).u64[0];
    v309 = (float64x2_t)vextq_s8((int8x16_t)v206, (int8x16_t)v206, 8uLL);
    do
    {
      v215 = *((_DWORD *)v178 + 4);
      v216 = (float64x2_t *)&v317[96 * v215];
      v217 = *v216;
      v19 = v216[1];
      v219 = v216[2];
      v218 = v216[3];
      v221 = v216[4];
      v220 = v216[5];
      v222 = (int64x2_t)*(unint64_t *)&v216[1].f64[0];
      v223 = (int64x2_t)*(unint64_t *)&v216[3].f64[0];
      v224 = (int64x2_t)*(unint64_t *)&v216[5].f64[0];
      v225 = (float64x2_t)vzip1q_s64(*(int64x2_t *)v216, (int64x2_t)v219);
      v226 = (float64x2_t)vzip2q_s64(*(int64x2_t *)v216, (int64x2_t)v219);
      v227 = (float64x2_t)vzip1q_s64((int64x2_t)v222.u64[0], (int64x2_t)v223.u64[0]);
      v228 = vmlaq_f64(vmlaq_f64(vmulq_n_f64(v225, v345), v343, v226), v341, v227);
      v229 = vmlaq_f64(vmlaq_f64(vmulq_n_f64((float64x2_t)vzip1q_s64((int64x2_t)v221, v348), v345), v343, (float64x2_t)vzip2q_s64((int64x2_t)v221, v348)), v341, (float64x2_t)vzip1q_s64((int64x2_t)v224.u64[0], (int64x2_t)*(unint64_t *)&v323.f64[0]));
      v230 = (int8x16_t)vdupq_n_s64(0x8000000000000000);
      v231 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v229, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v229));
      v232 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v228, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v228)))+ v231.f64[0];
      v231.f64[0] = v232;
      *(int8x8_t *)&v231.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v231)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v231)));
      if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v231.f64[0], vdup_lane_s32(*(int32x2_t *)&v231.f64[0], 1))).u8[0] & 1) == 0
        || fabs(v232) != 3.0)
      {
        v233 = vmlaq_f64(vmlaq_f64(vmulq_n_f64((float64x2_t)vzip1q_s64((int64x2_t)v221, v340), v338), v336, (float64x2_t)vzip2q_s64((int64x2_t)v221, v340)), v335, (float64x2_t)vzip1q_s64(v224, v337));
        v234 = vmlaq_f64(vmlaq_f64(vmulq_n_f64(v225, v338), v336, v226), v335, v227);
        v235 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v233, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v233));
        v236 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v234, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v234)))+ v235.f64[0];
        v235.f64[0] = v236;
        *(int8x8_t *)&v235.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v235)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v235)));
        if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v235.f64[0], vdup_lane_s32(*(int32x2_t *)&v235.f64[0], 1))).u8[0] & 1) == 0
          || fabs(v236) != 3.0)
        {
          v237 = vmlaq_f64(vmlaq_f64(vmulq_n_f64((float64x2_t)vzip1q_s64((int64x2_t)v221, v334), v331), v330, (float64x2_t)vzip2q_s64((int64x2_t)v221, v334)), v329, (float64x2_t)vzip1q_s64(v224, (int64x2_t)*(unint64_t *)&v332.f64[0]));
          v238 = vmlaq_f64(vmlaq_f64(vmulq_n_f64(v225, v331), v330, v226), v329, v227);
          v239 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v237, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v237));
          v240 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v238, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v238)))+ v239.f64[0];
          v239.f64[0] = v240;
          *(int8x8_t *)&v239.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v239)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v239)));
          if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v239.f64[0], vdup_lane_s32(*(int32x2_t *)&v239.f64[0], 1))).u8[0] & 1) == 0
            || fabs(v240) != 3.0)
          {
            v241.f64[0] = v216[1].f64[0];
            v241.f64[1] = v216->f64[0];
            v242.f64[0] = v216[3].f64[0];
            v242.f64[1] = v216[2].f64[0];
            v243 = vmlaq_f64(vnegq_f64(vmulq_f64(v242, v217)), v241, v219);
            *(_QWORD *)&v244 = *(_OWORD *)&vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v19, v219, 1)), v218, v217, 1);
            v245 = vmulq_n_f64((float64x2_t)vzip1q_s64(v348, (int64x2_t)v221), v244);
            v246 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64(v328, v244), v327, v243.f64[0]), v326, v243, 1);
            v247 = vmlaq_laneq_f64(vmlaq_n_f64(v245, (float64x2_t)vzip2q_s64(v348, (int64x2_t)v221), v243.f64[0]), (float64x2_t)vzip1q_s64((int64x2_t)*(unint64_t *)&v323.f64[0], v224), v243, 1);
            v248 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v247, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v247));
            v249 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v246, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v246)))+ v248.f64[0];
            v248.f64[0] = v249;
            *(int8x8_t *)&v246.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v248)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v248)));
            if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v246.f64[0], vdup_lane_s32(*(int32x2_t *)&v246.f64[0], 1))).u8[0] & 1) == 0
              || fabs(v249) != 3.0)
            {
              *(_QWORD *)&v242.f64[1] = vextq_s8((int8x16_t)v242, (int8x16_t)v242, 8uLL).u64[0];
              v250.f64[0] = v216[5].f64[0];
              v250.f64[1] = v216[4].f64[0];
              v251.f64[0] = v216[2].f64[0];
              *(_QWORD *)&v251.f64[1] = vextq_s8((int8x16_t)v219, (int8x16_t)v219, 8uLL).u64[0];
              v252 = vmlaq_f64(vnegq_f64(vmulq_f64(v250, v251)), v242, v221);
              *(_QWORD *)&v253 = *(_OWORD *)&vmlaq_f64(vnegq_f64(vmulq_laneq_f64(v218, v221, 1)), (float64x2_t)vdupq_laneq_s64((int64x2_t)v219, 1), v220);
              v254 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64(v328, v253), v327, v252.f64[0]), v326, v252, 1);
              v255 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64((float64x2_t)vzip1q_s64(v348, (int64x2_t)v217), v253), (float64x2_t)vzip2q_s64(v348, (int64x2_t)v217), v252.f64[0]), (float64x2_t)vzip1q_s64((int64x2_t)*(unint64_t *)&v323.f64[0], v222), v252, 1);
              v256 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v255, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v255));
              v257 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v254, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v254)))+ v256.f64[0];
              v256.f64[0] = v257;
              *(int8x8_t *)&v256.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v256)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v256)));
              if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v256.f64[0], vdup_lane_s32(*(int32x2_t *)&v256.f64[0], 1))).u8[0] & 1) == 0
                || fabs(v257) != 3.0)
              {
                v258.f64[0] = v216[4].f64[0];
                *(_QWORD *)&v258.f64[1] = vextq_s8((int8x16_t)v221, (int8x16_t)v221, 8uLL).u64[0];
                *(_QWORD *)&v241.f64[1] = vextq_s8((int8x16_t)v241, (int8x16_t)v241, 8uLL).u64[0];
                v259.f64[0] = v216->f64[0];
                *(_QWORD *)&v259.f64[1] = vextq_s8((int8x16_t)v217, (int8x16_t)v217, 8uLL).u64[0];
                *(_QWORD *)&v250.f64[1] = vextq_s8((int8x16_t)v250, (int8x16_t)v250, 8uLL).u64[0];
                v260 = vmlaq_f64(vnegq_f64(vmulq_f64(v250, v259)), v241, v258);
                *(_QWORD *)&v261 = *(_OWORD *)&vmlaq_f64(vnegq_f64(vmulq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v221, 1), v19)), (float64x2_t)vdupq_laneq_s64((int64x2_t)v217, 1), v220);
                v262 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64(v328, v261), v327, v260.f64[0]), v326, v260, 1);
                v263 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64((float64x2_t)vzip1q_s64(v348, (int64x2_t)v219), v261), (float64x2_t)vzip2q_s64(v348, (int64x2_t)v219), v260.f64[0]), (float64x2_t)vzip1q_s64((int64x2_t)*(unint64_t *)&v323.f64[0], v223), v260, 1);
                v264 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v263, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v263));
                v265 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v262, v230), (int8x16_t)v349), (int8x16_t)vceqzq_f64(v262)))+ v264.f64[0];
                v264.f64[0] = v265;
                v266 = (int32x2_t)vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v264)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v264)));
                if ((vmvn_s8((int8x8_t)vceq_s32(v266, vdup_lane_s32(v266, 1))).u8[0] & 1) == 0 || fabs(v265) != 3.0)
                {
                  v267 = vsubq_f64(v219, v217);
                  v268 = vsubq_f64(v218, v19);
                  v269 = vsubq_f64(v221, v217);
                  v270 = vsubq_f64(v220, v19);
                  v271 = vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v268, v269, 1)), v270, v267, 1);
                  v270.f64[1] = v269.f64[0];
                  v268.f64[1] = v267.f64[0];
                  v272 = vmlaq_f64(vnegq_f64(vmulq_f64(v270, v267)), v268, v269);
                  v273 = vmulq_f64(v272, v272);
                  if (vmulq_f64(v271, v271).f64[0] + v273.f64[0] + v273.f64[1] <= 0.000001)
                    goto LABEL_186;
                  v274 = (float64x2_t)vextq_s8((int8x16_t)v272, (int8x16_t)v272, 8uLL);
                  v275.f64[0] = v271.f64[0];
                  v275.f64[1] = v272.f64[0];
                  v276 = vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v225, v271.f64[0]), v226, v272.f64[0]), (float64x2_t)vzip1q_s64((int64x2_t)v19, (int64x2_t)v218), v274.f64[0]);
                  v277 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v221, v271), v272, v221, 1), v274, v220).f64[0] < -0.00000011920929
                      && v276.f64[1] < -0.00000011920929;
                  v278 = v277 && v276.f64[0] < -0.00000011920929;
                  v279 = (int8x16_t)vnegq_f64(v275);
                  v280 = (int8x16_t)vnegq_f64(v274);
                  v281 = v278 ? -1 : 0;
                  v282 = (int8x16_t)vdupq_n_s64(v281);
                  v19 = (float64x2_t)vbslq_s8(v282, v280, (int8x16_t)v274);
                  v283 = (float64x2_t)vbslq_s8(v282, v279, (int8x16_t)v275);
                  v284.f64[0] = v328.f64[0];
                  *(_QWORD *)&v284.f64[1] = v311;
                  v285.f64[0] = v327.f64[0];
                  *(_QWORD *)&v285.f64[1] = v310;
                  v286 = vmlaq_laneq_f64(vmulq_n_f64(v284, v283.f64[0]), v285, v283, 1);
                  v287 = vmlaq_laneq_f64(vmulq_f64(v283, v324), v309, v283, 1);
                  *(_QWORD *)&v283.f64[0] = v312;
                  *(_QWORD *)&v283.f64[1] = v308;
                  *(_QWORD *)&v288 = *(_OWORD *)&vmlaq_f64(v287, v19, v323);
                  v289 = vmlaq_n_f64(v286, v283, v19.f64[0]);
                  v290 = v289.f64[0] < -0.00000011920929 && v289.f64[1] < -0.00000011920929;
                  if (!v290 || v288 >= -0.00000011920929)
                  {
LABEL_186:
                    v292 = operator new(0x18uLL);
                    v293 = &v207[24 * v215];
                    v292[4] = v145;
                    *((_QWORD *)v292 + 1) = v293;
                    v294 = *(_QWORD *)v293;
                    *(_QWORD *)v292 = *(_QWORD *)v293;
                    *(_QWORD *)(v294 + 8) = v292;
                    *(_QWORD *)v293 = v292;
                    ++*((_QWORD *)v293 + 2);
                  }
                }
              }
            }
          }
        }
      }
      v178 = (_QWORD *)v178[1];
    }
    while (v178 != &v350);
    goto LABEL_187;
  }
LABEL_194:
  operator delete(v13);
  return v325;
}

void sub_1B65A1B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  void *v27;

  operator delete(v27);
  _Unwind_Resume(a1);
}

uint64_t std::list<int>::__sort<std::__less<void,void>>(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;

  if (a3 < 2)
    return result;
  if (a3 == 2)
  {
    v4 = *(uint64_t **)a2;
    if (*(_DWORD *)(*(_QWORD *)a2 + 16) < *(_DWORD *)(result + 16))
    {
      v5 = *v4;
      *(_QWORD *)(v5 + 8) = v4[1];
      *(_QWORD *)v4[1] = v5;
      v6 = *(_QWORD *)result;
      *(_QWORD *)(v6 + 8) = v4;
      *v4 = v6;
      *(_QWORD *)result = v4;
      v4[1] = result;
      return (uint64_t)v4;
    }
    return result;
  }
  v8 = a3 >> 1;
  v9 = (a3 >> 1) + 1;
  v10 = result;
  do
  {
    v10 = *(_QWORD *)(v10 + 8);
    --v9;
  }
  while (v9 > 1);
  v11 = std::list<int>::__sort<std::__less<void,void>>(result, v10, a3 >> 1);
  result = std::list<int>::__sort<std::__less<void,void>>(v10, a2, a3 - v8);
  v12 = *(_DWORD *)(v11 + 16);
  if (*(_DWORD *)(result + 16) >= v12)
  {
    v16 = *(uint64_t **)(v11 + 8);
    v13 = result;
    result = v11;
    if (v16 == (uint64_t *)v13)
      return result;
    goto LABEL_15;
  }
  v13 = *(_QWORD *)(result + 8);
  if (v13 == a2)
  {
LABEL_11:
    v13 = a2;
  }
  else
  {
    while (*(_DWORD *)(v13 + 16) < v12)
    {
      v13 = *(_QWORD *)(v13 + 8);
      if (v13 == a2)
        goto LABEL_11;
    }
  }
  v14 = *(_QWORD *)v13;
  v15 = *(_QWORD *)result;
  *(_QWORD *)(v15 + 8) = *(_QWORD *)(*(_QWORD *)v13 + 8);
  **(_QWORD **)(v14 + 8) = v15;
  v17 = *(_QWORD *)v11;
  v16 = *(uint64_t **)(v11 + 8);
  *(_QWORD *)(v17 + 8) = result;
  *(_QWORD *)result = v17;
  *(_QWORD *)v11 = v14;
  *(_QWORD *)(v14 + 8) = v11;
  if (v16 != (uint64_t *)v13)
  {
LABEL_15:
    if (v13 != a2)
    {
      v18 = v13;
      do
      {
        v19 = *((_DWORD *)v16 + 4);
        if (*(_DWORD *)(v13 + 16) >= v19)
        {
          v16 = (uint64_t *)v16[1];
          if (v16 == (uint64_t *)v18)
            return result;
        }
        else
        {
          v20 = *(_QWORD *)(v13 + 8);
          if (v20 == a2)
          {
LABEL_21:
            v20 = a2;
          }
          else
          {
            while (*(_DWORD *)(v20 + 16) < v19)
            {
              v20 = *(_QWORD *)(v20 + 8);
              if (v20 == a2)
                goto LABEL_21;
            }
          }
          v21 = *(_QWORD *)v20;
          v22 = *(_QWORD *)v13;
          *(_QWORD *)(v22 + 8) = *(_QWORD *)(*(_QWORD *)v20 + 8);
          **(_QWORD **)(v21 + 8) = v22;
          if (v18 == v13)
            v18 = v20;
          v24 = *v16;
          v23 = (uint64_t *)v16[1];
          *(_QWORD *)(v24 + 8) = v13;
          *(_QWORD *)v13 = v24;
          *v16 = v21;
          *(_QWORD *)(v21 + 8) = v16;
          v16 = v23;
          v13 = v20;
          if (v23 == (uint64_t *)v18)
            return result;
        }
      }
      while (v13 != a2);
    }
  }
  return result;
}

void SoundActivityDetector::~SoundActivityDetector(SoundActivityDetector *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1E69ED658;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1E69ED658;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t VoiceActivityDetector::VADProcess<float>(VoiceActivityDetector *a1, const float *a2, unsigned int a3, int a4)
{
  vDSP_Length v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  float *v12;
  int v13;
  _BYTE v15[4];
  float __B;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v8 = a3;
  MEMORY[0x1E0C80A78](a1);
  v10 = (unint64_t)&v15[-v9];
  bzero(&v15[-v9], v11);
  v12 = (float *)((v10 & 0xFFFFFFFFFFFFFFF3) + 16);
  __B = 32768.0;
  vDSP_vsmul(a2, 1, &__B, v12, 1, v8);
  if (a3 < 0x140)
    return 0;
  if (!a4)
    return 1;
  v13 = 0;
  do
  {
    v13 |= VoiceActivityDetector::SpxVADProcess(a1, v12);
    --a4;
  }
  while (a4);
  return v13 ^ 1u;
}

unsigned __int8 *PowerMeter::Process(unsigned __int8 *this, const float *a2, int a3)
{
  double *v5;
  double v6;
  double v7;
  double v8;
  float v9;
  int v10;
  float32x4_t v11;
  int v12;
  float32x4_t v13;
  int v14;
  uint64_t v15;
  float32x4_t v16;
  const float *v17;
  float32x4_t v18;
  float32x4_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  int8x16_t v23;
  uint64_t v24;
  uint64_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  int8x16_t v30;
  unsigned int v31;
  float v32;
  float v33;
  float v34;
  int v35;
  float64x2_t v36;
  double v37;
  int v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v46;
  float64x2_t v47;
  int8x16_t v48;
  uint64_t v49;
  uint64_t v50;
  int8x16_t v51;
  double v52;
  double v54;

  v5 = (double *)this;
  if (*((_DWORD *)this + 12) != a3)
  {
    if (*((double *)this + 1) == 0.0)
    {
      *(_OWORD *)(this + 8) = xmmword_1B66A29B0;
      *((_QWORD *)this + 4) = 0x3FEFFEF71A09F35FLL;
    }
    __powidf2();
    v5[3] = 1.0 - v6;
    this = (unsigned __int8 *)__powidf2();
    v5[5] = 1.0 - v7;
    *((_DWORD *)v5 + 12) = a3;
  }
  v8 = v5[8];
  if ((gCAVectorUnitType & 1) == 0)
  {
    this = (unsigned __int8 *)getenv("CA_NoVector");
    if (this)
    {
      this = (unsigned __int8 *)fwrite("CA_NoVector set; Vector unit optimized routines will be bypassed\n",
                                  0x41uLL,
                                  1uLL,
                                  (FILE *)*MEMORY[0x1E0C80C10]);
      v9 = 0.0;
      goto LABEL_10;
    }
    gCAVectorUnitType = 1;
  }
  v9 = 0.0;
  if ((a2 & 0xF) != 0)
  {
LABEL_10:
    v10 = a3;
    if (a3 < 1)
      goto LABEL_38;
    goto LABEL_34;
  }
  v11 = *(float32x4_t *)(v5 + 10);
  v12 = a3 + 3;
  v13 = 0uLL;
  if ((a3 + 3) >= 7)
  {
    if (a3 >= 0)
      v12 = a3;
    v14 = v12 >> 2;
    v15 = (v14 - 1);
    v16 = (float32x4_t)vdupq_n_s32(0x3DEAEB81u);
    v17 = a2;
    do
    {
      v18 = *(float32x4_t *)v17;
      v17 += 4;
      v13 = vmaxq_f32(v13, vabsq_f32(v18));
      v11 = vmlaq_f32(v11, v16, vmlaq_f32(vnegq_f32(v11), v18, v18));
      --v14;
    }
    while (v14);
    a2 += 4 * v15 + 4;
  }
  v9 = fmaxf(v13.f32[3], fmaxf(v13.f32[2], fmaxf(v13.f32[1], v13.f32[0])));
  v8 = vaddq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1), v11), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3))).f32[0]* 0.25;
  v19 = vabsq_f32(v11);
  v20 = vcvt_hight_f64_f32(v19);
  v21 = vcvtq_f64_f32(*(float32x2_t *)v19.f32);
  v22 = (float64x2_t)vdupq_n_s64(0x3CD203AF9EE75616uLL);
  v23 = (int8x16_t)vcgtq_f64(v21, v22);
  if (v21.f64[1] >= 1.0e15)
    v24 = 0;
  else
    v24 = -1;
  if (v21.f64[0] >= 1.0e15)
    v25 = 0;
  else
    v25 = -1;
  v26.i64[0] = v25;
  v26.i64[1] = v24;
  v27 = (int8x16_t)vcgtq_f64(v20, v22);
  if (v20.f64[1] >= 1.0e15)
    v28 = 0;
  else
    v28 = -1;
  if (v20.f64[0] >= 1.0e15)
    v29 = 0;
  else
    v29 = -1;
  v30.i64[0] = v29;
  v30.i64[1] = v28;
  *((int8x16_t *)v5 + 5) = vandq_s8((int8x16_t)v11, (int8x16_t)vuzp1q_s32((int32x4_t)vandq_s8(v23, v26), (int32x4_t)vandq_s8(v27, v30)));
  if (a3 <= 0)
    v10 = -(-a3 & 3);
  else
    v10 = a3 & 3;
  if (v10 >= 1)
  {
LABEL_34:
    v31 = v10 + 1;
    do
    {
      v32 = *a2++;
      v33 = v32;
      v34 = -v32;
      if (v32 < 0.0)
        v33 = v34;
      v9 = fmaxf(v33, v9);
      v8 = v8 + ((float)(v33 * v33) - v8) * 0.03;
      --v31;
    }
    while (v31 > 1);
  }
LABEL_38:
  if (v9 > *((float *)v5 + 13))
    *((float *)v5 + 13) = v9;
  v35 = *(unsigned __int8 *)v5;
  if (*(_BYTE *)v5)
  {
    v36.f64[0] = v9;
  }
  else
  {
    v37 = v5[13];
    v36.f64[0] = v9;
    if (v37 > v36.f64[0])
      v36.f64[0] = v37 + v5[5] * (v36.f64[0] - v37);
  }
  v38 = *((_DWORD *)v5 + 25) + a3;
  *((_DWORD *)v5 + 25) = v38;
  v39 = v5[15];
  if (v38 >= (int)(v5[1] * 0.907029478))
    v39 = v39 - v5[3] * v39;
  v40 = sqrt(v8);
  if (v39 < v36.f64[0])
  {
    *((_DWORD *)v5 + 25) = 0;
    v39 = v36.f64[0];
  }
  v41 = v40 * 1.41421356;
  if (!v35)
  {
    v42 = v5[14];
    if (v42 > v41)
      v41 = v42 + v5[5] * (v41 - v42);
  }
  v43 = fmin(v41, v39);
  v44 = fabs(v8);
  if (v44 >= 1.0e15 || v44 <= 1.0e-15)
    v46 = 0.0;
  else
    v46 = v8;
  v5[8] = v46;
  v36.f64[1] = v43;
  v47 = vabsq_f64(v36);
  v48 = (int8x16_t)vcgtq_f64(v47, (float64x2_t)vdupq_n_s64(0x3CD203AF9EE75616uLL));
  if (v47.f64[1] >= 1.0e15)
    v49 = 0;
  else
    v49 = -1;
  if (v47.f64[0] >= 1.0e15)
    v50 = 0;
  else
    v50 = -1;
  v51.i64[0] = v50;
  v51.i64[1] = v49;
  *(int8x16_t *)(v5 + 13) = vandq_s8(vandq_s8((int8x16_t)v36, v48), v51);
  v52 = fabs(v39);
  if (v52 >= 1.0e15 || v52 <= 1.0e-15)
    v54 = 0.0;
  else
    v54 = v39;
  v5[15] = v54;
  return this;
}

void VoiceActivityDetector::~VoiceActivityDetector(VoiceActivityDetector *this)
{
  VoiceActivityDetector::~VoiceActivityDetector(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  *(_QWORD *)this = &off_1E69ED580;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    MEMORY[0x1BCC95CEC](v2, 0x20C40A4A59CD2);
  }
  v6 = *((_QWORD *)this + 6);
  if (v6)
    MEMORY[0x1BCC95CC8](v6, 0x1000C8052888210);
  v7 = *((_QWORD *)this + 7);
  if (v7)
    MEMORY[0x1BCC95CC8](v7, 0x1000C8052888210);
  v8 = (_QWORD *)*((_QWORD *)this + 4);
  v9 = v8[1];
  if (v9)
    MEMORY[0x1BCC95CC8](v9, 0x1000C8052888210);
  v10 = v8[2];
  if (v10)
    MEMORY[0x1BCC95CC8](v10, 0x1000C8052888210);
  v11 = v8[3];
  if (v11)
    MEMORY[0x1BCC95CC8](v11, 0x1000C8052888210);
  v12 = v8[4];
  if (v12)
    MEMORY[0x1BCC95CC8](v12, 0x1000C8052888210);
  v13 = v8[7];
  if (v13)
    MEMORY[0x1BCC95CC8](v13, 0x1000C8052888210);
  v14 = v8[8];
  if (v14)
    MEMORY[0x1BCC95CC8](v14, 0x1000C8052888210);
  v15 = v8[5];
  if (v15)
    MEMORY[0x1BCC95CC8](v15, 0x1000C8052888210);
  v16 = *((_QWORD *)this + 4);
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  v17 = (_QWORD *)*((_QWORD *)this + 1);
  v18 = v17[5];
  if (v18)
    MEMORY[0x1BCC95CC8](v18, 0x1000C8052888210);
  v19 = v17[6];
  if (v19)
    MEMORY[0x1BCC95CC8](v19, 0x1000C8052888210);
  v20 = v17[7];
  if (v20)
    MEMORY[0x1BCC95CC8](v20, 0x1000C8052888210);
  v21 = v17[8];
  if (v21)
    MEMORY[0x1BCC95CC8](v21, 0x1000C8052888210);
  v22 = v17[10];
  if (v22)
    MEMORY[0x1BCC95CC8](v22, 0x1000C8052888210);
  v23 = v17[11];
  if (v23)
    MEMORY[0x1BCC95CC8](v23, 0x1000C8052888210);
  v24 = v17[12];
  if (v24)
    MEMORY[0x1BCC95CC8](v24, 0x1000C8052888210);
  v25 = v17[13];
  if (v25)
    MEMORY[0x1BCC95CC8](v25, 0x1000C8052888210);
  v26 = v17[14];
  if (v26)
    MEMORY[0x1BCC95CC8](v26, 0x1000C8052888210);
  v27 = v17[15];
  if (v27)
    MEMORY[0x1BCC95CC8](v27, 0x1000C8052888210);
  v28 = v17[16];
  if (v28)
    MEMORY[0x1BCC95CC8](v28, 0x1000C8052888210);
  v29 = v17[17];
  if (v29)
    MEMORY[0x1BCC95CC8](v29, 0x1000C8052888210);
  v30 = v17[23];
  if (v30)
    MEMORY[0x1BCC95CC8](v30, 0x1000C8052888210);
  v31 = v17[24];
  if (v31)
    MEMORY[0x1BCC95CC8](v31, 0x1000C8052888210);
  v32 = *((_QWORD *)this + 1);
  if (v32)
    MEMORY[0x1BCC95CEC](v32, 0x10A0C401EE7F367);
}

uint64_t VoiceActivityDetector::SpxVADProcess(VoiceActivityDetector *this, float *a2)
{
  uint64_t v4;
  vDSP_Length v5;
  int64_t v6;
  int v7;
  float v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  int64_t v12;
  size_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  float *v21;
  float v22;
  unint64_t v23;
  float v24;
  float *v25;
  float *v26;
  uint64_t v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  float v33;
  unint64_t v34;
  float32x4_t *v35;
  float32x4_t v36;
  int8x16_t v42;
  unint64_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  uint64_t result;
  _QWORD v52[2];
  float v53;
  float __A;
  float v55;
  float v56;
  float v57;
  float v58;
  float __C;
  float v60;
  float __B;
  uint64_t v62;

  v52[1] = v52;
  v62 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 1);
  v5 = *((int *)this + 7);
  v6 = *((int *)this + 5);
  v7 = *(_DWORD *)(v4 + 200);
  v8 = (float)*((unsigned int *)this + 6);
  v52[0] = *(_QWORD *)(v4 + 56);
  if (v7 + 1 < (int)(float)((float)(v8 * 30.0) / (float)(int)v6))
    v9 = v7 + 1;
  else
    v9 = (int)(float)((float)(v8 * 30.0) / (float)(int)v6);
  *(_DWORD *)(v4 + 200) = v9;
  ++*(_DWORD *)(v4 + 208);
  v10 = v9 <= (int)(float)((float)(v8 * 0.5) / (float)(int)v6);
  v11 = 176;
  if (!v10)
    v11 = 172;
  __B = *(float *)(v4 + v11);
  v60 = 1.0 - __B;
  v12 = v6 + v5;
  v13 = 4 * (v6 + v5) + 16;
  MEMORY[0x1E0C80A78](this);
  v15 = (v14 + 31) & 0xFFFFFFFFFFFFFFF0;
  bzero((char *)v52 - v15, v13);
  MEMORY[0x1E0C80A78](v16);
  bzero((char *)v52 - v15, v13);
  v17 = (((unint64_t)v52 - v15) & 0xFFFFFFFFFFFFFFF3) + 16;
  VoiceActivityDetector::preprocess_analysis(this, a2);
  v18 = 4 * v6;
  MEMORY[0x1E0C80A78](v19);
  bzero((char *)v52 - ((4 * v6 + 31) & 0xFFFFFFFFFFFFFFF0), v20);
  v21 = (float *)((((unint64_t)v52 - ((4 * v6 + 31) & 0xFFFFFFFFFFFFFFF0)) & 0xFFFFFFFFFFFFFFF3) + 16);
  __C = 0.0;
  vDSP_vmul(*(const float **)(v4 + 56), 1, *(const float **)(v4 + 64), 1, v21, 1, v6);
  vDSP_sve(v21, 1, &__C, v6);
  vDSP_vclr(v21, 1, v6);
  v58 = 0.0;
  vDSP_vmul(*(const float **)(v4 + 56), 1, *(const float **)(v4 + 56), 1, v21, 1, v6);
  vDSP_sve(v21, 1, &v58, v6);
  vDSP_vclr(v21, 1, v6);
  v57 = 0.0;
  vDSP_vmul(*(const float **)(v4 + 64), 1, *(const float **)(v4 + 64), 1, v21, 1, v6);
  vDSP_sve(v21, 1, &v57, v6);
  v22 = 0.0;
  if (v58 > 0.0 && v57 > 0.0)
    v22 = __C / sqrtf(v57 * v58);
  v23 = (((unint64_t)v52 - v15) & 0xFFFFFFFFFFFFFFF3) + 16;
  *(float *)(v4 + 72) = v22;
  v24 = expf(v22 * -26.49) * 8000000.0;
  memcpy(*(void **)(v4 + 64), *(const void **)(v4 + 56), 4 * v6);
  VoiceActivityDetector::update_noise_prob(this);
  v25 = (float *)(v17 + v18);
  vDSP_vsmul((const float *)(*(_QWORD *)(v4 + 56) + v18), 1, &__B, (float *)(v17 + v18), 1, v5);
  vDSP_vsma((const float *)(*(_QWORD *)(v4 + 88) + v18), 1, &v60, (const float *)(v17 + v18), 1, (float *)(v17 + v18), 1, v5);
  if ((int)v5 >= 1)
  {
    v26 = *(float **)(v4 + 136);
    v27 = v5;
    v28 = 4 * v6;
    do
    {
      if (*v26 <= 0.0)
        *(_DWORD *)(*(_QWORD *)(v4 + 88) + v28) = *(_DWORD *)(v17 + v28);
      v28 += 4;
      ++v26;
      --v27;
    }
    while (v27);
  }
  v29 = fminf(v24, 0.1);
  v55 = 0.0;
  v56 = -1.0;
  v53 = 100.0;
  __A = 1.0;
  vDSP_vclr((float *)(v17 + v18), 1, v5);
  vDSP_vadd((const float *)(v17 + v18), 1, (const float *)(*(_QWORD *)(v4 + 88) + v18), 1, (float *)(v17 + v18), 1, v5);
  vDSP_vsadd((const float *)(v17 + v18), 1, &__A, (float *)(v17 + v18), 1, v5);
  vDSP_svdiv(&__A, v25, 1, (float *)(v23 + v18), 1, v5);
  vDSP_vmsa((const float *)(v52[0] + v18), 1, (const float *)(v23 + v18), 1, &v56, (float *)(*(_QWORD *)(v4 + 96) + v18), 1, v5);
  vDSP_vclip((const float *)(*(_QWORD *)(v4 + 96) + v18), 1, &v55, &v53, (float *)(*(_QWORD *)(v4 + 96) + v18), 1, v5);
  vDSP_vsub((const float *)(*(_QWORD *)(v4 + 96) + v18), 1, (const float *)(*(_QWORD *)(v4 + 104) + v18), 1, (float *)(v23 + v18), 1, v5);
  vDSP_vthres((const float *)(v23 + v18), 1, &v55, v25, 1, v5);
  vDSP_vsub(v25, 1, (const float *)(v23 + v18), 1, (float *)(v23 + v18), 1, v5);
  vDSP_vsma((const float *)(v23 + v18), 1, (const float *)(v4 + 160), (const float *)(*(_QWORD *)(v4 + 96) + v18), 1, (float *)(v23 + v18), 1, v5);
  vDSP_vsma(v25, 1, (const float *)(v4 + 164), (const float *)(v23 + v18), 1, (float *)(*(_QWORD *)(v4 + 104) + v18), 1, 5uLL);
  vDSP_vsma(v25 + 5, 1, (const float *)(v4 + 168), (const float *)(v23 + v18 + 20), 1, (float *)(*(_QWORD *)(v4 + 104) + v18 + 20), 1, v5 - 5);
  if ((int)v5 < 1)
  {
    v33 = 0.0;
  }
  else
  {
    v30 = *(_QWORD *)(v4 + 104);
    if (v6 + 1 > v12)
      v31 = v6 + 1;
    else
      v31 = v6 + v5;
    v32 = v31 - v6;
    if (v32 >= 8)
    {
      v34 = v32 & 0xFFFFFFFFFFFFFFF8;
      v35 = (float32x4_t *)(v30 + 4 * v6 + 16);
      v36 = 0uLL;
      __asm { FMOV            V1.4S, #1.0 }
      v42.i64[0] = 0x8000000080000000;
      v42.i64[1] = 0x8000000080000000;
      v43 = v32 & 0xFFFFFFFFFFFFFFF8;
      v44 = 0uLL;
      do
      {
        v36 = vaddq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v35[-1], _Q1), (int8x16_t)v35[-1], v42), v36);
        v44 = vaddq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*v35, _Q1), *(int8x16_t *)v35, v42), v44);
        v35 += 2;
        v43 -= 8;
      }
      while (v43);
      v45 = vaddq_f32(v44, v36);
      v33 = vaddv_f32((float32x2_t)*(_OWORD *)&vpaddq_f32(v45, v45));
      if (v32 == v34)
        goto LABEL_28;
      v6 += v34;
    }
    else
    {
      v33 = 0.0;
    }
    do
    {
      v46 = *(float *)(v30 + 4 * v6);
      if (v46 <= 1.0)
        v46 = -0.0;
      v33 = v46 + v33;
      ++v6;
    }
    while (v6 < v12);
  }
LABEL_28:
  v47 = v33 / (float)*((unsigned int *)this + 7);
  v48 = (float)(0.899 / (float)((float)(0.5 / v47) + 1.0)) + 0.1;
  *(float *)(v4 + 144) = v47;
  *(float *)(v4 + 148) = v48;
  v49 = *(float *)(v4 + 152);
  if (v48 <= v49)
    v50 = v49 + (float)((float)(v48 - v49) * v29);
  else
    v50 = v48;
  *(float *)(v4 + 152) = v50;
  if (!*(_DWORD *)v4)
    return 1;
  if (v50 > *(float *)(v4 + 4) || *(_DWORD *)(v4 + 204) && v50 > *(float *)(v4 + 8))
  {
    result = 1;
    *(_DWORD *)(v4 + 204) = 1;
  }
  else
  {
    result = 0;
    *(_DWORD *)(v4 + 204) = 0;
  }
  return result;
}

float VoiceActivityDetector::preprocess_analysis(VoiceActivityDetector *this, float *a2)
{
  uint64_t v4;
  int v5;
  vDSP_Length v6;
  int v7;
  int v8;
  float *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  unint64_t v15;
  unsigned int **v16;
  _DWORD *v17;
  uint64_t v18;
  DSPSplitComplex __B;
  float v21;
  DSPSplitComplex __Z;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 1);
  v5 = *((_DWORD *)this + 4);
  v6 = *((int *)this + 5);
  v7 = 2 * v6 - v5;
  v8 = v5 - v7;
  v9 = *(float **)(v4 + 56);
  v10 = 4 * v7;
  memcpy(*(void **)(v4 + 40), *(const void **)(v4 + 184), v10);
  memcpy((void *)(*(_QWORD *)(v4 + 40) + v10), a2, 4 * *((unsigned int *)this + 4));
  memcpy(*(void **)(v4 + 184), &a2[v8], v10);
  vDSP_vmul(*(const float **)(v4 + 40), 1, *(const float **)(v4 + 80), 1, *(float **)(v4 + 40), 1, 2 * v6);
  MEMORY[0x1E0C80A78](v11);
  v13 = (unint64_t)&__B - ((v12 + 31) & 0xFFFFFFFFFFFFFFF0);
  bzero((void *)v13, v14);
  v15 = (v13 & 0xFFFFFFFFFFFFFFF3) + 16;
  __Z.realp = (float *)v15;
  __Z.imagp = (float *)(v15 + 4 * v6);
  vDSP_ctoz(*(const DSPComplex **)(v4 + 40), 2, &__Z, 1, v6);
  v16 = (unsigned int **)*((_QWORD *)this + 5);
  if (v16)
  {
    if (!*v16)
      abort();
    vDSP_DFT_Execute(*((const vDSP_DFT_SetupStruct **)*v16 + 1), __Z.realp, __Z.imagp, __Z.realp, __Z.imagp);
    LODWORD(__B.realp) = 1056964608;
    vDSP_vsmul(__Z.realp, 1, (const float *)&__B, __Z.realp, 1, (unint64_t)**v16 >> 1);
    vDSP_vsmul(__Z.imagp, 1, (const float *)&__B, __Z.imagp, 1, (unint64_t)**v16 >> 1);
  }
  v21 = (float)(int)v6 + (float)(int)v6;
  vDSP_vsdiv((const float *)v15, 1, &v21, (float *)v15, 1, 2 * v6);
  __B.realp = (float *)(v15 + 4 * v6 + 4);
  __B.imagp = (float *)(v15 + 8);
  vDSP_ztoc(&__B, 1, (DSPComplex *)(*(_QWORD *)(v4 + 48) + 8), 2, (int)v6 - 2);
  v17 = *(_DWORD **)(v4 + 48);
  *v17 = *(_DWORD *)v15;
  v17[1] = *(_DWORD *)(v15 + 4);
  v18 = 2 * (_DWORD)v6;
  v17[v18 - 2] = *(_DWORD *)(v15 + v18 * 4 - 4);
  v17[v18 - 1] = *(_DWORD *)(v15 + 4 * v6);
  vDSP_zvmags(&__Z, 1, v9, 1, v6);
  *v9 = *__Z.realp * *__Z.realp;
  return VPFilterBank::filterbank32_compute(*((VPFilterBank **)this + 4), v9, &v9[v6]);
}

void VoiceActivityDetector::update_noise_prob(VoiceActivityDetector *this)
{
  uint64_t v2;
  uint64_t v3;
  vDSP_Length v4;
  size_t v5;
  unint64_t v6;
  float v7;
  unint64_t v8;
  int v9;
  float v10;
  float v11;
  _BYTE v13[12];
  float v14;
  float v15;
  float __B;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 1);
  v3 = *((int *)this + 5);
  v4 = *((int *)this + 7);
  MEMORY[0x1E0C80A78](this);
  bzero(&v13[-((4 * v4 + 31) & 0xFFFFFFFFFFFFFFF0)], v5);
  v6 = (unint64_t)&v13[-((4 * v4 + 31) & 0xFFFFFFFFFFFFFFF0)] & 0xFFFFFFFFFFFFFFF3;
  v7 = *(float *)(v2 + 156);
  *(_DWORD *)(v6 + 16) = 0;
  v8 = v6 + 16;
  v15 = 0.667 - (float)(v7 * 0.667);
  __B = 0.333 - (float)(v7 * 0.333);
  vDSP_vsmul((const float *)(*(_QWORD *)(v2 + 56) + 4 * v3), 1, &__B, (float *)(v8 + 4), 1, v4 - 1);
  vDSP_vsma((const float *)(*(_QWORD *)(v2 + 56) + 4 * v3 + 4), 1, &__B, (const float *)v8, 1, (float *)v8, 1, v4 - 1);
  vDSP_vsma((const float *)(*(_QWORD *)(v2 + 56) + 4 * v3), 1, &v15, (const float *)v8, 1, (float *)v8, 1, v4);
  vDSP_vsma(*(const float **)(v2 + 112), 1, (const float *)(v2 + 156), (const float *)v8, 1, *(float **)(v2 + 112), 1, v4);
  v9 = *(_DWORD *)(v2 + 200);
  if (v9 == 1)
  {
    vDSP_vclr(*(float **)(v2 + 120), 1, v4);
    vDSP_vclr(*(float **)(v2 + 128), 1, v4);
    v9 = *(_DWORD *)(v2 + 200);
  }
  v10 = (float)*((unsigned int *)this + 6);
  v11 = (float)(v10 * 0.2) / (float)(int)v3;
  if (v11 <= (float)v9 && (float)(v10 / (float)(int)v3) <= (float)v9)
    v11 = (float)(v10 + v10) / (float)(int)v3;
  if (*(_DWORD *)(v2 + 208) <= (int)v11)
  {
    vDSP_vmin(*(const float **)(v2 + 120), 1, *(const float **)(v2 + 112), 1, *(float **)(v2 + 120), 1, v4);
    vDSP_vmin(*(const float **)(v2 + 128), 1, *(const float **)(v2 + 112), 1, *(float **)(v2 + 128), 1, v4);
  }
  else
  {
    *(_DWORD *)(v2 + 208) = 0;
    vDSP_vmin(*(const float **)(v2 + 128), 1, *(const float **)(v2 + 112), 1, *(float **)(v2 + 120), 1, v4);
    memcpy(*(void **)(v2 + 128), *(const void **)(v2 + 112), 4 * v4);
  }
  v14 = 4.0;
  vDSP_vsmul(*(const float **)(v2 + 120), 1, &v14, (float *)v8, 1, v4);
  vDSP_vsub((const float *)v8, 1, *(const float **)(v2 + 112), 1, *(float **)(v2 + 136), 1, v4);
}

void CreateMagicalWindow(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  float v5;
  float v6;
  int v7;
  float v8;
  float v9;
  float v10;

  if (a2 >= 1)
  {
    v3 = 0;
    v4 = a2;
    v5 = 1.0 / (float)a2;
    do
    {
      v6 = (float)((float)(int)v3 * 4.0) * v5;
      if (v6 >= 1.0)
      {
        if (v6 < 2.0)
        {
          v7 = 0;
          v6 = 2.0 - v6;
          goto LABEL_5;
        }
        if (v6 < 3.0)
        {
          v7 = 0;
          v6 = v6 + -2.0;
          goto LABEL_5;
        }
        v6 = 4.0 - v6;
      }
      v7 = 1;
LABEL_5:
      v8 = v6 * 1.27188667;
      v9 = cosf(v8 * 1.5708);
      v10 = (float)(0.5 - (float)(v9 * 0.5)) * (float)(0.5 - (float)(v9 * 0.5));
      if (!v7)
        v10 = 1.0 - v10;
      *(float *)(a1 + 4 * v3++) = sqrtf(v10);
    }
    while (v4 != v3);
  }
}

void calc_alpha_TE(float a1, float a2, float a3)
{
  double v3;
  float v4;
  float v5;
  float v6;
  float v7;

  v3 = a1 / (a2 * 1000.0);
  v4 = floor(v3);
  v5 = ceil(v3);
  if (v4 == v5)
  {
    if (v4)
    {
      v7 = a3 * -0.01;
      powf(v7 + 1.0, 1.0 / (float)v4);
    }
  }
  else
  {
    v6 = a3 * 0.01;
    if (v4)
      powf(1.0 - v6, 1.0 / (float)v4);
    if (v5)
      powf(1.0 - v6, 1.0 / (float)v5);
  }
}

uint64_t VBAP::initialize(int *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, void **a5)
{
  char *v5;
  unint64_t v6;
  size_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  double v14;
  __double2 v15;
  __double2 v16;
  float v17;
  float v18;
  float sinval;
  VBAP *v20;
  int v21;
  int v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  _BYTE *v29;
  _DWORD *v30;
  unint64_t v31;
  char *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  _OWORD *v36;
  char *v37;
  uint64_t v38;
  __int128 v39;
  const float *v40;
  const float *v41;
  uint64_t v42;
  int *v43;
  vDSP_Length v44;
  uint64_t v45;
  float64x2_t v46;
  float32x4_t v47;
  __n128 v48;
  float64x2_t v49;
  float64x2_t v50;
  float64x2_t v51;
  float64x2_t v52;
  uint64_t v53;
  size_t v54;
  void *v55;
  size_t v56;
  void *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unsigned int v61;
  uint64_t v62;
  unint64_t v63;
  BOOL v64;
  float64_t *v65;
  void *v66;
  void *v67;
  uint64_t v68;
  uint64_t i;
  uint64_t v70;
  float64x2_t v71;
  float64x2_t v72;
  float64x2_t v73;
  float64x2_t v74;
  float64x2_t v75;
  float64x2_t v76;
  uint64_t v77;
  float64x2_t v78;
  float v79;
  float64x2_t v80;
  int v81;
  int v82;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  float64x2_t v86;
  NSObject *v87;
  const char *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v99;
  float v100;
  float v101;
  float64x2_t v102;
  float64x2_t v103;
  float64x2_t v104;
  float64x2_t v105;
  float32x2_t *v106;
  float64x2_t v107;
  float64x2_t v108;
  BOOL v109;
  __int32 **v110;
  __int32 **v111;
  __int32 **v112;
  __int32 *v113;
  __int32 *v114;
  unint64_t v115;
  float32x4_t v116;
  char *v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unsigned int v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  void *v126;
  void *v127;
  uint64_t v128;
  char *v129;
  char **v130;
  int *v131;
  char *v132;
  char **v133;
  int v134;
  char *v135;
  unint64_t v136;
  char **v137;
  char *v138;
  char *v139;
  char *v140;
  _BYTE *v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  unint64_t v146;
  _BYTE *v147;
  char *v148;
  unint64_t v149;
  uint64_t v150;
  _OWORD *v151;
  __int128 *v152;
  uint64_t v153;
  __int128 v154;
  int v155;
  char *v156;
  char *v157;
  uint64_t v158;
  uint64_t v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  _BYTE *v163;
  char *v164;
  unint64_t v165;
  char *v166;
  char *v167;
  uint64_t v168;
  uint64_t v169;
  unint64_t v170;
  uint64_t v171;
  unint64_t v172;
  _BYTE *v173;
  uint64_t v174;
  uint64_t v175;
  void *v176;
  void *v177;
  uint64_t v178;
  char *v179;
  char **v180;
  char *v181;
  char **v182;
  char *v183;
  char **v184;
  uint64_t v185;
  char *v186;
  uint64_t v187;
  uint64_t v188;
  unint64_t v189;
  uint64_t v190;
  unint64_t v191;
  _BYTE *v192;
  uint64_t v193;
  _OWORD *v194;
  char *v195;
  uint64_t v196;
  __int128 v197;
  int v198;
  char *v199;
  char *v200;
  uint64_t v201;
  uint64_t v202;
  unint64_t v203;
  uint64_t v204;
  unint64_t v205;
  _BYTE *v206;
  char *v207;
  unint64_t v208;
  char *v209;
  uint64_t v210;
  float32x4_t *v211;
  float32x4_t *v212;
  uint64_t v213;
  int v214;
  uint64_t v215;
  uint64_t v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t v219;
  void *v220;
  void *v221;
  uint64_t v222;
  int *v223;
  int *v224;
  uint64_t v225;
  char *v226;
  char *v227;
  int v228;
  unint64_t v229;
  char *v230;
  uint64_t v231;
  uint64_t v232;
  unint64_t v233;
  uint64_t v234;
  unint64_t v235;
  _BYTE *v236;
  _DWORD *v237;
  unint64_t v238;
  char *v239;
  int v240;
  uint64_t v241;
  float32x4_t *v242;
  float32x4_t *v243;
  uint64_t v244;
  _DWORD *v245;
  unint64_t v246;
  uint64_t v247;
  float32x4_t *v248;
  float32x4_t *v249;
  uint64_t v250;
  int v251;
  int v252;
  char *v253;
  char **v254;
  char *v255;
  uint64_t v256;
  uint64_t v257;
  unint64_t v258;
  uint64_t v259;
  unint64_t v260;
  unint64_t v261;
  _BYTE *v262;
  _DWORD *v263;
  unint64_t v264;
  char *v265;
  int v266;
  int v267;
  char **v268;
  char *v269;
  uint64_t v270;
  uint64_t v271;
  unint64_t v272;
  uint64_t v273;
  unint64_t v274;
  _BYTE *v275;
  _DWORD *v276;
  unint64_t v277;
  char *v278;
  int v279;
  _DWORD *v280;
  unint64_t v281;
  unint64_t v282;
  uint64_t v283;
  float32x4_t *v284;
  float32x4_t *v285;
  uint64_t v286;
  int v287;
  char *v288;
  char **v289;
  char **v290;
  uint64_t v291;
  char *v292;
  uint64_t v293;
  uint64_t v294;
  unint64_t v295;
  uint64_t v296;
  unint64_t v297;
  unint64_t v298;
  _BYTE *v299;
  _DWORD *v300;
  unint64_t v301;
  char *v302;
  int v303;
  char *v304;
  char **v305;
  _QWORD *v306;
  char *v307;
  uint64_t v308;
  uint64_t v309;
  unint64_t v310;
  uint64_t v311;
  unint64_t v312;
  _BYTE *v313;
  _DWORD *v314;
  unint64_t v315;
  char *v316;
  uint64_t v317;
  float32x4_t *v318;
  float32x4_t *v319;
  uint64_t v320;
  uint64_t v321;
  float32x4_t *v322;
  float32x4_t *v323;
  uint64_t v324;
  uint64_t v325;
  float32x4_t *v326;
  float32x4_t *v327;
  uint64_t v328;
  uint64_t v329;
  float32x4_t *v330;
  float32x4_t *v331;
  uint64_t v332;
  int v333;
  uint64_t v334;
  uint64_t v335;
  unint64_t v336;
  uint64_t v337;
  uint64_t v338;
  void *v339;
  void *v340;
  char *v341;
  _DWORD *v342;
  char *v343;
  int v344;
  char *v345;
  char *v346;
  uint64_t v347;
  uint64_t v348;
  unint64_t v349;
  uint64_t v350;
  unint64_t v351;
  _BYTE *v352;
  _DWORD *v353;
  unint64_t v354;
  uint64_t v355;
  float32x4_t *v356;
  float32x4_t *v357;
  uint64_t v358;
  int v359;
  int v360;
  char *v361;
  uint64_t v362;
  uint64_t v363;
  unint64_t v364;
  uint64_t v365;
  unint64_t v366;
  _BYTE *v367;
  _DWORD *v368;
  unint64_t v369;
  char *v370;
  uint64_t v371;
  float32x4_t *v372;
  float32x4_t *v373;
  uint64_t v374;
  int v375;
  uint64_t v376;
  uint64_t v377;
  unint64_t v378;
  uint64_t v379;
  unint64_t v380;
  char *v381;
  int v382;
  uint64_t v383;
  float32x4_t *v384;
  float32x4_t *v385;
  uint64_t v386;
  __int32 *v387;
  __int32 *v388;
  __int32 *v389;
  __int32 v390;
  __int32 *v391;
  __int32 *v392;
  uint64_t v393;
  __int32 *v394;
  __int32 *v395;
  uint64_t v397;
  unint64_t v398;
  uint64_t v399;
  char *v400;
  char *v401;
  void *v402;
  char *v403;
  void *v404;
  void *v405;
  char *v406;
  unint64_t v407;
  uint64_t v408;
  char *v409;
  unint64_t v410;
  uint64_t v411;
  unint64_t v412;
  char *v413;
  char *v414;
  void *v415;
  void *v416;
  const float **v417;
  unint64_t v418;
  unsigned int v419;
  _QWORD *v420;
  _QWORD *v421;
  uint64_t v422;
  _QWORD *v423;
  _QWORD *v424;
  _QWORD *v425;
  void *v426;
  _QWORD *v427;
  void *v428;
  void *v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  void *v435;
  uint64_t v436;
  void *v437;
  void *v438;
  unint64_t v439;
  uint64_t v440;
  char **v441;
  unint64_t v442;
  BOOL v443;
  int *v444;
  unint64_t v445;
  uint64_t v446;
  uint64_t v447;
  void **v448;
  unint64_t v449;
  _QWORD *v450;
  unint64_t v451;
  int **v452;
  int *v453;
  int *v454;
  char *v455;
  uint64_t v456;
  unint64_t v457;
  uint64_t v458;
  float v459;
  uint64_t v460;
  uint64_t v461;
  float v462;
  float v463;
  uint64_t v464;
  float v465;
  float v466;
  int v467;
  float *v468;
  float v469;
  float v470;
  char *v471;
  float *v472;
  float v473;
  uint64_t v474;
  float v475;
  uint64_t v476;
  uint64_t v477;
  const float *v478;
  const float *v479;
  float32x2_t v480;
  float32x2_t v481;
  float32x2_t v482;
  float32x2_t v483;
  float64x2_t v484;
  float32x2_t v485;
  float64x2_t v486;
  float32x2_t v487;
  float32x2_t *p_C;
  __int32 v489;
  uint64_t v490;
  uint64_t v491;
  void *v492;
  uint64_t v493;
  void *v494;
  void *v495;
  uint64_t v496;
  char *v497;
  char *v498;
  char *v499;
  char *v500;
  char *v501;
  char *v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  const float *v510;
  float64x2_t *v511;
  float64x2_t *v512;
  float64x2_t *v513;
  unsigned int v514;
  uint64_t v515;
  float64x2_t v516;
  float64x2_t v517;
  float64x2_t v518;
  unint64_t v519;
  BOOL v520;
  uint64_t v521;
  uint64_t j;
  uint64_t v523;
  float64x2_t v524;
  float64x2_t v525;
  float64x2_t v526;
  float64x2_t v527;
  float64x2_t v528;
  float64x2_t v529;
  float64x2_t v530;
  float64x2_t v531;
  float64x2_t v532;
  uint64_t v533;
  float64x2_t v534;
  float64x2_t v535;
  float v536;
  double v537;
  float64x2_t v538;
  vDSP_Length v539;
  int64x2_t *v540;
  uint64_t v541;
  unint64_t v542;
  _DWORD *v543;
  int *v544;
  float *v545;
  int *v546;
  uint64_t v547;
  uint64_t v548;
  unint64_t v549;
  uint64_t v550;
  uint64_t v551;
  char *v552;
  char *v553;
  char *v554;
  char *v555;
  unint64_t v556;
  unint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  unint64_t v563;
  unint64_t v564;
  _BYTE *v565;
  char *v566;
  unint64_t v567;
  char *v568;
  int v569;
  uint64_t v570;
  _OWORD *v571;
  char *v572;
  uint64_t v573;
  __int128 v574;
  unint64_t v575;
  int *v576;
  uint64_t v577;
  unint64_t v578;
  unsigned int v579;
  uint64_t v580;
  uint64_t v581;
  int *v582;
  float *v583;
  float64x2_t v584;
  unsigned __int128 *v585;
  unint64_t v586;
  vDSP_Length v587;
  uint64_t v588;
  unsigned __int128 *v589;
  const float *v590;
  int64x2_t v591;
  int64x2_t v592;
  int64x2_t *v593;
  int64x2_t v594;
  vDSP_Length v595;
  const float *v596;
  unsigned __int128 v597;
  unsigned __int128 v598;
  int64x2_t v599;
  int *v600;
  int v601;
  uint64_t v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t *v605;
  uint64_t v606;
  _DWORD *v607;
  uint64_t v608;
  float v609;
  uint64_t v610;
  float32x2_t v611;
  int v612;
  uint64_t v613;
  float v614;
  float32x2_t v615;
  float32x2_t v616;
  uint64_t v617;
  float32x2_t *v618;
  float64x2_t v619;
  float64x2_t v620;
  float v621;
  uint64_t v622;
  uint64_t v623;
  float64x2_t v624;
  float64x2_t v625;
  float32x2_t v626;
  float64x2_t v627;
  float64x2_t v628;
  double v629;
  float v630;
  float v631;
  float v632;
  BOOL v633;
  float v634;
  BOOL v636;
  unint64_t v637;
  uint64_t v638;
  unint64_t v639;
  int *v640;
  void *v641;
  uint64_t v642;
  void *v643;
  uint64_t v644;
  char *v645;
  unint64_t v646;
  unint64_t v647;
  char *v648;
  double v649;
  float32x4_t v650;
  __n128 v651;
  double v652;
  float64x2_t v653;
  double v654;
  float64x2_t v655;
  _DWORD *v656;
  _DWORD *v657;
  const float **v658;
  char *v659;
  unint64_t v660;
  unsigned int v661;
  _QWORD *v662;
  _DWORD *v663;
  uint64_t v664;
  unsigned int v665;
  unsigned int v666;
  int *v667;
  char *v668;
  uint64_t v669;
  unsigned int v670;
  unsigned int v671;
  uint64_t v672;
  const float *v673;
  float v674;
  char *v675;
  uint64_t v676;
  _DWORD *v677;
  float v678;
  float v679;
  char *v680;
  _QWORD *v681;
  unint64_t v682;
  _QWORD *v683;
  const void *v684;
  int64_t v685;
  char *v686;
  char *v687;
  _QWORD *v688;
  _QWORD *v689;
  uint64_t v690;
  unint64_t v691;
  unint64_t v692;
  uint64_t v693;
  unint64_t v694;
  char *v695;
  char *v696;
  const void *v697;
  int64_t v698;
  char *v699;
  char *v700;
  char *v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  void *v705;
  void *v706;
  float *v707;
  uint64_t v708;
  uint64_t v709;
  char *v710;
  uint64_t v711;
  uint64_t v712;
  unint64_t v713;
  char *v714;
  _DWORD *v715;
  char *v716;
  uint64_t v717;
  unint64_t v718;
  uint64_t v719;
  unint64_t v720;
  _BYTE *v721;
  _DWORD *v722;
  char *v723;
  unint64_t v724;
  uint64_t v725;
  _OWORD *v726;
  char *v727;
  uint64_t v728;
  __int128 v729;
  int v730;
  uint64_t v731;
  _DWORD *v732;
  char v733;
  char *v734;
  char *v735;
  void *v736;
  char *v737;
  void *v738;
  void *v739;
  char *v740;
  char *v741;
  void *v742;
  char *v743;
  void *v744;
  void *v745;
  char **v747;
  unsigned int v748;
  char *v749;
  void **v750;
  uint64_t v751;
  unint64_t v752;
  uint64_t v753;
  float *v754[2];
  int v755;
  void *v758;
  char *v759;
  void *v760;
  char *v761;
  void *v762;
  void *v764;
  VBAP *v765[2];
  char **v766;
  int *v767;
  char **v768;
  _DWORD *v769;
  unint64_t v770;
  float64_t *v772;
  float64_t *v773;
  void *v774;
  float *v775;
  void *v776;
  float *v777;
  void *v778;
  _QWORD v779[2];
  void *__p;
  char *v781;
  char *v782;
  void *v783;
  char *v784;
  uint64_t v785;
  uint64_t __B;
  int v787;
  double v788;
  uint64_t v789;
  float v790;
  uint64_t __A;
  float v792;
  double v793;
  float v794;
  float32x2_t __C;
  uint64_t v796;
  int32x2_t v797;
  _BYTE buf[40];
  uint64_t v799;
  float32x4x3_t v800;

  v799 = *MEMORY[0x1E0C80C00];
  v5 = (char *)*((_QWORD *)a1 + 1);
  *((_QWORD *)a1 + 2) = v5;
  v6 = a1[75];
  if ((_DWORD)v6)
  {
    v8 = 4 * v6;
    v764 = operator new(4 * v6);
    bzero(v764, v8);
    v776 = operator new(v8);
    bzero(v776, v8);
    v774 = operator new(v8);
    bzero(v774, v8);
    v9 = 0;
    v10 = *a2;
    v11 = *a3;
    while (1)
    {
      v21 = *(_DWORD *)(v10 + 4 * v9);
      v22 = *(_DWORD *)(v11 + 4 * v9);
      v23 = *((_QWORD *)a1 + 3);
      if ((unint64_t)v5 >= v23)
        break;
      *(_DWORD *)v5 = v21;
      *((_DWORD *)v5 + 1) = v22;
      v5 += 8;
LABEL_4:
      *((_QWORD *)a1 + 2) = v5;
      v10 = *a2;
      v11 = *a3;
      v12 = *((_QWORD *)a1 + 7);
      v13 = (float *)(v12 + 4 * (3 * v9));
      v14 = *(float *)(*a2 + 4 * v9) * 0.0174532925;
      v15 = __sincos_stret(*(float *)(*a3 + 4 * v9) * 0.0174532925);
      v16 = __sincos_stret(v14);
      v17 = v15.__cosval * v16.__cosval;
      v18 = v15.__cosval * v16.__sinval;
      *v13 = v17;
      v13[1] = v18;
      sinval = v15.__sinval;
      v13[2] = sinval;
      v20 = (VBAP *)v764;
      *((float *)v764 + v9) = v17;
      *((_DWORD *)v776 + v9) = *(_DWORD *)(v12 + 4 * (3 * v9 + 1));
      *((_DWORD *)v774 + v9) = *(_DWORD *)(v12 + 4 * (3 * v9 + 2));
      ++v9;
      v6 = a1[75];
      if (v9 >= v6)
      {
        v41 = (const float *)v774;
        v40 = (const float *)v776;
        goto LABEL_33;
      }
    }
    v24 = (char *)*((_QWORD *)a1 + 1);
    v25 = (v5 - v24) >> 3;
    v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v27 = v23 - (_QWORD)v24;
    if (v27 >> 2 > v26)
      v26 = v27 >> 2;
    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8)
      v28 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v28 = v26;
    if (v28)
    {
      if (v28 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v29 = operator new(8 * v28);
    }
    else
    {
      v29 = 0;
    }
    v30 = &v29[8 * v25];
    *v30 = v21;
    v30[1] = v22;
    if (v5 == v24)
    {
      v24 = v5;
      v33 = &v29[8 * v25];
      goto LABEL_22;
    }
    v31 = v5 - 8 - v24;
    if (v31 < 0x168
      || &v29[v5 - v24 - 8 - (v31 & 0xFFFFFFFFFFFFFFF8)] > &v29[v5 - v24 - 8]
      || &v5[-(v31 & 0xFFFFFFFFFFFFFFF8) - 8] > v5 - 8
      || (unint64_t)(v24 - v29) < 0x20)
    {
      v32 = v5;
      v33 = &v29[8 * v25];
    }
    else
    {
      v35 = (v31 >> 3) + 1;
      v32 = &v5[-8 * (v35 & 0x3FFFFFFFFFFFFFFCLL)];
      v36 = &v29[8 * v25 - 16];
      v37 = v5 - 16;
      v38 = v35 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v39 = *(_OWORD *)v37;
        *(v36 - 1) = *((_OWORD *)v37 - 1);
        *v36 = v39;
        v36 -= 2;
        v37 -= 32;
        v38 -= 4;
      }
      while (v38);
      v33 = (char *)&v30[-2 * (v35 & 0x3FFFFFFFFFFFFFFCLL)];
      if (v35 == (v35 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_22;
    }
    do
    {
      v34 = *((_QWORD *)v32 - 1);
      v32 -= 8;
      *((_QWORD *)v33 - 1) = v34;
      v33 -= 8;
    }
    while (v32 != v24);
    v24 = (char *)*((_QWORD *)a1 + 1);
LABEL_22:
    v5 = (char *)(v30 + 2);
    *((_QWORD *)a1 + 1) = v33;
    *((_QWORD *)a1 + 2) = v30 + 2;
    *((_QWORD *)a1 + 3) = &v29[8 * v28];
    if (v24)
      operator delete(v24);
    goto LABEL_4;
  }
  v41 = 0;
  v20 = 0;
  v40 = 0;
LABEL_33:
  v775 = (float *)v41;
  v777 = (float *)v40;
  if (VBAP::find_duplicate_vertex(v20, v40, v41, (const float *)v6))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "VBAP.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 112;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = "initialize";
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 112;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Duplicate vertices were found",
        buf,
        0x22u);
    }
    v42 = 4294967246;
    goto LABEL_824;
  }
  v43 = a1;
  if (*((_QWORD *)a1 + 2) - *((_QWORD *)a1 + 1) == 16)
  {
    __C.i32[0] = 0;
    vDSP_distancesq(*((const float **)a1 + 7), 1, (const float *)(*((_QWORD *)a1 + 7) + 12), 1, (float *)&__C, 3uLL);
    if (fabsf(__C.f32[0] + -4.0) < 0.00001)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "VBAP.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 121;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = "initialize";
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 121;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%25s:%-5d CADSPUtility:%s:%d: Diametrically opposed speakers; No need to generate convex hull",
          buf,
          0x22u);
      }
      v42 = 0;
      *((_BYTE *)a1 + 314) = 1;
      goto LABEL_824;
    }
    v43 = a1;
    *((_BYTE *)a1 + 314) = 0;
  }
  v44 = v43[75];
  if ((_DWORD)v44 == 1)
  {
    *((_WORD *)v43 + 156) = 1;
    v45 = *((_QWORD *)v43 + 10);
    if (*((_QWORD *)v43 + 11) != v45)
      *((_QWORD *)v43 + 11) = v45;
    goto LABEL_823;
  }
  v787 = 0;
  __B = 0;
  vDSP_meanv(*((const float **)v43 + 7), 3, (float *)&__B, v44);
  vDSP_meanv((const float *)(*((_QWORD *)v43 + 7) + 4), 3, (float *)&__B + 1, v43[75]);
  vDSP_meanv((const float *)(*((_QWORD *)v43 + 7) + 8), 3, (float *)&v787, v43[75]);
  v53 = v43[75];
  if ((_DWORD)v53)
  {
    v54 = 4 * (3 * v53);
    v55 = operator new(v54);
    bzero(v55, v54);
    v56 = 8 * v53;
    v57 = operator new(8 * v53);
    bzero(v57, v56);
    v772 = (float64_t *)v57;
    v761 = (char *)operator new(v56);
    bzero(v761, v56);
    v58 = (uint64_t)v55 + v54;
    v759 = (char *)operator new(v56);
    bzero(v759, v56);
    v59 = 0;
    v60 = *((_QWORD *)a1 + 7);
    v61 = 2;
    do
    {
      vDSP_vsub((const float *)&__B, 1, (const float *)(v60 + 4 * (v61 - 2)), 1, (float *)v55 + v61 - 2, 1, 3uLL);
      v60 = *((_QWORD *)a1 + 7);
      v62 = 8 * v59;
      v772[(unint64_t)v62 / 8] = *(float *)(v60 + 4 * (v61 - 2));
      *(double *)&v761[v62] = *(float *)(v60 + 4 * (v61 - 1));
      v46.f64[0] = *(float *)(v60 + 4 * v61);
      *(float64_t *)&v759[v62] = v46.f64[0];
      ++v59;
      v63 = a1[75];
      v61 += 3;
    }
    while (v59 < v63);
    if (v63 >= 4)
    {
      v68 = 0;
      v48.n128_u64[0] = 0x3FA999999999999ALL;
      v65 = v772;
      v67 = v759;
      v66 = v761;
      while (2)
      {
        for (i = 0; i != v63; ++i)
        {
          if (i != v68)
          {
            v70 = 0;
            while (1)
            {
              if (v68 != v70 && i != v70)
              {
                v46.f64[0] = v772[v68];
                v46.f64[1] = *(float64_t *)&v761[8 * v68];
                v47.i64[0] = *(_QWORD *)&v759[8 * v68];
                v71.f64[0] = v772[i];
                v71.f64[1] = *(float64_t *)&v761[8 * i];
                v50.f64[0] = *(float64_t *)&v759[8 * i];
                v72.f64[0] = v772[v70];
                v72.f64[1] = *(float64_t *)&v761[8 * v70];
                v52.f64[0] = *(float64_t *)&v759[8 * v70];
                v73 = vsubq_f64(v72, v46);
                v74 = vsubq_f64(v52, (float64x2_t)v47);
                v75 = vsubq_f64(v71, v46);
                v76 = vsubq_f64(v50, (float64x2_t)v47);
                v51 = vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v74, v75, 1)), v76, v73, 1);
                v76.f64[1] = v75.f64[0];
                v74.f64[1] = v73.f64[0];
                v52 = vmlaq_f64(vnegq_f64(vmulq_f64(v73, v76)), v75, v74);
                v49.f64[0] = v51.f64[0];
                v49.f64[1] = v52.f64[0];
                v50 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v52, 1);
                if (vaddvq_f64(vabsq_f64(v49)) + vabsq_f64(v50).f64[0] > 0.05)
                  break;
              }
              if (v63 == ++v70)
                goto LABEL_55;
            }
            v77 = 0;
            v64 = 0;
            v48.n128_u64[0] = 0x3F847AE147AE147BLL;
            *(_QWORD *)&v49.f64[1] = vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL).u64[0];
            v78 = (float64x2_t)vextq_s8((int8x16_t)v52, (int8x16_t)v52, 8uLL);
            v52.f64[1] = v78.f64[0];
            v52 = vmulq_f64(v52, v52);
            v79 = sqrt(vmulq_f64(v51, v51).f64[0] + v52.f64[0] + v52.f64[1]);
            v52.f64[0] = 1.0;
            v51.f64[0] = 1.0 / v79;
            do
            {
              if (v70 != v77 && v68 != v77 && i != v77)
              {
                v80.f64[0] = v772[v77];
                v80.f64[1] = *(float64_t *)&v761[8 * v77];
                v78.f64[0] = *(float64_t *)&v759[8 * v77];
                v52 = vmulq_f64(vsubq_f64(v80, v46), v49);
                v78 = vmulq_f64(vsubq_f64(v78, (float64x2_t)v47), v50);
                v52.f64[0] = fabs((vaddvq_f64(v52) + v78.f64[0]) * v51.f64[0]);
                if (v52.f64[0] > 0.01)
                  break;
              }
              v64 = ++v77 >= v63;
            }
            while (v63 != v77);
            goto LABEL_70;
          }
LABEL_55:
          ;
        }
        ++v68;
        v64 = 1;
        if (v68 != v63)
          continue;
        break;
      }
    }
    else
    {
      v64 = 1;
      v65 = v772;
      v67 = v759;
      v66 = v761;
    }
  }
  else
  {
    LODWORD(v63) = 0;
    v55 = 0;
    v58 = 0;
    v66 = 0;
    v65 = 0;
    v67 = 0;
    v64 = 1;
  }
LABEL_70:
  v760 = v67;
  v762 = v66;
  v773 = v65;
  *((_BYTE *)a1 + 312) = v64;
  v81 = !v64;
  *((_BYTE *)a1 + 313) = !v64;
  v82 = *a1;
  v758 = v55;
  if (v64 && v82 == 1)
  {
    *a1 = 0;
    v783 = 0;
    v784 = 0;
    v785 = 0;
    __p = 0;
    v781 = 0;
    v782 = 0;
    goto LABEL_579;
  }
  v783 = 0;
  v784 = 0;
  v785 = 0;
  __p = 0;
  v781 = 0;
  v782 = 0;
  if (v82 != 1)
    goto LABEL_577;
  v42 = VBAP::delaunayTriangulation(a1, (const float *)v55, v58, a4, a5, v46.f64[0], v47, v48, v49.f64[0], v50, v51.f64[0], v52);
  if ((_DWORD)v42)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "VBAP.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 163;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = "initialize";
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 163;
      v87 = MEMORY[0x1E0C81028];
      v88 = "%25s:%-5d CADSPUtility:%s:%d: VBAP error, Delaunay triangulation issue";
      goto LABEL_795;
    }
LABEL_796:
    v733 = 0;
    v734 = (char *)__p;
    if (__p)
      goto LABEL_799;
    goto LABEL_806;
  }
  v778 = 0;
  v779[0] = 0;
  v779[1] = 0;
  v90 = *((_QWORD *)a1 + 28);
  v89 = *((_QWORD *)a1 + 29);
  *(_DWORD *)buf = 0;
  v91 = v89 - v90;
  if (v91)
  {
    std::vector<float>::__append(&v778, v91 >> 2, buf);
    v91 = (uint64_t)v778;
    v92 = v779[0];
  }
  else
  {
    v92 = 0;
  }
  if ((unint64_t)(v92 - v91) >= 0xC)
  {
    v93 = *((_QWORD *)a1 + 28);
    v94 = 1;
    v95 = 2;
    do
    {
      v96 = 4 * (v95 - 2);
      v97 = 3 * *(_DWORD *)(v93 + 4 * (v95 - 1));
      v98 = 3 * *(_DWORD *)(v93 + 4 * v95);
      v99 = 3 * *(_DWORD *)(v93 + v96);
      LODWORD(v83.f64[0]) = *((_DWORD *)v55 + v99);
      LODWORD(v85.f64[0]) = *((_DWORD *)v55 + v99 + 1);
      v100 = *((float *)v55 + v97) - *(float *)v83.f64;
      v101 = *((float *)v55 + v98) - *(float *)v83.f64;
      LODWORD(v83.f64[0]) = *((_DWORD *)v55 + v99 + 2);
      v102.f64[0] = v100;
      v84.f64[0] = (float)(*((float *)v55 + v97 + 1) - *(float *)v85.f64);
      v86.f64[0] = (float)(*((float *)v55 + v97 + 2) - *(float *)v83.f64);
      v103.f64[0] = v101;
      v85.f64[0] = (float)(*((float *)v55 + v98 + 1) - *(float *)v85.f64);
      v83.f64[0] = (float)(*((float *)v55 + v98 + 2) - *(float *)v83.f64);
      v104 = vmulq_f64(v85, v86);
      v86.f64[1] = v102.f64[0];
      v102.f64[1] = v84.f64[0];
      v105 = vmlaq_f64(vnegq_f64(v104), v84, v83);
      v83.f64[1] = v103.f64[0];
      v106 = (float32x2_t *)(v91 + v96);
      v103.f64[1] = v85.f64[0];
      v107 = vmlaq_f64(vnegq_f64(vmulq_f64(v83, v102)), v86, v103);
      v108 = vmulq_f64(v107, v107);
      v83 = vmulq_f64(v105, v105);
      v105.f64[1] = v107.f64[0];
      v108.f64[0] = 1.0 / sqrt(v83.f64[0] + v108.f64[0] + v108.f64[1]);
      *v106 = vcvt_f32_f64(vmulq_n_f64(v105, v108.f64[0]));
      *(float *)v107.f64 = vmulq_laneq_f64(v108, v107, 1).f64[0];
      v109 = ((v92 - v91) >> 2) / 3uLL > v94++;
      v95 += 3;
      v106[1].i32[0] = LODWORD(v107.f64[0]);
    }
    while (v109);
  }
  memset(buf, 0, 24);
  v110 = (__int32 **)*((_QWORD *)a1 + 19);
  v750 = (void **)(a1 + 38);
  v111 = (__int32 **)*((_QWORD *)a1 + 20);
  if (v111 != v110)
  {
    v112 = (__int32 **)*((_QWORD *)a1 + 20);
    do
    {
      v114 = *(v112 - 3);
      v112 -= 3;
      v113 = v114;
      if (v114)
      {
        *(v111 - 2) = v113;
        operator delete(v113);
      }
      v111 = v112;
    }
    while (v112 != v110);
    v91 = (uint64_t)v778;
    v92 = v779[0];
  }
  *((_QWORD *)a1 + 20) = v110;
  if ((unint64_t)(v92 - v91) >= 0xC)
  {
    LODWORD(v115) = 0;
    v116 = (float32x4_t)vdupq_n_s32(0x47C35000u);
    *(float32x4_t *)v754 = v116;
    while (1)
    {
      v118 = (3 * v115);
      v116.i32[0] = *(_DWORD *)(v91 + 4 * v118);
      v116.i32[1] = *(_DWORD *)(v91 + 4 * (v118 + 1));
      v116.i32[2] = *(_DWORD *)(v91 + 4 * (v118 + 2));
      v116 = vrndaq_f32(vmulq_f32(v116, *(float32x4_t *)v754));
      *(float32x4_t *)v765 = v116;
      v119 = *(_QWORD *)&buf[8];
      v120 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 3);
      v755 = v115;
      if (!(_DWORD)v115)
      {
        if (*(_QWORD *)&buf[8] == *(_QWORD *)buf)
        {
          std::vector<std::vector<float>>::__append((uint64_t *)buf, 1 - v120);
        }
        else if (v120 >= 2)
        {
          v124 = *(_QWORD *)buf + 24;
          if (*(_QWORD *)&buf[8] != *(_QWORD *)buf + 24)
          {
            v125 = *(_QWORD *)&buf[8];
            do
            {
              v127 = *(void **)(v125 - 24);
              v125 -= 24;
              v126 = v127;
              if (v127)
              {
                *(_QWORD *)(v119 - 16) = v126;
                operator delete(v126);
              }
              v119 = v125;
            }
            while (v125 != v124);
          }
          *(_QWORD *)&buf[8] = v124;
        }
        v137 = *(char ***)buf;
        v139 = *(char **)(*(_QWORD *)buf + 8);
        v138 = *(char **)(*(_QWORD *)buf + 16);
        if (v139 < v138)
        {
          *(_DWORD *)v139 = v765[0];
          v140 = v139 + 4;
          goto LABEL_137;
        }
        v141 = **(_BYTE ***)buf;
        v142 = (uint64_t)&v139[-**(_QWORD **)buf];
        v143 = v142 >> 2;
        v144 = (v142 >> 2) + 1;
        if (v144 >> 62)
          goto LABEL_835;
        v145 = v138 - v141;
        if (v145 >> 1 > v144)
          v144 = v145 >> 1;
        if ((unint64_t)v145 >= 0x7FFFFFFFFFFFFFFCLL)
          v146 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v146 = v144;
        if (v146)
        {
          if (!(v146 >> 62))
          {
            v147 = operator new(4 * v146);
            v55 = v758;
            goto LABEL_128;
          }
LABEL_834:
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v147 = 0;
LABEL_128:
        v148 = &v147[4 * v143];
        *(_DWORD *)v148 = v765[0];
        v140 = v148 + 4;
        if (v139 != v141)
        {
          v149 = v139 - 4 - v141;
          if (v149 < 0x2C)
            goto LABEL_851;
          if ((unint64_t)(v139 - &v147[v142]) < 0x20)
            goto LABEL_851;
          v150 = (v149 >> 2) + 1;
          v151 = &v147[4 * v143 - 16];
          v152 = (__int128 *)(v139 - 16);
          v153 = v150 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v154 = *v152;
            *(v151 - 1) = *(v152 - 1);
            *v151 = v154;
            v151 -= 2;
            v152 -= 2;
            v153 -= 8;
          }
          while (v153);
          v148 -= 4 * (v150 & 0x7FFFFFFFFFFFFFF8);
          v139 -= 4 * (v150 & 0x7FFFFFFFFFFFFFF8);
          if (v150 != (v150 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_851:
            do
            {
              v155 = *((_DWORD *)v139 - 1);
              v139 -= 4;
              *((_DWORD *)v148 - 1) = v155;
              v148 -= 4;
            }
            while (v139 != v141);
          }
        }
        v138 = &v147[4 * v146];
        *v137 = v148;
        v137[1] = v140;
        v137[2] = v138;
        if (v141)
        {
          operator delete(v141);
          v138 = v137[2];
        }
LABEL_137:
        v137[1] = v140;
        if (v140 < v138)
        {
          *(_DWORD *)v140 = HIDWORD(v765[0]);
          v156 = v140 + 4;
          goto LABEL_187;
        }
        v157 = *v137;
        v158 = v140 - *v137;
        v159 = v158 >> 2;
        v160 = (v158 >> 2) + 1;
        if (v160 >> 62)
          goto LABEL_835;
        v161 = v138 - v157;
        if (v161 >> 1 > v160)
          v160 = v161 >> 1;
        if ((unint64_t)v161 >= 0x7FFFFFFFFFFFFFFCLL)
          v162 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v162 = v160;
        if (v162)
        {
          if (v162 >> 62)
            goto LABEL_834;
          v163 = operator new(4 * v162);
          v55 = v758;
        }
        else
        {
          v163 = 0;
        }
        v164 = &v163[4 * v159];
        *(_DWORD *)v164 = HIDWORD(v765[0]);
        v156 = v164 + 4;
        if (v140 != v157)
        {
          v165 = v140 - 4 - v157;
          if (v165 < 0x2C)
          {
            v166 = v140;
            goto LABEL_184;
          }
          if ((unint64_t)(v140 - v163 - v158) < 0x20)
          {
            v166 = v140;
            goto LABEL_184;
          }
          v193 = (v165 >> 2) + 1;
          v166 = &v140[-4 * (v193 & 0x7FFFFFFFFFFFFFF8)];
          v194 = &v163[4 * v159 - 16];
          v195 = v140 - 16;
          v196 = v193 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v197 = *(_OWORD *)v195;
            *(v194 - 1) = *((_OWORD *)v195 - 1);
            *v194 = v197;
            v194 -= 2;
            v195 -= 32;
            v196 -= 8;
          }
          while (v196);
          v164 -= 4 * (v193 & 0x7FFFFFFFFFFFFFF8);
          if (v193 != (v193 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_184:
              v198 = *((_DWORD *)v166 - 1);
              v166 -= 4;
              *((_DWORD *)v164 - 1) = v198;
              v164 -= 4;
            }
            while (v166 != v157);
          }
        }
        v138 = &v163[4 * v162];
        *v137 = v164;
        v137[1] = v156;
        v137[2] = v138;
        if (v157)
        {
          operator delete(v157);
          v138 = v137[2];
        }
LABEL_187:
        v137[1] = v156;
        if (v156 < v138)
        {
          v116.i32[3] = HIDWORD(v765[1]);
          *(_DWORD *)v156 = v765[1];
          v199 = v156 + 4;
          goto LABEL_210;
        }
        v200 = *v137;
        v201 = v156 - *v137;
        v202 = v201 >> 2;
        v203 = (v201 >> 2) + 1;
        if (v203 >> 62)
LABEL_835:
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v204 = v138 - v200;
        if (v204 >> 1 > v203)
          v203 = v204 >> 1;
        if ((unint64_t)v204 >= 0x7FFFFFFFFFFFFFFCLL)
          v205 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v205 = v203;
        if (v205)
        {
          if (v205 >> 62)
            goto LABEL_834;
          v206 = operator new(4 * v205);
          v55 = v758;
        }
        else
        {
          v206 = 0;
        }
        v207 = &v206[4 * v202];
        v116.i32[3] = HIDWORD(v765[1]);
        *(_DWORD *)v207 = v765[1];
        v199 = v207 + 4;
        if (v156 != v200)
        {
          v208 = v156 - 4 - v200;
          if (v208 < 0x2C)
          {
            v209 = v156;
            goto LABEL_207;
          }
          if ((unint64_t)(v156 - v206 - v201) < 0x20)
          {
            v209 = v156;
            goto LABEL_207;
          }
          v210 = (v208 >> 2) + 1;
          v209 = &v156[-4 * (v210 & 0x7FFFFFFFFFFFFFF8)];
          v211 = (float32x4_t *)&v206[4 * v202 - 16];
          v212 = (float32x4_t *)(v156 - 16);
          v213 = v210 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v116 = *v212;
            v211[-1] = v212[-1];
            *v211 = v116;
            v211 -= 2;
            v212 -= 2;
            v213 -= 8;
          }
          while (v213);
          v207 -= 4 * (v210 & 0x7FFFFFFFFFFFFFF8);
          if (v210 != (v210 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_207:
              v214 = *((_DWORD *)v209 - 1);
              v209 -= 4;
              *((_DWORD *)v207 - 1) = v214;
              v207 -= 4;
            }
            while (v209 != v200);
          }
        }
        *v137 = v207;
        v137[1] = v199;
        v137[2] = &v206[4 * v205];
        if (v200)
          operator delete(v200);
LABEL_210:
        v137[1] = v199;
        v216 = *((_QWORD *)a1 + 19);
        v215 = *((_QWORD *)a1 + 20);
        v217 = 0xAAAAAAAAAAAAAAABLL * ((v215 - v216) >> 3);
        if (v215 == v216)
        {
          std::vector<std::vector<unsigned int>>::__append((uint64_t)v750, 1 - v217);
        }
        else if (v217 >= 2)
        {
          v218 = v216 + 24;
          if (v215 != v216 + 24)
          {
            v219 = *((_QWORD *)a1 + 20);
            do
            {
              v221 = *(void **)(v219 - 24);
              v219 -= 24;
              v220 = v221;
              if (v221)
              {
                *(_QWORD *)(v215 - 16) = v220;
                operator delete(v220);
              }
              v215 = v219;
            }
            while (v219 != v218);
          }
          *((_QWORD *)a1 + 20) = v218;
        }
        v222 = *((_QWORD *)a1 + 28);
        v223 = (int *)(v222 + 4 * v118);
        v224 = (int *)(v222 + 4 * (v118 + 3));
        v225 = *((_QWORD *)a1 + 19);
        v226 = *(char **)(v225 + 8);
        v767 = v224;
        while (2)
        {
          v228 = *v223;
          v229 = *(_QWORD *)(v225 + 16);
          if ((unint64_t)v226 >= v229)
          {
            v230 = *(char **)v225;
            v231 = (uint64_t)&v226[-*(_QWORD *)v225];
            v232 = v231 >> 2;
            v233 = (v231 >> 2) + 1;
            if (v233 >> 62)
              std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
            v234 = v229 - (_QWORD)v230;
            if (v234 >> 1 > v233)
              v233 = v234 >> 1;
            if ((unint64_t)v234 >= 0x7FFFFFFFFFFFFFFCLL)
              v235 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v235 = v233;
            if (v235)
            {
              if (v235 >> 62)
                goto LABEL_834;
              v236 = operator new(4 * v235);
            }
            else
            {
              v236 = 0;
            }
            v237 = &v236[4 * v232];
            *v237 = v228;
            v227 = (char *)(v237 + 1);
            if (v226 == v230)
            {
              v55 = v758;
              goto LABEL_239;
            }
            v238 = v226 - 4 - v230;
            if (v238 < 0xBC
              || &v236[v231 - 4 - (v238 & 0xFFFFFFFFFFFFFFFCLL)] > &v236[v231 - 4]
              || &v226[-(v238 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v226 - 4
              || (unint64_t)(v226 - v236 - v231) < 0x20)
            {
              v239 = v226;
              v55 = v758;
            }
            else
            {
              v241 = (v238 >> 2) + 1;
              v239 = &v226[-4 * (v241 & 0x7FFFFFFFFFFFFFF8)];
              v242 = (float32x4_t *)&v236[4 * v232 - 16];
              v243 = (float32x4_t *)(v226 - 16);
              v244 = v241 & 0x7FFFFFFFFFFFFFF8;
              v55 = v758;
              do
              {
                v116 = *v243;
                v242[-1] = v243[-1];
                *v242 = v116;
                v242 -= 2;
                v243 -= 2;
                v244 -= 8;
              }
              while (v244);
              v237 -= v241 & 0x7FFFFFFFFFFFFFF8;
              if (v241 == (v241 & 0x7FFFFFFFFFFFFFF8))
              {
LABEL_239:
                *(_QWORD *)v225 = v237;
                *(_QWORD *)(v225 + 8) = v227;
                *(_QWORD *)(v225 + 16) = &v236[4 * v235];
                if (v230)
                  operator delete(v230);
                v224 = v767;
LABEL_221:
                *(_QWORD *)(v225 + 8) = v227;
                ++v223;
                v226 = v227;
                if (v223 == v224)
                  goto LABEL_93;
                continue;
              }
            }
            do
            {
              v240 = *((_DWORD *)v239 - 1);
              v239 -= 4;
              *--v237 = v240;
            }
            while (v239 != v230);
            goto LABEL_239;
          }
          break;
        }
        *(_DWORD *)v226 = v228;
        v227 = v226 + 4;
        goto LABEL_221;
      }
      if (*(_QWORD *)&buf[8] != *(_QWORD *)buf)
        break;
LABEL_93:
      v115 = (v755 + 1);
      v91 = (uint64_t)v778;
      if (v115 >= ((uint64_t)(v779[0] - (_QWORD)v778) >> 2) / 3uLL)
      {
        v110 = (__int32 **)*((_QWORD *)a1 + 20);
        goto LABEL_445;
      }
    }
    v121 = 0;
    v122 = 0;
    while (1)
    {
      v123 = *(_QWORD *)(*(_QWORD *)buf + 24 * v121);
      v116.i64[0] = *(_QWORD *)v123;
      v116.i32[2] = *(_DWORD *)(v123 + 8);
      v116 = (float32x4_t)vceqq_f32(v116, *(float32x4_t *)v765);
      *(int16x4_t *)v116.f32 = vmovn_s32((int32x4_t)v116);
      if ((v116.i8[0] & 1) != 0 && (v116.i8[2] & 1) != 0 && (v116.i8[4] & 1) != 0)
        break;
      if (v120 - 1 == v121)
      {
        v136 = v122 + 2;
        if (v136 <= v120)
        {
          if (v136 < v120)
          {
            v174 = *(_QWORD *)buf + 24 * v136;
            if (*(_QWORD *)&buf[8] != v174)
            {
              v175 = *(_QWORD *)&buf[8];
              do
              {
                v177 = *(void **)(v175 - 24);
                v175 -= 24;
                v176 = v177;
                if (v177)
                {
                  *(_QWORD *)(v119 - 16) = v176;
                  operator delete(v176);
                }
                v119 = v175;
              }
              while (v175 != v174);
            }
            *(_QWORD *)&buf[8] = v174;
          }
        }
        else
        {
          std::vector<std::vector<float>>::__append((uint64_t *)buf, v136 - v120);
        }
        v752 = v122 + 2;
        v748 = v122 + 1;
        v178 = *(_QWORD *)buf + 24 * (v122 + 1);
        v180 = (char **)(v178 + 8);
        v179 = *(char **)(v178 + 8);
        v182 = (char **)(v178 + 16);
        v181 = *(char **)(v178 + 16);
        if (v179 < v181)
        {
          v116.i32[3] = HIDWORD(v765[1]);
          *(_DWORD *)v179 = v765[0];
          v183 = v179 + 4;
          goto LABEL_309;
        }
        v184 = (char **)(v178 + 8);
        v747 = (char **)(v178 + 16);
        v185 = *(_QWORD *)buf + 24 * v748;
        v186 = *(char **)v178;
        v187 = (uint64_t)&v179[-*(_QWORD *)v178];
        v188 = v187 >> 2;
        v189 = (v187 >> 2) + 1;
        if (v189 >> 62)
          goto LABEL_841;
        v190 = v181 - v186;
        if (v190 >> 1 > v189)
          v189 = v190 >> 1;
        if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFFCLL)
          v191 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v191 = v189;
        if (v191)
        {
          if (!(v191 >> 62))
          {
            v192 = operator new(4 * v191);
            goto LABEL_298;
          }
LABEL_838:
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v192 = 0;
LABEL_298:
        v280 = &v192[4 * v188];
        v116.i32[3] = HIDWORD(v765[1]);
        *v280 = v765[0];
        v183 = (char *)(v280 + 1);
        if (v179 == v186)
        {
          v178 = v185;
          v180 = v184;
        }
        else
        {
          v281 = v179 - 4 - v186;
          if (v281 < 0x2C)
          {
            v178 = v185;
            v180 = v184;
            goto LABEL_306;
          }
          v282 = v179 - &v192[v187];
          v178 = v185;
          v180 = v184;
          if (v282 < 0x20)
            goto LABEL_852;
          v283 = (v281 >> 2) + 1;
          v284 = (float32x4_t *)&v192[4 * v188 - 16];
          v285 = (float32x4_t *)(v179 - 16);
          v286 = v283 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v116 = *v285;
            v284[-1] = v285[-1];
            *v284 = v116;
            v284 -= 2;
            v285 -= 2;
            v286 -= 8;
          }
          while (v286);
          v280 -= v283 & 0x7FFFFFFFFFFFFFF8;
          v179 -= 4 * (v283 & 0x7FFFFFFFFFFFFFF8);
          if (v283 != (v283 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_852:
            do
            {
LABEL_306:
              v287 = *((_DWORD *)v179 - 1);
              v179 -= 4;
              *--v280 = v287;
            }
            while (v179 != v186);
          }
        }
        *(_QWORD *)v178 = v280;
        v181 = &v192[4 * v191];
        *v180 = v183;
        v182 = v747;
        *v747 = v181;
        if (v186)
        {
          operator delete(v186);
          v181 = *v747;
        }
LABEL_309:
        *v180 = v183;
        if (v183 < v181)
        {
          *(_DWORD *)v183 = HIDWORD(v765[0]);
          v288 = v183 + 4;
          goto LABEL_330;
        }
        v289 = v180;
        v290 = v182;
        v291 = v178;
        v292 = *(char **)v178;
        v293 = (uint64_t)&v183[-*(_QWORD *)v178];
        v294 = v293 >> 2;
        v295 = (v293 >> 2) + 1;
        if (v295 >> 62)
          goto LABEL_841;
        v296 = v181 - v292;
        if (v296 >> 1 > v295)
          v295 = v296 >> 1;
        if ((unint64_t)v296 >= 0x7FFFFFFFFFFFFFFCLL)
          v297 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v297 = v295;
        if (v297)
        {
          if (v297 >> 62)
            goto LABEL_838;
          v298 = v297;
          v299 = operator new(4 * v297);
          v297 = v298;
        }
        else
        {
          v299 = 0;
        }
        v300 = &v299[4 * v294];
        *v300 = HIDWORD(v765[0]);
        v288 = (char *)(v300 + 1);
        if (v183 == v292)
        {
          v182 = v290;
          v178 = v291;
          v180 = v289;
        }
        else
        {
          v301 = v183 - 4 - v292;
          if (v301 < 0x2C || (unint64_t)(v183 - v299 - v293) < 0x20)
          {
            v302 = v183;
            v182 = v290;
            v178 = v291;
            v180 = v289;
            goto LABEL_325;
          }
          v325 = (v301 >> 2) + 1;
          v302 = &v183[-4 * (v325 & 0x7FFFFFFFFFFFFFF8)];
          v326 = (float32x4_t *)&v299[4 * v294 - 16];
          v327 = (float32x4_t *)(v183 - 16);
          v328 = v325 & 0x7FFFFFFFFFFFFFF8;
          v178 = v291;
          do
          {
            v116 = *v327;
            v326[-1] = v327[-1];
            *v326 = v116;
            v326 -= 2;
            v327 -= 2;
            v328 -= 8;
          }
          while (v328);
          v300 -= v325 & 0x7FFFFFFFFFFFFFF8;
          v182 = v290;
          v180 = v289;
          if (v325 != (v325 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_325:
              v303 = *((_DWORD *)v302 - 1);
              v302 -= 4;
              *--v300 = v303;
            }
            while (v302 != v292);
          }
        }
        *(_QWORD *)v178 = v300;
        v181 = &v299[4 * v297];
        *v180 = v288;
        *v182 = v181;
        if (v292)
        {
          operator delete(v292);
          v181 = *v182;
        }
LABEL_330:
        *v180 = v288;
        if (v288 < v181)
        {
          *(_DWORD *)v288 = v765[1];
          v304 = v288 + 4;
          goto LABEL_365;
        }
        v768 = v180;
        v305 = v182;
        v306 = (_QWORD *)v178;
        v307 = *(char **)v178;
        v308 = (uint64_t)&v288[-*(_QWORD *)v178];
        v309 = v308 >> 2;
        v310 = (v308 >> 2) + 1;
        if (v310 >> 62)
LABEL_841:
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v311 = v181 - v307;
        if (v311 >> 1 > v310)
          v310 = v311 >> 1;
        if ((unint64_t)v311 >= 0x7FFFFFFFFFFFFFFCLL)
          v312 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v312 = v310;
        if (v312)
        {
          if (v312 >> 62)
            goto LABEL_838;
          v313 = operator new(4 * v312);
        }
        else
        {
          v313 = 0;
        }
        v314 = &v313[4 * v309];
        *v314 = v765[1];
        v304 = (char *)(v314 + 1);
        if (v288 != v307)
        {
          v315 = v288 - 4 - v307;
          if (v315 < 0x2C)
          {
            v316 = v288;
            goto LABEL_362;
          }
          if ((unint64_t)(v288 - v313 - v308) < 0x20)
          {
            v316 = v288;
            goto LABEL_362;
          }
          v329 = (v315 >> 2) + 1;
          v316 = &v288[-4 * (v329 & 0x7FFFFFFFFFFFFFF8)];
          v330 = (float32x4_t *)&v313[4 * v309 - 16];
          v331 = (float32x4_t *)(v288 - 16);
          v332 = v329 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v116 = *v331;
            v330[-1] = v331[-1];
            *v330 = v116;
            v330 -= 2;
            v331 -= 2;
            v332 -= 8;
          }
          while (v332);
          v314 -= v329 & 0x7FFFFFFFFFFFFFF8;
          if (v329 != (v329 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_362:
              v333 = *((_DWORD *)v316 - 1);
              v316 -= 4;
              *--v314 = v333;
            }
            while (v316 != v307);
          }
        }
        *v306 = v314;
        v180 = v768;
        *v768 = v304;
        *v305 = &v313[4 * v312];
        if (v307)
          operator delete(v307);
LABEL_365:
        *v180 = v304;
        v335 = *((_QWORD *)a1 + 19);
        v334 = *((_QWORD *)a1 + 20);
        v336 = 0xAAAAAAAAAAAAAAABLL * ((v334 - v335) >> 3);
        if (v752 <= v336)
        {
          if (v752 < v336)
          {
            v337 = v335 + 24 * v752;
            if (v334 != v337)
            {
              v338 = *((_QWORD *)a1 + 20);
              do
              {
                v340 = *(void **)(v338 - 24);
                v338 -= 24;
                v339 = v340;
                if (v340)
                {
                  *(_QWORD *)(v334 - 16) = v339;
                  operator delete(v339);
                }
                v334 = v338;
              }
              while (v338 != v337);
            }
            *((_QWORD *)a1 + 20) = v337;
          }
        }
        else
        {
          std::vector<std::vector<unsigned int>>::__append((uint64_t)v750, v752 - v336);
        }
        v128 = *((_QWORD *)a1 + 19) + 24 * v748;
        v130 = (char **)(v128 + 8);
        v341 = *(char **)(v128 + 8);
        v342 = (_DWORD *)(*((_QWORD *)a1 + 28) + 4 * v118);
        v268 = (char **)(v128 + 16);
        v343 = *(char **)(v128 + 16);
        v344 = *v342;
        v753 = v128;
        v769 = v342;
        if (v341 < v343)
        {
          *(_DWORD *)v341 = v344;
          v345 = v341 + 4;
          goto LABEL_396;
        }
        v346 = *(char **)v128;
        v347 = (uint64_t)&v341[-*(_QWORD *)v128];
        v348 = v347 >> 2;
        v349 = (v347 >> 2) + 1;
        if (v349 >> 62)
          goto LABEL_837;
        v350 = v343 - v346;
        if (v350 >> 1 > v349)
          v349 = v350 >> 1;
        if ((unint64_t)v350 >= 0x7FFFFFFFFFFFFFFCLL)
          v351 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v351 = v349;
        if (v351)
        {
          if (v351 >> 62)
            goto LABEL_838;
          v352 = operator new(4 * v351);
          v128 = v753;
        }
        else
        {
          v352 = 0;
        }
        v353 = &v352[4 * v348];
        *v353 = v344;
        v345 = (char *)(v353 + 1);
        if (v341 != v346)
        {
          v354 = v341 - 4 - v346;
          if (v354 < 0x2C)
            goto LABEL_853;
          if ((unint64_t)(v341 - &v352[v347]) < 0x20)
            goto LABEL_853;
          v355 = (v354 >> 2) + 1;
          v356 = (float32x4_t *)&v352[4 * v348 - 16];
          v357 = (float32x4_t *)(v341 - 16);
          v358 = v355 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v116 = *v357;
            v356[-1] = v357[-1];
            *v356 = v116;
            v356 -= 2;
            v357 -= 2;
            v358 -= 8;
          }
          while (v358);
          v353 -= v355 & 0x7FFFFFFFFFFFFFF8;
          v341 -= 4 * (v355 & 0x7FFFFFFFFFFFFFF8);
          if (v355 != (v355 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_853:
            do
            {
              v359 = *((_DWORD *)v341 - 1);
              v341 -= 4;
              *--v353 = v359;
            }
            while (v341 != v346);
          }
        }
        *(_QWORD *)v128 = v353;
        v343 = &v352[4 * v351];
        *v130 = v345;
        *v268 = v343;
        if (v346)
        {
          operator delete(v346);
          v128 = v753;
          v343 = *v268;
        }
        v342 = v769;
LABEL_396:
        *v130 = v345;
        v360 = v342[1];
        if (v345 < v343)
        {
          *(_DWORD *)v345 = v360;
          v253 = v345 + 4;
          goto LABEL_420;
        }
        v361 = *(char **)v128;
        v362 = (uint64_t)&v345[-*(_QWORD *)v128];
        v363 = v362 >> 2;
        v364 = (v362 >> 2) + 1;
        if (v364 >> 62)
          goto LABEL_837;
        v365 = v343 - v361;
        if (v365 >> 1 > v364)
          v364 = v365 >> 1;
        if ((unint64_t)v365 >= 0x7FFFFFFFFFFFFFFCLL)
          v366 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v366 = v364;
        if (v366)
        {
          if (v366 >> 62)
            goto LABEL_838;
          v367 = operator new(4 * v366);
          v128 = v753;
        }
        else
        {
          v367 = 0;
        }
        v368 = &v367[4 * v363];
        *v368 = v360;
        v253 = (char *)(v368 + 1);
        if (v345 != v361)
        {
          v369 = v345 - 4 - v361;
          if (v369 < 0x2C)
          {
            v370 = v345;
            goto LABEL_416;
          }
          if ((unint64_t)(v345 - v367 - v362) < 0x20)
          {
            v370 = v345;
            goto LABEL_416;
          }
          v371 = (v369 >> 2) + 1;
          v370 = &v345[-4 * (v371 & 0x7FFFFFFFFFFFFFF8)];
          v372 = (float32x4_t *)&v367[4 * v363 - 16];
          v373 = (float32x4_t *)(v345 - 16);
          v374 = v371 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v116 = *v373;
            v372[-1] = v373[-1];
            *v372 = v116;
            v372 -= 2;
            v373 -= 2;
            v374 -= 8;
          }
          while (v374);
          v368 -= v371 & 0x7FFFFFFFFFFFFFF8;
          if (v371 != (v371 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_416:
              v375 = *((_DWORD *)v370 - 1);
              v370 -= 4;
              *--v368 = v375;
            }
            while (v370 != v361);
          }
        }
        *(_QWORD *)v128 = v368;
        v343 = &v367[4 * v366];
        *v130 = v253;
        *v268 = v343;
        if (v361)
        {
          operator delete(v361);
          v128 = v753;
          v343 = *v268;
        }
        v342 = v769;
LABEL_420:
        *v130 = v253;
        v267 = v342[2];
        if (v253 >= v343)
        {
          v269 = *(char **)v128;
          v376 = (uint64_t)&v253[-*(_QWORD *)v128];
          v377 = v376 >> 2;
          v378 = (v376 >> 2) + 1;
          if (!(v378 >> 62))
          {
            v379 = v343 - v269;
            if (v379 >> 1 > v378)
              v378 = v379 >> 1;
            if ((unint64_t)v379 >= 0x7FFFFFFFFFFFFFFCLL)
              v274 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v274 = v378;
            if (v274)
            {
              if (v274 >> 62)
                goto LABEL_838;
              v275 = operator new(4 * v274);
              v128 = v753;
            }
            else
            {
              v275 = 0;
            }
            v276 = &v275[4 * v377];
            *v276 = v267;
            v117 = (char *)(v276 + 1);
            if (v253 != v269)
            {
              v380 = v253 - 4 - v269;
              if (v380 < 0x2C || (unint64_t)(v253 - v275 - v376) < 0x20)
              {
                v381 = v253;
                v55 = v758;
                goto LABEL_435;
              }
              v383 = (v380 >> 2) + 1;
              v381 = &v253[-4 * (v383 & 0x7FFFFFFFFFFFFFF8)];
              v384 = (float32x4_t *)&v275[4 * v377 - 16];
              v385 = (float32x4_t *)(v253 - 16);
              v386 = v383 & 0x7FFFFFFFFFFFFFF8;
              v55 = v758;
              do
              {
                v116 = *v385;
                v384[-1] = v385[-1];
                *v384 = v116;
                v384 -= 2;
                v385 -= 2;
                v386 -= 8;
              }
              while (v386);
              v276 -= v383 & 0x7FFFFFFFFFFFFFF8;
              if (v383 != (v383 & 0x7FFFFFFFFFFFFFF8))
              {
                do
                {
LABEL_435:
                  v382 = *((_DWORD *)v381 - 1);
                  v381 -= 4;
                  *--v276 = v382;
                }
                while (v381 != v269);
              }
              goto LABEL_438;
            }
LABEL_437:
            v55 = v758;
            goto LABEL_438;
          }
LABEL_837:
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        }
        goto LABEL_91;
      }
      v121 = ++v122;
      if (v120 <= v122)
        goto LABEL_93;
    }
    v128 = *((_QWORD *)a1 + 19) + 24 * v121;
    v130 = (char **)(v128 + 8);
    v129 = *(char **)(v128 + 8);
    v131 = (int *)(*((_QWORD *)a1 + 28) + 4 * v118);
    v133 = (char **)(v128 + 16);
    v132 = *(char **)(v128 + 16);
    v134 = *v131;
    v751 = v128;
    if (v129 >= v132)
    {
      v766 = (char **)(v128 + 16);
      v167 = *(char **)v128;
      v168 = (uint64_t)&v129[-*(_QWORD *)v128];
      v169 = v168 >> 2;
      v170 = (v168 >> 2) + 1;
      if (v170 >> 62)
        goto LABEL_837;
      v171 = v132 - v167;
      if (v171 >> 1 > v170)
        v170 = v171 >> 1;
      if ((unint64_t)v171 >= 0x7FFFFFFFFFFFFFFCLL)
        v172 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v172 = v170;
      if (v172)
      {
        if (v172 >> 62)
          goto LABEL_838;
        v173 = operator new(4 * v172);
        v128 = v751;
      }
      else
      {
        v173 = 0;
      }
      v245 = &v173[4 * v169];
      *v245 = v134;
      v135 = (char *)(v245 + 1);
      if (v129 != v167)
      {
        v246 = v129 - 4 - v167;
        if (v246 < 0x2C)
          goto LABEL_854;
        if ((unint64_t)(v129 - &v173[v168]) < 0x20)
          goto LABEL_854;
        v247 = (v246 >> 2) + 1;
        v248 = (float32x4_t *)&v173[4 * v169 - 16];
        v249 = (float32x4_t *)(v129 - 16);
        v250 = v247 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v116 = *v249;
          v248[-1] = v249[-1];
          *v248 = v116;
          v248 -= 2;
          v249 -= 2;
          v250 -= 8;
        }
        while (v250);
        v245 -= v247 & 0x7FFFFFFFFFFFFFF8;
        v129 -= 4 * (v247 & 0x7FFFFFFFFFFFFFF8);
        if (v247 != (v247 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_854:
          do
          {
            v251 = *((_DWORD *)v129 - 1);
            v129 -= 4;
            *--v245 = v251;
          }
          while (v129 != v167);
        }
      }
      *(_QWORD *)v128 = v245;
      v132 = &v173[4 * v172];
      *v130 = v135;
      v133 = v766;
      *v766 = v132;
      if (v167)
      {
        operator delete(v167);
        v128 = v751;
        v132 = *v766;
      }
    }
    else
    {
      *(_DWORD *)v129 = v134;
      v135 = v129 + 4;
    }
    *v130 = v135;
    v252 = v131[1];
    if (v135 < v132)
    {
      *(_DWORD *)v135 = v252;
      v253 = v135 + 4;
LABEL_280:
      *v130 = v253;
      v267 = v131[2];
      if (v253 < v132)
      {
LABEL_91:
        *(_DWORD *)v253 = v267;
        v117 = v253 + 4;
        v55 = v758;
        goto LABEL_92;
      }
      v268 = v133;
      v269 = *(char **)v128;
      v270 = (uint64_t)&v253[-*(_QWORD *)v128];
      v271 = v270 >> 2;
      v272 = (v270 >> 2) + 1;
      if (v272 >> 62)
        goto LABEL_837;
      v273 = v132 - v269;
      if (v273 >> 1 > v272)
        v272 = v273 >> 1;
      if ((unint64_t)v273 >= 0x7FFFFFFFFFFFFFFCLL)
        v274 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v274 = v272;
      if (v274)
      {
        if (v274 >> 62)
          goto LABEL_838;
        v275 = operator new(4 * v274);
        v128 = v751;
      }
      else
      {
        v275 = 0;
      }
      v276 = &v275[4 * v271];
      *v276 = v267;
      v117 = (char *)(v276 + 1);
      if (v253 == v269)
        goto LABEL_437;
      v277 = v253 - 4 - v269;
      if (v277 >= 0x2C && (unint64_t)(v253 - v275 - v270) >= 0x20)
      {
        v321 = (v277 >> 2) + 1;
        v278 = &v253[-4 * (v321 & 0x7FFFFFFFFFFFFFF8)];
        v322 = (float32x4_t *)&v275[4 * v271 - 16];
        v323 = (float32x4_t *)(v253 - 16);
        v324 = v321 & 0x7FFFFFFFFFFFFFF8;
        v55 = v758;
        do
        {
          v116 = *v323;
          v322[-1] = v323[-1];
          *v322 = v116;
          v322 -= 2;
          v323 -= 2;
          v324 -= 8;
        }
        while (v324);
        v276 -= v321 & 0x7FFFFFFFFFFFFFF8;
        if (v321 == (v321 & 0x7FFFFFFFFFFFFFF8))
          goto LABEL_438;
      }
      else
      {
        v278 = v253;
        v55 = v758;
      }
      do
      {
        v279 = *((_DWORD *)v278 - 1);
        v278 -= 4;
        *--v276 = v279;
      }
      while (v278 != v269);
LABEL_438:
      *(_QWORD *)v128 = v276;
      *v130 = v117;
      *v268 = &v275[4 * v274];
      if (v269)
        operator delete(v269);
LABEL_92:
      *v130 = v117;
      goto LABEL_93;
    }
    v254 = v133;
    v255 = *(char **)v128;
    v256 = (uint64_t)&v135[-*(_QWORD *)v128];
    v257 = v256 >> 2;
    v258 = (v256 >> 2) + 1;
    if (v258 >> 62)
      goto LABEL_837;
    v259 = v132 - v255;
    if (v259 >> 1 > v258)
      v258 = v259 >> 1;
    if ((unint64_t)v259 >= 0x7FFFFFFFFFFFFFFCLL)
      v260 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v260 = v258;
    if (v260)
    {
      if (v260 >> 62)
        goto LABEL_838;
      v261 = v260;
      v262 = operator new(4 * v260);
      v128 = v751;
      v260 = v261;
    }
    else
    {
      v262 = 0;
    }
    v263 = &v262[4 * v257];
    *v263 = v252;
    v253 = (char *)(v263 + 1);
    if (v135 == v255)
    {
      v133 = v254;
      goto LABEL_278;
    }
    v264 = v135 - 4 - v255;
    if (v264 >= 0x2C && (unint64_t)(v135 - v262 - v256) >= 0x20)
    {
      v317 = (v264 >> 2) + 1;
      v265 = &v135[-4 * (v317 & 0x7FFFFFFFFFFFFFF8)];
      v318 = (float32x4_t *)&v262[4 * v257 - 16];
      v319 = (float32x4_t *)(v135 - 16);
      v320 = v317 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v116 = *v319;
        v318[-1] = v319[-1];
        *v318 = v116;
        v318 -= 2;
        v319 -= 2;
        v320 -= 8;
      }
      while (v320);
      v263 -= v317 & 0x7FFFFFFFFFFFFFF8;
      v133 = v254;
      if (v317 == (v317 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_278:
        *(_QWORD *)v128 = v263;
        v132 = &v262[4 * v260];
        *v130 = v253;
        *v133 = v132;
        if (v255)
        {
          operator delete(v255);
          v128 = v751;
          v132 = *v133;
        }
        goto LABEL_280;
      }
    }
    else
    {
      v265 = v135;
      v133 = v254;
    }
    do
    {
      v266 = *((_DWORD *)v265 - 1);
      v265 -= 4;
      *--v263 = v266;
    }
    while (v265 != v255);
    goto LABEL_278;
  }
LABEL_445:
  if (*v750 != v110)
  {
    v110 = (__int32 **)*v750;
    do
    {
      v387 = *v110;
      v388 = v110[1];
      if (*v110 != v388)
      {
        v389 = *v110;
        do
        {
          v390 = *v389++;
          v391 = wmemchr(v389, v390, v388 - v389);
          if (v391)
            v392 = v391;
          else
            v392 = v388;
          v393 = v392 - v389 + 1;
          v394 = &v387[v393];
          v395 = v394 + 1;
          if (v394 != v388 && v395 != v388)
          {
            do
            {
              if (*v395 != *v387)
                v387[v393++] = *v395;
              ++v395;
            }
            while (v395 != v388);
          }
          v388 = &v387[v393];
          v387 = v389;
        }
        while (v393 != 1);
        if (v388 != v110[1])
          v110[1] = v388;
      }
      v110 += 3;
    }
    while (v110 != *((__int32 ***)a1 + 20));
  }
  if (v750 != &__p)
  {
    v397 = (uint64_t)*v750;
    v398 = 0xAAAAAAAAAAAAAAABLL * (((char *)v110 - (_BYTE *)*v750) >> 3);
    v399 = (uint64_t)v782;
    v400 = (char *)__p;
    if (0xAAAAAAAAAAAAAAABLL * ((v782 - (_BYTE *)__p) >> 3) >= v398)
    {
      v406 = v781;
      v407 = 0xAAAAAAAAAAAAAAABLL * ((v781 - (_BYTE *)__p) >> 3);
      if (v407 >= v398)
      {
        if ((__int32 **)v397 != v110)
        {
          do
          {
            if ((char *)v397 != v400)
              std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v400, *(char **)v397, *(_QWORD *)(v397 + 8), (uint64_t)(*(_QWORD *)(v397 + 8) - *(_QWORD *)v397) >> 2);
            v397 += 24;
            v400 += 24;
          }
          while ((__int32 **)v397 != v110);
          v406 = v781;
        }
        if (v406 != v400)
        {
          v414 = v406;
          do
          {
            v416 = (void *)*((_QWORD *)v414 - 3);
            v414 -= 24;
            v415 = v416;
            if (v416)
            {
              *((_QWORD *)v406 - 2) = v415;
              operator delete(v415);
            }
            v406 = v414;
          }
          while (v414 != v400);
        }
        v781 = v400;
        goto LABEL_504;
      }
      if (v781 != __p)
      {
        v408 = 8 * ((v781 - (_BYTE *)__p) >> 3);
        v409 = (char *)*v750;
        do
        {
          if (v409 != v400)
            std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v400, *(char **)v409, *((_QWORD *)v409 + 1), (uint64_t)(*((_QWORD *)v409 + 1) - *(_QWORD *)v409) >> 2);
          v409 += 24;
          v400 += 24;
          v408 -= 24;
        }
        while (v408);
        v400 = v781;
      }
      v413 = (char *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*,std::vector<unsigned int>*,std::vector<unsigned int>*>((uint64_t)&v782, v397 + 24 * v407, (uint64_t)v110, v400);
    }
    else
    {
      if (__p)
      {
        v401 = v781;
        v402 = __p;
        if (v781 != __p)
        {
          v403 = v781;
          do
          {
            v405 = (void *)*((_QWORD *)v403 - 3);
            v403 -= 24;
            v404 = v405;
            if (v405)
            {
              *((_QWORD *)v401 - 2) = v404;
              operator delete(v404);
            }
            v401 = v403;
          }
          while (v403 != v400);
          v402 = __p;
        }
        v781 = v400;
        operator delete(v402);
        v399 = 0;
        __p = 0;
        v781 = 0;
        v782 = 0;
      }
      if (v398 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_842;
      v410 = 0xAAAAAAAAAAAAAAABLL * (v399 >> 3);
      v411 = 2 * v410;
      if (2 * v410 <= v398)
        v411 = v398;
      v412 = v410 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v411;
      if (v412 > 0xAAAAAAAAAAAAAAALL)
LABEL_842:
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      __p = operator new(24 * v412);
      v781 = (char *)__p;
      v782 = (char *)__p + 24 * v412;
      v413 = (char *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*,std::vector<unsigned int>*,std::vector<unsigned int>*>((uint64_t)&v782, v397, (uint64_t)v110, __p);
    }
    v781 = v413;
  }
LABEL_504:
  std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((uint64_t)&v783, *(uint64_t *)buf, *(uint64_t *)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 3));
  LODWORD(v793) = 925353388;
  v417 = (const float **)v783;
  if (v784 != v783)
  {
    v418 = 0;
    v419 = 1;
    do
    {
      vDSP_vsmul(v417[3 * v418], 1, (const float *)&v793, (float *)v417[3 * v418], 1, 3uLL);
      v418 = v419;
      v417 = (const float **)v783;
      ++v419;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((v784 - (_BYTE *)v783) >> 3) > v418);
  }
  v421 = (_QWORD *)*((_QWORD *)a1 + 19);
  v420 = (_QWORD *)*((_QWORD *)a1 + 20);
  if (v421 != v420)
  {
    v422 = *(_QWORD *)buf;
    while (1)
    {
      while (v421[1] - *v421 > 0xFuLL)
      {
        v421 += 3;
        v422 += 24;
        if (v421 == v420)
          goto LABEL_536;
      }
      if (v421 + 3 == v420)
        break;
      v423 = v421;
      do
      {
        v426 = (void *)*v423;
        if (*v423)
        {
          v423[1] = v426;
          operator delete(v426);
          v423[1] = 0;
          v423[2] = 0;
        }
        v424 = v423 + 3;
        *(_OWORD *)v423 = *(_OWORD *)(v423 + 3);
        v423[2] = v423[5];
        v423[4] = 0;
        v423[5] = 0;
        v423[3] = 0;
        v425 = v423 + 6;
        v423 += 3;
      }
      while (v425 != v420);
      v420 = (_QWORD *)*((_QWORD *)a1 + 20);
      if (v420 != v424)
        goto LABEL_519;
LABEL_523:
      *((_QWORD *)a1 + 20) = v424;
      v430 = v422 + 24;
      v431 = *(_QWORD *)&buf[8];
      if (v422 + 24 != *(_QWORD *)&buf[8])
      {
        v432 = v422;
        do
        {
          v435 = *(void **)v432;
          if (*(_QWORD *)v432)
          {
            *(_QWORD *)(v432 + 8) = v435;
            operator delete(v435);
            *(_QWORD *)(v432 + 8) = 0;
            *(_QWORD *)(v432 + 16) = 0;
          }
          v433 = v432 + 24;
          *(_OWORD *)v432 = *(_OWORD *)(v432 + 24);
          *(_QWORD *)(v432 + 16) = *(_QWORD *)(v432 + 40);
          *(_QWORD *)(v432 + 32) = 0;
          *(_QWORD *)(v432 + 40) = 0;
          *(_QWORD *)(v432 + 24) = 0;
          v434 = v432 + 48;
          v432 += 24;
        }
        while (v434 != v431);
        v430 = *(_QWORD *)&buf[8];
        if (*(_QWORD *)&buf[8] == v433)
          goto LABEL_535;
LABEL_531:
        v436 = v430;
        do
        {
          v438 = *(void **)(v436 - 24);
          v436 -= 24;
          v437 = v438;
          if (v438)
          {
            *(_QWORD *)(v430 - 16) = v437;
            operator delete(v437);
          }
          v430 = v436;
        }
        while (v436 != v433);
        goto LABEL_535;
      }
      v433 = v422;
      if (v430 != v422)
        goto LABEL_531;
LABEL_535:
      *(_QWORD *)&buf[8] = v433;
      v420 = (_QWORD *)*((_QWORD *)a1 + 20);
      if (v421 == v420)
      {
LABEL_536:
        v421 = *v750;
        goto LABEL_538;
      }
    }
    v424 = v421;
    if (v420 == v421)
      goto LABEL_523;
LABEL_519:
    v427 = v420;
    do
    {
      v429 = (void *)*(v427 - 3);
      v427 -= 3;
      v428 = v429;
      if (v429)
      {
        *(v420 - 2) = v428;
        operator delete(v428);
      }
      v420 = v427;
    }
    while (v427 != v424);
    goto LABEL_523;
  }
  v420 = (_QWORD *)*((_QWORD *)a1 + 19);
LABEL_538:
  v439 = v420 - v421;
  __C.i32[0] = 0;
  v440 = *((_QWORD *)a1 + 10);
  v441 = (char **)(a1 + 20);
  v442 = (*((_QWORD *)a1 + 11) - v440) >> 2;
  v443 = v439 >= v442;
  if (v439 <= v442)
  {
    v445 = 0xAAAAAAAAAAAAAAABLL * v439;
    v444 = a1;
    if (!v443)
      *((_QWORD *)a1 + 11) = v440 + 4 * v439;
  }
  else
  {
    std::vector<float>::__append((void **)a1 + 10, v439 - v442, &__C);
    v444 = a1;
    v421 = (_QWORD *)*((_QWORD *)a1 + 19);
    v420 = (_QWORD *)*((_QWORD *)a1 + 20);
    v445 = 0xAAAAAAAAAAAAAAABLL * (v420 - v421);
  }
  v446 = *((_QWORD *)v444 + 13);
  v447 = *((_QWORD *)v444 + 14);
  v448 = (void **)(v444 + 26);
  __C.i32[0] = 0;
  v449 = (v447 - v446) >> 2;
  if (v445 <= v449)
  {
    if (v445 < v449)
      *((_QWORD *)a1 + 14) = v446 + 4 * v445;
  }
  else
  {
    std::vector<float>::__append(v448, v445 - v449, &__C);
    v421 = (_QWORD *)*((_QWORD *)a1 + 19);
    v420 = (_QWORD *)*((_QWORD *)a1 + 20);
  }
  v450 = v420;
  if (v420 != v421)
  {
    v451 = 0;
    do
    {
      v452 = (int **)&v421[3 * v451];
      v453 = *v452;
      v454 = v452[1];
      v455 = *v441;
      v456 = (char *)v454 - (char *)v453;
      if (v456)
      {
        v457 = v456 >> 2;
        v458 = *((_QWORD *)a1 + 7);
        v459 = (float)v457;
        v460 = (3 * v451);
        v461 = (v460 + 1);
        v462 = *(float *)&v455[4 * v460];
        v463 = *(float *)&v455[4 * v461];
        v464 = (v460 + 2);
        v465 = *(float *)&v455[4 * v464];
        if (v457 <= 1)
          v457 = 1;
        v466 = 1.0 / v459;
        do
        {
          v467 = *v453++;
          v462 = v462 + (float)(*(float *)(v458 + 4 * (3 * v467)) * v466);
          *(float *)&v455[4 * v460] = v462;
          v463 = v463 + (float)(*(float *)(v458 + 4 * (3 * v467 + 1)) * v466);
          *(float *)&v455[4 * v461] = v463;
          v465 = v465 + (float)(*(float *)(v458 + 4 * (3 * v467 + 2)) * v466);
          *(float *)&v455[4 * v464] = v465;
          --v457;
        }
        while (v457);
      }
      else
      {
        v460 = (3 * v451);
      }
      LODWORD(v788) = 0;
      vDSP_dotpr(*(const float **)(*(_QWORD *)buf + 24 * v451), 1, (const float *)&v455[4 * v460], 1, (float *)&v788, 3uLL);
      if (*(float *)&v788 == 0.0)
      {
        v792 = 0.0;
        __A = 0;
        v790 = 0.0;
        v789 = 0;
        __C = 0;
        v796 = 0;
        v797 = 0;
        *((_DWORD *)*v448 + v451) = 1065353216;
        v471 = *v441;
        v472 = *(float **)(*(_QWORD *)buf + 24 * v451);
        v473 = v472[1];
        *(float *)&__A = *(float *)&(*v441)[4 * v460] - (float)(*v472 * 0.00001);
        *(float *)&v789 = *(float *)&v471[4 * v460] + (float)(*v472 * 0.00001);
        v474 = 4 * (v460 + 1);
        *((float *)&__A + 1) = *(float *)&v471[v474] - (float)(v473 * 0.00001);
        v475 = v472[2];
        *((float *)&v789 + 1) = *(float *)&v471[v474] + (float)(v472[1] * 0.00001);
        v476 = 4 * (v460 + 2);
        v792 = *(float *)&v471[v476] - (float)(v475 * 0.00001);
        v790 = *(float *)&v471[v476] + (float)(v472[2] * 0.00001);
        VBAP::lineUnitSphereIntersection((VBAP *)&__A, (const float *)&v789, (float *)&__C, v468);
        v477 = (uint64_t)&(*v441)[4 * v460];
        v478 = (const float *)&(*v441)[4 * v460 + 4];
        v479 = (const float *)&(*v441)[4 * v460 + 8];
        v480 = vld1_dup_f32((const float *)v477);
        v481 = vsub_f32(v480, (float32x2_t)__PAIR64__(__C.u32[0], HIDWORD(v796)));
        v482 = vld1_dup_f32(v478);
        v483.i32[0] = vdup_lane_s32(v797, 1).u32[0];
        v484 = vcvtq_f64_f32(vsub_f32(v482, (float32x2_t)__PAIR64__(__C.u32[1], v797.u32[0])));
        v485 = vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(vmul_f32(v481, v481)), v484, v484));
        *(float32x2_t *)&v484.f64[0] = vld1_dup_f32(v479);
        v483.i32[1] = v796;
        v486 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)&v484.f64[0], v483));
        v487 = vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(v485), v486, v486));
        p_C = (float32x2_t *)((char *)&v796 + 4);
        if ((vmvn_s8((int8x8_t)vcge_f32((float32x2_t)vdup_lane_s32((int32x2_t)v487, 1), v487)).u8[0] & 1) == 0)
          p_C = &__C;
        v489 = p_C[1].i32[0];
        *(float32x2_t *)v477 = *p_C;
        *(_DWORD *)(v477 + 8) = v489;
      }
      else
      {
        __C.i32[0] = 0;
        vDSP_dotpr((const float *)&(*v441)[4 * v460], 1, (const float *)&(*v441)[4 * v460], 1, (float *)&__C, 3uLL);
        v469 = sqrtf(__C.f32[0]);
        *((float *)*v448 + v451) = v469;
        v470 = 1.0 / v469;
        __C.f32[0] = v470;
        if (*(float *)&v788 < 0.0)
          __C.f32[0] = -v470;
        vDSP_vsmul((const float *)&(*v441)[4 * v460], 1, (const float *)&__C, (float *)&(*v441)[4 * v460], 1, 3uLL);
      }
      ++v451;
      v421 = (_QWORD *)*((_QWORD *)a1 + 19);
      v450 = (_QWORD *)*((_QWORD *)a1 + 20);
    }
    while (0xAAAAAAAAAAAAAAABLL * (v450 - v421) > v451);
    v420 = (_QWORD *)*((_QWORD *)a1 + 19);
  }
  v490 = *(_QWORD *)buf;
  if (*(_QWORD *)buf)
  {
    v491 = *(_QWORD *)&buf[8];
    v492 = *(void **)buf;
    if (*(_QWORD *)&buf[8] != *(_QWORD *)buf)
    {
      v493 = *(_QWORD *)&buf[8];
      do
      {
        v495 = *(void **)(v493 - 24);
        v493 -= 24;
        v494 = v495;
        if (v495)
        {
          *(_QWORD *)(v491 - 16) = v494;
          operator delete(v494);
        }
        v491 = v493;
      }
      while (v493 != v490);
      v492 = *(void **)buf;
    }
    *(_QWORD *)&buf[8] = v490;
    operator delete(v492);
    v420 = (_QWORD *)*((_QWORD *)a1 + 19);
    v450 = (_QWORD *)*((_QWORD *)a1 + 20);
  }
  if (v450 == v420)
  {
    *a1 = 0;
    *(_DWORD *)buf = 0;
    std::vector<float>::assign(v441, 6uLL, buf);
  }
  if (v778)
  {
    v779[0] = v778;
    operator delete(v778);
  }
  v82 = *a1;
LABEL_577:
  if (v82)
    goto LABEL_710;
  v81 = *((unsigned __int8 *)a1 + 313);
  LODWORD(v63) = a1[75];
LABEL_579:
  LODWORD(v796) = 0;
  __C = 0;
  LODWORD(v779[0]) = 0;
  v778 = 0;
  v792 = 0.0;
  __A = 0;
  v790 = 0.0;
  v789 = 0;
  if (v81)
    goto LABEL_620;
  *(_QWORD *)buf = 0;
  v793 = 0.0;
  v788 = 0.0;
  v496 = (v63 + 1);
  if ((_DWORD)v63 == -1)
  {
    v497 = 0;
    v498 = 0;
    v499 = 0;
    v500 = 0;
    v501 = 0;
    v502 = 0;
    v503 = *((_QWORD *)a1 + 7);
    v504 = 0xFFFFFFFFLL;
    goto LABEL_586;
  }
  v501 = (char *)operator new(8 * v496);
  bzero(v501, 8 * v496);
  v500 = (char *)operator new(8 * v496);
  bzero(v500, 8 * v496);
  v502 = (char *)operator new(8 * v496);
  bzero(v502, 8 * v496);
  if ((_DWORD)v63)
  {
    v503 = *((_QWORD *)a1 + 7);
    v504 = v63;
    if (v63 < 0x10)
    {
      v505 = 0;
LABEL_594:
      v514 = 3 * v505;
      do
      {
        v515 = 8 * v505;
        *(double *)&v501[v515] = *(float *)(v503 + 4 * v514);
        *(double *)&v500[v515] = *(float *)(v503 + 4 * (v514 + 1));
        *(double *)&v502[v515] = *(float *)(v503 + 4 * (v514 + 2));
        ++v505;
        v514 += 3;
      }
      while (v504 != v505);
      goto LABEL_596;
    }
    v497 = v502;
    v498 = v501;
    v499 = v500;
LABEL_586:
    v505 = 0;
    v506 = 3 * (v63 - 1);
    if (v506 <= 0xFFFFFFFD && (v506 & 0xFFFFFFFF00000000) == 0)
    {
      v505 = 0;
      if ((unint64_t)(v499 - v498) >= 0x20
        && (unint64_t)(v497 - v498) >= 0x20
        && (unint64_t)(v497 - v499) >= 0x20)
      {
        v507 = 0;
        v508 = 0;
        v505 = v504 & 0xFFFFFFFC;
        v509 = v505;
        do
        {
          v510 = (const float *)(v503 + 4 * (v507 & 0xFFFFFFFC));
          v800 = vld3q_f32(v510);
          v511 = (float64x2_t *)&v501[v508];
          *v511 = vcvtq_f64_f32(*(float32x2_t *)v800.val[0].f32);
          v511[1] = vcvt_hight_f64_f32(v800.val[0]);
          v512 = (float64x2_t *)&v500[v508];
          *v512 = vcvtq_f64_f32(*(float32x2_t *)v800.val[1].f32);
          v512[1] = vcvt_hight_f64_f32(v800.val[1]);
          v513 = (float64x2_t *)&v502[v508];
          *v513 = vcvtq_f64_f32(*(float32x2_t *)v800.val[2].f32);
          v513[1] = vcvt_hight_f64_f32(v800.val[2]);
          v508 += 32;
          v507 += 12;
          v509 -= 4;
        }
        while (v509);
        if (v505 == v504)
          goto LABEL_596;
      }
    }
    goto LABEL_594;
  }
LABEL_596:
  vDSP_meanvD((const double *)v501, 1, (double *)buf, (v63 + 1));
  vDSP_meanvD((const double *)v500, 1, &v793, (a1[75] + 1));
  vDSP_meanvD((const double *)v502, 1, &v788, (a1[75] + 1));
  *(double *)buf = -*(double *)buf;
  v793 = -v793;
  v788 = -v788;
  vDSP_vsaddD((const double *)v501, 1, (const double *)buf, (double *)v501, 1, (a1[75] + 1));
  vDSP_vsaddD((const double *)v500, 1, &v793, (double *)v500, 1, (a1[75] + 1));
  vDSP_vsaddD((const double *)v502, 1, &v788, (double *)v502, 1, (a1[75] + 1));
  v519 = (a1[75] + 1);
  if (v519 >= 4)
  {
    v521 = 0;
    v520 = 1;
    while (2)
    {
      for (j = 0; j != v519; ++j)
      {
        if (j != v521)
        {
          v523 = 0;
          while (1)
          {
            if (v521 != v523 && j != v523)
            {
              v524.f64[0] = *(float64_t *)&v501[8 * v521];
              v524.f64[1] = *(float64_t *)&v500[8 * v521];
              v516.f64[0] = *(float64_t *)&v502[8 * v521];
              v525.f64[0] = *(float64_t *)&v501[8 * j];
              v525.f64[1] = *(float64_t *)&v500[8 * j];
              v517.f64[0] = *(float64_t *)&v502[8 * j];
              v526.f64[0] = *(float64_t *)&v501[8 * v523];
              v526.f64[1] = *(float64_t *)&v500[8 * v523];
              v518.f64[0] = *(float64_t *)&v502[8 * v523];
              v527 = vsubq_f64(v526, v524);
              v528 = vsubq_f64(v518, v516);
              v529 = vsubq_f64(v525, v524);
              v530 = vsubq_f64(v517, v516);
              v531 = vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v528, v529, 1)), v530, v527, 1);
              v530.f64[1] = v529.f64[0];
              v528.f64[1] = v527.f64[0];
              v518 = vmlaq_f64(vnegq_f64(vmulq_f64(v527, v530)), v529, v528);
              v532.f64[0] = v531.f64[0];
              v532.f64[1] = v518.f64[0];
              v517 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v518, 1);
              if (vaddvq_f64(vabsq_f64(v532)) + vabsq_f64(v517).f64[0] > 0.05)
                break;
            }
            if (v519 == ++v523)
              goto LABEL_600;
          }
          v533 = 0;
          v520 = 0;
          *(_QWORD *)&v532.f64[1] = vextq_s8((int8x16_t)v532, (int8x16_t)v532, 8uLL).u64[0];
          v534 = (float64x2_t)vextq_s8((int8x16_t)v518, (int8x16_t)v518, 8uLL);
          v518.f64[1] = v534.f64[0];
          v535 = vmulq_f64(v518, v518);
          v536 = sqrt(vmulq_f64(v531, v531).f64[0] + v535.f64[0] + v535.f64[1]);
          v537 = 1.0 / v536;
          do
          {
            if (v523 != v533 && v521 != v533 && j != v533)
            {
              v538.f64[0] = *(float64_t *)&v501[8 * v533];
              v538.f64[1] = *(float64_t *)&v500[8 * v533];
              v534.f64[0] = *(float64_t *)&v502[8 * v533];
              v534 = vmulq_f64(vsubq_f64(v534, v516), v517);
              if (fabs((vaddvq_f64(vmulq_f64(vsubq_f64(v538, v524), v532)) + v534.f64[0]) * v537) > 0.01)
                break;
            }
            v520 = ++v533 >= v519;
          }
          while (v519 != v533);
          goto LABEL_615;
        }
LABEL_600:
        ;
      }
      if (++v521 != v519)
        continue;
      break;
    }
  }
  else
  {
    v520 = 1;
  }
LABEL_615:
  operator delete(v502);
  operator delete(v500);
  operator delete(v501);
  v539 = a1[75];
  LODWORD(v63) = a1[75];
  if (v520)
  {
    if (v539 < 3)
    {
      v582 = a1;
      vDSP_meanv(*((const float **)a1 + 7), 3, (float *)&__C, a1[75]);
      vDSP_meanv((const float *)(*((_QWORD *)v582 + 7) + 4), 3, (float *)&__C + 1, v582[75]);
      vDSP_meanv((const float *)(*((_QWORD *)v582 + 7) + 8), 3, (float *)&v796, v582[75]);
    }
    else
    {
      v540 = (int64x2_t *)operator new(8 * v539);
      bzero(v540, 8 * v539);
      v541 = *((_QWORD *)a1 + 8) - *((_QWORD *)a1 + 7);
      memset(buf, 0, 24);
      v542 = (v541 >> 2) + 3;
      if (v541 >> 2 == -3)
      {
        v543 = 0;
      }
      else
      {
        if (v542 >> 62)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v543 = operator new(4 * v542);
        *(_QWORD *)buf = v543;
        *(_QWORD *)&buf[8] = v543;
        v542 = (unint64_t)&v543[v542];
        *(_QWORD *)&buf[16] = v542;
        bzero(v543, (v541 & 0xFFFFFFFFFFFFFFFCLL) + 12);
      }
      v585 = (unsigned __int128 *)operator new(4 * v539);
      bzero(v585, 4 * v539);
      v586 = *((_QWORD *)a1 + 1);
      if (v539 > 8
        && ((unint64_t)v585 >= 8 * v539 + v586 - 4 || v586 >= (unint64_t)v585 + 4 * v539))
      {
        v588 = v539 & 7;
        if ((v539 & 7) == 0)
          v588 = 8;
        v587 = v539 - v588;
        v589 = v585 + 1;
        v590 = (const float *)(v586 + 32);
        v591 = (int64x2_t)xmmword_1B6627110;
        v592 = (int64x2_t)xmmword_1B6626830;
        v593 = v540 + 2;
        v594 = vdupq_n_s64(4uLL);
        v595 = v587;
        do
        {
          v593[-2] = v592;
          v593[-1] = v591;
          *v593 = vaddq_s64(v592, v594);
          v593[1] = vaddq_s64(v591, v594);
          v593 += 4;
          v596 = v590 - 8;
          v597 = (unsigned __int128)vld2q_f32(v596);
          v598 = (unsigned __int128)vld2q_f32(v590);
          *(v589 - 1) = v597;
          *v589 = v598;
          v599 = vdupq_n_s64(8uLL);
          v591 = vaddq_s64(v591, v599);
          v592 = vaddq_s64(v592, v599);
          v589 += 2;
          v590 += 16;
          v595 -= 8;
        }
        while (v595);
      }
      else
      {
        v587 = 0;
      }
      v600 = (int *)(v586 + 8 * v587);
      do
      {
        v540->i64[v587] = v587;
        v601 = *v600;
        v600 += 2;
        *((_DWORD *)v585 + v587++) = v601;
      }
      while (v539 != v587);
      vDSP_vsorti((const float *)v585, (vDSP_Length *)v540, 0, v539, -1);
      v602 = a1[75];
      if ((_DWORD)v602)
      {
        v603 = 0;
        v604 = *((_QWORD *)a1 + 7);
        v605 = (uint64_t *)v540;
        do
        {
          v606 = *v605++;
          v607 = (_DWORD *)(v604 + 12 * v606);
          v543[v603] = *v607;
          v543[(v603 + 1)] = v607[1];
          v543[(v603 + 2)] = v607[2];
          v603 += 3;
        }
        while (3 * v602 != v603);
      }
      *(_DWORD *)(v542 - 12) = *v543;
      *(_DWORD *)(v542 - 8) = v543[1];
      *(_DWORD *)(v542 - 4) = v543[2];
      if ((_DWORD)v602)
      {
        v608 = 0;
        v609 = 0.0;
        do
        {
          v609 = v609
               + (float)((float)-(float)((float)(*(float *)&v543[(v608 + 1)]
                                               * *(float *)&v543[(v608 + 3)])
                                       - (float)(*(float *)&v543[(v608 + 4)]
                                               * *(float *)&v543[v608]))
                       * 0.5);
          v608 += 3;
        }
        while (3 * v602 != v608);
        v610 = 0;
        v611 = __C;
        v612 = v543[2];
        v613 = 3 * v602;
        v614 = 1.0 / v609;
        do
        {
          v615.i32[0] = v543[v610];
          v616.i32[0] = v543[(v610 + 3)];
          v616.i32[1] = v543[(v610 + 4)];
          v615.i32[1] = v543[(v610 + 1)];
          v611 = vmla_n_f32(v611, vadd_f32(v616, v615), (float)-(float)((float)(v615.f32[1] * v616.f32[0]) - (float)(v616.f32[1] * v615.f32[0]))* (float)(0.16667 * v614));
          v610 += 3;
        }
        while (v613 != v610);
        __C = v611;
        LODWORD(v796) = v612;
      }
      operator delete(v585);
      operator delete(v543);
      operator delete(v540);
      v582 = a1;
    }
    v617 = v582[75];
    if (v617 <= 1)
    {
      v621 = __C.f32[1];
      LODWORD(v620.f64[0]) = 0;
      v631 = 0.0;
      v630 = 0.0;
    }
    else
    {
      v618 = (float32x2_t *)*((_QWORD *)v582 + 7);
      v625 = vcvtq_f64_f32(vadd_f32(*v618, __C));
      v619 = (float64x2_t)vextq_s8((int8x16_t)v625, (int8x16_t)v625, 8uLL);
      v624.f64[0] = (float)(v618[1].f32[0] + *(float *)&v796);
      v624.f64[1] = v625.f64[0];
      v620 = (float64x2_t)vextq_s8((int8x16_t)v624, (int8x16_t)v624, 8uLL);
      v621 = __C.f32[1];
      v622 = 3 * v617;
      v623 = 6;
      v624.f64[1] = v620.f64[0];
      v625.f64[1] = v619.f64[0];
      do
      {
        v626.i32[0] = v618->i32[(v623 - 3)];
        v626.i32[1] = v618->i32[(v623 - 2)];
        v627 = vcvtq_f64_f32(vadd_f32(v626, __C));
        v620.f64[0] = (float)(v618->f32[(v623 - 1)] + *(float *)&v796);
        v628.f64[0] = v620.f64[0];
        v628.f64[1] = v627.f64[0];
        v584.f64[0] = (float)(v618[1].f32[0] + *(float *)&v796);
        v629 = vmlaq_f64(vnegq_f64(vmulq_laneq_f64(v584, v627, 1)), v619, v620).f64[0];
        v620 = vmlaq_f64(vnegq_f64(vmulq_f64(v628, v625)), v624, v627);
        v630 = v629;
        v631 = v620.f64[0];
        *(float *)v620.f64 = v620.f64[1];
        v632 = fabsf(v631);
        v633 = fabsf(v630) < 0.00001 && v632 < 0.00001;
        v634 = fabsf(*(float *)v620.f64);
        v636 = !v633 || v634 >= 0.00001 || v622 == v623;
        v623 += 3;
      }
      while (!v636);
    }
    *(float *)&__A = v630 - __C.f32[0];
    *((float *)&__A + 1) = v631 - v621;
    *(float *)&v789 = -(float)(__C.f32[0] + v630);
    *((float *)&v789 + 1) = -(float)(v621 + v631);
    v792 = *(float *)v620.f64 - *(float *)&v796;
    v790 = -(float)(*(float *)&v796 + *(float *)v620.f64);
    VBAP::lineUnitSphereIntersection((VBAP *)&__A, (const float *)&v789, *((float **)a1 + 10), v583);
    goto LABEL_710;
  }
LABEL_620:
  v544 = a1;
  vDSP_meanv(*((const float **)a1 + 7), 3, (float *)&__C, v63);
  vDSP_meanv((const float *)(*((_QWORD *)v544 + 7) + 4), 3, (float *)&__C + 1, v544[75]);
  vDSP_meanv((const float *)(*((_QWORD *)v544 + 7) + 8), 3, (float *)&v796, v544[75]);
  if ((float)((float)(fabsf(__C.f32[1]) + fabsf(__C.f32[0])) + fabsf(*(float *)&v796)) < 0.00003)
  {
    v546 = a1;
    v547 = *((_QWORD *)a1 + 10);
    if (*((_QWORD *)a1 + 11) == v547)
      goto LABEL_627;
    goto LABEL_622;
  }
  *(float *)&v778 = -__C.f32[0];
  *((float *)&v778 + 1) = -__C.f32[1];
  *(float *)v779 = -*(float *)&v796;
  v546 = a1;
  VBAP::lineUnitSphereIntersection((VBAP *)&__C, (const float *)&v778, *((float **)a1 + 10), v545);
  if (*((_BYTE *)a1 + 313))
  {
    v548 = *((_QWORD *)a1 + 10);
    v549 = *((_QWORD *)a1 + 11) - v548;
    if (v549 > 0xB)
    {
      v546 = a1;
      if (v549 != 12)
      {
        v547 = v548 + 12;
LABEL_622:
        *((_QWORD *)v546 + 11) = v547;
      }
    }
    else
    {
      std::vector<float>::__append((char **)a1 + 10, 3 - (v549 >> 2));
      v546 = a1;
    }
  }
LABEL_627:
  v550 = *((_QWORD *)v546 + 11) - *((_QWORD *)v546 + 10);
  if ((unint64_t)v550 < 0xC)
    goto LABEL_710;
  v551 = v546[75];
  if (!(_DWORD)v551)
    goto LABEL_710;
  v552 = 0;
  v553 = 0;
  v554 = 0;
  v555 = 0;
  LODWORD(v556) = 0;
  v557 = (v550 >> 2) / 3uLL;
  v770 = v557;
LABEL_631:
  v558 = 0;
  v561 = 3 * v551;
  do
  {
    v560 = *((_QWORD *)a1 + 7);
    v559 = *((_QWORD *)a1 + 10);
    if ((float)((float)(vabds_f32(*(float *)(v559 + 4 * (3 * v556 + 1)), *(float *)(v560 + 4 * (v558 + 1)))+ vabds_f32(*(float *)(v559 + 4 * (3 * v556)), *(float *)(v560 + 4 * v558)))+ vabds_f32(*(float *)(v559 + 4 * (3 * v556 + 2)), *(float *)(v560 + 4 * (v558 + 2)))) < 0.00000035763)
    {
      if (v555 < v554)
      {
        *(_DWORD *)v555 = v556;
        v555 += 4;
        break;
      }
      v562 = (v555 - v553) >> 2;
      v563 = v562 + 1;
      if ((unint64_t)(v562 + 1) >> 62)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      if ((v554 - v553) >> 1 > v563)
        v563 = (v554 - v553) >> 1;
      if ((unint64_t)(v554 - v553) >= 0x7FFFFFFFFFFFFFFCLL)
        v564 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v564 = v563;
      if (v564)
      {
        if (v564 >> 62)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v565 = operator new(4 * v564);
      }
      else
      {
        v565 = 0;
      }
      v552 = &v565[4 * v562];
      *(_DWORD *)v552 = v556;
      v566 = v552 + 4;
      if (v555 == v553)
      {
        v55 = v758;
        v554 = &v565[4 * v564];
        if (!v553)
          goto LABEL_653;
        goto LABEL_652;
      }
      v567 = v555 - 4 - v553;
      if (v567 < 0xBC
        || &v565[v555 - v553 - 4 - (v567 & 0xFFFFFFFFFFFFFFFCLL)] > &v565[v555 - v553 - 4]
        || &v555[-(v567 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v555 - 4
        || (unint64_t)(v553 - v565) < 0x20)
      {
        v568 = v555;
        v55 = v758;
      }
      else
      {
        v570 = (v567 >> 2) + 1;
        v568 = &v555[-4 * (v570 & 0x7FFFFFFFFFFFFFF8)];
        v571 = &v565[4 * v562 - 16];
        v572 = v555 - 16;
        v573 = v570 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v574 = *(_OWORD *)v572;
          *(v571 - 1) = *((_OWORD *)v572 - 1);
          *v571 = v574;
          v571 -= 2;
          v572 -= 32;
          v573 -= 8;
        }
        while (v573);
        v552 -= 4 * (v570 & 0x7FFFFFFFFFFFFFF8);
        v55 = v758;
        if (v570 == (v570 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_651:
          v554 = &v565[4 * v564];
          if (!v553)
          {
LABEL_653:
            v553 = v552;
            v555 = v566;
            v557 = v770;
            break;
          }
LABEL_652:
          operator delete(v553);
          goto LABEL_653;
        }
      }
      do
      {
        v569 = *((_DWORD *)v568 - 1);
        v568 -= 4;
        *((_DWORD *)v552 - 1) = v569;
        v552 -= 4;
      }
      while (v568 != v553);
      goto LABEL_651;
    }
    v558 += 3;
  }
  while (v561 != v558);
  while (1)
  {
    v556 = (v556 + 1);
    if (v557 <= v556)
      break;
    v551 = a1[75];
    if (a1[75])
      goto LABEL_631;
  }
  if (v555 == v552)
  {
    if (v552)
      goto LABEL_670;
  }
  else
  {
    v575 = 0;
    v576 = a1;
    v577 = *((_QWORD *)a1 + 11);
    v578 = (v555 - v552) >> 2;
    v579 = 1;
    do
    {
      v580 = *((_QWORD *)v576 + 10) + 12 * *(int *)&v552[4 * v575];
      v581 = v577 - (v580 + 12);
      if (v577 != v580 + 12)
        memmove((void *)(*((_QWORD *)v576 + 10) + 12 * *(int *)&v552[4 * v575]), (const void *)(v580 + 12), v577 - (v580 + 12));
      v577 = v580 + v581;
      v576 = a1;
      *((_QWORD *)a1 + 11) = v580 + v581;
      v575 = v579++;
    }
    while (v578 > v575);
LABEL_670:
    operator delete(v552);
  }
LABEL_710:
  v637 = (uint64_t)(*((_QWORD *)a1 + 11) - *((_QWORD *)a1 + 10)) >> 2;
  *((_QWORD *)a1 + 38) = v637 / 3;
  v638 = *((_QWORD *)a1 + 16);
  v639 = (*((_QWORD *)a1 + 17) - v638) >> 2;
  if (v637 / 3 <= v639)
  {
    v640 = a1;
    if (v637 / 3 < v639)
      *((_QWORD *)a1 + 17) = v638 + 4 * (v637 / 3);
  }
  else
  {
    std::vector<float>::__append((char **)a1 + 16, v637 / 3 - v639);
    v640 = a1;
    v637 = (uint64_t)(*((_QWORD *)a1 + 11) - *((_QWORD *)a1 + 10)) >> 2;
  }
  v643 = (void *)*((_QWORD *)v640 + 4);
  v642 = (uint64_t)(v640 + 8);
  v641 = v643;
  *(_QWORD *)(v642 + 8) = v643;
  v645 = *(char **)(v642 + 24);
  v644 = *(_QWORD *)(v642 + 32);
  v646 = (v644 - (uint64_t)v645) >> 2;
  v647 = v637 + v646;
  if (v637 + v646 > (uint64_t)(*(_QWORD *)(v642 + 16) - (_QWORD)v643) >> 2)
  {
    if (!(v647 >> 62))
    {
      v648 = (char *)operator new(4 * v647);
      *((_QWORD *)a1 + 4) = v648;
      *((_QWORD *)a1 + 5) = v648;
      *((_QWORD *)a1 + 6) = &v648[4 * v647];
      if (v641)
      {
        operator delete(v641);
        v645 = (char *)*((_QWORD *)a1 + 7);
        v644 = *((_QWORD *)a1 + 8);
        v646 = (v644 - (uint64_t)v645) >> 2;
      }
      goto LABEL_718;
    }
LABEL_840:
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
LABEL_718:
  std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)v642, v645, v644, v646);
  v657 = (_DWORD *)*((_QWORD *)a1 + 10);
  v656 = (_DWORD *)*((_QWORD *)a1 + 11);
  for (*(_QWORD *)buf = v642; v657 != v656; ++v657)
    std::back_insert_iterator<std::vector<float>>::operator=[abi:ne180100]((uint64_t *)buf, v657);
  if (*a1 != 1)
    goto LABEL_792;
  v658 = (const float **)v783;
  v659 = v784;
  if (v784 == v783)
    goto LABEL_792;
  v660 = 0;
  v661 = 1;
  while (2)
  {
    v662 = (char *)__p + 24 * v660;
    if (v662[1] - *v662 > 0xCuLL)
    {
LABEL_724:
      v660 = v661++;
      if (0xAAAAAAAAAAAAAAABLL * ((v659 - (char *)v658) >> 3) <= v660)
        goto LABEL_792;
      continue;
    }
    break;
  }
  *(_DWORD *)&buf[8] = 0;
  *(_QWORD *)buf = 0;
  v663 = (_DWORD *)*v662;
  v664 = *(_QWORD *)v642;
  v665 = 3 * *v663;
  *(_DWORD *)buf = *(_DWORD *)(*(_QWORD *)v642 + 4 * v665);
  *(_DWORD *)&buf[4] = *(_DWORD *)(v664 + 4 * (v665 + 1));
  *(_DWORD *)&buf[8] = *(_DWORD *)(v664 + 4 * (v665 + 2));
  v666 = 3 * v663[1];
  *(float *)buf = *(float *)buf + *(float *)(v664 + 4 * v666);
  *(float *)&buf[4] = *(float *)&buf[4] + *(float *)(v664 + 4 * (v666 + 1));
  *(float *)&buf[8] = *(float *)&buf[8] + *(float *)(v664 + 4 * (v666 + 2));
  LODWORD(v663) = 3 * v663[2];
  *(float *)buf = *(float *)buf + *(float *)(v664 + 4 * v663);
  *(float *)&buf[4] = *(float *)&buf[4] + *(float *)(v664 + 4 * ((_DWORD)v663 + 1));
  *(float *)&buf[8] = *(float *)&buf[8] + *(float *)(v664 + 4 * ((_DWORD)v663 + 2));
  __C.i32[0] = 0;
  vDSP_dotpr((const float *)buf, 1, v658[3 * v660], 1, (float *)&__C, 3uLL);
  LODWORD(v649) = __C.i32[0];
  if (__C.f32[0] > 0.0)
  {
    v658 = (const float **)v783;
    v659 = v784;
    goto LABEL_724;
  }
  LODWORD(v779[0]) = 0;
  v778 = 0;
  v667 = a1;
  vDSP_meanv(*((const float **)a1 + 4), 3, (float *)&v778, ((uint64_t)(*((_QWORD *)a1 + 5) - *((_QWORD *)a1 + 4)) >> 2) / 3uLL);
  vDSP_meanv((const float *)(*((_QWORD *)v667 + 4) + 4), 3, (float *)&v778 + 1, ((uint64_t)(*((_QWORD *)v667 + 5) - *((_QWORD *)v667 + 4)) >> 2) / 3uLL);
  vDSP_meanv((const float *)(*((_QWORD *)v667 + 4) + 8), 3, (float *)v779, ((uint64_t)(*((_QWORD *)v667 + 5) - *((_QWORD *)v667 + 4)) >> 2) / 3uLL);
  LODWORD(v788) = 0;
  vDSP_sve((const float *)&v778, 1, (float *)&v788, 3uLL);
  *(float *)&v788 = 1.0 / sqrtf(*(float *)&v788);
  __C = 0;
  v796 = 0;
  v797 = 0;
  vDSP_vsmul((const float *)&v778, 1, (const float *)&v788, (float *)&__C, 1, 3uLL);
  v794 = -*(float *)&v788;
  vDSP_vsmul((const float *)&v778, 1, &v794, (float *)&v796 + 1, 1, 3uLL);
  v793 = 0.0;
  vDSP_distancesq((const float *)&v778, 1, (const float *)&__C, 1, (float *)&v793, 3uLL);
  vDSP_distancesq((const float *)&v778, 1, (const float *)&v796 + 1, 1, (float *)&v793 + 1, 3uLL);
  v650.i32[0] = HIDWORD(v793);
  LODWORD(v649) = LODWORD(v793);
  v792 = 0.0;
  __A = 0;
  v668 = v781;
  if (v781 == __p)
  {
    v671 = 0;
  }
  else
  {
    v669 = 0;
    v670 = 0;
    v671 = 0;
    v672 = 12;
    if (*(float *)&v793 > *((float *)&v793 + 1))
      v672 = 0;
    v673 = (const float *)((char *)&__C + v672);
    v674 = 3.4028e38;
    v668 = (char *)__p;
    do
    {
      *(_DWORD *)&buf[8] = 0;
      *(_QWORD *)buf = 0;
      v675 = &v668[24 * v669];
      v676 = *(_QWORD *)v642;
      v677 = *(_DWORD **)v675;
      v678 = (float)(unint64_t)((uint64_t)(*((_QWORD *)v675 + 1) - *(_QWORD *)v675) >> 2);
      LODWORD(v675) = 3 * **(_DWORD **)v675;
      v679 = 1.0 / v678;
      *(float *)buf = *(float *)(*(_QWORD *)v642 + 4 * v675) * v679;
      *(float *)&buf[4] = *(float *)(v676 + 4 * ((_DWORD)v675 + 1)) * v679;
      *(float *)&buf[8] = *(float *)(v676 + 4 * ((_DWORD)v675 + 2)) * v679;
      LODWORD(v675) = 3 * v677[1];
      *(float *)buf = *(float *)buf + (float)(*(float *)(v676 + 4 * v675) * v679);
      *(float *)&buf[4] = *(float *)&buf[4] + (float)(*(float *)(v676 + 4 * ((_DWORD)v675 + 1)) * v679);
      *(float *)&buf[8] = *(float *)&buf[8] + (float)(*(float *)(v676 + 4 * ((_DWORD)v675 + 2)) * v679);
      LODWORD(v675) = 3 * v677[2];
      *(float *)buf = *(float *)buf + (float)(*(float *)(v676 + 4 * v675) * v679);
      *(float *)&buf[4] = *(float *)&buf[4] + (float)(*(float *)(v676 + 4 * ((_DWORD)v675 + 1)) * v679);
      *(float *)&buf[8] = *(float *)&buf[8] + (float)(*(float *)(v676 + 4 * ((_DWORD)v675 + 2)) * v679);
      vDSP_distancesq(v673, 1, (const float *)buf, 1, (float *)&v793, 3uLL);
      LODWORD(v649) = LODWORD(v793);
      if (*(float *)&v793 < v674)
      {
        __A = *(_QWORD *)buf;
        v792 = *(float *)&buf[8];
        v671 = v670;
        v674 = *(float *)&v793;
      }
      v668 = (char *)__p;
      v669 = ++v670;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((v781 - (_BYTE *)__p) >> 3) > v670);
  }
  v680 = &v668[24 * v671];
  v681 = v680 + 8;
  if (*((_QWORD *)v680 + 1) - *(_QWORD *)v680 > 0xCuLL)
    goto LABEL_792;
  v682 = *((_QWORD *)a1 + 21);
  v683 = (_QWORD *)*((_QWORD *)a1 + 20);
  if ((unint64_t)v683 >= v682)
  {
    v690 = *((_QWORD *)a1 + 19);
    v691 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v683 - v690) >> 3);
    if (v691 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v692 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v682 - v690) >> 3);
    v693 = 2 * v692;
    if (2 * v692 <= v691 + 1)
      v693 = v691 + 1;
    if (v692 >= 0x555555555555555)
      v694 = 0xAAAAAAAAAAAAAAALL;
    else
      v694 = v693;
    *(_QWORD *)&buf[32] = a1 + 42;
    if (v694)
    {
      if (v694 > 0xAAAAAAAAAAAAAAALL)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v695 = (char *)operator new(24 * v694);
    }
    else
    {
      v695 = 0;
    }
    v696 = &v695[24 * v691];
    *(_QWORD *)buf = v695;
    *(_QWORD *)&buf[8] = v696;
    v749 = v695;
    *(_QWORD *)&buf[16] = v696;
    *(_QWORD *)&buf[24] = &v695[24 * v694];
    *((_QWORD *)v696 + 1) = 0;
    *((_QWORD *)v696 + 2) = 0;
    *(_QWORD *)v696 = 0;
    v697 = *(const void **)v680;
    v698 = *v681 - *(_QWORD *)v680;
    if (*v681 != *(_QWORD *)v680)
    {
      if (v698 < 0)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v699 = (char *)operator new(*v681 - *(_QWORD *)v680);
      v700 = &v749[24 * v691];
      *(_QWORD *)v696 = v699;
      v701 = &v699[4 * (v698 >> 2)];
      *((_QWORD *)v700 + 1) = v699;
      *((_QWORD *)v700 + 2) = v701;
      memmove(v699, v697, v698);
      *((_QWORD *)v700 + 1) = v701;
    }
    *(_QWORD *)&buf[16] = v696 + 24;
    std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer((_QWORD *)a1 + 19, buf);
    v688 = (_QWORD *)*((_QWORD *)a1 + 20);
    v703 = *(_QWORD *)&buf[8];
    v702 = *(_QWORD *)&buf[16];
    if (*(_QWORD *)&buf[16] != *(_QWORD *)&buf[8])
    {
      v704 = *(_QWORD *)&buf[16];
      do
      {
        v706 = *(void **)(v704 - 24);
        v704 -= 24;
        v705 = v706;
        if (v706)
        {
          *(_QWORD *)(v702 - 16) = v705;
          operator delete(v705);
        }
        v702 = v704;
      }
      while (v704 != v703);
    }
    if (*(_QWORD *)buf)
      operator delete(*(void **)buf);
    v689 = a1;
  }
  else
  {
    *v683 = 0;
    v683[1] = 0;
    v683[2] = 0;
    v684 = *(const void **)v680;
    v685 = *v681 - *(_QWORD *)v680;
    if (*v681 != *(_QWORD *)v680)
    {
      if (v685 < 0)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v686 = (char *)operator new(*v681 - *(_QWORD *)v680);
      *v683 = v686;
      v683[1] = v686;
      v687 = &v686[4 * (v685 >> 2)];
      v683[2] = v687;
      memcpy(v686, v684, v685);
      v683[1] = v687;
    }
    v688 = v683 + 3;
    v689 = a1;
    *((_QWORD *)a1 + 20) = v683 + 3;
  }
  v689[20] = v688;
  memset(buf, 0, 24);
  vDSP_vadd(*((const float **)v783 + 3 * v671), 1, (const float *)&__A, 1, (float *)buf, 1, 3uLL);
  vDSP_vsub(*((const float **)v783 + 3 * v671), 1, (const float *)&__A, 1, (float *)&buf[12], 1, 3uLL);
  VBAP::lineUnitSphereIntersection((VBAP *)buf, (const float *)&buf[12], (float *)&__C, v707);
  vDSP_distancesq((const float *)&v778, 1, (const float *)&__C, 1, (float *)&v793, 3uLL);
  vDSP_distancesq((const float *)&v778, 1, (const float *)&v796 + 1, 1, (float *)&v793 + 1, 3uLL);
  if (v689[11] - v689[10] > 0xFFFFFFFFFFFFFFF3)
  {
    v708 = v689[11] + 12;
    v689[11] = v708;
  }
  else
  {
    std::vector<float>::__append((char **)a1 + 10, 3uLL);
    v708 = v689[11];
  }
  v709 = 12;
  if (*((float *)&v793 + 1) <= *(float *)&v793)
    v709 = 0;
  v710 = (char *)&__C + v709;
  v711 = v708;
  v712 = *(_QWORD *)v710;
  *(_DWORD *)(v711 - 4) = *((_DWORD *)v710 + 2);
  *(_QWORD *)(v711 - 12) = v712;
  v714 = (char *)v689[14];
  v713 = v689[15];
  if ((unint64_t)v714 < v713)
  {
    *(_DWORD *)v714 = 1065353216;
    v715 = v714 + 4;
    goto LABEL_788;
  }
  v716 = (char *)v689[13];
  v717 = (v714 - v716) >> 2;
  v718 = v717 + 1;
  if ((unint64_t)(v717 + 1) >> 62)
    goto LABEL_840;
  v719 = v713 - (_QWORD)v716;
  if (v719 >> 1 > v718)
    v718 = v719 >> 1;
  if ((unint64_t)v719 >= 0x7FFFFFFFFFFFFFFCLL)
    v720 = 0x3FFFFFFFFFFFFFFFLL;
  else
    v720 = v718;
  if (v720)
  {
    if (v720 >> 62)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v721 = operator new(4 * v720);
  }
  else
  {
    v721 = 0;
  }
  v722 = &v721[4 * v717];
  v723 = &v721[4 * v720];
  *v722 = 1065353216;
  v715 = v722 + 1;
  if (v714 != v716)
  {
    v724 = v714 - v716 - 4;
    if (v724 < 0x2C)
      goto LABEL_855;
    if ((unint64_t)(v716 - v721) < 0x20)
      goto LABEL_855;
    v725 = (v724 >> 2) + 1;
    v726 = &v721[4 * v717 - 16];
    v727 = v714 - 16;
    v728 = v725 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v729 = *(_OWORD *)v727;
      *(v726 - 1) = *((_OWORD *)v727 - 1);
      *v726 = v729;
      v726 -= 2;
      v727 -= 32;
      v728 -= 8;
    }
    while (v728);
    v722 -= v725 & 0x7FFFFFFFFFFFFFF8;
    v714 -= 4 * (v725 & 0x7FFFFFFFFFFFFFF8);
    if (v725 != (v725 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_855:
      do
      {
        v730 = *((_DWORD *)v714 - 1);
        v714 -= 4;
        *--v722 = v730;
      }
      while (v714 != v716);
    }
  }
  *((_QWORD *)a1 + 13) = v722;
  *((_QWORD *)a1 + 14) = v715;
  *((_QWORD *)a1 + 15) = v723;
  if (v716)
    operator delete(v716);
LABEL_788:
  *((_QWORD *)a1 + 14) = v715;
  ++*((_QWORD *)a1 + 38);
  v731 = *((_QWORD *)a1 + 16);
  if (*((_QWORD *)a1 + 17) - v731 == -4)
    *((_QWORD *)a1 + 17) = v731;
  else
    std::vector<float>::__append((char **)a1 + 16, 1uLL);
  v732 = (_DWORD *)(*((_QWORD *)a1 + 11) - 12);
  v789 = v642;
  std::back_insert_iterator<std::vector<float>>::operator=[abi:ne180100](&v789, v732);
  std::back_insert_iterator<std::vector<float>>::operator=[abi:ne180100](&v789, v732 + 1);
  std::back_insert_iterator<std::vector<float>>::operator=[abi:ne180100](&v789, v732 + 2);
LABEL_792:
  v42 = VBAP::delaunayTriangulation(a1, *((const float **)a1 + 4), *((_QWORD *)a1 + 5), a4, a5, v649, v650, v651, v652, v653, v654, v655);
  if ((_DWORD)v42)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "VBAP.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 198;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = "initialize";
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 198;
      v87 = MEMORY[0x1E0C81028];
      v88 = "%25s:%-5d CADSPUtility:%s:%d: VBAP error; Delaunay triangulation issue";
LABEL_795:
      _os_log_impl(&dword_1B5ED0000, v87, OS_LOG_TYPE_ERROR, v88, buf, 0x22u);
    }
    goto LABEL_796;
  }
  v733 = 1;
  v734 = (char *)__p;
  if (__p)
  {
LABEL_799:
    v735 = v781;
    v736 = v734;
    if (v781 != v734)
    {
      v737 = v781;
      do
      {
        v739 = (void *)*((_QWORD *)v737 - 3);
        v737 -= 24;
        v738 = v739;
        if (v739)
        {
          *((_QWORD *)v735 - 2) = v738;
          operator delete(v738);
        }
        v735 = v737;
      }
      while (v737 != v734);
      v736 = __p;
    }
    v781 = v734;
    operator delete(v736);
  }
LABEL_806:
  v740 = (char *)v783;
  if (v783)
  {
    v741 = v784;
    v742 = v783;
    if (v784 != v783)
    {
      v743 = v784;
      do
      {
        v745 = (void *)*((_QWORD *)v743 - 3);
        v743 -= 24;
        v744 = v745;
        if (v745)
        {
          *((_QWORD *)v741 - 2) = v744;
          operator delete(v744);
        }
        v741 = v743;
      }
      while (v743 != v740);
      v742 = v783;
    }
    v784 = v740;
    operator delete(v742);
  }
  if (v760)
    operator delete(v760);
  if (v762)
    operator delete(v762);
  if (v773)
    operator delete(v773);
  if (v55)
    operator delete(v55);
  if ((v733 & 1) != 0)
LABEL_823:
    v42 = 0;
LABEL_824:
  if (v775)
    operator delete(v775);
  if (v777)
    operator delete(v777);
  if (v20)
    operator delete(v20);
  return v42;
}

void sub_1B65A74DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,uint64_t a22,void *a23,uint64_t a24,void *a25,void *a26,void *a27,void *__p,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34)
{
  void *v34;
  uint64_t v35;

  std::vector<std::vector<unsigned int>>::~vector[abi:ne180100]((void **)(v35 - 176));
  if (__p)
    operator delete(__p);
  std::vector<std::vector<unsigned int>>::~vector[abi:ne180100](&a31);
  std::vector<std::vector<unsigned int>>::~vector[abi:ne180100](&a34);
  if (a20)
  {
    operator delete(a20);
    if (!a21)
    {
LABEL_5:
      if (!a25)
        goto LABEL_7;
      goto LABEL_6;
    }
  }
  else if (!a21)
  {
    goto LABEL_5;
  }
  operator delete(a21);
  if (!a25)
  {
LABEL_7:
    if (a19)
      operator delete(a19);
    if (a26)
    {
      operator delete(a26);
      if (!a27)
      {
LABEL_11:
        if (!v34)
          goto LABEL_12;
        goto LABEL_18;
      }
    }
    else if (!a27)
    {
      goto LABEL_11;
    }
    operator delete(a27);
    if (!v34)
LABEL_12:
      _Unwind_Resume(a1);
LABEL_18:
    operator delete(v34);
    _Unwind_Resume(a1);
  }
LABEL_6:
  operator delete(a25);
  goto LABEL_7;
}

void **std::vector<std::list<int>>::~vector[abi:ne180100](void **a1)
{
  uint64_t *v2;
  uint64_t *v3;
  void *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;

  v2 = (uint64_t *)*a1;
  if (*a1)
  {
    v3 = (uint64_t *)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        v5 = v3 - 3;
        if (*(v3 - 1))
        {
          v7 = *(v3 - 3);
          v6 = (uint64_t *)*(v3 - 2);
          v8 = *v6;
          *(_QWORD *)(v8 + 8) = *(_QWORD *)(v7 + 8);
          **(_QWORD **)(v7 + 8) = v8;
          *(v3 - 1) = 0;
          if (v6 != v5)
          {
            do
            {
              v9 = (uint64_t *)v6[1];
              operator delete(v6);
              v6 = v9;
            }
            while (v9 != v5);
          }
        }
        v3 = v5;
      }
      while (v5 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void **std::vector<std::vector<unsigned int>>::~vector[abi:ne180100](void **a1)
{
  char *v2;
  char *v3;
  void *v4;
  char *v5;
  void *v6;
  void *v7;

  v2 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      v5 = (char *)a1[1];
      do
      {
        v7 = (void *)*((_QWORD *)v5 - 3);
        v5 -= 24;
        v6 = v7;
        if (v7)
        {
          *((_QWORD *)v3 - 2) = v6;
          operator delete(v6);
        }
        v3 = v5;
      }
      while (v5 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

BOOL VBAP::find_duplicate_vertex(VBAP *this, const float *a2, const float *a3, const float *a4)
{
  size_t v8;
  float *v9;
  unint64_t v10;
  unsigned int v11;
  vDSP_Length v12;
  _BOOL8 result;
  _BYTE v15[4];
  float __C;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](this);
  v9 = (float *)&v15[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0)];
  if (v10 < 2)
    return 0;
  bzero(&v15[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0)], v8);
  v11 = 2;
  v12 = 1;
  do
  {
    vDSP_vsmul((const float *)this, 1, (const float *)this + v12, v9, 1, v12);
    vDSP_vsma(a2, 1, &a2[v12], v9, 1, v9, 1, v12);
    vDSP_vsma(a3, 1, &a3[v12], v9, 1, v9, 1, v12);
    __C = 0.0;
    vDSP_maxv(v9, 1, &__C, v12);
    result = __C > 1.0;
    v12 = v11++;
  }
  while (__C <= 1.0 && v12 < (unint64_t)a4);
  return result;
}

uint64_t VBAP::delaunayTriangulation(_QWORD *a1, const float *a2, uint64_t a3, uint64_t a4, void **a5, double a6, float32x4_t a7, __n128 a8, double a9, float64x2_t a10, double a11, float64x2_t a12)
{
  unint64_t v16;
  size_t v17;
  float64x2_t *v18;
  float64x2_t *v19;
  float64x2_t *v20;
  unint64_t v21;
  const float *v22;
  float64x2_t *v23;
  float64x2_t *v24;
  float64x2_t *v25;
  unint64_t v26;
  float32x4_t v27;
  unint64_t v28;
  double *v29;
  double *v30;
  double *v31;
  float *v32;
  float v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  float64x2_t v46;
  float64x2_t v47;
  uint64_t v48;
  BOOL v49;
  float64x2_t v50;
  float64x2_t v51;
  float v52;
  double v53;
  float64x2_t v54;
  NSObject *v55;
  uint64_t v56;
  uint64_t v58;
  unint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  unint64_t v65;
  int v66;
  unint64_t v67;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;
  char *v72;
  _DWORD *v73;
  char *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  unint64_t v80;
  _BYTE *v81;
  unsigned int *v82;
  unint64_t v83;
  uint64_t v84;
  float64x2_t *v85;
  float64x2_t *v86;
  uint64_t v87;
  unsigned int v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  int64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int64_t v97;
  int v98;
  char *v99;
  _BYTE *v100;
  char *v101;
  char *v102;
  unint64_t v103;
  char *v104;
  uint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  void **v113;
  char *v114;
  unint64_t v115;
  void *v116;
  char *v117;
  unint64_t v118;
  uint64_t v119;
  float64x2_t *v120;
  float64x2_t *v121;
  uint64_t v122;
  uint64_t v123;
  float64x2_t *v124;
  float64x2_t *v125;
  uint64_t v126;
  int v127;
  char *v128;
  char *v129;
  unint64_t v130;
  unsigned int v131;
  unint64_t v132;
  unsigned int *v133;
  int v134;
  unint64_t v135;
  int v136;
  unsigned int v137;
  unint64_t v138;
  int v139;
  int32x2_t v140;
  uint64_t v141;
  uint64_t v142;
  float64x2_t v143;
  char *v144;
  uint64_t v145;
  float64x2_t v146;
  uint64_t v147;
  float64x2_t v148;
  float64x2_t v149;
  unsigned int v150;
  float64x2_t v151;
  unsigned int v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  char *v156;
  char *v157;
  char *v158;
  unint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  unint64_t v163;
  char *v164;
  int64_t v165;
  char *v166;
  const void *v167;
  int64_t v168;
  char *v169;
  size_t v170;
  char *v171;
  double *v172;
  uint64_t v173;
  unint64_t v174;
  double *v175;
  unint64_t v176;
  float64x2_t v177;
  float64x2_t v178;
  __int128 v179;
  float64x2_t v180;
  float64x2_t v181;
  __int128 v182;
  float64x2_t v183;
  uint64_t v184;
  uint64_t v185;
  double v186;
  unsigned int v187;
  unsigned int v188;
  unsigned int v189;
  unint64_t v190;
  BOOL v191;
  uint64_t v192;
  float64x2_t v193;
  uint64_t v194;
  uint64_t v195;
  float64x2_t v196;
  float64x2_t v197;
  float64x2_t v198;
  float64x2_t v199;
  uint64_t v200;
  int v201;
  void **v202;
  int v203;
  unint64_t v204;
  char *v205;
  _QWORD *v206;
  uint64_t v207;
  uint64_t *v208;
  uint64_t *v209;
  void *v210;
  uint64_t *v211;
  uint64_t *v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t *v215;
  _QWORD *v216;
  _QWORD *v217;
  _QWORD *v218;
  uint64_t *v219;
  uint64_t *v220;
  uint64_t *v221;
  uint64_t *v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t *v225;
  _QWORD *v226;
  unint64_t v227;
  uint64_t v228;
  unint64_t v229;
  _QWORD *v230;
  _QWORD *v231;
  uint64_t v232;
  int v233;
  uint64_t v234;
  unint64_t v235;
  char *v236;
  char *v237;
  void **v238;
  uint64_t v239;
  _QWORD *v240;
  _QWORD *v241;
  char *__p;
  char *__pa;
  char *__pc;
  int __pb;
  char *v246;
  char *v247;
  char *v248;
  uint64_t v249;
  float64_t v250;
  uint64_t v251;
  uint64_t v252;
  float64_t v253;
  uint64_t v254;
  float64x2_t *v255;
  uint64_t v256;
  int v257;
  _BYTE buf[48];
  __int128 v259;
  float64x2_t v260;
  __int128 v261;
  uint64_t v262;

  v262 = *MEMORY[0x1E0C80C00];
  v16 = ((a3 - (uint64_t)a2) >> 2) / 3uLL;
  v255 = 0;
  if (!(v16 << 32))
  {
    v19 = 0;
    v20 = 0;
    v18 = 0;
    if ((int)v16 < 1)
      goto LABEL_16;
LABEL_6:
    if (v16 >= 4uLL)
    {
      v21 = 0;
      if ((unint64_t)((char *)v19 - (char *)v18) >= 0x20
        && (unint64_t)((char *)v20 - (char *)v18) >= 0x20
        && (unint64_t)((char *)v20 - (char *)v19) >= 0x20)
      {
        v21 = v16 - (v16 & 3);
        v22 = a2;
        v23 = v18;
        v24 = v19;
        v25 = v20;
        v26 = v21;
        do
        {
          *(float32x4x3_t *)(&a7 - 1) = vld3q_f32(v22);
          v22 += 12;
          *v23 = vcvtq_f64_f32(*(float32x2_t *)v27.f32);
          v23[1] = vcvt_hight_f64_f32(v27);
          v23 += 2;
          a10 = vcvt_hight_f64_f32(a7);
          *v24 = vcvtq_f64_f32(*(float32x2_t *)a7.f32);
          v24[1] = a10;
          v24 += 2;
          *v25 = vcvtq_f64_f32((float32x2_t)a8.n128_u64[0]);
          v25[1] = vcvt_hight_f64_f32((float32x4_t)a8);
          v25 += 2;
          v26 -= 4;
        }
        while (v26);
        if ((v16 & 3) == 0)
          goto LABEL_16;
      }
    }
    else
    {
      v21 = 0;
    }
    v28 = v16 - v21;
    v29 = &v20->f64[v21];
    v30 = &v19->f64[v21];
    v31 = &v18->f64[v21];
    v32 = (float *)&a2[3 * v21 + 1];
    do
    {
      *v31++ = *(v32 - 1);
      v33 = *v32;
      v34 = v32[1];
      v32 += 3;
      *v30++ = v33;
      *v29++ = v34;
      --v28;
    }
    while (v28);
    goto LABEL_16;
  }
  if (((v16 << 32) & 0x8000000000000000) != 0)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  v17 = (8 * v16) & 0x7FFFFFFFFLL;
  v18 = (float64x2_t *)operator new(v17);
  v255 = v18;
  bzero(v18, v17);
  v19 = (float64x2_t *)operator new(v17);
  bzero(v19, v17);
  v20 = (float64x2_t *)operator new(v17);
  bzero(v20, v17);
  if ((int)v16 >= 1)
    goto LABEL_6;
LABEL_16:
  if (v16 < 4)
    goto LABEL_35;
  v35 = 0;
LABEL_18:
  v36 = 0;
  while (v36 == v35)
  {
LABEL_19:
    if (++v36 == v16)
    {
      if (++v35 == v16)
        goto LABEL_35;
      goto LABEL_18;
    }
  }
  v37 = 0;
  while (1)
  {
    if (v35 != v37 && v36 != v37)
    {
      v38.f64[0] = v18->f64[v35];
      v38.f64[1] = v19->f64[v35];
      a7.i64[0] = *(_QWORD *)&v20->f64[v35];
      v39.f64[0] = v18->f64[v36];
      v39.f64[1] = v19->f64[v36];
      a10.f64[0] = v20->f64[v36];
      v40.f64[0] = v18->f64[v37];
      v40.f64[1] = v19->f64[v37];
      a12.f64[0] = v20->f64[v37];
      v41 = vsubq_f64(v40, v38);
      v42 = vsubq_f64(a12, (float64x2_t)a7);
      v43 = vsubq_f64(v39, v38);
      v44 = vsubq_f64(a10, (float64x2_t)a7);
      v45 = vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v42, v43, 1)), v44, v41, 1);
      v44.f64[1] = v43.f64[0];
      v42.f64[1] = v41.f64[0];
      a12 = vmlaq_f64(vnegq_f64(vmulq_f64(v41, v44)), v43, v42);
      v46.f64[0] = v45.f64[0];
      v46.f64[1] = a12.f64[0];
      a10 = (float64x2_t)vdupq_laneq_s64((int64x2_t)a12, 1);
      v47 = vabsq_f64(a10);
      if (vaddvq_f64(vabsq_f64(v46)) + v47.f64[0] > 0.05)
        break;
    }
    if (v16 == ++v37)
      goto LABEL_19;
  }
  v48 = 0;
  v49 = 0;
  *(_QWORD *)&v46.f64[1] = vextq_s8((int8x16_t)v46, (int8x16_t)v46, 8uLL).u64[0];
  v50 = (float64x2_t)vextq_s8((int8x16_t)a12, (int8x16_t)a12, 8uLL);
  a12.f64[1] = v50.f64[0];
  v51 = vmulq_f64(a12, a12);
  v52 = sqrt(vmulq_f64(v45, v45).f64[0] + v51.f64[0] + v51.f64[1]);
  v53 = 1.0 / v52;
  do
  {
    if (v37 != v48 && v35 != v48 && v36 != v48)
    {
      v54.f64[0] = v18->f64[v48];
      v54.f64[1] = v19->f64[v48];
      v50.f64[0] = v20->f64[v48];
      v51 = vmulq_f64(vsubq_f64(v54, v38), v46);
      v50 = vmulq_f64(vsubq_f64(v50, (float64x2_t)a7), a10);
      if (fabs((vaddvq_f64(v51) + v50.f64[0]) * v53) > 0.01)
        break;
    }
    v49 = ++v48 >= (unint64_t)v16;
  }
  while (v16 != v48);
  if (v49)
  {
LABEL_35:
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
LABEL_38:
      v56 = 4294967246;
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "VBAP.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 779;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = "delaunayTriangulation";
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 779;
    v55 = MEMORY[0x1E0C81028];
LABEL_37:
    _os_log_impl(&dword_1B5ED0000, v55, OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: Delaunay Triangulation Error: Convex hull could not be created. Check for overlapping speakers. ", buf, 0x22u);
    goto LABEL_38;
  }
  v58 = *(_QWORD *)(a4 + 8);
  v59 = (v58 - *(_QWORD *)a4) >> 2;
  v234 = 2 * (int)v16 - 4;
  v235 = v59 / 3;
  if (v59 / 3 == v234)
  {
    if (a1 + 28 != (_QWORD *)a4)
      std::vector<int>::__assign_with_size[abi:ne180100]<int *,int *>((char *)a1 + 224, *(char **)a4, v58, v59);
  }
  else if ((CDelaunayTriangles3D::find_delaunay_triangles((CDelaunayTriangles3D *)(a1 + 22), (uint64_t)v18, (uint64_t)v19, (uint64_t)v20, (std::vector<int> *)(a1 + 28), v16) & 1) == 0)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_38;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "VBAP.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 792;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = "delaunayTriangulation";
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 792;
    v55 = MEMORY[0x1E0C81028];
    goto LABEL_37;
  }
  v238 = a5;
  if (*(_DWORD *)a1 != 1 || a1[38] < 2uLL)
    goto LABEL_181;
  v60 = 0;
  memset(buf, 0, 24);
  v246 = 0;
  v247 = 0;
  v248 = 0;
  v62 = a1[28];
  v61 = a1[29];
  if ((unint64_t)(v61 - v62) < 0xC)
    goto LABEL_177;
  v60 = 0;
  v236 = 0;
  v63 = 0;
  v64 = 0;
  LODWORD(v65) = 0;
  v240 = a1;
  do
  {
    v257 = 0;
    v256 = 0;
    v66 = 3 * v65;
    v67 = ((uint64_t)(a1[8] - a1[7]) >> 2) / 3uLL;
    v68 = *(_DWORD *)(v62 + 4 * (3 * v65));
    if (v68 >= v67)
    {
      LODWORD(v256) = *(_DWORD *)(v62 + 4 * (3 * v65));
      v69 = 1;
      v68 = 0;
    }
    else
    {
      v69 = 0;
    }
    v70 = *(_DWORD *)(v62 + 4 * (v66 + 1));
    if (v70 >= v67)
      *(_DWORD *)((unint64_t)&v256 | (4 * v69++)) = v70;
    else
      v68 = *(_DWORD *)(v62 + 4 * (v66 + 1));
    v71 = *(_DWORD *)(v62 + 4 * (v66 + 2));
    if (v71 >= v67)
    {
      *((_DWORD *)&v256 + v69) = v71;
      if (v69 != 1)
      {
LABEL_56:
        a1 = v240;
        goto LABEL_57;
      }
    }
    else
    {
      v68 = v71;
      if (v69 != 2)
        goto LABEL_56;
    }
    v72 = *(char **)&buf[8];
    if (*(_QWORD *)&buf[8] >= *(_QWORD *)&buf[16])
    {
      v74 = *(char **)buf;
      v75 = (uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 2;
      v76 = v75 + 1;
      if ((unint64_t)(v75 + 1) >> 62)
        goto LABEL_230;
      v77 = *(_QWORD *)&buf[16] - *(_QWORD *)buf;
      if ((uint64_t)(*(_QWORD *)&buf[16] - *(_QWORD *)buf) >> 1 > v76)
        v76 = v77 >> 1;
      if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFFCLL)
        v78 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v78 = v76;
      v233 = v65;
      if (v78)
      {
        if (v78 >> 62)
          goto LABEL_229;
        v79 = v64;
        v80 = v78;
        v81 = operator new(4 * v78);
        v64 = v79;
        v78 = v80;
      }
      else
      {
        v81 = 0;
      }
      v82 = (unsigned int *)&v81[4 * v75];
      *v82 = v68;
      v73 = v82 + 1;
      if (v72 == v74)
      {
        LODWORD(v65) = v233;
      }
      else
      {
        v83 = v72 - 4 - v74;
        LODWORD(v65) = v233;
        if (v83 < 0x2C)
          goto LABEL_236;
        if ((unint64_t)(v74 - v81) < 0x20)
          goto LABEL_236;
        v84 = (v83 >> 2) + 1;
        v85 = (float64x2_t *)&v81[4 * v75 - 16];
        v86 = (float64x2_t *)(v72 - 16);
        v87 = v84 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v38 = *v86;
          v85[-1] = v86[-1];
          *v85 = v38;
          v85 -= 2;
          v86 -= 2;
          v87 -= 8;
        }
        while (v87);
        v82 -= v84 & 0x7FFFFFFFFFFFFFF8;
        v72 -= 4 * (v84 & 0x7FFFFFFFFFFFFFF8);
        if (v84 != (v84 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_236:
          do
          {
            v88 = *((_DWORD *)v72 - 1);
            v72 -= 4;
            *--v82 = v88;
          }
          while (v72 != v74);
        }
      }
      *(_QWORD *)buf = v82;
      *(_QWORD *)&buf[16] = &v81[4 * v78];
      if (v74)
      {
        v89 = v64;
        operator delete(v74);
        v64 = v89;
      }
    }
    else
    {
      **(_DWORD **)&buf[8] = v68;
      v73 = v72 + 4;
    }
    *(_QWORD *)&buf[8] = v73;
    if (HIDWORD(v256) >= v256)
      v90 = v256;
    else
      v90 = HIDWORD(v256);
    if (v256 <= HIDWORD(v256))
      v91 = HIDWORD(v256);
    else
      v91 = v256;
    if (v64 >= v236)
    {
      v92 = v64 - v60;
      v93 = (v64 - v60) >> 3;
      v94 = v93 + 1;
      if ((unint64_t)(v93 + 1) >> 61)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      if ((v236 - v60) >> 2 > v94)
        v94 = (v236 - v60) >> 2;
      if ((unint64_t)(v236 - v60) >= 0x7FFFFFFFFFFFFFF8)
        v95 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v95 = v94;
      if (v95)
      {
        __p = v60;
        if (v95 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v96 = v91;
        v97 = v92;
        v98 = v65;
        v99 = v64;
        v65 = v95;
        v100 = operator new(8 * v95);
        v64 = v99;
        v95 = v65;
        LODWORD(v65) = v98;
        v92 = v97;
        v91 = v96;
        v60 = __p;
      }
      else
      {
        v100 = 0;
      }
      v101 = &v100[8 * v93];
      *(_QWORD *)v101 = v90 | (v91 << 32);
      v102 = v101 + 8;
      if (v64 == v60)
      {
        a5 = v238;
      }
      else
      {
        v103 = v64 - 8 - v60;
        if (v103 < 0x168
          || &v100[v92 - 8 - (v103 & 0xFFFFFFFFFFFFFFF8)] > &v100[v92 - 8]
          || &v64[-(v103 & 0xFFFFFFFFFFFFFFF8) - 8] > v64 - 8
          || (unint64_t)(v64 - &v100[v92]) < 0x20)
        {
          v104 = v64;
          a5 = v238;
        }
        else
        {
          v119 = (v103 >> 3) + 1;
          v104 = &v64[-8 * (v119 & 0x3FFFFFFFFFFFFFFCLL)];
          v120 = (float64x2_t *)&v100[8 * v93 - 16];
          v121 = (float64x2_t *)(v64 - 16);
          v122 = v119 & 0x3FFFFFFFFFFFFFFCLL;
          a5 = v238;
          do
          {
            v38 = *v121;
            v120[-1] = v121[-1];
            *v120 = v38;
            v120 -= 2;
            v121 -= 2;
            v122 -= 4;
          }
          while (v122);
          v101 -= 8 * (v119 & 0x3FFFFFFFFFFFFFFCLL);
          if (v119 == (v119 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_115;
        }
        do
        {
          v105 = *((_QWORD *)v104 - 1);
          v104 -= 8;
          *((_QWORD *)v101 - 1) = v105;
          v101 -= 8;
        }
        while (v104 != v60);
      }
LABEL_115:
      v236 = &v100[8 * v95];
      if (v60)
        operator delete(v60);
      v60 = v101;
      v64 = v102;
      goto LABEL_118;
    }
    *(_QWORD *)v64 = v90 | (v91 << 32);
    v64 += 8;
    a5 = v238;
LABEL_118:
    v106 = v247;
    if (v247 >= v248)
    {
      v107 = v246;
      v108 = (char *)(v247 - v246);
      v109 = (v247 - v246) >> 2;
      v110 = v109 + 1;
      if ((unint64_t)(v109 + 1) >> 62)
LABEL_230:
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v111 = v248 - v246;
      if ((v248 - v246) >> 1 > v110)
        v110 = v111 >> 1;
      if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFFCLL)
        v112 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v112 = v110;
      if (v112)
      {
        if (v112 >> 62)
LABEL_229:
          std::__throw_bad_array_new_length[abi:ne180100]();
        v113 = a5;
        v114 = v64;
        v115 = v112;
        v116 = operator new(4 * v112);
        v64 = v114;
        a5 = v113;
        v112 = v115;
        v109 = (v247 - v246) >> 2;
        v108 = (char *)(v247 - v246);
      }
      else
      {
        v116 = 0;
      }
      v117 = (char *)v116 + 4 * v109;
      *(_DWORD *)v117 = v65;
      v63 = v117 + 4;
      if (v247 != v246)
      {
        v118 = v247 - 4 - v246;
        if (v118 < 0x2C)
          goto LABEL_237;
        if ((unint64_t)(v247 - &v108[(_QWORD)v116]) < 0x20)
          goto LABEL_237;
        v123 = (v118 >> 2) + 1;
        v124 = (float64x2_t *)((char *)v116 + 4 * v109 - 16);
        v125 = (float64x2_t *)(v247 - 16);
        v126 = v123 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v38 = *v125;
          v124[-1] = v125[-1];
          *v124 = v38;
          v124 -= 2;
          v125 -= 2;
          v126 -= 8;
        }
        while (v126);
        v117 -= 4 * (v123 & 0x7FFFFFFFFFFFFFF8);
        v106 = &v247[-4 * (v123 & 0x7FFFFFFFFFFFFFF8)];
        if (v123 != (v123 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_237:
          do
          {
            v127 = *((_DWORD *)v106 - 1);
            v106 -= 4;
            *((_DWORD *)v117 - 1) = v127;
            v117 -= 4;
          }
          while (v106 != v246);
        }
      }
      v246 = v117;
      v248 = (char *)v116 + 4 * v112;
      if (v107)
      {
        v128 = v64;
        operator delete(v107);
        v64 = v128;
      }
    }
    else
    {
      *(_DWORD *)v247 = v65;
      v63 = v247 + 4;
    }
    a1 = v240;
    v247 = v63;
    v62 = v240[28];
    v61 = v240[29];
LABEL_57:
    v65 = (v65 + 1);
  }
  while (v65 < ((v61 - v62) >> 2) / 3uLL);
  v129 = v246;
  if (v64 != v60)
  {
    __pa = v63;
    v130 = 0;
    v131 = 0;
    v132 = (v64 - v60) >> 3;
    v133 = *(unsigned int **)&buf[8];
    v232 = *(_QWORD *)buf;
    v134 = 1;
    while (1)
    {
      v135 = v130;
      v130 = v131 + 1;
      if (v132 > v130)
        break;
LABEL_152:
      v132 = (v64 - v60) >> 3;
      ++v134;
      v131 = v130;
      if (v132 <= v130)
      {
        v129 = v246;
        goto LABEL_175;
      }
    }
    v136 = 0;
    v38.f64[0] = *(float64_t *)&v60[8 * v135];
    v137 = v134;
    v138 = v131 + 1;
    while (1)
    {
      v139 = v131 + v136;
      v140 = vceq_s32(*(int32x2_t *)&v38.f64[0], *(int32x2_t *)&v60[8 * v138]);
      if ((v140.i32[0] & v140.i32[1] & 1) != 0)
        break;
      v138 = (v139 + 2);
      ++v136;
      ++v137;
      if (v132 <= v138)
        goto LABEL_152;
    }
    v141 = 4 * v135;
    v142 = *(unsigned int *)(v232 + 4 * v135);
    v143.f64[0] = v255->f64[v142];
    v143.f64[1] = v19->f64[v142];
    a8.n128_u64[0] = *(_QWORD *)&v20->f64[v142];
    v144 = (char *)(v232 + 4 * v138);
    v145 = *(unsigned int *)v144;
    v46.f64[0] = v255->f64[v145];
    v146.f64[0] = v20->f64[v145];
    v147 = LODWORD(v38.f64[0]);
    v38.f64[0] = v255->f64[v147];
    v148.f64[0] = v20->f64[v147];
    v51.f64[0] = v19->f64[v145];
    v149 = vmulq_f64(v38, v51);
    v51.f64[1] = v146.f64[0];
    v146.f64[1] = v46.f64[0];
    v47.f64[0] = v19->f64[v147];
    v150 = v139 + 1;
    v151 = vmlaq_f64(vnegq_f64(v149), v46, v47);
    v47.f64[1] = v148.f64[0];
    v148.f64[1] = v38.f64[0];
    v38 = vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v47, v146)), v51, v148), v143);
    v38.f64[0] = vaddvq_f64(v38) + vmulq_f64(v151, (float64x2_t)a8).f64[0];
    if (v38.f64[0] >= 0.0)
      v152 = v131;
    else
      v152 = v150;
    if (v38.f64[0] >= 0.0)
      v131 = v150;
    v153 = 4 * v152;
    v154 = a1[28];
    *(_DWORD *)(v154 + 4 * (3 * *(_DWORD *)&v129[v141])) = *(_DWORD *)(v232 + v153);
    v155 = 4 * v131;
    *(_DWORD *)(v154 + 4 * (3 * *(_DWORD *)&v129[v141] + 1)) = *(_DWORD *)(v232 + v155);
    v156 = &v60[8 * v138];
    *(_DWORD *)(v154 + 4 * (3 * *(_DWORD *)&v129[v141] + 2)) = *(_DWORD *)v156;
    v157 = &v129[4 * v138];
    *(_DWORD *)(v154 + 4 * (3 * *(_DWORD *)v157)) = *(_DWORD *)(v232 + v155);
    *(_DWORD *)(v154 + 4 * (3 * *(_DWORD *)v157 + 1)) = *(_DWORD *)(v232 + v153);
    *(_DWORD *)(v154 + 4 * (3 * *(_DWORD *)v157 + 2)) = *((_DWORD *)v156 + 1);
    v158 = v156 + 8;
    if (v156 + 8 != v64)
    {
      v159 = v64 - &v60[8 * (v136 + v130)] - 16;
      if (v159 < 0x38)
      {
        do
        {
LABEL_169:
          *(_DWORD *)v156 = *(_DWORD *)v158;
          *((_DWORD *)v156 + 1) = *((_DWORD *)v158 + 1);
          v156 += 8;
          v158 += 8;
        }
        while (v158 != v64);
      }
      else
      {
        v160 = (v159 >> 3) + 1;
        v161 = 8 * (v160 & 0x3FFFFFFFFFFFFFF8);
        v156 += v161;
        v162 = 8 * v137;
        v163 = (((unint64_t)&v64[-16 - (_QWORD)v60 - v162] >> 3) + 1) & 0x3FFFFFFFFFFFFFF8;
        v164 = &v60[v162 + 40];
        do
        {
          v38 = *((float64x2_t *)v164 - 1);
          v46 = *(float64x2_t *)v164;
          a8 = *((__n128 *)v164 + 1);
          *(_OWORD *)(v164 - 40) = *((_OWORD *)v164 - 2);
          *(float64x2_t *)(v164 - 24) = v38;
          *(float64x2_t *)(v164 - 8) = v46;
          *(__n128 *)(v164 + 8) = a8;
          v164 += 64;
          v163 -= 8;
        }
        while (v163);
        if (v160 != (v160 & 0x3FFFFFFFFFFFFFF8))
        {
          v158 += v161;
          goto LABEL_169;
        }
      }
    }
    v237 = v156;
    v165 = (char *)v133 - (v144 + 4);
    if (v133 != (unsigned int *)(v144 + 4))
    {
      v166 = v144;
      memmove(v144, v144 + 4, (char *)v133 - (v144 + 4));
      v144 = v166;
    }
    v167 = v157 + 4;
    v168 = __pa - (v157 + 4);
    if (__pa != v157 + 4)
    {
      v169 = v157;
      v170 = __pa - (v157 + 4);
      __pc = v157;
      v171 = v144;
      memmove(v169, v167, v170);
      v144 = v171;
      v157 = __pc;
    }
    v133 = (unsigned int *)&v144[v165];
    __pa = &v157[v168];
    v64 = v237;
    a5 = v238;
    v129 = v246;
    goto LABEL_152;
  }
LABEL_175:
  if (v129)
    operator delete(v129);
LABEL_177:
  if (*(_QWORD *)buf)
    operator delete(*(void **)buf);
  if (v60)
    operator delete(v60);
LABEL_181:
  v172 = (double *)a1[31];
  v173 = a1[29] - a1[28];
  v174 = (v173 >> 1) + (v173 >> 2);
  v175 = (double *)a1[32];
  v176 = v175 - v172;
  if (v174 <= v176)
  {
    if (v174 < v176)
    {
      v175 = &v172[v174];
      a1[32] = v175;
    }
  }
  else
  {
    std::vector<double>::__append((char **)a1 + 31, v174 - v176);
    v172 = (double *)a1[31];
    v175 = (double *)a1[32];
  }
  vDSP_vclrD(v172, 1, v175 - v172);
  v185 = a1[28];
  v184 = a1[29];
  v186 = 0.0;
  if ((unint64_t)(v184 - v185) >= 0xC)
  {
    v187 = 1;
    v188 = 8;
    v189 = 2;
    do
    {
      v192 = *(int *)(v185 + 4 * (v189 - 2));
      v193.f64[0] = v18->f64[v192];
      v193.f64[1] = v19->f64[v192];
      v177.f64[0] = v20->f64[v192];
      v194 = *(int *)(v185 + 4 * (v189 - 1));
      v178.f64[0] = v18->f64[v194];
      v181.f64[0] = v19->f64[v194];
      *(float64_t *)&v179 = v20->f64[v194];
      v195 = *(int *)(v185 + 4 * v189);
      v180.f64[0] = v18->f64[v195];
      v183.f64[0] = v19->f64[v195];
      *(float64_t *)&v182 = v20->f64[v195];
      v196.f64[0] = v181.f64[0];
      *(_QWORD *)&v196.f64[1] = v179;
      *(_QWORD *)&v197.f64[0] = v182;
      v197.f64[1] = v180.f64[0];
      *(_QWORD *)&v198.f64[0] = v179;
      v198.f64[1] = v178.f64[0];
      v199.f64[0] = v183.f64[0];
      *(_QWORD *)&v199.f64[1] = v182;
      if (fabs(vaddvq_f64(vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v199, v198)), v196, v197), v193))+ vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v180, v181)), v178, v183), v177).f64[0]) > 0.00000011920929)
      {
        v178.f64[1] = v181.f64[0];
        v180.f64[1] = v19->f64[*(int *)(v185 + 4 * v189)];
        *(float64x2_t *)buf = v193;
        *(float64x2_t *)&buf[16] = v177;
        *(float64x2_t *)&buf[32] = v178;
        v259 = v179;
        v260 = v180;
        v261 = v182;
        __invert_d3();
        v177.f64[1] = v250;
        v178.f64[1] = v253;
        v200 = a1[31];
        *(_QWORD *)(v200 + 8 * (v188 - 8)) = v246;
        *(_QWORD *)(v200 + 8 * (v188 - 7)) = v249;
        *(_QWORD *)(v200 + 8 * (v188 - 6)) = v252;
        *(_QWORD *)(v200 + 8 * (v188 - 5)) = v247;
        *(float64_t *)(v200 + 8 * (v188 - 4)) = v250;
        *(float64_t *)(v200 + 8 * (v188 - 3)) = v253;
        *(_QWORD *)(v200 + 8 * (v188 - 2)) = v248;
        *(_QWORD *)(v200 + 8 * (v188 - 1)) = v251;
        *(_QWORD *)(v200 + 8 * v188) = v254;
        v185 = a1[28];
        v184 = a1[29];
      }
      v190 = ((v184 - v185) >> 2) / 3uLL;
      v191 = v190 > v187++;
      v188 += 9;
      v189 += 3;
    }
    while (v191);
    v186 = (float)v190 * 0.125;
    a5 = v238;
  }
  v201 = vcvtmd_s64_f64(log(v186) * 0.72134752);
  if (v201 >= 6)
    v201 = 6;
  v202 = (void **)(a1 + 34);
  if (v235 == v234
    && (v203 = v201 & ~(v201 >> 31),
        v204 = (8 << (2 * (v201 & ~(v201 >> 31)))),
        v206 = *a5,
        v205 = (char *)a5[1],
        0xAAAAAAAAAAAAAAABLL * ((v205 - (_BYTE *)*a5) >> 3) == v204))
  {
    if (v202 != a5)
    {
      __pb = v201 & ~(v201 >> 31);
      v207 = a1[36];
      v208 = (uint64_t *)a1[34];
      if (0xAAAAAAAAAAAAAAABLL * ((v207 - (uint64_t)v208) >> 3) >= v204)
      {
        v216 = a1;
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[35] - (_QWORD)v208) >> 3) < v204)
        {
          v217 = &v206[(uint64_t)(a1[35] - (_QWORD)v208) >> 3];
          std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::list<int> *,std::list<int> *,std::list<int> *,0>(v206, v217, (_QWORD *)a1[34]);
          v218 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::list<int>>,std::list<int>*,std::list<int>*,std::list<int>*>((uint64_t)(a1 + 36), (uint64_t)v217, (uint64_t)v205, (_QWORD *)a1[35]);
          goto LABEL_225;
        }
        v219 = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::list<int> *,std::list<int> *,std::list<int> *,0>(v206, v205, (_QWORD *)a1[34]);
        v220 = (uint64_t *)a1[35];
        if (v220 != v219)
        {
          do
          {
            v221 = v220 - 3;
            if (*(v220 - 1))
            {
              v223 = *(v220 - 3);
              v222 = (uint64_t *)*(v220 - 2);
              v224 = *v222;
              *(_QWORD *)(v224 + 8) = *(_QWORD *)(v223 + 8);
              **(_QWORD **)(v223 + 8) = v224;
              *(v220 - 1) = 0;
              if (v222 != v221)
              {
                do
                {
                  v225 = (uint64_t *)v222[1];
                  operator delete(v222);
                  v222 = v225;
                }
                while (v225 != v221);
              }
            }
            v220 = v221;
          }
          while (v221 != v219);
        }
        a1 = v216;
        v216[35] = v219;
      }
      else
      {
        v239 = (uint64_t)(a1 + 36);
        if (v208)
        {
          v209 = (uint64_t *)a1[35];
          v210 = (void *)a1[34];
          if (v209 != v208)
          {
            v241 = a1;
            do
            {
              v211 = v209 - 3;
              if (*(v209 - 1))
              {
                v213 = *(v209 - 3);
                v212 = (uint64_t *)*(v209 - 2);
                v214 = *v212;
                *(_QWORD *)(v214 + 8) = *(_QWORD *)(v213 + 8);
                **(_QWORD **)(v213 + 8) = v214;
                *(v209 - 1) = 0;
                if (v212 != v211)
                {
                  do
                  {
                    v215 = (uint64_t *)v212[1];
                    operator delete(v212);
                    v212 = v215;
                  }
                  while (v215 != v211);
                }
              }
              v209 = v211;
            }
            while (v211 != v208);
            v210 = *v202;
            a1 = v241;
          }
          v226 = a1;
          a1[35] = v208;
          operator delete(v210);
          v207 = 0;
          *v202 = 0;
          v202[1] = 0;
          v202[2] = 0;
        }
        else
        {
          v226 = a1;
        }
        v227 = 0xAAAAAAAAAAAAAAABLL * (v207 >> 3);
        v228 = 2 * v227;
        if (2 * v227 <= v204)
          v228 = v204;
        if (v227 >= 0x555555555555555)
          v229 = 0xAAAAAAAAAAAAAAALL;
        else
          v229 = v228;
        if (v229 > 0xAAAAAAAAAAAAAAALL)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v230 = operator new(24 * v229);
        v226[34] = v230;
        v226[35] = v230;
        v231 = &v230[3 * v229];
        a1 = v226;
        v226[36] = v231;
        v218 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::list<int>>,std::list<int>*,std::list<int>*,std::list<int>*>(v239, (uint64_t)v206, (uint64_t)v205, v230);
LABEL_225:
        a1[35] = v218;
      }
      v203 = __pb;
    }
    v56 = 0;
    *((_DWORD *)a1 + 74) = v203;
  }
  else
  {
    v56 = 0;
    *((_DWORD *)a1 + 74) = CDelaunayTriangles3D::calculate_triangle_bins((uint64_t)v18, (uint64_t)v19, (uint64_t)v20, a1 + 28, (void **)a1 + 34);
  }
LABEL_39:
  if (v20)
    operator delete(v20);
  if (v19)
    operator delete(v19);
  if (v18)
    operator delete(v18);
  return v56;
}

void sub_1B65A8D28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35)
{
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;

  *(_QWORD *)(v38 + 280) = v39;
  if (v37)
  {
    operator delete(v37);
    if (v36)
    {
LABEL_7:
      operator delete(v36);
      v35 = a34;
      if (!a34)
        goto LABEL_9;
      goto LABEL_8;
    }
  }
  else if (v36)
  {
    goto LABEL_7;
  }
  if (!v35)
LABEL_9:
    _Unwind_Resume(a1);
LABEL_8:
  operator delete(v35);
  goto LABEL_9;
}

void VBAP::lineUnitSphereIntersection(VBAP *this, const float *__A, float *a3, float *a4)
{
  float v7;
  float v8;
  float v9;
  float __D;
  float v11;
  float __B;
  float v13;
  uint64_t v14;
  uint64_t __C;
  int v16;

  v16 = 0;
  v14 = 0;
  __C = 0;
  v13 = 0.0;
  vDSP_vsub((const float *)this, 1, __A, 1, (float *)&__C, 1, 3uLL);
  vDSP_dotpr((const float *)&__C, 1, (const float *)&__C, 1, (float *)&v14 + 1, 3uLL);
  vDSP_dotpr((const float *)this, 1, (const float *)&__C, 1, (float *)&v14, 3uLL);
  *(float *)&v14 = *(float *)&v14 + *(float *)&v14;
  vDSP_dotpr((const float *)this, 1, (const float *)this, 1, &v13, 3uLL);
  v13 = v13 + -1.0;
  v7 = (float)(v13 * (float)(-4.0 * *((float *)&v14 + 1))) + (float)(*(float *)&v14 * *(float *)&v14);
  if (v7 >= 0.0)
  {
    v8 = sqrtf(v7);
    v9 = (float)(v8 - *(float *)&v14) / (float)(*((float *)&v14 + 1) + *((float *)&v14 + 1));
    __D = (float)-(float)(v8 + *(float *)&v14) / (float)(*((float *)&v14 + 1) + *((float *)&v14 + 1));
    v11 = 1.0 - v9;
    __B = 1.0 - __D;
    vDSP_vsmsma((const float *)this, 1, &__B, __A, 1, &__D, a3 + 3, 1, 3uLL);
    vDSP_vsmsma((const float *)this, 1, &v11, __A, 1, &v9, a3, 1, 3uLL);
  }
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*,std::vector<unsigned int>*,std::vector<unsigned int>*>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  const void *v9;
  int64_t v10;
  char *v11;

  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *a4 = 0;
      a4[1] = 0;
      a4[2] = 0;
      v9 = *(const void **)v6;
      v8 = *(_QWORD *)(v6 + 8);
      v10 = v8 - *(_QWORD *)v6;
      if (v8 != *(_QWORD *)v6)
      {
        if (v10 < 0)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v11 = (char *)operator new(v8 - *(_QWORD *)v6);
        *a4 = v11;
        a4[1] = v11;
        v7 = &v11[4 * (v10 >> 2)];
        a4[2] = v7;
        memcpy(v11, v9, v10);
        a4[1] = v7;
      }
      a4 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  return a4;
}

void sub_1B65A9038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  void *v7;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = **(_QWORD **)(a1 + 16);
    v4 = **(_QWORD **)(a1 + 8);
    if (v3 != v4)
    {
      v5 = **(_QWORD **)(a1 + 16);
      do
      {
        v7 = *(void **)(v5 - 24);
        v5 -= 24;
        v6 = v7;
        if (v7)
        {
          *(_QWORD *)(v3 - 16) = v6;
          operator delete(v6);
        }
        v3 = v5;
      }
      while (v5 != v4);
    }
  }
  return a1;
}

_QWORD *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::list<int> *,std::list<int> *,std::list<int> *,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *i;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if (a3 != v5)
      {
        v8 = v5[1];
        for (i = (_QWORD *)a3[1]; (_QWORD *)v8 != v5 && i != a3; i = (_QWORD *)i[1])
        {
          *((_DWORD *)i + 4) = *(_DWORD *)(v8 + 16);
          v8 = *(_QWORD *)(v8 + 8);
        }
        if (i == a3)
        {
          if ((_QWORD *)v8 != v5)
          {
            v14 = operator new(0x18uLL);
            v15 = v14;
            *v14 = 0;
            v14[1] = 0;
            *((_DWORD *)v14 + 4) = *(_DWORD *)(v8 + 16);
            v16 = *(_QWORD *)(v8 + 8);
            if ((_QWORD *)v16 == v5)
            {
              v6 = 1;
            }
            else
            {
              v6 = 1;
              v17 = v14;
              do
              {
                v14 = operator new(0x18uLL);
                *v14 = v17;
                v14[1] = 0;
                *((_DWORD *)v14 + 4) = *(_DWORD *)(v16 + 16);
                v17[1] = v14;
                ++v6;
                v16 = *(_QWORD *)(v16 + 8);
                v17 = v14;
              }
              while ((_QWORD *)v16 != v5);
            }
            v7 = *a3;
            *(_QWORD *)(v7 + 8) = v15;
            *v15 = v7;
            *a3 = v14;
            v14[1] = a3;
            a3[2] += v6;
          }
        }
        else
        {
          v11 = *a3;
          v12 = *i;
          *(_QWORD *)(v12 + 8) = *(_QWORD *)(*a3 + 8);
          **(_QWORD **)(v11 + 8) = v12;
          do
          {
            v13 = (_QWORD *)i[1];
            --a3[2];
            operator delete(i);
            i = v13;
          }
          while (v13 != a3);
        }
      }
      v5 += 3;
      a3 += 3;
    }
    while (v5 != a2);
  }
  return a3;
}

void sub_1B65A922C(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  __cxa_begin_catch(a1);
  do
  {
    v2 = (_QWORD *)*v1;
    operator delete(v1);
    v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1B65A924C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::list<int>>,std::list<int>*,std::list<int>*,std::list<int>*>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  _DWORD *v10;

  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *a4 = a4;
      a4[1] = a4;
      a4[2] = 0;
      v7 = *(_QWORD *)(v6 + 8);
      if (v7 != v6)
      {
        v8 = 0;
        v9 = a4;
        do
        {
          v10 = operator new(0x18uLL);
          v10[4] = *(_DWORD *)(v7 + 16);
          *(_QWORD *)v10 = v9;
          *((_QWORD *)v10 + 1) = a4;
          *((_QWORD *)v9 + 1) = v10;
          *a4 = v10;
          a4[2] = ++v8;
          v7 = *(_QWORD *)(v7 + 8);
          v9 = v10;
        }
        while (v7 != v6);
      }
      v6 += 24;
      a4 += 3;
    }
    while (v6 != a3);
  }
  return a4;
}

void sub_1B65A9328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (v10)
  {
    v13 = (uint64_t *)v9[1];
    v14 = *v13;
    *(_QWORD *)(v14 + 8) = *(_QWORD *)(v11 + 8);
    **(_QWORD **)(v11 + 8) = v14;
    v9[2] = 0;
    if (v13 != v9)
    {
      do
      {
        v15 = (uint64_t *)v13[1];
        operator delete(v13);
        v13 = v15;
      }
      while (v15 != v9);
    }
  }
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::list<int>>,std::list<int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::list<int>>,std::list<int>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = **(uint64_t ***)(a1 + 16);
    v3 = **(uint64_t ***)(a1 + 8);
    if (v2 != v3)
    {
      do
      {
        v5 = v2 - 3;
        if (*(v2 - 1))
        {
          v7 = *(v2 - 3);
          v6 = (uint64_t *)*(v2 - 2);
          v8 = *v6;
          *(_QWORD *)(v8 + 8) = *(_QWORD *)(v7 + 8);
          **(_QWORD **)(v7 + 8) = v8;
          *(v2 - 1) = 0;
          if (v6 != v5)
          {
            do
            {
              v9 = (uint64_t *)v6[1];
              operator delete(v6);
              v6 = v9;
            }
            while (v9 != v5);
          }
        }
        v2 = v5;
      }
      while (v5 != v3);
    }
  }
  return a1;
}

uint64_t VBAP::VBAP(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, uint64_t __sz, void **a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  char *v26;
  char *v27;
  _QWORD *v28;
  uint64_t v29;
  NSObject *v30;
  const char *v31;
  uint64_t v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v13 = *a3;
  v12 = a3[1];
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v14 = v12 - v13;
  if (v14)
  {
    v15 = v14 >> 2;
    v16 = 3 * v15;
    if ((unint64_t)(3 * v15) >> 62)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v17 = 12 * v15;
    v18 = (char *)operator new(12 * v15);
    *(_QWORD *)(a1 + 32) = v18;
    v19 = &v18[4 * v16];
    *(_QWORD *)(a1 + 48) = v19;
    bzero(v18, v17);
    *(_QWORD *)(a1 + 40) = v19;
  }
  v33 = __sz;
  v21 = *a3;
  v20 = a3[1];
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  v22 = v20 - v21;
  if (v22)
  {
    v23 = v22 >> 2;
    v24 = 3 * v23;
    if ((unint64_t)(3 * v23) >> 62)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v25 = 12 * v23;
    v26 = (char *)operator new(12 * v23);
    *(_QWORD *)(a1 + 56) = v26;
    v27 = &v26[4 * v24];
    *(_QWORD *)(a1 + 72) = v27;
    bzero(v26, v25);
    *(_QWORD *)(a1 + 64) = v27;
  }
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  v28 = operator new(0x18uLL);
  *(_QWORD *)(a1 + 88) = v28 + 3;
  *(_QWORD *)(a1 + 96) = v28 + 3;
  v28[1] = 0;
  v28[2] = 0;
  *v28 = 0;
  *(_QWORD *)(a1 + 80) = v28;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = a1 + 176;
  *(_QWORD *)(a1 + 184) = a1 + 176;
  *(_QWORD *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_QWORD *)(a1 + 200) = a1 + 200;
  *(_QWORD *)(a1 + 208) = a1 + 200;
  *(_WORD *)(a1 + 314) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_DWORD *)a1 = a4;
  v29 = (a3[1] - *a3) >> 2;
  *(_DWORD *)(a1 + 300) = v29;
  if ((_DWORD)v29 && (a2[1] - *a2) >> 2 == v29)
  {
    if (!VBAP::initialize((int *)a1, a2, a3, v33, a6))
    {
      *(_BYTE *)(a1 + 315) = 1;
      return a1;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v35 = "VBAP.cpp";
      v36 = 1024;
      v37 = 35;
      v38 = 2080;
      v39 = "VBAP";
      v40 = 1024;
      v41 = 35;
      v30 = MEMORY[0x1E0C81028];
      v31 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Initialization Error; Check for duplicate vertices";
LABEL_14:
      _os_log_impl(&dword_1B5ED0000, v30, OS_LOG_TYPE_ERROR, v31, buf, 0x22u);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    v35 = "VBAP.cpp";
    v36 = 1024;
    v37 = 40;
    v38 = 2080;
    v39 = "VBAP";
    v40 = 1024;
    v41 = 40;
    v30 = MEMORY[0x1E0C81028];
    v31 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Initialization Error; Empty or inconsistent vertex set";
    goto LABEL_14;
  }
  return a1;
}

void sub_1B65A9728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, void **a10, void **a11, _Unwind_Exception *exception_object)
{
  _QWORD *v12;
  void **v13;
  uint64_t *v14;
  uint64_t *v15;
  void **v16;
  _QWORD *v17;
  uint64_t *v18;
  void *v19;
  void *v20;
  uint64_t *v21;
  void *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;

  v18 = (uint64_t *)v12[34];
  if (v18)
  {
    v21 = (uint64_t *)v12[35];
    v22 = (void *)v12[34];
    if (v21 != v18)
    {
      do
      {
        v23 = v21 - 3;
        if (*(v21 - 1))
        {
          v25 = *(v21 - 3);
          v24 = (uint64_t *)*(v21 - 2);
          v26 = *v24;
          *(_QWORD *)(v26 + 8) = *(_QWORD *)(v25 + 8);
          **(_QWORD **)(v25 + 8) = v26;
          *(v21 - 1) = 0;
          if (v24 != v23)
          {
            do
            {
              v27 = (uint64_t *)v24[1];
              operator delete(v24);
              v24 = v27;
            }
            while (v27 != v23);
          }
        }
        v21 = v23;
      }
      while (v23 != v18);
      v22 = (void *)v12[34];
    }
    v12[35] = v18;
    operator delete(v22);
    v19 = (void *)v12[31];
    if (!v19)
    {
LABEL_3:
      v20 = (void *)v12[28];
      if (!v20)
        goto LABEL_4;
      goto LABEL_16;
    }
  }
  else
  {
    v19 = (void *)v12[31];
    if (!v19)
      goto LABEL_3;
  }
  v12[32] = v19;
  operator delete(v19);
  v20 = (void *)v12[28];
  if (!v20)
  {
LABEL_4:
    if (!*v17)
      goto LABEL_19;
LABEL_17:
    v29 = v12[25];
    v28 = (uint64_t *)v12[26];
    v30 = *v28;
    *(_QWORD *)(v30 + 8) = *(_QWORD *)(v29 + 8);
    **(_QWORD **)(v29 + 8) = v30;
    v12[27] = 0;
    if (v28 != v15)
    {
      do
      {
        v31 = (uint64_t *)v28[1];
        operator delete(v28);
        v28 = v31;
      }
      while (v31 != v15);
    }
LABEL_19:
    if (v12[24])
    {
      v33 = v12[22];
      v32 = (uint64_t *)v12[23];
      v34 = *v32;
      *(_QWORD *)(v34 + 8) = *(_QWORD *)(v33 + 8);
      **(_QWORD **)(v33 + 8) = v34;
      v12[24] = 0;
      if (v32 != v14)
      {
        do
        {
          v35 = (uint64_t *)v32[1];
          operator delete(v32);
          v32 = v35;
        }
        while (v35 != v14);
      }
    }
    v36 = v12[19];
    if (v36)
    {
      v37 = v12[20];
      v38 = (void *)v12[19];
      if (v37 != v36)
      {
        v39 = v12[20];
        do
        {
          v41 = *(void **)(v39 - 24);
          v39 -= 24;
          v40 = v41;
          if (v41)
          {
            *(_QWORD *)(v37 - 16) = v40;
            operator delete(v40);
          }
          v37 = v39;
        }
        while (v39 != v36);
        v38 = (void *)v12[19];
      }
      v12[20] = v36;
      operator delete(v38);
    }
    v42 = (void *)v12[16];
    if (v42)
    {
      v12[17] = v42;
      operator delete(v42);
    }
    v43 = *a9;
    if (*a9)
    {
      v12[14] = v43;
      operator delete(v43);
      v44 = *v16;
      if (!*v16)
      {
LABEL_34:
        v45 = *v13;
        if (!*v13)
          goto LABEL_36;
        goto LABEL_35;
      }
    }
    else
    {
      v44 = *v16;
      if (!*v16)
        goto LABEL_34;
    }
    v12[11] = v44;
    operator delete(v44);
    v45 = *v13;
    if (!*v13)
    {
LABEL_36:
      v46 = *a10;
      if (*a10)
      {
        v12[5] = v46;
        operator delete(v46);
      }
      v47 = *a11;
      if (*a11)
      {
        v12[2] = v47;
        operator delete(v47);
      }
      _Unwind_Resume(a1);
    }
LABEL_35:
    v12[8] = v45;
    operator delete(v45);
    goto LABEL_36;
  }
LABEL_16:
  v12[29] = v20;
  operator delete(v20);
  if (!*v17)
    goto LABEL_19;
  goto LABEL_17;
}

void sub_1B65A9938()
{
  _QWORD *v0;

  if (!*v0)
    JUMPOUT(0x1B65A98E4);
  JUMPOUT(0x1B65A98DCLL);
}

void sub_1B65A994C()
{
  _QWORD *v0;

  if (!*v0)
    JUMPOUT(0x1B65A98F8);
  JUMPOUT(0x1B65A98F0);
}

void VBAP::changeSpeakerLocations(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  void *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  NSObject *v16;
  const char *v17;
  void *__p;
  uint64_t *v19;
  uint64_t v20;
  _BYTE buf[28];
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 315) = 0;
  v3 = (unint64_t)(a3[1] - *a3) >> 2;
  if (*(_DWORD *)(a1 + 300) != (_DWORD)v3 || (a2[1] - *a2) >> 2 != v3)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "VBAP.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 51;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = "changeSpeakerLocations";
    v22 = 1024;
    v23 = 51;
    v16 = MEMORY[0x1E0C81028];
    v17 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Unable to change speaker locations, azimuth and elevation have different sizes";
    goto LABEL_13;
  }
  vDSP_vclr(*(float **)(a1 + 80), 1, (uint64_t)(*(_QWORD *)(a1 + 88) - *(_QWORD *)(a1 + 80)) >> 2);
  memset(buf, 0, 24);
  __p = 0;
  v19 = 0;
  v20 = 0;
  v7 = VBAP::initialize((int *)a1, a2, a3, (uint64_t)buf, &__p);
  v8 = (uint64_t *)__p;
  if (__p)
  {
    v9 = v19;
    v10 = __p;
    if (v19 != __p)
    {
      do
      {
        v11 = v9 - 3;
        if (*(v9 - 1))
        {
          v13 = *(v9 - 3);
          v12 = (uint64_t *)*(v9 - 2);
          v14 = *v12;
          *(_QWORD *)(v14 + 8) = *(_QWORD *)(v13 + 8);
          **(_QWORD **)(v13 + 8) = v14;
          *(v9 - 1) = 0;
          if (v12 != v11)
          {
            do
            {
              v15 = (uint64_t *)v12[1];
              operator delete(v12);
              v12 = v15;
            }
            while (v15 != v11);
          }
        }
        v9 = v11;
      }
      while (v11 != v8);
      v10 = __p;
    }
    v19 = v8;
    operator delete(v10);
  }
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
  if (!v7)
  {
    *(_BYTE *)(a1 + 315) = 1;
    return;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "VBAP.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 59;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = "changeSpeakerLocations";
    v22 = 1024;
    v23 = 59;
    v16 = MEMORY[0x1E0C81028];
    v17 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Unable to change speaker locations";
LABEL_13:
    _os_log_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_ERROR, v17, buf, 0x22u);
  }
}

void sub_1B65A9BC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  std::vector<std::list<int>>::~vector[abi:ne180100](&a10);
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t VBAP::triangleLookup(VBAP *this, float32x2_t *a2, int *a3, float *a4)
{
  unsigned int subtriangle_containment;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  double v14;
  uint64_t result;
  float v16;
  float v17;
  float v18;
  NSObject *v19;
  const char *v20;
  double v21;
  double v22;
  float64x2_t __B;
  double v24;
  _BYTE __C[12];
  __int16 v26;
  int v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 315))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__C = 136315906;
      *(_QWORD *)&__C[4] = "VBAP.cpp";
      v26 = 1024;
      v27 = 316;
      v28 = 2080;
      v29 = "triangleLookup";
      v30 = 1024;
      v31 = 316;
      v19 = MEMORY[0x1E0C81028];
      v20 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; VBAP object not initialized";
      goto LABEL_15;
    }
    return 4294967246;
  }
  subtriangle_containment = CDelaunayTriangles3D::find_subtriangle_containment(*((int *)this + 74), a2->f32[0], a2->f32[1], a2[1].f32[0]);
  if ((subtriangle_containment & 0x80000000) != 0
    || (v9 = *((_QWORD *)this + 34),
        0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 35) - v9) >> 3) <= subtriangle_containment))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__C = 136315906;
      *(_QWORD *)&__C[4] = "VBAP.cpp";
      v26 = 1024;
      v27 = 322;
      v28 = 2080;
      v29 = "triangleLookup";
      v30 = 1024;
      v31 = 322;
      v19 = MEMORY[0x1E0C81028];
      v20 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Triangle lookup error";
LABEL_15:
      _os_log_impl(&dword_1B5ED0000, v19, OS_LOG_TYPE_ERROR, v20, __C, 0x22u);
      return 4294967246;
    }
    return 4294967246;
  }
  *a3 = -1;
  __B = vcvtq_f64_f32(*a2);
  v24 = a2[1].f32[0];
  v10 = v9 + 24 * subtriangle_containment;
  v11 = *(_QWORD *)(v10 + 8);
  if (v11 == v10)
  {
LABEL_18:
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__C = 136315906;
      *(_QWORD *)&__C[4] = "VBAP.cpp";
      v26 = 1024;
      v27 = 349;
      v28 = 2080;
      v29 = "triangleLookup";
      v30 = 1024;
      v31 = 349;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Triangle lookup error",
        __C,
        0x22u);
    }
    return 4294964151;
  }
  else
  {
    while (1)
    {
      v12 = *(_DWORD *)(v11 + 16);
      *(_QWORD *)__C = 0;
      v13 = 9 * v12;
      vDSP_dotprD((const double *)(*((_QWORD *)this + 31) + 72 * v12), 1, __B.f64, 1, (double *)__C, 3uLL);
      if (*(double *)__C > -0.00000011920929)
      {
        v22 = 0.0;
        vDSP_dotprD((const double *)(*((_QWORD *)this + 31) + 8 * (v13 + 3)), 1, __B.f64, 1, &v22, 3uLL);
        if (v22 > -0.00000011920929)
        {
          v21 = 0.0;
          vDSP_dotprD((const double *)(*((_QWORD *)this + 31) + 8 * (v13 + 6)), 1, __B.f64, 1, &v21, 3uLL);
          v14 = v21;
          if (v21 > -0.00000011920929)
            break;
        }
      }
      v11 = *(_QWORD *)(v11 + 8);
      if (v11 == v10)
        goto LABEL_18;
    }
    result = 0;
    v16 = *(double *)__C;
    v17 = v22;
    *a4 = v16;
    a4[1] = v17;
    v18 = v14;
    a4[2] = v18;
    *a3 = v12;
  }
  return result;
}

void VBAP::~VBAP(VBAP *this)
{
  uint64_t *v2;
  uint64_t *v3;
  void *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  void *v10;
  void *v11;
  VBAP *v12;
  uint64_t v13;
  uint64_t v14;
  VBAP *v15;
  VBAP *v16;
  uint64_t v17;
  uint64_t v18;
  VBAP *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;

  v2 = (uint64_t *)*((_QWORD *)this + 34);
  if (v2)
  {
    v3 = (uint64_t *)*((_QWORD *)this + 35);
    v4 = (void *)*((_QWORD *)this + 34);
    if (v3 != v2)
    {
      do
      {
        v5 = v3 - 3;
        if (*(v3 - 1))
        {
          v7 = *(v3 - 3);
          v6 = (uint64_t *)*(v3 - 2);
          v8 = *v6;
          *(_QWORD *)(v8 + 8) = *(_QWORD *)(v7 + 8);
          **(_QWORD **)(v7 + 8) = v8;
          *(v3 - 1) = 0;
          if (v6 != v5)
          {
            do
            {
              v9 = (uint64_t *)v6[1];
              operator delete(v6);
              v6 = v9;
            }
            while (v9 != v5);
          }
        }
        v3 = v5;
      }
      while (v5 != v2);
      v4 = (void *)*((_QWORD *)this + 34);
    }
    *((_QWORD *)this + 35) = v2;
    operator delete(v4);
  }
  v10 = (void *)*((_QWORD *)this + 31);
  if (v10)
  {
    *((_QWORD *)this + 32) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 28);
  if (v11)
  {
    *((_QWORD *)this + 29) = v11;
    operator delete(v11);
  }
  if (*((_QWORD *)this + 27))
  {
    v13 = *((_QWORD *)this + 25);
    v12 = (VBAP *)*((_QWORD *)this + 26);
    v14 = *(_QWORD *)v12;
    *(_QWORD *)(v14 + 8) = *(_QWORD *)(v13 + 8);
    **(_QWORD **)(v13 + 8) = v14;
    *((_QWORD *)this + 27) = 0;
    if (v12 != (VBAP *)((char *)this + 200))
    {
      do
      {
        v15 = (VBAP *)*((_QWORD *)v12 + 1);
        operator delete(v12);
        v12 = v15;
      }
      while (v15 != (VBAP *)((char *)this + 200));
    }
  }
  if (*((_QWORD *)this + 24))
  {
    v17 = *((_QWORD *)this + 22);
    v16 = (VBAP *)*((_QWORD *)this + 23);
    v18 = *(_QWORD *)v16;
    *(_QWORD *)(v18 + 8) = *(_QWORD *)(v17 + 8);
    **(_QWORD **)(v17 + 8) = v18;
    *((_QWORD *)this + 24) = 0;
    if (v16 != (VBAP *)((char *)this + 176))
    {
      do
      {
        v19 = (VBAP *)*((_QWORD *)v16 + 1);
        operator delete(v16);
        v16 = v19;
      }
      while (v19 != (VBAP *)((char *)this + 176));
    }
  }
  v20 = *((_QWORD *)this + 19);
  if (v20)
  {
    v21 = *((_QWORD *)this + 20);
    v22 = (void *)*((_QWORD *)this + 19);
    if (v21 != v20)
    {
      v23 = *((_QWORD *)this + 20);
      do
      {
        v25 = *(void **)(v23 - 24);
        v23 -= 24;
        v24 = v25;
        if (v25)
        {
          *(_QWORD *)(v21 - 16) = v24;
          operator delete(v24);
        }
        v21 = v23;
      }
      while (v23 != v20);
      v22 = (void *)*((_QWORD *)this + 19);
    }
    *((_QWORD *)this + 20) = v20;
    operator delete(v22);
  }
  v26 = (void *)*((_QWORD *)this + 16);
  if (v26)
  {
    *((_QWORD *)this + 17) = v26;
    operator delete(v26);
  }
  v27 = (void *)*((_QWORD *)this + 13);
  if (v27)
  {
    *((_QWORD *)this + 14) = v27;
    operator delete(v27);
  }
  v28 = (void *)*((_QWORD *)this + 10);
  if (v28)
  {
    *((_QWORD *)this + 11) = v28;
    operator delete(v28);
  }
  v29 = (void *)*((_QWORD *)this + 7);
  if (v29)
  {
    *((_QWORD *)this + 8) = v29;
    operator delete(v29);
  }
  v30 = (void *)*((_QWORD *)this + 4);
  if (v30)
  {
    *((_QWORD *)this + 5) = v30;
    operator delete(v30);
  }
  v31 = (void *)*((_QWORD *)this + 1);
  if (v31)
  {
    *((_QWORD *)this + 2) = v31;
    operator delete(v31);
  }
}

uint64_t VBAP::calculateVBAPGains(VBAP *this, float32x2_t *a2, float *__C)
{
  NSObject *v6;
  const char *v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  float v18;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  unsigned int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float64x2_t v27;
  float64x2_t v28;
  float64x2_t v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  double v39;
  double v40;
  double v41;
  float64x2_t v42;
  double v43;
  double v44;
  double v45;
  double v46;
  float64x2_t v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  uint64_t v54;
  uint64_t v55;
  float v56;
  uint64_t v57;
  uint64_t v58;
  float v59;
  float v60;
  uint64_t v61;
  uint64_t v62;
  float v63;
  float v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  float *v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unsigned int v72;
  uint64_t v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  float64_t v120;
  float64x2_t v121;
  float __B;
  float __Ca;
  float32x2_t __A;
  int v125;
  uint64_t v126;
  int v127;
  uint64_t v128;
  int v129;
  _DWORD buf[3];
  __int16 v131;
  int v132;
  __int16 v133;
  const char *v134;
  __int16 v135;
  int v136;
  uint64_t v137;

  v137 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 315))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      buf[0] = 136315906;
      *(_QWORD *)&buf[1] = "VBAP.cpp";
      v131 = 1024;
      v132 = 579;
      v133 = 2080;
      v134 = "calculateVBAPGains";
      v135 = 1024;
      v136 = 579;
      v6 = MEMORY[0x1E0C81028];
      v7 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Can not calculate gain if the VBAP object is not initialized";
      goto LABEL_11;
    }
    return 4294967246;
  }
  if (a2->f32[0] == 0.0 && a2->f32[1] == 0.0 && a2[1].f32[0] == 0.0)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      buf[0] = 136315906;
      *(_QWORD *)&buf[1] = "VBAP.cpp";
      v131 = 1024;
      v132 = 585;
      v133 = 2080;
      v134 = "calculateVBAPGains";
      v135 = 1024;
      v136 = 585;
      v6 = MEMORY[0x1E0C81028];
      v7 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Can not calculate gain for a source location [0, 0, 0]";
LABEL_11:
      _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_ERROR, v7, (uint8_t *)buf, 0x22u);
      return 4294967246;
    }
    return 4294967246;
  }
  vDSP_vclr(__C, 1, *((unsigned int *)this + 75));
  vDSP_vclr(*((float **)this + 16), 1, (uint64_t)(*((_QWORD *)this + 17) - *((_QWORD *)this + 16)) >> 2);
  v8 = vcvtq_f64_f32(*a2);
  v9.f64[0] = a2[1].f32[0];
  v10 = vmulq_f64(v9, v9);
  v11 = vmulq_f64(v8, v8);
  v10.f64[0] = 1.0 / sqrt(vaddvq_f64(v11) + v10.f64[0]);
  v12 = vmulq_f64(v10, v9);
  v13 = vmulq_n_f64(v8, v10.f64[0]);
  v14 = vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL).u64[0];
  if (*((_BYTE *)this + 314))
  {
    v15 = 0;
    v16 = *((_QWORD *)this + 7);
    v9.f64[0] = *(float *)(v16 + 8);
    *(_QWORD *)&v13.f64[1] = v14;
    v11.f64[0] = *(float *)(v16 + 20);
    v17 = sqrt((vaddvq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v16), v13)) + vmulq_f64(v9, v12).f64[0]) * 0.5 + 0.5);
    v18 = sqrt((vaddvq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)(v16 + 12)), v13)) + vmulq_f64(v11, v12).f64[0]) * 0.5+ 0.5);
    *__C = v17;
    __C[1] = v18;
    return v15;
  }
  if (*((_DWORD *)this + 75) < 2u)
  {
    v15 = 0;
    *__C = 1.0;
    return v15;
  }
  v119 = v14;
  v120 = v13.f64[0];
  v121 = v12;
  v125 = 0;
  v129 = 0;
  v128 = 0;
  v15 = VBAP::triangleLookup(this, a2, &v125, (float *)&v128);
  if ((_DWORD)v15)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      buf[0] = 136315906;
      *(_QWORD *)&buf[1] = "VBAP.cpp";
      v131 = 1024;
      v132 = 619;
      v133 = 2080;
      v134 = "calculateVBAPGains";
      v135 = 1024;
      v136 = 619;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Triangle lookup failed",
        (uint8_t *)buf,
        0x22u);
    }
    return v15;
  }
  v23 = (unsigned int *)(*((_QWORD *)this + 28) + 12 * v125);
  v24 = (int)v23[1];
  v25 = *((_QWORD *)this + 4);
  v20.f64[0] = *(float *)(v25 + 4 * (int)(3 * *v23 + 2));
  v21.f64[0] = *(float *)(v25 + 4 * (3 * (int)v24 + 2));
  v26 = (int)v23[2];
  v22.f64[0] = *(float *)(v25 + 4 * (3 * (int)v26 + 2));
  v27 = vcvtq_f64_f32(*(float32x2_t *)(v25 + 12 * (int)*v23));
  v28 = vcvtq_f64_f32(*(float32x2_t *)(v25 + 12 * v24));
  v29 = vcvtq_f64_f32(*(float32x2_t *)(v25 + 12 * v26));
  v30 = vaddvq_f64(vmulq_f64(v28, v27)) + vmulq_f64(v21, v20).f64[0];
  v31 = vaddvq_f64(vmulq_f64(v29, v28)) + vmulq_f64(v22, v21).f64[0];
  v37 = vmulq_f64(v29, v27);
  v37.f64[0] = vaddvq_f64(v37) + vmulq_f64(v22, v20).f64[0];
  v32 = 1.0 - v30 * v30;
  v33 = -(v37.f64[0] - v31 * v30) / v32;
  v34 = -(v31 - v37.f64[0] * v30) / v32;
  v35 = vmlaq_n_f64(vmlaq_n_f64(v29, v28, v34), v27, v33);
  v36 = vmlsq_lane_f64(v28, v27, v30, 0);
  v37.f64[0] = v21.f64[0] - v30 * v20.f64[0];
  v22.f64[0] = v22.f64[0] + v34 * v21.f64[0] + v33 * v20.f64[0];
  v38.f64[0] = v120;
  *(_QWORD *)&v38.f64[1] = v119;
  *(_QWORD *)&v39 = *(_OWORD *)&vmulq_f64(v20, v121);
  v40 = vaddvq_f64(vmulq_f64(v27, v38));
  v42 = vmulq_f64(v37, v37);
  v41 = vaddvq_f64(vmulq_f64(v36, v36)) + v42.f64[0];
  v42.f64[0] = 0.0;
  v43 = 0.0;
  if (v41 >= 0.00000999999975)
    v43 = (vaddvq_f64(vmulq_f64(v36, v38)) + vmulq_f64(v37, v121).f64[0]) / v41;
  v44 = vaddvq_f64(vmulq_f64(v35, v35)) + vmulq_f64(v22, v22).f64[0];
  if (v44 >= 0.00000999999975)
  {
    v42 = vmulq_f64(v22, v121);
    v42.f64[0] = (vaddvq_f64(vmulq_f64(v35, v38)) + v42.f64[0]) / v44;
  }
  v45 = v40 + v39 - v43 * v30 + v42.f64[0] * v33;
  v46 = v43 + v42.f64[0] * v34;
  v47.f64[0] = v45;
  v47.f64[1] = v46;
  v48 = vaddvq_f64(vmulq_f64(v47, v47)) + vmulq_f64(v42, v42).f64[0];
  v49 = 0.0;
  v50 = 0.0;
  v51 = 0.0;
  if (v48 > 0.00000999999975)
  {
    v52 = 1.0 / sqrt(v48);
    v49 = v52 * v45;
    v53 = v52 * v46;
    v51 = v52 * v42.f64[0];
    v50 = v53;
  }
  v54 = *((unsigned int *)this + 75);
  v55 = (int)*v23;
  if (v55 >= v54)
  {
    v57 = *((_QWORD *)this + 16);
    v58 = 4 * ((int)v55 - (int)v54);
    v59 = v49 + *(float *)(v57 + v58);
    *(float *)(v57 + v58) = v59;
  }
  else
  {
    v56 = v49;
    __C[v55] = v56;
  }
  if (v24 >= v54)
  {
    v61 = *((_QWORD *)this + 16);
    v62 = 4 * ((int)v24 - (int)v54);
    v63 = v50 + *(float *)(v61 + v62);
    *(float *)(v61 + v62) = v63;
  }
  else
  {
    v60 = v50;
    __C[v24] = v60;
  }
  if (v26 >= v54)
  {
    v65 = *((_QWORD *)this + 16);
    v66 = 4 * ((int)v26 - (int)v54);
    v51 = v51 + *(float *)(v65 + v66);
    *(float *)&v51 = v51;
    *(_DWORD *)(v65 + v66) = LODWORD(v51);
    memset(buf, 0, sizeof(buf));
    if (!(_DWORD)v54)
    {
      v67 = 0;
      goto LABEL_40;
    }
  }
  else
  {
    v64 = v51;
    __C[v26] = v64;
    memset(buf, 0, sizeof(buf));
  }
  v67 = 0;
  v68 = __C;
  v69 = v54;
  do
  {
    if (*v68 >= 0.00001)
      buf[v67++] = *(_DWORD *)v68;
    else
      *v68 = 0.0;
    ++v68;
    --v69;
  }
  while (v69);
LABEL_40:
  v127 = 0;
  v126 = 0;
  v70 = *((_QWORD *)this + 38);
  if (v70)
  {
    v71 = 0;
    v72 = 0;
    v73 = *((_QWORD *)this + 16);
    do
    {
      v74 = *(float *)(v73 + 4 * v71);
      if (v74 >= 0.00001)
        *((float *)&v126 + v72++) = v74;
      else
        *(_DWORD *)(v73 + 4 * v71) = 0;
      ++v71;
    }
    while (v70 > v71);
    __A = 0;
    if (v67 || v72 != 1)
    {
      if (v67 || v72 != 2)
      {
        if (v67 == 1 && v72 == 1)
        {
          v75 = sqrtf((float)((float)(*(float *)buf * *(float *)buf) + (float)v54)- (float)((float)(*(float *)buf * *(float *)buf) * (float)v54));
          v76 = *(float *)&v126 * (float)v54;
          v77 = (float)-(float)(v75 + *(float *)buf) / v76;
          __A.f32[0] = (float)(v75 - *(float *)buf) / v76;
        }
        else
        {
          if (v67 == 1 && v72 == 2)
          {
            v78 = (float)(*(float *)&v126 * *(float *)&v126) + (float)(*((float *)&v126 + 1) * *((float *)&v126 + 1));
            v79 = v78 * (float)v54;
            v80 = v79 + (float)((float)(*(float *)&v126 + *(float *)&v126) * *((float *)&v126 + 1));
            v81 = sqrtf(v80 + (float)((float)(*(float *)buf * *(float *)buf) * (float)(v78 - v79)));
            v82 = (float)(*((float *)&v126 + 1) + *(float *)&v126) * *(float *)buf;
            v83 = (float)-(float)(v82 + v81) / v80;
            v77 = (float)(v81 - v82) / v80;
          }
          else
          {
            if (v67 != 2 || v72 != 1)
              goto LABEL_64;
            v84 = sqrtf((float)((float)((float)((float)(*(float *)buf * *(float *)buf)+ (float)(*(float *)&buf[1] * *(float *)&buf[1]))+ (float)v54)+ (float)((float)(*(float *)buf + *(float *)buf) * *(float *)&buf[1]))- (float)((float)((float)(*(float *)buf * *(float *)buf)+ (float)(*(float *)&buf[1] * *(float *)&buf[1]))* (float)v54));
            v85 = *(float *)&v126 * (float)v54;
            v83 = (float)(v84 - (float)(*(float *)&buf[1] + *(float *)buf)) / v85;
            v77 = (float)-(float)(v84 + (float)(*(float *)&buf[1] + *(float *)buf)) / v85;
          }
          __A.f32[0] = v83;
        }
        __A.f32[1] = v77;
      }
      else
      {
        *(float *)&v51 = sqrtf((float)((float)((float)(*(float *)&v126 * *(float *)&v126)+ (float)((float)(*(float *)&v126 + *(float *)&v126) * *((float *)&v126 + 1)))+ (float)(*((float *)&v126 + 1) * *((float *)&v126 + 1)))+ (float)((float)((float)(*((float *)&v126 + 1) * *((float *)&v126 + 1))+ (float)(*(float *)&v126 * *(float *)&v126))* (float)v54));
        __A = vdiv_f32((float32x2_t)0xBF8000003F800000, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v51, 0));
      }
    }
    else
    {
      __A = vcvt_f32_f64(vdivq_f64((float64x2_t)xmmword_1B66A07C0, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt((double)v54) * *(float *)&v126), 0)));
    }
  }
  else
  {
    __A = 0;
  }
LABEL_64:
  __Ca = 0.0;
  vDSP_maxv((const float *)&__A, 1, &__Ca, 2uLL);
  if (*(_DWORD *)this)
  {
    v86 = *((_DWORD *)this + 75);
    v87 = *v23 - v86;
    if (*v23 >= v86)
    {
      v88 = *(_QWORD *)(*((_QWORD *)this + 19) + 24 * v87);
      v89 = *(_QWORD *)(*((_QWORD *)this + 19) + 24 * v87 + 8);
      v90 = v89 - v88;
      if (v89 != v88)
      {
        v91 = 0;
        v92 = v90 >> 2;
        v93 = *((_QWORD *)this + 16);
        v94 = *((_QWORD *)this + 13);
        v95 = 4 * v87;
        do
        {
          v96 = *(unsigned int *)(v88 + 4 * v91);
          __C[v96] = (float)(*(float *)(v93 + v95) / (float)(*(float *)(v94 + v95) * (float)v92)) + __C[v96];
          ++v91;
        }
        while (v92 > v91);
      }
    }
    v97 = v23[1];
    v98 = v97 - v86;
    if (v97 >= v86)
    {
      v99 = *(_QWORD *)(*((_QWORD *)this + 19) + 24 * v98);
      v100 = *(_QWORD *)(*((_QWORD *)this + 19) + 24 * v98 + 8);
      v101 = v100 - v99;
      if (v100 != v99)
      {
        v102 = 0;
        v103 = v101 >> 2;
        v104 = *((_QWORD *)this + 16);
        v105 = *((_QWORD *)this + 13);
        v106 = 4 * v98;
        do
        {
          v107 = *(unsigned int *)(v99 + 4 * v102);
          __C[v107] = (float)(*(float *)(v104 + v106) / (float)(*(float *)(v105 + v106) * (float)v103)) + __C[v107];
          ++v102;
        }
        while (v103 > v102);
      }
    }
    v108 = v23[2];
    v109 = v108 - v86;
    if (v108 >= v86)
    {
      v110 = *(_QWORD *)(*((_QWORD *)this + 19) + 24 * v109);
      v111 = *(_QWORD *)(*((_QWORD *)this + 19) + 24 * v109 + 8);
      v112 = v111 - v110;
      if (v111 != v110)
      {
        v113 = 0;
        v114 = v112 >> 2;
        v115 = *((_QWORD *)this + 16);
        v116 = *((_QWORD *)this + 13);
        v117 = 4 * v109;
        do
        {
          v118 = *(unsigned int *)(v110 + 4 * v113);
          __C[v118] = (float)(*(float *)(v115 + v117) / (float)(*(float *)(v116 + v117) * (float)v114)) + __C[v118];
          ++v113;
        }
        while (v114 > v113);
      }
    }
  }
  else
  {
    __B = 0.0;
    vDSP_sve(*((const float **)this + 16), 1, &__B, *((_QWORD *)this + 38));
    __B = __B * __Ca;
    vDSP_vsadd(__C, 1, &__B, __C, 1, *((unsigned int *)this + 75));
    v86 = *((_DWORD *)this + 75);
  }
  __B = 0.0;
  vDSP_svesq(__C, 1, &__B, v86);
  __B = 1.0 / sqrtf(__B);
  vDSP_vsmul(__C, 1, &__B, __C, 1, *((unsigned int *)this + 75));
  return v15;
}

uint64_t IIRFilter::CopyStateFrom()
{
  return 4294967292;
}

void IIRFilter824::~IIRFilter824(IIRFilter824 *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E69ED5A0;
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_1E69ED5A0;
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t IIRFilter824::Set(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  uint64_t v11;

  if (*(_DWORD *)(a1 + 12) < a2)
    return 4294967246;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = 0;
  if (a2)
  {
    v6 = a3 + 16;
    v7 = a2;
    v8 = (float64x2_t)vdupq_n_s64(0xC170000000000000);
    do
    {
      v9 = *(float64x2_t *)(v6 - 16);
      v10 = *(float64x2_t *)(v6 + 8);
      if (vaddvq_f64(vabsq_f64(v9)) + fabs(*(double *)v6 + -1.0) + fabs(v10.f64[0]) + fabs(*(double *)(v6 + 16)) >= 1.0e-15)
      {
        v11 = *(_QWORD *)(a1 + 24) + 52 * v5++;
        *(_DWORD *)(v11 + 8) = vcvtd_n_s64_f64(*(double *)v6, 0x18uLL);
        *(int32x2_t *)v11 = vmovn_s64(vcvtq_s64_f64(vmulq_f64(v9, v8)));
        *(int32x2_t *)(v11 + 12) = vmovn_s64(vcvtq_n_s64_f64(v10, 0x18uLL));
        *(_OWORD *)(v11 + 20) = 0uLL;
        *(_OWORD *)(v11 + 36) = 0uLL;
      }
      v6 += 40;
      --v7;
    }
    while (v7);
  }
  *(_DWORD *)(a1 + 16) = v5;
  if (v4 != v5)
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  return 0;
}

uint64_t IIRFilter824::Reset(IIRFilter824 *this)
{
  unint64_t v1;
  uint64_t v2;
  _OWORD *v3;

  if (*((_DWORD *)this + 4))
  {
    v1 = 0;
    v2 = 20;
    do
    {
      v3 = (_OWORD *)(*((_QWORD *)this + 3) + v2);
      *v3 = 0uLL;
      v3[1] = 0uLL;
      ++v1;
      v2 += 52;
    }
    while (v1 < *((unsigned int *)this + 4));
  }
  return 0;
}

uint64_t IIRFilter824::Process(IIRFilter824 *this, uint64_t a2, const AudioBufferList *a3, AudioBufferList *a4)
{
  int v8;
  void *mData;
  int v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v14;
  uint64_t v15;

  if (!*((_DWORD *)this + 4))
    return 4294956428;
  v8 = *((_DWORD *)this + 12);
  switch(v8)
  {
    case 3:
      mData = a3->mBuffers[0].mData;
      (*((void (**)(void *, void *, uint64_t, _QWORD, uint64_t, _QWORD))this + 7))(mData, a4->mBuffers[0].mData, a2, 0, 2, *((_QWORD *)this + 3));
      (*((void (**)(void *, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD))this + 7))(mData, *(_QWORD *)&a4[1].mBuffers[0].mNumberChannels, a2, 1, 2, *((_QWORD *)this + 3));
      break;
    case 2:
      (*((void (**)(void *, void *, uint64_t, _QWORD, _QWORD))this + 7))(a3->mBuffers[0].mData, a4->mBuffers[0].mData, a2, 0, *((_QWORD *)this + 3));
      (*((void (**)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD))this + 7))(*(_QWORD *)&a3[1].mBuffers[0].mNumberChannels, *(_QWORD *)&a4[1].mBuffers[0].mNumberChannels, a2, 1, *((_QWORD *)this + 3));
      break;
    case 1:
      (*((void (**)(void *, void *, uint64_t, _QWORD))this + 7))(a3->mBuffers[0].mData, a4->mBuffers[0].mData, a2, *((_QWORD *)this + 3));
      break;
    default:
      return 4294956428;
  }
  v10 = *((_DWORD *)this + 16);
  if (v10 == 1)
  {
    if (*((_DWORD *)this + 4) >= 2u)
    {
      v14 = 1;
      v15 = 52;
      do
      {
        (*((void (**)(void *, void *, uint64_t, uint64_t))this + 9))(a4->mBuffers[0].mData, a4->mBuffers[0].mData, a2, *((_QWORD *)this + 3) + v15);
        ++v14;
        v15 += 52;
      }
      while (v14 < *((unsigned int *)this + 4));
    }
    return 0;
  }
  if (v10 != 2)
    return 4294956428;
  if (*((_DWORD *)this + 4) >= 2u)
  {
    v11 = 1;
    v12 = 52;
    do
    {
      (*((void (**)(void *, void *, uint64_t, _QWORD, uint64_t))this + 9))(a4->mBuffers[0].mData, a4->mBuffers[0].mData, a2, 0, *((_QWORD *)this + 3) + v12);
      (*((void (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))this + 9))(*(_QWORD *)&a4[1].mBuffers[0].mNumberChannels, *(_QWORD *)&a4[1].mBuffers[0].mNumberChannels, a2, 1, *((_QWORD *)this + 3) + v12);
      ++v11;
      v12 += 52;
    }
    while (v11 < *((unsigned int *)this + 4));
  }
  return 0;
}

uint64_t IIRFilter824::CopyStateFrom(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  _DWORD *v3;
  int *v4;
  unint64_t v5;
  int v6;

  v2 = *(_DWORD *)(a1 + 16);
  if (v2 != *(_DWORD *)(a2 + 16))
    return 4294956428;
  if (v2 >= 2)
  {
    v3 = (_DWORD *)(*(_QWORD *)(a1 + 24) + 100);
    v4 = (int *)(*(_QWORD *)(a2 + 24) + 100);
    v5 = 1;
    do
    {
      *(v3 - 7) = *(v4 - 7);
      *(v3 - 6) = *(v4 - 6);
      *(v3 - 3) = *(v4 - 3);
      *(v3 - 2) = *(v4 - 2);
      *(v3 - 5) = *(v4 - 5);
      *(v3 - 4) = *(v4 - 4);
      *(v3 - 1) = *(v4 - 1);
      v6 = *v4;
      v4 += 13;
      *v3 = v6;
      v3 += 13;
      ++v5;
    }
    while (v5 < *(unsigned int *)(a1 + 16));
  }
  return 0;
}

void IIRFilterFloat32::~IIRFilterFloat32(IIRFilterFloat32 *this)
{
  IIRFilterFloat32::~IIRFilterFloat32(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  vDSP_biquadm_SetupStruct *v6;
  vDSP_biquadm_SetupStruct *v7;

  *(_QWORD *)this = &off_1E69ED5E0;
  v2 = (void *)*((_QWORD *)this + 13);
  if (v2)
  {
    *((_QWORD *)this + 14) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 10);
  if (v3)
  {
    *((_QWORD *)this + 11) = v3;
    operator delete(v3);
  }
  v4 = *((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v4)
    MEMORY[0x1BCC95CC8](v4, 0x1000C8077774924);
  v5 = (void *)*((_QWORD *)this + 6);
  if (v5)
  {
    *((_QWORD *)this + 7) = v5;
    operator delete(v5);
  }
  v6 = (vDSP_biquadm_SetupStruct *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v6)
    vDSP_biquadm_DestroySetup(v6);
  v7 = (vDSP_biquadm_SetupStruct *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v7)
    vDSP_biquadm_DestroySetup(v7);
}

uint64_t IIRFilterFloat32::Set(IIRFilterFloat32 *this, unsigned int a2, const BiquadCoefficients *a3)
{
  size_t v4;
  int8x16_t *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  vDSP_Length v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  double *v17;
  _QWORD *v18;
  double *v19;
  double *v20;
  double *v21;
  uint64_t v22;
  float64x2_t v28;
  int8x16_t v29;
  const BiquadCoefficients *v30;
  int8x16_t *v31;
  uint64_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  float64x2_t v46;
  float64x2_t v47;
  float64x2_t v48;
  float64x2_t v49;
  float64x2_t v50;
  float64x2_t v51;
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  float64x2_t v58;
  float64x2_t v59;
  float64x2_t v60;
  float64x2_t v61;
  float64x2_t v62;
  float64x2_t v63;
  float64x2_t v64;
  float64x2_t v65;
  float64x2_t v66;
  float64x2_t v67;
  float64x2_t v68;
  float64x2_t v69;
  float64x2_t v70;
  float64x2_t v71;
  float64x2_t v72;
  float64x2_t v73;
  float64x2_t v74;
  float64x2_t v75;
  float64x2_t v76;
  uint64_t v77;
  BOOL *v78;
  double *v79;
  int v80;

  v4 = *((unsigned int *)this + 3);
  if (v4 < a2)
    return 4294967246;
  v8 = (int8x16_t *)*((_QWORD *)this + 9);
  if ((_DWORD)v4)
    bzero(*((void **)this + 9), v4);
  if (!a2)
  {
    v13 = 0;
    goto LABEL_20;
  }
  v9 = *((unsigned int *)this + 2);
  if ((_DWORD)v9)
  {
    v10 = 0;
    v11 = 0;
    v12 = *((_QWORD *)this + 6);
    v13 = a2;
    v14 = 5 * v9;
    v15 = 5 * v9;
    do
    {
      v16 = 0;
      v17 = (double *)((char *)a3 + 40 * v11);
      v18 = v17 + 2;
      v19 = v17 + 3;
      v20 = v17 + 4;
      v21 = v17 + 1;
      do
      {
        *(_QWORD *)(v12 + 8 * (v10 + v16)) = *v18;
        *(double *)(v12 + 8 * (v10 + v16 + 1)) = *v19;
        *(double *)(v12 + 8 * (v10 + v16 + 2)) = *v20;
        *(double *)(v12 + 8 * (v10 + v16 + 3)) = *v17;
        *(double *)(v12 + 8 * (v10 + v16 + 4)) = *v21;
        v16 += 5;
      }
      while (v14 != v16);
      v8->i8[v11++] = fabs(*v21) + fabs(*v17) + fabs(*v19) + fabs(*v20) + fabs(*(double *)v18 + -1.0) >= 1.0e-15;
      v10 += v15;
    }
    while (v11 != a2);
    goto LABEL_20;
  }
  v13 = a2;
  if (a2 <= 0xF)
  {
    v22 = 0;
LABEL_18:
    v77 = a2 - v22;
    v78 = (BOOL *)&v8->i8[v22];
    v79 = (double *)((char *)a3 + 40 * v22 + 16);
    do
    {
      *v78++ = fabs(*(v79 - 1)) + fabs(*(v79 - 2)) + fabs(v79[1]) + fabs(v79[2]) + fabs(*v79 + -1.0) >= 1.0e-15;
      v79 += 5;
      --v77;
    }
    while (v77);
    goto LABEL_20;
  }
  v22 = a2 & 0xFFFFFFF0;
  __asm { FMOV            V0.2D, #-1.0 }
  v28 = (float64x2_t)vdupq_n_s64(0x3CD203AF9EE75616uLL);
  v29.i64[0] = 0x101010101010101;
  v29.i64[1] = 0x101010101010101;
  v30 = a3;
  v31 = v8;
  v32 = v22;
  do
  {
    v33.f64[0] = *((float64_t *)v30 + 50);
    v34.f64[0] = *((float64_t *)v30 + 51);
    v33.f64[1] = *((float64_t *)v30 + 55);
    v35.f64[0] = *((float64_t *)v30 + 40);
    v36.f64[0] = *((float64_t *)v30 + 41);
    v35.f64[1] = *((float64_t *)v30 + 45);
    v37.f64[0] = *((float64_t *)v30 + 30);
    v38.f64[0] = *((float64_t *)v30 + 31);
    v37.f64[1] = *((float64_t *)v30 + 35);
    v39.f64[0] = *((float64_t *)v30 + 20);
    v40.f64[0] = *((float64_t *)v30 + 21);
    v39.f64[1] = *((float64_t *)v30 + 25);
    v41.f64[0] = *((float64_t *)v30 + 10);
    v42.f64[0] = *((float64_t *)v30 + 11);
    v41.f64[1] = *((float64_t *)v30 + 15);
    v43.f64[0] = *(float64_t *)v30;
    v44.f64[0] = *((float64_t *)v30 + 1);
    v43.f64[1] = *((float64_t *)v30 + 5);
    v45.f64[0] = *((float64_t *)v30 + 60);
    v46.f64[0] = *((float64_t *)v30 + 61);
    v45.f64[1] = *((float64_t *)v30 + 65);
    v47.f64[0] = *((float64_t *)v30 + 70);
    v47.f64[1] = *((float64_t *)v30 + 75);
    v42.f64[1] = *((float64_t *)v30 + 16);
    v44.f64[1] = *((float64_t *)v30 + 6);
    v40.f64[1] = *((float64_t *)v30 + 26);
    v48.f64[0] = *((float64_t *)v30 + 71);
    v48.f64[1] = *((float64_t *)v30 + 76);
    v38.f64[1] = *((float64_t *)v30 + 36);
    v46.f64[1] = *((float64_t *)v30 + 66);
    v36.f64[1] = *((float64_t *)v30 + 46);
    v34.f64[1] = *((float64_t *)v30 + 56);
    v49.f64[0] = *((float64_t *)v30 + 73);
    v51.f64[0] = *((float64_t *)v30 + 2);
    v50.f64[0] = *((float64_t *)v30 + 3);
    v50.f64[1] = *((float64_t *)v30 + 8);
    v53.f64[0] = *((float64_t *)v30 + 42);
    v52.f64[0] = *((float64_t *)v30 + 43);
    v52.f64[1] = *((float64_t *)v30 + 48);
    v55.f64[0] = *((float64_t *)v30 + 62);
    v54.f64[0] = *((float64_t *)v30 + 63);
    v54.f64[1] = *((float64_t *)v30 + 68);
    v49.f64[1] = *((float64_t *)v30 + 78);
    v57.f64[0] = *((float64_t *)v30 + 52);
    v56.f64[0] = *((float64_t *)v30 + 53);
    v56.f64[1] = *((float64_t *)v30 + 58);
    v59.f64[0] = *((float64_t *)v30 + 32);
    v58.f64[0] = *((float64_t *)v30 + 33);
    v58.f64[1] = *((float64_t *)v30 + 38);
    v60 = vaddq_f64(vabsq_f64(v48), vabsq_f64(v47));
    v61 = vabsq_f64(v58);
    v62.f64[0] = *((float64_t *)v30 + 22);
    v58.f64[0] = *((float64_t *)v30 + 23);
    v58.f64[1] = *((float64_t *)v30 + 28);
    v63 = vaddq_f64(vabsq_f64(v46), vabsq_f64(v45));
    v64 = vabsq_f64(v58);
    v65.f64[0] = *((float64_t *)v30 + 12);
    v58.f64[0] = *((float64_t *)v30 + 13);
    v58.f64[1] = *((float64_t *)v30 + 18);
    v66 = vaddq_f64(vabsq_f64(v36), vabsq_f64(v35));
    v67 = vaddq_f64(vabsq_f64(v38), vabsq_f64(v37));
    v38.f64[0] = *((float64_t *)v30 + 4);
    v38.f64[1] = *((float64_t *)v30 + 9);
    v36.f64[0] = *((float64_t *)v30 + 24);
    v68 = vaddq_f64(vabsq_f64(v40), vabsq_f64(v39));
    v40.f64[0] = *((float64_t *)v30 + 44);
    v40.f64[1] = *((float64_t *)v30 + 49);
    v36.f64[1] = *((float64_t *)v30 + 29);
    v69 = vaddq_f64(vabsq_f64(v42), vabsq_f64(v41));
    v70 = vabsq_f64(v36);
    v36.f64[0] = *((float64_t *)v30 + 64);
    v36.f64[1] = *((float64_t *)v30 + 69);
    v71 = vaddq_f64(vabsq_f64(v44), vabsq_f64(v43));
    v72 = vabsq_f64(v36);
    v36.f64[0] = *((float64_t *)v30 + 74);
    v36.f64[1] = *((float64_t *)v30 + 79);
    v73 = vaddq_f64(vabsq_f64(v49), vabsq_f64(v36));
    v49.f64[0] = *((float64_t *)v30 + 54);
    v49.f64[1] = *((float64_t *)v30 + 59);
    v74 = vaddq_f64(vabsq_f64(v52), vabsq_f64(v40));
    v52.f64[0] = *((float64_t *)v30 + 34);
    v52.f64[1] = *((float64_t *)v30 + 39);
    v75 = vaddq_f64(v64, v70);
    v70.f64[0] = *((float64_t *)v30 + 14);
    v70.f64[1] = *((float64_t *)v30 + 19);
    v51.f64[1] = *((float64_t *)v30 + 7);
    v65.f64[1] = *((float64_t *)v30 + 17);
    v59.f64[1] = *((float64_t *)v30 + 37);
    v62.f64[1] = *((float64_t *)v30 + 27);
    v76 = vaddq_f64(v67, vaddq_f64(v61, vabsq_f64(v52)));
    v53.f64[1] = *((float64_t *)v30 + 47);
    v57.f64[1] = *((float64_t *)v30 + 57);
    v55.f64[1] = *((float64_t *)v30 + 67);
    v61.f64[0] = *((float64_t *)v30 + 72);
    v61.f64[1] = *((float64_t *)v30 + 77);
    *v31++ = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(vaddq_f64(vaddq_f64(v71, vaddq_f64(vabsq_f64(v50), vabsq_f64(v38))), vabsq_f64(vaddq_f64(v51, _Q0))), v28), (int32x4_t)vcgeq_f64(vaddq_f64(vaddq_f64(v69, vaddq_f64(vabsq_f64(v58), vabsq_f64(v70))), vabsq_f64(vaddq_f64(v65, _Q0))), v28)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(vaddq_f64(vaddq_f64(v68, v75), vabsq_f64(vaddq_f64(v62, _Q0))), v28), (int32x4_t)vcgeq_f64(vaddq_f64(v76, vabsq_f64(vaddq_f64(v59, _Q0))), v28))), (int8x16_t)vuzp1q_s16(
                              (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(vaddq_f64(vaddq_f64(v66, v74), vabsq_f64(vaddq_f64(v53, _Q0))), v28), (int32x4_t)vcgeq_f64(vaddq_f64(vaddq_f64(vaddq_f64(vabsq_f64(v34), vabsq_f64(v33)), vaddq_f64(vabsq_f64(v56), vabsq_f64(v49))), vabsq_f64(vaddq_f64(v57, _Q0))), v28)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(vaddq_f64(vaddq_f64(v63, vaddq_f64(vabsq_f64(v54), v72)), vabsq_f64(vaddq_f64(v55, _Q0))), v28), (int32x4_t)vcgeq_f64(vaddq_f64(vaddq_f64(v60, v73), vabsq_f64(vaddq_f64(v61, _Q0))), v28)))),
               v29);
    v30 = (const BiquadCoefficients *)((char *)v30 + 640);
    v32 -= 16;
  }
  while (v32);
  if (v22 != a2)
    goto LABEL_18;
LABEL_20:
  caulk::pooled_semaphore_mutex::_lock((IIRFilterFloat32 *)((char *)this + 40));
  vDSP_biquadm_SetCoefficientsDouble(*((vDSP_biquadm_Setup *)this + 4), *((const double **)this + 6), 0, 0, v13, *((unsigned int *)this + 2));
  vDSP_biquadm_SetActiveFilters(*((vDSP_biquadm_Setup *)this + 4), *((const BOOL **)this + 9));
  if (*((_DWORD *)this + 4) == a2)
    v80 = 1;
  else
    v80 = 2;
  *((_DWORD *)this + 11) = v80;
  *((_DWORD *)this + 4) = a2;
  caulk::pooled_semaphore_mutex::_unlock((IIRFilterFloat32 *)((char *)this + 40));
  return 0;
}

void sub_1B65AB508(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex *v1;

  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IIRFilterFloat32::Reset(vDSP_biquadm_Setup *this)
{
  vDSP_biquadm_ResetState(this[3]);
  return 0;
}

uint64_t IIRFilterFloat32::Process(IIRFilterFloat32 *this, unsigned int a2, const AudioBufferList *a3, AudioBufferList *a4)
{
  uint64_t mNumberBuffers;
  int v9;
  vDSP_biquadm_SetupStruct *v10;
  const vDSP_biquadm_SetupStruct *v11;
  uint64_t v13;
  void **p_mData;
  void **v15;
  void *v16;
  void *v17;

  mNumberBuffers = a3->mNumberBuffers;
  if ((_DWORD)mNumberBuffers != a4->mNumberBuffers || (_DWORD)mNumberBuffers != *((_DWORD *)this + 2))
    return 4294967246;
  if (caulk::pooled_semaphore_mutex::try_lock((IIRFilterFloat32 *)((char *)this + 40)))
  {
    v9 = *((_DWORD *)this + 11);
    if (v9)
    {
      v11 = (const vDSP_biquadm_SetupStruct *)*((_QWORD *)this + 3);
      v10 = (vDSP_biquadm_SetupStruct *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 3) = v10;
      *((_QWORD *)this + 4) = v11;
      if (v9 == 1)
        vDSP_biquadm_CopyState(v10, v11);
      else
        vDSP_biquadm_ResetState(v10);
      *((_DWORD *)this + 11) = 0;
    }
    caulk::pooled_semaphore_mutex::_unlock((IIRFilterFloat32 *)((char *)this + 40));
  }
  if ((_DWORD)mNumberBuffers)
  {
    v13 = 0;
    p_mData = &a4->mBuffers[0].mData;
    v15 = &a3->mBuffers[0].mData;
    do
    {
      v16 = *v15;
      v15 += 2;
      *(_QWORD *)(*((_QWORD *)this + 10) + v13) = v16;
      v17 = *p_mData;
      p_mData += 2;
      *(_QWORD *)(*((_QWORD *)this + 13) + v13) = v17;
      v13 += 8;
    }
    while (8 * mNumberBuffers != v13);
  }
  vDSP_biquadm(*((vDSP_biquadm_Setup *)this + 3), *((const float ***)this + 10), 1, *((float ***)this + 13), 1, a2);
  return 0;
}

void sub_1B65AB640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void BiquadCoefficients::GetQuadraticRoots(_DWORD *a1, uint64_t a2, double *a3, double a4, double a5, double a6)
{
  double v10;
  double v11;
  long double v12;
  __double2 v13;
  double v14;
  double v15;
  double v16;
  int v17;
  double v18;
  double v19;
  double v20;
  double v21;
  long double v22;

  if (a4 == 0.0)
  {
    if (a5 == 0.0)
    {
      *a1 = 0;
    }
    else
    {
      *a1 = 1;
      *(double *)a2 = -a6 / a5;
      *(_QWORD *)(a2 + 8) = 0;
    }
  }
  else
  {
    *a1 = 2;
    v10 = a4 * a6 * -4.0 + a5 * a5;
    v11 = sqrt(hypot(v10, 0.0));
    if ((*(_QWORD *)&v11 & 0x8000000000000000) != 0)
    {
      v15 = NAN;
      v14 = NAN;
    }
    else
    {
      v12 = atan2(0.0, v10);
      v13 = __sincos_stret(v12 * 0.5);
      v14 = v13.__cosval * v11;
      v15 = v13.__sinval * v11;
    }
    v16 = a4 + a4;
    v17 = -(int)logb(fmax(fabs(v16), 0.0));
    v18 = scalbn(v16, v17);
    v19 = scalbn(0.0, v17);
    v20 = v18 * v18 + v19 * v19;
    v21 = scalbn(v18 / v20, v17);
    v22 = scalbn(-v19 / v20, v17);
    *(long double *)a2 = -(v22 * v15 - v21 * (v14 - a5));
    *(long double *)(a2 + 8) = v21 * v15 + v22 * (v14 - a5);
    *a3 = v22 * v15 - v21 * (v14 + a5);
    a3[1] = -(v22 * (v14 + a5) + v21 * v15);
  }
}

BiquadCoefficients *BiquadCoefficients::SetBW(BiquadCoefficients *this, int a2, double a3, double a4, double a5)
{
  BiquadCoefficients *v5;
  long double v8;
  long double v9;
  long double v10;
  double v11;

  v5 = this;
  if (a3 <= 0.0 || a4 <= 0.0)
  {
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 2) = 0x3FF0000000000000;
  }
  else
  {
    v8 = fmin(a3, 3.11017673);
    v9 = a4 * 0.34657359 * v8;
    v10 = sin(v8);
    v11 = 0.5 / sinh(v9 / v10);
    return (BiquadCoefficients *)BiquadCoefficients::SetPriv(v5, a2, v8, v11, a5);
  }
  return this;
}

uint64_t BiquadCoefficients::SetPriv(BiquadCoefficients *this, int a2, long double a3, double a4, double a5)
{
  double v10;
  double v11;
  long double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  uint64_t result;
  long double v19;
  double v20;
  long double v21;
  long double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  long double v46;
  long double v47;
  long double v48;
  long double v49;
  long double v50;
  double v51;
  double v52;
  double v53;

  v10 = cos(a3);
  switch(a2)
  {
    case 1:
      v11 = __exp10(a5 * 0.05);
      v12 = sin(a3) / (a4 + a4);
      v13 = 0.5 - v10 * 0.5;
      v14 = v13 + v13;
      v15 = v12 + 1.0;
      v16 = v10 * -2.0;
      v17 = 1.0 - v12;
      goto LABEL_5;
    case 2:
      v11 = __exp10(a5 * 0.05);
      v19 = sin(a3) / (a4 + a4);
      v13 = v10 * 0.5 + 0.5;
      v14 = v13 * -2.0;
      v15 = v19 + 1.0;
      v16 = v10 * -2.0;
      v17 = 1.0 - v19;
LABEL_5:
      v20 = v13;
      goto LABEL_18;
    case 3:
      v11 = __exp10(a5 * 0.05);
      v20 = sin(a3) / (a4 + a4);
      v13 = -v20;
      v15 = v20 + 1.0;
      v16 = v10 * -2.0;
      v17 = 1.0 - v20;
      v14 = 0.0;
      goto LABEL_18;
    case 4:
      v11 = __exp10(a5 * 0.05);
      v21 = sin(a3) / (a4 + a4);
      v14 = v10 * -2.0;
      v13 = 1.0;
      v15 = v21 + 1.0;
      v17 = 1.0 - v21;
      v20 = 1.0;
      goto LABEL_17;
    case 5:
      v11 = __exp10(a5 * 0.05);
      v22 = sin(a3) / (a4 + a4);
      v13 = v22 + 1.0;
      v14 = v10 * -2.0;
      v20 = 1.0 - v22;
      v17 = 1.0 - v22;
      v16 = v10 * -2.0;
      v15 = v22 + 1.0;
      goto LABEL_18;
    case 6:
      v23 = __exp10(a5 * 0.025);
      v24 = v23 * sin(a3) / (a4 + a4);
      v25 = v24 * v23;
      goto LABEL_16;
    case 7:
      v26 = sin(a3);
      v27 = __exp10(a5 * 0.025);
      v28 = sqrt(v27);
      v11 = 1.0;
      v29 = v26 * (v28 + v28) / (a4 + a4);
      v30 = (v27 + -1.0) * v10;
      v31 = (v27 + 1.0) * v10;
      v32 = v30 + v27 + 1.0;
      v15 = v29 + v32;
      v16 = (v31 + v27 + -1.0) * -2.0;
      v17 = v32 - v29;
      v33 = v27 + 1.0 - v30;
      v20 = (v29 + v33) * v27;
      v14 = v27 * (v27 + -1.0 - v31 + v27 + -1.0 - v31);
      goto LABEL_12;
    case 8:
      v34 = sin(a3);
      v27 = __exp10(a5 * 0.025);
      v35 = sqrt(v27);
      v11 = 1.0;
      v29 = v34 * (v35 + v35) / (a4 + a4);
      v36 = (v27 + -1.0) * v10;
      v37 = (v27 + 1.0) * v10;
      v38 = v27 + 1.0 - v36;
      v15 = v29 + v38;
      v16 = v27 + -1.0 - v37 + v27 + -1.0 - v37;
      v17 = v38 - v29;
      v33 = v36 + v27 + 1.0;
      v20 = (v29 + v33) * v27;
      v14 = v27 * -2.0 * (v37 + v27 + -1.0);
LABEL_12:
      v13 = (v33 - v29) * v27;
      goto LABEL_18;
    case 9:
      v39 = __exp10(a5 * 0.00625);
      v40 = __exp10(a5 * 0.01875);
      result = 0;
      v41 = (1.0 - (sqrt((v10 * -2.0 + 2.0) * v40 - (v40 * v40 - v10 * v10 * (v40 * v40))) + v40 * v10)) / (1.0 - v40);
      v42 = v41 * -2.0;
      v43 = v41 * -2.0 + 1.0;
      v44 = v41 * v41;
      *((double *)this + 1) = v44;
      *((double *)this + 2) = (v43 + v44) * v39;
      *((_QWORD *)this + 3) = 0;
      *((_QWORD *)this + 4) = 0;
      *(double *)this = v42;
      return result;
    case 10:
      v45 = __exp10(a5 * 0.05);
      v46 = tan(a3 / (a4 + a4));
      result = 0;
      v47 = (0.5 - v46 * 4.0 / (v45 + 1.0) * 0.5) / (v46 * 4.0 / (v45 + 1.0) + 1.0);
      v48 = (v47 * 0.5 + -0.25) * (v45 * -2.0 + 2.0);
      v49 = v10 * -2.0 * (v47 + 0.5);
      v50 = v47 + v47;
      *(long double *)this = v49;
      *((long double *)this + 1) = v50;
      *((long double *)this + 2) = v48 + 1.0;
      *((long double *)this + 3) = v49;
      v51 = v50 - v48;
      goto LABEL_19;
    case 11:
      v23 = __exp10(a5 * 0.025);
      v24 = sin(a3) / (a4 + a4);
      v25 = v23 * v24;
LABEL_16:
      v52 = v24 / v23;
      v11 = 1.0;
      v15 = v52 + 1.0;
      v14 = v10 * -2.0;
      v17 = 1.0 - v52;
      v20 = v25 + 1.0;
      v13 = 1.0 - v25;
LABEL_17:
      v16 = v14;
LABEL_18:
      result = 0;
      v53 = 1.0 / v15;
      *(double *)this = v16 * v53;
      *((double *)this + 1) = v17 * v53;
      *((double *)this + 2) = v20 * (v53 * v11);
      *((double *)this + 3) = v14 * (v53 * v11);
      v51 = v13 * (v53 * v11);
LABEL_19:
      *((double *)this + 4) = v51;
      break;
    default:
      result = 4294967246;
      break;
  }
  return result;
}

uint64_t BiquadCoefficients::SetQ(BiquadCoefficients *this, int a2, double a3, double a4, double a5)
{
  uint64_t result;
  double v7;

  if (a2)
  {
    if (a3 <= 0.0 || a4 <= 0.0)
    {
      *(_QWORD *)this = 0;
      *((_QWORD *)this + 1) = 0;
      *((_QWORD *)this + 3) = 0;
      *((_QWORD *)this + 4) = 0;
      result = 4294967246;
      *((_QWORD *)this + 2) = 0x3FF0000000000000;
    }
    else
    {
      return BiquadCoefficients::SetPriv(this, a2, fmin(a3, 3.11017673), a4, a5);
    }
  }
  else
  {
    v7 = __exp10(a5 * 0.05);
    result = 0;
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
    *((double *)this + 2) = v7;
  }
  return result;
}

void BiquadCoefficients::GetT(BiquadCoefficients *this, double a2)
{
  double v3;
  double v4;
  double v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  float64x2_t *v11;
  double v12;
  double v13;
  double *v14;
  double v15;
  double v16;
  float64x2_t v17;
  double *v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v26;
  double v27;
  LambertW *v28;
  double v29;
  double v30;
  double *v31;
  double *v32;
  double v33;
  double v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  float64x2_t v38;
  float64x2_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v35 = 0;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v3 = *((double *)this + 2);
  v4 = *((double *)this + 3);
  v32 = (double *)((char *)this + 24);
  v31 = (double *)((char *)this + 32);
  BiquadCoefficients::GetQuadraticRoots((_DWORD *)&v35 + 1, (uint64_t)&v38, v39.f64, v3, v4, *((double *)this + 4));
  v5 = *(double *)this;
  v34 = 1.0;
  v30 = *((double *)this + 1);
  BiquadCoefficients::GetQuadraticRoots(&v35, (uint64_t)&v36, (double *)&v37, 1.0, *(double *)this, v30);
  v6 = v35;
  v7 = HIDWORD(v35);
  if (HIDWORD(v35) && (_DWORD)v35)
  {
    v8 = 0;
    v9 = v35;
    do
    {
      if (v9)
      {
        v10 = 0;
        v11 = &v38 + v8;
        v12 = v11->f64[0];
        v13 = v11->f64[1];
        v14 = (double *)&v36 + 1;
        while (hypot(v12 - *(v14 - 1), v13 - *v14) >= 1.0e-10)
        {
          ++v10;
          v14 += 2;
          if (v9 == v10)
            goto LABEL_5;
        }
        if ((int)(v7 + ~v8) >= 1)
          memmove(&v38 + v8, &v38 + v8 + 1, 16 * (v7 + ~v8));
        if (v9 + ~(_DWORD)v10 >= 1)
          memmove(&v36 + v10, &v36 + (v10 + 1), 16 * (v9 + ~(_DWORD)v10));
        --v7;
        --v6;
        --v8;
        v9 = v6;
      }
LABEL_5:
      ++v8;
    }
    while (v8 < v7);
  }
  v15 = 0.0;
  if (v7)
  {
    if (v7 == 1)
    {
      v34 = -v38.f64[0];
      v16 = 1.0;
      if (v3 != 0.0)
        goto LABEL_25;
    }
    else
    {
      v16 = -vaddq_f64(v39, v38).f64[0];
      v17 = vmulq_f64(v38, v39);
      *(_QWORD *)&v34 = *(_OWORD *)&vsubq_f64(v17, (float64x2_t)vdupq_laneq_s64((int64x2_t)v17, 1));
      v15 = 1.0;
      if (v3 != 0.0)
        goto LABEL_25;
    }
  }
  else
  {
    v16 = 0.0;
    if (v3 != 0.0)
      goto LABEL_25;
  }
  v18 = v32;
  if (v4 == 0.0)
    v18 = v31;
  v3 = *v18;
LABEL_25:
  v19 = *(double *)&v36;
  if (v6)
  {
    v20 = 1.0;
    if (v6 == 1)
    {
      v21 = -*(double *)&v36;
    }
    else
    {
      v20 = -(*(double *)&v37 + *(double *)&v36);
      v21 = -(*((double *)&v36 + 1) * *((double *)&v37 + 1) - *(double *)&v37 * *(double *)&v36);
    }
  }
  else
  {
    v21 = 1.0;
    v20 = 0.0;
  }
  v22 = v3 * v15;
  if (v6)
  {
    v23 = fabs(v22);
    v24 = fmin(fabs(v3 * v16 - v20 * v22) + v23 + fabs(v3 * v34 - v21 * v22), v23 + fabs(v3 * v16) + fabs(v3 * v34));
    if (v24 != 0.0)
    {
      if (v6 == 1)
      {
        if (*((double *)&v36 + 1) != 0.0 || *(double *)&v36 != 0.0)
        {
          log10(v24);
          log10(fabs(v19));
        }
      }
      else
      {
        v26 = v30 * -4.0 + v5 * v5;
        if (v26 == 0.0)
        {
          if (*(double *)&v36 == 0.0)
            return;
          v27 = fabs(*(double *)&v36);
        }
        else
        {
          if (v26 < 0.0)
          {
            log10(fabs(v30));
            log10(-v26);
            log10(v24);
            return;
          }
          v27 = fmax(fabs(*(double *)&v36), fabs(*(double *)&v37));
        }
        v33 = log(v27);
        v29 = v33 * (v27 * __exp10(-5.0)) / v24;
        if (v29 > -0.367879441 && v29 != 0.0)
          LambertW::lambertW(v28, v29, v29);
      }
    }
  }
}

void LambertW::lambertW(LambertW *this, double a2, double a3)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;

  v4 = -0.367879441;
  if (a2 <= -0.367879441)
    return;
  if (a2 == 0.0)
  {
    if (a2 >= 0.0)
      return;
    goto LABEL_4;
  }
  if (a2 <= 0.0)
    v10 = -0.367879441;
  else
    v10 = 0.0;
  if (a2 <= 0.0)
    v11 = -1.0;
  else
    v11 = 0.0;
  if (a2 <= 0.0)
    v12 = 0.0;
  else
    v12 = 2.71828183;
  if (a2 <= 0.0)
    v13 = 0.0;
  else
    v13 = 1.0;
  if (v12 >= a2)
  {
    v15 = v12;
    v14 = v13;
  }
  else
  {
    do
    {
      v14 = v13 * 10.0;
      v15 = exp(v13 * 10.0) * (v13 * 10.0);
      v10 = v12;
      v11 = v13;
      v13 = v13 * 10.0;
      v12 = v15;
    }
    while (v15 < a2);
  }
  v18 = v14 - v11;
  if (v14 - v11 > 1.0e-12)
  {
    do
    {
      v19 = v11 + ((a2 - v10) * 0.9 / (v15 - v10) + 0.05) * v18;
      v20 = exp(v19) * v19;
      if (v20 >= a2)
      {
        if (v20 > a2)
          v15 = v20;
        else
          v11 = v19;
        v14 = v19;
      }
      else
      {
        v10 = v20;
        v11 = v19;
        v19 = v14;
      }
      v18 = v19 - v11;
    }
    while (v19 - v11 > 1.0e-12);
  }
  if (a2 < 0.0)
  {
LABEL_4:
    v5 = -0.270670566;
    if (a2 <= -0.270670566)
    {
      v8 = -2.0;
      v9 = -1.0;
    }
    else
    {
      v6 = -2.0;
      v7 = -0.270670566;
      do
      {
        v8 = v6 * 10.0;
        v5 = exp(v6 * 10.0) * (v6 * 10.0);
        v9 = v6;
        v4 = v7;
        v7 = v5;
        v6 = v6 * 10.0;
      }
      while (v5 < a2);
    }
    if (v9 - v8 > 1.0e-12)
    {
      do
      {
        v16 = v9 + ((a2 - v4) * 0.9 / (v5 - v4) + 0.05) * (v8 - v9);
        v17 = exp(v16) * v16;
        if (v17 >= a2)
        {
          if (v17 > a2)
            v5 = v17;
          else
            v9 = v9 + ((a2 - v4) * 0.9 / (v5 - v4) + 0.05) * (v8 - v9);
          v8 = v16;
        }
        else
        {
          v9 = v9 + ((a2 - v4) * 0.9 / (v5 - v4) + 0.05) * (v8 - v9);
          v16 = v8;
          v4 = v17;
        }
      }
      while (v9 - v16 > 1.0e-12);
    }
  }
}

IIRFilterFloat32 *NewIIRFilter(const AudioStreamBasicDescription *a1, const AudioStreamBasicDescription *a2, const CAStreamBasicDescription *a3)
{
  __int128 v3;
  __int128 v4;
  IIRFilterFloat32 *v5;
  unsigned int v7;
  int v8;
  char v9;
  _BOOL4 v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v17;
  _BOOL4 v18;
  BOOL v20;
  uint64_t ProcessProcForFormats;
  int v22;
  uint64_t v23;
  const CAStreamBasicDescription *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v3 = *(_OWORD *)&a1->mBytesPerPacket;
  v34 = *(_OWORD *)&a1->mSampleRate;
  v35 = v3;
  v36 = *(_QWORD *)&a1->mBitsPerChannel;
  v4 = *(_OWORD *)&a2->mBytesPerPacket;
  v31 = *(_OWORD *)&a2->mSampleRate;
  v32 = v4;
  v33 = *(_QWORD *)&a2->mBitsPerChannel;
  if (*(double *)&v34 != *(double *)&v31)
    return 0;
  v7 = a3;
  v8 = 0;
  v9 = 1;
  if (DWORD2(v34) != 1819304813)
  {
    v10 = 0;
    goto LABEL_11;
  }
  v10 = 0;
  if (DWORD1(v35) == 1)
  {
    v11 = DWORD2(v35);
    if (DWORD2(v35) == (_DWORD)v35 && DWORD2(v35) >= v36 >> 3)
    {
      v8 = HIDWORD(v35);
      if (!HIDWORD(v35))
        goto LABEL_9;
      if ((BYTE12(v34) & 0x20) != 0
        || (v11 = DWORD2(v35) / HIDWORD(v35), DWORD2(v35) == DWORD2(v35) / HIDWORD(v35) * HIDWORD(v35)))
      {
        v8 = 0;
        if ((BYTE12(v34) & 2) != 0 || 8 * v11 != (_DWORD)v36)
        {
LABEL_84:
          v9 = 0;
          v10 = (BYTE12(v34) & 0x20) == 0;
          goto LABEL_11;
        }
        if ((BYTE12(v34) & 1) == 0)
        {
          if ((BYTE12(v34) & 4) != 0)
          {
            v15 = (HIDWORD(v34) >> 7) & 0x3F;
            if (v15 == 24 && v11 == 4)
            {
              v8 = 3;
            }
            else if (v15 || v11 != 4)
            {
              if (v11 == 2 && v15 == 0)
                v8 = 2;
              else
                v8 = 0;
            }
            else
            {
              v8 = 5;
            }
          }
          else
          {
            v8 = 0;
          }
          goto LABEL_84;
        }
        if ((WORD6(v34) & 0x1F84) == 0)
        {
          v8 = 4 * (v11 == 8);
          if (v11 == 4)
            v8 = 1;
          goto LABEL_84;
        }
      }
    }
    v8 = 0;
LABEL_9:
    v10 = 0;
    v9 = 1;
  }
LABEL_11:
  v5 = 0;
  if (DWORD2(v31) != 1819304813 || DWORD1(v32) != 1)
    return v5;
  v12 = DWORD2(v32);
  if (DWORD2(v32) != (_DWORD)v32)
    return 0;
  if (DWORD2(v32) < v33 >> 3)
    return 0;
  if (!HIDWORD(v32))
    return 0;
  if ((BYTE12(v31) & 0x20) == 0)
  {
    v12 = DWORD2(v32) / HIDWORD(v32);
    if (DWORD2(v32) != DWORD2(v32) / HIDWORD(v32) * HIDWORD(v32))
      return 0;
  }
  v13 = 0;
  if ((BYTE12(v31) & 2) == 0 && 8 * v12 == (_DWORD)v33)
  {
    if ((BYTE12(v31) & 1) != 0)
    {
      if ((WORD6(v31) & 0x1F84) != 0)
        return 0;
      v13 = 4 * (v12 == 8);
      if (v12 == 4)
        v13 = 1;
    }
    else if ((BYTE12(v31) & 4) != 0)
    {
      v14 = (HIDWORD(v31) >> 7) & 0x3F;
      if (v14 == 24 && v12 == 4)
      {
        v13 = 3;
      }
      else if (v14 || v12 != 4)
      {
        if (v12 == 2 && v14 == 0)
          v13 = 2;
        else
          v13 = 0;
      }
      else
      {
        v13 = 5;
      }
    }
    else
    {
      v13 = 0;
    }
  }
  if ((v9 & 1) != 0)
    return 0;
  v17 = HIDWORD(v35);
  if ((v8 - 2) >= 2)
  {
    if (v8 == 1)
    {
      v5 = 0;
      if (v13 == 1 && HIDWORD(v35) == HIDWORD(v32))
      {
        v27 = (HIDWORD(v31) >> 5) & 1;
        if (v10)
          LOBYTE(v27) = 0;
        if ((v27 & 1) != 0 || HIDWORD(v32) <= 1)
        {
          v5 = (IIRFilterFloat32 *)operator new();
          IIRFilterFloat32::IIRFilterFloat32(v5, SHIDWORD(v32), v7);
          return v5;
        }
        return 0;
      }
      return v5;
    }
    return 0;
  }
  v18 = (BYTE12(v31) & 0x20) == 0;
  if (HIDWORD(v35) != 1 || HIDWORD(v32) != 2)
    v18 = 0;
  v20 = HIDWORD(v35) == HIDWORD(v32) && v10 == ((BYTE12(v31) & 0x20) == 0);
  if (!v20 && !v18)
    return 0;
  ProcessProcForFormats = Biquad_8dot24::CreateProcessProcForFormats((Biquad_8dot24 *)&v34, (const CAStreamBasicDescription *)&v31, a3);
  v22 = ProcessProcForFormats;
  *(_QWORD *)&v30 = ProcessProcForFormats;
  *((_QWORD *)&v30 + 1) = v23;
  v25 = Biquad_8dot24::CreateProcessProcForFormats((Biquad_8dot24 *)&v31, (const CAStreamBasicDescription *)&v31, v24);
  v5 = 0;
  *(_QWORD *)&v29 = v25;
  *((_QWORD *)&v29 + 1) = v26;
  if (v22 && (_DWORD)v25)
  {
    v5 = (IIRFilterFloat32 *)operator new();
    IIRFilter824::IIRFilter824((uint64_t)v5, v17, v7, &v30, &v29);
  }
  return v5;
}

void sub_1B65AC8CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10B1C407AB215B4);
  _Unwind_Resume(a1);
}

void IIRFilterFloat32::IIRFilterFloat32(IIRFilterFloat32 *this, int a2, int a3)
{
  vDSP_biquadm_SetupStruct **v4;
  vDSP_biquadm_SetupStruct **v5;
  unint64_t v6;
  vDSP_biquadm_Setup Setup;
  vDSP_biquadm_SetupStruct *v8;
  vDSP_biquadm_Setup v9;
  vDSP_biquadm_SetupStruct *v10;
  size_t v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  std::runtime_error *exception;
  uint64_t v17;

  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a3;
  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E69ED5E0;
  *((_QWORD *)this + 3) = 0;
  v4 = (vDSP_biquadm_SetupStruct **)((char *)this + 24);
  *((_QWORD *)this + 4) = 0;
  v5 = (vDSP_biquadm_SetupStruct **)((char *)this + 32);
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((IIRFilterFloat32 *)((char *)this + 40));
  *((_DWORD *)this + 31) = 0;
  *(_OWORD *)((char *)this + 108) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  v6 = (5 * *((_DWORD *)this + 2) * *((_DWORD *)this + 3));
  v17 = 0;
  std::vector<double>::assign((char **)this + 6, v6, &v17);
  Setup = vDSP_biquadm_CreateSetup(*((const double **)this + 6), *((unsigned int *)this + 3), *((unsigned int *)this + 2));
  v8 = *v4;
  *v4 = Setup;
  if (v8)
    vDSP_biquadm_DestroySetup(v8);
  v9 = vDSP_biquadm_CreateSetup(*((const double **)this + 6), *((unsigned int *)this + 3), *((unsigned int *)this + 2));
  v10 = *v5;
  *v5 = v9;
  if (v10)
    vDSP_biquadm_DestroySetup(v10);
  if (!*v4 || !*v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "failed to create vDSP biquads");
  }
  v11 = *((unsigned int *)this + 3);
  v12 = (void *)operator new[]();
  bzero(v12, v11);
  v13 = *((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = v12;
  if (v13)
    MEMORY[0x1BCC95CC8](v13, 0x1000C8077774924);
  v14 = *((unsigned int *)this + 2);
  v17 = 0;
  std::vector<float *>::assign((char **)this + 10, v14, &v17);
  v15 = *((unsigned int *)this + 2);
  v17 = 0;
  std::vector<float *>::assign((char **)this + 13, v15, &v17);
}

void sub_1B65ACAB8(_Unwind_Exception *a1)
{
  vDSP_biquadm_SetupStruct **v1;
  vDSP_biquadm_SetupStruct **v2;
  _QWORD *v3;
  void **v4;
  void **v5;
  void **v6;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;

  v8 = *v6;
  if (*v6)
  {
    v3[14] = v8;
    operator delete(v8);
  }
  v9 = *v5;
  if (*v5)
  {
    v3[11] = v9;
    operator delete(v9);
  }
  v10 = v3[9];
  v3[9] = 0;
  if (v10)
    MEMORY[0x1BCC95CC8](v10, 0x1000C8077774924);
  v11 = *v4;
  if (*v4)
  {
    v3[7] = v11;
    operator delete(v11);
  }
  std::unique_ptr<vDSP_biquadm_SetupStruct,applesauce::raii::v1::detail::opaque_deletion_functor<vDSP_biquadm_SetupStruct*,&(vDSP_biquadm_DestroySetup)>>::~unique_ptr[abi:ne180100](v2);
  std::unique_ptr<vDSP_biquadm_SetupStruct,applesauce::raii::v1::detail::opaque_deletion_functor<vDSP_biquadm_SetupStruct*,&(vDSP_biquadm_DestroySetup)>>::~unique_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t IIRFilter824::IIRFilter824(uint64_t a1, int a2, unsigned int a3, _OWORD *a4, _OWORD *a5)
{
  size_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  _OWORD v13[4];

  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &off_1E69ED5A0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 48) = *a4;
  *(_OWORD *)(a1 + 64) = *a5;
  DWORD2(v13[0]) = 0x1000000;
  *(_QWORD *)&v13[0] = 0;
  memset((char *)v13 + 12, 0, 36);
  if (a3)
  {
    v7 = 52 * a3;
    v8 = (char *)operator new(v7);
    v9 = 0;
    v10 = &v8[52 * a3];
    do
    {
      v11 = &v8[v9];
      *(_OWORD *)v11 = v13[0];
      *((_OWORD *)v11 + 1) = v13[1];
      *((_OWORD *)v11 + 2) = v13[2];
      *((_DWORD *)v11 + 12) = 0;
      v9 += 52;
    }
    while (v7 != v9);
    *(_QWORD *)(a1 + 24) = v8;
    *(_QWORD *)(a1 + 32) = v10;
    *(_QWORD *)(a1 + 40) = v10;
  }
  return a1;
}

vDSP_biquadm_SetupStruct **std::unique_ptr<vDSP_biquadm_SetupStruct,applesauce::raii::v1::detail::opaque_deletion_functor<vDSP_biquadm_SetupStruct*,&(vDSP_biquadm_DestroySetup)>>::~unique_ptr[abi:ne180100](vDSP_biquadm_SetupStruct **a1)
{
  vDSP_biquadm_SetupStruct *v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
    vDSP_biquadm_DestroySetup(v2);
  return a1;
}

void BlockBuffer::Alloc(BlockBuffer *this, const unsigned int *a2)
{
  unint64_t v4;
  size_t v5;
  _DWORD *v6;
  unsigned int v7;
  unsigned int *v8;
  unint64_t v9;
  _QWORD *v10;
  void *v11;
  void *v12;
  _DWORD *v13;
  unsigned int v14;
  unsigned int *v15;
  unint64_t v16;
  _QWORD *v17;
  void *v18;
  std::bad_alloc *exception;
  std::bad_alloc *v20;

  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = malloc_type_malloc(8 * *((unsigned int *)this + 2), 0x2004093837F09uLL);
  if (*((_DWORD *)this + 2))
  {
    v4 = 0;
    v5 = (4 * *((_DWORD *)this + 3));
    if ((_DWORD)v5)
    {
      do
      {
        v6 = malloc_type_malloc((16 * a2[v4]) | 8, 0xB596D1CuLL);
        *(_QWORD *)(*(_QWORD *)this + 8 * v4) = v6;
        v7 = a2[v4];
        *v6 = v7;
        if (v7)
        {
          v8 = v6;
          v9 = 0;
          v10 = v6 + 4;
          do
          {
            *((_DWORD *)v10 - 2) = 1;
            *((_DWORD *)v10 - 1) = v5;
            v11 = malloc_type_malloc(v5, 0x2C8E6D5CuLL);
            if (!v11)
            {
              exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
              v20 = std::bad_alloc::bad_alloc(exception);
            }
            v12 = v11;
            bzero(v11, v5);
            *v10 = v12;
            v10 += 2;
            ++v9;
          }
          while (v9 < *v8);
        }
        ++v4;
      }
      while (v4 < *((unsigned int *)this + 2));
    }
    else
    {
      do
      {
        v13 = malloc_type_malloc((16 * a2[v4]) | 8, 0xB596D1CuLL);
        *(_QWORD *)(*(_QWORD *)this + 8 * v4) = v13;
        v14 = a2[v4];
        *v13 = v14;
        if (v14)
        {
          v15 = v13;
          v16 = 0;
          v17 = v13 + 4;
          do
          {
            *(v17 - 1) = 1;
            v18 = malloc_type_malloc(v5, 0x2C8E6D5CuLL);
            bzero(v18, v5);
            *v17 = v18;
            v17 += 2;
            ++v16;
          }
          while (v16 < *v15);
        }
        ++v4;
      }
      while (v4 < *((unsigned int *)this + 2));
    }
  }
}

void BlockBuffer::~BlockBuffer(BlockBuffer *this)
{
  void *v2;
  unint64_t v3;
  _DWORD *v4;
  unint64_t v5;
  uint64_t v6;

  v2 = *(void **)this;
  if (v2)
  {
    if (*((_DWORD *)this + 2))
    {
      v3 = 0;
      do
      {
        v4 = *(_DWORD **)(*(_QWORD *)this + 8 * v3);
        if (*v4)
        {
          v5 = 0;
          v6 = 4;
          do
          {
            free(*(void **)&v4[v6]);
            ++v5;
            v6 += 4;
          }
          while (v5 < *v4);
        }
        free(v4);
        ++v3;
      }
      while (v3 < *((unsigned int *)this + 2));
      v2 = *(void **)this;
    }
    free(v2);
    *(_QWORD *)this = 0;
  }
}

unsigned int *OutputBlockBuffer::Read(unsigned int *this, unsigned int a2, int a3, AudioBufferList **a4)
{
  unsigned int *v4;
  unsigned int v5;
  unint64_t v6;
  unsigned int v7;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  _DWORD *v13;
  unint64_t v14;
  AudioBufferList *v15;
  uint64_t v16;
  unsigned int v17;

  v4 = this;
  v5 = this[4];
  v6 = this[2];
  v7 = this[3] - v5;
  if (v7 >= a2)
    v7 = a2;
  if ((_DWORD)v6)
  {
    v9 = 0;
    v10 = (4 * a3);
    v11 = 4 * v5;
    v17 = v7;
    v12 = 4 * v7;
    do
    {
      v13 = *(_DWORD **)(*(_QWORD *)v4 + 8 * v9);
      if (*v13)
      {
        v14 = 0;
        v15 = a4[v9];
        v16 = 4;
        do
        {
          this = (unsigned int *)memcpy((void *)(*(_QWORD *)((char *)&v15->mNumberBuffers + v16 * 4) + v10), (const void *)(*(_QWORD *)&v13[v16] + v11), v12);
          ++v14;
          v16 += 4;
        }
        while (v14 < *v13);
        v6 = v4[2];
      }
      ++v9;
    }
    while (v9 < v6);
    v5 = v4[4];
    v7 = v17;
  }
  v4[4] = v5 + v7;
  return this;
}

void BlockProcessor::BlockProcessor(BlockProcessor *this, int a2, const unsigned int *a3, int a4, const unsigned int *a5, int a6, int (*a7)(void *, unsigned int, const AudioBufferList **, AudioBufferList **), void *a8)
{
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a6;
  BlockBuffer::Alloc(this, a3);
  *((_DWORD *)this + 8) = a4;
  *((_DWORD *)this + 9) = a6;
  BlockBuffer::Alloc((BlockProcessor *)((char *)this + 24), a5);
  *((_QWORD *)this + 6) = a7;
  *((_QWORD *)this + 7) = a8;
}

void sub_1B65ACFF8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;
  unint64_t v4;
  _DWORD *v5;
  unint64_t v6;
  uint64_t v7;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    if (*(_DWORD *)(v1 + 8))
    {
      v4 = 0;
      do
      {
        v5 = *(_DWORD **)(*(_QWORD *)v1 + 8 * v4);
        if (*v5)
        {
          v6 = 0;
          v7 = 4;
          do
          {
            free(*(void **)&v5[v7]);
            ++v6;
            v7 += 4;
          }
          while (v6 < *v5);
        }
        free(v5);
        ++v4;
      }
      while (v4 < *(unsigned int *)(v1 + 8));
      v3 = *(void **)v1;
    }
    free(v3);
    *(_QWORD *)v1 = 0;
  }
  _Unwind_Resume(exception_object);
}

uint64_t BlockProcessor::Process(BlockProcessor *this, unsigned int a2, const AudioBufferList **a3, AudioBufferList **a4)
{
  int v6;
  uint64_t v7;
  int v8;
  uint64_t result;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  size_t v15;
  _DWORD *v16;
  unint64_t v17;
  const AudioBufferList *v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  unsigned int v22;
  unint64_t v23;
  uint64_t v24;
  size_t v25;
  _DWORD *v26;
  unint64_t v27;
  AudioBufferList *v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;

  v6 = 0;
  v7 = *((unsigned int *)this + 3);
  while (1)
  {
    v8 = *((_DWORD *)this + 4);
    if (v8 == (_DWORD)v7)
      break;
LABEL_6:
    v10 = *((unsigned int *)this + 2);
    v32 = v6;
    v33 = a2;
    v31 = *((_DWORD *)this + 3) - v8;
    if (v31 >= a2)
      v11 = a2;
    else
      v11 = *((_DWORD *)this + 3) - v8;
    v12 = (4 * v6);
    v34 = v11;
    if ((_DWORD)v10)
    {
      v13 = 0;
      v14 = (4 * v8);
      v15 = 4 * v11;
      do
      {
        v16 = *(_DWORD **)(*(_QWORD *)this + 8 * v13);
        if (*v16)
        {
          v17 = 0;
          v18 = a3[v13];
          v19 = 4;
          do
          {
            memcpy((void *)(*(_QWORD *)&v16[v19] + v14), (const void *)(*(_QWORD *)((char *)&v18->mNumberBuffers + v19 * 4) + v12), v15);
            ++v17;
            v19 += 4;
          }
          while (v17 < *v16);
          v10 = *((unsigned int *)this + 2);
        }
        ++v13;
      }
      while (v13 < v10);
      v8 = *((_DWORD *)this + 4);
      v11 = v34;
    }
    *((_DWORD *)this + 4) = v8 + v11;
    v20 = *((_DWORD *)this + 10);
    v21 = *((unsigned int *)this + 8);
    v22 = *((_DWORD *)this + 9) - v20;
    if (v22 >= v11)
      v22 = v11;
    if ((_DWORD)v21)
    {
      v23 = 0;
      v24 = (4 * v20);
      v30 = v22;
      v25 = 4 * v22;
      do
      {
        v26 = *(_DWORD **)(*((_QWORD *)this + 3) + 8 * v23);
        if (*v26)
        {
          v27 = 0;
          v28 = a4[v23];
          v29 = 4;
          do
          {
            memcpy((void *)(*(_QWORD *)((char *)&v28->mNumberBuffers + v29 * 4) + v12), (const void *)(*(_QWORD *)&v26[v29] + v24), v25);
            ++v27;
            v29 += 4;
          }
          while (v27 < *v26);
          v21 = *((unsigned int *)this + 8);
        }
        ++v23;
      }
      while (v23 < v21);
      v20 = *((_DWORD *)this + 10);
      v11 = v34;
      v22 = v30;
    }
    *((_DWORD *)this + 10) = v20 + v22;
    a2 = v33 - v11;
    v6 = v11 + v32;
    if (v33 <= v31)
      return 0;
  }
  while (1)
  {
    result = (*((uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))this + 6))(*((_QWORD *)this + 7), v7, *(_QWORD *)this, *((_QWORD *)this + 3));
    *((_DWORD *)this + 4) = 0;
    *((_DWORD *)this + 10) = 0;
    if ((_DWORD)result)
      return result;
    if ((_DWORD)v7)
    {
      v8 = 0;
      goto LABEL_6;
    }
  }
}

void BlockProcessor::Reset(BlockProcessor *this)
{
  unint64_t v2;
  unint64_t v3;
  size_t v4;
  _DWORD *v5;
  unint64_t v6;
  uint64_t v7;

  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  if (*((_QWORD *)this + 3))
  {
    v2 = *((unsigned int *)this + 8);
    if ((_DWORD)v2)
    {
      v3 = 0;
      v4 = (4 * *((_DWORD *)this + 9));
      do
      {
        v5 = *(_DWORD **)(*((_QWORD *)this + 3) + 8 * v3);
        if (*v5)
        {
          v6 = 0;
          v7 = 4;
          do
          {
            bzero(*(void **)&v5[v7], v4);
            ++v6;
            v7 += 4;
          }
          while (v6 < *v5);
          v2 = *((unsigned int *)this + 8);
        }
        ++v3;
      }
      while (v3 < v2);
    }
  }
}

uint64_t HOA::getTDesign(HOA *this, _OWORD *__dst, float *a3, float *__C, float *a5)
{
  uint64_t v7;
  const void *v8;
  float *v9;
  size_t v10;
  __int128 *v11;
  __int128 v12;
  float __A;

  switch((int)this)
  {
    case 0:
      v7 = 1;
      if (__dst && a3)
      {
        *(_DWORD *)__dst = 0;
        *a3 = 0.0;
      }
      break;
    case 1:
      v7 = 4;
      if (__dst && a3)
      {
        *__dst = xmmword_1B66A2BD0;
        *(_OWORD *)a3 = xmmword_1B66A2BE0;
      }
      break;
    case 2:
      v7 = 12;
      if (__dst && a3)
      {
        *__dst = xmmword_1B6689D68;
        __dst[1] = unk_1B6689D78;
        __dst[2] = xmmword_1B6689D88;
        v11 = &xmmword_1B6689D98;
        *((_OWORD *)a3 + 2) = xmmword_1B6689DB8;
        goto LABEL_20;
      }
      break;
    case 3:
      v7 = 24;
      if (__dst && a3)
      {
        __dst[2] = xmmword_1B6689DE8;
        __dst[3] = unk_1B6689DF8;
        __dst[4] = xmmword_1B6689E08;
        __dst[5] = unk_1B6689E18;
        *__dst = xmmword_1B6689DC8;
        __dst[1] = unk_1B6689DD8;
        *((_OWORD *)a3 + 2) = xmmword_1B6689E48;
        *((_OWORD *)a3 + 3) = unk_1B6689E58;
        *((_OWORD *)a3 + 4) = xmmword_1B6689E68;
        *((_OWORD *)a3 + 5) = unk_1B6689E78;
        *(_OWORD *)a3 = xmmword_1B6689E28;
        *((_OWORD *)a3 + 1) = unk_1B6689E38;
      }
      break;
    case 4:
      v7 = 36;
      if (__dst && a3)
      {
        __dst[2] = xmmword_1B6689EA8;
        __dst[3] = unk_1B6689EB8;
        __dst[8] = xmmword_1B6689F08;
        __dst[6] = xmmword_1B6689EE8;
        __dst[7] = unk_1B6689EF8;
        __dst[4] = xmmword_1B6689EC8;
        __dst[5] = unk_1B6689ED8;
        *__dst = xmmword_1B6689E88;
        __dst[1] = unk_1B6689E98;
        v11 = &xmmword_1B6689F18;
        *((_OWORD *)a3 + 6) = xmmword_1B6689F78;
        *((_OWORD *)a3 + 7) = unk_1B6689F88;
        *((_OWORD *)a3 + 8) = xmmword_1B6689F98;
        *((_OWORD *)a3 + 2) = xmmword_1B6689F38;
        *((_OWORD *)a3 + 3) = unk_1B6689F48;
        *((_OWORD *)a3 + 4) = xmmword_1B6689F58;
        *((_OWORD *)a3 + 5) = unk_1B6689F68;
LABEL_20:
        v12 = v11[1];
        *(_OWORD *)a3 = *v11;
        *((_OWORD *)a3 + 1) = v12;
      }
      break;
    case 5:
      v7 = 60;
      if (__dst && a3)
      {
        __dst[12] = xmmword_1B668A068;
        __dst[13] = unk_1B668A078;
        __dst[14] = xmmword_1B668A088;
        __dst[8] = xmmword_1B668A028;
        __dst[9] = unk_1B668A038;
        __dst[10] = xmmword_1B668A048;
        __dst[11] = unk_1B668A058;
        __dst[4] = xmmword_1B6689FE8;
        __dst[5] = unk_1B6689FF8;
        __dst[6] = xmmword_1B668A008;
        __dst[7] = unk_1B668A018;
        *__dst = xmmword_1B6689FA8;
        __dst[1] = unk_1B6689FB8;
        __dst[2] = xmmword_1B6689FC8;
        __dst[3] = unk_1B6689FD8;
        *((_OWORD *)a3 + 12) = xmmword_1B668A158;
        *((_OWORD *)a3 + 13) = unk_1B668A168;
        *((_OWORD *)a3 + 14) = xmmword_1B668A178;
        *((_OWORD *)a3 + 8) = xmmword_1B668A118;
        *((_OWORD *)a3 + 9) = unk_1B668A128;
        *((_OWORD *)a3 + 10) = xmmword_1B668A138;
        *((_OWORD *)a3 + 11) = unk_1B668A148;
        *((_OWORD *)a3 + 4) = xmmword_1B668A0D8;
        *((_OWORD *)a3 + 5) = unk_1B668A0E8;
        *((_OWORD *)a3 + 6) = xmmword_1B668A0F8;
        *((_OWORD *)a3 + 7) = unk_1B668A108;
        *(_OWORD *)a3 = xmmword_1B668A098;
        *((_OWORD *)a3 + 1) = unk_1B668A0A8;
        *((_OWORD *)a3 + 2) = xmmword_1B668A0B8;
        *((_OWORD *)a3 + 3) = unk_1B668A0C8;
      }
      break;
    case 6:
      v7 = 84;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668A188, 0x150uLL);
        v8 = &unk_1B668A2D8;
        v9 = a3;
        v10 = 336;
        goto LABEL_72;
      }
      break;
    case 7:
      v7 = 108;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668A428, 0x1B0uLL);
        v8 = &unk_1B668A5D8;
        v9 = a3;
        v10 = 432;
        goto LABEL_72;
      }
      break;
    case 8:
      v7 = 144;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668A788, 0x240uLL);
        v8 = &unk_1B668A9C8;
        v9 = a3;
        v10 = 576;
        goto LABEL_72;
      }
      break;
    case 9:
      v7 = 180;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668AC08, 0x2D0uLL);
        v8 = &unk_1B668AED8;
        v9 = a3;
        v10 = 720;
        goto LABEL_72;
      }
      break;
    case 10:
      v7 = 216;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668B1A8, 0x360uLL);
        v8 = &unk_1B668B508;
        v9 = a3;
        v10 = 864;
        goto LABEL_72;
      }
      break;
    case 11:
      v7 = 266;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668B868, 0x428uLL);
        v8 = &unk_1B668BC90;
        v9 = a3;
        v10 = 1064;
        goto LABEL_72;
      }
      break;
    case 12:
      v7 = 314;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668C0B8, 0x4E8uLL);
        v8 = &unk_1B668C5A0;
        v9 = a3;
        v10 = 1256;
        goto LABEL_72;
      }
      break;
    case 13:
      v7 = 366;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668CA88, 0x5B8uLL);
        v8 = &unk_1B668D040;
        v9 = a3;
        v10 = 1464;
        goto LABEL_72;
      }
      break;
    case 14:
      v7 = 422;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668D5F8, 0x698uLL);
        v8 = &unk_1B668DC90;
        v9 = a3;
        v10 = 1688;
        goto LABEL_72;
      }
      break;
    case 15:
      v7 = 482;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668E328, 0x788uLL);
        v8 = &unk_1B668EAB0;
        v9 = a3;
        v10 = 1928;
        goto LABEL_72;
      }
      break;
    case 16:
      v7 = 546;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B668F238, 0x888uLL);
        v8 = &unk_1B668FAC0;
        v9 = a3;
        v10 = 2184;
        goto LABEL_72;
      }
      break;
    case 17:
      v7 = 614;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B6690348, 0x998uLL);
        v8 = &unk_1B6690CE0;
        v9 = a3;
        v10 = 2456;
        goto LABEL_72;
      }
      break;
    case 18:
      v7 = 686;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B6691678, 0xAB8uLL);
        v8 = &unk_1B6692130;
        v9 = a3;
        v10 = 2744;
        goto LABEL_72;
      }
      break;
    case 19:
      v7 = 762;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B6692BE8, 0xBE8uLL);
        v8 = &unk_1B66937D0;
        v9 = a3;
        v10 = 3048;
        goto LABEL_72;
      }
      break;
    case 20:
      v7 = 842;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B66943B8, 0xD28uLL);
        v8 = &unk_1B66950E0;
        v9 = a3;
        v10 = 3368;
        goto LABEL_72;
      }
      break;
    case 21:
      v7 = 926;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B6695E08, 0xE78uLL);
        v8 = &unk_1B6696C80;
        v9 = a3;
        v10 = 3704;
        goto LABEL_72;
      }
      break;
    default:
      v7 = 1014;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_1B6697AF8, 0xFD8uLL);
        v8 = &unk_1B6698AD0;
        v9 = a3;
        v10 = 4056;
LABEL_72:
        memcpy(v9, v8, v10);
      }
      break;
  }
  if (__C)
  {
    __A = 1.0;
    vDSP_vfill(&__A, __C, 1, v7);
  }
  return v7;
}

__n128 *std::vector<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>>::__emplace_back_slow_path<std::shared_ptr<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>> &>(uint64_t a1, __n128 a2)
{
  __n128 *v2;
  __n128 *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  __n128 *v10;
  unint64_t *v11;
  unint64_t v12;
  char *v13;
  __n128 *v14;
  __n128 v15;
  __n128 *v16;
  std::__shared_weak_count *v17;

  v2 = *(__n128 **)a1;
  v3 = *(__n128 **)(a1 + 8);
  v4 = ((uint64_t)v3 - *(_QWORD *)a1) >> 4;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  v7 = *(_QWORD *)(a1 + 16) - (_QWORD)v2;
  if (v7 >> 3 > v5)
    v5 = v7 >> 3;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0)
    v5 = 0xFFFFFFFFFFFFFFFLL;
  if (v5 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v8 = 16 * v5;
  v9 = (char *)operator new(16 * v5);
  v10 = (__n128 *)&v9[16 * v4];
  *v10 = a2;
  if (a2.n128_u64[1])
  {
    v11 = (unint64_t *)(a2.n128_u64[1] + 16);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    v2 = *(__n128 **)a1;
    v3 = *(__n128 **)(a1 + 8);
  }
  v13 = &v9[v8];
  v14 = v10 + 1;
  if (v3 == v2)
  {
    *(_QWORD *)a1 = v10;
    *(_QWORD *)(a1 + 8) = v14;
    *(_QWORD *)(a1 + 16) = v13;
  }
  else
  {
    do
    {
      v15 = v3[-1];
      --v3;
      v10[-1] = v15;
      --v10;
      v3->n128_u64[0] = 0;
      v3->n128_u64[1] = 0;
    }
    while (v3 != v2);
    v2 = *(__n128 **)a1;
    v16 = *(__n128 **)(a1 + 8);
    *(_QWORD *)a1 = v10;
    *(_QWORD *)(a1 + 8) = v14;
    *(_QWORD *)(a1 + 16) = v13;
    while (v16 != v2)
    {
      v17 = (std::__shared_weak_count *)v16[-1].n128_u64[1];
      if (v17)
        std::__shared_weak_count::__release_weak(v17);
      --v16;
    }
  }
  if (v2)
    operator delete(v2);
  return v14;
}

uint64_t *std::unique_ptr<DFTSetups>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  vDSP_DFT_SetupStruct *v3;
  vDSP_DFT_SetupStruct *v4;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(vDSP_DFT_SetupStruct **)(v2 + 16);
    if (v3)
      vDSP_DFT_DestroySetup(v3);
    v4 = *(vDSP_DFT_SetupStruct **)(v2 + 8);
    if (v4)
      vDSP_DFT_DestroySetup(v4);
    MEMORY[0x1BCC95CEC](v2, 0x1060C40CA828048);
  }
  return a1;
}

void std::__shared_ptr_emplace<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69ED620;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69ED620;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void std::__shared_ptr_emplace<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>::__on_zero_shared(_QWORD *a1)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  vDSP_DFT_SetupStruct *v4;
  vDSP_DFT_SetupStruct *v5;
  std::__shared_weak_count *v6;

  v2 = (os_unfair_lock_s *)a1[6];
  if (os_unfair_lock_trylock(v2))
  {
    caulk::shared_instance_manager<DFTSetups>::remove_expired((uint64_t)v2);
    os_unfair_lock_unlock(v2);
  }
  v3 = a1[5];
  a1[5] = 0;
  if (v3)
  {
    v4 = *(vDSP_DFT_SetupStruct **)(v3 + 16);
    if (v4)
      vDSP_DFT_DestroySetup(v4);
    v5 = *(vDSP_DFT_SetupStruct **)(v3 + 8);
    if (v5)
      vDSP_DFT_DestroySetup(v5);
    MEMORY[0x1BCC95CEC](v3, 0x1060C40CA828048);
  }
  v6 = (std::__shared_weak_count *)a1[4];
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void caulk::shared_instance_manager<DFTSetups>::remove_expired(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;

  v1 = *(uint64_t **)(a1 + 8);
  v2 = *(uint64_t **)(a1 + 16);
  if (v1 != v2)
  {
    while (1)
    {
      v4 = v1[1];
      if (!v4 || *(_QWORD *)(v4 + 8) == -1)
        break;
      v1 += 2;
      if (v1 == v2)
        return;
    }
    if (v1 != v2)
    {
      v5 = v1 + 2;
      if (v1 + 2 != v2)
      {
        do
        {
          v6 = v5[1];
          if (v6 && *(_QWORD *)(v6 + 8) != -1)
          {
            v7 = *v5;
            *v5 = 0;
            v5[1] = 0;
            v8 = (std::__shared_weak_count *)v1[1];
            *v1 = v7;
            v1[1] = v6;
            if (v8)
              std::__shared_weak_count::__release_weak(v8);
            v1 += 2;
          }
          v5 += 2;
        }
        while (v5 != v2);
        v2 = *(uint64_t **)(a1 + 16);
      }
    }
    if (v1 != v2)
    {
      while (v2 != v1)
      {
        v9 = (std::__shared_weak_count *)*(v2 - 1);
        if (v9)
          std::__shared_weak_count::__release_weak(v9);
        v2 -= 2;
      }
      *(_QWORD *)(a1 + 16) = v1;
    }
  }
}

uint64_t MultiRadixRealFFT::Initialize(MultiRadixRealFFT *this, unsigned int a2)
{
  unsigned __int8 v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  vDSP_DFT_SetupStruct *Setup;
  vDSP_DFT_SetupStruct *v15;
  vDSP_DFT_Setup v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *p_shared_weak_owners;
  unint64_t v23;
  unint64_t v24;
  __n128 *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  __n128 *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  BOOL v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *p_shared_owners;
  unint64_t v49;
  uint64_t v50;
  __n128 v51;

  {
    v50 = operator new();
    *(_DWORD *)v50 = 0;
    *(_QWORD *)(v50 + 16) = 0;
    *(_QWORD *)(v50 + 24) = 0;
    *(_QWORD *)(v50 + 8) = 0;
    DFTSetupList<false>::instance(void)::global = v50;
  }
  v5 = DFTSetupList<false>::instance(void)::global;
  os_unfair_lock_lock((os_unfair_lock_t)DFTSetupList<false>::instance(void)::global);
  caulk::shared_instance_manager<DFTSetups>::remove_expired(v5);
  v6 = *(_QWORD **)(v5 + 8);
  v7 = *(_QWORD **)(v5 + 16);
  while (v6 != v7)
  {
    v8 = (std::__shared_weak_count *)v6[1];
    if (v8)
    {
      v9 = std::__shared_weak_count::lock(v8);
      if (v9)
      {
        v10 = v9;
        if (*v6)
        {
          v11 = *(_QWORD *)(*v6 + 16);
          if (*(_DWORD *)v11 == a2)
          {
            p_shared_owners = (unint64_t *)&v9->__shared_owners_;
            do
              v49 = __ldxr(p_shared_owners);
            while (__stxr(v49 + 1, p_shared_owners));
            do
              v32 = __ldaxr(p_shared_owners);
            while (__stlxr(v32 - 1, p_shared_owners));
            goto LABEL_34;
          }
        }
        v12 = (unint64_t *)&v9->__shared_owners_;
        do
          v13 = __ldaxr(v12);
        while (__stlxr(v13 - 1, v12));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
    }
    v6 += 2;
  }
  Setup = vDSP_DFT_zrop_CreateSetup(0, a2, vDSP_DFT_FORWARD);
  v15 = Setup;
  if (Setup)
    v16 = vDSP_DFT_zrop_CreateSetup(Setup, a2, vDSP_DFT_INVERSE);
  else
    v16 = 0;
  v17 = operator new();
  *(_DWORD *)v17 = a2;
  *(_QWORD *)(v17 + 8) = v15;
  *(_QWORD *)(v17 + 16) = v16;
  v18 = (std::__shared_weak_count *)operator new(0x38uLL);
  v19 = v18;
  v18->__shared_owners_ = 0;
  v20 = (unint64_t *)&v18->__shared_owners_;
  v18->__shared_weak_owners_ = 0;
  v18->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69ED620;
  v51.n128_u64[0] = (unint64_t)&v18[1];
  v18[1].__shared_weak_owners_ = v17;
  v18[2].__vftable = (std::__shared_weak_count_vtbl *)v5;
  v51.n128_u64[1] = (unint64_t)v18;
  do
    v21 = __ldxr(v20);
  while (__stxr(v21 + 1, v20));
  p_shared_weak_owners = (unint64_t *)&v18->__shared_weak_owners_;
  do
    v23 = __ldxr(p_shared_weak_owners);
  while (__stxr(v23 + 1, p_shared_weak_owners));
  v18[1].__vftable = (std::__shared_weak_count_vtbl *)&v18[1];
  v18[1].__shared_owners_ = (uint64_t)v18;
  do
    v24 = __ldaxr(v20);
  while (__stlxr(v24 - 1, v20));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v19);
  }
  v25 = *(__n128 **)(v5 + 16);
  if ((unint64_t)v25 >= *(_QWORD *)(v5 + 24))
  {
    v29 = std::vector<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>>::__emplace_back_slow_path<std::shared_ptr<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>> &>(v5 + 8, v51);
    v10 = (std::__shared_weak_count *)v51.n128_u64[1];
    v26 = v51.n128_u64[0];
  }
  else
  {
    v26 = v51.n128_u64[0];
    *v25 = v51;
    v10 = (std::__shared_weak_count *)v51.n128_u64[1];
    if (v51.n128_u64[1])
    {
      v27 = (unint64_t *)(v51.n128_u64[1] + 16);
      do
        v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
    }
    v29 = v25 + 1;
  }
  *(_QWORD *)(v5 + 16) = v29;
  v11 = *(_QWORD *)(v26 + 16);
  if (v10)
  {
    v30 = (unint64_t *)&v10->__shared_owners_;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
    do
      v32 = __ldaxr(v30);
    while (__stlxr(v32 - 1, v30));
LABEL_34:
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v5);
  if (*(_QWORD *)(v11 + 8) && *(_QWORD *)(v11 + 16))
  {
    if (!v10)
    {
      v35 = 0;
      v36 = 0;
      v39 = 1;
      goto LABEL_54;
    }
    v33 = (unint64_t *)&v10->__shared_owners_;
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
    v35 = 0;
    v36 = v10;
  }
  else
  {
    v11 = 0;
    v35 = 1936292453;
    if (!v10)
    {
      v39 = 1;
      v36 = 0;
      goto LABEL_54;
    }
    v36 = 0;
  }
  v37 = (unint64_t *)&v10->__shared_owners_;
  do
    v38 = __ldaxr(v37);
  while (__stlxr(v38 - 1, v37));
  if (!v38)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  v39 = v36 == 0;
  if (v36)
  {
    v40 = (unint64_t *)&v36->__shared_owners_;
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
LABEL_54:
  v42 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  *(_QWORD *)this = v11;
  *((_QWORD *)this + 1) = v36;
  if (!v42)
    goto LABEL_58;
  v43 = (unint64_t *)&v42->__shared_owners_;
  do
    v44 = __ldaxr(v43);
  while (__stlxr(v44 - 1, v43));
  if (!v44)
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
    if (v39)
      return v35;
  }
  else
  {
LABEL_58:
    if (v39)
      return v35;
  }
  v45 = (unint64_t *)&v36->__shared_owners_;
  do
    v46 = __ldaxr(v45);
  while (__stlxr(v46 - 1, v45));
  if (!v46)
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  return v35;
}

void sub_1B65AE0FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B65AE114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  os_unfair_lock_s *v5;
  va_list va;

  va_start(va, a5);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)va);
  os_unfair_lock_unlock(v5);
  _Unwind_Resume(a1);
}

void MultiRadixRealFFT::RealInPlaceTransform(MultiRadixRealFFT *this, DSPSplitComplex *a2, int a3, float a4)
{
  uint64_t v7;
  float __B;

  if (!*(_QWORD *)this)
    abort();
  v7 = 16;
  if (a3 == 1)
    v7 = 8;
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(*(_QWORD *)this + v7), a2->realp, a2->imagp, a2->realp, a2->imagp);
  if (a3 == 1)
  {
    __B = 0.5;
    vDSP_vsmul(a2->realp, 1, &__B, a2->realp, 1, (unint64_t)**(unsigned int **)this >> 1);
    vDSP_vsmul(a2->imagp, 1, &__B, a2->imagp, 1, (unint64_t)**(unsigned int **)this >> 1);
  }
}

void MultiRadixRealFFT::RealOutOfPlaceForwardTransform(MultiRadixRealFFT *this, DSPComplex *__C, DSPSplitComplex *a3, float a4)
{
  float __B;

  vDSP_ctoz(__C, 2, a3, 1, (unint64_t)**(unsigned int **)this >> 1);
  if (!*(_QWORD *)this)
    abort();
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(*(_QWORD *)this + 8), a3->realp, a3->imagp, a3->realp, a3->imagp);
  __B = a4 * 0.5;
  vDSP_vsmul(a3->realp, 1, &__B, a3->realp, 1, (unint64_t)**(unsigned int **)this >> 1);
  vDSP_vsmul(a3->imagp, 1, &__B, a3->imagp, 1, (unint64_t)**(unsigned int **)this >> 1);
}

void MultiRadixRealFFT::RealOutOfPlaceInverseTransform(const vDSP_DFT_SetupStruct ***this, const DSPSplitComplex *a2, DSPComplex *a3)
{
  const vDSP_DFT_SetupStruct **v3;
  uint64_t v7;
  size_t v8;
  char *v9;
  vDSP_Length v10;
  uint64_t v11;
  DSPSplitComplex __Z;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = *this;
  if (!*this)
    abort();
  v7 = *(unsigned int *)v3;
  MEMORY[0x1E0C80A78](this);
  v9 = (char *)&v11 - ((v8 + 15) & 0x7FFFFFFF0);
  bzero(v9, v8);
  __Z.realp = (float *)v9;
  __Z.imagp = (float *)&v9[(2 * v7) & 0x1FFFFFFFCLL];
  vDSP_DFT_Execute(v3[2], a2->realp, a2->imagp, (float *)v9, __Z.imagp);
  if (*this)
    v10 = (unint64_t)*(unsigned int *)*this >> 1;
  else
    v10 = 0;
  vDSP_ztoc(&__Z, 1, a3, 2, v10);
}

uint64_t MultiRadixFFT_Create(unsigned int a1, _QWORD *a2)
{
  _QWORD *v4;
  unsigned __int8 v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  vDSP_DFT_SetupStruct *Setup;
  vDSP_DFT_SetupStruct *v16;
  vDSP_DFT_Setup v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *p_shared_weak_owners;
  unint64_t v24;
  unint64_t v25;
  __n128 *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  __n128 *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  char v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  BOOL v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *p_shared_owners;
  unint64_t v54;
  uint64_t v55;
  __n128 v56;

  v4 = (_QWORD *)operator new();
  *v4 = 0;
  v4[1] = 0;
  {
    v55 = operator new();
    *(_DWORD *)v55 = 0;
    *(_QWORD *)(v55 + 16) = 0;
    *(_QWORD *)(v55 + 24) = 0;
    *(_QWORD *)(v55 + 8) = 0;
    DFTSetupList<true>::instance(void)::global = v55;
  }
  v6 = DFTSetupList<true>::instance(void)::global;
  os_unfair_lock_lock((os_unfair_lock_t)DFTSetupList<true>::instance(void)::global);
  caulk::shared_instance_manager<DFTSetups>::remove_expired(v6);
  v7 = *(_QWORD **)(v6 + 8);
  v8 = *(_QWORD **)(v6 + 16);
  while (v7 != v8)
  {
    v9 = (std::__shared_weak_count *)v7[1];
    if (v9)
    {
      v10 = std::__shared_weak_count::lock(v9);
      if (v10)
      {
        v11 = v10;
        if (*v7)
        {
          v12 = *(_QWORD *)(*v7 + 16);
          if (*(_DWORD *)v12 == a1)
          {
            p_shared_owners = (unint64_t *)&v10->__shared_owners_;
            do
              v54 = __ldxr(p_shared_owners);
            while (__stxr(v54 + 1, p_shared_owners));
            do
              v33 = __ldaxr(p_shared_owners);
            while (__stlxr(v33 - 1, p_shared_owners));
            goto LABEL_34;
          }
        }
        v13 = (unint64_t *)&v10->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
    }
    v7 += 2;
  }
  Setup = vDSP_DFT_zop_CreateSetup(0, a1, vDSP_DFT_FORWARD);
  v16 = Setup;
  if (Setup)
    v17 = vDSP_DFT_zop_CreateSetup(Setup, a1, vDSP_DFT_INVERSE);
  else
    v17 = 0;
  v18 = operator new();
  *(_DWORD *)v18 = a1;
  *(_QWORD *)(v18 + 8) = v16;
  *(_QWORD *)(v18 + 16) = v17;
  v19 = (std::__shared_weak_count *)operator new(0x38uLL);
  v20 = v19;
  v19->__shared_owners_ = 0;
  v21 = (unint64_t *)&v19->__shared_owners_;
  v19->__shared_weak_owners_ = 0;
  v19->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69ED620;
  v56.n128_u64[0] = (unint64_t)&v19[1];
  v19[1].__shared_weak_owners_ = v18;
  v19[2].__vftable = (std::__shared_weak_count_vtbl *)v6;
  v56.n128_u64[1] = (unint64_t)v19;
  do
    v22 = __ldxr(v21);
  while (__stxr(v22 + 1, v21));
  p_shared_weak_owners = (unint64_t *)&v19->__shared_weak_owners_;
  do
    v24 = __ldxr(p_shared_weak_owners);
  while (__stxr(v24 + 1, p_shared_weak_owners));
  v19[1].__vftable = (std::__shared_weak_count_vtbl *)&v19[1];
  v19[1].__shared_owners_ = (uint64_t)v19;
  do
    v25 = __ldaxr(v21);
  while (__stlxr(v25 - 1, v21));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v20);
  }
  v26 = *(__n128 **)(v6 + 16);
  if ((unint64_t)v26 >= *(_QWORD *)(v6 + 24))
  {
    v30 = std::vector<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>>::__emplace_back_slow_path<std::shared_ptr<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>> &>(v6 + 8, v56);
    v11 = (std::__shared_weak_count *)v56.n128_u64[1];
    v27 = v56.n128_u64[0];
  }
  else
  {
    v27 = v56.n128_u64[0];
    *v26 = v56;
    v11 = (std::__shared_weak_count *)v56.n128_u64[1];
    if (v56.n128_u64[1])
    {
      v28 = (unint64_t *)(v56.n128_u64[1] + 16);
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    v30 = v26 + 1;
  }
  *(_QWORD *)(v6 + 16) = v30;
  v12 = *(_QWORD *)(v27 + 16);
  if (v11)
  {
    v31 = (unint64_t *)&v11->__shared_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    do
      v33 = __ldaxr(v31);
    while (__stlxr(v33 - 1, v31));
LABEL_34:
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v6);
  if (*(_QWORD *)(v12 + 8) && *(_QWORD *)(v12 + 16))
  {
    if (!v11)
    {
      v36 = 0;
      v38 = 0;
      v41 = 1;
      v37 = 1;
      goto LABEL_54;
    }
    v34 = (unint64_t *)&v11->__shared_owners_;
    do
      v35 = __ldxr(v34);
    while (__stxr(v35 + 1, v34));
    v36 = 0;
    v37 = 1;
    v38 = v11;
  }
  else
  {
    v12 = 0;
    v37 = 0;
    v36 = 1936292453;
    if (!v11)
    {
      v41 = 1;
      v38 = 0;
      goto LABEL_54;
    }
    v38 = 0;
  }
  v39 = (unint64_t *)&v11->__shared_owners_;
  do
    v40 = __ldaxr(v39);
  while (__stlxr(v40 - 1, v39));
  if (!v40)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  v41 = v38 == 0;
  if (v38)
  {
    v42 = (unint64_t *)&v38->__shared_owners_;
    do
      v43 = __ldxr(v42);
    while (__stxr(v43 + 1, v42));
  }
LABEL_54:
  v44 = (std::__shared_weak_count *)v4[1];
  *v4 = v12;
  v4[1] = v38;
  if (!v44)
    goto LABEL_58;
  v45 = (unint64_t *)&v44->__shared_owners_;
  do
    v46 = __ldaxr(v45);
  while (__stlxr(v46 - 1, v45));
  if (!v46)
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
    if (v41)
      goto LABEL_64;
  }
  else
  {
LABEL_58:
    if (v41)
      goto LABEL_64;
  }
  v47 = (unint64_t *)&v38->__shared_owners_;
  do
    v48 = __ldaxr(v47);
  while (__stlxr(v48 - 1, v47));
  if (!v48)
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
LABEL_64:
  if ((v37 & 1) != 0)
  {
    *a2 = v4;
  }
  else
  {
    v49 = (std::__shared_weak_count *)v4[1];
    if (v49)
    {
      v50 = (unint64_t *)&v49->__shared_owners_;
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
    MEMORY[0x1BCC95CEC](v4, 0x20C40A4A59CD2);
  }
  return v36;
}

void sub_1B65AE8B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B65AE8CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  os_unfair_lock_s *v5;
  va_list va;

  va_start(va, a5);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)va);
  os_unfair_lock_unlock(v5);
  _Unwind_Resume(a1);
}

uint64_t MultiRadixFFT_Dispose(uint64_t result)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  if (result)
  {
    v1 = *(std::__shared_weak_count **)(result + 8);
    if (v1)
    {
      p_shared_owners = (unint64_t *)&v1->__shared_owners_;
      do
        v3 = __ldaxr(p_shared_owners);
      while (__stlxr(v3 - 1, p_shared_owners));
      if (!v3)
      {
        ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
        std::__shared_weak_count::__release_weak(v1);
      }
    }
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void MultiRadixFFT_CplxInPlaceTransform(_QWORD *a1, const float **a2, int a3)
{
  uint64_t v3;

  if (a1)
  {
    if (!*a1)
      abort();
    v3 = 16;
    if (a3 == 1)
      v3 = 8;
    vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(*a1 + v3), *a2, a2[1], (float *)*a2, (float *)a2[1]);
  }
}

uint64_t MultiRadixRealFFT_Create(unsigned int a1, MultiRadixRealFFT **a2)
{
  MultiRadixRealFFT *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  v4 = (MultiRadixRealFFT *)operator new();
  *(_QWORD *)v4 = 0;
  *((_QWORD *)v4 + 1) = 0;
  v5 = MultiRadixRealFFT::Initialize(v4, a1);
  if ((_DWORD)v5)
  {
    v6 = (std::__shared_weak_count *)*((_QWORD *)v4 + 1);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    MEMORY[0x1BCC95CEC](v4, 0x20C40A4A59CD2);
  }
  else
  {
    *a2 = v4;
  }
  return v5;
}

uint64_t NextPrime(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  char v3;
  unsigned int v4;
  unsigned int v5;
  int v7;
  int v8;
  int v9;
  int v10;

  if (a1 >= 0xFFF2)
  {
    a1 = a1 | 1;
    v1 = a1;
    do
    {
      v2 = 1;
      v3 = 1;
      do
      {
        v4 = kPrimes[v2];
        if (v4 * v4 > v1)
          break;
        v5 = v1 % v4;
        v3 &= v5 != 0;
      }
      while (v5 && v2++ < 0x198D);
      if ((v3 & 1) != 0)
        return v1;
      v1 = (v1 + 2);
    }
    while ((_DWORD)v1);
  }
  if (a1 >= 3)
  {
    v7 = 0;
    v8 = 6541;
    do
    {
      v9 = v8 + v7;
      if (v8 + v7 < 0 != __OFADD__(v8, v7))
        ++v9;
      v10 = v9 >> 1;
      if (a1 <= kPrimes[v10])
        v8 = v10;
      else
        v7 = v10 + 1;
      v1 = kPrimes[v7];
    }
    while (a1 > v1);
    return v1;
  }
  return 2;
}

void Biquad::GetHipassParams(Biquad *this, double a2, double a3, BiquadCoefficients *a4)
{
  double v6;
  __double2 v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  v6 = __exp10(0.0);
  if (a2 * 3.14159265 <= 0.0 || v6 <= 0.0)
  {
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 2) = 0x3FF0000000000000;
  }
  else
  {
    v7 = __sincos_stret(fmin(a2 * 3.14159265, 3.11017673));
    v8 = __exp10(0.0);
    v9 = v7.__sinval / (v6 + v6);
    v10 = v7.__cosval * 0.5 + 0.5;
    v11 = 1.0 / (v9 + 1.0);
    v12 = v11 * v8;
    *(double *)this = v7.__cosval * -2.0 * v11;
    *((double *)this + 1) = v11 - v9 * v11;
    *((double *)this + 2) = v10 * v12;
    *((double *)this + 3) = v10 * -2.0 * v12;
    *((double *)this + 4) = v10 * v12;
  }
}

float64x2_t Biquad::Process_Float32(Biquad *this, float *a2, float *a3, int a4)
{
  float32x2_t v4;
  float32x2_t v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unsigned int v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  unsigned int v34;
  float v35;
  float v36;
  float v37;
  float v38;
  BOOL v39;
  float v40;
  float32x2_t v41;
  float v42;
  float v44;
  float v45;
  float v47;
  float64x2_t result;

  v4 = vcvt_f32_f64(*(float64x2_t *)((char *)this + 40));
  v5 = vcvt_f32_f64(*(float64x2_t *)((char *)this + 56));
  v6 = *((double *)this + 2);
  v7 = *((double *)this + 3);
  v8 = *((double *)this + 4);
  v9 = *(double *)this;
  v10 = *((double *)this + 1);
  v11 = v4.f32[1];
  v12 = v5.f32[1];
  v13 = a4 - 4;
  if (a4 >= 4)
  {
    v14 = *a2;
    v15 = a2[1];
    v16 = a2[2];
    v17 = a2[3];
    v18 = (float)((float)((float)(v4.f32[0] * v7) + (float)(v4.f32[1] * v8)) - (float)(v5.f32[0] * v9))
        + (float)(*a2 * v6);
    v19 = (float)((float)(v4.f32[0] * v8) + (float)(*a2 * v7)) + (float)(v15 * v6);
    v20 = (float)(v15 * v7) + (float)(v16 * v6);
    v21 = v17 * v6;
    a2 += 4;
    if (v13 >= 5)
    {
      do
      {
        v22 = *a2;
        v23 = v18 - (float)(v12 * v10);
        *a3 = v23;
        v24 = v20 + (float)(v14 * v8);
        v14 = a2[1];
        v25 = v19 - (float)((float)(v23 * v9) + (float)(v5.f32[0] * v10));
        a3[1] = v25;
        v26 = v21 + (float)(v15 * v8);
        v15 = a2[2];
        v27 = v24 - (float)((float)(v23 * v10) + (float)(v25 * v9));
        v28 = v16 * v8;
        a3[2] = v27;
        v29 = v26 + (float)(v16 * v7);
        v16 = a2[3];
        v12 = v29 - (float)((float)(v25 * v10) + (float)(v27 * v9));
        v30 = v17 * v8;
        a3[3] = v12;
        v31 = v28 + (float)(v17 * v7);
        v17 = a2[4];
        v5.f32[0] = (float)(v31 - (float)((float)(v27 * v10) + (float)(v12 * v9))) + (float)(v22 * v6);
        v18 = (float)((float)(v30 + (float)(v22 * v7)) + (float)(v14 * v6)) - (float)(v5.f32[0] * v9);
        v19 = (float)((float)(v22 * v8) + (float)(v14 * v7)) + (float)(v15 * v6);
        v20 = (float)(v15 * v7) + (float)(v16 * v6);
        a3[4] = v5.f32[0];
        a3 += 5;
        v13 -= 5;
        v21 = v17 * v6;
        a2 += 5;
      }
      while (v13 > 4);
    }
    v32 = v18 - (float)(v12 * v10);
    v33 = v19 - (float)((float)(v32 * v9) + (float)(v5.f32[0] * v10));
    *a3 = v32;
    a3[1] = v33;
    v12 = (float)(v20 + (float)(v14 * v8)) - (float)((float)(v32 * v10) + (float)(v33 * v9));
    v5.f32[0] = (float)((float)(v21 + (float)(v15 * v8)) + (float)(v16 * v7))
              - (float)((float)(v33 * v10) + (float)(v12 * v9));
    a3[2] = v12;
    a3[3] = v5.f32[0];
    a3 += 4;
    v4.f32[0] = v17;
    v11 = v16;
    a4 = v13;
  }
  if (a4 < 1)
  {
    v35 = v11;
    v36 = v12;
  }
  else
  {
    v34 = a4 + 1;
    do
    {
      v35 = v4.f32[0];
      v36 = v5.f32[0];
      v37 = *a2++;
      v4.f32[0] = v37;
      v5.f32[0] = (float)((float)((float)(v35 * v7) + (float)(v11 * v8))
                        - (float)((float)(v5.f32[0] * v9) + (float)(v12 * v10)))
                + (float)(v37 * v6);
      *a3++ = v5.f32[0];
      --v34;
      v12 = v36;
      v11 = v35;
    }
    while (v34 > 1);
  }
  v38 = fabsf(v4.f32[0]);
  v39 = v38 >= 1.0e15 || v38 <= 1.0e-15;
  v40 = 0.0;
  if (v39)
    v41.f32[0] = 0.0;
  else
    v41.f32[0] = v4.f32[0];
  v42 = fabsf(v35);
  if (v42 >= 1.0e15 || v42 <= 1.0e-15)
    v44 = 0.0;
  else
    v44 = v35;
  v41.f32[1] = v44;
  v45 = fabsf(v5.f32[0]);
  if (v45 >= 1.0e15 || v45 <= 1.0e-15)
    v5.f32[0] = 0.0;
  v47 = fabsf(v36);
  if (v47 < 1.0e15 && v47 > 1.0e-15)
    v40 = v36;
  v5.f32[1] = v40;
  *(float64x2_t *)((char *)this + 40) = vcvtq_f64_f32(v41);
  result = vcvtq_f64_f32(v5);
  *(float64x2_t *)((char *)this + 56) = result;
  return result;
}

uint64_t HOA::RotationMatrix::RotationMatrix(uint64_t a1, unsigned int a2, int a3, char a4)
{
  unsigned int v4;
  unint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  unsigned int v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  unint64_t *v25;
  unint64_t *v26;
  int v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  unsigned int v37;
  uint64_t v38;

  v4 = a2;
  v38 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = a4;
  if (a2 >= 4 && a3 == 2)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v28 = 136316162;
      v29 = "HOA.cpp";
      v30 = 1024;
      v32 = 2080;
      v31 = 29;
      v33 = "RotationMatrix";
      v34 = 1024;
      v35 = 29;
      v36 = 1024;
      v37 = v4;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Trying to create a HOA rotation matrix of order = %d > 3 with FuMa norm"
        "alization, capping to order 3",
        (uint8_t *)&v28,
        0x28u);
    }
    v4 = 3;
  }
  v6 = v4 + 1;
  v28 = 0;
  std::vector<float>::assign((char **)a1, (8 * v6 * (unint64_t)v6 - 2) * v6 / 6, &v28);
  v7 = *(_BYTE **)(a1 + 24);
  if (v6 > (uint64_t)(*(_QWORD *)(a1 + 40) - (_QWORD)v7) >> 4)
  {
    v8 = *(_BYTE **)(a1 + 32);
    v9 = (char *)operator new(16 * v6);
    v10 = &v9[(v8 - v7) & 0xFFFFFFFFFFFFFFF0];
    v11 = v10;
    if (v8 != v7)
    {
      v12 = &v9[(v8 - v7) & 0xFFFFFFFFFFFFFFF0];
      do
      {
        v11 = v12 - 16;
        *((_OWORD *)v12 - 1) = *((_OWORD *)v8 - 1);
        v8 -= 16;
        v12 -= 16;
      }
      while (v8 != v7);
    }
    *(_QWORD *)(a1 + 24) = v11;
    *(_QWORD *)(a1 + 32) = v10;
    *(_QWORD *)(a1 + 40) = &v9[16 * v6];
    if (v7)
      operator delete(v7);
  }
  v13 = 0;
  v14 = *(unint64_t **)(a1 + 32);
  do
  {
    v16 = ((2 * v13) | 1) * ((2 * v13) | 1);
    v17 = *(_QWORD *)a1 + 4 * ((8 * v13 * v13 - 2) * v13 / 6uLL);
    v18 = *(_QWORD *)(a1 + 40);
    if ((unint64_t)v14 < v18)
    {
      *v14 = v17;
      v14[1] = v16;
      v15 = v14 + 2;
    }
    else
    {
      v19 = *(unint64_t **)(a1 + 24);
      v20 = ((char *)v14 - (char *)v19) >> 4;
      v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 60)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v22 = v18 - (_QWORD)v19;
      if (v22 >> 3 > v21)
        v21 = v22 >> 3;
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
        v23 = 0xFFFFFFFFFFFFFFFLL;
      else
        v23 = v21;
      if (v23)
      {
        if (v23 >> 60)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v24 = (char *)operator new(16 * v23);
      }
      else
      {
        v24 = 0;
      }
      v25 = (unint64_t *)&v24[16 * v20];
      *v25 = v17;
      v25[1] = v16;
      v26 = v25;
      if (v14 != v19)
      {
        do
        {
          *((_OWORD *)v26 - 1) = *((_OWORD *)v14 - 1);
          v26 -= 2;
          v14 -= 2;
        }
        while (v14 != v19);
        v14 = *(unint64_t **)(a1 + 24);
      }
      v15 = v25 + 2;
      *(_QWORD *)(a1 + 24) = v26;
      *(_QWORD *)(a1 + 32) = v25 + 2;
      *(_QWORD *)(a1 + 40) = &v24[16 * v23];
      if (v14)
        operator delete(v14);
    }
    *(_QWORD *)(a1 + 32) = v15;
    ++v13;
    v14 = v15;
  }
  while (v13 <= v4);
  return a1;
}

void sub_1B65AF134(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;
  void *v4;

  v3 = *(void **)(v1 + 24);
  if (v3)
  {
    *(_QWORD *)(v1 + 32) = v3;
    operator delete(v3);
    v4 = *(void **)v1;
    if (!*(_QWORD *)v1)
LABEL_3:
      _Unwind_Resume(exception_object);
  }
  else
  {
    v4 = *(void **)v1;
    if (!*(_QWORD *)v1)
      goto LABEL_3;
  }
  *(_QWORD *)(v1 + 8) = v4;
  operator delete(v4);
  _Unwind_Resume(exception_object);
}

HOA::RotationMatrix *HOA::RotationMatrix::RotationMatrix(HOA::RotationMatrix *this, int a2, char a3)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  BOOL v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = (unsigned __int16)a2;
  v6 = 0x40000000;
  do
  {
    v7 = v6;
    v6 >>= 2;
  }
  while (v7 > (unsigned __int16)a2);
  if (!v7)
    goto LABEL_9;
  v8 = 0;
  do
  {
    v9 = v8 + v7;
    v10 = 2 * v7;
    if (v5 < v8 + v7)
    {
      v9 = 0;
      v10 = 0;
    }
    v5 -= v9;
    v11 = v10 + v8;
    v8 = (v10 + v8) >> 1;
    v12 = v7 > 3;
    v7 >>= 2;
  }
  while (v12);
  if (v11 > 1)
    v13 = v8 - 1;
  else
LABEL_9:
    v13 = 0;
  v14 = a2 & 0xFFFF0000;
  if ((a2 & 0xFFFF0000) == 0x6B0000)
  {
    v15 = 2;
  }
  else if (v14 == 12517376)
  {
    v15 = 0;
  }
  else if (v14 == 12451840)
  {
    v15 = 1;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v17 = 136315906;
      v18 = "HOA.cpp";
      v19 = 1024;
      v20 = 632;
      v21 = 2080;
      v22 = "normalizationFromTag";
      v23 = 1024;
      v24 = 632;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; This is not SN3D/N3D/FuMa: unsupported",
        (uint8_t *)&v17,
        0x22u);
    }
    v15 = -1;
  }
  HOA::RotationMatrix::RotationMatrix((uint64_t)this, v13, v15, a3);
  return this;
}

void HOA::RotationMatrix::setIdentity(float **this)
{
  float **v2;
  float **v3;
  vDSP_Stride v4;
  float *v5;
  float __A;

  vDSP_vclr(*this, 1, this[1] - *this);
  v2 = (float **)this[3];
  v3 = (float **)this[4];
  if (v2 != v3)
  {
    v4 = 2;
    do
    {
      __A = 1.0;
      v5 = *v2;
      v2 += 2;
      vDSP_vfill(&__A, v5, v4, (v4 - 1));
      v4 += 2;
    }
    while (v2 != v3);
  }
}

void HOA::RotationMatrix::setRotationMatrixYPR(float **this, float a2, float a3, float a4)
{
  float **v4;
  float **v5;
  float **v6;
  vDSP_Stride v7;
  float *v8;
  float *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  float v14;
  float v15;
  __float2 v16;
  __float2 v17;
  __float2 v18;
  __float2 v19;
  float *v20;
  float v21;
  uint64_t v22;
  int v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  char *v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  float v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  float v69;
  float v70;
  int v71;
  uint64_t v72;
  int v73;
  float v74;
  float v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  float v79;
  int v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  uint64_t v86;
  int v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  uint64_t v97;
  char *v98;
  uint64_t v99;
  unint64_t v100;
  float **v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  size_t v107;
  float *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  size_t v131;
  float __A;
  uint64_t v133;

  v4 = this;
  v133 = *MEMORY[0x1E0C80C00];
  if (a2 == 0.0 && a3 == 0.0 && a4 == 0.0)
  {
    vDSP_vclr(*this, 1, this[1] - *this);
    v5 = (float **)v4[3];
    v6 = (float **)v4[4];
    if (v5 != v6)
    {
      v7 = 2;
      do
      {
        __A = 1.0;
        v8 = *v5;
        v5 += 2;
        vDSP_vfill(&__A, v8, v7, (v7 - 1));
        v7 += 2;
      }
      while (v5 != v6);
    }
    return;
  }
  v9 = this[3];
  v10 = (char *)this[4] - (char *)v9;
  v11 = v10 >> 4;
  v12 = (v10 >> 4) - 1;
  **(_DWORD **)v9 = 1065353216;
  if (v10 >= 0x11 && (v10 >> 4) != 1)
  {
    v14 = a4 * 0.017453;
    v15 = a3 * 0.017453;
    v16 = __sincosf_stret(a2 * -0.017453);
    v17 = __sincosf_stret(v15);
    v19 = __sincosf_stret(v14);
    v20 = (float *)*((_QWORD *)v9 + 2);
    *v20 = -(float)((float)((float)(v17.__sinval * v16.__sinval) * v19.__sinval) - (float)(v19.__cosval * v16.__cosval));
    v20[1] = -(float)((float)((float)(v17.__sinval * v16.__sinval) * v19.__cosval) + (float)(v19.__sinval * v16.__cosval));
    v20[2] = v17.__cosval * v16.__sinval;
    v20[3] = v19.__sinval * v17.__cosval;
    v20[4] = v19.__cosval * v17.__cosval;
    v20[5] = v17.__sinval;
    v21 = -(float)(v16.__cosval * v17.__sinval);
    v20[6] = -(float)((float)(v19.__cosval * v16.__sinval) - (float)(v21 * v19.__sinval));
    v20[7] = (float)(v19.__sinval * v16.__sinval) + (float)(v21 * v19.__cosval);
    v20[8] = v17.__cosval * v16.__cosval;
    if ((_DWORD)v12 == 1)
      goto LABEL_92;
    v108 = v9;
    v101 = v4;
    v22 = (2 * v12);
    v23 = (2 * v12) | 1;
    ((void (*)(_QWORD))MEMORY[0x1E0C80A78])(v18);
    v24 = (char *)&v101 - ((4 * (v23 * v23) + 15) & 0x3FFFFFFF0);
    MEMORY[0x1E0C80A78](v25);
    v27 = (char *)&v101 - v26;
    bzero((char *)&v101 - v26, 4 * (v23 * v23));
    v28 = 0;
    v29 = 0;
    v120 = v23;
    v30 = *((_DWORD *)v20 + 2);
    *(_QWORD *)v27 = *(_QWORD *)v20;
    *((_DWORD *)v27 + 2) = v30;
    v31 = &v27[4 * v23];
    v32 = *(_QWORD *)(v20 + 3);
    v33 = &v27[8 * v23];
    v106 = (8 * ((unint64_t)(int)v22 >> 1)) | 4;
    v105 = (v11 - 2);
    *((float *)v31 + 2) = v20[5];
    v104 = (v12 << 33) ^ 0xFFFFFFFE00000000;
    v115 = ((unint64_t)v12 << 33) | 0x100000000;
    *(_QWORD *)v31 = v32;
    v34 = *((_QWORD *)v20 + 3);
    v119 = v22 | 1;
    v35 = (8 * v11 - 8) | 3;
    *((float *)v33 + 2) = v20[8];
    LODWORD(v32) = 4 * v11;
    v36 = (4 * v11 - 4);
    *(_QWORD *)v33 = v34;
    v103 = v36 | 2;
    v37 = (-2 * v11);
    v38 = 4 * (v23 * v23);
    v114 = v37 | 1;
    v102 = -(int)v32 | 1;
    v39 = -2;
    v122 = 3;
    v124 = -1;
    v113 = 5;
    v40 = 2;
    v41 = 20;
    v125 = v36 | 1;
    v42 = v36 | 1;
    v107 = v38;
    while (1)
    {
      v121 = v41;
      v112 = v29;
      v109 = 8 * v29;
      bzero(v24, v38);
      v43 = 0;
      v118 = v40 - 1;
      v44 = 2 * ((int)v40 - 1);
      v129 = v40 * v120;
      v128 = v40 * v120 + v44;
      v117 = v40 - 2;
      v116 = v44;
      v126 = (v40 - 2) * v120 + v44;
      v127 = (v40 - 2) * v120;
      v45 = v28 + 4;
      v131 = -1;
      v110 = v42;
      v130 = v42;
      v46 = v102;
      v111 = v35;
      v47 = v35;
      v48 = v104;
      v49 = v39;
      do
      {
        v50 = 0;
        if ((int)v49 >= 0)
          v51 = v49;
        else
          v51 = -(int)v49;
        v52 = v51 + v40;
        v53 = v51 + v40 - 1;
        v54 = v40 - v51;
        v55 = v49 + v40;
        v56 = (float)((v53 << (v49 == 0)) * v52);
        if (v49)
          v57 = 0.5;
        else
          v57 = -0.5;
        v58 = (float)((v54 - 1) * v54);
        if (v49)
          v59 = 1.0;
        else
          v59 = 0.0;
        v60 = v59 * -0.5;
        v61 = (v49 + v118) * v120;
        v62 = v61 + v116;
        v63 = v55 * (int)v120 + (int)v116;
        v64 = v55 * (int)v120;
        if (v49 == -1)
          v65 = 0.0;
        else
          v65 = 1.0;
        v66 = (v118 + ~(_DWORD)v49) * v120;
        v67 = v66 + (int)v116;
        v68 = v66;
        if (v49 == -1)
          v69 = 1.0;
        else
          v69 = 0.0;
        v70 = sqrtf(v69 + 1.0);
        v71 = (v117 + v49) * v120;
        v72 = v71 + (int)v116;
        v73 = v40 - v49;
        if (v49 == 1)
          v74 = 1.0;
        else
          v74 = 0.0;
        v75 = v74 + 1.0;
        v76 = v73 * v120;
        v77 = v73 * (int)v120 + (int)v116;
        v78 = v76;
        if (v49 == 1)
          v79 = 0.0;
        else
          v79 = 1.0;
        v80 = 4;
        v123 = v48;
        v81 = sqrtf(v75);
        do
        {
          LODWORD(v86) = v39 + v50;
          if ((int)v39 + (int)v50 >= 0)
            v86 = v86;
          else
            v86 = -(int)v86;
          if (v40 == v86)
            v87 = (2 * v40 - 1) * 2 * v40;
          else
            v87 = v50 * (v28 + v80);
          v88 = 1.0 / (float)v87;
          v89 = sqrtf((float)((v49 + v40) * (v40 - v49)) * v88);
          if (v89 != 0.0)
          {
            if (v50)
            {
              if (v45 == v50)
                v90 = -(float)((float)(*(float *)&v27[4 * v61] * v20[3]) - (float)(*(float *)&v27[4 * v62] * v20[5]));
              else
                v90 = *(float *)&v27[v48 >> 30] * v20[4];
            }
            else
            {
              v90 = (float)(*(float *)&v27[4 * v61] * v20[5]) + (float)(*(float *)&v27[4 * v62] * v20[3]);
            }
            v89 = v90 * v89;
          }
          v91 = v57 * sqrtf(v56 * v88);
          v85 = v60 * sqrtf(v58 * v88);
          if (v91 == 0.0)
          {
            if (v85 != 0.0)
            {
              if (v49 >= 1)
              {
LABEL_74:
                if (v50)
                {
                  if (v45 == v50)
                    v84 = (float)-(float)((float)(*(float *)&v27[4 * v64] * v20[6])
                                        - (float)(*(float *)&v27[4 * v63] * v20[8]))
                        - (float)((float)(*(float *)&v27[4 * v68] * *v20) - (float)(*(float *)&v27[4 * v67] * v20[2]));
                  else
                    v84 = (float)(*(float *)&v27[4 * (int)v130 + 4 * (int)v50] * v20[1])
                        + (float)(*(float *)&v27[4 * (int)v131 + 4 * (int)v50] * v20[7]);
                }
                else
                {
                  v84 = (float)((float)(*(float *)&v27[4 * v68] * v20[2]) + (float)(*(float *)&v27[4 * v67] * *v20))
                      + (float)((float)(*(float *)&v27[4 * v64] * v20[8]) + (float)(*(float *)&v27[4 * v63] * v20[6]));
                }
              }
              else
              {
LABEL_84:
                if (v50)
                {
                  if (v45 == v50)
                  {
                    v82 = -(float)((float)(*(float *)&v27[4 * v71] * v20[6]) - (float)(*(float *)&v27[4 * v72] * v20[8]));
                    v83 = -(float)((float)(*(float *)&v27[4 * v78] * *v20) - (float)(*(float *)&v27[4 * v77] * v20[2]));
                  }
                  else
                  {
                    v82 = *(float *)&v27[4 * v46 + 4 * (int)v50] * v20[7];
                    v83 = *(float *)&v27[4 * v47 + 4 * (int)v50] * v20[1];
                  }
                }
                else
                {
                  v82 = (float)(*(float *)&v27[4 * v71] * v20[8]) + (float)(*(float *)&v27[4 * v72] * v20[6]);
                  v83 = (float)(*(float *)&v27[4 * v78] * v20[2]) + (float)(*(float *)&v27[4 * v77] * *v20);
                }
                v84 = v82 - v83;
              }
              v85 = v84 * v85;
            }
          }
          else
          {
            if (!v49)
            {
              if (v50)
              {
                if (v45 == v50)
                  v94 = (float)-(float)((float)(*(float *)&v27[4 * v129] * v20[6])
                                      - (float)(*(float *)&v27[4 * v128] * v20[8]))
                      - (float)((float)(*(float *)&v27[4 * v127] * *v20) - (float)(*(float *)&v27[4 * v126] * v20[2]));
                else
                  v94 = (float)(*(float *)&v27[4 * (int)v124 + 4 * (int)v50] * v20[1])
                      + (float)(*(float *)&v27[4 * (int)v125 + 4 * (int)v50] * v20[7]);
              }
              else
              {
                v94 = (float)((float)(*(float *)&v27[4 * v127] * v20[2]) + (float)(*(float *)&v27[4 * v126] * *v20))
                    + (float)((float)(*(float *)&v27[4 * v129] * v20[8]) + (float)(*(float *)&v27[4 * v128] * v20[6]));
              }
              goto LABEL_83;
            }
            if (v49 < 1)
            {
              if (v50)
              {
                if (v45 == v50)
                {
                  v95 = -(float)((float)(*(float *)&v27[4 * v64] * v20[6]) - (float)(*(float *)&v27[4 * v63] * v20[8]));
                  v96 = -(float)((float)(*(float *)&v27[4 * v68] * *v20) - (float)(*(float *)&v27[4 * v67] * v20[2]));
                }
                else
                {
                  v95 = *(float *)&v27[4 * (int)v131 + 4 * (int)v50] * v20[7];
                  v96 = *(float *)&v27[4 * (int)v130 + 4 * (int)v50] * v20[1];
                }
              }
              else
              {
                v95 = (float)(*(float *)&v27[4 * v64] * v20[8]) + (float)(*(float *)&v27[4 * v63] * v20[6]);
                v96 = (float)(*(float *)&v27[4 * v68] * v20[2]) + (float)(*(float *)&v27[4 * v67] * *v20);
              }
              v94 = (float)(v95 * v65) + (float)(v96 * v70);
LABEL_83:
              v91 = v94 * v91;
              if (v85 != 0.0)
                goto LABEL_84;
              goto LABEL_41;
            }
            if (v50)
            {
              if (v45 == v50)
              {
                v92 = -(float)((float)(*(float *)&v27[4 * v71] * v20[6]) - (float)(*(float *)&v27[4 * v72] * v20[8]));
                v93 = -(float)((float)(*(float *)&v27[4 * v78] * *v20) - (float)(*(float *)&v27[4 * v77] * v20[2]));
              }
              else
              {
                v92 = *(float *)&v27[4 * v46 + 4 * (int)v50] * v20[7];
                v93 = *(float *)&v27[4 * v47 + 4 * (int)v50] * v20[1];
              }
            }
            else
            {
              v92 = (float)(*(float *)&v27[4 * v71] * v20[8]) + (float)(*(float *)&v27[4 * v72] * v20[6]);
              v93 = (float)(*(float *)&v27[4 * v78] * v20[2]) + (float)(*(float *)&v27[4 * v77] * *v20);
            }
            v91 = (float)-(float)((float)(v93 * v79) - (float)(v92 * v81)) * v91;
            if (v85 != 0.0)
              goto LABEL_74;
          }
LABEL_41:
          *(float *)&v24[4 * v43 + 4 * (int)v50++] = v91 + (float)(v89 + v85);
          v48 += 0x100000000;
          --v80;
        }
        while ((_DWORD)v28 + 5 != (_DWORD)v50);
        ++v49;
        v48 = v123 + v115;
        v43 += v119;
        v47 += v114;
        v46 += v119;
        v130 += v114;
        v131 += v119;
      }
      while (v122 != (_DWORD)v49);
      v97 = 0;
      v131 = v109 + 20;
      v130 = *(_QWORD *)&v108[4 * v40];
      v98 = v24;
      v99 = v113;
      v100 = v106;
      do
      {
        memcpy((void *)(v130 + (v97 & 0x3FFFFFFFCLL)), v98, v131);
        v98 += v100;
        v97 += v121;
        --v99;
      }
      while (v99);
      v38 = v107;
      memcpy(v27, v24, v107);
      ++v40;
      --v39;
      ++v122;
      v29 = v112 + 1;
      v113 += 2;
      v28 += 2;
      v35 = v111 + v103;
      v42 = v110 + v103;
      v124 += v119;
      v125 += v119;
      v41 = v121 + 8;
      if (v112 + 1 == v105)
      {
        v4 = v101;
LABEL_92:
        if (*((_DWORD *)v4 + 12) == 2)
          HOA::RotationMatrix::toFuMa((HOA::RotationMatrix *)v4);
        if (*((_BYTE *)v4 + 52))
          HOA::RotationMatrix::transposePrivate((HOA::RotationMatrix *)v4);
        return;
      }
    }
  }
}

void HOA::RotationMatrix::toFuMa(HOA::RotationMatrix *this)
{
  uint64_t v1;
  unint64_t v2;
  unsigned int v3;
  unsigned int v10;
  int v11;
  float *v12;
  __int128 __C;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  int v25;
  __int128 __A;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _OWORD v30[2];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  int v37;
  __int128 __B;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  int v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v1 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4) - v1;
  v3 = (v2 >> 4) - 1;
  if (v2 >= 0x11 && (v2 >> 4) != 1)
  {
    __B = 0u;
    v39 = 0u;
    LODWORD(v40) = 0;
    DWORD1(__B) = 1065353216;
    __asm { FMOV            V8.2S, #1.0 }
    *(_QWORD *)((char *)&v39 + 4) = _D8;
    *(_QWORD *)&__A = 0;
    v27 = 0u;
    *((_QWORD *)&__A + 1) = _D8;
    HIDWORD(v27) = 1065353216;
    LODWORD(v28) = 0;
    LODWORD(v15) = 0;
    __C = 0u;
    v14 = 0u;
    vDSP_mmul(*(const float **)(v1 + 16), 1, (const float *)&__B, 1, (float *)&__C, 1, 3uLL, 3uLL, 3uLL);
    vDSP_mmul((const float *)&__A, 1, (const float *)&__C, 1, *(float **)(*((_QWORD *)this + 3) + 16), 1, 3uLL, 3uLL, 3uLL);
    if (v3 != 1)
    {
      v42 = 0u;
      v43 = 0u;
      LODWORD(v44) = 0;
      v40 = 0u;
      v41 = 0u;
      __B = 0u;
      v39 = 0u;
      LODWORD(v39) = 1065353216;
      HIDWORD(v39) = 1065353216;
      DWORD2(v40) = 1065353216;
      LODWORD(v42) = 1065353216;
      HIDWORD(v43) = 1065353216;
      memset(v30, 0, sizeof(v30));
      LODWORD(v31) = 0;
      v28 = 0u;
      v29 = 0u;
      __A = 0u;
      v27 = 0u;
      DWORD2(__A) = 1065353216;
      LODWORD(v28) = 1065353216;
      HIDWORD(v28) = 1065353216;
      *(_QWORD *)((char *)v30 + 12) = _D8;
      LODWORD(v19) = 0;
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      __C = 0u;
      v14 = 0u;
      vDSP_mmul(*(const float **)(*((_QWORD *)this + 3) + 32), 1, (const float *)&__B, 1, (float *)&__C, 1, 5uLL, 5uLL, 5uLL);
      vDSP_mmul((const float *)&__A, 1, (const float *)&__C, 1, *(float **)(*((_QWORD *)this + 3) + 32), 1, 5uLL, 5uLL, 5uLL);
      if (v3 != 2)
      {
        v50 = 0;
        v46 = xmmword_1B669FD3C;
        v47 = unk_1B669FD4C;
        v48 = xmmword_1B669FD5C;
        v49 = unk_1B669FD6C;
        v42 = xmmword_1B669FCFC;
        v43 = unk_1B669FD0C;
        v44 = xmmword_1B669FD1C;
        v45 = unk_1B669FD2C;
        __B = xmmword_1B669FCBC;
        v39 = *(_OWORD *)algn_1B669FCCC;
        v40 = xmmword_1B669FCDC;
        v41 = unk_1B669FCEC;
        v33 = xmmword_1B669FE00;
        v34 = unk_1B669FE10;
        v35 = xmmword_1B669FE20;
        v36 = unk_1B669FE30;
        v30[0] = xmmword_1B669FDC0;
        v30[1] = unk_1B669FDD0;
        v31 = xmmword_1B669FDE0;
        v32 = unk_1B669FDF0;
        __A = xmmword_1B669FD80;
        v27 = *(_OWORD *)algn_1B669FD90;
        v28 = xmmword_1B669FDA0;
        v29 = unk_1B669FDB0;
        v37 = 0;
        v25 = 0;
        v23 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        v19 = 0u;
        v20 = 0u;
        v17 = 0u;
        v18 = 0u;
        v15 = 0u;
        v16 = 0u;
        __C = 0u;
        v14 = 0u;
        vDSP_mmul(*(const float **)(*((_QWORD *)this + 3) + 48), 1, (const float *)&__B, 1, (float *)&__C, 1, 7uLL, 7uLL, 7uLL);
        vDSP_mmul((const float *)&__A, 1, (const float *)&__C, 1, *(float **)(*((_QWORD *)this + 3) + 48), 1, 7uLL, 7uLL, 7uLL);
        if (v3 >= 4)
        {
          v10 = 4;
          v11 = 9;
          do
          {
            v12 = *(float **)(*((_QWORD *)this + 3) + 16 * v10);
            if (v12)
              vDSP_vclr(v12, 1, (v11 * v11));
            ++v10;
            v11 += 2;
          }
          while (v10 <= v3);
        }
      }
    }
  }
}

void HOA::RotationMatrix::transposePrivate(HOA::RotationMatrix *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  float *v7;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  unsigned int v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v3 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4);
  MEMORY[0x1E0C80A78](this);
  v7 = (float *)((char *)v15 - v6);
  if (v5 >= 0x11 && (v5 & 0xFFFFFFFF0) != 16)
  {
    bzero((char *)v15 - v6, 4 * v4);
    v9 = 1;
    v10 = 3;
    do
    {
      v11 = v3 + 16 * v9;
      v12 = *(float **)v11;
      if (*(_QWORD *)v11)
      {
        v13 = *(_QWORD *)(v11 + 8);
        vDSP_mtrans(*(const float **)v11, 1, v7, 1, v10, v10);
        memcpy(v12, v7, 4 * v13);
        v3 = *((_QWORD *)this + 3);
        v2 = *((_QWORD *)this + 4);
      }
      ++v9;
      v10 += 2;
      if ((unint64_t)(v2 - v3) <= 0x10)
        v14 = 0;
      else
        v14 = ((unint64_t)(v2 - v3) >> 4) - 1;
    }
    while (v9 <= v14);
  }
}

uint64_t HOA::RotationMatrix::toRegularMatrix(uint64_t result, char *a2, uint64_t a3)
{
  unint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  int v38;
  unint64_t v39;
  unsigned int v40;
  unsigned int v41;
  BOOL v42;
  BOOL v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  __int128 *v47;
  __int128 v48;
  __int128 v49;
  char *v50;

  v3 = *(_QWORD *)(result + 32) - *(_QWORD *)(result + 24);
  if (v3 <= 0x10)
    v4 = 1;
  else
    v4 = v3 >> 4;
  v5 = v4 * v4;
  if (a3 == v5 * v5)
  {
    v7 = result;
    bzero(a2, 4 * a3);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = *(_QWORD *)(v7 + 32) - v8;
    if (v9 <= 0x10)
      v10 = 0;
    else
      v10 = (v9 >> 4) - 1;
    if (v4 <= 1)
      v11 = 1;
    else
      v11 = v4;
    if (*(_BYTE *)(v7 + 52))
    {
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = v5 + 1;
      v16 = 1;
      do
      {
        if (v16 <= 1)
          v17 = 1;
        else
          v17 = v16;
        if (v10 >= v14)
          result = *(_QWORD *)(v8 + 16 * v14);
        else
          result = 0;
        v18 = 0;
        v19 = v12;
        do
        {
          v20 = v18;
          v21 = v19;
          v22 = v13 + 1;
          do
          {
            *(_DWORD *)&a2[4 * v21++] = *(_DWORD *)(result + 4 * v20);
            v20 += v16;
            --v22;
          }
          while (v22);
          ++v18;
          v19 += v5;
        }
        while (v18 != v17);
        ++v14;
        v16 += 2;
        v13 += 2;
        v12 += v15;
        v15 += 2 * v5 + 2;
      }
      while (v14 != v11);
    }
    else
    {
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = (v5 + 1);
      v27 = 1;
      do
      {
        if (v27 <= 1)
          result = 1;
        else
          result = v27;
        if (v10 >= v25)
          v28 = *(_QWORD *)(v8 + 16 * v25);
        else
          v28 = 0;
        if ((v25 & 0x7FFFFFFE) > 5)
        {
          v35 = 0;
          v36 = 0;
          v37 = 2 * v25;
          v38 = v23;
          do
          {
            v39 = 0;
            v40 = v23 + v5 * v36;
            v41 = v27 * v36;
            v42 = __CFADD__(v40, v37);
            v43 = __CFADD__(v41, v37);
            if (!v42 && !v43 && (unint64_t)&a2[4 * v40 - v28 + -4 * v41] >= 0x20)
            {
              v44 = v35;
              v45 = v38;
              v46 = v24 & 0xFFFFFFF8;
              do
              {
                v47 = (__int128 *)(v28 + 4 * v44);
                v48 = *v47;
                v49 = v47[1];
                v50 = &a2[4 * v45];
                *(_OWORD *)v50 = v48;
                *((_OWORD *)v50 + 1) = v49;
                v45 += 8;
                v44 += 8;
                v46 -= 8;
              }
              while (v46);
              v39 = (2 * v25) & 0xFFFFFFF8;
            }
            do
            {
              *(_DWORD *)&a2[4 * (v38 + v39)] = *(_DWORD *)(v28 + 4 * (v35 + v39));
              ++v39;
            }
            while (v39 < ((2 * (_DWORD)v25) | 1u));
            ++v36;
            v38 += v5;
            v35 += v24 + 1;
          }
          while (v36 != result);
        }
        else
        {
          v29 = 0;
          v30 = 0;
          v31 = v23;
          do
          {
            v32 = v29;
            v33 = v31;
            v34 = v24 + 1;
            do
            {
              *(_DWORD *)&a2[4 * v33++] = *(_DWORD *)(v28 + 4 * v32++);
              --v34;
            }
            while (v34);
            ++v30;
            v31 += v5;
            v29 += v27;
          }
          while (v30 != (_DWORD)result);
        }
        ++v25;
        v27 += 2;
        v23 += v26;
        v24 += 2;
        v26 += (2 * v5 + 2);
      }
      while (v25 != v11);
    }
  }
  return result;
}

void HOA::RotationMatrix::applyLeft(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, vDSP_Length __N)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v11;
  char *v14;
  size_t v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  vDSP_Length v19;
  vDSP_Length v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  const float *v24;
  uint64_t v25;
  BOOL v26;
  _QWORD v27[2];

  v27[0] = a4;
  v27[1] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v6 - v7) <= 0x10)
    v8 = 1;
  else
    v8 = (unint64_t)(v6 - v7) >> 4;
  v9 = (v8 * __N * v8);
  if (a3 == v9 && a5 == v9)
  {
    v11 = __N;
    v14 = 0;
    if (*(_BYTE *)(a1 + 52) && v6 != v7)
    {
      MEMORY[0x1E0C80A78](a1);
      v14 = (char *)v27 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v14, v15);
    }
    v16 = 0;
    v17 = 0;
    v18 = 2 * v11;
    v19 = 1;
    v20 = v11;
    do
    {
      v23 = v7 + 16 * v16;
      v24 = *(const float **)v23;
      v25 = *(_QWORD *)(v23 + 8);
      if (v24)
        v26 = v25 == v19 * v19;
      else
        v26 = 0;
      if (!v26)
        break;
      if (*(_BYTE *)(a1 + 52))
      {
        vDSP_mtrans(v24, 1, (float *)v14, 1, v19, v19);
        v24 = (const float *)v14;
      }
      vDSP_mmul(v24, 1, (const float *)(a2 + 4 * v17), 1, (float *)(v27[0] + 4 * v17), 1, v19, v20, v19);
      v17 += v11;
      v19 += 2;
      ++v16;
      v7 = *(_QWORD *)(a1 + 24);
      v21 = *(_QWORD *)(a1 + 32) - v7;
      v22 = v21 <= 0x10 ? 0 : (v21 >> 4) - 1;
      v11 += v18;
    }
    while (v16 <= v22);
  }
}

void HOA::RotationMatrix::applyLeftAccumulating(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, vDSP_Length __N)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v11;
  uint64_t v14;
  BOOL v15;
  size_t v16;
  int v17;
  unsigned int v18;
  vDSP_Length v19;
  const float **v20;
  const float *v21;
  const float *v22;
  BOOL v23;
  const float *v24;
  uint64_t v25;
  unsigned int v26;
  vDSP_Length v27;
  vDSP_Length v28;
  unsigned int v29;
  unint64_t v30;
  unsigned int v31;
  char *v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v6 - v7) <= 0x10)
    v8 = 1;
  else
    v8 = (unint64_t)(v6 - v7) >> 4;
  v9 = (v8 * v8);
  if (a3 == v9 && a5 == v9)
  {
    v11 = __N;
    v14 = a1;
    if (*(_BYTE *)(a1 + 52))
      v15 = v6 == v7;
    else
      v15 = 1;
    if (v15)
    {
      v32 = 0;
    }
    else
    {
      MEMORY[0x1E0C80A78](a1);
      v32 = (char *)&v32 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v32, v16);
    }
    v17 = 0;
    v18 = 0;
    v19 = 1;
    v33 = v14;
    do
    {
      v20 = (const float **)(v7 + 16 * v18);
      v22 = *v20;
      v21 = v20[1];
      if (v22)
        v23 = v21 == (const float *)(v19 * v19);
      else
        v23 = 0;
      if (!v23)
        break;
      v34 = v18;
      if (*(_BYTE *)(v14 + 52))
      {
        v24 = v22;
        v22 = (const float *)v32;
        vDSP_mtrans(v24, 1, (float *)v32, 1, v19, v19);
      }
      v25 = 0;
      v26 = 0;
      do
      {
        v27 = 0;
        v28 = v25 * v19;
        v29 = 1;
        do
        {
          vDSP_vsma(*(const float **)(a2 + 8 * (v17 + v29 - 1)), 1, &v22[v27 + v28], *(const float **)(a4 + 8 * (v26 + v17)), 1, *(float **)(a4 + 8 * (v26 + v17)), 1, v11);
          v27 = v29++;
        }
        while (v19 > v27);
        v25 = ++v26;
      }
      while (v19 > v26);
      v17 += v19;
      v19 += 2;
      v18 = v34 + 1;
      v14 = v33;
      v7 = *(_QWORD *)(v33 + 24);
      v30 = *(_QWORD *)(v33 + 32) - v7;
      v31 = v30 <= 0x10 ? 0 : (v30 >> 4) - 1;
    }
    while (v18 <= v31);
  }
}

float HOA::legendre(HOA *this, int a2, float result)
{
  int v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  int v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  int v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;

  if (a2 >= (int)this)
    v3 = (int)this;
  else
    v3 = a2;
  v4 = 1.0;
  switch((int)this)
  {
    case 0:
      goto LABEL_30;
    case 1:
      if (v3)
        return -sqrtf(-(float)((float)(result * result) + -1.0));
      return result;
    case 2:
      if (v3 == 2)
        return 3.0 - (float)((float)(result * result) * 3.0);
      if (v3 == 1)
      {
        v11 = result * -3.0;
        v12 = -(float)((float)(result * result) + -1.0);
        goto LABEL_40;
      }
      v4 = 0.0;
      if (v3)
LABEL_30:
        result = v4;
      else
        result = (float)((float)(result * result) * 1.5) + -0.5;
      break;
    case 3:
      if (v3 == 2)
      {
        result = (float)(result * 15.0) - (float)((float)(result * result) * (float)(result * 15.0));
      }
      else if (v3 == 1)
      {
        v13 = result * result;
        v11 = (float)(v13 * -7.5) + 1.5;
LABEL_39:
        v12 = 1.0 - v13;
LABEL_40:
        result = v11 * sqrtf(v12);
      }
      else if (v3)
      {
        v14 = 1.0 - (float)(result * result);
        v15 = sqrtf(v14);
        v16 = -15.0;
LABEL_86:
        result = (float)(v14 * v16) * v15;
      }
      else
      {
        result = (float)((float)(result * -3.0) + (float)((float)(result * (float)(result * result)) * 5.0)) * 0.5;
      }
      break;
    case 4:
      switch(v3)
      {
        case 0:
          result = (float)((float)((float)((float)(result * result) * -30.0)
                                 + (float)((float)((float)(result * result) * (float)(result * result)) * 35.0))
                         * 0.125)
                 + 0.375;
          break;
        case 1:
          v19 = result * 2.5;
          v13 = result * result;
          v11 = v19 * (float)((float)(v13 * -7.0) + 3.0);
          goto LABEL_39;
        case 2:
          result = (float)((float)((float)(result * result) * 52.5) + -7.5)
                 - (float)((float)(result * result) * (float)((float)((float)(result * result) * 52.5) + -7.5));
          break;
        case 3:
          v20 = 1.0 - (float)(result * result);
          v21 = sqrtf(v20);
          v22 = -105.0;
          goto LABEL_104;
        default:
          v17 = (float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result));
          v18 = 105.0;
          goto LABEL_64;
      }
      return result;
    case 5:
      switch(v3)
      {
        case 0:
          v5 = result * 0.125;
          v6 = result * result;
          v7 = (float)((float)(v6 * v6) * 63.0) + 15.0;
          v8 = -70.0;
          goto LABEL_66;
        case 1:
          v25 = result * result;
          v26 = sqrtf(1.0 - v25);
          v27 = -1.875;
          v28 = (float)((float)(v25 * -14.0) + 1.0) + (float)((float)(v25 * v25) * 21.0);
          goto LABEL_100;
        case 2:
          v29 = result * 52.5;
          v30 = result * result;
          v31 = v29 - (float)(v30 * v29);
          v32 = -3.0;
          goto LABEL_102;
        case 3:
          v33 = result * result;
          v34 = 1.0 - v33;
          v35 = sqrtf(1.0 - v33);
          v36 = v33 * -9.0;
          v37 = -52.5;
          goto LABEL_60;
        case 4:
          result = (float)((float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result)))
                 * (float)(result * 945.0);
          break;
        default:
          v23 = 1.0 - (float)(result * result);
          v15 = sqrtf(v23);
          v14 = v23 * v23;
          *(float *)&v24 = -945.0;
          goto LABEL_85;
      }
      return result;
    case 6:
      switch(v3)
      {
        case 0:
          result = (float)((float)((float)((float)((float)((float)(result * result) * (float)(result * result)) * -315.0)
                                         + (float)((float)((float)(result * result)
                                                         * (float)((float)(result * result) * (float)(result * result)))
                                                 * 231.0))
                                 + (float)((float)(result * result) * 105.0))
                         * 0.0625)
                 + -0.3125;
          break;
        case 1:
          v38 = result * -2.625;
          v39 = result * result;
          v40 = (float)((float)(v39 * -30.0) + 5.0) + (float)((float)(v39 * v39) * 33.0);
          v41 = sqrtf(1.0 - v39);
          goto LABEL_92;
        case 2:
          v42 = result * result;
          v43 = 13.125 - (float)(v42 * 13.125);
          v44 = v42 * v42;
          v45 = (float)(v42 * -18.0) + 1.0;
          v46 = 33.0;
          goto LABEL_68;
        case 3:
          result = (float)((float)((float)(1.0 - (float)(result * result)) * result)
                         * (float)((float)((float)(result * result) * -1732.5) + 472.5))
                 * sqrtf(1.0 - (float)(result * result));
          break;
        case 4:
          v47 = result * result;
          v48 = 1.0 - v47;
          v36 = v47 * -11.0;
          v49 = v48 * v48;
          v35 = 472.5;
          goto LABEL_61;
        case 5:
          v50 = 1.0 - (float)(result * result);
          v51 = sqrtf(v50);
          v52 = result * -10395.0;
          v53 = v50 * v50;
          goto LABEL_96;
        default:
          v14 = 1.0 - (float)(result * result);
          v15 = v14 * v14;
          *(float *)&v24 = 10395.0;
          goto LABEL_85;
      }
      return result;
    case 7:
      switch(v3)
      {
        case 0:
          result = ((float)((float)(result * result) * (float)(result * result)) * -693.0
                  + -35.0
                  + (float)((float)((float)(result * result) * 429.0)
                          * (float)((float)(result * result) * (float)(result * result)))
                  + (float)((float)(result * result) * 315.0))
                 * (float)(result * 0.0625);
          break;
        case 1:
          v6 = result * result;
          v5 = sqrtf(1.0 - v6) * -0.4375;
          v7 = (float)((float)((float)(v6 * v6) * -495.0) + -5.0) + (float)((float)(v6 * (float)(v6 * v6)) * 429.0);
          v8 = 135.0;
          goto LABEL_66;
        case 2:
          v58 = result * 7.875;
          v59 = result * result;
          v60 = v58 - (float)(v59 * v58);
          v61 = v59 * v59;
          v62 = (float)(v59 * -110.0) + 15.0;
          v63 = 143.0;
          goto LABEL_98;
        case 3:
          v64 = result * result;
          v65 = 1.0 - v64;
          v51 = sqrtf(1.0 - v64);
          v52 = (float)((float)(v64 * -66.0) + 3.0) + (float)((float)(v64 * v64) * 143.0);
          v66 = -39.375;
          goto LABEL_95;
        case 4:
          result = (float)((float)((float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result)))
                         * (float)(result * 1732.5))
                 * (float)((float)((float)(result * result) * 13.0) + -3.0);
          break;
        case 5:
          v67 = result * result;
          v68 = 1.0 - v67;
          v35 = sqrtf(1.0 - v67);
          v36 = v67 * -13.0;
          v34 = v68 * v68;
          v37 = -5197.5;
LABEL_60:
          v49 = v34 * v37;
LABEL_61:
          result = -(float)((float)(v49 * v35) + (float)(v36 * (float)(v49 * v35)));
          break;
        case 6:
          result = (float)(result * 135140.0)
                 * (float)((float)(1.0 - (float)(result * result))
                         * (float)((float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result))));
          break;
        default:
          v54 = 1.0 - (float)(result * result);
          v55 = sqrtf(v54);
          v56 = v54 * (float)(v54 * v54);
          v57 = -135140.0;
          goto LABEL_75;
      }
      return result;
    case 8:
      switch(v3)
      {
        case 0:
          v9 = result * result;
          result = (float)((float)((float)((float)((float)((float)(v9 * v9) * 6930.0)
                                                 + (float)((float)((float)(v9 * v9) * (float)(v9 * v9)) * 6435.0))
                                         + (float)((float)(v9 * (float)(v9 * v9)) * -12012.0))
                                 + (float)(v9 * -1260.0))
                         * 0.0078125)
                 + 0.27344;
          break;
        case 1:
          v70 = result * -0.5625;
          v6 = result * result;
          v5 = v70 * sqrtf(1.0 - v6);
          v7 = (float)((float)((float)(v6 * v6) * -1001.0) + -35.0) + (float)((float)(v6 * (float)(v6 * v6)) * 715.0);
          v8 = 385.0;
LABEL_66:
          result = v5 * (float)(v7 + (float)(v6 * v8));
          break;
        case 2:
          v71 = result * result;
          v43 = 19.688 - (float)(v71 * 19.688);
          v44 = -(float)((float)(v71 * v71) - (float)(v71 * (float)(v71 * v71)));
          v45 = (float)(v71 * 33.0) + -1.0;
          v46 = 143.0;
LABEL_68:
          result = (float)(v45 + (float)(v44 * v46)) * v43;
          break;
        case 3:
          result = (float)((float)((float)(result * -433.12) * (float)(1.0 - (float)(result * result)))
                         * (float)((float)((float)((float)(result * result) * -26.0) + 3.0)
                                 + (float)((float)((float)(result * result) * (float)(result * result)) * 39.0)))
                 * sqrtf(1.0 - (float)(result * result));
          break;
        case 4:
          v72 = result * result;
          v73 = 1.0 - v72;
          v41 = (float)((float)(v72 * -26.0) + 1.0) + (float)((float)(v72 * v72) * 65.0);
          v38 = v73 * v73;
          *(float *)&v74 = 1299.4;
          goto LABEL_91;
        case 5:
          v75 = 1.0 - (float)(result * result);
          v76 = sqrtf(v75);
          result = -(float)((float)((float)((float)(v75 * v75) * (float)(result * -67568.0)) * v76)
                          + (float)((float)((float)(result * result) * -5.0)
                                  * (float)((float)((float)(v75 * v75) * (float)(result * -67568.0)) * v76)));
          break;
        case 6:
          v30 = result * result;
          v31 = (float)((float)(1.0 - v30) * 67568.0) * (float)((float)(1.0 - v30) * (float)(1.0 - v30));
          v32 = -15.0;
          goto LABEL_102;
        case 7:
          v77 = 1.0 - (float)(result * result);
          v21 = sqrtf(v77);
          v20 = v77 * (float)(v77 * v77);
          v22 = -2027000.0;
          goto LABEL_104;
        default:
          v69 = (float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result));
          v17 = v69 * v69;
          v18 = 2027000.0;
LABEL_64:
          result = v17 * v18;
          break;
      }
      return result;
    case 9:
      switch(v3)
      {
        case 0:
          result = (float)((float)((float)((float)((float)(result * 315.0)
                                                 + (float)((float)(result
                                                                 * (float)((float)(result * result)
                                                                         * (float)(result * result)))
                                                         * 18018.0))
                                         + (float)((float)(result
                                                         * (float)((float)((float)(result * result)
                                                                         * (float)(result * result))
                                                                 * (float)((float)(result * result)
                                                                         * (float)(result * result))))
                                                 * 12155.0))
                                 + (float)((float)(result * (float)(result * result)) * -4620.0))
                         + (float)((float)((float)(result * (float)(result * result))
                                         * (float)((float)(result * result) * (float)(result * result)))
                                 * -25740.0))
                 * 0.0078125;
          break;
        case 1:
          v79 = result * result;
          result = (float)(sqrtf(1.0 - v79) * -0.35156)
                 * (float)((float)((float)((float)((float)((float)(v79 * v79) * 2002.0) + 7.0)
                                         + (float)((float)((float)(v79 * v79) * (float)(v79 * v79)) * 2431.0))
                                 + (float)(v79 * -308.0))
                         + (float)((float)(v79 * (float)(v79 * v79)) * -4004.0));
          break;
        case 2:
          result = (float)((float)((float)((float)(result * -7.0)
                                         + (float)((float)(result * (float)(result * result)) * 91.0))
                                 + (float)((float)((float)(result * (float)(result * result))
                                                 * (float)((float)(result * result) * (float)(result * result)))
                                         * 221.0))
                         + (float)((float)(result * (float)((float)(result * result) * (float)(result * result)))
                                 * -273.0))
                 * (float)(30.938 - (float)((float)(result * result) * 30.938));
          break;
        case 3:
          v80 = result * result;
          v20 = sqrtf(1.0 - v80);
          v21 = (float)((float)((float)((float)(v80 * v80) * -195.0) + -1.0)
                      + (float)((float)(v80 * (float)(v80 * v80)) * 221.0))
              + (float)(v80 * 39.0);
          v81 = (float)(v80 * 216.56) + -216.56;
          goto LABEL_105;
        case 4:
          v82 = (float)(result * result) + -1.0;
          v41 = (float)(result + (float)((float)(result * (float)(result * result)) * -10.0))
              + (float)((float)(result * (float)((float)(result * result) * (float)(result * result))) * 17.0);
          v38 = v82 * v82;
          *(float *)&v74 = 16892.0;
          goto LABEL_91;
        case 5:
          v83 = result * result;
          v51 = sqrtf(1.0 - v83);
          v84 = v83 + -1.0;
          v85 = v83 * v83;
          v86 = (float)(v83 * -30.0) + 1.0;
          v87 = 85.0;
          goto LABEL_94;
        case 6:
          result = (float)((float)((float)((float)(result * result) + -1.0) * -337840.0)
                         * (float)((float)((float)(result * result) + -1.0) * (float)((float)(result * result) + -1.0)))
                 * (float)((float)(result * -3.0) + (float)((float)(result * (float)(result * result)) * 17.0));
          break;
        case 7:
          v30 = result * result;
          v31 = sqrtf(1.0 - v30)
              * (float)(1013500.0 * (float)((float)(v30 + -1.0) * (float)((float)(v30 + -1.0) * (float)(v30 + -1.0))));
          v32 = -17.0;
          goto LABEL_102;
        case 8:
          v88 = result * 34459000.0;
          v89 = (float)((float)(result * result) + -1.0) * (float)((float)(result * result) + -1.0);
          result = v88 * (float)(v89 * v89);
          break;
        default:
          v78 = 1.0 - (float)(result * result);
          v55 = sqrtf(v78);
          v56 = (float)(v78 * v78) * (float)(v78 * v78);
          v57 = -34459000.0;
LABEL_75:
          result = v55 * (float)(v57 * v56);
          break;
      }
      return result;
    case 10:
      switch(v3)
      {
        case 0:
          v10 = result * result;
          return (float)((float)((float)((float)((float)((float)((float)(v10 * 90090.0) * (float)(v10 * v10))
                                                       + (float)((float)(v10
                                                                       * (float)((float)(v10 * v10) * (float)(v10 * v10)))
                                                               * 46189.0))
                                               + (float)((float)(v10 * v10) * -30030.0))
                                       + (float)((float)((float)(v10 * v10) * (float)(v10 * v10)) * -109400.0))
                               + (float)(v10 * 3465.0))
                       * 0.0039062)
               + -0.24609;
        case 1:
          return (float)(sqrtf(1.0 - (float)(result * result)) * -0.42969)
               * (float)((float)((float)((float)((float)(result * 63.0)
                                               + (float)((float)(result
                                                               * (float)((float)(result * result)
                                                                       * (float)(result * result)))
                                                       * 4914.0))
                                       + (float)((float)(result
                                                       * (float)((float)((float)(result * result)
                                                                       * (float)(result * result))
                                                               * (float)((float)(result * result)
                                                                       * (float)(result * result))))
                                               * 4199.0))
                               + (float)((float)(result * (float)(result * result)) * -1092.0))
                       + (float)((float)((float)(result * (float)(result * result))
                                       * (float)((float)(result * result) * (float)(result * result)))
                               * -7956.0));
        case 2:
          v90 = result * result;
          return (float)((float)((float)((float)((float)((float)(v90 * v90) * 2730.0) + 7.0)
                                       + (float)((float)((float)(v90 * v90) * (float)(v90 * v90)) * 4199.0))
                               + (float)(v90 * -364.0))
                       + (float)((float)(v90 * (float)(v90 * v90)) * -6188.0))
               * (float)(3.8672 - (float)(v90 * 3.8672));
        case 3:
          v91 = result * result;
          v40 = sqrtf(1.0 - (float)(result * result));
          v41 = (float)((float)((float)(result * -7.0) + (float)((float)(result * (float)(result * result)) * 105.0))
                      + (float)((float)((float)(result * (float)(result * result)) * (float)(v91 * v91)) * 323.0))
              + (float)((float)(result * (float)(v91 * v91)) * -357.0);
          v38 = (float)(v91 * 402.19) + -402.19;
          goto LABEL_92;
        case 4:
          v92 = result * result;
          v93 = v92 + -1.0;
          v41 = (float)((float)((float)((float)(v92 * v92) * -255.0) + -1.0)
                      + (float)((float)(v92 * (float)(v92 * v92)) * 323.0))
              + (float)(v92 * 45.0);
          v38 = v93 * v93;
          *(float *)&v74 = 2815.3;
LABEL_91:
          v40 = *(float *)&v74;
LABEL_92:
          result = (float)(v38 * v40) * v41;
          break;
        case 5:
          v51 = sqrtf(1.0 - (float)(result * result));
          v84 = (float)(result * result) + -1.0;
          v85 = result * (float)((float)(result * result) * (float)(result * result));
          v86 = (float)(result * 15.0) + (float)((float)(result * (float)(result * result)) * -170.0);
          v87 = 323.0;
LABEL_94:
          v52 = v86 + (float)(v85 * v87);
          v65 = v84 * v84;
          v66 = -16892.0;
LABEL_95:
          v53 = v65 * v66;
LABEL_96:
          result = (float)(v53 * v52) * v51;
          break;
        case 6:
          v94 = result * result;
          v60 = (float)((float)(v94 + -1.0) * -84459.0) * (float)((float)(v94 + -1.0) * (float)(v94 + -1.0));
          v61 = v94 * v94;
          v62 = (float)(v94 * -102.0) + 3.0;
          v63 = 323.0;
LABEL_98:
          result = v60 * (float)(v62 + (float)(v61 * v63));
          break;
        case 7:
          v26 = sqrtf(1.0 - (float)(result * result));
          v27 = 5743200.0
              * (float)((float)((float)(result * result) + -1.0)
                      * (float)((float)((float)(result * result) + -1.0) * (float)((float)(result * result) + -1.0)));
          v28 = (float)(result * -3.0) + (float)((float)(result * (float)(result * result)) * 19.0);
LABEL_100:
          result = v26 * (float)(v27 * v28);
          break;
        case 8:
          v30 = result * result;
          v31 = (float)((float)((float)(v30 + -1.0) * (float)(v30 + -1.0))
                      * (float)((float)(v30 + -1.0) * (float)(v30 + -1.0)))
              * 17230000.0;
          v32 = -19.0;
LABEL_102:
          result = -(float)(v31 + (float)((float)(v30 * v32) * v31));
          break;
        case 9:
          v95 = 1.0 - (float)(result * result);
          v21 = sqrtf(v95);
          v20 = (float)(v95 * v95) * (float)(v95 * v95);
          v22 = -654730000.0;
LABEL_104:
          v81 = result * v22;
LABEL_105:
          result = (float)(v81 * v20) * v21;
          break;
        default:
          v14 = (float)(result * result) + -1.0;
          v15 = (float)(v14 * v14) * (float)(v14 * v14);
          *(float *)&v24 = -654730000.0;
LABEL_85:
          v16 = *(float *)&v24;
          goto LABEL_86;
      }
      return result;
    default:
      v4 = 0.0;
      goto LABEL_30;
  }
  return result;
}

void HOA::initialize(HOA *this, double a2, double a3, double a4)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  float v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float32x4_t *v34;
  float32x4_t *v35;
  float32x4_t v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int32x4_t v47;
  int32x4_t *v48;
  int v49;
  unint64_t v50;
  float *v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  _DWORD *v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  _DWORD *v61;
  unint64_t v62;
  int v63;
  HOA *v64;
  uint64_t v65;
  uint64_t v66;
  const void *v67;
  __int128 *v68;
  __int128 *v69;
  __int128 *v70;
  __int128 *v71;
  void *v72;
  size_t v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  unsigned int v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  float *v93;
  float *v94;
  uint64_t v95;
  float *v96;
  float v97;
  float v98;
  float v99;
  __float2 v100;
  __float2 v101;
  unsigned int v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unsigned int v109;
  uint64_t v110;
  __int128 *v111;
  unsigned int v112;
  __int128 *v113;
  uint64_t v114;
  uint64_t v115;
  __int128 v116;
  _OWORD *v117;
  uint64_t v118;
  unsigned int v119;
  int *v120;
  int v121;
  int v122;
  BOOL v123;
  unsigned int v124;
  int v125;
  unsigned int v126;
  int v127;
  _QWORD *v128;
  unsigned int v129;
  unsigned int v130;
  int v131;
  const char *v132;
  __int16 v133;
  int v134;
  __int16 v135;
  const char *v136;
  __int16 v137;
  int v138;
  __int16 v139;
  unsigned int v140;
  uint64_t v141;

  v141 = *MEMORY[0x1E0C80C00];
  v5 = *((_DWORD *)this + 1);
  v6 = v5 + 1;
  v7 = v6 * v6;
  *((_DWORD *)this + 3) = (v5 + 1) * (v5 + 1);
  *(_DWORD *)this = v5;
  _CF = *((_DWORD *)this + 76) == 2 && v5 >= 4;
  if (_CF)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v131 = 136316162;
      v132 = "HOA.cpp";
      v133 = 1024;
      v135 = 2080;
      v134 = 684;
      v136 = "initialize";
      v137 = 1024;
      v138 = 684;
      v139 = 1024;
      v140 = v5;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; initializing a HOA instance with order = %d > 3 with FuMa normalization",
        (uint8_t *)&v131,
        0x28u);
    }
    v9 = 3;
  }
  else
  {
    if (v5 < 0xB)
      goto LABEL_13;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v131 = 136316162;
      v132 = "HOA.cpp";
      v133 = 1024;
      v135 = 2080;
      v134 = 687;
      v136 = "initialize";
      v137 = 1024;
      v138 = 687;
      v139 = 1024;
      v140 = v5;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Warning; initializing a HOA instance with order = %d > 10",
        (uint8_t *)&v131,
        0x28u);
    }
    v9 = 10;
  }
  *(_DWORD *)this = v9;
  v6 = v9 + 1;
  v7 = v6 * v6;
LABEL_13:
  v11 = (uint64_t *)((char *)this + 80);
  v10 = *((_QWORD *)this + 10);
  *((_DWORD *)this + 2) = v7;
  v12 = (*((_QWORD *)this + 11) - v10) >> 2;
  if (v7 <= v12)
  {
    if (v7 < v12)
      *((_QWORD *)this + 11) = v10 + 4 * v7;
  }
  else
  {
    std::vector<float>::__append((char **)this + 10, v7 - v12);
    v6 = *(_DWORD *)this + 1;
  }
  v13 = v6;
  v14 = *((_DWORD *)this + 76);
  if (v14 == 2)
  {
    v19 = 0;
    v20 = 0;
    LODWORD(v21) = 0;
    v22 = *v11;
    v23 = *v11 + 16;
    v24 = -1;
    __asm { FMOV            V2.4S, #1.0 }
    do
    {
      v29 = sqrtf((float)((float)(int)v20 * 2.0) + 1.0);
      v30 = (int)v21;
      if ((v20 & 0x7FFFFFFC) != 0)
      {
        v31 = v19 & 0xFFFFFFF8;
        v32 = (2 * (_DWORD)v20) & 0xFFFFFFF8;
        v21 = v32 + (int)v21;
        v33 = v30;
        v34 = (float32x4_t *)(v23 + 4 * v30);
        v35 = (float32x4_t *)&flt_1B669FE44[v33 + 4];
        do
        {
          v36 = vdivq_f32(_Q2, vmulq_n_f32(*v35, v29));
          v34[-1] = vdivq_f32(_Q2, vmulq_n_f32(v35[-1], v29));
          *v34 = v36;
          v34 += 2;
          v35 += 2;
          v31 -= 8;
        }
        while (v31);
      }
      else
      {
        LODWORD(v32) = 0;
        v21 = (int)v21;
      }
      v37 = v32 + v24;
      do
      {
        *(float *)(v22 + 4 * v21) = 1.0 / (float)(flt_1B669FE44[v21] * v29);
        ++v21;
        _CF = __CFADD__(v37++, 1);
      }
      while (!_CF);
      ++v20;
      v19 += 2;
      v24 -= 2;
    }
    while (v20 != v13);
  }
  else if (v14)
  {
    v38 = 0;
    v39 = 0;
    LODWORD(v40) = 0;
    v41 = *v11;
    v42 = *v11 + 16;
    v43 = -1;
    do
    {
      *(float *)&a4 = 1.0 / sqrtf((float)((float)(int)v39 * 2.0) + 1.0);
      v44 = (int)v40;
      if ((v39 & 0x7FFFFFFC) != 0)
      {
        v45 = v38 & 0xFFFFFFF8;
        v46 = (2 * (_DWORD)v39) & 0xFFFFFFF8;
        v40 = v46 + (int)v40;
        v47 = vdupq_lane_s32(*(int32x2_t *)&a4, 0);
        v48 = (int32x4_t *)(v42 + 4 * v44);
        do
        {
          v48[-1] = v47;
          *v48 = v47;
          v48 += 2;
          v45 -= 8;
        }
        while (v45);
      }
      else
      {
        LODWORD(v46) = 0;
        v40 = (int)v40;
      }
      v49 = v46 + v43;
      do
      {
        *(_DWORD *)(v41 + 4 * v40++) = LODWORD(a4);
        _CF = __CFADD__(v49++, 1);
      }
      while (!_CF);
      ++v39;
      v38 += 2;
      v43 -= 2;
    }
    while (v39 != v13);
  }
  else
  {
    v15 = 0;
    v16 = *v11;
    v17 = 1;
    v18 = 4;
    do
    {
      memset_pattern16((void *)(v16 + 4 * v15), &unk_1B6627B80, v18);
      v15 += v17;
      v17 += 2;
      v18 += 8;
      --v13;
    }
    while (v13);
  }
  v50 = (*((_DWORD *)this + 2) * *((_DWORD *)this + 2));
  v131 = 0;
  std::vector<float>::assign((char **)this + 13, v50, &v131);
  v53 = *((_DWORD *)this + 44);
  v54 = *(int *)this;
  if (v53)
  {
    if (v53 == 2)
    {
      if (v54 < 0xA)
      {
        v55 = &unk_1B66A0428;
        goto LABEL_52;
      }
    }
    else
    {
      if (v53 != 1)
        goto LABEL_55;
      if (v54 < 0xA)
      {
        v55 = &unk_1B66A0400;
LABEL_52:
        v52 = v55[v54];
        goto LABEL_55;
      }
    }
    v52 = 121;
  }
  else
  {
    if (v54 < 0x16)
    {
      v55 = &unk_1B66A0450;
      goto LABEL_52;
    }
    v52 = 1014;
  }
LABEL_55:
  v56 = *((_QWORD *)this + 26);
  *((_DWORD *)this + 6) = v52;
  v57 = v52;
  v58 = (*((_QWORD *)this + 27) - v56) >> 2;
  if (v57 <= v58)
  {
    if (v57 < v58)
      *((_QWORD *)this + 27) = v56 + 4 * v57;
  }
  else
  {
    std::vector<float>::__append((char **)this + 26, v57 - v58);
    v57 = *((unsigned int *)this + 6);
  }
  v59 = *((_QWORD *)this + 29);
  v60 = (*((_QWORD *)this + 30) - v59) >> 2;
  if (v57 <= v60)
  {
    if (v57 < v60)
      *((_QWORD *)this + 30) = v59 + 4 * v57;
  }
  else
  {
    std::vector<float>::__append((char **)this + 29, v57 - v60);
    v57 = *((unsigned int *)this + 6);
  }
  v61 = (_DWORD *)*((_QWORD *)this + 32);
  v62 = (uint64_t)(*((_QWORD *)this + 33) - (_QWORD)v61) >> 2;
  if (v57 <= v62)
  {
    if (v57 < v62)
      *((_QWORD *)this + 33) = &v61[v57];
  }
  else
  {
    std::vector<float>::__append((char **)this + 32, v57 - v62);
    v61 = (_DWORD *)*((_QWORD *)this + 32);
  }
  v63 = *((_DWORD *)this + 44);
  v64 = (HOA *)*(unsigned int *)this;
  v65 = *((_QWORD *)this + 26);
  v66 = *((_QWORD *)this + 29);
  if (v63)
  {
    if (v63 == 2)
    {
      switch((int)v64)
      {
        case 0:
          if (v65 && v66 && v61)
          {
LABEL_79:
            *(_DWORD *)v65 = 0;
            *(_DWORD *)v66 = 0;
            *v61 = 1065353216;
          }
          break;
        case 1:
          if (v65 && v66 && v61)
          {
            *(_OWORD *)v65 = xmmword_1B66A2C10;
            *(_OWORD *)v66 = xmmword_1B66A2C20;
            v68 = &xmmword_1B66A2C30;
LABEL_129:
            *(_OWORD *)v61 = *v68;
          }
          break;
        case 2:
          if (v65 && v66 && v61)
          {
            *(_DWORD *)(v65 + 32) = 1116271638;
            *(_OWORD *)v65 = xmmword_1B669B224;
            *(_OWORD *)(v65 + 16) = unk_1B669B234;
            *(_DWORD *)(v66 + 32) = -1035839118;
            *(_OWORD *)v66 = xmmword_1B669B248;
            *(_OWORD *)(v66 + 16) = unk_1B669B258;
            v61[8] = 1068792731;
            v69 = &xmmword_1B669B26C;
            goto LABEL_143;
          }
          break;
        case 3:
          if (v65 && v66 && v61)
          {
            *(_OWORD *)v65 = xmmword_1B669B290;
            *(_OWORD *)(v65 + 16) = unk_1B669B2A0;
            *(_OWORD *)(v65 + 32) = xmmword_1B669B2B0;
            *(_OWORD *)(v65 + 48) = unk_1B669B2C0;
            *(_OWORD *)v66 = xmmword_1B669B2D0;
            *(_OWORD *)(v66 + 16) = unk_1B669B2E0;
            *(_OWORD *)(v66 + 32) = xmmword_1B669B2F0;
            *(_OWORD *)(v66 + 48) = unk_1B669B300;
            v70 = &xmmword_1B669B310;
            goto LABEL_159;
          }
          break;
        case 4:
          if (v65 && v66 && v61)
          {
            *(_DWORD *)(v65 + 96) = 1058111518;
            *(_OWORD *)v65 = xmmword_1B669B350;
            *(_OWORD *)(v65 + 16) = unk_1B669B360;
            *(_OWORD *)(v65 + 64) = xmmword_1B669B390;
            *(_OWORD *)(v65 + 80) = unk_1B669B3A0;
            *(_OWORD *)(v65 + 32) = xmmword_1B669B370;
            *(_OWORD *)(v65 + 48) = unk_1B669B380;
            *(_OWORD *)v66 = xmmword_1B669B3B4;
            *(_OWORD *)(v66 + 16) = unk_1B669B3C4;
            *(_OWORD *)(v66 + 64) = xmmword_1B669B3F4;
            *(_OWORD *)(v66 + 80) = unk_1B669B404;
            *(_OWORD *)(v66 + 32) = xmmword_1B669B3D4;
            *(_OWORD *)(v66 + 48) = unk_1B669B3E4;
            *(_DWORD *)(v66 + 96) = 1110360230;
            v61[24] = 1057102910;
            v69 = &xmmword_1B669B418;
LABEL_142:
            v74 = v69[5];
            *((_OWORD *)v61 + 4) = v69[4];
            *((_OWORD *)v61 + 5) = v74;
            v75 = v69[3];
            *((_OWORD *)v61 + 2) = v69[2];
            *((_OWORD *)v61 + 3) = v75;
LABEL_143:
            v76 = v69[1];
            *(_OWORD *)v61 = *v69;
            *((_OWORD *)v61 + 1) = v76;
          }
          break;
        case 5:
          if (v65 && v66 && v61)
          {
            *(_OWORD *)(v65 + 32) = xmmword_1B669B49C;
            *(_OWORD *)(v65 + 48) = unk_1B669B4AC;
            *(_OWORD *)(v65 + 128) = xmmword_1B669B4FC;
            *(_OWORD *)(v65 + 96) = xmmword_1B669B4DC;
            *(_OWORD *)(v65 + 112) = unk_1B669B4EC;
            *(_OWORD *)(v65 + 64) = xmmword_1B669B4BC;
            *(_OWORD *)(v65 + 80) = unk_1B669B4CC;
            *(_OWORD *)v65 = xmmword_1B669B47C;
            *(_OWORD *)(v65 + 16) = unk_1B669B48C;
            *(_OWORD *)(v66 + 32) = xmmword_1B669B52C;
            *(_OWORD *)(v66 + 48) = unk_1B669B53C;
            *(_OWORD *)v66 = xmmword_1B669B50C;
            *(_OWORD *)(v66 + 16) = unk_1B669B51C;
            *(_OWORD *)(v66 + 128) = xmmword_1B669B58C;
            *(_OWORD *)(v66 + 96) = xmmword_1B669B56C;
            *(_OWORD *)(v66 + 112) = unk_1B669B57C;
            *(_OWORD *)(v66 + 64) = xmmword_1B669B54C;
            *(_OWORD *)(v66 + 80) = unk_1B669B55C;
            v71 = &xmmword_1B669B59C;
LABEL_148:
            v77 = v71[7];
            *((_OWORD *)v61 + 6) = v71[6];
            *((_OWORD *)v61 + 7) = v77;
            *((_OWORD *)v61 + 8) = v71[8];
            v78 = v71[3];
            *((_OWORD *)v61 + 2) = v71[2];
            *((_OWORD *)v61 + 3) = v78;
            v79 = v71[5];
            *((_OWORD *)v61 + 4) = v71[4];
            *((_OWORD *)v61 + 5) = v79;
            v80 = v71[1];
            *(_OWORD *)v61 = *v71;
            *((_OWORD *)v61 + 1) = v80;
          }
          break;
        case 6:
          if (v65 && v66 && v61)
          {
            *(_DWORD *)(v65 + 192) = 1127431944;
            *(_OWORD *)(v65 + 128) = xmmword_1B669B6AC;
            *(_OWORD *)(v65 + 144) = unk_1B669B6BC;
            *(_OWORD *)(v65 + 160) = xmmword_1B669B6CC;
            *(_OWORD *)(v65 + 176) = unk_1B669B6DC;
            *(_OWORD *)(v65 + 64) = xmmword_1B669B66C;
            *(_OWORD *)(v65 + 80) = unk_1B669B67C;
            *(_OWORD *)(v65 + 96) = xmmword_1B669B68C;
            *(_OWORD *)(v65 + 112) = unk_1B669B69C;
            *(_OWORD *)v65 = xmmword_1B669B62C;
            *(_OWORD *)(v65 + 16) = unk_1B669B63C;
            *(_OWORD *)(v65 + 32) = xmmword_1B669B64C;
            *(_OWORD *)(v65 + 48) = unk_1B669B65C;
            *(_DWORD *)(v66 + 192) = -1030844557;
            *(_OWORD *)(v66 + 128) = xmmword_1B669B770;
            *(_OWORD *)(v66 + 144) = unk_1B669B780;
            *(_OWORD *)(v66 + 160) = xmmword_1B669B790;
            *(_OWORD *)(v66 + 176) = unk_1B669B7A0;
            *(_OWORD *)(v66 + 64) = xmmword_1B669B730;
            *(_OWORD *)(v66 + 80) = unk_1B669B740;
            *(_OWORD *)(v66 + 96) = xmmword_1B669B750;
            *(_OWORD *)(v66 + 112) = unk_1B669B760;
            *(_OWORD *)v66 = xmmword_1B669B6F0;
            *(_OWORD *)(v66 + 16) = unk_1B669B700;
            *(_OWORD *)(v66 + 32) = xmmword_1B669B710;
            *(_OWORD *)(v66 + 48) = unk_1B669B720;
            v61[48] = 1048755214;
            v70 = &xmmword_1B669B7B4;
            goto LABEL_158;
          }
          break;
        case 7:
          if (v65 && v66 && v61)
          {
            *(_OWORD *)(v65 + 192) = xmmword_1B669B938;
            *(_OWORD *)(v65 + 208) = unk_1B669B948;
            *(_OWORD *)(v65 + 224) = xmmword_1B669B958;
            *(_OWORD *)(v65 + 240) = unk_1B669B968;
            *(_OWORD *)(v65 + 128) = xmmword_1B669B8F8;
            *(_OWORD *)(v65 + 144) = unk_1B669B908;
            *(_OWORD *)(v65 + 160) = xmmword_1B669B918;
            *(_OWORD *)(v65 + 176) = unk_1B669B928;
            *(_OWORD *)(v65 + 64) = xmmword_1B669B8B8;
            *(_OWORD *)(v65 + 80) = unk_1B669B8C8;
            *(_OWORD *)(v65 + 96) = xmmword_1B669B8D8;
            *(_OWORD *)(v65 + 112) = unk_1B669B8E8;
            *(_OWORD *)v65 = xmmword_1B669B878;
            *(_OWORD *)(v65 + 16) = unk_1B669B888;
            *(_OWORD *)(v65 + 32) = xmmword_1B669B898;
            *(_OWORD *)(v65 + 48) = unk_1B669B8A8;
            *(_OWORD *)(v66 + 192) = xmmword_1B669BA38;
            *(_OWORD *)(v66 + 208) = unk_1B669BA48;
            *(_OWORD *)(v66 + 224) = xmmword_1B669BA58;
            *(_OWORD *)(v66 + 240) = unk_1B669BA68;
            *(_OWORD *)(v66 + 128) = xmmword_1B669B9F8;
            *(_OWORD *)(v66 + 144) = unk_1B669BA08;
            *(_OWORD *)(v66 + 160) = xmmword_1B669BA18;
            *(_OWORD *)(v66 + 176) = unk_1B669BA28;
            *(_OWORD *)(v66 + 64) = xmmword_1B669B9B8;
            *(_OWORD *)(v66 + 80) = unk_1B669B9C8;
            *(_OWORD *)(v66 + 96) = xmmword_1B669B9D8;
            *(_OWORD *)(v66 + 112) = unk_1B669B9E8;
            *(_OWORD *)v66 = xmmword_1B669B978;
            *(_OWORD *)(v66 + 16) = unk_1B669B988;
            *(_OWORD *)(v66 + 32) = xmmword_1B669B998;
            *(_OWORD *)(v66 + 48) = unk_1B669B9A8;
            v70 = &xmmword_1B669BA78;
LABEL_157:
            v81 = v70[13];
            *((_OWORD *)v61 + 12) = v70[12];
            *((_OWORD *)v61 + 13) = v81;
            v82 = v70[15];
            *((_OWORD *)v61 + 14) = v70[14];
            *((_OWORD *)v61 + 15) = v82;
LABEL_158:
            v83 = v70[9];
            *((_OWORD *)v61 + 8) = v70[8];
            *((_OWORD *)v61 + 9) = v83;
            v84 = v70[11];
            *((_OWORD *)v61 + 10) = v70[10];
            *((_OWORD *)v61 + 11) = v84;
            v85 = v70[5];
            *((_OWORD *)v61 + 4) = v70[4];
            *((_OWORD *)v61 + 5) = v85;
            v86 = v70[7];
            *((_OWORD *)v61 + 6) = v70[6];
            *((_OWORD *)v61 + 7) = v86;
LABEL_159:
            v87 = v70[1];
            *(_OWORD *)v61 = *v70;
            *((_OWORD *)v61 + 1) = v87;
            v88 = v70[3];
            *((_OWORD *)v61 + 2) = v70[2];
            *((_OWORD *)v61 + 3) = v88;
          }
          break;
        case 8:
          if (v65 && v66 && v61)
          {
            memcpy(*((void **)this + 26), &unk_1B669BB78, 0x144uLL);
            memcpy((void *)v66, &unk_1B669BCBC, 0x144uLL);
            v67 = &unk_1B669BE00;
LABEL_164:
            v72 = v61;
            v73 = 324;
            goto LABEL_170;
          }
          break;
        case 9:
          if (v65 && v66 && v61)
          {
            memcpy(*((void **)this + 26), &unk_1B669BF44, 0x190uLL);
            memcpy((void *)v66, &unk_1B669C0D4, 0x190uLL);
            v67 = &unk_1B669C264;
LABEL_169:
            v72 = v61;
            v73 = 400;
            goto LABEL_170;
          }
          break;
        default:
          if (v65 && v66 && v61)
          {
            memcpy(*((void **)this + 26), &unk_1B669C3F4, 0x1E4uLL);
            memcpy((void *)v66, &unk_1B669C5D8, 0x1E4uLL);
            v67 = &unk_1B669C7BC;
LABEL_124:
            v72 = v61;
            v73 = 484;
LABEL_170:
            memcpy(v72, v67, v73);
          }
          break;
      }
    }
    else if (v63 == 1)
    {
      switch((int)v64)
      {
        case 0:
          if (v65 && v66)
            goto LABEL_79;
          break;
        case 1:
          if (v65 && v66 && v61)
          {
            *(_OWORD *)v65 = xmmword_1B66A2C10;
            *(_OWORD *)v66 = xmmword_1B66A2BF0;
            v68 = &xmmword_1B66A2C00;
            goto LABEL_129;
          }
          break;
        case 2:
          if (v65 && v66 && v61)
          {
            *(_DWORD *)(v65 + 32) = 1123963561;
            *(_OWORD *)v65 = xmmword_1B6699AA8;
            *(_OWORD *)(v65 + 16) = unk_1B6699AB8;
            *(_DWORD *)(v66 + 32) = -1039627997;
            *(_OWORD *)v66 = xmmword_1B6699ACC;
            *(_OWORD *)(v66 + 16) = unk_1B6699ADC;
            v61[8] = 1069089495;
            v69 = &xmmword_1B6699AF0;
            goto LABEL_143;
          }
          break;
        case 3:
          if (v65 && v66 && v61)
          {
            *(_OWORD *)v65 = xmmword_1B6699B14;
            *(_OWORD *)(v65 + 16) = unk_1B6699B24;
            *(_OWORD *)(v65 + 32) = xmmword_1B6699B34;
            *(_OWORD *)(v65 + 48) = unk_1B6699B44;
            *(_OWORD *)v66 = xmmword_1B6699B54;
            *(_OWORD *)(v66 + 16) = unk_1B6699B64;
            *(_OWORD *)(v66 + 32) = xmmword_1B6699B74;
            *(_OWORD *)(v66 + 48) = unk_1B6699B84;
            v70 = &xmmword_1B6699B94;
            goto LABEL_159;
          }
          break;
        case 4:
          if (v65 && v66 && v61)
          {
            *(_DWORD *)(v65 + 96) = -1038292098;
            *(_OWORD *)v65 = xmmword_1B6699BD4;
            *(_OWORD *)(v65 + 16) = unk_1B6699BE4;
            *(_OWORD *)(v65 + 64) = xmmword_1B6699C14;
            *(_OWORD *)(v65 + 80) = unk_1B6699C24;
            *(_OWORD *)(v65 + 32) = xmmword_1B6699BF4;
            *(_OWORD *)(v65 + 48) = unk_1B6699C04;
            *(_OWORD *)v66 = xmmword_1B6699C38;
            *(_OWORD *)(v66 + 16) = unk_1B6699C48;
            *(_OWORD *)(v66 + 64) = xmmword_1B6699C78;
            *(_OWORD *)(v66 + 80) = unk_1B6699C88;
            *(_OWORD *)(v66 + 32) = xmmword_1B6699C58;
            *(_OWORD *)(v66 + 48) = unk_1B6699C68;
            *(_DWORD *)(v66 + 96) = -1040443289;
            v61[24] = 1057367852;
            v69 = &xmmword_1B6699C9C;
            goto LABEL_142;
          }
          break;
        case 5:
          if (v65 && v66 && v61)
          {
            *(_OWORD *)(v65 + 32) = xmmword_1B6699D20;
            *(_OWORD *)(v65 + 48) = unk_1B6699D30;
            *(_OWORD *)(v65 + 128) = xmmword_1B6699D80;
            *(_OWORD *)(v65 + 96) = xmmword_1B6699D60;
            *(_OWORD *)(v65 + 112) = unk_1B6699D70;
            *(_OWORD *)(v65 + 64) = xmmword_1B6699D40;
            *(_OWORD *)(v65 + 80) = unk_1B6699D50;
            *(_OWORD *)v65 = xmmword_1B6699D00;
            *(_OWORD *)(v65 + 16) = unk_1B6699D10;
            *(_OWORD *)(v66 + 32) = xmmword_1B6699DB0;
            *(_OWORD *)(v66 + 48) = unk_1B6699DC0;
            *(_OWORD *)v66 = xmmword_1B6699D90;
            *(_OWORD *)(v66 + 16) = unk_1B6699DA0;
            *(_OWORD *)(v66 + 128) = xmmword_1B6699E10;
            *(_OWORD *)(v66 + 96) = xmmword_1B6699DF0;
            *(_OWORD *)(v66 + 112) = unk_1B6699E00;
            *(_OWORD *)(v66 + 64) = xmmword_1B6699DD0;
            *(_OWORD *)(v66 + 80) = unk_1B6699DE0;
            v71 = &xmmword_1B6699E20;
            goto LABEL_148;
          }
          break;
        case 6:
          if (v65 && v66 && v61)
          {
            *(_DWORD *)(v65 + 192) = -1022566698;
            *(_OWORD *)(v65 + 128) = xmmword_1B6699F30;
            *(_OWORD *)(v65 + 144) = unk_1B6699F40;
            *(_OWORD *)(v65 + 160) = xmmword_1B6699F50;
            *(_OWORD *)(v65 + 176) = unk_1B6699F60;
            *(_OWORD *)(v65 + 64) = xmmword_1B6699EF0;
            *(_OWORD *)(v65 + 80) = unk_1B6699F00;
            *(_OWORD *)(v65 + 96) = xmmword_1B6699F10;
            *(_OWORD *)(v65 + 112) = unk_1B6699F20;
            *(_OWORD *)v65 = xmmword_1B6699EB0;
            *(_OWORD *)(v65 + 16) = unk_1B6699EC0;
            *(_OWORD *)(v65 + 32) = xmmword_1B6699ED0;
            *(_OWORD *)(v65 + 48) = unk_1B6699EE0;
            *(_DWORD *)(v66 + 192) = 1102138249;
            *(_OWORD *)(v66 + 128) = xmmword_1B6699FF4;
            *(_OWORD *)(v66 + 144) = unk_1B669A004;
            *(_OWORD *)(v66 + 160) = xmmword_1B669A014;
            *(_OWORD *)(v66 + 176) = unk_1B669A024;
            *(_OWORD *)(v66 + 64) = xmmword_1B6699FB4;
            *(_OWORD *)(v66 + 80) = unk_1B6699FC4;
            *(_OWORD *)(v66 + 96) = xmmword_1B6699FD4;
            *(_OWORD *)(v66 + 112) = unk_1B6699FE4;
            *(_OWORD *)v66 = xmmword_1B6699F74;
            *(_OWORD *)(v66 + 16) = unk_1B6699F84;
            *(_OWORD *)(v66 + 32) = xmmword_1B6699F94;
            *(_OWORD *)(v66 + 48) = unk_1B6699FA4;
            v61[48] = 1048646893;
            v70 = &xmmword_1B669A038;
            goto LABEL_158;
          }
          break;
        case 7:
          if (v65 && v66 && v61)
          {
            *(_OWORD *)(v65 + 192) = xmmword_1B669A1BC;
            *(_OWORD *)(v65 + 208) = unk_1B669A1CC;
            *(_OWORD *)(v65 + 224) = xmmword_1B669A1DC;
            *(_OWORD *)(v65 + 240) = unk_1B669A1EC;
            *(_OWORD *)(v65 + 128) = xmmword_1B669A17C;
            *(_OWORD *)(v65 + 144) = unk_1B669A18C;
            *(_OWORD *)(v65 + 160) = xmmword_1B669A19C;
            *(_OWORD *)(v65 + 176) = unk_1B669A1AC;
            *(_OWORD *)(v65 + 64) = xmmword_1B669A13C;
            *(_OWORD *)(v65 + 80) = unk_1B669A14C;
            *(_OWORD *)(v65 + 96) = xmmword_1B669A15C;
            *(_OWORD *)(v65 + 112) = unk_1B669A16C;
            *(_OWORD *)v65 = xmmword_1B669A0FC;
            *(_OWORD *)(v65 + 16) = unk_1B669A10C;
            *(_OWORD *)(v65 + 32) = xmmword_1B669A11C;
            *(_OWORD *)(v65 + 48) = unk_1B669A12C;
            *(_OWORD *)(v66 + 192) = xmmword_1B669A2BC;
            *(_OWORD *)(v66 + 208) = unk_1B669A2CC;
            *(_OWORD *)(v66 + 224) = xmmword_1B669A2DC;
            *(_OWORD *)(v66 + 240) = unk_1B669A2EC;
            *(_OWORD *)(v66 + 128) = xmmword_1B669A27C;
            *(_OWORD *)(v66 + 144) = unk_1B669A28C;
            *(_OWORD *)(v66 + 160) = xmmword_1B669A29C;
            *(_OWORD *)(v66 + 176) = unk_1B669A2AC;
            *(_OWORD *)(v66 + 64) = xmmword_1B669A23C;
            *(_OWORD *)(v66 + 80) = unk_1B669A24C;
            *(_OWORD *)(v66 + 96) = xmmword_1B669A25C;
            *(_OWORD *)(v66 + 112) = unk_1B669A26C;
            *(_OWORD *)v66 = xmmword_1B669A1FC;
            *(_OWORD *)(v66 + 16) = unk_1B669A20C;
            *(_OWORD *)(v66 + 32) = xmmword_1B669A21C;
            *(_OWORD *)(v66 + 48) = unk_1B669A22C;
            v70 = &xmmword_1B669A2FC;
            goto LABEL_157;
          }
          break;
        case 8:
          if (v65 && v66 && v61)
          {
            memcpy(*((void **)this + 26), &unk_1B669A3FC, 0x144uLL);
            memcpy((void *)v66, &unk_1B669A540, 0x144uLL);
            v67 = &unk_1B669A684;
            goto LABEL_164;
          }
          break;
        case 9:
          if (v65 && v66 && v61)
          {
            memcpy(*((void **)this + 26), &unk_1B669A7C8, 0x190uLL);
            memcpy((void *)v66, &unk_1B669A958, 0x190uLL);
            v67 = &unk_1B669AAE8;
            goto LABEL_169;
          }
          break;
        default:
          if (v65 && v66 && v61)
          {
            memcpy(*((void **)this + 26), &unk_1B669AC78, 0x1E4uLL);
            memcpy((void *)v66, &unk_1B669AE5C, 0x1E4uLL);
            v67 = &unk_1B669B040;
            goto LABEL_124;
          }
          break;
      }
    }
  }
  else
  {
    HOA::getTDesign(v64, (_OWORD *)v65, *((float **)this + 29), (float *)v61, v51);
  }
  vDSP_vsmul(*((const float **)this + 26), 1, &kDeg2Radf, *((float **)this + 26), 1, *((unsigned int *)this + 6));
  vDSP_vsmul(*((const float **)this + 29), 1, &kDeg2Radf, *((float **)this + 29), 1, *((unsigned int *)this + 6));
  v89 = *((_DWORD *)this + 6);
  v90 = 3 * v89;
  v91 = *((_QWORD *)this + 35);
  v92 = (*((_QWORD *)this + 36) - v91) >> 2;
  if (v90 <= v92)
  {
    if (v90 < v92)
      *((_QWORD *)this + 36) = v91 + 4 * v90;
  }
  else
  {
    std::vector<float>::__append((char **)this + 35, v90 - v92);
    v89 = *((_DWORD *)this + 6);
  }
  if (v89)
  {
    v93 = (float *)*((_QWORD *)this + 26);
    v94 = (float *)*((_QWORD *)this + 29);
    v95 = v89;
    v96 = (float *)(*((_QWORD *)this + 35) + 8);
    do
    {
      v97 = *v93++;
      v98 = v97;
      v99 = *v94++;
      v100 = __sincosf_stret(v99);
      v101 = __sincosf_stret(v98);
      *(v96 - 2) = v100.__cosval * v101.__cosval;
      *(v96 - 1) = v100.__cosval * v101.__sinval;
      *v96 = v100.__sinval;
      v96 += 3;
      --v95;
    }
    while (v95);
  }
  if (*((_DWORD *)this + 76) != 2)
    goto LABEL_222;
  v102 = *((_DWORD *)this + 2);
  v103 = v102 * v102;
  v104 = *((_QWORD *)this + 46);
  v105 = (*((_QWORD *)this + 47) - v104) >> 2;
  if (v103 <= v105)
  {
    if (v103 < v105)
      *((_QWORD *)this + 47) = v104 + 4 * v103;
  }
  else
  {
    std::vector<float>::__append((char **)this + 46, v103 - v105);
    v102 = *((_DWORD *)this + 2);
  }
  if (!v102)
    goto LABEL_222;
  v106 = *((_QWORD *)this + 46);
  if (v102 >= 8)
  {
    v108 = 0;
    v109 = 0;
    v110 = 0;
    v111 = (__int128 *)&unk_1B669FE94;
    while (1)
    {
      v112 = v109;
      v113 = v111;
      v114 = v102 & 0xFFFFFFF8;
      if (__CFADD__(v102 * v110, v102 - 1))
      {
        v115 = 0;
      }
      else
      {
        do
        {
          v116 = *v113;
          v117 = (_OWORD *)(v106 + 4 * v112);
          *v117 = *(v113 - 1);
          v117[1] = v116;
          v113 += 2;
          v112 += 8;
          v114 -= 8;
        }
        while (v114);
        v115 = v102 & 0xFFFFFFF8;
        if (v115 == v102)
          goto LABEL_189;
      }
      v118 = v102 - v115;
      v119 = v109 + v115;
      v120 = (int *)&xmmword_1B669FE84 + v115 + v108;
      do
      {
        v121 = *v120++;
        *(_DWORD *)(v106 + 4 * v119++) = v121;
        --v118;
      }
      while (v118);
LABEL_189:
      ++v110;
      v111 += 4;
      v109 += v102;
      v108 += 16;
      if (v110 == v102)
        goto LABEL_222;
    }
  }
  *(_DWORD *)v106 = 1065353216;
  if (v102 == 1)
    goto LABEL_222;
  *(_DWORD *)(v106 + 4) = 0;
  *(_DWORD *)(v106 + 8) = 0;
  if (v102 == 2)
  {
    v107 = 3;
LABEL_221:
    *(_DWORD *)(v106 + 4 * v107) = 0;
    goto LABEL_222;
  }
  *(_DWORD *)(v106 + 12) = 0;
  if (v102 == 3)
  {
    *(_QWORD *)(v106 + 16) = 0;
    *(_QWORD *)(v106 + 24) = 0x3F80000000000000;
    v107 = 8;
    goto LABEL_221;
  }
  if (v102 != 4)
  {
    *(_DWORD *)(v106 + 16) = 0;
    if (v102 != 5)
    {
      *(_DWORD *)(v106 + 20) = 0;
      if (v102 != 6)
        *(_DWORD *)(v106 + 24) = 0;
    }
  }
  *(_DWORD *)(v106 + 4 * v102) = 0;
  *(_DWORD *)(v106 + 4 * (v102 + 1)) = 0;
  *(_DWORD *)(v106 + 4 * (v102 + 2)) = 0;
  *(_DWORD *)(v106 + 4 * (v102 + 3)) = 1065353216;
  if (v102 != 4)
  {
    *(_DWORD *)(v106 + 4 * (v102 + 4)) = 0;
    if (v102 != 5)
    {
      *(_DWORD *)(v106 + 4 * (v102 + 5)) = 0;
      if (v102 != 6)
      {
        *(_DWORD *)(v106 + 52) = 0;
        v125 = 2 * v102;
        *(_QWORD *)(v106 + 8 * v102) = 0x3F80000000000000;
        *(_DWORD *)(v106 + 4 * (v125 + 2)) = 0;
        *(_DWORD *)(v106 + 4 * (v125 + 3)) = 0;
        v123 = v102 == 4;
        *(_DWORD *)(v106 + 4 * (v125 + 4)) = 0;
        *(_DWORD *)(v106 + 4 * (v125 + 5)) = 0;
        v124 = 2 * v102 + 6;
        goto LABEL_211;
      }
    }
  }
  v122 = 2 * v102;
  *(_QWORD *)(v106 + 8 * v102) = 0x3F80000000000000;
  *(_DWORD *)(v106 + 4 * (v122 + 2)) = 0;
  *(_DWORD *)(v106 + 4 * (v122 + 3)) = 0;
  v123 = v102 == 4;
  if (v102 != 4)
  {
    *(_DWORD *)(v106 + 4 * (v122 + 4)) = 0;
    if (v102 != 5)
    {
      v124 = v122 + 5;
LABEL_211:
      *(_DWORD *)(v106 + 4 * v124) = 0;
    }
  }
  v126 = 3 * v102;
  *(_DWORD *)(v106 + 4 * v126) = 0;
  *(_DWORD *)(v106 + 4 * (v126 + 1)) = 0;
  *(_DWORD *)(v106 + 4 * (v126 + 2)) = 1065353216;
  *(_DWORD *)(v106 + 4 * (v126 + 3)) = 0;
  if (!v123)
  {
    *(_DWORD *)(v106 + 4 * (v126 + 4)) = 0;
    if (v102 == 5)
    {
      *(_QWORD *)(v106 + 80) = 0;
      *(_QWORD *)(v106 + 88) = 0;
      v107 = 24;
      goto LABEL_221;
    }
    *(_DWORD *)(v106 + 4 * (v126 + 5)) = 0;
    if (v102 != 6)
      *(_DWORD *)(v106 + 4 * (v126 + 6)) = 0;
    v127 = 4 * v102;
    v128 = (_QWORD *)(v106 + 16 * v102);
    *v128 = 0;
    v128[1] = 0;
    *(_DWORD *)(v106 + 4 * (v127 + 4)) = 0;
    *(_DWORD *)(v106 + 4 * (v127 + 5)) = 0;
    if (v102 != 6)
      *(_DWORD *)(v106 + 4 * (v127 + 6)) = 1065353216;
    v129 = 5 * v102;
    *(_DWORD *)(v106 + 4 * v129) = 0;
    *(_DWORD *)(v106 + 4 * (v129 + 1)) = 0;
    *(_DWORD *)(v106 + 4 * (v129 + 2)) = 0;
    *(_DWORD *)(v106 + 4 * (v129 + 3)) = 0;
    *(_DWORD *)(v106 + 4 * (v129 + 4)) = 0;
    *(_DWORD *)(v106 + 4 * (v129 + 5)) = 0;
    if (v102 != 6)
    {
      *(_DWORD *)(v106 + 4 * (v129 + 6)) = 0;
      v130 = 6 * v102;
      *(_QWORD *)(v106 + 4 * v130) = 0;
      *(_QWORD *)(v106 + 4 * (v130 + 2)) = 0;
      *(_QWORD *)(v106 + 4 * (v130 + 4)) = 0x3F80000000000000;
      v107 = v130 + 6;
      goto LABEL_221;
    }
  }
LABEL_222:
  *((_QWORD *)this + 2) = 0;
  *((_BYTE *)this + 28) = 1;
}

uint64_t HOA::HOA(uint64_t a1, unsigned int a2, int a3)
{
  double v4;
  double v5;
  double v6;

  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 4) = a2;
  *(_BYTE *)(a1 + 28) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_QWORD *)(a1 + 296) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_DWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 304) = a3;
  HOA::RotationMatrix::RotationMatrix(a1 + 312, a2, a3, 1);
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 384) = 0;
  HOA::initialize((HOA *)a1, v4, v5, v6);
  return a1;
}

void sub_1B65B2B30(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  v6 = v2;
  v8 = *v6;
  if (*v6)
  {
    v1[47] = v8;
    operator delete(v8);
    v9 = (void *)v1[42];
    if (!v9)
    {
LABEL_3:
      v10 = *v3;
      if (!*v3)
        goto LABEL_4;
      goto LABEL_18;
    }
  }
  else
  {
    v9 = (void *)v1[42];
    if (!v9)
      goto LABEL_3;
  }
  v1[43] = v9;
  operator delete(v9);
  v10 = *v3;
  if (!*v3)
  {
LABEL_4:
    v11 = (void *)v1[35];
    if (!v11)
      goto LABEL_5;
    goto LABEL_19;
  }
LABEL_18:
  v1[40] = v10;
  operator delete(v10);
  v11 = (void *)v1[35];
  if (!v11)
  {
LABEL_5:
    v12 = (void *)v1[32];
    if (!v12)
      goto LABEL_6;
    goto LABEL_20;
  }
LABEL_19:
  v1[36] = v11;
  operator delete(v11);
  v12 = (void *)v1[32];
  if (!v12)
  {
LABEL_6:
    v13 = (void *)v1[29];
    if (!v13)
      goto LABEL_7;
    goto LABEL_21;
  }
LABEL_20:
  v1[33] = v12;
  operator delete(v12);
  v13 = (void *)v1[29];
  if (!v13)
  {
LABEL_7:
    v14 = (void *)v1[26];
    if (!v14)
      goto LABEL_8;
    goto LABEL_22;
  }
LABEL_21:
  v1[30] = v13;
  operator delete(v13);
  v14 = (void *)v1[26];
  if (!v14)
  {
LABEL_8:
    v15 = *v5;
    if (!*v5)
      goto LABEL_9;
    goto LABEL_23;
  }
LABEL_22:
  v1[27] = v14;
  operator delete(v14);
  v15 = *v5;
  if (!*v5)
  {
LABEL_9:
    v16 = (void *)v1[19];
    if (!v16)
      goto LABEL_10;
    goto LABEL_24;
  }
LABEL_23:
  v1[24] = v15;
  operator delete(v15);
  v16 = (void *)v1[19];
  if (!v16)
  {
LABEL_10:
    v17 = (void *)v1[16];
    if (!v17)
      goto LABEL_11;
    goto LABEL_25;
  }
LABEL_24:
  v1[20] = v16;
  operator delete(v16);
  v17 = (void *)v1[16];
  if (!v17)
  {
LABEL_11:
    v18 = (void *)v1[13];
    if (!v18)
      goto LABEL_12;
    goto LABEL_26;
  }
LABEL_25:
  v1[17] = v17;
  operator delete(v17);
  v18 = (void *)v1[13];
  if (!v18)
  {
LABEL_12:
    v19 = (void *)v1[10];
    if (!v19)
      goto LABEL_13;
    goto LABEL_27;
  }
LABEL_26:
  v1[14] = v18;
  operator delete(v18);
  v19 = (void *)v1[10];
  if (!v19)
  {
LABEL_13:
    v20 = (void *)v1[7];
    if (!v20)
      goto LABEL_14;
    goto LABEL_28;
  }
LABEL_27:
  v1[11] = v19;
  operator delete(v19);
  v20 = (void *)v1[7];
  if (!v20)
  {
LABEL_14:
    v21 = *v4;
    if (!*v4)
      goto LABEL_15;
    goto LABEL_29;
  }
LABEL_28:
  v1[8] = v20;
  operator delete(v20);
  v21 = *v4;
  if (!*v4)
LABEL_15:
    _Unwind_Resume(exception_object);
LABEL_29:
  v1[5] = v21;
  operator delete(v21);
  _Unwind_Resume(exception_object);
}

uint64_t HOA::HOA(uint64_t a1, int a2, int a3)
{
  double v5;
  double v6;
  double v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  BOOL v15;
  int v16;
  int *v17;
  unsigned int v18;
  int v19;
  int v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)(a1 + 32) = 0u;
  *(_BYTE *)(a1 + 28) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_DWORD *)(a1 + 176) = a3;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_QWORD *)(a1 + 296) = 0;
  HOA::RotationMatrix::RotationMatrix((HOA::RotationMatrix *)(a1 + 312), a2, 1);
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  v8 = 0x40000000;
  *(_QWORD *)(a1 + 384) = 0;
  do
  {
    v9 = v8;
    v8 >>= 2;
  }
  while (v9 > (unsigned __int16)a2);
  if (!v9)
  {
    v16 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    v17 = (int *)(a1 + 4);
LABEL_11:
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v21 = 136315906;
      v22 = "HOA.cpp";
      v23 = 1024;
      v24 = 662;
      v25 = 2080;
      v26 = "HOA";
      v27 = 1024;
      v28 = 662;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Incorrect order",
        (uint8_t *)&v21,
        0x22u);
      v16 = *v17;
    }
    goto LABEL_13;
  }
  v10 = 0;
  v11 = (unsigned __int16)a2;
  do
  {
    v12 = v10 + v9;
    v13 = 2 * v9;
    if (v11 < v10 + v9)
    {
      v12 = 0;
      v13 = 0;
    }
    v11 -= v12;
    v14 = v13 + v10;
    v10 = (v13 + v10) >> 1;
    v15 = v9 > 3;
    v9 >>= 2;
  }
  while (v15);
  v16 = v10 - 1;
  *(_DWORD *)(a1 + 4) = v10 - 1;
  v17 = (int *)(a1 + 4);
  if (v14 <= 1)
    goto LABEL_11;
LABEL_13:
  if ((v16 + 1) * (v16 + 1) != (unsigned __int16)a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v21 = 136315906;
    v22 = "HOA.cpp";
    v23 = 1024;
    v24 = 666;
    v25 = 2080;
    v26 = "HOA";
    v27 = 1024;
    v28 = 666;
    _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Incorrect channel count (i.e. not consistent with HOA order definition Ch"
      "annels = (order+1)^2)",
      (uint8_t *)&v21,
      0x22u);
  }
  v18 = a2 & 0xFFFF0000;
  if ((a2 & 0xFFFF0000) == 0x6B0000)
  {
    v19 = 2;
  }
  else if (v18 == 12517376)
  {
    v19 = 0;
  }
  else if (v18 == 12451840)
  {
    v19 = 1;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v21 = 136315906;
      v22 = "HOA.cpp";
      v23 = 1024;
      v24 = 632;
      v25 = 2080;
      v26 = "normalizationFromTag";
      v27 = 1024;
      v28 = 632;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; This is not SN3D/N3D/FuMa: unsupported",
        (uint8_t *)&v21,
        0x22u);
    }
    v19 = -1;
  }
  *(_DWORD *)(a1 + 304) = v19;
  HOA::initialize((HOA *)a1, v5, v6, v7);
  return a1;
}

void sub_1B65B2FCC(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  v7 = *v5;
  if (*v5)
  {
    v1[47] = v7;
    operator delete(v7);
    v8 = (void *)v1[42];
    if (!v8)
    {
LABEL_3:
      v9 = *v2;
      if (!*v2)
        goto LABEL_4;
      goto LABEL_18;
    }
  }
  else
  {
    v8 = (void *)v1[42];
    if (!v8)
      goto LABEL_3;
  }
  v1[43] = v8;
  operator delete(v8);
  v9 = *v2;
  if (!*v2)
  {
LABEL_4:
    v10 = (void *)v1[35];
    if (!v10)
      goto LABEL_5;
    goto LABEL_19;
  }
LABEL_18:
  v1[40] = v9;
  operator delete(v9);
  v10 = (void *)v1[35];
  if (!v10)
  {
LABEL_5:
    v11 = (void *)v1[32];
    if (!v11)
      goto LABEL_6;
    goto LABEL_20;
  }
LABEL_19:
  v1[36] = v10;
  operator delete(v10);
  v11 = (void *)v1[32];
  if (!v11)
  {
LABEL_6:
    v12 = (void *)v1[29];
    if (!v12)
      goto LABEL_7;
    goto LABEL_21;
  }
LABEL_20:
  v1[33] = v11;
  operator delete(v11);
  v12 = (void *)v1[29];
  if (!v12)
  {
LABEL_7:
    v13 = (void *)v1[26];
    if (!v13)
      goto LABEL_8;
    goto LABEL_22;
  }
LABEL_21:
  v1[30] = v12;
  operator delete(v12);
  v13 = (void *)v1[26];
  if (!v13)
  {
LABEL_8:
    v14 = *v4;
    if (!*v4)
      goto LABEL_9;
    goto LABEL_23;
  }
LABEL_22:
  v1[27] = v13;
  operator delete(v13);
  v14 = *v4;
  if (!*v4)
  {
LABEL_9:
    v15 = (void *)v1[19];
    if (!v15)
      goto LABEL_10;
    goto LABEL_24;
  }
LABEL_23:
  v1[24] = v14;
  operator delete(v14);
  v15 = (void *)v1[19];
  if (!v15)
  {
LABEL_10:
    v16 = (void *)v1[16];
    if (!v16)
      goto LABEL_11;
    goto LABEL_25;
  }
LABEL_24:
  v1[20] = v15;
  operator delete(v15);
  v16 = (void *)v1[16];
  if (!v16)
  {
LABEL_11:
    v17 = (void *)v1[13];
    if (!v17)
      goto LABEL_12;
    goto LABEL_26;
  }
LABEL_25:
  v1[17] = v16;
  operator delete(v16);
  v17 = (void *)v1[13];
  if (!v17)
  {
LABEL_12:
    v18 = (void *)v1[10];
    if (!v18)
      goto LABEL_13;
    goto LABEL_27;
  }
LABEL_26:
  v1[14] = v17;
  operator delete(v17);
  v18 = (void *)v1[10];
  if (!v18)
  {
LABEL_13:
    v19 = (void *)v1[7];
    if (!v19)
      goto LABEL_14;
    goto LABEL_28;
  }
LABEL_27:
  v1[11] = v18;
  operator delete(v18);
  v19 = (void *)v1[7];
  if (!v19)
  {
LABEL_14:
    v20 = *v3;
    if (!*v3)
      goto LABEL_15;
    goto LABEL_29;
  }
LABEL_28:
  v1[8] = v19;
  operator delete(v19);
  v20 = *v3;
  if (!*v3)
LABEL_15:
    _Unwind_Resume(exception_object);
LABEL_29:
  v1[5] = v20;
  operator delete(v20);
  _Unwind_Resume(exception_object);
}

void HOA::~HOA(HOA *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  v2 = (void *)*((_QWORD *)this + 46);
  if (v2)
  {
    *((_QWORD *)this + 47) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 42);
  if (v3)
  {
    *((_QWORD *)this + 43) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 39);
  if (v4)
  {
    *((_QWORD *)this + 40) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 35);
  if (v5)
  {
    *((_QWORD *)this + 36) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 32);
  if (v6)
  {
    *((_QWORD *)this + 33) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 29);
  if (v7)
  {
    *((_QWORD *)this + 30) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 26);
  if (v8)
  {
    *((_QWORD *)this + 27) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 23);
  if (v9)
  {
    *((_QWORD *)this + 24) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 19);
  if (v10)
  {
    *((_QWORD *)this + 20) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 16);
  if (v11)
  {
    *((_QWORD *)this + 17) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 13);
  if (v12)
  {
    *((_QWORD *)this + 14) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 10);
  if (v13)
  {
    *((_QWORD *)this + 11) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 7);
  if (v14)
  {
    *((_QWORD *)this + 8) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 4);
  if (v15)
  {
    *((_QWORD *)this + 5) = v15;
    operator delete(v15);
  }
}

uint64_t HOA::createEncoder(HOA *this, const float *a2, const float *a3, vDSP_Length a4, float *a5, uint64_t a6)
{
  int v11;
  uint64_t v12;
  uint8_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  uint64_t v19;
  const float *v20;
  uint64_t v21;
  NSObject *v23;
  const char *v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 28))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v26 = "HOA.cpp";
      v27 = 1024;
      v28 = 777;
      v29 = 2080;
      v30 = "createEncoder";
      v31 = 1024;
      v32 = 777;
      v23 = MEMORY[0x1E0C81028];
      v24 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized";
LABEL_19:
      _os_log_impl(&dword_1B5ED0000, v23, OS_LOG_TYPE_ERROR, v24, buf, 0x22u);
    }
    return 4294967246;
  }
  if (*((unsigned int *)this + 3) * a4 != a6)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v26 = "HOA.cpp";
      v27 = 1024;
      v28 = 782;
      v29 = 2080;
      v30 = "createEncoder";
      v31 = 1024;
      v32 = 782;
      v23 = MEMORY[0x1E0C81028];
      v24 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Inconsistent vector size";
      goto LABEL_19;
    }
    return 4294967246;
  }
  if (a4)
  {
    v11 = *((_DWORD *)this + 2);
    v12 = 4 * a4;
    MEMORY[0x1E0C80A78](this);
    v13 = &buf[-((v12 + 15) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v13, 4 * a4);
    MEMORY[0x1E0C80A78](v14);
    bzero(v13, 4 * a4);
    vDSP_vsmul(a2, 1, &kDeg2Radf, (float *)v13, 1, a4);
    vDSP_vsmul(a3, 1, &kDeg2Radf, (float *)v13, 1, a4);
    v15 = (v11 * a4);
    HOA::sphericalHarmonics((HOA *)v13, (const float *)v13, (const float *)a4, (uint64_t)a5, (float *)*(unsigned int *)this);
    MEMORY[0x1E0C80A78](v16);
    v18 = (float *)&buf[-v17];
    bzero(&buf[-v17], 4 * v15);
    if (*((_DWORD *)this + 76) == 2)
    {
      vDSP_mmul(*((const float **)this + 46), 1, a5, 1, v18, 1, *((unsigned int *)this + 2), a4, *((unsigned int *)this + 2));
      if ((_DWORD)v15)
        memcpy(a5, v18, 4 * v15);
    }
    v19 = 0;
    v20 = a5;
    do
      vDSP_vmul(*((const float **)this + 10), 1, v20++, a4, &v18[(*((_DWORD *)this + 2) * v19++)], 1, *((unsigned int *)this + 2));
    while (a4 != v19);
    if ((_DWORD)v15)
      memcpy(a5, v18, 4 * v15);
    if (*((_DWORD *)this + 1) != *(_DWORD *)this)
    {
      v21 = 4 * *((unsigned int *)this + 3) * a4 - 4 * v15;
      if (v21 >= 1)
        bzero(&a5[v15], 4 * (((unint64_t)v21 >> 2) - ((unint64_t)v21 > 3)) + 4);
    }
  }
  return 0;
}

void HOA::sphericalHarmonics(HOA *this, const float *a2, const float *a3, uint64_t a4, float *a5)
{
  unsigned int v6;
  uint64_t v8;
  char *v9;
  size_t v10;
  unint64_t v11;
  uint64_t v12;
  size_t v13;
  __int128 v14;
  unint64_t v15;
  const float *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  float *v23;
  const float *v24;
  float v25;
  float *v26;
  int v27;
  HOA *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  float *v34;
  float v35;
  float v36;
  float *v37;
  float *v38;
  float v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  float v51;
  uint64_t v52;
  float32x4_t *v53;
  uint64_t v54;
  float32x4_t *v55;
  float32x4_t v56;
  uint64_t v57;
  uint64_t v58;
  float *v59;
  float *v60;
  float v61;
  float *v62;
  uint64_t v63;
  int v64;
  int v65;
  HOA *v66;
  HOA *v67;
  uint64_t v68;
  float v69;
  uint64_t v70;
  char *v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  HOA *v76;
  char *v77;
  unsigned int v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  HOA *v83;
  HOA *v84;
  uint64_t v85;
  int v86;
  char *v87;
  __int128 v88;
  unint64_t v89;
  __int128 v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v6 = a3;
    v83 = this;
    v70 = (uint64_t)&v70;
    v76 = (HOA *)((_DWORD)a5 + 1);
    MEMORY[0x1E0C80A78](this);
    v9 = (char *)&v70 - v8;
    bzero((char *)&v70 - v8, v10);
    v11 = v6;
    MEMORY[0x1E0C80A78](v12);
    v87 = (char *)&v70 - ((v13 + 15) & 0x7FFFFFFF0);
    bzero(v87, v13);
    if ((int)v6 >= 1)
    {
      v77 = v9;
      if (v6 > 1uLL)
      {
        v15 = v6 - (unint64_t)(v6 & 1);
        v16 = a2;
        v17 = v87;
        v18 = v15;
        do
        {
          v19 = *(_QWORD *)v16;
          v16 += 2;
          *(_QWORD *)&v14 = v19;
          v88 = v14;
          *(float *)&v20 = sinf(*((float *)&v19 + 1));
          *(_QWORD *)&v90 = v20;
          *(float *)&v14 = sinf(*(float *)&v88);
          DWORD1(v14) = v90;
          *v17++ = v14;
          v18 -= 2;
        }
        while (v18);
        if ((v6 & 1) == 0)
          goto LABEL_11;
      }
      else
      {
        v15 = 0;
      }
      v21 = v6 - v15;
      v22 = v15;
      v23 = (float *)&v87[4 * v15];
      v24 = &a2[v22];
      do
      {
        v25 = *v24++;
        *v23++ = sinf(v25);
        --v21;
      }
      while (v21);
LABEL_11:
      v26 = (float *)v77;
      v86 = 0;
      v27 = 0;
      v28 = 0;
      v82 = 0;
      v75 = v6 & 7;
      v74 = v6 - v75;
      v29 = 4 * (int)v6;
      v73 = a4 + 16;
      v72 = 2 * v6;
      v71 = v77 + 16;
      v30 = 1;
      v31 = v6;
      v32 = 1;
      v89 = v6;
      *(_QWORD *)&v90 = v29;
      v85 = a4;
      do
      {
        v78 = v31;
        v80 = v30;
        v33 = 0;
        v81 = v27;
        *(_QWORD *)&v88 = a4 + v29 * (v32 + v27);
        v34 = v26;
        do
        {
          __powisf2();
          v36 = v35;
          v37 = (float *)v87;
          v38 = v34;
          do
          {
            v39 = *v37++;
            *v38++ = HOA::legendre(v28, v33, v39) * v36;
            --v11;
          }
          while (v11);
          ++v33;
          v11 = v89;
          v29 = v90;
          v34 = (float *)((char *)v34 + v90);
        }
        while (v33 != v32);
        v40 = (int)v28;
        v41 = v86;
        v42 = v82;
        v43 = v75;
        v44 = v74;
        v45 = v73;
        v46 = v71;
        do
        {
          v47 = v41;
          if (v42 <= v40)
            v48 = v40;
          else
            v48 = v42;
          v49 = v6 * v48;
          if (v42 >= 0)
            v50 = v42;
          else
            v50 = -v42;
          v51 = sqrtf(flt_1B66A0284[(_QWORD)v28 - v50]* (float)((float)((float)((float)(int)v28 * 2.0) + 1.0)* flt_1B66A02D8[(v50 + (_DWORD)v28)]));
          if (v11 < 8)
          {
            v52 = 0;
LABEL_30:
            v57 = v49;
            v58 = v11 - v52;
            v59 = (float *)(a4 + 4 * (v52 + v47));
            v60 = &v26[v52 + v57];
            do
            {
              v61 = *v60++;
              *v59++ = v61 * v51;
              --v58;
            }
            while (v58);
            goto LABEL_18;
          }
          v53 = (float32x4_t *)(v45 + 4 * v41);
          v54 = v44;
          v55 = (float32x4_t *)&v46[4 * v49];
          do
          {
            v56 = vmulq_n_f32(*v55, v51);
            v53[-1] = vmulq_n_f32(v55[-1], v51);
            *v53 = v56;
            v53 += 2;
            v55 += 2;
            v54 -= 8;
          }
          while (v54);
          v52 = v44;
          if (v43)
            goto LABEL_30;
LABEL_18:
          ++v42;
          v41 = v47 + v6;
          --v40;
        }
        while (v32 != v42);
        v79 = v32;
        v62 = (float *)v88;
        if (v28)
        {
          v63 = 0;
          v84 = v28;
          do
          {
            v64 = 1;
            v65 = v86;
            *(_QWORD *)&v88 = v62;
            v66 = v28;
            v67 = v83;
            v68 = v85;
            do
            {
              *v62 = (float)(*v62 * 1.4142) * cosf(*((float *)v67 + v63) * (float)v64);
              v69 = sinf(-(float)((float)(int)v66 * *((float *)v67 + v63)));
              v29 = v90;
              *(float *)(v68 + 4 * (v63 + v65)) = (float)(*(float *)(v68 + 4 * (v63 + v65)) * 1.4142) * v69;
              v62 = (float *)((char *)v62 + v29);
              ++v64;
              v65 += v6;
              v66 = (HOA *)((char *)v66 - 1);
            }
            while (v66);
            ++v63;
            v62 = (float *)(v88 + 4);
            v11 = v89;
            v28 = v84;
          }
          while (v63 != v89);
        }
        v28 = (HOA *)((char *)v28 + 1);
        v32 = v79 + 1;
        --v82;
        v86 += v78;
        v31 = v78 + v72;
        v27 = v81 + v80;
        v30 = (v80 + 2);
        v26 = (float *)v77;
        a4 = v85;
      }
      while (v28 != v76);
    }
  }
}

void HOA::createEncoder(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const float *v5;
  unint64_t v7;
  const float *v8;
  unint64_t v11;
  uint64_t v12;
  float *v13;
  float *v14;
  unint64_t v15;
  float *v16;
  unint64_t v17;
  BOOL v18;
  unint64_t v19;
  NSObject *v20;
  const char *v21;
  int v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 28))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return;
    v22 = 136315906;
    v23 = "HOA.cpp";
    v24 = 1024;
    v25 = 834;
    v26 = 2080;
    v27 = "createEncoder";
    v28 = 1024;
    v29 = 834;
    v20 = MEMORY[0x1E0C81028];
    v21 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized";
LABEL_10:
    _os_log_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&v22, 0x22u);
    return;
  }
  v5 = *(const float **)a2;
  v7 = *(_QWORD *)(a2 + 8) - (_QWORD)v5;
  v8 = *(const float **)a3;
  if ((uint64_t)v7 >> 2 != (uint64_t)(*(_QWORD *)(a3 + 8) - (_QWORD)v8) >> 2)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return;
    v22 = 136315906;
    v23 = "HOA.cpp";
    v24 = 1024;
    v25 = 839;
    v26 = 2080;
    v27 = "createEncoder";
    v28 = 1024;
    v29 = 839;
    v20 = MEMORY[0x1E0C81028];
    v21 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Inconsistent azimuth/elevation size";
    goto LABEL_10;
  }
  v11 = v7 >> 2;
  v14 = *(float **)(a1 + 32);
  v12 = a1 + 32;
  v13 = v14;
  *(_DWORD *)(v12 - 16) = v7 >> 2;
  v15 = *(_DWORD *)(v12 - 20) * (v7 >> 2);
  v16 = *(float **)(v12 + 8);
  v17 = v16 - v14;
  v18 = v15 >= v17;
  v19 = v15 - v17;
  if (v19 != 0 && v18)
  {
    std::vector<float>::__append((char **)v12, v19);
    v5 = *(const float **)a2;
    v8 = *(const float **)a3;
    LODWORD(v11) = *(_DWORD *)(a1 + 16);
    v13 = *(float **)(a1 + 32);
    v16 = *(float **)(a1 + 40);
  }
  else if (!v18)
  {
    v16 = &v13[v15];
    *(_QWORD *)(a1 + 40) = v16;
  }
  HOA::createEncoder((HOA *)a1, v5, v8, v11, v13, v16 - v13);
}

uint64_t HOA::createDecoder(unsigned int *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;
  uint64_t v7;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  NSObject *v14;
  const char *v15;
  uint64_t v16;
  vDSP_Length v18;
  uint64_t v19;
  unint64_t v20;
  void **v21;
  unint64_t v22;
  int32x2_t v23;
  uint64_t v24;
  const float *v25;
  int64_t v26;
  char *v27;
  uint64_t v28;
  int32x4_t *v29;
  uint64_t v30;
  int32x4_t v31;
  int32x4_t *v32;
  uint64_t v33;
  uint64_t v34;
  const float *v35;
  int64_t v36;
  char *v37;
  char *v38;
  char *v39;
  void *v40;
  char *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  size_t v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  float *v52;
  float v53;
  __float2 v54;
  __float2 v55;
  vDSP_Length __P;
  char *v57;
  char *v58;
  const float *v59;
  const float *v60;
  int64_t v61;
  char *v62;
  uint64_t i;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  size_t v68;
  size_t v69;
  char *v70;
  char *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t k;
  void *v76;
  unsigned int v77;
  float v78;
  HOA *v79;
  unsigned int v80;
  void *v81;
  uint64_t j;
  uint64_t v83;
  float v84;
  float v85;
  uint64_t v86;
  size_t v87;
  char *v88;
  char *v89;
  uint64_t v90;
  vDSP_Length v91;
  unint64_t v92;
  unint64_t v93;
  const float *v94;
  float *v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  char *v100;
  float *v101;
  float *__C;
  void *v103;
  float *v104;
  char *v105;
  float *v106;
  float __A;
  void *__p;
  char *v109;
  char *v110;
  char *v111;
  char *v112;
  char *v113;
  char *v114;
  char *v115;
  char *v116;
  float __B;
  uint8_t buf[48];
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  _BYTE v136[28];
  __int16 v137;
  int v138;
  uint64_t v139;

  v139 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)a1 + 28))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return 4294967246;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "HOA.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 948;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = "createDecoder";
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 948;
    v14 = MEMORY[0x1E0C81028];
    v15 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized";
LABEL_12:
    _os_log_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_ERROR, v15, buf, 0x22u);
    return 4294967246;
  }
  v5 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  if (!v5)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return 4294967246;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "HOA.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 953;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = "createDecoder";
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 953;
    v14 = MEMORY[0x1E0C81028];
    v15 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Empty azimuth/elevation";
    goto LABEL_12;
  }
  v7 = v5 >> 2;
  if (v7 != (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "HOA.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 958;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = "createDecoder";
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 958;
      v14 = MEMORY[0x1E0C81028];
      v15 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Inconsistent azimuth/elevation size";
      goto LABEL_12;
    }
    return 4294967246;
  }
  v12 = *((_QWORD *)a1 + 16);
  v10 = a1 + 32;
  v11 = v12;
  *(v10 - 27) = v7;
  v13 = (*((_QWORD *)v10 + 1) - v12) >> 2;
  if (v7 <= v13)
  {
    if (v7 < v13)
      *((_QWORD *)a1 + 17) = v11 + 4 * v7;
  }
  else
  {
    std::vector<float>::__append((char **)v10, v7 - v13);
    LODWORD(v7) = a1[5];
  }
  v18 = v7;
  v19 = *((_QWORD *)a1 + 19);
  v20 = (*((_QWORD *)a1 + 20) - v19) >> 2;
  if (v18 <= v20)
  {
    if (v18 < v20)
      *((_QWORD *)a1 + 20) = v19 + 4 * v18;
  }
  else
  {
    std::vector<float>::__append((char **)a1 + 19, v18 - v20);
    v18 = a1[5];
  }
  vDSP_vsmul(*(const float **)a2, 1, &kDeg2Radf, *((float **)a1 + 16), 1, v18);
  vDSP_vsmul(*(const float **)a3, 1, &kDeg2Radf, *((float **)a1 + 19), 1, a1[5]);
  v21 = (void **)(a1 + 14);
  v22 = a1[2] * a1[5];
  *(_DWORD *)buf = 0;
  std::vector<float>::assign((char **)a1 + 7, v22, buf);
  if (!*a1)
  {
    v28 = a1[5];
    if ((_DWORD)v28)
    {
      *(float *)v23.i32 = 1.0 / sqrtf((float)v28);
      v29 = (int32x4_t *)*v21;
      if (v28 >= 8)
      {
        v30 = v28 & 0xFFFFFFF8;
        v31 = vdupq_lane_s32(v23, 0);
        v32 = v29 + 1;
        v33 = v30;
        do
        {
          v32[-1] = v31;
          *v32 = v31;
          v32 += 2;
          v33 -= 8;
        }
        while (v33);
        if (v30 == v28)
        {
          LODWORD(v28) = 0;
          goto LABEL_141;
        }
        LODWORD(v28) = v28 - v30;
        v29 = (int32x4_t *)((char *)v29 + 4 * v30);
      }
      do
      {
        v29->i32[0] = v23.i32[0];
        v29 = (int32x4_t *)((char *)v29 + 4);
        LODWORD(v28) = v28 - 1;
      }
      while ((_DWORD)v28);
    }
LABEL_141:
    v16 = 0;
LABEL_142:
    if (a1[1] != (_DWORD)v28)
    {
      v96 = a1[5] * a1[3];
      *(_DWORD *)buf = 0;
      v97 = *((_QWORD *)a1 + 7);
      v98 = (*((_QWORD *)a1 + 8) - v97) >> 2;
      if (v96 <= v98)
      {
        if (v96 < v98)
          *((_QWORD *)a1 + 8) = v97 + 4 * v96;
      }
      else
      {
        std::vector<float>::__append(v21, v96 - v98, buf);
      }
    }
    return v16;
  }
  v134 = 0u;
  v135 = 0u;
  v132 = 0u;
  v133 = 0u;
  v130 = 0u;
  v131 = 0u;
  v128 = 0u;
  v129 = 0u;
  v126 = 0u;
  v127 = 0u;
  v124 = 0u;
  v125 = 0u;
  v122 = 0u;
  v123 = 0u;
  v120 = 0u;
  v121 = 0u;
  v119 = 0u;
  memset(buf, 0, sizeof(buf));
  v114 = 0;
  v115 = 0;
  v116 = 0;
  v25 = *(const float **)a2;
  v24 = *(_QWORD *)(a2 + 8);
  v26 = v24 - *(_QWORD *)a2;
  if (v24 == *(_QWORD *)a2)
  {
    v27 = 0;
  }
  else
  {
    if (v26 < 0)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v27 = (char *)operator new(v24 - *(_QWORD *)a2);
    v114 = v27;
    v116 = &v27[4 * (v26 >> 2)];
    memcpy(v27, v25, v26);
    v115 = v116;
  }
  v111 = 0;
  v112 = 0;
  v113 = 0;
  v35 = *(const float **)a3;
  v34 = *(_QWORD *)(a3 + 8);
  v36 = v34 - *(_QWORD *)a3;
  if (v34 == *(_QWORD *)a3)
  {
    v37 = 0;
  }
  else
  {
    if (v36 < 0)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v37 = (char *)operator new(v34 - *(_QWORD *)a3);
    v111 = v37;
    v113 = &v37[4 * (v36 >> 2)];
    memcpy(v37, v35, v36);
    v112 = v113;
  }
  memset(v136, 0, 24);
  __p = 0;
  v109 = 0;
  v110 = 0;
  VBAP::VBAP((uint64_t)buf, (uint64_t *)&v114, (uint64_t *)&v111, 1, (uint64_t)v136, &__p);
  v38 = (char *)__p;
  if (__p)
  {
    v39 = v109;
    v40 = __p;
    if (v109 != __p)
    {
      do
      {
        v41 = v39 - 24;
        if (*((_QWORD *)v39 - 1))
        {
          v43 = *((_QWORD *)v39 - 3);
          v42 = (uint64_t *)*((_QWORD *)v39 - 2);
          v44 = *v42;
          *(_QWORD *)(v44 + 8) = *(_QWORD *)(v43 + 8);
          **(_QWORD **)(v43 + 8) = v44;
          *((_QWORD *)v39 - 1) = 0;
          if (v42 != (uint64_t *)v41)
          {
            do
            {
              v45 = (char *)v42[1];
              operator delete(v42);
              v42 = (uint64_t *)v45;
            }
            while (v45 != v41);
          }
        }
        v39 = v41;
      }
      while (v41 != v38);
      v40 = __p;
    }
    v109 = v38;
    operator delete(v40);
  }
  if (*(_QWORD *)v136)
  {
    *(_QWORD *)&v136[8] = *(_QWORD *)v136;
    operator delete(*(void **)v136);
  }
  if (v37)
  {
    v112 = v37;
    operator delete(v37);
  }
  if (v27)
  {
    v115 = v27;
    operator delete(v27);
  }
  if (BYTE11(v135))
  {
    if (216 * a1[2])
    {
      v46 = 864 * a1[2];
      v47 = (char *)operator new(v46);
      bzero(v47, v46);
    }
    else
    {
      v47 = 0;
    }
    v48 = (char *)operator new(0x360uLL);
    bzero(v48, 0x360uLL);
    v49 = (char *)operator new(0x360uLL);
    bzero(v49, 0x360uLL);
    v103 = v49;
    v106 = (float *)operator new(0xA20uLL);
    bzero(v106, 0xA20uLL);
    memcpy(v48, &unk_1B668B1A8, 0x360uLL);
    memcpy(v49, &unk_1B668B508, 0x360uLL);
    vDSP_vsmul((const float *)v48, 1, &kDeg2Radf, (float *)v48, 1, 0xD8uLL);
    vDSP_vsmul((const float *)v49, 1, &kDeg2Radf, (float *)v49, 1, 0xD8uLL);
    HOA::sphericalHarmonics((HOA *)v48, (const float *)v49, (const float *)0xD8, (uint64_t)v47, (float *)*a1);
    v50 = v49;
    v51 = 0;
    v52 = v106 + 2;
    do
    {
      v53 = *(float *)&v48[v51];
      v54 = __sincosf_stret(*(float *)&v50[v51]);
      v55 = __sincosf_stret(v53);
      *(v52 - 2) = v54.__cosval * v55.__cosval;
      *(v52 - 1) = v54.__cosval * v55.__sinval;
      *v52 = v54.__sinval;
      v52 += 3;
      v51 += 4;
    }
    while (v51 != 864);
    if (a1[76] == 2)
    {
      __P = a1[2];
      if (216 * (_DWORD)__P)
      {
        v57 = (char *)operator new(4 * (216 * __P));
        bzero(v57, 4 * (216 * __P));
        v58 = &v57[4 * (216 * __P)];
      }
      else
      {
        v57 = 0;
        v58 = 0;
      }
      vDSP_mmul(*((const float **)a1 + 46), 1, (const float *)v47, 1, (float *)v57, 1, __P, 0xD8uLL, __P);
      if (v58 != v57)
        memcpy(v47, v57, v58 - v57);
      if (v57)
        operator delete(v57);
    }
    __A = 0.0046296;
    v60 = (const float *)*((_QWORD *)a1 + 10);
    v59 = (const float *)*((_QWORD *)a1 + 11);
    v109 = 0;
    v110 = 0;
    __p = 0;
    v61 = (char *)v59 - (char *)v60;
    if (v59 == v60)
    {
      v62 = 0;
    }
    else
    {
      if (v61 < 0)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v62 = (char *)operator new((char *)v59 - (char *)v60);
      __p = v62;
      v110 = &v62[4 * (v61 >> 2)];
      bzero(v62, v61);
      v109 = &v62[v61];
    }
    vDSP_svdiv(&__A, v60, 1, (float *)v62, 1, a1[2]);
    for (i = 0; i != 864; i += 4)
      vDSP_vmul((const float *)__p, 1, (const float *)&v47[i], 216, (float *)&v47[i], 216, a1[2]);
    if (a4 == 1)
    {
      v64 = a1[2];
      v65 = (216 * v64);
      v100 = v48;
      v101 = (float *)v47;
      if ((_DWORD)v65)
      {
        v66 = (char *)operator new(4 * v65);
        bzero(v66, 4 * v65);
        __C = (float *)operator new(4 * v65);
        bzero(__C, 4 * v65);
      }
      else
      {
        v66 = 0;
        __C = 0;
      }
      v105 = (char *)operator new(0x2D900uLL);
      bzero(v105, 0x2D900uLL);
      if (216 * a1[5])
      {
        v69 = 864 * a1[5];
        v70 = (char *)operator new(v69);
        bzero(v70, v69);
        v104 = (float *)v70;
        v71 = &v70[v69];
      }
      else
      {
        v104 = 0;
        v71 = 0;
      }
      if ((_DWORD)v65)
        memcpy(v66, v47, 4 * v65);
      if ((_DWORD)v64)
      {
        v76 = operator new(4 * v64);
        bzero(v76, 4 * v64);
      }
      else
      {
        v76 = 0;
      }
      v77 = *a1;
      v78 = cosf(2.4068 / (float)((float)*a1 + 1.51));
      v79 = 0;
      v80 = 1;
      do
      {
        *(_DWORD *)v136 = HOA::legendre(v79, 0, v78);
        vDSP_vfill((const float *)v136, (float *)v76 + ((_DWORD)v79 * (_DWORD)v79), 1, v80);
        v79 = (HOA *)((_DWORD)v79 + 1);
        v80 += 2;
      }
      while (v79 <= v77);
      v81 = v105;
      vDSP_vmul((const float *)v76, 1, *((const float **)a1 + 10), 1, (float *)v76, 1, a1[2]);
      vDSP_vmul((const float *)v76, 1, *((const float **)a1 + 10), 1, (float *)v76, 1, a1[2]);
      for (j = 0; j != 864; j += 4)
        vDSP_vmul((const float *)v76, 1, (const float *)&v66[j], 216, (float *)&v66[j], 216, a1[2]);
      vDSP_mtrans((const float *)v66, 1, __C, 1, 0xD8uLL, a1[2]);
      vDSP_mmul(__C, 1, (const float *)v47, 1, (float *)v105, 1, 0xD8uLL, 0xD8uLL, a1[2]);
      vDSP_vsq((const float *)v105, 1, (float *)v105, 1, 0xB640uLL);
      v83 = 0;
      __B = 0.0;
      do
      {
        *(_DWORD *)v136 = 0;
        vDSP_sve((const float *)&v105[v83], 216, (float *)v136, 0xD8uLL);
        v84 = __B;
        if (*(float *)v136 > __B)
        {
          __B = *(float *)v136;
          v84 = *(float *)v136;
        }
        v83 += 4;
      }
      while (v83 != 864);
      if (v84 == 0.0)
        v85 = 1.0;
      else
        v85 = 1.0 / v84;
      __B = v85;
      vDSP_vsmul((const float *)v105, 1, &__B, (float *)v105, 1, 0xB640uLL);
      vDSP_vclr(v104, 1, (v71 - (char *)v104) >> 2);
      v99 = v71 - (char *)v104;
      v86 = a1[5];
      if ((_DWORD)v86)
      {
        v87 = 4 * v86;
        v88 = (char *)operator new(4 * v86);
        bzero(v88, v87);
        v89 = &v88[v87];
      }
      else
      {
        v88 = 0;
        v89 = 0;
      }
      v90 = 0;
      v91 = (v89 - v88) >> 2;
      while (1)
      {
        v16 = VBAP::calculateVBAPGains((VBAP *)buf, (float32x2_t *)&v106[3 * v90], (float *)v88);
        if ((_DWORD)v16)
          break;
        vDSP_vsq((const float *)v88, 1, (float *)v88, 1, v91);
        v92 = a1[5];
        if ((_DWORD)v92)
        {
          v93 = 0;
          v94 = (const float *)v88;
          v95 = v104;
          do
          {
            vDSP_vsma((const float *)&v105[4 * v90], 216, v94, v95, v92, v95, v92, 0xD8uLL);
            ++v93;
            v92 = a1[5];
            ++v95;
            ++v94;
          }
          while (v93 < v92);
        }
        ++v90;
        v81 = v105;
        if (v90 == 216)
        {
          *(_DWORD *)v136 = v99 >> 2;
          vvsqrtf(v104, v104, (const int *)v136);
          vDSP_mmul(v101, 1, v104, 1, *((float **)a1 + 7), 1, a1[2], a1[5], 0xD8uLL);
          v16 = 0;
          goto LABEL_124;
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v136 = 136315906;
        *(_QWORD *)&v136[4] = "HOA.cpp";
        *(_WORD *)&v136[12] = 1024;
        *(_DWORD *)&v136[14] = 924;
        *(_WORD *)&v136[18] = 2080;
        *(_QWORD *)&v136[20] = "createALLRAD2";
        v137 = 1024;
        v138 = 924;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; VBAP calculation error",
          v136,
          0x22u);
      }
LABEL_124:
      if (v88)
        operator delete(v88);
      if (v76)
        operator delete(v76);
      v21 = (void **)(a1 + 14);
      v47 = (char *)v101;
      if (v104)
        operator delete(v104);
      operator delete(v81);
      v48 = v100;
      if (__C)
        operator delete(__C);
    }
    else
    {
      vDSP_vclr(*((float **)a1 + 7), 1, a1[2] * a1[5]);
      v67 = a1[5];
      if ((_DWORD)v67)
      {
        v68 = 4 * v67;
        v66 = (char *)operator new(4 * v67);
        bzero(v66, v68);
      }
      else
      {
        v66 = 0;
      }
      v72 = 0;
      while (1)
      {
        v16 = VBAP::calculateVBAPGains((VBAP *)buf, (float32x2_t *)&v106[3 * v72], (float *)v66);
        if ((_DWORD)v16)
          break;
        v73 = a1[5];
        if ((_DWORD)v73)
        {
          v74 = 0;
          for (k = 0; k < v73; ++k)
          {
            vDSP_vsma((const float *)&v47[4 * v72], 216, (const float *)&v66[v74], (const float *)(*((_QWORD *)a1 + 7) + v74), v73, (float *)(*((_QWORD *)a1 + 7) + v74), v73, a1[2]);
            v73 = a1[5];
            v74 += 4;
          }
        }
        if (++v72 == 216)
        {
          v16 = 0;
          goto LABEL_132;
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v136 = 136315906;
        *(_QWORD *)&v136[4] = "HOA.cpp";
        *(_WORD *)&v136[12] = 1024;
        *(_DWORD *)&v136[14] = 863;
        *(_WORD *)&v136[18] = 2080;
        *(_QWORD *)&v136[20] = "createALLRAD";
        v137 = 1024;
        v138 = 863;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; VBAP calculation error",
          v136,
          0x22u);
      }
    }
LABEL_132:
    if (v66)
      operator delete(v66);
    if (__p)
      operator delete(__p);
    operator delete(v106);
    operator delete(v103);
    operator delete(v48);
    if (v47)
      operator delete(v47);
    VBAP::~VBAP((VBAP *)buf);
    LODWORD(v28) = *a1;
    goto LABEL_142;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v136 = 136315906;
    *(_QWORD *)&v136[4] = "HOA.cpp";
    *(_WORD *)&v136[12] = 1024;
    *(_DWORD *)&v136[14] = 982;
    *(_WORD *)&v136[18] = 2080;
    *(_QWORD *)&v136[20] = "createDecoder";
    v137 = 1024;
    v138 = 982;
    _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; VBAP object was not initialized",
      v136,
      0x22u);
  }
  VBAP::~VBAP((VBAP *)buf);
  return 4294967246;
}

void sub_1B65B4B6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *__p, void *a18, void *a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  void *v31;
  void *v32;

  if (v32)
  {
    operator delete(v32);
    if (!__p)
    {
LABEL_4:
      operator delete(a18);
      if (a15)
        operator delete(a15);
      if (v31)
        operator delete(v31);
      if (a21)
        operator delete(a21);
      operator delete(a19);
      operator delete(a16);
      operator delete(a13);
      if (a14)
        operator delete(a14);
      VBAP::~VBAP((VBAP *)&a31);
      _Unwind_Resume(a1);
    }
  }
  else if (!__p)
  {
    goto LABEL_4;
  }
  operator delete(__p);
  goto LABEL_4;
}

void HOA::createSphericalGridDecoder(unsigned int *a1)
{
  char *v2;
  void **v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  const float *v13;
  const float *v14;
  size_t v15;
  void *v16;
  const float *v17;
  const float *v18;
  size_t v19;
  void *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t i;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  float __A;
  _BYTE buf[28];
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)a1 + 28))
  {
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)a1 + 128, *((char **)a1 + 26), *((_QWORD *)a1 + 27), (uint64_t)(*((_QWORD *)a1 + 27) - *((_QWORD *)a1 + 26)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)a1 + 152, *((char **)a1 + 29), *((_QWORD *)a1 + 30), (uint64_t)(*((_QWORD *)a1 + 30) - *((_QWORD *)a1 + 29)) >> 2);
    v3 = (void **)(a1 + 46);
    v2 = (char *)*((_QWORD *)a1 + 23);
    v4 = a1[6];
    a1[5] = v4;
    v5 = a1[2] * v4;
    v6 = (uint64_t)(*((_QWORD *)a1 + 24) - (_QWORD)v2) >> 2;
    if (v5 <= v6)
    {
      if (v5 < v6)
        *((_QWORD *)a1 + 24) = &v2[4 * v5];
    }
    else
    {
      std::vector<float>::__append((char **)a1 + 23, v5 - v6);
      v2 = (char *)*v3;
    }
    HOA::sphericalHarmonics(*((HOA **)a1 + 26), *((const float **)a1 + 29), (const float *)((uint64_t)(*((_QWORD *)a1 + 27) - *((_QWORD *)a1 + 26)) >> 2), (uint64_t)v2, (float *)*a1);
    if (a1[44] - 1 <= 1)
    {
      LODWORD(v7) = a1[5];
      if ((_DWORD)v7)
      {
        v8 = 0;
        v9 = 0;
        do
        {
          vDSP_vmul(*((const float **)a1 + 32), 1, (const float *)(*((_QWORD *)a1 + 23) + v8), v7, (float *)(*((_QWORD *)a1 + 23) + v8), v7, v7);
          ++v9;
          v7 = a1[5];
          v8 += 4;
        }
        while (v9 < v7);
      }
      *(float *)buf = (float)v7 * 0.079577;
      vDSP_vsmul(*((const float **)a1 + 23), 1, (const float *)buf, *((float **)a1 + 23), 1, (uint64_t)(*((_QWORD *)a1 + 24) - *((_QWORD *)a1 + 23)) >> 2);
    }
    v10 = *((_QWORD *)a1 + 7);
    v11 = (uint64_t)(*((_QWORD *)a1 + 24) - *((_QWORD *)a1 + 23)) >> 2;
    v12 = (*((_QWORD *)a1 + 8) - v10) >> 2;
    if (v11 <= v12)
    {
      if (v11 < v12)
        *((_QWORD *)a1 + 8) = v10 + 4 * v11;
    }
    else
    {
      std::vector<float>::__append((char **)a1 + 7, v11 - v12);
    }
    if (a1[76] == 2)
    {
      v14 = (const float *)*((_QWORD *)a1 + 23);
      v13 = (const float *)*((_QWORD *)a1 + 24);
      memset(buf, 0, 24);
      v15 = (char *)v13 - (char *)v14;
      if (v13 == v14)
      {
        v16 = 0;
      }
      else
      {
        if ((v15 & 0x8000000000000000) != 0)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v16 = operator new((char *)v13 - (char *)v14);
        bzero(v16, v15);
        v15 += (size_t)v16;
      }
      vDSP_mmul(*((const float **)a1 + 46), 1, v14, 1, (float *)v16, 1, a1[2], a1[6], a1[2]);
      if ((void *)v15 != v16)
        memmove(*v3, v16, v15 - (_QWORD)v16);
      if (v16)
        operator delete(v16);
    }
    __A = 1.0 / (float)a1[6];
    v18 = (const float *)*((_QWORD *)a1 + 10);
    v17 = (const float *)*((_QWORD *)a1 + 11);
    memset(buf, 0, 24);
    v19 = (char *)v17 - (char *)v18;
    if (v17 == v18)
    {
      v20 = 0;
    }
    else
    {
      if ((v19 & 0x8000000000000000) != 0)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v20 = operator new((char *)v17 - (char *)v18);
      bzero(v20, v19);
    }
    vDSP_svdiv(&__A, v18, 1, (float *)v20, 1, a1[2]);
    v21 = a1[6];
    if ((_DWORD)v21)
    {
      v22 = 0;
      for (i = 0; i < v21; ++i)
      {
        vDSP_vmul((const float *)v20, 1, (const float *)(*((_QWORD *)a1 + 23) + v22), v21, (float *)(*((_QWORD *)a1 + 7) + v22), v21, a1[2]);
        v21 = a1[6];
        v22 += 4;
      }
    }
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)a1 + 184, *((char **)a1 + 7), *((_QWORD *)a1 + 8), (uint64_t)(*((_QWORD *)a1 + 8) - *((_QWORD *)a1 + 7)) >> 2);
    if (a1[1] != *a1)
    {
      v24 = a1[6] * a1[3];
      v27 = 0;
      v25 = *((_QWORD *)a1 + 7);
      v26 = (*((_QWORD *)a1 + 8) - v25) >> 2;
      if (v24 <= v26)
      {
        if (v24 < v26)
          *((_QWORD *)a1 + 8) = v25 + 4 * v24;
      }
      else
      {
        std::vector<float>::__append((void **)a1 + 7, v24 - v26, &v27);
      }
    }
    if (v20)
      operator delete(v20);
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "HOA.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1051;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = "createSphericalGridDecoder";
    v30 = 1024;
    v31 = 1051;
    _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized",
      buf,
      0x22u);
  }
}

void sub_1B65B5190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  void *v12;

  if (!v12)
    _Unwind_Resume(exception_object);
  operator delete(v12);
  _Unwind_Resume(exception_object);
}

void KaiserWindow::KaiserWindow(KaiserWindow *this, int a2, double a3)
{
  _DWORD *v6;
  size_t v7;
  double v8;
  double v9;
  uint64_t *v10;
  uint64_t *v11;
  double v12;
  double v13;
  double v14;
  long double v15;
  uint64_t v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  long double v22;
  double v23;
  float v24;
  double v25;
  double v26;
  double v27;
  double v28;

  v6 = 0;
  *(_DWORD *)this = a2;
  *((double *)this + 1) = a3;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  if (a2 != -1)
  {
    v7 = (a2 + 1);
    v6 = operator new(v7 * 4);
    *((_QWORD *)this + 2) = v6;
    *((_QWORD *)this + 4) = &v6[v7];
    bzero(v6, v7 * 4);
    *((_QWORD *)this + 3) = &v6[v7];
  }
  if (a3 >= 50.0)
  {
    v8 = a3 * 0.1102 + -0.95874;
  }
  else
  {
    v8 = 0.0;
    if (a3 > 21.0)
      v8 = (a3 + -21.0) * 0.07886 + pow(a3 + -21.0, 0.4) * 0.5842;
  }
  v9 = fabs(v8);
  v10 = &qword_1B662D000;
  v11 = &qword_1B662D000;
  v28 = v8;
  if (v9 >= 3.75)
  {
    v14 = 3.75 / v9;
    v15 = exp(v9);
    v11 = &qword_1B662D000;
    v10 = &qword_1B662D000;
    v8 = v28;
    v13 = ((((((((v14 * 0.00392377 + -0.01647633) * v14 + 0.02635537) * v14 + -0.02057706) * v14 + 0.00916281) * v14
            + -0.00157565)
           * v14
           + 0.00225319)
          * v14
          + 0.01328592)
         * v14
         + 0.39894228)
        * v15
        / sqrt(v9);
    if (!a2)
      goto LABEL_16;
  }
  else
  {
    v12 = v8 * 0.266666667 * (v8 * 0.266666667);
    v13 = (((((v12 * 0.0045813 + 0.0360768) * v12 + 0.2659732) * v12 + 1.2067492) * v12 + 3.0899424) * v12 + 3.5156229)
        * v12
        + 1.0;
    if (!a2)
      goto LABEL_16;
  }
  v16 = 0;
  v17 = -1.0;
  v18 = *((double *)v10 + 436);
  v19 = *((double *)v11 + 437);
  v20 = 1.0 / v13;
  do
  {
    v25 = sqrt(-(v17
               + ((double)v16 - (double)((a2 - 1) >> 1))
               * (1.0
                / (double)((a2 - 1) >> 1))
               * (((double)v16 - (double)((a2 - 1) >> 1))
                * (1.0
                 / (double)((a2 - 1) >> 1)))))
        * v8;
    v26 = fabs(v25);
    if (v26 >= 3.75)
    {
      v22 = exp(v26);
      v17 = -1.0;
      v8 = v28;
      v21 = 3.75 / v26;
      v23 = (v19
           + (v18
            + ((((((v21 * 0.00392377 + -0.01647633) * v21 + 0.02635537) * v21 + -0.02057706) * v21 + 0.00916281) * v21
              + -0.00157565)
             * v21
             + 0.00225319)
            * v21)
           * v21)
          * v22
          / sqrt(v26);
    }
    else
    {
      v27 = v25 * 0.266666667 * (v25 * 0.266666667);
      v23 = (((((v27 * 0.0045813 + 0.0360768) * v27 + 0.2659732) * v27 + 1.2067492) * v27 + 3.0899424) * v27 + 3.5156229)
          * v27
          + 1.0;
    }
    v24 = v23 * v20;
    *(float *)&v6[++v16] = v24;
  }
  while (a2 != v16);
LABEL_16:
  *v6 = 0;
}

uint64_t std::__split_buffer<KaiserWindow>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      while (1)
      {
        v4 = v2 - 40;
        *(_QWORD *)(a1 + 16) = v2 - 40;
        v5 = *(void **)(v2 - 24);
        if (!v5)
          break;
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
        v2 = *(_QWORD *)(a1 + 16);
        if (v2 == v3)
          goto LABEL_6;
      }
      v2 -= 40;
    }
    while (v4 != v3);
  }
LABEL_6:
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<KaiserWindow>,std::reverse_iterator<KaiserWindow*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    while (v3 != v4)
    {
      v5 = *(void **)(v3 + 16);
      if (v5)
      {
        *(_QWORD *)(v3 + 24) = v5;
        operator delete(v5);
      }
      v3 += 40;
    }
  }
  return a1;
}

uint64_t Biquad_8dot24::CreateProcessProcForFormats(Biquad_8dot24 *this, const CAStreamBasicDescription *a2, const CAStreamBasicDescription *a3)
{
  BOOL v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v19;

  v3 = *((_DWORD *)this + 2) == 1819304813 && *((_DWORD *)this + 5) == 1;
  if (!v3)
    goto LABEL_8;
  v4 = *((_DWORD *)this + 6);
  if (v4 != *((_DWORD *)this + 4))
    goto LABEL_8;
  v5 = *((_DWORD *)this + 8);
  if (v4 < v5 >> 3)
    goto LABEL_8;
  v6 = *((_DWORD *)this + 7);
  if (!v6)
    goto LABEL_9;
  v14 = *((_DWORD *)this + 3);
  if ((v14 & 0x20) == 0)
  {
    v3 = v4 == v4 / v6 * v6;
    v4 /= v6;
    if (!v3)
    {
LABEL_8:
      v6 = 0;
LABEL_9:
      v7 = 1;
      goto LABEL_10;
    }
  }
  v6 = 0;
  if ((v14 & 2) != 0)
  {
    v7 = 0;
  }
  else
  {
    v7 = 0;
    if (8 * v4 == v5)
    {
      if ((v14 & 1) != 0)
      {
        v15 = 4 * (v4 == 8);
        if (v4 == 4)
          v15 = 1;
        if ((v14 & 0x1F84) != 0)
          v6 = 0;
        else
          v6 = v15;
        v7 = (*((_DWORD *)this + 3) & 0x1F84) != 0;
      }
      else if ((v14 & 4) != 0)
      {
        v17 = (v14 >> 7) & 0x3F;
        if (v17 == 24 && v4 == 4)
        {
          v7 = 0;
          v6 = 3;
        }
        else if (v17 || v4 != 4)
        {
          v7 = 0;
          if (v4 == 2 && v17 == 0)
            v6 = 2;
          else
            v6 = 0;
        }
        else
        {
          v7 = 0;
          v6 = 5;
        }
      }
      else
      {
        v6 = 0;
        v7 = 0;
      }
    }
  }
LABEL_10:
  if (*((_DWORD *)a2 + 2) != 1819304813 || *((_DWORD *)a2 + 5) != 1)
    return 0;
  v9 = *((_DWORD *)a2 + 6);
  if (v9 != *((_DWORD *)a2 + 4))
    return 0;
  v10 = *((_DWORD *)a2 + 8);
  if (v9 < v10 >> 3)
    return 0;
  v11 = *((_DWORD *)a2 + 7);
  if (!v11)
    return 0;
  v12 = *((_DWORD *)a2 + 3);
  if ((v12 & 0x20) == 0)
  {
    v3 = v9 == v9 / v11 * v11;
    v9 /= v11;
    if (!v3)
      return 0;
  }
  v13 = 0;
  if ((v12 & 2) == 0 && 8 * v9 == v10)
  {
    if ((v12 & 1) != 0)
    {
      if ((v12 & 0x1F84) != 0)
        return 0;
      v13 = 4 * (v9 == 8);
      if (v9 == 4)
        v13 = 1;
    }
    else if ((v12 & 4) != 0)
    {
      v16 = (v12 >> 7) & 0x3F;
      if (v16 == 24 && v9 == 4)
      {
        v13 = 3;
      }
      else if (v16 || v9 != 4)
      {
        if (v9 == 2 && v16 == 0)
          v13 = 2;
        else
          v13 = 0;
      }
      else
      {
        v13 = 5;
      }
    }
    else
    {
      v13 = 0;
    }
  }
  if (v7 || *(double *)this != *(double *)a2)
    return 0;
  v19 = *((_DWORD *)this + 7);
  if (v19 != 1)
  {
    if (v19 == 2 && v11 == 2)
    {
      if ((*((_BYTE *)this + 12) & 0x20) != 0)
      {
        if (v6 == 3 && v13 == 3 && (v12 & 0x20) != 0)
          return 2;
        return 0;
      }
      if ((v12 & 0x20) != 0)
      {
        if (v6 == 2 && v13 == 3)
          return 3;
        return 0;
      }
      if (v6 != 2)
        return v6 == 3 && v13 == 3;
      if (v13 != 2)
        return v13 == 3;
      return 1;
    }
    return 0;
  }
  if (v11 == 2)
  {
    if ((v12 & 0x20) == 0)
    {
      if (v6 == 3)
      {
        if (v13 == 3)
          return 1;
      }
      else if (v6 == 2 && v13 == 2)
      {
        return 1;
      }
    }
    return 0;
  }
  if (v11 != 1)
    return 0;
  if (v6 != 2)
    return v6 == 3 && v13 == 3;
  if (v13 != 2)
    return v13 == 3;
  return 1;
}

__int16 *Biquad_8dot24::Process16mTo824m(__int16 *result, int *a2, unsigned int a3, int *a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v4 = a4[5];
  v5 = a4[7];
  v6 = a4[9];
  v7 = a4[11];
  if (a3)
  {
    v9 = *a4;
    v8 = a4[1];
    v11 = a4[3];
    v10 = a4[4];
    v12 = a3;
    v13 = a4[2];
    do
    {
      v14 = v4;
      v15 = v6;
      v16 = v11 * (uint64_t)v4;
      v17 = *result++;
      v4 = v17 << 9;
      v18 = v16 + v10 * (uint64_t)v5 + v9 * (uint64_t)v15 + v8 * (uint64_t)v7 + (v17 << 9) * (uint64_t)v13;
      if (v18 < 0)
        v6 = -(int)((unint64_t)-v18 >> 24);
      else
        v6 = (unint64_t)v18 >> 24;
      *a2++ = v6;
      v7 = v15;
      v5 = v14;
      --v12;
    }
    while (v12);
  }
  else
  {
    v14 = a4[7];
    v15 = a4[11];
  }
  a4[5] = v4;
  a4[7] = v14;
  a4[9] = v6;
  a4[11] = v15;
  return result;
}

uint64_t Biquad_8dot24::Process16sInterleavedTo824sInterleaved(uint64_t result, uint64_t a2, int a3, int *a4)
{
  unint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t i;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;

  v4 = (2 * a3);
  v5 = a4[2];
  v6 = a4[3];
  v7 = *a4;
  v8 = a4[1];
  v9 = a4[5];
  v10 = a4[4];
  v11 = a4[7];
  v12 = a4[9];
  v13 = a4[11];
  if ((_DWORD)v4)
  {
    for (i = 0; i < v4; i += 2)
    {
      v15 = v9;
      v16 = v12;
      v17 = v6 * (uint64_t)v9;
      v9 = *(__int16 *)(result + 2 * i) << 9;
      v18 = v17 + v10 * (uint64_t)v11 + v7 * (uint64_t)v16 + v8 * (uint64_t)v13 + v9 * (uint64_t)v5;
      if (v18 < 0)
        v12 = -(int)((unint64_t)-v18 >> 24);
      else
        v12 = (unint64_t)v18 >> 24;
      *(_DWORD *)(a2 + 4 * i) = v12;
      v13 = v16;
      v11 = v15;
    }
  }
  else
  {
    v15 = a4[7];
    v16 = a4[11];
  }
  a4[5] = v9;
  a4[7] = v15;
  a4[9] = v12;
  a4[11] = v16;
  v19 = a4[6];
  v20 = a4[8];
  v21 = a4[10];
  v22 = a4[12];
  if ((_DWORD)v4)
  {
    v23 = 1;
    do
    {
      v24 = v19;
      v25 = v21;
      v26 = v6 * (uint64_t)v19;
      v19 = *(__int16 *)(result + 2 * v23) << 9;
      v27 = v26 + v10 * (uint64_t)v20 + v7 * (uint64_t)v25 + v8 * (uint64_t)v22 + v19 * (uint64_t)v5;
      if (v27 < 0)
        v21 = -(int)((unint64_t)-v27 >> 24);
      else
        v21 = (unint64_t)v27 >> 24;
      *(_DWORD *)(a2 + 4 * v23) = v21;
      v23 += 2;
      v22 = v25;
      v20 = v24;
    }
    while (v23 < v4);
  }
  else
  {
    v24 = a4[8];
    v25 = a4[12];
  }
  a4[6] = v19;
  a4[8] = v24;
  a4[10] = v21;
  a4[12] = v25;
  return result;
}

int *Biquad_8dot24::Process824mTo824m(int *result, int *a2, unsigned int a3, int *a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v4 = a4[5];
  v5 = a4[7];
  v6 = a4[9];
  v7 = a4[11];
  if (a3)
  {
    v9 = *a4;
    v8 = a4[1];
    v11 = a4[3];
    v10 = a4[4];
    v12 = a3;
    v13 = a4[2];
    do
    {
      v14 = v4;
      v15 = v6;
      v16 = v11 * (uint64_t)v4;
      v17 = *result++;
      v4 = v17;
      v18 = v16 + v10 * (uint64_t)v5 + v9 * (uint64_t)v15 + v8 * (uint64_t)v7 + v17 * (uint64_t)v13;
      if (v18 < 0)
        v6 = -(int)((unint64_t)-v18 >> 24);
      else
        v6 = (unint64_t)v18 >> 24;
      *a2++ = v6;
      v7 = v15;
      v5 = v14;
      --v12;
    }
    while (v12);
  }
  else
  {
    v14 = a4[7];
    v15 = a4[11];
  }
  a4[5] = v4;
  a4[7] = v14;
  a4[9] = v6;
  a4[11] = v15;
  return result;
}

__int16 *Biquad_8dot24::Process16mTo16m(__int16 *result, _WORD *a2, unsigned int a3, int *a4)
{
  int v4;
  int v5;
  unint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;

  v4 = a4[5];
  v5 = a4[7];
  LODWORD(v6) = a4[9];
  v7 = a4[11];
  if (a3)
  {
    v9 = *a4;
    v8 = a4[1];
    v10 = a4[3];
    v11 = a4[4];
    v12 = a3;
    v13 = a4[2];
    do
    {
      v14 = v4;
      v15 = v6;
      v16 = v10 * (uint64_t)v4;
      v17 = *result++;
      v4 = v17 << 9;
      v18 = v16 + v11 * (uint64_t)v5 + v9 * (uint64_t)v15 + v8 * (uint64_t)v7 + (v17 << 9) * (uint64_t)v13;
      if (v18 < 0)
        v6 = -(-v18 >> 24);
      else
        v6 = (unint64_t)v18 >> 24;
      v19 = v6 >> 9;
      if ((int)v6 < -16777215)
        LOWORD(v19) = 0x8000;
      if ((int)v6 > 16776703)
        LOWORD(v19) = 0x7FFF;
      *a2++ = v19;
      v7 = v15;
      v5 = v14;
      --v12;
    }
    while (v12);
  }
  else
  {
    v14 = a4[7];
    v15 = a4[11];
  }
  a4[5] = v4;
  a4[7] = v14;
  a4[9] = v6;
  a4[11] = v15;
  return result;
}

int *Biquad_8dot24::Process824mTo824sInterleaved(int *result, int *a2, unsigned int a3, int *a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v4 = a4[5];
  v5 = a4[7];
  v6 = a4[9];
  v7 = a4[11];
  if (a3)
  {
    v9 = *a4;
    v8 = a4[1];
    v11 = a4[3];
    v10 = a4[4];
    v12 = a3;
    v13 = a4[2];
    do
    {
      v14 = v4;
      v15 = v6;
      v16 = v11 * (uint64_t)v4;
      v17 = *result++;
      v4 = v17;
      v18 = v16 + v10 * (uint64_t)v5 + v9 * (uint64_t)v15 + v8 * (uint64_t)v7 + v17 * (uint64_t)v13;
      if (v18 < 0)
        v6 = -(int)((unint64_t)-v18 >> 24);
      else
        v6 = (unint64_t)v18 >> 24;
      *a2 = v6;
      a2[1] = v6;
      a2 += 2;
      v7 = v15;
      v5 = v14;
      --v12;
    }
    while (v12);
  }
  else
  {
    v14 = a4[7];
    v15 = a4[11];
  }
  a4[5] = v4;
  a4[7] = v14;
  a4[9] = v6;
  a4[11] = v15;
  return result;
}

__int16 *Biquad_8dot24::Process16mTo16sInterleaved(__int16 *result, _WORD *a2, unsigned int a3, int *a4)
{
  int v4;
  int v5;
  unint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;

  v4 = a4[5];
  v5 = a4[7];
  LODWORD(v6) = a4[9];
  v7 = a4[11];
  if (a3)
  {
    v9 = *a4;
    v8 = a4[1];
    v10 = a4[3];
    v11 = a4[4];
    v12 = a3;
    v13 = a4[2];
    do
    {
      v14 = v4;
      v15 = v6;
      v16 = v10 * (uint64_t)v4;
      v17 = *result++;
      v4 = v17 << 9;
      v18 = v16 + v11 * (uint64_t)v5 + v9 * (uint64_t)v15 + v8 * (uint64_t)v7 + (v17 << 9) * (uint64_t)v13;
      if (v18 < 0)
        v6 = -(-v18 >> 24);
      else
        v6 = (unint64_t)v18 >> 24;
      v19 = v6 >> 9;
      if ((int)v6 < -16777215)
        LOWORD(v19) = 0x8000;
      if ((int)v6 > 16776703)
        LOWORD(v19) = 0x7FFF;
      *a2 = v19;
      a2[1] = v19;
      a2 += 2;
      v7 = v15;
      v5 = v14;
      --v12;
    }
    while (v12);
  }
  else
  {
    v14 = a4[7];
    v15 = a4[11];
  }
  a4[5] = v4;
  a4[7] = v14;
  a4[9] = v6;
  a4[11] = v15;
  return result;
}

uint64_t Biquad_8dot24::Process824sInterleavedTo824sInterleaved(uint64_t result, uint64_t a2, int a3, int *a4)
{
  unint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t i;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;

  v4 = (2 * a3);
  v5 = a4[2];
  v6 = a4[3];
  v7 = *a4;
  v8 = a4[1];
  v9 = a4[5];
  v10 = a4[4];
  v11 = a4[7];
  v12 = a4[9];
  v13 = a4[11];
  if ((_DWORD)v4)
  {
    for (i = 0; i < v4; i += 2)
    {
      v15 = v9;
      v16 = v12;
      v17 = v6 * (uint64_t)v9;
      v9 = *(_DWORD *)(result + 4 * i);
      v18 = v17 + v10 * (uint64_t)v11 + v7 * (uint64_t)v16 + v8 * (uint64_t)v13 + v9 * (uint64_t)v5;
      if (v18 < 0)
        v12 = -(int)((unint64_t)-v18 >> 24);
      else
        v12 = (unint64_t)v18 >> 24;
      *(_DWORD *)(a2 + 4 * i) = v12;
      v13 = v16;
      v11 = v15;
    }
  }
  else
  {
    v15 = a4[7];
    v16 = a4[11];
  }
  a4[5] = v9;
  a4[7] = v15;
  a4[9] = v12;
  a4[11] = v16;
  v19 = a4[6];
  v20 = a4[8];
  v21 = a4[10];
  v22 = a4[12];
  if ((_DWORD)v4)
  {
    v23 = 1;
    do
    {
      v24 = v19;
      v25 = v21;
      v26 = v6 * (uint64_t)v19;
      v19 = *(_DWORD *)(result + 4 * v23);
      v27 = v26 + v10 * (uint64_t)v20 + v7 * (uint64_t)v25 + v8 * (uint64_t)v22 + v19 * (uint64_t)v5;
      if (v27 < 0)
        v21 = -(int)((unint64_t)-v27 >> 24);
      else
        v21 = (unint64_t)v27 >> 24;
      *(_DWORD *)(a2 + 4 * v23) = v21;
      v23 += 2;
      v22 = v25;
      v20 = v24;
    }
    while (v23 < v4);
  }
  else
  {
    v24 = a4[8];
    v25 = a4[12];
  }
  a4[6] = v19;
  a4[8] = v24;
  a4[10] = v21;
  a4[12] = v25;
  return result;
}

uint64_t Biquad_8dot24::Process16sInterleavedTo16sInterleaved(uint64_t result, uint64_t a2, int a3, int *a4)
{
  unint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  unint64_t i;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  int v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;

  v4 = (2 * a3);
  v5 = a4[2];
  v6 = a4[3];
  v7 = *a4;
  v8 = a4[1];
  v9 = a4[5];
  v10 = a4[4];
  v11 = a4[7];
  LODWORD(v12) = a4[9];
  v13 = a4[11];
  if ((_DWORD)v4)
  {
    for (i = 0; i < v4; i += 2)
    {
      v15 = v9;
      v16 = v12;
      v17 = v6 * (uint64_t)v9;
      v9 = *(__int16 *)(result + 2 * i) << 9;
      v18 = v17 + v10 * (uint64_t)v11 + v7 * (uint64_t)v16 + v8 * (uint64_t)v13 + v9 * (uint64_t)v5;
      if (v18 < 0)
        v12 = -(-v18 >> 24);
      else
        v12 = (unint64_t)v18 >> 24;
      v19 = v12 >> 9;
      if ((int)v12 < -16777215)
        LOWORD(v19) = 0x8000;
      if ((int)v12 > 16776703)
        LOWORD(v19) = 0x7FFF;
      *(_WORD *)(a2 + 2 * i) = v19;
      v13 = v16;
      v11 = v15;
    }
  }
  else
  {
    v15 = a4[7];
    v16 = a4[11];
  }
  a4[5] = v9;
  a4[7] = v15;
  a4[9] = v12;
  a4[11] = v16;
  v20 = a4[6];
  v21 = a4[8];
  LODWORD(v22) = a4[10];
  v23 = a4[12];
  if ((_DWORD)v4)
  {
    v24 = 1;
    do
    {
      v25 = v20;
      v26 = v22;
      v27 = v6 * (uint64_t)v20;
      v20 = *(__int16 *)(result + 2 * v24) << 9;
      v28 = v27 + v10 * (uint64_t)v21 + v7 * (uint64_t)v26 + v8 * (uint64_t)v23 + v20 * (uint64_t)v5;
      if (v28 < 0)
        v22 = -(-v28 >> 24);
      else
        v22 = (unint64_t)v28 >> 24;
      v29 = v22 >> 9;
      if ((int)v22 < -16777215)
        LOWORD(v29) = 0x8000;
      if ((int)v22 > 16776703)
        LOWORD(v29) = 0x7FFF;
      *(_WORD *)(a2 + 2 * v24) = v29;
      v24 += 2;
      v23 = v26;
      v21 = v25;
    }
    while (v24 < v4);
  }
  else
  {
    v25 = a4[8];
    v26 = a4[12];
  }
  a4[6] = v20;
  a4[8] = v25;
  a4[10] = v22;
  a4[12] = v26;
  return result;
}

__int16 *Biquad_8dot24::Process16InterleavedTo824Deinterleaved(__int16 *result, int *a2, uint64_t a3, int a4, unsigned int a5, int *a6)
{
  int *v6;
  int *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;

  v6 = &a6[a4];
  v9 = v6[11];
  v7 = v6 + 11;
  v8 = v9;
  v10 = *(v7 - 6);
  v11 = *(v7 - 4);
  v12 = *(v7 - 2);
  if ((_DWORD)a3)
  {
    v14 = *a6;
    v13 = a6[1];
    v15 = 2 * a5;
    a3 = a3;
    v16 = a6[3];
    v17 = a6[4];
    v18 = a6[2];
    do
    {
      v19 = v10;
      v20 = v12;
      v21 = v16 * (uint64_t)v10;
      v10 = *result << 9;
      v22 = v21 + v17 * (uint64_t)v11 + v14 * (uint64_t)v20 + v13 * (uint64_t)v8 + v10 * (uint64_t)v18;
      if (v22 < 0)
        v12 = -(int)((unint64_t)-v22 >> 24);
      else
        v12 = (unint64_t)v22 >> 24;
      *a2++ = v12;
      result = (__int16 *)((char *)result + v15);
      v8 = v20;
      v11 = v19;
      --a3;
    }
    while (a3);
  }
  else
  {
    v19 = *(v7 - 4);
    v20 = v8;
  }
  *(v7 - 6) = v10;
  *(v7 - 4) = v19;
  *(v7 - 2) = v12;
  *v7 = v20;
  return result;
}

int *Biquad_8dot24::Process824DeinterleavedTo824Deinterleaved(int *result, int *a2, uint64_t a3, unsigned int a4, int *a5)
{
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  int *v10;
  int v11;
  int *v12;
  int v13;
  int *v14;
  int v15;
  int *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;

  v5 = a5[5];
  v6 = a5[7];
  v7 = a5[9];
  v8 = a5[11];
  if (a4)
  {
    v9 = a4;
    v10 = &a5[v9 + 5];
    v11 = *v10;
    a5[5] = *v10;
    v12 = &a5[v9 + 7];
    v13 = *v12;
    a5[7] = *v12;
    v14 = &a5[v9 + 9];
    v15 = *v14;
    a5[9] = *v14;
    v16 = &a5[v9 + 11];
    v17 = *v16;
    a5[11] = *v16;
    if ((_DWORD)a3)
    {
      v19 = *a5;
      v18 = a5[1];
      v21 = a5[3];
      v20 = a5[4];
      a3 = a3;
      v22 = a5[2];
      do
      {
        v23 = v11;
        v24 = v15;
        v25 = *result++;
        v11 = v25;
        v26 = v18 * (uint64_t)v17 + v19 * (uint64_t)v15 + v20 * (uint64_t)v13 + v21 * (uint64_t)v23 + v25 * (uint64_t)v22;
        if (v26 < 0)
          v15 = -(int)((unint64_t)-v26 >> 24);
        else
          v15 = (unint64_t)v26 >> 24;
        *a2++ = v15;
        v17 = v24;
        v13 = v23;
        --a3;
      }
      while (a3);
    }
    else
    {
      v23 = v13;
      v24 = v17;
    }
    a5[7] = v23;
    a5[9] = v15;
    a5[11] = v24;
    *v10 = v11;
    *v12 = a5[7];
    *v14 = a5[9];
    *v16 = a5[11];
  }
  else if ((_DWORD)a3)
  {
    v28 = *a5;
    v27 = a5[1];
    v30 = a5[3];
    v29 = a5[4];
    v31 = a3;
    v32 = a5[11];
    v33 = a5[7];
    v34 = a5[2];
    do
    {
      v6 = v5;
      v8 = v7;
      v35 = *result++;
      v5 = v35;
      v36 = v27 * (uint64_t)v32 + v28 * (uint64_t)v7 + v29 * (uint64_t)v33 + v30 * (uint64_t)v6 + v35 * (uint64_t)v34;
      if (v36 < 0)
        v7 = -(int)((unint64_t)-v36 >> 24);
      else
        v7 = (unint64_t)v36 >> 24;
      *a2++ = v7;
      v32 = v8;
      v33 = v6;
      --v31;
    }
    while (v31);
  }
  a5[5] = v5;
  a5[7] = v6;
  a5[9] = v7;
  a5[11] = v8;
  return result;
}

void ConvolutionFilter::Reset(void **this)
{
  bzero(this[1], *((int *)this + 8));
  bzero(this[2], *((int *)this + 8));
  bzero(this[3], *((int *)this + 8));
}

void FIRFilter::~FIRFilter(void **this)
{
  *this = off_1E69ED678;
  free(this[1]);
  free(this[2]);
  free(this[3]);
}

{
  *this = off_1E69ED678;
  free(this[1]);
  free(this[2]);
  free(this[3]);
  JUMPOUT(0x1BCC95CECLL);
}

void *FIRFilter::Process(uint64_t a1, char *a2, float *a3, int a4, uint64_t a5)
{
  uint64_t v5;
  float *v10;
  vDSP_Length v11;
  size_t v12;
  size_t v13;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v5 = *(int *)(a5 + 12);
  if ((int)v5 >= 97)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v15 = 136315394;
      v16 = "Convolution.cpp";
      v17 = 1024;
      v18 = 569;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  failed assertion: kernelSize <= kMaxKernelSize", (uint8_t *)&v15, 0x12u);
    }
    __break(1u);
  }
  v10 = *(float **)(a1 + 8);
  v11 = a4;
  v12 = 4 * a4;
  memcpy(&v10[v5], a2, v12);
  vDSP_conv(v10, 1, *(const float **)a5, 1, a3, 1, v11, v5 + 1);
  if ((int)v5 <= a4)
    return memcpy(v10, &a2[4 * v11 + -4 * v5], 4 * v5);
  v13 = (int)v5 - a4;
  memmove(v10, &v10[v11], v13 * 4);
  return memmove(&v10[v13], a2, v12);
}

void *FIRFilter::Process2(float **a1, char *a2, float *a3, int a4, const float **a5, uint64_t a6)
{
  uint64_t v6;
  float *v13;
  vDSP_Length v14;
  size_t v15;
  const float *v16;
  const float *v17;
  const float *v18;
  size_t v19;
  float __Step;
  float __Start;
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v6 = *(int *)(a6 + 12);
  if ((int)v6 >= 97)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __Start = 4.8151e-34;
      v23 = "Convolution.cpp";
      v24 = 1024;
      v25 = 682;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  failed assertion: kernelSize <= kMaxKernelSize", (uint8_t *)&__Start, 0x12u);
    }
    __break(1u);
  }
  v13 = a1[1];
  v14 = a4;
  v15 = 4 * a4;
  memcpy(&v13[v6], a2, v15);
  v16 = *(const float **)a6;
  vDSP_conv(v13, 1, *a5, 1, a1[2], 1, v14, v6 + 1);
  vDSP_conv(v13, 1, v16, 1, a1[3], 1, v14, v6 + 1);
  v18 = a1[2];
  v17 = a1[3];
  __Start = 0.0;
  __Step = 1.0 / (float)a4;
  vDSP_vsub(v18, 1, v17, 1, a3, 1, v14);
  vDSP_vrampmul(a3, 1, &__Start, &__Step, a3, 1, v14);
  vDSP_vadd(v18, 1, a3, 1, a3, 1, v14);
  if ((int)v6 <= a4)
    return memcpy(v13, &a2[4 * v14 + -4 * v6], 4 * v6);
  v19 = (int)v6 - a4;
  memmove(v13, &v13[v14], v19 * 4);
  return memmove(&v13[v19], a2, v15);
}

uint64_t ConvolutionKernel::ConvolutionKernel(uint64_t a1, uint64_t a2)
{
  signed int v4;
  unsigned int v5;
  uint64_t v6;
  void *v7;
  int v8;
  uint64_t v9;
  uint64_t i;
  float32x2_t *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  double v23;
  float32_t v24;
  std::bad_alloc *exception;
  std::bad_alloc *v27;
  double v28;
  float64x2_t __x;
  float64x2_t __xa;
  float64x2_t __xb;
  long double v32;
  float64x2_t v33;
  long double v34;
  float64x2_t v35;
  long double v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  unsigned __int16 v41;
  unsigned int v42;
  int v43;
  unsigned int v44;

  v41 = 0;
  (*(void (**)(uint64_t, unsigned __int16 *, uint64_t))(*(_QWORD *)a2 + 16))(a2, &v41, 2);
  v4 = bswap32(v41) >> 16;
  if (v4 >= 64)
    v5 = 64;
  else
    v5 = v4;
  *(_DWORD *)(a1 + 12) = v5;
  v42 = 0;
  (*(void (**)(uint64_t, unsigned int *, uint64_t))(*(_QWORD *)a2 + 16))(a2, &v42, 4);
  *(_DWORD *)(a1 + 8) = bswap32(v42);
  v6 = *(int *)(a1 + 12) + 1;
  v7 = malloc_type_malloc(4 * v6, 0x7C51E058uLL);
  if ((_DWORD)v6 && !v7)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v27 = std::bad_alloc::bad_alloc(exception);
  }
  *(_QWORD *)a1 = v7;
  v8 = v4 - v5;
  if (v8 >= 1)
  {
    do
    {
      v43 = 0;
      (*(void (**)(uint64_t, int *, uint64_t))(*(_QWORD *)a2 + 16))(a2, &v43, 4);
      --v8;
    }
    while (v8);
  }
  v9 = *(int *)(a1 + 12);
  if ((int)v9 < 1)
  {
    *(_DWORD *)(*(_QWORD *)a1 + 4 * v9) = *(_DWORD *)(a1 + 8);
    return a1;
  }
  for (i = 0; i < v12; ++i)
  {
    v44 = 0;
    (*(void (**)(uint64_t, unsigned int *, uint64_t))(*(_QWORD *)a2 + 16))(a2, &v44, 4);
    v11 = *(float32x2_t **)a1;
    *(_DWORD *)(*(_QWORD *)a1 + 4 * i) = bswap32(v44);
    v12 = *(int *)(a1 + 12);
  }
  v11->i32[v12] = *(_DWORD *)(a1 + 8);
  if ((int)v12 >= 1)
  {
    if (v5 <= 0x20)
      v13 = 5;
    else
      v13 = 10;
    if ((int)v12 >= v13)
      v14 = v13;
    else
      v14 = v12;
    v15 = (double)(int)v14;
    if (v14 < 4)
    {
      v16 = 0;
LABEL_25:
      v23 = 1.0 / v15;
      do
      {
        v24 = sin((double)((int)v16 + 1) * 1.57079633 * v23) * v11->f32[v16];
        v11->f32[v16++] = v24;
      }
      while (v14 != v16);
      return a1;
    }
    v16 = v14 & 0x7FFFFFFC;
    v38 = vmulq_n_f64((float64x2_t)xmmword_1B6627180, 1.57079633 / v15);
    v28 = 1.57079633 / v15;
    __x = vmulq_n_f64((float64x2_t)xmmword_1B6627170, 1.57079633 / v15);
    v32 = sin(__x.f64[1]);
    v17.f64[0] = sin(__x.f64[0]);
    v17.f64[1] = v32;
    v33 = v17;
    __x.f64[0] = sin(v38.f64[1]);
    v18.f64[0] = sin(v38.f64[0]);
    v18.f64[1] = __x.f64[0];
    *(float32x4_t *)v11->f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(v33, vcvtq_f64_f32(*v11))), vmulq_f64(v18, vcvt_hight_f64_f32(*(float32x4_t *)v11->f32)));
    if (v16 != 4)
    {
      v39 = vmulq_n_f64((float64x2_t)xmmword_1B66A29C0, v28);
      __xa = vmulq_n_f64((float64x2_t)xmmword_1B66A29D0, v28);
      v34 = sin(__xa.f64[1]);
      v19.f64[0] = sin(__xa.f64[0]);
      v19.f64[1] = v34;
      v35 = v19;
      __xa.f64[0] = sin(v39.f64[1]);
      v20.f64[0] = sin(v39.f64[0]);
      v20.f64[1] = __xa.f64[0];
      *(float32x4_t *)v11[2].f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(v35, vcvtq_f64_f32(v11[2]))), vmulq_f64(v20, vcvt_hight_f64_f32(*(float32x4_t *)v11[2].f32)));
      if (v16 != 8)
      {
        v40 = vmulq_n_f64((float64x2_t)xmmword_1B66A29E0, v28);
        __xb = vmulq_n_f64((float64x2_t)xmmword_1B66A29F0, v28);
        v36 = sin(__xb.f64[1]);
        v21.f64[0] = sin(__xb.f64[0]);
        v21.f64[1] = v36;
        v37 = v21;
        __xb.f64[0] = sin(v40.f64[1]);
        v22.f64[0] = sin(v40.f64[0]);
        v22.f64[1] = __xb.f64[0];
        *(float32x4_t *)v11[4].f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(v37, vcvtq_f64_f32(v11[4]))), vmulq_f64(v22, vcvt_hight_f64_f32(*(float32x4_t *)v11[4].f32)));
      }
    }
    if (v16 != v14)
      goto LABEL_25;
  }
  return a1;
}

void ConvolutionFilter::ConvolutionFilter(ConvolutionFilter *this)
{
  void *v2;
  void *v3;
  void *v4;
  std::bad_alloc *exception;
  std::bad_alloc *v6;

  *(_QWORD *)this = off_1E69ED678;
  v2 = malloc_type_malloc(0x10190uLL, 0x7C51E058uLL);
  if (!v2
    || (*((_QWORD *)this + 1) = v2, (v3 = malloc_type_malloc(0x10190uLL, 0x7C51E058uLL)) == 0)
    || (*((_QWORD *)this + 2) = v3, (v4 = malloc_type_malloc(0x10190uLL, 0x7C51E058uLL)) == 0))
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v6 = std::bad_alloc::bad_alloc(exception);
  }
  *((_QWORD *)this + 3) = v4;
  *((_DWORD *)this + 8) = 65936;
  (*(void (**)(ConvolutionFilter *))(*(_QWORD *)this + 24))(this);
}

void ConvolutionFilter::~ConvolutionFilter(void **this)
{
  *this = off_1E69ED678;
  free(this[1]);
  free(this[2]);
  free(this[3]);
}

void VPFilterBank::~VPFilterBank(VPFilterBank *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

float VPFilterBank::filterbank32_compute(VPFilterBank *this, const float *a2, float *a3)
{
  uint64_t v6;
  uint64_t v7;
  vDSP_Length v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  float *v12;
  unint64_t v13;
  float *v14;
  float result;
  unint64_t v16;
  float *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v7 = *((_QWORD *)this + 7);
  v6 = *((_QWORD *)this + 8);
  v8 = *((unsigned int *)this + 13);
  MEMORY[0x1E0C80A78](this);
  v10 = (unint64_t)&v19 - ((v9 + 31) & 0x7FFFFFFF0);
  bzero((void *)v10, v11);
  v12 = (float *)((v10 & 0xFFFFFFFFFFFFFFF3) + 16);
  HIDWORD(v19) = 0;
  vDSP_vmul(*((const float **)this + 3), 1, a2, 1, v12, 1, v8);
  if (*((_DWORD *)this + 12))
  {
    v13 = 0;
    v14 = a3;
    do
    {
      vDSP_sve(&v12[*(int *)(v7 + 4 * v13)], 1, v14, *(int *)(v6 + 4 * v13));
      ++v13;
      ++v14;
    }
    while (v13 < *((unsigned int *)this + 12));
  }
  vDSP_vmul(*((const float **)this + 4), 1, a2, 1, v12, 1, *((unsigned int *)this + 13));
  if (*((_DWORD *)this + 12) != 1)
  {
    v16 = 0;
    v17 = a3 + 1;
    do
    {
      v18 = v16;
      vDSP_sve(&v12[*(int *)(v7 + 4 * v16)], 1, (float *)&v19 + 1, *(int *)(v6 + 4 * v16));
      ++v16;
      result = v17[v18] + *((float *)&v19 + 1);
      v17[v18] = result;
    }
    while (v16 < (*((_DWORD *)this + 12) - 1));
  }
  return result;
}

void ausdk::AUInputElement::~AUInputElement(ausdk::AUInputElement *this)
{
  _QWORD *v2;
  void *v3;

  *(_QWORD *)this = off_1E69ED7C0;
  v2 = (_QWORD *)*((_QWORD *)this + 19);
  if (v2)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v2);
    *((_QWORD *)this + 19) = 0;
  }
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 36) = 0;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
  }
  ausdk::AUElement::~AUElement((const void **)this);
}

{
  _QWORD *v2;
  void *v3;

  *(_QWORD *)this = off_1E69ED7C0;
  v2 = (_QWORD *)*((_QWORD *)this + 19);
  if (v2)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v2);
    *((_QWORD *)this + 19) = 0;
  }
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 36) = 0;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
  }
  ausdk::AUElement::~AUElement((const void **)this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t ausdk::AUInputElement::SetStreamFormat(ausdk::AUInputElement *this, const AudioChannelLayout *a2)
{
  ausdk::AUIOElement::SetStreamFormat(this, a2);
  (*(void (**)(ausdk::AUInputElement *, _QWORD))(*(_QWORD *)this + 64))(this, 0);
  return 0;
}

void ausdk::AUInputElement::SetInputCallback(ausdk::AUInputElement *this, int (*a2)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a3)
{
  _QWORD *v4;

  if (a2)
  {
    *((_DWORD *)this + 43) = 2;
    *((_QWORD *)this + 22) = a2;
    *((_QWORD *)this + 23) = a3;
    (*(void (**)(ausdk::AUInputElement *, _QWORD))(*(_QWORD *)this + 64))(this, 0);
  }
  else
  {
    *((_DWORD *)this + 43) = 0;
    v4 = (_QWORD *)*((_QWORD *)this + 19);
    if (v4)
    {
      ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v4);
      *((_QWORD *)this + 19) = 0;
    }
    *((_QWORD *)this + 20) = 0;
    *((_DWORD *)this + 36) = 0;
  }
}

uint64_t ausdk::AUInputElement::PullInput(ausdk::AUInputElement *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4, uint64_t a5)
{
  int v5;
  ausdk::AUBufferList *v11;
  AudioBufferList *v12;
  int v13;
  unsigned int v14;
  int v15;
  _DWORD *v16;
  uint64_t v17;
  int v18;
  _QWORD *v19;
  uint64_t result;
  ausdk::AUException *exception;
  std::logic_error *v22;
  _DWORD v23[2];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v5 = *((_DWORD *)this + 43);
  if (!v5)
    return 4294956420;
  v11 = (ausdk::AUInputElement *)((char *)this + 144);
  if (v5 == 1 || !*((_BYTE *)this + 168))
  {
    v13 = *((_DWORD *)this + 23);
    if ((v13 & 0x20) != 0)
      v14 = *((_DWORD *)this + 27);
    else
      v14 = 1;
    if (v14 > *((_DWORD *)this + 40))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v23[0] = 67109120;
        v23[1] = -10868;
        _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "AUBuffer throwing bad_alloc", (uint8_t *)v23, 8u);
      }
      exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
      ausdk::AUException::AUException(exception, -10868);
    }
    if ((v13 & 0x20) != 0)
      v15 = 1;
    else
      v15 = *((_DWORD *)this + 27);
    v16 = (_DWORD *)*((_QWORD *)this + 19);
    v12 = (AudioBufferList *)(v16 + 12);
    v17 = v16[12];
    if (v16[12] > *v16)
    {
      v22 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](v22, "AllocatedBuffer::PrepareNull(): too many buffers");
    }
    if ((_DWORD)v17)
    {
      v18 = *((_DWORD *)this + 26) * a5;
      v19 = v16 + 16;
      do
      {
        *((_DWORD *)v19 - 2) = v15;
        *((_DWORD *)v19 - 1) = v18;
        *v19 = 0;
        v19 += 2;
        --v17;
      }
      while (v17);
    }
    *(_DWORD *)v11 = 2;
  }
  else
  {
    v12 = (AudioBufferList *)ausdk::AUBufferList::PrepareBuffer(v11, (const AudioStreamBasicDescription *)this + 2, a5);
    v5 = *((_DWORD *)this + 43);
  }
  if (v5 == 1)
    LODWORD(result) = AudioUnitRender(*((AudioUnit *)this + 24), a2, a3, *((_DWORD *)this + 50), a5, v12);
  else
    LODWORD(result) = (*((uint64_t (**)(_QWORD, unsigned int *, const AudioTimeStamp *, uint64_t, uint64_t, AudioBufferList *))this
                       + 22))(*((_QWORD *)this + 23), a2, a3, a4, a5, v12);
  if (*((_DWORD *)this + 43))
    return result;
  else
    return 4294956420;
}

void sub_1B65B7180(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double ausdk::ComponentBase::GetComponentDescription(ausdk::ComponentBase *this, OpaqueAudioComponentInstance *a2)
{
  OpaqueAudioComponent *Component;
  double result;
  AudioComponentDescription outDesc;

  memset(&outDesc, 0, sizeof(outDesc));
  Component = AudioComponentInstanceGetComponent(a2);
  if (Component && !AudioComponentGetDescription(Component, &outDesc))
  {
    result = *(double *)&outDesc.componentType;
    *(AudioComponentDescription *)this = outDesc;
  }
  else
  {
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_DWORD *)this + 4) = 0;
  }
  return result;
}

void ausdk::ComponentBase::~ComponentBase(ausdk::ComponentBase *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t ausdk::ComponentBase::AP_Open(uint64_t (**this)(char *, void *), void *a2, OpaqueAudioComponentInstance *a3)
{
  unsigned __int8 v5;
  uint64_t v6;

  if ((v5 & 1) == 0
  {
    MEMORY[0x1BCC958E4](&ausdk::ComponentBase::InitializationMutex(void)::global);
  }
  std::recursive_mutex::lock(&ausdk::ComponentBase::InitializationMutex(void)::global);
  v6 = this[4]((char *)this + 64, a2);
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 32))(v6);
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  std::recursive_mutex::unlock(&ausdk::ComponentBase::InitializationMutex(void)::global);
  return 0;
}

void sub_1B65B72D0(void *a1, int a2)
{
  uint64_t v2;
  _DWORD *v5;
  int v6;

  switch(a2)
  {
    case 5:
      v5 = __cxa_begin_catch(a1);
      break;
    case 4:
      __cxa_begin_catch(a1);
      __cxa_end_catch();
      v6 = -108;
      if (!v2)
        goto LABEL_15;
      goto LABEL_8;
    case 3:
      v6 = *(_DWORD *)__cxa_begin_catch(a1);
LABEL_4:
      __cxa_end_catch();
      if (!v2)
        goto LABEL_15;
      goto LABEL_8;
    default:
      v5 = __cxa_begin_catch(a1);
      if (a2 != 2)
      {
        __cxa_end_catch();
        v6 = -1;
        if (!v2)
          goto LABEL_15;
LABEL_8:
        if (v6)
          MEMORY[0x1BCC95CEC](v2, 0x1080C4018D86D6ALL);
LABEL_15:
        JUMPOUT(0x1B65B7294);
      }
      break;
  }
  v6 = v5[4];
  goto LABEL_4;
}

uint64_t ausdk::ComponentBase::AP_Close(ausdk::ComponentBase *this, void *a2)
{
  char *v3;

  v3 = (char *)this + 64;
  (*(void (**)(char *, void *))(*((_QWORD *)this + 8) + 24))((char *)this + 64, a2);
  (*(void (**)(char *))(*(_QWORD *)v3 + 40))(v3);
  (*((void (**)(char *))this + 5))(v3);
  free(this);
  return 0;
}

void ausdk::AUOutputElement::~AUOutputElement(ausdk::AUOutputElement *this)
{
  _QWORD *v2;
  void *v3;

  *(_QWORD *)this = off_1E69ED7C0;
  v2 = (_QWORD *)*((_QWORD *)this + 19);
  if (v2)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v2);
    *((_QWORD *)this + 19) = 0;
  }
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 36) = 0;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
  }
  ausdk::AUElement::~AUElement((const void **)this);
}

{
  _QWORD *v2;
  void *v3;

  *(_QWORD *)this = off_1E69ED7C0;
  v2 = (_QWORD *)*((_QWORD *)this + 19);
  if (v2)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v2);
    *((_QWORD *)this + 19) = 0;
  }
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 36) = 0;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
  }
  ausdk::AUElement::~AUElement((const void **)this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t ausdk::AUOutputElement::SetStreamFormat(ausdk::AUOutputElement *this, const AudioChannelLayout *a2)
{
  ausdk::AUIOElement::SetStreamFormat(this, a2);
  (*(void (**)(ausdk::AUOutputElement *, _QWORD))(*(_QWORD *)this + 64))(this, 0);
  return 0;
}

ausdk::AUOutputElement *ausdk::AUOutputElement::AUOutputElement(ausdk::AUOutputElement *this, ausdk::AUBase *a2)
{
  ausdk::AUIOElement *v3;

  v3 = ausdk::AUIOElement::AUIOElement(this, a2);
  *(_QWORD *)v3 = &off_1E69ED740;
  ausdk::AUIOElement::AllocateBuffer(v3, 0);
  return this;
}

void sub_1B65B75A4(_Unwind_Exception *a1)
{
  ausdk::AUIOElement *v1;

  ausdk::AUIOElement::~AUIOElement(v1);
  _Unwind_Resume(a1);
}

void ausdk::AUIOElement::~AUIOElement(ausdk::AUIOElement *this)
{
  _QWORD *v2;
  void *v3;

  *(_QWORD *)this = off_1E69ED7C0;
  v2 = (_QWORD *)*((_QWORD *)this + 19);
  if (v2)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v2);
    *((_QWORD *)this + 19) = 0;
  }
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 36) = 0;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
  }
  ausdk::AUElement::~AUElement((const void **)this);
}

uint64_t ausdk::AUElement::GetParameterList(uint64_t this, unsigned int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;

  if (*(_BYTE *)(this + 40))
  {
    v2 = *(_QWORD *)(this + 56) - *(_QWORD *)(this + 48);
    if (v2)
    {
      v3 = 0;
      v4 = 4 * (v2 >> 2);
      do
      {
        a2[v3] = v3;
        ++v3;
        v4 -= 4;
      }
      while (v4);
    }
  }
  else
  {
    v5 = *(unsigned int **)(this + 16);
    v6 = *(unsigned int **)(this + 24);
    while (v5 != v6)
    {
      v7 = *v5;
      v5 += 2;
      *a2++ = v7;
    }
  }
  return this;
}

void ausdk::AUElement::SetScheduledEvent(ausdk::AUElement *this, unsigned int a2, const AudioUnitParameterEvent *a3, unsigned int a4, unsigned int a5, char a6)
{
  uint64_t v7;
  _QWORD *v8;
  int v9;
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a3->eventType == kParameterEvent_Immediate)
  {
    ausdk::AUElement::SetParameter(this, a2, a3->eventValues.immediate.value, a6);
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v7 = *((_QWORD *)this + 1);
    v8 = (_QWORD *)(v7 + 440);
    if (*(char *)(v7 + 463) < 0)
      v8 = (_QWORD *)*v8;
    v9 = 136315138;
    v10 = v8;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Warning: %s was passed a ramped parameter event but does not implement them. Ignoring.", (uint8_t *)&v9, 0xCu);
  }
}

void ausdk::AUElement::UseIndexedParameters(ausdk::AUElement *this, unsigned int a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  unsigned int v15;
  unsigned int *v16;

  v3 = a2;
  v5 = (unsigned int *)*((_QWORD *)this + 6);
  v4 = (unsigned int *)*((_QWORD *)this + 7);
  v6 = v4 - v5;
  if (a2 <= v6)
  {
    if (a2 >= v6)
      goto LABEL_18;
    v16 = &v5[a2];
LABEL_17:
    *((_QWORD *)this + 7) = v16;
    goto LABEL_18;
  }
  v7 = a2 - v6;
  v8 = *((_QWORD *)this + 8);
  if (v7 <= (v8 - (uint64_t)v4) >> 2)
  {
    bzero(*((void **)this + 7), 4 * v7);
    v16 = &v4[v7];
    goto LABEL_17;
  }
  v9 = v8 - (_QWORD)v5;
  if (v9 >> 1 > (unint64_t)a2)
    v3 = v9 >> 1;
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL)
    v10 = 0x3FFFFFFFFFFFFFFFLL;
  else
    v10 = v3;
  if (v10 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v11 = (char *)operator new(4 * v10);
  v12 = &v11[4 * v6];
  v13 = &v11[4 * v10];
  bzero(v12, 4 * v7);
  v14 = &v12[4 * v7];
  if (v4 != v5)
  {
    do
    {
      v15 = atomic_load(--v4);
      *((_DWORD *)v12 - 1) = v15;
      v12 -= 4;
    }
    while (v4 != v5);
    v4 = (unsigned int *)*((_QWORD *)this + 6);
  }
  *((_QWORD *)this + 6) = v12;
  *((_QWORD *)this + 7) = v14;
  *((_QWORD *)this + 8) = v13;
  if (v4)
    operator delete(v4);
LABEL_18:
  *((_BYTE *)this + 40) = 1;
}

uint64_t ausdk::AUIOElement::SetStreamFormat(ausdk::AUIOElement *this, const AudioChannelLayout *a2)
{
  __int128 v3;
  __int128 v4;
  int v5;

  v3 = *(_OWORD *)&a2->mChannelLayoutTag;
  v4 = *(_OWORD *)&a2->mChannelDescriptions[0].mChannelFlags;
  *((_QWORD *)this + 14) = *(_QWORD *)&a2[1].mChannelLayoutTag;
  *((_OWORD *)this + 5) = v3;
  *((_OWORD *)this + 6) = v4;
  v5 = ausdk::AUChannelLayout::NumberChannels(*((ausdk::AUChannelLayout **)this + 15), a2);
  if (v5 && *((_DWORD *)this + 27) != v5)
    (*(void (**)(ausdk::AUIOElement *))(*(_QWORD *)this + 104))(this);
  return 0;
}

_DWORD *ausdk::AUIOElement::AllocateBuffer(_DWORD *this, int a2)
{
  uint64_t v2;
  int v3;
  ausdk::AUBufferList *v4;
  const AudioStreamBasicDescription *v5;
  int v6;

  v2 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v2 + 18))
  {
    v3 = a2;
    if (!a2)
      v3 = *(_DWORD *)(v2 + 336);
    v4 = (ausdk::AUBufferList *)(this + 36);
    v5 = (const AudioStreamBasicDescription *)(this + 20);
    if (*((_BYTE *)this + 168))
    {
      if ((*(unsigned int (**)(_DWORD *))(*(_QWORD *)this + 72))(this))
        v6 = v3;
      else
        v6 = 0;
    }
    else
    {
      v6 = 0;
    }
    return ausdk::AUBufferList::Allocate(v4, v5, v6);
  }
  return this;
}

void ausdk::AUIOElement::GetChannelLayoutTags(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t ausdk::AUIOElement::SetAudioChannelLayout(ausdk::AUIOElement *this, AudioChannelLayout *a2)
{
  int v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t result;
  void *__dst[2];
  uint64_t v12;

  v4 = *((_DWORD *)this + 27);
  if (v4 != ausdk::AUChannelLayout::NumberChannels((ausdk::AUChannelLayout *)a2, a2))
    return 4294956445;
  v5 = 20 * a2->mNumberChannelDescriptions + 12;
  v6 = (v5 & 0x1C) == 0;
  v7 = v5 >> 5;
  if (v6)
    v8 = v7;
  else
    v8 = v7 + 1;
  std::vector<AudioChannelLayout>::vector(__dst, v8);
  memcpy(__dst[0], a2, 20 * a2->mNumberChannelDescriptions + 12);
  v9 = (void *)*((_QWORD *)this + 15);
  if (v9)
  {
    *((_QWORD *)this + 16) = v9;
    operator delete(v9);
  }
  result = 0;
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)__dst;
  *((_QWORD *)this + 17) = v12;
  return result;
}

uint64_t ausdk::AUIOElement::GetAudioChannelLayout(ausdk::AUIOElement *this, AudioChannelLayout *a2, BOOL *a3)
{
  ausdk::AUChannelLayout *v4;
  int v5;
  uint64_t v6;

  *a3 = 1;
  v4 = (ausdk::AUChannelLayout *)*((_QWORD *)this + 15);
  if (!ausdk::AUChannelLayout::NumberChannels(v4, a2))
    return 0;
  v5 = *((_DWORD *)v4 + 2);
  v6 = (20 * v5 + 12);
  if (a2 && 20 * v5 != -12)
    memcpy(a2, v4, (20 * v5 + 12));
  return v6;
}

uint64_t ausdk::AUIOElement::RemoveAudioChannelLayout(ausdk::AUIOElement *this)
{
  _QWORD *v2;
  void *v3;
  _QWORD *v5;
  __int128 v6;

  std::vector<AudioChannelLayout>::vector(&v5, 1uLL);
  v2 = v5;
  *v5 = 0;
  *((_DWORD *)v2 + 2) = 0;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
    v2 = v5;
  }
  *((_QWORD *)this + 15) = v2;
  *((_OWORD *)this + 8) = v6;
  return 0;
}

void ausdk::AUElement::SetParameter(ausdk::AUElement *this, unsigned int a2, float a3, char a4)
{
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  char *v10;
  char *v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  unsigned int v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  unint64_t v23;
  char *v24;
  char *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  char *v31;
  char *v32;
  _DWORD *v33;
  unsigned int *v34;
  int v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  unsigned int *v43;
  uint64_t v44;
  unsigned int v45;
  char *v46;
  char *v47;
  unint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  _DWORD *v52;
  char *v53;
  char *v54;
  int v55;
  unsigned int v56;
  char *i;
  unsigned int *v58;
  int v59;
  void *v60;
  ausdk::AUException *exception;
  int v62;
  _QWORD *v63;
  __int16 v64;
  unsigned int v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 40))
  {
    v7 = *((_QWORD *)this + 6);
    if (a2 >= (unint64_t)((*((_QWORD *)this + 7) - v7) >> 2))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v62 = 67109120;
        LODWORD(v63) = -10878;
        _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Warning: %s SetParameter for undefined param ID %u while initialized. Ignoring.", (uint8_t *)&v62, 8u);
      }
      exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
      ausdk::AUException::AUException(exception, -10878);
    }
    v8 = (unsigned int *)(v7 + 4 * a2);
    goto LABEL_4;
  }
  v11 = (char *)*((_QWORD *)this + 2);
  v10 = (char *)*((_QWORD *)this + 3);
  v12 = v11;
  if (v10 != v11)
  {
    v13 = (v10 - v11) >> 3;
    v12 = (char *)*((_QWORD *)this + 2);
    do
    {
      v14 = v13 >> 1;
      v15 = &v12[8 * (v13 >> 1)];
      v17 = *(_DWORD *)v15;
      v16 = v15 + 8;
      v13 += ~(v13 >> 1);
      if (v17 < a2)
        v12 = v16;
      else
        v13 = v14;
    }
    while (v13);
  }
  if (v12 != v10)
  {
    if (*(_DWORD *)v12 != a2)
      v12 = (char *)*((_QWORD *)this + 3);
    if (v10 != v12)
    {
      v8 = (unsigned int *)(v12 + 4);
LABEL_4:
      v9 = LODWORD(a3);
LABEL_5:
      atomic_store(v9, v8);
      return;
    }
  }
  v18 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v18 + 17) || (a4 & 1) != 0)
  {
    v20 = v10 - v11;
    if (v10 == v11)
    {
      v22 = (char *)*((_QWORD *)this + 3);
    }
    else
    {
      v21 = v20 >> 3;
      v22 = (char *)*((_QWORD *)this + 2);
      do
      {
        v23 = v21 >> 1;
        v24 = &v22[8 * (v21 >> 1)];
        v26 = *(_DWORD *)v24;
        v25 = v24 + 8;
        v21 += ~(v21 >> 1);
        if (v26 < a2)
          v22 = v25;
        else
          v21 = v23;
      }
      while (v21);
    }
    if (v10 != v22 && *(_DWORD *)v22 == a2)
    {
      v8 = (unsigned int *)(v22 + 4);
      goto LABEL_4;
    }
    v27 = v22 - v11;
    v28 = (v22 - v11) >> 3;
    v29 = &v11[(v22 - v11) & 0xFFFFFFFFFFFFFFF8];
    v30 = *((_QWORD *)this + 4);
    if ((unint64_t)v10 < v30)
    {
      if (v29 == v10)
      {
        *(_DWORD *)v10 = a2;
        *(float *)&v11[8 * v28 + 4] = a3;
        *((_QWORD *)this + 3) = v10 + 8;
        return;
      }
      v9 = LODWORD(a3);
      v31 = v29 + 8;
      v32 = v10 - 8;
      v33 = (_DWORD *)*((_QWORD *)this + 3);
      while (v32 < v10)
      {
        v34 = (unsigned int *)(v32 + 4);
        v35 = *(_DWORD *)v32;
        v32 += 8;
        *v33 = v35;
        LODWORD(v34) = atomic_load(v34);
        v33[1] = (_DWORD)v34;
        v33 += 2;
      }
      *((_QWORD *)this + 3) = v33;
      if (v10 != v31)
      {
        v42 = 8 * ((v10 - v31) >> 3);
        v43 = (unsigned int *)(v10 - 4);
        v44 = (uint64_t)&v11[8 * v28 - 4];
        do
        {
          *(v43 - 1) = *(_DWORD *)(v44 + v42 - 4);
          v45 = atomic_load((unsigned int *)(v44 + v42));
          atomic_store(v45, v43);
          v43 -= 2;
          v42 -= 8;
        }
        while (v42);
      }
      *(_DWORD *)v29 = a2;
      v8 = (unsigned int *)&v11[8 * v28 + 4];
      goto LABEL_5;
    }
    v36 = (v20 >> 3) + 1;
    if (v36 >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v37 = v30 - (_QWORD)v11;
    v38 = (uint64_t)(v30 - (_QWORD)v11) >> 2;
    if (v38 > v36)
      v36 = v38;
    if (v37 >= 0x7FFFFFFFFFFFFFF8)
      v39 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v39 = v36;
    if (v39)
    {
      v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v39);
    }
    else
    {
      v41 = 0;
      v40 = 0;
    }
    v46 = &v41[8 * v28];
    v47 = &v41[8 * v40];
    if (v28 == v40)
    {
      if (v27 < 1)
      {
        if (v22 == v11)
          v49 = 1;
        else
          v49 = v27 >> 2;
        v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v49);
        v46 = &v50[8 * (v49 >> 2)];
        v47 = &v50[8 * v51];
        if (v41)
          operator delete(v41);
      }
      else
      {
        v48 = v28 + 2;
        if (v28 >= -1)
          v48 = v28 + 1;
        v46 -= 8 * (v48 >> 1);
      }
    }
    *(_DWORD *)v46 = a2;
    *((float *)v46 + 1) = a3;
    v52 = v46 + 8;
    v53 = (char *)*((_QWORD *)this + 2);
    if (v53 != v29)
    {
      v54 = v29;
      do
      {
        v55 = *((_DWORD *)v54 - 2);
        v54 -= 8;
        *((_DWORD *)v46 - 2) = v55;
        v46 -= 8;
        v56 = atomic_load((unsigned int *)v54 + 1);
        *((_DWORD *)v46 + 1) = v56;
      }
      while (v54 != v53);
    }
    for (i = (char *)*((_QWORD *)this + 3); v29 != i; v52 += 2)
    {
      v58 = (unsigned int *)(v29 + 4);
      v59 = *(_DWORD *)v29;
      v29 += 8;
      *v52 = v59;
      LODWORD(v58) = atomic_load(v58);
      v52[1] = (_DWORD)v58;
    }
    v60 = (void *)*((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v46;
    *((_QWORD *)this + 3) = v52;
    *((_QWORD *)this + 4) = v47;
    if (v60)
      operator delete(v60);
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v19 = (_QWORD *)(v18 + 440);
    if (*(char *)(v18 + 463) < 0)
      v19 = (_QWORD *)*v19;
    v62 = 136315394;
    v63 = v19;
    v64 = 1024;
    v65 = a2;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Warning: %s SetParameter for undefined param ID %u while initialized. Ignoring.", (uint8_t *)&v62, 0x12u);
  }
}

void sub_1B65B7F48(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::AUElement::AsIOElement(ausdk::AUElement *this)
{
  return 0;
}

BOOL ausdk::AUElement::HasParameterID(ausdk::AUElement *this, unsigned int a2)
{
  char *v3;

  if (*((_BYTE *)this + 40))
    return a2 < (unint64_t)((uint64_t)(*((_QWORD *)this + 7) - *((_QWORD *)this + 6)) >> 2);
  v3 = (char *)*((_QWORD *)this + 3);
  return v3 != ausdk::flat_map<unsigned int,ausdk::AtomicValue<float>>::find(*((char **)this + 2), v3, a2);
}

char *ausdk::flat_map<unsigned int,ausdk::AtomicValue<float>>::find(char *a1, char *a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t v4;
  char *v5;
  char *v6;
  unsigned int v7;

  if (a2 != a1)
  {
    v3 = (a2 - a1) >> 3;
    do
    {
      v4 = v3 >> 1;
      v5 = &a1[8 * (v3 >> 1)];
      v7 = *(_DWORD *)v5;
      v6 = v5 + 8;
      v3 += ~(v3 >> 1);
      if (v7 < a3)
        a1 = v6;
      else
        v3 = v4;
    }
    while (v3);
    if (a1 != a2 && *(_DWORD *)a1 == a3)
      return a1;
  }
  return a2;
}

float ausdk::AUElement::GetParameter(ausdk::AUElement *this, unsigned int a2)
{
  uint64_t v2;
  unsigned int *v3;
  char *v4;
  char *v5;
  ausdk::AUException *exception;
  ausdk::AUException *v9;
  int v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 40))
  {
    v2 = *((_QWORD *)this + 6);
    if (a2 >= (unint64_t)((*((_QWORD *)this + 7) - v2) >> 2))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v10 = 67109120;
        v11 = -10878;
        _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Warning: %s SetParameter for undefined param ID %u while initialized. Ignoring.", (uint8_t *)&v10, 8u);
      }
      exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
      ausdk::AUException::AUException(exception, -10878);
    }
    v3 = (unsigned int *)(v2 + 4 * a2);
  }
  else
  {
    v4 = (char *)*((_QWORD *)this + 3);
    v5 = ausdk::flat_map<unsigned int,ausdk::AtomicValue<float>>::find(*((char **)this + 2), v4, a2);
    if (v4 == v5)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v10 = 67109120;
        v11 = -10878;
        _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Warning: %s SetParameter for undefined param ID %u while initialized. Ignoring.", (uint8_t *)&v10, 8u);
      }
      v9 = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
      ausdk::AUException::AUException(v9, -10878);
    }
    v3 = (unsigned int *)(v5 + 4);
  }
  return COERCE_FLOAT(atomic_load(v3));
}

void sub_1B65B81E4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

ausdk::AUIOElement *ausdk::AUIOElement::AUIOElement(ausdk::AUIOElement *this, ausdk::AUBase *a2)
{
  uint64_t v3;

  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = 0;
  *((_BYTE *)this + 40) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_QWORD *)this = off_1E69ED7C0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 14) = 0;
  std::vector<AudioChannelLayout>::vector((_QWORD *)this + 15, 1uLL);
  v3 = *((_QWORD *)this + 15);
  *(_QWORD *)v3 = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_BYTE *)this + 168) = 1;
  *((_QWORD *)this + 10) = 0x40E5888000000000;
  *(_OWORD *)((char *)this + 88) = xmmword_1B6626900;
  *(_OWORD *)((char *)this + 104) = xmmword_1B66A0830;
  return this;
}

void sub_1B65B8294(_Unwind_Exception *a1)
{
  const void **v1;

  ausdk::AUElement::~AUElement(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::AUScope::SetNumberOfElements(int64x2_t *this, unsigned int a2)
{
  uint64_t result;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  char *v12;
  uint64_t v13;
  int64x2_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  int64x2_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int64x2_t v39;
  unint64_t v40;
  int64x2_t *v41;

  result = this[2].i64[1];
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  v4 = a2;
  v6 = this[1].i64[0];
  v5 = this[1].i64[1];
  v7 = (v5 - v6) >> 3;
  if (v7 >= a2)
  {
    if (v7 > a2)
    {
      v15 = (uint64_t *)(v5 - 8);
      v16 = v5 - 8;
      do
      {
        result = *v15;
        *v15 = 0;
        if (result)
          result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
        this[1].i64[1] = (uint64_t)v15;
        v17 = v16 - this[1].i64[0];
        v16 -= 8;
        --v15;
      }
      while (v4 < v17 >> 3);
    }
  }
  else
  {
    if (a2 > (unint64_t)((this[2].i64[0] - v6) >> 3))
    {
      v41 = this + 2;
      v8 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(a2);
      v11 = (_QWORD *)this[1].i64[0];
      v10 = (_QWORD *)this[1].i64[1];
      if (v10 == v11)
      {
        v14 = vdupq_n_s64((unint64_t)v10);
        v12 = &v8[8 * v7];
      }
      else
      {
        v12 = &v8[8 * v7];
        do
        {
          v13 = *--v10;
          *v10 = 0;
          *((_QWORD *)v12 - 1) = v13;
          v12 -= 8;
        }
        while (v10 != v11);
        v14 = this[1];
      }
      this[1].i64[0] = (uint64_t)v12;
      this[1].i64[1] = (uint64_t)&v8[8 * v7];
      v39 = v14;
      v18 = this[2].i64[0];
      this[2].i64[0] = (uint64_t)&v8[8 * v9];
      v40 = v18;
      v38 = v14.i64[0];
      result = std::__split_buffer<std::unique_ptr<DspLib::DynamicFilter::Algorithm>>::~__split_buffer((uint64_t)&v38);
      v7 = (this[1].i64[1] - this[1].i64[0]) >> 3;
    }
    for (; v7 < v4; v7 = ((uint64_t)v22 - this[1].i64[0]) >> 3)
    {
      v37 = 0;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, _QWORD, unint64_t))(*(_QWORD *)this->i64[0] + 416))(&v37, this->i64[0], this->u32[2], v7);
      v20 = (uint64_t *)this[1].i64[1];
      v19 = this[2].u64[0];
      if ((unint64_t)v20 >= v19)
      {
        v23 = this[1].i64[0];
        v24 = ((uint64_t)v20 - v23) >> 3;
        if ((unint64_t)(v24 + 1) >> 61)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v25 = v19 - v23;
        v26 = v25 >> 2;
        if (v25 >> 2 <= (unint64_t)(v24 + 1))
          v26 = v24 + 1;
        if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
          v27 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v27 = v26;
        v41 = this + 2;
        if (v27)
          v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v27);
        else
          v28 = 0;
        v29 = (uint64_t *)(v27 + 8 * v24);
        v30 = v27 + 8 * v28;
        v40 = v30;
        v31 = v37;
        v37 = 0;
        *v29 = v31;
        v22 = v29 + 1;
        v39.i64[1] = (uint64_t)(v29 + 1);
        v33 = (_QWORD *)this[1].i64[0];
        v32 = (_QWORD *)this[1].i64[1];
        if (v32 == v33)
        {
          v35 = vdupq_n_s64((unint64_t)v32);
        }
        else
        {
          do
          {
            v34 = *--v32;
            *v32 = 0;
            *--v29 = v34;
          }
          while (v32 != v33);
          v35 = this[1];
          v22 = (_QWORD *)v39.i64[1];
          v30 = v40;
        }
        this[1].i64[0] = (uint64_t)v29;
        this[1].i64[1] = (uint64_t)v22;
        v39 = v35;
        v36 = this[2].i64[0];
        this[2].i64[0] = v30;
        v40 = v36;
        v38 = v35.i64[0];
        std::__split_buffer<std::unique_ptr<DspLib::DynamicFilter::Algorithm>>::~__split_buffer((uint64_t)&v38);
      }
      else
      {
        v21 = v37;
        v37 = 0;
        *v20 = v21;
        v22 = v20 + 1;
      }
      this[1].i64[1] = (uint64_t)v22;
      result = v37;
      v37 = 0;
      if (result)
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
        v22 = (_QWORD *)this[1].i64[1];
      }
    }
  }
  return result;
}

void sub_1B65B8528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    (*(void (**)(uint64_t))(*(_QWORD *)a9 + 8))(a9);
  _Unwind_Resume(exception_object);
}

BOOL ausdk::AUScope::HasElementWithName(ausdk::AUScope *this)
{
  unint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  for (i = 0; ; ++i)
  {
    v3 = *((_QWORD *)this + 5);
    if (v3)
      LODWORD(v4) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    else
      v4 = (*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3;
    if (i >= v4)
      break;
    v5 = *((_QWORD *)this + 5);
    if (v5)
    {
      v6 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v5 + 32))(v5, i);
      if (!v6)
        continue;
    }
    else
    {
      v7 = *((_QWORD *)this + 2);
      if (i >= (*((_QWORD *)this + 3) - v7) >> 3)
        continue;
      v6 = *(_QWORD *)(v7 + 8 * i);
      if (!v6)
        continue;
    }
    if (*(_QWORD *)(v6 + 72))
      return i < v4;
  }
  return i < v4;
}

void ausdk::Owned<__CFDictionary *>::releaseRef(const void *a1)
{
  if (a1)
    CFRelease(a1);
}

void ausdk::AUScope::RestoreElementNames(ausdk::AUScope *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  uint64_t v6;
  uint64_t v7;
  CFIndex Count;
  unint64_t v9;
  uint64_t i;
  const void *Value;
  const void *v12;
  CFTypeID v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int *v17;
  _DWORD *v18;
  uint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  void **keys;
  void **v30;
  uint64_t v31;
  char buffer[16];
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v6 = *((_QWORD *)a2 + 5);
  if (v6)
    LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  else
    v7 = (*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 3;
  Count = CFDictionaryGetCount(a3);
  v9 = Count & ~(Count >> 63);
  keys = 0;
  v30 = 0;
  v31 = 0;
  std::vector<__CFString const*>::vector(&keys, v9);
  CFDictionaryGetKeysAndValues(a3, (const void **)keys, 0);
  if (Count >= 1)
  {
    for (i = 0; i != v9; ++i)
    {
      v28 = 0;
      *(_OWORD *)buffer = 0u;
      v33 = 0u;
      CFStringGetCString((CFStringRef)keys[i], buffer, 32, 0x600u);
      if (sscanf(buffer, "%u", &v28))
      {
        if (v28 < v7)
        {
          Value = CFDictionaryGetValue(a3, keys[i]);
          v12 = Value;
          if (Value)
          {
            v13 = CFGetTypeID(Value);
            if (v13 == CFStringGetTypeID())
            {
              v14 = *((_QWORD *)a2 + 5);
              if (v14)
              {
                v15 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 32))(v14, v28);
                if (v15)
                  goto LABEL_12;
              }
              else
              {
                v19 = *((_QWORD *)a2 + 2);
                if (v28 < (unint64_t)((*((_QWORD *)a2 + 3) - v19) >> 3))
                {
                  v15 = *(_QWORD *)(v19 + 8 * v28);
                  if (v15)
                  {
LABEL_12:
                    ausdk::Owned<__CFString const*>::operator=((const void **)(v15 + 72), v12);
                    v17 = (unsigned int *)*((_QWORD *)this + 1);
                    v16 = *((_QWORD *)this + 2);
                    if ((unint64_t)v17 >= v16)
                    {
                      v20 = *(unsigned int **)this;
                      v21 = ((uint64_t)v17 - *(_QWORD *)this) >> 2;
                      v22 = v21 + 1;
                      if ((unint64_t)(v21 + 1) >> 62)
                        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
                      v23 = v16 - (_QWORD)v20;
                      if (v23 >> 1 > v22)
                        v22 = v23 >> 1;
                      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL)
                        v24 = 0x3FFFFFFFFFFFFFFFLL;
                      else
                        v24 = v22;
                      if (v24)
                      {
                        v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)this + 16, v24);
                        v20 = *(unsigned int **)this;
                        v17 = (unsigned int *)*((_QWORD *)this + 1);
                      }
                      else
                      {
                        v25 = 0;
                      }
                      v26 = (unsigned int *)&v25[4 * v21];
                      *v26 = v28;
                      v18 = v26 + 1;
                      while (v17 != v20)
                      {
                        v27 = *--v17;
                        *--v26 = v27;
                      }
                      *(_QWORD *)this = v26;
                      *((_QWORD *)this + 1) = v18;
                      *((_QWORD *)this + 2) = &v25[4 * v24];
                      if (v20)
                        operator delete(v20);
                    }
                    else
                    {
                      *v17 = v28;
                      v18 = v17 + 1;
                    }
                    *((_QWORD *)this + 1) = v18;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (keys)
  {
    v30 = keys;
    operator delete(keys);
  }
}

void sub_1B65B88A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  uint64_t v13;
  void *v15;

  v15 = *(void **)v13;
  if (*(_QWORD *)v13)
  {
    *(_QWORD *)(v13 + 8) = v15;
    operator delete(v15);
  }
  _Unwind_Resume(exception_object);
}

UInt8 *ausdk::AUScope::SaveState(ausdk::AUScope *this, __CFData *a2)
{
  uint64_t v4;
  UInt8 *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex Length;
  unint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int *v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  CFIndex v21;
  UInt8 v22[4];
  UInt8 v23[4];
  UInt8 bytes[16];
  __int128 v25;
  __int128 v26;
  CFTypeRef v27[2];
  CFTypeRef cf[2];
  __int128 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 5);
  if (!v4)
  {
    result = (UInt8 *)((*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3);
    if (!(_DWORD)result)
      return result;
    goto LABEL_5;
  }
  result = (UInt8 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  if ((_DWORD)result)
  {
LABEL_5:
    v6 = 0;
    v20 = result;
    do
    {
      v7 = *((_QWORD *)this + 5);
      if (v7)
        v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 32))(v7, v6);
      else
        v8 = *(_QWORD *)(*((_QWORD *)this + 2) + 8 * v6);
      result = (UInt8 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
      if (!(_DWORD)result)
        goto LABEL_39;
      *(_DWORD *)bytes = bswap32(*((_DWORD *)this + 2));
      CFDataAppendBytes(a2, bytes, 4);
      *(_DWORD *)bytes = bswap32(v6);
      CFDataAppendBytes(a2, bytes, 4);
      v9 = *((unsigned int *)this + 2);
      v30 = 0;
      *(_OWORD *)cf = 0u;
      v29 = 0u;
      v26 = 0u;
      *(_OWORD *)v27 = 0u;
      *(_OWORD *)bytes = 0u;
      v25 = 0u;
      Length = CFDataGetLength(a2);
      *(_DWORD *)v22 = 0;
      CFDataAppendBytes(a2, v22, 4);
      v21 = Length;
      if (*(_BYTE *)(v8 + 40))
      {
        v11 = *(_QWORD *)(v8 + 56) - *(_QWORD *)(v8 + 48);
        if ((v11 & 0x3FFFFFFFCLL) != 0)
        {
          v12 = 0;
          v13 = 0;
          v14 = (v11 >> 2);
          do
          {
            v15 = atomic_load((unsigned int *)(*(_QWORD *)(v8 + 48) + 4 * v12));
            if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t, UInt8 *))(**(_QWORD **)(v8 + 8) + 256))(*(_QWORD *)(v8 + 8), v9, v12, bytes))
            {
              goto LABEL_14;
            }
            if ((v30 & 0x10) != 0)
            {
              if (cf[1])
                CFRelease(cf[1]);
              if ((_DWORD)v29 == 26)
              {
                if (v27[1])
                  CFRelease(v27[1]);
              }
            }
            if ((v30 & 0xA000) == 0)
            {
LABEL_14:
              *(_DWORD *)v23 = bswap32(v12);
              CFDataAppendBytes(a2, v23, 4);
              *(_DWORD *)v23 = bswap32(v15);
              CFDataAppendBytes(a2, v23, 4);
              ++v13;
            }
            ++v12;
          }
          while (v14 != v12);
          goto LABEL_38;
        }
      }
      else
      {
        v17 = *(unsigned int **)(v8 + 16);
        v16 = *(unsigned int **)(v8 + 24);
        if (v17 != v16)
        {
          v13 = 0;
          do
          {
            v18 = *v17;
            v19 = atomic_load(v17 + 1);
            if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t, UInt8 *))(**(_QWORD **)(v8 + 8) + 256))(*(_QWORD *)(v8 + 8), v9, v18, bytes))
            {
              goto LABEL_27;
            }
            if ((v30 & 0x10) != 0)
            {
              if (cf[1])
                CFRelease(cf[1]);
              if ((_DWORD)v29 == 26 && v27[1])
                CFRelease(v27[1]);
            }
            if ((v30 & 0xA000) == 0)
            {
LABEL_27:
              *(_DWORD *)v23 = bswap32(v18);
              CFDataAppendBytes(a2, v23, 4);
              *(_DWORD *)v23 = bswap32(v19);
              CFDataAppendBytes(a2, v23, 4);
              ++v13;
            }
            v17 += 2;
          }
          while (v17 != v16);
          goto LABEL_38;
        }
      }
      v13 = 0;
LABEL_38:
      result = CFDataGetMutableBytePtr(a2);
      *(_DWORD *)&result[v21] = bswap32(v13);
LABEL_39:
      ++v6;
    }
    while (v6 != v20);
  }
  return result;
}

const unsigned __int8 *ausdk::AUScope::RestoreState(ausdk::AUScope *this, const unsigned __int8 *a2)
{
  unint64_t v4;
  uint64_t v5;
  ausdk::AUElement *v6;
  uint64_t v7;
  char *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;

  v4 = bswap32(*(_DWORD *)a2);
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    v6 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v5 + 32))(v5, v4);
    if (!v6)
      return &a2[8 * bswap32(*((_DWORD *)a2 + 1)) + 8];
  }
  else
  {
    v8 = (char *)this + 16;
    v7 = *((_QWORD *)this + 2);
    if (v4 >= (*((_QWORD *)v8 + 1) - v7) >> 3)
      return &a2[8 * bswap32(*((_DWORD *)a2 + 1)) + 8];
    v6 = *(ausdk::AUElement **)(v7 + 8 * v4);
    if (!v6)
      return &a2[8 * bswap32(*((_DWORD *)a2 + 1)) + 8];
  }
  v9 = *((_DWORD *)a2 + 1);
  v10 = (unsigned int *)(a2 + 8);
  if (v9)
  {
    v11 = bswap32(v9);
    if (v11 <= 1)
      v12 = 1;
    else
      v12 = v11;
    do
    {
      v13 = *v10;
      v14 = v10[1];
      v10 += 2;
      ausdk::AUElement::SetParameter(v6, bswap32(v13), COERCE_FLOAT(bswap32(v14)), 0);
      --v12;
    }
    while (v12);
  }
  return (const unsigned __int8 *)v10;
}

void ausdk::AUEffectBase::~AUEffectBase(ausdk::AUEffectBase *this)
{
  void **v2;

  *(_QWORD *)this = &off_1E69ED840;
  v2 = (void **)((char *)this + 528);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v2);
  ausdk::AUBase::~AUBase(this);
}

{
  void **v2;

  *(_QWORD *)this = &off_1E69ED840;
  v2 = (void **)((char *)this + 528);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v2);
  ausdk::AUBase::~AUBase(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t ausdk::AUEffectBase::Initialize(int64x2_t *this)
{
  ausdk::AUScope *v2;
  int v3;
  int v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v8;
  uint64_t v9;
  __int16 *v10;
  int v11;
  int v12;
  BOOL v14;
  BOOL v15;
  BOOL v16;
  BOOL v19;
  uint64_t result;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  char *v30;
  uint64_t v31;
  int64x2_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  unint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  uint64_t v54;
  int64x2_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _OWORD v63[2];
  int64x2_t *v64;

  v2 = (ausdk::AUScope *)&this[5];
  v3 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[5], 0) + 108);
  v4 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[8], 0) + 108);
  v61 = 0;
  v5 = (*(uint64_t (**)(int64x2_t *, uint64_t *))(this->i64[0] + 376))(this, &v61);
  if (v5)
    v6 = v61 == 0;
  else
    v6 = 1;
  if (!v6)
  {
    v9 = 0;
    while (1)
    {
      v10 = (__int16 *)(v61 + 4 * v9);
      v11 = *v10;
      v12 = v10[1];
      if (v11 < 0 && v12 < 0)
      {
        if (v11 == -1 && v12 == -2)
          goto LABEL_10;
        v14 = (v11 & v12) == 0xFFFFFFFF && (unsigned __int16)(v4 ^ v3) == 0;
        v15 = v14;
        v16 = v12 == -1 && v11 == -2;
        if (v16 || v15)
          goto LABEL_10;
LABEL_44:
        if (++v9 >= (unint64_t)v5)
          return 4294956428;
      }
      else
      {
        if (v11 != -1 && (__int16)v3 != v11)
          goto LABEL_44;
        v19 = v12 == -1 || (__int16)v4 == v12;
        if (++v9 >= (unint64_t)v5 || v19)
        {
          if (!v19)
            return 4294956428;
LABEL_10:
          if (this[36].i8[8])
            v8 = 1;
          else
            v8 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[8], 0) + 108);
          v21 = this[33].i64[1];
          v22 = this[33].i64[0];
          v23 = v21 - v22;
          v24 = (v21 - v22) >> 3;
          v25 = v8;
          if (v24 >= v8)
          {
            if (v24 > v8)
            {
              v33 = (uint64_t *)(v21 - 8);
              v34 = v21 - 8;
              do
              {
                v35 = *v33;
                *v33 = 0;
                if (v35)
                  (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
                this[33].i64[1] = (uint64_t)v33;
                v36 = v34 - this[33].i64[0];
                v34 -= 8;
                --v33;
              }
              while (v25 < v36 >> 3);
            }
          }
          else
          {
            if (v8 > (unint64_t)((this[34].i64[0] - v22) >> 3))
            {
              v64 = this + 34;
              v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v8);
              v28 = (_QWORD *)this[33].i64[1];
              v29 = (_QWORD *)this[33].i64[0];
              if (v28 == v29)
              {
                v32 = vdupq_n_s64((unint64_t)v28);
                v30 = &v26[8 * v24];
              }
              else
              {
                v30 = &v26[8 * v24];
                do
                {
                  v31 = *--v28;
                  *v28 = 0;
                  *((_QWORD *)v30 - 1) = v31;
                  v30 -= 8;
                }
                while (v28 != v29);
                v32 = this[33];
              }
              this[33].i64[0] = (uint64_t)v30;
              this[33].i64[1] = (uint64_t)&v26[8 * v24];
              *(int64x2_t *)((char *)v63 + 8) = v32;
              v37 = this[34].i64[0];
              this[34].i64[0] = (uint64_t)&v26[8 * v27];
              *((_QWORD *)&v63[1] + 1) = v37;
              *(_QWORD *)&v63[0] = v32.i64[0];
              std::__split_buffer<std::unique_ptr<DspLib::DynamicFilter::Algorithm>>::~__split_buffer((uint64_t)v63);
              v23 = this[33].i64[1] - this[33].i64[0];
            }
            v38 = v23 >> 3;
            if (v25 > (v23 >> 3))
            {
              do
              {
                (*(void (**)(uint64_t *__return_ptr, int64x2_t *))(this->i64[0] + 576))(&v62, this);
                v39 = (_QWORD *)this[33].i64[1];
                v40 = this[34].u64[0];
                if ((unint64_t)v39 >= v40)
                {
                  v43 = this[33].i64[0];
                  v44 = ((uint64_t)v39 - v43) >> 3;
                  if ((unint64_t)(v44 + 1) >> 61)
                    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
                  v45 = v40 - v43;
                  v46 = v45 >> 2;
                  if (v45 >> 2 <= (unint64_t)(v44 + 1))
                    v46 = v44 + 1;
                  if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8)
                    v47 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v47 = v46;
                  v64 = this + 34;
                  if (v47)
                    v47 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v47);
                  else
                    v48 = 0;
                  v49 = (_QWORD *)(v47 + 8 * v44);
                  v50 = v47 + 8 * v48;
                  *((_QWORD *)&v63[1] + 1) = v50;
                  v51 = v62;
                  v62 = 0;
                  *v49 = v51;
                  v42 = v49 + 1;
                  *(_QWORD *)&v63[1] = v49 + 1;
                  v52 = (_QWORD *)this[33].i64[1];
                  v53 = (_QWORD *)this[33].i64[0];
                  if (v52 == v53)
                  {
                    v55 = vdupq_n_s64((unint64_t)v52);
                  }
                  else
                  {
                    do
                    {
                      v54 = *--v52;
                      *v52 = 0;
                      *--v49 = v54;
                    }
                    while (v52 != v53);
                    v55 = this[33];
                    v50 = *((_QWORD *)&v63[1] + 1);
                    v42 = *(_QWORD **)&v63[1];
                  }
                  this[33].i64[0] = (uint64_t)v49;
                  this[33].i64[1] = (uint64_t)v42;
                  *(int64x2_t *)((char *)v63 + 8) = v55;
                  v56 = this[34].i64[0];
                  this[34].i64[0] = v50;
                  *((_QWORD *)&v63[1] + 1) = v56;
                  *(_QWORD *)&v63[0] = v55.i64[0];
                  std::__split_buffer<std::unique_ptr<DspLib::DynamicFilter::Algorithm>>::~__split_buffer((uint64_t)v63);
                }
                else
                {
                  v41 = v62;
                  v62 = 0;
                  *v39 = v41;
                  v42 = v39 + 1;
                }
                this[33].i64[1] = (uint64_t)v42;
                v57 = v62;
                v62 = 0;
                if (v57)
                  (*(void (**)(uint64_t))(*(_QWORD *)v57 + 8))(v57);
                LODWORD(v38) = v38 + 1;
              }
              while ((_DWORD)v38 != (_DWORD)v25);
            }
          }
          if ((_DWORD)v25)
          {
            v58 = 0;
            v59 = this[33].i64[0];
            do
            {
              v60 = *(_QWORD *)(v59 + 8 * v58);
              if (v60)
                *(_DWORD *)(v60 + 16) = v58;
              ++v58;
            }
            while (v25 != v58);
          }
          this[35].i64[1] = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[8], 0);
          this[36].i64[0] = ausdk::AUScope::SafeGetElement(v2, 0);
          v64 = 0;
          memset(v63, 0, sizeof(v63));
          (*(void (**)(_OWORD *__return_ptr, int64x2_t *, uint64_t, _QWORD))(this->i64[0] + 392))(v63, this, 2, 0);
          result = 0;
          this[36].i32[3] = DWORD2(v63[1]);
          return result;
        }
      }
    }
  }
  if (v4 << 16 == v3 << 16 && v4 << 16 != 0)
    goto LABEL_10;
  return 4294956428;
}

void sub_1B65B9164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

double ausdk::AUEffectBase::Cleanup(ausdk::AUEffectBase *this)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  double result;

  v2 = (_QWORD *)*((_QWORD *)this + 67);
  v3 = (_QWORD *)*((_QWORD *)this + 66);
  while (v2 != v3)
  {
    v5 = *--v2;
    v4 = v5;
    *v2 = 0;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  *((_QWORD *)this + 67) = v3;
  result = 0.0;
  *(_OWORD *)((char *)this + 568) = 0u;
  return result;
}

uint64_t ausdk::AUEffectBase::Reset(ausdk::AUEffectBase *this)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)*((_QWORD *)this + 66);
  v2 = (_QWORD *)*((_QWORD *)this + 67);
  while (v1 != v2)
  {
    if (*v1)
      (*(void (**)(_QWORD))(*(_QWORD *)*v1 + 16))(*v1);
    ++v1;
  }
  return 0;
}

uint64_t ausdk::AUEffectBase::GetPropertyInfo(ausdk::AUEffectBase *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;

  if (a3 || (a2 | 8) != 0x1D)
    return 4294956417;
  result = 0;
  *a6 = 1;
  *a5 = 4;
  return result;
}

uint64_t ausdk::AUEffectBase::GetProperty(ausdk::AUEffectBase *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  unsigned __int8 *v6;

  if (a3)
    return 4294956417;
  if (a2 == 29)
  {
    v6 = (unsigned __int8 *)this + 554;
  }
  else
  {
    if (a2 != 21)
      return 4294956417;
    v6 = (unsigned __int8 *)this + 552;
  }
  result = 0;
  *a5 = *v6;
  return result;
}

uint64_t ausdk::AUEffectBase::SetProperty(ausdk::AUEffectBase *this, int a2, int a3, unsigned int a4, int *a5, unsigned int a6)
{
  uint64_t result;
  int v8;

  if (a3)
    return 4294956417;
  if (a2 == 29)
  {
    result = 0;
    *((_BYTE *)this + 554) = *a5 != 0;
  }
  else if (a2 == 21)
  {
    if (a6 < 4)
    {
      return 4294956445;
    }
    else
    {
      v8 = *a5;
      if ((*a5 != 0) != (*((_BYTE *)this + 552) != 0))
      {
        if (!v8 && *((_BYTE *)this + 552))
        {
          if (*((_BYTE *)this + 17))
            (*(void (**)(ausdk::AUEffectBase *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
        }
        (*(void (**)(ausdk::AUEffectBase *, BOOL))(*(_QWORD *)this + 584))(this, v8 != 0);
      }
      return 0;
    }
  }
  else
  {
    return 4294956417;
  }
  return result;
}

uint64_t ausdk::AUEffectBase::ProcessBufferLists(ausdk::AUEffectBase *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  char IsInputSilent;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;
  char v18;

  if (((*(uint64_t (**)(ausdk::AUEffectBase *))(*(_QWORD *)this + 592))(this) & 1) == 0)
  {
    IsInputSilent = ausdk::AUEffectBase::IsInputSilent(this, *a2, a5);
    *a2 |= 0x10u;
    v11 = *((_QWORD *)this + 67);
    v12 = *((_QWORD *)this + 66);
    if (v11 != v12)
    {
      v13 = IsInputSilent;
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = *(_QWORD *)(v12 + 8 * v14);
        if (v16)
        {
          v18 = v13;
          (*(void (**)(uint64_t, void *, void *, uint64_t, char *))(*(_QWORD *)v16 + 24))(v16, a3->mBuffers[v14].mData, a4->mBuffers[v14].mData, a5, &v18);
          if (!v18)
            *a2 &= ~0x10u;
          v11 = *((_QWORD *)this + 67);
          v12 = *((_QWORD *)this + 66);
        }
        v14 = v15++;
      }
      while (v14 < (v11 - v12) >> 3);
    }
  }
  return 0;
}

uint64_t ausdk::AUEffectBase::Render(ausdk::AUInputElement **this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  uint64_t v8;
  ausdk::AUInputElement *v9;
  const AudioBufferList *BufferList;
  ausdk::AUInputElement *v11;
  AudioBufferList *v12;
  ausdk::AUInputElement *v14;
  ausdk::AUInputElement *v15;
  unsigned int *v16;
  uint64_t v17;
  unsigned int *v18;
  int v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _DWORD *v26;
  unsigned int *v27;
  unsigned int v28;
  void **v29;
  _QWORD v30[3];

  if (!ausdk::AUBase::HasInput((ausdk::AUBase *)this, 0))
    return 4294956420;
  v8 = ausdk::AUInputElement::PullInput(this[72], a2, a3, 0, a4);
  if (!(_DWORD)v8)
  {
    if (*((_BYTE *)this + 554))
    {
      v9 = this[71];
      if (*((_BYTE *)v9 + 168))
      {
        BufferList = (const AudioBufferList *)ausdk::AUBufferList::GetBufferList((ausdk::AUInputElement *)((char *)this[72] + 144));
        ausdk::AUBufferList::SetBufferList((ausdk::AUInputElement *)((char *)v9 + 144), BufferList);
      }
    }
    if ((*((unsigned int (**)(ausdk::AUInputElement **))*this + 74))(this))
    {
      if (!*((_BYTE *)this + 554))
      {
        v11 = this[72];
        v12 = (AudioBufferList *)ausdk::AUBufferList::GetBufferList((ausdk::AUInputElement *)((char *)this[71] + 144));
        ausdk::AUBufferList::CopyBufferContentsTo((_QWORD *)v11 + 18, v12);
      }
      v8 = 0;
    }
    else
    {
      v14 = this[48];
      v15 = this[49];
      v16 = (unsigned int *)ausdk::AUBufferList::GetBufferList((ausdk::AUInputElement *)((char *)this[72] + 144));
      v17 = ausdk::AUBufferList::GetBufferList((ausdk::AUInputElement *)((char *)this[71] + 144));
      v18 = (unsigned int *)v17;
      if (v14 == v15)
      {
        v8 = (*((uint64_t (**)(ausdk::AUInputElement **, unsigned int *, unsigned int *, uint64_t, uint64_t))*this
              + 22))(this, a2, v16, v17, a4);
      }
      else
      {
        v30[0] = a2;
        v30[1] = v16;
        v30[2] = v17;
        v8 = (*((uint64_t (**)(ausdk::AUInputElement **, char *, uint64_t, _QWORD *))*this + 70))(this, (char *)this + 384, a4, v30);
        v19 = *((_DWORD *)this + 147) * a4;
        v20 = *v16;
        if ((_DWORD)v20)
        {
          v21 = v16 + 4;
          do
          {
            v22 = (*((_DWORD *)v21 - 2) * v19);
            *v21 -= v22;
            *((_DWORD *)v21 - 1) = v22;
            v21 += 2;
            --v20;
          }
          while (v20);
        }
        v23 = *v18;
        if ((_DWORD)v23)
        {
          v24 = v18 + 4;
          do
          {
            v25 = (*((_DWORD *)v24 - 2) * v19);
            *v24 -= v25;
            *((_DWORD *)v24 - 1) = v25;
            v24 += 2;
            --v23;
          }
          while (v23);
        }
      }
    }
    if ((*(_BYTE *)a2 & 0x10) != 0 && !*((_BYTE *)this + 554))
    {
      v26 = (_DWORD *)ausdk::AUBufferList::GetBufferList((ausdk::AUInputElement *)((char *)this[71] + 144));
      if (*v26)
      {
        v27 = v26;
        v28 = 0;
        v29 = (void **)(v26 + 4);
        do
        {
          bzero(*v29, *((unsigned int *)v29 - 1));
          ++v28;
          v29 += 2;
        }
        while (v28 < *v27);
      }
    }
  }
  return v8;
}

BOOL ausdk::AUEffectBase::StreamFormatWritable(ausdk::AUEffectBase *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t ausdk::AUEffectBase::ChangeStreamFormat(ausdk::AUEffectBase *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  ausdk::AUBase::ChangeStreamFormat(this, a2, a3, a4, a5);
  if (*((_BYTE *)this + 553) && a4->mSampleRate != a5->mSampleRate)
    (*(void (**)(ausdk::AUEffectBase *, uint64_t, _QWORD, _QWORD, Float64))(*(_QWORD *)this + 432))(this, 3, 0, 0, a4->mSampleRate);
  return 0;
}

uint64_t ausdk::AUEffectBase::ProcessScheduledSlice(ausdk::AUEffectBase *this, uint64_t *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t result;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;

  v5 = *a2;
  v7 = (unsigned int *)a2[1];
  v6 = (unsigned int *)a2[2];
  v8 = *((_DWORD *)this + 147) * a4;
  v9 = *v7;
  if ((_DWORD)v9)
  {
    v10 = v7 + 3;
    do
    {
      *v10 = *(v10 - 1) * v8;
      v10 += 4;
      --v9;
    }
    while (v9);
  }
  v11 = *v6;
  if ((_DWORD)v11)
  {
    v12 = v6 + 3;
    do
    {
      *v12 = *(v12 - 1) * v8;
      v12 += 4;
      --v11;
    }
    while (v11);
  }
  result = (*(uint64_t (**)(ausdk::AUEffectBase *, uint64_t, unsigned int *, unsigned int *, uint64_t))(*(_QWORD *)this + 176))(this, v5, v7, v6, a4);
  v14 = *v7;
  if ((_DWORD)v14)
  {
    v15 = v7 + 4;
    do
    {
      *v15 += (*((_DWORD *)v15 - 2) * v8);
      v15 += 2;
      --v14;
    }
    while (v14);
  }
  v16 = *v6;
  if ((_DWORD)v16)
  {
    v17 = v6 + 4;
    do
    {
      *v17 += (*((_DWORD *)v17 - 2) * v8);
      v17 += 2;
      --v16;
    }
    while (v16);
  }
  return result;
}

uint64_t ausdk::AUMethodInitialize(ausdk *this, void *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *((_QWORD *)this + 67);
  if (v3)
    (*(void (**)(_QWORD, void *))(*(_QWORD *)v3 + 16))(*((_QWORD *)this + 67), a2);
  if (*((_BYTE *)this + 81))
  {
    v4 = 0;
  }
  else
  {
    v4 = (*(uint64_t (**)(char *, void *))(*((_QWORD *)this + 8) + 56))((char *)this + 64, a2);
    if (!(_DWORD)v4)
    {
      if ((*(unsigned int (**)(char *))(*((_QWORD *)this + 8) + 160))((char *)this + 64))
        std::vector<AudioUnitParameterEvent>::reserve((void **)this + 56, 0x18uLL);
      *((_BYTE *)this + 82) = 1;
      (*(void (**)(char *))(*((_QWORD *)this + 8) + 496))((char *)this + 64);
      v4 = 0;
      *((_BYTE *)this + 81) = 1;
      __dmb(0xBu);
    }
  }
  if (v3)
    (*(void (**)(uint64_t, void *))(*(_QWORD *)v3 + 24))(v3, a2);
  return v4;
}

void sub_1B65B98A0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65B9888);
}

uint64_t ausdk::AUMethodUninitialize(ausdk *this, void *a2)
{
  uint64_t v3;
  char *v4;

  v3 = *((_QWORD *)this + 67);
  if (v3)
    (*(void (**)(_QWORD, void *))(*(_QWORD *)v3 + 16))(*((_QWORD *)this + 67), a2);
  v4 = (char *)this + 64;
  if (*((_BYTE *)this + 81))
    (*(void (**)(char *, void *))(*(_QWORD *)v4 + 64))((char *)this + 64, a2);
  (*(void (**)(char *, void *))(*(_QWORD *)v4 + 504))((char *)this + 64, a2);
  *((_QWORD *)this + 49) = 0;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((_QWORD *)this + 42) = 0xFFEFFFFFFFFFFFFFLL;
  *(_WORD *)((char *)this + 81) = 0;
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    return 0;
  }
  return v3;
}

void sub_1B65B99D0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65B99BCLL);
}

uint64_t ausdk::AUMethodGetPropertyInfo(ausdk *this, void *a2, uint64_t a3, uint64_t a4, unsigned int *a5, unsigned int *a6, unsigned __int8 *a7)
{
  int v11;
  uint64_t v13;
  uint64_t PropertyInfo;
  BOOL v16;
  unsigned int v17;

  v11 = (int)a2;
  v17 = 0;
  v16 = 0;
  v13 = *((_QWORD *)this + 67);
  if (v13)
    (*(void (**)(_QWORD, void *, uint64_t, uint64_t, unsigned int *, unsigned int *, unsigned __int8 *))(*(_QWORD *)v13 + 16))(*((_QWORD *)this + 67), a2, a3, a4, a5, a6, a7);
  PropertyInfo = ausdk::AUBase::DispatchGetPropertyInfo((ausdk *)((char *)this + 64), v11, a3, a4, &v17, &v16);
  if (a5)
    *a5 = v17;
  if (a6)
    *(_BYTE *)a6 = v16;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  return PropertyInfo;
}

void sub_1B65B9B18(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65B9AF8);
}

uint64_t ausdk::AUMethodGetProperty(ausdk *this, void *a2, uint64_t a3, uint64_t a4, _OWORD *a5, _DWORD *a6, unsigned int *a7)
{
  int v11;
  uint64_t v13;
  size_t v14;
  ausdk::AUBase *v15;
  uint64_t v16;
  uint64_t PropertyInfo;
  NSObject *v18;
  const char *v19;
  int v20;
  void *v22;
  _OWORD *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  unsigned int v27;
  BOOL v28;

  v11 = (int)a2;
  v28 = 0;
  v13 = *((_QWORD *)this + 67);
  if (v13)
    (*(void (**)(_QWORD, void *, uint64_t, uint64_t, _OWORD *, _DWORD *, unsigned int *))(*(_QWORD *)v13 + 16))(*((_QWORD *)this + 67), a2, a3, a4, a5, a6, a7);
  if (!a6)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
LABEL_13:
      PropertyInfo = 0;
      v16 = 4294967246;
LABEL_14:
      v20 = 1;
      if (!v13)
        goto LABEL_16;
      goto LABEL_15;
    }
    LOWORD(v24) = 0;
    v18 = MEMORY[0x1E0C81028];
    v19 = "AudioUnitGetProperty: null size pointer";
LABEL_32:
    _os_log_error_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_ERROR, v19, (uint8_t *)&v24, 2u);
    goto LABEL_13;
  }
  if (!a5)
  {
    LODWORD(v24) = 0;
    PropertyInfo = ausdk::AUBase::DispatchGetPropertyInfo((ausdk *)((char *)this + 64), v11, a3, a4, (unsigned int *)&v24, &v28);
    *a6 = (_DWORD)v24;
    v20 = 1;
    v16 = PropertyInfo;
    if (!v13)
      goto LABEL_16;
LABEL_15:
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
    goto LABEL_16;
  }
  v14 = *a6;
  if (!(_DWORD)v14)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_13;
    LOWORD(v24) = 0;
    v18 = MEMORY[0x1E0C81028];
    v19 = "AudioUnitGetProperty: *ioDataSize == 0 on entry";
    goto LABEL_32;
  }
  v27 = 0;
  v15 = (ausdk *)((char *)this + 64);
  v16 = ausdk::AUBase::DispatchGetPropertyInfo((ausdk *)((char *)this + 64), v11, a3, a4, &v27, &v28);
  if ((_DWORD)v16)
  {
    PropertyInfo = 0;
    goto LABEL_14;
  }
  v22 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v23 = a5;
  if (v14 < v27)
  {
    std::vector<std::byte>::__append((unint64_t *)&v24, v27);
    v22 = v24;
    v23 = v24;
  }
  PropertyInfo = ausdk::AUBase::DispatchGetProperty(v15, v11, a3, a4, v23);
  if ((_DWORD)PropertyInfo)
  {
    *a6 = 0;
  }
  else if (v14 >= v27 || v22 == v25)
  {
    *a6 = v27;
  }
  else
  {
    memcpy(a5, v22, v14);
  }
  if (v22)
    operator delete(v22);
  v20 = 0;
  if (v13)
    goto LABEL_15;
LABEL_16:
  if (!v20)
    return PropertyInfo;
  return v16;
}

void sub_1B65B9DD0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  uint64_t v9;

  if (__p)
    operator delete(__p);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65B9CE0);
}

uint64_t ausdk::AUMethodSetProperty(ausdk *this, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *__s2, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  NSObject *v16;
  const char *v17;
  char v18;
  char *v19;
  _OWORD v21[2];
  uint64_t v22;

  v12 = *((_QWORD *)this + 67);
  if (v12)
    (*(void (**)(_QWORD))(*(_QWORD *)v12 + 16))(*((_QWORD *)this + 67));
  if (__s2 && (_DWORD)a6)
  {
    v13 = ausdk::AUBase::DispatchSetProperty((const void **)this + 8, a2, a3, a4, __s2, a6);
LABEL_6:
    v14 = v13;
    goto LABEL_32;
  }
  if (!__s2 && !(_DWORD)a6)
  {
    v15 = (char *)this + 64;
    if ((int)a2 <= 26)
    {
      if ((_DWORD)a2 != 19)
      {
        if ((_DWORD)a2 == 25)
        {
          ausdk::Owned<__CFString const*>::operator=((const void **)this + 73, 0);
LABEL_31:
          v14 = 0;
LABEL_32:
          v18 = 1;
          if (!v12)
            goto LABEL_34;
          goto LABEL_33;
        }
LABEL_28:
        v13 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15 + 104))((char *)this + 64, a2, a3, a4);
        goto LABEL_6;
      }
      v14 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v15 + 544))((char *)this + 64, a3, a4);
      if ((_DWORD)v14)
        goto LABEL_32;
LABEL_25:
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15 + 432))(v15, a2, a3, a4);
      goto LABEL_31;
    }
    if ((_DWORD)a2 == 27)
    {
      if (!(_DWORD)a3)
      {
        v22 = 0;
        memset(v21, 0, sizeof(v21));
        v19 = (char *)this + 544;
        if (memcmp(v19, v21, 0x28uLL))
        {
          *((_QWORD *)v19 + 4) = 0;
          *(_OWORD *)v19 = 0u;
          *((_OWORD *)v19 + 1) = 0u;
          (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v15 + 432))(v15, 27, 0, a4);
        }
        goto LABEL_31;
      }
    }
    else
    {
      if ((_DWORD)a2 != 54)
        goto LABEL_28;
      if (!(_DWORD)a3)
      {
        ausdk::Owned<__CFString const*>::operator=((const void **)this + 66, 0);
        goto LABEL_25;
      }
    }
    v14 = 4294956430;
    goto LABEL_32;
  }
  if (!__s2)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_22;
    LOWORD(v21[0]) = 0;
    v16 = MEMORY[0x1E0C81028];
    v17 = "AudioUnitSetProperty: inData == NULL";
    goto LABEL_38;
  }
  if ((_DWORD)a6)
    goto LABEL_31;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21[0]) = 0;
    v16 = MEMORY[0x1E0C81028];
    v17 = "AudioUnitSetProperty: inDataSize == 0";
LABEL_38:
    _os_log_error_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)v21, 2u);
  }
LABEL_22:
  v18 = 0;
  v14 = 0;
  if (v12)
LABEL_33:
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
LABEL_34:
  if ((v18 & 1) == 0)
    return 4294967246;
  return v14;
}

void sub_1B65BA0D0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65BA080);
}

uint64_t ausdk::AUMethodGetParameter(ausdk *this, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, float *a6)
{
  uint64_t v11;
  uint64_t v12;

  v11 = *((_QWORD *)this + 67);
  if (v11)
    (*(void (**)(_QWORD, void *, uint64_t, uint64_t, uint64_t, float *))(*(_QWORD *)v11 + 16))(*((_QWORD *)this + 67), a2, a3, a4, a5, a6);
  if (a5)
  {
    v12 = (*(uint64_t (**)(char *, void *, uint64_t, uint64_t, uint64_t, float *))(*((_QWORD *)this + 8) + 144))((char *)this + 64, a2, a3, a4, a5, a6);
    if (!v11)
      return v12;
    goto LABEL_7;
  }
  v12 = 4294967246;
  if (v11)
LABEL_7:
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  return v12;
}

void sub_1B65BA1F8(void *a1)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65BA1E0);
}

uint64_t ausdk::AUMethodSetParameter(ausdk *this, void *a2, float a3)
{
  if ((LODWORD(a3) & 0x7FFFFFFFu) > 0x7F7FFFFF)
    return 4294900553;
  else
    return (*(uint64_t (**)(char *, void *))(*((_QWORD *)this + 8) + 152))((char *)this + 64, a2);
}

uint64_t ausdk::AUMethodReset(ausdk *this, void *a2, uint64_t a3)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = *((_QWORD *)this + 67);
  if (v6)
    (*(void (**)(_QWORD))(*(_QWORD *)v6 + 16))(*((_QWORD *)this + 67));
  v8 = *((_QWORD *)this + 8);
  v7 = (char *)this + 64;
  *((_QWORD *)v7 + 41) = 0;
  *(_OWORD *)(v7 + 312) = 0u;
  *(_OWORD *)(v7 + 296) = 0u;
  *(_OWORD *)(v7 + 280) = 0u;
  *((_QWORD *)v7 + 34) = 0xFFEFFFFFFFFFFFFFLL;
  v9 = (*(uint64_t (**)(char *, void *, uint64_t))(v8 + 72))(v7, a2, a3);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  return v9;
}

void sub_1B65BA3C0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65BA3ACLL);
}

uint64_t ausdk::AUMethodAddPropertyListener(ausdk *this, void *a2, uint64_t a3, void (*a4)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int), void *a5)
{
  uint64_t v9;
  uint64_t v10;

  v9 = *((_QWORD *)this + 67);
  if (v9)
    (*(void (**)(_QWORD, void *, uint64_t, _QWORD, void *))(*(_QWORD *)v9 + 16))(*((_QWORD *)this + 67), a2, a3, a4, a5);
  v10 = (*(uint64_t (**)(char *, void *, uint64_t, _QWORD, void *))(*((_QWORD *)this + 8) + 112))((char *)this + 64, a2, a3, a4, a5);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  return v10;
}

void sub_1B65BA4D0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65BA4B8);
}

uint64_t ausdk::AUMethodRemovePropertyListener(ausdk *this, void *a2, uint64_t a3, void (*a4)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int))
{
  uint64_t v7;
  uint64_t v8;

  v7 = *((_QWORD *)this + 67);
  if (v7)
    (*(void (**)(_QWORD, void *, uint64_t, void (*)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int)))(*(_QWORD *)v7 + 16))(*((_QWORD *)this + 67), a2, a3, a4);
  v8 = (*(uint64_t (**)(char *, void *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 120))((char *)this + 64, a2, a3, 0, 0);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  return v8;
}

void sub_1B65BA5D8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65BA5C4);
}

uint64_t ausdk::AUMethodRender(ausdk *this, int *a2, unsigned int *a3, const AudioTimeStamp *a4, uint64_t a5, AudioBufferList *a6, AudioBufferList *a7)
{
  uint64_t v7;
  int *v10;
  char *v11;
  unsigned int v13;
  uint64_t v14;
  uint64_t Element;
  uint64_t v18;
  UInt32 mNumberBuffers;
  uint64_t v20;
  int v21;
  unsigned int v22;
  unsigned int *p_mDataByteSize;
  unsigned int v24;
  char *v25;
  _BYTE *i;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  unint64_t *v32;
  NSObject *v33;
  _QWORD *v34;
  int v35;
  unint64_t *v36;
  unint64_t *v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  int v61;
  _QWORD *v62;
  _QWORD *v63;
  int v64;
  uint64_t v65;
  _DWORD *v66;
  int v67;
  unint64_t j;
  uint64_t v69;
  _QWORD *v71;
  _QWORD *v72;
  std::runtime_error *exception;
  uint64_t v74;
  char *v75;
  int v76;
  uint8_t buf[4];
  _BYTE v78[10];
  _BYTE v79[6];
  __int16 v80;
  int v81;
  __int16 v82;
  unsigned int v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v76 = 0;
  v7 = 4294967246;
  if (!a3 || !a6)
    return v7;
  if (a2)
    v10 = a2;
  else
    v10 = &v76;
  v11 = (char *)this + 64;
  if (!*((_BYTE *)this + 81))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v60 = (_QWORD *)((char *)this + 504);
      if (*((char *)this + 527) < 0)
        v60 = (_QWORD *)*v60;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v78 = v60;
      *(_WORD *)&v78[8] = 1024;
      *(_DWORD *)v79 = -10867;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", buf, 0x12u);
    }
    v7 = 4294956429;
    if (!*((_DWORD *)this + 101))
    {
      *((_DWORD *)this + 101) = -10867;
      (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))(v11, 22, 0, 0);
    }
    return v7;
  }
  v13 = *((_DWORD *)this + 100);
  if (v13 < a5)
  {
    v14 = mach_absolute_time();
    if (*((double *)this + 51) < (double)(v14 - *((_QWORD *)this + 52)))
    {
      *((_QWORD *)this + 52) = v14;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v64 = *((_DWORD *)this + 100);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)v78 = a5;
        *(_WORD *)&v78[4] = 1024;
        *(_DWORD *)&v78[6] = v64;
        _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "kAudioUnitErr_TooManyFramesToProcess : inFramesToProcess=%u, mMaxFramesPerSlice=%u", buf, 0xEu);
      }
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v62 = (_QWORD *)((char *)this + 504);
      if (*((char *)this + 527) < 0)
        v62 = (_QWORD *)*v62;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v78 = v62;
      *(_WORD *)&v78[8] = 1024;
      *(_DWORD *)v79 = -10874;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", buf, 0x12u);
    }
    v7 = 4294956422;
    if (!*((_DWORD *)this + 101))
    {
      *((_DWORD *)this + 101) = -10874;
      (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))(v11, 22, 0, 0);
    }
    return v7;
  }
  if (v13 != (_DWORD)a5 && *((_BYTE *)this + 440))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v63 = (_QWORD *)((char *)this + 504);
      if (*((char *)this + 527) < 0)
        v63 = (_QWORD *)*v63;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v78 = v63;
      *(_WORD *)&v78[8] = 1024;
      *(_DWORD *)v79 = -50;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", buf, 0x12u);
    }
    if (!*((_DWORD *)this + 101))
      goto LABEL_113;
    return v7;
  }
  v75 = (char *)this + 64;
  Element = ausdk::AUScope::SafeGetElement((ausdk *)((char *)this + 192), a4);
  if ((*(_BYTE *)(Element + 92) & 0x20) != 0)
    v18 = *(unsigned int *)(Element + 108);
  else
    v18 = 1;
  mNumberBuffers = a6->mNumberBuffers;
  if ((_DWORD)v18 == a6->mNumberBuffers)
  {
    v74 = Element;
    if (!(_DWORD)v18)
    {
LABEL_32:
      i = (_BYTE *)Element;
      v25 = v75;
      if (*((_BYTE *)this + 328))
        *((_QWORD *)this + 40) = pthread_self();
      if (*((_BYTE *)this + 312))
      {
        v27 = (unint64_t *)((char *)this + 296);
LABEL_36:
        v28 = (_QWORD *)atomic_load(v27);
        if (v28)
        {
          do
          {
            v29 = __ldaxr(v27);
            if ((_QWORD *)v29 != v28)
            {
              __clrex();
              goto LABEL_36;
            }
          }
          while (__stlxr(0, v27));
          v30 = 0;
          do
          {
            v31 = (_QWORD *)v30;
            v30 = (unint64_t)v28;
            v28 = (_QWORD *)*v28;
            *(_QWORD *)v30 = v31;
          }
          while (v28);
          v32 = (unint64_t *)((char *)this + 304);
          v33 = MEMORY[0x1E0C81028];
          while (1)
          {
            v34 = v31;
            v35 = *(_DWORD *)(v30 + 8);
            switch(v35)
            {
              case 3:
                v44 = (unint64_t *)atomic_load((unint64_t *)this + 36);
                if (v44)
                {
                  do
                  {
                    v45 = (unint64_t *)*v44;
LABEL_68:
                    v46 = atomic_load(v32);
                    *v44 = v46;
                    do
                    {
                      v47 = __ldaxr(v32);
                      if (v47 != v46)
                      {
                        __clrex();
                        goto LABEL_68;
                      }
                    }
                    while (__stlxr((unint64_t)v44, v32));
                    v44 = v45;
                  }
                  while (v45);
                }
LABEL_74:
                v48 = atomic_load(v32);
                *(_QWORD *)v30 = v48;
                do
                {
                  v49 = __ldaxr(v32);
                  if (v49 != v48)
                  {
                    __clrex();
                    goto LABEL_74;
                  }
                }
                while (__stlxr(v30, v32));
                if (atomic_load((unint64_t *)this + 36))
                  atomic_store(0, (unint64_t *)this + 36);
                break;
              case 2:
                v39 = (unint64_t *)atomic_load((unint64_t *)this + 36);
                if (v39)
                {
                  v40 = 0;
                  do
                  {
                    v41 = v39;
                    if (v39[2] == *(_QWORD *)(v30 + 16) && v39[3] == *(_QWORD *)(v30 + 24))
                    {
                      v54 = *v39;
                      if (v40)
                        *v40 = v54;
                      else
                        atomic_store(v54, (unint64_t *)this + 36);
                      while (1)
                      {
                        v55 = atomic_load(v32);
                        *v39 = v55;
                        while (1)
                        {
                          v56 = __ldaxr(v32);
                          if (v56 != v55)
                            break;
                          if (!__stlxr((unint64_t)v39, v32))
                            goto LABEL_61;
                        }
                        __clrex();
                      }
                    }
                    v39 = (unint64_t *)*v39;
                    v40 = v41;
                  }
                  while (*v41);
                }
                while (1)
                {
LABEL_61:
                  v42 = atomic_load(v32);
                  *(_QWORD *)v30 = v42;
                  while (1)
                  {
                    v43 = __ldaxr(v32);
                    if (v43 != v42)
                      break;
                    if (!__stlxr(v30, v32))
                      goto LABEL_84;
                  }
                  __clrex();
                }
              case 1:
                v36 = (unint64_t *)((char *)this + 288);
                v37 = (unint64_t *)atomic_load((unint64_t *)this + 36);
                if (v37)
                {
                  do
                  {
                    v38 = v37;
                    if (v37[2] == *(_QWORD *)(v30 + 16) && v37[3] == *(_QWORD *)(v30 + 24))
                    {
                      while (1)
                      {
                        v52 = atomic_load(v32);
                        *(_QWORD *)v30 = v52;
                        while (1)
                        {
                          v53 = __ldaxr(v32);
                          if (v53 != v52)
                            break;
                          if (!__stlxr(v30, v32))
                            goto LABEL_84;
                        }
                        __clrex();
                      }
                    }
                    v37 = (unint64_t *)*v37;
                  }
                  while (*v38);
                  *v38 = v30;
                  *(_QWORD *)v30 = 0;
                }
                else
                {
                  v51 = atomic_load(v36);
                  *(_QWORD *)v30 = v51;
                  atomic_store(v30, v36);
                }
                break;
              default:
                if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_1B5ED0000, v33, OS_LOG_TYPE_ERROR, "ioData.mNumberBuffers=%u, ASBD::NumberChannelStreams(output.GetStreamFormat())=%u; kAudio_ParamError",
                    buf,
                    2u);
                }
                break;
            }
LABEL_84:
            if (!v34)
              break;
            v31 = (_QWORD *)*v34;
            v30 = (unint64_t)v34;
          }
        }
        *(_DWORD *)buf = *v10 | 4;
        v57 = atomic_load((unint64_t *)this + 36);
        for (i = (_BYTE *)v74; v57; v57 = *(_QWORD *)v57)
          (*(void (**)(_QWORD, uint8_t *, unsigned int *, const AudioTimeStamp *, uint64_t, AudioBufferList *))(v57 + 16))(*(_QWORD *)(v57 + 24), buf, a3, a4, a5, a6);
        v25 = v75;
      }
      if (a6->mBuffers[0].mData
        && (!i[168]
         || ((v58 = *((_QWORD *)this + 29)) == 0
           ? (v59 = (*((_QWORD *)this + 27) - *((_QWORD *)this + 26)) >> 3)
           : (LODWORD(v59) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v58 + 24))(v58)),
             v59 < 2)))
      {
        ausdk::AUBufferList::SetBufferList((ausdk::AUBufferList *)(i + 144), a6);
      }
      else
      {
        ausdk::AUIOElement::PrepareBuffer((ausdk::AUIOElement *)i, a5);
      }
      v65 = (*(uint64_t (**)(char *, int *, unsigned int *, const AudioTimeStamp *, uint64_t))(*(_QWORD *)v25 + 200))(v25, v10, a3, a4, a5);
      v7 = v65;
      if ((_DWORD)v65)
      {
        if (!*((_DWORD *)this + 101))
        {
          *((_DWORD *)this + 101) = v65;
          (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))(v25, 22, 0, 0);
        }
      }
      else
      {
        v66 = i + 144;
        if (a6->mBuffers[0].mData)
        {
          ausdk::AUBufferList::CopyBufferContentsTo((_QWORD *)i + 18, a6);
          *v66 = 0;
        }
        else
        {
          if (!*v66)
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)v78 = -1;
              _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", buf, 8u);
            }
            exception = (std::runtime_error *)__cxa_allocate_exception(0x18uLL);
            ausdk::AUException::AUException(exception, -1);
          }
          memcpy(a6, (const void *)(*(_QWORD *)(v74 + 152) + 48), (16 * a6->mNumberBuffers) | 8);
        }
      }
      if (*((_BYTE *)this + 312))
      {
        v67 = (_DWORD)v7 ? 264 : 8;
        *(_DWORD *)buf = *v10 | v67;
        for (j = atomic_load((unint64_t *)this + 36); j; j = *(_QWORD *)j)
          (*(void (**)(_QWORD, uint8_t *, unsigned int *, const AudioTimeStamp *, uint64_t, AudioBufferList *))(j + 16))(*(_QWORD *)(j + 24), buf, a3, a4, a5, a6);
      }
      v69 = *((_QWORD *)this + 56);
      if (v69 != *((_QWORD *)this + 57))
        *((_QWORD *)this + 57) = v69;
      return v7;
    }
    v20 = 0;
    v21 = *(_DWORD *)(Element + 104);
    v22 = v21 * a5;
    p_mDataByteSize = &a6->mBuffers[0].mDataByteSize;
    while (1)
    {
      if (*(_QWORD *)(p_mDataByteSize + 1))
      {
        v24 = *p_mDataByteSize;
        if (*p_mDataByteSize < v22)
        {
          v61 = v21;
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67110144;
            *(_DWORD *)v78 = a5;
            *(_WORD *)&v78[4] = 1024;
            *(_DWORD *)&v78[6] = v61;
            *(_WORD *)v79 = 1024;
            *(_DWORD *)&v79[2] = v22;
            v80 = 1024;
            v81 = v20;
            v82 = 1024;
            v83 = v24;
            _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%u frames, %u bytes/frame, expected %u-byte buffer; ioData.mBuffers[%u].mDataByteSize=%u; kAudio_ParamError",
              buf,
              0x20u);
          }
          v11 = v75;
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            v72 = (_QWORD *)((char *)this + 504);
            if (*((char *)this + 527) < 0)
              v72 = (_QWORD *)*v72;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)v78 = v72;
            *(_WORD *)&v78[8] = 1024;
            *(_DWORD *)v79 = -50;
            _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", buf, 0x12u);
          }
          v7 = 4294967246;
          if (!*((_DWORD *)this + 101))
            goto LABEL_113;
          return v7;
        }
        *p_mDataByteSize = v22;
      }
      ++v20;
      p_mDataByteSize += 4;
      if (v18 == v20)
        goto LABEL_32;
    }
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)v78 = mNumberBuffers;
    *(_WORD *)&v78[4] = 1024;
    *(_DWORD *)&v78[6] = v18;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "ioData.mNumberBuffers=%u, ASBD::NumberChannelStreams(output.GetStreamFormat())=%u; kAudio_ParamError",
      buf,
      0xEu);
  }
  v11 = v75;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v71 = (_QWORD *)((char *)this + 504);
    if (*((char *)this + 527) < 0)
      v71 = (_QWORD *)*v71;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)v78 = v71;
    *(_WORD *)&v78[8] = 1024;
    *(_DWORD *)v79 = -50;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", buf, 0x12u);
  }
  v7 = 4294967246;
  if (!*((_DWORD *)this + 101))
  {
LABEL_113:
    *((_DWORD *)this + 101) = -50;
    (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))(v11, 22, 0, 0);
  }
  return v7;
}

void sub_1B65BB0A0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int128 buf)
{
  uint64_t v13;
  void *v14;
  int *v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;

  if (!a2)
    _Unwind_Resume(a1);
  __cxa_free_exception(v14);
  v17 = (int *)__cxa_begin_catch(a1);
  if (a2 == 2)
  {
    v18 = *v17;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      if (!v18)
        goto LABEL_13;
      goto LABEL_7;
    }
    v19 = (_QWORD *)(v13 + 504);
    if (*(char *)(v13 + 527) < 0)
      v19 = (_QWORD *)*v19;
    LODWORD(buf) = 136315394;
    *(_QWORD *)((char *)&buf + 4) = v19;
    WORD6(buf) = 1024;
    *(_DWORD *)((char *)&buf + 14) = v18;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)&buf, 0x12u);
    if (v18)
    {
LABEL_7:
      if (!*(_DWORD *)(v13 + 404))
      {
        *(_DWORD *)(v13 + 404) = v18;
        (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v13 + 64) + 432))(a11, 22, 0, 0);
      }
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v20 = (_QWORD *)(v13 + 504);
      if (*(char *)(v13 + 527) < 0)
        v20 = (_QWORD *)*v20;
      LODWORD(buf) = 136315394;
      *(_QWORD *)((char *)&buf + 4) = v20;
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = -1;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)&buf, 0x12u);
    }
    if (!*(_DWORD *)(v13 + 404))
    {
      *(_DWORD *)(v13 + 404) = -1;
      (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v13 + 64) + 432))(a11, 22, 0, 0);
    }
  }
LABEL_13:
  __cxa_end_catch();
  JUMPOUT(0x1B65BAE80);
}

void sub_1B65BB264()
{
  __cxa_end_catch();
  JUMPOUT(0x1B65BB0C4);
}

void sub_1B65BB270()
{
  __cxa_end_catch();
  JUMPOUT(0x1B65BB0C4);
}

void sub_1B65BB280()
{
  JUMPOUT(0x1B65BB0C4);
}

uint64_t ausdk::AUMethodAddRenderNotify(ausdk *this, void *a2, int (*a3)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a4)
{
  uint64_t v7;
  uint64_t v8;

  v7 = *((_QWORD *)this + 67);
  if (v7)
    (*(void (**)(_QWORD, void *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))(*(_QWORD *)v7 + 16))(*((_QWORD *)this + 67), a2, a3, a4);
  v8 = (*(uint64_t (**)(char *, void *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))(*((_QWORD *)this + 8) + 128))((char *)this + 64, a2, a3, a4);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  return v8;
}

void sub_1B65BB300(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65BB2ECLL);
}

uint64_t ausdk::AUMethodRemoveRenderNotify(ausdk *this, void *a2, int (*a3)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a4)
{
  uint64_t v7;
  uint64_t v8;

  v7 = *((_QWORD *)this + 67);
  if (v7)
    (*(void (**)(_QWORD, void *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))(*(_QWORD *)v7 + 16))(*((_QWORD *)this + 67), a2, a3, a4);
  v8 = (*(uint64_t (**)(char *, void *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))(*((_QWORD *)this + 8) + 136))((char *)this + 64, a2, a3, a4);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  return v8;
}

void sub_1B65BB400(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65BB3ECLL);
}

uint64_t ausdk::AUMethodScheduleParameters(ausdk *this, char *a2, const AudioUnitParameterEvent *a3)
{
  uint64_t v3;
  BOOL v4;
  _DWORD *v5;
  int v6;

  if (!a2 || !(_DWORD)a3)
    return (*(uint64_t (**)(char *))(*((_QWORD *)this + 8) + 168))((char *)this + 64);
  v3 = 0;
  v4 = 0;
  v5 = a2 + 28;
  while (1)
  {
    v6 = *(v5 - 4);
    if (v6 == 2)
      break;
    if (v6 == 1 && (*(v5 - 2) & 0x7FFFFFFFu) >= 0x7F800000)
      goto LABEL_11;
LABEL_10:
    v4 = ++v3 >= (unint64_t)a3;
    v5 += 8;
    if (a3 == v3)
      goto LABEL_11;
  }
  if ((*(v5 - 1) & 0x7FFFFFFFu) <= 0x7F7FFFFF && (*v5 & 0x7FFFFFFFu) <= 0x7F7FFFFF)
    goto LABEL_10;
LABEL_11:
  if (v4)
    return (*(uint64_t (**)(char *))(*((_QWORD *)this + 8) + 168))((char *)this + 64);
  return 4294900553;
}

uint64_t ausdk::AUMethodRemovePropertyListenerWithUserData(ausdk *this, void *a2, uint64_t a3, void (*a4)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int), void *a5)
{
  uint64_t v9;
  uint64_t v10;

  v9 = *((_QWORD *)this + 67);
  if (v9)
    (*(void (**)(_QWORD, void *, uint64_t, _QWORD, void *))(*(_QWORD *)v9 + 16))(*((_QWORD *)this + 67), a2, a3, a4, a5);
  v10 = (*(uint64_t (**)(char *, void *, uint64_t, _QWORD, uint64_t))(*((_QWORD *)this + 8) + 120))((char *)this + 64, a2, a3, a4, 1);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  return v10;
}

void sub_1B65BB62C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B65BB614);
}

uint64_t (*ausdk::AUBaseProcessLookup::Lookup(ausdk::AUBaseProcessLookup *this))(ausdk *__hidden this, void *)
{
  uint64_t (*v1)(ausdk *__hidden, void *);
  uint64_t (*v2)(ausdk *, int *, unsigned int *, const AudioTimeStamp *, _DWORD *, AudioBufferList *);

  if (((_DWORD)this - 1) > 0x11)
    v1 = 0;
  else
    v1 = off_1E69EDA98[(int)this - 1];
  v2 = ausdk::AUMethodProcess;
  if ((_DWORD)this != 20)
    v2 = 0;
  if (v1)
    return v1;
  else
    return (uint64_t (*)(ausdk *__hidden, void *))v2;
}

uint64_t ausdk::AUMethodProcess(ausdk *this, int *a2, unsigned int *a3, const AudioTimeStamp *a4, _DWORD *a5, AudioBufferList *a6)
{
  int *v10;
  int v11;
  uint64_t v12;
  char *v13;
  unsigned int v14;
  uint64_t Element;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  unsigned int *v21;
  unsigned int v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _QWORD *v27;
  int v28;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  int v33;
  uint8_t buf[4];
  _BYTE v35[10];
  _BYTE v36[6];
  __int16 v37;
  int v38;
  __int16 v39;
  unsigned int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v33 = 0;
  if (a2)
  {
    v10 = a2;
    v11 = *a2;
    if ((*a2 & 0x200) != 0)
      goto LABEL_7;
  }
  else
  {
    LOWORD(v11) = 0;
    v10 = &v33;
  }
  v12 = 4294967246;
  if (!a3 || !a5)
    return v12;
LABEL_7:
  v13 = (char *)this + 64;
  if ((v11 & 0x200) != 0)
    goto LABEL_31;
  if (!*((_BYTE *)this + 81))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v27 = (_QWORD *)((char *)this + 504);
      if (*((char *)this + 527) < 0)
        v27 = (_QWORD *)*v27;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v35 = v27;
      *(_WORD *)&v35[8] = 1024;
      *(_DWORD *)v36 = -10867;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, process err: %d", buf, 0x12u);
    }
    v12 = 4294956429;
    if (!*((_DWORD *)this + 101))
    {
      *((_DWORD *)this + 101) = -10867;
      (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))((char *)this + 64, 22, 0, 0);
    }
    return v12;
  }
  v14 = *((_DWORD *)this + 100);
  if (v14 < a4)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v29 = (_QWORD *)((char *)this + 504);
      if (*((char *)this + 527) < 0)
        v29 = (_QWORD *)*v29;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v35 = v29;
      *(_WORD *)&v35[8] = 1024;
      *(_DWORD *)v36 = -10874;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, process err: %d", buf, 0x12u);
    }
    v12 = 4294956422;
    if (!*((_DWORD *)this + 101))
    {
      *((_DWORD *)this + 101) = -10874;
      (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))((char *)this + 64, 22, 0, 0);
    }
    return v12;
  }
  if (v14 != (_DWORD)a4 && *((_BYTE *)this + 440))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v30 = (_QWORD *)((char *)this + 504);
      if (*((char *)this + 527) < 0)
        v30 = (_QWORD *)*v30;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v35 = v30;
      *(_WORD *)&v35[8] = 1024;
      *(_DWORD *)v36 = -50;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, process err: %d", buf, 0x12u);
    }
    v12 = 4294967246;
    if (!*((_DWORD *)this + 101))
      goto LABEL_49;
    return v12;
  }
  Element = ausdk::AUScope::SafeGetElement((ausdk *)((char *)this + 144), 0);
  if ((*(_BYTE *)(Element + 92) & 0x20) != 0)
    v16 = *(unsigned int *)(Element + 108);
  else
    v16 = 1;
  v17 = *a5;
  if ((_DWORD)v16 == *a5)
  {
    if ((_DWORD)v16)
    {
      v18 = 0;
      v19 = *(_DWORD *)(Element + 104);
      v20 = v19 * (_DWORD)a4;
      v21 = a5 + 3;
      do
      {
        if (*(_QWORD *)(v21 + 1))
        {
          v22 = *v21;
          if (*v21 < v20)
          {
            v28 = v19;
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67110144;
              *(_DWORD *)v35 = (_DWORD)a4;
              *(_WORD *)&v35[4] = 1024;
              *(_DWORD *)&v35[6] = v28;
              *(_WORD *)v36 = 1024;
              *(_DWORD *)&v36[2] = v20;
              v37 = 1024;
              v38 = v18;
              v39 = 1024;
              v40 = v22;
              _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%u frames, %u bytes/frame, expected %u-byte buffer; ioData.mBuffers[%u].mDataByteSize=%u; kAudio_ParamError",
                buf,
                0x20u);
            }
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              v32 = (_QWORD *)((char *)this + 504);
              if (*((char *)this + 527) < 0)
                v32 = (_QWORD *)*v32;
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)v35 = v32;
              *(_WORD *)&v35[8] = 1024;
              *(_DWORD *)v36 = -50;
              _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, process err: %d", buf, 0x12u);
            }
            v12 = 4294967246;
            if (!*((_DWORD *)this + 101))
              goto LABEL_49;
            return v12;
          }
          *v21 = v20;
        }
        ++v18;
        v21 += 4;
      }
      while (v16 != v18);
    }
LABEL_31:
    if (*((_BYTE *)this + 328))
      *((_QWORD *)this + 40) = pthread_self();
    if (*(double *)a3 == *((double *)this + 42))
      return 0;
    v23 = *(_OWORD *)a3;
    v24 = *((_OWORD *)a3 + 1);
    v25 = *((_OWORD *)a3 + 3);
    *((_OWORD *)this + 23) = *((_OWORD *)a3 + 2);
    *((_OWORD *)this + 24) = v25;
    *((_OWORD *)this + 21) = v23;
    *((_OWORD *)this + 22) = v24;
    return (*(uint64_t (**)(char *, int *, _DWORD *, _DWORD *, const AudioTimeStamp *, AudioBufferList *))(*(_QWORD *)v13 + 176))((char *)this + 64, v10, a5, a5, a4, a6);
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)v35 = v17;
    *(_WORD *)&v35[4] = 1024;
    *(_DWORD *)&v35[6] = v16;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "ioData.mNumberBuffers=%u, ASBD::NumberChannelStreams(input->GetStreamFormat())=%u; kAudio_ParamError",
      buf,
      0xEu);
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v31 = (_QWORD *)((char *)this + 504);
    if (*((char *)this + 527) < 0)
      v31 = (_QWORD *)*v31;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)v35 = v31;
    *(_WORD *)&v35[8] = 1024;
    *(_DWORD *)v36 = -50;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, process err: %d", buf, 0x12u);
  }
  v12 = 4294967246;
  if (!*((_DWORD *)this + 101))
  {
LABEL_49:
    *((_DWORD *)this + 101) = -50;
    (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))((char *)this + 64, 22, 0, 0);
  }
  return v12;
}

void sub_1B65BBC7C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 buf)
{
  uint64_t v11;
  uint64_t v12;
  int *v14;
  int v15;
  _QWORD *v16;
  _QWORD *v17;

  if (!a2)
    _Unwind_Resume(a1);
  v14 = (int *)__cxa_begin_catch(a1);
  if (a2 == 2)
  {
    v15 = *v14;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      if (!v15)
        goto LABEL_13;
      goto LABEL_7;
    }
    v16 = (_QWORD *)(v11 + 504);
    if (*(char *)(v11 + 527) < 0)
      v16 = (_QWORD *)*v16;
    LODWORD(buf) = 136315394;
    *(_QWORD *)((char *)&buf + 4) = v16;
    WORD6(buf) = 1024;
    *(_DWORD *)((char *)&buf + 14) = v15;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, process err: %d", (uint8_t *)&buf, 0x12u);
    if (v15)
    {
LABEL_7:
      if (!*(_DWORD *)(v11 + 404))
      {
        *(_DWORD *)(v11 + 404) = v15;
        (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v11 + 64) + 432))(v12, 22, 0, 0);
      }
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v17 = (_QWORD *)(v11 + 504);
      if (*(char *)(v11 + 527) < 0)
        v17 = (_QWORD *)*v17;
      LODWORD(buf) = 136315394;
      *(_QWORD *)((char *)&buf + 4) = v17;
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = -1;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, process err: %d", (uint8_t *)&buf, 0x12u);
    }
    if (!*(_DWORD *)(v11 + 404))
    {
      *(_DWORD *)(v11 + 404) = -1;
      (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v11 + 64) + 432))(v12, 22, 0, 0);
    }
  }
LABEL_13:
  __cxa_end_catch();
  JUMPOUT(0x1B65BB914);
}

void sub_1B65BBE14()
{
  __cxa_end_catch();
  JUMPOUT(0x1B65BBC98);
}

void sub_1B65BBE20()
{
  __cxa_end_catch();
  JUMPOUT(0x1B65BBC98);
}

void sub_1B65BBE30()
{
  JUMPOUT(0x1B65BBC98);
}

uint64_t (*ausdk::AUBaseProcessMultipleLookup::Lookup(ausdk::AUBaseProcessMultipleLookup *this))(ausdk *__hidden this, void *)
{
  uint64_t (*v1)(ausdk *__hidden, void *);
  uint64_t (*v2)(ausdk *, int *, unsigned int *, const AudioTimeStamp *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **);

  if (((_DWORD)this - 1) > 0x11)
    v1 = 0;
  else
    v1 = off_1E69EDA98[(int)this - 1];
  v2 = ausdk::AUMethodProcessMultiple;
  if ((_DWORD)this != 21)
    v2 = 0;
  if (v1)
    return v1;
  else
    return (uint64_t (*)(ausdk *__hidden, void *))v2;
}

uint64_t ausdk::AUMethodProcessMultiple(ausdk *this, int *a2, unsigned int *a3, const AudioTimeStamp *a4, uint64_t a5, uint64_t a6, const AudioBufferList **a7, uint64_t a8, AudioBufferList **a9)
{
  unint64_t v10;
  uint64_t v12;
  unint64_t v13;
  int *v16;
  int v17;
  uint64_t v18;
  char *v19;
  unsigned int v20;
  uint64_t v21;
  BOOL v22;
  uint64_t Element;
  uint64_t v24;
  _DWORD *v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  _QWORD *v29;
  unsigned int v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  int v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  unsigned int *v40;
  unsigned int v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  int v46;
  char *v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  ausdk::AUScope *v55;
  int v56;
  BOOL v57;
  unsigned int v58;
  unsigned int v59;
  char *v60;
  unsigned int v61;
  int v62;
  uint8_t buf[4];
  _BYTE v64[10];
  _BYTE v65[6];
  __int16 v66;
  int v67;
  __int16 v68;
  int v69;
  __int16 v70;
  unsigned int v71;
  uint64_t v72;

  v10 = (unint64_t)a7;
  v12 = a5;
  v13 = (unint64_t)a4;
  v72 = *MEMORY[0x1E0C80C00];
  v62 = 0;
  if (a2)
  {
    v16 = a2;
    v17 = *a2;
    if ((*a2 & 0x200) != 0)
      goto LABEL_8;
  }
  else
  {
    LOWORD(v17) = 0;
    v16 = &v62;
  }
  v18 = 4294967246;
  if (!a3 || !a6 || !a8)
    return v18;
LABEL_8:
  v19 = (char *)this + 64;
  if ((v17 & 0x200) != 0)
    goto LABEL_59;
  if (!*((_BYTE *)this + 81))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v48 = (_QWORD *)((char *)this + 504);
      if (*((char *)this + 527) < 0)
        v48 = (_QWORD *)*v48;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v64 = v48;
      *(_WORD *)&v64[8] = 1024;
      *(_DWORD *)v65 = -10867;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, processmultiple err: %d", buf, 0x12u);
    }
    v18 = 4294956429;
    if (!*((_DWORD *)this + 101))
    {
      *((_DWORD *)this + 101) = -10867;
      (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))((char *)this + 64, 22, 0, 0);
    }
    return v18;
  }
  v20 = *((_DWORD *)this + 100);
  if (v20 < a4)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v49 = (_QWORD *)((char *)this + 504);
      if (*((char *)this + 527) < 0)
        v49 = (_QWORD *)*v49;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v64 = v49;
      *(_WORD *)&v64[8] = 1024;
      *(_DWORD *)v65 = -10874;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, processmultiple err: %d", buf, 0x12u);
    }
    v18 = 4294956422;
    if (!*((_DWORD *)this + 101))
    {
      *((_DWORD *)this + 101) = -10874;
      (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))((char *)this + 64, 22, 0, 0);
    }
    return v18;
  }
  if (v20 != (_DWORD)a4 && *((_BYTE *)this + 440))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v50 = (_QWORD *)((char *)this + 504);
      if (*((char *)this + 527) < 0)
        v50 = (_QWORD *)*v50;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v64 = v50;
      *(_WORD *)&v64[8] = 1024;
      *(_DWORD *)v65 = -50;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, processmultiple err: %d", buf, 0x12u);
    }
    v18 = 4294967246;
    if (!*((_DWORD *)this + 101))
    {
      *((_DWORD *)this + 101) = -50;
      (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))((char *)this + 64, 22, 0, 0);
    }
    return v18;
  }
  v58 = a7;
  v59 = a5;
  v61 = a4;
  v60 = (char *)this + 64;
  if ((_DWORD)a5)
  {
    v21 = 0;
    v22 = 1;
    v55 = (ausdk *)((char *)this + 144);
    while (1)
    {
      v57 = v22;
      if (*(_QWORD *)(a6 + 8 * v21))
      {
        Element = ausdk::AUScope::SafeGetElement(v55, v21);
        if ((*(_BYTE *)(Element + 92) & 0x20) != 0)
          v24 = *(unsigned int *)(Element + 108);
        else
          v24 = 1;
        v25 = *(_DWORD **)(a6 + 8 * v21);
        v26 = *v25;
        if ((_DWORD)v24 != *v25)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109632;
            *(_DWORD *)v64 = v21;
            *(_WORD *)&v64[4] = 1024;
            *(_DWORD *)&v64[6] = v26;
            *(_WORD *)v65 = 1024;
            *(_DWORD *)&v65[2] = v24;
            _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "inInputBufferLists[%u]->mNumberBuffers=%u, ASBD::NumberChannelStreams(input.GetStreamFormat())=%u; kAudio_ParamError",
              buf,
              0x14u);
          }
          v47 = v60;
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            v54 = (_QWORD *)((char *)this + 504);
            if (*((char *)this + 527) < 0)
              v54 = (_QWORD *)*v54;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)v64 = v54;
            *(_WORD *)&v64[8] = 1024;
            *(_DWORD *)v65 = -50;
            _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, processmultiple err: %d", buf, 0x12u);
          }
          v18 = 4294967246;
          if (*((_DWORD *)this + 101))
            return v18;
LABEL_88:
          *((_DWORD *)this + 101) = -50;
          (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)this + 8) + 432))(v47, 22, 0, 0);
          return v18;
        }
        if ((_DWORD)v24)
          break;
      }
LABEL_34:
      v22 = ++v21 < (unint64_t)v59;
      if (v21 == v59)
        goto LABEL_45;
    }
    v27 = 0;
    v28 = *(_DWORD *)(Element + 104) * v61;
    v29 = v25 + 4;
    while (*v29)
    {
      v30 = *((_DWORD *)v29 - 1);
      if (v30 < v28)
      {
        v56 = *(_DWORD *)(Element + 104);
        v31 = v60;
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67110400;
          *(_DWORD *)v64 = v61;
          *(_WORD *)&v64[4] = 1024;
          *(_DWORD *)&v64[6] = v56;
          *(_WORD *)v65 = 1024;
          *(_DWORD *)&v65[2] = v28;
          v66 = 1024;
          v67 = v21;
          v68 = 1024;
          v69 = v27;
          v70 = 1024;
          v71 = v30;
          _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%u frames, %u bytes/frame, expected %u-byte buffer; inInputBufferLists[%u].mBuffers[%u].mDataByteSize=%u; kAudio_ParamError",
            buf,
            0x26u);
        }
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
LABEL_41:
          if (!*((_DWORD *)this + 101))
          {
            *((_DWORD *)this + 101) = -50;
            (*(void (**)(char *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v31 + 432))(v31, 22, 0, 0);
          }
          if (v57)
            return 4294967246;
          goto LABEL_45;
        }
LABEL_89:
        v51 = (_QWORD *)((char *)this + 504);
        if (*((char *)this + 527) < 0)
          v51 = (_QWORD *)*v51;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)v64 = v51;
        *(_WORD *)&v64[8] = 1024;
        *(_DWORD *)v65 = -50;
        _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, processmultiple err: %d", buf, 0x12u);
        goto LABEL_41;
      }
      ++v27;
      v29 += 2;
      if (v24 == v27)
        goto LABEL_34;
    }
    v31 = v60;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_41;
    goto LABEL_89;
  }
LABEL_45:
  v19 = v60;
  v13 = v61;
  v10 = v58;
  v12 = v59;
  if (!v58)
  {
LABEL_59:
    if (*((_BYTE *)this + 328))
      *((_QWORD *)this + 40) = pthread_self();
    if (*(double *)a3 == *((double *)this + 42))
      return 0;
    v42 = *(_OWORD *)a3;
    v43 = *((_OWORD *)a3 + 1);
    v44 = *((_OWORD *)a3 + 3);
    *((_OWORD *)this + 23) = *((_OWORD *)a3 + 2);
    *((_OWORD *)this + 24) = v44;
    *((_OWORD *)this + 21) = v42;
    *((_OWORD *)this + 22) = v43;
    return (*(uint64_t (**)(char *, int *, unint64_t, uint64_t, uint64_t, unint64_t, uint64_t))(*(_QWORD *)v19 + 184))(v19, v16, v13, v12, a6, v10, a8);
  }
  v32 = 0;
  while (1)
  {
    if (*(_QWORD *)(a8 + 8 * v32))
    {
      v33 = ausdk::AUScope::SafeGetElement((ausdk *)((char *)this + 192), v32);
      if ((*(_BYTE *)(v33 + 92) & 0x20) != 0)
        v34 = *(unsigned int *)(v33 + 108);
      else
        v34 = 1;
      v35 = *(_DWORD **)(a8 + 8 * v32);
      v36 = *v35;
      if ((_DWORD)v34 != *v35)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109632;
          *(_DWORD *)v64 = v32;
          *(_WORD *)&v64[4] = 1024;
          *(_DWORD *)&v64[6] = v36;
          *(_WORD *)v65 = 1024;
          *(_DWORD *)&v65[2] = v34;
          _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "ioOutputBufferLists[%u]->mNumberBuffers=%u, ASBD::NumberChannelStreams(output.GetStreamFormat())=%u; kAudio_ParamError",
            buf,
            0x14u);
        }
        v47 = v60;
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          v53 = (_QWORD *)((char *)this + 504);
          if (*((char *)this + 527) < 0)
            v53 = (_QWORD *)*v53;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)v64 = v53;
          *(_WORD *)&v64[8] = 1024;
          *(_DWORD *)v65 = -50;
          _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, processmultiple err: %d", buf, 0x12u);
        }
        v18 = 4294967246;
        if (*((_DWORD *)this + 101))
          return v18;
        goto LABEL_88;
      }
      if ((_DWORD)v34)
        break;
    }
LABEL_58:
    ++v32;
    v19 = v60;
    v13 = v61;
    v10 = v58;
    v12 = v59;
    if (v32 == v58)
      goto LABEL_59;
  }
  v37 = 0;
  v38 = *(_DWORD *)(v33 + 104);
  v39 = v38 * v61;
  v40 = v35 + 3;
  while (!*(_QWORD *)(v40 + 1))
  {
LABEL_57:
    ++v37;
    v40 += 4;
    if (v34 == v37)
      goto LABEL_58;
  }
  v41 = *v40;
  if (*v40 >= v39)
  {
    *v40 = v39;
    goto LABEL_57;
  }
  v46 = v38;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67110400;
    *(_DWORD *)v64 = v61;
    *(_WORD *)&v64[4] = 1024;
    *(_DWORD *)&v64[6] = v46;
    *(_WORD *)v65 = 1024;
    *(_DWORD *)&v65[2] = v39;
    v66 = 1024;
    v67 = v32;
    v68 = 1024;
    v69 = v37;
    v70 = 1024;
    v71 = v41;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%u frames, %u bytes/frame, expected %u-byte buffer; ioOutputBufferLists[%u]->mBuffers[%u].mDataByteSize=%u; kAudio_ParamError",
      buf,
      0x26u);
  }
  v47 = v60;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v52 = (_QWORD *)((char *)this + 504);
    if (*((char *)this + 527) < 0)
      v52 = (_QWORD *)*v52;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)v64 = v52;
    *(_WORD *)&v64[8] = 1024;
    *(_DWORD *)v65 = -50;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, processmultiple err: %d", buf, 0x12u);
  }
  v18 = 4294967246;
  if (!*((_DWORD *)this + 101))
    goto LABEL_88;
  return v18;
}

void sub_1B65BC794(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, __int128 buf)
{
  uint64_t v15;
  int *v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;

  if (!a2)
    _Unwind_Resume(a1);
  v17 = (int *)__cxa_begin_catch(a1);
  if (a2 == 2)
  {
    v18 = *v17;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      if (!v18)
        goto LABEL_13;
      goto LABEL_7;
    }
    v19 = (_QWORD *)(v15 + 504);
    if (*(char *)(v15 + 527) < 0)
      v19 = (_QWORD *)*v19;
    LODWORD(buf) = 136315394;
    *(_QWORD *)((char *)&buf + 4) = v19;
    WORD6(buf) = 1024;
    *(_DWORD *)((char *)&buf + 14) = v18;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, processmultiple err: %d", (uint8_t *)&buf, 0x12u);
    if (v18)
    {
LABEL_7:
      if (!*(_DWORD *)(v15 + 404))
      {
        *(_DWORD *)(v15 + 404) = v18;
        (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v15 + 64) + 432))(a13, 22, 0, 0);
      }
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v20 = (_QWORD *)(v15 + 504);
      if (*(char *)(v15 + 527) < 0)
        v20 = (_QWORD *)*v20;
      LODWORD(buf) = 136315394;
      *(_QWORD *)((char *)&buf + 4) = v20;
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = -1;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "  from %s, processmultiple err: %d", (uint8_t *)&buf, 0x12u);
    }
    if (!*(_DWORD *)(v15 + 404))
    {
      *(_DWORD *)(v15 + 404) = -1;
      (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v15 + 64) + 432))(a13, 22, 0, 0);
    }
  }
LABEL_13:
  __cxa_end_catch();
  JUMPOUT(0x1B65BC23CLL);
}

void sub_1B65BC940()
{
  __cxa_end_catch();
  JUMPOUT(0x1B65BC7C0);
}

void sub_1B65BC94C()
{
  __cxa_end_catch();
  JUMPOUT(0x1B65BC7C0);
}

void sub_1B65BC95C()
{
  JUMPOUT(0x1B65BC7C0);
}

uint64_t (*ausdk::AUBaseProcessAndMultipleLookup::Lookup(ausdk::AUBaseProcessAndMultipleLookup *this))(ausdk *this, int *a2, unsigned int *a3, const AudioTimeStamp *a4, uint64_t a5, uint64_t a6, const AudioBufferList **a7, uint64_t a8, AudioBufferList **a9)
{
  int v1;
  uint64_t (*v3)(ausdk *, int *, unsigned int *, const AudioTimeStamp *, _DWORD *, AudioBufferList *);

  v1 = (_DWORD)this - 1;
  if (((_DWORD)this - 1) <= 0x11 && ((0x1880uLL >> v1) & 1) == 0)
    return (uint64_t (*)(ausdk *, int *, unsigned int *, const AudioTimeStamp *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))off_1E69EDA98[v1];
  v3 = ausdk::AUMethodProcess;
  if ((_DWORD)this != 20)
    v3 = 0;
  if ((_DWORD)this == 21)
    return ausdk::AUMethodProcessMultiple;
  else
    return (uint64_t (*)(ausdk *, int *, unsigned int *, const AudioTimeStamp *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))v3;
}

void AUScopeDynamic::~AUScopeDynamic(AUScopeDynamic *this)
{
  AUScopeDynamic::~AUScopeDynamic(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_1E69EDB38;
  ElementVector::freeOld(*((ElementVector ***)this + 3));
  v2 = (*(uint64_t (**)(AUScopeDynamic *))(*(_QWORD *)this + 24))(this);
  if (v2)
  {
    v3 = 0;
    do
    {
      v4 = (*(uint64_t (**)(AUScopeDynamic *, uint64_t))(*(_QWORD *)this + 32))(this, v3);
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
      v3 = (v3 + 1);
    }
    while (v2 != (_DWORD)v3);
  }
  v5 = *((_QWORD *)this + 3);
  if (v5)
  {
    free(*(void **)(v5 + 16));
    MEMORY[0x1BCC95CEC](v5, 0x10A0C409D8FE3EALL);
  }
  *((_QWORD *)this + 4) = &off_1E69EDF70;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
}

void AUScopeDynamic::SetNumberOfElements(AUScopeDynamic *this, unsigned int a2)
{
  char *v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  unint64_t v8;
  ElementVector *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = (char *)this + 32;
  v5 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 4) + 16))((char *)this + 32);
  v6 = *((_QWORD *)v4 - 1);
  if (v6)
  {
    v7 = *(_DWORD *)(v6 + 12);
    if (v7 >= a2)
      goto LABEL_13;
    v8 = a2;
    if (*(_DWORD *)(v6 + 8) <= a2)
    {
      v9 = (ElementVector *)operator new();
      ElementVector::ElementVector(v9, a2, (ElementVector *)v6);
      v6 = (uint64_t)v9;
    }
    else
    {
      *(_DWORD *)(v6 + 12) = a2;
    }
  }
  else
  {
    v6 = operator new();
    v8 = a2;
    ElementVector::ElementVector((ElementVector *)v6, a2, 0);
    v7 = 0;
  }
  if (v8 > v7)
  {
    v10 = v7;
    do
    {
      (*(void (**)(uint64_t *__return_ptr, _QWORD, _QWORD, uint64_t))(**((_QWORD **)this + 1) + 416))(&v13, *((_QWORD *)this + 1), *((unsigned int *)this + 4), v10);
      v11 = v13;
      v13 = 0;
      *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v10) = v11;
      v12 = v13;
      v13 = 0;
      if (v12)
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
      ++v10;
    }
    while (v8 != v10);
  }
  __dmb(0xBu);
  *(_DWORD *)(v6 + 12) = a2;
  *((_QWORD *)this + 3) = v6;
LABEL_13:
  if (v5)
    (*(void (**)(char *))(*(_QWORD *)v4 + 24))(v4);
}

void sub_1B65BCB38(_Unwind_Exception *a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;

  MEMORY[0x1BCC95CEC](v3, 0x10A0C409D8FE3EALL);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t AUScopeDynamic::GetNumberOfElements(AUScopeDynamic *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 3);
  if (v1)
    return *(unsigned int *)(v1 + 12);
  else
    return 0;
}

uint64_t AUScopeDynamic::GetElement(AUScopeDynamic *this, unsigned int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 3);
  if (v2 && *(_DWORD *)(v2 + 12) > a2)
    return *(_QWORD *)(*(_QWORD *)(v2 + 16) + 8 * a2);
  else
    return 0;
}

ElementVector *AUScopeDynamic::Cleanup(ElementVector ***this)
{
  return ElementVector::freeOld(this[3]);
}

ElementVector *ElementVector::freeOld(ElementVector **this)
{
  ElementVector *result;
  ElementVector *v3;

  result = *this;
  if (result)
  {
    result = (ElementVector *)ElementVector::freeOld(result);
    v3 = *this;
    if (*this)
    {
      free(*((void **)v3 + 2));
      result = (ElementVector *)MEMORY[0x1BCC95CEC](v3, 0x10A0C409D8FE3EALL);
    }
  }
  *this = 0;
  return result;
}

void ElementVector::ElementVector(ElementVector *this, uint64_t a2, ElementVector *a3)
{
  int v5;
  unint64_t v6;
  size_t v7;
  void *v8;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  std::bad_alloc *exception;
  std::bad_alloc *v14;

  *(_QWORD *)this = a3;
  v5 = -(int)__clz(a2 - 1);
  v6 = v5 & 0x3F;
  *((_QWORD *)this + 1) = (1 << v5);
  v7 = (8 << v5) & 0x7FFFFFFF8;
  v8 = malloc_type_malloc(v7, 0x2C8E6D5CuLL);
  if (v6 <= 0x1F && v8 == 0)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v14 = std::bad_alloc::bad_alloc(exception);
  }
  v10 = v8;
  bzero(v8, v7);
  *((_QWORD *)this + 2) = v10;
  if (a3)
  {
    v11 = *((unsigned int *)a3 + 3);
    if ((_DWORD)v11)
    {
      v12 = 0;
      do
      {
        *(_QWORD *)(*((_QWORD *)this + 2) + v12) = *(_QWORD *)(*((_QWORD *)a3 + 2) + v12);
        v12 += 8;
      }
      while (8 * v11 != v12);
    }
    *((_DWORD *)this + 3) = v11;
  }
}

int64x2_t *ausdk::AUBase::PostConstructorInternal(int64x2_t *this)
{
  if (!this[21].i32[0])
    (*(void (**)(int64x2_t *, uint64_t))(this->i64[0] + 512))(this, 1156);
  return ausdk::AUBase::CreateElements(this);
}

uint64_t ausdk::AUBase::PreDestructorInternal(ausdk::AUBase *this)
{
  uint64_t v2;
  uint64_t result;

  v2 = *((_QWORD *)this + 59);
  if (v2)
    (*(void (**)(_QWORD))(*(_QWORD *)v2 + 16))(*((_QWORD *)this + 59));
  if (*((_BYTE *)this + 17))
    (*(void (**)(ausdk::AUBase *))(*(_QWORD *)this + 64))(this);
  result = (*(uint64_t (**)(ausdk::AUBase *))(*(_QWORD *)this + 504))(this);
  *((_QWORD *)this + 41) = 0;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((_QWORD *)this + 34) = 0xFFEFFFFFFFFFFFFFLL;
  *(_WORD *)((char *)this + 17) = 0;
  if (v2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  return result;
}

void sub_1B65BCEBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::AUBase::Initialize(ausdk::AUBase *this)
{
  return 0;
}

uint64_t ausdk::AUBase::Reset(ausdk::AUBase *this)
{
  return 0;
}

uint64_t ausdk::AUBase::GetPropertyInfo(ausdk::AUBase *this, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  return 4294956417;
}

uint64_t ausdk::AUBase::GetProperty(ausdk::AUBase *this, unsigned int a2, unsigned int a3, unsigned int a4, void *a5)
{
  return 4294956417;
}

uint64_t ausdk::AUBase::SetProperty(ausdk::AUBase *this, unsigned int a2, unsigned int a3, unsigned int a4, const void *a5)
{
  return 4294956417;
}

uint64_t ausdk::AUBase::RemovePropertyValue(ausdk::AUBase *this)
{
  return 4294956445;
}

uint64_t ausdk::AUBase::AddPropertyListener(ausdk::AUBase *this, int a2, void (*a3)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int), void *a4)
{
  char *v8;
  char *v9;
  char *v10;
  unint64_t v11;
  _DWORD *v12;
  char *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  __int128 v19;

  v9 = (char *)*((_QWORD *)this + 51);
  v8 = (char *)*((_QWORD *)this + 52);
  if (v9 == v8)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 53) - (_QWORD)v9) >> 3) > 0x1F)
    {
      v8 = (char *)*((_QWORD *)this + 51);
    }
    else
    {
      v10 = (char *)operator new(0x300uLL);
      *((_QWORD *)this + 51) = v10;
      *((_QWORD *)this + 52) = v10;
      *((_QWORD *)this + 53) = v10 + 768;
      if (v9)
      {
        operator delete(v9);
        v8 = (char *)*((_QWORD *)this + 52);
      }
      else
      {
        v8 = v10;
      }
    }
  }
  v11 = *((_QWORD *)this + 53);
  if ((unint64_t)v8 >= v11)
  {
    v13 = (char *)*((_QWORD *)this + 51);
    v14 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v13) >> 3) + 1;
    if (v14 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (_QWORD)v13) >> 3);
    if (2 * v15 > v14)
      v14 = 2 * v15;
    if (v15 >= 0x555555555555555)
      v16 = 0xAAAAAAAAAAAAAAALL;
    else
      v16 = v14;
    if (v16)
    {
      if (v16 > 0xAAAAAAAAAAAAAAALL)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v17 = (char *)operator new(24 * v16);
    }
    else
    {
      v17 = 0;
    }
    v18 = &v17[8 * ((v8 - v13) >> 3)];
    *(_DWORD *)v18 = a2;
    *((_DWORD *)v18 + 1) = 0;
    *((_QWORD *)v18 + 1) = a3;
    *((_QWORD *)v18 + 2) = a4;
    v12 = v18 + 24;
    if (v8 != v13)
    {
      do
      {
        v19 = *(_OWORD *)(v8 - 24);
        *((_QWORD *)v18 - 1) = *((_QWORD *)v8 - 1);
        *(_OWORD *)(v18 - 24) = v19;
        v18 -= 24;
        v8 -= 24;
      }
      while (v8 != v13);
      v8 = (char *)*((_QWORD *)this + 51);
    }
    *((_QWORD *)this + 51) = v18;
    *((_QWORD *)this + 52) = v12;
    *((_QWORD *)this + 53) = &v17[24 * v16];
    if (v8)
      operator delete(v8);
  }
  else
  {
    *(_DWORD *)v8 = a2;
    *((_DWORD *)v8 + 1) = 0;
    v12 = v8 + 24;
    *((_QWORD *)v8 + 1) = a3;
    *((_QWORD *)v8 + 2) = a4;
  }
  *((_QWORD *)this + 52) = v12;
  return 0;
}

uint64_t ausdk::AUBase::RemovePropertyListener(ausdk::AUBase *this, int a2, void (*a3)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int), void *a4, int a5)
{
  __int128 *v5;
  uint64_t v6;
  __int128 *v8;
  __int128 v9;

  v6 = *((_QWORD *)this + 51);
  v5 = (__int128 *)*((_QWORD *)this + 52);
  if ((__int128 *)v6 != v5)
  {
    while (*(_DWORD *)v6 != a2
         || *(void (**)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int))(v6 + 8) != a3
         || a5 && *(void **)(v6 + 16) != a4)
    {
      v6 += 24;
      if ((__int128 *)v6 == v5)
        return 0;
    }
    if ((__int128 *)v6 != v5)
    {
      v8 = (__int128 *)(v6 + 24);
      if ((__int128 *)(v6 + 24) != v5)
      {
        do
        {
          if (*(_DWORD *)v8 != a2
            || *((void (**)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int))v8
               + 1) != a3
            || a5 && *((void **)v8 + 2) != a4)
          {
            v9 = *v8;
            *(_QWORD *)(v6 + 16) = *((_QWORD *)v8 + 2);
            *(_OWORD *)v6 = v9;
            v6 += 24;
          }
          v8 = (__int128 *)((char *)v8 + 24);
        }
        while (v8 != v5);
        v5 = (__int128 *)*((_QWORD *)this + 52);
      }
      if ((__int128 *)v6 != v5)
        *((_QWORD *)this + 52) = v6;
    }
  }
  return 0;
}

uint64_t ausdk::AUBase::SetRenderNotification(ausdk::AUBase *this, int (*a2)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a3)
{
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;

  if (!a2)
    return 4294967246;
  *((_BYTE *)this + 248) = 1;
  ausdk::AUThreadSafeList<ausdk::AUBase::RenderCallback>::AllocNode((uint64_t)this + 224);
  *(_DWORD *)(v6 + 8) = 1;
  *(_QWORD *)(v6 + 16) = a2;
  *(_QWORD *)(v6 + 24) = a3;
  v7 = (unint64_t *)((char *)this + 232);
LABEL_3:
  v8 = atomic_load(v7);
  *(_QWORD *)v6 = v8;
  do
  {
    v9 = __ldaxr(v7);
    if (v9 != v8)
    {
      __clrex();
      goto LABEL_3;
    }
  }
  while (__stlxr(v6, v7));
  return 0;
}

uint64_t ausdk::AUBase::RemoveRenderNotification(ausdk::AUBase *this, int (*a2)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a3)
{
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;

  ausdk::AUThreadSafeList<ausdk::AUBase::RenderCallback>::AllocNode((uint64_t)this + 224);
  *(_DWORD *)(v6 + 8) = 2;
  *(_QWORD *)(v6 + 16) = a2;
  *(_QWORD *)(v6 + 24) = a3;
  v7 = (unint64_t *)((char *)this + 232);
LABEL_2:
  v8 = atomic_load(v7);
  *(_QWORD *)v6 = v8;
  do
  {
    v9 = __ldaxr(v7);
    if (v9 != v8)
    {
      __clrex();
      goto LABEL_2;
    }
  }
  while (__stlxr(v6, v7));
  return 0;
}

uint64_t ausdk::AUBase::GetParameter(ausdk::AUBase *this, unsigned int a2, unsigned int a3, unsigned int a4, float *a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  *a5 = ausdk::AUElement::GetParameter(Element, a2);
  return 0;
}

uint64_t ausdk::AUBase::SetParameter(ausdk::AUBase *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  return 0;
}

uint64_t ausdk::AUBase::ScheduleParameter(ausdk::AUBase *this, const AudioUnitParameterEvent *a2, int a3)
{
  int v6;
  int v7;
  uint64_t v8;
  const AudioUnitParameterEvent *v9;
  _OWORD *v10;
  unint64_t v11;
  AudioUnitParameterEvent::$30DB46DA13B14C3192C3DF0E34A08043 v12;
  _OWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  AudioUnitParameterEvent::$30DB46DA13B14C3192C3DF0E34A08043 eventValues;
  char *v22;
  char *v23;
  _OWORD *v24;
  __int128 v25;

  v6 = (*(uint64_t (**)(ausdk::AUBase *))(*(_QWORD *)this + 160))(this);
  if (a3)
  {
    v7 = v6;
    v8 = 0;
    do
    {
      v9 = &a2[v8];
      if (v9->eventType == kParameterEvent_Immediate)
        (*(void (**)(ausdk::AUBase *, _QWORD, _QWORD, _QWORD, _QWORD, AudioUnitParameterValue))(*(_QWORD *)this + 152))(this, v9->parameter, v9->scope, v9->element, v9->eventValues.immediate.bufferOffset, v9->eventValues.immediate.value);
      if (v7)
      {
        v10 = (_OWORD *)*((_QWORD *)this + 49);
        v11 = *((_QWORD *)this + 50);
        if ((unint64_t)v10 >= v11)
        {
          v14 = *((_QWORD *)this + 48);
          v15 = ((uint64_t)v10 - v14) >> 5;
          v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 59)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          v17 = v11 - v14;
          if (v17 >> 4 > v16)
            v16 = v17 >> 4;
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFE0)
            v18 = 0x7FFFFFFFFFFFFFFLL;
          else
            v18 = v16;
          if (v18)
            v18 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v18);
          else
            v19 = 0;
          v20 = (_OWORD *)(v18 + 32 * v15);
          eventValues = v9->eventValues;
          *v20 = *(_OWORD *)&v9->scope;
          v20[1] = eventValues;
          v23 = (char *)*((_QWORD *)this + 48);
          v22 = (char *)*((_QWORD *)this + 49);
          v24 = v20;
          if (v22 != v23)
          {
            do
            {
              v25 = *((_OWORD *)v22 - 1);
              *(v24 - 2) = *((_OWORD *)v22 - 2);
              *(v24 - 1) = v25;
              v24 -= 2;
              v22 -= 32;
            }
            while (v22 != v23);
            v22 = (char *)*((_QWORD *)this + 48);
          }
          v13 = v20 + 2;
          *((_QWORD *)this + 48) = v24;
          *((_QWORD *)this + 49) = v20 + 2;
          *((_QWORD *)this + 50) = v18 + 32 * v19;
          if (v22)
            operator delete(v22);
        }
        else
        {
          v12 = v9->eventValues;
          *v10 = *(_OWORD *)&v9->scope;
          v10[1] = v12;
          v13 = v10 + 2;
        }
        *((_QWORD *)this + 49) = v13;
      }
      ++v8;
    }
    while (v8 != a3);
  }
  return 0;
}

uint64_t ausdk::AUBase::SetBusCount(ausdk::AUBase *this, unsigned int a2, unsigned int a3)
{
  int64x2_t *Scope;

  if (*((_BYTE *)this + 17))
    return 4294956447;
  Scope = (int64x2_t *)ausdk::AUBase::GetScope(this, a2);
  ausdk::AUScope::SetNumberOfElements(Scope, a3);
  return 0;
}

uint64_t ausdk::AUBase::SetConnection(const void **this, const AudioUnitConnection *a2)
{
  uint64_t Element;
  OpaqueAudioComponentInstance *sourceAudioUnit;
  uint64_t result;
  _QWORD *v7;
  UInt32 ioDataSize;
  _OWORD outData[2];
  uint64_t v10;

  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(this + 10), a2->destInputNumber);
  sourceAudioUnit = a2->sourceAudioUnit;
  if (!a2->sourceAudioUnit)
    goto LABEL_6;
  v10 = 0;
  memset(outData, 0, sizeof(outData));
  ioDataSize = 40;
  result = AudioUnitGetProperty(sourceAudioUnit, 8u, 2u, a2->sourceOutputNumber, outData, &ioDataSize);
  if (!(_DWORD)result)
  {
    result = ausdk::AUBase::DispatchSetProperty(this, 8, 1, a2->destInputNumber, outData, 40);
    if (!(_DWORD)result)
    {
      if (a2->sourceAudioUnit)
      {
        *(_DWORD *)(Element + 172) = 1;
        *(AudioUnitConnection *)(Element + 192) = *a2;
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)Element + 64))(Element, 0);
LABEL_9:
        (*((void (**)(const void **, uint64_t, uint64_t, _QWORD))*this + 54))(this, 1, 1, a2->destInputNumber);
        return 0;
      }
LABEL_6:
      *(_DWORD *)(Element + 172) = 0;
      v7 = *(_QWORD **)(Element + 152);
      if (v7)
      {
        ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v7);
        *(_QWORD *)(Element + 152) = 0;
      }
      *(_QWORD *)(Element + 160) = 0;
      *(_DWORD *)(Element + 144) = 0;
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t ausdk::AUBase::SetInputCallback(ausdk::AUBase *this, uint64_t a2, uint64_t a3, int (*a4)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a5)
{
  ausdk::AUInputElement *Element;

  Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((ausdk::AUBase *)((char *)this + 80), a3);
  ausdk::AUInputElement::SetInputCallback(Element, a4, a5);
  (*(void (**)(ausdk::AUBase *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 432))(this, a2, 1, a3);
  return 0;
}

uint64_t ausdk::AUBase::GetParameterList(ausdk::AUBase *this, unsigned int a2, unsigned int *a3, unsigned int *a4)
{
  _QWORD *Scope;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;

  Scope = (_QWORD *)ausdk::AUBase::GetScope(this, a2);
  v7 = Scope[5];
  if (v7)
  {
    LODWORD(v8) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
    if ((_DWORD)v8)
      goto LABEL_3;
LABEL_14:
    v10 = 0;
    goto LABEL_15;
  }
  v8 = (Scope[3] - Scope[2]) >> 3;
  if (!(_DWORD)v8)
    goto LABEL_14;
LABEL_3:
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = v8;
  do
  {
    v13 = Scope[5];
    if (v13)
      v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v13 + 32))(v13, v9);
    else
      v14 = *(_QWORD *)(Scope[2] + 8 * v9);
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 16))(v14);
    if (v15 > v10)
    {
      v11 = v14;
      v10 = v15;
    }
    ++v9;
  }
  while (v12 != v9);
  if (a3 && v11)
    (*(void (**)(uint64_t, unsigned int *))(*(_QWORD *)v11 + 24))(v11, a3);
LABEL_15:
  *a4 = v10;
  return 0;
}

uint64_t ausdk::AUBase::GetParameterInfo(ausdk::AUBase *this, unsigned int a2, unsigned int a3, AudioUnitParameterInfo *a4)
{
  return 4294956418;
}

uint64_t ausdk::AUBase::GetParameterHistoryInfo(ausdk::AUBase *this, unsigned int a2, unsigned int a3, float *a4, float *a5)
{
  return 4294956417;
}

uint64_t ausdk::AUBase::SaveState(ausdk::AUBase *this, ausdk **a2)
{
  __CFData *Mutable;
  unsigned int i;
  ausdk::AUScope *Scope;
  unsigned int v6;
  ausdk::AUScope *v7;
  __CFDictionary *v8;
  unsigned int v9;
  const CFDictionaryValueCallBacks *v10;
  uint64_t v11;
  __CFDictionary *v12;
  unint64_t j;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFStringRef v19;
  const void *v20;
  CFStringRef v21;
  ausdk *theDict;
  _DWORD v25[3];
  __CFString *v26;
  int v27;

  *(_QWORD *)&v25[1] = 0;
  v26 = 0;
  v27 = 0;
  ausdk::ComponentBase::GetComponentDescription((ausdk::ComponentBase *)&v25[1], *((OpaqueAudioComponentInstance **)this + 1));
  theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  ausdk::AddNumToDictionary(theDict, (__CFDictionary *)CFSTR("version"), 0);
  ausdk::AddNumToDictionary(theDict, (__CFDictionary *)CFSTR("type"), (const __CFString *)v25[1]);
  ausdk::AddNumToDictionary(theDict, (__CFDictionary *)CFSTR("subtype"), (const __CFString *)v25[2]);
  v25[0] = (_DWORD)v26;
  ausdk::AddNumToDictionary(theDict, (__CFDictionary *)CFSTR("manufacturer"), (const __CFString *)v26);
  Mutable = CFDataCreateMutable(0, 0);
  for (i = 0; i != 3; ++i)
  {
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, i);
    ausdk::AUScope::SaveState(Scope, Mutable);
  }
  (*(void (**)(ausdk::AUBase *, __CFData *))(*(_QWORD *)this + 280))(this, Mutable);
  CFDictionarySetValue(theDict, CFSTR("data"), Mutable);
  if (Mutable)
    ausdk::Owned<__CFData *>::releaseRef(Mutable);
  CFDictionarySetValue(theDict, CFSTR("name"), *((const void **)this + 46));
  if (!(*(unsigned int (**)(ausdk::AUBase *, uint64_t, _QWORD, _QWORD, _DWORD *))(*(_QWORD *)this + 88))(this, 26, 0, 0, v25))ausdk::AddNumToDictionary(theDict, (__CFDictionary *)CFSTR("render-quality"), (const __CFString *)v25[0]);
  v6 = 0;
  while (1)
  {
    v7 = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, v6);
    if (ausdk::AUScope::HasElementWithName(v7))
      break;
    if (++v6 == 4)
      goto LABEL_29;
  }
  v8 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v9 = 0;
  v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    v11 = ausdk::AUBase::GetScope(this, v9);
    if (!ausdk::AUScope::HasElementWithName((ausdk::AUScope *)v11))
      goto LABEL_27;
    v12 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], v10);
    for (j = 0; ; ++j)
    {
      v14 = *(_QWORD *)(v11 + 40);
      if (v14)
        LODWORD(v15) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
      else
        v15 = (*(_QWORD *)(v11 + 24) - *(_QWORD *)(v11 + 16)) >> 3;
      if (j >= v15)
        break;
      v16 = *(_QWORD *)(v11 + 40);
      if (v16)
      {
        v17 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v16 + 32))(v16, j);
        if (!v17)
          continue;
      }
      else
      {
        v18 = *(_QWORD *)(v11 + 16);
        if (j >= (*(_QWORD *)(v11 + 24) - v18) >> 3)
          continue;
        v17 = *(_QWORD *)(v18 + 8 * j);
        if (!v17)
          continue;
      }
      if (*(_QWORD *)(v17 + 72))
      {
        v19 = CFStringCreateWithFormat(0, 0, CFSTR("%u"), j);
        v20 = *(const void **)(v17 + 72);
        ausdk::Owned<__CFString const*>::retainRef(v20);
        CFDictionarySetValue(v12, v19, v20);
        ausdk::Owned<__CFString const*>::releaseRef(v20);
        ausdk::Owned<__CFString const*>::releaseRef(v19);
      }
    }
    v21 = CFStringCreateWithFormat(0, 0, CFSTR("%u"), *(unsigned int *)(v11 + 8));
    CFDictionarySetValue(v8, v21, v12);
    ausdk::Owned<__CFString const*>::releaseRef(v21);
    ausdk::Owned<__CFDictionary *>::releaseRef(v12);
LABEL_27:
    ++v9;
  }
  while (v9 != 4);
  CFDictionarySetValue(theDict, CFSTR("element-name"), v8);
  ausdk::Owned<__CFDictionary *>::releaseRef(v8);
LABEL_29:
  *a2 = theDict;
  ausdk::Owned<__CFData *>::releaseRef(0);
  ausdk::Owned<__CFDictionary *>::releaseRef(0);
  return 0;
}

void sub_1B65BDAB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12)
{
  const void *v12;

  ausdk::Owned<__CFDictionary *>::releaseRef(v12);
  ausdk::Owned<__CFData *>::releaseRef(0);
  ausdk::Owned<__CFDictionary *>::releaseRef(a12);
  _Unwind_Resume(a1);
}

uint64_t ausdk::AUBase::RestoreState(OpaqueAudioComponentInstance **this, CFTypeRef cf)
{
  CFTypeID v4;
  uint64_t result;
  const __CFNumber *Value;
  const __CFNumber *v7;
  CFTypeID v8;
  const __CFNumber *v9;
  const __CFNumber *v10;
  CFTypeID v11;
  const __CFNumber *v12;
  const __CFNumber *v13;
  CFTypeID v14;
  const __CFData *v15;
  const __CFData *v16;
  CFTypeID v17;
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v20;
  ausdk::AUScope *Scope;
  const __CFString *v22;
  OpaqueAudioComponentInstance *v23;
  CFTypeID v24;
  const __CFNumber *v25;
  const __CFNumber *v26;
  CFTypeID v27;
  const __CFDictionary *v28;
  CFTypeID v29;
  uint64_t v30;
  CFStringRef v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  CFTypeID v34;
  const __CFDictionary *v35;
  unsigned int *v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int *v39;
  uint64_t v40;
  int valuePtr;
  uint64_t v42;
  uint64_t v43;
  int v44;

  v4 = CFGetTypeID(cf);
  if (v4 != CFDictionaryGetTypeID())
    return 4294956445;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  ausdk::ComponentBase::GetComponentDescription((ausdk::ComponentBase *)&v42, this[1]);
  if (CFDictionaryContainsKey((CFDictionaryRef)cf, CFSTR("part")))
    return 4294956445;
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("version"));
  if (!Value)
    return 4294956445;
  v7 = Value;
  v8 = CFGetTypeID(Value);
  if (v8 != CFNumberGetTypeID())
    return 4294956445;
  valuePtr = 0;
  CFNumberGetValue(v7, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr)
    return 4294956445;
  v9 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("subtype"));
  if (!v9)
    return 4294956445;
  v10 = v9;
  v11 = CFGetTypeID(v9);
  if (v11 != CFNumberGetTypeID())
    return 4294956445;
  CFNumberGetValue(v10, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr != HIDWORD(v42))
    return 4294956445;
  v12 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("manufacturer"));
  if (!v12)
    return 4294956445;
  v13 = v12;
  v14 = CFGetTypeID(v12);
  if (v14 != CFNumberGetTypeID())
    return 4294956445;
  CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr != (_DWORD)v43)
    return 4294956445;
  v15 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("data"));
  if (v15)
  {
    v16 = v15;
    v17 = CFGetTypeID(v15);
    if (v17 == CFDataGetTypeID())
    {
      BytePtr = CFDataGetBytePtr(v16);
      Length = CFDataGetLength(v16);
      if (Length >= 1)
      {
        v20 = &BytePtr[Length];
        do
        {
          Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope((ausdk::AUBase *)this, bswap32(*(_DWORD *)BytePtr));
          BytePtr = ausdk::AUScope::RestoreState(Scope, BytePtr + 4);
        }
        while (BytePtr < v20);
      }
    }
  }
  v22 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("name"));
  v23 = this[46];
  if (v23)
    CFRelease(v23);
  if (!v22 || (v24 = CFGetTypeID(v22), v24 != CFStringGetTypeID()))
    v22 = CFSTR("Untitled");
  this[46] = (OpaqueAudioComponentInstance *)v22;
  *((_DWORD *)this + 90) = -1;
  CFRetain(v22);
  (*((void (**)(OpaqueAudioComponentInstance **, uint64_t, _QWORD, _QWORD))*this + 54))(this, 36, 0, 0);
  v25 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("render-quality"));
  if (v25)
  {
    v26 = v25;
    v27 = CFGetTypeID(v25);
    if (v27 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v26, kCFNumberSInt32Type, &valuePtr);
      ausdk::AUBase::DispatchSetProperty((const void **)this, 26, 0, 0, &valuePtr, 4);
    }
  }
  result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("element-name"));
  if (result)
  {
    v28 = (const __CFDictionary *)result;
    v29 = CFGetTypeID((CFTypeRef)result);
    if (v29 == CFDictionaryGetTypeID())
    {
      v30 = 0;
      do
      {
        v31 = CFStringCreateWithFormat(0, 0, CFSTR("%u"), v30);
        v32 = (const __CFDictionary *)CFDictionaryGetValue(v28, v31);
        if (v32)
        {
          v33 = v32;
          v34 = CFGetTypeID(v32);
          if (v34 == CFDictionaryGetTypeID())
          {
            v38 = 0;
            v39 = 0;
            v40 = 0;
            v35 = (const __CFDictionary *)ausdk::AUBase::GetScope((ausdk::AUBase *)this, v30);
            ausdk::AUScope::RestoreElementNames((ausdk::AUScope *)&v38, v35, v33);
            v36 = v38;
            v37 = v39;
            if (v38 != v39)
            {
              do
                (*((void (**)(OpaqueAudioComponentInstance **, uint64_t, uint64_t, _QWORD))*this + 54))(this, 30, v30, *v36++);
              while (v36 != v37);
              v36 = v38;
            }
            if (v36)
            {
              v39 = v36;
              operator delete(v36);
            }
          }
        }
        CFRelease(v31);
        result = 0;
        v30 = (v30 + 1);
      }
      while ((_DWORD)v30 != 4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_1B65BDEF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::AUBase::GetParameterValueStrings(ausdk::AUBase *this, unsigned int a2, unsigned int a3, const __CFArray **a4)
{
  return 4294956417;
}

uint64_t ausdk::AUBase::CopyClumpName(ausdk::AUBase *this, unsigned int a2, unsigned int a3, unsigned int a4, const __CFString **a5)
{
  return 4294956417;
}

uint64_t ausdk::AUBase::GetPresets(ausdk::AUBase *this, const __CFArray **a2)
{
  return 4294956417;
}

uint64_t ausdk::AUBase::NewFactoryPresetSet(ausdk::AUBase *this, const AUPreset *a2)
{
  return 4294956417;
}

uint64_t ausdk::AUBase::NewCustomPresetSet(CFTypeRef *this, const AUPreset *a2)
{
  AUPreset *v4;

  v4 = (AUPreset *)(this + 45);
  CFRelease(this[46]);
  *v4 = *a2;
  CFRetain(this[46]);
  return 0;
}

uint64_t ausdk::AUBase::CopyIconLocation(ausdk::AUBase *this)
{
  return 0;
}

uint64_t ausdk::AUBase::SupportedNumChannels(ausdk::AUBase *this, const AUChannelInfo **a2)
{
  return 0;
}

BOOL ausdk::AUBase::ValidFormat(ausdk::AUBase *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  _BOOL8 result;

  result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if (result)
    return (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
  return result;
}

__n128 ausdk::AUBase::GetStreamFormat@<Q0>(ausdk::AUBase *this@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  ausdk::AUScope *v5;
  uint64_t IOElement;
  __n128 result;
  __int128 v8;

  if (a2)
  {
    if (a2 == 2)
    {
      v5 = (ausdk::AUBase *)((char *)this + 128);
    }
    else
    {
      if (a2 != 1)
        ausdk::Throw((ausdk *)0xFFFFD58ELL);
      v5 = (ausdk::AUBase *)((char *)this + 80);
    }
    a2 = a3;
  }
  else
  {
    v5 = (ausdk::AUBase *)((char *)this + 128);
  }
  IOElement = ausdk::AUScope::GetIOElement(v5, a2);
  result = *(__n128 *)(IOElement + 80);
  v8 = *(_OWORD *)(IOElement + 96);
  *(__n128 *)a4 = result;
  *(_OWORD *)(a4 + 16) = v8;
  *(_QWORD *)(a4 + 32) = *(_QWORD *)(IOElement + 112);
  return result;
}

uint64_t ausdk::AUBase::ChangeStreamFormat(ausdk::AUBase *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *__s2, const AudioStreamBasicDescription *__s1)
{
  ausdk::AUScope *v9;
  unsigned int v10;
  uint64_t IOElement;

  if (memcmp(__s1, __s2, 0x28uLL))
  {
    if ((_DWORD)a2)
    {
      if ((_DWORD)a2 == 2)
      {
        v9 = (ausdk::AUBase *)((char *)this + 128);
      }
      else
      {
        if ((_DWORD)a2 != 1)
          ausdk::Throw((ausdk *)0xFFFFD58ELL);
        v9 = (ausdk::AUBase *)((char *)this + 80);
      }
      v10 = a3;
    }
    else
    {
      v9 = (ausdk::AUBase *)((char *)this + 128);
      v10 = 0;
    }
    IOElement = ausdk::AUScope::GetIOElement(v9, v10);
    (*(void (**)(uint64_t, const AudioStreamBasicDescription *))(*(_QWORD *)IOElement + 56))(IOElement, __s1);
    (*(void (**)(ausdk::AUBase *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 432))(this, 8, a2, a3);
  }
  return 0;
}

uint64_t ausdk::AUBase::CreateElement@<X0>(ausdk::AUBase *this@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  uint64_t result;
  uint64_t v6;

  switch(a2)
  {
    case 0:
    case 3:
    case 4:
      result = operator new();
      v6 = result;
      *(_QWORD *)result = &off_1E69EDDC8;
      *(_QWORD *)(result + 8) = this;
      *(_QWORD *)(result + 24) = 0;
      *(_QWORD *)(result + 32) = 0;
      *(_QWORD *)(result + 16) = 0;
      *(_BYTE *)(result + 40) = 0;
      *(_OWORD *)(result + 48) = 0u;
      *(_OWORD *)(result + 64) = 0u;
      break;
    case 1:
      v6 = operator new();
      result = (uint64_t)ausdk::AUIOElement::AUIOElement((ausdk::AUIOElement *)v6, this);
      *(_QWORD *)v6 = &off_1E69EDE10;
      *(_OWORD *)(v6 + 172) = 0u;
      *(_OWORD *)(v6 + 188) = 0u;
      *(_DWORD *)(v6 + 204) = 0;
      break;
    case 2:
      v6 = operator new();
      result = (uint64_t)ausdk::AUOutputElement::AUOutputElement((ausdk::AUOutputElement *)v6, this);
      break;
    default:
      ausdk::Throw((ausdk *)0xFFFFD58ELL);
  }
  *a3 = v6;
  return result;
}

void sub_1B65BE1DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10E1C409BA96DF7);
  _Unwind_Resume(a1);
}

uint64_t ausdk::AUBase::PropertyChanged(uint64_t this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v9;

  v4 = *(_QWORD *)(this + 408);
  v5 = *(_QWORD *)(this + 416);
  if (v4 != v5)
  {
    v9 = this;
    do
    {
      if (*(_DWORD *)v4 == (_DWORD)a2)
        this = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(v4 + 8))(*(_QWORD *)(v4 + 16), *(_QWORD *)(v9 + 8), a2, a3, a4);
      v4 += 24;
    }
    while (v4 != v5);
  }
  return this;
}

uint64_t ausdk::AUBase::ReallocateBuffers(int64x2_t *this)
{
  uint64_t v2;
  unint64_t v3;
  unsigned int v4;
  uint64_t Element;
  uint64_t result;
  unint64_t v7;
  unsigned int v8;
  uint64_t v9;

  ausdk::AUBase::CreateElements(this);
  v2 = this[10].i64[1];
  if (v2)
  {
    LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    if (!(_DWORD)v3)
      goto LABEL_7;
  }
  else
  {
    v3 = (unint64_t)(this[9].i64[1] - this[9].i64[0]) >> 3;
    if (!(_DWORD)v3)
      goto LABEL_7;
  }
  v4 = 0;
  do
  {
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[8], v4);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)Element + 64))(Element, 0);
    ++v4;
  }
  while ((_DWORD)v3 != v4);
LABEL_7:
  result = this[7].i64[1];
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    LODWORD(v7) = result;
    if (!(_DWORD)result)
      goto LABEL_13;
  }
  else
  {
    v7 = (unint64_t)(this[6].i64[1] - this[6].i64[0]) >> 3;
    if (!(_DWORD)v7)
      goto LABEL_13;
  }
  v8 = 0;
  do
  {
    v9 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[5], v8);
    result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 64))(v9, 0);
    ++v8;
  }
  while ((_DWORD)v7 != v8);
LABEL_13:
  this[27].i8[0] = 1;
  return result;
}

void ausdk::AUBase::DeallocateIOBuffers(ausdk::AUBase *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t Element;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  _QWORD *v11;

  if (*((_BYTE *)this + 432))
  {
    v2 = *((_QWORD *)this + 21);
    if (v2)
      LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    else
      v3 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
    if ((_DWORD)v3)
    {
      v4 = 0;
      do
      {
        Element = ausdk::AUScope::SafeGetElement((ausdk::AUBase *)((char *)this + 128), v4);
        v6 = *(_QWORD **)(Element + 152);
        if (v6)
        {
          ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v6);
          *(_QWORD *)(Element + 152) = 0;
        }
        *(_QWORD *)(Element + 160) = 0;
        *(_DWORD *)(Element + 144) = 0;
        ++v4;
      }
      while ((_DWORD)v3 != v4);
    }
    v7 = *((_QWORD *)this + 15);
    if (v7)
    {
      LODWORD(v8) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
      if (!(_DWORD)v8)
        goto LABEL_18;
    }
    else
    {
      v8 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
      if (!(_DWORD)v8)
      {
LABEL_18:
        *((_BYTE *)this + 432) = 0;
        return;
      }
    }
    v9 = 0;
    do
    {
      v10 = ausdk::AUScope::SafeGetElement((ausdk::AUBase *)((char *)this + 80), v9);
      v11 = *(_QWORD **)(v10 + 152);
      if (v11)
      {
        ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v11);
        *(_QWORD *)(v10 + 152) = 0;
      }
      *(_QWORD *)(v10 + 160) = 0;
      *(_DWORD *)(v10 + 144) = 0;
      ++v9;
    }
    while ((_DWORD)v8 != v9);
    goto LABEL_18;
  }
}

uint64_t ausdk::AUBase::SetMaxFramesPerSlice(uint64_t this, int a2)
{
  uint64_t v2;

  if (*(_DWORD *)(this + 336) != a2)
  {
    v2 = this;
    *(_DWORD *)(this + 336) = a2;
    if (*(_BYTE *)(this + 432))
      (*(void (**)(uint64_t))(*(_QWORD *)this + 496))(this);
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v2 + 432))(v2, 14, 0, 0);
  }
  return this;
}

uint64_t ausdk::AUBase::CanSetMaxFrames(ausdk::AUBase *this)
{
  if (*((_BYTE *)this + 17))
    return 4294956447;
  else
    return 0;
}

uint64_t ausdk::AUBase::GetAudioChannelLayout(ausdk::AUBase *this, unsigned int a2, unsigned int a3, AudioChannelLayout *a4, BOOL *a5)
{
  ausdk::AUScope *Scope;
  uint64_t IOElement;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a2);
  IOElement = ausdk::AUScope::GetIOElement(Scope, a3);
  return (*(uint64_t (**)(uint64_t, AudioChannelLayout *, BOOL *))(*(_QWORD *)IOElement + 96))(IOElement, a4, a5);
}

uint64_t ausdk::AUBase::SetAudioChannelLayout(ausdk::AUBase *this, uint64_t a2, uint64_t a3, AudioChannelLayout *a4)
{
  ausdk::AUScope *Scope;
  _DWORD *IOElement;
  int v10;
  const AudioChannelLayout *v11;
  _DWORD *v12;
  _DWORD *v13;
  uint64_t v15;
  _DWORD *v17;
  _DWORD *v18;
  uint64_t v19;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a2);
  IOElement = (_DWORD *)ausdk::AUScope::GetIOElement(Scope, a3);
  v10 = IOElement[27];
  if (v10 != ausdk::AUChannelLayout::NumberChannels((ausdk::AUChannelLayout *)a4, v11))
    return 4294956445;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  (*(void (**)(_DWORD **__return_ptr, ausdk::AUBase *, uint64_t, uint64_t))(*(_QWORD *)this + 552))(&v17, this, a2, a3);
  v12 = v17;
  if (v17 == v18)
  {
    v15 = 4294956417;
  }
  else
  {
    v13 = v17;
    while (*v13 && *v13 != a4->mChannelLayoutTag)
    {
      if (++v13 == v18)
        goto LABEL_14;
    }
    if (v13 != v18)
    {
      v15 = (*(uint64_t (**)(_DWORD *, AudioChannelLayout *))(*(_QWORD *)IOElement + 88))(IOElement, a4);
      v12 = v17;
      goto LABEL_15;
    }
LABEL_14:
    v15 = 4294956445;
  }
LABEL_15:
  if (v12)
  {
    v18 = v12;
    operator delete(v12);
  }
  return v15;
}

void sub_1B65BE670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::AUBase::RemoveAudioChannelLayout(ausdk::AUBase *this, unsigned int a2, unsigned int a3)
{
  ausdk::AUScope *Scope;
  uint64_t IOElement;
  uint64_t result;
  char v7;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a2);
  IOElement = ausdk::AUScope::GetIOElement(Scope, a3);
  v7 = 0;
  result = (*(uint64_t (**)(uint64_t, _QWORD, char *))(*(_QWORD *)IOElement + 96))(IOElement, 0, &v7);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)IOElement + 104))(IOElement);
  return result;
}

uint64_t ausdk::AUBase::GetChannelLayoutTags(ausdk::AUBase *this, unsigned int a2, unsigned int a3)
{
  ausdk::AUScope *Scope;
  uint64_t IOElement;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a2);
  IOElement = ausdk::AUScope::GetIOElement(Scope, a3);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)IOElement + 80))(IOElement);
}

uint64_t ausdk::AUBase::ProcessForScheduledParams(ausdk::AUBase *a1, __int128 **a2, uint64_t a3, uint64_t a4)
{
  __int128 *v8;
  __int128 *v9;
  unint64_t v10;
  uint64_t v11;
  __n128 v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int *v15;
  __int128 *v16;
  uint64_t v17;
  __int128 *v18;
  int v19;
  int v21;
  uint64_t v23;
  int v24;
  uint64_t Element;
  uint64_t result;
  BOOL v28;
  BOOL (*v29)(ausdk *, const AudioUnitParameterEvent *, const AudioUnitParameterEvent *);

  v8 = *a2;
  v9 = a2[1];
  v10 = 126 - 2 * __clz(((char *)v9 - (char *)v8) >> 5);
  v29 = ausdk::ParameterEventListSortPredicate;
  if (v9 == v8)
    v11 = 0;
  else
    v11 = v10;
  v12.n128_f64[0] = _ZNSt3__111__introsortINS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_Lb0EEEvT1_S9_T0_NS_15iterator_traitsIS9_E15difference_typeEb(v8, v9, (uint64_t (**)(__int128 *, __int128 *))&v29, v11, 1);
  if ((_DWORD)a3)
  {
    v13 = 0;
    v14 = a3;
    while (1)
    {
      v15 = (unsigned int *)*a2;
      v16 = a2[1];
      v17 = a3;
      v18 = *a2;
      if (*a2 != v16)
        break;
      v23 = (a3 - v13);
      v17 = a3;
LABEL_34:
      result = (*(uint64_t (**)(ausdk::AUBase *, uint64_t, uint64_t, uint64_t, uint64_t, __n128))(*(_QWORD *)a1 + 568))(a1, a4, v13, v23, a3, v12);
      if ((_DWORD)result)
        return result;
      v13 = v17;
      v28 = v14 > v23;
      if (v14 >= v23)
        v14 -= v23;
      else
        v14 = 0;
      if (!v28)
        return 0;
    }
    while (1)
    {
      v19 = *((_DWORD *)v18 + 4);
      if (v19 > (int)v13 && v19 < (int)v17)
        break;
      if (*((_DWORD *)v18 + 3) == 2)
      {
        v21 = *((_DWORD *)v18 + 5) + v19;
        if (v21 >= (int)v17 || v21 <= (int)v13)
          v17 = v17;
        else
          v17 = v21;
      }
      v18 += 2;
      if (v18 == v16)
        goto LABEL_22;
    }
    v17 = *((unsigned int *)v18 + 4);
LABEL_22:
    v23 = (v17 - v13);
    while (1)
    {
      v24 = v15[4];
      if (v15[3] == 2)
      {
        if (v24 < (int)v17 && (int)(v15[5] + v24) > (int)v13)
        {
LABEL_31:
          Element = ausdk::AUBase::GetElement(a1, *v15, v15[1]);
          if (Element)
            (*(void (**)(uint64_t, _QWORD, unsigned int *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)Element + 32))(Element, v15[2], v15, v13, (v17 - v13), 0);
        }
      }
      else if (v24 <= v13)
      {
        goto LABEL_31;
      }
      v15 += 8;
      if (v15 == (unsigned int *)v16)
        goto LABEL_34;
    }
  }
  return 0;
}

BOOL ausdk::ParameterEventListSortPredicate(ausdk *this, const AudioUnitParameterEvent *a2, const AudioUnitParameterEvent *a3)
{
  return *((_DWORD *)this + 4) < a2->eventValues.ramp.startBufferOffset;
}

double _ZNSt3__111__introsortINS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_Lb0EEEvT1_S9_T0_NS_15iterator_traitsIS9_E15difference_typeEb(__int128 *a1, __int128 *a2, uint64_t (**a3)(__int128 *, __int128 *), uint64_t a4, char a5)
{
  __int128 *v10;
  uint64_t v11;
  unint64_t v12;
  __int128 *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 *v18;
  __int128 *v19;
  __int128 *v20;
  __int128 *v21;
  __int128 *v22;
  __int128 *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  BOOL v29;
  double result;
  __int128 v31;
  __int128 *v32;
  int v33;
  __int128 *v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 *v44;
  BOOL v46;
  uint64_t v47;
  __int128 *v48;
  __int128 *v49;
  __int128 v50;
  uint64_t v51;
  char *v52;
  __int128 v53;
  __int128 *v54;
  __int128 v55;
  int64_t v56;
  int64_t v57;
  uint64_t v58;
  __int128 *v59;
  __int128 *v60;
  __int128 v61;
  __int128 *v62;
  __int128 v63;
  uint64_t v64;
  uint64_t v65;
  __int128 v66;
  uint64_t v67;
  uint64_t v68;
  __int128 v69;
  __int128 *v70;
  __int128 *v71;
  uint64_t v72;
  uint64_t v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  unint64_t v78;
  __int128 *v79;
  __int128 v80;
  __int128 *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 *v86;
  __int128 v87;
  __int128 *v88;
  __int128 *v89;
  __int128 v90;
  char v91;
  __int128 v92;
  __int128 *v93;
  __int128 *v94;
  __int128 *v95;
  __int128 *v96;
  int64_t v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;

uint64_t ausdk::AUBase::GetElement(ausdk::AUBase *this, unsigned int a2, uint64_t a3)
{
  _QWORD *Scope;
  uint64_t v5;
  uint64_t v7;

  Scope = (_QWORD *)ausdk::AUBase::GetScope(this, a2);
  v5 = Scope[5];
  if (v5)
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v5 + 32))(Scope[5], a3);
  v7 = Scope[2];
  if (a3 >= (unint64_t)((Scope[3] - v7) >> 3))
    return 0;
  else
    return *(_QWORD *)(v7 + 8 * a3);
}

uint64_t _ZNSt3__17__sort3B8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEjT1_S9_S9_T0_(__int128 *a1, __int128 *a2, __int128 *a3, uint64_t (**a4)(__int128 *, __int128 *))
{
  char v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v8 = (*a4)(a2, a1);
  result = (*a4)(a3, a2);
  if ((v8 & 1) != 0)
  {
    if ((_DWORD)result)
    {
      v11 = *a1;
      v10 = a1[1];
      v12 = a3[1];
      *a1 = *a3;
      a1[1] = v12;
    }
    else
    {
      v20 = *a1;
      v19 = a1[1];
      v21 = a2[1];
      *a1 = *a2;
      a1[1] = v21;
      *a2 = v20;
      a2[1] = v19;
      result = (*a4)(a3, a2);
      if (!(_DWORD)result)
        return result;
      v11 = *a2;
      v10 = a2[1];
      v22 = a3[1];
      *a2 = *a3;
      a2[1] = v22;
    }
    *a3 = v11;
    a3[1] = v10;
  }
  else if ((_DWORD)result)
  {
    v14 = *a2;
    v13 = a2[1];
    v15 = a3[1];
    *a2 = *a3;
    a2[1] = v15;
    *a3 = v14;
    a3[1] = v13;
    result = (*a4)(a2, a1);
    if ((_DWORD)result)
    {
      v17 = *a1;
      v16 = a1[1];
      v18 = a2[1];
      *a1 = *a2;
      a1[1] = v18;
      *a2 = v17;
      a2[1] = v16;
    }
  }
  return result;
}

__n128 _ZNSt3__17__sort4B8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEvT1_S9_S9_S9_T0_(uint64_t a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t (**a5)(__int128 *, __int128 *))
{
  __n128 result;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  _ZNSt3__17__sort3B8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEjT1_S9_S9_T0_((__int128 *)a1, a2, a3, a5);
  if ((*a5)(a4, a3))
  {
    v12 = *a3;
    v11 = a3[1];
    v13 = a4[1];
    *a3 = *a4;
    a3[1] = v13;
    *a4 = v12;
    a4[1] = v11;
    if ((*a5)(a3, a2))
    {
      v15 = *a2;
      v14 = a2[1];
      v16 = a3[1];
      *a2 = *a3;
      a2[1] = v16;
      *a3 = v15;
      a3[1] = v14;
      if ((*a5)(a2, (__int128 *)a1))
      {
        v17 = *(_OWORD *)a1;
        result = *(__n128 *)(a1 + 16);
        v18 = a2[1];
        *(_OWORD *)a1 = *a2;
        *(_OWORD *)(a1 + 16) = v18;
        *a2 = v17;
        a2[1] = (__int128)result;
      }
    }
  }
  return result;
}

__n128 _ZNSt3__17__sort5B8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEvT1_S9_S9_S9_S9_T0_(uint64_t a1, __int128 *a2, __int128 *a3, __int128 *a4, __int128 *a5, uint64_t (**a6)(__int128 *, __int128 *))
{
  __n128 v12;
  __n128 result;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;

  v12 = _ZNSt3__17__sort4B8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEvT1_S9_S9_S9_T0_(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(__int128 *, __int128 *, __n128))*a6)(a5, a4, v12))
  {
    v15 = *a4;
    v14 = a4[1];
    v16 = a5[1];
    *a4 = *a5;
    a4[1] = v16;
    *a5 = v15;
    a5[1] = v14;
    if ((*a6)(a4, a3))
    {
      v18 = *a3;
      v17 = a3[1];
      v19 = a4[1];
      *a3 = *a4;
      a3[1] = v19;
      *a4 = v18;
      a4[1] = v17;
      if ((*a6)(a3, a2))
      {
        v21 = *a2;
        v20 = a2[1];
        v22 = a3[1];
        *a2 = *a3;
        a2[1] = v22;
        *a3 = v21;
        a3[1] = v20;
        if ((*a6)(a2, (__int128 *)a1))
        {
          v23 = *(_OWORD *)a1;
          result = *(__n128 *)(a1 + 16);
          v24 = a2[1];
          *(_OWORD *)a1 = *a2;
          *(_OWORD *)(a1 + 16) = v24;
          *a2 = v23;
          a2[1] = (__int128)result;
        }
      }
    }
  }
  return result;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEbT1_S9_T0_(__int128 *a1, __int128 *a2, uint64_t (**a3)(__int128 *, __int128 *))
{
  uint64_t v6;
  _BOOL8 result;
  __int128 *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 *v12;
  __int128 *v13;
  uint64_t v14;
  int v15;
  __int128 v16;
  uint64_t v17;
  __int128 *v18;
  __int128 v19;
  __int128 *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;

  v6 = ((char *)a2 - (char *)a1) >> 5;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 2;
      if ((*a3)(a2 - 2, a1))
      {
        v10 = *a1;
        v9 = a1[1];
        v11 = *(a2 - 1);
        *a1 = *v8;
        a1[1] = v11;
        *v8 = v10;
        *(a2 - 1) = v9;
      }
      return 1;
    case 3:
      _ZNSt3__17__sort3B8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEjT1_S9_S9_T0_(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      _ZNSt3__17__sort4B8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEvT1_S9_S9_S9_T0_((uint64_t)a1, a1 + 2, a1 + 4, a2 - 2, a3);
      return 1;
    case 5:
      _ZNSt3__17__sort5B8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEvT1_S9_S9_S9_S9_T0_((uint64_t)a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
      return 1;
    default:
      v12 = a1 + 4;
      _ZNSt3__17__sort3B8ne180100INS_15_RangeAlgPolicyERPDoFbRK23AudioUnitParameterEventS4_EPS2_EEjT1_S9_S9_T0_(a1, a1 + 2, a1 + 4, a3);
      v13 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v14 = 0;
      v15 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v13, v12))
    {
      v16 = v13[1];
      v22 = *v13;
      v23 = v16;
      v17 = v14;
      while (1)
      {
        v18 = (__int128 *)((char *)a1 + v17);
        v19 = *(__int128 *)((char *)a1 + v17 + 80);
        v18[6] = *(__int128 *)((char *)a1 + v17 + 64);
        v18[7] = v19;
        if (v17 == -64)
          break;
        v17 -= 32;
        if (((*a3)(&v22, v18 + 2) & 1) == 0)
        {
          v20 = (__int128 *)((char *)a1 + v17 + 96);
          goto LABEL_12;
        }
      }
      v20 = a1;
LABEL_12:
      v21 = v23;
      *v20 = v22;
      v20[1] = v21;
      if (++v15 == 8)
        return v13 + 2 == a2;
    }
    v12 = v13;
    v14 += 32;
    v13 += 2;
    if (v13 == a2)
      return 1;
  }
}

uint64_t ausdk::AUScope::GetIOElement(ausdk::AUScope *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  ausdk::AUException *exception;
  _DWORD v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v2 + 32))(*((_QWORD *)this + 5));
    if (!v3)
    {
LABEL_7:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v7[0] = 67109120;
        v7[1] = -10877;
        _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)v7, 8u);
      }
      exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
      ausdk::AUException::AUException(exception, -10877);
    }
  }
  else
  {
    v4 = *((_QWORD *)this + 2);
    if (a2 >= (unint64_t)((*((_QWORD *)this + 3) - v4) >> 3))
      goto LABEL_7;
    v3 = *(_QWORD *)(v4 + 8 * a2);
    if (!v3)
      goto LABEL_7;
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
  if (!result)
    goto LABEL_7;
  return result;
}

void sub_1B65BF658(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

int64x2_t *ausdk::AUBase::CreateElements(int64x2_t *this)
{
  int64x2_t *v1;

  if (!this[1].i8[0])
  {
    v1 = this;
    ausdk::AUScope::Initialize(this + 5, (ausdk::AUBase *)v1, 1, v1[1].u32[1]);
    ausdk::AUScope::Initialize(v1 + 8, (ausdk::AUBase *)v1, 2, v1[1].u32[2]);
    ausdk::AUScope::Initialize(v1 + 11, (ausdk::AUBase *)v1, 3, v1[1].u32[3]);
    this = (int64x2_t *)(*(uint64_t (**)(int64x2_t *))(v1->i64[0] + 48))(v1);
    v1[1].i8[0] = 1;
  }
  return this;
}

uint64_t ausdk::AUBase::DispatchSetProperty(const void **this, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *__s2, uint64_t a6)
{
  int v6;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  void (*v16)(const void **, uint64_t, uint64_t, uint64_t);
  const void **v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __n128 v21;
  size_t v22;
  int v23;
  uint64_t v24;
  _QWORD *Scope;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  ausdk::AUScope *v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  void *__dst[2];
  __int128 v36;
  uint64_t v37;

  v6 = a6;
  if ((int)a2 > 18)
  {
    if ((int)a2 <= 35)
    {
      switch((int)a2)
      {
        case 19:
          if (a6 < 0xC)
            return 4294956445;
          v12 = a6;
          if (20 * (unint64_t)*((unsigned int *)__s2 + 2) + 12 > a6)
            return 4294956445;
          __dst[0] = 0;
          __dst[1] = 0;
          *(_QWORD *)&v36 = 0;
          if ((a6 & 0x1F) != 0)
            v13 = ((unint64_t)a6 >> 5) + 1;
          else
            v13 = (unint64_t)a6 >> 5;
          std::vector<AudioChannelLayout>::vector(__dst, v13);
          memcpy(__dst[0], __s2, v12);
          v14 = (*((uint64_t (**)(const void **, uint64_t, uint64_t, void *))*this + 67))(this, a3, a4, __dst[0]);
          if (!(_DWORD)v14)
            (*((void (**)(const void **, uint64_t, uint64_t, uint64_t))*this + 54))(this, 19, a3, a4);
          if (__dst[0])
          {
            __dst[1] = __dst[0];
            operator delete(__dst[0]);
          }
          return v14;
        case 23:
          if (a6 < 0x10)
            return 4294956445;
          return (*((uint64_t (**)(const void **, uint64_t, uint64_t, _QWORD, _QWORD))*this + 30))(this, 23, a4, *__s2, __s2[1]);
        case 25:
          if ((_DWORD)a6 != 8)
            return 4294956445;
          if ((_DWORD)a3)
            return 4294956430;
          ausdk::Owned<__CFString const*>::operator=(this + 65, (const void *)*__s2);
          v16 = (void (*)(const void **, uint64_t, uint64_t, uint64_t))*((_QWORD *)*this + 54);
          v17 = this;
          v18 = 25;
          goto LABEL_66;
        case 27:
          if ((_DWORD)a3)
            return 4294956430;
          if (a6 >= 0x28)
            v22 = 40;
          else
            v22 = a6;
          v23 = memcmp(this + 60, __s2, v22);
          *((_OWORD *)this + 30) = 0u;
          *((_OWORD *)this + 31) = 0u;
          this[64] = 0;
          memcpy(this + 60, __s2, v22);
          if (!v23)
            return 0;
          v16 = (void (*)(const void **, uint64_t, uint64_t, uint64_t))*((_QWORD *)*this + 54);
          v17 = this;
          v18 = 27;
          goto LABEL_66;
        case 30:
          if (!ausdk::AUBase::GetElement((ausdk::AUBase *)this, a3, a4))
            return 4294956419;
          if (v6 != 8)
            return 4294956445;
          Scope = (_QWORD *)ausdk::AUBase::GetScope((ausdk::AUBase *)this, a3);
          v26 = Scope[5];
          if (v26)
          {
            v27 = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v26 + 32))(Scope[5], a4);
          }
          else
          {
            v30 = Scope[2];
            if (a4 >= (unint64_t)((Scope[3] - v30) >> 3))
              v27 = 0;
            else
              v27 = *(_QWORD *)(v30 + 8 * a4);
          }
          ausdk::Owned<__CFString const*>::operator=((const void **)(v27 + 72), (const void *)*__s2);
          v16 = (void (*)(const void **, uint64_t, uint64_t, uint64_t))*((_QWORD *)*this + 54);
          v17 = this;
          v18 = 30;
          v24 = a3;
          goto LABEL_96;
        default:
          goto LABEL_82;
      }
    }
    switch((_DWORD)a2)
    {
      case '$':
        if ((_DWORD)a6 != 16)
          return 4294956445;
        if (!(_DWORD)a3)
        {
          v28 = (void *)__s2[1];
          __dst[0] = *(void **)__s2;
          __dst[1] = v28;
          if (((uint64_t)__dst[0] & 0x80000000) != 0)
          {
            if (!v28)
              return 4294956445;
            v29 = (*((uint64_t (**)(const void **, void **))*this + 41))(this, __dst);
          }
          else
          {
            v29 = (*((uint64_t (**)(const void **, void **))*this + 40))(this, __dst);
          }
          v14 = v29;
          if ((_DWORD)v29)
            return v14;
          v16 = (void (*)(const void **, uint64_t, uint64_t, uint64_t))*((_QWORD *)*this + 54);
          v17 = this;
          v18 = 36;
          goto LABEL_66;
        }
        break;
      case '3':
        if ((a3 - 1) <= 1)
        {
          if (!ausdk::AUBase::GetElement((ausdk::AUBase *)this, a3, a4))
            return 4294956419;
          if (v6 == 4)
          {
            if (*((_BYTE *)this + 17))
              return 4294956447;
            v31 = (ausdk::AUScope *)ausdk::AUBase::GetScope((ausdk::AUBase *)this, a3);
            v14 = 0;
            *(_BYTE *)(ausdk::AUScope::GetIOElement(v31, a4) + 168) = *(_DWORD *)__s2 != 0;
            return v14;
          }
          return 4294956445;
        }
        break;
      case '6':
        if (!(_DWORD)a3)
        {
          if ((_DWORD)a6 == 8)
          {
            ausdk::Owned<__CFString const*>::operator=(this + 58, (const void *)*__s2);
            v16 = (void (*)(const void **, uint64_t, uint64_t, uint64_t))*((_QWORD *)*this + 54);
            v17 = this;
            v18 = 54;
LABEL_66:
            v24 = 0;
LABEL_96:
            v16(v17, v18, v24, a4);
            return 0;
          }
          return 4294956445;
        }
        break;
      default:
LABEL_82:
        v14 = (*((uint64_t (**)(const void **, uint64_t, uint64_t, uint64_t, _QWORD *, uint64_t))*this + 12))(this, a2, a3, a4, __s2, a6);
        if (!(_DWORD)v14)
          (*((void (**)(const void **, uint64_t, uint64_t, uint64_t))*this + 54))(this, a2, a3, a4);
        return v14;
    }
    return 4294956430;
  }
  switch((int)a2)
  {
    case 0:
      if ((_DWORD)a6 != 8)
        return 4294956445;
      if ((_DWORD)a3)
        return 4294956430;
      return (*((uint64_t (**)(const void **, _QWORD))*this + 36))(this, *__s2);
    case 1:
      if (a6 < 0x10)
        return 4294956445;
      *(_OWORD *)__dst = *(_OWORD *)__s2;
      v19 = (*((uint64_t (**)(const void **, void **))*this + 29))(this, __dst);
      goto LABEL_25;
    case 2:
      if ((_DWORD)a6 != 8)
        return 4294956445;
      if (!ausdk::AUBase::GetElement((ausdk::AUBase *)this, a3, a4))
        return 4294956419;
      v37 = 0;
      *(_OWORD *)__dst = 0u;
      v36 = 0u;
      (*((void (**)(void **__return_ptr, const void **, uint64_t, uint64_t))*this + 49))(__dst, this, a3, a4);
      v32 = *(_OWORD *)__dst;
      v33 = v36;
      v34 = v37;
      *(_QWORD *)&v32 = *__s2;
      if (!(*((unsigned int (**)(const void **, uint64_t, uint64_t, __int128 *))*this + 48))(this, a3, a4, &v32))goto LABEL_84;
      if (!memcmp(__dst, &v32, 0x28uLL))
        return 0;
      if (!ausdk::AUBase::IsStreamFormatWritable((ausdk::AUBase *)this, a3, a4))
        goto LABEL_85;
      v19 = (*((uint64_t (**)(const void **, uint64_t, uint64_t, void **, __int128 *))*this + 50))(this, a3, a4, __dst, &v32);
      goto LABEL_25;
    case 8:
      if (a6 < 0x24)
        return 4294956445;
      if (!ausdk::AUBase::GetElement((ausdk::AUBase *)this, a3, a4))
        return 4294956419;
      v21 = *(__n128 *)__s2;
      v20 = *((_OWORD *)__s2 + 1);
      *(_OWORD *)__dst = *(_OWORD *)__s2;
      v36 = v20;
      v37 = *((unsigned int *)__s2 + 8);
      v21.n128_u64[0] = (unint64_t)__dst[0];
      if (*(double *)__dst >= 0.0
        && *(double *)__dst < 3000000.0
        && v36 < 0xF4240
        && DWORD1(v36) < 0xF4240
        && DWORD2(v36) < 0xF4240
        && (HIDWORD(v36) - 1) <= 0x3FF
        && v37 <= 0x400
        && LODWORD(__dst[1])
        && (LODWORD(__dst[1]) != 1819304813 || (_QWORD)v36 == (DWORD2(v36) | 0x100000000))
        && (*((unsigned int (**)(const void **, uint64_t, uint64_t, void **, __n128))*this + 48))(this, a3, a4, __dst, v21))
      {
        v34 = 0;
        v32 = 0u;
        v33 = 0u;
        (*((void (**)(__int128 *__return_ptr, const void **, uint64_t, uint64_t))*this + 49))(&v32, this, a3, a4);
        if (!memcmp(&v32, __dst, 0x28uLL))
          return 0;
        if (ausdk::AUBase::IsStreamFormatWritable((ausdk::AUBase *)this, a3, a4))
        {
          v19 = (*((uint64_t (**)(const void **, uint64_t, uint64_t, __int128 *, void **))*this + 50))(this, a3, a4, &v32, __dst);
LABEL_25:
          v14 = v19;
        }
        else
        {
LABEL_85:
          v14 = 4294956431;
        }
      }
      else
      {
LABEL_84:
        v14 = 4294956428;
      }
      break;
    case 11:
      if ((_DWORD)a6 != 4)
        return 4294956445;
      if (!(*((unsigned int (**)(const void **, uint64_t))*this + 27))(this, a3))
        goto LABEL_85;
      v14 = (*((uint64_t (**)(const void **, uint64_t, _QWORD))*this + 28))(this, a3, *(unsigned int *)__s2);
      if (!(_DWORD)v14)
        (*((void (**)(const void **, uint64_t, uint64_t, uint64_t))*this + 54))(this, 11, a3, a4);
      return v14;
    case 14:
      if ((_DWORD)a6 != 4)
        return 4294956445;
      v14 = (*((uint64_t (**)(const void **))*this + 65))(this);
      if (!(_DWORD)v14)
        (*((void (**)(const void **, _QWORD))*this + 64))(this, *(unsigned int *)__s2);
      return v14;
    default:
      goto LABEL_82;
  }
  return v14;
}

void sub_1B65BFDF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::AUBase::IsStreamFormatWritable(ausdk::AUBase *this, uint64_t a2, uint64_t a3)
{
  ausdk::AUBase *v3;
  uint64_t (*v7)(ausdk::AUBase *, uint64_t, uint64_t);
  uint64_t v8;
  uint64_t v9;

  v3 = this;
  if ((_DWORD)a2)
  {
    if ((_DWORD)a2 != 2
      && ((_DWORD)a2 != 1
       || *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUBase *)((char *)this + 80), a3) + 172) == 1))
    {
      return 0;
    }
    v7 = *(uint64_t (**)(ausdk::AUBase *, uint64_t, uint64_t))(*(_QWORD *)v3 + 368);
    this = v3;
    v8 = a2;
    v9 = a3;
  }
  else
  {
    v7 = *(uint64_t (**)(ausdk::AUBase *, uint64_t, uint64_t))(*(_QWORD *)this + 368);
    v8 = 2;
    v9 = 0;
  }
  return v7(this, v8, v9);
}

void ausdk::AddNumToDictionary(ausdk *this, __CFDictionary *a2, const __CFString *a3)
{
  CFNumberRef v5;
  int valuePtr;

  valuePtr = (int)a3;
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(this, a2, v5);
  CFRelease(v5);
}

void ausdk::Owned<__CFData *>::releaseRef(const void *a1)
{
  if (a1)
    CFRelease(a1);
}

double ausdk::AUThreadSafeList<ausdk::AUBase::RenderCallback>::AllocNode(uint64_t a1)
{
  unint64_t *v1;
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  _OWORD *v9;
  double result;

  v1 = (unint64_t *)(a1 + 16);
LABEL_2:
  v2 = (unint64_t *)atomic_load(v1);
  if (v2)
  {
    do
    {
      v3 = __ldaxr(v1);
      if ((unint64_t *)v3 != v2)
      {
        __clrex();
        goto LABEL_2;
      }
    }
    while (__stlxr(0, v1));
    v4 = *v2;
    if (*v2)
    {
      v5 = (unint64_t *)*v2;
      do
      {
        v6 = v5;
        v5 = (unint64_t *)*v5;
      }
      while (v5);
      while (1)
      {
        v7 = atomic_load(v1);
        *v6 = v7;
        while (1)
        {
          v8 = __ldaxr(v1);
          if (v8 != v7)
            break;
          if (!__stlxr(v4, v1))
            return result;
        }
        __clrex();
      }
    }
  }
  else
  {
    v9 = (_OWORD *)operator new();
    result = 0.0;
    *v9 = 0u;
    v9[1] = 0u;
  }
  return result;
}

ausdk::AUBase *ausdk::AUBase::AUBase(ausdk::AUBase *this, OpaqueAudioComponentInstance *a2, int a3, int a4)
{
  uint64_t v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  int8x8_t v11;
  int16x4_t v12;
  int16x8_t v13;
  size_t v14;
  std::string *v15;
  __int128 v16;
  int16x8_t v17;
  std::string *v18;
  __int128 v19;
  int16x8_t v20;
  std::string *v21;
  __int128 v22;
  std::string::value_type v24[8];
  char v25;
  std::string::value_type __s[8];
  char v27;
  std::string v28;
  std::string v29;
  std::string v30;
  std::string v31;
  std::string info;
  uint64_t v33;
  uint64_t v34;
  int v35;
  _OWORD __str[2];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E69ED700;
  *((_QWORD *)this + 1) = a2;
  ausdk::ComponentBase::GetComponentDescription((ausdk::ComponentBase *)__str, a2);
  v7 = 0;
  *(_QWORD *)this = off_1E69EDB78;
  *((_WORD *)this + 8) = 0;
  *((_BYTE *)this + 18) = 0;
  *((_DWORD *)this + 5) = a3;
  *((_DWORD *)this + 6) = a4;
  *((_DWORD *)this + 7) = 0;
  do
  {
    v8 = (char *)this + v7;
    *((_QWORD *)v8 + 4) = 0;
    *((_DWORD *)v8 + 10) = 0;
    *((_OWORD *)v8 + 3) = 0uLL;
    *((_OWORD *)v8 + 4) = 0uLL;
    v7 += 48;
  }
  while (v7 != 192);
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 32) = 0;
  *((_BYTE *)this + 264) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_BYTE *)this + 248) = 0;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_QWORD *)this + 42) = 0;
  info.__r_.__value_.__r.__words[0] = 0;
  mach_timebase_info((mach_timebase_info_t)&info);
  LODWORD(v9) = HIDWORD(info.__r_.__value_.__r.__words[0]);
  LODWORD(v10) = info.__r_.__value_.__l.__data_;
  *((double *)this + 43) = (double)v9 / (double)v10 * 1000000000.0;
  *((_QWORD *)this + 44) = 0;
  *((_DWORD *)this + 90) = -1;
  *((_QWORD *)this + 46) = 0;
  *((_BYTE *)this + 376) = 0;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_BYTE *)this + 432) = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  ausdk::ComponentBase::GetComponentDescription((ausdk::ComponentBase *)&v33, *((OpaqueAudioComponentInstance **)this + 1));
  memset(__str, 0, sizeof(__str));
  snprintf((char *)__str, 0x20uLL, "AU (%p): ", *((const void **)this + 1));
  v11.i32[0] = bswap32(v33);
  v12 = (int16x4_t)vzip1_s8(v11, v11);
  *(int8x8_t *)v13.i8 = vbsl_s8((int8x8_t)vcgt_u16((uint16x4_t)0x5F005F005F005FLL, (uint16x4_t)(*(_QWORD *)&vadd_s16(v12, (int16x4_t)0xE000E000E000E0) & 0xFF00FF00FF00FFLL)), (int8x8_t)v12, (int8x8_t)0x2E002E002E002ELL);
  *((_BYTE *)&v28.__r_.__value_.__s + 23) = 4;
  LODWORD(v28.__r_.__value_.__l.__data_) = vmovn_s16(v13).u32[0];
  v28.__r_.__value_.__s.__data_[4] = 0;
  v14 = strlen((const char *)__str);
  v15 = std::string::insert(&v28, 0, (const std::string::value_type *)__str, v14);
  v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v29.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  std::string::push_back(&v29, 47);
  v17 = *(int16x8_t *)&v29.__r_.__value_.__l.__data_;
  v30 = v29;
  memset(&v29, 0, sizeof(v29));
  v17.i32[0] = bswap32(HIDWORD(v33));
  *(int8x8_t *)v17.i8 = vzip1_s8(*(int8x8_t *)v17.i8, *(int8x8_t *)v17.i8);
  *(int8x8_t *)v17.i8 = vbsl_s8((int8x8_t)vcgt_u16((uint16x4_t)0x5F005F005F005FLL, (uint16x4_t)(*(_QWORD *)&vadd_s16(*(int16x4_t *)v17.i8, (int16x4_t)0xE000E000E000E0) & 0xFF00FF00FF00FFLL)), *(int8x8_t *)v17.i8, (int8x8_t)0x2E002E002E002ELL);
  v27 = 4;
  *(_DWORD *)__s = vmovn_s16(v17).u32[0];
  __s[4] = 0;
  v18 = std::string::append(&v30, __s, 4uLL);
  v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v31.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  std::string::push_back(&v31, 47);
  v20 = *(int16x8_t *)&v31.__r_.__value_.__l.__data_;
  info = v31;
  memset(&v31, 0, sizeof(v31));
  v20.i32[0] = bswap32(v34);
  *(int8x8_t *)v20.i8 = vzip1_s8(*(int8x8_t *)v20.i8, *(int8x8_t *)v20.i8);
  *(int8x8_t *)v20.i8 = vbsl_s8((int8x8_t)vcgt_u16((uint16x4_t)0x5F005F005F005FLL, (uint16x4_t)(*(_QWORD *)&vadd_s16(*(int16x4_t *)v20.i8, (int16x4_t)0xE000E000E000E0) & 0xFF00FF00FF00FFLL)), *(int8x8_t *)v20.i8, (int8x8_t)0x2E002E002E002ELL);
  v25 = 4;
  *(_DWORD *)v24 = vmovn_s16(v20).u32[0];
  v24[4] = 0;
  v21 = std::string::append(&info, v24, 4uLL);
  v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  *((_QWORD *)this + 57) = *((_QWORD *)&v21->__r_.__value_.__l + 2);
  *(_OWORD *)((char *)this + 440) = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (v25 < 0)
    operator delete(*(void **)v24);
  if (SHIBYTE(info.__r_.__value_.__r.__words[2]) < 0)
    operator delete(info.__r_.__value_.__l.__data_);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
  if (v27 < 0)
    operator delete(*(void **)__s);
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v30.__r_.__value_.__l.__data_);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v29.__r_.__value_.__l.__data_);
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v28.__r_.__value_.__l.__data_);
  *((_QWORD *)this + 41) = 0;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_QWORD *)this + 34) = 0xFFEFFFFFFFFFFFFFLL;
  ausdk::AUScope::Initialize((int64x2_t *)this + 2, this, 0, 1);
  *((_DWORD *)this + 90) = -1;
  *((_QWORD *)this + 46) = CFSTR("Untitled");
  CFRetain(CFSTR("Untitled"));
  return this;
}

void sub_1B65C0384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  _QWORD *v47;
  unint64_t *v48;
  uint64_t v49;
  void **v51;
  void *v52;
  void *v53;
  uint64_t v54;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v49 - 121) < 0)
    operator delete(*(void **)(v49 - 144));
  if (a47 < 0)
    operator delete(a42);
  if (a21 < 0)
    operator delete(a16);
  if (a40 < 0)
    operator delete(a35);
  if (a33 < 0)
    operator delete(a28);
  if (a27 < 0)
    operator delete(a22);
  v51 = (void **)(v47 + 48);
  v52 = (void *)v47[51];
  if (v52)
  {
    v47[52] = v52;
    operator delete(v52);
  }
  v53 = *v51;
  if (*v51)
  {
    v47[49] = v53;
    operator delete(v53);
  }
  ausdk::AUThreadSafeList<ausdk::AUBase::RenderCallback>::~AUThreadSafeList(v48);
  v54 = 24;
  do
  {
    *(_QWORD *)(v49 - 96) = &v47[v54];
    std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v49 - 96));
    v54 -= 6;
  }
  while (v54 * 8);
  _Unwind_Resume(a1);
}

unint64_t *ausdk::AUThreadSafeList<ausdk::AUBase::RenderCallback>::~AUThreadSafeList(unint64_t *a1)
{
  unint64_t *i;
  unint64_t *j;
  unint64_t *k;

  for (i = (unint64_t *)atomic_load(a1); i; i = (unint64_t *)atomic_load(a1))
  {
    atomic_store(*i, a1);
    MEMORY[0x1BCC95CEC]();
  }
  for (j = (unint64_t *)atomic_load(a1 + 1); j; j = (unint64_t *)atomic_load(a1 + 1))
  {
    atomic_store(*j, a1 + 1);
    MEMORY[0x1BCC95CEC]();
  }
  for (k = (unint64_t *)atomic_load(a1 + 2); k; k = (unint64_t *)atomic_load(a1 + 2))
  {
    atomic_store(*k, a1 + 2);
    MEMORY[0x1BCC95CEC]();
  }
  return a1;
}

void ausdk::AUBase::~AUBase(ausdk::AUBase *this)
{
  const void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void **v6;

  *(_QWORD *)this = off_1E69EDB78;
  v2 = (const void *)*((_QWORD *)this + 46);
  if (v2)
    CFRelease(v2);
  ausdk::Owned<__CFString const*>::releaseRef(*((const void **)this + 65));
  ausdk::Owned<__CFString const*>::releaseRef(*((const void **)this + 58));
  if (*((char *)this + 463) < 0)
    operator delete(*((void **)this + 55));
  v3 = (void *)*((_QWORD *)this + 51);
  if (v3)
  {
    *((_QWORD *)this + 52) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 48);
  if (v4)
  {
    *((_QWORD *)this + 49) = v4;
    operator delete(v4);
  }
  ausdk::AUThreadSafeList<ausdk::AUBase::RenderCallback>::~AUThreadSafeList((unint64_t *)this + 28);
  v5 = 192;
  do
  {
    v6 = (void **)((char *)this + v5);
    std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v6);
    v5 -= 48;
  }
  while (v5);
}

uint64_t ausdk::AUBase::DispatchGetPropertyInfo(ausdk::AUBase *this, int a2, uint64_t a3, uint64_t a4, unsigned int *a5, BOOL *a6)
{
  unsigned int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v16;
  unsigned int v17;
  void *v18;
  void *v20;
  void *v21;
  uint64_t v22;

  switch(a2)
  {
    case 0:
    case 25:
    case 54:
      if ((_DWORD)a3)
        goto LABEL_52;
      goto LABEL_3;
    case 1:
    case 23:
      if (a3 > 1)
        goto LABEL_52;
      goto LABEL_45;
    case 2:
      v13 = 8;
      goto LABEL_14;
    case 3:
      LODWORD(v20) = 0;
      v14 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t, _QWORD, void **))(*(_QWORD *)this + 248))(this, a3, 0, &v20);
      if ((_DWORD)v14)
        return v14;
      v15 = 4 * (_DWORD)v20;
      goto LABEL_55;
    case 4:
      v14 = 0;
      v15 = 104;
      goto LABEL_55;
    case 8:
      v13 = 40;
LABEL_14:
      *a5 = v13;
      *a6 = ausdk::AUBase::IsStreamFormatWritable(this, a3, a4);
      goto LABEL_47;
    case 11:
      *a5 = 4;
      v14 = 0;
      *a6 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t))(*(_QWORD *)this + 216))(this, a3);
      return v14;
    case 12:
    case 61:
      if (!(_DWORD)a3)
        goto LABEL_7;
      goto LABEL_52;
    case 13:
      if ((_DWORD)a3)
        goto LABEL_52;
      v16 = (*(uint64_t (**)(ausdk::AUBase *, _QWORD))(*(_QWORD *)this + 376))(this, 0);
      if (!v16)
        goto LABEL_58;
      v12 = 4 * v16;
      goto LABEL_43;
    case 14:
      if ((_DWORD)a3)
        goto LABEL_52;
      v11 = 4;
      goto LABEL_46;
    case 16:
      v14 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this + 296))(this, a3, a4, 0);
      if (!(_DWORD)v14)
        goto LABEL_54;
      return v14;
    case 19:
      *a6 = 0;
      v17 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t, uint64_t, _QWORD, BOOL *))(*(_QWORD *)this + 528))(this, a3, a4, 0, a6);
      v14 = 0;
      *a5 = v17;
      if (!v17)
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        (*(void (**)(void **__return_ptr, ausdk::AUBase *, uint64_t, uint64_t))(*(_QWORD *)this + 552))(&v20, this, a3, a4);
        if (v20 == v21)
          v14 = 4294956417;
        else
          v14 = 4294956445;
        if (v20)
        {
          v21 = v20;
          operator delete(v20);
        }
      }
      return v14;
    case 20:
      if ((_DWORD)a3)
        goto LABEL_52;
      if (!(*(unsigned int (**)(ausdk::AUBase *))(*(_QWORD *)this + 360))(this))
        goto LABEL_58;
      goto LABEL_7;
    case 22:
      if ((_DWORD)a3)
        goto LABEL_52;
      v12 = 4;
      goto LABEL_43;
    case 24:
      if ((_DWORD)a3)
        goto LABEL_52;
      v14 = (*(uint64_t (**)(ausdk::AUBase *, _QWORD))(*(_QWORD *)this + 312))(this, 0);
      if ((_DWORD)v14)
        return v14;
LABEL_7:
      v12 = 8;
LABEL_43:
      *a5 = v12;
      *a6 = 0;
      goto LABEL_47;
    case 27:
      if ((_DWORD)a3)
        goto LABEL_52;
      v11 = 40;
      goto LABEL_46;
    case 30:
LABEL_3:
      v11 = 8;
      goto LABEL_46;
    case 32:
      v20 = 0;
      v21 = 0;
      v22 = 0;
      (*(void (**)(void **__return_ptr, ausdk::AUBase *, uint64_t, uint64_t))(*(_QWORD *)this + 552))(&v20, this, a3, a4);
      v18 = v20;
      if (v20 != v21)
      {
        *a5 = (_DWORD)v21 - (_DWORD)v20;
        *a6 = 0;
        if (v18)
        {
          v21 = v18;
          operator delete(v18);
        }
        goto LABEL_48;
      }
      if (v20)
      {
        v21 = v20;
        operator delete(v20);
      }
LABEL_58:
      v14 = 4294956417;
      break;
    case 35:
      v12 = 16;
      goto LABEL_43;
    case 36:
      if ((_DWORD)a3)
        goto LABEL_52;
LABEL_45:
      v11 = 16;
LABEL_46:
      *a5 = v11;
      *a6 = 1;
      goto LABEL_47;
    case 51:
      if ((a3 - 1) > 1)
      {
LABEL_52:
        v14 = 4294956430;
      }
      else
      {
        *a6 = 1;
        *a5 = 4;
LABEL_47:
        if (ausdk::AUBase::GetElement(this, a3, a4))
LABEL_48:
          v14 = 0;
        else
          v14 = 4294956419;
      }
      break;
    case 53:
      v14 = 0;
LABEL_54:
      v15 = 8;
LABEL_55:
      *a5 = v15;
      *a6 = 0;
      return v14;
    default:
      return (*(uint64_t (**)(ausdk::AUBase *))(*(_QWORD *)this + 80))(this);
  }
  return v14;
}

uint64_t ausdk::AUBase::DispatchGetProperty(ausdk::AUBase *this, int a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _QWORD *Scope;
  uint64_t v19;
  uint64_t v20;
  int v21;
  const void *v22;
  __int128 v23;
  __int128 v24;
  const void *v25;
  void *v26;
  double v27;
  unsigned int v28;
  BOOL v29;
  ausdk::AUScope *v30;
  _DWORD __n[5];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  switch(a2)
  {
    case 0:
      *(_QWORD *)&__n[1] = 0;
      v9 = (*(uint64_t (**)(ausdk::AUBase *, _DWORD *))(*(_QWORD *)this + 272))(this, &__n[1]);
      goto LABEL_37;
    case 1:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 15:
    case 17:
    case 18:
    case 21:
    case 23:
    case 26:
    case 28:
    case 29:
    case 31:
    case 33:
    case 34:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 52:
      return (*(uint64_t (**)(ausdk::AUBase *))(*(_QWORD *)this + 88))(this);
    case 2:
      (*(void (**)(_DWORD *__return_ptr, ausdk::AUBase *, uint64_t, uint64_t))(*(_QWORD *)this + 392))(&__n[1], this, a3, a4);
      v10 = 0;
      goto LABEL_38;
    case 3:
      __n[0] = 0;
      v10 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t, _QWORD, _DWORD *))(*(_QWORD *)this + 248))(this, a3, 0, __n);
      if (!(_DWORD)v10)
      {
        *(_OWORD *)&__n[1] = 0uLL;
        *(_QWORD *)&v33 = 0;
        std::vector<unsigned int>::vector((std::vector<unsigned int> *)&__n[1], __n[0]);
        v10 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t, _QWORD, _DWORD *))(*(_QWORD *)this + 248))(this, a3, *(_QWORD *)&__n[1], __n);
        v13 = *(void **)&__n[1];
        if (!(_DWORD)v10)
          memcpy(a5, *(const void **)&__n[1], *(_QWORD *)&__n[3] - *(_QWORD *)&__n[1]);
        if (v13)
        {
          *(_QWORD *)&__n[3] = v13;
          operator delete(v13);
        }
      }
      return v10;
    case 4:
      v38 = 0;
      v36 = 0u;
      v37 = 0u;
      v34 = 0u;
      v35 = 0u;
      *(_OWORD *)&__n[1] = 0u;
      v33 = 0u;
      v10 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t, uint64_t, _DWORD *))(*(_QWORD *)this + 256))(this, a3, a4, &__n[1]);
      v14 = v37;
      a5[4] = v36;
      a5[5] = v14;
      *((_QWORD *)a5 + 12) = v38;
      v15 = v33;
      *a5 = *(_OWORD *)&__n[1];
      a5[1] = v15;
      v16 = v35;
      a5[2] = v34;
      a5[3] = v16;
      return v10;
    case 8:
      (*(void (**)(_DWORD *__return_ptr, ausdk::AUBase *, uint64_t, uint64_t))(*(_QWORD *)this + 392))(&__n[1], this, a3, a4);
      v10 = 0;
      v17 = v33;
      *a5 = *(_OWORD *)&__n[1];
      a5[1] = v17;
      *((_QWORD *)a5 + 4) = v34;
      return v10;
    case 11:
      Scope = (_QWORD *)ausdk::AUBase::GetScope(this, a3);
      v19 = Scope[5];
      if (v19)
        LODWORD(v20) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
      else
        v20 = (Scope[3] - Scope[2]) >> 3;
      v10 = 0;
      *(_DWORD *)a5 = v20;
      return v10;
    case 12:
      v27 = (*(double (**)(ausdk::AUBase *))(*(_QWORD *)this + 344))(this);
      goto LABEL_48;
    case 13:
      *(_QWORD *)&__n[1] = 0;
      v28 = (*(uint64_t (**)(ausdk::AUBase *, _DWORD *))(*(_QWORD *)this + 376))(this, &__n[1]);
      if (v28)
        v29 = *(_QWORD *)&__n[1] == 0;
      else
        v29 = 1;
      if (!v29)
        memcpy(a5, *(const void **)&__n[1], 4 * v28);
      return 0;
    case 14:
      v10 = 0;
      v21 = *((_DWORD *)this + 84);
      goto LABEL_50;
    case 16:
      *(_QWORD *)&__n[1] = 0;
      v9 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t, uint64_t, _DWORD *))(*(_QWORD *)this + 296))(this, a3, a4, &__n[1]);
      goto LABEL_37;
    case 19:
      LOBYTE(__n[1]) = 0;
      if (!(*(unsigned int (**)(ausdk::AUBase *, uint64_t, uint64_t, _OWORD *, _DWORD *))(*(_QWORD *)this
                                                                                                  + 528))(this, a3, a4, a5, &__n[1]))return 4294956417;
      return 0;
    case 20:
      if (!(*(unsigned int (**)(ausdk::AUBase *))(*(_QWORD *)this + 360))(this))
        return 4294956417;
      v27 = (*(double (**)(ausdk::AUBase *))(*(_QWORD *)this + 352))(this);
LABEL_48:
      v10 = 0;
      *(double *)a5 = v27;
      return v10;
    case 22:
      v10 = 0;
      *(_DWORD *)a5 = *((_DWORD *)this + 85);
      *((_DWORD *)this + 85) = 0;
      return v10;
    case 24:
      *(_QWORD *)&__n[1] = 0;
      v9 = (*(uint64_t (**)(ausdk::AUBase *, _DWORD *))(*(_QWORD *)this + 312))(this, &__n[1]);
      goto LABEL_37;
    case 25:
      v22 = (const void *)*((_QWORD *)this + 65);
      *(_QWORD *)a5 = v22;
      if (!v22)
        return 4294956446;
      goto LABEL_52;
    case 27:
      v10 = 0;
      v23 = *((_OWORD *)this + 30);
      v24 = *((_OWORD *)this + 31);
      *((_QWORD *)a5 + 4) = *((_QWORD *)this + 64);
      *a5 = v23;
      a5[1] = v24;
      return v10;
    case 30:
      v25 = *(const void **)(ausdk::AUBase::GetElement(this, a3, a4) + 72);
      ausdk::Owned<__CFString const*>::retainRef(v25);
      ausdk::Owned<__CFString const*>::releaseRef(v25);
      if (!v25)
        return 4294956446;
      CFRetain(v25);
      v10 = 0;
      *(_QWORD *)a5 = v25;
      return v10;
    case 32:
      *(_OWORD *)&__n[1] = 0uLL;
      *(_QWORD *)&v33 = 0;
      (*(void (**)(_DWORD *__return_ptr, ausdk::AUBase *, uint64_t, uint64_t))(*(_QWORD *)this + 552))(&__n[1], this, a3, a4);
      v26 = *(void **)&__n[1];
      if (*(_QWORD *)&__n[1] == *(_QWORD *)&__n[3])
      {
        if (*(_QWORD *)&__n[1])
        {
          *(_QWORD *)&__n[3] = *(_QWORD *)&__n[1];
          operator delete(*(void **)&__n[1]);
        }
        return 4294956417;
      }
      else
      {
        memcpy(a5, *(const void **)&__n[1], *(_QWORD *)&__n[3] - *(_QWORD *)&__n[1]);
        if (v26)
        {
          *(_QWORD *)&__n[3] = v26;
          operator delete(v26);
        }
        return 0;
      }
    case 35:
      *(_OWORD *)&__n[1] = *a5;
      if (!__n[1])
        return 4294956445;
      v10 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t))(*(_QWORD *)this + 304))(this, a3);
      *a5 = *(_OWORD *)&__n[1];
      if ((_DWORD)v10 != -10879)
        return v10;
      return (*(uint64_t (**)(ausdk::AUBase *, uint64_t, uint64_t, uint64_t, _OWORD *))(*(_QWORD *)this + 88))(this, 35, a3, a4, a5);
    case 36:
      *a5 = *(_OWORD *)((char *)this + 360);
      v22 = (const void *)*((_QWORD *)this + 46);
      if (!v22)
        return 0;
      goto LABEL_52;
    case 51:
      v30 = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
      v10 = 0;
      v21 = *(unsigned __int8 *)(ausdk::AUScope::GetIOElement(v30, a4) + 168);
LABEL_50:
      *(_DWORD *)a5 = v21;
      return v10;
    case 53:
      *(_QWORD *)&__n[1] = 0;
      v9 = (*(uint64_t (**)(ausdk::AUBase *, uint64_t, uint64_t, _DWORD *, _DWORD *))(*(_QWORD *)this + 264))(this, a3, a4, &__n[1], &__n[2]);
LABEL_37:
      v10 = v9;
LABEL_38:
      v11 = *(_QWORD *)&__n[1];
      goto LABEL_39;
    case 54:
      v22 = (const void *)*((_QWORD *)this + 58);
      *(_QWORD *)a5 = v22;
      if (v22)
LABEL_52:
        CFRetain(v22);
      return 0;
    default:
      if (a2 == 61)
      {
        v10 = 0;
        v11 = *((_QWORD *)this + 34);
LABEL_39:
        *(_QWORD *)a5 = v11;
      }
      else
      {
        return (*(uint64_t (**)(ausdk::AUBase *))(*(_QWORD *)this + 88))(this);
      }
      return v10;
  }
}

void sub_1B65C0E90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *ausdk::AUBase::SetAFactoryPresetAsCurrent(char *this, const AUPreset *a2)
{
  CFTypeRef *v3;
  AUPreset *v4;

  if ((a2->presetNumber & 0x80000000) == 0)
  {
    if (a2->presetName)
    {
      v3 = (CFTypeRef *)this;
      v4 = (AUPreset *)(this + 360);
      CFRelease(*((CFTypeRef *)this + 46));
      *v4 = *a2;
      return (char *)CFRetain(v3[46]);
    }
  }
  return this;
}

void ausdk::BufferAllocator::~BufferAllocator(ausdk::BufferAllocator *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

_DWORD *ausdk::BufferAllocator::Allocate(ausdk::BufferAllocator *this, unsigned int a2, int a3)
{
  void *v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  _DWORD *result;
  std::logic_error *exception;
  std::bad_alloc *v11;
  std::bad_alloc *v12;
  uint8_t v13[16];

  if (a2 > 0x1000)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "AudioBuffers::Allocate: Too many buffers");
  }
  v4 = 0;
  v5 = 0;
  v6 = (a3 + 15) & 0xFFFFFFF0;
  if (a2 && v6)
  {
    if (((v6 * (unint64_t)a2) & 0xFFFFFFFF00000000) != 0)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v13 = 0;
        _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "AUBuffer throwing bad_alloc", v13, 2u);
      }
      v11 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v12 = std::bad_alloc::bad_alloc(v11);
    }
    v5 = v6 * a2;
    if (v6 * a2)
    {
      v4 = malloc_type_malloc(v6 * a2, 0x9473491AuLL);
      bzero(v4, v6 * a2);
    }
    else
    {
      v4 = 0;
    }
  }
  if (a2 <= 1)
    v7 = 1;
  else
    v7 = a2;
  v8 = 16 * v7 + 56;
  result = malloc_type_malloc(v8, 0xA1F80C9AuLL);
  *result = a2;
  result[1] = v6;
  *((_QWORD *)result + 1) = 0;
  result[4] = v8;
  result[5] = v5;
  *((_QWORD *)result + 3) = 0;
  *((_QWORD *)result + 4) = v4;
  *((_QWORD *)result + 5) = 0;
  *((_QWORD *)result + 7) = 0;
  *((_QWORD *)result + 8) = 0;
  result[12] = a2;
  return result;
}

void sub_1B65C1084(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void ausdk::BufferAllocator::Deallocate(int a1, _QWORD *a2)
{
  void *v3;

  v3 = (void *)a2[4];
  if (v3)
    free(v3);
  free(a2);
}

uint64_t ausdk::AUBufferList::PrepareBuffer(ausdk::AUBufferList *this, const AudioStreamBasicDescription *a2, unsigned int a3)
{
  AudioFormatFlags mFormatFlags;
  UInt32 mChannelsPerFrame;
  UInt32 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  UInt32 v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  ausdk::AUException *exception;
  ausdk::AUException *v16;
  std::logic_error *v17;
  int v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 5) < a3)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v18 = 67109120;
      v19 = -10874;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "AUBuffer throwing bad_alloc", (uint8_t *)&v18, 8u);
    }
    exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(exception, -10874);
  }
  mFormatFlags = a2->mFormatFlags;
  mChannelsPerFrame = a2->mChannelsPerFrame;
  if ((mFormatFlags & 0x20) != 0)
    v5 = a2->mChannelsPerFrame;
  else
    v5 = 1;
  if (v5 > *((_DWORD *)this + 4))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v18 = 67109120;
      v19 = -10868;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "AUBuffer throwing bad_alloc", (uint8_t *)&v18, 8u);
    }
    v16 = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(v16, -10868);
  }
  if ((mFormatFlags & 0x20) != 0)
    mChannelsPerFrame = 1;
  v6 = *((_QWORD *)this + 1);
  v7 = v6 + 48;
  v8 = *(unsigned int *)(v6 + 48);
  if (*(_DWORD *)(v6 + 48) > *(_DWORD *)v6)
  {
    v17 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](v17, "AllocatedBuffer::Prepare(): too many buffers");
    goto LABEL_23;
  }
  v9 = a2->mBytesPerFrame * a3;
  v10 = *(unsigned int *)(v6 + 4);
  if (v10 < v9)
    goto LABEL_22;
  v11 = *(_QWORD *)(v6 + 32);
  v12 = v11 + *(unsigned int *)(v6 + 20);
  if ((_DWORD)v8)
  {
    v13 = (unint64_t *)(v6 + 64);
    do
    {
      *v13 = v11;
      v11 += v10;
      *((_DWORD *)v13 - 2) = mChannelsPerFrame;
      *((_DWORD *)v13 - 1) = v9;
      v13 += 2;
      --v8;
    }
    while (v8);
  }
  if (v11 > v12)
  {
LABEL_22:
    v17 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](v17, "AllocatedBuffer::Prepare(): insufficient capacity");
LABEL_23:
  }
  *(_DWORD *)this = 1;
  return v7;
}

void sub_1B65C1314(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_DWORD *ausdk::AUBufferList::Allocate(ausdk::AUBufferList *this, const AudioStreamBasicDescription *a2, int a3)
{
  _QWORD *v6;
  UInt32 mBytesPerFrame;
  UInt32 mChannelsPerFrame;
  _DWORD *result;

  v6 = (_QWORD *)*((_QWORD *)this + 1);
  if (v6)
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v6);
  mBytesPerFrame = a2->mBytesPerFrame;
  if ((a2->mFormatFlags & 0x20) != 0)
    mChannelsPerFrame = a2->mChannelsPerFrame;
  else
    mChannelsPerFrame = 1;
  result = ((_DWORD *(*)(ausdk::BufferAllocator *, unsigned int, int))ausdk::BufferAllocator::instance(void)::global[2])((ausdk::BufferAllocator *)&ausdk::BufferAllocator::instance(void)::global, mChannelsPerFrame, mBytesPerFrame * a3);
  *((_QWORD *)this + 1) = result;
  *((_DWORD *)this + 4) = mChannelsPerFrame;
  *((_DWORD *)this + 5) = a3;
  *(_DWORD *)this = 0;
  return result;
}

void CAException::~CAException(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1BCC95CECLL);
}

const char *CAException::what(CAException *this)
{
  return "CAException";
}

void CAXException::~CAXException(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t CAXException::what(CAXException *this)
{
  return (uint64_t)this + 8;
}

uint64_t CACFDictionary::GetSInt32(uint64_t this, const __CFString *a2, int *a3)
{
  const __CFNumber *v4;
  CFTypeID v5;

  if (this)
  {
    this = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)this, a2);
    if (this)
    {
      v4 = (const __CFNumber *)this;
      v5 = CFGetTypeID((CFTypeRef)this);
      if (v5 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v4, kCFNumberSInt32Type, a3);
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return this;
}

uint64_t CACFDictionary::GetFloat32(uint64_t this, const __CFString *a2, float *a3)
{
  const __CFNumber *v4;
  CFTypeID v5;

  if (this)
  {
    this = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)this, a2);
    if (this)
    {
      v4 = (const __CFNumber *)this;
      v5 = CFGetTypeID((CFTypeRef)this);
      if (v5 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v4, kCFNumberFloat32Type, a3);
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return this;
}

uint64_t CACFDictionary::GetFloat64(uint64_t this, const __CFString *a2, double *a3)
{
  const __CFNumber *v4;
  CFTypeID v5;

  if (this)
  {
    this = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)this, a2);
    if (this)
    {
      v4 = (const __CFNumber *)this;
      v5 = CFGetTypeID((CFTypeRef)this);
      if (v5 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v4, kCFNumberFloat64Type, a3);
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return this;
}

const __CFDictionary *CACFDictionary::GetCACFArray(const __CFDictionary **this, const __CFString *a2, CACFArray *a3)
{
  const __CFDictionary *result;
  const __CFDictionary *v7;
  CFTypeID v8;

  CACFDictionary::operator=((uint64_t)a3, 0);
  result = *this;
  if (*this)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, a2);
    if (result)
    {
      v7 = result;
      v8 = CFGetTypeID(result);
      result = (const __CFDictionary *)CFArrayGetTypeID();
      if ((const __CFDictionary *)v8 == result)
        return (const __CFDictionary *)CACFDictionary::operator=((uint64_t)a3, v7);
    }
  }
  return result;
}

const __CFDictionary *CACFDictionary::GetCACFDictionary(const __CFDictionary **this, const __CFString *a2, CACFDictionary *a3)
{
  const __CFDictionary *result;
  const __CFDictionary *v7;
  CFTypeID v8;

  CACFDictionary::operator=((uint64_t)a3, 0);
  result = *this;
  if (*this)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, a2);
    if (result)
    {
      v7 = result;
      v8 = CFGetTypeID(result);
      result = (const __CFDictionary *)CFDictionaryGetTypeID();
      if ((const __CFDictionary *)v8 == result)
        return (const __CFDictionary *)CACFDictionary::operator=((uint64_t)a3, v7);
    }
  }
  return result;
}

void CACFBoolean::~CACFBoolean(CACFBoolean *this)
{
  const void *v2;

  if (*((_BYTE *)this + 8))
  {
    v2 = *(const void **)this;
    if (*(_QWORD *)this)
      CFRelease(v2);
  }
}

void CACFNumber::~CACFNumber(CACFNumber *this)
{
  const void *v2;

  if (*((_BYTE *)this + 8))
  {
    v2 = *(const void **)this;
    if (*(_QWORD *)this)
      CFRelease(v2);
  }
}

CADeprecated::AUOutputBL *CADeprecated::AUOutputBL::AUOutputBL(CADeprecated::AUOutputBL *this, const CAStreamBasicDescription *a2)
{
  uint64_t v3;
  __int128 v4;
  int v5;

  v3 = *((_QWORD *)a2 + 4);
  v4 = *((_OWORD *)a2 + 1);
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_OWORD *)this + 1) = v4;
  *((_QWORD *)this + 4) = v3;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 512;
  if ((*((_BYTE *)this + 12) & 0x20) != 0)
    v5 = *((_DWORD *)this + 7);
  else
    v5 = 1;
  *((_DWORD *)this + 14) = v5;
  *((_QWORD *)this + 6) = operator new[]();
  return this;
}

uint64_t CADeprecated::AUOutputBL::Prepare(uint64_t this, int a2)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  _DWORD *v7;
  int *v8;
  int v9;
  _DWORD *v10;
  int *v11;
  int v12;
  _DWORD *exception;
  int v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(this + 12) & 0x20) != 0)
    v2 = 1;
  else
    v2 = *(_DWORD *)(this + 28);
  v3 = *(_QWORD *)(this + 40);
  if (v3)
  {
    v4 = *(_DWORD *)(this + 24) * a2;
    v5 = *(_DWORD *)(this + 56);
    v6 = *(unsigned int *)(this + 60);
    if (v4 * v5 > (v6 * v5))
    {
      if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
      {
        v14 = 136315650;
        v15 = "AUOutputBL.cpp";
        v16 = 1024;
        v17 = 63;
        v18 = 1024;
        v19 = -10874;
        _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (%d) [(nBytes * mNumberBuffers) > AllocatedBytes() is false]: \"\"", (uint8_t *)&v14, 0x18u);
      }
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &off_1E69EE218;
      exception[2] = -10874;
    }
    v7 = *(_DWORD **)(this + 48);
    *v7 = v5;
    if (v5)
    {
      v8 = v7 + 2;
      do
      {
        *((_QWORD *)v8 + 1) = v3;
        v3 += v6;
        *v8 = v2;
        v8[1] = v4;
        v8 += 4;
        --v5;
      }
      while (v5);
    }
  }
  else
  {
    v9 = *(_DWORD *)(this + 56);
    v10 = *(_DWORD **)(this + 48);
    *v10 = v9;
    if (v9)
    {
      v11 = v10 + 2;
      v12 = *(_DWORD *)(this + 24) * a2;
      do
      {
        *v11 = v2;
        v11[1] = v12;
        *((_QWORD *)v11 + 1) = 0;
        v11 += 4;
        --v9;
      }
      while (v9);
    }
  }
  return this;
}

uint64_t CADeprecated::AUOutputBL::Allocate(uint64_t this, int a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  size_t v6;
  void *v7;

  v2 = this;
  if (a2)
  {
    v3 = a2;
    v4 = *(_DWORD *)(this + 24) * a2;
    v5 = *(_DWORD *)(this + 56);
    if (v4 <= v5 * *(_DWORD *)(this + 60))
      return this;
    if (v5 > 1)
      v4 = ((v4 & 0xFFFFFFF0) + 16) | 0x10;
    *(_DWORD *)(this + 60) = v4;
    v6 = v4 * v5;
    v7 = (void *)operator new[]();
    bzero(v7, v6);
    this = *(_QWORD *)(v2 + 40);
    *(_QWORD *)(v2 + 40) = v7;
    if (this)
      this = MEMORY[0x1BCC95CC8](this, 0x1000C8077774924);
  }
  else
  {
    this = *(_QWORD *)(this + 40);
    if (this)
    {
      this = MEMORY[0x1BCC95CC8](this, 0x1000C8077774924);
      *(_QWORD *)(v2 + 40) = 0;
    }
    v3 = 0;
    *(_DWORD *)(v2 + 60) = 0;
  }
  *(_DWORD *)(v2 + 64) = v3;
  return this;
}

uint64_t PListLogger::log(PListLogger *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return vdprintf(*(_DWORD *)this, a2, va);
}

uint64_t logSubsystem(void)
{
  unint64_t v0;
  char v2;
  char **v3;
  char *v4;

  v0 = atomic_load(&logSubsystem(void)::onceflag);
  if (v0 != -1)
  {
    v4 = &v2;
    v3 = &v4;
    std::__call_once(&logSubsystem(void)::onceflag, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<logSubsystem(void)::$_0 &&>>);
  }
  return logSubsystem(void)::scope;
}

os_log_t std::__call_once_proxy[abi:ne180100]<std::tuple<logSubsystem(void)::$_0 &&>>()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio.utility", "TPLM");
  *v0 = result;
  logSubsystem(void)::scope = (uint64_t)v0;
  return result;
}

uint64_t TuningPListMgr::loadTuningInSubdirs_(uint64_t a1, const __CFString ***a2, unsigned int a3, unsigned int a4)
{
  const __CFString *v8;
  const __CFString *v9;
  __CFString *MutableCopy;
  uint64_t v11;
  CFStringRef **v12;
  const __CFAllocator *v13;
  CFIndex v14;
  const __CFString *v15;
  CFMutableStringRef Mutable;
  const __CFURL *v17;
  __CFReadStream *v18;
  const __CFDictionary *v19;
  const void **v20;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  __CFDictionary *v24;
  __CFDictionary *v25;
  __CFString *v26;
  CFIndex Count;
  const __CFString *Value;
  uint64_t v29;
  CFTypeID TypeID;
  CFIndex v31;
  const void **v32;
  const void **v33;
  uint64_t i;
  const __CFDictionary *v35;
  CFTypeID v36;
  const __CFString *v37;
  CFTypeID v38;
  uint64_t v39;
  const __CFString **v40;
  __CFDictionary *v41;
  void *v42;
  char *v43;
  CFDictionaryRef *v45;
  CFMutableStringRef key;
  const __CFString *suffix;
  CFMutableStringRef theString[2];
  __CFDictionary *v49;

  v8 = **a2;
  if (v8 && CFStringHasPrefix(v8, CFSTR("/")))
    v9 = &stru_1E69EEE40;
  else
    v9 = *(const __CFString **)a1;
  theString[1] = (CFMutableStringRef)1;
  MutableCopy = CFStringCreateMutableCopy(0, 0, v9);
  theString[0] = MutableCopy;
  v11 = a3 - 1;
  v12 = a2;
  if (!MutableCopy)
    goto LABEL_8;
LABEL_6:
  CFStringAppend(MutableCopy, CFSTR("/"));
  if (theString[0])
    CFStringAppend(theString[0], **v12);
LABEL_8:
  while (v11)
  {
    MutableCopy = theString[0];
    --v11;
    ++v12;
    if (theString[0])
      goto LABEL_6;
  }
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v14 = strlen(TuningPListMgr::kTuningFileTypeSuffixMap[a4]);
  suffix = CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)TuningPListMgr::kTuningFileTypeSuffixMap[a4], v14, 0x600u, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (theString[0])
  {
    v15 = theString[0];
    if (!CFStringHasSuffix(theString[0], suffix))
    {
      CFStringAppend(theString[0], suffix);
      v15 = theString[0];
    }
  }
  else
  {
    v15 = 0;
  }
  Mutable = CFStringCreateMutable(v13, 512);
  v17 = CFURLCreateWithFileSystemPath(v13, v15, kCFURLPOSIXPathStyle, 0);
  if (v17
    && (v18 = CFReadStreamCreateWithFile(v13, v17), CFRelease(v17), v18)
    && (CFReadStreamOpen(v18),
        v19 = (const __CFDictionary *)CFPropertyListCreateWithStream(v13, v18, 0, 0, 0, 0),
        CFReadStreamClose(v18),
        CFRelease(v18),
        v19))
  {
    CFRelease(Mutable);
    v20 = (const void **)a2[a3 - 1];
    v21 = *v20;
    if (a4)
    {
      key = (CFMutableStringRef)*v20;
    }
    else
    {
      v23 = 0;
      v24 = 0;
      v25 = 0;
      key = theString[0];
      v49 = 0;
      do
      {
        v26 = kLegacyStripNameKeys[v23];
        if (!CFDictionaryContainsKey(v19, v26))
        {
          if (!v25)
          {
            Count = CFDictionaryGetCount(v19);
            v24 = CFDictionaryCreateMutableCopy(v13, Count + 2, v19);
            v49 = v24;
          }
          CFDictionaryAddValue(v24, v26, v21);
          v25 = v24;
        }
        ++v23;
      }
      while (v23 != 2);
      if (v24)
        CFRelease(v19);
      else
        v24 = v19;
      v19 = v24;
    }
    Value = (const __CFString *)CFDictionaryGetValue(v19, CFSTR("name"));
    v29 = a4;
    if (Value)
    {
      TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(Value))
      {
        v45 = (CFDictionaryRef *)(a1 + 8 * v29 + 16);
        v31 = CFDictionaryGetCount(*v45);
        if (v31 >= 1)
        {
          v32 = (const void **)operator new[]();
          v33 = (const void **)operator new[]();
          CFDictionaryGetKeysAndValues(*v45, v32, v33);
          for (i = 0; v31 != i; ++i)
          {
            if (!v32[i])
              break;
            v35 = (const __CFDictionary *)v33[i];
            if (!v35)
              break;
            v36 = CFDictionaryGetTypeID();
            if (v36 == CFGetTypeID(v35))
            {
              v37 = (const __CFString *)CFDictionaryGetValue(v35, CFSTR("name"));
              if (v37)
              {
                v38 = CFStringGetTypeID();
                if (v38 == CFGetTypeID(v37) && CFStringCompare(v37, Value, 0) == kCFCompareEqualTo)
                {
                  CFDictionaryRemoveValue(*v45, v32[i]);
                  break;
                }
              }
            }
          }
          MEMORY[0x1BCC95CC8](v32, 0xC0C80B8AA526DLL);
          MEMORY[0x1BCC95CC8](v33, 0xC0C80B8AA526DLL);
        }
      }
    }
    v39 = a1 + 8 * v29;
    v41 = *(__CFDictionary **)(v39 + 16);
    v40 = (const __CFString **)(v39 + 16);
    CFDictionarySetValue(v41, key, v19);
    v43 = *(char **)(a1 + 48);
    if (v43)
      PListLogger::logItemEntry(*v40, "@@ Strips Aug  9 2024 18:27:12", v43, v42);
    v22 = 0;
  }
  else
  {
    if (Mutable)
    {
      CFStringAppend(Mutable, CFSTR("Error loading plist file "));
      CFStringAppend(Mutable, v15);
      CFStringAppend(Mutable, CFSTR("\n"));
    }
    CFRelease(Mutable);
    v19 = 0;
    v22 = 0xFFFFFFFFLL;
  }
  if (suffix)
    CFRelease(suffix);
  if (v19)
    CFRelease(v19);
  CACFMutableString::~CACFMutableString((CACFMutableString *)theString);
  return v22;
}

void sub_1B65C1EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  applesauce::CF::ObjectRef<__CFDictionary *>::~ObjectRef((const void **)va1);
  CACFMutableString::~CACFMutableString((CACFMutableString *)va);
  _Unwind_Resume(a1);
}

void CACFMutableString::~CACFMutableString(CACFMutableString *this)
{
  const void *v2;

  if (*((_BYTE *)this + 8))
  {
    v2 = *(const void **)this;
    if (*(_QWORD *)this)
      CFRelease(v2);
  }
}

void PListLogger::logItemEntry(const __CFString *this, const char *a2, char *a3, void *a4)
{
  CFTypeID v7;
  int v8;
  size_t v9;
  CFNumberType Type;
  int v11;
  size_t v12;
  int v13;
  size_t v14;
  int v15;
  int Count;
  CFIndex v17;
  int v18;
  size_t v19;
  int v20;
  int v21;
  CFIndex i;
  PListLogger *ValueAtIndex;
  void *v24;
  int v25;
  size_t v26;
  int v27;
  size_t v28;
  CFIndex v29;
  __int128 valuePtr;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v7 = CFGetTypeID(this);
  if (CFStringGetTypeID() == v7)
  {
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    valuePtr = 0u;
    v31 = 0u;
    v8 = *((_DWORD *)a3 + 1);
    if (v8 >= 127)
      v9 = 127;
    else
      v9 = v8;
    if ((_DWORD)v9)
      memset((char *)&valuePtr + (int)v9 - (v9 - 1) - 1, 32, v9);
    PListLogger::log((PListLogger *)a3, "%s", (const char *)&valuePtr);
    CFGetRetainCount(this);
    CFStringGetCStringPtr(this, 0);
    PListLogger::log((PListLogger *)a3, "'%s' | String{%d} | \"%s\"\n");
  }
  else if (CFNumberGetTypeID() == v7)
  {
    Type = CFNumberGetType((CFNumberRef)this);
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    valuePtr = 0u;
    v31 = 0u;
    v11 = *((_DWORD *)a3 + 1);
    if (v11 >= 127)
      v12 = 127;
    else
      v12 = v11;
    if ((_DWORD)v12)
      memset((char *)&valuePtr + (int)v12 - (v12 - 1) - 1, 32, v12);
    PListLogger::log((PListLogger *)a3, "%s", (const char *)&valuePtr);
    if ((unint64_t)Type <= kCFNumberDoubleType)
    {
      if (((1 << Type) & 0x3060) != 0)
      {
        *(_QWORD *)&valuePtr = 0;
        CFNumberGetValue((CFNumberRef)this, Type, &valuePtr);
        CFGetRetainCount(this);
        PListLogger::log((PListLogger *)a3, "'%s' | Number(float){%d} | %f\n");
        return;
      }
      if (((1 << Type) & 0x82) != 0)
      {
        LOBYTE(valuePtr) = 0;
        CFNumberGetValue((CFNumberRef)this, Type, &valuePtr);
        CFGetRetainCount(this);
        PListLogger::log((PListLogger *)a3, "'%s' | Number(SInt8){%d} | 0x%02x\n");
        return;
      }
      if (((1 << Type) & 0x104) != 0)
      {
        LOWORD(valuePtr) = 0;
        CFNumberGetValue((CFNumberRef)this, Type, &valuePtr);
        CFGetRetainCount(this);
        PListLogger::log((PListLogger *)a3, "'%s' | Number(SInt16){%d} | 0x%04x\n");
        return;
      }
    }
    LODWORD(valuePtr) = 0;
    CFNumberGetValue((CFNumberRef)this, Type, &valuePtr);
    v29 = CFGetRetainCount(this);
    PListLogger::log((PListLogger *)a3, "'%s' | Number(SInt32){%d} | %-6d 0x%08x %c%c%c%c\n", a2, v29);
  }
  else if (CFDictionaryGetTypeID() == v7)
  {
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    valuePtr = 0u;
    v31 = 0u;
    v13 = *((_DWORD *)a3 + 1);
    if (v13 >= 127)
      v14 = 127;
    else
      v14 = v13;
    if ((_DWORD)v14)
      memset((char *)&valuePtr + (int)v14 - (v14 - 1) - 1, 32, v14);
    PListLogger::log((PListLogger *)a3, "%s", (const char *)&valuePtr);
    v15 = CFGetRetainCount(this);
    Count = CFDictionaryGetCount((CFDictionaryRef)this);
    PListLogger::log((PListLogger *)a3, "'%s' | Dictionary{%d} | %d key/value pairs\n", a2, v15, Count);
    if (!strcmp("aupreset", a2))
      a3[8] = 1;
    *((_DWORD *)a3 + 1) += 4;
    CFDictionaryApplyFunction((CFDictionaryRef)this, (CFDictionaryApplierFunction)PListLogger::logDictEntry, a3);
    *((_DWORD *)a3 + 1) -= 4;
    a3[8] = 0;
  }
  else if (CFArrayGetTypeID() == v7)
  {
    v17 = CFArrayGetCount((CFArrayRef)this);
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    valuePtr = 0u;
    v31 = 0u;
    v18 = *((_DWORD *)a3 + 1);
    if (v18 >= 127)
      v19 = 127;
    else
      v19 = v18;
    if ((_DWORD)v19)
      memset((char *)&valuePtr + (int)v19 - (v19 - 1) - 1, 32, v19);
    PListLogger::log((PListLogger *)a3, "%s", (const char *)&valuePtr);
    v20 = CFGetRetainCount(this);
    PListLogger::log((PListLogger *)a3, "'%s' | Array{%d} | %d ordered objects\n", a2, v20, v17);
    v21 = *((_DWORD *)a3 + 1);
    *((_DWORD *)a3 + 1) = v21 + 4;
    if (v17 >= 1)
    {
      for (i = 0; i != v17; ++i)
      {
        ValueAtIndex = (PListLogger *)CFArrayGetValueAtIndex((CFArrayRef)this, i);
        valuePtr = 0uLL;
        snprintf((char *)&valuePtr, 0x10uLL, "[%u]", i);
        PListLogger::logItemEntry(ValueAtIndex, &valuePtr, a3, v24);
      }
      v21 = *((_DWORD *)a3 + 1) - 4;
    }
    *((_DWORD *)a3 + 1) = v21;
  }
  else if (CFDataGetTypeID() == v7)
  {
    v36 = 0uLL;
    v37 = 0uLL;
    v34 = 0uLL;
    v35 = 0uLL;
    v32 = 0uLL;
    v33 = 0uLL;
    valuePtr = 0uLL;
    v31 = 0uLL;
    v25 = *((_DWORD *)a3 + 1);
    if (v25 >= 127)
      v26 = 127;
    else
      v26 = v25;
    if ((_DWORD)v26)
      memset((char *)&valuePtr + (int)v26 - (v26 - 1) - 1, 32, v26);
    PListLogger::log((PListLogger *)a3, "%s", (const char *)&valuePtr);
    CFGetRetainCount(this);
    CFDataGetLength((CFDataRef)this);
    PListLogger::log((PListLogger *)a3, "'%s' | %sData{%d} | %d bytes\n");
  }
  else
  {
    v36 = 0uLL;
    v37 = 0uLL;
    v34 = 0uLL;
    v35 = 0uLL;
    v32 = 0uLL;
    v33 = 0uLL;
    valuePtr = 0uLL;
    v31 = 0uLL;
    v27 = *((_DWORD *)a3 + 1);
    if (v27 >= 127)
      v28 = 127;
    else
      v28 = v27;
    if ((_DWORD)v28)
      memset((char *)&valuePtr + (int)v28 - (v28 - 1) - 1, 32, v28);
    PListLogger::log((PListLogger *)a3, "%s", (const char *)&valuePtr);
    PListLogger::log((PListLogger *)a3, "'%s' | <unknown type id: %d)>\n");
  }
}

uint64_t PListLogger::logDictEntry(const __CFString *this, PListLogger *a2, const char *a3, void *a4)
{
  const char *CStringPtr;
  void *v7;

  CStringPtr = CFStringGetCStringPtr(this, 0);
  return PListLogger::logItemEntry(a2, CStringPtr, a3, v7);
}

const void *TuningPListMgr::getAUPresetFromUnit(TuningPListMgr *this, const __CFDictionary *a2)
{
  const void *result;
  const void *v3;
  CFTypeID TypeID;

  result = CFDictionaryGetValue(this, CFSTR("aupreset"));
  if (result)
  {
    v3 = result;
    TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(v3))
      return v3;
    else
      return 0;
  }
  return result;
}

const __CFDictionary *TuningPListMgr::lookupPlist_(uint64_t a1, const char *a2, unsigned int a3)
{
  uint64_t v3;
  CFDictionaryRef *v4;
  uint64_t v5;
  CFStringRef v7;
  const __CFString *v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  CFTypeID v12;
  CFIndex Count;
  CFIndex v14;
  const void **v15;
  const void **v16;
  uint64_t i;
  CFTypeID TypeID;
  const __CFString *Value;
  const __CFString *v20;
  CFTypeID v21;
  const __CFDictionary **v22;
  NSObject **v23;
  NSObject *v24;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1 + 8 * a3;
  v5 = *(_QWORD *)(v3 + 16);
  v4 = (CFDictionaryRef *)(v3 + 16);
  if (!v5)
    return 0;
  v7 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (!v7)
    return 0;
  v8 = v7;
  v9 = *v4;
  if (a3 - 1 > 2)
  {
    Count = CFDictionaryGetCount(v9);
    if (Count <= 0)
    {
      CFRelease(v8);
      return 0;
    }
    v14 = Count;
    v15 = (const void **)operator new[]();
    v16 = (const void **)operator new[]();
    CFDictionaryGetKeysAndValues(*v4, v15, v16);
    for (i = 0; i != v14; ++i)
    {
      if (!v15[i])
        break;
      v11 = (const __CFDictionary *)v16[i];
      if (!v11)
        break;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v11))
      {
        Value = (const __CFString *)CFDictionaryGetValue(v11, CFSTR("name"));
        if (Value)
        {
          v20 = Value;
          v21 = CFStringGetTypeID();
          if (v21 == CFGetTypeID(v20) && CFStringCompare(v20, v8, 0) == kCFCompareEqualTo)
            goto LABEL_25;
        }
      }
    }
    v22 = (const __CFDictionary **)logSubsystem();
    if (v22)
    {
      v11 = *v22;
      if (!*v22)
        goto LABEL_25;
    }
    else
    {
      v11 = (const __CFDictionary *)MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_DEFAULT))
    {
      v26 = 136315394;
      v27 = "TuningPListMgr.cpp";
      v28 = 1024;
      v29 = 424;
      _os_log_impl(&dword_1B5ED0000, (os_log_t)v11, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Did not match strip name field to file name!", (uint8_t *)&v26, 0x12u);
    }
    v11 = 0;
LABEL_25:
    MEMORY[0x1BCC95CC8](v15, 0xC0C80B8AA526DLL);
    MEMORY[0x1BCC95CC8](v16, 0xC0C80B8AA526DLL);
    CFRelease(v8);
    if (v11)
      return v11;
LABEL_26:
    v23 = (NSObject **)logSubsystem();
    if (v23)
    {
      v24 = *v23;
      if (!*v23)
        return 0;
    }
    else
    {
      v24 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v26 = 136315394;
      v27 = "TuningPListMgr.cpp";
      v28 = 1024;
      v29 = 435;
      _os_log_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_DEFAULT, "%25s:%-5d return dictionary is null", (uint8_t *)&v26, 0x12u);
    }
    return 0;
  }
  v10 = (const __CFDictionary *)CFDictionaryGetValue(v9, v8);
  if (!v10 || (v11 = v10, v12 = CFDictionaryGetTypeID(), v12 != CFGetTypeID(v11)))
  {
    CFRelease(v8);
    goto LABEL_26;
  }
  CFRelease(v8);
  return v11;
}

const void *TuningPListMgr::getEffect(TuningPListMgr *this, const __CFDictionary *a2)
{
  const void *result;
  const void *v3;
  CFTypeID TypeID;
  const __CFDictionary *v5;
  CFTypeID v6;
  const void *v7;
  CFTypeID v8;

  result = CFDictionaryGetValue(this, CFSTR("strips"));
  if (result)
  {
    v3 = result;
    TypeID = CFArrayGetTypeID();
    if (TypeID != CFGetTypeID(v3) || CFArrayGetCount((CFArrayRef)v3) < 1)
      return 0;
    result = CFArrayGetValueAtIndex((CFArrayRef)v3, 0);
    if (!result)
      return result;
    v5 = (const __CFDictionary *)result;
    v6 = CFDictionaryGetTypeID();
    if (v6 == CFGetTypeID(v5))
    {
      result = CFDictionaryGetValue(v5, CFSTR("effects"));
      if (result)
      {
        v7 = result;
        v8 = CFArrayGetTypeID();
        if (v8 == CFGetTypeID(v7))
          return v7;
        else
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFDictionary *TuningPListMgr::getUnitByName(TuningPListMgr *this, const __CFArray *a2, const char *a3)
{
  CFIndex Count;
  CFIndex v6;
  CFStringRef v7;
  const __CFString *v8;
  CFIndex v9;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v11;
  CFTypeID TypeID;
  const __CFString *Value;
  const __CFString *v14;
  CFTypeID v15;

  Count = CFArrayGetCount(this);
  if (Count < 1)
    return 0;
  v6 = Count;
  v7 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)a2, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (!v7)
    return 0;
  v8 = v7;
  v9 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(this, v9);
    if (ValueAtIndex)
    {
      v11 = ValueAtIndex;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v11))
      {
        Value = (const __CFString *)CFDictionaryGetValue(v11, CFSTR("displayname"));
        if (Value)
        {
          v14 = Value;
          v15 = CFStringGetTypeID();
          if (v15 == CFGetTypeID(v14) && CFStringCompare(v8, v14, 0) == kCFCompareEqualTo)
            break;
        }
      }
    }
    if (v6 == ++v9)
    {
      v11 = 0;
      break;
    }
  }
  CFRelease(v8);
  return v11;
}

uint64_t CATimeUtilities::GetCurrentGregorianDate(CATimeUtilities *this)
{
  CFAbsoluteTime Current;
  unsigned __int8 v2;

  Current = CFAbsoluteTimeGetCurrent();
  if ((v2 & 1) == 0
  {
    CATimeUtilities::GregorianDateFromAbsoluteTime(double)::tz = (uint64_t)CFTimeZoneCopySystem();
  }
  return *(_OWORD *)&CFAbsoluteTimeGetGregorianDate(Current, (CFTimeZoneRef)CATimeUtilities::GregorianDateFromAbsoluteTime(double)::tz);
}

void sub_1B65C2B20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFMutableStringRef PlatformUtilities::CopyHardwareModelShortName(PlatformUtilities *this)
{
  const __CFAllocator *v1;
  CFMutableStringRef Mutable;
  __CFString *v3;
  CFMutableStringRef MutableCopy;
  const __CFString *v5;
  uint64_t v6;
  const __CFString *v7;
  CFIndex Length;
  size_t v10;
  char v11;
  char cStr[16];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  CFRange v17;

  v16 = *MEMORY[0x1E0C80C00];
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  v14 = 0u;
  v15 = 0u;
  *(_OWORD *)cStr = 0u;
  v13 = 0u;
  v10 = 64;
  sysctlbyname("hw.model", cStr, &v10, 0, 0);
  CFStringAppendCString(v3, cStr, 0);
  MutableCopy = CFStringCreateMutableCopy(v1, 0, v3);
  CFRelease(v3);
  if (MutableCopy)
  {
    v5 = CFSTR("AP");
    if (CFStringHasSuffix(MutableCopy, CFSTR("AP"))
      || (v5 = CFSTR("DEV"), CFStringHasSuffix(MutableCopy, CFSTR("DEV")))
      || (v5 = CFSTR("ap"), CFStringHasSuffix(MutableCopy, CFSTR("ap")))
      || (v5 = CFSTR("dev"), CFStringHasSuffix(MutableCopy, CFSTR("dev"))))
    {
      CFStringTrim(MutableCopy, v5);
    }
    *(_QWORD *)cStr = 0;
    *(_QWORD *)&cStr[8] = 1;
    v6 = MGGetProductType();
    if (v6 == 952317141)
    {
      v10 = (size_t)CFStringCreateWithCString(0, "u", 0x600u);
      v11 = 1;
      CACFString::operator=((uint64_t)cStr, (uint64_t)&v10);
    }
    else
    {
      if (v6 != 2081274472 && v6 != 2468178735)
        goto LABEL_16;
      v10 = (size_t)CFStringCreateWithCString(0, "m", 0x600u);
      v11 = 1;
      CACFString::operator=((uint64_t)cStr, (uint64_t)&v10);
    }
    CACFString::~CACFString((CACFString *)&v10);
LABEL_16:
    v7 = *(const __CFString **)cStr;
    if (*(_QWORD *)cStr && CFStringHasSuffix(MutableCopy, *(CFStringRef *)cStr))
    {
      Length = CFStringGetLength(MutableCopy);
      v17.length = CFStringGetLength(v7);
      v17.location = Length - v17.length;
      CFStringFindAndReplace(MutableCopy, v7, &stru_1E69EEE40, v17, 1uLL);
    }
    CACFString::~CACFString((CACFString *)cStr);
  }
  return MutableCopy;
}

void sub_1B65C2DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  CACFString::~CACFString((CACFString *)&a9);
  CACFString::~CACFString((CACFString *)&a11);
  _Unwind_Resume(a1);
}

uint64_t PlatformUtilities_iOS::GetProductType(PlatformUtilities_iOS *this)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (PlatformUtilities_iOS::GetProductType(void)::sCompletedCheck == 1)
    return PlatformUtilities_iOS::GetProductType(void)::sType;
  PlatformUtilities_iOS::GetProductType(void)::sCompletedCheck = 1;
  v2 = MGGetProductType();
  if (v2 > 2158787295)
  {
    if (v2 > 3196805750)
    {
      if (v2 > 3711192743)
      {
        if (v2 > 3885279869)
        {
          if (v2 > 4068102501)
          {
            if (v2 <= 4231109336)
            {
              switch(v2)
              {
                case 4068102502:
                  result = 168;
                  goto LABEL_472;
                case 4172444931:
                  result = 132;
                  goto LABEL_472;
                case 4201643249:
                  result = 35;
                  goto LABEL_472;
              }
              goto LABEL_471;
            }
            if (v2 > 4240173201)
            {
              if (v2 == 4240173202)
              {
                result = 2;
                goto LABEL_472;
              }
              if (v2 == 4242862982)
              {
                result = 80;
                goto LABEL_472;
              }
              goto LABEL_471;
            }
            if (v2 != 4231109337)
            {
              if (v2 == 4232256925)
              {
                result = 114;
                goto LABEL_472;
              }
              goto LABEL_471;
            }
            goto LABEL_377;
          }
          if (v2 <= 3953847431)
          {
            if (v2 == 3885279870)
            {
              result = 32;
              goto LABEL_472;
            }
            if (v2 != 3933865620)
            {
              if (v2 == 3933982784)
              {
                result = 53;
                goto LABEL_472;
              }
              goto LABEL_471;
            }
            goto LABEL_372;
          }
          if (v2 > 4055323050)
          {
            if (v2 == 4055323051)
            {
              result = 58;
              goto LABEL_472;
            }
            if (v2 == 4067129264)
            {
              result = 139;
              goto LABEL_472;
            }
          }
          else
          {
            if (v2 == 3953847432)
            {
              result = 170;
              goto LABEL_472;
            }
            if (v2 == 4025247511)
            {
              result = 133;
              goto LABEL_472;
            }
          }
LABEL_471:
          result = 0;
          goto LABEL_472;
        }
        if (v2 <= 3825599859)
        {
          if (v2 <= 3767261005)
          {
            switch(v2)
            {
              case 3711192744:
                result = 84;
                goto LABEL_472;
              case 3742999858:
                result = 159;
                goto LABEL_472;
              case 3743999268:
                result = 24;
                goto LABEL_472;
            }
            goto LABEL_471;
          }
          if (v2 == 3767261006)
          {
            result = 153;
            goto LABEL_472;
          }
          if (v2 != 3801472101)
          {
            if (v2 == 3819635030)
            {
              result = 160;
              goto LABEL_472;
            }
            goto LABEL_471;
          }
          goto LABEL_344;
        }
        if (v2 <= 3863625341)
        {
          switch(v2)
          {
            case 3825599860:
              result = 20;
              goto LABEL_472;
            case 3839750255:
              result = 169;
              goto LABEL_472;
            case 3856877970:
              result = 110;
              goto LABEL_472;
          }
          goto LABEL_471;
        }
        if (v2 > 3865922941)
        {
          if (v2 == 3865922942)
          {
            result = 56;
            goto LABEL_472;
          }
          if (v2 == 3867318491)
          {
            result = 162;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
        if (v2 != 3863625342)
        {
          if (v2 == 3865897231)
          {
            result = 79;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
LABEL_385:
        result = 97;
        goto LABEL_472;
      }
      if (v2 <= 3540156651)
      {
        if (v2 > 3300281075)
        {
          if (v2 <= 3397214290)
          {
            if (v2 == 3300281076)
            {
              result = 54;
              goto LABEL_472;
            }
            if (v2 == 3348380076)
            {
              result = 4;
              goto LABEL_472;
            }
            if (v2 != 3361025853)
              goto LABEL_471;
            goto LABEL_381;
          }
          if (v2 <= 3417429876)
          {
            if (v2 == 3397214291)
            {
              result = 74;
              goto LABEL_472;
            }
            if (v2 == 3402870384)
            {
              result = 70;
              goto LABEL_472;
            }
            goto LABEL_471;
          }
          if (v2 != 3417429877)
          {
            if (v2 == 3455223061)
            {
              result = 83;
              goto LABEL_472;
            }
            goto LABEL_471;
          }
          goto LABEL_371;
        }
        if (v2 <= 3228373940)
        {
          if (v2 == 3196805751)
          {
            result = 7;
            goto LABEL_472;
          }
          if (v2 == 3215673114)
          {
            result = 75;
            goto LABEL_472;
          }
          v9 = 3217792190;
LABEL_151:
          if (v2 != v9)
            goto LABEL_471;
          goto LABEL_372;
        }
        if (v2 == 3228373941)
        {
LABEL_383:
          result = 104;
          goto LABEL_472;
        }
        if (v2 != 3241053352)
        {
          if (v2 == 3242623367)
          {
            result = 15;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
LABEL_384:
        result = 107;
        goto LABEL_472;
      }
      if (v2 > 3637438249)
      {
        if (v2 <= 3670339450)
        {
          if (v2 == 3637438250)
          {
            result = 52;
            goto LABEL_472;
          }
          if (v2 != 3645319985)
          {
            if (v2 == 3663011141)
            {
              result = 156;
              goto LABEL_472;
            }
            goto LABEL_471;
          }
          goto LABEL_380;
        }
        if (v2 > 3683904381)
        {
          if (v2 == 3683904382)
          {
            result = 137;
            goto LABEL_472;
          }
          v6 = 3707345671;
          goto LABEL_359;
        }
        if (v2 == 3670339451)
          goto LABEL_372;
        v7 = 3677894691;
LABEL_96:
        if (v2 == v7)
        {
          result = 102;
          goto LABEL_472;
        }
        goto LABEL_471;
      }
      if (v2 <= 3585085678)
      {
        if (v2 == 3540156652)
        {
          result = 93;
          goto LABEL_472;
        }
        if (v2 != 3543203160)
        {
          if (v2 == 3571532206)
          {
            result = 151;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
        goto LABEL_372;
      }
      if (v2 == 3585085679)
      {
        result = 10;
        goto LABEL_472;
      }
      if (v2 == 3599094683)
        goto LABEL_385;
      v12 = 3636345305;
      goto LABEL_366;
    }
    if (v2 > 2688879998)
    {
      if (v2 <= 2940697644)
      {
        if (v2 <= 2781508712)
        {
          if (v2 > 2722529671)
          {
            switch(v2)
            {
              case 2722529672:
                result = 28;
                goto LABEL_472;
              case 2730762296:
                result = 112;
                goto LABEL_472;
              case 2751865418:
                result = 143;
                goto LABEL_472;
            }
            goto LABEL_471;
          }
          if (v2 == 2688879999)
          {
            result = 39;
            goto LABEL_472;
          }
          if (v2 != 2692844695)
          {
            if (v2 == 2702125347)
            {
              result = 3;
              goto LABEL_472;
            }
            goto LABEL_471;
          }
LABEL_256:
          result = 197;
          goto LABEL_472;
        }
        if (v2 <= 2797549162)
        {
          switch(v2)
          {
            case 2781508713:
              result = 6;
              goto LABEL_472;
            case 2793418701:
              result = 19;
              goto LABEL_472;
            case 2795618603:
              result = 42;
              goto LABEL_472;
          }
          goto LABEL_471;
        }
        if (v2 > 2880863277)
        {
          if (v2 != 2880863278)
          {
            if (v2 == 2903084588)
            {
              result = 85;
              goto LABEL_472;
            }
            goto LABEL_471;
          }
LABEL_360:
          result = 51;
          goto LABEL_472;
        }
        if (v2 == 2797549163)
        {
          result = 113;
          goto LABEL_472;
        }
        v5 = 2823174122;
        goto LABEL_280;
      }
      if (v2 <= 3101941569)
      {
        if (v2 <= 2979575959)
        {
          switch(v2)
          {
            case 2940697645:
              result = 38;
              goto LABEL_472;
            case 2941181571:
              result = 41;
              goto LABEL_472;
            case 2943112657:
              result = 149;
              goto LABEL_472;
          }
          goto LABEL_471;
        }
        if (v2 == 2979575960)
        {
          result = 155;
          goto LABEL_472;
        }
        if (v2 == 3001488778)
        {
          result = 34;
          goto LABEL_472;
        }
        v11 = 3054476161;
LABEL_315:
        if (v2 != v11)
          goto LABEL_471;
        goto LABEL_316;
      }
      if (v2 <= 3133873108)
      {
        if (v2 == 3101941570)
          goto LABEL_272;
        if (v2 != 3104290450)
        {
          v10 = 3128362815;
          goto LABEL_370;
        }
        goto LABEL_337;
      }
      if (v2 <= 3184375230)
      {
        if (v2 == 3133873109)
        {
          result = 62;
          goto LABEL_472;
        }
        if (v2 == 3143587592)
        {
          result = 166;
          goto LABEL_472;
        }
        goto LABEL_471;
      }
      if (v2 == 3184375231)
      {
LABEL_389:
        result = 77;
        goto LABEL_472;
      }
      v12 = 3196158497;
LABEL_366:
      if (v2 != v12)
        goto LABEL_471;
      goto LABEL_367;
    }
    if (v2 <= 2454275342)
    {
      if (v2 > 2288107368)
      {
        if (v2 <= 2336512886)
        {
          if (v2 != 2288107369)
          {
            if (v2 == 2309863438)
            {
              result = 37;
              goto LABEL_472;
            }
            if (v2 == 2311900306)
            {
              result = 14;
              goto LABEL_472;
            }
            goto LABEL_471;
          }
          goto LABEL_363;
        }
        if (v2 > 2418348557)
        {
          if (v2 == 2418348558)
          {
            result = 135;
            goto LABEL_472;
          }
          if (v2 == 2445473385)
          {
            result = 124;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
        if (v2 == 2336512887)
        {
LABEL_378:
          result = 121;
          goto LABEL_472;
        }
        v4 = 2385671069;
LABEL_300:
        if (v2 == v4)
        {
          result = 50;
          goto LABEL_472;
        }
        goto LABEL_471;
      }
      if (v2 <= 2236272847)
      {
        if (v2 != 2158787296)
        {
          if (v2 == 2159747553)
          {
            result = 26;
            goto LABEL_472;
          }
          if (v2 != 2162679683)
            goto LABEL_471;
          goto LABEL_386;
        }
LABEL_217:
        result = 69;
        goto LABEL_472;
      }
      if (v2 != 2236272848)
      {
        if (v2 != 2262113699)
        {
          if (v2 == 2270970153)
          {
            result = 21;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
        goto LABEL_382;
      }
LABEL_367:
      result = 87;
      goto LABEL_472;
    }
    if (v2 <= 2619317133)
    {
      if (v2 <= 2487868871)
      {
        if (v2 == 2454275343)
        {
          result = 63;
          goto LABEL_472;
        }
        if (v2 != 2458172802)
        {
          v3 = 2468178735;
LABEL_168:
          if (v2 == v3)
          {
            result = 120;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
        goto LABEL_367;
      }
      if (v2 == 2487868872)
        goto LABEL_384;
      if (v2 != 2516717268)
      {
        v4 = 2614323575;
        goto LABEL_300;
      }
    }
    else
    {
      if (v2 <= 2628394913)
      {
        if (v2 == 2619317134)
          goto LABEL_388;
        if (v2 != 2622433984)
        {
          if (v2 == 2625074843)
          {
            result = 161;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
        goto LABEL_379;
      }
      if (v2 <= 2644487443)
      {
        if (v2 == 2628394914)
          goto LABEL_316;
        v7 = 2634105757;
        goto LABEL_96;
      }
      if (v2 == 2644487444)
      {
        result = 92;
        goto LABEL_472;
      }
      if (v2 != 2673319456)
        goto LABEL_471;
    }
    result = 73;
    goto LABEL_472;
  }
  if (v2 <= 1309571157)
  {
    if (v2 <= 676119127)
    {
      if (v2 <= 337183580)
      {
        if (v2 > 133314239)
        {
          if (v2 > 228444037)
          {
            if (v2 > 262180326)
            {
              if (v2 == 262180327)
              {
                result = 123;
                goto LABEL_472;
              }
              if (v2 == 330877086)
              {
                result = 43;
                goto LABEL_472;
              }
              goto LABEL_471;
            }
            if (v2 != 228444038)
            {
              v3 = 253148925;
              goto LABEL_168;
            }
LABEL_380:
            result = 72;
            goto LABEL_472;
          }
          if (v2 == 133314240)
          {
            result = 40;
            goto LABEL_472;
          }
          if (v2 != 157833461)
          {
            if (v2 == 173258742)
            {
              result = 59;
              goto LABEL_472;
            }
            goto LABEL_471;
          }
LABEL_249:
          result = 78;
          goto LABEL_472;
        }
        if (v2 <= 42878381)
        {
          switch(v2)
          {
            case 23433786:
              result = 61;
              goto LABEL_472;
            case 33245053:
              result = 68;
              goto LABEL_472;
            case 40511012:
              result = 134;
              goto LABEL_472;
          }
          goto LABEL_471;
        }
        if (v2 == 42878382)
        {
          result = 12;
          goto LABEL_472;
        }
        if (v2 != 79936591)
        {
          if (v2 != 88647037)
            goto LABEL_471;
          goto LABEL_389;
        }
LABEL_382:
        result = 76;
        goto LABEL_472;
      }
      if (v2 <= 363237282)
      {
        if (v2 > 344862119)
        {
          switch(v2)
          {
            case 344862120:
              result = 115;
              goto LABEL_472;
            case 355234908:
              result = 129;
              goto LABEL_472;
            case 358923952:
              result = 126;
              goto LABEL_472;
          }
          goto LABEL_471;
        }
        if (v2 == 337183581)
        {
          result = 11;
          goto LABEL_472;
        }
        if (v2 == 340218669)
        {
          result = 111;
          goto LABEL_472;
        }
        v8 = 341800273;
        goto LABEL_162;
      }
      if (v2 <= 502329936)
      {
        if (v2 != 363237283)
        {
          if (v2 == 425046865)
          {
            result = 157;
            goto LABEL_472;
          }
          if (v2 == 445396642)
          {
            result = 117;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
        goto LABEL_372;
      }
      if (v2 <= 555503453)
      {
        if (v2 == 502329937)
        {
          result = 22;
          goto LABEL_472;
        }
        v6 = 551446205;
LABEL_359:
        if (v2 != v6)
          goto LABEL_471;
        goto LABEL_360;
      }
      if (v2 != 555503454)
      {
        if (v2 == 574536383)
        {
          result = 30;
          goto LABEL_472;
        }
        goto LABEL_471;
      }
LABEL_388:
      result = 106;
      goto LABEL_472;
    }
    if (v2 <= 952317140)
    {
      if (v2 > 776033018)
      {
        if (v2 > 851437780)
        {
          if (v2 <= 910181309)
          {
            if (v2 == 851437781)
            {
              result = 29;
              goto LABEL_472;
            }
            if (v2 == 896202454)
            {
              result = 71;
              goto LABEL_472;
            }
            goto LABEL_471;
          }
          if (v2 == 910181310)
            goto LABEL_387;
          if (v2 != 910313402)
            goto LABEL_471;
LABEL_337:
          result = 195;
          goto LABEL_472;
        }
        if (v2 == 776033019)
        {
          result = 57;
          goto LABEL_472;
        }
        if (v2 != 810906663)
        {
          if (v2 != 820711327)
            goto LABEL_471;
          goto LABEL_217;
        }
LABEL_379:
        result = 98;
        goto LABEL_472;
      }
      if (v2 <= 746003605)
      {
        if (v2 == 676119128)
        {
          result = 146;
          goto LABEL_472;
        }
        if (v2 == 689804742)
        {
          result = 36;
          goto LABEL_472;
        }
        v10 = 698697055;
LABEL_370:
        if (v2 != v10)
          goto LABEL_471;
        goto LABEL_371;
      }
      if (v2 == 746003606)
      {
LABEL_316:
        result = 101;
        goto LABEL_472;
      }
      if (v2 == 749116821)
      {
        result = 165;
        goto LABEL_472;
      }
      v5 = 761631964;
LABEL_280:
      if (v2 == v5)
      {
        result = 109;
        goto LABEL_472;
      }
      goto LABEL_471;
    }
    if (v2 > 1169082143)
    {
      if (v2 <= 1280909811)
      {
        if (v2 == 1169082144)
        {
          result = 33;
          goto LABEL_472;
        }
        if (v2 == 1234705395)
        {
          result = 125;
          goto LABEL_472;
        }
        if (v2 != 1280441783)
          goto LABEL_471;
        goto LABEL_249;
      }
      if (v2 <= 1294429941)
      {
        if (v2 == 1280909812)
        {
          result = 152;
          goto LABEL_472;
        }
        if (v2 != 1293446025)
          goto LABEL_471;
        goto LABEL_373;
      }
      if (v2 == 1294429942)
      {
        result = 147;
        goto LABEL_472;
      }
      if (v2 != 1302273958)
        goto LABEL_471;
LABEL_363:
      result = 108;
      goto LABEL_472;
    }
    if (v2 > 1110205731)
    {
      if (v2 == 1110205732)
      {
        result = 48;
        goto LABEL_472;
      }
      if (v2 == 1114644381)
      {
        result = 82;
        goto LABEL_472;
      }
      v6 = 1119807502;
      goto LABEL_359;
    }
    if (v2 != 952317141)
    {
      if (v2 == 1060988941)
      {
        result = 9;
        goto LABEL_472;
      }
      if (v2 == 1085318934)
      {
        result = 131;
        goto LABEL_472;
      }
      goto LABEL_471;
    }
    goto LABEL_378;
  }
  if (v2 <= 1733600852)
  {
    if (v2 <= 1434404432)
    {
      if (v2 > 1380747800)
      {
        if (v2 <= 1412429327)
        {
          switch(v2)
          {
            case 1380747801:
              result = 127;
              goto LABEL_472;
            case 1402208364:
              result = 130;
              goto LABEL_472;
            case 1408738134:
              result = 150;
              goto LABEL_472;
          }
        }
        else if (v2 > 1419435330)
        {
          if (v2 == 1419435331)
          {
            result = 142;
            goto LABEL_472;
          }
          if (v2 == 1429914406)
          {
            result = 23;
            goto LABEL_472;
          }
        }
        else
        {
          if (v2 == 1412429328)
          {
            result = 65;
            goto LABEL_472;
          }
          if (v2 == 1415625992)
          {
            result = 136;
            goto LABEL_472;
          }
        }
        goto LABEL_471;
      }
      if (v2 <= 1364038515)
      {
        if (v2 == 1309571158)
        {
          result = 141;
          goto LABEL_472;
        }
        if (v2 == 1325975682)
        {
          result = 67;
          goto LABEL_472;
        }
        v8 = 1353145733;
LABEL_162:
        if (v2 != v8)
          goto LABEL_471;
        goto LABEL_344;
      }
      if (v2 != 1364038516)
      {
        if (v2 == 1371389549)
        {
          result = 27;
          goto LABEL_472;
        }
        if (v2 != 1373516433)
          goto LABEL_471;
        goto LABEL_272;
      }
LABEL_371:
      result = 194;
      goto LABEL_472;
    }
    if (v2 <= 1573906121)
    {
      if (v2 > 1549248875)
      {
        switch(v2)
        {
          case 1549248876:
            result = 172;
            goto LABEL_472;
          case 1554479185:
            result = 167;
            goto LABEL_472;
          case 1559256613:
            result = 55;
            goto LABEL_472;
        }
      }
      else
      {
        switch(v2)
        {
          case 1434404433:
            result = 17;
            goto LABEL_472;
          case 1517755655:
            result = 171;
            goto LABEL_472;
          case 1540760353:
            result = 5;
            goto LABEL_472;
        }
      }
      goto LABEL_471;
    }
    if (v2 <= 1625227433)
    {
      switch(v2)
      {
        case 1573906122:
          result = 138;
          goto LABEL_472;
        case 1602181456:
          result = 154;
          goto LABEL_472;
        case 1608945770:
          result = 192;
          goto LABEL_472;
      }
      goto LABEL_471;
    }
    if (v2 > 1701146936)
    {
      if (v2 == 1701146937)
      {
        result = 49;
        goto LABEL_472;
      }
      if (v2 == 1721691077)
      {
        result = 16;
        goto LABEL_472;
      }
      goto LABEL_471;
    }
    if (v2 != 1625227434)
    {
      if (v2 == 1644180312)
      {
        result = 145;
        goto LABEL_472;
      }
      goto LABEL_471;
    }
    goto LABEL_383;
  }
  if (v2 <= 2023824666)
  {
    if (v2 > 1868379042)
    {
      if (v2 <= 1908832378)
      {
        if (v2 != 1868379043)
        {
          if (v2 == 1878257790)
          {
            result = 81;
            goto LABEL_472;
          }
          if (v2 == 1895344378)
          {
            result = 86;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
        goto LABEL_272;
      }
      if (v2 <= 2001966016)
      {
        if (v2 != 1908832379)
        {
          if (v2 == 1990293942)
          {
            result = 140;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
LABEL_377:
        result = 196;
        goto LABEL_472;
      }
      if (v2 != 2001966017)
      {
        if (v2 == 2021146989)
        {
          result = 18;
          goto LABEL_472;
        }
        goto LABEL_471;
      }
LABEL_344:
      result = 88;
      goto LABEL_472;
    }
    if (v2 <= 1756509289)
    {
      if (v2 == 1733600853)
      {
        result = 128;
        goto LABEL_472;
      }
      if (v2 == 1737882206)
      {
        result = 116;
        goto LABEL_472;
      }
      v9 = 1744899922;
      goto LABEL_151;
    }
    if (v2 == 1756509290)
    {
      result = 144;
      goto LABEL_472;
    }
    if (v2 == 1770142589)
    {
      result = 163;
      goto LABEL_472;
    }
    v11 = 1834147427;
    goto LABEL_315;
  }
  if (v2 > 2085054104)
  {
    if (v2 > 2103978417)
    {
      if (v2 <= 2141052861)
      {
        if (v2 != 2103978418)
        {
          if (v2 == 2132302344)
          {
            result = 148;
            goto LABEL_472;
          }
          goto LABEL_471;
        }
LABEL_373:
        result = 96;
        goto LABEL_472;
      }
      if (v2 != 2141052862)
      {
        v10 = 2144123136;
        goto LABEL_370;
      }
LABEL_372:
      result = 193;
      goto LABEL_472;
    }
    if (v2 == 2085054105)
    {
      result = 158;
      goto LABEL_472;
    }
    if (v2 != 2089455188)
    {
      if (v2 != 2095883268)
        goto LABEL_471;
      goto LABEL_256;
    }
LABEL_381:
    result = 105;
    goto LABEL_472;
  }
  if (v2 <= 2078329140)
  {
    if (v2 != 2023824667)
    {
      if (v2 != 2032616841)
      {
        if (v2 == 2048538371)
        {
          result = 60;
          goto LABEL_472;
        }
        goto LABEL_471;
      }
LABEL_387:
      result = 25;
      goto LABEL_472;
    }
LABEL_272:
    result = 100;
    goto LABEL_472;
  }
  if (v2 > 2081274471)
  {
    if (v2 != 2081274472)
    {
      if (v2 == 2084894489)
      {
        result = 164;
        goto LABEL_472;
      }
      goto LABEL_471;
    }
LABEL_386:
    result = 122;
    goto LABEL_472;
  }
  if (v2 == 2078329141)
  {
    result = 31;
    goto LABEL_472;
  }
  if (v2 != 2080700391)
    goto LABEL_471;
  result = 46;
LABEL_472:
  PlatformUtilities_iOS::GetProductType(void)::sType = result;
  return result;
}

uint64_t PlatformUtilities_iOS::IsTelephonyCaptureAllowed()
{
  uint64_t result;

  if (queryBuildType(void)::once != -1)
    dispatch_once(&queryBuildType(void)::once, &__block_literal_global_67);
  if (!gIsInternal && !gIsCarrier)
    return 0;
  CFPreferencesAppSynchronize(CFSTR("com.apple.coreaudio"));
  result = CACFPreferencesGetAppIntegerValue(CFSTR("EnableTelephonyMonitor"), CFSTR("com.apple.coreaudio"), 0);
  if (result)
  {
    CFPreferencesAppSynchronize(CFSTR("com.apple.coreaudio"));
    return CACFPreferencesGetAppIntegerValue(CFSTR("EnableVPTelephonyMonitor"), CFSTR("com.apple.coreaudio"), 0) != 0;
  }
  return result;
}

void ___ZL14queryBuildTypev_block_invoke()
{
  const void *v0;
  CFTypeRef *v1;
  BOOL v2;
  const __CFString *v3;
  BOOL v4;
  const void *v5;
  BOOL v6;
  _QWORD v7[2];
  _QWORD v8[2];
  _QWORD v9[2];

  v9[1] = 1;
  v0 = (const void *)MGCopyAnswer();
  v9[0] = v0;
  v1 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
  if (v0)
    v2 = CFEqual(v0, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
  else
    v2 = 0;
  gIsInternal = v2;
  v8[1] = 1;
  v3 = (const __CFString *)MGCopyAnswer();
  v8[0] = v3;
  if (v3)
    v4 = CFStringCompare(CFSTR("Carrier"), v3, 0) == kCFCompareEqualTo;
  else
    v4 = 0;
  gIsCarrier = v4;
  v7[1] = 1;
  v5 = (const void *)MGCopyAnswer();
  v7[0] = v5;
  if (v5)
    v6 = CFEqual(v5, *v1) != 0;
  else
    v6 = 0;
  gIsUI = v6;
  CACFBoolean::~CACFBoolean((CACFBoolean *)v7);
  CACFString::~CACFString((CACFString *)v8);
  CACFBoolean::~CACFBoolean((CACFBoolean *)v9);
}

void sub_1B65C4708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  CACFBoolean::~CACFBoolean((CACFBoolean *)&a9);
  CACFString::~CACFString((CACFString *)&a11);
  CACFBoolean::~CACFBoolean((CACFBoolean *)&a13);
  _Unwind_Resume(a1);
}

CFStringRef PlatformUtilities_iOS::CopyProductTypeFilePrefix(int a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFStringRef result;
  uint64_t v27;
  char __str[8];
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)__str = 0;
  v29 = 0;
  v30 = 0;
  switch(a1)
  {
    case 1:
      v27 = 0;
      v1 = 184;
      goto LABEL_8;
    case 2:
      v27 = 0;
      goto LABEL_5;
    case 3:
      v27 = 97;
LABEL_5:
      v1 = 238;
      goto LABEL_8;
    case 4:
      v27 = 0;
      v1 = 520;
      goto LABEL_8;
    case 5:
      v27 = 0;
      v1 = 620;
LABEL_8:
      v2 = 98;
      goto LABEL_233;
    case 6:
      v27 = 0;
      v1 = 10;
      goto LABEL_50;
    case 7:
      v27 = 0;
      v1 = 11;
      goto LABEL_50;
    case 8:
      v27 = 0;
      v1 = 12;
      goto LABEL_50;
    case 9:
      v27 = 0;
      v1 = 16;
      goto LABEL_50;
    case 10:
      v27 = 0;
      v1 = 17;
      goto LABEL_50;
    case 11:
      v27 = 0;
      v1 = 101;
      goto LABEL_50;
    case 12:
      v27 = 0;
      v1 = 111;
      goto LABEL_50;
    case 13:
      v27 = 0;
      v1 = 121;
      goto LABEL_50;
    case 14:
      v27 = 0;
      v1 = 20;
      goto LABEL_50;
    case 15:
      v27 = 0;
      v1 = 21;
      goto LABEL_50;
    case 16:
      v27 = 0;
      v1 = 22;
      goto LABEL_50;
    case 17:
      v27 = 0;
      goto LABEL_49;
    case 18:
      v27 = 0;
      v1 = 28;
      goto LABEL_50;
    case 19:
      v27 = 0;
      v1 = 37;
      goto LABEL_50;
    case 20:
      v27 = 0;
      v1 = 38;
      goto LABEL_50;
    case 21:
      v27 = 0;
      v1 = 201;
      goto LABEL_50;
    case 22:
      v27 = 0;
      v1 = 211;
      goto LABEL_50;
    case 23:
      v27 = 0;
      v1 = 221;
      goto LABEL_50;
    case 24:
      v27 = 0;
      v1 = 32;
      goto LABEL_50;
    case 25:
      v27 = 0;
      v1 = 33;
      goto LABEL_50;
    case 26:
      v27 = 0;
      v1 = 79;
      goto LABEL_50;
    case 27:
      v27 = 0;
      v1 = 42;
      goto LABEL_50;
    case 28:
      v27 = 0;
      v1 = 43;
      goto LABEL_50;
    case 29:
      v27 = 0;
      v1 = 47;
      goto LABEL_50;
    case 30:
      v27 = 0;
      v1 = 48;
      goto LABEL_50;
    case 31:
      v27 = 0;
      v1 = 49;
      goto LABEL_50;
    case 32:
      v27 = 103;
      v1 = 52;
      goto LABEL_50;
    case 33:
      v3 = 103;
      goto LABEL_38;
    case 34:
      v3 = 112;
LABEL_38:
      v27 = v3;
      v1 = 53;
      goto LABEL_50;
    case 35:
      v27 = 112;
      v1 = 54;
      goto LABEL_50;
    case 36:
      v27 = 0;
      v1 = 63;
      goto LABEL_50;
    case 37:
      v27 = 0;
      v1 = 64;
      goto LABEL_50;
    case 38:
      v27 = 0;
      v1 = 73;
      goto LABEL_50;
    case 39:
      v27 = 0;
      v1 = 74;
      goto LABEL_50;
    case 40:
      v27 = 0;
      v1 = 83;
      goto LABEL_50;
    case 41:
      v27 = 0;
      v1 = 84;
      goto LABEL_50;
    case 42:
      v27 = 0;
      v1 = 93;
      goto LABEL_50;
    case 43:
      v27 = 0;
      v1 = 94;
      goto LABEL_50;
    case 44:
      v27 = 117;
LABEL_49:
      v1 = 27;
LABEL_50:
      v2 = 100;
      goto LABEL_233;
    case 45:
      v27 = 0;
      v1 = 59;
      goto LABEL_243;
    case 46:
      v27 = 0;
      v1 = 104;
      goto LABEL_232;
    case 47:
      v27 = 0;
      goto LABEL_55;
    case 48:
      v27 = 100;
LABEL_55:
      v1 = 42;
      goto LABEL_123;
    case 49:
      v27 = 0;
      goto LABEL_60;
    case 50:
      v4 = 98;
      goto LABEL_59;
    case 51:
      v4 = 115;
LABEL_59:
      v27 = v4;
LABEL_60:
      v1 = 71;
      goto LABEL_123;
    case 52:
      v27 = 0;
      v1 = 72;
      goto LABEL_123;
    case 53:
      v27 = 0;
      v1 = 73;
      goto LABEL_123;
    case 54:
      v27 = 0;
      v1 = 81;
      goto LABEL_123;
    case 55:
      v27 = 0;
      v1 = 82;
      goto LABEL_123;
    case 56:
      v27 = 0;
      goto LABEL_67;
    case 57:
      v27 = 109;
LABEL_67:
      v1 = 85;
      goto LABEL_123;
    case 58:
      v27 = 0;
      goto LABEL_70;
    case 59:
      v27 = 109;
LABEL_70:
      v1 = 86;
      goto LABEL_123;
    case 60:
      v27 = 0;
      goto LABEL_73;
    case 61:
      v27 = 109;
LABEL_73:
      v1 = 87;
      goto LABEL_123;
    case 62:
      v27 = 0;
      v1 = 96;
      goto LABEL_123;
    case 63:
      v27 = 0;
      v1 = 97;
      goto LABEL_123;
    case 64:
      v27 = 0;
      goto LABEL_78;
    case 65:
      v27 = 97;
LABEL_78:
      v1 = 98;
      goto LABEL_123;
    case 66:
      v27 = 0;
      goto LABEL_81;
    case 67:
      v27 = 97;
LABEL_81:
      v1 = 99;
      goto LABEL_123;
    case 68:
      v27 = 97;
      v1 = 105;
      goto LABEL_123;
    case 69:
      v27 = 0;
      v1 = 120;
      goto LABEL_123;
    case 70:
      v27 = 0;
      v1 = 127;
      goto LABEL_123;
    case 71:
      v27 = 0;
      v1 = 128;
      goto LABEL_123;
    case 72:
      v27 = 0;
      goto LABEL_88;
    case 73:
      v27 = 97;
LABEL_88:
      v1 = 171;
      goto LABEL_123;
    case 74:
      v27 = 0;
      v1 = 181;
      goto LABEL_123;
    case 75:
      v27 = 0;
      v1 = 182;
      goto LABEL_123;
    case 76:
      v27 = 0;
      v1 = 207;
      goto LABEL_123;
    case 77:
      v27 = 0;
      v1 = 210;
      goto LABEL_123;
    case 78:
      v27 = 0;
      v1 = 217;
      goto LABEL_123;
    case 79:
      v27 = 0;
      v1 = 255;
      goto LABEL_123;
    case 80:
      v27 = 0;
      v1 = 271;
      goto LABEL_123;
    case 81:
      v27 = 0;
      v1 = 272;
      goto LABEL_123;
    case 82:
      v27 = 0;
      v1 = 305;
      goto LABEL_123;
    case 83:
      v27 = 0;
      v1 = 307;
      goto LABEL_123;
    case 84:
      v27 = 0;
      v1 = 308;
      goto LABEL_123;
    case 85:
      v27 = 0;
      v1 = 310;
      goto LABEL_123;
    case 86:
      v27 = 0;
      v1 = 311;
      goto LABEL_123;
    case 87:
      v27 = 0;
      v1 = 317;
      goto LABEL_123;
    case 88:
      v27 = 0;
      v1 = 320;
      goto LABEL_123;
    case 89:
      v27 = 0;
      v1 = 348;
      goto LABEL_123;
    case 90:
      v27 = 0;
      v1 = 381;
      goto LABEL_123;
    case 91:
      v27 = 0;
      v1 = 382;
      goto LABEL_123;
    case 92:
      v27 = 0;
      v1 = 407;
      goto LABEL_123;
    case 93:
      v27 = 0;
      v1 = 408;
      goto LABEL_123;
    case 94:
      v27 = 0;
      v1 = 410;
      goto LABEL_123;
    case 95:
      v27 = 0;
      v1 = 411;
      goto LABEL_123;
    case 96:
      v27 = 0;
      v1 = 417;
      goto LABEL_123;
    case 97:
      v27 = 0;
      v1 = 420;
      goto LABEL_123;
    case 98:
      v27 = 0;
      v1 = 507;
      goto LABEL_123;
    case 99:
      v27 = 0;
      v1 = 508;
      goto LABEL_123;
    case 100:
      v27 = 0;
      v1 = 517;
      goto LABEL_123;
    case 101:
      v27 = 0;
      v1 = 522;
      goto LABEL_123;
    case 102:
      v27 = 0;
      v1 = 537;
      goto LABEL_123;
    case 103:
      v27 = 0;
      v1 = 538;
      goto LABEL_123;
    case 104:
      v27 = 0;
      v1 = 617;
      goto LABEL_123;
    case 105:
      v27 = 0;
      v1 = 620;
      goto LABEL_123;
    case 106:
      v27 = 0;
      v1 = 717;
      goto LABEL_123;
    case 107:
      v27 = 0;
      v1 = 720;
LABEL_123:
      v2 = 106;
      goto LABEL_233;
    case 108:
      v27 = 97;
      v1 = 27;
      goto LABEL_232;
    case 109:
      v27 = 97;
      v1 = 28;
      goto LABEL_232;
    case 110:
      v27 = 0;
      v1 = 41;
      goto LABEL_232;
    case 111:
      v27 = 0;
      v1 = 42;
      goto LABEL_232;
    case 112:
      v27 = 0;
      v1 = 48;
      goto LABEL_232;
    case 113:
      v27 = 0;
      v1 = 49;
      goto LABEL_232;
    case 114:
      v27 = 0;
      v1 = 51;
      goto LABEL_232;
    case 115:
      v27 = 0;
      v1 = 53;
      goto LABEL_232;
    case 116:
      v27 = 0;
      v1 = 56;
      goto LABEL_232;
    case 117:
      v27 = 0;
      v1 = 61;
      goto LABEL_232;
    case 118:
      v27 = 0;
      v1 = 64;
      goto LABEL_232;
    case 119:
      v27 = 0;
      v1 = 65;
      goto LABEL_232;
    case 120:
      v27 = 0;
      v1 = 66;
      goto LABEL_232;
    case 121:
      v27 = 0;
      v1 = 69;
      goto LABEL_232;
    case 122:
      v27 = 0;
      v1 = 71;
      goto LABEL_232;
    case 123:
      v27 = 0;
      v1 = 74;
      goto LABEL_232;
    case 124:
      v27 = 0;
      v1 = 75;
      goto LABEL_232;
    case 125:
      v27 = 0;
      v1 = 841;
      goto LABEL_232;
    case 126:
      v27 = 0;
      v1 = 102;
      goto LABEL_232;
    case 127:
      v27 = 0;
      v1 = 112;
      goto LABEL_232;
    case 128:
      v5 = 115;
      goto LABEL_146;
    case 129:
      v5 = 98;
LABEL_146:
      v27 = v5;
      v1 = 111;
      goto LABEL_232;
    case 130:
      v6 = 115;
      goto LABEL_149;
    case 131:
      v6 = 98;
LABEL_149:
      v27 = v6;
      v1 = 121;
      goto LABEL_232;
    case 132:
      v7 = 115;
      goto LABEL_152;
    case 133:
      v7 = 98;
LABEL_152:
      v27 = v7;
      v1 = 131;
      goto LABEL_232;
    case 134:
      v8 = 115;
      goto LABEL_155;
    case 135:
      v8 = 98;
LABEL_155:
      v27 = v8;
      v1 = 140;
      goto LABEL_232;
    case 136:
      v9 = 115;
      goto LABEL_158;
    case 137:
      v9 = 98;
LABEL_158:
      v27 = v9;
      v1 = 141;
      goto LABEL_232;
    case 138:
      v10 = 115;
      goto LABEL_161;
    case 139:
      v10 = 98;
LABEL_161:
      v27 = v10;
      v1 = 142;
      goto LABEL_232;
    case 140:
      v11 = 98;
      goto LABEL_164;
    case 141:
      v11 = 115;
LABEL_164:
      v27 = v11;
      v1 = 143;
      goto LABEL_232;
    case 142:
      v12 = 115;
      goto LABEL_167;
    case 143:
      v12 = 98;
LABEL_167:
      v27 = v12;
      v1 = 144;
      goto LABEL_232;
    case 144:
      v13 = 115;
      goto LABEL_170;
    case 145:
      v13 = 98;
LABEL_170:
      v27 = v13;
      v1 = 146;
      goto LABEL_232;
    case 146:
      v14 = 98;
      goto LABEL_173;
    case 147:
      v14 = 115;
LABEL_173:
      v27 = v14;
      v1 = 149;
      goto LABEL_232;
    case 148:
      v15 = 115;
      goto LABEL_176;
    case 149:
      v15 = 98;
LABEL_176:
      v27 = v15;
      v1 = 157;
      goto LABEL_232;
    case 150:
      v16 = 115;
      goto LABEL_179;
    case 151:
      v16 = 98;
LABEL_179:
      v27 = v16;
      v1 = 158;
      goto LABEL_232;
    case 152:
      v17 = 115;
      goto LABEL_182;
    case 153:
      v17 = 98;
LABEL_182:
      v27 = v17;
      v1 = 187;
      goto LABEL_232;
    case 154:
      v18 = 115;
      goto LABEL_185;
    case 155:
      v18 = 98;
LABEL_185:
      v27 = v18;
      v1 = 188;
      goto LABEL_232;
    case 156:
      v19 = 115;
      goto LABEL_188;
    case 157:
      v19 = 98;
LABEL_188:
      v27 = v19;
      v1 = 197;
      goto LABEL_232;
    case 158:
      v20 = 115;
      goto LABEL_191;
    case 159:
      v20 = 98;
LABEL_191:
      v27 = v20;
      v1 = 198;
      goto LABEL_232;
    case 160:
      v27 = 0;
      v1 = 199;
      goto LABEL_232;
    case 161:
      v21 = 115;
      goto LABEL_195;
    case 162:
      v21 = 98;
LABEL_195:
      v27 = v21;
      v1 = 207;
      goto LABEL_232;
    case 163:
      v22 = 115;
      goto LABEL_198;
    case 164:
      v22 = 98;
LABEL_198:
      v27 = v22;
      v1 = 208;
      goto LABEL_232;
    case 165:
      v23 = 115;
      goto LABEL_201;
    case 166:
      v23 = 98;
LABEL_201:
      v27 = v23;
      v1 = 217;
      goto LABEL_232;
    case 167:
      v24 = 115;
      goto LABEL_204;
    case 168:
      v24 = 98;
LABEL_204:
      v27 = v24;
      v1 = 218;
      goto LABEL_232;
    case 169:
      v27 = 0;
      v1 = 210;
      goto LABEL_232;
    case 170:
      v27 = 0;
      v1 = 101;
      goto LABEL_209;
    case 171:
      v27 = 0;
      v1 = 102;
      goto LABEL_209;
    case 172:
      v27 = 0;
      v1 = 103;
LABEL_209:
      v2 = 112;
      goto LABEL_233;
    case 173:
      v25 = 110;
      goto LABEL_212;
    case 174:
      v25 = 112;
LABEL_212:
      v27 = v25;
      v1 = 398;
      goto LABEL_229;
    case 175:
      v27 = 0;
      v1 = 456;
      goto LABEL_229;
    case 176:
      v27 = 112;
      v1 = 698;
      goto LABEL_229;
    case 177:
      v27 = 0;
      v1 = 720;
      goto LABEL_229;
    case 178:
      v27 = 0;
      v1 = 721;
      goto LABEL_229;
    case 179:
      v27 = 0;
      v1 = 734;
      goto LABEL_229;
    case 180:
      v27 = 0;
      v1 = 742;
      goto LABEL_229;
    case 181:
      v27 = 0;
      v1 = 1125;
      goto LABEL_229;
    case 182:
      v27 = 0;
      v1 = 1153;
      goto LABEL_229;
    case 183:
      v27 = 0;
      v1 = 1232;
      goto LABEL_229;
    case 184:
      v27 = 0;
      v1 = 1250;
      goto LABEL_229;
    case 185:
      v27 = 0;
      v1 = 1251;
      goto LABEL_229;
    case 186:
      v27 = 0;
      v1 = 1252;
      goto LABEL_229;
    case 187:
      v27 = 0;
      v1 = 1253;
      goto LABEL_229;
    case 188:
      snprintf(__str, 0x18uLL, "%c%d%c", 116, 698, 116);
      goto LABEL_234;
    case 189:
      v27 = 0;
      v1 = 6502;
      goto LABEL_229;
    case 190:
      v27 = 0;
      v1 = 6809;
LABEL_229:
      v2 = 116;
      goto LABEL_233;
    case 191:
      v27 = 0;
      v1 = 100;
      v2 = 113;
      goto LABEL_233;
    case 192:
      v27 = 0;
      v1 = 301;
LABEL_232:
      v2 = 110;
      goto LABEL_233;
    case 193:
      v27 = 0;
      v1 = 101;
      goto LABEL_243;
    case 194:
      v27 = 0;
      v1 = 201;
      goto LABEL_243;
    case 195:
      v27 = 0;
      v1 = 301;
      goto LABEL_243;
    case 196:
      v27 = 0;
      v1 = 401;
      goto LABEL_243;
    case 197:
      v27 = 0;
      v1 = 501;
LABEL_243:
      v2 = 118;
LABEL_233:
      snprintf(__str, 0x18uLL, "%c%d%c", v2, v1, v27);
LABEL_234:
      if (!__str[0])
        goto LABEL_236;
      result = CFStringCreateWithCString(0, __str, 0x600u);
      break;
    default:
LABEL_236:
      result = 0;
      break;
  }
  return result;
}

void CADeprecated::CAMutex::~CAMutex(CADeprecated::CAMutex *this)
{
  *(_QWORD *)this = &off_1E69EDF70;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24));
}

{
  *(_QWORD *)this = &off_1E69EDF70;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24));
  JUMPOUT(0x1BCC95CECLL);
}

BOOL CADeprecated::CAMutex::Lock(CADeprecated::CAMutex *this)
{
  _opaque_pthread_t *v2;
  _opaque_pthread_t *v3;
  int v4;
  int v5;
  int v7;
  _DWORD *exception;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = pthread_self();
  v3 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  v4 = pthread_equal(v2, v3);
  if (!v4)
  {
    v5 = pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
    if (v5)
    {
      v7 = v5;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v9 = 136315394;
        v10 = "CAMutex.cpp";
        v11 = 1024;
        v12 = 106;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  CAMutex::Lock: Could not lock the mutex", (uint8_t *)&v9, 0x12u);
      }
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &off_1E69EE218;
      exception[2] = v7;
    }
    atomic_store((unint64_t)v2, (unint64_t *)this + 2);
  }
  return v4 == 0;
}

void CADeprecated::CAMutex::Unlock(CADeprecated::CAMutex *this)
{
  _opaque_pthread_t *v2;
  _opaque_pthread_t *v3;
  int v4;
  int v5;
  _DWORD *exception;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = pthread_self();
  v3 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  if (pthread_equal(v2, v3))
  {
    atomic_store(0, (unint64_t *)this + 2);
    v4 = pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 24));
    if (v4)
    {
      v5 = v4;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v7 = 136315394;
        v8 = "CAMutex.cpp";
        v9 = 1024;
        v10 = 152;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  CAMutex::Unlock: Could not unlock the mutex", (uint8_t *)&v7, 0x12u);
      }
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &off_1E69EE218;
      exception[2] = v5;
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v7 = 136315394;
    v8 = "CAMutex.cpp";
    v9 = 1024;
    v10 = 160;
    _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%25s:%-5d  CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own", (uint8_t *)&v7, 0x12u);
  }
}

uint64_t CADeprecated::CAMutex::Try(CADeprecated::CAMutex *this, BOOL *a2)
{
  _opaque_pthread_t *v4;
  _opaque_pthread_t *v5;
  BOOL v6;
  int v7;
  uint64_t result;
  int v9;
  _DWORD *exception;
  _BYTE v11[5];
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  v4 = pthread_self();
  v5 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  if (pthread_equal(v4, v5))
  {
    v6 = 0;
  }
  else
  {
    v7 = pthread_mutex_trylock((pthread_mutex_t *)((char *)this + 24));
    if (v7 == 16)
    {
      v6 = 0;
      result = 0;
      goto LABEL_7;
    }
    if (v7)
    {
      v11[0] = HIBYTE(v7);
      v11[1] = BYTE2(v7);
      v11[2] = BYTE1(v7);
      v9 = v7;
      v11[3] = v7;
      v11[4] = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        v13 = "CAMutex.cpp";
        v14 = 1024;
        v15 = 224;
        v16 = 1024;
        v17 = v9;
        v18 = 2080;
        v19 = v11;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  CAMutex::Try: call to pthread_mutex_trylock failed, Error: %d (%s)", buf, 0x22u);
      }
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &off_1E69EE218;
      exception[2] = v9;
    }
    atomic_store((unint64_t)v4, (unint64_t *)this + 2);
    v6 = 1;
  }
  result = 1;
LABEL_7:
  *a2 = v6;
  return result;
}

BOOL CADeprecated::CAMutex::IsFree(CADeprecated::CAMutex *this)
{
  unint64_t v1;

  v1 = atomic_load((unint64_t *)this + 2);
  return v1 == 0;
}

BOOL CADeprecated::CAMutex::IsOwnedByCurrentThread(CADeprecated::CAMutex *this)
{
  _opaque_pthread_t *v2;
  _opaque_pthread_t *v3;

  v2 = pthread_self();
  v3 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  return pthread_equal(v2, v3) != 0;
}

CADeprecated::CAMutex *CADeprecated::CAMutex::CAMutex(CADeprecated::CAMutex *this, const char *a2)
{
  int v3;
  int v5;
  _DWORD *exception;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E69EDF70;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = 0;
  v3 = pthread_mutex_init((pthread_mutex_t *)((char *)this + 24), 0);
  if (v3)
  {
    v5 = v3;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v7 = 136315394;
      v8 = "CAMutex.cpp";
      v9 = 1024;
      v10 = 56;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  CAMutex::CAMutex: Could not init the mutex", (uint8_t *)&v7, 0x12u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E69EE218;
    exception[2] = v5;
  }
  return this;
}

BOOL CAStreamBasicDescription::IsEqual(CAStreamBasicDescription *this, const AudioStreamBasicDescription *a2)
{
  return *(double *)this == a2->mSampleRate
      && *((_DWORD *)this + 2) == a2->mFormatID
      && *((_DWORD *)this + 3) == a2->mFormatFlags
      && *((_DWORD *)this + 4) == a2->mBytesPerPacket
      && *((_DWORD *)this + 5) == a2->mFramesPerPacket
      && *((_DWORD *)this + 6) == a2->mBytesPerFrame
      && *((_DWORD *)this + 7) == a2->mChannelsPerFrame
      && *((_DWORD *)this + 8) == a2->mBitsPerChannel;
}

{
  int v3;
  AudioFormatID mFormatID;
  int v6;
  UInt32 mBytesPerPacket;
  int v8;
  UInt32 mFramesPerPacket;
  int v10;
  UInt32 mBytesPerFrame;
  int v12;
  UInt32 mChannelsPerFrame;
  int v14;
  UInt32 mBitsPerChannel;

  if (*(double *)this != 0.0 && a2->mSampleRate != 0.0 && *(double *)this != a2->mSampleRate)
    return 0;
  v3 = *((_DWORD *)this + 2);
  if (v3)
  {
    mFormatID = a2->mFormatID;
    if (mFormatID && v3 != mFormatID)
      return 0;
  }
  v6 = *((_DWORD *)this + 4);
  if (v6)
  {
    mBytesPerPacket = a2->mBytesPerPacket;
    if (mBytesPerPacket)
    {
      if (v6 != mBytesPerPacket)
        return 0;
    }
  }
  v8 = *((_DWORD *)this + 5);
  if (v8)
  {
    mFramesPerPacket = a2->mFramesPerPacket;
    if (mFramesPerPacket)
    {
      if (v8 != mFramesPerPacket)
        return 0;
    }
  }
  v10 = *((_DWORD *)this + 6);
  if (v10)
  {
    mBytesPerFrame = a2->mBytesPerFrame;
    if (mBytesPerFrame)
    {
      if (v10 != mBytesPerFrame)
        return 0;
    }
  }
  v12 = *((_DWORD *)this + 7);
  if (v12)
  {
    mChannelsPerFrame = a2->mChannelsPerFrame;
    if (mChannelsPerFrame)
    {
      if (v12 != mChannelsPerFrame)
        return 0;
    }
  }
  v14 = *((_DWORD *)this + 8);
  return (!v14 || (mBitsPerChannel = a2->mBitsPerChannel) == 0 || v14 == mBitsPerChannel)
      && CA::Implementation::EquivalentFormatFlags(this, a2, (const AudioStreamBasicDescription *)1, 1);
}

const __CFString *CACFString::GetCString(const __CFString *theString, __CFString *a2, char *a3, unsigned int *a4)
{
  const __CFString *v6;
  int v7;
  int v8;
  CFIndex usedBufLen;
  CFRange v10;

  if (*(_DWORD *)a3)
  {
    v6 = theString;
    if (theString)
    {
      usedBufLen = 0;
      v10.length = CFStringGetLength(theString);
      v10.location = 0;
      theString = (const __CFString *)CFStringGetBytes(v6, v10, 0x8000100u, 0, 0, (UInt8 *)a2, (*(_DWORD *)a3 - 1), &usedBufLen);
      v7 = usedBufLen;
      *((_BYTE *)&a2->isa + usedBufLen) = 0;
      v8 = v7 + 1;
    }
    else
    {
      LOBYTE(a2->isa) = 0;
      v8 = 1;
    }
    *(_DWORD *)a3 = v8;
  }
  return theString;
}

uint64_t PrefValueToPriority(const __CFString *a1, BOOL *a2)
{
  CFTypeID v4;
  int v5;
  int v6;
  int valuePtr;
  int v9;
  char buffer[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  valuePtr = -1;
  v4 = CFGetTypeID(a1);
  if (v4 == CFNumberGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &valuePtr);
    v5 = valuePtr + 3;
  }
  else
  {
    if (v4 != CFStringGetTypeID())
      goto LABEL_22;
    if (CFEqual(a1, CFSTR("error")))
    {
      v5 = 1;
      goto LABEL_23;
    }
    if (CFEqual(a1, CFSTR("warning")))
    {
      v5 = 2;
      goto LABEL_23;
    }
    if (CFEqual(a1, CFSTR("note")) || CFEqual(a1, CFSTR("notice")))
    {
      v5 = 3;
      goto LABEL_23;
    }
    if (CFEqual(a1, CFSTR("info")))
    {
      v5 = 4;
      goto LABEL_23;
    }
    if (CFEqual(a1, CFSTR("details")))
    {
      v5 = 5;
      goto LABEL_23;
    }
    if (CFEqual(a1, CFSTR("minutiae")))
    {
      v5 = 6;
      goto LABEL_23;
    }
    if (CFEqual(a1, CFSTR("spew")))
    {
      v5 = 7;
      goto LABEL_23;
    }
    v12 = 0u;
    v13 = 0u;
    *(_OWORD *)buffer = 0u;
    v11 = 0u;
    if (!CFStringGetCString(a1, buffer, 64, 0x8000100u))
    {
LABEL_22:
      v5 = -1;
      goto LABEL_23;
    }
    v9 = 0;
    v6 = sscanf(buffer, "%d", &v9);
    v5 = v9 + 3;
    if (v6 != 1)
      v5 = -1;
  }
LABEL_23:
  *a2 = v5 > 0;
  return v5 & ~(v5 >> 31);
}

_QWORD *std::__function::__func<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E69EDFF0;
  v2 = a1 + 2;
  v3 = (_QWORD *)a1[5];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E69EDFF0;
  v1 = a1 + 2;
  v2 = (_QWORD *)a1[5];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x30uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_1E69EDFF0;
  v2[1] = v3;
  std::__function::__value_func<void ()(std::vector<long long> const&)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_1B65C5C10(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_1E69EDFF0;
  a2[1] = v2;
  return std::__function::__value_func<void ()(std::vector<long long> const&)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

_QWORD *std::__function::__func<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::destroy(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 16);
  result = *(_QWORD **)(a1 + 40);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 16;
  v3 = (char *)*((_QWORD *)__p + 5);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

BOOL std::__function::__func<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<int>(__CFString const*,__CFString const*,int (*)(void const*,BOOL &),std::function<void ()(int)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  char v7;
  int v8;

  v3 = *a2;
  v7 = 0;
  v4 = (*(uint64_t (**)(uint64_t, char *))(a1 + 8))(v3, &v7);
  if (!v7)
    return 0;
  v8 = v4;
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, int *))(*(_QWORD *)v5 + 48))(v5, &v8);
  return v7 != 0;
}

void std::__function::__func<CALegacyLog::Scope::init(unsigned long long,char const*,__CFString const*,__CFString const*,unsigned int)::$_0,std::allocator<CALegacyLog::Scope::init(unsigned long long,char const*,__CFString const*,__CFString const*,unsigned int)::$_0>,void ()(int)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<CALegacyLog::Scope::init(unsigned long long,char const*,__CFString const*,__CFString const*,unsigned int)::$_0,std::allocator<CALegacyLog::Scope::init(unsigned long long,char const*,__CFString const*,__CFString const*,unsigned int)::$_0>,void ()(int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E69EE038;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CALegacyLog::Scope::init(unsigned long long,char const*,__CFString const*,__CFString const*,unsigned int)::$_0,std::allocator<CALegacyLog::Scope::init(unsigned long long,char const*,__CFString const*,__CFString const*,unsigned int)::$_0>,void ()(int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E69EE038;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<CALegacyLog::Scope::init(unsigned long long,char const*,__CFString const*,__CFString const*,unsigned int)::$_0,std::allocator<CALegacyLog::Scope::init(unsigned long long,char const*,__CFString const*,__CFString const*,unsigned int)::$_0>,void ()(int)>::operator()(uint64_t result, int *a2)
{
  int v2;
  uint64_t v3;
  int v4;

  v2 = *a2;
  v3 = *(_QWORD *)(result + 8);
  if (*a2 >= 5)
    v4 = 5;
  else
    v4 = *a2;
  if ((*(_DWORD *)(v3 + 48) & 0x20) != 0)
    v2 = v4;
  *(_DWORD *)(v3 + 8) = v2;
  return result;
}

uint64_t CALegacyLog::RegisterScope(CALegacyLog *this, const char *a2, const char *a3, const char *a4, const char *a5, const char *a6)
{
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  os_log_t v12;
  CFStringRef v13;
  CFStringRef v14;
  void **v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  CASmartPreferences *v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t (*v33)(const __CFString *, BOOL *);
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  _QWORD v42[3];
  _QWORD *v43;
  uint64_t (*v44)(const __CFString *, BOOL *);
  _QWORD v45[3];
  _QWORD *v46;
  _QWORD v47[3];
  _QWORD *v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  pthread_rwlock_rdlock(&sLock);
  if (!gScopes || (v9 = *(_QWORD **)gScopes, v10 = *(_QWORD **)(gScopes + 8), *(_QWORD **)gScopes == v10))
  {
LABEL_5:
    v11 = 0;
  }
  else
  {
    while (*v9 != this)
    {
      v9 += 2;
      if (v9 == v10)
        goto LABEL_5;
    }
    v11 = v9[1];
  }
  pthread_rwlock_unlock(&sLock);
  if (!v11)
  {
    v11 = operator new();
    *(_DWORD *)(v11 + 8) = 3;
    *(_QWORD *)(v11 + 16) = 0;
    *(_QWORD *)(v11 + 56) = 0;
    *(_BYTE *)(v11 + 64) = 0;
    if (a2)
      v12 = os_log_create("com.apple.coreaudio", a2);
    else
      v12 = (os_log_t)MEMORY[0x1E0C81028];
    *(_QWORD *)v11 = v12;
    gUseOSLogInDefaultScope = 1;
    v13 = CFStringCreateWithCString(0, "com.apple.coreaudio", 0x8000100u);
    v14 = CFStringCreateWithCString(0, a3, 0x8000100u);
    *(_QWORD *)(v11 + 24) = a2;
    *(_QWORD *)(v11 + 32) = v13;
    *(_QWORD *)(v11 + 40) = v14;
    *(_DWORD *)(v11 + 48) = 31;
    if (v13)
      CFRetain(v13);
    if (v14)
      CFRetain(v14);
    *(_QWORD *)(v11 + 120) = 0;
    *(_OWORD *)(v11 + 104) = 0u;
    *(_OWORD *)(v11 + 88) = 0u;
    *(_OWORD *)(v11 + 72) = 0u;
    pthread_rwlock_wrlock(&sLock);
    v15 = (void **)gScopes;
    if (!gScopes)
    {
      v15 = (void **)operator new();
      *v15 = 0;
      v15[1] = 0;
      v15[2] = 0;
      gScopes = (uint64_t)v15;
    }
    v17 = v15[1];
    v16 = (unint64_t)v15[2];
    if ((unint64_t)v17 >= v16)
    {
      v19 = ((char *)v17 - (_BYTE *)*v15) >> 4;
      v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 60)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v21 = v16 - (_QWORD)*v15;
      if (v21 >> 3 > v20)
        v20 = v21 >> 3;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0)
        v22 = 0xFFFFFFFFFFFFFFFLL;
      else
        v22 = v20;
      if (v22)
      {
        if (v22 >> 60)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v23 = (char *)operator new(16 * v22);
      }
      else
      {
        v23 = 0;
      }
      v24 = &v23[16 * v19];
      v25 = &v23[16 * v22];
      *(_QWORD *)v24 = this;
      *((_QWORD *)v24 + 1) = v11;
      v18 = v24 + 16;
      v27 = (char *)*v15;
      v26 = (char *)v15[1];
      if (v26 != *v15)
      {
        do
        {
          *((_OWORD *)v24 - 1) = *((_OWORD *)v26 - 1);
          v24 -= 16;
          v26 -= 16;
        }
        while (v26 != v27);
        v26 = (char *)*v15;
      }
      *v15 = v24;
      v15[1] = v18;
      v15[2] = v25;
      if (v26)
        operator delete(v26);
    }
    else
    {
      *v17 = this;
      v17[1] = v11;
      v18 = v17 + 2;
    }
    v15[1] = v18;
    v28 = (CASmartPreferences *)pthread_rwlock_unlock(&sLock);
    if (!v13)
      goto LABEL_61;
    v42[0] = &off_1E69EE038;
    v42[1] = v11;
    v43 = v42;
    CASmartPreferences::instance(v28);
    v44 = PrefValueToPriority;
    v29 = v45;
    v30 = (uint64_t)v43;
    if (v43)
    {
      if (v43 == v42)
      {
        v46 = v45;
        (*(void (**)(_QWORD *, _QWORD *))(v42[0] + 24))(v42, v45);
LABEL_40:
        v48 = 0;
        v31 = operator new(0x30uLL);
        v32 = v31;
        v33 = v44;
        v34 = v46;
        *v31 = &off_1E69EDFF0;
        v31[1] = v33;
        if (v34)
        {
          if (v34 == v45)
          {
            v31[5] = v31 + 2;
            (*(void (**)(_QWORD *))(v45[0] + 24))(v45);
LABEL_46:
            v48 = v32;
            CASmartPreferences::_RegisterFirstHandler((uint64_t)&CASmartPreferences::instance(void)::global, v14, v13, v47);
            v36 = v48;
            if (v48 == v47)
            {
              v37 = 4;
              v36 = v47;
            }
            else
            {
              if (!v48)
                goto LABEL_51;
              v37 = 5;
            }
            (*(void (**)(void))(*v36 + 8 * v37))();
LABEL_51:
            if (v46 == v45)
            {
              v38 = 4;
            }
            else
            {
              if (!v46)
                goto LABEL_56;
              v38 = 5;
              v29 = v46;
            }
            (*(void (**)(_QWORD *))(*v29 + 8 * v38))(v29);
LABEL_56:
            v39 = v43;
            if (v43 == v42)
            {
              v40 = 4;
              v39 = v42;
            }
            else
            {
              if (!v43)
              {
LABEL_61:
                CFRelease(v13);
                CFRelease(v14);
                return v11;
              }
              v40 = 5;
            }
            (*(void (**)(void))(*v39 + 8 * v40))();
            goto LABEL_61;
          }
          v35 = &v46;
          v31[5] = v34;
        }
        else
        {
          v35 = v31 + 5;
        }
        *v35 = 0;
        goto LABEL_46;
      }
      v30 = (*(uint64_t (**)(void))(*v43 + 16))();
    }
    v46 = (_QWORD *)v30;
    goto LABEL_40;
  }
  return v11;
}

void sub_1B65C6210(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t CALegacyLog::LogEnabled(int a1, uint64_t a2, unint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  os_log_type_t v8;

  if (a1 > 5)
    goto LABEL_15;
  if (a2)
  {
    if (!*(_QWORD *)a2)
      goto LABEL_16;
  }
  else if (gUseOSLogInDefaultScope != 1)
  {
    return a1 < 4;
  }
  if ((a1 - 1) < 3)
    return 1;
  if ((a1 - 4) > 1
    || (!a2 ? (v6 = MEMORY[0x1E0C81028]) : (v6 = *(NSObject **)a2),
        (v7 = 1, a1 == 4) ? (v8 = OS_LOG_TYPE_INFO) : (v8 = OS_LOG_TYPE_DEBUG),
        !os_log_type_enabled(v6, v8)))
  {
LABEL_15:
    if (a2)
    {
LABEL_16:
      if (!HIDWORD(a3))
        return *(_DWORD *)(a2 + 8) >= a1;
      if ((*(_QWORD *)(a2 + 8 * (a1 - 1) + 72) & HIDWORD(a3)) == 0)
      {
        if ((~*(_DWORD *)(a2 + 16) & HIDWORD(a3)) == 0)
          return 0;
        return *(_DWORD *)(a2 + 8) >= a1;
      }
      return 1;
    }
    return a1 < 4;
  }
  return v7;
}

void TFileBSD::~TFileBSD(TFileBSD *this)
{
  TFileBSD::~TFileBSD(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  NSObject *v2;
  void (**v3)(TFileBSD *__hidden);
  NSObject *v4;
  void *v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  TFileBSD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E69EE080;
  if (kTFileBSDSubsystem)
  {
    v2 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v6 = 136315906;
    v7 = "TFileBSD.cpp";
    v8 = 1024;
    v9 = 132;
    v10 = 2080;
    v11 = "~TFileBSD";
    v12 = 2048;
    v13 = this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", (uint8_t *)&v6, 0x26u);
    v3 = *(void (***)(TFileBSD *__hidden))this;
    goto LABEL_8;
  }
LABEL_7:
  v3 = &off_1E69EE080;
LABEL_8:
  if (((unsigned int (*)(TFileBSD *))v3[15])(this))
    (*(void (**)(TFileBSD *))(*(_QWORD *)this + 112))(this);
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v4 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          v6 = 136315906;
          v7 = "TFileBSD.cpp";
          v8 = 1024;
          v9 = 141;
          v10 = 2080;
          v11 = "~TFileBSD";
          v12 = 2048;
          v13 = this;
          _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", (uint8_t *)&v6, 0x26u);
        }
      }
    }
  }
  v5 = (void *)*((_QWORD *)this + 1);
  if (v5)
  {
    free(v5);
    *((_QWORD *)this + 1) = 0;
  }
}

size_t TFileBSD::Read(FILE **this, void *a2, size_t a3)
{
  NSObject *v6;
  size_t v7;
  int v8;
  NSObject *v9;
  CAXException *exception;
  unsigned int v12;
  CAXException *v13;
  _BYTE v14[16];
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v6 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v6 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315906;
    v16 = "TFileBSD.cpp";
    v17 = 1024;
    v18 = 449;
    v19 = 2080;
    v20 = "Read";
    v21 = 2048;
    v22 = (const char *)this;
    _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", buf, 0x26u);
  }
LABEL_7:
  if ((((uint64_t (*)(FILE **))(*this)->_lb._base)(this) & 1) == 0)
  {
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)v14, 0xFFFFFFDA);
      *(_DWORD *)buf = 136315906;
      v16 = "TFileBSD.cpp";
      v17 = 1024;
      v18 = 452;
      v19 = 2080;
      v20 = v14;
      v21 = 2080;
      v22 = "Read - file not open";
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
    }
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "Read - file not open", -38);
  }
  if (a3)
  {
    v7 = fread(a2, 1uLL, a3, this[2]);
    if (v7 < a3 && !feof(this[2]))
    {
      v8 = ferror(this[2]);
      if (v8)
      {
        v12 = v8;
        if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
        {
          CAX4CCString::CAX4CCString((CAX4CCString *)v14, v12);
          *(_DWORD *)buf = 136315906;
          v16 = "TFileBSD.cpp";
          v17 = 1024;
          v18 = 463;
          v19 = 2080;
          v20 = v14;
          v21 = 2080;
          v22 = "Read::fread";
          _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
        }
        v13 = (CAXException *)__cxa_allocate_exception(0x110uLL);
        CAXException::CAXException(v13, "Read::fread", v12);
      }
    }
    this[3] = (FILE *)((char *)this[3] + v7);
  }
  else
  {
    v7 = 0;
  }
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v9 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          v16 = "TFileBSD.cpp";
          v17 = 1024;
          v18 = 469;
          v19 = 2080;
          v20 = "Read";
          v21 = 2048;
          v22 = (const char *)this;
          _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", buf, 0x26u);
        }
      }
    }
  }
  return v7;
}

void sub_1B65C67A8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

size_t TFileBSD::Write(FILE **this, void *a2, size_t a3)
{
  NSObject *v6;
  size_t v7;
  int v8;
  NSObject *v9;
  CAXException *exception;
  unsigned int v12;
  CAXException *v13;
  _BYTE v14[16];
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v6 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v6 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315906;
    v16 = "TFileBSD.cpp";
    v17 = 1024;
    v18 = 479;
    v19 = 2080;
    v20 = "Write";
    v21 = 2048;
    v22 = (const char *)this;
    _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", buf, 0x26u);
  }
LABEL_7:
  if ((((uint64_t (*)(FILE **))(*this)->_lb._base)(this) & 1) == 0)
  {
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)v14, 0xFFFFFFDA);
      *(_DWORD *)buf = 136315906;
      v16 = "TFileBSD.cpp";
      v17 = 1024;
      v18 = 482;
      v19 = 2080;
      v20 = v14;
      v21 = 2080;
      v22 = "Write - file not open";
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
    }
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "Write - file not open", -38);
  }
  if (a3)
  {
    v7 = fwrite(a2, 1uLL, a3, this[2]);
    if (v7 < a3)
    {
      v8 = ferror(this[2]);
      if (v8)
      {
        v12 = v8;
        if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
        {
          CAX4CCString::CAX4CCString((CAX4CCString *)v14, v12);
          *(_DWORD *)buf = 136315906;
          v16 = "TFileBSD.cpp";
          v17 = 1024;
          v18 = 492;
          v19 = 2080;
          v20 = v14;
          v21 = 2080;
          v22 = "Write::fwrite";
          _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
        }
        v13 = (CAXException *)__cxa_allocate_exception(0x110uLL);
        CAXException::CAXException(v13, "Write::fwrite", v12);
      }
    }
    this[3] = (FILE *)((char *)this[3] + v7);
  }
  else
  {
    v7 = 0;
  }
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v9 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          v16 = "TFileBSD.cpp";
          v17 = 1024;
          v18 = 498;
          v19 = 2080;
          v20 = "Write";
          v21 = 2048;
          v22 = (const char *)this;
          _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", buf, 0x26u);
        }
      }
    }
  }
  return v7;
}

void sub_1B65C6B40(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t TFileBSD::ReadAsync(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  uint64_t result;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v2 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v5 = 136315906;
    v6 = "TFileBSD.cpp";
    v7 = 1024;
    v8 = 508;
    v9 = 2080;
    v10 = "ReadAsync";
    v11 = 2048;
    v12 = a1;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", (uint8_t *)&v5, 0x26u);
  }
LABEL_7:
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1) & 1) == 0)
  {
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "TFileBSD.cpp";
      v7 = 1024;
      v8 = 511;
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d ASSERTION FAILURE [(IsOpen()) != 0 is false]: ", (uint8_t *)&v5, 0x12u);
    }
    __break(1u);
  }
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 4294967258;
  if (!kTFileBSDSubsystem)
    return 0;
  if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) == 0)
    return 0;
  v3 = *(NSObject **)kTFileBSDSubsystem;
  if (!*(_QWORD *)kTFileBSDSubsystem)
    return 0;
  result = os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    v5 = 136315906;
    v6 = "TFileBSD.cpp";
    v7 = 1024;
    v8 = 561;
    v9 = 2080;
    v10 = "ReadAsync";
    v11 = 2048;
    v12 = a1;
    _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", (uint8_t *)&v5, 0x26u);
    return 0;
  }
  return result;
}

void TFileBSD::Seek(FILE **this, FILE *a2)
{
  NSObject *v4;
  NSObject *v5;
  CAXException *exception;
  int v7;
  CAXException *v8;
  _BYTE v9[16];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v4 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v4 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315906;
    v11 = "TFileBSD.cpp";
    v12 = 1024;
    v13 = 364;
    v14 = 2080;
    v15 = "Seek";
    v16 = 2048;
    v17 = (const char *)this;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", buf, 0x26u);
  }
LABEL_7:
  if ((((uint64_t (*)(FILE **))(*this)->_lb._base)(this) & 1) == 0)
  {
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)v9, 0xFFFFFFDA);
      *(_DWORD *)buf = 136315906;
      v11 = "TFileBSD.cpp";
      v12 = 1024;
      v13 = 367;
      v14 = 2080;
      v15 = v9;
      v16 = 2080;
      v17 = "Seek - file not open";
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
    }
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "Seek - file not open", -38);
  }
  if (fseeko(this[2], (off_t)a2 + (_QWORD)this[4], 0))
  {
    v7 = *__error() + 100000;
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)v9, v7);
      *(_DWORD *)buf = 136315906;
      v11 = "TFileBSD.cpp";
      v12 = 1024;
      v13 = 369;
      v14 = 2080;
      v15 = v9;
      v16 = 2080;
      v17 = "Seek::fseeko failed";
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
    }
    v8 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v8, "Seek::fseeko failed", v7);
  }
  this[3] = a2;
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v5 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          v11 = "TFileBSD.cpp";
          v12 = 1024;
          v13 = 374;
          v14 = 2080;
          v15 = "Seek";
          v16 = 2048;
          v17 = (const char *)this;
          _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", buf, 0x26u);
        }
      }
    }
  }
}

void sub_1B65C70C8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void TFileBSD::SeekAsync(TFileBSD *this, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  TFileBSD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = kTFileBSDSubsystem;
  if (kTFileBSDSubsystem)
  {
    v5 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
    {
      *((_QWORD *)this + 3) = a2;
LABEL_8:
      if ((*(_BYTE *)(v4 + 8) & 1) != 0)
      {
        v6 = *(NSObject **)v4;
        if (*(_QWORD *)v4)
        {
          if (os_log_type_enabled(*(os_log_t *)v4, OS_LOG_TYPE_DEBUG))
          {
            v7 = 136315906;
            v8 = "TFileBSD.cpp";
            v9 = 1024;
            v10 = 387;
            v11 = 2080;
            v12 = "SeekAsync";
            v13 = 2048;
            v14 = this;
            _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", (uint8_t *)&v7, 0x26u);
          }
        }
      }
      return;
    }
  }
  else
  {
    v5 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    v7 = 136315906;
    v8 = "TFileBSD.cpp";
    v9 = 1024;
    v10 = 383;
    v11 = 2080;
    v12 = "SeekAsync";
    v13 = 2048;
    v14 = this;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", (uint8_t *)&v7, 0x26u);
    v4 = kTFileBSDSubsystem;
  }
  *((_QWORD *)this + 3) = a2;
  if (v4)
    goto LABEL_8;
}

uint64_t TFileBSD::GetPosition(TFileBSD *this)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  TFileBSD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = kTFileBSDSubsystem;
  if (kTFileBSDSubsystem)
  {
    v3 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
    {
LABEL_8:
      if ((*(_BYTE *)(v2 + 8) & 1) != 0)
      {
        v4 = *(NSObject **)v2;
        if (*(_QWORD *)v2)
        {
          if (os_log_type_enabled(*(os_log_t *)v2, OS_LOG_TYPE_DEBUG))
          {
            v6 = 136315906;
            v7 = "TFileBSD.cpp";
            v8 = 1024;
            v9 = 399;
            v10 = 2080;
            v11 = "GetPosition";
            v12 = 2048;
            v13 = this;
            _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", (uint8_t *)&v6, 0x26u);
          }
        }
      }
      return *((_QWORD *)this + 3);
    }
  }
  else
  {
    v3 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    v6 = 136315906;
    v7 = "TFileBSD.cpp";
    v8 = 1024;
    v9 = 397;
    v10 = 2080;
    v11 = "GetPosition";
    v12 = 2048;
    v13 = this;
    _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", (uint8_t *)&v6, 0x26u);
    v2 = kTFileBSDSubsystem;
  }
  if (v2)
    goto LABEL_8;
  return *((_QWORD *)this + 3);
}

void TFileBSD::Skip(FILE **this, off_t a2)
{
  NSObject *v4;
  NSObject *v5;
  CAXException *exception;
  int v7;
  CAXException *v8;
  _BYTE v9[16];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v4 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v4 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315906;
    v11 = "TFileBSD.cpp";
    v12 = 1024;
    v13 = 409;
    v14 = 2080;
    v15 = "Skip";
    v16 = 2048;
    v17 = (const char *)this;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", buf, 0x26u);
  }
LABEL_7:
  if ((((uint64_t (*)(FILE **))(*this)->_lb._base)(this) & 1) == 0)
  {
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)v9, 0xFFFFFFDA);
      *(_DWORD *)buf = 136315906;
      v11 = "TFileBSD.cpp";
      v12 = 1024;
      v13 = 412;
      v14 = 2080;
      v15 = v9;
      v16 = 2080;
      v17 = "Skip - file not open";
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
    }
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "Skip - file not open", -38);
  }
  if (fseeko(this[2], a2, 1))
  {
    v7 = *__error() + 100000;
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)v9, v7);
      *(_DWORD *)buf = 136315906;
      v11 = "TFileBSD.cpp";
      v12 = 1024;
      v13 = 414;
      v14 = 2080;
      v15 = v9;
      v16 = 2080;
      v17 = "Skip::fseeko failed";
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
    }
    v8 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v8, "Skip::fseeko failed", v7);
  }
  this[3] = (FILE *)((char *)this[3] + a2);
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v5 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          v11 = "TFileBSD.cpp";
          v12 = 1024;
          v13 = 420;
          v14 = 2080;
          v15 = "Skip";
          v16 = 2048;
          v17 = (const char *)this;
          _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", buf, 0x26u);
        }
      }
    }
  }
}

void sub_1B65C7760(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

off_t TFileBSD::GetLength(FILE **this)
{
  NSObject *v2;
  int v3;
  off_t st_size;
  NSObject *v5;
  CAXException *exception;
  int v8;
  CAXException *v9;
  _BYTE v10[16];
  uint8_t v11[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  stat buf;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v2 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    buf.st_dev = 136315906;
    *(_QWORD *)&buf.st_mode = "TFileBSD.cpp";
    WORD2(buf.st_ino) = 1024;
    *(_DWORD *)((char *)&buf.st_ino + 6) = 429;
    HIWORD(buf.st_uid) = 2080;
    *(_QWORD *)&buf.st_gid = "GetLength";
    *((_WORD *)&buf.st_rdev + 2) = 2048;
    *(_QWORD *)((char *)&buf.st_rdev + 6) = this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", (uint8_t *)&buf, 0x26u);
  }
LABEL_7:
  if ((((uint64_t (*)(FILE **))(*this)->_lb._base)(this) & 1) == 0)
  {
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)v11, 0xFFFFFFDA);
      buf.st_dev = 136315906;
      *(_QWORD *)&buf.st_mode = "TFileBSD.cpp";
      WORD2(buf.st_ino) = 1024;
      *(_DWORD *)((char *)&buf.st_ino + 6) = 433;
      HIWORD(buf.st_uid) = 2080;
      *(_QWORD *)&buf.st_gid = v11;
      *((_WORD *)&buf.st_rdev + 2) = 2080;
      *(_QWORD *)((char *)&buf.st_rdev + 6) = "GetLength - file not open";
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", (uint8_t *)&buf, 0x26u);
    }
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "GetLength - file not open", -38);
  }
  memset(&buf, 0, sizeof(buf));
  v3 = fileno(this[2]);
  if (fstat(v3, &buf))
  {
    v8 = *__error() + 100000;
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)v10, v8);
      *(_DWORD *)v11 = 136315906;
      v12 = "TFileBSD.cpp";
      v13 = 1024;
      v14 = 436;
      v15 = 2080;
      v16 = v10;
      v17 = 2080;
      v18 = "GetLength::fstat failed";
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", v11, 0x26u);
    }
    v9 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v9, "GetLength::fstat failed", v8);
  }
  st_size = buf.st_size;
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v5 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v11 = 136315906;
          v12 = "TFileBSD.cpp";
          v13 = 1024;
          v14 = 439;
          v15 = 2080;
          v16 = "GetLength";
          v17 = 2048;
          v18 = (const char *)this;
          _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", v11, 0x26u);
        }
      }
    }
  }
  return st_size;
}

void sub_1B65C7AE0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL TFileBSD::Exists(const char **this)
{
  NSObject *v2;
  _BOOL8 v3;
  NSObject *v4;
  stat v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v2 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v6.st_dev = 136315906;
    *(_QWORD *)&v6.st_mode = "TFileBSD.cpp";
    WORD2(v6.st_ino) = 1024;
    *(_DWORD *)((char *)&v6.st_ino + 6) = 236;
    HIWORD(v6.st_uid) = 2080;
    *(_QWORD *)&v6.st_gid = "Exists";
    *((_WORD *)&v6.st_rdev + 2) = 2048;
    *(_QWORD *)((char *)&v6.st_rdev + 6) = this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", (uint8_t *)&v6, 0x26u);
  }
LABEL_7:
  if (((*((uint64_t (**)(const char **))*this + 15))(this) & 1) != 0)
  {
    v3 = 1;
  }
  else
  {
    memset(&v6, 0, sizeof(v6));
    v3 = stat(this[1], &v6) == 0;
  }
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v4 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          v6.st_dev = 136315906;
          *(_QWORD *)&v6.st_mode = "TFileBSD.cpp";
          WORD2(v6.st_ino) = 1024;
          *(_DWORD *)((char *)&v6.st_ino + 6) = 252;
          HIWORD(v6.st_uid) = 2080;
          *(_QWORD *)&v6.st_gid = "Exists";
          *((_WORD *)&v6.st_rdev + 2) = 2048;
          *(_QWORD *)((char *)&v6.st_rdev + 6) = this;
          _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", (uint8_t *)&v6, 0x26u);
        }
      }
    }
  }
  return v3;
}

void TFileBSD::Create(TFileBSD *this)
{
  NSObject *v2;
  const char *v3;
  FILE *v4;
  NSObject *v5;
  int v6;
  CAXException *exception;
  int v8;
  CAXException *v9;
  _BYTE v10[16];
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v2 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315906;
    v12 = "TFileBSD.cpp";
    v13 = 1024;
    v14 = 262;
    v15 = 2080;
    v16 = "Create";
    v17 = 2048;
    v18 = (const char *)this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", buf, 0x26u);
  }
LABEL_7:
  if (((*(uint64_t (**)(TFileBSD *))(*(_QWORD *)this + 80))(this) & 1) == 0)
  {
    v3 = (const char *)*((_QWORD *)this + 1);
    if (v3)
    {
      v4 = fopen(v3, "w+b");
      if (!v4)
      {
        v6 = *__error() + 100000;
        if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
        {
          CAX4CCString::CAX4CCString((CAX4CCString *)v10, v6);
          *(_DWORD *)buf = 136315906;
          v12 = "TFileBSD.cpp";
          v13 = 1024;
          v14 = 268;
          v15 = 2080;
          v16 = v10;
          v17 = 2080;
          v18 = "Create::fopen failed";
          _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
        }
        exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
        CAXException::CAXException(exception, "Create::fopen failed", v6);
      }
      if (fclose(v4))
      {
        v8 = *__error() + 100000;
        if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
        {
          CAX4CCString::CAX4CCString((CAX4CCString *)v10, v8);
          *(_DWORD *)buf = 136315906;
          v12 = "TFileBSD.cpp";
          v13 = 1024;
          v14 = 269;
          v15 = 2080;
          v16 = v10;
          v17 = 2080;
          v18 = "Create::fclose failed";
          _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
        }
        v9 = (CAXException *)__cxa_allocate_exception(0x110uLL);
        CAXException::CAXException(v9, "Create::fclose failed", v8);
      }
    }
  }
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v5 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          v12 = "TFileBSD.cpp";
          v13 = 1024;
          v14 = 281;
          v15 = 2080;
          v16 = "Create";
          v17 = 2048;
          v18 = (const char *)this;
          _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", buf, 0x26u);
        }
      }
    }
  }
}

void sub_1B65C8030(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void TFileBSD::DeleteFile(const std::__fs::filesystem::path **this)
{
  NSObject *v2;
  std::error_code *v3;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  const std::__fs::filesystem::path **v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v2 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v5 = 136315906;
    v6 = "TFileBSD.cpp";
    v7 = 1024;
    v8 = 290;
    v9 = 2080;
    v10 = "DeleteFile";
    v11 = 2048;
    v12 = this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", (uint8_t *)&v5, 0x26u);
  }
LABEL_7:
  if (((unsigned int (*)(const std::__fs::filesystem::path **))(*this)[5].__pn_.__r_.__value_.__l.__data_)(this))
    ((void (*)(const std::__fs::filesystem::path **))(*this)[4].__pn_.__r_.__value_.__r.__words[2])(this);
  remove(this[1], v3);
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v4 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          v5 = 136315906;
          v6 = "TFileBSD.cpp";
          v7 = 1024;
          v8 = 301;
          v9 = 2080;
          v10 = "DeleteFile";
          v11 = 2048;
          v12 = this;
          _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", (uint8_t *)&v5, 0x26u);
        }
      }
    }
  }
}

void TFileBSD::Open(const char **this, unsigned int a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  FILE *v7;
  NSObject *v8;
  CAXException *v9;
  CAXException *exception;
  int v11;
  CAXException *v12;
  _BYTE v13[16];
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v4 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v4 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315906;
    v15 = "TFileBSD.cpp";
    v16 = 1024;
    v17 = 310;
    v18 = 2080;
    v19 = "Open";
    v20 = 2048;
    v21 = (const char *)this;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", buf, 0x26u);
  }
LABEL_7:
  if (((*((uint64_t (**)(const char **))*this + 15))(this) & 1) == 0)
  {
    if (a2 >= 2)
    {
      if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
      {
        CAX4CCString::CAX4CCString((CAX4CCString *)v13, 0xFFFFFFCE);
        *(_DWORD *)buf = 136315906;
        v15 = "TFileBSD.cpp";
        v16 = 1024;
        v17 = 315;
        v18 = 2080;
        v19 = v13;
        v20 = 2080;
        v21 = "Open - file open invalid file permission";
        _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
      }
      exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
      CAXException::CAXException(exception, "Open - file open invalid file permission", -50);
    }
    if (access(this[1], 2 * (a2 != 0)))
    {
      v5 = *__error();
      if (v5 == 13 || v5 == 1)
      {
        if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
        {
          CAX4CCString::CAX4CCString((CAX4CCString *)v13, 0xFFFFFFCA);
          *(_DWORD *)buf = 136315906;
          v15 = "TFileBSD.cpp";
          v16 = 1024;
          v17 = 321;
          v18 = 2080;
          v19 = v13;
          v20 = 2080;
          v21 = "Open: Permission denied";
          _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
        }
        v9 = (CAXException *)__cxa_allocate_exception(0x110uLL);
        CAXException::CAXException(v9, "Open: Permission denied", -54);
      }
    }
    if (a2)
      v6 = "r+b";
    else
      v6 = "rb";
    v7 = fopen(this[1], v6);
    this[2] = (const char *)v7;
    if (!v7)
    {
      v11 = *__error() + 100000;
      if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
      {
        CAX4CCString::CAX4CCString((CAX4CCString *)v13, v11);
        *(_DWORD *)buf = 136315906;
        v15 = "TFileBSD.cpp";
        v16 = 1024;
        v17 = 327;
        v18 = 2080;
        v19 = v13;
        v20 = 2080;
        v21 = "Open::fopen failed";
        _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
      }
      v12 = (CAXException *)__cxa_allocate_exception(0x110uLL);
      CAXException::CAXException(v12, "Open::fopen failed", v11);
    }
    if ((uint64_t)this[4] >= 1)
      (*((void (**)(const char **, _QWORD))*this + 5))(this, 0);
    this[5] = (const char *)(*((uint64_t (**)(const char **))*this + 9))(this);
  }
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v8 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          v15 = "TFileBSD.cpp";
          v16 = 1024;
          v17 = 338;
          v18 = 2080;
          v19 = "Open";
          v20 = 2048;
          v21 = (const char *)this;
          _os_log_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", buf, 0x26u);
        }
      }
    }
  }
}

void sub_1B65C8688(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void TFileBSD::Close(TFileBSD *this)
{
  NSObject *v2;
  FILE *v3;
  NSObject *v4;
  int v5;
  CAXException *exception;
  _BYTE v7[16];
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v2 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315906;
    v9 = "TFileBSD.cpp";
    v10 = 1024;
    v11 = 347;
    v12 = 2080;
    v13 = "Close";
    v14 = 2048;
    v15 = (const char *)this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", buf, 0x26u);
  }
LABEL_7:
  v3 = (FILE *)*((_QWORD *)this + 2);
  if (v3 && fclose(v3))
  {
    v5 = *__error() + 100000;
    if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
    {
      CAX4CCString::CAX4CCString((CAX4CCString *)v7, v5);
      *(_DWORD *)buf = 136315906;
      v9 = "TFileBSD.cpp";
      v10 = 1024;
      v11 = 351;
      v12 = 2080;
      v13 = v7;
      v14 = 2080;
      v15 = "Close::fclose failed";
      _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d about to throw %s: %s", buf, 0x26u);
    }
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "Close::fclose failed", v5);
  }
  *((_QWORD *)this + 2) = 0;
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v4 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          v9 = "TFileBSD.cpp";
          v10 = 1024;
          v11 = 354;
          v12 = 2080;
          v13 = "Close";
          v14 = 2048;
          v15 = (const char *)this;
          _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", buf, 0x26u);
        }
      }
    }
  }
}

void sub_1B65C8918(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL TFileBSD::IsOpen(TFileBSD *this)
{
  return *((_QWORD *)this + 2) != 0;
}

void TFileBSD::Clear(FILE **this)
{
  NSObject *v2;
  int v3;
  int v4;
  NSObject *v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  FILE **v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (kTFileBSDSubsystem)
  {
    v2 = *(NSObject **)kTFileBSDSubsystem;
    if (!*(_QWORD *)kTFileBSDSubsystem)
      goto LABEL_7;
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v6 = 136315906;
    v7 = "TFileBSD.cpp";
    v8 = 1024;
    v9 = 571;
    v10 = 2080;
    v11 = "Clear";
    v12 = 2048;
    v13 = this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %p", (uint8_t *)&v6, 0x26u);
  }
LABEL_7:
  if ((((uint64_t (*)(FILE **))(*this)->_lb._base)(this) & 1) != 0)
  {
    v3 = fileno(this[2]);
    ftruncate(v3, 0);
  }
  else
  {
    ((void (*)(FILE **, uint64_t))(*this)->_extra)(this, 1);
    v4 = fileno(this[2]);
    ftruncate(v4, 0);
    (*(void (**)(FILE **))&(*this)->_ur)(this);
  }
  this[3] = 0;
  this[4] = 0;
  if (kTFileBSDSubsystem)
  {
    if ((*(_BYTE *)(kTFileBSDSubsystem + 8) & 1) != 0)
    {
      v5 = *(NSObject **)kTFileBSDSubsystem;
      if (*(_QWORD *)kTFileBSDSubsystem)
      {
        if (os_log_type_enabled(*(os_log_t *)kTFileBSDSubsystem, OS_LOG_TYPE_DEBUG))
        {
          v6 = 136315906;
          v7 = "TFileBSD.cpp";
          v8 = 1024;
          v9 = 589;
          v10 = 2080;
          v11 = "Clear";
          v12 = 2048;
          v13 = this;
          _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s %p", (uint8_t *)&v6, 0x26u);
        }
      }
    }
  }
}

void sub_1B65C8D04(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9, __int128 a10)
{
  uint64_t v10;
  NSObject **v11;
  NSObject *v12;

  if (!a2)
    _Unwind_Resume(a1);
  __cxa_begin_catch(a1);
  v11 = *(NSObject ***)(v10 + 1400);
  if (v11)
  {
    v12 = *v11;
    if (!*v11)
      goto LABEL_8;
  }
  else
  {
    v12 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    LODWORD(a9) = 136315906;
    *(_QWORD *)((char *)&a9 + 4) = "TFileBSD.cpp";
    WORD6(a9) = 1024;
    *(_DWORD *)((char *)&a9 + 14) = 138;
    WORD1(a10) = 2080;
    *(_QWORD *)((char *)&a10 + 4) = "~TFileBSD";
    WORD6(a10) = 2048;
    _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_INFO, "%25s:%-5d <-%s %p: Swallowed exception from Close()", (uint8_t *)&a9, 0x26u);
  }
LABEL_8:
  __cxa_end_catch();
  JUMPOUT(0x1B65C8C2CLL);
}

os_log_t ___ZN8TFileBSDC2EPK7__CFURL_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "tfbsd");
  *v0 = result;
  kTFileBSDSubsystem = (uint64_t)v0;
  return result;
}

void CADeprecated::AudioRingBuffer::~AudioRingBuffer(CADeprecated::AudioRingBuffer *this)
{
  CADeprecated::AudioRingBuffer::~AudioRingBuffer(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E69EE198;
  CADeprecated::AudioRingBuffer::Deallocate(this);
  v2 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v2)
    MEMORY[0x1BCC95CEC](v2, 0x1080C404ACF7207);
  v3 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v3)
    MEMORY[0x1BCC95CEC](v3, 0x1080C404ACF7207);
}

OpaqueAudioConverter *CADeprecated::AudioRingBuffer::Deallocate(CADeprecated::AudioRingBuffer *this)
{
  void *v2;
  OpaqueAudioConverter *result;

  v2 = (void *)*((_QWORD *)this + 13);
  if (v2)
  {
    free(v2);
    *((_QWORD *)this + 13) = 0;
  }
  *((_DWORD *)this + 28) = 0;
  *((_QWORD *)this + 15) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  result = (OpaqueAudioConverter *)*((_QWORD *)this + 16);
  if (result)
  {
    result = (OpaqueAudioConverter *)AudioConverterDispose(result);
    *((_QWORD *)this + 16) = 0;
  }
  return result;
}

_DWORD *CADeprecated::AudioRingBuffer::Allocate(CADeprecated::AudioRingBuffer *this, const CAStreamBasicDescription *a2, int a3)
{
  int v6;
  uint64_t v7;
  size_t v8;
  char *v9;
  BOOL v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t i;
  char *v16;
  __int128 v17;
  __int128 v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  _DWORD *result;
  _QWORD *v24;
  uint64_t v25;
  std::bad_alloc *exception;
  std::bad_alloc *v27;

  v6 = *((_DWORD *)a2 + 6);
  if ((*((_DWORD *)a2 + 3) & 0x20) != 0)
    v7 = *((unsigned int *)a2 + 7);
  else
    v7 = 1;
  CADeprecated::AudioRingBuffer::Deallocate(this);
  *((_DWORD *)this + 28) = v7;
  *((_DWORD *)this + 29) = v6;
  *((_DWORD *)this + 30) = a3;
  *((_DWORD *)this + 31) = v6 * a3;
  v8 = ((v6 * a3 + 8) * v7);
  v9 = (char *)malloc_type_malloc(v8, 0x7C51E058uLL);
  if ((_DWORD)v8)
    v10 = v9 == 0;
  else
    v10 = 0;
  if (v10)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v27 = std::bad_alloc::bad_alloc(exception);
  }
  v11 = v9;
  bzero(v9, v8);
  *((_QWORD *)this + 13) = v11;
  if ((int)v7 > 0)
  {
    v12 = 0;
    v13 = &v11[8 * v7];
    v14 = *((unsigned int *)this + 31);
    do
    {
      *(_QWORD *)(*((_QWORD *)this + 13) + 8 * v12) = v13;
      v13 += v14;
      ++v12;
    }
    while (v7 != v12);
  }
  for (i = 0; i != 768; i += 24)
  {
    v16 = (char *)this + i;
    *((_QWORD *)v16 + 17) = 0;
    *((_QWORD *)v16 + 18) = 0;
    *((_DWORD *)v16 + 38) = 0;
  }
  *((_DWORD *)this + 226) = 0;
  *((_BYTE *)this + 908) = 1;
  v17 = *(_OWORD *)a2;
  v18 = *((_OWORD *)a2 + 1);
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 4);
  *(_OWORD *)((char *)this + 24) = v18;
  *(_OWORD *)((char *)this + 8) = v17;
  v19 = *((_DWORD *)a2 + 3);
  v20 = *((_DWORD *)a2 + 7);
  if ((v19 & 0x20) != 0)
    v21 = v20;
  else
    v21 = 1;
  if ((v19 & 0x20) != 0)
    v22 = 1;
  else
    v22 = v20;
  result = malloc_type_malloc(16 * (v21 - 1) + 24, 0xCBF08C5DuLL);
  *result = v21;
  if ((_DWORD)v21)
  {
    v24 = result + 4;
    do
    {
      *((_DWORD *)v24 - 2) = v22;
      *((_DWORD *)v24 - 1) = 0;
      *v24 = 0;
      v24 += 2;
      --v21;
    }
    while (v21);
  }
  v25 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = result;
  if (v25)
    JUMPOUT(0x1BCC95CECLL);
  return result;
}

uint64_t CADeprecated::AudioRingBuffer::ConvertAndStore(uint64_t this, int a2, const AudioBufferList *a3, int a4, UInt32 inNumberPCMFrames)
{
  const AudioBufferList *v6;
  uint64_t mNumberBuffers;
  UInt32 v8;
  void **p_mData;
  void **v10;
  char *v11;
  AudioBufferList *v12;
  uint64_t v13;
  UInt32 v14;
  uint64_t *v15;
  void **v16;
  uint64_t v17;

  if (inNumberPCMFrames)
  {
    v6 = *(const AudioBufferList **)(this + 96);
    mNumberBuffers = v6->mNumberBuffers;
    if ((_DWORD)mNumberBuffers)
    {
      v8 = *(_DWORD *)(this + 72) * inNumberPCMFrames;
      p_mData = &v6->mBuffers[0].mData;
      v10 = &a3->mBuffers[0].mData;
      do
      {
        v11 = (char *)*v10;
        v10 += 2;
        *p_mData = &v11[a4];
        *((_DWORD *)p_mData - 1) = v8;
        p_mData += 2;
        --mNumberBuffers;
      }
      while (mNumberBuffers);
    }
    v12 = *(AudioBufferList **)(this + 88);
    v13 = v12->mNumberBuffers;
    if ((_DWORD)v13)
    {
      v14 = *(_DWORD *)(this + 32) * inNumberPCMFrames;
      v15 = *(uint64_t **)(this + 104);
      v16 = &v12->mBuffers[0].mData;
      do
      {
        v17 = *v15++;
        *v16 = (void *)(v17 + a2);
        *((_DWORD *)v16 - 1) = v14;
        v16 += 2;
        --v13;
      }
      while (v13);
    }
    return AudioConverterConvertComplexBuffer(*(AudioConverterRef *)(this + 128), inNumberPCMFrames, v6, v12);
  }
  return this;
}

uint64_t CADeprecated::AudioRingBuffer::Store(CADeprecated::AudioRingBuffer *this, const AudioBufferList *a2, unsigned int a3, uint64_t a4)
{
  CADeprecated::AudioRingBuffer *v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v10;
  unsigned int *v11;
  int v12;
  char *v13;
  uint64_t *v14;
  uint64_t v15;
  char *v16;
  unsigned int v17;
  void **v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  size_t v26;
  unsigned int v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  unsigned int v33;
  char *v34;
  unsigned int v35;
  char v36;
  uint64_t v37;
  size_t v38;
  unsigned int v39;
  uint64_t *v40;
  uint64_t v41;
  unsigned int v42;
  void **v43;
  void *v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  const AudioBufferList *v50;
  int v51;
  UInt32 v52;
  UInt32 v53;
  int v54;
  uint64_t v55;
  unsigned int v56;
  char v57;
  UInt32 v58;
  uint64_t v59;
  size_t v60;
  void **v61;
  unsigned int v62;
  uint64_t v63;
  void *v64;
  void *v65;
  uint64_t v66;
  size_t v67;
  UInt32 v68;
  uint64_t v69;
  void **v70;
  uint64_t v71;
  UInt32 mNumberBuffers;
  void **p_mData;
  unsigned int v74;
  void *v75;
  void *v76;
  char *v77;
  int v78;
  CADeprecated::AudioRingBuffer *v79;
  uint64_t v80;
  uint64_t v81;

  if (!a3)
    return 0;
  v5 = this;
  v6 = *((unsigned int *)this + 30);
  if (v6 < a3)
    return 3;
  v10 = a4 + a3;
  v11 = (unsigned int *)((char *)this + 904);
  v12 = *((_DWORD *)this + 226);
  v13 = (char *)this + 24 * (v12 & 0x1F);
  v15 = *((_QWORD *)v13 + 18);
  v14 = (uint64_t *)(v13 + 144);
  if (v15 > a4 || *((_BYTE *)this + 908) && *((_BYTE *)this + 909))
  {
    v16 = (char *)this + 24 * ((v12 + 1) & 0x1F);
    *((_QWORD *)v16 + 17) = a4;
    *((_QWORD *)v16 + 18) = a4;
    *((_DWORD *)v16 + 38) = v12 + 1;
    while (1)
    {
      v17 = __ldaxr(v11);
      if (v17 != v12)
        break;
      if (!__stlxr(v12 + 1, v11))
        goto LABEL_13;
    }
    __clrex();
    *v11 = v17;
LABEL_13:
    *((_BYTE *)this + 908) = 0;
  }
  else if (v10 - *((_QWORD *)this + 3 * (v12 & 0x1F) + 17) > v6)
  {
    v30 = v10 - v6;
    v31 = *v14;
    v32 = v30 <= *v14;
    v33 = v12 + 1;
    v34 = (char *)this + 24 * ((v12 + 1) & 0x1F);
    *((_QWORD *)v34 + 17) = v30;
    if (v32)
      v30 = v31;
    *((_QWORD *)v34 + 18) = v30;
    *((_DWORD *)v34 + 38) = v33;
    while (1)
    {
      v35 = __ldaxr(v11);
      if (v35 != v12)
        break;
      if (!__stlxr(v33, v11))
      {
        v36 = 1;
        goto LABEL_62;
      }
    }
    v36 = 0;
    __clrex();
LABEL_62:
    if ((v36 & 1) == 0)
      *v11 = v35;
  }
  v18 = (void **)*((_QWORD *)this + 13);
  v19 = *((_QWORD *)this + 3 * (*((_DWORD *)this + 226) & 0x1F) + 18);
  v20 = *((int *)this + 30);
  v22 = *((_DWORD *)this + 28);
  v21 = *((_DWORD *)this + 29);
  if (v19 >= a4)
  {
    v24 = ((v20 & ((int)(a4 % v20) >> 31)) + a4 % v20) * v21;
    goto LABEL_36;
  }
  v80 = a4 + a3;
  v23 = ((v20 & ((int)(v19 % v20) >> 31)) + v19 % v20) * v21;
  v24 = ((v20 & ((int)(a4 % v20) >> 31)) + a4 % v20) * v21;
  if (v24 <= v23)
  {
    if (v22 >= 1)
    {
      v79 = this;
      v37 = v23;
      v38 = *((_DWORD *)this + 31) - v23;
      v78 = *((_DWORD *)this + 28);
      v39 = v22 + 1;
      v40 = (uint64_t *)*((_QWORD *)this + 13);
      do
      {
        v41 = *v40++;
        bzero((void *)(v41 + v37), v38);
        --v39;
      }
      while (v39 > 1);
      v42 = v78 + 1;
      v43 = v18;
      do
      {
        v44 = *v43++;
        bzero(v44, v24);
        --v42;
      }
      while (v42 > 1);
      goto LABEL_34;
    }
  }
  else if (v22 >= 1)
  {
    v79 = this;
    v25 = v23;
    v26 = v24 - v23;
    v27 = v22 + 1;
    v28 = (uint64_t *)*((_QWORD *)this + 13);
    do
    {
      v29 = *v28++;
      bzero((void *)(v29 + v25), v26);
      --v27;
    }
    while (v27 > 1);
LABEL_34:
    v5 = v79;
  }
  v10 = v80;
LABEL_36:
  v45 = *((int *)v5 + 30);
  v46 = ((v45 & ((int)(v10 % v45) >> 31)) + v10 % v45) * *((_DWORD *)v5 + 29);
  v47 = *((_QWORD *)v5 + 16);
  if (v46 <= v24)
  {
    if (v47)
    {
      v53 = v45 - a4 % v45 - (v45 & ((int)(a4 % v45) >> 31));
      CADeprecated::AudioRingBuffer::ConvertAndStore((uint64_t)v5, v24, a2, 0, v53);
      v51 = v53 * *((_DWORD *)v5 + 18);
      v52 = (*((_DWORD *)v5 + 30) & ((int)(v10 % *((int *)v5 + 30)) >> 31)) + v10 % *((int *)v5 + 30);
      v48 = (uint64_t)v5;
      v49 = 0;
      v50 = a2;
      goto LABEL_41;
    }
    if ((int)a2->mNumberBuffers >= 1)
    {
      v81 = v10;
      v66 = v24;
      v67 = *((_DWORD *)v5 + 31) - v24;
      v68 = a2->mNumberBuffers + 1;
      v69 = 16;
      v70 = v18;
      do
      {
        v71 = (uint64_t)*v70++;
        memcpy((void *)(v71 + v66), *(const void **)((char *)&a2->mNumberBuffers + v69), v67);
        v69 += 16;
        --v68;
      }
      while (v68 > 1);
      mNumberBuffers = a2->mNumberBuffers;
      v10 = v81;
      if ((int)a2->mNumberBuffers >= 1)
      {
        p_mData = &a2->mBuffers[0].mData;
        v74 = mNumberBuffers + 1;
        do
        {
          v76 = *v18++;
          v75 = v76;
          v77 = (char *)*p_mData;
          p_mData += 2;
          memcpy(v75, &v77[v67], v46);
          --v74;
        }
        while (v74 > 1);
      }
    }
  }
  else
  {
    if (v47)
    {
      v48 = (uint64_t)v5;
      v49 = v24;
      v50 = a2;
      v51 = 0;
      v52 = a3;
LABEL_41:
      CADeprecated::AudioRingBuffer::ConvertAndStore(v48, v49, v50, v51, v52);
      goto LABEL_42;
    }
    v58 = a2->mNumberBuffers;
    if ((int)a2->mNumberBuffers >= 1)
    {
      v59 = v24;
      v60 = v46 - v24;
      v61 = &a2->mBuffers[0].mData;
      v62 = v58 + 1;
      do
      {
        v63 = (uint64_t)*v18++;
        v64 = (void *)(v63 + v59);
        v65 = *v61;
        v61 += 2;
        memcpy(v64, v65, v60);
        --v62;
      }
      while (v62 > 1);
    }
  }
LABEL_42:
  v54 = *((_DWORD *)v5 + 226);
  v55 = (uint64_t)v5 + 24 * ((v54 + 1) & 0x1F) + 136;
  *(_QWORD *)v55 = *((_QWORD *)v5 + 3 * (v54 & 0x1F) + 17);
  *(_QWORD *)(v55 + 8) = v10;
  *(_DWORD *)(v55 + 16) = v54 + 1;
  while (1)
  {
    v56 = __ldaxr(v11);
    if (v56 != v54)
      break;
    if (!__stlxr(v54 + 1, v11))
    {
      v57 = 1;
      goto LABEL_47;
    }
  }
  v57 = 0;
  __clrex();
LABEL_47:
  result = 0;
  if ((v57 & 1) == 0)
    *v11 = v56;
  return result;
}

uint64_t CADeprecated::AudioRingBuffer::CheckTimeBounds(CADeprecated::AudioRingBuffer *this, uint64_t a2, uint64_t a3)
{
  int v3;
  char *v4;
  uint64_t *v5;
  uint64_t *v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v12;
  int v13;
  unsigned int v14;

  v3 = *((_DWORD *)this + 226);
  v4 = (char *)this + 24 * (v3 & 0x1F);
  v5 = (uint64_t *)(v4 + 136);
  v6 = (uint64_t *)(v4 + 144);
  v7 = v4 + 152;
  v8 = 8;
  while (1)
  {
    v9 = *v5;
    v10 = *v6;
    if (*v7 == v3)
      break;
    if (!--v8)
      return 4;
  }
  if (v10 > a2)
    v12 = 1;
  else
    v12 = 2;
  if (v10 >= a3)
    v12 = 0;
  if (v9 >= a3)
    v13 = -2;
  else
    v13 = -1;
  if (v10 >= a3)
    v14 = v13;
  else
    v14 = 3;
  if (v9 > a2)
    return v14;
  else
    return v12;
}

uint64_t CADeprecated::AudioRingBuffer::Fetch(const void ***this, AudioBufferList *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t result;
  const void **v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  signed int v15;
  uint64_t v16;
  void **v17;
  UInt32 v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  UInt32 v23;
  uint64_t v24;
  const void **v25;
  uint64_t v26;
  void **p_mData;
  UInt32 v28;
  char *v29;
  char *v30;
  const void *v31;
  UInt32 *p_mDataByteSize;
  UInt32 v33;
  uint64_t v34;
  int v35;

  v8 = a4 + a3;
  result = CADeprecated::AudioRingBuffer::CheckTimeBounds((CADeprecated::AudioRingBuffer *)this, a4, v8);
  if (!(_DWORD)result)
  {
    if (a3)
    {
      v10 = this[13];
      v11 = *((_DWORD *)this + 29);
      v12 = *((int *)this + 30);
      v13 = ((v12 & ((int)(a4 % v12) >> 31)) + a4 % v12) * v11;
      v14 = ((v12 & ((int)(v8 % v12) >> 31)) + v8 % v12) * v11;
      v15 = v14 - v13;
      if (v14 <= v13)
      {
        v35 = *((_DWORD *)this + 31) - v13;
        if ((int)a2->mNumberBuffers >= 1)
        {
          v34 = v8;
          v22 = v13;
          v23 = a2->mNumberBuffers + 1;
          v24 = 16;
          v25 = this[13];
          do
          {
            v26 = (uint64_t)*v25++;
            memcpy(*(void **)((char *)&a2->mNumberBuffers + v24), (const void *)(v26 + v22), v35);
            v24 += 16;
            --v23;
          }
          while (v23 > 1);
          v8 = v34;
          if ((int)a2->mNumberBuffers >= 1)
          {
            p_mData = &a2->mBuffers[0].mData;
            v28 = a2->mNumberBuffers + 1;
            do
            {
              v29 = (char *)*p_mData;
              p_mData += 2;
              v30 = &v29[v35];
              v31 = *v10++;
              memcpy(v30, v31, v14);
              --v28;
            }
            while (v28 > 1);
          }
        }
        v15 = v35 + v14;
      }
      else
      {
        if ((int)a2->mNumberBuffers < 1)
          return CADeprecated::AudioRingBuffer::CheckTimeBounds((CADeprecated::AudioRingBuffer *)this, a4, v8);
        v16 = v13;
        v17 = &a2->mBuffers[0].mData;
        v18 = a2->mNumberBuffers + 1;
        do
        {
          v20 = *v17;
          v17 += 2;
          v19 = v20;
          v21 = (uint64_t)*v10++;
          memcpy(v19, (const void *)(v21 + v16), v15);
          --v18;
        }
        while (v18 > 1);
      }
    }
    else
    {
      v15 = 0;
    }
    if ((int)a2->mNumberBuffers >= 1)
    {
      p_mDataByteSize = &a2->mBuffers[0].mDataByteSize;
      v33 = a2->mNumberBuffers + 1;
      do
      {
        *p_mDataByteSize = v15;
        p_mDataByteSize += 4;
        --v33;
      }
      while (v33 > 1);
    }
    return CADeprecated::AudioRingBuffer::CheckTimeBounds((CADeprecated::AudioRingBuffer *)this, a4, v8);
  }
  return result;
}

const __CFArray *CACFArray::GetCFType(CFArrayRef *this, unsigned int a2, const void **a3)
{
  const __CFArray *result;
  const void *ValueAtIndex;

  result = *this;
  if (result)
  {
    if (CFArrayGetCount(result) <= a2)
    {
      return 0;
    }
    else
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*this, a2);
      *a3 = ValueAtIndex;
      return (const __CFArray *)(ValueAtIndex != 0);
    }
  }
  return result;
}

uint64_t CACFArray::GetFloat32(CFArrayRef *this, unsigned int a2, float *a3)
{
  uint64_t result;
  const __CFNumber *v5;
  CFTypeID v6;
  CFTypeRef cf;

  cf = 0;
  result = (uint64_t)CACFArray::GetCFType(this, a2, &cf);
  if ((_DWORD)result)
  {
    v5 = (const __CFNumber *)cf;
    if (cf)
    {
      v6 = CFGetTypeID(cf);
      result = CFNumberGetTypeID();
      if (v6 == result)
        return CFNumberGetValue(v5, kCFNumberFloat32Type, a3);
    }
  }
  return result;
}

uint64_t CACFArray::GetFloat64(CFArrayRef *this, unsigned int a2, double *a3)
{
  uint64_t result;
  const __CFNumber *v5;
  CFTypeID v6;
  CFTypeRef cf;

  cf = 0;
  result = (uint64_t)CACFArray::GetCFType(this, a2, &cf);
  if ((_DWORD)result)
  {
    v5 = (const __CFNumber *)cf;
    if (cf)
    {
      v6 = CFGetTypeID(cf);
      result = CFNumberGetTypeID();
      if (v6 == result)
        return CFNumberGetValue(v5, kCFNumberFloat64Type, a3);
    }
  }
  return result;
}

uint64_t CACFArray::GetCACFString(CFArrayRef *this, unsigned int a2, CFTypeRef *a3)
{
  uint64_t result;
  CFTypeRef v7;
  CFTypeID v8;
  CFTypeRef cf;

  if (*a3)
  {
    if (*((_BYTE *)a3 + 8))
      CFRelease(*a3);
    *a3 = 0;
  }
  *((_BYTE *)a3 + 8) = 1;
  cf = 0;
  result = (uint64_t)CACFArray::GetCFType(this, a2, &cf);
  if ((_DWORD)result)
  {
    v7 = cf;
    if (cf)
    {
      v8 = CFGetTypeID(cf);
      result = CFStringGetTypeID();
      if (v8 == result)
        return CACFString::operator=((uint64_t)a3, v7);
    }
  }
  return result;
}

uint64_t CACFArray::GetCACFArray(CFArrayRef *this, unsigned int a2, CACFArray *a3)
{
  uint64_t result;
  CFTypeRef v7;
  CFTypeID v8;
  CFTypeRef cf;

  CACFDictionary::operator=((uint64_t)a3, 0);
  cf = 0;
  result = (uint64_t)CACFArray::GetCFType(this, a2, &cf);
  if ((_DWORD)result)
  {
    v7 = cf;
    if (cf)
    {
      v8 = CFGetTypeID(cf);
      result = CFArrayGetTypeID();
      if (v8 == result)
        return CACFDictionary::operator=((uint64_t)a3, v7);
    }
  }
  return result;
}

uint64_t CACFArray::GetCACFDictionary(CFArrayRef *this, unsigned int a2, CACFDictionary *a3)
{
  uint64_t result;
  CFTypeRef v7;
  CFTypeID v8;
  CFTypeRef cf;

  CACFDictionary::operator=((uint64_t)a3, 0);
  cf = 0;
  result = (uint64_t)CACFArray::GetCFType(this, a2, &cf);
  if ((_DWORD)result)
  {
    v7 = cf;
    if (cf)
    {
      v8 = CFGetTypeID(cf);
      result = CFDictionaryGetTypeID();
      if (v8 == result)
        return CACFDictionary::operator=((uint64_t)a3, v7);
    }
  }
  return result;
}

void CACFArray::AppendFloat32(CFMutableArrayRef *this, float a2)
{
  CFNumberRef v3;
  _QWORD v4[2];
  float valuePtr;

  if (*this && *((_BYTE *)this + 9))
  {
    v4[1] = 1;
    valuePtr = a2;
    v3 = CFNumberCreate(0, kCFNumberFloat32Type, &valuePtr);
    v4[0] = v3;
    if (v3 && *this)
    {
      if (*((_BYTE *)this + 9))
        CFArrayAppendValue(*this, v3);
    }
    CACFNumber::~CACFNumber((CACFNumber *)v4);
  }
}

void sub_1B65C9B70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CACFNumber::~CACFNumber((CACFNumber *)va);
  _Unwind_Resume(a1);
}

uint64_t *CASmartPreferences::instance(CASmartPreferences *this)
{
  unsigned __int8 v1;
  CASmartPreferences *v3;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v3)
    {
      CASmartPreferences::CASmartPreferences(v3);
    }
  }
  return &CASmartPreferences::instance(void)::global;
}

void sub_1B65C9BD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CASmartPreferences::CASmartPreferences(CASmartPreferences *this)
{
  NSObject *global_queue;
  _QWORD handler[5];

  CASmartPreferences::instance(void)::global = 850045863;
  unk_1EF137588 = 0u;
  unk_1EF137598 = 0u;
  unk_1EF1375A8 = 0u;
  qword_1EF1375B8 = 0;
  qword_1EF1375C0 = (uint64_t)CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  global_queue = dispatch_get_global_queue(0, 0);
  *(_OWORD *)algn_1EF1375C8 = 0u;
  *(_OWORD *)&algn_1EF1375C8[16] = 0u;
  qword_1EF1375E0 = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DC0], 1uLL, 0, global_queue);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = ___ZN18CASmartPreferencesC2Ev_block_invoke;
  handler[3] = &__block_descriptor_tmp_25506;
  handler[4] = &CASmartPreferences::instance(void)::global;
  dispatch_source_set_event_handler((dispatch_source_t)qword_1EF1375E0, handler);
  dispatch_resume((dispatch_object_t)qword_1EF1375E0);
}

void sub_1B65C9CC4(_Unwind_Exception *a1)
{
  std::mutex::~mutex((std::mutex *)&CASmartPreferences::instance(void)::global);
  _Unwind_Resume(a1);
}

void ___ZN18CASmartPreferencesC2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1;
  CFStringRef *v2;
  CFStringRef *v3;

  v1 = *(_QWORD *)(a1 + 32);
  std::mutex::lock((std::mutex *)v1);
  CFSetApplyFunction(*(CFSetRef *)(v1 + 64), (CFSetApplierFunction)SynchronizePrefDomain, 0);
  v2 = *(CFStringRef **)(v1 + 72);
  v3 = *(CFStringRef **)(v1 + 80);
  while (v2 != v3)
  {
    CASmartPreferences::Pref::Load(v2);
    v2 += 6;
  }
  std::mutex::unlock((std::mutex *)v1);
}

void sub_1B65C9D3C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t SynchronizePrefDomain(const __CFString *a1, void *a2)
{
  return CFPreferencesSynchronize(a1, (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
}

CFPropertyListRef CASmartPreferences::Pref::Load(CFStringRef *this)
{
  CFPropertyListRef result;
  CFStringRef v3;
  CFPropertyListRef v4;

  result = CFPreferencesCopyAppValue(*this, this[1]);
  if (result)
  {
    v4 = result;
    v3 = this[5];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (CFPropertyListRef)(*((uint64_t (**)(CFStringRef, CFPropertyListRef *))v3->isa + 6))(v3, &v4);
  }
  return result;
}

double CACFPreferencesGetAppFloatValue(const __CFString *a1, const __CFString *a2, BOOL *a3)
{
  const __CFString *v4;
  BOOL *v5;
  const __CFString *v6;
  BOOL *v7;
  double v8;
  char v10;

  v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  v6 = v4;
  if (a3)
    v7 = a3;
  else
    v7 = (BOOL *)&v10;
  v8 = CASmartPreferences::InterpretFloat(v4, v7, v5);
  if (v6)
    CFRelease(v6);
  return v8;
}

double CASmartPreferences::InterpretFloat(const __CFString *this, _BYTE *a2, BOOL *a3)
{
  CFTypeID v5;
  double valuePtr;
  char buffer[16];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  valuePtr = 0.0;
  *a2 = 0;
  if (this)
  {
    v5 = CFGetTypeID(this);
    if (v5 == CFBooleanGetTypeID())
    {
      valuePtr = (double)CFBooleanGetValue((CFBooleanRef)this);
LABEL_6:
      *a2 = 1;
      return valuePtr;
    }
    if (v5 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)this, kCFNumberDoubleType, &valuePtr);
      goto LABEL_6;
    }
    if (v5 == CFStringGetTypeID())
    {
      v10 = 0u;
      v11 = 0u;
      *(_OWORD *)buffer = 0u;
      v9 = 0u;
      CFStringGetCString(this, buffer, 64, 0x600u);
      if (sscanf(buffer, "%lf", &valuePtr) == 1)
        goto LABEL_6;
    }
  }
  return valuePtr;
}

uint64_t CACFPreferencesGetAppIntegerValue(const __CFString *a1, const __CFString *a2, BOOL *a3)
{
  const __CFBoolean *v4;
  const __CFBoolean *v5;
  CFTypeID v6;
  uint64_t v7;
  int valuePtr;
  char buffer[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFBoolean *)CFPreferencesCopyAppValue(a1, a2);
  v5 = v4;
  valuePtr = 0;
  if (a3)
    *a3 = 0;
  if (v4)
  {
    v6 = CFGetTypeID(v4);
    if (v6 == CFBooleanGetTypeID())
    {
      valuePtr = CFBooleanGetValue(v5);
    }
    else if (v6 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
    }
    else if (v6 != CFStringGetTypeID()
           || (v12 = 0u,
               v13 = 0u,
               *(_OWORD *)buffer = 0u,
               v11 = 0u,
               CFStringGetCString((CFStringRef)v5, buffer, 64, 0x600u),
               sscanf(buffer, "%d", &valuePtr) != 1))
    {
LABEL_13:
      v7 = valuePtr;
      CFRelease(v5);
      return v7;
    }
    if (a3)
      *a3 = 1;
    goto LABEL_13;
  }
  return 0;
}

BOOL CACFPreferencesGetAppBooleanValue(const __CFString *a1, const __CFString *a2, BOOL *a3)
{
  CASmartPreferences *v4;
  BOOL *v5;
  CASmartPreferences *v6;
  BOOL *v7;
  _BOOL8 v8;
  char v10;

  v4 = (CASmartPreferences *)CFPreferencesCopyAppValue(a1, a2);
  v6 = v4;
  if (a3)
    v7 = a3;
  else
    v7 = (BOOL *)&v10;
  v8 = CASmartPreferences::InterpretBoolean(v4, v7, v5);
  if (v6)
    CFRelease(v6);
  return v8;
}

BOOL CASmartPreferences::InterpretBoolean(CASmartPreferences *this, _BYTE *a2, BOOL *a3)
{
  const __CFBoolean *v4;
  CFTypeID v5;
  char v7;
  char *v8;
  int v9;
  BOOL v10;
  int valuePtr;
  char buffer[16];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  *a2 = 0;
  if (this)
  {
    v4 = this;
    v5 = CFGetTypeID(this);
    if (v5 == CFBooleanGetTypeID())
    {
      LODWORD(this) = CFBooleanGetValue(v4);
LABEL_6:
      *a2 = 1;
      return (_DWORD)this != 0;
    }
    if (v5 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v4, kCFNumberIntType, &valuePtr);
      LODWORD(this) = valuePtr != 0;
      goto LABEL_6;
    }
    if (v5 != CFStringGetTypeID())
    {
      LODWORD(this) = 0;
      return (_DWORD)this != 0;
    }
    v14 = 0u;
    v15 = 0u;
    *(_OWORD *)buffer = 0u;
    v13 = 0u;
    CFStringGetCString((CFStringRef)v4, buffer, 64, 0x600u);
    if (sscanf(buffer, "%d", &valuePtr) == 1)
    {
      *a2 = 1;
      LODWORD(this) = valuePtr != 0;
      return (_DWORD)this != 0;
    }
    v7 = buffer[0];
    if (buffer[0])
    {
      v8 = &buffer[1];
      do
      {
        *(v8 - 1) = __tolower(v7);
        v9 = *v8++;
        v7 = v9;
      }
      while (v9);
    }
    if (!(*(unsigned __int16 *)buffer ^ 0x6F6E | buffer[2])
      || (*(_DWORD *)buffer == 1936482662 ? (v10 = *(unsigned __int16 *)&buffer[4] == 101) : (v10 = 0), v10))
    {
      LODWORD(this) = 0;
      goto LABEL_6;
    }
    if (*(_DWORD *)buffer == 7562617 || !(*(_DWORD *)buffer ^ 0x65757274 | buffer[4]))
    {
      LODWORD(this) = 1;
      *a2 = 1;
    }
    else
    {
      LODWORD(this) = valuePtr;
    }
  }
  return (_DWORD)this != 0;
}

void CASmartPreferences::_RegisterFirstHandler(uint64_t a1, const void *a2, const void *a3, _QWORD *a4)
{
  CFTypeRef *v8;
  CFTypeRef *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  int64x2_t v28;
  char *v29;
  char *v30;
  int64x2_t v31;
  char *v32;
  uint64_t v33;

  std::mutex::lock((std::mutex *)a1);
  v8 = *(CFTypeRef **)(a1 + 72);
  v9 = *(CFTypeRef **)(a1 + 80);
  while (v8 != v9)
  {
    if (CFEqual(a2, *v8) && CFEqual(a3, v8[1]))
      goto LABEL_31;
    v8 += 6;
  }
  CFRetain(a2);
  CFRetain(a3);
  v10 = *(_QWORD *)(a1 + 88);
  v11 = *(_QWORD *)(a1 + 80);
  if (v11 >= v10)
  {
    v13 = *(_QWORD *)(a1 + 72);
    v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v13) >> 4);
    if (v14 + 1 > 0x555555555555555)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v13) >> 4);
    v16 = 2 * v15;
    if (2 * v15 <= v14 + 1)
      v16 = v14 + 1;
    if (v15 >= 0x2AAAAAAAAAAAAAALL)
      v17 = 0x555555555555555;
    else
      v17 = v16;
    v33 = a1 + 88;
    if (v17)
    {
      if (v17 > 0x555555555555555)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v18 = (char *)operator new(48 * v17);
    }
    else
    {
      v18 = 0;
    }
    v30 = v18;
    v31.i64[0] = (uint64_t)&v18[48 * v14];
    v32 = &v18[48 * v17];
    std::construct_at[abi:ne180100]<CASmartPreferences::Pref,__CFString const*&,__CFString const*&,std::function<BOOL ()(void const*)> &,CASmartPreferences::Pref*>(v31.i64[0], (uint64_t)a2, (uint64_t)a3, a4);
    v19 = v31.i64[0];
    v12 = v31.i64[0] + 48;
    v31.i64[1] = v31.i64[0] + 48;
    v21 = *(_QWORD *)(a1 + 72);
    v20 = *(_QWORD *)(a1 + 80);
    if (v20 == v21)
    {
      v28 = vdupq_n_s64(v20);
LABEL_29:
      *(_QWORD *)(a1 + 72) = v19;
      *(_QWORD *)(a1 + 80) = v12;
      v31 = v28;
      v29 = *(char **)(a1 + 88);
      *(_QWORD *)(a1 + 88) = v32;
      v32 = v29;
      v30 = (char *)v28.i64[0];
      std::__split_buffer<CASmartPreferences::Pref>::~__split_buffer((uint64_t)&v30);
      goto LABEL_30;
    }
    v22 = 0;
    v23 = *(_QWORD *)(a1 + 80);
    while (1)
    {
      v24 = v19 + v22;
      v25 = v20 + v22;
      *(_OWORD *)(v19 + v22 - 48) = *(_OWORD *)(v20 + v22 - 48);
      v26 = *(_QWORD *)(v20 + v22 - 8);
      if (v26)
      {
        if (v25 - 32 == v26)
        {
          *(_QWORD *)(v24 - 8) = v24 - 32;
          (*(void (**)(_QWORD))(**(_QWORD **)(v25 - 8) + 24))(*(_QWORD *)(v25 - 8));
          goto LABEL_26;
        }
        v27 = (_QWORD *)(v23 - 8);
        *(_QWORD *)(v24 - 8) = v26;
      }
      else
      {
        v27 = (_QWORD *)(v24 - 8);
      }
      *v27 = 0;
LABEL_26:
      v23 -= 48;
      v22 -= 48;
      if (v20 + v22 == v21)
      {
        v19 += v22;
        v28 = *(int64x2_t *)(a1 + 72);
        v12 = v31.i64[1];
        goto LABEL_29;
      }
    }
  }
  std::construct_at[abi:ne180100]<CASmartPreferences::Pref,__CFString const*&,__CFString const*&,std::function<BOOL ()(void const*)> &,CASmartPreferences::Pref*>(*(_QWORD **)(a1 + 80), (uint64_t)a2, (uint64_t)a3, a4);
  v12 = v11 + 48;
  *(_QWORD *)(a1 + 80) = v11 + 48;
LABEL_30:
  *(_QWORD *)(a1 + 80) = v12;
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 64), a3);
  CASmartPreferences::Pref::Load((CFStringRef *)(*(_QWORD *)(a1 + 80) - 48));
LABEL_31:
  std::mutex::unlock((std::mutex *)a1);
}

void sub_1B65CA4C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  std::mutex *v2;
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CASmartPreferences::Pref>::~__split_buffer((uint64_t)va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

_QWORD *std::construct_at[abi:ne180100]<CASmartPreferences::Pref,__CFString const*&,__CFString const*&,std::function<BOOL ()(void const*)> &,CASmartPreferences::Pref*>(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v7 = (_QWORD *)a4[3];
  if (!v7)
  {
    v13 = 0;
    *a1 = a2;
    a1[1] = a3;
LABEL_9:
    a1[5] = 0;
    return a1;
  }
  if (v7 == a4)
  {
    v13 = v12;
    (*(void (**)(_QWORD *, _QWORD *))(*a4 + 24))(a4, v12);
    v8 = v13;
  }
  else
  {
    v8 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v7 + 16))(v7);
    v13 = v8;
  }
  *a1 = a2;
  a1[1] = a3;
  if (!v8)
    goto LABEL_9;
  if (v8 == v12)
  {
    a1[5] = a1 + 2;
    (*(void (**)(_QWORD *))(v12[0] + 24))(v12);
  }
  else
  {
    a1[5] = (*(uint64_t (**)(_QWORD *))(*v8 + 16))(v8);
  }
  v9 = v13;
  if (v13 == v12)
  {
    v10 = 4;
    v9 = v12;
    goto LABEL_15;
  }
  if (v13)
  {
    v10 = 5;
LABEL_15:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  return a1;
}

void sub_1B65CA62C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<CASmartPreferences::Pref>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    *(_QWORD *)(a1 + 16) = v2 - 48;
    v4 = *(_QWORD **)(v2 - 8);
    if (v4 == (_QWORD *)(v2 - 32))
    {
      v4 = (_QWORD *)(v2 - 32);
      v5 = 4;
LABEL_7:
      (*(void (**)(void))(*v4 + 8 * v5))();
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      if (v4)
      {
        v5 = 5;
        goto LABEL_7;
      }
      v2 -= 48;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void *CAAudioChannelLayout::RefCountedLayout::operator new(CAAudioChannelLayout::RefCountedLayout *this)
{
  void *result;
  std::bad_alloc *exception;
  std::bad_alloc *v3;

  result = malloc_type_malloc((size_t)this + 16, 0x7C51E058uLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_alloc::bad_alloc(exception);
  }
  return result;
}

uint64_t CAReferenceCounted::releaseObject(uint64_t this)
{
  if (this)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 8))(this);
  return this;
}

void CAAudioChannelLayout::CAAudioChannelLayout(CAAudioChannelLayout *this, int a2)
{
  _QWORD *v4;

  *(_QWORD *)this = 0;
  v4 = CAAudioChannelLayout::RefCountedLayout::operator new((CAAudioChannelLayout::RefCountedLayout *)0xC);
  *v4 = off_1E69EE240;
  v4[1] = 0xC00000001;
  v4[2] = 0;
  *((_DWORD *)v4 + 6) = 0;
  *((_DWORD *)v4 + 4) = a2;
  *(_QWORD *)this = v4;
}

unsigned int **CAAudioChannelLayout::operator=(unsigned int **a1, unsigned int *a2)
{
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  size_t v9;
  unsigned int *v10;
  std::runtime_error *exception;

  v4 = *a1;
  if (!v4)
    goto LABEL_7;
  if (v4 + 4 != a2)
  {
    v5 = v4 + 2;
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v5));
    if (!v7)
      (*(void (**)(unsigned int *))(*(_QWORD *)v4 + 16))(v4);
LABEL_7:
    if (a2)
    {
      if (((20 * a2[2]) & 0xFFFFFFFF00000000) != 0)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::overflow_error::overflow_error[abi:ne180100](exception, "arithmetic multiplication overflow");
      }
      else
      {
        v8 = 20 * a2[2];
        v9 = v8 + 12;
        if (v8 < 0xFFFFFFF4)
        {
          v10 = (unsigned int *)CAAudioChannelLayout::RefCountedLayout::operator new((CAAudioChannelLayout::RefCountedLayout *)(v8 + 12));
          *(_QWORD *)v10 = off_1E69EE240;
          v10[2] = 1;
          v10[3] = v9;
          bzero(v10 + 4, v9);
          memcpy(v10 + 4, a2, v9);
LABEL_12:
          *a1 = v10;
          return a1;
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::overflow_error::overflow_error[abi:ne180100](exception, "arithmetic addition overflow");
      }
    }
    v10 = (unsigned int *)CAAudioChannelLayout::RefCountedLayout::operator new((CAAudioChannelLayout::RefCountedLayout *)0xC);
    *(_QWORD *)v10 = off_1E69EE240;
    *((_QWORD *)v10 + 1) = 0xC00000001;
    *((_QWORD *)v10 + 2) = 0;
    v10[6] = 0;
    goto LABEL_12;
  }
  return a1;
}

void sub_1B65CA8F8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void CAAudioChannelLayout::~CAAudioChannelLayout(unsigned int **this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *this;
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 16))(v2);
    *this = 0;
  }
}

void MemoryStream::~MemoryStream(MemoryStream *this)
{
  MemoryStream::~MemoryStream(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  const void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E69EE280;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
  {
    CFRelease(v2);
  }
  else
  {
    v3 = (void *)*((_QWORD *)this + 2);
    if (v3)
    {
      if (*((_BYTE *)this + 40))
        free(v3);
    }
  }
}

size_t MemoryStream::Read(MemoryStream *this, void *__dst, size_t a3)
{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  _DWORD *exception;

  v3 = *((_QWORD *)this + 4);
  v4 = *((_QWORD *)this + 2);
  if (v4)
    v5 = *((_QWORD *)this + 3) - v3 >= a3;
  else
    v5 = 0;
  if (!v5)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -39;
  }
  memcpy(__dst, (const void *)(v4 + v3), a3);
  *((_QWORD *)this + 4) += a3;
  return a3;
}

CFIndex MemoryStream::Write(MemoryStream *this, const UInt8 *__src, size_t __n)
{
  CFIndex v3;
  uint64_t v6;
  uint64_t v7;
  int Length;
  CFRange v9;
  _DWORD *exception;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v3 = __n;
  v16 = *MEMORY[0x1E0C80C00];
  v6 = *((_QWORD *)this + 2);
  if (!v6)
  {
    Length = CFDataGetLength(*((CFDataRef *)this + 1));
    v9.location = *((_QWORD *)this + 4);
    if (v9.location == Length)
    {
      CFDataAppendBytes(*((CFMutableDataRef *)this + 1), __src, v3);
      *((_QWORD *)this + 3) = CFDataGetLength(*((CFDataRef *)this + 1));
    }
    else
    {
      v9.length = (int)v3;
      CFDataReplaceBytes(*((CFMutableDataRef *)this + 1), v9, __src, (int)v3);
    }
    goto LABEL_11;
  }
  if (!*((_BYTE *)this + 41))
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -54;
  }
  v7 = *((_QWORD *)this + 4);
  if (*((_QWORD *)this + 3) - v7 >= __n)
  {
    memcpy((void *)(v6 + v7), __src, __n);
LABEL_11:
    *((_QWORD *)this + 4) += v3;
    return v3;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v12 = 136315394;
    v13 = "MemoryStream.cpp";
    v14 = 1024;
    v15 = 184;
    _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  failed assertion: goodToCopy", (uint8_t *)&v12, 0x12u);
  }
  return 0;
}

uint64_t TStream::ReadAsync()
{
  return 4294967292;
}

uint64_t MemoryStream::Seek(uint64_t this, uint64_t a2)
{
  uint64_t v2;

  if (a2 < 0)
  {
    *(_QWORD *)(this + 32) = 0;
  }
  else
  {
    v2 = *(_QWORD *)(this + 24);
    if (v2 <= a2)
      *(_QWORD *)(this + 32) = v2;
    else
      *(_QWORD *)(this + 32) = a2;
  }
  return this;
}

uint64_t MemoryStream::GetPosition(MemoryStream *this)
{
  return *((_QWORD *)this + 4);
}

uint64_t MemoryStream::Skip(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(this + 24);
  v3 = *(_QWORD *)(this + 32);
  v4 = -v3;
  v5 = v2 - v3;
  v6 = v3 + a2;
  if (v5 > a2)
    v2 = v6;
  if (v4 >= a2)
    v2 = 0;
  *(_QWORD *)(this + 32) = v2;
  return this;
}

uint64_t MemoryStream::GetLength(MemoryStream *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t CADeprecated::CABufferList::AllocateBuffers(uint64_t this, unsigned int a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  size_t v5;
  char *v6;
  int v7;
  const void **v8;
  char *v9;
  size_t v10;

  if (*(_DWORD *)(this + 36) < a2)
  {
    v2 = this;
    v3 = *(_DWORD *)(this + 24);
    if (v3 <= 1)
      v4 = a2;
    else
      v4 = (a2 + 15) & 0xFFFFFFE0 | 0x10;
    v5 = v4 * v3;
    v6 = (char *)operator new[]();
    bzero(v6, v5);
    v7 = *(_DWORD *)(v2 + 24);
    if (v7)
    {
      v8 = (const void **)(v2 + 40);
      v9 = v6;
      do
      {
        if (*v8)
        {
          v10 = *((unsigned int *)v8 - 1);
          if ((_DWORD)v10)
            memcpy(v9, *v8, v10);
        }
        *((_DWORD *)v8 - 1) = v4;
        *v8 = v9;
        v8 += 2;
        v9 += v4;
        --v7;
      }
      while (v7);
    }
    this = *(_QWORD *)(v2 + 8);
    *(_QWORD *)(v2 + 8) = v6;
    *(_DWORD *)(v2 + 16) = v4;
    if (this)
      JUMPOUT(0x1BCC95CC8);
  }
  return this;
}

uint64_t AUPBPropertiesChanged()
{
  return MEMORY[0x1E0CFF348]();
}

uint64_t AUPBRegisterAU()
{
  return MEMORY[0x1E0CFF350]();
}

uint64_t AUPBUnregisterAU()
{
  return MEMORY[0x1E0CFF358]();
}

uint64_t AVAUVoiceIOGetPreferredChatFlavorForBundleID()
{
  return MEMORY[0x1E0C89C28]();
}

uint64_t AVAUVoiceIOInitializeListenersForBundleID()
{
  return MEMORY[0x1E0C89C30]();
}

uint64_t AVAUVoiceIORemoveActiveChatFlavorForBundleID()
{
  return MEMORY[0x1E0C89C48]();
}

uint64_t AVAUVoiceIOSetActiveChatFlavorForBundleID()
{
  return MEMORY[0x1E0C89C50]();
}

uint64_t AVAUVoiceIOSetHiddenChatFlavorsForBundleID()
{
  return MEMORY[0x1E0C89C58]();
}

uint64_t AVAUVoiceIOSetSupportedChatFlavorsForBundleID()
{
  return MEMORY[0x1E0C89C60]();
}

uint64_t AVAUVoiceIOSetVoiceProcessingBypassedForBundleID()
{
  return MEMORY[0x1E0C89C68]();
}

OSStatus AudioComponentCopyName(AudioComponent inComponent, CFStringRef *outName)
{
  return MEMORY[0x1E0CFF3D0](inComponent, outName);
}

AudioComponent AudioComponentFindNext(AudioComponent inComponent, const AudioComponentDescription *inDesc)
{
  return (AudioComponent)MEMORY[0x1E0CFF3E8](inComponent, inDesc);
}

OSStatus AudioComponentGetDescription(AudioComponent inComponent, AudioComponentDescription *outDesc)
{
  return MEMORY[0x1E0CFF3F0](inComponent, outDesc);
}

Boolean AudioComponentInstanceCanDo(AudioComponentInstance inInstance, SInt16 inSelectorID)
{
  return MEMORY[0x1E0CFF400](inInstance, inSelectorID);
}

OSStatus AudioComponentInstanceDispose(AudioComponentInstance inInstance)
{
  return MEMORY[0x1E0CFF408](inInstance);
}

AudioComponent AudioComponentInstanceGetComponent(AudioComponentInstance inInstance)
{
  return (AudioComponent)MEMORY[0x1E0CFF410](inInstance);
}

OSStatus AudioComponentInstanceNew(AudioComponent inComponent, AudioComponentInstance *outInstance)
{
  return MEMORY[0x1E0CFF418](inComponent, outInstance);
}

AudioComponent AudioComponentRegister(const AudioComponentDescription *inDesc, CFStringRef inName, UInt32 inVersion, AudioComponentFactoryFunction inFactory)
{
  return (AudioComponent)MEMORY[0x1E0CFF428](inDesc, inName, *(_QWORD *)&inVersion, inFactory);
}

OSStatus AudioConverterConvertComplexBuffer(AudioConverterRef inAudioConverter, UInt32 inNumberPCMFrames, const AudioBufferList *inInputData, AudioBufferList *outOutputData)
{
  return MEMORY[0x1E0CFF448](inAudioConverter, *(_QWORD *)&inNumberPCMFrames, inInputData, outOutputData);
}

OSStatus AudioConverterDispose(AudioConverterRef inAudioConverter)
{
  return MEMORY[0x1E0CFF450](inAudioConverter);
}

OSStatus AudioConverterFillComplexBuffer(AudioConverterRef inAudioConverter, AudioConverterComplexInputDataProc inInputDataProc, void *inInputDataProcUserData, UInt32 *ioOutputDataPacketSize, AudioBufferList *outOutputData, AudioStreamPacketDescription *outPacketDescription)
{
  return MEMORY[0x1E0CFF458](inAudioConverter, inInputDataProc, inInputDataProcUserData, ioOutputDataPacketSize, outOutputData, outPacketDescription);
}

OSStatus AudioConverterGetProperty(AudioConverterRef inAudioConverter, AudioConverterPropertyID inPropertyID, UInt32 *ioPropertyDataSize, void *outPropertyData)
{
  return MEMORY[0x1E0CFF468](inAudioConverter, *(_QWORD *)&inPropertyID, ioPropertyDataSize, outPropertyData);
}

OSStatus AudioConverterNew(const AudioStreamBasicDescription *inSourceFormat, const AudioStreamBasicDescription *inDestinationFormat, AudioConverterRef *outAudioConverter)
{
  return MEMORY[0x1E0CFF478](inSourceFormat, inDestinationFormat, outAudioConverter);
}

OSStatus AudioConverterReset(AudioConverterRef inAudioConverter)
{
  return MEMORY[0x1E0CFF498](inAudioConverter);
}

OSStatus AudioConverterSetProperty(AudioConverterRef inAudioConverter, AudioConverterPropertyID inPropertyID, UInt32 inPropertyDataSize, const void *inPropertyData)
{
  return MEMORY[0x1E0CFF4A0](inAudioConverter, *(_QWORD *)&inPropertyID, *(_QWORD *)&inPropertyDataSize, inPropertyData);
}

OSStatus AudioFormatGetProperty(AudioFormatPropertyID inPropertyID, UInt32 inSpecifierSize, const void *inSpecifier, UInt32 *ioPropertyDataSize, void *outPropertyData)
{
  return MEMORY[0x1E0CFF510](*(_QWORD *)&inPropertyID, *(_QWORD *)&inSpecifierSize, inSpecifier, ioPropertyDataSize, outPropertyData);
}

OSStatus AudioObjectGetPropertyData(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, UInt32 inQualifierDataSize, const void *inQualifierData, UInt32 *ioDataSize, void *outData)
{
  return MEMORY[0x1E0C975D0](*(_QWORD *)&inObjectID, inAddress, *(_QWORD *)&inQualifierDataSize, inQualifierData, ioDataSize, outData);
}

Boolean AudioObjectHasProperty(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress)
{
  return MEMORY[0x1E0C975E0](*(_QWORD *)&inObjectID, inAddress);
}

uint64_t AudioSampleRateConverterCreate()
{
  return MEMORY[0x1E0CFF540]();
}

uint64_t AudioSampleRateConverterDispose()
{
  return MEMORY[0x1E0CFF548]();
}

uint64_t AudioSampleRateConverterGetExpectedNumberOfOutputFrames()
{
  return MEMORY[0x1E0CFF550]();
}

uint64_t AudioSampleRateConverterGetKernelSize()
{
  return MEMORY[0x1E0CFF558]();
}

uint64_t AudioSampleRateConverterGetLatency()
{
  return MEMORY[0x1E0CFF560]();
}

uint64_t AudioSampleRateConverterGetNumberOfChannels()
{
  return MEMORY[0x1E0CFF568]();
}

uint64_t AudioSampleRateConverterGetRequiredNumberOfInputFrames()
{
  return MEMORY[0x1E0CFF570]();
}

uint64_t AudioSampleRateConverterProcess()
{
  return MEMORY[0x1E0CFF578]();
}

uint64_t AudioSampleRateConverterReset()
{
  return MEMORY[0x1E0CFF580]();
}

OSStatus AudioUnitGetParameter(AudioUnit inUnit, AudioUnitParameterID inID, AudioUnitScope inScope, AudioUnitElement inElement, AudioUnitParameterValue *outValue)
{
  return MEMORY[0x1E0CFF5A0](inUnit, *(_QWORD *)&inID, *(_QWORD *)&inScope, *(_QWORD *)&inElement, outValue);
}

OSStatus AudioUnitGetProperty(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void *outData, UInt32 *ioDataSize)
{
  return MEMORY[0x1E0CFF5A8](inUnit, *(_QWORD *)&inID, *(_QWORD *)&inScope, *(_QWORD *)&inElement, outData, ioDataSize);
}

OSStatus AudioUnitGetPropertyInfo(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, UInt32 *outDataSize, Boolean *outWritable)
{
  return MEMORY[0x1E0CFF5B0](inUnit, *(_QWORD *)&inID, *(_QWORD *)&inScope, *(_QWORD *)&inElement, outDataSize, outWritable);
}

OSStatus AudioUnitInitialize(AudioUnit inUnit)
{
  return MEMORY[0x1E0CFF5B8](inUnit);
}

OSStatus AudioUnitProcess(AudioUnit inUnit, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inNumberFrames, AudioBufferList *ioData)
{
  return MEMORY[0x1E0CFF5C0](inUnit, ioActionFlags, inTimeStamp, *(_QWORD *)&inNumberFrames, ioData);
}

OSStatus AudioUnitProcessMultiple(AudioUnit inUnit, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inNumberFrames, UInt32 inNumberInputBufferLists, const AudioBufferList **inInputBufferLists, UInt32 inNumberOutputBufferLists, AudioBufferList **ioOutputBufferLists)
{
  return MEMORY[0x1E0CFF5C8](inUnit, ioActionFlags, inTimeStamp, *(_QWORD *)&inNumberFrames, *(_QWORD *)&inNumberInputBufferLists, inInputBufferLists, *(_QWORD *)&inNumberOutputBufferLists, ioOutputBufferLists);
}

OSStatus AudioUnitRender(AudioUnit inUnit, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inOutputBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData)
{
  return MEMORY[0x1E0CFF5E0](inUnit, ioActionFlags, inTimeStamp, *(_QWORD *)&inOutputBusNumber, *(_QWORD *)&inNumberFrames, ioData);
}

OSStatus AudioUnitReset(AudioUnit inUnit, AudioUnitScope inScope, AudioUnitElement inElement)
{
  return MEMORY[0x1E0CFF5E8](inUnit, *(_QWORD *)&inScope, *(_QWORD *)&inElement);
}

OSStatus AudioUnitSetParameter(AudioUnit inUnit, AudioUnitParameterID inID, AudioUnitScope inScope, AudioUnitElement inElement, AudioUnitParameterValue inValue, UInt32 inBufferOffsetInFrames)
{
  return MEMORY[0x1E0CFF5F8](inUnit, *(_QWORD *)&inID, *(_QWORD *)&inScope, *(_QWORD *)&inElement, *(_QWORD *)&inBufferOffsetInFrames, inValue);
}

OSStatus AudioUnitSetProperty(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, const void *inData, UInt32 inDataSize)
{
  return MEMORY[0x1E0CFF600](inUnit, *(_QWORD *)&inID, *(_QWORD *)&inScope, *(_QWORD *)&inElement, inData, *(_QWORD *)&inDataSize);
}

OSStatus AudioUnitUninitialize(AudioUnit inUnit)
{
  return MEMORY[0x1E0CFF608](inUnit);
}

int BNNSFilterApply(void *filter, const void *in, void *out)
{
  return MEMORY[0x1E0C8B5A8](filter, in, out);
}

void *__cdecl BNNSFilterCreateLayerFullyConnected(const BNNSLayerParametersFullyConnected *layer_params, const BNNSFilterParameters *filter_params)
{
  return (void *)MEMORY[0x1E0C8B668](layer_params, filter_params);
}

void BNNSFilterDestroy(void *filter)
{
  MEMORY[0x1E0C8B6E8](filter);
}

uint64_t BNNSGraphCompileFromFile_v2()
{
  return MEMORY[0x1E0C8B730]();
}

uint64_t BNNSGraphCompileOptionsDestroy()
{
  return MEMORY[0x1E0C8B748]();
}

uint64_t BNNSGraphCompileOptionsMakeDefault()
{
  return MEMORY[0x1E0C8B768]();
}

uint64_t BNNSGraphCompileOptionsSetOptimizationPreference()
{
  return MEMORY[0x1E0C8B7C0]();
}

uint64_t BNNSGraphCompileOptionsSetOutputPath()
{
  return MEMORY[0x1E0C8B7C8]();
}

uint64_t BNNSGraphCompileOptionsSetTargetSingleThread()
{
  return MEMORY[0x1E0C8B7F8]();
}

uint64_t BNNSGraphCompileOptionsSetValidateMILFile()
{
  return MEMORY[0x1E0C8B808]();
}

uint64_t BNNSGraphContextDestroy_v2()
{
  return MEMORY[0x1E0C8B820]();
}

uint64_t BNNSGraphContextExecute_v2()
{
  return MEMORY[0x1E0C8B830]();
}

uint64_t BNNSGraphContextGetTensorDescriptor_v2()
{
  return MEMORY[0x1E0C8B850]();
}

uint64_t BNNSGraphContextGetWorkspaceSize_v2()
{
  return MEMORY[0x1E0C8B860]();
}

uint64_t BNNSGraphContextMake()
{
  return MEMORY[0x1E0C8B868]();
}

uint64_t BNNSGraphContextMakeStreaming()
{
  return MEMORY[0x1E0C8B878]();
}

uint64_t BNNSGraphContextSetArgumentType()
{
  return MEMORY[0x1E0C8B888]();
}

uint64_t BNNSGraphContextSetBatchSize_v2()
{
  return MEMORY[0x1E0C8B898]();
}

uint64_t BNNSGraphGetArgumentCount()
{
  return MEMORY[0x1E0C8B8D8]();
}

uint64_t BNNSGraphGetArgumentIntents()
{
  return MEMORY[0x1E0C8B8E0]();
}

uint64_t BNNSGraphGetArgumentNames()
{
  return MEMORY[0x1E0C8B8E8]();
}

uint64_t BNNSGraphGetArgumentPosition()
{
  return MEMORY[0x1E0C8B8F0]();
}

uint64_t BNNSGraphGetOutputCount()
{
  return MEMORY[0x1E0C8B938]();
}

uint64_t BNNSGraphGetWorkspaceSize_v2()
{
  return MEMORY[0x1E0C8B958]();
}

size_t BNNSNDArrayGetDataSize(const BNNSNDArrayDescriptor *array)
{
  return MEMORY[0x1E0C8B9B0](array);
}

uint64_t CARegisterDeviceOrientation()
{
  return MEMORY[0x1E0C92230]();
}

uint64_t CARegisterUIOrientation()
{
  return MEMORY[0x1E0C92238]();
}

uint64_t CAUnregisterDeviceOrientation()
{
  return MEMORY[0x1E0C92240]();
}

uint64_t CAUnregisterUIOrientation()
{
  return MEMORY[0x1E0C92248]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

CFGregorianDate CFAbsoluteTimeGetGregorianDate(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  uint64_t v2;
  double v3;
  CFGregorianDate result;

  v2 = MEMORY[0x1E0C97C88](tz, at);
  result.second = v3;
  result.year = v2;
  result.month = BYTE4(v2);
  result.day = BYTE5(v2);
  result.hour = BYTE6(v2);
  result.minute = HIBYTE(v2);
  return result;
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  return (CFAllocatorRef)MEMORY[0x1E0C97CC0]();
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1E0C97D30](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DB0](theArray, idx, value);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  MEMORY[0x1E0C97DB8](theArray);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1E0C98120](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1E0C98150]();
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1E0C98350](cf);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  MEMORY[0x1E0C98390](theData, bytes, length);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983B8](allocator, capacity);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x1E0C983F0](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1E0C98408](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1E0C98418]();
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
  MEMORY[0x1E0C98428](theData, range.location, range.length, newBytes, newLength);
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  MEMORY[0x1E0C98430](theData, length);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98538](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1E0C98720](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1E0C98758](cf);
}

uint64_t CFLog()
{
  return MEMORY[0x1E0C98808]();
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988B8]();
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988D0]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x1E0C98900](center, observer, name, object);
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1E0C98908]();
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1E0C98910](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1E0C989A8](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x1E0C98A30](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)MEMORY[0x1E0C98A50](applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A70](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A78](key, applicationID, keyExistsAndHasValidFormat);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
  MEMORY[0x1E0C98A80](key, value, applicationID);
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x1E0C98A98](applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C98AA0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AB0](allocator, propertyList, mutabilityOption);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AD0](allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AE0](allocator, stream, streamLength, options, format, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  MEMORY[0x1E0C98B10](stream);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1E0C98B48](alloc, fileURL);
}

CFStreamError CFReadStreamGetError(CFReadStreamRef stream)
{
  CFIndex v1;
  uint64_t v2;
  CFStreamError result;

  v1 = MEMORY[0x1E0C98B58](stream);
  result.error = v2;
  result.domain = v1;
  return result;
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B80](stream);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98D70](theSet, value);
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98D78](theSet, applier, context);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98D98](allocator, capacity, callBacks);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x1E0C98ED8](theString, appendedString);
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  MEMORY[0x1E0C98EE0](theString, cStr, *(_QWORD *)&encoding);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  MEMORY[0x1E0C98EF0](theString, formatOptions, format);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F18](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1E0C98F78](alloc, theString);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F90](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FC8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation, contentsDeallocator);
}

uint64_t CFStringCreateWithCAOrientation()
{
  return MEMORY[0x1E0C92250]();
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FE0](alloc, cStr, *(_QWORD *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1E0C99020](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99050](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C99058](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99068](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1E0C990B0](theString, idx);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C990E0](string, buffer, maxBufLen);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1E0C990F0](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  return MEMORY[0x1E0C99128](string);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1E0C99168]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1E0C99190](theString, suffix);
}

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
  MEMORY[0x1E0C99250](theString, trimString);
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C99280]();
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1E0C992C8](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99318](anURL);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1E0C99390](allocator, url);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C993C8](allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateFromFileSystemRepresentationRelativeToBase(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C993D8](allocator, buffer, bufLen, isDirectory, baseURL);
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99418](allocator, URLBytes, length, *(_QWORD *)&encoding, baseURL);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99448](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C99490](url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C994A0](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1E0C994B8]();
}

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  return MEMORY[0x1E0C994D0](url, error);
}

Boolean CFURLWriteDataAndPropertiesToResource(CFURLRef url, CFDataRef dataToWrite, CFDictionaryRef propertiesToWrite, SInt32 *errorCode)
{
  return MEMORY[0x1E0C99508](url, dataToWrite, propertiesToWrite, errorCode);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1E0C99518](alloc);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1E0C99538](alloc, uuid);
}

OSStatus ExtAudioFileCreateWithURL(CFURLRef inURL, AudioFileTypeID inFileType, const AudioStreamBasicDescription *inStreamDesc, const AudioChannelLayout *inChannelLayout, UInt32 inFlags, ExtAudioFileRef *outExtAudioFile)
{
  return MEMORY[0x1E0CFF630](inURL, *(_QWORD *)&inFileType, inStreamDesc, inChannelLayout, *(_QWORD *)&inFlags, outExtAudioFile);
}

OSStatus ExtAudioFileDispose(ExtAudioFileRef inExtAudioFile)
{
  return MEMORY[0x1E0CFF638](inExtAudioFile);
}

OSStatus ExtAudioFileGetProperty(ExtAudioFileRef inExtAudioFile, ExtAudioFilePropertyID inPropertyID, UInt32 *ioPropertyDataSize, void *outPropertyData)
{
  return MEMORY[0x1E0CFF640](inExtAudioFile, *(_QWORD *)&inPropertyID, ioPropertyDataSize, outPropertyData);
}

OSStatus ExtAudioFileOpenURL(CFURLRef inURL, ExtAudioFileRef *outExtAudioFile)
{
  return MEMORY[0x1E0CFF650](inURL, outExtAudioFile);
}

OSStatus ExtAudioFileRead(ExtAudioFileRef inExtAudioFile, UInt32 *ioNumberFrames, AudioBufferList *ioData)
{
  return MEMORY[0x1E0CFF658](inExtAudioFile, ioNumberFrames, ioData);
}

OSStatus ExtAudioFileSetProperty(ExtAudioFileRef inExtAudioFile, ExtAudioFilePropertyID inPropertyID, UInt32 inPropertyDataSize, const void *inPropertyData)
{
  return MEMORY[0x1E0CFF668](inExtAudioFile, *(_QWORD *)&inPropertyID, *(_QWORD *)&inPropertyDataSize, inPropertyData);
}

OSStatus ExtAudioFileWrite(ExtAudioFileRef inExtAudioFile, UInt32 inNumberFrames, const AudioBufferList *ioData)
{
  return MEMORY[0x1E0CFF680](inExtAudioFile, *(_QWORD *)&inNumberFrames, ioData);
}

OSStatus ExtAudioFileWriteAsync(ExtAudioFileRef inExtAudioFile, UInt32 inNumberFrames, const AudioBufferList *ioData)
{
  return MEMORY[0x1E0CFF688](inExtAudioFile, *(_QWORD *)&inNumberFrames, ioData);
}

uint64_t ExtendedAudioBufferList_Create()
{
  return MEMORY[0x1E0CFF690]();
}

uint64_t ExtendedAudioBufferList_CreateWithFormat()
{
  return MEMORY[0x1E0CFF698]();
}

uint64_t ExtendedAudioBufferList_Destroy()
{
  return MEMORY[0x1E0CFF6A0]();
}

uint64_t ExtendedAudioBufferList_Prepare()
{
  return MEMORY[0x1E0CFF6A8]();
}

uint64_t ExtendedAudioBufferList_PrepareWithNumberOfBuffers()
{
  return MEMORY[0x1E0CFF6B0]();
}

uint64_t FigCaptureSpeakerInterferenceMitigationIsRequired()
{
  return MEMORY[0x1E0D03A50]();
}

uint64_t FigCaptureSpeakerInterferenceMitigationIsSupported()
{
  return MEMORY[0x1E0D03A58]();
}

uint64_t IOHIDEventCreateKeyboardEvent()
{
  return MEMORY[0x1E0CBB078]();
}

uint64_t IOHIDEventGetIntegerValue()
{
  return MEMORY[0x1E0CBB130]();
}

CFArrayRef IOHIDEventSystemClientCopyServices(IOHIDEventSystemClientRef client)
{
  return (CFArrayRef)MEMORY[0x1E0CBB1E8](client);
}

uint64_t IOHIDEventSystemClientCreate()
{
  return MEMORY[0x1E0CBB1F0]();
}

uint64_t IOHIDEventSystemClientSetMatching()
{
  return MEMORY[0x1E0CBB268]();
}

uint64_t IOHIDServiceClientCopyEvent()
{
  return MEMORY[0x1E0CBB498]();
}

CFDictionaryRef IOPSCopyExternalPowerAdapterDetails(void)
{
  return (CFDictionaryRef)MEMORY[0x1E0CBB860]();
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1E0DE2B20]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1E0DE2B50]();
}

uint64_t MGGetProductType()
{
  return MEMORY[0x1E0DE2B68]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x1E0DE2B70]();
}

uint64_t MGGetStringAnswer()
{
  return MEMORY[0x1E0DE2B80]();
}

uint64_t MGIsQuestionValid()
{
  return MEMORY[0x1E0DE2BA0]();
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x1E0CB2D88](format);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x1E0CB3250]();
}

uint64_t NativeInt16ToFloat32Scaled_ARM()
{
  return MEMORY[0x1E0CFF700]();
}

uint64_t NativeInt32ToFloat32Scaled_ARM()
{
  return MEMORY[0x1E0CFF708]();
}

uint64_t PLLogRegisteredEvent()
{
  return MEMORY[0x1E0D7FE28]();
}

uint64_t VoiceProcessorCreate()
{
  return MEMORY[0x1E0DC73F0]();
}

uint64_t VoiceProcessorGetVersion()
{
  return MEMORY[0x1E0DC73F8]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

uint64_t AudioMetadataFrame_GetHeader()
{
  return MEMORY[0x1E0CFF7A8]();
}

uint64_t AudioBufferList_GetMetadataFrame(const AudioBufferList *a1)
{
  return MEMORY[0x1E0CFF7B8](a1);
}

void CAFormatter::CAFormatter(CAFormatter *this, const CAStreamBasicDescription *a2)
{
  MEMORY[0x1E0CFF810](this, a2);
}

void CAFormatter::CAFormatter(CAFormatter *this, const AudioStreamBasicDescription *a2)
{
  MEMORY[0x1E0CFF830](this, a2);
}

uint64_t AUProcessingBlockBase::UnitsChanged()
{
  return MEMORY[0x1E0CFF840]();
}

uint64_t AUProcessingBlockBase::InsertAUAtIndex(AUProcessingBlockBase *this, uint64_t a2, const AUPBUnit *a3)
{
  return MEMORY[0x1E0CFF848](this, a2, a3);
}

uint64_t AUProcessingBlockBase::RemoveAUAtIndex(AUProcessingBlockBase *this)
{
  return MEMORY[0x1E0CFF850](this);
}

uint64_t AUProcessingBlockBase::SetName(AUProcessingBlockBase *this, const __CFString *a2)
{
  return MEMORY[0x1E0CFF858](this, a2);
}

void AUProcessingBlockBase::AUProcessingBlockBase(AUProcessingBlockBase *this, const __CFString *a2)
{
  MEMORY[0x1E0CFF860](this, a2);
}

void AUProcessingBlockBase::~AUProcessingBlockBase(AUProcessingBlockBase *this)
{
  MEMORY[0x1E0CFF868](this);
}

uint64_t AUProcessingBlock_DSPGraph::AUProcessingBlock_DSPGraph()
{
  return MEMORY[0x1E0CFF898]();
}

void AUProcessingBlock_DSPGraph::~AUProcessingBlock_DSPGraph(AUProcessingBlock_DSPGraph *this)
{
  MEMORY[0x1E0CFF8A0](this);
}

uint64_t AT::Resampler::createWithFilterSpecification(AT::Resampler *this, double a2, double a3, double a4, double a5, double a6)
{
  return MEMORY[0x1E0CFF910](this, a2, a3, a4, a5, a6);
}

uint64_t AT::Resampler::create(AT::Resampler *this, double a2, double a3, double a4)
{
  return MEMORY[0x1E0CFF918](this, a2, a3, a4);
}

uint64_t IR::IRDataLoader::fileExists()
{
  return MEMORY[0x1E0DDE550]();
}

{
  return MEMORY[0x1E0DDE558]();
}

uint64_t IR::IRDataLoader::fileExists(IR::IRDataLoader *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE560](this, a2);
}

uint64_t IR::IRDataLoader::getUserData()
{
  return MEMORY[0x1E0DDE568]();
}

uint64_t IR::IRDataLoader::getUserData(IR::IRDataLoader *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE570](this, a2);
}

uint64_t IR::IRDataLoader::writeIRFile()
{
  return MEMORY[0x1E0DDE578]();
}

uint64_t IR::IRDataLoader::getIRDataTypes(IR::IRDataLoader *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE580](this, a2);
}

uint64_t IR::IRDataLoader::getFilterLength()
{
  return MEMORY[0x1E0DDE588]();
}

uint64_t IR::IRDataLoader::getFilterLength(IR::IRDataLoader *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE590](this, a2);
}

uint64_t IR::IRDataLoader::getModelingDelay(IR::IRDataLoader *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE598](this, a2);
}

uint64_t IR::IRDataLoader::getAudioChannelLayoutTag()
{
  return MEMORY[0x1E0DDE5A0]();
}

uint64_t IR::IRDataLoader::getAudioChannelLayoutTag(IR::IRDataLoader *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE5A8](this, a2);
}

uint64_t IR::IRDataLoader::registerCustomLayoutIfNecessary(IR::IRDataLoader *this, const AudioChannelLayout *a2)
{
  return MEMORY[0x1E0DDE5B0](this, a2);
}

uint64_t IR::IRDataLoader::getOriginalAudioChannelLayoutTag(IR::IRDataLoader *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE5B8](this, a2);
}

uint64_t IR::IRDataLoader::hasFailedToFetchPersonalizedHRTF(IR::IRDataLoader *this)
{
  return MEMORY[0x1E0DDE5C0](this);
}

uint64_t IR::IRDataLoader::addPersonalizedHRTFListenerCallback()
{
  return MEMORY[0x1E0DDE5C8]();
}

uint64_t IR::IRDataLoader::removePersonalizedHRTFListenerCallback()
{
  return MEMORY[0x1E0DDE5D0]();
}

uint64_t IR::IRDataLoader::load()
{
  return MEMORY[0x1E0DDE5D8]();
}

uint64_t IR::IRDataLoader::create()
{
  return MEMORY[0x1E0DDE5E0]();
}

uint64_t IR::IRDataLoader::instance(IR::IRDataLoader *this)
{
  return MEMORY[0x1E0DDE5E8](this);
}

uint64_t IR::IRCoordinates::set()
{
  return MEMORY[0x1E0DDE5F0]();
}

uint64_t IR::IRCoordinates::IRCoordinates(IR::IRCoordinates *this)
{
  return MEMORY[0x1E0DDE5F8](this);
}

uint64_t IR::copyHRTFBinURL(IR *this)
{
  return MEMORY[0x1E0DDE600](this);
}

uint64_t IR::FFTFilterKernel::accumulate()
{
  return MEMORY[0x1E0DDE608]();
}

uint64_t IR::FFTFilterKernel::initialize(IR::FFTFilterKernel *this)
{
  return MEMORY[0x1E0DDE610](this);
}

uint64_t IR::FFTFilterKernel::storeCoeffs(IR::FFTFilterKernel *this, const float *a2, uint64_t a3, MultiRadixRealFFT *a4)
{
  return MEMORY[0x1E0DDE618](this, a2, a3, a4);
}

uint64_t IR::FFTFilterKernel::reset(IR::FFTFilterKernel *this)
{
  return MEMORY[0x1E0DDE620](this);
}

uint64_t IR::FFTFilterKernel::scale(IR::FFTFilterKernel *this, float a2)
{
  return MEMORY[0x1E0DDE628](this, a2);
}

uint64_t IR::FFTFilterKernel::FFTFilterKernel(IR::FFTFilterKernel *this, const IR::FFTFilterKernel *a2)
{
  return MEMORY[0x1E0DDE630](this, a2);
}

uint64_t IR::FFTFilterKernel::FFTFilterKernel(IR::FFTFilterKernel *this)
{
  return MEMORY[0x1E0DDE638](this);
}

void IR::FFTFilterKernel::~FFTFilterKernel(IR::FFTFilterKernel *this)
{
  MEMORY[0x1E0DDE640](this);
}

uint64_t IR::FFTFilterTranspose::FFTFilterTranspose(IR::FFTFilterTranspose *this)
{
  return MEMORY[0x1E0DDE648](this);
}

uint64_t IR::getGenericIRBasePath(IR *this)
{
  return MEMORY[0x1E0DDE650](this);
}

uint64_t IR::ComplexDataCircBuffer::initialize(IR::ComplexDataCircBuffer *this)
{
  return MEMORY[0x1E0DDE658](this);
}

uint64_t IR::ComplexDataCircBuffer::getNumFFTBuffers(IR::ComplexDataCircBuffer *this)
{
  return MEMORY[0x1E0DDE660](this);
}

uint64_t IR::ComplexDataCircBuffer::getSampleDataPtrs(IR::ComplexDataCircBuffer *this)
{
  return MEMORY[0x1E0DDE668](this);
}

uint64_t IR::ComplexDataCircBuffer::getNumOutputChannels(IR::ComplexDataCircBuffer *this)
{
  return MEMORY[0x1E0DDE670](this);
}

uint64_t IR::ComplexDataCircBuffer::inverseFFTOverlapAdd(IR::ComplexDataCircBuffer *this)
{
  return MEMORY[0x1E0DDE678](this);
}

uint64_t IR::ComplexDataCircBuffer::getFFTPartitionLength(IR::ComplexDataCircBuffer *this)
{
  return MEMORY[0x1E0DDE680](this);
}

uint64_t IR::ComplexDataCircBuffer::cleanup(IR::ComplexDataCircBuffer *this)
{
  return MEMORY[0x1E0DDE688](this);
}

uint64_t IR::ComplexDataCircBuffer::ComplexDataCircBuffer(IR::ComplexDataCircBuffer *this)
{
  return MEMORY[0x1E0DDE690](this);
}

void IR::ComplexDataCircBuffer::~ComplexDataCircBuffer(IR::ComplexDataCircBuffer *this)
{
  MEMORY[0x1E0DDE698](this);
}

uint64_t IR::getPresetDataAttributes()
{
  return MEMORY[0x1E0DDE6A0]();
}

uint64_t IR::getProductTypeXTCIRFullPath(IR *this)
{
  return MEMORY[0x1E0DDE6A8](this);
}

uint64_t IR::IRData::getUserData(IR::IRData *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE6B0](this, a2);
}

uint64_t IR::IRData::getModelingDelay(IR::IRData *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE6B8](this, a2);
}

uint64_t IR::IRData::getAudioChannelLayoutTag(IR::IRData *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE6C0](this, a2);
}

uint64_t IR::IRData::getBooleanFromDictionary()
{
  return MEMORY[0x1E0DDE6C8]();
}

uint64_t IR::IRData::getNumFiltersPerSpatialPoint(IR::IRData *this, const IR::IRDataAttributes *a2)
{
  return MEMORY[0x1E0DDE6D0](this, a2);
}

uint64_t IR::FFTFilter::initialize(IR::FFTFilter *this)
{
  return MEMORY[0x1E0DDE6D8](this);
}

uint64_t IR::FFTFilter::initialize(IR::FFTFilter *this, unsigned int a2, unsigned int a3, unsigned int a4, BOOL a5, unsigned int a6, unsigned int a7, BOOL a8, BOOL a9, BOOL a10)
{
  return MEMORY[0x1E0DDE6E0](this);
}

uint64_t IR::FFTFilter::setFilterCoeffs(IR::FFTFilter *this, const float *const *a2)
{
  return MEMORY[0x1E0DDE6E8](this, a2);
}

uint64_t IR::FFTFilter::setFilterKernels()
{
  return MEMORY[0x1E0DDE6F0]();
}

uint64_t IR::FFTFilter::getScratchKernels(IR::FFTFilter *this)
{
  return MEMORY[0x1E0DDE6F8](this);
}

uint64_t IR::FFTFilter::processMultipleInputs(IR::FFTFilter *this, float *const *a2, float *const *a3, uint64_t a4, uint64_t a5, uint64_t a6, IR::ComplexDataCircBuffer *a7)
{
  return MEMORY[0x1E0DDE700](this, a2, a3, a4, a5, a6, a7);
}

uint64_t IR::FFTFilter::reset(IR::FFTFilter *this)
{
  return MEMORY[0x1E0DDE708](this);
}

uint64_t IR::FFTFilter::process(IR::FFTFilter *this, const float *a2, float *const *a3)
{
  return MEMORY[0x1E0DDE710](this, a2, a3);
}

uint64_t IR::FFTFilter::process(IR::FFTFilter *this, const float *a2, float *const *a3, uint64_t a4, uint64_t a5, IR::ComplexDataCircBuffer *a6)
{
  return MEMORY[0x1E0DDE718](this, a2, a3, a4, a5, a6);
}

uint64_t IR::FFTFilter::FFTFilter(IR::FFTFilter *this)
{
  return MEMORY[0x1E0DDE720](this);
}

uint64_t APAC::MetadataJSON(APAC *this, const APAC::Metadata *a2)
{
  return MEMORY[0x1E0CFF920](this, a2);
}

uint64_t APAC::MetadataBitStreamParser::parse(APAC::MetadataBitStreamParser *this, void *a2, uint64_t a3, APAC::Metadata *a4)
{
  return MEMORY[0x1E0CFF928](this, a2, a3, a4);
}

uint64_t APAC::ImmersiveRendererData_V2_Manager::getACLPointer()
{
  return MEMORY[0x1E0CFF930]();
}

uint64_t APAC::ImmersiveRendererData_V2_Manager::getACLByteSize()
{
  return MEMORY[0x1E0CFF938]();
}

uint64_t APAC::ImmersiveRendererData_V2_Manager::getMetadataConfig()
{
  return MEMORY[0x1E0CFF940]();
}

uint64_t APAC::ImmersiveRendererData_V2_Manager::hasMetadataConfig()
{
  return MEMORY[0x1E0CFF948]();
}

uint64_t APAC::ImmersiveRendererData_V2_Manager::getNumRendererDescriptions()
{
  return MEMORY[0x1E0CFF950]();
}

uint64_t APAC::ImmersiveRendererData_V2_Manager::getImmersiveRendererDescriptionPointer()
{
  return MEMORY[0x1E0CFF958]();
}

uint64_t E5RT::BufferObject::AllocMemory()
{
  return MEMORY[0x1E0D1F590]();
}

uint64_t E5RT::BufferObject::GetDataSpan(E5RT::BufferObject *this)
{
  return MEMORY[0x1E0D1F598](this);
}

uint64_t E5RT::MemoryObject::TryAsBuffer(E5RT::MemoryObject *this)
{
  return MEMORY[0x1E0D1F5A0](this);
}

uint64_t E5RT::SurfaceObject::AllocSurface()
{
  return MEMORY[0x1E0D1F5A8]();
}

uint64_t E5RT::ExecutionStream::EncodeOperation()
{
  return MEMORY[0x1E0D1F5D0]();
}

uint64_t E5RT::ExecutionStream::ExecuteStreamSync(E5RT::ExecutionStream *this)
{
  return MEMORY[0x1E0D1F5D8](this);
}

uint64_t E5RT::ExecutionStream::CreateExecutionStream(E5RT::ExecutionStream *this)
{
  return MEMORY[0x1E0D1F5E0](this);
}

uint64_t E5RT::ExecutionStreamOperation::CreatePreCompiledComputeOp()
{
  return MEMORY[0x1E0D1F668]();
}

uint64_t E5RT::IOPort::GetMemoryObject(E5RT::IOPort *this)
{
  return MEMORY[0x1E0D1F680](this);
}

uint64_t E5RT::IOPort::BindMemoryObject()
{
  return MEMORY[0x1E0D1F688]();
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::end_mutate(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1E0DDB438](this);
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::begin_mutate(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1E0DDB440](this);
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::lf_read_sync_write_impl(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1E0DDB448](this);
}

void caulk::concurrent::message::~message(caulk::concurrent::message *this)
{
  MEMORY[0x1E0DDB450](this);
}

uint64_t caulk::concurrent::messenger::shared_high_priority(caulk::concurrent::messenger *this)
{
  return MEMORY[0x1E0DDB458](this);
}

uint64_t caulk::concurrent::messenger::shared_logging_priority(caulk::concurrent::messenger *this)
{
  return MEMORY[0x1E0DDB460](this);
}

uint64_t caulk::concurrent::messenger::drain(caulk::concurrent::messenger *this)
{
  return MEMORY[0x1E0DDB468](this);
}

uint64_t caulk::concurrent::messenger::enqueue(caulk::concurrent::messenger *this, caulk::concurrent::message *a2)
{
  return MEMORY[0x1E0DDB470](this, a2);
}

uint64_t caulk::concurrent::messenger::messenger()
{
  return MEMORY[0x1E0DDB478]();
}

void caulk::concurrent::messenger::~messenger(caulk::concurrent::messenger *this)
{
  MEMORY[0x1E0DDB488](this);
}

uint64_t caulk::deferred_logger::create_message(caulk::deferred_logger *this, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1E0DDB490](this, a2, a3);
}

uint64_t caulk::deferred_logger::create_v(caulk::deferred_logger *this, void *a2)
{
  return MEMORY[0x1E0DDB498](this, a2);
}

uint64_t caulk::autorelease_pool::autorelease_pool(caulk::autorelease_pool *this)
{
  return MEMORY[0x1E0DDB4A0](this);
}

void caulk::autorelease_pool::~autorelease_pool(caulk::autorelease_pool *this)
{
  MEMORY[0x1E0DDB4A8](this);
}

uint64_t caulk::pooled_semaphore_mutex::_lock(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x1E0DDB4C0](this);
}

uint64_t caulk::pooled_semaphore_mutex::_unlock(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x1E0DDB4C8](this);
}

uint64_t caulk::pooled_semaphore_mutex::try_lock(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x1E0DDB4D0](this);
}

uint64_t caulk::pooled_semaphore_mutex::pooled_semaphore_mutex(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x1E0DDB4D8](this);
}

uint64_t caulk::init_realtime_safe_resource(caulk *this)
{
  return MEMORY[0x1E0DDB4F8](this);
}

uint64_t caulk::platform::process_name(caulk::platform *this)
{
  return MEMORY[0x1E0DDB6F0](this);
}

uint64_t caulk::semaphore::timed_wait(caulk::semaphore *this, double a2)
{
  return MEMORY[0x1E0DDB6F8](this, a2);
}

uint64_t caulk::semaphore::signal(caulk::semaphore *this)
{
  return MEMORY[0x1E0DDB700](this);
}

uint64_t caulk::semaphore::semaphore(caulk::semaphore *this)
{
  return MEMORY[0x1E0DDB708](this);
}

void caulk::semaphore::~semaphore(caulk::semaphore *this)
{
  MEMORY[0x1E0DDB710](this);
}

uint64_t AudioDSP::Core::HeadTracker::Initialize()
{
  return MEMORY[0x1E0DDE728]();
}

uint64_t AudioDSP::Core::HeadTracker::DisconnectRM(AudioDSP::Core::HeadTracker *this)
{
  return MEMORY[0x1E0DDE730](this);
}

uint64_t AudioDSP::Core::HeadTracker::GetCurrentHeadPose(AudioDSP::Core::HeadTracker *this, simd_quatf *a2)
{
  return MEMORY[0x1E0DDE738](this, a2);
}

uint64_t AudioDSP::Core::HeadTracker::SetCanAccessHALAPIs(AudioDSP::Core::HeadTracker *this)
{
  return MEMORY[0x1E0DDE740](this);
}

uint64_t AudioDSP::Core::HeadTracker::RegisterUserChoiceListener(AudioDSP::Core::HeadTracker *this)
{
  return MEMORY[0x1E0DDE748](this);
}

uint64_t AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener(AudioDSP::Core::HeadTracker *this)
{
  return MEMORY[0x1E0DDE750](this);
}

uint64_t AudioDSP::Core::HeadTracker::ConnectRM()
{
  return MEMORY[0x1E0DDE758]();
}

uint64_t AudioDSP::Core::HeadTracker::HeadTracker()
{
  return MEMORY[0x1E0DDE760]();
}

void AudioDSP::Core::HeadTracker::~HeadTracker(AudioDSP::Core::HeadTracker *this)
{
  MEMORY[0x1E0DDE768](this);
}

uint64_t DSPGraph::ABIVersion(DSPGraph *this)
{
  return MEMORY[0x1E0CFF968](this);
}

uint64_t DSPGraph::Interpreter::compileFile()
{
  return MEMORY[0x1E0CFF9A8]();
}

uint64_t DSPGraph::Interpreter::compileText()
{
  return MEMORY[0x1E0CFF9B0]();
}

uint64_t DSPGraph::Interpreter::Interpreter()
{
  return MEMORY[0x1E0CFF9B8]();
}

void DSPGraph::Interpreter::~Interpreter(DSPGraph::Interpreter *this)
{
  MEMORY[0x1E0CFF9C0](this);
}

uint64_t DSPGraph::NewBoxRegistry::add()
{
  return MEMORY[0x1E0CFF9E8]();
}

uint64_t DSPGraph::NewBoxRegistry::NewBoxRegistry(DSPGraph::NewBoxRegistry *this)
{
  return MEMORY[0x1E0CFF9F0](this);
}

uint64_t DSPGraph::ThrowException()
{
  return MEMORY[0x1E0CFF9F8]();
}

uint64_t DSPGraph::MakeFloatNoninterleavedFormat(DSPGraph *this, double a2)
{
  return MEMORY[0x1E0CFFA00](this, a2);
}

uint64_t DSPGraph::Box::initialize(DSPGraph::Box *this)
{
  return MEMORY[0x1E0CFFA08](this);
}

uint64_t DSPGraph::Box::selfLatencyInSeconds(DSPGraph::Box *this)
{
  return MEMORY[0x1E0CFFA28](this);
}

uint64_t DSPGraph::Box::totalLatencyInSamples(DSPGraph::Box *this)
{
  return MEMORY[0x1E0CFFA30](this);
}

uint64_t DSPGraph::Box::propagateFlagsAndTimeStamp(DSPGraph::Box *this, uint64_t a2, const AudioTimeStamp *a3)
{
  return MEMORY[0x1E0CFFA48](this, a2, a3);
}

uint64_t DSPGraph::Box::Box(DSPGraph::Box *this)
{
  return MEMORY[0x1E0CFFA58](this);
}

void DSPGraph::Box::~Box(DSPGraph::Box *this)
{
  MEMORY[0x1E0CFFA60](this);
}

uint64_t DSPGraph::Graph::initialize(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFA68](this);
}

uint64_t DSPGraph::Graph::setAUStrip(DSPGraph::Graph *this, const __CFDictionary *a2)
{
  return MEMORY[0x1E0CFFA70](this, a2);
}

uint64_t DSPGraph::Graph::unconfigure(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFA78](this);
}

uint64_t DSPGraph::Graph::uninitialize(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFA80](this);
}

uint64_t DSPGraph::Graph::writeDotFile(DSPGraph::Graph *this, const char *a2)
{
  return MEMORY[0x1E0CFFA88](this, a2);
}

uint64_t DSPGraph::Graph::setSRCQuality(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFA98](this);
}

uint64_t DSPGraph::Graph::processMultiple()
{
  return MEMORY[0x1E0CFFAA8]();
}

uint64_t DSPGraph::Graph::setSRCAlgorithm(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFAB0](this);
}

uint64_t DSPGraph::Graph::setPropertyStrip(DSPGraph::Graph *this, const __CFDictionary *a2)
{
  return MEMORY[0x1E0CFFAB8](this, a2);
}

uint64_t DSPGraph::Graph::setPropertyStrip(DSPGraph::Graph *this, const __CFDictionary *a2, const __CFString *a3)
{
  return MEMORY[0x1E0CFFAC0](this, a2, a3);
}

uint64_t DSPGraph::Graph::setSliceDuration()
{
  return MEMORY[0x1E0CFFAC8]();
}

uint64_t DSPGraph::Graph::setSRCMinimumPhase(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFAD0](this);
}

uint64_t DSPGraph::Graph::getLatencyInSeconds(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFAD8](this);
}

uint64_t DSPGraph::Graph::initializeWithFlags(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFAE0](this);
}

uint64_t DSPGraph::Graph::add()
{
  return MEMORY[0x1E0CFFAE8]();
}

{
  return MEMORY[0x1E0CFFAF0]();
}

uint64_t DSPGraph::Graph::box()
{
  return MEMORY[0x1E0CFFAF8]();
}

uint64_t DSPGraph::Graph::reset(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFB00](this);
}

uint64_t DSPGraph::Graph::connect()
{
  return MEMORY[0x1E0CFFB08]();
}

{
  return MEMORY[0x1E0CFFB10]();
}

uint64_t DSPGraph::Graph::addInput()
{
  return MEMORY[0x1E0CFFB18]();
}

uint64_t DSPGraph::Graph::addOutput()
{
  return MEMORY[0x1E0CFFB20]();
}

uint64_t DSPGraph::Graph::configure(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFB28](this);
}

uint64_t DSPGraph::Graph::getFormat()
{
  return MEMORY[0x1E0CFFB30]();
}

uint64_t DSPGraph::Graph::preflight()
{
  return MEMORY[0x1E0CFFB38]();
}

uint64_t DSPGraph::Graph::Graph(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFB40](this);
}

uint64_t DSPGraph::strprintf(DSPGraph *this, const char *a2, ...)
{
  return MEMORY[0x1E0CFFB80](this, a2);
}

uint64_t IR::IRCoordinates::get()
{
  return MEMORY[0x1E0DDE770]();
}

uint64_t IR::IRCoordinates::operator!=()
{
  return MEMORY[0x1E0DDE778]();
}

uint64_t IR::ComplexDataCircBuffer::isInitialized(IR::ComplexDataCircBuffer *this)
{
  return MEMORY[0x1E0DDE780](this);
}

uint64_t IR::IRData::getMaxDelay(IR::IRData *this)
{
  return MEMORY[0x1E0DDE788](this);
}

uint64_t IR::IRData::getUserData(IR::IRData *this)
{
  return MEMORY[0x1E0DDE790](this);
}

uint64_t IR::IRData::getAverageIR(IR::IRData *this)
{
  return MEMORY[0x1E0DDE798](this);
}

uint64_t IR::IRData::getDataLayout(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7A0](this);
}

uint64_t IR::IRData::getFilterLength(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7A8](this);
}

uint64_t IR::IRData::getModelingDelay(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7B0](this);
}

uint64_t IR::IRData::getCoordinateTree(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7B8](this);
}

uint64_t IR::IRData::getPartitionLength(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7C0](this);
}

uint64_t IR::IRData::getProcessingDelay(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7C8](this);
}

uint64_t IR::IRData::getIRDataAttributes(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7D0](this);
}

uint64_t IR::IRData::isAverageIRComputed(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7D8](this);
}

uint64_t IR::IRData::getTriangulationData(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7E0](this);
}

uint64_t IR::IRData::getDefaultCoordinates(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7E8](this);
}

uint64_t IR::IRData::getInterpolatedCoeffs()
{
  return MEMORY[0x1E0DDE7F0]();
}

uint64_t IR::IRData::getAudioChannelLayoutTag(IR::IRData *this)
{
  return MEMORY[0x1E0DDE7F8](this);
}

uint64_t IR::IRData::canInterpolateInDimension()
{
  return MEMORY[0x1E0DDE800]();
}

uint64_t IR::IRData::getNumFiltersPerSpatialPoint(IR::IRData *this)
{
  return MEMORY[0x1E0DDE808](this);
}

uint64_t IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>()
{
  return off_1E69A9C00();
}

uint64_t IR::FFTFilter::doXFadeUpdate(IR::FFTFilter *this)
{
  return MEMORY[0x1E0DDE810](this);
}

uint64_t E5RT::TensorDescriptor::GetSize(E5RT::TensorDescriptor *this)
{
  return MEMORY[0x1E0D1F7A8](this);
}

uint64_t E5RT::OperandDescriptor::TensorDescriptor(E5RT::OperandDescriptor *this)
{
  return MEMORY[0x1E0D1F7B0](this);
}

uint64_t E5RT::OperandDescriptor::SurfaceDescriptor(E5RT::OperandDescriptor *this)
{
  return MEMORY[0x1E0D1F7B8](this);
}

uint64_t E5RT::OperandDescriptor::TryAsTensorDescriptor(E5RT::OperandDescriptor *this)
{
  return MEMORY[0x1E0D1F7C0](this);
}

uint64_t E5RT::OperandDescriptor::TryAsSurfaceDescriptor(E5RT::OperandDescriptor *this)
{
  return MEMORY[0x1E0D1F7C8](this);
}

uint64_t E5RT::ExecutionStreamOperation::GetInputPorts(E5RT::ExecutionStreamOperation *this)
{
  return MEMORY[0x1E0D1F7D0](this);
}

uint64_t E5RT::ExecutionStreamOperation::GetOutputPorts(E5RT::ExecutionStreamOperation *this)
{
  return MEMORY[0x1E0D1F7D8](this);
}

uint64_t E5RT::IOPort::GetPortDescriptor(E5RT::IOPort *this)
{
  return MEMORY[0x1E0D1F7E0](this);
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::end_access(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1E0DDB718](this);
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::begin_access(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1E0DDB720](this);
}

uint64_t AudioDSP::Core::HeadTracker::HasActiveRMConnection(AudioDSP::Core::HeadTracker *this)
{
  return MEMORY[0x1E0DDE818](this);
}

uint64_t AudioDSP::Core::HeadTracker::GetAppliedFaceToDevicePitchAngleOffset(AudioDSP::Core::HeadTracker *this)
{
  return MEMORY[0x1E0DDE820](this);
}

uint64_t DSPGraph::NewBoxRegistry::newBox()
{
  return MEMORY[0x1E0CFFB90]();
}

uint64_t DSPGraph::Graph::numOutputs(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFBD8](this);
}

uint64_t DSPGraph::Graph::hasProperty(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFBE0](this);
}

uint64_t DSPGraph::Graph::hasParameter(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFBE8](this);
}

uint64_t DSPGraph::Graph::getFormatNames(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFBF0](this);
}

uint64_t DSPGraph::Graph::getParameterList(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFBF8](this);
}

uint64_t DSPGraph::Graph::in(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFC00](this);
}

uint64_t DSPGraph::Graph::out(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFC08](this);
}

uint64_t DSPGraph::Graph::decompile()
{
  return MEMORY[0x1E0CFFC10]();
}

uint64_t DSPGraph::Graph::numInputs(DSPGraph::Graph *this)
{
  return MEMORY[0x1E0CFFC18](this);
}

const char *__cdecl std::runtime_error::what(const std::runtime_error *this)
{
  return (const char *)MEMORY[0x1E0DE4190](this);
}

std::string *__cdecl std::error_code::message(std::string *__return_ptr retstr, const std::error_code *this)
{
  return (std::string *)MEMORY[0x1E0DE41A0](retstr, this);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return MEMORY[0x1E0DE41D8](this, __s);
}

const std::__fs::filesystem::directory_entry *__cdecl std::__fs::filesystem::directory_iterator::__dereference(const std::__fs::filesystem::directory_iterator *this)
{
  return (const std::__fs::filesystem::directory_entry *)MEMORY[0x1E0DE41F8](this);
}

const std::__fs::filesystem::directory_entry *__cdecl std::__fs::filesystem::recursive_directory_iterator::__dereference(const std::__fs::filesystem::recursive_directory_iterator *this)
{
  return (const std::__fs::filesystem::directory_entry *)MEMORY[0x1E0DE4200](this);
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__filename(const std::__fs::filesystem::path *this)
{
  const std::string_view::value_type *v1;
  std::basic_string_view<_CharT, _Traits>::size_type v2;
  std::__fs::filesystem::path::__string_view result;

  v1 = (const std::string_view::value_type *)MEMORY[0x1E0DE4208](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__extension(const std::__fs::filesystem::path *this)
{
  const std::string_view::value_type *v1;
  std::basic_string_view<_CharT, _Traits>::size_type v2;
  std::__fs::filesystem::path::__string_view result;

  v1 = (const std::string_view::value_type *)MEMORY[0x1E0DE4210](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__parent_path(const std::__fs::filesystem::path *this)
{
  const std::string_view::value_type *v1;
  std::basic_string_view<_CharT, _Traits>::size_type v2;
  std::__fs::filesystem::path::__string_view result;

  v1 = (const std::string_view::value_type *)MEMORY[0x1E0DE4218](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__root_directory(const std::__fs::filesystem::path *this)
{
  const std::string_view::value_type *v1;
  std::basic_string_view<_CharT, _Traits>::size_type v2;
  std::__fs::filesystem::path::__string_view result;

  v1 = (const std::string_view::value_type *)MEMORY[0x1E0DE4220](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path *__cdecl std::__fs::filesystem::path::lexically_relative(std::__fs::filesystem::path *__return_ptr retstr, const std::__fs::filesystem::path *this, const std::__fs::filesystem::path *__base)
{
  return (std::__fs::filesystem::path *)MEMORY[0x1E0DE4228](retstr, this, __base);
}

int std::__fs::filesystem::path::__compare(const std::__fs::filesystem::path *this, std::__fs::filesystem::path::__string_view a2)
{
  return MEMORY[0x1E0DE4238](this, a2.__data_, a2.__size_);
}

std::string *__cdecl std::locale::name(std::string *__return_ptr retstr, const std::locale *this)
{
  return (std::string *)MEMORY[0x1E0DE4240](retstr, this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

BOOL std::locale::operator==(const std::locale *this, const std::locale *a2)
{
  return MEMORY[0x1E0DE4250](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

const char *__cdecl std::exception::what(const std::exception *this)
{
  return (const char *)MEMORY[0x1E0DE4270](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4278](this, a2);
}

{
  return (std::logic_error *)MEMORY[0x1E0DE4288](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4290](this, a2);
}

void std::logic_error::~logic_error(std::logic_error *this)
{
  MEMORY[0x1E0DE42A8](this);
}

std::exception_ptr *__cdecl std::exception_ptr::exception_ptr(std::exception_ptr *this, const std::exception_ptr *a2)
{
  return (std::exception_ptr *)MEMORY[0x1E0DE42F0](this, a2);
}

void std::exception_ptr::~exception_ptr(std::exception_ptr *this)
{
  MEMORY[0x1E0DE42F8](this);
}

std::exception_ptr *__cdecl std::exception_ptr::operator=(std::exception_ptr *this, const std::exception_ptr *a2)
{
  return (std::exception_ptr *)MEMORY[0x1E0DE4300](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1E0DE4308](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x1E0DE4320](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return (std::runtime_error *)MEMORY[0x1E0DE4310](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x1E0DE4328](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::runtime_error *a2)
{
  return (std::runtime_error *)MEMORY[0x1E0DE4318](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x1E0DE4330](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
  MEMORY[0x1E0DE4338](this);
}

{
  MEMORY[0x1E0DE4340](this);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1E0DE4388](this);
}

void std::__call_once(std::once_flag::_State_type *a1, void *a2, void (__cdecl *a3)(void *))
{
  MEMORY[0x1E0DE43A8](a1, a2, a3);
}

std::regex_error *__cdecl std::regex_error::regex_error(std::regex_error *this, std::regex_constants::error_type __ecode)
{
  return (std::regex_error *)MEMORY[0x1E0DE43B0](this, *(_QWORD *)&__ecode);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
  MEMORY[0x1E0DE43F8](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add, __p_new_stuff);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4408](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4428](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4470](this, __pos, __s, __n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  MEMORY[0x1E0DE4480](this, __n, __c);
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x1E0DE4490](this, __pos, __n1, __s, __n2);
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
  MEMORY[0x1E0DE44A8](this, __requested_capacity);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
  MEMORY[0x1E0DE44B0](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x1E0DE44B8](this, __c);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1E0DE44C8](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1E0DE44D8](this, __str);
}

std::system_error *__cdecl std::system_error::system_error(std::system_error *this, int __ev, const std::error_category *__ecat)
{
  return (std::system_error *)MEMORY[0x1E0DE4560](this, *(_QWORD *)&__ev, __ecat);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1E0DE4590]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1E0DE45A0]();
}

{
  return MEMORY[0x1E0DE45A8]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1E0DE45B0]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1E0DE4608]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1E0DE4628]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x1E0DE4638]();
}

{
  return MEMORY[0x1E0DE4650]();
}

{
  return MEMORY[0x1E0DE4670]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x1E0DE4698]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x1E0DE46A0]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x1E0DE46A8]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1E0DE46B0]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1E0DE46B8]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1E0DE46C0]();
}

{
  return MEMORY[0x1E0DE46C8]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1E0DE46D0]();
}

{
  return MEMORY[0x1E0DE46E0]();
}

{
  return MEMORY[0x1E0DE46E8]();
}

{
  return MEMORY[0x1E0DE46F8]();
}

{
  return MEMORY[0x1E0DE4700]();
}

{
  return MEMORY[0x1E0DE4708]();
}

{
  return MEMORY[0x1E0DE4718]();
}

{
  return MEMORY[0x1E0DE4728]();
}

{
  return MEMORY[0x1E0DE4738]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1E0DE47A8]();
}

void std::error_category::~error_category(std::error_category *this)
{
  MEMORY[0x1E0DE47C0](this);
}

std::regex_traits<char>::char_class_type std::__get_classname(const char *__s, BOOL __icase)
{
  return MEMORY[0x1E0DE47C8](__s, __icase);
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

void std::recursive_mutex::lock(std::recursive_mutex *this)
{
  MEMORY[0x1E0DE4820](this);
}

void std::recursive_mutex::unlock(std::recursive_mutex *this)
{
  MEMORY[0x1E0DE4828](this);
}

std::recursive_mutex *__cdecl std::recursive_mutex::recursive_mutex(std::recursive_mutex *this)
{
  return (std::recursive_mutex *)MEMORY[0x1E0DE4838](this);
}

void std::recursive_mutex::~recursive_mutex(std::recursive_mutex *this)
{
  MEMORY[0x1E0DE4840](this);
}

const std::error_category *std::system_category(void)
{
  return (const std::error_category *)MEMORY[0x1E0DE4848]();
}

void std::condition_variable::notify_one(std::condition_variable *this)
{
  MEMORY[0x1E0DE4898](this);
}

void std::condition_variable::__do_timed_wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk, std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> a3)
{
  MEMORY[0x1E0DE48A0](this, __lk, a3.__d_.__rep_);
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
  MEMORY[0x1E0DE48B0](this);
}

void std::__shared_mutex_base::lock_shared(std::__shared_mutex_base *this)
{
  MEMORY[0x1E0DE48B8](this);
}

void std::__shared_mutex_base::unlock_shared(std::__shared_mutex_base *this)
{
  MEMORY[0x1E0DE48C0](this);
}

BOOL std::__shared_mutex_base::try_lock_shared(std::__shared_mutex_base *this)
{
  return MEMORY[0x1E0DE48C8](this);
}

void std::__shared_mutex_base::lock(std::__shared_mutex_base *this)
{
  MEMORY[0x1E0DE48D0](this);
}

void std::__shared_mutex_base::unlock(std::__shared_mutex_base *this)
{
  MEMORY[0x1E0DE48D8](this);
}

BOOL std::__shared_mutex_base::try_lock(std::__shared_mutex_base *this)
{
  return MEMORY[0x1E0DE48E0](this);
}

std::__shared_mutex_base *__cdecl std::__shared_mutex_base::__shared_mutex_base(std::__shared_mutex_base *this)
{
  return (std::__shared_mutex_base *)MEMORY[0x1E0DE48E8](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1E0DE48F8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

std::string *__cdecl std::__get_collation_name(std::string *__return_ptr retstr, const char *__s)
{
  return (std::string *)MEMORY[0x1E0DE4910](retstr, __s);
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
  MEMORY[0x1E0DE4920](*(_QWORD *)&__ev, __what_arg);
}

uint64_t std::pmr::get_default_resource(std::pmr *this)
{
  return MEMORY[0x1E0DE4950](this);
}

std::__fs::filesystem::path *__cdecl std::__fs::filesystem::__absolute(std::__fs::filesystem::path *__return_ptr retstr, const std::__fs::filesystem::path *a2, std::error_code *__ec)
{
  return (std::__fs::filesystem::path *)MEMORY[0x1E0DE4958](retstr, a2, __ec);
}

size_t std::__fs::filesystem::hash_value(const std::__fs::filesystem::path *__p)
{
  return MEMORY[0x1E0DE4960](__p);
}

uintmax_t std::__fs::filesystem::__file_size(const std::__fs::filesystem::path *a1, std::error_code *__ec)
{
  return MEMORY[0x1E0DE4978](a1, __ec);
}

BOOL std::__fs::filesystem::__create_directory(const std::__fs::filesystem::path *a1, std::error_code *a2)
{
  return MEMORY[0x1E0DE49D8](a1, a2);
}

std::__fs::filesystem::directory_iterator *__cdecl std::__fs::filesystem::directory_iterator::__increment(std::__fs::filesystem::directory_iterator *this, std::error_code *__ec)
{
  return (std::__fs::filesystem::directory_iterator *)MEMORY[0x1E0DE49F0](this, __ec);
}

std::__fs::filesystem::directory_iterator *__cdecl std::__fs::filesystem::directory_iterator::directory_iterator(std::__fs::filesystem::directory_iterator *this, const std::__fs::filesystem::path *a2, std::error_code *a3, std::__fs::filesystem::directory_options a4)
{
  return (std::__fs::filesystem::directory_iterator *)MEMORY[0x1E0DE49F8](this, a2, a3, a4);
}

BOOL std::__fs::filesystem::__create_directories(const std::__fs::filesystem::path *a1, std::error_code *a2)
{
  return MEMORY[0x1E0DE4A00](a1, a2);
}

std::__fs::filesystem::path *__cdecl std::__fs::filesystem::__temp_directory_path(std::__fs::filesystem::path *__return_ptr retstr, std::error_code *__ec)
{
  return (std::__fs::filesystem::path *)MEMORY[0x1E0DE4A08](retstr, __ec);
}

std::__fs::filesystem::recursive_directory_iterator *__cdecl std::__fs::filesystem::recursive_directory_iterator::__increment(std::__fs::filesystem::recursive_directory_iterator *this, std::error_code *__ec)
{
  return (std::__fs::filesystem::recursive_directory_iterator *)MEMORY[0x1E0DE4A10](this, __ec);
}

std::__fs::filesystem::recursive_directory_iterator *__cdecl std::__fs::filesystem::recursive_directory_iterator::recursive_directory_iterator(std::__fs::filesystem::recursive_directory_iterator *this, const std::__fs::filesystem::path *__p, std::__fs::filesystem::directory_options __opt, std::error_code *__ec)
{
  return (std::__fs::filesystem::recursive_directory_iterator *)MEMORY[0x1E0DE4A18](this, __p, __opt, __ec);
}

std::__fs::filesystem::path *__cdecl std::__fs::filesystem::path::replace_extension(std::__fs::filesystem::path *this, const std::__fs::filesystem::path *__replacement)
{
  return (std::__fs::filesystem::path *)MEMORY[0x1E0DE4A20](this, __replacement);
}

BOOL std::__fs::filesystem::__remove(const std::__fs::filesystem::path *a1, std::error_code *__ec)
{
  return MEMORY[0x1E0DE4A38](a1, __ec);
}

void std::__fs::filesystem::__rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x1E0DE4A40](__from, __to, __ec);
}

std::__fs::filesystem::file_status std::__fs::filesystem::__status(const std::__fs::filesystem::path *a1, std::error_code *__ec)
{
  return (std::__fs::filesystem::file_status)MEMORY[0x1E0DE4A48](a1, __ec);
}

double std::stod(const std::string *__str, size_t *__idx)
{
  double result;

  MEMORY[0x1E0DE4A68](__str, __idx);
  return result;
}

int std::stoi(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1E0DE4A78](__str, __idx, *(_QWORD *)&__base);
}

void *__cdecl std::align(size_t __align, size_t __sz, void **__ptr, size_t *__space)
{
  return (void *)MEMORY[0x1E0DE4A88](__align, __sz, __ptr, __space);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA0](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA8](this);
}

BOOL std::mutex::try_lock(std::mutex *this)
{
  return MEMORY[0x1E0DE4AB0](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x1E0DE4AB8](this);
}

uint64_t std::__sort<std::__less<float,float> &,float *>()
{
  return MEMORY[0x1E0DE4AE8]();
}

uint64_t std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>()
{
  return MEMORY[0x1E0DE4B00]();
}

uint64_t std::__sort<std::__less<unsigned long,unsigned long> &,unsigned long *>()
{
  return MEMORY[0x1E0DE4B10]();
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x1E0DE4B38]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1E0DE4B48]();
}

time_t std::chrono::system_clock::to_time_t(const std::chrono::system_clock::time_point *__t)
{
  return MEMORY[0x1E0DE4B50](__t);
}

const std::locale *std::locale::classic(void)
{
  return (const std::locale *)MEMORY[0x1E0DE4B78]();
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x1E0DE4B88](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x1E0DE4B90](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

const std::locale *__cdecl std::locale::operator=(std::locale *this, const std::locale *a2)
{
  return (const std::locale *)MEMORY[0x1E0DE4BA0](this, a2);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x1E0DE4C50](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::move(std::ios_base *this, std::ios_base *a2)
{
  MEMORY[0x1E0DE4C70](this, a2);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::to_chars(std::__1 *this, char *a2, char *a3, double a4)
{
  return MEMORY[0x1E0DE4CD8](this, a2, a3, a4);
}

{
  return MEMORY[0x1E0DE4CF0](this, a2, a3, a4);
}

uint64_t std::to_chars()
{
  return MEMORY[0x1E0DE4CE0]();
}

{
  return MEMORY[0x1E0DE4CE8]();
}

{
  return MEMORY[0x1E0DE4CF8]();
}

{
  return MEMORY[0x1E0DE4D00]();
}

{
  return MEMORY[0x1E0DE4D10]();
}

{
  return MEMORY[0x1E0DE4D18]();
}

uint64_t std::to_chars(std::__1 *this, char *a2, char *a3, float a4)
{
  return MEMORY[0x1E0DE4D08](this, a2, a3, a4);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x1E0DE4D40](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, float __val)
{
  return (std::string *)MEMORY[0x1E0DE4D50](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D58](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D60](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, uint64_t __val)
{
  return (std::string *)MEMORY[0x1E0DE4D68](retstr, __val);
}

{
  return (std::string *)MEMORY[0x1E0DE4D78](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x1E0DE4D70](retstr, __val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x1E0DE4D88]();
}

std::bad_cast *__cdecl std::bad_cast::bad_cast(std::bad_cast *this)
{
  return (std::bad_cast *)MEMORY[0x1E0DE4D90](this);
}

{
  return (std::bad_cast *)MEMORY[0x1E0DE4D98](this);
}

void std::bad_cast::~bad_cast(std::bad_cast *this)
{
  MEMORY[0x1E0DE4DA8](this);
}

std::bad_alloc *__cdecl std::bad_alloc::bad_alloc(std::bad_alloc *this)
{
  return (std::bad_alloc *)MEMORY[0x1E0DE4DB0](this);
}

void std::bad_alloc::~bad_alloc(std::bad_alloc *this)
{
  MEMORY[0x1E0DE4DC0](this);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x1E0DE4DD0](this);
}

{
  MEMORY[0x1E0DE4DD8](this);
}

std::exception_ptr std::current_exception(void)
{
  return (std::exception_ptr)MEMORY[0x1E0DE4DF0]();
}

void std::rethrow_exception(std::exception_ptr a1)
{
  MEMORY[0x1E0DE4DF8](a1.__ptr_);
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

uint64_t operator delete[]()
{
  return off_1E69AA378();
}

void operator delete(void *__p)
{
  off_1E69AA380(__p);
}

void operator delete(void *__p, std::align_val_t a2)
{
  off_1E69AA388(__p, a2);
}

uint64_t operator delete()
{
  return off_1E69AA390();
}

void *__cdecl operator new[](size_t __sz, const std::nothrow_t *a2)
{
  return (void *)off_1E69AA398(__sz, a2);
}

uint64_t operator new[]()
{
  return off_1E69AA3A0();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E69AA3A8(__sz);
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2)
{
  return (void *)off_1E69AA3B0(__sz, a2);
}

uint64_t operator new()
{
  return off_1E69AA3B8();
}

CFStringRef __CFStringMakeConstantString(const char *cStr)
{
  return (CFStringRef)MEMORY[0x1E0C9AA00](cStr);
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1E0C80A98](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE5098]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x1E0DE50A0](a1);
}

void *__cxa_get_exception_ptr(void *a1)
{
  return (void *)MEMORY[0x1E0DE50A8](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x1E0DE50B0](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x1E0DE50D0]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

double __exp10(double a1)
{
  double result;

  MEMORY[0x1E0C80AC8](a1);
  return result;
}

float __exp10f(float a1)
{
  float result;

  MEMORY[0x1E0C80AD0](a1);
  return result;
}

uint64_t __invert_d3()
{
  return MEMORY[0x1E0C80B18]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

uint64_t __powidf2()
{
  return MEMORY[0x1E0C80B98]();
}

uint64_t __powisf2()
{
  return MEMORY[0x1E0C80BA0]();
}

__double2 __sincos_stret(double a1)
{
  double v1;
  double v2;
  __double2 result;

  MEMORY[0x1E0C80BC8](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  float v1;
  float v2;
  __float2 result;

  MEMORY[0x1E0C80BD0](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C70](*(_QWORD *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C78](*(_QWORD *)&a1);
}

uint64_t __udivti3()
{
  return MEMORY[0x1E0C80C80]();
}

uint64_t __umodti3()
{
  return MEMORY[0x1E0C80C98]();
}

uint64_t _get_cpu_capabilities()
{
  return MEMORY[0x1E0C80F88]();
}

uint64_t _os_assert_log()
{
  return MEMORY[0x1E0C80FF0]();
}

uint64_t _os_crash()
{
  return MEMORY[0x1E0C81000]();
}

uint64_t _os_crash_msg()
{
  return MEMORY[0x1E0C81008]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1E0C81010]();
}

uint64_t _os_feature_enabled_simple_impl()
{
  return MEMORY[0x1E0C81018]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81020](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81040](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _os_log_pack_fill()
{
  return MEMORY[0x1E0C81058]();
}

uint64_t _os_log_pack_size()
{
  return MEMORY[0x1E0C81060]();
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x1E0C81068]();
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C810D0](dso, log, type, spid, name, format, buf, *(_QWORD *)&size);
}

simd_float4 _simd_pow_f4(simd_float4 x, simd_float4 y)
{
  simd_float4 result;

  MEMORY[0x1E0C811F8]((__n128)x, (__n128)y);
  return result;
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1E0DA88F0]();
}

uint64_t _xpc_runtime_is_app_sandboxed()
{
  return MEMORY[0x1E0C812A0]();
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x1E0C813B0]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1E0C813D0](a1, *(_QWORD *)&a2);
}

float acosf(float a1)
{
  float result;

  MEMORY[0x1E0C81508](a1);
  return result;
}

float asinf(float a1)
{
  float result;

  MEMORY[0x1E0C815A0](a1);
  return result;
}

long double atan2(long double __y, long double __x)
{
  long double result;

  MEMORY[0x1E0C81620](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C81628](a1, a2);
  return result;
}

float atanf(float a1)
{
  float result;

  MEMORY[0x1E0C81630](a1);
  return result;
}

char *__cdecl basename(char *a1)
{
  return (char *)MEMORY[0x1E0C816D8](a1);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

int cache_create(const char *name, const cache_attributes_t *attrs, cache_t **cache_out)
{
  return MEMORY[0x1E0C81770](name, attrs, cache_out);
}

int cache_destroy(cache_t *cache)
{
  return MEMORY[0x1E0C81778](cache);
}

int cache_get_and_retain(cache_t *cache, void *key, void **value_out)
{
  return MEMORY[0x1E0C81788](cache, key, value_out);
}

int cache_release_value(cache_t *cache, void *value)
{
  return MEMORY[0x1E0C817D8](cache, value);
}

int cache_set_and_retain(cache_t *cache, void *key, void *value, cache_cost_t cost)
{
  return MEMORY[0x1E0C817F8](cache, key, value, cost);
}

void catlas_saxpby(const int __N, const float __alpha, const float *__X, const int __incX, const float __beta, float *__Y, const int __incY)
{
  MEMORY[0x1E0C8BAD8](*(_QWORD *)&__N, __X, *(_QWORD *)&__incX, __Y, *(_QWORD *)&__incY, __alpha, __beta);
}

void cblas_cgemv(const CBLAS_ORDER __Order, const CBLAS_TRANSPOSE __TransA, const int __M, const int __N, const void *__alpha, const void *__A, const int __lda, const void *__X, const int __incX, const void *__beta, void *__Y, const int __incY)
{
  MEMORY[0x1E0C8BAF0](*(_QWORD *)&__Order, *(_QWORD *)&__TransA, *(_QWORD *)&__M, *(_QWORD *)&__N, __alpha, __A, *(_QWORD *)&__lda, __X);
}

void cblas_cgerc(const CBLAS_ORDER __Order, const int __M, const int __N, const void *__alpha, const void *__X, const int __incX, const void *__Y, const int __incY, void *__A, const int __lda)
{
  MEMORY[0x1E0C8BAF8](*(_QWORD *)&__Order, *(_QWORD *)&__M, *(_QWORD *)&__N, __alpha, __X, *(_QWORD *)&__incX, __Y, *(_QWORD *)&__incY);
}

void cblas_csscal(const int __N, const float __alpha, void *__X, const int __incX)
{
  MEMORY[0x1E0C8BB00](*(_QWORD *)&__N, __X, *(_QWORD *)&__incX, __alpha);
}

void cblas_scopy(const int __N, const float *__X, const int __incX, float *__Y, const int __incY)
{
  MEMORY[0x1E0C8BBC8](*(_QWORD *)&__N, __X, *(_QWORD *)&__incX, __Y, *(_QWORD *)&__incY);
}

float cblas_sdot(const int __N, const float *__X, const int __incX, const float *__Y, const int __incY)
{
  float result;

  MEMORY[0x1E0C8BBD8](*(_QWORD *)&__N, __X, *(_QWORD *)&__incX, __Y, *(_QWORD *)&__incY);
  return result;
}

float cblas_sdsdot(const int __N, const float __alpha, const float *__X, const int __incX, const float *__Y, const int __incY)
{
  float result;

  MEMORY[0x1E0C8BBE8](*(_QWORD *)&__N, __X, *(_QWORD *)&__incX, __Y, *(_QWORD *)&__incY, __alpha);
  return result;
}

void cblas_sgemv(const CBLAS_ORDER __Order, const CBLAS_TRANSPOSE __TransA, const int __M, const int __N, const float __alpha, const float *__A, const int __lda, const float *__X, const int __incX, const float __beta, float *__Y, const int __incY)
{
  MEMORY[0x1E0C8BC20](*(_QWORD *)&__Order, *(_QWORD *)&__TransA, *(_QWORD *)&__M, *(_QWORD *)&__N, __A, *(_QWORD *)&__lda, __X, *(_QWORD *)&__incX, __alpha, __beta);
}

float cblas_snrm2(const int __N, const float *__X, const int __incX)
{
  float result;

  MEMORY[0x1E0C8BC48](*(_QWORD *)&__N, __X, *(_QWORD *)&__incX);
  return result;
}

void cblas_sscal(const int __N, const float __alpha, float *__X, const int __incX)
{
  MEMORY[0x1E0C8BC60](*(_QWORD *)&__N, __X, *(_QWORD *)&__incX, __alpha);
}

int cgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BC80](__n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
}

int cgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BC88](__jobu, __jobvt, __m, __n, __a, __lda, __s, __u);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

long double cos(long double __x)
{
  long double result;

  MEMORY[0x1E0C82B40](__x);
  return result;
}

float cosf(float a1)
{
  float result;

  MEMORY[0x1E0C82B48](a1);
  return result;
}

int cpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BC90](__uplo, __n, __a, __lda, __info);
}

int dgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BC98](__job, __n, __a, __lda, __ilo, __ihi, __scale, __info);
}

int dgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BD20](__m, __n, __a, __lda, __ipiv, __info);
}

int dgetri_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BD30](__n, __a, __lda, __ipiv, __work, __lwork, __info);
}

int dhseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BD38](__job, __compz, __n, __ilo, __ihi, __h__, __ldh, __wr);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
  MEMORY[0x1E0C82BD8](iterations, queue, block);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82C18](queue, context, work);
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  return (void *)MEMORY[0x1E0C82CF0](object);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA8](object);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
  MEMORY[0x1E0C82EE0](object, context);
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
  MEMORY[0x1E0C82EE8](object, finalizer);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1E0C83038]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

uint64_t espresso_context_destroy()
{
  return MEMORY[0x1E0D1FF10]();
}

uint64_t espresso_create_context()
{
  return MEMORY[0x1E0D1FF38]();
}

uint64_t espresso_create_plan()
{
  return MEMORY[0x1E0D1FF40]();
}

uint64_t espresso_network_bind_buffer()
{
  return MEMORY[0x1E0D1FFB8]();
}

uint64_t espresso_plan_add_network()
{
  return MEMORY[0x1E0D200B0]();
}

uint64_t espresso_plan_build()
{
  return MEMORY[0x1E0D200C8]();
}

uint64_t espresso_plan_destroy()
{
  return MEMORY[0x1E0D200E8]();
}

uint64_t espresso_plan_execute_sync()
{
  return MEMORY[0x1E0D20100]();
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x1E0C83280](__x);
  return result;
}

long double exp2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83288](__x);
  return result;
}

float exp2f(float a1)
{
  float result;

  MEMORY[0x1E0C83290](a1);
  return result;
}

float expf(float a1)
{
  float result;

  MEMORY[0x1E0C83298](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1E0C83300](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int feof(FILE *a1)
{
  return MEMORY[0x1E0C83340](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x1E0C83348](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x1E0C833A0](a1, *(_QWORD *)&a2, a3);
}

int fileno(FILE *a1)
{
  return MEMORY[0x1E0C833B0](a1);
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C83440](__x, __y);
  return result;
}

float fmodf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C83448](a1, a2);
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1E0C83488](*(_QWORD *)&a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C834A0](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

int fscanf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83520](a1, a2);
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x1E0C83530](a1, a2, *(_QWORD *)&a3);
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  return MEMORY[0x1E0C83538](__stream, a2, *(_QWORD *)&__whence);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x1E0C83580](a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1E0C83590](*(_QWORD *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

long double hypot(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C838E8](__x, __y);
  return result;
}

float hypotf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C838F0](a1, a2);
  return result;
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1E0C83A20]();
}

float ldexpf(float a1, int a2)
{
  float result;

  MEMORY[0x1E0C83B48](*(_QWORD *)&a2, a1);
  return result;
}

lconv *localeconv(void)
{
  return (lconv *)MEMORY[0x1E0C83B98]();
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1E0C83BA8](a1);
}

long double log(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BB8](__x);
  return result;
}

long double log10(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BC0](__x);
  return result;
}

float log10f(float a1)
{
  float result;

  MEMORY[0x1E0C83BC8](a1);
  return result;
}

long double log2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BE8](__x);
  return result;
}

float log2f(float a1)
{
  float result;

  MEMORY[0x1E0C83BF0](a1);
  return result;
}

long double logb(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BF8](__x);
  return result;
}

float logf(float a1)
{
  float result;

  MEMORY[0x1E0C83C00](a1);
  return result;
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

kern_return_t mach_wait_until(uint64_t deadline)
{
  return MEMORY[0x1E0C83E28](deadline);
}

void *__cdecl malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF0](alignment, size, type_id);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x1E0C83F08](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_valloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F18](size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1E0C84070](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x1E0C840B8](__b, __pattern16, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C84160](a1, a2);
}

int mkpath_np(const char *path, mode_t omode)
{
  return MEMORY[0x1E0C84198](path, omode);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1E0C841D8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

long double modf(long double __x, long double *__y)
{
  long double result;

  MEMORY[0x1E0C841E0](__y, __x);
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1E0C84220](a1, a2);
}

float nexttowardf(float a1, long double a2)
{
  float result;

  MEMORY[0x1E0C843C0](a1, a2);
  return result;
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1E0C843E8](*(_QWORD *)&token, state64);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1E0DE7BF0](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1E0DE7BF8]();
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void objc_end_catch(void)
{
  MEMORY[0x1E0DE7C80]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1E0DE7D08](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7E58](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E60](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1E0DE7E70](a1);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7FA0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1E0DE7FB8](location, obj);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C84480](a1, *(_QWORD *)&a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1E0C84920](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1E0C84928](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1E0C84930](log, ptr);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C84998](lock);
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x1E0C849A8](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

uint64_t os_unfair_recursive_lock_lock_with_options()
{
  return MEMORY[0x1E0C849B8]();
}

uint64_t os_unfair_recursive_lock_unlock()
{
  return MEMORY[0x1E0C849D0]();
}

void perror(const char *a1)
{
  MEMORY[0x1E0C84AF0](a1);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C84BB8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C84BC0](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1E0C84BD0](a1);
}

int pthread_equal(pthread_t a1, pthread_t a2)
{
  return MEMORY[0x1E0C84D80](a1, a2);
}

int pthread_getname_np(pthread_t a1, char *a2, size_t a3)
{
  return MEMORY[0x1E0C84DB0](a1, a2, a3);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_trylock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E30](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EA0](a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EB8](a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EC0](a1);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1E0C84ED8]();
}

int puts(const char *a1)
{
  return MEMORY[0x1E0C84F60](a1);
}

int rand(void)
{
  return MEMORY[0x1E0C84FB0]();
}

uint64_t random(void)
{
  return MEMORY[0x1E0C84FC0]();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1E0C85000](*(_QWORD *)&a1, a2, a3);
}

float remainderf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C850B0](a1, a2);
  return result;
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return MEMORY[0x1E0C850B8](__p, __ec);
}

long double scalbn(long double __x, int __y)
{
  long double result;

  MEMORY[0x1E0C85240](*(_QWORD *)&__y, __x);
  return result;
}

int sched_yield(void)
{
  return MEMORY[0x1E0C85270]();
}

int sgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BDE0](__m, __n, __a, __lda, __tau, __work, __lwork, __info);
}

int sgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BDF0](__n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
}

int sgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BE08](__m, __n, __a, __lda, __ipiv, __info);
}

int sgetri_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BE10](__n, __a, __lda, __ipiv, __work, __lwork, __info);
}

long double sin(long double __x)
{
  long double result;

  MEMORY[0x1E0C85418](__x);
  return result;
}

float sinf(float a1)
{
  float result;

  MEMORY[0x1E0C85420](a1);
  return result;
}

long double sinh(long double __x)
{
  long double result;

  MEMORY[0x1E0C85428](__x);
  return result;
}

float sinhf(float a1)
{
  float result;

  MEMORY[0x1E0C85430](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int sorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BE18](__m, __n, __k, __a, __lda, __tau, __work, __lwork);
}

sparse_status sparse_commit(void *A)
{
  return MEMORY[0x1E0C8BE20](A);
}

sparse_status sparse_insert_entries_float(sparse_matrix_float A, sparse_dimension N, const float *val, const sparse_index *indx, const sparse_index *jndx)
{
  return MEMORY[0x1E0C8BE80](A, N, val, indx, jndx);
}

sparse_matrix_float sparse_matrix_create_float(sparse_dimension M, sparse_dimension N)
{
  return (sparse_matrix_float)MEMORY[0x1E0C8BEB0](M, N);
}

sparse_status sparse_matrix_destroy(void *A)
{
  return MEMORY[0x1E0C8BEB8](A);
}

sparse_status sparse_matrix_vector_product_dense_float(CBLAS_TRANSPOSE transa, float alpha, sparse_matrix_float A, const float *x, sparse_stride incx, float *y, sparse_stride incy)
{
  return MEMORY[0x1E0C8BED0](*(_QWORD *)&transa, A, x, incx, y, incy, alpha);
}

int sprintf(char *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C85460](a1, a2);
}

void srand(unsigned int a1)
{
  MEMORY[0x1E0C85478](*(_QWORD *)&a1);
}

void srandom(unsigned int a1)
{
  MEMORY[0x1E0C85488](*(_QWORD *)&a1);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C85498](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

char *__cdecl stpcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x1E0C854F0](__dst, __src);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x1E0C85530](__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x1E0C85558](a1, a2, a3, a4);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85568](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85570](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C855E8](__s, *(_QWORD *)&__c);
}

double strtod(const char *a1, char **a2)
{
  double result;

  MEMORY[0x1E0C85618](a1, a2);
  return result;
}

float strtof(const char *a1, char **a2)
{
  float result;

  MEMORY[0x1E0C85628](a1, a2);
  return result;
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85678](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C856A8](__str, __endptr, *(_QWORD *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1E0C85798](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1E0C857A0](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
  MEMORY[0x1E0C857D0](*(_QWORD *)&a1, a2);
}

long double tan(long double __x)
{
  long double result;

  MEMORY[0x1E0C857E8](__x);
  return result;
}

float tanf(float a1)
{
  float result;

  MEMORY[0x1E0C857F0](a1);
  return result;
}

float tanhf(float a1)
{
  float result;

  MEMORY[0x1E0C85800](a1);
  return result;
}

float tgammaf(float a1)
{
  float result;

  MEMORY[0x1E0C858D8](a1);
  return result;
}

uint64_t thread_selfcounts()
{
  return MEMORY[0x1E0C85918]();
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1E0C859E0](*(_QWORD *)&a1);
}

void vDSP_DFT_DestroySetup(vDSP_DFT_Setup __Setup)
{
  MEMORY[0x1E0C8BF50](__Setup);
}

void vDSP_DFT_Execute(const vDSP_DFT_SetupStruct *__Setup, const float *__Ir, const float *__Ii, float *__Or, float *__Oi)
{
  MEMORY[0x1E0C8BF60](__Setup, __Ir, __Ii, __Or, __Oi);
}

vDSP_DFT_Setup vDSP_DFT_zop_CreateSetup(vDSP_DFT_Setup __Previous, vDSP_Length __Length, vDSP_DFT_Direction __Direction)
{
  return (vDSP_DFT_Setup)MEMORY[0x1E0C8BFA0](__Previous, __Length, *(_QWORD *)&__Direction);
}

vDSP_DFT_Setup vDSP_DFT_zrop_CreateSetup(vDSP_DFT_Setup __Previous, vDSP_Length __Length, vDSP_DFT_Direction __Direction)
{
  return (vDSP_DFT_Setup)MEMORY[0x1E0C8BFB0](__Previous, __Length, *(_QWORD *)&__Direction);
}

void vDSP_biquad(const vDSP_biquad_SetupStruct *__Setup, float *__Delay, const float *__X, vDSP_Stride __IX, float *__Y, vDSP_Stride __IY, vDSP_Length __N)
{
  MEMORY[0x1E0C8BFC0](__Setup, __Delay, __X, __IX, __Y, __IY, __N);
}

vDSP_biquad_Setup vDSP_biquad_CreateSetup(const double *__Coefficients, vDSP_Length __M)
{
  return (vDSP_biquad_Setup)MEMORY[0x1E0C8BFD0](__Coefficients, __M);
}

void vDSP_biquad_DestroySetup(vDSP_biquad_Setup __setup)
{
  MEMORY[0x1E0C8BFE0](__setup);
}

void vDSP_biquadm(vDSP_biquadm_Setup __Setup, const float **__X, vDSP_Stride __IX, float **__Y, vDSP_Stride __IY, vDSP_Length __N)
{
  MEMORY[0x1E0C8BFF0](__Setup, __X, __IX, __Y, __IY, __N);
}

void vDSP_biquadm_CopyState(vDSP_biquadm_Setup __dest, const vDSP_biquadm_SetupStruct *__src)
{
  MEMORY[0x1E0C8C000](__dest, __src);
}

vDSP_biquadm_Setup vDSP_biquadm_CreateSetup(const double *__coeffs, vDSP_Length __M, vDSP_Length __N)
{
  return (vDSP_biquadm_Setup)MEMORY[0x1E0C8C008](__coeffs, __M, __N);
}

void vDSP_biquadm_DestroySetup(vDSP_biquadm_Setup __setup)
{
  MEMORY[0x1E0C8C018](__setup);
}

void vDSP_biquadm_ResetState(vDSP_biquadm_Setup __setup)
{
  MEMORY[0x1E0C8C028](__setup);
}

void vDSP_biquadm_SetActiveFilters(vDSP_biquadm_Setup __setup, const BOOL *__filter_states)
{
  MEMORY[0x1E0C8C030](__setup, __filter_states);
}

void vDSP_biquadm_SetCoefficientsDouble(vDSP_biquadm_Setup __setup, const double *__coeffs, vDSP_Length __start_sec, vDSP_Length __start_chn, vDSP_Length __nsec, vDSP_Length __nchn)
{
  MEMORY[0x1E0C8C038](__setup, __coeffs, __start_sec, __start_chn, __nsec, __nchn);
}

void vDSP_conv(const float *__A, vDSP_Stride __IA, const float *__F, vDSP_Stride __IF, float *__C, vDSP_Stride __IC, vDSP_Length __N, vDSP_Length __P)
{
  MEMORY[0x1E0C8C050](__A, __IA, __F, __IF, __C, __IC, __N, __P);
}

FFTSetup vDSP_create_fftsetup(vDSP_Length __Log2n, FFTRadix __Radix)
{
  return (FFTSetup)MEMORY[0x1E0C8C060](__Log2n, *(_QWORD *)&__Radix);
}

void vDSP_ctoz(const DSPComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__Z, vDSP_Stride __IZ, vDSP_Length __N)
{
  MEMORY[0x1E0C8C070](__C, __IC, __Z, __IZ, __N);
}

void vDSP_destroy_fftsetup(FFTSetup __setup)
{
  MEMORY[0x1E0C8C0A0](__setup);
}

void vDSP_distancesq(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C0B0](__A, __IA, __B, __IB, __C, __N);
}

void vDSP_dotpr(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C0D0](__A, __IA, __B, __IB, __C, __N);
}

void vDSP_dotprD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C0E0](__A, __IA, __B, __IB, __C, __N);
}

void vDSP_fft_zrip(FFTSetup __Setup, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __Log2N, FFTDirection __Direction)
{
  MEMORY[0x1E0C8C130](__Setup, __C, __IC, __Log2N, *(_QWORD *)&__Direction);
}

void vDSP_hamm_window(float *__C, vDSP_Length __N, int __Flag)
{
  MEMORY[0x1E0C8C150](__C, __N, *(_QWORD *)&__Flag);
}

void vDSP_hann_window(float *__C, vDSP_Length __N, int __Flag)
{
  MEMORY[0x1E0C8C160](__C, __N, *(_QWORD *)&__Flag);
}

void vDSP_maxmgv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C188](__A, __IA, __C, __N);
}

void vDSP_maxmgvi(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length *__I, vDSP_Length __N)
{
  MEMORY[0x1E0C8C198](__A, __IA, __C, __I, __N);
}

void vDSP_maxv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C1B0](__A, __IA, __C, __N);
}

void vDSP_maxvi(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length *__I, vDSP_Length __N)
{
  MEMORY[0x1E0C8C1C0](__A, __IA, __C, __I, __N);
}

void vDSP_meanv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C1E8](__A, __IA, __C, __N);
}

void vDSP_meanvD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C1F0](__A, __IA, __C, __N);
}

void vDSP_measqv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C1F8](__A, __IA, __C, __N);
}

void vDSP_minmgvi(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length *__I, vDSP_Length __N)
{
  MEMORY[0x1E0C8C210](__A, __IA, __C, __I, __N);
}

void vDSP_minv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C220](__A, __IA, __C, __N);
}

void vDSP_minvi(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length *__I, vDSP_Length __N)
{
  MEMORY[0x1E0C8C230](__A, __IA, __C, __I, __N);
}

void vDSP_mmov(const float *__A, float *__C, vDSP_Length __M, vDSP_Length __N, vDSP_Length __TA, vDSP_Length __TC)
{
  MEMORY[0x1E0C8C248](__A, __C, __M, __N, __TA, __TC);
}

void vDSP_mmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N, vDSP_Length __P)
{
  MEMORY[0x1E0C8C250](__A, __IA, __B, __IB, __C, __IC, __M, __N);
}

void vDSP_mmulD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N, vDSP_Length __P)
{
  MEMORY[0x1E0C8C258](__A, __IA, __B, __IB, __C, __IC, __M, __N);
}

void vDSP_mtrans(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N)
{
  MEMORY[0x1E0C8C260](__A, __IA, __C, __IC, __M, __N);
}

void vDSP_mtransD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N)
{
  MEMORY[0x1E0C8C270](__A, __IA, __C, __IC, __M, __N);
}

void vDSP_normalize(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, float *__Mean, float *__StandardDeviation, vDSP_Length __N)
{
  MEMORY[0x1E0C8C280](__A, __IA, __C, __IC, __Mean, __StandardDeviation, __N);
}

void vDSP_nzcros(const float *__A, vDSP_Stride __IA, vDSP_Length __B, vDSP_Length *__C, vDSP_Length *__D, vDSP_Length __N)
{
  MEMORY[0x1E0C8C290](__A, __IA, __B, __C, __D, __N);
}

void vDSP_rect(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C2B0](__A, __IA, __C, __IC, __N);
}

void vDSP_rmsqv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C2C0](__A, __IA, __C, __N);
}

void vDSP_svdiv(const float *__A, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C2D8](__A, __B, __IB, __C, __IC, __N);
}

void vDSP_sve(const float *__A, vDSP_Stride __I, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C2E8](__A, __I, __C, __N);
}

void vDSP_svemg(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C318](__A, __IA, __C, __N);
}

void vDSP_svesq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C328](__A, __IA, __C, __N);
}

void vDSP_vabs(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C358](__A, __IA, __C, __IC, __N);
}

void vDSP_vadd(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C368](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vaddD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C378](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vam(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C398](__A, __IA, __B, __IB, __C, __IC, __D, __ID);
}

void vDSP_vasm(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C3C0](__A, __IA, __B, __IB, __C, __D, __ID, __N);
}

void vDSP_vavlin(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C3D0](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vclip(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C3D8](__A, __IA, __B, __C, __D, __ID, __N);
}

void vDSP_vclr(float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C400](__C, __IC, __N);
}

void vDSP_vclrD(double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C408](__C, __IC, __N);
}

void vDSP_vdbcon(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N, unsigned int __F)
{
  MEMORY[0x1E0C8C420](__A, __IA, __B, __C, __IC, __N, *(_QWORD *)&__F);
}

void vDSP_vdist(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C430](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vdiv(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C448](__B, __IB, __A, __IA, __C, __IC, __N);
}

void vDSP_vdpsp(const double *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C458](__A, __IA, __C, __IC, __N);
}

void vDSP_vfill(const float *__A, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C460](__A, __C, __IC, __N);
}

void vDSP_vfixr16(const float *__A, vDSP_Stride __IA, __int16 *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C4D0](__A, __IA, __C, __IC, __N);
}

void vDSP_vfixr32(const float *__A, vDSP_Stride __IA, int *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C4E0](__A, __IA, __C, __IC, __N);
}

void vDSP_vfixr8(const float *__A, vDSP_Stride __IA, char *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C4F8](__A, __IA, __C, __IC, __N);
}

void vDSP_vfixu32(const float *__A, vDSP_Stride __IA, unsigned int *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C568](__A, __IA, __C, __IC, __N);
}

void vDSP_vflt16(const __int16 *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C598](__A, __IA, __C, __IC, __N);
}

void vDSP_vflt24(const vDSP_int24 *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C5A8](__A, __IA, __C, __IC, __N);
}

void vDSP_vflt32(const int *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C5B8](__A, __IA, __C, __IC, __N);
}

void vDSP_vflt8(const char *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C5C8](__A, __IA, __C, __IC, __N);
}

void vDSP_vfrac(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C620](__A, __IA, __C, __IC, __N);
}

void vDSP_vgathr(const float *__A, const vDSP_Length *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C630](__A, __B, __IB, __C, __IC, __N);
}

void vDSP_viclip(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C658](__A, __IA, __B, __C, __D, __ID, __N);
}

void vDSP_vindex(const float *__A, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C668](__A, __B, __IB, __C, __IC, __N);
}

void vDSP_vlim(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C680](__A, __IA, __B, __C, __D, __ID, __N);
}

void vDSP_vlint(const float *__A, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N, vDSP_Length __M)
{
  MEMORY[0x1E0C8C690](__A, __B, __IB, __C, __IC, __N, __M);
}

void vDSP_vma(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C6A0](__A, __IA, __B, __IB, __C, __IC, __D, __ID);
}

void vDSP_vmax(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C6C0](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vmaxmg(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C6D0](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vmin(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C6D8](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vmma(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, vDSP_Stride __IC, const float *__D, vDSP_Stride __ID, float *__E, vDSP_Stride __IE, vDSP_Length __N)
{
  MEMORY[0x1E0C8C6F8](__A, __IA, __B, __IB, __C, __IC, __D, __ID);
}

void vDSP_vmmsb(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, vDSP_Stride __IC, const float *__D, vDSP_Stride __ID, float *__E, vDSP_Stride __IE, vDSP_Length __N)
{
  MEMORY[0x1E0C8C708](__A, __IA, __B, __IB, __C, __IC, __D, __ID);
}

void vDSP_vmsa(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C718](__A, __IA, __B, __IB, __C, __D, __ID, __N);
}

void vDSP_vmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C740](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vmulD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C748](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vneg(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C768](__A, __IA, __C, __IC, __N);
}

void vDSP_vpoly(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N, vDSP_Length __P)
{
  MEMORY[0x1E0C8C778](__A, __IA, __B, __IB, __C, __IC, __N, __P);
}

void vDSP_vramp(const float *__A, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C7A0](__A, __B, __C, __IC, __N);
}

void vDSP_vrampmul(const float *__I, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O, vDSP_Stride __OS, vDSP_Length __N)
{
  MEMORY[0x1E0C8C7B0](__I, __IS, __Start, __Step, __O, __OS, __N);
}

void vDSP_vrampmul2(const float *__I0, const float *__I1, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O0, float *__O1, vDSP_Stride __OS, vDSP_Length __N)
{
  MEMORY[0x1E0C8C7B8](__I0, __I1, __IS, __Start, __Step, __O0, __O1, __OS);
}

void vDSP_vrampmuladd(const float *__I, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O, vDSP_Stride __OS, vDSP_Length __N)
{
  MEMORY[0x1E0C8C7D0](__I, __IS, __Start, __Step, __O, __OS, __N);
}

void vDSP_vrampmuladd2(const float *__I0, const float *__I1, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O0, float *__O1, vDSP_Stride __OS, vDSP_Length __N)
{
  MEMORY[0x1E0C8C7D8](__I0, __I1, __IS, __Start, __Step, __O0, __O1, __OS);
}

void vDSP_vrsum(const float *__A, vDSP_Stride __IA, const float *__S, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C7E0](__A, __IA, __S, __C, __IC, __N);
}

void vDSP_vrvrs(float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C7F0](__C, __IC, __N);
}

void vDSP_vsadd(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C800](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vsaddD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C810](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vsbm(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C828](__A, __IA, __B, __IB, __C, __IC, __D, __ID);
}

void vDSP_vsbsm(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C848](__A, __IA, __B, __IB, __C, __D, __ID, __N);
}

void vDSP_vsdiv(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C860](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vsma(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C888](__A, __IA, __B, __C, __IC, __D, __ID, __N);
}

void vDSP_vsmaD(const double *__A, vDSP_Stride __IA, const double *__B, const double *__C, vDSP_Stride __IC, double *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C890](__A, __IA, __B, __C, __IC, __D, __ID, __N);
}

void vDSP_vsmsa(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C898](__A, __IA, __B, __C, __D, __ID, __N);
}

void vDSP_vsmsb(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C8B0](__A, __IA, __B, __C, __IC, __D, __ID, __N);
}

void vDSP_vsmsma(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, const float *__D, float *__E, vDSP_Stride __IE, vDSP_Length __N)
{
  MEMORY[0x1E0C8C8C0](__A, __IA, __B, __C, __IC, __D, __E, __IE);
}

void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C8E0](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vsmulD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C8E8](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vsort(float *__C, vDSP_Length __N, int __Order)
{
  MEMORY[0x1E0C8C8F0](__C, __N, *(_QWORD *)&__Order);
}

void vDSP_vsorti(const float *__C, vDSP_Length *__I, vDSP_Length *__Temporary, vDSP_Length __N, int __Order)
{
  MEMORY[0x1E0C8C900](__C, __I, __Temporary, __N, *(_QWORD *)&__Order);
}

void vDSP_vspdp(const float *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C918](__A, __IA, __C, __IC, __N);
}

void vDSP_vsq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C920](__A, __IA, __C, __IC, __N);
}

void vDSP_vsub(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C940](__B, __IB, __A, __IA, __C, __IC, __N);
}

void vDSP_vsubD(const double *__B, vDSP_Stride __IB, const double *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C950](__B, __IB, __A, __IA, __C, __IC, __N);
}

void vDSP_vswap(float *__A, vDSP_Stride __IA, float *__B, vDSP_Stride __IB, vDSP_Length __N)
{
  MEMORY[0x1E0C8C960](__A, __IA, __B, __IB, __N);
}

void vDSP_vswmax(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N, vDSP_Length __WindowLength)
{
  MEMORY[0x1E0C8C970](__A, __IA, __C, __IC, __N, __WindowLength);
}

void vDSP_vthr(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C9A8](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vthrD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C9B0](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vthres(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C9B8](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vthresD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C9C8](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vthrsc(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8C9D0](__A, __IA, __B, __C, __D, __ID, __N);
}

void vDSP_zaspec(const DSPSplitComplex *__A, float *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA00](__A, __C, __N);
}

void vDSP_zcoher(const float *__A, const float *__B, const DSPSplitComplex *__C, float *__D, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA08](__A, __B, __C, __D, __N);
}

void vDSP_zdotpr(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA10](__A, __IA, __B, __IB, __C, __N);
}

void vDSP_zmmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N, vDSP_Length __P)
{
  MEMORY[0x1E0C8CA18](__A, __IA, __B, __IB, __C, __IC, __M, __N);
}

void vDSP_zrvdiv(const DSPSplitComplex *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA28](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_zrvmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA38](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_ztoc(const DSPSplitComplex *__Z, vDSP_Stride __IZ, DSPComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA50](__Z, __IZ, __C, __IC, __N);
}

void vDSP_zvabs(const DSPSplitComplex *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA60](__A, __IA, __C, __IC, __N);
}

void vDSP_zvabsD(const DSPDoubleSplitComplex *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA68](__A, __IA, __C, __IC, __N);
}

void vDSP_zvadd(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA70](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_zvcma(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA80](__A, __IA, __B, __IB, __C, __IC, __D, __ID);
}

void vDSP_zvcmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA88](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_zvconj(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CA90](__A, __IA, __C, __IC, __N);
}

void vDSP_zvdiv(const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CAA0](__B, __IB, __A, __IA, __C, __IC, __N);
}

void vDSP_zvma(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x1E0C8CAB0](__A, __IA, __B, __IB, __C, __IC, __D, __ID);
}

void vDSP_zvmags(const DSPSplitComplex *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CAB8](__A, __IA, __C, __IC, __N);
}

void vDSP_zvmgsa(const DSPSplitComplex *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CAC8](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_zvmmaa(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__D, vDSP_Stride __ID, const DSPSplitComplex *__E, vDSP_Stride __IE, const DSPSplitComplex *__F, vDSP_Stride __IF, vDSP_Length __N)
{
  MEMORY[0x1E0C8CAD0](__A, __IA, __B, __IB, __C, __IC, __D, __ID);
}

void vDSP_zvmov(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CAD8](__A, __IA, __C, __IC, __N);
}

void vDSP_zvmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N, int __Conjugate)
{
  MEMORY[0x1E0C8CAE8](__A, __IA, __B, __IB, __C, __IC, __N, *(_QWORD *)&__Conjugate);
}

void vDSP_zvneg(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CAF8](__A, __IA, __C, __IC, __N);
}

void vDSP_zvphas(const DSPSplitComplex *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CB00](__A, __IA, __C, __IC, __N);
}

void vDSP_zvsub(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CB10](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_zvzsml(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8CB20](__A, __IA, __B, __C, __IC, __N);
}

int vdprintf(int a1, const char *a2, va_list a3)
{
  return MEMORY[0x1E0C85A60](*(_QWORD *)&a1, a2, a3);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1E0C85B98](__str, __size, __format, a4);
}

void vvcopysign(double *a1, const double *a2, const double *a3, const int *a4)
{
  MEMORY[0x1E0C8D948](a1, a2, a3, a4);
}

void vvcosf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8D968](a1, a2, a3);
}

void vvexpf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8D9D8](a1, a2, a3);
}

void vvfabsf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8D9F8](a1, a2, a3);
}

void vvlog10f(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8DA58](a1, a2, a3);
}

void vvlogf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8DA98](a1, a2, a3);
}

void vvnintf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8DAB8](a1, a2, a3);
}

void vvpowf(float *a1, const float *a2, const float *a3, const int *a4)
{
  MEMORY[0x1E0C8DAC8](a1, a2, a3, a4);
}

void vvpowsf(float *a1, const float *a2, const float *a3, const int *a4)
{
  MEMORY[0x1E0C8DAE0](a1, a2, a3, a4);
}

void vvsincosf(float *a1, float *a2, const float *a3, const int *a4)
{
  MEMORY[0x1E0C8DB38](a1, a2, a3, a4);
}

void vvsinf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8DB48](a1, a2, a3);
}

void vvsinhf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8DB58](a1, a2, a3);
}

void vvsqrt(double *a1, const double *a2, const int *a3)
{
  MEMORY[0x1E0C8DB78](a1, a2, a3);
}

void vvsqrtf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8DB80](a1, a2, a3);
}

void vvtanhf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x1E0C8DBB0](a1, a2, a3);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x1E0C85CB8](__s, *(_QWORD *)&__c, __n);
}

xmlDocPtr xmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename, const char *encoding, int options)
{
  return (xmlDocPtr)MEMORY[0x1E0DE8CD0](ctxt, filename, encoding, *(_QWORD *)&options);
}

void xmlFreeDoc(xmlDocPtr cur)
{
  MEMORY[0x1E0DE8D38](cur);
}

void xmlFreeParserCtxt(xmlParserCtxtPtr ctxt)
{
  MEMORY[0x1E0DE8D50](ctxt);
}

xmlParserCtxtPtr xmlNewParserCtxt(void)
{
  return (xmlParserCtxtPtr)MEMORY[0x1E0DE8E18]();
}

