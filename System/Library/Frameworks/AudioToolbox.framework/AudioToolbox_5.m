void DspLib::MozartCompressor::Algorithm::processBlock(DspLib::MozartCompressor::Algorithm *this, DspLibBuffer *a2, DspLibBuffer *a3)
{
  uint64_t cycle_count;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  float **v18;
  size_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  float **v27;
  size_t v28;
  uint64_t v29;
  float **v30;
  unint64_t v31;
  uint64_t v32;
  float *v33;
  float **v34;
  uint64_t *v35;
  uint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  char *v39;
  size_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  vDSP_Length v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  uint64_t v52;
  char *v53;
  const float *v54;
  char *v55;
  _QWORD v56[2];
  uint64_t v57;
  _QWORD v58[3];
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  vDSP_Length v62;
  _QWORD v63[3];
  _BYTE v64[24];
  _QWORD v65[3];
  _QWORD v66[3];
  float **v67;
  unint64_t v68;
  uint64_t v69;
  float **v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  cycle_count = vp::utility::CPU_Profiler::get_cycle_count(a2);
  DspLibBuffer::setNumFrames(a3, cycle_count);
  if (*((_BYTE *)this + 8))
  {
    v7 = DspLibBuffer::numChannels(a2);
    MEMORY[0x1E0C80A78](v7);
    v10 = (char *)v56 - v9;
    if (v8 >= 0x200)
      v11 = 512;
    else
      v11 = v8;
    bzero((char *)v56 - v9, v11);
    if (DspLibBuffer::numChannels(a2))
    {
      v12 = 0;
      do
      {
        *(_QWORD *)&v10[8 * v12] = DspLibBuffer::channel(a2, v12);
        ++v12;
      }
      while (v12 < DspLibBuffer::numChannels(a2));
    }
    v13 = DspLibBuffer::numChannels(a2);
    v14 = vp::utility::CPU_Profiler::get_cycle_count(a2);
    v15 = DspLibBuffer::numChannels(a3);
    MEMORY[0x1E0C80A78](v15);
    v18 = (float **)((char *)v56 - v17);
    if (v16 >= 0x200)
      v19 = 512;
    else
      v19 = v16;
    bzero((char *)v56 - v17, v19);
    if (DspLibBuffer::numChannels(a3))
    {
      v20 = 0;
      do
      {
        v18[v20] = (float *)DspLibBuffer::channel(a3, v20);
        ++v20;
      }
      while (v20 < DspLibBuffer::numChannels(a3));
    }
    v21 = DspLibBuffer::numChannels(a3);
    v22 = vp::utility::CPU_Profiler::get_cycle_count(a3);
    if (*((_BYTE *)this + 40))
      DspLib::CPUMeasure::start((int8x16_t *)((char *)this + 72));
    v66[0] = v10;
    v66[1] = v13;
    v66[2] = v14;
    v23 = *((float *)this + 68);
    v65[0] = v18;
    v65[1] = v21;
    v65[2] = v22;
    DspLib::multiply(v66, v65, v23);
    if (*((_BYTE *)this + 216))
    {
      v57 = cycle_count;
      v56[1] = v56;
      MEMORY[0x1E0C80A78](v24);
      v27 = (float **)((char *)v56 - v26);
      if (v25 >= 0x200)
        v28 = 512;
      else
        v28 = v25;
      bzero((char *)v56 - v26, v28);
      v30 = (float **)*((_QWORD *)this + 31);
      v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 32) - (_QWORD)v30) >> 3);
      if (*((float ***)this + 32) != v30)
      {
        v32 = 0;
        do
        {
          v33 = *v30;
          v30 += 3;
          v27[v32++] = v33;
        }
        while (v31 > v32);
      }
      v34 = v18;
      if (*((_BYTE *)this + 280))
      {
        v70 = v18;
        v71 = v21;
        v72 = v22;
        v67 = v27;
        v68 = v31;
        v69 = v57;
        DspLib::Biquad::Filter::process((_QWORD *)this + 36, (uint64_t)&v70, &v67);
        v34 = v27;
      }
      v35 = (uint64_t *)*((_QWORD *)this + 28);
      v36 = (uint64_t *)*((_QWORD *)this + 29);
      MEMORY[0x1E0C80A78](v29);
      v39 = (char *)v56 - v38;
      if (v37 >= 0x200)
        v40 = 512;
      else
        v40 = v37;
      bzero((char *)v56 - v38, v40);
      if (v36 == v35)
        goto LABEL_33;
      v41 = 0;
      v42 = v35;
      do
      {
        v43 = *v42;
        v42 += 3;
        *(_QWORD *)&v39[8 * v41++] = v43;
      }
      while (0xAAAAAAAAAAAAAAABLL * (v36 - v35) > v41);
      if (v36 == v35)
LABEL_33:
        v44 = 0;
      else
        v44 = (v35[1] - *v35) >> 2;
      *(_QWORD *)v64 = v39;
      *(_QWORD *)&v64[8] = 0xAAAAAAAAAAAAAAABLL * (v36 - v35);
      *(_QWORD *)&v64[16] = v44;
      v45 = *((unsigned int *)this + 3);
      v63[0] = v34;
      v63[1] = v45;
      cycle_count = v57;
      v63[2] = v57;
      DspLib::DownSampler::process((unsigned int *)this + 124, v63, v64);
      v47 = *(_QWORD *)&v64[16];
      if (*(_QWORD *)&v64[16] <= 1uLL)
        v48 = 1;
      else
        v48 = *(_QWORD *)&v64[16];
      v49 = 4 * v48;
      MEMORY[0x1E0C80A78](v46);
      v50 = (v49 + 15) & 0xFFFFFFFFFFFFFFF0;
      v51 = (char *)v56 - v50;
      v61 = *(_OWORD *)v64;
      v62 = v47;
      DspLib::RMS::process((uint64_t)this + 512, &v61, (const float *)((char *)v56 - v50), v47);
      MEMORY[0x1E0C80A78](v52);
      v53 = (char *)v56 - v50;
      if (*((_BYTE *)this + 1120))
      {
        v59 = *(_QWORD *)v64;
        v60 = *(_OWORD *)&v64[8];
        DspLib::RMS::process((uint64_t)this + 704, (__int128 *)&v59, (const float *)((char *)v56 - v50), v47);
      }
      v54 = (const float *)**((_QWORD **)this + 28);
      DspLib::MozartCompressor::Algorithm::calculateGain((uint64_t)this, (uint64_t)v51, v47, (uint64_t)v53, v47, (uint64_t)v54, cycle_count);
      v70 = v18;
      v71 = v21;
      v72 = v22;
      v67 = v18;
      v68 = v21;
      v69 = v22;
      DspLib::MultiChannelCircularDelay::process((const void **)this + 149, &v70, &v67);
      v58[0] = v18;
      v58[1] = v21;
      v58[2] = v22;
      DspLib::multiply(v58, v54);
    }
    if (*((_BYTE *)this + 40))
      DspLib::CPUMeasure::stop((DspLib::MozartCompressor::Algorithm *)((char *)this + 72), cycle_count, *((double *)this + 3));
  }
  else
  {
    v55 = basename("/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/DspLib/MozartCompressor/dsp/DspLibMozartCompressor.cpp");
    printf("DSP Sound assertion in %s at line %d\n", v55, 586);
    ++DspLibDebug::mAssertCounter;
  }
}

void DspLib::MozartCompressor::Algorithm::calculateGain(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  float *v13;
  vDSP_Length v14;
  uint64_t v15;
  vDSP_Length v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  unint64_t v20;
  uint64_t v21;
  float *v22;
  uint64_t v23;
  float v24;
  DspLib *v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v29;
  float *v30;
  uint64_t v31;
  float *v32;
  float *v33;
  uint64_t v34;
  float v35;
  uint64_t v36;
  float *v37;
  vDSP_Length v38;
  float *v39;
  vDSP_Length v40;
  _QWORD v41[3];
  _QWORD v42[3];
  float *v43;
  _QWORD v44[2];

  v44[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v13 = (float *)((char *)&v36 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  v39 = v13;
  v40 = v14;
  MEMORY[0x1E0C80A78](v15);
  v37 = (float *)((char *)&v36 - v17);
  v38 = v16;
  MEMORY[0x1E0C80A78](v18);
  v22 = (float *)((char *)&v36 - v21);
  if (v23)
  {
    *(_DWORD *)(a1 + 904) = *v19;
    if (!*(_BYTE *)(a1 + 896))
    {
      memmove(v13, v19, 4 * a5);
      goto LABEL_6;
    }
  }
  else if (!*(_BYTE *)(a1 + 896))
  {
    goto LABEL_6;
  }
  DspLib::MozartCompressor::Algorithm::processGating((float *)a1, (uint64_t)v19, v20, (uint64_t)v13);
LABEL_6:
  v24 = *(float *)(*(_QWORD *)(a1 + 48) + 180);
  if (v24 <= 1.5)
  {
    if (v24 <= 0.5)
      DspLib::fill(v22, a5, 1.0);
    else
      v25 = (DspLib *)DspLib::MozartCompressor::Algorithm::audioActivityDetector_1(a1, (uint64_t)v13, a5, (uint64_t)v22);
  }
  else
  {
    v25 = (DspLib *)DspLib::MozartCompressor::Algorithm::audioActivityDetector_2(a1, (uint64_t)v13, a5, (uint64_t)v22);
  }
  if (a5)
  {
    v26 = 0;
    v27 = 1;
    do
    {
      v13[v26] = DspLib::power2dBSafe(v25, v13[v26], 1.0e-20) + -0.691;
      v26 = v27;
    }
    while (a5 > v27++);
    *(float *)(a1 + 900) = *v13;
  }
  DspLib::MozartCompressor::Curve::vectCurve((float *)(a1 + 988), (uint64_t)v13, a5, &v39, &v37);
  DspLib::dB2Amp(v39, v40);
  DspLib::dB2Amp(v37, v38);
  DspLib::MozartCompressor::AttackReleaseFilter::process((float *)(a1 + 1088), (uint64_t)v37, v38, (uint64_t)v39, v40, (uint64_t)v39, v40, v29, (uint64_t)v22, a5);
  if (*(_BYTE *)(a1 + 1120))
  {
    v30 = v37;
    if (a5)
    {
      v31 = 0;
      do
      {
        v30[v31] = sqrtf(*(float *)(a4 + 4 * v31)) * 0.92353;
        ++v31;
      }
      while (a5 > v31);
      v32 = v39;
      *(float *)(a1 + 1184) = *v30 * *v39;
    }
    else
    {
      v32 = v39;
    }
    DspLib::MozartCompressor::Limiter::autoThresholdCompressorGain(a1 + 1124, a1 + 988, (uint64_t)v30, v38, (uint64_t)v32, v40, (uint64_t)v32);
  }
  v33 = v39;
  if (a5)
  {
    v34 = 0;
    do
    {
      v35 = v33[v34];
      if (v35 < *(float *)(a1 + 1216))
        *(float *)(a1 + 1216) = v35;
      if (v35 > *(float *)(a1 + 1220))
        *(float *)(a1 + 1220) = v35;
      v33[v34] = *(float *)(a1 + 276) * v33[v34];
      ++v34;
    }
    while (a5 > v34);
  }
  v43 = v33;
  v44[0] = a6;
  v42[0] = &v43;
  v42[1] = 1;
  v42[2] = v40;
  v41[0] = v44;
  v41[1] = 1;
  v41[2] = a7;
  DspLib::PolyPhaseInterpolator::process((unsigned int *)(a1 + 392), v42, v41);
}

float *DspLib::MozartCompressor::Algorithm::processGating(float *result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t i;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;

  if (a3)
  {
    for (i = 0; a3 > i; ++i)
    {
      v5 = *(float *)(a2 + 4 * i);
      if (v5 > result[238])
      {
        v6 = result[232];
        if (v5 > v6)
        {
          v7 = result[231] + 1.0;
LABEL_8:
          result[232] = v6 * v7;
          goto LABEL_9;
        }
        if (result[235] < v6)
        {
          v7 = result[230];
          goto LABEL_8;
        }
      }
LABEL_9:
      v8 = (float)(v5 * result[228]) + (float)(result[229] * result[227]);
      result[229] = v8;
      if (v5 <= (float)(v8 * result[236]))
      {
        v9 = result[235];
      }
      else
      {
        v9 = result[235];
        if (v5 < (float)(result[232] * result[237]))
        {
          if (v5 <= v9)
            v10 = result[233];
          else
            v10 = result[234] + 1.0;
          v9 = v9 * v10;
          result[235] = v9;
        }
      }
      *(float *)(a4 + 4 * i) = v9;
    }
  }
  return result;
}

uint64_t DspLib::MozartCompressor::Algorithm::audioActivityDetector_2(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  int v5;
  float v6;
  float v7;

  if (a3)
  {
    v4 = 0;
    v5 = *(_DWORD *)(result + 976);
    do
    {
      v6 = *(float *)(a2 + 4 * v4);
      v7 = *(float *)(result + 964);
      if (v6 <= (float)(v7 * *(float *)(result + 956)))
      {
        if (v6 < (float)(v7 * *(float *)(result + 960)))
          *(float *)(result + 964) = v6;
      }
      else
      {
        *(float *)(result + 964) = v6;
        v5 += *(_DWORD *)(result + 980);
        *(_DWORD *)(result + 976) = v5;
      }
      if (v5)
      {
        *(_DWORD *)(result + 976) = --v5;
      }
      else
      {
        v5 = 0;
        if (v6 >= *(float *)(result + 952))
        {
          *(_DWORD *)(a4 + 4 * v4) = 0;
          goto LABEL_11;
        }
      }
      *(_DWORD *)(a4 + 4 * v4) = 1065353216;
      *(_BYTE *)(result + 984) = 1;
LABEL_11:
      ++v4;
    }
    while (a3 > v4);
  }
  return result;
}

uint64_t DspLib::MozartCompressor::Algorithm::audioActivityDetector_1(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  int v5;
  int v6;
  float v7;
  float v8;
  int v9;
  int v10;

  if (a3)
  {
    v4 = 0;
    v5 = *(unsigned __int8 *)(result + 968);
    v6 = *(_DWORD *)(result + 972);
    while (1)
    {
      v7 = *(float *)(a2 + 4 * v4);
      v8 = *(float *)(result + 964);
      if (v7 > (float)(v8 * *(float *)(result + 956)))
      {
        *(float *)(result + 964) = v7;
        v5 = 1;
        *(_BYTE *)(result + 968) = 1;
        v8 = v7;
      }
      if (v7 < (float)(v8 * *(float *)(result + 960)))
      {
        v5 = 0;
        *(float *)(result + 964) = v7;
        *(_BYTE *)(result + 968) = 0;
      }
      if (v6 != v5)
        break;
      v9 = *(_DWORD *)(result + 976);
      if (v9)
      {
        v10 = v9 - 1;
LABEL_11:
        *(_DWORD *)(result + 976) = v10;
        goto LABEL_12;
      }
      if (v7 >= *(float *)(result + 952))
      {
        *(_DWORD *)(result + 972) = v6;
        *(_DWORD *)(a4 + 4 * v4) = 0;
        goto LABEL_13;
      }
LABEL_12:
      *(_DWORD *)(result + 972) = v5;
      *(_DWORD *)(a4 + 4 * v4) = 1065353216;
      *(_BYTE *)(result + 984) = 1;
LABEL_13:
      ++v4;
      v6 = v5;
      if (a3 <= v4)
        return result;
    }
    v10 = *(_DWORD *)(result + 980);
    goto LABEL_11;
  }
  return result;
}

uint64_t DspLib::MozartCompressor::Algorithm::numStatus(DspLib::MozartCompressor::Algorithm *this)
{
  return 21;
}

void DspLib::MozartCompressor::Algorithm::status(uint64_t a1, uint64_t a2, vDSP_Length __N)
{
  DspLib *v5;
  DspLib *v6;
  float v7;
  DspLib *v8;
  DspLib *v9;
  DspLib *v10;
  DspLib *v11;
  DspLib *v12;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  const float *v17;
  uint64_t v18;
  DspLib *v19;
  DspLib *v20;
  float v21;
  float v22;

  DspLib::clear((float *)a2, __N);
  if (*(_BYTE *)(a1 + 40))
  {
    *(float *)a2 = DspLib::amp2dBSafe(v5, *(float *)(a1 + 1116), 0.000001);
    v7 = DspLib::amp2dBSafe(v6, *(float *)(a1 + 1176), 0.000001);
    *(float *)(a2 + 4) = v7;
    *(float *)(a2 + 48) = v7 + *(float *)a2;
    *(float *)(a2 + 8) = -DspLib::amp2dBSafe(v8, *(float *)(a1 + 1180), 0.000001);
    *(float *)(a2 + 20) = (float)(DspLib::power2dBSafe(v9, *(float *)(a1 + 916), 1.0e-20) + -0.691)
                        + *(float *)(*(_QWORD *)(a1 + 48) + 136);
    *(float *)(a2 + 28) = (float)(DspLib::power2dBSafe(v10, *(float *)(a1 + 928), 1.0e-20) + -0.691)
                        - *(float *)(*(_QWORD *)(a1 + 48) + 136);
    *(float *)(a2 + 24) = DspLib::power2dBSafe(v11, *(float *)(a1 + 904), 1.0e-20) + -0.691;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 900);
    v13 = 0.0;
    if (*(_BYTE *)(a1 + 984))
      v13 = 1.0;
    *(float *)(a2 + 52) = v13;
    *(_BYTE *)(a1 + 984) = 0;
    v14 = DspLib::amp2dBSafe(v12, *(float *)(a1 + 1184), 0.000001);
    v15 = *(float *)(a2 + 24);
    if (v14 > v15)
      v15 = v14;
    *(float *)(a2 + 12) = v15;
    v16 = *(unsigned int *)(a1 + 1224);
    *(float *)(a2 + 32) = v14;
    *(float *)(a2 + 36) = (float)v16;
    v17 = *(const float **)(a1 + 48);
    v18 = *(_QWORD *)(a1 + 56);
    *(float *)(a2 + 40) = v17[v16];
    *(_DWORD *)(a1 + 1224) = ((int)v16 + 1) % 0x35u;
    *(float *)(a2 + 44) = DspLib::sum(v17, (v18 - (uint64_t)v17) >> 2);
    *(float *)(a2 + 56) = DspLib::amp2dBSafe(v19, *(float *)(a1 + 1216), 0.000001);
    v21 = DspLib::amp2dBSafe(v20, *(float *)(a1 + 1220), 0.000001);
    v22 = *(double *)(a1 + 24);
    *(float *)(a2 + 60) = v21;
    *(float *)(a2 + 64) = v22;
    *(_QWORD *)(a2 + 68) = 0;
    *(_QWORD *)(a2 + 76) = 0;
  }
}

double DspLib::MozartCompressor::Algorithm::latencySamples(DspLib::MozartCompressor::Algorithm *this, double a2)
{
  char *v4;

  if (!*((_BYTE *)this + 8))
  {
    v4 = basename("/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/DspLib/MozartCompressor/dsp/DspLibMozartCompressor.cpp");
    printf("DSP Sound assertion in %s at line %d\n", v4, 912);
    ++DspLibDebug::mAssertCounter;
  }
  LODWORD(a2) = *((_DWORD *)this + 297);
  return (double)*(unint64_t *)&a2;
}

void DspLib::MozartCompressor::Algorithm::~Algorithm(DspLib::MozartCompressor::Algorithm *this)
{
  DspLib::MozartCompressor::Algorithm::~Algorithm(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void **v11;

  *(_QWORD *)this = &off_1E69C4938;
  v11 = (void **)((char *)this + 1192);
  std::vector<DspLib::PeakPowerGuard::AdmittanceFilterCoeffSet::FIRfilter>::__destroy_vector::operator()[abi:ne180100](&v11);
  v11 = (void **)((char *)this + 864);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  v2 = (void *)*((_QWORD *)this + 102);
  if (v2)
  {
    *((_QWORD *)this + 103) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 99);
  if (v3)
  {
    *((_QWORD *)this + 100) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 94);
  if (v4)
  {
    *((_QWORD *)this + 95) = v4;
    operator delete(v4);
  }
  v11 = (void **)((char *)this + 672);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  v5 = (void *)*((_QWORD *)this + 78);
  if (v5)
  {
    *((_QWORD *)this + 79) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 75);
  if (v6)
  {
    *((_QWORD *)this + 76) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 70);
  if (v7)
  {
    *((_QWORD *)this + 71) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 59);
  if (v8)
  {
    *((_QWORD *)this + 60) = v8;
    operator delete(v8);
  }
  v11 = (void **)((char *)this + 440);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  v11 = (void **)((char *)this + 408);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  v11 = (void **)((char *)this + 368);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::MozartCompressor::Algorithm *)((char *)this + 336));
  v9 = (void *)*((_QWORD *)this + 39);
  if (v9)
  {
    *((_QWORD *)this + 40) = v9;
    operator delete(v9);
  }
  v11 = (void **)((char *)this + 248);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  v11 = (void **)((char *)this + 224);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  *(_QWORD *)this = off_1E69C46F0;
  v10 = (void *)*((_QWORD *)this + 6);
  if (v10)
  {
    *((_QWORD *)this + 7) = v10;
    operator delete(v10);
  }
}

float DspLib::MozartCompressor::curveInterpolate(DspLib::MozartCompressor *this, float a2, float a3, float a4, float a5, float a6, float a7)
{
  float v9;

  if (a7 <= a2 || a7 >= a4)
    return a6;
  v9 = (float)((float)((float)(a2 + a4) * 0.5) - a7) / (float)(a2 - a4);
  if (v9 < 0.0)
    v9 = -v9;
  return (float)((float)((float)(a5 - (float)((float)((float)(a5 - a3) / (float)(a4 - a2)) * a4))
                       + (float)((float)((float)(a5 - a3) / (float)(a4 - a2)) * a7))
               * (float)(1.0 - (float)(v9 + 0.5)))
       + (float)((float)(v9 + 0.5) * a6);
}

void DspLib::FIR::initialize(DspLib::FIR *this, unint64_t a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  int v8;

  v5 = *((_QWORD *)this + 5);
  v6 = *((_QWORD *)this + 6);
  v4 = (uint64_t *)((char *)this + 40);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v5) >> 3) != a2 || *(_QWORD *)this != a3)
  {
    *(_QWORD *)this = a3;
    std::vector<std::vector<float>>::resize(v4, a2);
    v7 = (const void *)*((_QWORD *)this + 1);
    if (*((const void **)this + 2) == v7)
    {
      v8 = 1065353216;
      DspLib::FIR::setCoefficients(this, &v8, 1uLL);
      *((_QWORD *)this + 4) = 1;
    }
    else
    {
      DspLib::FIR::setCoefficients(this, v7, *((_QWORD *)this + 4));
    }
    DspLib::FIR::reset(this);
  }
}

void DspLib::FIR::setCoefficients(_QWORD *a1, const void *a2, unint64_t a3)
{
  unint64_t v6;
  float **v7;
  float **v8;
  uint64_t v9;
  unint64_t v10;
  float *v11;
  float *v12;
  void **v13;

  v6 = ((a3 - 1) & 0xFFFFFFFFFFFFFFFCLL) + 4;
  v7 = (float **)a1[5];
  v8 = (float **)a1[6];
  if (v8 != v7)
  {
    v9 = *a1;
    if (*a1)
    {
      if (a3 <= 1)
      {
        do
        {
          v7[1] = *v7;
          v7 += 3;
        }
        while (v7 != v8);
      }
      else
      {
        v10 = v9 + v6;
        if (v9 + v6 == v7[1] - *v7)
          goto LABEL_9;
        do
        {
          std::vector<float>::resize((uint64_t)v7, v10);
          v11 = *v7;
          v12 = v7[1];
          v7 += 3;
          DspLib::clear(v11, v12 - v11);
        }
        while (v7 != v8);
      }
    }
  }
  if (!a3)
  {
    a1[2] = a1[1];
    goto LABEL_13;
  }
LABEL_9:
  v13 = (void **)(a1 + 1);
  std::vector<float>::resize((uint64_t)(a1 + 1), v6);
  if (v6 > a3)
    DspLib::clear((float *)*v13 + a3, v6 - a3);
  memmove(*v13, a2, 4 * a3);
LABEL_13:
  a1[4] = a3;
}

void DspLib::FIR::reset(DspLib::FIR *this)
{
  uint64_t v1;
  uint64_t v2;
  float *v3;
  uint64_t v4;

  v1 = *((_QWORD *)this + 5);
  v2 = *((_QWORD *)this + 6);
  while (v1 != v2)
  {
    v3 = *(float **)v1;
    v4 = *(_QWORD *)(v1 + 8);
    v1 += 24;
    DspLib::clear(v3, (v4 - (uint64_t)v3) >> 2);
  }
}

void DspLib::FIR::uninitialize(DspLib::FIR *this)
{
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 5);
  *((_QWORD *)this + 2) = *((_QWORD *)this + 1);
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = 0;
}

void DspLib::FIR::scaleHistory(DspLib::FIR *this, float a2)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v5;

  v2 = *((_QWORD *)this + 5);
  for (i = *((_QWORD *)this + 6); v2 != i; v2 += 24)
  {
    v5 = *(_QWORD *)(v2 + 8) - *(_QWORD *)v2;
    if (v5)
      DspLib::multiply(*(float **)v2, v5 >> 2, a2);
  }
}

void DspLib::FIR::process(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v7;
  unsigned int v8;
  float *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  vDSP_Length v13;
  uint64_t v14;
  uint64_t v15;

  v3 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(a1 + 48) != v3)
  {
    v7 = 0;
    v8 = 1;
    do
    {
      if (*(_QWORD *)(a1 + 32) == 1)
      {
        DspLib::multiply(*(const float **)(*a2 + 8 * v7), a2[2], *(float **)(*a3 + 8 * v7), **(float **)(a1 + 8));
      }
      else
      {
        v9 = *(float **)(v3 + 24 * v7);
        v10 = a2[2];
        v12 = *(_QWORD *)(a1 + 8);
        v11 = *(_QWORD *)(a1 + 16);
        if (v10)
        {
          memmove((char *)v9 + v11 - v12, *(const void **)(*a2 + 8 * v7), 4 * v10);
          v12 = *(_QWORD *)(a1 + 8);
          v11 = *(_QWORD *)(a1 + 16);
          v13 = a2[2];
        }
        else
        {
          v13 = 0;
        }
        vDSP_conv(v9 + 1, 1, (const float *)(v11 - 4), -1, *(float **)(*a3 + 8 * v7), 1, v13, (v11 - v12) >> 2);
        v15 = *(_QWORD *)(a1 + 8);
        v14 = *(_QWORD *)(a1 + 16);
        if (v14 != v15)
          memmove(v9, &v9[a2[2]], v14 - v15);
      }
      v7 = v8;
      v3 = *(_QWORD *)(a1 + 40);
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 48) - v3) >> 3) > v8++);
  }
}

double DspLib::LowFlow::Algorithm::Algorithm(DspLib::LowFlow::Algorithm *this)
{
  _WORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _OWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  _QWORD *v11;
  char *v12;
  _QWORD *v13;
  double result;

  v1 = (_WORD *)((char *)this + 11920);
  v2 = (_QWORD *)DspLib::AlgorithmBase::AlgorithmBase((uint64_t)this, &_ZGRN6DspLib7LowFlow10ParametersL8kDefaultE_, 0x38uLL, (uint64_t)&_ZGRN6DspLib7LowFlow10ParametersL8kMinimumE_, 56, (uint64_t)&_ZGRN6DspLib7LowFlow10ParametersL8kMaximumE_, 56);
  v3 = 0;
  *v2 = &off_1E69C4A48;
  v4 = 2;
  do
  {
    v5 = &v2[v3];
    *((_DWORD *)v5 + 56) = 0;
    *((_BYTE *)v5 + 228) = 0;
    v5[29] = 0;
    v5[30] = 0x42C8000000000000;
    *((_BYTE *)v5 + 256) = 0;
    v6 = &v2[v3 + 33];
    *((_DWORD *)v5 + 100) = 0;
    v5[51] = 0;
    *((_BYTE *)v5 + 416) = 0;
    v5[566] = 0;
    *((_DWORD *)v5 + 1134) = 0;
    *((_OWORD *)v5 + 284) = 0uLL;
    *((_OWORD *)v5 + 285) = 0uLL;
    *((_OWORD *)v5 + 286) = 0uLL;
    *v6 = 0uLL;
    v6[1] = 0uLL;
    v6[2] = 0uLL;
    v6[3] = 0uLL;
    v6[4] = 0uLL;
    v6[5] = 0uLL;
    v6[6] = 0uLL;
    v6[7] = 0uLL;
    v5[673] = 1065353216;
    *((_DWORD *)v5 + 1348) = 0;
    v7 = &v2[v3 + 673];
    *(_QWORD *)((char *)v7 + 12) = 0x5D00000055;
    *(_OWORD *)((char *)v7 + 20) = xmmword_1B6627BD0;
    v3 += 702;
    *((_BYTE *)v7 + 440) = 0;
    --v4;
  }
  while (v4);
  v8 = 0;
  v9 = (char *)v2 + 11572;
  v10 = 1460;
  do
  {
    v11 = &v2[v8];
    *((_DWORD *)v11 + 2864) = 0;
    v11[1433] = 0;
    v12 = &v9[v8 * 8];
    *(v12 - 100) = 0;
    v13 = &v2[v10];
    *(_OWORD *)((char *)v13 - 172) = 0uLL;
    *(_OWORD *)(v13 - 23) = 0uLL;
    *(_OWORD *)(v13 - 25) = 0uLL;
    *((_OWORD *)v12 - 3) = xmmword_1B662B470;
    *((_OWORD *)v12 - 2) = xmmword_1B662B480;
    *((_OWORD *)v12 - 1) = xmmword_1B662B490;
    *(_OWORD *)&v9[v8 * 8] = xmmword_1B662B4A0;
    *(_QWORD *)((char *)v13 - 84) = 0;
    *(_QWORD *)((char *)v13 - 92) = 0;
    *(_QWORD *)((char *)v13 - 76) = 0;
    *((_OWORD *)v13 - 4) = 0uLL;
    *((_OWORD *)v13 - 3) = 0uLL;
    *((_OWORD *)v13 - 2) = 0uLL;
    *(v13 - 2) = 0;
    *((_DWORD *)v11 + 2918) = 1065353216;
    *((_WORD *)v12 + 52) = 1;
    v8 += 29;
    v10 += 29;
    *v13 = 0;
  }
  while (v8 != 58);
  *v1 = 0;
  v2[1491] = 0;
  *(_QWORD *)&result = 0x8000000080;
  v2[4] = 0x8000000080;
  return result;
}

uint64_t DspLib::LowFlow::Algorithm::initialize(DspLib::LowFlow::Algorithm *this, int a2, double a3)
{
  uint64_t v4;
  _BOOL4 v5;

  v4 = DspLib::AlgorithmBase::initialize(this, a2, a3);
  if ((_DWORD)v4)
  {
    v5 = *((_DWORD *)this + 3) == 4;
    DspLib::LowFlow::AnalysisPath::initialize((uint64_t)this + 224, 0, v5);
    DspLib::LowFlow::Mitigator::initialize((DspLib::LowFlow::Algorithm *)((char *)this + 11456), 0, v5);
    DspLib::LowFlow::AnalysisPath::initialize((uint64_t)this + 5840, 1, v5);
    DspLib::LowFlow::Mitigator::initialize((DspLib::LowFlow::Algorithm *)((char *)this + 11688), 1, v5);
    *((_BYTE *)this + 8) = 1;
    (*(void (**)(DspLib::LowFlow::Algorithm *))(*(_QWORD *)this + 144))(this);
  }
  (*(void (**)(DspLib::LowFlow::Algorithm *))(*(_QWORD *)this + 152))(this);
  return v4;
}

void DspLib::LowFlow::Algorithm::uninitialize(DspLib::LowFlow::Algorithm *this)
{
  DspLib::LowFlow::AnalysisPath *v1;
  char *v2;
  uint64_t v3;
  uint64_t i;

  *((_BYTE *)this + 8) = 0;
  v1 = (DspLib::LowFlow::Algorithm *)((char *)this + 224);
  v2 = (char *)this + 11456;
  v3 = 11232;
  do
  {
    DspLib::LowFlow::AnalysisPath::uninitialize(v1);
    v1 = (DspLib::LowFlow::AnalysisPath *)((char *)v1 + 5616);
    v3 -= 5616;
  }
  while (v3);
  for (i = 0; i != 464; i += 232)
    DspLib::LowFlow::Mitigator::uninitialize((DspLib::LowFlow::Mitigator *)&v2[i]);
}

void DspLib::LowFlow::Algorithm::reset(DspLib::LowFlow::Algorithm *this)
{
  DspLib::LowFlow::AnalysisPath *v1;
  char *v2;
  uint64_t v3;
  uint64_t i;

  v1 = (DspLib::LowFlow::Algorithm *)((char *)this + 224);
  v2 = (char *)this + 11456;
  v3 = 11232;
  do
  {
    DspLib::LowFlow::AnalysisPath::reset(v1);
    v1 = (DspLib::LowFlow::AnalysisPath *)((char *)v1 + 5616);
    v3 -= 5616;
  }
  while (v3);
  for (i = 0; i != 464; i += 232)
    DspLib::LowFlow::Mitigator::reset((DspLib::LowFlow::Mitigator *)&v2[i]);
}

void DspLib::LowFlow::Algorithm::setParameters(uint64_t a1, const void *a2, uint64_t a3, __n128 a4)
{
  BOOL *v5;
  float *v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;

  v5 = (BOOL *)(a1 + 11920);
  DspLib::AlgorithmBase::setParameters((_QWORD *)a1, a2, a3, a4);
  v6 = *(float **)(a1 + 48);
  v7 = *v6;
  v5[1] = v6[1] >= 0.5;
  *v5 = v7 >= 0.5;
  LODWORD(v6) = vcvtas_u32_f32(v6[5]);
  *(_QWORD *)(a1 + 11928) = v6;
  if (*(_BYTE *)(a1 + 8))
  {
    v8 = a1 + 224;
    v9 = 11232;
    do
    {
      DspLib::LowFlow::AnalysisPath::setParameters(v8, *(_QWORD *)(a1 + 48), (uint64_t)(*(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48)) >> 2, *(_QWORD *)(a1 + 11928) << 7);
      v8 += 5616;
      v9 -= 5616;
    }
    while (v9);
    for (i = 0; i != 464; i += 232)
      DspLib::LowFlow::Mitigator::setParameters(a1 + 11456 + i, *(_QWORD *)(a1 + 48), (uint64_t)(*(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48)) >> 2, *(_QWORD *)(a1 + 11928) << 7);
  }
}

void DspLib::LowFlow::Algorithm::processBlock(DspLib::LowFlow::Algorithm *this, DspLibBuffer *a2, DspLibBuffer *a3)
{
  DspLib::LowFlow::Algorithm *v5;
  _BYTE *v6;
  uint64_t cycle_count;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  float **v12;
  size_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  float **v17;
  size_t v18;
  unsigned int v19;
  char *v20;
  unsigned __int8 *v21;
  uint64_t v22;
  float **v23;
  char v24;
  uint64_t v25;
  char v26;
  float *v27;
  unint64_t v28;
  vDSP_Length v29;
  float v30;
  uint64_t v31;
  char v32;
  float **v33;
  unsigned __int8 *v34;
  char v35;
  uint64_t v36;
  char *v37;
  float *v38;
  unint64_t v39;
  vp::utility::CPU_Profiler *v40[2];
  unsigned __int8 *v41;
  float **v42;
  uint64_t v43;
  _BYTE *v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v5 = this;
  v48 = *MEMORY[0x1E0C80C00];
  v6 = (char *)this + 11920;
  cycle_count = vp::utility::CPU_Profiler::get_cycle_count(a2);
  DspLibBuffer::setNumFrames(a3, cycle_count);
  if (*v6)
  {
    DspLibBuffer::operator=((uint64_t)a3, a2);
  }
  else
  {
    v44 = v6;
    if (*((_BYTE *)v5 + 40))
      DspLib::CPUMeasure::start((int8x16_t *)((char *)v5 + 72));
    v8 = *((_DWORD *)v5 + 3);
    v9 = DspLibBuffer::numChannels(a2);
    v40[1] = (vp::utility::CPU_Profiler *)v40;
    MEMORY[0x1E0C80A78](v9);
    v12 = (float **)((char *)v40 - v11);
    if (v10 >= 0x200)
      v13 = 512;
    else
      v13 = v10;
    bzero((char *)v40 - v11, v13);
    v40[0] = a2;
    DspLibBuffer::channelsPtr((float *)a2, v12);
    v14 = DspLibBuffer::numChannels(a3);
    MEMORY[0x1E0C80A78](v14);
    v17 = (float **)((char *)v40 - v16);
    if (v15 >= 0x200)
      v18 = 512;
    else
      v18 = v15;
    bzero((char *)v40 - v16, v18);
    DspLibBuffer::channelsPtr((float *)a3, v17);
    if ((_DWORD)cycle_count)
    {
      v19 = 0;
      v20 = (char *)v5 + 224;
      v45 = (char *)v5 + 11456;
      v42 = v17;
      v43 = cycle_count;
      v41 = (unsigned __int8 *)v5 + 5824;
      do
      {
        v21 = (unsigned __int8 *)v5;
        v22 = 0;
        v46 = 0;
        v47 = 0;
        v23 = (float **)(cycle_count - v19);
        v24 = 1;
        v25 = v19;
        do
        {
          v26 = v24;
          if (v8 == 4)
            v27 = &(*(float **)((char *)v12 + ((8 * v22) | 0x10)))[v25];
          else
            v27 = 0;
          v28 = DspLib::LowFlow::AnalysisPath::process((DspLib::LowFlow::AnalysisPath *)&v20[5616 * v22], &v12[v22][v25], v23, v27, v21[40]);
          v24 = 0;
          *(&v46 + v22) = *(_QWORD *)&v20[5616 * v22 + 16];
          v22 = 1;
        }
        while ((v26 & 1) != 0);
        v29 = v28;
        if (v44[1])
        {
          v30 = fmaxf(*((float *)&v46 + 1), 0.0);
          if (v30 < *((float *)&v47 + 1))
            v30 = *((float *)&v47 + 1);
          *((float *)&v46 + 1) = v30;
          *((float *)&v47 + 1) = v30;
        }
        v31 = 0;
        v32 = 1;
        v5 = (DspLib::LowFlow::Algorithm *)v21;
        v34 = v41;
        v33 = v42;
        do
        {
          v35 = v32;
          if (v8 == 4)
          {
            v36 = (8 * v31) | 0x10;
            v37 = (char *)&(*(float **)((char *)v12 + v36))[v25];
            v38 = &(*(float **)((char *)v33 + v36))[v25];
          }
          else
          {
            v37 = 0;
            v38 = 0;
          }
          DspLib::LowFlow::Mitigator::process((uint64_t)&v45[232 * v31], (char *)&v12[v31][v25], (int)(&v46 + v31), *(_QWORD *)&v20[5616 * v31 + 144], ((*((_QWORD *)v5 + 1491) & 0x1FFFFFFFFFFFFFFLL) << 6) | 1, &v33[v31][v25], v29, *v34 != 0, v37, v38);
          v32 = 0;
          v31 = 1;
        }
        while ((v35 & 1) != 0);
        v19 = v25 + v29;
        LODWORD(cycle_count) = v43;
      }
      while ((int)v25 + (int)v29 < v43);
    }
    if (*((_BYTE *)v5 + 40))
    {
      v39 = vp::utility::CPU_Profiler::get_cycle_count(v40[0]);
      DspLib::CPUMeasure::stop((DspLib::LowFlow::Algorithm *)((char *)v5 + 72), v39, *((double *)v5 + 3));
    }
  }
}

void DspLib::LowFlow::Algorithm::status(uint64_t a1, float *a2, vDSP_Length __N)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;

  DspLib::clear(a2, __N);
  v5 = a1 + 224;
  v6 = a1 + 11456;
  v7 = 11232;
  do
  {
    DspLib::LowFlow::AnalysisPath::status(v5, (uint64_t)a2);
    v5 += 5616;
    v7 -= 5616;
  }
  while (v7);
  for (i = 0; i != 464; i += 232)
    DspLib::LowFlow::Mitigator::status(v6 + i, (uint64_t)a2);
}

uint64_t DspLib::LowFlow::Algorithm::setModelParameters(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, _DWORD *a5)
{
  const void *v10;

  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1))
    return 1;
  DspLib::LowFlow::AnalysisPath::setModelParameters(a1 + 224, a2, (const void *)a3, a4, a5);
  if (a4)
    v10 = a4 + 4096;
  else
    v10 = 0;
  DspLib::LowFlow::AnalysisPath::setModelParameters(a1 + 5840, a2 + 36, (const void *)(a3 + 4096), v10, a5);
  return 0;
}

void DspLib::LowFlow::Algorithm::~Algorithm(DspLib::LowFlow::Algorithm *this)
{
  DspLib::LowFlow::Algorithm::~Algorithm(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  DspLib::LowFlow::AnalysisPath *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;

  v2 = 0;
  *(_QWORD *)this = &off_1E69C4A48;
  v3 = (char *)this + 11848;
  do
  {
    v4 = *(_QWORD *)((char *)this + v2 + 11912);
    *(_QWORD *)((char *)this + v2 + 11912) = 0;
    if (v4)
      std::default_delete<DspLib::LinearDelay>::operator()[abi:ne180100]((uint64_t)&v3[v2 + 64], v4);
    v5 = *(void **)((char *)this + v2 + 11880);
    if (v5)
    {
      *(_QWORD *)((char *)this + v2 + 11888) = v5;
      operator delete(v5);
    }
    v6 = *(_QWORD *)((char *)this + v2 + 11872);
    *(_QWORD *)((char *)this + v2 + 11872) = 0;
    if (v6)
      std::default_delete<DspLib::FFT::PartialFrameInverseSTFT>::operator()[abi:ne180100]((uint64_t)&v3[v2 + 24], v6);
    v7 = *(void **)((char *)this + v2 + 11848);
    if (v7)
    {
      *(_QWORD *)((char *)this + v2 + 11856) = v7;
      operator delete(v7);
    }
    v8 = *(_QWORD *)((char *)this + v2 + 11736);
    *(_QWORD *)((char *)this + v2 + 11736) = 0;
    if (v8)
      std::default_delete<DspLib::FFT::PartialFrameForwardSTFT>::operator()[abi:ne180100]((uint64_t)&v3[v2 - 112], v8);
    v9 = *(void **)((char *)this + v2 + 11712);
    if (v9)
    {
      *(_QWORD *)((char *)this + v2 + 11720) = v9;
      operator delete(v9);
    }
    v2 -= 232;
  }
  while (v2 != -464);
  v10 = (DspLib::LowFlow::Algorithm *)((char *)this + 5840);
  v11 = -11232;
  do
  {
    DspLib::LowFlow::AnalysisPath::~AnalysisPath(v10);
    v10 = (DspLib::LowFlow::AnalysisPath *)(v12 - 5616);
    v11 += 5616;
  }
  while (v11);
  *(_QWORD *)this = off_1E69C46F0;
  v13 = (void *)*((_QWORD *)this + 6);
  if (v13)
  {
    *((_QWORD *)this + 7) = v13;
    operator delete(v13);
  }
}

double DspLib::LowFlow::Algorithm::latencySamples(DspLib::LowFlow::Algorithm *this)
{
  return (double)(unint64_t)((*((_QWORD *)this + 1491) << 7) - 128);
}

uint64_t DspLib::LowFlow::Algorithm::numStatus(DspLib::LowFlow::Algorithm *this)
{
  return 1500;
}

void DspLib::LowFlow::AnalysisPath::~AnalysisPath(DspLib::LowFlow::AnalysisPath *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;

  v2 = (void *)*((_QWORD *)this + 543);
  if (v2)
  {
    *((_QWORD *)this + 544) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 540);
  if (v3)
  {
    *((_QWORD *)this + 541) = v3;
    operator delete(v3);
  }
  v4 = *((_QWORD *)this + 538);
  *((_QWORD *)this + 538) = 0;
  if (v4)
    MEMORY[0x1BCC95CEC](v4, 0x1000C40BAFFE814);
  v5 = (void *)*((_QWORD *)this + 18);
  if (v5)
  {
    *((_QWORD *)this + 19) = v5;
    operator delete(v5);
  }
  v6 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v6)
    std::default_delete<DspLib::FFT::BufferedForwardSTFT>::operator()[abi:ne180100]((uint64_t)this + 136, v6);
  v7 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v7)
    std::default_delete<DspLib::FFT::BufferedForwardSTFT>::operator()[abi:ne180100]((uint64_t)this + 128, v7);
  v8 = (void *)*((_QWORD *)this + 13);
  if (v8)
  {
    *((_QWORD *)this + 14) = v8;
    operator delete(v8);
  }
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::LowFlow::AnalysisPath *)((char *)this + 80));
  v9 = (void *)*((_QWORD *)this + 7);
  if (v9)
  {
    *((_QWORD *)this + 8) = v9;
    operator delete(v9);
  }
}

void DspLib::LoudspeakerManagerV1::PowerMeter::reset(DspLib::CircularDelay **this)
{
  DspLib::CircularDelay *v2;
  DspLib::CircularDelay *v3;
  DspLib::CircularDelay *v4;
  DspLib::CircularDelay *v5;

  DspLib::FIRDecimator::reset((DspLib::FIRDecimator *)this);
  v2 = this[12];
  v3 = this[13];
  while (v2 != v3)
  {
    *((_DWORD *)v2 + 8) = 0;
    DspLib::CircularDelay::reset(v2);
    v2 = (DspLib::CircularDelay *)((char *)v2 + 40);
  }
  v4 = this[17];
  v5 = this[18];
  if (v4 != v5)
    bzero(v4, ((v5 - v4 - 4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  this[15] = 0;
}

void DspLib::LoudspeakerManagerV1::PowerMeter::setParameters(DspLib::LoudspeakerManagerV1::PowerMeter *this, float a2, float a3, unint64_t a4, double a5, const float *a6, unint64_t a7)
{
  __n128 v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  char *v17;
  uint64_t v18;
  _QWORD v19[3];
  _QWORD *v20;
  float v21[62];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 80))
  {
    *((float *)this + 21) = a2;
    *((float *)this + 22) = a3;
  }
  std::vector<DspLib::MovingAverage>::__clear[abi:ne180100]((uint64_t *)this + 12);
  std::vector<DspLib::MovingAverage>::resize((uint64_t *)this + 12, a7);
  std::vector<std::vector<float>>::resize((uint64_t *)this + 6, 2uLL);
  DspLib::FIRDecimator::setSrcParameters(this, 6uLL, a4);
  v19[0] = &unk_1E69BFC40;
  v19[1] = DspLib::makeChebychevWindow;
  v20 = v19;
  v12.n128_f32[0] = DspLib::makeSincWindow(v21, 0x3DuLL, 6u, 0xAu, (uint64_t)v19, 0.6);
  v13 = v20;
  if (v20 == v19)
  {
    v14 = 4;
    v13 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_8;
    v14 = 5;
  }
  (*(void (**)(__n128))(*v13 + 8 * v14))(v12);
LABEL_8:
  DspLib::FIRDecimator::setCoefficients((uint64_t)this, v21, 0x3DuLL);
  *((double *)this + 16) = a5 / (double)*(unint64_t *)this;
  if (a7)
  {
    v15 = 0;
    v16 = 1;
    do
    {
      DspLib::MovingAverage::setLength((DspLib::MovingAverage *)(*((_QWORD *)this + 12) + 40 * v15), vcvtad_u64_f64(*((double *)this + 16) * a6[v15]));
      v15 = v16++;
    }
    while (v15 < a7);
  }
  v18 = *((_QWORD *)this + 17);
  v17 = (char *)this + 136;
  *((_QWORD *)v17 + 1) = v18;
  std::vector<float>::resize((uint64_t)v17, a7);
}

void sub_1B60E9854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12)
{
  uint64_t *v12;
  uint64_t *v14;
  uint64_t v15;

  v14 = a12;
  if (a12 == v12)
  {
    v15 = 4;
    v14 = &a9;
  }
  else
  {
    if (!a12)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void std::vector<DspLib::MovingAverage>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;

  v3 = a1[1];
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<DspLib::MovingAverage>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 40 * a2;
    if (v3 != v7)
    {
      v8 = a1[1];
      do
      {
        v10 = *(void **)(v8 - 40);
        v8 -= 40;
        v9 = v10;
        if (v10)
        {
          *(_QWORD *)(v3 - 32) = v9;
          operator delete(v9);
        }
        v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

int32x2_t DspLib::LoudspeakerManagerV1::PowerMeter::setSpVACalibration(uint64_t a1, uint64_t a2)
{
  int32x2_t result;

  *(_BYTE *)(a1 + 80) = 1;
  result = vrev64_s32(*(int32x2_t *)(a2 + 4));
  *(int32x2_t *)(a1 + 84) = result;
  return result;
}

void DspLib::LoudspeakerManagerV1::PowerMeter::process(DspLib::LoudspeakerManagerV1::PowerMeter *this, float *a2, float *a3, uint64_t a4)
{
  DspLib::MovingAverage *v8;
  DspLib::MovingAverage *v9;
  vDSP_Length v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  float v19;
  float v20;
  uint64_t v21;
  _QWORD v24[3];
  _QWORD v25[2];
  vDSP_Length v26;
  _QWORD v27[2];
  _QWORD v28[3];

  v28[2] = *MEMORY[0x1E0C80C00];
  if (*((double *)this + 16) <= (double)*((unint64_t *)this + 15))
  {
    v8 = (DspLib::MovingAverage *)*((_QWORD *)this + 12);
    v9 = (DspLib::MovingAverage *)*((_QWORD *)this + 13);
    while (v8 != v9)
    {
      DspLib::MovingAverage::recalculateState(v8);
      v8 = (DspLib::MovingAverage *)((char *)v8 + 40);
    }
    *((_QWORD *)this + 15) = 0;
  }
  if (a4)
  {
    v10 = *((_QWORD *)this + 4);
    v11 = MEMORY[0x1E0C80A78](this);
    v13 = (float *)((char *)&v24[-1] - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
    MEMORY[0x1E0C80A78](v11);
    v15 = (float *)((char *)&v24[-1] - v14);
    v28[0] = a2;
    v28[1] = a3;
    v27[0] = v13;
    v27[1] = (char *)&v24[-1] - v14;
    v25[0] = v27;
    v25[1] = 2;
    v26 = v10;
    v24[0] = v28;
    v24[1] = 2;
    v24[2] = a4;
    DspLib::FIRDecimator::process((uint64_t)this, v24, v25);
    if (v26)
    {
      DspLib::multiply(v13, v10, v15);
      v16 = *((_QWORD *)this + 12);
      if (*((_QWORD *)this + 13) != v16)
      {
        v17 = 0;
        v18 = 1;
        do
        {
          DspLib::MovingAverage::process((uint64_t *)(v16 + 40 * v17), v13, v10, (char *)v15, v10);
          v19 = *((float *)this + 21) * *((float *)this + 22);
          v20 = v19 * DspLib::maxv(v15, v10);
          v21 = *((_QWORD *)this + 17);
          if (*(float *)(v21 + 4 * v17) >= v20)
            v20 = *(float *)(v21 + 4 * v17);
          *(float *)(v21 + 4 * v17) = v20;
          v17 = v18;
          v16 = *((_QWORD *)this + 12);
        }
        while (0xCCCCCCCCCCCCCCCDLL * ((*((_QWORD *)this + 13) - v16) >> 3) > v18++);
      }
      *((_QWORD *)this + 15) += v26;
    }
  }
}

float DspLib::LoudspeakerManagerV1::PowerMeter::status(uint64_t a1, uint64_t a2)
{
  float v2;
  float result;

  v2 = 0.0;
  if (*(_BYTE *)(a1 + 80))
    v2 = 1.0;
  *(float *)(a2 + 20) = v2;
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 84);
  result = *(float *)(a1 + 88);
  *(float *)(a2 + 28) = result;
  return result;
}

void DspLib::LoudspeakerManagerV1::PowerMeter::getPeakPowers(DspLib::LoudspeakerManagerV1::PowerMeter *this, float *__dst)
{
  _BYTE *v2;
  _BYTE *v3;
  _BYTE *v5;
  _BYTE *v6;

  v2 = (_BYTE *)*((_QWORD *)this + 17);
  v3 = (_BYTE *)*((_QWORD *)this + 18);
  if (v3 != v2)
  {
    memmove(__dst, v2, v3 - v2);
    v5 = (_BYTE *)*((_QWORD *)this + 17);
    v6 = (_BYTE *)*((_QWORD *)this + 18);
    if (v5 != v6)
      bzero(v5, ((v6 - v5 - 4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
}

uint64_t std::vector<DspLib::MovingAverage>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  _QWORD v16[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = v7 + 40 * a2;
      do
      {
        *(_QWORD *)(v7 + 32) = 0;
        *(_OWORD *)v7 = 0uLL;
        *(_OWORD *)(v7 + 16) = 0uLL;
        *(_DWORD *)(v7 + 36) = 1065353216;
        v7 += 40;
      }
      while (v7 != v13);
      v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x333333333333333)
      v11 = 0x666666666666666;
    else
      v11 = v9;
    v16[4] = result;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DspLib::PeakPowerGuard::AdmittanceFilterCoeffSet::Preset>>(result, v11);
    else
      v12 = 0;
    v14 = &v12[40 * v8];
    v16[0] = v12;
    v16[1] = v14;
    v16[3] = &v12[40 * v11];
    v15 = &v14[40 * a2];
    do
    {
      *((_QWORD *)v14 + 4) = 0;
      *(_OWORD *)v14 = 0uLL;
      *((_OWORD *)v14 + 1) = 0uLL;
      *((_DWORD *)v14 + 9) = 1065353216;
      v14 += 40;
    }
    while (v14 != v15);
    v16[2] = v15;
    std::vector<DspLib::MovingAverage>::__swap_out_circular_buffer(a1, v16);
    return std::__split_buffer<DspLib::MovingAverage>::~__split_buffer((uint64_t)v16);
  }
  return result;
}

void sub_1B60E9D00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<DspLib::MovingAverage>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<DspLib::MovingAverage>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<DspLib::MovingAverage>,std::reverse_iterator<DspLib::MovingAverage*>,std::reverse_iterator<DspLib::MovingAverage*>,std::reverse_iterator<DspLib::MovingAverage*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<DspLib::MovingAverage>,std::reverse_iterator<DspLib::MovingAverage*>,std::reverse_iterator<DspLib::MovingAverage*>,std::reverse_iterator<DspLib::MovingAverage*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 40) = 0;
      *(_QWORD *)(v7 - 32) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      v8 = *(_OWORD *)(a3 - 5);
      a3 -= 5;
      *(_OWORD *)(v7 - 40) = v8;
      *(_QWORD *)(v7 - 24) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      *(_QWORD *)(v7 - 16) = a3[3];
      *(_QWORD *)(v7 - 8) = a3[4];
      v7 = *((_QWORD *)&v14 + 1) - 40;
      *((_QWORD *)&v14 + 1) -= 40;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<DspLib::MovingAverage>,std::reverse_iterator<DspLib::MovingAverage*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<DspLib::MovingAverage>,std::reverse_iterator<DspLib::MovingAverage*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<DspLib::MovingAverage>,std::reverse_iterator<DspLib::MovingAverage*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<DspLib::MovingAverage>,std::reverse_iterator<DspLib::MovingAverage*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 40;
  }
}

uint64_t std::__split_buffer<DspLib::MovingAverage>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<DspLib::MovingAverage>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<DspLib::MovingAverage>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 40);
    *(_QWORD *)(a1 + 16) = v2 - 40;
    if (v5)
    {
      *(_QWORD *)(v2 - 32) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 40;
    }
  }
}

DspLib::MeisterStueck::Algorithm *DspLib::MeisterStueck::Algorithm::Algorithm(DspLib::MeisterStueck::Algorithm *this, char a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;

  v4 = DspLib::AlgorithmBase::AlgorithmBase((uint64_t)this, &DspLib::MeisterStueck::Parameters::kDefault, 0x87uLL, (uint64_t)&DspLib::MeisterStueck::Parameters::kMinimum, 135, (uint64_t)&DspLib::MeisterStueck::Parameters::kMaximum, 135);
  *(_QWORD *)v4 = &off_1E69C4B58;
  *(_OWORD *)(v4 + 216) = 0u;
  *(_OWORD *)(v4 + 232) = 0u;
  *(_OWORD *)(v4 + 248) = 0u;
  *(_BYTE *)(v4 + 264) = 1;
  *(_DWORD *)(v4 + 268) = 1065353216;
  *(_BYTE *)(v4 + 272) = 0;
  *(_DWORD *)(v4 + 276) = 1065353216;
  *(_BYTE *)(v4 + 280) = 0;
  *(_QWORD *)&v5 = 0x100000001;
  *((_QWORD *)&v5 + 1) = 0x100000001;
  *(_OWORD *)(v4 + 284) = v5;
  *(_BYTE *)(v4 + 300) = 0;
  *(_BYTE *)(v4 + 328) = 0;
  *(_DWORD *)(v4 + 332) = 0;
  *(_QWORD *)(v4 + 304) = 0;
  *(_QWORD *)(v4 + 312) = 0;
  *(_QWORD *)(v4 + 320) = &off_1E69C4400;
  *(_BYTE *)(v4 + 336) = 0;
  *(_OWORD *)(v4 + 344) = 0u;
  *(_OWORD *)(v4 + 360) = 0u;
  *(_OWORD *)(v4 + 376) = 0u;
  *(_OWORD *)(v4 + 392) = 0u;
  *(_OWORD *)(v4 + 408) = 0u;
  v6 = v4 + 432;
  *(_QWORD *)(v4 + 424) = 0;
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::FilterBank((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)(v4 + 432));
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::FilterBank((DspLib::MeisterStueck::Algorithm *)((char *)this + 1016));
  *((_QWORD *)this + 220) = 0;
  *((_OWORD *)this + 109) = 0u;
  *((_OWORD *)this + 108) = 0u;
  *((_OWORD *)this + 107) = 0u;
  *((_OWORD *)this + 106) = 0u;
  *((_OWORD *)this + 105) = 0u;
  *((_OWORD *)this + 104) = 0u;
  *((_OWORD *)this + 103) = 0u;
  *((_OWORD *)this + 102) = 0u;
  *((_OWORD *)this + 101) = 0u;
  *((_OWORD *)this + 100) = 0u;
  *((_BYTE *)this + 300) = a2;
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::setPhaseCompensationOnlyMode(v6, a2);
  return this;
}

void sub_1B60EA094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _QWORD *a10)
{
  _QWORD *v10;
  DspLib::AnalyticSignalTransformAllpass *v11;
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank *v12;
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank *v13;
  DspLib::MeisterStueck::Kernel::ScratchArea *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  void *v24;

  v16 = v10[220];
  v10[220] = 0;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  v17 = v10[219];
  v10[219] = 0;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  v18 = 0;
  v19 = v10 + 218;
  while (1)
  {
    v20 = v19[v18];
    v19[v18] = 0;
    if (v20)
      MEMORY[0x1BCC95CEC](v20, 0x1000C4027586B93);
    if (--v18 == -3)
    {
      DspLib::MeisterStueck::Kernel::ScratchArea::~ScratchArea(v14);
      v21 = 0;
      v22 = v10 + 203;
      while (1)
      {
        v23 = v22[v21];
        v22[v21] = 0;
        if (v23)
          (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
        if (--v21 == -4)
        {
          DspLib::FourBandRandomOrderLrFilterBank::FilterBank::~FilterBank(v13);
          DspLib::FourBandRandomOrderLrFilterBank::FilterBank::~FilterBank(v12);
          DspLib::AnalyticSignalTransformAllpass::~AnalyticSignalTransformAllpass(v11);
          a10 = v10 + 30;
          std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
          std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
          *v10 = off_1E69C46F0;
          v24 = (void *)v10[6];
          if (v24)
          {
            v10[7] = v24;
            operator delete(v24);
          }
          _Unwind_Resume(a1);
        }
      }
    }
  }
}

void DspLib::MeisterStueck::Kernel::ScratchArea::~ScratchArea(DspLib::MeisterStueck::Kernel::ScratchArea *this)
{
  void *v2;
  void *v3;
  void **v4;

  v2 = (void *)*((_QWORD *)this + 9);
  if (v2)
  {
    *((_QWORD *)this + 10) = v2;
    operator delete(v2);
  }
  v4 = (void **)((char *)this + 48);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  v4 = (void **)this;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
}

uint64_t DspLib::MeisterStueck::Algorithm::initialize(DspLib::MeisterStueck::Algorithm *this, int a2, double a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v12;

  v5 = DspLib::AlgorithmBase::initialize(this, a2, a3);
  v6 = v5;
  if (a2 != 1 && *((_BYTE *)this + 300))
  {
    v12 = basename("/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/DspLib/MeisterStueck/dsp/DspLibMeisterStueck.cpp");
    printf("DSP Sound assertion in %s at line %d\n", v12, 23);
    ++DspLibDebug::mAssertCounter;
  }
  else if ((_DWORD)v5)
  {
    std::vector<std::vector<float>>::resize((uint64_t *)this + 27, *((unsigned int *)this + 3));
    v7 = *((_QWORD *)this + 27);
    v8 = *((_QWORD *)this + 28);
    while (v7 != v8)
    {
      std::vector<float>::resize(v7, *((unsigned int *)this + 8));
      v7 += 24;
    }
    std::vector<std::vector<float>>::resize((uint64_t *)this + 30, *((unsigned int *)this + 3));
    v9 = *((_QWORD *)this + 30);
    v10 = *((_QWORD *)this + 31);
    while (v9 != v10)
    {
      std::vector<float>::resize(v9, *((unsigned int *)this + 8));
      v9 += 24;
    }
    DspLib::FourBandRandomOrderLrFilterBank::FilterBank::initialize((DspLib::MeisterStueck::Algorithm *)((char *)this + 432), *((_DWORD *)this + 3), *((double *)this + 3));
    *((_BYTE *)this + 8) = 1;
    (*(void (**)(DspLib::MeisterStueck::Algorithm *))(*(_QWORD *)this + 144))(this);
    (*(void (**)(DspLib::MeisterStueck::Algorithm *, _QWORD))(*(_QWORD *)this + 200))(this, *((unsigned __int8 *)this + 40));
  }
  return v6;
}

void DspLib::MeisterStueck::Algorithm::uninitialize(DspLib::MeisterStueck::Algorithm *this)
{
  uint64_t v2;
  char *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = 0;
  *((_BYTE *)this + 8) = 0;
  v3 = (char *)this + 1600;
  v4 = (uint64_t *)((char *)this + 1632);
  do
  {
    v5 = *(_QWORD *)&v3[v2];
    *(_QWORD *)&v3[v2] = 0;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    v2 += 8;
  }
  while (v2 != 32);
  std::vector<std::vector<float>>::__clear[abi:ne180100](v4);
  *((_QWORD *)this + 208) = *((_QWORD *)this + 207);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 210);
  v6 = 0;
  *((_QWORD *)this + 214) = *((_QWORD *)this + 213);
  v7 = (char *)this + 1728;
  do
  {
    v8 = *(_QWORD *)&v7[v6];
    *(_QWORD *)&v7[v6] = 0;
    if (v8)
      MEMORY[0x1BCC95CEC](v8, 0x1000C4027586B93);
    v6 += 8;
  }
  while (v6 != 24);
  DspLib::AnalyticSignalTransformAllpass::uninitialize((DspLib::MeisterStueck::Algorithm *)((char *)this + 320));
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::uninitialize((DspLib::MeisterStueck::Algorithm *)((char *)this + 432));
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::uninitialize((DspLib::MeisterStueck::Algorithm *)((char *)this + 1016));
  v9 = *((_QWORD *)this + 219);
  *((_QWORD *)this + 219) = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  v10 = *((_QWORD *)this + 220);
  *((_QWORD *)this + 220) = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 27);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 30);
}

void DspLib::MeisterStueck::Algorithm::reset(DspLib::MeisterStueck::Algorithm *this)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t i;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = 0;
  v3 = (char *)this + 1600;
  do
  {
    v4 = *(_QWORD *)&v3[v2];
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 152))(v4);
    v2 += 8;
  }
  while (v2 != 32);
  for (i = 0; i != 24; i += 8)
  {
    v6 = *(_DWORD **)((char *)this + i + 1728);
    if (v6)
    {
      v6[2] = 0;
      v6[4] = 0;
      v6[6] = 0;
    }
  }
  v7 = *((_QWORD *)this + 219);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 152))(v7);
  v8 = *((_QWORD *)this + 220);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 152))(v8);
  DspLib::AnalyticSignalTransformAllpass::reset((DspLib::MeisterStueck::Algorithm *)((char *)this + 320));
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::reset((DspLib::MeisterStueck::Algorithm *)((char *)this + 432));
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::reset((DspLib::MeisterStueck::Algorithm *)((char *)this + 1016));
}

uint64_t DspLib::MeisterStueck::Algorithm::setMeteringIsEnabled(uint64_t this, int a2)
{
  uint64_t v2;
  DspLib::AudioMeter::Algorithm *v3;
  double v4;
  uint64_t v5;
  DspLib::AudioMeter::Algorithm *v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;

  *(_BYTE *)(this + 40) = a2;
  if (!*(_BYTE *)(this + 300))
  {
    v2 = this;
    if (a2)
    {
      v3 = (DspLib::AudioMeter::Algorithm *)operator new();
      v4 = DspLib::AudioMeter::Algorithm::Algorithm(v3);
      v5 = *(_QWORD *)(v2 + 1752);
      *(_QWORD *)(v2 + 1752) = v3;
      if (v5)
        (*(void (**)(uint64_t, double))(*(_QWORD *)v5 + 8))(v5, v4);
      v6 = (DspLib::AudioMeter::Algorithm *)operator new();
      v7 = DspLib::AudioMeter::Algorithm::Algorithm(v6);
      v8 = *(_QWORD *)(v2 + 1760);
      *(_QWORD *)(v2 + 1760) = v6;
      if (v8)
        (*(void (**)(uint64_t, double))(*(_QWORD *)v8 + 8))(v8, v7);
      (*(void (**)(_QWORD, _QWORD, double))(**(_QWORD **)(v2 + 1752) + 16))(*(_QWORD *)(v2 + 1752), *(unsigned int *)(v2 + 12), *(double *)(v2 + 24));
      (*(void (**)(_QWORD, _QWORD, double))(**(_QWORD **)(v2 + 1760) + 16))(*(_QWORD *)(v2 + 1760), *(unsigned int *)(v2 + 16), *(double *)(v2 + 24));
      v9 = *(_QWORD *)(v2 + 48) + 488;
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v2 + 1752) + 144))(*(_QWORD *)(v2 + 1752), v9, 8);
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v2 + 1760) + 144))(*(_QWORD *)(v2 + 1760), v9, 8);
    }
    else
    {
      v10 = *(_QWORD *)(this + 1752);
      *(_QWORD *)(v2 + 1752) = 0;
      if (v10)
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
      v11 = *(_QWORD *)(v2 + 1760);
      *(_QWORD *)(v2 + 1760) = 0;
      if (v11)
        (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    }
    for (i = 0; i != 32; i += 8)
    {
      this = *(_QWORD *)(v2 + 1600 + i);
      if (this)
        this = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)this + 200))(this, *(unsigned __int8 *)(v2 + 40));
    }
  }
  return this;
}

void sub_1B60EA648(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10E1C4016621F76);
  _Unwind_Resume(a1);
}

void DspLib::MeisterStueck::Algorithm::setParameters(uint64_t a1, const void *a2, uint64_t a3, __n128 a4)
{
  float *v5;
  unsigned int v6;
  uint64_t i;
  _DWORD *v8;
  void *v9;
  uint8x8_t v10;

  DspLib::AlgorithmBase::setParameters((_QWORD *)a1, a2, a3, a4);
  if (!*(_BYTE *)(a1 + 8))
    return;
  v5 = *(float **)(a1 + 48);
  if (vcvtas_u32_f32(v5[134]) >= 3 && v5[131] >= 0.5)
  {
    *(_BYTE *)(a1 + 264) = 0;
  }
  else
  {
    v6 = vcvtas_u32_f32(v5[132]);
    if (!*(_BYTE *)(a1 + 264) && v6 != 2)
    {
      for (i = 0; i != 24; i += 8)
      {
        v8 = *(_DWORD **)(a1 + 1728 + i);
        if (v8)
        {
          v8[2] = 0;
          v8[4] = 0;
          v8[6] = 0;
        }
      }
    }
    *(_BYTE *)(a1 + 264) = v6 != 2;
    if (v6 != 2)
    {
      if (!*(_BYTE *)(a1 + 328))
        DspLib::AnalyticSignalTransformAllpass::initialize((DspLib::AnalyticSignalTransformAllpass *)(a1 + 320), *(_DWORD *)(a1 + 12));
      goto LABEL_16;
    }
  }
  DspLib::AnalyticSignalTransformAllpass::uninitialize((DspLib::AnalyticSignalTransformAllpass *)(a1 + 320));
LABEL_16:
  if (*(float *)(*(_QWORD *)(a1 + 48) + 472) >= 0.5)
  {
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 312) = 0;
  }
  else
  {
    if (*(_BYTE *)(a1 + 264))
    {
      if (*(_BYTE *)(a1 + 300))
        v9 = DspLib::MeisterStueck::Algorithm::processAnalyticalPhaseCompensator;
      else
        v9 = DspLib::MeisterStueck::Algorithm::processAnalyticalSignal;
    }
    else if (*(_BYTE *)(a1 + 300))
    {
      v9 = DspLib::MeisterStueck::Algorithm::processRegularPhaseCompensator;
    }
    else
    {
      v9 = DspLib::MeisterStueck::Algorithm::processRegularSignal;
    }
    *(_QWORD *)(a1 + 304) = v9;
    *(_QWORD *)(a1 + 312) = 0;
  }
  DspLib::MeisterStueck::Algorithm::setFilterbankParameters((DspLib::MeisterStueck::Algorithm *)a1);
  DspLib::MeisterStueck::Algorithm::setInputAndOutputGainParameters(a1);
  DspLib::MeisterStueck::Algorithm::setSRCParameters(a1);
  DspLib::MeisterStueck::Algorithm::setCompressorKernelParameters((DspLib::MeisterStueck::Algorithm *)a1);
  DspLib::MeisterStueck::Algorithm::setOSCFilterParameters((DspLib::MeisterStueck::Algorithm *)a1, v10);
}

void DspLib::MeisterStueck::Algorithm::setFilterbankParameters(DspLib::MeisterStueck::Algorithm *this)
{
  uint64_t v2;
  char v3;
  _OWORD *v4;
  __int128 v5;
  char *v6;
  uint64_t i;
  float v8;
  BOOL v9;
  float v10;
  int v11;
  _OWORD v12[2];
  _BYTE v13[28];

  v2 = 0;
  v3 = 0;
  v4 = (_OWORD *)*((_QWORD *)this + 6);
  *(_OWORD *)&v13[12] = v4[28];
  v5 = *(_OWORD *)((char *)v4 + 420);
  v12[0] = *(_OWORD *)((char *)v4 + 404);
  v12[1] = v5;
  *(_OWORD *)v13 = *(_OWORD *)((char *)v4 + 436);
  do
  {
    if (*(float *)((char *)v4 + v2 + 88) >= 0.5 && *(float *)((char *)v4 + v2 + 24) >= 0.5)
      v3 |= *((_BYTE *)this + 300) == 0;
    v2 += 100;
  }
  while (v2 != 400);
  v6 = (char *)v4 + 72;
  for (i = 44; i != 60; i += 4)
  {
    v8 = *((float *)v6 + 4);
    v9 = v8 < 0.5;
    if (v8 < 0.5)
      v10 = 0.0;
    else
      v10 = 1.0;
    *(float *)((char *)v12 + i) = v10;
    if (!v9)
    {
      if (((v3 & 1) != 0 && *((float *)v6 - 12) < 0.5 || *(float *)v6 >= 0.5) && !*((_BYTE *)this + 300))
        v11 = -1027080192;
      else
        v11 = *((_DWORD *)v6 + 5);
      *(_DWORD *)((char *)&v12[-1] + i - 4) = v11;
    }
    v6 += 100;
  }
  if (*((_BYTE *)this + 264))
  {
    if (!*((_BYTE *)this + 300))
      DspLib::FourBandRandomOrderLrFilterBank::FilterBank::initialize((DspLib::MeisterStueck::Algorithm *)((char *)this + 1016), *((_DWORD *)this + 3), *((double *)this + 3));
  }
  else
  {
    DspLib::FourBandRandomOrderLrFilterBank::FilterBank::uninitialize((DspLib::MeisterStueck::Algorithm *)((char *)this + 1016));
  }
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::setParameters((uint64_t)this + 432, v12, 15);
  if (!*((_BYTE *)this + 300))
  {
    if (*((_BYTE *)this + 1040))
      DspLib::FourBandRandomOrderLrFilterBank::FilterBank::setParameters((uint64_t)this + 1016, v12, 15);
  }
}

uint64_t DspLib::MeisterStueck::Algorithm::setInputAndOutputGainParameters(uint64_t this)
{
  uint64_t v1;
  DspLib *v2;
  _BOOL8 isEqual;
  DspLib *v4;

  if (!*(_BYTE *)(this + 300))
  {
    v1 = this;
    *(float *)(this + 268) = DspLib::dB2Amp((DspLib *)this, *(float *)(*(_QWORD *)(this + 48) + 400));
    isEqual = DspLib::isEqual(v2, *(float *)(*(_QWORD *)(v1 + 48) + 400), 0.0, 1.0e-20);
    *(_BYTE *)(v1 + 272) = !isEqual;
    *(float *)(v1 + 276) = DspLib::dB2Amp((DspLib *)isEqual, *(float *)(*(_QWORD *)(v1 + 48) + 480));
    this = DspLib::isEqual(v4, *(float *)(*(_QWORD *)(v1 + 48) + 480), 0.0, 1.0e-20);
    *(_BYTE *)(v1 + 280) = this ^ 1;
  }
  return this;
}

uint64_t DspLib::MeisterStueck::Algorithm::setSRCParameters(uint64_t this)
{
  uint64_t v1;
  float *v2;
  unsigned int v3;
  unsigned int v4;
  float v5;
  uint64_t v6;
  unsigned int v7;
  float v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  float v13;
  float v14;
  uint8x8_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  uint64_t v22;

  if (!*(_BYTE *)(this + 300))
  {
    v1 = this;
    v2 = *(float **)(this + 48);
    v3 = vcvtas_u32_f32(v2[134]);
    v4 = vcvtas_u32_f32(v2[132]);
    if (v3)
    {
      v5 = 100.0;
      if (v4 != 1)
        v5 = 65.0;
    }
    else if (v4 == 1)
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)this + 120))(this, 130);
    }
    else
    {
      v5 = v2[130];
    }
    v6 = 0;
    v7 = 0;
    v8 = fabsf(v5);
    v9 = 88;
    do
    {
      v10 = DspLib::FourBandRandomOrderLrFilterBank::FilterBank::xOverOrder((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)(v1 + 432), v6);
      v11 = vcvtas_u32_f32((float)v10 * 0.5);
      if (v3)
        v12 = v11;
      else
        v12 = v10;
      v13 = *(double *)(v1 + 24);
      v14 = DspLib::FourBandRandomOrderLrFilterBank::FilterBank::xOverFrequency((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)(v1 + 432), v6);
      *(float *)v15.i32 = exp2f(v8 / (float)((float)v12 * 6.0));
      v16 = (float)(v13 / (float)(v14 * (float)(*(float *)v15.i32 + *(float *)v15.i32)));
      if (v16 <= 1)
        v17 = 1;
      else
        v17 = (float)(v13 / (float)(v14 * (float)(*(float *)v15.i32 + *(float *)v15.i32)));
      v15.i32[0] = *(_DWORD *)(*(_QWORD *)(v1 + 48) + v9);
      if (*(float *)v15.i32 < 0.5
        || v16 < 2
        || (this = DspLib::FourBandRandomOrderLrFilterBank::FilterBank::numActiveBands((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)(v1 + 432), v15), v7 >= (int)this - 1))
      {
        *(_DWORD *)(v1 + 4 * v6 + 284) = 1;
        v22 = v1 + 8 * v6;
        this = *(_QWORD *)(v22 + 1728);
        *(_QWORD *)(v22 + 1728) = 0;
        if (this)
          this = MEMORY[0x1BCC95CEC](this, 0x1000C4027586B93);
      }
      else
      {
        v18 = v1 + 8 * v6;
        if (!*(_QWORD *)(v18 + 1728))
        {
          v19 = operator new();
          *(_OWORD *)v19 = xmmword_1B662B770;
          *(_QWORD *)(v19 + 16) = 0x100000000;
          *(_DWORD *)(v19 + 24) = 0;
          this = *(_QWORD *)(v18 + 1728);
          *(_QWORD *)(v18 + 1728) = v19;
          if (this)
            this = MEMORY[0x1BCC95CEC](this, 0x1000C4027586B93);
        }
        v20 = v1 + 4 * v6;
        if (*(_DWORD *)(v20 + 284) != v17)
        {
          *(_DWORD *)(v20 + 284) = v17;
          v21 = *(unsigned int **)(v18 + 1728);
          v21[2] = 0;
          v21[3] = v17;
          v21[4] = 0;
          v21[5] = v17;
          v21[6] = 0;
          *v21 = v17;
          v21[1] = v17;
        }
      }
      if (*(float *)(*(_QWORD *)(v1 + 48) + v9) >= 0.5)
        ++v7;
      ++v6;
      v9 += 100;
    }
    while (v6 != 3);
  }
  return this;
}

void DspLib::MeisterStueck::Algorithm::setCompressorKernelParameters(DspLib::MeisterStueck::Algorithm *this)
{
  DspLib *active;
  uint8x8_t v3;
  uint64_t v4;
  unsigned int v5;
  float v6;
  float *v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  uint8x8_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  DspLib::MeisterStueck::Kernel::Algorithm *v16;
  uint64_t v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  float v22;
  char v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float v28[4];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 300))
  {
    DspLib::clear(v28, 4uLL);
    if (*(float *)(*((_QWORD *)this + 6) + 484) >= 0.5)
    {
      v4 = 0;
      v5 = 0;
      v6 = 0.0;
      v7 = v28;
      v8 = 88;
      v9 = 0.0;
      do
      {
        v3.i32[0] = *(_DWORD *)(*((_QWORD *)this + 6) + v8);
        if (*(float *)v3.i32 >= 0.5)
        {
          v10 = 20000.0;
          v11 = 20000.0;
          if (v4 != 24)
          {
            v10 = 20000.0;
            if (v5 < DspLib::FourBandRandomOrderLrFilterBank::FilterBank::numActiveBands((DspLib::MeisterStueck::Algorithm *)((char *)this + 432), v3)- 1)v10 = *(float *)((char *)&DspLib::MeisterStueck::Parameters::kDefault + v4 + 404);
            active = (DspLib *)DspLib::FourBandRandomOrderLrFilterBank::FilterBank::numActiveBands((DspLib::MeisterStueck::Algorithm *)((char *)this + 432), v12);
            if (v5 >= (int)active - 1)
              v11 = 20000.0;
            else
              v11 = *(float *)(*((_QWORD *)this + 6) + v4 + 404);
          }
          *v7 = DspLib::amp2dBSafe(active, (float)(v10 - v6) / (float)(v11 - v9), 0.000001);
          ++v5;
          v6 = v10;
          v9 = v11;
        }
        v4 += 8;
        ++v7;
        v8 += 100;
      }
      while (v4 != 32);
    }
    v13 = 0;
    v14 = -400;
    do
    {
      v15 = (char *)this + 8 * v13;
      v16 = (DspLib::MeisterStueck::Kernel::Algorithm *)*((_QWORD *)v15 + 200);
      if (*(float *)(*((_QWORD *)this + 6) + v14 + 488) >= 0.5)
      {
        if (!v16)
        {
          v16 = (DspLib::MeisterStueck::Kernel::Algorithm *)operator new();
          DspLib::MeisterStueck::Kernel::Algorithm::Algorithm(v16);
          v17 = *((_QWORD *)v15 + 200);
          *((_QWORD *)v15 + 200) = v16;
          if (v17)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
            v16 = (DspLib::MeisterStueck::Kernel::Algorithm *)*((_QWORD *)v15 + 200);
          }
        }
        v18 = *((double *)this + 3);
        (*(void (**)(DspLib::MeisterStueck::Kernel::Algorithm *, _QWORD, double))(*(_QWORD *)v16 + 16))(v16, *((unsigned int *)this + 3), roundf(v18 / (float)*((unsigned int *)this + v13 + 71)));
        v19 = *((_QWORD *)this + 6);
        v20 = v19 + v14;
        *(_DWORD *)(v20 + 464) = *(_DWORD *)(v19 + 476);
        *(float *)(v20 + 476) = v28[v13];
        v21 = 0;
        if (vcvtas_u32_f32(*(float *)(v19 + 536)) <= 1)
          v22 = 0.0;
        else
          v22 = 20.0;
        *(float *)(v20 + 432) = v22;
        if (*(float *)(v19 + 524) >= 0.5)
          v21 = *(_DWORD *)(v19 + 464);
        *(_DWORD *)(v20 + 408) = v21;
        v23 = *((_BYTE *)this + 264);
        if (v23)
          v24 = 1.0;
        else
          v24 = 0.0;
        *(float *)(v20 + 496) = v24;
        DspLib::MeisterStueck::Kernel::allocate((DspLib::MeisterStueck::Algorithm *)((char *)this + 1632), (DspLib::MeisterStueck::Kernel::ScratchArea *)*((unsigned int *)this + 3), *((unsigned int *)this + 8), v23);
        v25 = *((_QWORD *)v15 + 200);
        v26 = (*(uint64_t (**)(DspLib::MeisterStueck::Algorithm *))(*(_QWORD *)this + 136))(this);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v25 + 144))(v25, v14 + v26 + 400, 25);
        if (*(float *)(*((_QWORD *)this + 6) + 472) >= 0.5)
          (*(void (**)(_QWORD, _QWORD, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 0, 1.0);
        if (!*((_BYTE *)this + 264))
        {
          if ((_DWORD)v13 == 2)
          {
            (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 16, 4.0);
            (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 7, 2.0);
          }
          else if ((_DWORD)v13 == 1)
          {
            (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 16, 2.0);
            (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 7, 8.0);
          }
          else if ((_DWORD)v13)
          {
            (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 16, 4.0);
            (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 7, 1.0);
          }
          else
          {
            (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 16, 1.0);
            (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 7, 10.0);
          }
          (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)v15 + 200) + 128))(*((_QWORD *)v15 + 200), 5, 0.0);
        }
        (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v15 + 200) + 200))(*((_QWORD *)v15 + 200), *((unsigned __int8 *)this + 40));
      }
      else
      {
        *((_QWORD *)v15 + 200) = 0;
        if (v16)
          (*(void (**)(DspLib::MeisterStueck::Kernel::Algorithm *))(*(_QWORD *)v16 + 8))(v16);
      }
      ++v13;
      v14 += 100;
    }
    while (v14);
    if (*((_BYTE *)this + 264))
    {
      v27 = *((_QWORD *)this + 203);
      if (v27)
        (*(void (**)(uint64_t, uint64_t, float))(*(_QWORD *)v27 + 128))(v27, 5, 0.0);
    }
  }
}

void sub_1B60EB05C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10E1C40DE58F3FBLL);
  _Unwind_Resume(a1);
}

void DspLib::MeisterStueck::Algorithm::setOSCFilterParameters(DspLib::MeisterStueck::Algorithm *this, uint8x8_t a2)
{
  int active;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  uint64_t i;
  float v8;
  int v9;
  BOOL v10[4];
  int v11;
  double v12;
  uint64_t v13;
  int v14;
  _QWORD v15[2];
  _QWORD v16[3];

  v16[2] = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 300))
  {
    v16[0] = 0;
    v16[1] = 0;
    v15[0] = 0;
    v15[1] = 0;
    active = DspLib::MeisterStueck::Algorithm::activeCrossOverFrequencies((uint64_t)this, (uint64_t)v16, a2, 4, (uint64_t)v15, 4uLL);
    v4 = 0;
    v5 = 0;
    v12 = 0.0;
    v13 = 0;
    v14 = 0;
    v10[0] = *(float *)(*((_QWORD *)this + 6) + 532) >= 0.5;
    v11 = *((_DWORD *)this + 3);
    v6 = (char *)this + 1600;
    for (i = 88; *(float *)(*((_QWORD *)this + 6) + i) < 0.5; i += 100)
    {
LABEL_11:
      if (++v4 == 4)
        return;
    }
    v8 = *((double *)this + 3);
    v12 = (float)(v8 / (float)*(unsigned int *)&v6[4 * v4 - 1316]);
    v14 = *((_DWORD *)v15 + v5);
    if (v5)
    {
      if (v5 == active)
      {
        LODWORD(v13) = *((_DWORD *)v16 + (active - 1));
        v9 = 0;
LABEL_10:
        HIDWORD(v13) = v9;
        DspLib::MeisterStueck::OSCFilter::setParameters((DspLib::Biquad::ParametricFilter *)(*(_QWORD *)&v6[8 * v4] + 520), (uint64_t)v10);
        ++v5;
        goto LABEL_11;
      }
      LODWORD(v13) = *((_DWORD *)v16 + v5 - 1);
    }
    else
    {
      LODWORD(v13) = 0;
    }
    v9 = *((_DWORD *)v16 + v5);
    goto LABEL_10;
  }
}

void DspLib::MeisterStueck::Algorithm::status(uint64_t a1, float *a2, vDSP_Length __N)
{
  float v5;
  uint64_t v6;
  float *v7;
  uint64_t v8;
  char *v9;

  if (*(_BYTE *)(a1 + 8))
  {
    DspLib::clear(a2, __N);
    v5 = *(double *)(a1 + 24);
    a2[1] = (float)*(unsigned int *)(a1 + 12);
    a2[2] = v5;
    if (!*(_BYTE *)(a1 + 300))
    {
      v6 = 0;
      v7 = a2 + 67;
      do
      {
        v8 = *(_QWORD *)(a1 + 1600 + v6);
        if (v8)
          (*(void (**)(uint64_t, float *, uint64_t))(*(_QWORD *)v8 + 184))(v8, v7, 7);
        v6 += 8;
        v7 += 7;
      }
      while (v6 != 32);
    }
    if (*(_BYTE *)(a1 + 40))
    {
      (*(void (**)(_QWORD, float *, uint64_t))(**(_QWORD **)(a1 + 1752) + 184))(*(_QWORD *)(a1 + 1752), a2 + 3, 32);
      (*(void (**)(_QWORD, float *, uint64_t))(**(_QWORD **)(a1 + 1760) + 184))(*(_QWORD *)(a1 + 1760), a2 + 35, 32);
    }
    else
    {
      DspLib::fill(a2 + 3, 0x20uLL, -100.0);
      DspLib::fill(a2 + 35, 0x20uLL, -100.0);
    }
  }
  else
  {
    v9 = basename("/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/DspLib/MeisterStueck/dsp/DspLibMeisterStueck.cpp");
    printf("DSP Sound assertion in %s at line %d\n", v9, 171);
    ++DspLibDebug::mAssertCounter;
  }
}

void DspLib::MeisterStueck::Algorithm::processBlock(DspLib::MeisterStueck::Algorithm *this, DspLibBuffer *a2, DspLibBuffer *a3)
{
  unint64_t cycle_count;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  size_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int8x16_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  char *v20;
  _QWORD v22[3];
  uint64_t v23[4];

  v23[3] = *MEMORY[0x1E0C80C00];
  cycle_count = vp::utility::CPU_Profiler::get_cycle_count(a2);
  if (*((_BYTE *)this + 8))
  {
    v7 = cycle_count;
    DspLibBuffer::setNumFrames(a3, cycle_count);
    if (vp::utility::CPU_Profiler::get_cycle_count(a3))
    {
      v8 = DspLibBuffer::numChannels(a3);
      MEMORY[0x1E0C80A78](v8);
      v11 = (char *)&v22[-1] - v10;
      if (v9 >= 0x200)
        v12 = 512;
      else
        v12 = v9;
      bzero((char *)&v22[-1] - v10, v12);
      if (DspLibBuffer::numChannels(a3))
      {
        v13 = 0;
        do
        {
          *(_QWORD *)&v11[8 * v13] = DspLibBuffer::channel(a3, v13);
          ++v13;
        }
        while (v13 < DspLibBuffer::numChannels(a3));
      }
      v14 = DspLibBuffer::numChannels(a3);
      v15 = vp::utility::CPU_Profiler::get_cycle_count(a3);
      if (a2 != a3)
        DspLibBuffer::operator=((uint64_t)a3, a2);
      if (*((_BYTE *)this + 272))
      {
        v23[0] = (uint64_t)v11;
        v23[1] = v14;
        v23[2] = v15;
        DspLib::multiply(v23, *((float *)this + 67));
      }
      if (*((_BYTE *)this + 40))
      {
        (*(void (**)(_QWORD, DspLibBuffer *))(**((_QWORD **)this + 219) + 168))(*((_QWORD *)this + 219), a3);
        v16 = DspLib::CPUMeasure::start((int8x16_t *)((char *)this + 72));
      }
      v17 = *((_QWORD *)this + 38);
      v18 = *((_QWORD *)this + 39);
      if (v18 & 1 | v17)
      {
        v19 = (_QWORD *)((char *)this + (v18 >> 1));
        if ((v18 & 1) != 0)
          v17 = *(_QWORD *)(*v19 + v17);
        v22[0] = v11;
        v22[1] = v14;
        v22[2] = v15;
        ((void (*)(_QWORD *, _QWORD *, __n128))v17)(v19, v22, (__n128)v16);
      }
      if (*((_BYTE *)this + 40))
      {
        DspLib::CPUMeasure::stop((DspLib::MeisterStueck::Algorithm *)((char *)this + 72), v7, *((double *)this + 3));
        (*(void (**)(_QWORD, DspLibBuffer *))(**((_QWORD **)this + 220) + 168))(*((_QWORD *)this + 220), a3);
      }
    }
  }
  else
  {
    v20 = basename("/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/DspLib/MeisterStueck/dsp/DspLibMeisterStueck.cpp");
    printf("DSP Sound assertion in %s at line %d\n", v20, 203);
    ++DspLibDebug::mAssertCounter;
  }
}

uint64_t DspLib::MeisterStueck::Algorithm::processAnalyticalPhaseCompensator(_QWORD *a1, _QWORD *a2)
{
  const void *v4;
  uint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  const void *v29;
  uint64_t v30[3];
  __int128 v31;
  const void *v32;
  uint64_t v33[3];
  const void *v34[3];
  _QWORD v35[3];
  _QWORD v36[4];

  v36[3] = *MEMORY[0x1E0C80C00];
  v4 = (const void *)a2[2];
  v5 = (uint64_t *)a1[27];
  v6 = (_QWORD *)a1[28];
  v7 = 0xAAAAAAAAAAAAAAABLL * (v6 - v5);
  MEMORY[0x1E0C80A78](a1);
  v10 = (char *)&v26 - v9;
  if (v8 >= 0x200)
    v11 = 512;
  else
    v11 = v8;
  bzero((char *)&v26 - v9, v11);
  if (v6 != v5)
  {
    v13 = 0;
    do
    {
      v14 = *v5;
      v5 += 3;
      *(_QWORD *)&v10[8 * v13++] = v14;
    }
    while (v7 > v13);
  }
  v15 = (uint64_t *)a1[30];
  v16 = (_QWORD *)a1[31];
  v17 = 0xAAAAAAAAAAAAAAABLL * (v16 - v15);
  MEMORY[0x1E0C80A78](v12);
  v20 = (char *)&v26 - v19;
  if (v18 >= 0x200)
    v21 = 512;
  else
    v21 = v18;
  bzero((char *)&v26 - v19, v21);
  if (v16 != v15)
  {
    v22 = 0;
    do
    {
      v23 = *v15;
      v15 += 3;
      *(_QWORD *)&v20[8 * v22++] = v23;
    }
    while (v17 > v22);
  }
  v24 = a2[1];
  v36[0] = *a2;
  v36[1] = v24;
  v36[2] = v4;
  v35[0] = v10;
  v35[1] = v7;
  v35[2] = v4;
  v34[0] = v20;
  v34[1] = (const void *)v17;
  v34[2] = v4;
  DspLib::AnalyticSignalTransformAllpass::process((uint64_t)(a1 + 40), (uint64_t)v36, (uint64_t)v35, v34);
  v33[0] = (uint64_t)v10;
  v33[1] = v7;
  v33[2] = (uint64_t)v4;
  *(_QWORD *)&v31 = v20;
  *((_QWORD *)&v31 + 1) = v17;
  v32 = v4;
  DspLib::add(v33, &v31);
  v30[0] = (uint64_t)v10;
  v30[1] = v7;
  v30[2] = (uint64_t)v4;
  DspLib::multiply(v30, 0.70711);
  *(_QWORD *)&v28 = v10;
  *((_QWORD *)&v28 + 1) = v7;
  v29 = v4;
  v26 = *(_OWORD *)a2;
  v27 = a2[2];
  return DspLib::FourBandRandomOrderLrFilterBank::FilterBank::processBlock((uint64_t)(a1 + 54), &v28, &v26);
}

void DspLib::MeisterStueck::Algorithm::processAnalyticalSignal(uint64_t a1, _QWORD *a2)
{
  const void *v4;
  uint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  _QWORD v29[3];
  _QWORD v30[3];
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  const void *v34;
  uint64_t v35[3];
  __int128 v36;
  const void *v37;
  uint64_t v38[3];
  const void *v39[3];
  _QWORD v40[3];
  _QWORD v41[5];

  v41[3] = *MEMORY[0x1E0C80C00];
  v4 = (const void *)a2[2];
  v5 = *(uint64_t **)(a1 + 216);
  v6 = *(_QWORD **)(a1 + 224);
  v7 = 0xAAAAAAAAAAAAAAABLL * (v6 - v5);
  MEMORY[0x1E0C80A78](a1);
  v10 = (char *)&v25 - v9;
  if (v8 >= 0x200)
    v11 = 512;
  else
    v11 = v8;
  bzero((char *)&v25 - v9, v11);
  if (v6 != v5)
  {
    v13 = 0;
    do
    {
      v14 = *v5;
      v5 += 3;
      *(_QWORD *)&v10[8 * v13++] = v14;
    }
    while (v7 > v13);
  }
  v15 = *(uint64_t **)(a1 + 240);
  v16 = *(_QWORD **)(a1 + 248);
  v17 = 0xAAAAAAAAAAAAAAABLL * (v16 - v15);
  MEMORY[0x1E0C80A78](v12);
  v20 = (char *)&v25 - v19;
  if (v18 >= 0x200)
    v21 = 512;
  else
    v21 = v18;
  bzero((char *)&v25 - v19, v21);
  if (v16 != v15)
  {
    v22 = 0;
    do
    {
      v23 = *v15;
      v15 += 3;
      *(_QWORD *)&v20[8 * v22++] = v23;
    }
    while (v17 > v22);
  }
  v24 = a2[1];
  v41[0] = *a2;
  v41[1] = v24;
  v41[2] = v4;
  v40[0] = v10;
  v40[1] = v7;
  v40[2] = v4;
  v39[0] = v20;
  v39[1] = (const void *)v17;
  v39[2] = v4;
  DspLib::AnalyticSignalTransformAllpass::process(a1 + 320, (uint64_t)v41, (uint64_t)v40, v39);
  if (*(_BYTE *)(a1 + 300))
  {
    v38[0] = (uint64_t)v10;
    v38[1] = v7;
    v38[2] = (uint64_t)v4;
    *(_QWORD *)&v36 = v20;
    *((_QWORD *)&v36 + 1) = v17;
    v37 = v4;
    DspLib::add(v38, &v36);
    v35[0] = (uint64_t)v10;
    v35[1] = v7;
    v35[2] = (uint64_t)v4;
    DspLib::multiply(v35, 0.70711);
    *(_QWORD *)&v33 = v10;
    *((_QWORD *)&v33 + 1) = v7;
    v34 = v4;
    v31 = *(_OWORD *)a2;
    v32 = a2[2];
    DspLib::FourBandRandomOrderLrFilterBank::FilterBank::processBlock(a1 + 432, &v33, &v31);
  }
  else
  {
    v30[0] = v10;
    v30[1] = v7;
    v30[2] = v4;
    DspLib::FourBandRandomOrderLrFilterBank::FilterBank::analyze(a1 + 432, v30);
    v29[0] = v20;
    v29[1] = v17;
    v29[2] = v4;
    DspLib::FourBandRandomOrderLrFilterBank::FilterBank::analyze(a1 + 1016, v29);
    DspLib::MeisterStueck::Algorithm::processAnalyticalCompressorKernels((uint64_t **)a1, (DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)(a1 + 432), (DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)(a1 + 1016), (uint64_t)v4);
    v27 = *(_OWORD *)a2;
    v28 = a2[2];
    DspLib::FourBandRandomOrderLrFilterBank::FilterBank::synthesize(a1 + 432, &v27);
    if (*(_BYTE *)(a1 + 280))
    {
      v25 = *(_OWORD *)a2;
      v26 = a2[2];
      DspLib::multiply((uint64_t *)&v25, *(float *)(a1 + 276));
    }
  }
}

void DspLib::MeisterStueck::Algorithm::processAnalyticalCompressorKernels(uint64_t **this, DspLib::FourBandRandomOrderLrFilterBank::FilterBank *a2, DspLib::FourBandRandomOrderLrFilterBank::FilterBank *a3, uint64_t a4)
{
  DspLib::MeisterStueck::Algorithm *v5;
  uint64_t *v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  DspLib::MeisterStueck::Algorithm *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  uint64_t v40;
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank *v41;
  __int128 v42;
  char *v43;
  unint64_t v44;
  char *v45;
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank *v46;
  uint64_t v47;
  unint64_t v48;
  __int128 v49;
  uint64_t v50;
  __int128 v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  _QWORD v55[3];
  _QWORD v56[3];
  uint64_t v57[3];
  __int128 v58;
  uint64_t v59;
  __int128 v60;
  uint64_t v61;
  __int128 v62;
  uint64_t v63;
  __int128 v64;
  uint64_t v65;
  _QWORD v66[2];
  uint64_t v67;
  _QWORD v68[3];
  _QWORD v69[5];

  v46 = a2;
  v47 = a4;
  v5 = (DspLib::MeisterStueck::Algorithm *)this;
  v69[3] = *MEMORY[0x1E0C80C00];
  v7 = this[27];
  v6 = this[28];
  v8 = 0xAAAAAAAAAAAAAAABLL * (v6 - v7);
  MEMORY[0x1E0C80A78](this);
  v11 = (char *)&v41 - v10;
  if (v9 >= 0x200)
    v12 = 512;
  else
    v12 = v9;
  bzero((char *)&v41 - v10, v12);
  if (v6 != v7)
  {
    v14 = 0;
    do
    {
      v15 = *v7;
      v7 += 3;
      *(_QWORD *)&v11[8 * v14++] = v15;
    }
    while (v8 > v14);
  }
  v43 = v11;
  v44 = v8;
  v17 = (uint64_t *)*((_QWORD *)v5 + 30);
  v16 = (_QWORD *)*((_QWORD *)v5 + 31);
  v18 = 0xAAAAAAAAAAAAAAABLL * (v16 - v17);
  MEMORY[0x1E0C80A78](v13);
  v21 = (char *)&v41 - v20;
  if (v19 >= 0x200)
    v22 = 512;
  else
    v22 = v19;
  bzero((char *)&v41 - v20, v22);
  if (v16 != v17)
  {
    v23 = 0;
    do
    {
      v24 = *v17;
      v17 += 3;
      *(_QWORD *)&v21[8 * v23++] = v24;
    }
    while (v18 > v23);
  }
  *(_QWORD *)&v42 = v21;
  *((_QWORD *)&v42 + 1) = v18;
  v25 = 0;
  v26 = (_QWORD *)((char *)v5 + 1728);
  v45 = (char *)v5 + 1632;
  v27 = 88;
  v41 = a3;
  do
  {
    if (*(float *)(*((_QWORD *)v5 + 6) + v27) >= 0.5)
    {
      v48 = DspLib::FourBandRandomOrderLrFilterBank::FilterBank::buffer(v46, v25);
      v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)v5 + 28) - *((_QWORD *)v5 + 27)) >> 3);
      v29 = DspLib::FourBandRandomOrderLrFilterBank::FilterBank::buffer(a3, v25);
      v30 = v5;
      v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)v5 + 31) - *((_QWORD *)v5 + 30)) >> 3);
      if (v25 <= 2 && (v32 = *v26) != 0)
      {
        v66[0] = v43;
        v66[1] = v44;
        v33 = v47;
        v67 = v47;
        v64 = v42;
        v65 = v47;
        v69[0] = v48;
        v69[1] = v28;
        v69[2] = v47;
        DspLib::DownSampler::process((unsigned int *)(v32 + 4), v69, v66);
        v34 = (unsigned int *)(v32 + 12);
        v68[0] = v29;
        v68[1] = v31;
        v68[2] = v33;
        v36 = (uint64_t)v43;
        v35 = v44;
        DspLib::DownSampler::process(v34, v68, &v64);
        v37 = v67;
        v5 = v30;
        if (v67)
        {
          v38 = *(v26 - 16);
          *(_QWORD *)&v62 = v36;
          *((_QWORD *)&v62 + 1) = v35;
          v63 = v67;
          v60 = v42;
          v61 = v67;
          *(_QWORD *)&v58 = v36;
          *((_QWORD *)&v58 + 1) = v35;
          v59 = v67;
          DspLib::MeisterStueck::Kernel::Algorithm::processBlock(v38, &v62, &v60, &v58);
          v57[0] = v36;
          v57[1] = v35;
          v57[2] = v37;
          DspLib::multiply(v57, (float)*((unsigned int *)v30 + v25 + 71));
        }
        v39 = (unsigned int *)(*v26 + 20);
        v56[0] = v36;
        v56[1] = v35;
        v56[2] = v37;
        v55[0] = v48;
        v55[1] = v28;
        v55[2] = v47;
        DspLib::UpSampler::process(v39, v56, v55);
        a3 = v41;
      }
      else
      {
        v40 = *(v26 - 16);
        *(_QWORD *)&v53 = v48;
        *((_QWORD *)&v53 + 1) = v28;
        v54 = v47;
        *(_QWORD *)&v51 = v29;
        *((_QWORD *)&v51 + 1) = v31;
        v52 = v47;
        *(_QWORD *)&v49 = v48;
        *((_QWORD *)&v49 + 1) = v28;
        v50 = v47;
        DspLib::MeisterStueck::Kernel::Algorithm::processBlock(v40, &v53, &v51, &v49);
        v5 = v30;
      }
    }
    ++v25;
    v27 += 100;
    ++v26;
  }
  while (v27 != 488);
}

uint64_t DspLib::MeisterStueck::Algorithm::processRegularPhaseCompensator(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = *a2;
  v4 = *((_QWORD *)a2 + 2);
  return DspLib::FourBandRandomOrderLrFilterBank::FilterBank::processBlock(a1 + 432, (uint64_t *)&v3);
}

void DspLib::MeisterStueck::Algorithm::processRegularSignal(uint64_t a1, uint64_t *a2)
{
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank *v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;

  v4 = (DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)(a1 + 432);
  v9 = *a2;
  v10 = *(_OWORD *)(a2 + 1);
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::analyze(a1 + 432, &v9);
  DspLib::MeisterStueck::Algorithm::processRegularCompressorKernels((DspLib::MeisterStueck::Algorithm *)a1, v4, a2[2]);
  v7 = *(_OWORD *)a2;
  v8 = a2[2];
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::synthesize((uint64_t)v4, &v7);
  if (*(_BYTE *)(a1 + 280))
  {
    v5 = *(_OWORD *)a2;
    v6 = a2[2];
    DspLib::multiply((uint64_t *)&v5, *(float *)(a1 + 276));
  }
}

void DspLib::MeisterStueck::Algorithm::processRegularCompressorKernels(DspLib::MeisterStueck::Algorithm *this, DspLib::FourBandRandomOrderLrFilterBank::FilterBank *a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank *v25;
  _QWORD v26[3];
  _QWORD v27[3];
  _QWORD v28[3];
  _QWORD v29[3];
  uint64_t v30[3];
  _QWORD v31[3];
  _QWORD v32[3];
  _QWORD v33[2];
  uint64_t v34;
  _QWORD v35[5];

  v25 = a2;
  v35[3] = *MEMORY[0x1E0C80C00];
  v6 = (uint64_t *)*((_QWORD *)this + 27);
  v5 = (_QWORD *)*((_QWORD *)this + 28);
  v7 = 0xAAAAAAAAAAAAAAABLL * (v5 - v6);
  MEMORY[0x1E0C80A78](this);
  v10 = (char *)&v26[-1] - v9;
  if (v8 >= 0x200)
    v11 = 512;
  else
    v11 = v8;
  bzero((char *)&v26[-1] - v9, v11);
  if (v5 != v6)
  {
    v12 = 0;
    do
    {
      v13 = *v6;
      v6 += 3;
      *(_QWORD *)&v10[8 * v12++] = v13;
    }
    while (v7 > v12);
  }
  v14 = 0;
  v15 = (_QWORD *)((char *)this + 1728);
  v16 = 88;
  v17 = v25;
  do
  {
    if (*(float *)(*((_QWORD *)this + 6) + v16) >= 0.5)
    {
      v18 = DspLib::FourBandRandomOrderLrFilterBank::FilterBank::buffer(v17, v14);
      v19 = v18;
      if (v14 <= 2 && (v20 = *v15) != 0)
      {
        v33[0] = v10;
        v33[1] = v7;
        v34 = a3;
        v35[0] = v18;
        v35[1] = v7;
        v35[2] = a3;
        DspLib::DownSampler::process((unsigned int *)(v20 + 4), v35, v33);
        v21 = v34;
        if (v34)
        {
          v22 = *(v15 - 16);
          v32[0] = v10;
          v32[1] = v7;
          v32[2] = v34;
          v31[0] = v10;
          v31[1] = v7;
          v31[2] = v34;
          DspLib::MeisterStueck::Kernel::Algorithm::processBlock(v22, v32, v31);
          v30[0] = (uint64_t)v10;
          v30[1] = v7;
          v30[2] = v21;
          DspLib::multiply(v30, (float)*((unsigned int *)this + v14 + 71));
        }
        v23 = (unsigned int *)(*v15 + 20);
        v29[0] = v10;
        v29[1] = v7;
        v29[2] = v21;
        v28[0] = v19;
        v28[1] = v7;
        v28[2] = a3;
        DspLib::UpSampler::process(v23, v29, v28);
        v17 = v25;
      }
      else
      {
        v24 = *(v15 - 16);
        v27[0] = v19;
        v27[1] = v7;
        v27[2] = a3;
        v26[0] = v19;
        v26[1] = v7;
        v26[2] = a3;
        DspLib::MeisterStueck::Kernel::Algorithm::processBlock(v24, v27, v26);
      }
    }
    ++v14;
    v16 += 100;
    ++v15;
  }
  while (v16 != 488);
}

uint64_t DspLib::MeisterStueck::Algorithm::activeCrossOverFrequencies(uint64_t a1, uint64_t a2, uint8x8_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;

  v10 = (DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)(a1 + 432);
  if (DspLib::FourBandRandomOrderLrFilterBank::FilterBank::numActiveBands((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)(a1 + 432), a3) < 2)return 0;
  if (a6)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    do
    {
      if (*(float *)(*(_QWORD *)(a1 + 48) + 4 * (25 * v11 + 22)) >= 0.5)
      {
        *(float *)(a2 + 4 * v13) = DspLib::FourBandRandomOrderLrFilterBank::FilterBank::xOverFrequency(v10, v12);
        *(_DWORD *)(a5 + 4 * v13++) = DspLib::FourBandRandomOrderLrFilterBank::FilterBank::xOverOrder(v10, v12);
      }
      v11 = ++v12;
    }
    while (a6 > v12);
  }
  else
  {
    v13 = 0;
  }
  return v13 - 1;
}

void DspLib::MeisterStueck::Kernel::allocate(DspLib::MeisterStueck::Kernel *this, DspLib::MeisterStueck::Kernel::ScratchArea *a2, unint64_t a3, char a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;

  std::vector<std::vector<float>>::resize((uint64_t *)this, (unint64_t)a2);
  v8 = *(_QWORD *)this;
  v9 = *((_QWORD *)this + 1);
  while (v8 != v9)
  {
    std::vector<float>::resize(v8, a3);
    v8 += 24;
  }
  std::vector<void const*>::resize((uint64_t)this + 24, (unint64_t)a2);
  if (a2)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v10++) = *(_QWORD *)(*(_QWORD *)this + v11);
      v11 += 24;
    }
    while ((unint64_t)a2 > v10);
  }
  v12 = (_QWORD *)((char *)this + 48);
  if ((a4 & 1) != 0)
  {
    std::vector<std::vector<float>>::resize((uint64_t *)this + 6, (unint64_t)a2);
    v13 = *((_QWORD *)this + 6);
    v14 = *((_QWORD *)this + 7);
    while (v13 != v14)
    {
      std::vector<float>::resize(v13, a3);
      v13 += 24;
    }
    v15 = (_QWORD *)((char *)this + 72);
    std::vector<void const*>::resize((uint64_t)v15, (unint64_t)a2);
    if (a2)
    {
      v16 = 0;
      v17 = 0;
      do
      {
        *(_QWORD *)(*v15 + 8 * v16++) = *(_QWORD *)(*v12 + v17);
        v17 += 24;
      }
      while ((unint64_t)a2 > v16);
    }
  }
  else
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 6);
    *((_QWORD *)this + 10) = *((_QWORD *)this + 9);
  }
}

void DspLib::MeisterStueck::Algorithm::~Algorithm(DspLib::MeisterStueck::Algorithm *this)
{
  DspLib::MeisterStueck::Algorithm::~Algorithm(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  void *v6;
  void *v7;
  uint64_t j;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  void **v13;

  *(_QWORD *)this = &off_1E69C4B58;
  v2 = *((_QWORD *)this + 220);
  *((_QWORD *)this + 220) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 219);
  *((_QWORD *)this + 219) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  for (i = 1744; i != 1720; i -= 8)
  {
    v5 = *(_QWORD *)((char *)this + i);
    *(_QWORD *)((char *)this + i) = 0;
    if (v5)
      MEMORY[0x1BCC95CEC](v5, 0x1000C4027586B93);
  }
  v6 = (void *)*((_QWORD *)this + 213);
  if (v6)
  {
    *((_QWORD *)this + 214) = v6;
    operator delete(v6);
  }
  v13 = (void **)((char *)this + 1680);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v13);
  v7 = (void *)*((_QWORD *)this + 207);
  if (v7)
  {
    *((_QWORD *)this + 208) = v7;
    operator delete(v7);
  }
  v13 = (void **)((char *)this + 1632);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v13);
  for (j = 1624; j != 1592; j -= 8)
  {
    v9 = *(_QWORD *)((char *)this + j);
    *(_QWORD *)((char *)this + j) = 0;
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  }
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::~FilterBank((DspLib::MeisterStueck::Algorithm *)((char *)this + 1016));
  DspLib::FourBandRandomOrderLrFilterBank::FilterBank::~FilterBank((DspLib::MeisterStueck::Algorithm *)((char *)this + 432));
  *((_QWORD *)this + 40) = &off_1E69C4400;
  v10 = (void *)*((_QWORD *)this + 51);
  if (v10)
  {
    *((_QWORD *)this + 52) = v10;
    operator delete(v10);
  }
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::MeisterStueck::Algorithm *)((char *)this + 384));
  v11 = (void *)*((_QWORD *)this + 45);
  if (v11)
  {
    *((_QWORD *)this + 46) = v11;
    operator delete(v11);
  }
  v13 = (void **)((char *)this + 240);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v13);
  v13 = (void **)((char *)this + 216);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v13);
  *(_QWORD *)this = off_1E69C46F0;
  v12 = (void *)*((_QWORD *)this + 6);
  if (v12)
  {
    *((_QWORD *)this + 7) = v12;
    operator delete(v12);
  }
}

double DspLib::MeisterStueck::Algorithm::latencySamples(DspLib::MeisterStueck::Algorithm *this)
{
  return 0.0;
}

uint64_t DspLib::MeisterStueck::Algorithm::numStatus(DspLib::MeisterStueck::Algorithm *this)
{
  return 95;
}

void DspLib::FourBandRandomOrderLrFilterBank::FilterBank::~FilterBank(DspLib::FourBandRandomOrderLrFilterBank::FilterBank *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void **v8;

  v8 = (void **)((char *)this + 560);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v8);
  v8 = (void **)((char *)this + 536);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v8);
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)((char *)this + 512));
  v2 = (void *)*((_QWORD *)this + 61);
  if (v2)
  {
    *((_QWORD *)this + 62) = v2;
    operator delete(v2);
  }
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)((char *)this + 440));
  v3 = (void *)*((_QWORD *)this + 52);
  if (v3)
  {
    *((_QWORD *)this + 53) = v3;
    operator delete(v3);
  }
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)((char *)this + 368));
  v4 = (void *)*((_QWORD *)this + 43);
  if (v4)
  {
    *((_QWORD *)this + 44) = v4;
    operator delete(v4);
  }
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)((char *)this + 296));
  v5 = (void *)*((_QWORD *)this + 34);
  if (v5)
  {
    *((_QWORD *)this + 35) = v5;
    operator delete(v5);
  }
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::FourBandRandomOrderLrFilterBank::FilterBank *)((char *)this + 224));
  v6 = (void *)*((_QWORD *)this + 25);
  if (v6)
  {
    *((_QWORD *)this + 26) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 19);
  if (v7)
  {
    *((_QWORD *)this + 20) = v7;
    operator delete(v7);
  }
  v8 = (void **)((char *)this + 128);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v8);
}

_QWORD *DspLib::forAllParametersOf(_QWORD *result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  _QWORD **v5;
  _QWORD *v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD v9[3];
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  if (*((_DWORD *)result + 4) != -1)
  {
    v3 = (uint64_t)result;
    v4 = 0;
    while (1)
    {
      v5 = (_QWORD **)(v4 ? *(_QWORD *)(v3 + 8) + 8 * (v4 - 1) : v3);
      v6 = *v5;
      v9[0] = &off_1E69C4C68;
      v9[1] = a2;
      v9[2] = &v8;
      v10 = v9;
      DspLib::forAllParametersOf(v6, (uint64_t)v9);
      result = v10;
      if (v10 == v9)
        break;
      if (v10)
      {
        v7 = 5;
LABEL_10:
        result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
      }
      v4 = v8 + 1;
      v8 = v4;
      if (v4 >= *(_DWORD *)(v3 + 16) + 1)
        return result;
    }
    result = v9;
    v7 = 4;
    goto LABEL_10;
  }
  return result;
}

{
  _QWORD *v2;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD v9[3];
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  v2 = (_QWORD *)result[1];
  if (v2[1])
  {
    v4 = result;
    v5 = 0;
    while (1)
    {
      v6 = *v2 + 16 * v5;
      v9[0] = &off_1E69C4CF8;
      v9[1] = a2;
      v9[2] = &v8;
      v10 = v9;
      DspLib::forAllParametersOf(v6, (uint64_t)v9);
      result = v10;
      if (v10 == v9)
        break;
      if (v10)
      {
        v7 = 5;
LABEL_7:
        result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
      }
      v5 = ++v8;
      v2 = (_QWORD *)v4[1];
      if (v2[1] <= (unint64_t)v8)
        return result;
    }
    result = v9;
    v7 = 4;
    goto LABEL_7;
  }
  return result;
}

void sub_1B60EC620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1B60EC748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t DspLib::forAllParametersOf(uint64_t result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  __int128 v11;
  uint64_t v12;
  unsigned int v13;

  v2 = *(_QWORD **)(result + 8);
  if (v2[1])
  {
    v4 = result;
    v5 = 0;
    v6 = 1;
    do
    {
      v7 = *v2 + 24 * v5;
      v8 = *(_OWORD *)v7;
      v12 = *(_QWORD *)(v7 + 16);
      v11 = v8;
      v13 = v6 - 1;
      v9 = *(_QWORD *)(a2 + 24);
      if (!v9)
        std::__throw_bad_function_call[abi:ne180100]();
      result = (*(uint64_t (**)(uint64_t, unsigned int *, __int128 *))(*(_QWORD *)v9 + 48))(v9, &v13, &v11);
      v5 = v6;
      v2 = *(_QWORD **)(v4 + 8);
    }
    while (v2[1] > (unint64_t)v6++);
  }
  return result;
}

uint64_t *DspLib::AlgorithmParametersInstance::AlgorithmParametersInstance(uint64_t *a1, uint64_t a2)
{
  _QWORD *v3;
  unsigned int v4;
  unint64_t i;
  uint64_t v6;
  uint64_t v7;

  a1[1] = 0;
  v3 = a1 + 1;
  a1[2] = 0;
  a1[3] = 0;
  *a1 = a2;
  v4 = DspLib::groupOffset(a2, *(_DWORD *)(*(_QWORD *)(a2 + 8) + 8));
  std::vector<float>::resize((uint64_t)v3, v4);
  for (i = 0; i < DspLib::groupOffset(*a1, *(_DWORD *)(*(_QWORD *)(*a1 + 8) + 8)); ++i)
  {
    v6 = *a1;
    v7 = DspLib::parameterAddress(*a1, i);
    *(_DWORD *)(*v3 + 4 * i) = *(_DWORD *)(DspLib::AlgorithmParametersDefinition::operator[](v6, v7) + 12);
  }
  return a1;
}

void sub_1B60EC8C8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t DspLib::AlgorithmParametersInstance::group(DspLib::AlgorithmParametersInstance *this, unsigned int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  return v2 + 4 * DspLib::groupOffset(*(_QWORD *)this, a2);
}

uint64_t DspLib::AlgorithmParametersInstance::setValue(uint64_t *a1, uint64_t a2, float a3)
{
  uint64_t v5;

  v5 = DspLib::groupOffset(*a1, a2) + HIDWORD(a2);
  return DspLib::AlgorithmParametersInstance::setValue((DspLib::AlgorithmParametersInstance *)a1, v5, a3);
}

float DspLib::AlgorithmParametersInstance::operator[](uint64_t *a1, uint64_t a2)
{
  unsigned int v3;

  v3 = DspLib::groupOffset(*a1, a2) + HIDWORD(a2);
  return DspLib::AlgorithmParametersInstance::operator[](a1, v3);
}

float DspLib::AlgorithmParametersInstance::operator[](uint64_t *a1, unsigned int a2)
{
  if (DspLib::groupOffset(*a1, *(_DWORD *)(*(_QWORD *)(*a1 + 8) + 8)) < a2)
    abort();
  return *(float *)(a1[1] + 4 * a2);
}

uint64_t DspLib::AlgorithmParametersInstance::setValue(DspLib::AlgorithmParametersInstance *this, uint64_t a2, float a3)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  float v9;
  float v10;

  v4 = a2;
  v6 = *(_QWORD *)this;
  v7 = DspLib::parameterAddress(*(_QWORD *)this, a2);
  result = DspLib::AlgorithmParametersDefinition::operator[](v6, v7);
  v9 = *(float *)(result + 16);
  v10 = *(float *)(result + 20);
  if (v10 >= a3)
    v10 = a3;
  if (v9 <= a3)
    v9 = v10;
  *(float *)(*((_QWORD *)this + 1) + 4 * v4) = v9;
  return result;
}

void std::__function::__func<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69C4C68;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69C4C68;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>::operator()(uint64_t a1, uint64_t *a2, __int128 *a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  v3 = *a2;
  v4 = HIDWORD(*a2);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = **(unsigned int **)(a1 + 16);
  v9 = *a3;
  v10 = *((_QWORD *)a3 + 2);
  v11 = v6 | (v3 << 32);
  v12 = v4;
  v7 = *(_QWORD *)(v5 + 24);
  if (!v7)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, uint64_t *, __int128 *))(*(_QWORD *)v7 + 48))(v7, &v11, &v9);
}

uint64_t std::__function::__func<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::SystemParametersDefinition const&,std::function<void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>::target_type()
{
}

void std::__function::__func<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(unsigned int,DspLib::ParameterDefinition)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(unsigned int,DspLib::ParameterDefinition)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69C4CF8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(unsigned int,DspLib::ParameterDefinition)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69C4CF8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(unsigned int,DspLib::ParameterDefinition)>::operator()(uint64_t a1, unsigned int *a2, __int128 *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = **(unsigned int **)(a1 + 16);
  v8 = *a3;
  v9 = *((_QWORD *)a3 + 2);
  v10 = v5 | (v3 << 32);
  v6 = *(_QWORD *)(v4 + 24);
  if (!v6)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, uint64_t *, __int128 *))(*(_QWORD *)v6 + 48))(v6, &v10, &v8);
}

uint64_t std::__function::__func<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(unsigned int,DspLib::ParameterDefinition)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0,std::allocator<DspLib::forAllParametersOf(DspLib::AlgorithmParametersDefinition const&,std::function<void ()(DspLib::AlgorithmParameterAddress,DspLib::ParameterDefinition)>)::$_0>,void ()(unsigned int,DspLib::ParameterDefinition)>::target_type()
{
}

int DspLib::LoudspeakerModel::Parameters::mode(float *a1)
{
  int result;
  char *v2;

  result = vcvtas_u32_f32(fmaxf(*a1, 0.0));
  if (result >= 4)
  {
    v2 = basename("/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/DspLib/LoudspeakerModel/dsp/DspLibLoudspeakerModelParameters.cpp");
    printf("DSP Sound assertion in %s at line %d\n", v2, 21);
    result = 0;
    ++DspLibDebug::mAssertCounter;
  }
  return result;
}

void DspLib::LoudspeakerModel::Parameters::setBoundaries(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t i;
  int v9;
  float v10;
  int v11;
  float v12;

  for (i = 0; i != 39; ++i)
  {
    v9 = DspLib::LoudspeakerModel::Parameters::mode(a1);
    v10 = DspLib::LoudspeakerModel::Parameters::min(v9, i);
    v11 = DspLib::LoudspeakerModel::Parameters::mode(a1);
    v12 = DspLib::LoudspeakerModel::Parameters::max(v11, i);
    *(float *)(a3 + 4 * i) = v10;
    *(float *)(a5 + 4 * i) = v12;
  }
}

float DspLib::LoudspeakerModel::Parameters::min(int a1, unsigned int a2)
{
  float result;
  unsigned int v3;
  float *v4;

  if (a2 <= 4)
    return *((float *)&DspLib::LoudspeakerModel::Parameters::kMinimum + a2);
  switch(a1)
  {
    case 1:
      v3 = a2 - 5;
      v4 = (float *)&DspLib::LoudspeakerModel::Parameters::ThieleSmall::kMinimum;
      goto LABEL_8;
    case 2:
      v3 = a2 - 5;
      v4 = (float *)&DspLib::LoudspeakerModel::Parameters::Sdomain_0::kMinimum;
      goto LABEL_8;
    case 3:
      v3 = a2 - 5;
      v4 = (float *)&DspLib::LoudspeakerModel::Parameters::Sdomain_1::kMinimum;
LABEL_8:
      result = v4[v3];
      break;
    case 4:
      result = 0.0;
      break;
    default:
      result = -1.0e19;
      break;
  }
  return result;
}

float DspLib::LoudspeakerModel::Parameters::max(int a1, unsigned int a2)
{
  float result;
  unsigned int v3;
  float *v4;

  if (a2 <= 4)
    return *((float *)&DspLib::LoudspeakerModel::Parameters::kMaximum + a2);
  switch(a1)
  {
    case 1:
      v3 = a2 - 5;
      v4 = (float *)&DspLib::LoudspeakerModel::Parameters::ThieleSmall::kMaximum;
      goto LABEL_8;
    case 2:
      v3 = a2 - 5;
      v4 = (float *)&DspLib::LoudspeakerModel::Parameters::Sdomain_0::kMaximum;
      goto LABEL_8;
    case 3:
      v3 = a2 - 5;
      v4 = (float *)&DspLib::LoudspeakerModel::Parameters::Sdomain_1::kMaximum;
LABEL_8:
      result = v4[v3];
      break;
    case 4:
      result = 0.0;
      break;
    default:
      result = 1.0e19;
      break;
  }
  return result;
}

void DspLib::ConstantQFilterbank::Analyzer::setParameters(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, double a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD v30[5];

  v12 = *a1;
  v11 = a1[1];
  if (0x4EC4EC4EC4EC4EC5 * ((v11 - *a1) >> 3) == a3)
  {
    v12 = a1[1];
  }
  else
  {
    v13 = a3;
    while (v11 != v12)
    {
      v11 -= 104;
      std::__destroy_at[abi:ne180100]<DspLib::Biquad::ParametricFilter,0>(v11);
    }
    a1[1] = v12;
    if (v13)
    {
      v14 = 0;
      do
      {
        v15 = a1[1];
        v16 = a1[2];
        if (v15 >= v16)
        {
          v18 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v15 - *a1) >> 3);
          v19 = v18 + 1;
          if ((unint64_t)(v18 + 1) > 0x276276276276276)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          v20 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v16 - *a1) >> 3);
          if (2 * v20 > v19)
            v19 = 2 * v20;
          if (v20 >= 0x13B13B13B13B13BLL)
            v21 = 0x276276276276276;
          else
            v21 = v19;
          v30[4] = a1 + 2;
          if (v21)
            v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DspLib::Biquad::ParametricFilter>>((uint64_t)(a1 + 2), v21);
          else
            v22 = 0;
          v23 = &v22[104 * v18];
          v30[0] = v22;
          v30[1] = v23;
          v30[3] = &v22[104 * v21];
          *(_OWORD *)v23 = 0u;
          *((_OWORD *)v23 + 1) = 0u;
          *((_OWORD *)v23 + 2) = 0u;
          *((_OWORD *)v23 + 3) = 0u;
          *((_OWORD *)v23 + 4) = 0u;
          *((_OWORD *)v23 + 5) = 0u;
          *((_QWORD *)v23 + 12) = 0;
          v30[2] = v23 + 104;
          std::vector<DspLib::Biquad::ParametricFilter>::__swap_out_circular_buffer(a1, v30);
          v17 = a1[1];
          std::__split_buffer<DspLib::Biquad::ParametricFilter>::~__split_buffer((uint64_t)v30);
        }
        else
        {
          *(_QWORD *)(v15 + 96) = 0;
          *(_OWORD *)(v15 + 64) = 0u;
          *(_OWORD *)(v15 + 80) = 0u;
          *(_OWORD *)(v15 + 32) = 0u;
          *(_OWORD *)(v15 + 48) = 0u;
          *(_OWORD *)v15 = 0u;
          *(_OWORD *)(v15 + 16) = 0u;
          v17 = v15 + 104;
          a1[1] = v15 + 104;
        }
        a1[1] = v17;
        DspLib::Biquad::ParametricFilter::initialize((DspLib::Biquad::ParametricFilter *)(*a1 + v14), 1uLL, a6, 1uLL);
        v14 += 104;
        --v13;
      }
      while (v13);
      v12 = a1[1];
    }
  }
  v24 = *a1;
  if (v12 != *a1)
  {
    v25 = 0;
    v26 = 0;
    v27 = (double)vcvtad_u64_f64(a6);
    do
    {
      v28 = *(unsigned int *)(a4 + 4 * v26);
      v29 = *(unsigned int *)(a2 + 4 * v26);
      DspLib::Biquad::ParametricFilter::initialize((DspLib::Biquad::ParametricFilter *)(v24 + v25), 1uLL, v27, 1uLL);
      DspLib::Biquad::ParametricFilter::setParametricEQ(*a1 + v25, (v29 << 32) | 0xE, (double *)(((unint64_t)LODWORD(a5) << 32) | v28), 0, 0x41uLL);
      ++v26;
      v24 = *a1;
      v25 += 104;
    }
    while (v26 < 0x4EC4EC4EC4EC4EC5 * ((a1[1] - *a1) >> 3));
  }
}

void sub_1B60ED0C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<DspLib::Biquad::ParametricFilter>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void DspLib::ConstantQFilterbank::Modifier::initialize(DspLib::ConstantQFilterbank::Modifier *this, unsigned int a2, double a3)
{
  DspLib::Biquad::ParametricFilter *v6;
  int v7;
  DspLib::Biquad::ParametricFilter *v8;
  int v9;

  v7 = *((unsigned __int8 *)this + 8);
  v6 = (DspLib::ConstantQFilterbank::Modifier *)((char *)this + 8);
  if (!v7)
    DspLib::Biquad::ParametricFilter::initialize(v6, a2, a3, 1uLL);
  if (!*((_BYTE *)this + 216))
    DspLib::Biquad::ParametricFilter::initialize((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 216), a2, a3, 1uLL);
  if (!*((_BYTE *)this + 320))
    DspLib::Biquad::ParametricFilter::initialize((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 320), a2, a3, 1uLL);
  v9 = *((unsigned __int8 *)this + 112);
  v8 = (DspLib::ConstantQFilterbank::Modifier *)((char *)this + 112);
  if (!v9)
    DspLib::Biquad::ParametricFilter::initialize(v8, a2, a3, 1uLL);
}

void DspLib::ConstantQFilterbank::Modifier::setMaxFrameSize(DspLib::ConstantQFilterbank::Modifier *this, unint64_t a2)
{
  std::vector<float>::resize((uint64_t)this + 432, a2);
  std::vector<float>::resize((uint64_t)this + 456, a2);
}

void DspLib::ConstantQFilterbank::Modifier::setSampleRate(DspLib::ConstantQFilterbank::Modifier *this, double a2)
{
  vDSP_Length v2;
  double v4;

  v2 = *((_QWORD *)this + 7);
  if (!v2)
    abort();
  v4 = (double)vcvtad_u64_f64(a2);
  DspLib::Biquad::ParametricFilter::initialize((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 8), v2, v4, *((_QWORD *)this + 8));
  DspLib::Biquad::ParametricFilter::initialize((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 216), v2, v4, *((_QWORD *)this + 34));
  DspLib::Biquad::ParametricFilter::initialize((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 320), v2, v4, *((_QWORD *)this + 47));
}

void DspLib::ConstantQFilterbank::Modifier::uninitialize(DspLib::ConstantQFilterbank::Modifier *this)
{
  DspLib::Biquad::ParametricFilter::uninitialize((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 8));
  DspLib::Biquad::ParametricFilter::uninitialize((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 216));
  DspLib::Biquad::ParametricFilter::uninitialize((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 320));
  DspLib::Biquad::ParametricFilter::uninitialize((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 112));
  *((_QWORD *)this + 55) = *((_QWORD *)this + 54);
  *((_QWORD *)this + 58) = *((_QWORD *)this + 57);
  *((_QWORD *)this + 60) = 0;
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 66);
  *((_QWORD *)this + 70) = *((_QWORD *)this + 69);
}

void DspLib::ConstantQFilterbank::Modifier::reset(DspLib::ConstantQFilterbank::Modifier *this)
{
  DspLib::Biquad::SetupWrapper::reset((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 56));
  DspLib::Biquad::SetupWrapper::reset((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 264));
  DspLib::Biquad::SetupWrapper::reset((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 368));
  DspLib::Biquad::SetupWrapper::reset((DspLib::ConstantQFilterbank::Modifier *)((char *)this + 160));
  *((_BYTE *)this + 424) = 0;
}

void DspLib::ConstantQFilterbank::Modifier::setParameters(uint64_t a1, const void *a2, unint64_t a3, char a4, int a5, float a6)
{
  void **v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  unsigned int v16;
  uint64_t v17;

  v12 = (void **)(a1 + 496);
  std::vector<float>::resize(a1 + 496, a3);
  if (a3)
    memmove(*v12, a2, 4 * a3);
  *(float *)(a1 + 488) = a6;
  DspLib::Biquad::ParametricFilter::setNumberOfStages((DspLib::Biquad::ParametricFilter *)(a1 + 8), a3);
  DspLib::Biquad::ParametricFilter::setNumberOfStages((DspLib::Biquad::ParametricFilter *)(a1 + 112), a3);
  if ((a4 & 1) == 0)
  {
    DspLib::Biquad::ParametricFilter::setNumberOfStages((DspLib::Biquad::ParametricFilter *)(a1 + 216), a3);
    DspLib::Biquad::ParametricFilter::setNumberOfStages((DspLib::Biquad::ParametricFilter *)(a1 + 320), a3);
  }
  *(_BYTE *)(a1 + 520) = a5;
  v13 = (uint64_t *)(a1 + 528);
  if (a5)
  {
    std::vector<std::vector<float>>::resize(v13, *(_QWORD *)(a1 + 56));
    std::vector<void const*>::resize(a1 + 552, *(_QWORD *)(a1 + 56));
    v14 = *(uint64_t **)(a1 + 528);
    v15 = *(uint64_t **)(a1 + 536);
    if (v14 != v15)
    {
      v16 = 0;
      do
      {
        std::vector<float>::resize((uint64_t)v14, (uint64_t)(*(_QWORD *)(a1 + 440) - *(_QWORD *)(a1 + 432)) >> 2);
        v17 = *v14;
        v14 += 3;
        *(_QWORD *)(*(_QWORD *)(a1 + 552) + 8 * v16++) = v17;
      }
      while (v14 != v15);
    }
  }
  else
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100](v13);
    *(_QWORD *)(a1 + 560) = *(_QWORD *)(a1 + 552);
  }
}

void DspLib::ConstantQFilterbank::calculateCoefficients(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  _QWORD *v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  int v10;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v1 = MEMORY[0x1E0C80A78](a1);
  if (v3)
  {
    v6 = &v11[-2 * v3];
    do
    {
      *(_DWORD *)v6 = 23;
      *(_QWORD *)((char *)v6 + 4) = 1148846080;
      *((_DWORD *)v6 + 3) = 1065353216;
      v6 += 2;
    }
    while (v6 != v11);
    v7 = 0;
    v8 = &v11[-2 * v3 + 1];
    do
    {
      v9 = *(_DWORD *)(v4 + 4 * v7);
      v10 = *(_DWORD *)(v2 + 4 * v7);
      *(v8 - 2) = 28;
      *(v8 - 1) = v9;
      *v8 = v10;
      v8[1] = v5;
      ++v7;
      v8 += 4;
    }
    while (v3 > v7);
  }
  DspLib::Biquad::ParametricFilter::setParametricEQs(v1, (uint64_t)&v11[-2 * v3], v3);
}

void DspLib::ConstantQFilterbank::Modifier::apply(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  char v9;
  vDSP_Length v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  _QWORD v19[3];
  __int128 v20;
  uint64_t v21;
  uint64_t v22[5];
  uint64_t v23;
  _QWORD v24[2];
  float **v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v24[0] = a4;
  v24[1] = a5;
  v23 = a6;
  v22[0] = a1;
  v22[1] = (uint64_t)&v23;
  v22[2] = (uint64_t)v24;
  v22[3] = a2;
  v22[4] = a3;
  if (*(_BYTE *)(a1 + 520))
  {
    if (*(_BYTE *)(a1 + 424))
    {
      DspLib::ConstantQFilterbank::Modifier::apply(DspLib::MultiSpan<float const>,DspLib::MultiSpan<float>,std::span<float const,18446744073709551615ul>,DspLib::Biquad::ParametricFilter const*)::$_0::operator()(v22, (DspLib::Biquad::ParametricFilter *)(a1 + 320));
      v27 = *(_OWORD *)a2;
      v28 = *(_QWORD *)(a2 + 16);
      v25 = *(float ***)(a1 + 552);
      v26 = *(_OWORD *)(a2 + 8);
      DspLib::Biquad::Filter::process((_QWORD *)(a1 + 216), (uint64_t)&v27, &v25);
      v9 = 0;
    }
    else
    {
      DspLib::ConstantQFilterbank::Modifier::apply(DspLib::MultiSpan<float const>,DspLib::MultiSpan<float>,std::span<float const,18446744073709551615ul>,DspLib::Biquad::ParametricFilter const*)::$_0::operator()(v22, (DspLib::Biquad::ParametricFilter *)(a1 + 216));
      v27 = *(_OWORD *)a2;
      v28 = *(_QWORD *)(a2 + 16);
      v25 = *(float ***)(a1 + 552);
      v26 = *(_OWORD *)(a2 + 8);
      DspLib::Biquad::Filter::process((_QWORD *)(a1 + 320), (uint64_t)&v27, &v25);
      v9 = 1;
    }
    *(_BYTE *)(a1 + 424) = v9;
    v10 = *(_QWORD *)(a2 + 16);
    if (v10 >= 2)
    {
      if (*(_QWORD *)(a1 + 480) != v10)
      {
        *(_QWORD *)(a1 + 480) = v10;
        DspLib::ramp(*(float **)(a1 + 432), v10, 0, 0.0, 1.0);
        DspLib::ramp(*(float **)(a1 + 456), *(_QWORD *)(a1 + 480), 0, 1.0, 0.0);
      }
      v20 = *(_OWORD *)a3;
      v21 = *(_QWORD *)(a3 + 16);
      DspLib::multiply(&v20, *(const float **)(a1 + 432));
      v11 = *(_QWORD *)(a1 + 56);
      v12 = *(_QWORD *)(a2 + 16);
      v19[0] = *(_QWORD *)(a1 + 552);
      v19[1] = v11;
      v19[2] = v12;
      DspLib::multiply(v19, *(const float **)(a1 + 456));
      v17 = *(_OWORD *)a3;
      v18 = *(_QWORD *)(a3 + 16);
      v13 = *(_QWORD *)(a1 + 56);
      v14 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)&v15 = *(_QWORD *)(a1 + 552);
      *((_QWORD *)&v15 + 1) = v13;
      v16 = v14;
      DspLib::add((uint64_t *)&v17, &v15);
    }
  }
  else
  {
    DspLib::ConstantQFilterbank::Modifier::apply(DspLib::MultiSpan<float const>,DspLib::MultiSpan<float>,std::span<float const,18446744073709551615ul>,DspLib::Biquad::ParametricFilter const*)::$_0::operator()(v22, (DspLib::Biquad::ParametricFilter *)(a1 + 320));
  }
}

__n128 DspLib::ConstantQFilterbank::Modifier::apply(DspLib::MultiSpan<float const>,DspLib::MultiSpan<float>,std::span<float const,18446744073709551615ul>,DspLib::Biquad::ParametricFilter const*)::$_0::operator()(uint64_t *a1, DspLib::Biquad::ParametricFilter *this)
{
  uint64_t v4;
  const DspLib::Biquad::Filter *v5;
  __int128 *v6;
  __int128 *v7;
  uint64_t v8;
  __n128 result;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;

  v4 = *a1;
  DspLib::Biquad::ParametricFilter::setNumberOfStages(this, ((*(_QWORD *)(*a1 + 504) - *(_QWORD *)(*a1 + 496)) >> 2));
  if (!*(_QWORD *)a1[1])
    DspLib::Biquad::Filter::copyStatesFrom((DspLib::Biquad::Filter *)(v4 + 112), this);
  DspLib::ConstantQFilterbank::calculateCoefficients((uint64_t)this);
  if (*(_QWORD *)a1[1])
    v5 = *(const DspLib::Biquad::Filter **)a1[1];
  else
    v5 = (const DspLib::Biquad::Filter *)(v4 + 112);
  DspLib::Biquad::Filter::copyStatesFrom(this, v5);
  v6 = (__int128 *)a1[3];
  v7 = (__int128 *)a1[4];
  v12 = *((_QWORD *)v6 + 2);
  v11 = *v6;
  v10 = *v7;
  v8 = *((_QWORD *)v7 + 2);
  v15 = v11;
  v16 = v12;
  v13 = v10;
  v14 = v8;
  DspLib::Biquad::Filter::process(this, (uint64_t)&v15, (float ***)&v13);
  return result;
}

void DspLib::ConstantQFilterbank::Modifier::setGains(uint64_t a1)
{
  DspLib::ConstantQFilterbank::calculateCoefficients(a1 + 8);
}

void DspLib::XTC::FIRMatrix::initialize(DspLib::XTC::FIRMatrix *this, uint64_t a2)
{
  uint64_t i;

  for (i = 0; i != 256; i += 64)
    DspLib::FIR::initialize((DspLib::XTC::FIRMatrix *)((char *)this + i), 1uLL, a2);
}

void DspLib::XTC::FIRMatrix::reset(DspLib::XTC::FIRMatrix *this)
{
  uint64_t i;

  for (i = 0; i != 256; i += 64)
    DspLib::FIR::reset((DspLib::XTC::FIRMatrix *)((char *)this + i));
}

void DspLib::XTC::FIRMatrix::setCoefficients(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v5;
  char v6;
  char v7;
  char *v8;

  v2 = a2[1];
  *(_QWORD *)(a1 + 256) = a2[2];
  if (v2 == 4)
  {
    v5 = 0;
    v6 = 1;
    do
    {
      v7 = v6;
      DspLib::FIR::setCoefficients((_QWORD *)(a1 + (v5 << 6)), *(const void **)(*a2 + 8 * v5), a2[2]);
      DspLib::FIR::setCoefficients((_QWORD *)(a1 + ((v5 | 1) << 6)), *(const void **)(*a2 + 8 * (v5 | 1)), a2[2]);
      v6 = 0;
      v5 = 2;
    }
    while ((v7 & 1) != 0);
  }
  else
  {
    v8 = basename("/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/DspLib/XTC/dsp/DspLibXTC_FIRMatrix.cpp");
    printf("DSP Sound assertion in %s at line %d\n", v8, 37);
    ++DspLibDebug::mAssertCounter;
  }
}

void DspLib::XTC::FIRMatrix::process(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  char v9;
  char v10;
  uint64_t v11;
  const float *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v17[4];
  int v18;
  _QWORD v19[3];
  _QWORD v20[3];
  _BYTE *v21;
  _QWORD v22[2];

  v6 = 0;
  v22[1] = *MEMORY[0x1E0C80C00];
  v7 = 1;
  do
  {
    v18 = v7;
    DspLib::clear(*(float **)(*a3 + 8 * v6), a3[2]);
    v9 = 1;
    do
    {
      v10 = v9;
      MEMORY[0x1E0C80A78](v8);
      v12 = (const float *)&v17[-v11];
      v13 = a2[2];
      v15 = (2 * v6) | v14;
      v16 = *(_QWORD *)(*a2 + 8 * v14);
      v21 = &v17[-v11];
      v22[0] = v16;
      v20[0] = v22;
      v20[1] = 1;
      v20[2] = v13;
      v19[0] = &v21;
      v19[1] = 1;
      v19[2] = v13;
      DspLib::FIR::process(a1 + (v15 << 6), v20, v19);
      DspLib::add(*(float **)(*a3 + 8 * v6), a3[2], v12);
      v9 = 0;
    }
    while ((v10 & 1) != 0);
    v7 = 0;
    v6 = 1;
  }
  while ((v18 & 1) != 0);
}

double DspLib::PowerGuard::PowerAnalyzerBase::initialize(DspLib::PowerGuard::PowerAnalyzerBase *this, double a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  double result;

  LODWORD(v2) = 4 * vcvtad_u64_f64(a2 / 1500.0 * 0.25);
  v3 = 5 * vcvtad_u64_f64(a2 / 1500.0 / 5.0);
  v4 = 4;
  if (vabdd_f64(a2 / 1500.0, (double)v2) <= vabdd_f64(a2 / 1500.0, (double)v3))
  {
    v2 = v2;
  }
  else
  {
    v4 = 5;
    v2 = v3;
  }
  *((_QWORD *)this + 2) = v4;
  *((_QWORD *)this + 3) = v2;
  result = a2 / (double)v2;
  *((double *)this + 1) = result;
  return result;
}

void DspLib::PowerGuard::PowerAnalyzerBase::setParameters(DspLib::PowerGuard::PowerAnalyzerBase *this, float *a2, unint64_t a3)
{
  double v3;
  unint64_t *v4;
  unint64_t v5;
  float v6;
  char *v7;
  unint64_t v8[4];

  if (a3 >= 5)
  {
    v7 = basename("/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/DspLib/LoudspeakerManagerV1/PowerGuard/dsp/DspLibPowerGuardClasses.cpp");
    printf("DSP Sound assertion in %s at line %d\n", v7, 38);
    ++DspLibDebug::mAssertCounter;
  }
  else
  {
    if (a3)
    {
      v3 = *((double *)this + 1);
      v4 = v8;
      v5 = a3;
      do
      {
        v6 = *a2++;
        *v4++ = vcvtad_u64_f64(v3 * v6);
        --v5;
      }
      while (v5);
    }
    DspLib::MultiMovingAverage::setLengths((uint64_t *)this + 4, v8, a3);
  }
}

void DspLib::PowerGuard::PowerAnalyzerBase::process(DspLib::PowerGuard::PowerAnalyzerBase *this@<X0>, const float *const *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>, unint64_t a6@<D0>)
{
  vDSP_Length v11;
  int64x2_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15[3];
  _OWORD v16[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  LODWORD(a6) = *((_DWORD *)this + 22);
  if (*((double *)this + 1) <= (double)a6)
  {
    DspLib::MultiMovingAverage::recalculateState((DspLib::PowerGuard::PowerAnalyzerBase *)((char *)this + 32));
    *((_DWORD *)this + 22) = 0;
  }
  if (a3 && a4)
  {
    v11 = (**(uint64_t (***)(DspLib::PowerGuard::PowerAnalyzerBase *, const float *const *, uint64_t, uint64_t, _QWORD *))this)(this, a2, a3, a4, a5);
    v12 = vdupq_n_s64((unint64_t)(a5 + 2));
    a5[10] = v11;
    v16[0] = vaddq_s64(v12, (int64x2_t)xmmword_1B6626890);
    v16[1] = vaddq_s64(v12, (int64x2_t)xmmword_1B662C2A0);
    v15[0] = (uint64_t)v16;
    v15[1] = 4;
    v15[2] = v11;
    DspLib::MultiMovingAverage::process((uint64_t *)this + 4, a5, v11, v15);
    *((_DWORD *)this + 22) += a4;
  }
  else
  {
    a5[10] = 0;
    DspLib::clear((float *)a5, 4uLL);
    v13 = 0;
    v14 = a5 + 2;
    do
    {
      DspLib::clear((float *)&v14[v13], 4uLL);
      v13 += 2;
    }
    while (v13 != 8);
  }
}

void DspLib::PowerGuard::WooferPowerAnalyzer::initialize(DspLib::PowerGuard::WooferPowerAnalyzer *this, double a2)
{
  DspLib::PowerGuard::PowerAnalyzerBase::initialize(this, a2);
  *((double *)this + 15) = a2 / (double)(unint64_t)(*((_QWORD *)this + 3) / *((_QWORD *)this + 2));
  DspLib::Biquad::Filter::initialize((DspLib::PowerGuard::WooferPowerAnalyzer *)((char *)this + 128), 1uLL, 0);
  DspLib::AveragingDecimator::setSrcFactor((void **)this + 25, (char *)(*((_QWORD *)this + 3) / *((_QWORD *)this + 2)), 0);
  DspLib::AveragingDecimator::setSrcFactor((void **)this + 31, *((char **)this + 2), 0);
}

void DspLib::PowerGuard::WooferPowerAnalyzer::uninitialize(DspLib::PowerGuard::WooferPowerAnalyzer *this)
{
  DspLib::MultiMovingAverage::setLengths((uint64_t *)this + 4, (unint64_t *)1, 0);
  DspLib::Biquad::Filter::uninitialize((DspLib::PowerGuard::WooferPowerAnalyzer *)((char *)this + 128));
}

void DspLib::PowerGuard::WooferPowerAnalyzer::setParameters(DspLib::PowerGuard::WooferPowerAnalyzer *this, float a2, float a3, float *a4, unint64_t a5, float a6, float a7)
{
  float v12;
  float v13;
  float v14;

  DspLib::PowerGuard::PowerAnalyzerBase::setParameters(this, a4, a5);
  *((float *)this + 23) = (float)(a2 * a2) / a3;
  v12 = *((double *)this + 15);
  v13 = 1.0;
  v14 = 1.0;
  if ((float)(1.0 / v12) < a6)
    v14 = (float)(1000.0 / v12) / (float)(a6 / 4.6052);
  if (v14 <= 1.0)
    v13 = v14;
  *((float *)this + 25) = v13;
  *((float *)this + 28) = a7;
}

void DspLib::PowerGuard::WooferPowerAnalyzer::setAdmittanceCoeffs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  v5 = a1 + 128;
  DspLib::Biquad::Filter::setNumberOfStages((vDSP_Length *)(a1 + 128), a3);
  DspLib::Biquad::Filter::setCoefficients(v5, a2, a3, 0, 0x41uLL);
}

void DspLib::PowerGuard::WooferPowerAnalyzer::reset(DspLib::PowerGuard::WooferPowerAnalyzer *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 4);
  v3 = *((_QWORD *)this + 5);
  while (v2 != v3)
  {
    *(_DWORD *)(v2 + 8) = 0;
    v2 += 16;
  }
  DspLib::CircularDelay::reset((DspLib::PowerGuard::WooferPowerAnalyzer *)((char *)this + 56));
  *((_DWORD *)this + 22) = 0;
  DspLib::Biquad::SetupWrapper::reset((DspLib::PowerGuard::WooferPowerAnalyzer *)((char *)this + 176));
  DspLib::AveragingDecimator::reset((DspLib::PowerGuard::WooferPowerAnalyzer *)((char *)this + 200));
  DspLib::AveragingDecimator::reset((DspLib::PowerGuard::WooferPowerAnalyzer *)((char *)this + 248));
  *((_QWORD *)this + 13) = 0;
}

uint64_t DspLib::PowerGuard::WooferPowerAnalyzer::powerFunction(DspLib::PowerGuard::WooferPowerAnalyzer *this, const float *const *a2, uint64_t a3, uint64_t a4, float *a5)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  float **v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  const float *v19;
  uint64_t v20;
  float v21;
  uint64_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  float *v29;
  uint64_t v30;
  const float *v31;
  unint64_t v32;
  uint64_t v33;

  result = 0;
  v33 = *MEMORY[0x1E0C80C00];
  if (a3 && a4)
  {
    MEMORY[0x1E0C80A78](0);
    v8 = 4 * *((_QWORD *)this + 3);
    v9 = *((_QWORD *)this + 27);
    v31 = (const float *)((char *)&v28 - v10);
    v32 = v8;
    DspLib::AveragingDecimator::processKernel((uint64_t)this + 200, *v11, v12, (uint64_t)&v31, v9, (*((_QWORD *)this + 28) - v9) >> 2, (void **)this + 27);
    v14 = (float **)v32;
    if (v32 <= 1)
      v15 = 1;
    else
      v15 = v32;
    v16 = 4 * v15;
    MEMORY[0x1E0C80A78](v13);
    v17 = (v16 + 15) & 0xFFFFFFFFFFFFFFF0;
    v18 = (char *)&v28 - v17;
    v19 = v31;
    DspLib::Biquad::Filter::process((_QWORD *)this + 16, (uint64_t)v31, (uint64_t)v14, (uint64_t)&v28 - v17, v14);
    DspLib::multiply((float *)((char *)&v28 - v17), (vDSP_Length)v14, v19);
    MEMORY[0x1E0C80A78](v20);
    v21 = *((float *)this + 24);
    DspLib::multiply(v31, v32, v31, v32, (float *)((char *)&v28 - v17));
    DspLib::multiply((float *)((char *)&v28 - v17), (vDSP_Length)v14, v21);
    if (v14)
    {
      v22 = 0;
      v23 = *((float *)this + 25);
      v24 = *((float *)this + 26);
      v25 = *((float *)this + 27);
      v26 = *((float *)this + 28);
      do
      {
        v24 = v24 + (float)(v23 * (float)(*(float *)&v18[4 * v22] - v24));
        v27 = *(float *)((char *)&v28 + 4 * v22 - v17);
        v25 = v25 + (float)(v23 * (float)(v27 - v25));
        if (v24 < (float)(v26 * v25))
          *(float *)&v18[4 * v22] = v27 * v26;
        ++v22;
      }
      while ((unint64_t)v14 > v22);
      *((float *)this + 26) = v24;
      *((float *)this + 27) = v25;
    }
    DspLib::multiply((float *)((char *)&v28 - v17), (vDSP_Length)v14, *((float *)this + 23));
    v29 = a5;
    v30 = 4;
    DspLib::AveragingDecimator::processKernel((uint64_t)this + 248, (char *)&v28 - v17, (uint64_t)v14, (uint64_t)&v29, *((_QWORD *)this + 33), (uint64_t)(*((_QWORD *)this + 34) - *((_QWORD *)this + 33)) >> 2, (void **)this + 33);
    return v30;
  }
  return result;
}

void DspLib::PowerGuard::TweeterPowerAnalyzer::initialize(DspLib::PowerGuard::TweeterPowerAnalyzer *this, double a2)
{
  DspLib::PowerGuard::PowerAnalyzerBase::initialize(this, a2);
  DspLib::AveragingDecimator::setSrcFactor((void **)this + 12, *((char **)this + 3), 0);
}

float DspLib::PowerGuard::TweeterPowerAnalyzer::setParameters(DspLib::PowerGuard::TweeterPowerAnalyzer *this, float a2, float a3, float a4, float *a5, unint64_t a6)
{
  float result;

  DspLib::PowerGuard::PowerAnalyzerBase::setParameters(this, a5, a6);
  result = (float)((float)(a2 * a2) * a3) / a4;
  *((float *)this + 23) = result;
  return result;
}

void DspLib::PowerGuard::TweeterPowerAnalyzer::reset(DspLib::PowerGuard::TweeterPowerAnalyzer *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 4);
  v3 = *((_QWORD *)this + 5);
  while (v2 != v3)
  {
    *(_DWORD *)(v2 + 8) = 0;
    v2 += 16;
  }
  DspLib::CircularDelay::reset((DspLib::PowerGuard::TweeterPowerAnalyzer *)((char *)this + 56));
  *((_DWORD *)this + 22) = 0;
  DspLib::AveragingDecimator::reset((DspLib::PowerGuard::TweeterPowerAnalyzer *)((char *)this + 96));
}

uint64_t DspLib::PowerGuard::TweeterPowerAnalyzer::powerFunction(DspLib::PowerGuard::TweeterPowerAnalyzer *this, const float *const *a2, unint64_t a3, vDSP_Length a4, float *a5)
{
  uint64_t result;
  uint64_t v11;
  float *v12;
  unint64_t v13;
  unsigned int v14;
  uint64_t v15;
  float *v16;
  uint64_t v17;
  uint64_t v18;

  result = 0;
  v18 = *MEMORY[0x1E0C80C00];
  if (a3 && a4)
  {
    MEMORY[0x1E0C80A78](0);
    v12 = (float *)((char *)&v15 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
    DspLib::clear(v12, a4);
    v13 = 0;
    v14 = 1;
    do
    {
      DspLib::multiplyAccumulate(v12, a4, a2[v13], a4, a2[v13]);
      v13 = v14++;
    }
    while (v13 < a3);
    DspLib::multiply(v12, a4, *((float *)this + 23));
    v16 = a5;
    v17 = 4;
    DspLib::AveragingDecimator::processKernel((uint64_t)this + 96, v12, a4, (uint64_t)&v16, *((_QWORD *)this + 14), (uint64_t)(*((_QWORD *)this + 15) - *((_QWORD *)this + 14)) >> 2, (void **)this + 14);
    return v17;
  }
  return result;
}

BOOL DspLib::PowerGuard::TargetCalculator::setParameters(DspLib::PowerGuard::TargetCalculator *this, unint64_t a2, const float *a3, const float *a4, unint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  int v14;
  char *v16;

  v10 = 0;
  v11 = (uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 2;
  do
  {
    DspLib::LinearDelay::setLength((float **)((char *)this + v10), a2);
    v10 += 24;
  }
  while (v10 != 96);
  do
  {
    DspLib::LinearDelay::setLength((float **)((char *)this + v10), a2);
    v10 += 24;
  }
  while (v10 != 192);
  if (a5 > 4)
  {
    v16 = basename("/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/DspLib/LoudspeakerManagerV1/PowerGuard/dsp/DspLibPowerGuardClasses.cpp");
    printf("DSP Sound assertion in %s at line %d\n", v16, 205);
    ++DspLibDebug::mAssertCounter;
  }
  else
  {
    if (a5)
    {
      v12 = (_DWORD *)((char *)this + 272);
      do
      {
        v13 = *(_DWORD *)a3++;
        *(v12 - 4) = v13;
        v14 = *(_DWORD *)a4++;
        *v12++ = v14;
        --a5;
      }
      while (a5);
    }
    if (v11 != a2)
      DspLib::PowerGuard::TargetCalculator::reset(this);
  }
  return v11 != a2;
}

double DspLib::PowerGuard::TargetCalculator::reset(DspLib::PowerGuard::TargetCalculator *this)
{
  uint64_t i;
  char *v3;
  char *v4;
  float *v5;
  uint64_t v6;
  double result;

  for (i = 0; i != 96; i += 24)
    DspLib::clear(*(float **)((char *)this + i), (uint64_t)(*(_QWORD *)((char *)this + i + 8) - *(_QWORD *)((char *)this + i)) >> 2);
  v3 = (char *)this + 96;
  v4 = (char *)this + 192;
  do
  {
    v5 = *(float **)v3;
    v6 = *((_QWORD *)v3 + 1);
    v3 += 24;
    DspLib::clear(v5, (v6 - (uint64_t)v5) >> 2);
  }
  while (v3 != v4);
  *(_OWORD *)v4 = 0u;
  *((_OWORD *)this + 13) = 0u;
  memset_pattern16((char *)this + 288, &unk_1B6627B80, 0x10uLL);
  memset_pattern16((char *)this + 304, &unk_1B6627B80, 0x10uLL);
  result = 0.0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  return result;
}

void DspLib::PowerGuard::TargetCalculator::process(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5)
{
  char *v5;
  float *v6;
  uint64_t i;
  uint64_t *v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  _QWORD *v13;
  const float **v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  const float **v20;
  _QWORD *v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  const float *v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  uint64_t v31;
  float v32;
  float v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  _OWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  int v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  uint64_t v57;
  uint64_t v58;
  float v59;
  float v60;
  uint64_t v61;
  float v62;
  float v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _OWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  vDSP_Length v71;
  vDSP_Length v72;
  float *v73;
  uint64_t v74;
  uint64_t v75;
  __int128 v76;
  uint64_t v77;

  v66 = a5;
  v67 = a4;
  v77 = *MEMORY[0x1E0C80C00];
  v74 = a1;
  v64 = a1 + 208;
  v65 = a1 + 192;
  v68 = a3;
  v69 = a2;
  v5 = (char *)(a2 + 16);
  v6 = (float *)(a3 + 16);
  v75 = -16;
  for (i = 8; i != 104; i += 24)
  {
    v8 = (uint64_t *)(v69 + 80);
    v72 = *(_QWORD *)(v69 + 80);
    v73 = (float *)v5;
    v9 = DspLib::maxv((const float *)v5, v72);
    v10 = v74;
    v11 = v75;
    *(float *)(v74 + v75 + 208) = v9;
    v12 = (float *)(v10 + v11 + 208);
    v13 = (_QWORD *)(v10 + i);
    v14 = (const float **)(v10 + i - 8);
    v15 = DspLib::maxv(*v14, (uint64_t)(*(_QWORD *)(v10 + i) - (_QWORD)*v14) >> 2);
    if (*v12 >= v15)
      v15 = *v12;
    *v12 = v15;
    v71 = *(_QWORD *)(v68 + 80);
    v16 = DspLib::maxv(v6, v71);
    v17 = v74;
    v18 = v75;
    *(float *)(v74 + v75 + 224) = v16;
    v19 = (float *)(v17 + v18 + 224);
    v20 = (const float **)(v17 + i + 88);
    v21 = (_QWORD *)(v17 + i + 96);
    v23 = DspLib::maxv(*v20, (uint64_t)(*v21 - (_QWORD)*v20) >> 2);
    v70 = &v64;
    if (*v19 >= v23)
      v23 = *v19;
    *v19 = v23;
    MEMORY[0x1E0C80A78](v22);
    v25 = (const float *)((char *)&v64 - v24);
    v26 = *v8;
    v28 = v27[1] - *v27;
    DspLib::add(*v14, (uint64_t)(*v13 - (_QWORD)*v14) >> 2, *v20, (uint64_t)(*v21 - (_QWORD)*v20) >> 2, (float *)((char *)&v64 - v24));
    DspLib::add(v73, v72, v6, v72, (float *)&v25[v26 + (v28 >> 2) - *v8]);
    v29 = DspLib::maxv(v25, v26 + (v28 >> 2));
    *(float *)(v74 + v75 + 240) = v29;
    DspLib::LinearDelay::write((uint64_t *)v14, (char *)v73, v72);
    DspLib::LinearDelay::write((uint64_t *)v20, (char *)v6, v71);
    v5 = (char *)(v73 + 4);
    v75 += 4;
    v6 += 4;
  }
  v30 = 0;
  v31 = v74;
  do
  {
    v32 = *(float *)(v31 + v30 + 224);
    v33 = *(float *)(v31 + v30 + 256);
    if (v32 >= v33)
    {
      v34 = *(float *)(v31 + v30 + 272) - v33;
      v33 = v33 + (float)(v34 * (float)(1.0 - expf((float)-(float)(v32 - v33) / fmaxf(v34, 1.0e-15))));
    }
    *(float *)((char *)&v76 + v30) = v33;
    v30 += 4;
  }
  while (v30 != 16);
  v35 = 0;
  *(_OWORD *)(v31 + 240) = v76;
  v76 = *(_OWORD *)(v31 + 240);
  v38 = v66;
  v37 = v67;
  v40 = v64;
  v39 = v65;
  do
  {
    v36 = v31 + 240;
    v41 = *(float *)(v31 + 240 + 4 * v35);
    v42 = *(float *)(v39 + 4 * v35);
    if (v42 <= v41)
      v43 = *(float *)(v39 + 4 * v35);
    else
      v43 = *(float *)(v36 + 4 * v35);
    v44 = *(float *)(v40 + 4 * v35);
    if (v44 <= v41)
      v45 = *(float *)(v40 + 4 * v35);
    else
      v45 = *(float *)(v36 + 4 * v35);
    v46 = v43 + v45;
    if (v46 <= v41)
    {
      v47 = *(float *)(v36 + 4 * v35);
    }
    else
    {
      v47 = v41 * 0.5;
      if (v42 <= (float)(v41 * 0.5))
        v48 = *(float *)(v39 + 4 * v35);
      else
        v48 = v41 * 0.5;
      if (v44 <= v47)
        v49 = *(float *)(v40 + 4 * v35);
      else
        v49 = v41 * 0.5;
      v50 = v48 + v49;
      v51 = 10;
      v52 = *(float *)(v36 + 4 * v35);
      do
      {
        v53 = v47 + (float)((float)((float)((float)(v41 - v50) / (float)(v46 - v50)) * 0.9) * (float)(v52 - v47));
        if (v42 <= v53)
          v54 = *(float *)(v39 + 4 * v35);
        else
          v54 = v47 + (float)((float)((float)((float)(v41 - v50) / (float)(v46 - v50)) * 0.9) * (float)(v52 - v47));
        if (v44 <= v53)
          v55 = *(float *)(v40 + 4 * v35);
        else
          v55 = v47 + (float)((float)((float)((float)(v41 - v50) / (float)(v46 - v50)) * 0.9) * (float)(v52 - v47));
        v56 = v54 + v55;
        if (v56 <= v41)
        {
          v47 = v47 + (float)((float)((float)((float)(v41 - v50) / (float)(v46 - v50)) * 0.9) * (float)(v52 - v47));
          v50 = v56;
        }
        if ((float)(v41 - v50) < (float)(v41 * 0.00001))
          break;
        if (v56 > v41)
        {
          v46 = v56;
          v52 = v53;
        }
        --v51;
      }
      while (v51);
    }
    *((float *)&v76 + v35++) = v47;
  }
  while (v35 != 4);
  v57 = 0;
  *v37 = v76;
  do
  {
    *(float *)(v38 + v57) = *(float *)(v31 + 272 + v57) - *(float *)((char *)v37 + v57);
    v57 += 4;
  }
  while (v57 != 16);
  v58 = 0;
  v59 = 1.0;
  do
  {
    v60 = fminf(*(float *)((char *)v37 + v58) / fmaxf(*(float *)(v31 + v58 + 192), 1.0e-15), 1.0);
    *(float *)(v31 + v58 + 288) = v60;
    if (v60 < v59)
      v59 = v60;
    v58 += 4;
  }
  while (v58 != 16);
  v61 = 0;
  v62 = 1.0;
  do
  {
    v63 = fminf(*(float *)((char *)v37 + v61) / fmaxf(*(float *)(v31 + v61 + 208), 1.0e-15), 1.0);
    *(float *)(v31 + v61 + 304) = v63;
    if (v63 < v62)
      v62 = v63;
    v61 += 4;
  }
  while (v61 != 16);
}

__n128 DspLib::PowerGuard::TargetCalculator::status(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  DspLib *v7;
  __n128 result;

  v4 = 0;
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 192);
  *(_OWORD *)(a2 + 140) = *(_OWORD *)(a1 + 208);
  v5 = a1 + 304;
  v6 = a2 + 172;
  do
  {
    *(float *)(v6 + v4 - 140) = DspLib::power2dBSafe((DspLib *)a1, *(float *)(v5 + v4 - 16), 1.0e-20);
    *(float *)(v6 + v4) = DspLib::power2dBSafe(v7, *(float *)(v5 + v4), 1.0e-20);
    v4 += 4;
  }
  while (v4 != 16);
  *(_OWORD *)(a2 + 192) = *(_OWORD *)(a1 + 224);
  result = *(__n128 *)(a1 + 240);
  *(__n128 *)(a2 + 208) = result;
  return result;
}

BOOL DspLib::PowerGuard::GainCalculator::setParameters(DspLib::PowerGuard::GainCalculator *this, unint64_t a2, float a3)
{
  uint64_t v6;

  v6 = (uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 2;
  DspLib::LinearDelay::setLength((float **)this, a2);
  *((float *)this + 6) = a3;
  if (v6 != a2)
    DspLib::clear(*(float **)this, (uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 2);
  return v6 != a2;
}

float DspLib::PowerGuard::GainCalculator::process(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, float a6)
{
  _QWORD *v12;
  unint64_t v13;
  const void **v14;
  uint64_t v15;
  char *v16;
  char *v17;
  unint64_t v18;
  float v19;
  float v20;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  v12 = (_QWORD *)(a1 + 8);
  v13 = *(_QWORD *)(a2 + 80) + ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  v14 = (const void **)MEMORY[0x1E0C80A78](a1);
  v16 = (char *)v22 - v15;
  DspLib::LinearDelay::process(v14, v17, v18, (char *)v22 - v15);
  if (*v12 != *(_QWORD *)a1)
    memmove(&v16[4 * *(_QWORD *)(a2 + 80)], *(const void **)a1, *v12 - *(_QWORD *)a1);
  v19 = sqrtf(DspLib::PowerGuard::findGainFromZeroInputZeroStateDecomposition(a3, (uint64_t)v16, v13, a4, a5));
  if (v19 < *(float *)(a1 + 24))
    v19 = *(float *)(a1 + 24);
  v20 = sqrtf(a6);
  if (v19 < (float)(v20 * 0.70711))
    v19 = v20 * 0.70711;
  if (v20 < v19)
    v19 = v20;
  return fmaxf(v19, 0.0);
}

float DspLib::PowerGuard::findGainFromZeroInputZeroStateDecomposition(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  float v27;
  float v28;
  _QWORD v30[3];
  _QWORD v31[3];
  _OWORD v32[2];
  _OWORD v33[2];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a3 <= 1)
    v9 = 1;
  else
    v9 = a3;
  MEMORY[0x1E0C80A78](a1);
  v13 = &v30[-2 * v12];
  v14 = 0;
  memset(v33, 0, sizeof(v33));
  v15 = 4 * v11;
  do
  {
    *(_QWORD *)((char *)v33 + v14) = v13;
    v13 = (_QWORD *)((char *)v13 + ((4 * v11) & 0xFFFFFFFFFFFFFFF0) + 16);
    v14 += 8;
  }
  while (v14 != 32);
  v31[0] = v33;
  v31[1] = 4;
  v31[2] = a3;
  DspLib::MultiMovingAverage::zeroStateResponse(a1, v10, a3, v31);
  MEMORY[0x1E0C80A78](v16);
  v18 = (char *)v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = 0;
  memset(v32, 0, sizeof(v32));
  do
  {
    *(_QWORD *)((char *)v32 + v19) = v18;
    v18 += (v15 & 0xFFFFFFFFFFFFFFF0) + 16;
    v19 += 8;
  }
  while (v19 != 32);
  v30[0] = v32;
  v30[1] = 4;
  v30[2] = a3;
  DspLib::MultiMovingAverage::zeroInputResponse(a1, v30);
  v21 = 0;
  v22 = 1.0;
  v23 = 4 * v9;
  do
  {
    MEMORY[0x1E0C80A78](v20);
    DspLib::add(*((const float **)v33 + v21), a3, *((const float **)v32 + v21), a3, (float *)((char *)v30 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0)));
    v20 = DspLib::maxIndex((const float *)((char *)v30 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0)), a3);
    v25 = *(float *)(a5 + 4 * v21) * 0.1;
    v26 = *(float *)(a4 + 4 * v21);
    if ((float)(*(float *)&v20 - v26) > v25)
    {
      v27 = v26 - *(float *)(*((_QWORD *)v32 + v21) + 4 * v24);
      if (v25 < v27)
        v25 = v27;
      v28 = v25 / *(float *)(*((_QWORD *)v33 + v21) + 4 * v24);
      if (v28 < v22)
        v22 = v28;
    }
    ++v21;
  }
  while (v21 != 4);
  return v22;
}

uint64_t DspLib::PowerGuard::PowerController::setParameters(DspLib::PowerGuard::PowerController *this, unint64_t a2, const float *a3, const float *a4, unint64_t a5, float a6)
{
  _BOOL4 v9;
  int v10;
  uint64_t v11;

  v9 = DspLib::PowerGuard::TargetCalculator::setParameters(this, a2, a3, a4, a5);
  v10 = v9 | DspLib::PowerGuard::GainCalculator::setParameters((DspLib::PowerGuard::PowerController *)((char *)this + 336), a2, a6);
  v11 = v10 | DspLib::PowerGuard::GainCalculator::setParameters((DspLib::PowerGuard::PowerController *)((char *)this + 368), a2, a6);
  if ((_DWORD)v11 == 1)
    DspLib::PowerGuard::PowerController::reset((float **)this);
  return v11;
}

void DspLib::PowerGuard::PowerController::reset(float **this)
{
  DspLib::PowerGuard::TargetCalculator::reset((DspLib::PowerGuard::TargetCalculator *)this);
  DspLib::clear(this[42], this[43] - this[42]);
  DspLib::clear(this[46], this[47] - this[46]);
  this[40] = 0;
  this[41] = 0;
}

BOOL DspLib::PowerGuard::PowerController::uninitialize(DspLib::PowerGuard::PowerController *this)
{
  DspLib::PowerGuard::GainCalculator::setParameters((DspLib::PowerGuard::PowerController *)((char *)this + 336), 0, 0.0);
  return DspLib::PowerGuard::GainCalculator::setParameters((DspLib::PowerGuard::PowerController *)((char *)this + 368), 0, 0.0);
}

float DspLib::PowerGuard::PowerController::process(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  float v14;
  _BYTE v16[16];

  v10 = a1 + 320;
  DspLib::PowerGuard::TargetCalculator::process(a1, a2, a4, (_OWORD *)(a1 + 320), (uint64_t)v16);
  v12 = v11;
  v14 = DspLib::PowerGuard::GainCalculator::process(a1 + 336, a2, a3, v10, (uint64_t)v16, v13);
  DspLib::PowerGuard::GainCalculator::process(a1 + 368, a4, a5, v10, (uint64_t)v16, v12);
  return v14;
}

void DspLib::PowerGuard::GainApplier::initialize(DspLib::PowerGuard::GainApplier *this, double a2, unint64_t a3, unint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  *(double *)this = a2;
  v7 = *((_QWORD *)this + 9);
  v8 = *((_QWORD *)this + 8);
  std::vector<DspLib::LinearDelay>::resize((uint64_t *)this + 8, a3);
  if (a4 != (uint64_t)(*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 2)
  {
    std::vector<float>::resize((uint64_t)this + 8, a4);
    std::vector<float>::resize((uint64_t)this + 32, a4);
    goto LABEL_5;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((v7 - v8) >> 3) != a3)
LABEL_5:
    DspLib::PowerGuard::GainApplier::reset(this);
}

void DspLib::PowerGuard::GainApplier::reset(DspLib::PowerGuard::GainApplier *this)
{
  uint64_t v1;
  uint64_t v2;
  float *v3;
  uint64_t v4;

  *((_DWORD *)this + 14) = 1065353216;
  v1 = *((_QWORD *)this + 8);
  v2 = *((_QWORD *)this + 9);
  while (v1 != v2)
  {
    v3 = *(float **)v1;
    v4 = *(_QWORD *)(v1 + 8);
    v1 += 24;
    DspLib::clear(v3, (v4 - (uint64_t)v3) >> 2);
  }
}

void DspLib::PowerGuard::GainApplier::uninitialize(DspLib::PowerGuard::GainApplier *this)
{
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 8);
  *((_QWORD *)this + 2) = *((_QWORD *)this + 1);
  *((_QWORD *)this + 5) = *((_QWORD *)this + 4);
}

BOOL DspLib::PowerGuard::GainApplier::setParameters(DspLib::PowerGuard::GainApplier *this, unint64_t a2, float a3, float a4)
{
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v10;
  float *v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  float *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;

  v7 = *((_QWORD *)this + 8);
  v8 = *((_QWORD *)this + 9);
  if (v8 == v7)
  {
    v10 = 0;
  }
  else
  {
    v10 = a2 != (uint64_t)(*(_QWORD *)(v7 + 8) - *(_QWORD *)v7) >> 2;
    do
    {
      DspLib::LinearDelay::setLength((float **)v7, a2);
      v7 += 24;
    }
    while (v7 != v8);
  }
  v11 = (float *)*((_QWORD *)this + 1);
  v12 = *((_QWORD *)this + 2) - (_QWORD)v11;
  if (v12)
  {
    v13 = *(double *)this;
    v14 = 1.0;
    v15 = 1.0;
    if ((float)(1.0 / v13) < a3)
      v15 = (float)(1000.0 / v13) / (float)(a3 / 4.6052);
    if (v15 > 1.0)
      v15 = 1.0;
    if ((float)(1.0 / v13) < a4)
      v14 = (float)(1000.0 / v13) / (float)(a4 / 4.6052);
    if (v14 > 1.0)
      v14 = 1.0;
    *v11 = v15;
    v16 = (float *)*((_QWORD *)this + 4);
    *v16 = v14;
    if ((unint64_t)v12 >= 5)
    {
      v17 = 0;
      v18 = v12 >> 2;
      v19 = 1;
      do
      {
        v11[v19] = v11[v17] + (float)(v15 * (float)(1.0 - v11[v17]));
        v16[v19] = v16[v17] + (float)(v14 * (float)(1.0 - v16[v17]));
        v19 = (v17++ + 2);
      }
      while (v18 > v19);
    }
  }
  if (v10)
    DspLib::PowerGuard::GainApplier::reset(this);
  return v10;
}

void DspLib::PowerGuard::GainApplier::process(DspLib::PowerGuard::GainApplier *this, const float *const *a2, float *const *a3, unint64_t a4, float a5)
{
  uint64_t v5;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  BOOL v14;
  float v15;
  uint64_t v17;
  const float *v18;
  uint64_t v19;
  const float *v20;
  float v21;
  uint64_t v22;
  float v23;
  unsigned int v24;
  _QWORD v25[2];

  v25[1] = *MEMORY[0x1E0C80C00];
  v5 = *((_QWORD *)this + 9) - *((_QWORD *)this + 8);
  if (v5)
  {
    v11 = 0;
    v12 = 0xAAAAAAAAAAAAAAABLL * (v5 >> 3);
    v13 = 1;
    do
    {
      DspLib::LinearDelay::process((const void **)(*((_QWORD *)this + 8) + 24 * v11), (char *)a2[v11], a4, (char *)a3[v11]);
      v11 = v13;
      v14 = v12 > v13++;
    }
    while (v14);
    v15 = *((float *)this + 14);
    if (a5 != 1.0 || v15 != 1.0)
    {
      v17 = 8;
      if (v15 < a5)
        v17 = 32;
      v18 = (const float *)MEMORY[0x1E0C80A78](*(_QWORD *)((char *)this + v17));
      v20 = (const float *)((char *)v25 - v19);
      DspLib::multiplyAdd(v18, a4, (float *)((char *)v25 - v19), v21, *((float *)this + 14));
      v22 = 0;
      v23 = v20[a4 - 1];
      if (v23 > 0.9977)
        v23 = 1.0;
      *((float *)this + 14) = v23;
      v24 = 1;
      do
      {
        DspLib::multiply(a3[v22], a4, v20);
        v22 = v24;
        v14 = v12 > v24++;
      }
      while (v14);
    }
  }
}

uint64_t *GetAudioDSPManager()
{
  unsigned __int8 v0;
  AudioDSPManager *v2;

  if ((v0 & 1) == 0)
  {
    if ((_DWORD)v2)
    {
      AudioDSPManager::AudioDSPManager(v2);
    }
  }
  return &GetAudioDSPManager::gAudioDSPManager;
}

void sub_1B60EF274(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void AudioDSPManager::AudioDSPManager(AudioDSPManager *this)
{
  const void *v1;
  const void *v2;
  CFTypeID v3;
  std::string *v4;
  CFMutableStringRef v5;
  PlatformUtilities_iOS *v6;
  std::runtime_error *exception;
  CFTypeRef cf;
  std::string __p;
  std::string v10;

  GetAudioDSPManager::gAudioDSPManager = (uint64_t)&off_1E69C4DE8;
  dword_1ED3377D8 = 0;
  v1 = (const void *)MGCopyAnswer();
  v2 = v1;
  if (v1 && (v3 = CFGetTypeID(v1), v3 != CFStringGetTypeID()))
  {
    qword_1ED3377E0 = 0;
    CFRelease(v2);
  }
  else
  {
    qword_1ED3377E0 = (uint64_t)v2;
  }
  if (queryBuildType(void)::once != -1)
    dispatch_once(&queryBuildType(void)::once, &__block_literal_global_67);
  byte_1ED3377E8 = gIsInternal;
  byte_1ED3377E9 = gIsUI;
  std::__fs::filesystem::path::path[abi:ne180100]<char [23],void>((std::string *)&qword_1ED3377F0, "/Library/Audio/Tunings");
  vp::utility::temporary_directory_path(&v10);
  std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>(&__p, "AudioCapture/VP");
  std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&__p, (uint64_t)&v10, (std::__fs::filesystem::path *)&qword_1ED337808);
  v4 = std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>((std::string *)&qword_1ED337820, "/usr/local/lib/");
  word_1ED337838 = 0;
  v5 = PlatformUtilities::CopyHardwareModelShortName((PlatformUtilities *)v4);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v5);
  if (!cf)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  v6 = (PlatformUtilities_iOS *)applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)&qword_1ED337840);
  byte_1ED337858 = 0;
  byte_1ED33785C = 0;
  dword_1ED337860 = PlatformUtilities_iOS::GetProductType(v6);
  byte_1ED337864 = 1;
  dword_1ED337868 = MGGetSInt32Answer();
  qword_1ED33786C = GetAcousticID();
  byte_1ED337874 = 0;
  byte_1ED337878 = 0;
  byte_1ED33787C = 0;
  byte_1ED337880 = 0;
  *(_QWORD *)&algn_1ED337881[7] = 0;
  byte_1ED337890 = 0;
  if (cf)
    CFRelease(cf);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v10.__r_.__value_.__l.__data_);
}

void sub_1B60EF4A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  applesauce::CF::StringRef::~StringRef(&a10);
  if (byte_1ED337837 < 0)
    operator delete((void *)qword_1ED337820);
  if (byte_1ED33781F < 0)
    operator delete((void *)qword_1ED337808);
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (byte_1ED337807 < 0)
    operator delete((void *)qword_1ED3377F0);
  applesauce::CF::StringRef::~StringRef((const void **)&qword_1ED3377E0);
  _Unwind_Resume(a1);
}

std::string *std::__fs::filesystem::path::path[abi:ne180100]<char [23],void>(std::string *this, char *a2)
{
  char *v3;

  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  v3 = a2 - 1;
  while (*++v3)
    ;
  std::string::append[abi:ne180100]<char const*,0>(this, a2, v3);
  return this;
}

void sub_1B60EF5C8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

std::string *std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>(std::string *this, char *a2)
{
  char *v3;

  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  v3 = a2 - 1;
  while (*++v3)
    ;
  std::string::append[abi:ne180100]<char const*,0>(this, a2, v3);
  return this;
}

void sub_1B60EF620(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void AudioDSPManager::~AudioDSPManager(AudioDSPManager *this)
{
  vp::Context::~Context((AudioDSPManager *)((char *)this + 8));
}

{
  vp::Context::~Context((AudioDSPManager *)((char *)this + 8));
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AudioDSPManager::ImplementedInterfaceVersion(AudioDSPManager *this)
{
  return 1;
}

void AudioDSPManager::RegisterAudioUnits(AudioDSPManager *this, char a2)
{
  UInt32 v3;
  NSObject *global_queue;

  if ((a2 & 2) != 0)
  {
    if (CACFPreferencesGetAppBooleanValue(CFSTR("AllAUsPublic"), CFSTR("com.apple.coreaudio"), 0))
      v3 = 0;
    else
      v3 = 0x8000;
    RegisterInternalAudioUnits_iOS(v3);
  }
  if ((a2 & 1) != 0)
    RegisterPublicAudioUnits();
  global_queue = dispatch_get_global_queue(-32768, 0);
  dispatch_async(global_queue, &__block_literal_global_1);
}

_QWORD *AudioDSPManager::CreateVoiceProcessor(AudioDSPManager *this)
{
  char *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  unsigned int v11;
  uint64_t i;
  uint64_t v13;
  unsigned int v14;
  _QWORD *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  id v19;
  std::pmr *v20;
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *v22;
  __CFNotificationCenter *v23;
  __CFNotificationCenter *v24;
  __CFNotificationCenter *v25;
  __CFNotificationCenter *v26;
  uint64_t default_resource;
  CFPropertyListRef v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  CFPropertyListRef v33;
  unsigned int v34;
  unint64_t *v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  CFTypeRef v39;
  __int128 v40;
  __int128 v41;
  _QWORD *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  BOOL v54;
  __int128 v55;
  CFTypeRef v56;
  CFTypeRef v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  _BYTE buf[24];
  _BYTE *v63;
  void *v64[2];
  uint64_t v65;
  void *v66[2];
  uint64_t v67;
  void *v68[2];
  uint64_t v69;
  __int16 v70;
  void *__p[2];
  uint64_t v72;
  __int128 v73;
  _OWORD v74[2];
  CFTypeRef cf;
  char v76;
  __int128 v77;
  _QWORD v78[3];
  _QWORD *v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  if (_os_feature_enabled_impl())
    return (_QWORD *)VoiceProcessorCreate();
  v3 = (char *)this + 8;
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E69E2890;
  vp::Context::Context((uint64_t)(v4 + 1), (uint64_t)v3);
  v5 = operator new();
  *(_QWORD *)v5 = 2;
  CADeprecated::CAMutex::CAMutex((CADeprecated::CAMutex *)(v5 + 8), "stateMutex");
  *(_QWORD *)(v5 + 96) = 0;
  *(_QWORD *)(v5 + 104) = 0;
  *(_QWORD *)(v5 + 112) = 0;
  v6 = v5 + 120;
  CADeprecated::CAMutex::CAMutex((CADeprecated::CAMutex *)(v5 + 120), "vp data");
  *(_DWORD *)(v5 + 208) = 0;
  *(_DWORD *)(v5 + 212) = 0;
  v7 = (unsigned int *)(v5 + 208);
  if (VPStrategyMgrScope(void)::once != -1)
    dispatch_once(&VPStrategyMgrScope(void)::once, &__block_literal_global_18270);
  if (VPStrategyMgrScope(void)::scope)
  {
    if ((*(_BYTE *)(VPStrategyMgrScope(void)::scope + 8) & 1) != 0)
    {
      v8 = *(id *)VPStrategyMgrScope(void)::scope;
      if (v8)
      {
        v9 = v8;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "vpStrategyManager.mm";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 193;
          _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d ================", buf, 0x12u);
        }

      }
    }
  }
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v5 + 120);
  do
    v11 = __ldaxr(v7);
  while (__stlxr(v11 + 1, v7));
  while (*(_DWORD *)(v5 + 212))
    usleep(0x1F4u);
  v13 = *(_QWORD *)(v5 + 96);
  for (i = *(_QWORD *)(v5 + 104); i != v13; VPPropertyItem::~VPPropertyItem((VPPropertyItem *)(i - 48)))
    ;
  *(_QWORD *)(v5 + 104) = v13;
  do
    v14 = __ldaxr(v7);
  while (__stlxr(v14 - 1, v7));
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v5 + 120);
  *(_DWORD *)(v5 + 216) = -1082130432;
  *(_QWORD *)(v5 + 224) = 0;
  CADeprecated::CAMutex::CAMutex((CADeprecated::CAMutex *)(v5 + 232), "vpLock");
  *(_QWORD *)(v5 + 336) = 0;
  *(_QWORD *)(v5 + 344) = 0;
  *(_QWORD *)(v5 + 320) = 0;
  *(_QWORD *)(v5 + 328) = v5 + 336;
  v4[25] = v5;
  v15 = (_QWORD *)operator new();
  *v15 = &off_1E69E2A38;
  v15[1] = 0;
  v15[2] = 0;
  v15[3] = v5;
  v4[26] = v15;
  v4[27] = 0;
  if (VPStrategyMgrScope(void)::once != -1)
    dispatch_once(&VPStrategyMgrScope(void)::once, &__block_literal_global_18270);
  if (VPStrategyMgrScope(void)::scope)
  {
    if ((*(_BYTE *)(VPStrategyMgrScope(void)::scope + 8) & 1) != 0)
    {
      v16 = *(id *)VPStrategyMgrScope(void)::scope;
      if (v16)
      {
        v17 = v16;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "vpStrategyManager.mm";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 136;
          _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_DEBUG, "%25s:%-5d ================", buf, 0x12u);
        }

      }
    }
  }
  if (VPStrategyMgrScope(void)::once != -1)
    dispatch_once(&VPStrategyMgrScope(void)::once, &__block_literal_global_18270);
  if (VPStrategyMgrScope(void)::scope)
  {
    v18 = *(id *)VPStrategyMgrScope(void)::scope;
    if (!v18)
      goto LABEL_40;
  }
  else
  {
    v18 = MEMORY[0x1E0C81028];
    v19 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "vpStrategyManager.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 137;
    _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "%25s:%-5d created VPStrategyManager", buf, 0x12u);
  }

LABEL_40:
  v20 = (std::pmr *)_os_feature_enabled_impl();
  if ((_DWORD)v20)
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(DarwinNotifyCenter, v4, (CFNotificationCallback)DefaultDuckingCallBack, CFSTR("AUVoiceIODuckingLevelDefault"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    v22 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(v22, v4, (CFNotificationCallback)MinDuckingLevelCallBack, CFSTR("AUVoiceIODuckingLevelMin"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    v23 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(v23, v4, (CFNotificationCallback)MidDuckingLevelCallBack, CFSTR("AUVoiceIODuckingLevelMid"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    v24 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(v24, v4, (CFNotificationCallback)MaxDuckingLevelCallBack, CFSTR("AUVoiceIODuckingLevelMax"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    v25 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(v25, v4, (CFNotificationCallback)EnableAdvancedDuckingCallBack, CFSTR("AUVoiceIOEnableAdvancedDucking"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    v26 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(v26, v4, (CFNotificationCallback)DisableAdvancedDuckingCallBack, CFSTR("AUVoiceIODisableAdvancedDucking"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  v61 = v4;
  if (queryBuildType(void)::once != -1)
    dispatch_once(&queryBuildType(void)::once, &__block_literal_global_67);
  if (!gIsInternal)
    return v4;
  default_resource = std::pmr::get_default_resource(v20);
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v28 = CFPreferencesCopyAppValue(CFSTR("vp_enable_debug_features"), CFSTR("com.apple.coreaudio"));
  v57 = v28;
  if (v28)
  {
    v29 = applesauce::CF::convert_as<unsigned int,0>((const __CFNumber *)v28);
    if ((v29 & 0xFF00000000) != 0 && v29 == 1)
    {
      *(_QWORD *)buf = &off_1E69C4E58;
      *(_QWORD *)&buf[8] = &v58;
      v63 = buf;
      vp::Decorator_Assembler_Template<VoiceProcessorBase>::add_decorator(&v58, (uint64_t)buf);
      v31 = v63;
      if (v63 == buf)
      {
        v32 = 4;
        v31 = buf;
        goto LABEL_52;
      }
      if (v63)
      {
        v32 = 5;
LABEL_52:
        (*(void (**)(_QWORD *, uint64_t))(*v31 + 8 * v32))(v31, v30);
      }
    }
  }
  v33 = CFPreferencesCopyAppValue(CFSTR("vp_enable_cpu_profiler"), CFSTR("com.apple.coreaudio"));
  v56 = v33;
  if (!v33)
    goto LABEL_88;
  v34 = (unsigned __int16)applesauce::CF::convert_as<BOOL,0>((const __CFBoolean *)v33);
  if (v34 <= 0x100)
    LOBYTE(v34) = 0;
  if (!(_BYTE)v34)
    goto LABEL_88;
  vp::create_shared_messenger(default_resource, (uint64_t *)&v55);
  *(_QWORD *)buf = &v58;
  vp::Context::Context((uint64_t)&buf[8], (uint64_t)v3);
  v77 = v55;
  if (*((_QWORD *)&v55 + 1))
  {
    v35 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }
  v37 = (char *)operator new(0xE8uLL);
  v38 = *(_QWORD *)buf;
  *(_QWORD *)v37 = &off_1E69C4EA0;
  *((_QWORD *)v37 + 1) = v38;
  *((_DWORD *)v37 + 4) = *(_DWORD *)&buf[8];
  *((_QWORD *)v37 + 3) = *(_QWORD *)&buf[16];
  *((_WORD *)v37 + 16) = (_WORD)v63;
  *((_QWORD *)v37 + 7) = v65;
  *((_QWORD *)v37 + 10) = v67;
  *((_QWORD *)v37 + 13) = v69;
  *((_WORD *)v37 + 56) = v70;
  v39 = cf;
  *((_QWORD *)v37 + 17) = v72;
  *(_OWORD *)(v37 + 40) = *(_OWORD *)v64;
  *(_QWORD *)&buf[16] = 0;
  v64[0] = 0;
  v64[1] = 0;
  *((_OWORD *)v37 + 4) = *(_OWORD *)v66;
  v66[1] = 0;
  v67 = 0;
  v65 = 0;
  v66[0] = 0;
  *(_OWORD *)(v37 + 88) = *(_OWORD *)v68;
  v68[0] = 0;
  v68[1] = 0;
  v69 = 0;
  *(_OWORD *)(v37 + 120) = *(_OWORD *)__p;
  __p[0] = 0;
  __p[1] = 0;
  v40 = v73;
  v41 = v74[0];
  *(_OWORD *)(v37 + 169) = *(_OWORD *)((char *)v74 + 9);
  *((_OWORD *)v37 + 9) = v40;
  *((_OWORD *)v37 + 10) = v41;
  *((_QWORD *)v37 + 24) = v39;
  v72 = 0;
  cf = 0;
  v37[200] = v76;
  *(_OWORD *)(v37 + 216) = v77;
  v77 = 0uLL;
  v79 = v37;
  vp::Decorator_Assembler_Template<VoiceProcessorBase>::add_decorator(&v58, (uint64_t)v78);
  v42 = v79;
  if (v79 == v78)
  {
    v43 = 4;
    v42 = v78;
  }
  else
  {
    if (!v79)
      goto LABEL_65;
    v43 = 5;
  }
  (*(void (**)(_QWORD *))(*v42 + 8 * v43))(v42);
LABEL_65:
  v44 = (std::__shared_weak_count *)*((_QWORD *)&v77 + 1);
  if (*((_QWORD *)&v77 + 1))
  {
    v45 = (unint64_t *)(*((_QWORD *)&v77 + 1) + 8);
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
  if (cf)
    CFRelease(cf);
  if (SHIBYTE(v72) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v69) < 0)
    operator delete(v68[0]);
  if (SHIBYTE(v67) < 0)
    operator delete(v66[0]);
  if (SHIBYTE(v65) < 0)
    operator delete(v64[0]);
  if (*(_QWORD *)&buf[16])
    CFRelease(*(CFTypeRef *)&buf[16]);
  v47 = (std::__shared_weak_count *)*((_QWORD *)&v55 + 1);
  if (*((_QWORD *)&v55 + 1))
  {
    v48 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
    do
      v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
  v4 = v61;
LABEL_88:
  v61 = 0;
  v50 = v59;
  if (v58 != v59)
  {
    v51 = v58 + 32;
    do
    {
      v78[0] = v4;
      v52 = *(_QWORD *)(v51 - 8);
      if (!v52)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(_BYTE *__return_ptr, uint64_t, _QWORD *))(*(_QWORD *)v52 + 48))(buf, v52, v78);
      v4 = *(_QWORD **)buf;
      *(_QWORD *)buf = 0;
      v53 = v78[0];
      v78[0] = 0;
      if (v53)
        (*(void (**)(uint64_t))(*(_QWORD *)v53 + 8))(v53);
      if (!v4)
        break;
      v54 = v51 == v50;
      v51 += 32;
    }
    while (!v54);
  }
  if (v56)
    CFRelease(v56);
  if (v57)
    CFRelease(v57);
  *(_QWORD *)buf = &v58;
  std::vector<std::function<std::unique_ptr<VoiceProcessorBase> ()(std::unique_ptr<VoiceProcessorBase>)>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  return v4;
}

void sub_1B60EFFE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, vp::Context *a9, uint64_t a10, char a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t AudioDSPManager::GetVoiceProcessorVersion(AudioDSPManager *this)
{
  if (_os_feature_enabled_impl())
    return VoiceProcessorGetVersion();
  else
    return GetVoiceProcessorVersion((AudioDSPManager *)((char *)this + 8), 0, 0, 0, 0);
}

uint64_t AudioDSPManager::CreateVibeAnalyzer(AudioDSPManager *this, const __CFDictionary *a2)
{
  return 0;
}

uint64_t applesauce::CF::convert_as<BOOL,0>(const __CFBoolean *a1)
{
  CFTypeID TypeID;
  __int16 v3;
  int v4;
  CFTypeID v5;

  TypeID = CFBooleanGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    LOBYTE(v3) = CFBooleanGetValue(a1) != 0;
    v4 = 1;
  }
  else
  {
    v5 = CFNumberGetTypeID();
    if (v5 == CFGetTypeID(a1))
    {
      v3 = applesauce::CF::details::number_convert_as<BOOL>(a1);
      v4 = HIBYTE(v3);
    }
    else
    {
      LOBYTE(v3) = 0;
      v4 = 0;
    }
  }
  return v3 | (v4 << 8);
}

void std::vector<std::function<std::unique_ptr<VoiceProcessorBase> ()(std::unique_ptr<VoiceProcessorBase>)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (!v2)
    return;
  v4 = (char *)v1[1];
  v5 = **a1;
  if (v4 == v2)
    goto LABEL_10;
  do
  {
    v6 = v4 - 32;
    v7 = (char *)*((_QWORD *)v4 - 1);
    if (v4 - 32 == v7)
    {
      v7 = v4 - 32;
      v8 = 4;
    }
    else
    {
      if (!v7)
        goto LABEL_8;
      v8 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_8:
    v4 = v6;
  }
  while (v6 != v2);
  v5 = **a1;
LABEL_10:
  v1[1] = v2;
  operator delete(v5);
}

VPStrategyManager *std::unique_ptr<VPStrategyManager>::reset[abi:ne180100](VPStrategyManager **a1)
{
  VPStrategyManager *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    VPStrategyManager::~VPStrategyManager(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void vp::Decorator_Assembler_Template<VoiceProcessorBase>::add_decorator(uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  if (*(_QWORD *)(a2 + 24))
  {
    v4 = a1[1];
    v5 = a1[2];
    if (v4 < v5)
    {
      v6 = std::__function::__value_func<std::unique_ptr<VoiceProcessorBase> ()(std::unique_ptr<VoiceProcessorBase>)>::__value_func[abi:ne180100](v4, a2)+ 32;
LABEL_26:
      a1[1] = v6;
      return;
    }
    v7 = (uint64_t)(v4 - *a1) >> 5;
    if ((unint64_t)(v7 + 1) >> 59)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v8 = v5 - *a1;
    v9 = v8 >> 4;
    if (v8 >> 4 <= (unint64_t)(v7 + 1))
      v9 = v7 + 1;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0)
      v10 = 0x7FFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    if (v10)
    {
      if (v10 >> 59)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v11 = (char *)operator new(32 * v10);
    }
    else
    {
      v11 = 0;
    }
    v12 = &v11[32 * v10];
    v13 = std::__function::__value_func<std::unique_ptr<VoiceProcessorBase> ()(std::unique_ptr<VoiceProcessorBase>)>::__value_func[abi:ne180100]((uint64_t)&v11[32 * v7], a2);
    v6 = v13 + 32;
    v15 = (char *)*a1;
    v14 = (char *)a1[1];
    if (v14 == (char *)*a1)
    {
      *a1 = v13;
      a1[1] = v6;
      a1[2] = (uint64_t)v12;
      if (!v14)
        goto LABEL_26;
    }
    else
    {
      do
      {
        v14 -= 32;
        v13 = std::__function::__value_func<std::unique_ptr<VoiceProcessorBase> ()(std::unique_ptr<VoiceProcessorBase>)>::__value_func[abi:ne180100](v13 - 32, (uint64_t)v14);
      }
      while (v14 != v15);
      v16 = (char *)*a1;
      v14 = (char *)a1[1];
      *a1 = v13;
      a1[1] = v6;
      a1[2] = (uint64_t)v12;
      if (v14 != v16)
      {
        while (1)
        {
          v17 = v14 - 32;
          v18 = (char *)*((_QWORD *)v14 - 1);
          if (v14 - 32 == v18)
            break;
          if (v18)
          {
            v19 = 5;
LABEL_21:
            (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
          }
          v14 -= 32;
          if (v17 == v16)
          {
            v14 = v16;
            goto LABEL_24;
          }
        }
        v18 = v14 - 32;
        v19 = 4;
        goto LABEL_21;
      }
LABEL_24:
      if (!v14)
        goto LABEL_26;
    }
    operator delete(v14);
    goto LABEL_26;
  }
}

uint64_t std::__function::__value_func<std::unique_ptr<VoiceProcessorBase> ()(std::unique_ptr<VoiceProcessorBase>)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

_QWORD *_ZNSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators12CPU_ProfilerEJRKNS2_7ContextERNS2_27Decorator_Assembler_ProductERNS_10shared_ptrIN5caulk10concurrent9messengerEEEEEEvDpOT0_EUlT_E_NS_9allocatorISO_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESU_EED1Ev(_QWORD *a1)
{
  *a1 = &off_1E69C4EA0;
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 27));
  vp::Context::~Context((vp::Context *)(a1 + 2));
  return a1;
}

void _ZNSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators12CPU_ProfilerEJRKNS2_7ContextERNS2_27Decorator_Assembler_ProductERNS_10shared_ptrIN5caulk10concurrent9messengerEEEEEEvDpOT0_EUlT_E_NS_9allocatorISO_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESU_EED0Ev(_QWORD *a1)
{
  *a1 = &off_1E69C4EA0;
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 27));
  vp::Context::~Context((vp::Context *)(a1 + 2));
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *_ZNKSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators12CPU_ProfilerEJRKNS2_7ContextERNS2_27Decorator_Assembler_ProductERNS_10shared_ptrIN5caulk10concurrent9messengerEEEEEEvDpOT0_EUlT_E_NS_9allocatorISO_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESU_EE7__cloneEv(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v2 = operator new(0xE8uLL);
  v3 = a1[1];
  *v2 = &off_1E69C4EA0;
  v2[1] = v3;
  vp::Context::Context((uint64_t)(v2 + 2), (uint64_t)(a1 + 2));
  v4 = a1[28];
  v2[27] = a1[27];
  v2[28] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return v2;
}

void sub_1B60F0638(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators12CPU_ProfilerEJRKNS2_7ContextERNS2_27Decorator_Assembler_ProductERNS_10shared_ptrIN5caulk10concurrent9messengerEEEEEEvDpOT0_EUlT_E_NS_9allocatorISO_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESU_EE7__cloneEPNS0_6__baseISV_EE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v4 = a1[1];
  *a2 = &off_1E69C4EA0;
  a2[1] = v4;
  result = vp::Context::Context((uint64_t)(a2 + 2), (uint64_t)(a1 + 2));
  v6 = a1[28];
  a2[27] = a1[27];
  a2[28] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  return result;
}

void _ZNSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators12CPU_ProfilerEJRKNS2_7ContextERNS2_27Decorator_Assembler_ProductERNS_10shared_ptrIN5caulk10concurrent9messengerEEEEEEvDpOT0_EUlT_E_NS_9allocatorISO_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESU_EE7destroyEv(uint64_t a1)
{
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](a1 + 216);
  vp::Context::~Context((vp::Context *)(a1 + 16));
}

void _ZNSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators12CPU_ProfilerEJRKNS2_7ContextERNS2_27Decorator_Assembler_ProductERNS_10shared_ptrIN5caulk10concurrent9messengerEEEEEEvDpOT0_EUlT_E_NS_9allocatorISO_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESU_EE18destroy_deallocateEv(uint64_t a1)
{
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](a1 + 216);
  vp::Context::~Context((vp::Context *)(a1 + 16));
  operator delete((void *)a1);
}

void _ZNSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators12CPU_ProfilerEJRKNS2_7ContextERNS2_27Decorator_Assembler_ProductERNS_10shared_ptrIN5caulk10concurrent9messengerEEEEEEvDpOT0_EUlT_E_NS_9allocatorISO_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESU_EEclEOSU_(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5;
  __int128 v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v14;
  _BYTE v15[8];
  CFTypeRef v16;
  void *v17;
  char v18;
  void *v19;
  char v20;
  void *v21;
  char v22;
  void *__p;
  char v24;
  CFTypeRef cf;
  __int128 v26;
  uint64_t v27;

  v5 = *a2;
  *a2 = 0;
  vp::Context::Context((uint64_t)v15, a1 + 16);
  v6 = *(_OWORD *)(a1 + 216);
  v14 = v6;
  if (*((_QWORD *)&v6 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v6 + 1) + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = operator new();
  v27 = v5;
  v26 = v14;
  vp::decorators::CPU_Profiler::CPU_Profiler(v9, v15, &v27, &v26);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
  if (*((_QWORD *)&v26 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v27;
  v27 = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  if (cf)
    CFRelease(cf);
  if (v24 < 0)
    operator delete(__p);
  if (v22 < 0)
    operator delete(v21);
  if (v20 < 0)
    operator delete(v19);
  if (v18 < 0)
    operator delete(v17);
  if (v16)
    CFRelease(v16);
  *a3 = v9;
}

void sub_1B60F0854(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, CFTypeRef a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,CFTypeRef cf)
{
  uint64_t v44;
  uint64_t v45;
  std::__shared_weak_count *v47;
  unint64_t *p_shared_owners;
  unint64_t v49;
  uint64_t v50;

  v47 = *(std::__shared_weak_count **)(v45 - 56);
  if (v47)
  {
    p_shared_owners = (unint64_t *)&v47->__shared_owners_;
    do
      v49 = __ldaxr(p_shared_owners);
    while (__stlxr(v49 - 1, p_shared_owners));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
  v50 = *(_QWORD *)(v45 - 40);
  *(_QWORD *)(v45 - 40) = 0;
  if (v50)
    (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
  MEMORY[0x1BCC95CEC](v44, 0x10A1C40319A4EC9);
  if (cf)
    CFRelease(cf);
  if (a37 < 0)
    operator delete(__p);
  if (a30 < 0)
    operator delete(a25);
  if (a24 < 0)
    operator delete(a19);
  if (a18 < 0)
    operator delete(a13);
  if (a11)
    CFRelease(a11);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators17Xcode_InstrumentsEJRNS2_27Decorator_Assembler_ProductEEEEvDpOT0_EUlT_E_NS_9allocatorISF_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESL_EED0Ev()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 _ZNKSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators17Xcode_InstrumentsEJRNS2_27Decorator_Assembler_ProductEEEEvDpOT0_EUlT_E_NS_9allocatorISF_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESL_EE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69C4E58;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators17Xcode_InstrumentsEJRNS2_27Decorator_Assembler_ProductEEEEvDpOT0_EUlT_E_NS_9allocatorISF_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESL_EE7__cloneEPNS0_6__baseISM_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69C4E58;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2vp28Decorator_Assembler_TemplateI18VoiceProcessorBaseE13add_decoratorINS2_10decorators17Xcode_InstrumentsEJRNS2_27Decorator_Assembler_ProductEEEEvDpOT0_EUlT_E_NS_9allocatorISF_EEFNS_10unique_ptrIS4_NS_14default_deleteIS4_EEEESL_EEclEOSL_@<X0>(uint64_t *a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;

  v3 = *a1;
  *a1 = 0;
  v4 = operator new();
  v6 = v3;
  vp::decorators::Xcode_Instruments::Xcode_Instruments(v4, &v6);
  result = v6;
  v6 = 0;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  *a2 = v4;
  return result;
}

void sub_1B60F0A90(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void ___ZN15AudioDSPManager18RegisterAudioUnitsEj_block_invoke()
{
  const char *v0;
  int v1;
  caulk::platform *v2;
  int v3;
  size_t size;
  uint64_t v5;
  void *v6;
  std::string *v7;
  void *v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  const std::__fs::filesystem::directory_entry *v12;
  _BOOL4 v13;
  std::string *p_pn;
  unint64_t v15;
  ssize_t v16;
  int *v17;
  std::string::size_type v18;
  std::runtime_error *v19;
  _OWORD *v20;
  unint64_t v21;
  char v22;
  unsigned int v23;
  char v24;
  char v25;
  char *v26;
  std::string::size_type v27;
  void *v28;
  size_t v29;
  std::string *v30;
  std::string *v31;
  std::__shared_weak_count *cntrl;
  uint64_t *p_shared_owners;
  unint64_t v34;
  std::string::size_type v35;
  std::runtime_error *v36;
  char v37;
  void *__p;
  __int128 v39;
  std::__fs::filesystem::path __from;
  std::string pn;
  std::__fs::filesystem::recursive_directory_iterator v42;
  std::__fs::filesystem::path v43;
  __int128 v44;
  std::__fs::filesystem::path v45;
  std::string v46;
  char *v47;
  unsigned __int8 v48;
  std::string buf;
  __int128 v50;
  __int128 v51;
  std::__fs::filesystem::path __base;
  std::string v53;
  uint64_t v54;
  std::__fs::filesystem::path::__string_view v55;

  v54 = *MEMORY[0x1E0C80C00];
  v0 = "audiomxd";
  v1 = _os_feature_enabled_impl();
  if (!v1)
    v0 = "mediaserverd";
  v2 = (caulk::platform *)getpid();
  caulk::platform::process_name(v2);
  v3 = SHIBYTE(v53.__r_.__value_.__r.__words[2]);
  if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  else
    size = v53.__r_.__value_.__l.__size_;
  v5 = 12;
  if (v1)
    v5 = 8;
  if (size != v5
    || ((v6 = (void *)v53.__r_.__value_.__r.__words[0], (v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      ? (v7 = &v53)
      : (v7 = (std::string *)v53.__r_.__value_.__r.__words[0]),
        memcmp(v7, v0, size)))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "cannot migrate AudioUnit assets for current process", (uint8_t *)&buf, 2u);
      LOBYTE(v3) = *((_BYTE *)&v53.__r_.__value_.__s + 23);
    }
    if ((v3 & 0x80) != 0)
    {
      v8 = (void *)v53.__r_.__value_.__r.__words[0];
      goto LABEL_17;
    }
    return;
  }
  if (v3 < 0)
    operator delete(v6);
  v47 = getenv("TMPDIR");
  if (!v47)
    return;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v53.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "start migrating AudioUnit assets", (uint8_t *)&v53, 2u);
  }
  std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v46, &v47);
  std::__fs::filesystem::path::path[abi:ne180100]<char [6],void>(&v53, "Cache");
  std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&v53, (uint64_t)&v46, &v45);
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v53.__r_.__value_.__l.__data_);
  v9 = open("/dev/urandom", 0x1000000);
  if ((_DWORD)v9 == -1)
  {
    v35 = *__error();
    std::string::basic_string[abi:ne180100]<0>(&buf, "open /dev/urandom");
    v36 = std::runtime_error::runtime_error((std::runtime_error *)&v53, &buf);
    v53.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E69D5620;
    v53.__r_.__value_.__r.__words[2] = v35;
    __base.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)"/AppleInternal/Library/BuildRoots/c7268dd4-5656-"
                                                                        "11ef-b8ac-76625042721f/Applications/Xcode.app/Co"
                                                                        "ntents/Developer/Platforms/iPhoneOS.platform/Dev"
                                                                        "eloper/SDKs/iPhoneOS18.0.Internal.sdk/usr/local/"
                                                                        "include/boost/uuid/detail/random_provider_posix.ipp";
    __base.__pn_.__r_.__value_.__l.__size_ = (std::string::size_type)"boost::uuids::detail::random_provider_base::random_provider_base()";
    __base.__pn_.__r_.__value_.__r.__words[2] = 60;
    boost::throw_exception<boost::uuids::entropy_error>(v36, (int8x16_t *)&__base);
  }
  v10 = 0;
  v11 = 0;
  v44 = xmmword_1E69D5520;
  do
  {
    v37 = v10;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v43.__pn_, (char **)&v44 + v11);
    std::__fs::filesystem::__status(&v43, 0);
    if (!v53.__r_.__value_.__s.__data_[0] || v53.__r_.__value_.__s.__data_[0] == 255)
      goto LABEL_93;
    MEMORY[0x1BCC95A34](&v42, &v43, 0, 0);
    while (v42.__imp_.__ptr_)
    {
      v12 = std::__fs::filesystem::recursive_directory_iterator::__dereference(&v42);
      std::__fs::filesystem::path::extension[abi:ne180100](&v12->__p_, (uint64_t)&v53);
      std::__fs::filesystem::path::path[abi:ne180100]<char [12],void>(&__base.__pn_, ".mil");
      v55.__data_ = (const std::string_view::value_type *)&__base;
      v13 = std::__fs::filesystem::operator==[abi:ne180100]((const std::__fs::filesystem::path *)&v53, v55);
      if (SHIBYTE(__base.__pn_.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__base.__pn_.__r_.__value_.__l.__data_);
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v53.__r_.__value_.__l.__data_);
        if (!v13)
          goto LABEL_84;
      }
      else if (!v13)
      {
        goto LABEL_84;
      }
      if (SHIBYTE(v45.__pn_.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&pn, v45.__pn_.__r_.__value_.__l.__data_, v45.__pn_.__r_.__value_.__l.__size_);
      else
        pn = v45.__pn_;
      std::__fs::filesystem::path::path[abi:ne180100]<char [2],void>(&__base.__pn_, "/");
      std::__fs::filesystem::path::lexically_relative((std::__fs::filesystem::path *)&v53, &v12->__p_, &__base);
      std::__fs::filesystem::path::operator/=[abi:ne180100]((std::__fs::filesystem::path *)&pn, (std::__fs::filesystem::path *)&v53);
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v53.__r_.__value_.__l.__data_);
      if (SHIBYTE(__base.__pn_.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__base.__pn_.__r_.__value_.__l.__data_);
      std::__fs::filesystem::path::path[abi:ne180100]<char [12],void>(&v53, ".ir");
      std::__fs::filesystem::path::replace_extension((std::__fs::filesystem::path *)&pn, (const std::__fs::filesystem::path *)&v53);
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v53.__r_.__value_.__l.__data_);
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        p_pn = &pn;
        if ((pn.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          p_pn = (std::string *)pn.__r_.__value_.__r.__words[0];
        LODWORD(v53.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_pn;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "compiling \"%s\"", (uint8_t *)&v53, 0xCu);
      }
      std::__fs::filesystem::path::parent_path[abi:ne180100]((const std::__fs::filesystem::path *)&pn, (uint64_t)&__from);
      std::__fs::filesystem::__create_directories(&__from, 0);
      v15 = 0;
      do
      {
        v16 = read(v9, (char *)&v51 + v15, 16 - v15);
        if (v16 < 0)
        {
          v17 = __error();
          if (*v17 != 4)
          {
            v18 = *v17;
            std::string::basic_string[abi:ne180100]<0>(&buf, "read");
            v19 = std::runtime_error::runtime_error((std::runtime_error *)&v53, &buf);
            v53.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E69D5620;
            v53.__r_.__value_.__r.__words[2] = v18;
            __base.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)"/AppleInternal/Library/BuildRoots/c7268d"
                                                                                "d4-5656-11ef-b8ac-76625042721f/Applicati"
                                                                                "ons/Xcode.app/Contents/Developer/Platfor"
                                                                                "ms/iPhoneOS.platform/Developer/SDKs/iPho"
                                                                                "neOS18.0.Internal.sdk/usr/local/include/"
                                                                                "boost/uuid/detail/random_provider_posix.ipp";
            __base.__pn_.__r_.__value_.__l.__size_ = (std::string::size_type)"void boost::uuids::detail::random_provider_"
                                                                             "base::get_random_bytes(void *, std::size_t)";
            __base.__pn_.__r_.__value_.__r.__words[2] = 98;
            boost::throw_exception<boost::uuids::entropy_error>(v19, (int8x16_t *)&__base);
          }
        }
        else
        {
          v15 += v16;
        }
      }
      while (v15 < 0x10);
      BYTE8(v51) = BYTE8(v51) & 0x3F | 0x80;
      BYTE6(v51) = BYTE6(v51) & 0xF | 0x40;
      v50 = v51;
      v20 = operator new(0x28uLL);
      v21 = 0;
      __p = v20;
      v39 = xmmword_1B66A04D0;
      *v20 = 0u;
      v20[1] = 0u;
      *(_QWORD *)((char *)v20 + 29) = 0;
      do
      {
        if (*((unsigned __int8 *)&v50 + v21) >= 0xA0u)
          v22 = 87;
        else
          v22 = 48;
        *(_BYTE *)v20 = v22 + (*((_BYTE *)&v50 + v21) >> 4);
        v23 = *((_BYTE *)&v50 + v21) & 0xF;
        if (v23 >= 0xA)
          v24 = 87;
        else
          v24 = 48;
        v25 = v24 + v23;
        v26 = (char *)v20 + 2;
        *((_BYTE *)v20 + 1) = v25;
        if (v21 <= 9 && ((1 << v21) & 0x2A8) != 0)
        {
          v26 = (char *)v20 + 3;
          *((_BYTE *)v20 + 2) = 45;
        }
        ++v21;
        v20 = v26;
      }
      while (v21 != 16);
      std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&__from.__pn_, (uint64_t)&__p);
      if (SHIBYTE(v39) < 0)
        operator delete(__p);
      *(_OWORD *)&v53.__r_.__value_.__l.__data_ = 0uLL;
      v53.__r_.__value_.__r.__words[0] = BNNSGraphCompileOptionsMakeDefault();
      v53.__r_.__value_.__l.__size_ = v27;
      __p = &v53;
      BNNSGraphCompileOptionsSetTargetSingleThread();
      BNNSGraphCompileOptionsSetOptimizationPreference();
      BNNSGraphCompileOptionsSetOutputPath();
      v28 = (void *)BNNSGraphCompileFromFile_v2();
      if (v28 && v29)
      {
        munmap(v28, v29);
        std::__fs::filesystem::__rename(&__from, (const std::__fs::filesystem::path *)&pn, 0);
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          v30 = &pn;
          if ((pn.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v30 = (std::string *)pn.__r_.__value_.__r.__words[0];
          LODWORD(__base.__pn_.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)__base.__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
          _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "compiled \"%s\"", (uint8_t *)&__base, 0xCu);
        }
      }
      else
      {
        std::__fs::filesystem::__status(&__from, 0);
        if (v48 && v48 != 255)
          std::__fs::filesystem::__remove(&__from, 0);
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          v31 = &pn;
          if ((pn.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v31 = (std::string *)pn.__r_.__value_.__r.__words[0];
          LODWORD(__base.__pn_.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)__base.__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)v31;
          _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "failed to compile \"%s\"", (uint8_t *)&__base, 0xCu);
        }
      }
      applesauce::raii::v1::detail::ScopeGuard<MigrateAudioUnitAssets::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard((uint64_t)&__p);
      if (SHIBYTE(__from.__pn_.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__from.__pn_.__r_.__value_.__l.__data_);
      if (SHIBYTE(pn.__r_.__value_.__r.__words[2]) < 0)
        operator delete(pn.__r_.__value_.__l.__data_);
LABEL_84:
      std::__fs::filesystem::recursive_directory_iterator::__increment(&v42, 0);
    }
    cntrl = v42.__imp_.__cntrl_;
    if (v42.__imp_.__cntrl_)
    {
      p_shared_owners = &v42.__imp_.__cntrl_->__shared_owners_;
      do
        v34 = __ldaxr((unint64_t *)p_shared_owners);
      while (__stlxr(v34 - 1, (unint64_t *)p_shared_owners));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))cntrl->__on_zero_shared)(cntrl);
        std::__shared_weak_count::__release_weak(cntrl);
      }
    }
LABEL_93:
    if (SHIBYTE(v43.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v43.__pn_.__r_.__value_.__l.__data_);
    v10 = 1;
    v11 = 1;
  }
  while ((v37 & 1) == 0);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v53.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "stop migrating AudioUnit assets", (uint8_t *)&v53, 2u);
  }
  boost::uuids::detail::random_provider_base::destroy(v9);
  if (SHIBYTE(v45.__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v45.__pn_.__r_.__value_.__l.__data_);
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
  {
    v8 = (void *)v46.__r_.__value_.__r.__words[0];
LABEL_17:
    operator delete(v8);
  }
}

void sub_1B60F1494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  uint64_t v47;
  uint64_t v48;
  unint64_t *p_shared_owners;
  unint64_t v51;

  if (a2)
  {
    __cxa_end_catch();
    if (a26)
    {
      p_shared_owners = (unint64_t *)&a26->__shared_owners_;
      do
        v51 = __ldaxr(p_shared_owners);
      while (__stlxr(v51 - 1, p_shared_owners));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))a26->__on_zero_shared)(a26);
        std::__shared_weak_count::__release_weak(a26);
      }
    }
    if (a33 < 0)
      operator delete(__p);
    boost::uuids::detail::random_provider_base::destroy(v47);
    if (a41 < 0)
      operator delete(a36);
    if (a47 < 0)
      operator delete(a42);
    __cxa_begin_catch(a1);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)(v48 - 176) = 0;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "failed to migrate AudioUnit assets due to uncaught exception", (uint8_t *)(v48 - 176), 2u);
    }
    __cxa_end_catch();
    JUMPOUT(0x1B60F0BB4);
  }
  _Unwind_Resume(a1);
}

uint64_t CircularModelDOA::UpdateKappa(float **this, float a2)
{
  float __A;

  __A = a2;
  vDSP_vfill(&__A, this[3], 1, *((unsigned int *)this + 2));
  return (*(uint64_t (**)(float **, float))*this)(this, __A);
}

void CircularModelDOA::UpdateKappa(uint64_t a1, uint64_t a2)
{
  const void *v4;
  int64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = *(const void **)a2;
  v6 = *(_QWORD *)(a2 + 8) - (_QWORD)v4;
  if (*(_DWORD *)(a1 + 8) == v6 >> 2)
  {
    memcpy(*(void **)(a1 + 24), v4, v6);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, a2);
    return;
  }
  if (AUSpatialProbabilityLogScope(void)::once != -1)
    dispatch_once(&AUSpatialProbabilityLogScope(void)::once, &__block_literal_global_5486);
  if (AUSpatialProbabilityLogScope(void)::scope)
  {
    v7 = *(NSObject **)AUSpatialProbabilityLogScope(void)::scope;
    if (!*(_QWORD *)AUSpatialProbabilityLogScope(void)::scope)
      return;
  }
  else
  {
    v7 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2;
    v9 = *(_DWORD *)(a1 + 8);
    v10 = 136315906;
    v11 = "CircularModels.cpp";
    v12 = 1024;
    v13 = 187;
    v14 = 2048;
    v15 = v8;
    v16 = 1024;
    v17 = v9;
    _os_log_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_DEFAULT, "%25s:%-5d CircularModels: Kappa not set. Input length (%lu) and internal length (%u) do not match.\n", (uint8_t *)&v10, 0x22u);
  }
}

void VonMisesModelDOA::UpdateNormConst(VonMisesModelDOA *this, float a2)
{
  float v3;
  float __A;

  v3 = *((float *)this + 21);
  __A = a2 / (float)(v3 * sinhf(a2));
  vDSP_vfill(&__A, *((float **)this + 6), 1, *((unsigned int *)this + 2));
}

void VonMisesModelDOA::UpdateNormConst(uint64_t a1, const float **a2)
{
  vvsinhf(*(float **)(a1 + 48), *a2, (const int *)(a1 + 72));
  vDSP_vsmul(*(const float **)(a1 + 48), 1, (const float *)(a1 + 84), *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
  vDSP_svdiv((const float *)(a1 + 76), *(const float **)(a1 + 48), 1, *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
  vDSP_vmul(*(const float **)(a1 + 48), 1, *a2, 1, *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
}

void VonMisesModelDOA::~VonMisesModelDOA(VonMisesModelDOA *this)
{
  CircularModelDOA::~CircularModelDOA(this);
  JUMPOUT(0x1BCC95CECLL);
}

void VonMisesModelDOA::GetValue(uint64_t a1, const float **a2, const float **a3, float **a4)
{
  uint64_t v6;
  float *v7;
  float *v8;

  CircularModelDOA::innerProductTargetTimesSubbandDOA(a1, a2, a3, a4);
  vDSP_vmul(*a4, 1, *(const float **)(a1 + 24), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  vvexpf(*a4, *a4, (const int *)(a1 + 72));
  vDSP_vmul(*a4, 1, *(const float **)(a1 + 48), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  v6 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v6)
  {
    v7 = *(float **)(a1 + 24);
    v8 = *a4;
    do
    {
      if (*v7 < 1.0e-15)
        *v8 = *(float *)(a1 + 88);
      ++v8;
      ++v7;
      --v6;
    }
    while (v6);
  }
}

void CircularModelDOA::innerProductTargetTimesSubbandDOA(uint64_t a1, const float **a2, const float **a3, float **a4)
{
  float v8;
  float v9;
  float v10;
  float v11;
  float __B;

  vDSP_vclr(*a4, 1, *(unsigned int *)(a1 + 8));
  vDSP_vsmul(*a2, 1, (const float *)(a1 + 92), *(float **)(a1 + 192), 1, *(unsigned int *)(a1 + 8));
  vvsincosf(*(float **)(a1 + 120), *(float **)(a1 + 96), *(const float **)(a1 + 192), (const int *)(a1 + 72));
  vDSP_vsmul(*a3, 1, (const float *)(a1 + 92), *(float **)(a1 + 192), 1, *(unsigned int *)(a1 + 8));
  vvsincosf(*(float **)(a1 + 168), *(float **)(a1 + 144), *(const float **)(a1 + 192), (const int *)(a1 + 72));
  v8 = *(float *)(a1 + 92);
  v9 = cosf(*(float *)(a1 + 12) * v8);
  __B = v9 * cosf(v8 * *(float *)(a1 + 16));
  vDSP_vmul(*(const float **)(a1 + 96), 1, *(const float **)(a1 + 144), 1, *(float **)(a1 + 192), 1, *(unsigned int *)(a1 + 8));
  vDSP_vsmul(*(const float **)(a1 + 192), 1, &__B, *(float **)(a1 + 192), 1, *(unsigned int *)(a1 + 8));
  vDSP_vadd(*(const float **)(a1 + 192), 1, *a4, 1, *a4, 1, *(unsigned int *)(a1 + 8));
  v10 = *(float *)(a1 + 92);
  v11 = sinf(*(float *)(a1 + 12) * v10);
  __B = v11 * cosf(v10 * *(float *)(a1 + 16));
  vDSP_vmul(*(const float **)(a1 + 120), 1, *(const float **)(a1 + 144), 1, *(float **)(a1 + 192), 1, *(unsigned int *)(a1 + 8));
  vDSP_vsmul(*(const float **)(a1 + 192), 1, &__B, *(float **)(a1 + 192), 1, *(unsigned int *)(a1 + 8));
  vDSP_vadd(*(const float **)(a1 + 192), 1, *a4, 1, *a4, 1, *(unsigned int *)(a1 + 8));
  __B = sinf(*(float *)(a1 + 16) * *(float *)(a1 + 92));
  vDSP_vsmul(*(const float **)(a1 + 168), 1, &__B, *(float **)(a1 + 192), 1, *(unsigned int *)(a1 + 8));
  vDSP_vadd(*(const float **)(a1 + 192), 1, *a4, 1, *a4, 1, *(unsigned int *)(a1 + 8));
}

void CircularModelDOA::~CircularModelDOA(CircularModelDOA *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  *(_QWORD *)this = &unk_1E69D88C0;
  v2 = (void *)*((_QWORD *)this + 24);
  if (v2)
  {
    *((_QWORD *)this + 25) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 21);
  if (v3)
  {
    *((_QWORD *)this + 22) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 18);
  if (v4)
  {
    *((_QWORD *)this + 19) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 15);
  if (v5)
  {
    *((_QWORD *)this + 16) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 12);
  if (v6)
  {
    *((_QWORD *)this + 13) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 6);
  if (v7)
  {
    *((_QWORD *)this + 7) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 3);
  if (v8)
  {
    *((_QWORD *)this + 4) = v8;
    operator delete(v8);
  }
}

void ComplementVonMisesModelDOA::UpdateNormConst(ComplementVonMisesModelDOA *this, float a2)
{
  float v4;
  float v5;
  float __A;

  v4 = *((float *)this + 21);
  v5 = expf(a2);
  __A = a2 / (float)(v4 * (float)-(float)(sinhf(a2) - (float)(a2 * v5)));
  vDSP_vfill(&__A, *((float **)this + 6), 1, *((unsigned int *)this + 2));
}

void ComplementVonMisesModelDOA::UpdateNormConst(uint64_t a1, const float **a2)
{
  vvexpf(*(float **)(a1 + 216), *a2, (const int *)(a1 + 72));
  vDSP_vmul(*(const float **)(a1 + 216), 1, *a2, 1, *(float **)(a1 + 216), 1, *(unsigned int *)(a1 + 8));
  vvsinhf(*(float **)(a1 + 48), *a2, (const int *)(a1 + 72));
  vDSP_vsub(*(const float **)(a1 + 48), 1, *(const float **)(a1 + 216), 1, *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
  vDSP_vsmul(*(const float **)(a1 + 48), 1, (const float *)(a1 + 84), *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
  vDSP_svdiv((const float *)(a1 + 76), *(const float **)(a1 + 48), 1, *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
  vDSP_vmul(*(const float **)(a1 + 48), 1, *a2, 1, *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
}

void ComplementVonMisesModelDOA::~ComplementVonMisesModelDOA(ComplementVonMisesModelDOA *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E69D8950;
  v2 = (void *)*((_QWORD *)this + 27);
  if (v2)
  {
    *((_QWORD *)this + 28) = v2;
    operator delete(v2);
  }
  CircularModelDOA::~CircularModelDOA(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E69D8950;
  v2 = (void *)*((_QWORD *)this + 27);
  if (v2)
  {
    *((_QWORD *)this + 28) = v2;
    operator delete(v2);
  }
  CircularModelDOA::~CircularModelDOA(this);
  JUMPOUT(0x1BCC95CECLL);
}

void ComplementVonMisesModelDOA::GetValue(uint64_t a1, const float **a2, const float **a3, float **a4)
{
  uint64_t v6;
  float *v7;
  float *v8;

  CircularModelDOA::innerProductTargetTimesSubbandDOA(a1, a2, a3, a4);
  vvexpf(*(float **)(a1 + 216), *(const float **)(a1 + 24), (const int *)(a1 + 72));
  vDSP_vmul(*a4, 1, *(const float **)(a1 + 24), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  vvexpf(*a4, *a4, (const int *)(a1 + 72));
  vDSP_vsub(*a4, 1, *(const float **)(a1 + 216), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  vDSP_vmul(*a4, 1, *(const float **)(a1 + 48), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  v6 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v6)
  {
    v7 = *(float **)(a1 + 24);
    v8 = *a4;
    do
    {
      if (*v7 < 1.0e-15)
        *v8 = *(float *)(a1 + 88);
      ++v8;
      ++v7;
      --v6;
    }
    while (v6);
  }
}

float WatsonModelDOA::UpdateNormConst(WatsonModelDOA *this, float a2, double a3, double a4, float a5)
{
  float v6;
  float result;
  float __A;

  KummerFirstKind(*((float *)this + 54), *((float *)this + 55), a2, a5);
  __A = *((float *)this + 19) / (float)(v6 * *((float *)this + 21));
  vDSP_vfill(&__A, *((float **)this + 6), 1, *((unsigned int *)this + 2));
  return result;
}

void WatsonModelDOA::UpdateNormConst(uint64_t a1, uint64_t *a2, double a3, double a4, double a5, float a6)
{
  vKummerFirstKind(*a2, a2[1], *(_QWORD *)(a1 + 48), *(float *)(a1 + 216), *(float *)(a1 + 220), a5, a6);
  vDSP_vsmul(*(const float **)(a1 + 48), 1, (const float *)(a1 + 84), *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
  vDSP_svdiv((const float *)(a1 + 76), *(const float **)(a1 + 48), 1, *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
}

void WatsonModelDOA::~WatsonModelDOA(WatsonModelDOA *this)
{
  CircularModelDOA::~CircularModelDOA(this);
  JUMPOUT(0x1BCC95CECLL);
}

void WatsonModelDOA::GetValue(uint64_t a1, const float **a2, const float **a3, float **a4)
{
  uint64_t v6;
  float *v7;
  float *v8;

  CircularModelDOA::innerProductTargetTimesSubbandDOA(a1, a2, a3, a4);
  vDSP_vmul(*a4, 1, *a4, 1, *a4, 1, *(unsigned int *)(a1 + 8));
  vDSP_vmul(*a4, 1, *(const float **)(a1 + 24), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  vvexpf(*a4, *a4, (const int *)(a1 + 72));
  vDSP_vmul(*a4, 1, *(const float **)(a1 + 48), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  v6 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v6)
  {
    v7 = *(float **)(a1 + 24);
    v8 = *a4;
    do
    {
      if (*v7 < 1.0e-15)
        *v8 = *(float *)(a1 + 88);
      ++v8;
      ++v7;
      --v6;
    }
    while (v6);
  }
}

void vKummerFirstKind(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5, double a6, float a7)
{
  uint64_t v11;
  unint64_t v12;
  int v13;

  if (a2 != a1)
  {
    v11 = 0;
    v12 = (a2 - a1) >> 2;
    do
    {
      KummerFirstKind(a4, a5, *(float *)(a1 + 4 * v11), a7);
      *(_DWORD *)(a3 + 4 * v11++) = v13;
    }
    while (v12 > v11);
  }
}

void KummerFirstKind(float a1, float a2, float a3, float a4)
{
  float v4;
  float v5;
  float v6;
  unsigned int v7;

  v4 = a1;
  v5 = (float)(a1 * a3) / a2;
  v6 = v5 + 1.0;
  if (fabsf(v5) > 0.000000001)
  {
    v7 = 1;
    do
    {
      v4 = v4 + 1.0;
      a2 = a2 + 1.0;
      v5 = (float)((float)((float)(v5 * a3) * v4) / a2) / (float)(v7 + 1);
      v6 = v6 + v5;
      if (v7 > 0x62)
        break;
      ++v7;
    }
    while (fabsf(v5) > 0.000000001);
  }
}

void ComplementWatsonModelDOA::UpdateNormConst(ComplementWatsonModelDOA *this, float a2, double a3, double a4, float a5)
{
  float v7;
  float v8;
  float v9;
  float __A;

  KummerFirstKind(*((float *)this + 54), *((float *)this + 55), a2, a5);
  v7 = *((float *)this + 19);
  v8 = *((float *)this + 21);
  __A = v7 / (float)((float)(expf(a2) - v9) * v8);
  vDSP_vfill(&__A, *((float **)this + 6), 1, *((unsigned int *)this + 2));
}

void ComplementWatsonModelDOA::UpdateNormConst(uint64_t a1, uint64_t a2)
{
  double v4;
  float v5;

  vvexpf(*(float **)(a1 + 224), *(const float **)a2, (const int *)(a1 + 72));
  vKummerFirstKind(*(_QWORD *)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a1 + 48), *(float *)(a1 + 216), *(float *)(a1 + 220), v4, v5);
  vDSP_vsub(*(const float **)(a1 + 48), 1, *(const float **)(a1 + 224), 1, *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
  vDSP_vsmul(*(const float **)(a1 + 48), 1, (const float *)(a1 + 84), *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
  vDSP_svdiv((const float *)(a1 + 76), *(const float **)(a1 + 48), 1, *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
}

void ComplementWatsonModelDOA::~ComplementWatsonModelDOA(ComplementWatsonModelDOA *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E69D8998;
  v2 = (void *)*((_QWORD *)this + 28);
  if (v2)
  {
    *((_QWORD *)this + 29) = v2;
    operator delete(v2);
  }
  CircularModelDOA::~CircularModelDOA(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E69D8998;
  v2 = (void *)*((_QWORD *)this + 28);
  if (v2)
  {
    *((_QWORD *)this + 29) = v2;
    operator delete(v2);
  }
  CircularModelDOA::~CircularModelDOA(this);
  JUMPOUT(0x1BCC95CECLL);
}

void ComplementWatsonModelDOA::GetValue(uint64_t a1, const float **a2, const float **a3, float **a4)
{
  uint64_t v6;
  float *v7;
  float *v8;

  CircularModelDOA::innerProductTargetTimesSubbandDOA(a1, a2, a3, a4);
  vvexpf(*(float **)(a1 + 224), *(const float **)(a1 + 24), (const int *)(a1 + 72));
  vDSP_vmul(*a4, 1, *a4, 1, *a4, 1, *(unsigned int *)(a1 + 8));
  vDSP_vmul(*a4, 1, *(const float **)(a1 + 24), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  vvexpf(*a4, *a4, (const int *)(a1 + 72));
  vDSP_vsub(*a4, 1, *(const float **)(a1 + 224), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  vDSP_vmul(*a4, 1, *(const float **)(a1 + 48), 1, *a4, 1, *(unsigned int *)(a1 + 8));
  v6 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v6)
  {
    v7 = *(float **)(a1 + 24);
    v8 = *a4;
    do
    {
      if (*v7 < 1.0e-15)
        *v8 = *(float *)(a1 + 88);
      ++v8;
      ++v7;
      --v6;
    }
    while (v6);
  }
}

void UniformModelDOA::UpdateNormConst(UniformModelDOA *this, float a2)
{
  vDSP_vfill((const float *)this + 20, *((float **)this + 3), 1, *((unsigned int *)this + 2));
  vDSP_vfill((const float *)this + 19, *((float **)this + 6), 1, *((unsigned int *)this + 2));
}

void UniformModelDOA::UpdateNormConst(uint64_t a1)
{
  vDSP_vfill((const float *)(a1 + 80), *(float **)(a1 + 24), 1, *(unsigned int *)(a1 + 8));
  vDSP_vfill((const float *)(a1 + 76), *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 8));
}

void UniformModelDOA::~UniformModelDOA(UniformModelDOA *this)
{
  CircularModelDOA::~CircularModelDOA(this);
  JUMPOUT(0x1BCC95CECLL);
}

void UniformModelDOA::GetValue(uint64_t a1, uint64_t a2, uint64_t a3, float **a4)
{
  vDSP_vfill((const float *)(a1 + 88), *a4, 1, *(unsigned int *)(a1 + 8));
}

uint64_t CircularModelSV::UpdateKappa(float **this, float a2)
{
  float __A;

  __A = a2;
  vDSP_vfill(&__A, this[6], 1, *((unsigned int *)this + 3));
  return (*(uint64_t (**)(float **, float))*this)(this, __A);
}

void CircularModelSV::UpdateKappa(uint64_t a1, uint64_t a2)
{
  const void *v4;
  int64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = *(const void **)a2;
  v6 = *(_QWORD *)(a2 + 8) - (_QWORD)v4;
  if (*(_DWORD *)(a1 + 12) == v6 >> 2)
  {
    memcpy(*(void **)(a1 + 48), v4, v6);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, a2);
    return;
  }
  if (AUSpatialProbabilityLogScope(void)::once != -1)
    dispatch_once(&AUSpatialProbabilityLogScope(void)::once, &__block_literal_global_5486);
  if (AUSpatialProbabilityLogScope(void)::scope)
  {
    v7 = *(NSObject **)AUSpatialProbabilityLogScope(void)::scope;
    if (!*(_QWORD *)AUSpatialProbabilityLogScope(void)::scope)
      return;
  }
  else
  {
    v7 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2;
    v9 = *(_DWORD *)(a1 + 12);
    v10 = 136315906;
    v11 = "CircularModels.cpp";
    v12 = 1024;
    v13 = 515;
    v14 = 2048;
    v15 = v8;
    v16 = 1024;
    v17 = v9;
    _os_log_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_DEFAULT, "%25s:%-5d CircularModels: Kappa not set. Input length (%lu) and internal length (%u) do not match.\n", (uint8_t *)&v10, 0x22u);
  }
}

void WatsonModelSV::UpdateNormConst(WatsonModelSV *this, float a2, double a3, double a4, float a5)
{
  float v6;
  float v7;
  float __A;

  KummerFirstKind(*((float *)this + 24), *((float *)this + 27), a2, a5);
  v6 = *((float *)this + 30);
  __A = v6 - logf(v7 * *((float *)this + 28));
  vDSP_vfill(&__A, *((float **)this + 9), 1, *((unsigned int *)this + 3));
}

void WatsonModelSV::UpdateNormConst(uint64_t a1, uint64_t *a2, double a3, double a4, double a5, float a6)
{
  vKummerFirstKind(*a2, a2[1], *(_QWORD *)(a1 + 152), *(float *)(a1 + 96), *(float *)(a1 + 108), a5, a6);
  vDSP_vsmul(*(const float **)(a1 + 152), 1, (const float *)(a1 + 112), *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 12));
  vvlogf(*(float **)(a1 + 72), *(const float **)(a1 + 72), (const int *)(a1 + 104));
  vDSP_vneg(*(const float **)(a1 + 72), 1, *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 12));
  vDSP_vsadd(*(const float **)(a1 + 72), 1, (const float *)(a1 + 120), *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 12));
}

void WatsonModelSV::~WatsonModelSV(WatsonModelSV *this)
{
  CircularModelSV::~CircularModelSV(this);
  JUMPOUT(0x1BCC95CECLL);
}

void WatsonModelSV::GetValue(uint64_t a1, _QWORD *a2, float **a3)
{
  vDSP_Length v6;
  int v7;
  float *v8;
  unsigned int v9;
  vDSP_Length __N;
  unsigned int v11;
  float *v12;
  uint64_t v13;
  DSPSplitComplex __A;
  DSPSplitComplex __B;
  DSPSplitComplex __D;

  vDSP_vclr(*(float **)(a1 + 128), 1, (2 * *(_DWORD *)(a1 + 12)));
  v7 = *(_DWORD *)(a1 + 8);
  v6 = *(unsigned int *)(a1 + 12);
  v8 = (float *)(*(_QWORD *)(a1 + 128) + 4 * v6);
  __D.realp = *(float **)(a1 + 128);
  __D.imagp = v8;
  if (v7)
  {
    v9 = 0;
    do
    {
      __N = *(unsigned int *)(a1 + 12);
      v11 = *(_DWORD *)(a1 + 16) + __N * v9;
      v12 = (float *)(*a2 + 4 * v11);
      __B.realp = (float *)(*a2 + 4 * __N * v9);
      __B.imagp = v12;
      v13 = *(_QWORD *)(a1 + 24);
      __A.realp = (float *)(v13 + 4 * __N * v9);
      __A.imagp = (float *)(v13 + 4 * v11);
      vDSP_zvcma(&__A, 1, &__B, 1, &__D, 1, &__D, 1, __N);
      ++v9;
    }
    while (v9 < *(_DWORD *)(a1 + 8));
    v6 = *(unsigned int *)(a1 + 12);
  }
  vDSP_zvmags(&__D, 1, *(float **)(a1 + 152), 1, v6);
  vDSP_vmul(*(const float **)(a1 + 152), 1, *(const float **)(a1 + 48), 1, *(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
  vDSP_vadd(*(const float **)(a1 + 152), 1, *(const float **)(a1 + 72), 1, *a3, 1, *(unsigned int *)(a1 + 12));
}

void CircularModelSV::~CircularModelSV(CircularModelSV *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &unk_1E69ECC00;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 16);
  if (v3)
  {
    *((_QWORD *)this + 17) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 9);
  if (v4)
  {
    *((_QWORD *)this + 10) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 6);
  if (v5)
  {
    *((_QWORD *)this + 7) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 3);
  if (v6)
  {
    *((_QWORD *)this + 4) = v6;
    operator delete(v6);
  }
}

void ComplementWatsonModelSV::UpdateNormConst(ComplementWatsonModelSV *this, float a2, double a3, double a4, float a5)
{
  float v7;
  float v8;
  float __A;

  KummerFirstKind(*((float *)this + 24), *((float *)this + 27), a2, a5);
  v7 = *((float *)this + 29);
  __A = 1.0 / (float)((float)(v7 * expf(a2)) - (float)(v7 * v8));
  vDSP_vfill(&__A, *((float **)this + 9), 1, *((unsigned int *)this + 3));
}

void ComplementWatsonModelSV::UpdateNormConst(uint64_t a1, uint64_t *a2, double a3, double a4, double a5, float a6)
{
  uint64_t v6;

  v6 = a1 + 96;
  vKummerFirstKind(*a2, a2[1], *(_QWORD *)(a1 + 152), *(float *)(a1 + 96), *(float *)(a1 + 108), a5, a6);
  vvexpf(*(float **)(v6 - 24), *(const float **)(v6 - 48), (const int *)(v6 + 8));
  vDSP_vsmul(*(const float **)(v6 - 24), 1, (const float *)(v6 + 20), *(float **)(v6 - 24), 1, *(unsigned int *)(v6 - 84));
  vDSP_vsmul(*(const float **)(v6 + 56), 1, (const float *)(v6 + 20), *(float **)(v6 + 56), 1, *(unsigned int *)(v6 - 84));
  vDSP_vsub(*(const float **)(v6 + 56), 1, *(const float **)(v6 - 24), 1, *(float **)(v6 - 24), 1, *(unsigned int *)(v6 - 84));
  vDSP_svdiv((const float *)v6, *(const float **)(v6 - 24), 1, *(float **)(v6 - 24), 1, *(unsigned int *)(v6 - 84));
}

void ComplementWatsonModelSV::~ComplementWatsonModelSV(ComplementWatsonModelSV *this)
{
  CircularModelSV::~CircularModelSV(this);
  JUMPOUT(0x1BCC95CECLL);
}

void ComplementWatsonModelSV::GetValue(uint64_t a1, _QWORD *a2, float **a3)
{
  vDSP_Length v6;
  int v7;
  float *v8;
  unsigned int v9;
  vDSP_Length __N;
  unsigned int v11;
  float *v12;
  uint64_t v13;
  DSPSplitComplex __A;
  DSPSplitComplex __B;
  DSPSplitComplex __D;

  vDSP_vclr(*(float **)(a1 + 128), 1, (2 * *(_DWORD *)(a1 + 12)));
  v7 = *(_DWORD *)(a1 + 8);
  v6 = *(unsigned int *)(a1 + 12);
  v8 = (float *)(*(_QWORD *)(a1 + 128) + 4 * v6);
  __D.realp = *(float **)(a1 + 128);
  __D.imagp = v8;
  if (v7)
  {
    v9 = 0;
    do
    {
      __N = *(unsigned int *)(a1 + 12);
      v11 = *(_DWORD *)(a1 + 16) + __N * v9;
      v12 = (float *)(*a2 + 4 * v11);
      __B.realp = (float *)(*a2 + 4 * __N * v9);
      __B.imagp = v12;
      v13 = *(_QWORD *)(a1 + 24);
      __A.realp = (float *)(v13 + 4 * __N * v9);
      __A.imagp = (float *)(v13 + 4 * v11);
      vDSP_zvcma(&__A, 1, &__B, 1, &__D, 1, &__D, 1, __N);
      ++v9;
    }
    while (v9 < *(_DWORD *)(a1 + 8));
    v6 = *(unsigned int *)(a1 + 12);
  }
  vDSP_zvmags(&__D, 1, *(float **)(a1 + 152), 1, v6);
  vDSP_vmul(*(const float **)(a1 + 152), 1, *(const float **)(a1 + 48), 1, *(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
  vvexpf(*a3, *(const float **)(a1 + 152), (const int *)(a1 + 104));
  vvexpf(*(float **)(a1 + 152), *(const float **)(a1 + 48), (const int *)(a1 + 104));
  vDSP_vsub(*a3, 1, *(const float **)(a1 + 152), 1, *a3, 1, *(unsigned int *)(a1 + 12));
  vDSP_vmul(*(const float **)(a1 + 72), 1, *a3, 1, *a3, 1, *(unsigned int *)(a1 + 12));
  vvlogf(*a3, *a3, (const int *)(a1 + 104));
}

void SumMixWatsonModelSV::UpdateNormConst(SumMixWatsonModelSV *this, float a2, double a3, double a4, float a5)
{
  float v6;
  float v7;
  float __A;

  KummerFirstKind(*((float *)this + 24), *((float *)this + 27), a2, a5);
  v6 = *((float *)this + 30);
  __A = v6 - logf(v7 * *((float *)this + 28));
  vDSP_vfill(&__A, *((float **)this + 9), 1, *((unsigned int *)this + 3));
}

void SumMixWatsonModelSV::UpdateNormConst(uint64_t a1, uint64_t *a2, double a3, double a4, double a5, float a6)
{
  vKummerFirstKind(*a2, a2[1], *(_QWORD *)(a1 + 152), *(float *)(a1 + 96), *(float *)(a1 + 108), a5, a6);
  vDSP_vsmul(*(const float **)(a1 + 152), 1, (const float *)(a1 + 112), *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 12));
  vvlogf(*(float **)(a1 + 72), *(const float **)(a1 + 72), (const int *)(a1 + 104));
  vDSP_vneg(*(const float **)(a1 + 72), 1, *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 12));
  vDSP_vsadd(*(const float **)(a1 + 72), 1, (const float *)(a1 + 120), *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 12));
}

void SumMixWatsonModelSV::~SumMixWatsonModelSV(SumMixWatsonModelSV *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E69ECC90;
  v2 = (void *)*((_QWORD *)this + 22);
  if (v2)
  {
    *((_QWORD *)this + 23) = v2;
    operator delete(v2);
  }
  CircularModelSV::~CircularModelSV(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E69ECC90;
  v2 = (void *)*((_QWORD *)this + 22);
  if (v2)
  {
    *((_QWORD *)this + 23) = v2;
    operator delete(v2);
  }
  CircularModelSV::~CircularModelSV(this);
  JUMPOUT(0x1BCC95CECLL);
}

void SumMixWatsonModelSV::GetValue(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  vDSP_Length v6;
  int v7;
  unsigned int v8;
  vDSP_Length __N;
  unsigned int v10;
  float *v11;
  uint64_t v12;
  unsigned int v13;
  vDSP_Length v14;
  unsigned int v15;
  float *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  vDSP_Length v21;
  uint64_t v22;
  float *v23;
  DSPSplitComplex v24;
  DSPSplitComplex __A;
  DSPSplitComplex __B;
  DSPSplitComplex __D;

  vDSP_vclr(*(float **)(a1 + 128), 1, (2 * *(_DWORD *)(a1 + 12)));
  v7 = *(_DWORD *)(a1 + 8);
  v6 = *(unsigned int *)(a1 + 12);
  __D.realp = *(float **)(a1 + 128);
  __D.imagp = &__D.realp[v6];
  if (v7)
  {
    v8 = 0;
    do
    {
      __N = *(unsigned int *)(a1 + 12);
      v10 = *(_DWORD *)(a1 + 16) + __N * v8;
      v11 = (float *)(*a2 + 4 * v10);
      __B.realp = (float *)(*a2 + 4 * __N * v8);
      __B.imagp = v11;
      v12 = *(_QWORD *)(a1 + 24);
      __A.realp = (float *)(v12 + 4 * __N * v8);
      __A.imagp = (float *)(v12 + 4 * v10);
      vDSP_zvcma(&__A, 1, &__B, 1, &__D, 1, &__D, 1, __N);
      ++v8;
    }
    while (v8 < *(_DWORD *)(a1 + 8));
    v6 = *(unsigned int *)(a1 + 12);
  }
  vDSP_zvneg(&__D, 1, &__D, 1, v6);
  vDSP_vclr(*(float **)(a1 + 176), 1, (2 * *(_DWORD *)(a1 + 16)));
  if (*(_DWORD *)(a1 + 8))
  {
    v13 = 0;
    do
    {
      v14 = *(unsigned int *)(a1 + 12);
      v15 = *(_DWORD *)(a1 + 16) + v14 * v13;
      v16 = (float *)(*a2 + 4 * v15);
      __B.realp = (float *)(*a2 + 4 * v14 * v13);
      __B.imagp = v16;
      v17 = *(_QWORD *)(a1 + 24);
      __A.realp = (float *)(v17 + 4 * v14 * v13);
      __A.imagp = (float *)(v17 + 4 * v15);
      v18 = *(_QWORD *)(a1 + 176);
      v24.realp = (float *)(v18 + 4 * v14 * v13);
      v24.imagp = (float *)(v18 + 4 * v15);
      vDSP_zvma(&__D, 1, &__A, 1, &__B, 1, &v24, 1, v14);
      ++v13;
      v19 = *(_DWORD *)(a1 + 8);
    }
    while (v13 < v19);
    if (v19)
    {
      v20 = 0;
      do
      {
        v21 = *(unsigned int *)(a1 + 12);
        v22 = *(_QWORD *)(a1 + 176);
        v23 = (float *)(v22 + 4 * (*(_DWORD *)(a1 + 16) + v21 * v20));
        __B.realp = (float *)(v22 + 4 * v21 * v20);
        __B.imagp = v23;
        vDSP_zvmags(&__B, 1, *(float **)(a1 + 152), 1, v21);
        vDSP_vmul(*(const float **)(a1 + 152), 1, *(const float **)(a1 + 48), 1, *(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
        vDSP_vadd(*(const float **)(a1 + 152), 1, *(const float **)(a1 + 72), 1, (float *)(*a3 + 4 * *(_DWORD *)(a1 + 12) * v20++), 1, *(unsigned int *)(a1 + 12));
      }
      while (v20 < *(_DWORD *)(a1 + 8));
    }
  }
}

void UniformModelSV::UpdateNormConst(UniformModelSV *this, float a2)
{
  vDSP_vfill((const float *)this + 25, *((float **)this + 6), 1, *((unsigned int *)this + 3));
  vDSP_vfill((const float *)this + 24, *((float **)this + 9), 1, *((unsigned int *)this + 3));
}

void UniformModelSV::UpdateNormConst(uint64_t a1)
{
  vDSP_vfill((const float *)(a1 + 100), *(float **)(a1 + 48), 1, *(unsigned int *)(a1 + 12));
  vDSP_vfill((const float *)(a1 + 96), *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 12));
}

void UniformModelSV::~UniformModelSV(UniformModelSV *this)
{
  CircularModelSV::~CircularModelSV(this);
  JUMPOUT(0x1BCC95CECLL);
}

void UniformModelSV::GetValue(uint64_t a1, uint64_t a2, float **a3)
{
  float __A;

  __A = logf(1.0 / *(float *)(a1 + 116));
  vDSP_vfill(&__A, *a3, 1, *(unsigned int *)(a1 + 12));
}

void GaussLSModelSV::UpdateNormConst(float **this, float a2)
{
  float __A;

  __A = 1.0;
  vDSP_vfill(&__A, this[9], 1, *((unsigned int *)this + 3));
}

void GaussLSModelSV::UpdateNormConst(uint64_t a1)
{
  float __A;

  __A = 1.0;
  vDSP_vfill(&__A, *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 12));
}

void GaussLSModelSV::~GaussLSModelSV(GaussLSModelSV *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E69ECD20;
  v2 = (void *)*((_QWORD *)this + 22);
  if (v2)
  {
    *((_QWORD *)this + 23) = v2;
    operator delete(v2);
  }
  CircularModelSV::~CircularModelSV(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E69ECD20;
  v2 = (void *)*((_QWORD *)this + 22);
  if (v2)
  {
    *((_QWORD *)this + 23) = v2;
    operator delete(v2);
  }
  CircularModelSV::~CircularModelSV(this);
  JUMPOUT(0x1BCC95CECLL);
}

void GaussLSModelSV::GetValue(uint64_t a1, _QWORD *a2, float **a3)
{
  float *realp;
  uint64_t v7;
  int v8;
  unsigned int v9;
  vDSP_Length __N;
  unsigned int v11;
  float *v12;
  uint64_t v13;
  unsigned int v14;
  const float *v15;
  DSPSplitComplex __A;
  DSPSplitComplex __B;
  DSPSplitComplex __D;

  vDSP_vclr(*(float **)(a1 + 128), 1, (2 * *(_DWORD *)(a1 + 12)));
  v8 = *(_DWORD *)(a1 + 8);
  v7 = *(unsigned int *)(a1 + 12);
  __D.realp = *(float **)(a1 + 128);
  realp = __D.realp;
  __D.imagp = &__D.realp[v7];
  if (v8)
  {
    v9 = 0;
    do
    {
      __N = *(unsigned int *)(a1 + 12);
      v11 = *(_DWORD *)(a1 + 16) + __N * v9;
      v12 = (float *)(*a2 + 4 * v11);
      __B.realp = (float *)(*a2 + 4 * __N * v9);
      __B.imagp = v12;
      v13 = *(_QWORD *)(a1 + 24);
      __A.realp = (float *)(v13 + 4 * __N * v9);
      __A.imagp = (float *)(v13 + 4 * v11);
      vDSP_zvcma(&__A, 1, &__B, 1, &__D, 1, &__D, 1, __N);
      ++v9;
    }
    while (v9 < *(_DWORD *)(a1 + 8));
    realp = *(float **)(a1 + 128);
    LODWORD(v7) = *(_DWORD *)(a1 + 12);
  }
  vDSP_vmul(realp, 1, realp, 1, realp, 1, (2 * v7));
  vDSP_vadd(*(const float **)(a1 + 128), 1, (const float *)(*(_QWORD *)(a1 + 128) + 4 * *(unsigned int *)(a1 + 12)), 1, *(float **)(a1 + 128), 1, *(unsigned int *)(a1 + 12));
  vDSP_vclr(*(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
  if ((*(_DWORD *)(a1 + 8) & 0x7FFFFFFF) != 0)
  {
    v14 = 0;
    do
    {
      v15 = (const float *)(*a2 + 4 * *(_DWORD *)(a1 + 12) * v14);
      vDSP_vma(v15, 1, v15, 1, *(const float **)(a1 + 152), 1, *(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
      ++v14;
    }
    while (v14 < 2 * *(_DWORD *)(a1 + 8));
  }
  vDSP_vsub(*(const float **)(a1 + 128), 1, *(const float **)(a1 + 152), 1, *(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
  vDSP_vmul(*(const float **)(a1 + 48), 1, *(const float **)(a1 + 152), 1, *(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
  vDSP_vneg(*(const float **)(a1 + 152), 1, *a3, 1, *(unsigned int *)(a1 + 12));
}

float SumMixGaussLSModelSV::UpdateNormConst(float **this, float a2)
{
  float result;
  float __A;

  __A = -a2;
  vDSP_vfill(&__A, this[9], 1, *((unsigned int *)this + 3));
  return result;
}

void SumMixGaussLSModelSV::UpdateNormConst(uint64_t a1, const float **a2)
{
  vDSP_vneg(*a2, 1, *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 12));
}

void SumMixGaussLSModelSV::~SumMixGaussLSModelSV(SumMixGaussLSModelSV *this)
{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = &off_1E69ECD68;
  v2 = (void *)*((_QWORD *)this + 28);
  if (v2)
  {
    *((_QWORD *)this + 29) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 25);
  if (v3)
  {
    *((_QWORD *)this + 26) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 22);
  if (v4)
  {
    *((_QWORD *)this + 23) = v4;
    operator delete(v4);
  }
  CircularModelSV::~CircularModelSV(this);
}

{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = &off_1E69ECD68;
  v2 = (void *)*((_QWORD *)this + 28);
  if (v2)
  {
    *((_QWORD *)this + 29) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 25);
  if (v3)
  {
    *((_QWORD *)this + 26) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 22);
  if (v4)
  {
    *((_QWORD *)this + 23) = v4;
    operator delete(v4);
  }
  CircularModelSV::~CircularModelSV(this);
  JUMPOUT(0x1BCC95CECLL);
}

void SumMixGaussLSModelSV::GetValue(uint64_t a1, _QWORD *a2, float **a3)
{
  unsigned int v6;
  vDSP_Length v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  vDSP_Length v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  vDSP_Length v15;
  float *v16;
  unsigned int v17;
  vDSP_Length v18;
  uint64_t v19;
  float *v20;
  unsigned int v21;
  vDSP_Length v22;
  float *v23;
  vDSP_Length v24;
  int v25;
  float *v26;
  unsigned int v27;
  vDSP_Length __N;
  unsigned int v29;
  float *v30;
  uint64_t v31;
  vDSP_Length v32;
  int v33;
  float *v34;
  unsigned int v35;
  vDSP_Length v36;
  unsigned int v37;
  float *v38;
  uint64_t v39;
  DSPSplitComplex v40;
  DSPSplitComplex v41;
  float v42;
  DSPSplitComplex __D;
  DSPSplitComplex __B;
  DSPSplitComplex __A;
  DSPSplitComplex __C;

  vDSP_vclr(*a3, 1, *(unsigned int *)(a1 + 16));
  if (*(_DWORD *)(a1 + 8))
  {
    v6 = 0;
    do
    {
      v7 = *(unsigned int *)(a1 + 12);
      v8 = *(_DWORD *)(a1 + 16);
      __C.realp = *(float **)(a1 + 128);
      __C.imagp = &__C.realp[v7];
      v9 = *(_QWORD *)(a1 + 24);
      __A.realp = (float *)(v9 + 4 * v7 * v6);
      __A.imagp = (float *)(v9 + 4 * (v8 + v7 * v6));
      vDSP_zvconj(&__A, 1, &__C, 1, v7);
      vDSP_zvneg(&__C, 1, &__C, 1, *(unsigned int *)(a1 + 12));
      vDSP_vclr(*(float **)(a1 + 176), 1, (2 * *(_DWORD *)(a1 + 16)));
      if (*(_DWORD *)(a1 + 8))
      {
        v10 = 0;
        do
        {
          v11 = *(unsigned int *)(a1 + 12);
          v12 = *(_QWORD *)(a1 + 24);
          v13 = *(_DWORD *)(a1 + 16) + v11 * v10;
          __B.realp = (float *)(v12 + 4 * v11 * v10);
          __B.imagp = (float *)(v12 + 4 * v13);
          v14 = *(_QWORD *)(a1 + 176);
          __D.realp = (float *)(v14 + 4 * v11 * v10);
          __D.imagp = (float *)(v14 + 4 * v13);
          vDSP_zvmul(&__C, 1, &__B, 1, &__D, 1, v11, 1);
          ++v10;
        }
        while (v10 < *(_DWORD *)(a1 + 8));
      }
      v15 = *(unsigned int *)(a1 + 12);
      v16 = (float *)(*(_QWORD *)(a1 + 176) + 4 * v15 * v6);
      vDSP_vsadd(v16, 1, (const float *)(a1 + 96), v16, 1, v15);
      vDSP_vclr(*(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
      if (*(_DWORD *)(a1 + 8))
      {
        v17 = 0;
        do
        {
          v18 = *(unsigned int *)(a1 + 12);
          v19 = *(_QWORD *)(a1 + 176);
          v20 = (float *)(v19 + 4 * (*(_DWORD *)(a1 + 16) + v18 * v17));
          __B.realp = (float *)(v19 + 4 * v18 * v17);
          __B.imagp = v20;
          vDSP_zvmgsa(&__B, 1, *(const float **)(a1 + 152), 1, *(float **)(a1 + 152), 1, v18);
          ++v17;
        }
        while (v17 < *(_DWORD *)(a1 + 8));
      }
      v42 = 2.2204e-16;
      vDSP_vthr(*(const float **)(a1 + 152), 1, &v42, *(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
      vDSP_svdiv((const float *)(a1 + 96), *(const float **)(a1 + 152), 1, *(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
      if ((*(_DWORD *)(a1 + 8) & 0x7FFFFFFF) != 0)
      {
        v21 = 0;
        do
        {
          v22 = *(unsigned int *)(a1 + 12);
          v23 = (float *)(*(_QWORD *)(a1 + 176) + 4 * v22 * v21);
          vDSP_vmul(v23, 1, *(const float **)(a1 + 152), 1, v23, 1, v22);
          ++v21;
        }
        while (v21 < 2 * *(_DWORD *)(a1 + 8));
      }
      vDSP_vclr(*(float **)(a1 + 128), 1, (2 * *(_DWORD *)(a1 + 12)));
      v25 = *(_DWORD *)(a1 + 8);
      v24 = *(unsigned int *)(a1 + 12);
      v26 = (float *)(*(_QWORD *)(a1 + 128) + 4 * v24);
      __B.realp = *(float **)(a1 + 128);
      __B.imagp = v26;
      if (v25)
      {
        v27 = 0;
        do
        {
          __N = *(unsigned int *)(a1 + 12);
          v29 = *(_DWORD *)(a1 + 16) + __N * v27;
          v30 = (float *)(*a2 + 4 * v29);
          __D.realp = (float *)(*a2 + 4 * __N * v27);
          __D.imagp = v30;
          v31 = *(_QWORD *)(a1 + 176);
          v41.realp = (float *)(v31 + 4 * __N * v27);
          v41.imagp = (float *)(v31 + 4 * v29);
          vDSP_zvcma(&v41, 1, &__D, 1, &__B, 1, &__B, 1, __N);
          ++v27;
        }
        while (v27 < *(_DWORD *)(a1 + 8));
        v24 = *(unsigned int *)(a1 + 12);
      }
      vDSP_zvneg(&__B, 1, &__B, 1, v24);
      vDSP_zrvmul(&__B, 1, *(const float **)(a1 + 152), 1, &__B, 1, *(unsigned int *)(a1 + 12));
      vDSP_vclr(*(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
      v33 = *(_DWORD *)(a1 + 8);
      v32 = *(unsigned int *)(a1 + 12);
      v34 = (float *)(*(_QWORD *)(a1 + 200) + 4 * v32);
      __D.realp = *(float **)(a1 + 200);
      __D.imagp = v34;
      if (v33)
      {
        v35 = 0;
        do
        {
          v36 = *(unsigned int *)(a1 + 12);
          v37 = *(_DWORD *)(a1 + 16) + v36 * v35;
          v38 = (float *)(*a2 + 4 * v37);
          v41.realp = (float *)(*a2 + 4 * v36 * v35);
          v41.imagp = v38;
          v39 = *(_QWORD *)(a1 + 176);
          v40.realp = (float *)(v39 + 4 * v36 * v35);
          v40.imagp = (float *)(v39 + 4 * v37);
          vDSP_zvma(&__B, 1, &v40, 1, &v41, 1, &__D, 1, v36);
          vDSP_zvmgsa(&__D, 1, *(const float **)(a1 + 152), 1, *(float **)(a1 + 152), 1, *(unsigned int *)(a1 + 12));
          ++v35;
        }
        while (v35 < *(_DWORD *)(a1 + 8));
        v32 = *(unsigned int *)(a1 + 12);
      }
      vDSP_vmul(*(const float **)(a1 + 48), 1, *(const float **)(a1 + 152), 1, *(float **)(a1 + 152), 1, v32);
      vDSP_vneg(*(const float **)(a1 + 152), 1, &(*a3)[*(_DWORD *)(a1 + 12) * v6++], 1, *(unsigned int *)(a1 + 12));
    }
    while (v6 < *(_DWORD *)(a1 + 8));
  }
}

uint64_t complementaryModelType(unsigned int a1)
{
  std::logic_error *exception;

  if (a1 >= 5)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Unknown input parameter!");
  }
  return dword_1B662F6A4[a1];
}

void sub_1B60F3920(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::invalid_argument::invalid_argument[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
  return result;
}

void CircularModelDOA::SetTargetDOA(CircularModelDOA *this, float a2, float a3, float a4)
{
  NSObject *v8;
  double v9;
  NSObject *v10;
  double v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  double v17;
  __int16 v18;
  double v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *((float *)this + 3) = a2;
  if (a3 >= -90.0 && a3 <= 90.0)
  {
    *((float *)this + 4) = a3;
    goto LABEL_14;
  }
  if (AUSpatialProbabilityLogScope(void)::once != -1)
    dispatch_once(&AUSpatialProbabilityLogScope(void)::once, &__block_literal_global_5486);
  if (AUSpatialProbabilityLogScope(void)::scope)
  {
    v8 = *(NSObject **)AUSpatialProbabilityLogScope(void)::scope;
    if (!*(_QWORD *)AUSpatialProbabilityLogScope(void)::scope)
      goto LABEL_14;
  }
  else
  {
    v8 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = *((float *)this + 4);
    v12 = 136315906;
    v13 = "CircularModels.cpp";
    v14 = 1024;
    v15 = 143;
    v16 = 2048;
    v17 = a3;
    v18 = 2048;
    v19 = v9;
    _os_log_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_DEFAULT, "%25s:%-5d CircularModels: Target elevation not set to (%f), it remains at the current value (%f). Elevation should be in range [-90, 90].\n", (uint8_t *)&v12, 0x26u);
  }
LABEL_14:
  if (a4 >= 0.0)
  {
    *((float *)this + 5) = a4;
    return;
  }
  if (AUSpatialProbabilityLogScope(void)::once != -1)
    dispatch_once(&AUSpatialProbabilityLogScope(void)::once, &__block_literal_global_5486);
  if (AUSpatialProbabilityLogScope(void)::scope)
  {
    v10 = *(NSObject **)AUSpatialProbabilityLogScope(void)::scope;
    if (!*(_QWORD *)AUSpatialProbabilityLogScope(void)::scope)
      return;
  }
  else
  {
    v10 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11 = *((float *)this + 5);
    v12 = 136315906;
    v13 = "CircularModels.cpp";
    v14 = 1024;
    v15 = 159;
    v16 = 2048;
    v17 = a4;
    v18 = 2048;
    v19 = v11;
    _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEFAULT, "%25s:%-5d CircularModels: Target distance not set to (%f), it remains at the current value (%f). Distance must be nonnegative.\n", (uint8_t *)&v12, 0x26u);
  }
}

void CircularModelSV::SetTargetSV(uint64_t a1, uint64_t a2)
{
  const void *v4;
  size_t v6;
  void *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = *(const void **)a2;
  v6 = *(_QWORD *)(a2 + 8) - (_QWORD)v4;
  v8 = a1 + 24;
  v7 = *(void **)(a1 + 24);
  if (v6 == *(_QWORD *)(v8 + 8) - (_QWORD)v7)
  {
    memcpy(v7, v4, v6);
    return;
  }
  if (AUSpatialProbabilityLogScope(void)::once != -1)
    dispatch_once(&AUSpatialProbabilityLogScope(void)::once, &__block_literal_global_5486);
  if (AUSpatialProbabilityLogScope(void)::scope)
  {
    v9 = *(NSObject **)AUSpatialProbabilityLogScope(void)::scope;
    if (!*(_QWORD *)AUSpatialProbabilityLogScope(void)::scope)
      return;
  }
  else
  {
    v9 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v10 = (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2;
    v11 = (uint64_t)(*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 2;
    v12 = 136315906;
    v13 = "CircularModels.cpp";
    v14 = 1024;
    v15 = 487;
    v16 = 2048;
    v17 = v10;
    v18 = 2048;
    v19 = v11;
    _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEFAULT, "%25s:%-5d CircularModels: TargetSV not set. Input length (%lu) and internal length (%lu) do not match.\n", (uint8_t *)&v12, 0x26u);
  }
}

void VoiceProcessorV8::~VoiceProcessorV8(VoiceProcessorV8 *this)
{
  VoiceProcessorV8::~VoiceProcessorV8(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  VPTimeFreqConverter *v2;
  VPTimeFreqConverter *v3;
  VPTimeFreqConverter *v4;
  VPTimeFreqConverter *v5;
  VPTimeFreqConverter *v6;
  VPTimeFreqConverter *v7;
  void *v8;

  *(_QWORD *)this = &off_1E69C4EE8;
  caulk::details::lifetime_guard_base<VoiceProcessorV2>::invalidate((uint64_t)this + 16600);
  myFreeABLDynamic((AudioBufferList **)this + 2167);
  myFreeABLDynamic((AudioBufferList **)this + 2168);
  myFreeABLDynamic((AudioBufferList **)this + 2169);
  myFreeABLDynamic((AudioBufferList **)this + 2170);
  myFreeABLDynamic((AudioBufferList **)this + 2171);
  v2 = (VPTimeFreqConverter *)*((_QWORD *)this + 2178);
  if (v2)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v2);
    MEMORY[0x1BCC95CEC]();
    *((_QWORD *)this + 2178) = 0;
  }
  myFreeABLDynamic((AudioBufferList **)this + 2177);
  myFreeABLDynamic((AudioBufferList **)this + 2172);
  myFreeABLDynamic((AudioBufferList **)this + 2173);
  myFreeABLDynamic((AudioBufferList **)this + 2174);
  v3 = (VPTimeFreqConverter *)*((_QWORD *)this + 2175);
  if (v3)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v3);
    MEMORY[0x1BCC95CEC]();
    *((_QWORD *)this + 2175) = 0;
  }
  myFreeABLDynamic((AudioBufferList **)this + 2179);
  if ((*((_DWORD *)this + 18) & 0xFFFFFFFE) == 0x18)
  {
    myFreeABLDynamic((AudioBufferList **)this + 2183);
    myFreeABLDynamic((AudioBufferList **)this + 2184);
    myFreeABLDynamic((AudioBufferList **)this + 2185);
    myFreeABLDynamic((AudioBufferList **)this + 2186);
    myFreeABLDynamic((AudioBufferList **)this + 2187);
    v4 = (VPTimeFreqConverter *)*((_QWORD *)this + 2188);
    if (v4)
    {
      VPTimeFreqConverter::~VPTimeFreqConverter(v4);
      MEMORY[0x1BCC95CEC]();
      *((_QWORD *)this + 2188) = 0;
    }
    v5 = (VPTimeFreqConverter *)*((_QWORD *)this + 2189);
    if (v5)
    {
      VPTimeFreqConverter::~VPTimeFreqConverter(v5);
      MEMORY[0x1BCC95CEC]();
      *((_QWORD *)this + 2189) = 0;
    }
    v6 = (VPTimeFreqConverter *)*((_QWORD *)this + 2190);
    if (v6)
    {
      VPTimeFreqConverter::~VPTimeFreqConverter(v6);
      MEMORY[0x1BCC95CEC]();
      *((_QWORD *)this + 2190) = 0;
    }
    v7 = (VPTimeFreqConverter *)*((_QWORD *)this + 2191);
    if (v7)
    {
      VPTimeFreqConverter::~VPTimeFreqConverter(v7);
      MEMORY[0x1BCC95CEC]();
      *((_QWORD *)this + 2191) = 0;
    }
  }
  StopVPWirelessChargingMatStateListener();
  std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)this + 2193, 0);
  v8 = (void *)*((_QWORD *)this + 2180);
  if (v8)
  {
    *((_QWORD *)this + 2181) = v8;
    operator delete(v8);
  }
  VoiceProcessorV7::~VoiceProcessorV7(this);
}

uint64_t VoiceProcessorV8::GetVersion(VoiceProcessorV8 *this)
{
  return 8;
}

BOOL VoiceProcessorV8::SupportsSWB(VoiceProcessorV8 *this)
{
  return (*((_DWORD *)this + 18) & 0xFFFFFFFC) == 4;
}

uint64_t VoiceProcessorV8::Initialize(VoiceProcessorV8 *this)
{
  int v2;
  int v3;
  uint64_t result;
  BOOL *v5;
  unsigned int v6;
  VPTimeFreqConverter *v7;
  VPTimeFreqConverter *v8;
  VPTimeFreqConverter *v9;
  VPTimeFreqConverter *v10;
  VPTimeFreqConverter *v11;
  OpaqueAudioComponentInstance *v12;
  int v13;
  UInt32 outDataSize;
  float __A;

  *((_DWORD *)this + 100) = 0;
  v2 = *((_DWORD *)this + 153);
  if (v2)
  {
    v3 = 0;
    do
    {
      v3 = (2 * v3) | 1;
      --v2;
    }
    while (v2);
    *((_DWORD *)this + 100) = v3;
  }
  result = VoiceProcessorV2::Initialize(this);
  if (!(_DWORD)result)
  {
    VoiceProcessorV4::InitializeV4Specifics(this);
    VoiceProcessorV5::InitializeV5Specifics(this);
    VoiceProcessorV6::InitializeV6Specifics(this);
    result = VoiceProcessorV7::InitializeV7Specifics(this);
    if (!(_DWORD)result)
    {
      v5 = (BOOL *)this + 17064;
      v6 = *((_DWORD *)this + 18);
      if (v6 <= 0x26)
      {
        if (((1 << v6) & 0x6303000000) != 0)
        {
          VoiceProcessorV7::LoadTrimGains(this);
        }
        else if (((1 << v6) & 0xF0) != 0)
        {
          VoiceProcessorV7::LoadTrimGains(this);
          *((_BYTE *)this + 17536) = 1;
        }
      }
      v7 = (VPTimeFreqConverter *)*((_QWORD *)this + 2175);
      if (v7)
      {
        VPTimeFreqConverter::~VPTimeFreqConverter(v7);
        MEMORY[0x1BCC95CEC]();
      }
      VPTimeFreqConverter_Create(0, *((_DWORD *)this + 127), (VPTimeFreqConverter **)this + 2175);
      myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2167);
      myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2168);
      myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2169);
      myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 824), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2170);
      myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127) + 1, (AudioBufferList **)this + 2171);
      myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2172);
      myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2173);
      myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2174);
      myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), *((_DWORD *)this + 127), (AudioBufferList **)this + 2179);
      if ((*((_DWORD *)this + 18) & 0xFFFFFFFE) == 0x18)
      {
        myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2183);
        myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2184);
        myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2185);
        myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2186);
        myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), 2 * *((_DWORD *)this + 127), (AudioBufferList **)this + 2187);
        v8 = (VPTimeFreqConverter *)*((_QWORD *)this + 2188);
        if (v8)
        {
          VPTimeFreqConverter::~VPTimeFreqConverter(v8);
          MEMORY[0x1BCC95CEC]();
        }
        VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), (VPTimeFreqConverter **)this + 2188);
        v9 = (VPTimeFreqConverter *)*((_QWORD *)this + 2189);
        if (v9)
        {
          VPTimeFreqConverter::~VPTimeFreqConverter(v9);
          MEMORY[0x1BCC95CEC]();
        }
        VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), (VPTimeFreqConverter **)this + 2189);
        v10 = (VPTimeFreqConverter *)*((_QWORD *)this + 2190);
        if (v10)
        {
          VPTimeFreqConverter::~VPTimeFreqConverter(v10);
          MEMORY[0x1BCC95CEC]();
        }
        VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), (VPTimeFreqConverter **)this + 2190);
        v11 = (VPTimeFreqConverter *)*((_QWORD *)this + 2191);
        if (v11)
        {
          VPTimeFreqConverter::~VPTimeFreqConverter(v11);
          MEMORY[0x1BCC95CEC]();
        }
        VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), (VPTimeFreqConverter **)this + 2191);
      }
      __A = 1.0;
      vDSP_vfill(&__A, *(float **)(*((_QWORD *)this + 2179) + 16), 1, *((unsigned int *)this + 127));
      v12 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 368);
      if (v12)
      {
        outDataSize = 0;
        if (!AudioUnitGetPropertyInfo(v12, 0xED8u, 0, 0, &outDataSize, 0))
        {
          v13 = 0;
          std::vector<float>::assign((char **)this + 2180, (unint64_t)outDataSize >> 2, &v13);
        }
      }
      *((_QWORD *)this + 2176) = 0;
      (*(void (**)(VoiceProcessorV8 *))(*(_QWORD *)this + 696))(this);
      result = 0;
      *v5 = 0;
      if ((*((_DWORD *)this + 18) & 0xFFFFFFFE) == 0x18)
      {
        result = 0;
        *v5 = *((_DWORD *)this + 3098) == 3;
      }
    }
  }
  return result;
}

void VoiceProcessorV8::InitializeDownlinkTimeFreqConverters(VoiceProcessorV8 *this)
{
  VPTimeFreqConverter **v2;
  VPTimeFreqConverter *v3;
  double v4;
  double v5;
  unsigned int NextFFTFriendlyBlkSz;
  unint64_t v7;
  BlockProcessor *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;

  v2 = (VPTimeFreqConverter **)((char *)this + 17424);
  v3 = (VPTimeFreqConverter *)*((_QWORD *)this + 2178);
  if (v3)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v3);
    MEMORY[0x1BCC95CEC]();
    *v2 = 0;
  }
  if (*((_QWORD *)this + 2177))
    myFreeABLDynamic((AudioBufferList **)this + 2177);
  if ((~*((_DWORD *)this + 2208) & 0xC0) == 0)
  {
    v4 = *((double *)this + 36);
    v5 = *((double *)this + 41);
    NextFFTFriendlyBlkSz = *((_DWORD *)this + 129);
    if (v4 != v5)
      NextFFTFriendlyBlkSz = vcvtpd_u64_f64(v4 * (double)NextFFTFriendlyBlkSz / v5);
    if (*((_BYTE *)this + 480))
    {
      if ((double)NextFFTFriendlyBlkSz / v4 >= 0.012)
        v7 = NextFFTFriendlyBlkSz;
      else
        v7 = (v4 * 0.012);
      NextFFTFriendlyBlkSz = BlockSizeHelper::GetNextFFTFriendlyBlkSz(v7);
      v10 = *((_DWORD *)this + 79);
      v11 = v10;
      v8 = (BlockProcessor *)operator new();
      BlockProcessor::BlockProcessor(v8, 1, &v11, 1, &v10, NextFFTFriendlyBlkSz, (int (*)(void *, unsigned int, const AudioBufferList **, AudioBufferList **))VoiceProcessorV8::ReblockerForOCNSAndSpeechEnhancerCB, this);
      v9 = 0;
      std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)this + 2193, (uint64_t)v8);
      std::unique_ptr<BlockProcessor>::reset[abi:ne180100](&v9, 0);
    }
    VPTimeFreqConverter_Create(2, NextFFTFriendlyBlkSz, v2);
    myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 288), 2 * NextFFTFriendlyBlkSz, (AudioBufferList **)this + 2177);
  }
}

void sub_1B60F4298(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x1080C40622722D2);
  _Unwind_Resume(a1);
}

uint64_t VoiceProcessorV8::SetupUplink_MMNS(uint64_t this, unsigned int a2)
{
  unint64_t v2;

  if (a2 != 1)
  {
    v2 = *(_QWORD *)(this + 4656) & 0xFD5FC7FFFFBFFF7FLL;
    *(_QWORD *)(this + 4656) = v2 + 0x80380000400080;
    if (a2)
    {
      *(_QWORD *)(this + 4656) = v2 | 0x80380000400086;
      if (a2 >= 3)
      {
        *(_QWORD *)(this + 4656) = v2 | 0x8038000040008ELL;
        if (a2 != 3)
          *(_QWORD *)(this + 4656) = v2 & 0xF95C87FE7E3FFC61 | 0x483580181C0039ELL;
      }
    }
  }
  return this;
}

uint64_t VoiceProcessorV8::SetupUplink_MS(uint64_t this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  _BOOL4 v8;
  uint64_t v9;
  _BOOL4 v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2 != 1)
  {
    v2 = this;
    v3 = *(_QWORD *)(this + 4656);
    v4 = v3 | 0x400081;
    v5 = 4194463;
    if (a2 == 3)
      v5 = 4194447;
    v6 = v3 | v5;
    if (a2 >= 3)
    {
      v7 = a2 != 3;
    }
    else
    {
      v6 = v3 | 0x400087;
      v7 = 0;
    }
    v8 = a2 >= 3;
    if (a2)
      v9 = v6;
    else
      v9 = v4;
    if (a2)
      v10 = v7;
    else
      v10 = 0;
    if (!a2)
      v8 = 0;
    v11 = v9 & 0xF9FFFFFFDDFFF3FFLL;
    *(_QWORD *)(this + 4656) = v11 | 0x600000002000C00;
    if ((*(_DWORD *)(this + 72) & 0xFFFFFFFE) == 0x18)
    {
      if (v8)
        v12 = v11 | 0x600000002000D00;
      else
        v12 = v11 | 0x600000002000C00;
      if (v10)
        v13 = v12 | 0x200;
      else
        v13 = v12;
      *(_QWORD *)(this + 4656) = v13 & 0xFFDD37FFDE3FFFFFLL | 0x22880001C00000;
    }
    this = VoiceProcessorV2::GetChatFlavor((VoiceProcessorV2 *)this);
    if ((_DWORD)this == 2 && (*(_BYTE *)(v2 + 16544) & 4) != 0)
    {
      *(_QWORD *)(v2 + 4656) |= 0x800000000000000uLL;
      if (*(_BYTE *)(v2 + 2246))
      {
        this = VoiceProcessorV2::IsDeviceSupportingAdvancedChatFlavors((VoiceProcessorV2 *)this);
        if ((_DWORD)this)
          *(_QWORD *)(v2 + 4664) |= 4uLL;
      }
    }
  }
  return this;
}

void VoiceProcessorV8::SetupDownlinkBasicAUChain(VoiceProcessorV8 *this)
{
  VoiceProcessorV7::SetupDownlinkBasicAUChain(this);
  *((_QWORD *)this + 1104) = *((_QWORD *)this + 1104) & 0xFFFFEFF8FFFFFC53 | 0x1004000002A8;
}

uint64_t VoiceProcessorV8::ApplyPortSubtypeTuningOverride(VoiceProcessorV8 *this, unsigned int a2)
{
  char *v3;
  _QWORD *v4;
  NSObject *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t TuningInSubdirs;
  _QWORD *v10;
  NSObject *v11;
  _QWORD *v12;
  int *v13;
  const char *v14;
  const __CFDictionary *v15;
  _BOOL4 v16;
  _QWORD *v17;
  NSObject *v18;
  int *v19;
  unsigned __int8 *v20;
  _QWORD *v21;
  NSObject *v22;
  int *v23;
  _QWORD *v24;
  NSObject *v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  NSObject *v30;
  _QWORD *v31;
  int *v32;
  const char *v33;
  const __CFDictionary *v34;
  _BOOL4 v35;
  _QWORD *v36;
  NSObject *v37;
  int *v38;
  unsigned __int8 *v39;
  _QWORD *v40;
  NSObject *v41;
  int *v42;
  _QWORD *v43;
  NSObject *v44;
  int *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  NSObject *v49;
  _QWORD *v50;
  int *v51;
  const char *v52;
  uint64_t v53;
  const __CFDictionary *v54;
  _QWORD *v55;
  NSObject *v56;
  int *v57;
  unsigned __int8 *v58;
  _QWORD *v59;
  NSObject *v60;
  int *v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  NSObject *v65;
  int *v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD *v69;
  NSObject *v70;
  _QWORD *v71;
  int *v72;
  const char *v73;
  const __CFDictionary *v74;
  _BOOL4 v75;
  _QWORD *v76;
  NSObject *v77;
  int *v78;
  unsigned __int8 *v79;
  _QWORD *v80;
  NSObject *v81;
  int *v82;
  _QWORD *v83;
  NSObject *v84;
  int *v85;
  uint64_t v86;
  _QWORD *v87;
  NSObject *v88;
  int *v89;
  uint64_t v90;
  uint64_t v91;
  std::string *p_str;
  _QWORD *v93;
  NSObject *v94;
  _QWORD *v95;
  std::string *v96;
  int *v97;
  const char *v98;
  std::string *v99;
  std::string *v100;
  const __CFDictionary *v101;
  _QWORD *v102;
  NSObject *v103;
  std::string *v104;
  int *v105;
  std::string *v106;
  unsigned __int8 *v107;
  _QWORD *v108;
  NSObject *v109;
  std::string *v110;
  int *v111;
  std::string *v112;
  int v113;
  _QWORD *v114;
  NSObject *v115;
  int *v116;
  uint64_t v117;
  uint64_t v118;
  _QWORD *v119;
  NSObject *v120;
  _QWORD *v121;
  int *v122;
  const char *v123;
  const __CFDictionary *v124;
  _QWORD *v125;
  NSObject *v126;
  int *v127;
  unsigned __int8 *v128;
  _QWORD *v129;
  NSObject *v130;
  int *v131;
  int *v133;
  int *v134;
  CFStringRef inData;
  char v137;
  CFTypeRef v138;
  char v139;
  std::string __str;
  _BYTE v141[28];
  __int16 v142;
  const char *v143;
  CFTypeRef cf;
  char v145;
  uint8_t buf[48];
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  _BYTE v158[31];
  uint64_t v159;

  v159 = *MEMORY[0x1E0C80C00];
  v3 = (char *)this + 15897;
  if ((*(unsigned int (**)(VoiceProcessorV8 *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 520))(this, **((unsigned int **)this + 292), *((unsigned int *)this + 596), **((unsigned int **)this + 295)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v4 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
    {
      v5 = (*v4 ? *v4 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, *((_DWORD *)this + 596));
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 444;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v141;
        _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> known headphones with HW EQ AU preset override detected %s", buf, 0x1Cu);
      }
    }
    v6 = (int *)*((_QWORD *)this + 1570);
    if (v6 && (*v3 || v3[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v7 = VPLogScope(void)::scope;
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, *((_DWORD *)this + 596));
      CALegacyLog::log(v6, 5, v7, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 444, "ApplyPortSubtypeTuningOverride", "known headphones with HW EQ AU preset override detected %s", (const char *)buf);
    }
    v157 = 0u;
    memset(v158, 0, sizeof(v158));
    v155 = 0u;
    v156 = 0u;
    v153 = 0u;
    v154 = 0u;
    v151 = 0u;
    v152 = 0u;
    v149 = 0u;
    v150 = 0u;
    v147 = 0u;
    v148 = 0u;
    memset(buf, 0, sizeof(buf));
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, a2);
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&__str, *((_DWORD *)this + 23));
    snprintf((char *)buf, 0xFFuLL, "%s_vprx_tmst_%s", v141, (const char *)&__str);
    v8 = *((_QWORD *)this + 341);
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCString(0, "Generic", 0x600u);
    __str.__r_.__value_.__s.__data_[8] = 1;
    cf = CFStringCreateWithCString(0, "Headphones", 0x600u);
    v145 = 1;
    v138 = CFStringCreateWithCString(0, (const char *)buf, 0x600u);
    v139 = 1;
    *(_QWORD *)v141 = &__str;
    *(_QWORD *)&v141[8] = &cf;
    *(_QWORD *)&v141[16] = &v138;
    TuningInSubdirs = TuningPListMgr::loadTuningInSubdirs_(v8, (const __CFString ***)v141, 3u, 1u);
    CACFString::~CACFString((CACFString *)&v138);
    CACFString::~CACFString((CACFString *)&cf);
    CACFString::~CACFString((CACFString *)&__str);
    if ((_DWORD)TuningInSubdirs)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v10 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v11 = (*v10 ? *v10 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          v12 = (_QWORD *)((char *)this + 8);
          if (*((char *)this + 31) < 0)
            v12 = (_QWORD *)*v12;
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 453;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = v12;
          v142 = 2080;
          v143 = (const char *)buf;
          _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to find Headphone EQ aupreset: %s/Generic/Headphones/%s", v141, 0x26u);
        }
      }
      v13 = (int *)*((_QWORD *)this + 1570);
      if (v13 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
        {
          v133 = (int *)*((_QWORD *)this + 1570);
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v13 = v133;
        }
        v14 = (char *)this + 8;
        if (*((char *)this + 31) < 0)
          v14 = *(const char **)v14;
        CALegacyLog::log(v13, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 453, "ApplyPortSubtypeTuningOverride", ": failed to find Headphone EQ aupreset: %s/Generic/Headphones/%s", v14, (const char *)buf);
      }
    }
    cf = 0;
    v15 = TuningPListMgr::lookupPlist_(*((_QWORD *)this + 341), (const char *)buf, 1u);
    cf = v15;
    if (v15)
      v16 = TuningInSubdirs == 0;
    else
      v16 = 0;
    if (v16)
    {
      CFRetain(v15);
      AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1465, 0, 0, 0, 8uLL, &cf, 1);
      CFRelease(cf);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v17 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v18 = (*v17 ? *v17 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 463;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = buf;
          v142 = 2080;
          v143 = "(DL-)TM";
          _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> found Headphone EQ aupreset:%s for %s", v141, 0x26u);
        }
      }
      v19 = (int *)*((_QWORD *)this + 1570);
      if (v19 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v19, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 463, "ApplyPortSubtypeTuningOverride", "found Headphone EQ aupreset:%s for %s", (const char *)buf, "(DL-)TM");
      }
      std::string::basic_string[abi:ne180100]<0>(v141, "(DL-)TM");
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v141;
      v20 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)this + 4576, v141, (uint64_t)&std::piecewise_construct, (__int128 **)&__str);
      std::string::__assign_external((std::string *)(v20 + 40), (const std::string::value_type *)buf);
      if ((v141[23] & 0x80000000) != 0)
        operator delete(*(void **)v141);
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v21 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v22 = (*v21 ? *v21 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 467;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = buf;
          v142 = 2080;
          v143 = "(DL-)TM";
          _os_log_impl(&dword_1B5ED0000, v22, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to load Headphone EQ tuning aupreset:%s for %s", v141, 0x26u);
        }
      }
      v23 = (int *)*((_QWORD *)this + 1570);
      if (v23 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v23, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 467, "ApplyPortSubtypeTuningOverride", ": failed to load Headphone EQ tuning aupreset:%s for %s", (const char *)buf, "(DL-)TM");
      }
    }
  }
  else
  {
    TuningInSubdirs = 0;
  }
  if ((*(unsigned int (**)(VoiceProcessorV8 *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 520))(this, **((unsigned int **)this + 292), *((unsigned int *)this + 596), **((unsigned int **)this + 295)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v24 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
    {
      v25 = (*v24 ? *v24 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, *((_DWORD *)this + 596));
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 472;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v141;
        _os_log_impl(&dword_1B5ED0000, v25, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> known headphones with downlink deesser AU preset override detected %s", buf, 0x1Cu);
      }
    }
    v26 = (int *)*((_QWORD *)this + 1570);
    if (v26 && (*v3 || v3[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v27 = VPLogScope(void)::scope;
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, *((_DWORD *)this + 596));
      CALegacyLog::log(v26, 5, v27, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 472, "ApplyPortSubtypeTuningOverride", "known headphones with downlink deesser AU preset override detected %s", (const char *)buf);
    }
    v157 = 0u;
    memset(v158, 0, sizeof(v158));
    v155 = 0u;
    v156 = 0u;
    v153 = 0u;
    v154 = 0u;
    v151 = 0u;
    v152 = 0u;
    v149 = 0u;
    v150 = 0u;
    v147 = 0u;
    v148 = 0u;
    memset(buf, 0, sizeof(buf));
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, a2);
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&__str, *((_DWORD *)this + 23));
    snprintf((char *)buf, 0xFFuLL, "%s_vprx_dees_%s", v141, (const char *)&__str);
    v28 = *((_QWORD *)this + 341);
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCString(0, "Generic", 0x600u);
    __str.__r_.__value_.__s.__data_[8] = 1;
    cf = CFStringCreateWithCString(0, "Headphones", 0x600u);
    v145 = 1;
    v138 = CFStringCreateWithCString(0, (const char *)buf, 0x600u);
    v139 = 1;
    *(_QWORD *)v141 = &__str;
    *(_QWORD *)&v141[8] = &cf;
    *(_QWORD *)&v141[16] = &v138;
    TuningInSubdirs = TuningPListMgr::loadTuningInSubdirs_(v28, (const __CFString ***)v141, 3u, 1u);
    CACFString::~CACFString((CACFString *)&v138);
    CACFString::~CACFString((CACFString *)&cf);
    CACFString::~CACFString((CACFString *)&__str);
    if ((_DWORD)TuningInSubdirs)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v29 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v30 = (*v29 ? *v29 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          v31 = (_QWORD *)((char *)this + 8);
          if (*((char *)this + 31) < 0)
            v31 = (_QWORD *)*v31;
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 480;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = v31;
          v142 = 2080;
          v143 = (const char *)buf;
          _os_log_impl(&dword_1B5ED0000, v30, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to find downlink deesser aupreset: %s/Generic/Headphones/%s, using preset from strip", v141, 0x26u);
        }
      }
      v32 = (int *)*((_QWORD *)this + 1570);
      if (v32 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
        {
          v134 = (int *)*((_QWORD *)this + 1570);
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v32 = v134;
        }
        v33 = (char *)this + 8;
        if (*((char *)this + 31) < 0)
          v33 = *(const char **)v33;
        CALegacyLog::log(v32, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 480, "ApplyPortSubtypeTuningOverride", ": failed to find downlink deesser aupreset: %s/Generic/Headphones/%s, using preset from strip", v33, (const char *)buf);
      }
    }
    cf = 0;
    v34 = TuningPListMgr::lookupPlist_(*((_QWORD *)this + 341), (const char *)buf, 1u);
    cf = v34;
    if (v34)
      v35 = TuningInSubdirs == 0;
    else
      v35 = 0;
    if (v35)
    {
      CFRetain(v34);
      AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1390, 0, 0, 0, 8uLL, &cf, 1);
      CFRelease(cf);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v36 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v37 = (*v36 ? *v36 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 490;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = buf;
          v142 = 2080;
          v143 = "(DL-)FEVDeesser";
          _os_log_impl(&dword_1B5ED0000, v37, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> found Headphone deesser aupreset:%s for %s", v141, 0x26u);
        }
      }
      v38 = (int *)*((_QWORD *)this + 1570);
      if (v38 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v38, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 490, "ApplyPortSubtypeTuningOverride", "found Headphone deesser aupreset:%s for %s", (const char *)buf, "(DL-)FEVDeesser");
      }
      std::string::basic_string[abi:ne180100]<0>(v141, "(DL-)FEVDeesser");
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v141;
      v39 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)this + 4576, v141, (uint64_t)&std::piecewise_construct, (__int128 **)&__str);
      std::string::__assign_external((std::string *)(v39 + 40), (const std::string::value_type *)buf);
      if ((v141[23] & 0x80000000) != 0)
        operator delete(*(void **)v141);
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v40 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v41 = (*v40 ? *v40 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 493;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = buf;
          v142 = 2080;
          v143 = "(DL-)FEVDeesser";
          _os_log_impl(&dword_1B5ED0000, v41, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to load Headphone deesser tuning aupreset:%s for %s", v141, 0x26u);
        }
      }
      v42 = (int *)*((_QWORD *)this + 1570);
      if (v42 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v42, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 493, "ApplyPortSubtypeTuningOverride", ": failed to load Headphone deesser tuning aupreset:%s for %s", (const char *)buf, "(DL-)FEVDeesser");
      }
    }
  }
  if ((*(unsigned int (**)(VoiceProcessorV8 *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 520))(this, **((unsigned int **)this + 292), *((unsigned int *)this + 596), **((unsigned int **)this + 295)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v43 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
    {
      v44 = (*v43 ? *v43 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, *((_DWORD *)this + 596));
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 498;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v141;
        _os_log_impl(&dword_1B5ED0000, v44, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> known headset with mic EQ AU preset override detected %s", buf, 0x1Cu);
      }
    }
    v45 = (int *)*((_QWORD *)this + 1570);
    if (v45 && (*v3 || v3[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v46 = VPLogScope(void)::scope;
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, *((_DWORD *)this + 596));
      CALegacyLog::log(v45, 5, v46, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 498, "ApplyPortSubtypeTuningOverride", "known headset with mic EQ AU preset override detected %s", (const char *)buf);
    }
    v157 = 0u;
    memset(v158, 0, sizeof(v158));
    v155 = 0u;
    v156 = 0u;
    v153 = 0u;
    v154 = 0u;
    v151 = 0u;
    v152 = 0u;
    v149 = 0u;
    v150 = 0u;
    v147 = 0u;
    v148 = 0u;
    memset(buf, 0, sizeof(buf));
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, a2);
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&__str, *((_DWORD *)this + 23));
    snprintf((char *)buf, 0xFFuLL, "%s_vptx_%s", v141, (const char *)&__str);
    v47 = *((_QWORD *)this + 341);
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCString(0, "Generic", 0x600u);
    __str.__r_.__value_.__s.__data_[8] = 1;
    cf = CFStringCreateWithCString(0, "Headphones", 0x600u);
    v145 = 1;
    v138 = CFStringCreateWithCString(0, (const char *)buf, 0x600u);
    v139 = 1;
    *(_QWORD *)v141 = &__str;
    *(_QWORD *)&v141[8] = &cf;
    *(_QWORD *)&v141[16] = &v138;
    TuningInSubdirs = TuningPListMgr::loadTuningInSubdirs_(v47, (const __CFString ***)v141, 3u, 1u);
    CACFString::~CACFString((CACFString *)&v138);
    CACFString::~CACFString((CACFString *)&cf);
    CACFString::~CACFString((CACFString *)&__str);
    if ((_DWORD)TuningInSubdirs)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v48 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v49 = (*v48 ? *v48 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          v50 = (_QWORD *)((char *)this + 8);
          if (*((char *)this + 31) < 0)
            v50 = (_QWORD *)*v50;
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 505;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = v50;
          v142 = 2080;
          v143 = (const char *)buf;
          _os_log_impl(&dword_1B5ED0000, v49, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to find headset EQ aupreset: %s/Generic/Headphones/%s, trying without usecase", v141, 0x26u);
        }
      }
      v51 = (int *)*((_QWORD *)this + 1570);
      if (v51 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v52 = (char *)this + 8;
        if (*((char *)this + 31) < 0)
          v52 = *(const char **)v52;
        CALegacyLog::log(v51, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 505, "ApplyPortSubtypeTuningOverride", ": failed to find headset EQ aupreset: %s/Generic/Headphones/%s, trying without usecase", v52, (const char *)buf);
      }
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, a2);
      snprintf((char *)buf, 0xFFuLL, "%s_vptx", v141);
      v53 = *((_QWORD *)this + 341);
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCString(0, "Generic", 0x600u);
      __str.__r_.__value_.__s.__data_[8] = 1;
      cf = CFStringCreateWithCString(0, "Headphones", 0x600u);
      v145 = 1;
      v138 = CFStringCreateWithCString(0, (const char *)buf, 0x600u);
      v139 = 1;
      *(_QWORD *)v141 = &__str;
      *(_QWORD *)&v141[8] = &cf;
      *(_QWORD *)&v141[16] = &v138;
      TuningInSubdirs = TuningPListMgr::loadTuningInSubdirs_(v53, (const __CFString ***)v141, 3u, 1u);
      CACFString::~CACFString((CACFString *)&v138);
      CACFString::~CACFString((CACFString *)&cf);
      CACFString::~CACFString((CACFString *)&__str);
    }
    cf = 0;
    v54 = TuningPListMgr::lookupPlist_(*((_QWORD *)this + 341), (const char *)buf, 1u);
    cf = v54;
    if ((_DWORD)TuningInSubdirs || !v54)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v59 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v60 = (*v59 ? *v59 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 519;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = buf;
          v142 = 2080;
          v143 = "(UL-)Mic1EQ";
          _os_log_impl(&dword_1B5ED0000, v60, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to load headset EQ tuning aupreset:%s for %s", v141, 0x26u);
        }
      }
      v61 = (int *)*((_QWORD *)this + 1570);
      if (v61 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v61, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 519, "ApplyPortSubtypeTuningOverride", ": failed to load headset EQ tuning aupreset:%s for %s", (const char *)buf, "(UL-)Mic1EQ");
      }
    }
    else
    {
      CFRetain(v54);
      AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 897, 0, 0, 0, 8uLL, &cf, 1);
      CFRelease(cf);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v55 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v56 = (*v55 ? *v55 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 516;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = buf;
          v142 = 2080;
          v143 = "(UL-)Mic1EQ";
          _os_log_impl(&dword_1B5ED0000, v56, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> found headset EQ aupreset:%s for %s", v141, 0x26u);
        }
      }
      v57 = (int *)*((_QWORD *)this + 1570);
      if (v57 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v57, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 516, "ApplyPortSubtypeTuningOverride", "found headset EQ aupreset:%s for %s", (const char *)buf, "(UL-)Mic1EQ");
      }
      std::string::basic_string[abi:ne180100]<0>(v141, "(UL-)Mic1EQ");
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v141;
      v58 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)this + 4616, v141, (uint64_t)&std::piecewise_construct, (__int128 **)&__str);
      std::string::__assign_external((std::string *)(v58 + 40), (const std::string::value_type *)buf);
      if ((v141[23] & 0x80000000) != 0)
        operator delete(*(void **)v141);
    }
  }
  v62 = **((unsigned int **)this + 292);
  v63 = *((unsigned int *)this + 596);
  if ((_DWORD)v62 == 1885892727 && (v63 & 0xFFFFFFFE) == 0x62363066)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v64 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
    {
      v65 = (*v64 ? *v64 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
      {
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, *((_DWORD *)this + 596));
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 524;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v141;
        _os_log_impl(&dword_1B5ED0000, v65, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> known headphones with SpeechEnhancer AU preset override detected %s", buf, 0x1Cu);
      }
    }
    v66 = (int *)*((_QWORD *)this + 1570);
    if (v66 && (*v3 || v3[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v67 = VPLogScope(void)::scope;
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, *((_DWORD *)this + 596));
      CALegacyLog::log(v66, 5, v67, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 524, "ApplyPortSubtypeTuningOverride", "known headphones with SpeechEnhancer AU preset override detected %s", (const char *)buf);
    }
    v157 = 0u;
    memset(v158, 0, sizeof(v158));
    v155 = 0u;
    v156 = 0u;
    v153 = 0u;
    v154 = 0u;
    v151 = 0u;
    v152 = 0u;
    v149 = 0u;
    v150 = 0u;
    v147 = 0u;
    v148 = 0u;
    memset(buf, 0, sizeof(buf));
    CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, a2);
    snprintf((char *)buf, 0xFFuLL, "%s_vprx_spen", v141);
    v68 = *((_QWORD *)this + 341);
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCString(0, "Generic", 0x600u);
    __str.__r_.__value_.__s.__data_[8] = 1;
    cf = CFStringCreateWithCString(0, "Headphones", 0x600u);
    v145 = 1;
    v138 = CFStringCreateWithCString(0, (const char *)buf, 0x600u);
    v139 = 1;
    *(_QWORD *)v141 = &__str;
    *(_QWORD *)&v141[8] = &cf;
    *(_QWORD *)&v141[16] = &v138;
    TuningInSubdirs = TuningPListMgr::loadTuningInSubdirs_(v68, (const __CFString ***)v141, 3u, 1u);
    CACFString::~CACFString((CACFString *)&v138);
    CACFString::~CACFString((CACFString *)&cf);
    CACFString::~CACFString((CACFString *)&__str);
    if ((_DWORD)TuningInSubdirs)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v69 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v70 = (*v69 ? *v69 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
        {
          v71 = (_QWORD *)((char *)this + 8);
          if (*((char *)this + 31) < 0)
            v71 = (_QWORD *)*v71;
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 530;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = v71;
          v142 = 2080;
          v143 = (const char *)buf;
          _os_log_impl(&dword_1B5ED0000, v70, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to find Headphone SpeechEnhancer aupreset: %s/Generic/Headphones/%s, using preset from strip", v141, 0x26u);
        }
      }
      v72 = (int *)*((_QWORD *)this + 1570);
      if (v72 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v73 = (char *)this + 8;
        if (*((char *)this + 31) < 0)
          v73 = *(const char **)v73;
        CALegacyLog::log(v72, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 530, "ApplyPortSubtypeTuningOverride", ": failed to find Headphone SpeechEnhancer aupreset: %s/Generic/Headphones/%s, using preset from strip", v73, (const char *)buf);
      }
    }
    cf = 0;
    v74 = TuningPListMgr::lookupPlist_(*((_QWORD *)this + 341), (const char *)buf, 1u);
    cf = v74;
    if (v74)
      v75 = TuningInSubdirs == 0;
    else
      v75 = 0;
    if (v75)
    {
      CFRetain(v74);
      AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1384, 0, 0, 0, 8uLL, &cf, 1);
      CFRelease(cf);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v76 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v77 = (*v76 ? *v76 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 539;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = buf;
          v142 = 2080;
          v143 = "(DL-)SpeechEnh";
          _os_log_impl(&dword_1B5ED0000, v77, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> found Headphone SpeechEnhancer aupreset:%s for %s", v141, 0x26u);
        }
      }
      v78 = (int *)*((_QWORD *)this + 1570);
      if (v78 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v78, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 539, "ApplyPortSubtypeTuningOverride", "found Headphone SpeechEnhancer aupreset:%s for %s", (const char *)buf, "(DL-)SpeechEnh");
      }
      std::string::basic_string[abi:ne180100]<0>(v141, "(DL-)SpeechEnh");
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v141;
      v79 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)this + 4576, v141, (uint64_t)&std::piecewise_construct, (__int128 **)&__str);
      std::string::__assign_external((std::string *)(v79 + 40), (const std::string::value_type *)buf);
      if ((v141[23] & 0x80000000) != 0)
        operator delete(*(void **)v141);
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v80 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v81 = (*v80 ? *v80 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v141 = 136315906;
          *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&v141[12] = 1024;
          *(_DWORD *)&v141[14] = 542;
          *(_WORD *)&v141[18] = 2080;
          *(_QWORD *)&v141[20] = buf;
          v142 = 2080;
          v143 = "(DL-)SpeechEnh";
          _os_log_impl(&dword_1B5ED0000, v81, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to load Headphone SpeechEnhancer tuning aupreset:%s for %s", v141, 0x26u);
        }
      }
      v82 = (int *)*((_QWORD *)this + 1570);
      if (v82 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v82, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 542, "ApplyPortSubtypeTuningOverride", ": failed to load Headphone SpeechEnhancer tuning aupreset:%s for %s", (const char *)buf, "(DL-)SpeechEnh");
      }
    }
    v62 = **((unsigned int **)this + 292);
    v63 = *((unsigned int *)this + 596);
  }
  if ((_DWORD)v62 == 1885892727 && (v63 & 0xFFFFFFFE) == 0x62363066)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v83 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
    {
      v84 = (*v83 ? *v83 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
      {
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, *((_DWORD *)this + 596));
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 547;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v141;
        _os_log_impl(&dword_1B5ED0000, v84, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> known headphones with OCNS AU preset override detected %s", buf, 0x1Cu);
      }
    }
    v85 = (int *)*((_QWORD *)this + 1570);
    if (v85 && (*v3 || v3[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v86 = VPLogScope(void)::scope;
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, *((_DWORD *)this + 596));
      CALegacyLog::log(v85, 5, v86, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 547, "ApplyPortSubtypeTuningOverride", "known headphones with OCNS AU preset override detected %s", (const char *)buf);
    }
    std::string::basic_string[abi:ne180100]<0>(v141, "telephony");
    if (VoiceProcessorV2::GetChatFlavor(this) == 2 && (*((_BYTE *)this + 16544) & 4) != 0)
    {
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&__str, 0x7669736Fu);
      std::string::basic_string[abi:ne180100]<0>(buf, (char *)&__str);
      if ((v141[23] & 0x80000000) != 0)
        operator delete(*(void **)v141);
      *(_OWORD *)v141 = *(_OWORD *)buf;
      *(_QWORD *)&v141[16] = *(_QWORD *)&buf[16];
    }
    std::operator+<char>();
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v87 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      v88 = (*v87 ? *v87 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&cf, *((_DWORD *)this + 596));
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 556;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = &cf;
        _os_log_impl(&dword_1B5ED0000, v88, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Using tuning override preset name for ocns: %s", buf, 0x1Cu);
      }
    }
    v89 = (int *)*((_QWORD *)this + 1570);
    if (v89 && (*v3 || v3[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v90 = VPLogScope(void)::scope;
      CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, *((_DWORD *)this + 596));
      CALegacyLog::log(v89, 3, v90, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 556, "ApplyPortSubtypeTuningOverride", "Using tuning override preset name for ocns: %s", (const char *)buf);
    }
    v91 = *((_QWORD *)this + 341);
    cf = CFStringCreateWithCString(0, "Generic", 0x600u);
    v145 = 1;
    v138 = CFStringCreateWithCString(0, "Headphones", 0x600u);
    v139 = 1;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_str = &__str;
    else
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    inData = CFStringCreateWithCString(0, (const char *)p_str, 0x600u);
    v137 = 1;
    *(_QWORD *)buf = &cf;
    *(_QWORD *)&buf[8] = &v138;
    *(_QWORD *)&buf[16] = &inData;
    TuningInSubdirs = TuningPListMgr::loadTuningInSubdirs_(v91, (const __CFString ***)buf, 3u, 1u);
    CACFString::~CACFString((CACFString *)&inData);
    CACFString::~CACFString((CACFString *)&v138);
    CACFString::~CACFString((CACFString *)&cf);
    if ((_DWORD)TuningInSubdirs)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v93 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v94 = (*v93 ? *v93 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
        {
          v95 = (_QWORD *)((char *)this + 8);
          if (*((char *)this + 31) < 0)
            v95 = (_QWORD *)*v95;
          v96 = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v96 = (std::string *)__str.__r_.__value_.__r.__words[0];
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 559;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v95;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = v96;
          _os_log_impl(&dword_1B5ED0000, v94, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to find Headphone OCNS aupreset: %s/Generic/Headphones/%s, using preset from strip", buf, 0x26u);
        }
      }
      v97 = (int *)*((_QWORD *)this + 1570);
      if (v97 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v98 = (char *)this + 8;
        if (*((char *)this + 31) < 0)
          v98 = *(const char **)v98;
        v99 = &__str;
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v99 = (std::string *)__str.__r_.__value_.__r.__words[0];
        CALegacyLog::log(v97, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 559, "ApplyPortSubtypeTuningOverride", ": failed to find Headphone OCNS aupreset: %s/Generic/Headphones/%s, using preset from strip", v98, (const char *)v99);
      }
    }
    v138 = 0;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v100 = &__str;
    else
      v100 = (std::string *)__str.__r_.__value_.__r.__words[0];
    v101 = TuningPListMgr::lookupPlist_(*((_QWORD *)this + 341), (const char *)v100, 1u);
    v138 = v101;
    if ((_DWORD)TuningInSubdirs || !v101)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v108 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v109 = (*v108 ? *v108 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v109, OS_LOG_TYPE_DEBUG))
        {
          v110 = (std::string *)__str.__r_.__value_.__r.__words[0];
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v110 = &__str;
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 571;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v110;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "(UL-)OCNSV4";
          _os_log_impl(&dword_1B5ED0000, v109, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> : failed to load Headphone OCNS tuning aupreset:%s for %s", buf, 0x26u);
        }
      }
      v111 = (int *)*((_QWORD *)this + 1570);
      if (v111 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v112 = (std::string *)__str.__r_.__value_.__r.__words[0];
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v112 = &__str;
        CALegacyLog::log(v111, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 571, "ApplyPortSubtypeTuningOverride", ": failed to load Headphone OCNS tuning aupreset:%s for %s", (const char *)v112, "(UL-)OCNSV4");
      }
    }
    else
    {
      CFRetain(v101);
      AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1038, 0, 0, 0, 8uLL, &v138, 1);
      CFRelease(v138);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v102 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v103 = (*v102 ? *v102 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
        {
          v104 = (std::string *)__str.__r_.__value_.__r.__words[0];
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v104 = &__str;
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 568;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v104;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "(UL-)OCNSV4";
          _os_log_impl(&dword_1B5ED0000, v103, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> found Headphone OCNS aupreset:%s for %s", buf, 0x26u);
        }
      }
      v105 = (int *)*((_QWORD *)this + 1570);
      if (v105 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v106 = (std::string *)__str.__r_.__value_.__r.__words[0];
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v106 = &__str;
        CALegacyLog::log(v105, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 568, "ApplyPortSubtypeTuningOverride", "found Headphone OCNS aupreset:%s for %s", (const char *)v106, "(UL-)OCNSV4");
      }
      std::string::basic_string[abi:ne180100]<0>(buf, "(UL-)OCNSV4");
      cf = buf;
      v107 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)this + 4616, buf, (uint64_t)&std::piecewise_construct, (__int128 **)&cf);
      std::string::operator=((std::string *)(v107 + 40), &__str);
      if ((char)buf[23] < 0)
        operator delete(*(void **)buf);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    if ((v141[23] & 0x80000000) != 0)
      operator delete(*(void **)v141);
    v62 = **((unsigned int **)this + 292);
    v63 = *((unsigned int *)this + 596);
  }
  if ((*(unsigned int (**)(VoiceProcessorV8 *, uint64_t, uint64_t))(*(_QWORD *)this + 712))(this, v62, v63))
  {
    v113 = *((_DWORD *)this + 21);
    if (v113 == 1718628662 || v113 == 1718628408)
    {
      LODWORD(inData) = 0;
      AudioUnitSetProperty(*((AudioUnit *)this + 404), 0x15u, 0, 0, &inData, 4u);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v114 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v115 = (*v114 ? *v114 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v115, OS_LOG_TYPE_DEBUG))
        {
          CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)v141, *((_DWORD *)this + 596));
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "VoiceProcessor_v8.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 579;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v141;
          _os_log_impl(&dword_1B5ED0000, v115, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> known headphones with ReverbSuppressor AU preset override detected %s", buf, 0x1Cu);
        }
      }
      v116 = (int *)*((_QWORD *)this + 1570);
      if (v116 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v117 = VPLogScope(void)::scope;
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)buf, *((_DWORD *)this + 596));
        CALegacyLog::log(v116, 5, v117, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 579, "ApplyPortSubtypeTuningOverride", "known headphones with ReverbSuppressor AU preset override detected %s", (const char *)buf);
      }
      v157 = unk_1B6687C3C;
      memset(v158, 0, sizeof(v158));
      v153 = unk_1B6687BFC;
      v154 = xmmword_1B6687C0C;
      v155 = unk_1B6687C1C;
      v156 = xmmword_1B6687C2C;
      v149 = unk_1B6687BBC;
      v150 = xmmword_1B6687BCC;
      v151 = unk_1B6687BDC;
      v152 = xmmword_1B6687BEC;
      strcpy((char *)buf, "vptx_reverbsuppressor_telephony");
      *(_OWORD *)&buf[32] = xmmword_1B6687B8C;
      v147 = unk_1B6687B9C;
      v148 = xmmword_1B6687BAC;
      v118 = *((_QWORD *)this + 341);
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCString(0, "Generic", 0x600u);
      __str.__r_.__value_.__s.__data_[8] = 1;
      cf = CFStringCreateWithCString(0, "Headphones", 0x600u);
      v145 = 1;
      v138 = CFStringCreateWithCString(0, (const char *)buf, 0x600u);
      v139 = 1;
      *(_QWORD *)v141 = &__str;
      *(_QWORD *)&v141[8] = &cf;
      *(_QWORD *)&v141[16] = &v138;
      TuningInSubdirs = TuningPListMgr::loadTuningInSubdirs_(v118, (const __CFString ***)v141, 3u, 1u);
      CACFString::~CACFString((CACFString *)&v138);
      CACFString::~CACFString((CACFString *)&cf);
      CACFString::~CACFString((CACFString *)&__str);
      if ((_DWORD)TuningInSubdirs)
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v119 = (_QWORD *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
        {
          v120 = (*v119 ? *v119 : MEMORY[0x1E0C81028]);
          if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
          {
            v121 = (_QWORD *)((char *)this + 8);
            if (*((char *)this + 31) < 0)
              v121 = (_QWORD *)*v121;
            *(_DWORD *)v141 = 136315906;
            *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
            *(_WORD *)&v141[12] = 1024;
            *(_DWORD *)&v141[14] = 585;
            *(_WORD *)&v141[18] = 2080;
            *(_QWORD *)&v141[20] = v121;
            v142 = 2080;
            v143 = (const char *)buf;
            _os_log_impl(&dword_1B5ED0000, v120, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> : failed to find Headphone ReverbSuppressor aupreset: %s/Generic/Headphones/%s", v141, 0x26u);
          }
        }
        v122 = (int *)*((_QWORD *)this + 1570);
        if (v122 && (*v3 || v3[1]))
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v123 = (char *)this + 8;
          if (*((char *)this + 31) < 0)
            v123 = *(const char **)v123;
          CALegacyLog::log(v122, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 585, "ApplyPortSubtypeTuningOverride", ": failed to find Headphone ReverbSuppressor aupreset: %s/Generic/Headphones/%s", v123, (const char *)buf);
        }
      }
      else
      {
        v124 = TuningPListMgr::lookupPlist_(*((_QWORD *)this + 341), (const char *)buf, 1u);
        cf = v124;
        if (v124)
        {
          CFRetain(v124);
          AUPropAndParamHelper::AddItemToAUPropsList((AUPropertyItem **)this + 1050, 0, 0, 0, 8uLL, &cf, 1);
          CFRelease(cf);
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v125 = (_QWORD *)VPLogScope(void)::scope;
          if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
          {
            v126 = (*v125 ? *v125 : MEMORY[0x1E0C81028]);
            if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v141 = 136315906;
              *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
              *(_WORD *)&v141[12] = 1024;
              *(_DWORD *)&v141[14] = 596;
              *(_WORD *)&v141[18] = 2080;
              *(_QWORD *)&v141[20] = buf;
              v142 = 2080;
              v143 = "(UL-)ReverbSuppressor";
              _os_log_impl(&dword_1B5ED0000, v126, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> found Headphone ReverbSuppressor aupreset:%s for %s", v141, 0x26u);
            }
          }
          v127 = (int *)*((_QWORD *)this + 1570);
          if (v127 && (*v3 || v3[1]))
          {
            if (VPLogScope(void)::once != -1)
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            CALegacyLog::log(v127, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 596, "ApplyPortSubtypeTuningOverride", "found Headphone ReverbSuppressor aupreset:%s for %s", (const char *)buf, "(UL-)ReverbSuppressor");
          }
          std::string::basic_string[abi:ne180100]<0>(v141, "(UL-)ReverbSuppressor");
          __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v141;
          v128 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)this + 4616, v141, (uint64_t)&std::piecewise_construct, (__int128 **)&__str);
          std::string::__assign_external((std::string *)(v128 + 40), (const std::string::value_type *)buf);
          if ((v141[23] & 0x80000000) != 0)
            operator delete(*(void **)v141);
        }
        else
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v129 = (_QWORD *)VPLogScope(void)::scope;
          if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
          {
            v130 = (*v129 ? *v129 : MEMORY[0x1E0C81028]);
            if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v141 = 136315906;
              *(_QWORD *)&v141[4] = "VoiceProcessor_v8.cpp";
              *(_WORD *)&v141[12] = 1024;
              *(_DWORD *)&v141[14] = 600;
              *(_WORD *)&v141[18] = 2080;
              *(_QWORD *)&v141[20] = buf;
              v142 = 2080;
              v143 = "(UL-)ReverbSuppressor";
              _os_log_impl(&dword_1B5ED0000, v130, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> : failed to load Headphone EQ tuning aupreset:%s for %s", v141, 0x26u);
            }
          }
          v131 = (int *)*((_QWORD *)this + 1570);
          if (v131 && (*v3 || v3[1]))
          {
            if (VPLogScope(void)::once != -1)
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            CALegacyLog::log(v131, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v8/VoiceProcessor_v8.cpp", 600, "ApplyPortSubtypeTuningOverride", ": failed to load Headphone EQ tuning aupreset:%s for %s", (const char *)buf, "(UL-)ReverbSuppressor");
          }
        }
      }
    }
  }
  return TuningInSubdirs;
}

void sub_1B60F72D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(exception_object);
}

float VoiceProcessorV5::GetDynamicDuckingOffset(VoiceProcessorV5 *this)
{
  return 1.0;
}

uint64_t VoiceProcessorV8::ReblockerForOCNSAndSpeechEnhancer(VoiceProcessorV8 *this, uint64_t a2, const AudioBufferList **a3, AudioBufferList **a4)
{
  (*(void (**)(VoiceProcessorV8 *, _QWORD, _QWORD, uint64_t, uint64_t))(*(_QWORD *)this + 768))(this, *a3, *a4, 1, a2);
  return 0;
}

void CAX4CCStringNoQuote::CAX4CCStringNoQuote(CAX4CCStringNoQuote *this, unsigned int a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v4 = bswap32(a2);
  *(_DWORD *)this = v4;
  v5 = MEMORY[0x1E0C80978];
  if ((v4 & 0x80) != 0)
  {
    if (!__maskrune((char)v4, 0x40000uLL))
      goto LABEL_17;
  }
  else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v4 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  v6 = *((char *)this + 1);
  if ((v6 & 0x80000000) != 0)
  {
    if (!__maskrune(v6, 0x40000uLL))
      goto LABEL_17;
  }
  else if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  v7 = *((char *)this + 2);
  if ((v7 & 0x80000000) != 0)
  {
    if (!__maskrune(v7, 0x40000uLL))
      goto LABEL_17;
LABEL_13:
    v8 = *((char *)this + 3);
    if ((v8 & 0x80000000) != 0)
    {
      if (!__maskrune(v8, 0x40000uLL))
        goto LABEL_17;
    }
    else if ((*(_DWORD *)(v5 + 4 * v8 + 60) & 0x40000) == 0)
    {
      goto LABEL_17;
    }
    *((_BYTE *)this + 4) = 0;
    return;
  }
  if ((*(_DWORD *)(v5 + 4 * v7 + 60) & 0x40000) != 0)
    goto LABEL_13;
LABEL_17:
  if (a2 + 199999 > 0x61A7E)
    snprintf((char *)this, 0x10uLL, "0x%x");
  else
    snprintf((char *)this, 0x10uLL, "%d");
}

void CALegacyLog::log(int *a1, int a2, uint64_t a3, char *a4, uint64_t a5, const char *a6, char *__format, ...)
{
  int v12;
  CATimeUtilities *v13;
  unsigned int v14;
  uint64_t CurrentGregorianDate;
  double v16;
  int v17;
  int v18;
  _opaque_pthread_t *v19;
  int v20;
  char *v21;
  size_t v22;
  int v23;
  int v24;
  int v25;
  FILE *v26;
  FILE *v27;
  int v28;
  int v29;
  char __str[1024];
  _OWORD v31[4];
  char v32[1024];
  uint64_t v33;
  va_list va;

  va_start(va, __format);
  v33 = *MEMORY[0x1E0C80C00];
  if (vsnprintf(__str, 0x400uLL, __format, va) < 0)
    return;
  if (!a3)
  {
    bzero(v32, 0x400uLL);
    LOBYTE(v12) = 31;
LABEL_7:
    CurrentGregorianDate = CATimeUtilities::GetCurrentGregorianDate(v13);
    v17 = snprintf(v32, 0x400uLL, "%.2d:%.2d:%.2d.%.3d ", (int)((unint64_t)CurrentGregorianDate >> 24) >> 24, CurrentGregorianDate >> 56, (int)v16, (int)((v16 - (double)(int)v16) * 1000.0));
    v14 = v17 & ~(v17 >> 31);
    if ((v12 & 2) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
  v12 = *(_DWORD *)(a3 + 48);
  bzero(v32, 0x400uLL);
  if ((v12 & 1) != 0)
    goto LABEL_7;
  v14 = 0;
  if ((v12 & 2) != 0)
  {
LABEL_8:
    v18 = snprintf(&v32[v14], 1024 - v14, "%s", gPriorityStrings[a2 - 1]);
    v14 += v18 & ~(v18 >> 31);
  }
LABEL_9:
  if ((v12 & 4) != 0)
  {
    memset(v31, 0, sizeof(v31));
    v19 = pthread_self();
    pthread_getname_np(v19, (char *)v31, 0x40uLL);
    if (LOBYTE(v31[0]))
    {
      v20 = snprintf(&v32[v14], 1024 - v14, "[%s] ");
    }
    else
    {
      pthread_self();
      v20 = snprintf(&v32[v14], 1024 - v14, "[%p] ");
    }
    v14 += v20 & ~(v20 >> 31);
    if (!a3)
      goto LABEL_21;
LABEL_16:
    if (*(_QWORD *)(a3 + 24))
    {
      v21 = &v32[v14];
      v22 = 1024 - v14;
      if (a2 >= 3)
        v23 = snprintf(v21, v22, "<%s> ");
      else
        v23 = snprintf(v21, v22, ">%s> ");
      v14 += v23 & ~(v23 >> 31);
    }
    goto LABEL_21;
  }
  if (a3)
    goto LABEL_16;
LABEL_21:
  if ((v12 & 8) != 0)
  {
    if (a4)
    {
      strrchr(a4, 47);
      v24 = snprintf(&v32[v14], 1024 - v14, "%s:%d: ");
    }
    else
    {
      v24 = snprintf(&v32[v14], 1024 - v14, "%d: ");
    }
    v14 += v24 & ~(v24 >> 31);
  }
  if (a6 && (v12 & 0x10) != 0)
  {
    v25 = snprintf(&v32[v14], 1024 - v14, "%s: ", a6);
    v14 += v25 & ~(v25 >> 31);
  }
  snprintf(&v32[v14], 1024 - v14, "%s", __str);
  if (!a3
    || (v26 = *(FILE **)(a3 + 56)) == 0
    || (fprintf(v26, "%s\n", v32), fflush(*(FILE **)(a3 + 56)), !*(_BYTE *)(a3 + 64)))
  {
    v27 = (FILE *)*((_QWORD *)a1 + 1);
    if (v27)
    {
      fprintf(v27, "%s\n", v32);
      fflush(*((FILE **)a1 + 1));
    }
    else
    {
      if (a2 >= 3)
        v28 = 3;
      else
        v28 = a2;
      v29 = *a1;
      if (*a1 == 3)
      {
        puts(v32);
      }
      else if (v29 == 2)
      {
        syslog(v28 + 2, "%s", v32);
      }
      else if (v29 == 1)
      {
        CFLog();
      }
    }
  }
}

void CACFString::~CACFString(CACFString *this)
{
  const void *v2;

  if (*((_BYTE *)this + 8))
  {
    v2 = *(const void **)this;
    if (*(_QWORD *)this)
      CFRelease(v2);
  }
}

void AUPropAndParamHelper::AddItemToAUPropsList(AUPropertyItem **a1, unsigned int a2, unsigned int a3, unsigned int a4, size_t size, void *a6, int a7)
{
  AUPropertyItem *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  size_t v13;
  unsigned int v14;
  void *v15;
  AUPropertyItem *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  unint64_t *v22;
  uint64_t v23;
  size_t v24;
  unsigned int v25;
  AUPropertyItem *v26;
  AUPropertyItem *v27;
  AUPropertyItem *v28;
  size_t v29;
  int v30;
  const void *v31;
  AUPropertyItem *v32;
  AUPropertyItem *v33;
  __int128 v34;
  __int128 v35;
  AUPropertyItem *v36;
  unint64_t v37;
  unsigned int v38;
  unsigned int v39;
  void *v40;
  char *v41;
  _BYTE v42[24];
  _QWORD *v43;
  _QWORD v44[3];
  char v45;
  __int128 v46;
  __int128 v47;

  if (a7 && (v8 = *a1, (v9 = a1[1] - *a1) != 0))
  {
    v10 = v9 / 24;
    if (v10 <= 1)
      v10 = 1;
    while (*(_DWORD *)v8 != a2 || *((_DWORD *)v8 + 1) != a3 || *((_DWORD *)v8 + 2) != a4)
    {
      v8 = (AUPropertyItem *)((char *)v8 + 24);
      if (!--v10)
        goto LABEL_9;
    }
    AUPropertyItem::SetData(v8, size, a6);
  }
  else
  {
LABEL_9:
    v40 = 0;
    v37 = __PAIR64__(a3, a2);
    v38 = a4;
    v39 = 0;
    AUPropertyItem::SetData((AUPropertyItem *)&v37, size, a6);
    v11 = (unint64_t)a1[2];
    v12 = (unint64_t *)a1[1];
    if ((unint64_t)v12 >= v11)
    {
      v17 = 0xAAAAAAAAAAAAAAABLL * (((char *)v12 - (char *)*a1) >> 3);
      if (v17 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (_QWORD)*a1) >> 3);
      v19 = 2 * v18;
      if (2 * v18 <= v17 + 1)
        v19 = v17 + 1;
      if (v18 >= 0x555555555555555)
        v20 = 0xAAAAAAAAAAAAAAALL;
      else
        v20 = v19;
      v43 = a1 + 2;
      v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(v20);
      v22 = (unint64_t *)&v21[24 * v17];
      v41 = v21;
      *(_QWORD *)v42 = v22;
      *(_QWORD *)&v42[8] = v22;
      *(_QWORD *)&v42[16] = &v21[24 * v23];
      v22[2] = 0;
      v25 = v38;
      v24 = v39;
      v15 = v40;
      *v22 = v37;
      v22[1] = v25;
      AUPropertyItem::SetData((AUPropertyItem *)v22, v24, v15);
      v26 = *(AUPropertyItem **)v42;
      *(_QWORD *)&v42[8] += 24;
      v28 = *a1;
      v27 = a1[1];
      *(_QWORD *)&v47 = *(_QWORD *)v42;
      *((_QWORD *)&v47 + 1) = *(_QWORD *)v42;
      v46 = v47;
      v44[0] = a1 + 2;
      v44[1] = &v46;
      v44[2] = &v47;
      v45 = 0;
      if (v27 != v28)
      {
        do
        {
          *((_DWORD *)v26 - 3) = 0;
          *((_QWORD *)v26 - 1) = 0;
          if (v27 != v26)
          {
            v30 = *((_DWORD *)v27 - 4);
            v29 = *((unsigned int *)v27 - 3);
            v31 = (const void *)*((_QWORD *)v27 - 1);
            *((_QWORD *)v26 - 3) = *((_QWORD *)v27 - 3);
            v32 = (AUPropertyItem *)((char *)v26 - 24);
            *((_DWORD *)v32 + 2) = v30;
            AUPropertyItem::SetData(v32, v29, v31);
            v26 = (AUPropertyItem *)*((_QWORD *)&v47 + 1);
          }
          v27 = (AUPropertyItem *)((char *)v27 - 24);
          v26 = (AUPropertyItem *)((char *)v26 - 24);
          *((_QWORD *)&v47 + 1) = v26;
        }
        while (v27 != v28);
        v15 = v40;
      }
      v45 = 1;
      std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<AUPropertyItem>,std::reverse_iterator<AUPropertyItem*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v44);
      v33 = a1[2];
      v34 = *(_OWORD *)&v42[8];
      v36 = *(AUPropertyItem **)&v42[8];
      v35 = *(_OWORD *)a1;
      *a1 = v26;
      *(_OWORD *)v42 = v35;
      *(_OWORD *)(a1 + 1) = v34;
      *(_QWORD *)&v42[16] = v33;
      v41 = (char *)v35;
      std::__split_buffer<AUPropertyItem>::~__split_buffer((uint64_t)&v41);
      v16 = v36;
    }
    else
    {
      v12[2] = 0;
      v14 = v38;
      v13 = v39;
      v15 = v40;
      *v12 = v37;
      v12[1] = v14;
      AUPropertyItem::SetData((AUPropertyItem *)v12, v13, v15);
      v16 = (AUPropertyItem *)(v12 + 3);
      a1[1] = (AUPropertyItem *)(v12 + 3);
    }
    a1[1] = v16;
    if (v15)
      free(v15);
  }
}

void sub_1B60F7BA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  std::__split_buffer<AUPropertyItem>::~__split_buffer((uint64_t)&a14);
  if (a13)
    free(a13);
  _Unwind_Resume(a1);
}

void AUPropertyItem::SetData(AUPropertyItem *this, size_t size, const void *a3)
{
  unsigned int v4;
  void *v6;
  void *v7;
  void *v8;
  std::bad_alloc *exception;
  std::bad_alloc *v10;

  v4 = size;
  v6 = (void *)*((_QWORD *)this + 2);
  if (v6)
    free(v6);
  *((_DWORD *)this + 3) = 0;
  *((_QWORD *)this + 2) = 0;
  if (a3)
  {
    v7 = malloc_type_malloc(v4, 0x2C8E6D5CuLL);
    v8 = v7;
    if (v4 && !v7)
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v10 = std::bad_alloc::bad_alloc(exception);
    }
    bzero(v7, v4);
    *((_QWORD *)this + 2) = v8;
    if (v8)
    {
      memcpy(v8, a3, v4);
      *((_DWORD *)this + 3) = v4;
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a1);
}

uint64_t std::__split_buffer<AUPropertyItem>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 24;
    v4 = *(void **)(i - 8);
    if (v4)
    {
      free(v4);
      *(_QWORD *)(i - 8) = 0;
    }
    *(_QWORD *)(i - 24) = 0;
    *(_QWORD *)(i - 16) = 0;
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<AUPropertyItem>,std::reverse_iterator<AUPropertyItem*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = *(_QWORD **)(*(_QWORD *)(a1 + 16) + 8);
    v4 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8);
    while (v3 != v4)
    {
      v5 = (void *)v3[2];
      if (v5)
      {
        free(v5);
        v3[2] = 0;
      }
      *v3 = 0;
      v3[1] = 0;
      v3 += 3;
    }
  }
  return a1;
}

uint64_t VoiceProcessorV8::ReblockerForOCNSAndSpeechEnhancerCB(VoiceProcessorV8 *this, void *a2, uint64_t a3, const AudioBufferList **a4, AudioBufferList **a5)
{
  return (*(uint64_t (**)(VoiceProcessorV8 *, void *, uint64_t, const AudioBufferList **))(*(_QWORD *)this
                                                                                                  + 760))(this, a2, a3, a4);
}

uint64_t *std::unique_ptr<BlockProcessor>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    BlockBuffer::~BlockBuffer((BlockBuffer *)(v2 + 24));
    BlockBuffer::~BlockBuffer((BlockBuffer *)v2);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

uint64_t caulk::details::lifetime_guard_base<VoiceProcessorV2>::invalidate(uint64_t result)
{
  uint64_t v1;
  caulk::semaphore *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  if (*(_QWORD *)(result + 8))
  {
    v1 = result;
    v2 = (caulk::semaphore *)(result + 24);
    _ZNSt3__18optionalIN5caulk9semaphoreEE7emplaceB8ne180100IJEvEERS2_DpOT_((caulk::semaphore *)(result + 24));
    v3 = *(std::__shared_weak_count **)(v1 + 16);
    *(_QWORD *)(v1 + 8) = 0;
    *(_QWORD *)(v1 + 16) = 0;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    result = caulk::semaphore::timed_wait(v2, -1.0);
    __dmb(9u);
  }
  return result;
}

void VoiceProcessorV8::VoiceProcessorV8(VoiceProcessorV8 *this, const vp::Context *a2)
{
  uint64_t v2;

  VoiceProcessorV4::VoiceProcessorV4(this, a2);
  *(_QWORD *)(v2 + 17056) = 0;
  *(_OWORD *)(v2 + 17040) = 0u;
  *(_BYTE *)(v2 + 17064) = 0;
  *(_BYTE *)(v2 + 479) = 1;
  *(_OWORD *)(v2 + 17072) = 0u;
  *(_OWORD *)(v2 + 17088) = 0u;
  *(_OWORD *)(v2 + 17104) = 0u;
  *(_OWORD *)(v2 + 17120) = 0u;
  *(_OWORD *)(v2 + 17136) = 0u;
  *(_OWORD *)(v2 + 17152) = 0u;
  *(_OWORD *)(v2 + 17168) = 0u;
  *(_DWORD *)(v2 + 17184) = 0;
  *(_OWORD *)(v2 + 17192) = 0u;
  *(_OWORD *)(v2 + 17208) = 0u;
  *(_OWORD *)(v2 + 17224) = 0u;
  *(_OWORD *)(v2 + 17240) = 0u;
  *(_OWORD *)(v2 + 17256) = 0u;
  *(_OWORD *)(v2 + 17268) = 0u;
  *(_OWORD *)(v2 + 17304) = 0u;
  *(_OWORD *)(v2 + 17320) = 0u;
  *(_OWORD *)(v2 + 17288) = 0u;
  *(_QWORD *)v2 = &off_1E69C4EE8;
  *(_OWORD *)(v2 + 17336) = 0u;
  *(_OWORD *)(v2 + 17352) = 0u;
  *(_OWORD *)(v2 + 17368) = 0u;
  *(_OWORD *)(v2 + 17384) = 0u;
  *(_OWORD *)(v2 + 17400) = 0u;
  *(_OWORD *)(v2 + 17416) = 0u;
  *(_OWORD *)(v2 + 17432) = 0u;
  *(_OWORD *)(v2 + 17448) = 0u;
  *(_OWORD *)(v2 + 17464) = 0u;
  *(_OWORD *)(v2 + 17480) = 0u;
  *(_OWORD *)(v2 + 17496) = 0u;
  *(_OWORD *)(v2 + 17512) = 0u;
  *(_OWORD *)(v2 + 17521) = 0u;
  *(_OWORD *)(v2 + 17544) = 0u;
  *(_OWORD *)(v2 + 17560) = 0u;
  *(_OWORD *)(v2 + 17576) = 0u;
  *(_OWORD *)(v2 + 17592) = 0u;
  *(_QWORD *)(v2 + 17608) = 0;
  StartVPWirelessChargingMatStateListener();
}

void sub_1B60F8164(_Unwind_Exception *a1)
{
  VoiceProcessorV7 *v1;
  uint64_t *v2;
  void *v4;

  std::unique_ptr<BlockProcessor>::reset[abi:ne180100](v2, 0);
  v4 = (void *)*((_QWORD *)v1 + 2180);
  if (v4)
  {
    *((_QWORD *)v1 + 2181) = v4;
    operator delete(v4);
  }
  VoiceProcessorV7::~VoiceProcessorV7(v1);
  _Unwind_Resume(a1);
}

void vp::v8::create(vp::v8 *this@<X0>, VoiceProcessorV8 **a2@<X8>)
{
  VoiceProcessorV8 *v5;

  v5 = (VoiceProcessorV8 *)operator new();
  VoiceProcessorV8::VoiceProcessorV8(v5, this);
  *a2 = v5;
}

void sub_1B60F81E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10F3C404579F1B7);
  _Unwind_Resume(a1);
}

void AUCNG::~AUCNG(AUCNG *this)
{
  *(_QWORD *)this = &off_1E69C5200;
  ausdk::AUBase::~AUBase(this);
}

{
  *(_QWORD *)this = &off_1E69C5200;
  ausdk::AUBase::~AUBase(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AUCNG::Initialize(AUCNG *this)
{
  const void *v2;
  uint64_t Element;

  v2 = (const void *)(ausdk::AUScope::SafeGetElement((AUCNG *)((char *)this + 80), 0) + 80);
  Element = ausdk::AUScope::SafeGetElement((AUCNG *)((char *)this + 128), 0);
  if (!memcmp(v2, (const void *)(Element + 80), 0x28uLL))
    return 0;
  else
    return 4294956428;
}

uint64_t AUCNG::Reset(AUCNG *this)
{
  return 0;
}

uint64_t AUCNG::GetPropertyInfo(AUCNG *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    result = 0;
    *a6 = 1;
    *a5 = 4;
  }
  return result;
}

uint64_t AUCNG::GetProperty(AUCNG *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  int v8;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    v8 = (*(uint64_t (**)(AUCNG *))(*(_QWORD *)this + 576))(this);
    result = 0;
    *a5 = v8;
  }
  return result;
}

uint64_t AUCNG::SetProperty(AUCNG *this, int a2, int a3, unsigned int a4, int *a5, unsigned int a6)
{
  uint64_t result;
  int v8;
  int v9;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    if (a6 >= 4)
    {
      v8 = *a5;
      v9 = *a5 != 0;
      if (v9 != (*(unsigned int (**)(AUCNG *))(*(_QWORD *)this + 576))(this))
        (*(void (**)(AUCNG *, BOOL))(*(_QWORD *)this + 584))(this, v8 != 0);
      return 0;
    }
    else
    {
      return 4294956445;
    }
  }
  return result;
}

uint64_t AUCNG::GetParameter(AUCNG *this, unsigned int a2, unsigned int a3, unsigned int a4, float *a5)
{
  uint64_t v8;
  ausdk::AUElement *v9;
  uint64_t result;
  ausdk::AUElement **v11;
  ausdk::AUElement ***v12;
  float Parameter;

  if (a2 > 1)
    return 4294956418;
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v12 = (ausdk::AUElement ***)((char *)this + 48);
    v11 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (v12[1] == v11)
      v9 = 0;
    else
      v9 = *v11;
  }
  Parameter = ausdk::AUElement::GetParameter(v9, a2);
  result = 0;
  *a5 = Parameter;
  return result;
}

uint64_t AUCNG::SetParameter(AUCNG *this, unsigned int a2, float a3)
{
  uint64_t v6;
  ausdk::AUElement *v7;
  ausdk::AUElement **v9;
  ausdk::AUElement ***v10;

  if (a2 > 1)
    return 4294956418;
  v6 = *((_QWORD *)this + 9);
  if (v6)
  {
    v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
  }
  else
  {
    v10 = (ausdk::AUElement ***)((char *)this + 48);
    v9 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (v10[1] == v9)
      v7 = 0;
    else
      v7 = *v9;
  }
  ausdk::AUElement::SetParameter(v7, a2, a3, 0);
  return 0;
}

uint64_t AUCNG::CanScheduleParameters(AUCNG *this)
{
  return 0;
}

uint64_t AUCNG::ProcessBufferLists(AUCNG *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, unsigned int a5)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  float Parameter;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  float v18;
  unint64_t v19;
  uint64_t v20;
  float __B;

  if (((*(uint64_t (**)(AUCNG *, unsigned int *, const AudioBufferList *))(*(_QWORD *)this + 576))(this, a2, a3) & 1) == 0)
  {
    if (a4->mBuffers[0].mDataByteSize >= 4)
    {
      v8 = 0;
      do
        *((float *)a4->mBuffers[0].mData + v8++) = (float)((float)((float)random() * 4.6566e-10) * 2.0) + -1.0;
      while (v8 < (unint64_t)a4->mBuffers[0].mDataByteSize >> 2);
    }
    if (a4->mNumberBuffers >= 2)
    {
      v9 = 1;
      v10 = 32;
      do
      {
        memcpy(*(void **)((char *)&a4->mNumberBuffers + v10), a4->mBuffers[0].mData, a4->mBuffers[0].mDataByteSize);
        ++v9;
        v10 += 16;
      }
      while (v9 < a4->mNumberBuffers);
    }
    v11 = *((_QWORD *)this + 9);
    if (v11)
    {
      v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
    }
    else
    {
      v13 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v13)
        v12 = 0;
      else
        v12 = *v13;
    }
    Parameter = ausdk::AUElement::GetParameter(v12, 0);
    v15 = *((_QWORD *)this + 9);
    if (v15)
    {
      v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
    }
    else
    {
      v17 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v17)
        v16 = 0;
      else
        v16 = *v17;
    }
    v18 = Parameter + ausdk::AUElement::GetParameter(v16, 1u);
    if (v18 != 0.0)
    {
      __B = __exp10f(v18 / 20.0);
      if (a4->mNumberBuffers)
      {
        v19 = 0;
        v20 = 16;
        do
        {
          vDSP_vsmul(*(const float **)((char *)&a4->mNumberBuffers + v20), 1, &__B, *(float **)((char *)&a4->mNumberBuffers + v20), 1, a5);
          ++v19;
          v20 += 16;
        }
        while (v19 < a4->mNumberBuffers);
      }
    }
  }
  return 0;
}

uint64_t ausdk::AUBase::ProcessMultipleBufferLists(ausdk::AUBase *this, unsigned int *a2, unsigned int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  return 4294967292;
}

uint64_t ausdk::AUBase::ComplexRender(ausdk::AUBase *this, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, unsigned int a5, unsigned int *a6, AudioStreamPacketDescription *a7, AudioBufferList *a8, void *a9, unsigned int *a10)
{
  return 4294967292;
}

uint64_t ausdk::AUBase::RenderBus(ausdk::AUBase *this, unsigned int *a2, const AudioTimeStamp *a3)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;

  if (a3->mSampleTime == *((double *)this + 34))
    return 0;
  v3 = *(_OWORD *)&a3->mSampleTime;
  v4 = *(_OWORD *)&a3->mRateScalar;
  v5 = *(_OWORD *)&a3->mSMPTETime.mHours;
  *((_OWORD *)this + 19) = *(_OWORD *)&a3->mSMPTETime.mSubframes;
  *((_OWORD *)this + 20) = v5;
  *((_OWORD *)this + 17) = v3;
  *((_OWORD *)this + 18) = v4;
  return (*(uint64_t (**)(ausdk::AUBase *, unsigned int *))(*(_QWORD *)this + 208))(this, a2);
}

uint64_t AUCNG::Render(AUCNG *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUInputElement *Element;
  uint64_t result;
  uint64_t v10;
  uint64_t BufferList;
  uint64_t v12;
  uint64_t v13;

  if (!ausdk::AUBase::HasInput(this, 0))
    return 4294956420;
  Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUCNG *)((char *)this + 80), 0);
  result = ausdk::AUInputElement::PullInput(Element, a2, a3, 0, a4);
  if (!(_DWORD)result)
  {
    v10 = ausdk::AUScope::SafeGetElement((AUCNG *)((char *)this + 80), 0);
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    v12 = ausdk::AUScope::SafeGetElement((AUCNG *)((char *)this + 128), 0);
    v13 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v12 + 144));
    return (*(uint64_t (**)(AUCNG *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 176))(this, a2, BufferList, v13, a4);
  }
  return result;
}

uint64_t ausdk::AUBase::BusCountWritable(ausdk::AUBase *this)
{
  return 0;
}

double AUCNG::GetParameterInfo(AUCNG *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  double result;
  AudioUnitParameterOptions v6;

  buffer->flags = -1073741824;
  buffer->unitName = 0;
  if (!a2)
  {
    if (a3 == 1)
    {
      buffer->cfNameString = CFSTR("Gain Offset");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Gain Offset"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      *(_QWORD *)&result = 3250585600;
      *(_QWORD *)&buffer->minValue = 3250585600;
      v6 = buffer->flags & 0x3FFF7FFF | 0x40008000;
      buffer->defaultValue = 0.0;
      buffer->flags = v6;
    }
    else if (!a3)
    {
      buffer->cfNameString = CFSTR("Gain");
      buffer->flags = -939524096;
      CFStringGetCString(CFSTR("Gain"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      result = 524288.381;
      *(_QWORD *)&buffer->minValue = 0x41200000C2F00000;
      buffer->defaultValue = -120.0;
    }
  }
  return result;
}

uint64_t AUCNG::GetPresets(AUCNG *this, const __CFArray **a2)
{
  __CFArray *Mutable;

  if (a2)
  {
    Mutable = CFArrayCreateMutable(0, 2, 0);
    CFArrayAppendValue(Mutable, &sAUCNGPresets);
    CFArrayAppendValue(Mutable, &unk_1EF132630);
    *a2 = Mutable;
  }
  return 0;
}

uint64_t AUCNG::NewFactoryPresetSet(AUCNG *this, const AUPreset *a2)
{
  uint64_t presetNumber;
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v7;

  presetNumber = a2->presetNumber;
  if (presetNumber > 1)
    return 4294956445;
  v4 = *((_QWORD *)this + 9);
  if (v4)
  {
    v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  }
  else
  {
    v7 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v7)
      v5 = 0;
    else
      v5 = *v7;
  }
  ausdk::AUElement::SetParameter(v5, 0, -120.0, 0);
  ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, (const AUPreset *)&sAUCNGPresets + presetNumber);
  return 0;
}

double AUCNG::GetLatency(AUCNG *this)
{
  return 0.0;
}

double AUCNG::GetTailTime(AUCNG *this)
{
  return 0.0;
}

uint64_t AUCNG::SupportsTail(AUCNG *this)
{
  return 1;
}

BOOL AUCNG::StreamFormatWritable(AUCNG *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUCNG::SupportedNumChannels(AUCNG *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUCNG::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 2;
}

BOOL AUCNG::ValidFormat(AUCNG *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  _BOOL4 v5;

  if (ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2))
    v5 = (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
  else
    v5 = 0;
  return a4->mChannelsPerFrame - 1 < 2 && v5;
}

uint64_t ausdk::AUBase::GetScopeExtended(ausdk::AUBase *this)
{
  return 0;
}

uint64_t ausdk::AUBase::InRenderThread(ausdk::AUBase *this)
{
  pthread_t v2;
  _opaque_pthread_t *v3;
  BOOL v4;
  unsigned int v5;
  _BOOL4 v6;

  v2 = pthread_self();
  v3 = (_opaque_pthread_t *)*((_QWORD *)this + 32);
  if (v3)
    v4 = v2 == v3;
  else
    v4 = 0;
  v5 = v4;
  v6 = v3 == 0;
  if (v2)
    return v5;
  else
    return v6;
}

uint64_t ausdk::AUBase::Start(ausdk::AUBase *this)
{
  return 4294967292;
}

uint64_t ausdk::AUBase::Stop(ausdk::AUBase *this)
{
  return 4294967292;
}

uint64_t ausdk::AUBase::MIDIEvent(ausdk::AUBase *this)
{
  return 4294967292;
}

uint64_t ausdk::AUBase::SysEx(ausdk::AUBase *this, const unsigned __int8 *a2)
{
  return 4294967292;
}

uint64_t ausdk::AUBase::MIDIEventList(ausdk::AUBase *this, unsigned int a2, const MIDIEventList *a3)
{
  return 4294967292;
}

uint64_t ausdk::AUBase::StartNote(ausdk::AUBase *this, unsigned int a2, unsigned int a3, unsigned int *a4, unsigned int a5, const MusicDeviceNoteParams *a6)
{
  return 4294967292;
}

uint64_t ausdk::AUBase::StopNote(ausdk::AUBase *this)
{
  return 4294967292;
}

uint64_t ausdk::AUBase::ProcessScheduledSlice(ausdk::AUBase *this, void *a2)
{
  return 0;
}

uint64_t AUCNG::ShouldBypassEffect(AUCNG *this)
{
  return *((unsigned __int8 *)this + 528);
}

uint64_t AUCNG::SetBypassEffect(uint64_t this, char a2)
{
  *(_BYTE *)(this + 528) = a2;
  return this;
}

uint64_t ausdk::AUBase::HasInput(ausdk::AUBase *this, unsigned int a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  char *v6;

  v3 = *((_QWORD *)this + 15);
  if (!v3)
  {
    v6 = (char *)this + 96;
    v5 = *((_QWORD *)this + 12);
    if (a2 >= (unint64_t)((*((_QWORD *)v6 + 1) - v5) >> 3))
      return 0;
    result = *(_QWORD *)(v5 + 8 * a2);
    if (!result)
      return result;
    return *(_DWORD *)(result + 172) != 0;
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
  if (result)
    return *(_DWORD *)(result + 172) != 0;
  return result;
}

uint64_t ausdk::AUScope::SafeGetElement(ausdk::AUScope *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  ausdk::AUException *exception;
  _DWORD v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v2 + 32))(*((_QWORD *)this + 5));
    if (!result)
    {
LABEL_7:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v6[0] = 67109120;
        v6[1] = -10877;
        _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)v6, 8u);
      }
      exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
      ausdk::AUException::AUException(exception, -10877);
    }
  }
  else
  {
    v4 = *((_QWORD *)this + 2);
    if (a2 >= (unint64_t)((*((_QWORD *)this + 3) - v4) >> 3))
      goto LABEL_7;
    result = *(_QWORD *)(v4 + 8 * a2);
    if (!result)
      goto LABEL_7;
  }
  return result;
}

void sub_1B60F8C10(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::AUBufferList::GetBufferList(ausdk::AUBufferList *this)
{
  ausdk::AUException *exception;
  _DWORD v3[2];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)this)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v3[0] = 67109120;
      v3[1] = -1;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)v3, 8u);
    }
    exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(exception, -1);
  }
  return *((_QWORD *)this + 1) + 48;
}

void sub_1B60F8D08(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

std::runtime_error *ausdk::AUException::AUException(std::runtime_error *this, int a2)
{
  std::string *p_p;
  std::string::size_type size;
  std::string *v6;
  __int128 v7;
  std::string __p;
  std::string v10;
  std::string v11;

  std::string::basic_string[abi:ne180100]<0>(&v10, "OSStatus ");
  std::to_string(&__p, a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v6 = std::string::append(&v10, (const std::string::value_type *)p_p, size);
  v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  std::runtime_error::runtime_error(this, &v11);
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v11.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v10.__r_.__value_.__l.__data_);
  this->__vftable = (std::runtime_error_vtbl *)&off_1E69EDED8;
  LODWORD(this[1].__vftable) = a2;
  return this;
}

void sub_1B60F8E04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void ausdk::AUException::~AUException(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t LiteMatrix<float>::LiteMatrix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  std::vector<float>::resize(a1 + 16, a3 * a2);
  bzero(*(void **)(a1 + 16), *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16));
  return a1;
}

void sub_1B60F8EC4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiteMatrix<float>::operator()(unint64_t *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*a1 <= a2 || (v3 = a1[1], v3 <= a3))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "LiteMatrix.h";
      v7 = 1024;
      v8 = 125;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  subscript out of bounds", (uint8_t *)&v5, 0x12u);
    }
    __break(1u);
  }
  return a1[2] + 4 * (a3 + v3 * a2);
}

unint64_t CLiteMatrix::Get(CLiteMatrix *this, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)this <= a2 || (v3 = *((_QWORD *)this + 1), v3 <= a3))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "LiteMatrix.h";
      v7 = 1024;
      v8 = 262;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  subscript out of bounds", (uint8_t *)&v5, 0x12u);
    }
    __break(1u);
  }
  return *((_QWORD *)this + 2) + 4 * (a3 + v3 * a2);
}

float *RotationUtilities::yawPitchRoll2RotationMatrixFOA(RotationUtilities *this, CLiteMatrix *a2, float a3, float a4, float a5)
{
  __float2 v7;
  __float2 v8;
  float *result;

  if (*(_QWORD *)this != 4)
    __assert_rtn("yawPitchRoll2RotationMatrixFOA", "RotationUtilities.cpp", 119, "R.NumRows()==4");
  if (*((_QWORD *)this + 1) != 4)
    __assert_rtn("yawPitchRoll2RotationMatrixFOA", "RotationUtilities.cpp", 120, "R.NumCols()==4");
  v7 = __sincosf_stret(a3);
  v8 = __sincosf_stret(a4);
  *(_DWORD *)CLiteMatrix::Get(this, 0, 0) = 1065353216;
  *(_DWORD *)CLiteMatrix::Get(this, 0, 1uLL) = 0;
  *(_DWORD *)CLiteMatrix::Get(this, 0, 2uLL) = 0;
  *(_DWORD *)CLiteMatrix::Get(this, 0, 3uLL) = 0;
  *(_DWORD *)CLiteMatrix::Get(this, 1uLL, 0) = 0;
  *(float *)CLiteMatrix::Get(this, 1uLL, 1uLL) = v7.__cosval + (float)(v7.__sinval * (float)(v8.__sinval * -0.0));
  *(float *)CLiteMatrix::Get(this, 1uLL, 2uLL) = v8.__cosval * 0.0;
  *(float *)CLiteMatrix::Get(this, 1uLL, 3uLL) = v7.__sinval + (float)((float)(v7.__cosval * v8.__sinval) * 0.0);
  *(_DWORD *)CLiteMatrix::Get(this, 2uLL, 0) = 0;
  *(float *)CLiteMatrix::Get(this, 2uLL, 1uLL) = (float)(v7.__cosval * -0.0) - (float)(v8.__sinval * v7.__sinval);
  *(float *)CLiteMatrix::Get(this, 2uLL, 2uLL) = v8.__cosval;
  *(float *)CLiteMatrix::Get(this, 2uLL, 3uLL) = (float)(v7.__cosval * v8.__sinval) + (float)(v7.__sinval * -0.0);
  *(_DWORD *)CLiteMatrix::Get(this, 3uLL, 0) = 0;
  *(float *)CLiteMatrix::Get(this, 3uLL, 1uLL) = -(float)(v7.__sinval * v8.__cosval);
  *(float *)CLiteMatrix::Get(this, 3uLL, 2uLL) = -v8.__sinval;
  result = (float *)CLiteMatrix::Get(this, 3uLL, 3uLL);
  *result = v7.__cosval * v8.__cosval;
  return result;
}

void ASAParamsGeneric::~ASAParamsGeneric(ASAParamsGeneric *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

float ASAParamsGeneric::constructDerivedParams(ASAParamsGeneric *this)
{
  float v1;
  float v2;
  float v3;
  uint32x2_t v4;
  uint32x2_t v5;
  float result;

  v2 = *((float *)this + 2);
  v1 = *((float *)this + 3);
  v3 = v1 * *((float *)this + 7);
  *((float *)this + 12) = *((float *)this + 6) * v1;
  *((float *)this + 13) = v3;
  v4 = *(uint32x2_t *)((char *)this + 16);
  v5 = vsra_n_u32((uint32x2_t)0x100000001, v4, 1uLL);
  *((uint32x2_t *)this + 7) = v5;
  *((_DWORD *)this + 16) = (float)(unint64_t)((float)(v2 / v1) + 0.5);
  *((float *)this + 17) = v2 / (float)v4.u32[0];
  *((_DWORD *)this + 18) = v5.i32[0];
  result = 1.0 / (float)v5.u32[0];
  *((float *)this + 19) = result;
  return result;
}

void ASAParamsChromaHiFreq::~ASAParamsChromaHiFreq(ASAParamsChromaHiFreq *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

float ASAParamsChromaHiFreq::constructDerivedParams(ASAParamsChromaHiFreq *this)
{
  float result;

  result = 1.0 / (float)*((unsigned int *)this + 2);
  *((float *)this + 7) = result;
  return result;
}

void ASAParamsBeatsV2::~ASAParamsBeatsV2(ASAParamsBeatsV2 *this)
{
  void *v2;
  void *v3;
  void *v4;
  void **v5;

  *(_QWORD *)this = off_1E69C54B0;
  v5 = (void **)((char *)this + 112);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 8);
  if (v3)
  {
    *((_QWORD *)this + 9) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 5);
  if (v4)
  {
    *((_QWORD *)this + 6) = v4;
    operator delete(v4);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void **v5;

  *(_QWORD *)this = off_1E69C54B0;
  v5 = (void **)((char *)this + 112);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 8);
  if (v3)
  {
    *((_QWORD *)this + 9) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 5);
  if (v4)
  {
    *((_QWORD *)this + 6) = v4;
    operator delete(v4);
  }
  MEMORY[0x1BCC95CEC](this, 0x10A1C4039B2F151);
}

void ASAParamsHarmonicConsistency::~ASAParamsHarmonicConsistency(ASAParamsHarmonicConsistency *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E69C54D8;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_1E69C54D8;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsModEnergy2::~ASAParamsModEnergy2(ASAParamsModEnergy2 *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E69C5550;
  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)
  {
    *((_QWORD *)this + 6) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_1E69C5550;
  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)
  {
    *((_QWORD *)this + 6) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::__fs::filesystem::path>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>((uint64_t)(v6 + 2), a2, a3, (_QWORD *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B60F95F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void ASAParamsRms::~ASAParamsRms(ASAParamsRms *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsModEnergy::~ASAParamsModEnergy(ASAParamsModEnergy *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsLowEnergy::~ASAParamsLowEnergy(ASAParamsLowEnergy *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsRolloff::~ASAParamsRolloff(ASAParamsRolloff *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsCentroid::~ASAParamsCentroid(ASAParamsCentroid *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsFlux::~ASAParamsFlux(ASAParamsFlux *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsReconDiff::~ASAParamsReconDiff(ASAParamsReconDiff *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsCepstralSparsity::~ASAParamsCepstralSparsity(ASAParamsCepstralSparsity *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsCepstralVariance::~ASAParamsCepstralVariance(ASAParamsCepstralVariance *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsAvgPitchDensity::~ASAParamsAvgPitchDensity(ASAParamsAvgPitchDensity *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAParamsAvgTonalityPower::~ASAParamsAvgTonalityPower(ASAParamsAvgTonalityPower *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void ASAFeatures::ASAFeatures(ASAFeatures *this, const ASAParamsGeneric *a2, const ASAParamsChromaHiFreq *a3, const ASAParamsBeatsV2 *a4, const ASAParamsHarmonicConsistency *a5, const ASAParamsRms *a6, const ASAParamsModEnergy *a7, const ASAParamsModEnergy2 *a8, __int128 a9, __int128 a10, __int128 a11, __int128 a12, const ASAParamsAvgTonalityPower *a13, char a14)
{
  const ASAParamsBeatsV2 *v14;
  const ASAParamsGeneric *v16;
  ASAFeatures *v17;
  unsigned int v18;
  double v19;
  double v20;
  _QWORD *v21;
  float v22;
  uint32x2_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  uint64_t v36;
  int v37;
  const ASAParamsGeneric *v38;
  float v39;
  unint64_t v40;
  double v41;
  const ASAParamsGeneric *v42;
  float v43;
  uint64_t v44;
  float v45;
  float v46;
  float v47;
  double *v48;
  double v49;
  float v50;
  uint64_t v51;
  float v52;
  float v53;
  float v54;
  const ASAParamsGeneric *v55;
  uint32x2_t v56;
  int32x2_t v58;
  float (**v59)(uint64_t, uint64_t);
  unint64_t v60;
  float (**v61)(uint64_t, uint64_t);
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  _QWORD *v67;
  char *v68;
  char *v69;
  __int128 v70;
  unint64_t v71;
  float (**v72)(uint64_t, uint64_t);
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  char *v77;
  float (**v78)(uint64_t, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  char *v82;
  __int128 v83;
  unint64_t v84;
  float (**v85)(uint64_t, ASAFeatures **);
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  char *v90;
  float (**v91)(uint64_t, uint64_t);
  uint64_t v92;
  char *v93;
  char *v94;
  char *v95;
  __int128 v96;
  unint64_t v97;
  float (**v98)(uint64_t, ASAFeatures **);
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  char *v103;
  float (**v104)(uint64_t, ASAFeatures **);
  uint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  __int128 v109;
  unint64_t v110;
  _QWORD *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  char *v116;
  float (**v117)(uint64_t, ASAFeatures **);
  uint64_t v118;
  char *v119;
  char *v120;
  char *v121;
  __int128 v122;
  unint64_t v123;
  float (**v124)(uint64_t, ASAFeatures **);
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  char *v129;
  char *v130;
  uint64_t v131;
  char *v132;
  char *v133;
  char *v134;
  __int128 v135;
  unint64_t v136;
  float (**v137)(uint64_t, ASAFeatures **);
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  char *v142;
  float (**v143)(uint64_t, ASAFeatures **);
  uint64_t v144;
  char *v145;
  char *v146;
  char *v147;
  __int128 v148;
  unint64_t v149;
  float (**v150)(uint64_t, uint64_t);
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  unint64_t v154;
  char *v155;
  float (**v156)(uint64_t, ASAFeatures **);
  uint64_t v157;
  char *v158;
  char *v159;
  char *v160;
  __int128 v161;
  unint64_t v162;
  float (**v163)(uint64_t, uint64_t);
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  char *v168;
  float (**v169)(uint64_t, uint64_t);
  uint64_t v170;
  char *v171;
  char *v172;
  char *v173;
  __int128 v174;
  unint64_t v175;
  _QWORD *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  unint64_t v180;
  char *v181;
  float (**v182)(uint64_t, uint64_t);
  uint64_t v183;
  char *v184;
  char *v185;
  char *v186;
  __int128 v187;
  unint64_t v188;
  _QWORD *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  unint64_t v193;
  char *v194;
  char *v195;
  uint64_t v196;
  char *v197;
  char *v198;
  char *v199;
  __int128 v200;
  unint64_t v201;
  _QWORD *v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  unint64_t v206;
  char *v207;
  char *v208;
  uint64_t v209;
  char *v210;
  char *v211;
  char *v212;
  __int128 v213;
  unint64_t v214;
  float (**v215)(float **, uint64_t);
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  unint64_t v219;
  char *v220;
  char *v221;
  uint64_t v222;
  char *v223;
  char *v224;
  char *v225;
  __int128 v226;
  unint64_t v227;
  _QWORD *v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  unint64_t v232;
  char *v233;
  float (**v234)(float **, uint64_t);
  uint64_t v235;
  char *v236;
  char *v237;
  char *v238;
  __int128 v239;
  unint64_t v240;
  float (**v241)(uint64_t, uint64_t);
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  unint64_t v245;
  char *v246;
  char *v247;
  uint64_t v248;
  char *v249;
  char *v250;
  char *v251;
  __int128 v252;
  unint64_t v253;
  _QWORD *v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  unint64_t v258;
  char *v259;
  float (**v260)(uint64_t, uint64_t);
  uint64_t v261;
  char *v262;
  char *v263;
  char *v264;
  __int128 v265;
  unint64_t v266;
  float (**v267)(uint64_t, uint64_t);
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  unint64_t v271;
  char *v272;
  char *v273;
  uint64_t v274;
  char *v275;
  char *v276;
  char *v277;
  __int128 v278;
  unint64_t v279;
  char *v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  unint64_t v284;
  char *v285;
  float (**v286)(uint64_t, uint64_t);
  uint64_t v287;
  char *v288;
  char *v289;
  char *v290;
  __int128 v291;
  unint64_t v292;
  _QWORD *v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  unint64_t v297;
  char *v298;
  char *v299;
  uint64_t v300;
  char *v301;
  char *v302;
  char *v303;
  __int128 v304;
  uint64_t v305;
  void *v306;
  void *v307;
  uint64_t v309;
  void *v310;
  void *v311;
  uint64_t v313;
  void *v314;
  void *v315;
  uint64_t v316;
  void *v317;
  void *v318;
  uint64_t v319;
  void *v320;
  void *v321;
  uint64_t v322;
  void *v323;
  void *v324;
  _QWORD *v325;
  uint64_t v326;
  void *v327;
  void *v328;
  uint64_t v329;
  void *v330;
  void *v331;
  uint64_t v332;
  void *v333;
  void *v334;
  uint64_t v335;
  void *v336;
  void *v337;
  uint64_t v338;
  void *v339;
  void *v340;
  uint64_t v341;
  void *v342;
  void *v343;
  uint64_t v344;
  void *v345;
  void *v346;
  uint64_t v347;
  void *v348;
  void *v349;
  uint64_t v350;
  void *v351;
  void *v352;
  uint64_t v353;
  void *v354;
  void *v355;
  _OWORD *v356;
  _OWORD *v357;
  _QWORD *v358;
  uint64_t v359;
  void *v360;
  uint64_t v361;
  uint64_t v362;
  char *v363;
  uint64_t v364;
  int v365;
  int v366;
  uint64_t v367;
  int v368;
  int v369;
  int v370;
  uint64_t v371;
  void *v372;
  void *v373;
  uint64_t v374;
  void *v375;
  void *v376;
  _QWORD *v377;
  unint64_t v378;
  uint64_t v379;
  void *v380;
  void *v381;
  uint64_t v383;
  uint64_t v384;
  void *v385;
  void *v386;
  uint64_t v387;
  void *v388;
  void *v389;
  uint64_t v390;
  void *v391;
  void *v392;
  uint64_t v393;
  void *v394;
  void *v395;
  uint64_t v396;
  void *v397;
  void *v398;
  uint64_t v399;
  void *v400;
  void *v401;
  uint64_t v402;
  void *v403;
  void *v404;
  _QWORD *v405;
  uint64_t v406;
  void *v407;
  uint64_t v408;
  void *v409;
  void *v410;
  uint64_t v411;
  void *v412;
  void *v413;
  uint64_t v414;
  void *v415;
  void *v416;
  uint64_t v417;
  void *v418;
  void *v419;
  uint64_t v420;
  void *v421;
  void *v422;
  uint64_t v423;
  void *v424;
  void *v425;
  uint64_t v426;
  void *v427;
  void *v428;
  uint64_t v429;
  void *v430;
  void *v431;
  uint64_t v432;
  void *v433;
  void *v434;
  uint64_t v435;
  void *v436;
  void *v437;
  uint64_t v438;
  void *v439;
  void *v440;
  uint64_t v441;
  void *v442;
  void *v443;
  uint64_t v444;
  void *v445;
  void *v446;
  uint64_t v447;
  void *v448;
  void *v449;
  uint64_t v450;
  void *v451;
  void *v452;
  uint64_t v453;
  void *v454;
  void *v455;
  uint64_t v456;
  void *v457;
  void *v458;
  uint64_t v459;
  void *v460;
  void *v461;
  uint64_t v462;
  void *v463;
  void *v464;
  uint64_t v465;
  void *v466;
  void *v467;
  uint64_t v468;
  void *v469;
  void *v470;
  uint64_t v471;
  void *v472;
  void *v473;
  uint64_t v474;
  void *v475;
  void *v476;
  uint64_t v477;
  void *v478;
  void *v479;
  uint64_t v480;
  void *v481;
  void *v482;
  uint64_t v483;
  void *v484;
  void *v485;
  uint64_t v486;
  void *v487;
  void *v488;
  uint64_t v489;
  void *v490;
  void *v491;
  uint64_t v492;
  void *v493;
  void *v494;
  uint64_t v495;
  void *v496;
  void *v497;
  uint64_t v498;
  float *v499;
  float *v500;
  double *v501;
  double v502;
  uint64_t v503;
  double v504;
  uint64_t v505;
  unint64_t v506;
  float *v507;
  float *v508;
  uint64_t v509;
  __double2 v510;
  float cosval;
  float sinval;
  float32x2_t *v513;
  float32x2_t *v514;
  unsigned int v515;
  int v516;
  unsigned int v517;
  uint64_t v518;
  float v519;
  float32x2_t *v520;
  float v521;
  float v522;
  uint64_t i;
  float v524;
  float *v525;
  float32x2_t *v526;
  uint64_t v527;
  float32x2_t *v528;
  float v529;
  float v530;
  float v531;
  float *v532;
  float v533;
  float v534;
  float v535;
  float *v536;
  uint64_t v537;
  float v538;
  float v539;
  float32x2_t v540;
  float32x2_t v541;
  unint64_t v542;
  unsigned int v543;
  float v544;
  float v545;
  float v546;
  float *v547;
  float v548;
  float v549;
  double v550;
  double v551;
  float32x2_t v552;
  double v553;
  double v554;
  float *v555;
  uint64_t v556;
  float v557;
  double v558;
  double v559;
  long double v560;
  unsigned int *v561;
  uint64_t v562;
  float *v563;
  int v564;
  int v565;
  float v566;
  float *v567;
  double v568;
  float v569;
  float v570;
  int v571;
  float *v572;
  char v573;
  float v574;
  float *v575;
  uint64_t v576;
  float v577;
  uint64_t v578;
  float v579;
  float v580;
  float v581;
  float v582;
  float *v583;
  uint64_t v584;
  float v585;
  __double2 v586;
  float v587;
  float v588;
  float v589;
  float v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  float v595;
  float v596;
  float v597;
  void *v598;
  vDSP_Length v599;
  double v600;
  double v601;
  _QWORD *v602;
  float v603;
  double v604;
  double *v605;
  uint64_t v606;
  float v607;
  double v608;
  double v609;
  long double v610;
  float v611;
  uint64_t v612;
  uint64_t v613;
  uint64_t v614;
  uint64_t v615;
  uint64_t v616;
  unsigned int v617;
  float v618;
  float v619;
  float v620;
  unsigned int v621;
  float v622;
  unsigned int v623;
  float v624;
  float v625;
  float v626;
  float v627;
  float v628;
  float v629;
  float v630;
  float v631;
  float v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  uint64_t v641;
  _OWORD *v642;
  uint64_t v643;
  unint64_t v644;
  unint64_t v645;
  float32x2_t *v646;
  float v647;
  float v648;
  uint64_t v649;
  int v650;
  double v651;
  uint64_t v652;
  uint64_t v653;
  unint64_t v654;
  unint64_t v655;
  uint64_t *v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t v659;
  __int128 v660;
  uint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  float v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  int v671;
  void *v672;
  uint64_t v673;
  uint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  int v682;
  void *v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  double v687;
  float v688;
  uint64_t v689;
  uint64_t v690;
  uint64_t v691;
  int v692;
  void *v693;
  uint64_t v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  int v698;
  void *v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  int v704;
  void *v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  uint64_t v709;
  int v710;
  void *v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  int v716;
  void *v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  int v722;
  void *v723;
  uint64_t v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  int v728;
  void *v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t v732;
  uint64_t v733;
  uint64_t v734;
  uint64_t v735;
  int v736;
  void *v737;
  uint64_t v738;
  uint64_t v739;
  uint64_t v740;
  uint64_t v741;
  int v742;
  void *v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  void *v747;
  char *v748;
  unint64_t j;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  uint64_t v753;
  _DWORD *v754;
  _DWORD *v755;
  BOOL v756;
  float32x2_t *v757;
  int *v758;
  int **v759;
  uint64_t v760;
  unint64_t v761;
  _DWORD *v762;
  int v763;
  uint64_t v764;
  uint64_t v765;
  float32x2_t *v766;
  int64x2_t *v767;
  __int32 v768;
  __int32 v769;
  uint32x2_t v770;
  unint64_t v771;
  float32x2_t *v772;
  float32x2_t *v773;
  float32x2_t *v774;
  uint64_t v775;
  unint64_t v776;
  uint64_t v777;
  unint64_t v778;
  char *v779;
  uint64_t *v780;
  uint64_t v781;
  float32x2_t **v782;
  float32x2_t v783;
  uint64_t v784;
  int64x2_t v785;
  int32x2_t v786;
  int8x16_t v787;
  float64x2_t v788;
  float32x2_t *v790;
  unint64_t v791;
  float32x2_t *v792;
  uint64_t v793;
  float32x2_t *v794;
  float32x2_t *v795;
  float32x2_t *v796;
  float32x2_t v797;
  unint64_t v798;
  uint64_t v799;
  int v800;
  int v801;
  uint64_t v802;
  unint64_t v803;
  uint64_t *v804;
  float32x2_t *v805;
  float32x2_t *v806;
  uint64_t v807;
  uint64_t v808;
  uint64_t v809;
  unint64_t v810;
  uint64_t v811;
  uint64_t *v812;
  float32x2_t *v813;
  float32x2_t *v814;
  uint64_t v815;
  float32x2_t **v816;
  float32x2_t *v817;
  float32x2_t v818;
  unint64_t v819;
  float *v820;
  float32x2_t *v821;
  uint64_t v822;
  _QWORD *v823;
  std::bad_alloc *exception;
  std::bad_alloc *v825;
  std::bad_alloc *v826;
  _QWORD *v827;
  char *v828;
  float64x2_t v829;
  void **v830;
  float32x2_t **v831;
  void *v832;
  _BYTE *v833;
  void *__p;
  _BYTE *v835;
  double __B;
  double v837;
  uint64_t v838;

  v14 = a4;
  v16 = a2;
  v17 = this;
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 2) = a4;
  *((_QWORD *)this + 3) = a5;
  *((_QWORD *)this + 4) = a6;
  *((_QWORD *)this + 5) = a7;
  *((_QWORD *)this + 6) = a8;
  *(_OWORD *)((char *)this + 56) = a9;
  *(_OWORD *)((char *)this + 72) = a10;
  *(_OWORD *)((char *)this + 88) = a11;
  *(_OWORD *)((char *)this + 104) = a12;
  v828 = (char *)this + 768;
  *((_QWORD *)this + 15) = a13;
  v830 = (void **)((char *)this + 128);
  bzero((char *)this + 128, 0x250uLL);
  *(_OWORD *)((char *)v17 + 760) = 0u;
  *(_OWORD *)((char *)v17 + 776) = 0u;
  *(_OWORD *)((char *)v17 + 744) = 0u;
  *((_BYTE *)v17 + 976) = 1;
  *(_QWORD *)((char *)v17 + 980) = 1065353216;
  *((_DWORD *)v17 + 252) = 0;
  v18 = *((_DWORD *)a3 + 2);
  v19 = log((float)(*((float *)v16 + 2) * 0.5) / *((float *)a3 + 3));
  if (VADGenUtils::InvLogTwo(void)::result)
  {
    v20 = *(double *)VADGenUtils::InvLogTwo(void)::result;
  }
  else
  {
    v21 = (_QWORD *)operator new();
    *v21 = 0x3FF71547652B82FELL;
    VADGenUtils::InvLogTwo(void)::result = (uint64_t)v21;
    v14 = (const ASAParamsBeatsV2 *)*((_QWORD *)v17 + 2);
    v16 = *(const ASAParamsGeneric **)v17;
    v20 = 1.44269504;
  }
  v22 = v20 * v19;
  *((_DWORD *)v17 + 180) = (float)(unint64_t)((float)((float)(1.0 / (float)v18) + v22) + 0.5);
  __asm { FMOV            V1.2D, #0.5 }
  v829 = _Q1;
  v27 = vcvt_n_u32_f32(vcvt_f32_f64(vcvtq_f64_u64(vcvtq_u64_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vmul_n_f32(*(float32x2_t *)((char *)v14 + 28), *((float *)v16 + 3)), (float32x2_t)0x3F0000003F000000)), _Q1)))), 1uLL);
  v827 = (_QWORD *)((char *)v17 + 724);
  *(uint32x2_t *)((char *)v17 + 724) = v27;
  *((_DWORD *)v17 + 183) = *((_DWORD *)v16 + 11) - 2 * *((_DWORD *)v14 + 4);
  *((_DWORD *)v17 + 184) = ((*((_DWORD *)v14 + 6) * v27.i32[1]) >> 1) + 1;
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v17 + 31, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)v14 + 6) - *((_QWORD *)v14 + 5)) >> 2));
  std::vector<float>::resize((uint64_t)v828, 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(*(_QWORD *)(*((_QWORD *)v17 + 2) + 48) - *(_QWORD *)(*((_QWORD *)v17 + 2) + 40)) >> 2));
  v28 = *((_QWORD *)v17 + 2);
  v29 = *(_QWORD *)(v28 + 40);
  v30 = *(_QWORD *)(v28 + 48) - v29;
  if (v30)
  {
    v31 = 0;
    v32 = v30 / 12;
    v33 = *((_QWORD *)v17 + 93);
    v34 = (*((_QWORD *)v17 + 94) - v33) >> 2;
    if (v32 <= 1)
      v32 = 1;
    v35 = (int *)(v29 + 8);
    while (1)
    {
      if (v34 == v31)
        std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
      *(_DWORD *)(v33 + 4 * v31) = *(v35 - 2);
      v36 = *((_QWORD *)v17 + 96);
      if (v31 >= (*((_QWORD *)v17 + 97) - v36) >> 2)
        break;
      v37 = *v35;
      v35 += 3;
      *(_DWORD *)(v36 + 4 * v31++) = v37;
      if (v32 == v31)
        goto LABEL_11;
    }
LABEL_621:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
LABEL_11:
  v38 = *(const ASAParamsGeneric **)v17;
  v39 = *(float *)(*(_QWORD *)v17 + 12) * 0.2;
  *(double *)&v40 = v39 + 0.5;
  *((_DWORD *)v17 + 198) = (float)(unint64_t)*(double *)&v40 + 2;
  LODWORD(v40) = *((_DWORD *)v38 + 5);
  v41 = 1.0 / *(float *)(*((_QWORD *)v17 + 3) + 8);
  VADGenUtils::TwoPoleBandpassCoeff<double>((double *)v17 + 100, (double *)v17 + 101, (double *)v17 + 102, (v41 + v41) * 3.14159265 / ((double)v40 / *((float *)v38 + 2)));
  v42 = *(const ASAParamsGeneric **)v17;
  v43 = *(float *)(*(_QWORD *)v17 + 12);
  v44 = *((_QWORD *)v17 + 4);
  *((uint32x2_t *)v17 + 103) = vcvt_u32_f32(vcvt_f32_f64(vcvtq_f64_u64(vcvtq_u64_f64(vaddq_f64(vcvtq_f64_f32(vmul_n_f32(*(float32x2_t *)(*((_QWORD *)v17 + 3) + 16), v43)), v829)))));
  v45 = (float)(v43 * *(float *)(v44 + 20)) / (float)((float)(v43 * *(float *)(v44 + 20)) + 1.0);
  v46 = (float)(v43 * *(float *)(v44 + 16)) / (float)((float)(v43 * *(float *)(v44 + 16)) + 1.0);
  *((float *)v17 + 210) = (float)((float)(1.0 - v45) * 0.5) * (float)(v46 + 1.0);
  *((float *)v17 + 208) = v45 + v46;
  *((float *)v17 + 209) = -(float)(v45 * v46);
  v47 = *(float *)(v44 + 20) * *((float *)v42 + 3);
  *((float *)v17 + 211) = v47 / (float)(v47 + 1.0);
  v48 = (double *)VADGenUtils::TwoPi(void)::result;
  if (VADGenUtils::TwoPi(void)::result)
  {
    v49 = *(double *)VADGenUtils::TwoPi(void)::result;
  }
  else
  {
    v48 = (double *)operator new();
    *v48 = 6.28318531;
    VADGenUtils::TwoPi(void)::result = (uint64_t)v48;
    v42 = *(const ASAParamsGeneric **)v17;
    v49 = 6.28318531;
  }
  v50 = v49;
  VADGenUtils::TwoPoleBandpassCoeff<double>((double *)v17 + 106, (double *)v17 + 107, (double *)v17 + 108, (float)((float)(*(float *)(*((_QWORD *)v17 + 5) + 8) * v50) / *((float *)v42 + 3)));
  v51 = *((_QWORD *)v17 + 6);
  v52 = *(float *)(*(_QWORD *)v17 + 12);
  *((uint32x2_t *)v17 + 109) = vcvt_u32_f32(vcvt_f32_f64(vcvtq_f64_u64(vcvtq_u64_f64(vaddq_f64(vcvtq_f64_f32(vmul_n_f32(*(float32x2_t *)(v51 + 12), v52)), v829)))));
  v53 = *v48;
  VADGenUtils::TwoPoleBandpassCoeff<double>((double *)v17 + 110, (double *)v17 + 111, (double *)v17 + 112, (float)((float)(*(float *)(v51 + 8) * v53) / v52));
  v54 = *v48;
  VADGenUtils::TwoPoleBandpassCoeff<double>((double *)v17 + 113, (double *)v17 + 114, (double *)v17 + 115, (float)((float)(*(float *)(*((_QWORD *)v17 + 6) + 20) * v54)/ (float)(2 * *(_DWORD *)(*(_QWORD *)v17 + 44) - 1)));
  v55 = *(const ASAParamsGeneric **)v17;
  v56.i32[0] = *(_DWORD *)(*(_QWORD *)v17 + 72);
  v56.i32[1] = v56.i32[0] - 1;
  __asm { FMOV            V15.2S, #1.0 }
  *((float32x2_t *)v17 + 116) = vdiv_f32(_D15, vcvt_f32_u32(v56));
  v58 = (int32x2_t)vcvt_u32_f32(vcvt_f32_f64(vcvtq_f64_u64(vcvtq_u64_f64(vaddq_f64(vcvtq_f64_f32(vmul_n_f32(*(float32x2_t *)(*((_QWORD *)v17 + 14) + 8), *((float *)v55 + 2))), v829)))));
  *((int32x2_t *)v17 + 117) = v58;
  v58.i32[0] = vsub_s32(vdup_lane_s32(v58, 1), v58).u32[0];
  *((_DWORD *)v17 + 236) = v58.i32[0] + 1;
  *((float *)v17 + 237) = 1.0 / (float)(v58.i32[0] + 1);
  v59 = (float (**)(uint64_t, uint64_t))*((_QWORD *)v17 + 16);
  *((_QWORD *)v17 + 17) = v59;
  v60 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v59 >= v60)
  {
    v62 = v60 - (_QWORD)v59;
    v63 = v62 >> 3;
    if ((unint64_t)(v62 >> 3) <= 1)
      v63 = 1;
    if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF0)
      v64 = 0xFFFFFFFFFFFFFFFLL;
    else
      v64 = v63;
    v65 = std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v64);
    v67 = &v65[2 * v66];
    *v65 = ASAFeatures::ChromaHiFreq;
    v65[1] = 0;
    v61 = (float (**)(uint64_t, uint64_t))(v65 + 2);
    v69 = (char *)*((_QWORD *)v17 + 16);
    v68 = (char *)*((_QWORD *)v17 + 17);
    if (v68 != v69)
    {
      do
      {
        v70 = *((_OWORD *)v68 - 1);
        v68 -= 16;
        *((_OWORD *)v65 - 1) = v70;
        v65 -= 2;
      }
      while (v68 != v69);
      v68 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v65;
    *((_QWORD *)v17 + 17) = v61;
    *((_QWORD *)v17 + 18) = v67;
    if (v68)
      operator delete(v68);
  }
  else
  {
    *v59 = ASAFeatures::ChromaHiFreq;
    v59[1] = 0;
    v61 = v59 + 2;
  }
  *((_QWORD *)v17 + 17) = v61;
  v71 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v61 >= v71)
  {
    v73 = ((char *)v61 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v73 + 1) >> 60)
      goto LABEL_627;
    v74 = v71 - (_QWORD)*v830;
    v75 = v74 >> 3;
    if (v74 >> 3 <= (unint64_t)(v73 + 1))
      v75 = v73 + 1;
    if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFF0)
      v76 = 0xFFFFFFFFFFFFFFFLL;
    else
      v76 = v75;
    v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v76);
    v78 = (float (**)(uint64_t, uint64_t))&v77[16 * v73];
    v80 = &v77[16 * v79];
    *v78 = ASAFeatures::BeatsV2;
    v78[1] = 0;
    v72 = v78 + 2;
    v82 = (char *)*((_QWORD *)v17 + 16);
    v81 = (char *)*((_QWORD *)v17 + 17);
    if (v81 != v82)
    {
      do
      {
        v83 = *((_OWORD *)v81 - 1);
        v81 -= 16;
        *((_OWORD *)v78 - 1) = v83;
        v78 -= 2;
      }
      while (v81 != v82);
      v81 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v78;
    *((_QWORD *)v17 + 17) = v72;
    *((_QWORD *)v17 + 18) = v80;
    if (v81)
      operator delete(v81);
  }
  else
  {
    *v61 = ASAFeatures::BeatsV2;
    v61[1] = 0;
    v72 = v61 + 2;
  }
  *((_QWORD *)v17 + 17) = v72;
  v84 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v72 >= v84)
  {
    v86 = ((char *)v72 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v86 + 1) >> 60)
      goto LABEL_627;
    v87 = v84 - (_QWORD)*v830;
    v88 = v87 >> 3;
    if (v87 >> 3 <= (unint64_t)(v86 + 1))
      v88 = v86 + 1;
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF0)
      v89 = 0xFFFFFFFFFFFFFFFLL;
    else
      v89 = v88;
    v90 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v89);
    v91 = (float (**)(uint64_t, uint64_t))&v90[16 * v86];
    v93 = &v90[16 * v92];
    *v91 = ASAFeatures::HarmonicConsistency;
    v91[1] = 0;
    v85 = (float (**)(uint64_t, ASAFeatures **))(v91 + 2);
    v95 = (char *)*((_QWORD *)v17 + 16);
    v94 = (char *)*((_QWORD *)v17 + 17);
    if (v94 != v95)
    {
      do
      {
        v96 = *((_OWORD *)v94 - 1);
        v94 -= 16;
        *((_OWORD *)v91 - 1) = v96;
        v91 -= 2;
      }
      while (v94 != v95);
      v94 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v91;
    *((_QWORD *)v17 + 17) = v85;
    *((_QWORD *)v17 + 18) = v93;
    if (v94)
      operator delete(v94);
  }
  else
  {
    *v72 = ASAFeatures::HarmonicConsistency;
    v72[1] = 0;
    v85 = (float (**)(uint64_t, ASAFeatures **))(v72 + 2);
  }
  *((_QWORD *)v17 + 17) = v85;
  v97 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v85 >= v97)
  {
    v99 = ((char *)v85 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v99 + 1) >> 60)
      goto LABEL_627;
    v100 = v97 - (_QWORD)*v830;
    v101 = v100 >> 3;
    if (v100 >> 3 <= (unint64_t)(v99 + 1))
      v101 = v99 + 1;
    if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF0)
      v102 = 0xFFFFFFFFFFFFFFFLL;
    else
      v102 = v101;
    v103 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v102);
    v104 = (float (**)(uint64_t, ASAFeatures **))&v103[16 * v99];
    v106 = &v103[16 * v105];
    *v104 = ASAFeatures::FilteredRmsDB;
    v104[1] = 0;
    v98 = v104 + 2;
    v108 = (char *)*((_QWORD *)v17 + 16);
    v107 = (char *)*((_QWORD *)v17 + 17);
    if (v107 != v108)
    {
      do
      {
        v109 = *((_OWORD *)v107 - 1);
        v107 -= 16;
        *((_OWORD *)v104 - 1) = v109;
        v104 -= 2;
      }
      while (v107 != v108);
      v107 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v104;
    *((_QWORD *)v17 + 17) = v98;
    *((_QWORD *)v17 + 18) = v106;
    if (v107)
      operator delete(v107);
  }
  else
  {
    *v85 = ASAFeatures::FilteredRmsDB;
    v85[1] = 0;
    v98 = v85 + 2;
  }
  *((_QWORD *)v17 + 17) = v98;
  v110 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v98 >= v110)
  {
    v112 = ((char *)v98 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v112 + 1) >> 60)
      goto LABEL_627;
    v113 = v110 - (_QWORD)*v830;
    v114 = v113 >> 3;
    if (v113 >> 3 <= (unint64_t)(v112 + 1))
      v114 = v112 + 1;
    if ((unint64_t)v113 >= 0x7FFFFFFFFFFFFFF0)
      v115 = 0xFFFFFFFFFFFFFFFLL;
    else
      v115 = v114;
    v116 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v115);
    v117 = (float (**)(uint64_t, ASAFeatures **))&v116[16 * v112];
    v119 = &v116[16 * v118];
    *v117 = ASAFeatures::FilteredRmsDBDeriv;
    v117[1] = 0;
    v111 = v117 + 2;
    v121 = (char *)*((_QWORD *)v17 + 16);
    v120 = (char *)*((_QWORD *)v17 + 17);
    if (v120 != v121)
    {
      do
      {
        v122 = *((_OWORD *)v120 - 1);
        v120 -= 16;
        *((_OWORD *)v117 - 1) = v122;
        v117 -= 2;
      }
      while (v120 != v121);
      v120 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v117;
    *((_QWORD *)v17 + 17) = v111;
    *((_QWORD *)v17 + 18) = v119;
    if (v120)
      operator delete(v120);
  }
  else
  {
    *v98 = ASAFeatures::FilteredRmsDBDeriv;
    v98[1] = 0;
    v111 = v98 + 2;
  }
  *((_QWORD *)v17 + 17) = v111;
  v123 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v111 >= v123)
  {
    v125 = ((char *)v111 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v125 + 1) >> 60)
      goto LABEL_627;
    v126 = v123 - (_QWORD)*v830;
    v127 = v126 >> 3;
    if (v126 >> 3 <= (unint64_t)(v125 + 1))
      v127 = v125 + 1;
    if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFF0)
      v128 = 0xFFFFFFFFFFFFFFFLL;
    else
      v128 = v127;
    v129 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v128);
    v130 = &v129[16 * v125];
    v132 = &v129[16 * v131];
    *(_QWORD *)v130 = ASAFeatures::RmsDynamicRange;
    *((_QWORD *)v130 + 1) = 0;
    v124 = (float (**)(uint64_t, ASAFeatures **))(v130 + 16);
    v134 = (char *)*((_QWORD *)v17 + 16);
    v133 = (char *)*((_QWORD *)v17 + 17);
    if (v133 != v134)
    {
      do
      {
        v135 = *((_OWORD *)v133 - 1);
        v133 -= 16;
        *((_OWORD *)v130 - 1) = v135;
        v130 -= 16;
      }
      while (v133 != v134);
      v133 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v130;
    *((_QWORD *)v17 + 17) = v124;
    *((_QWORD *)v17 + 18) = v132;
    if (v133)
      operator delete(v133);
  }
  else
  {
    *v111 = ASAFeatures::RmsDynamicRange;
    v111[1] = 0;
    v124 = (float (**)(uint64_t, ASAFeatures **))(v111 + 2);
  }
  *((_QWORD *)v17 + 17) = v124;
  v136 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v124 >= v136)
  {
    v138 = ((char *)v124 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v138 + 1) >> 60)
      goto LABEL_627;
    v139 = v136 - (_QWORD)*v830;
    v140 = v139 >> 3;
    if (v139 >> 3 <= (unint64_t)(v138 + 1))
      v140 = v138 + 1;
    if ((unint64_t)v139 >= 0x7FFFFFFFFFFFFFF0)
      v141 = 0xFFFFFFFFFFFFFFFLL;
    else
      v141 = v140;
    v142 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v141);
    v143 = (float (**)(uint64_t, ASAFeatures **))&v142[16 * v138];
    v145 = &v142[16 * v144];
    *v143 = ASAFeatures::NormRms;
    v143[1] = 0;
    v137 = v143 + 2;
    v147 = (char *)*((_QWORD *)v17 + 16);
    v146 = (char *)*((_QWORD *)v17 + 17);
    if (v146 != v147)
    {
      do
      {
        v148 = *((_OWORD *)v146 - 1);
        v146 -= 16;
        *((_OWORD *)v143 - 1) = v148;
        v143 -= 2;
      }
      while (v146 != v147);
      v146 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v143;
    *((_QWORD *)v17 + 17) = v137;
    *((_QWORD *)v17 + 18) = v145;
    if (v146)
      operator delete(v146);
  }
  else
  {
    *v124 = ASAFeatures::NormRms;
    v124[1] = 0;
    v137 = v124 + 2;
  }
  *((_QWORD *)v17 + 17) = v137;
  v149 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v137 >= v149)
  {
    v151 = ((char *)v137 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v151 + 1) >> 60)
      goto LABEL_627;
    v152 = v149 - (_QWORD)*v830;
    v153 = v152 >> 3;
    if (v152 >> 3 <= (unint64_t)(v151 + 1))
      v153 = v151 + 1;
    if ((unint64_t)v152 >= 0x7FFFFFFFFFFFFFF0)
      v154 = 0xFFFFFFFFFFFFFFFLL;
    else
      v154 = v153;
    v155 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v154);
    v156 = (float (**)(uint64_t, ASAFeatures **))&v155[16 * v151];
    v158 = &v155[16 * v157];
    *v156 = ASAFeatures::LogRmsStdDev;
    v156[1] = 0;
    v150 = (float (**)(uint64_t, uint64_t))(v156 + 2);
    v160 = (char *)*((_QWORD *)v17 + 16);
    v159 = (char *)*((_QWORD *)v17 + 17);
    if (v159 != v160)
    {
      do
      {
        v161 = *((_OWORD *)v159 - 1);
        v159 -= 16;
        *((_OWORD *)v156 - 1) = v161;
        v156 -= 2;
      }
      while (v159 != v160);
      v159 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v156;
    *((_QWORD *)v17 + 17) = v150;
    *((_QWORD *)v17 + 18) = v158;
    if (v159)
      operator delete(v159);
  }
  else
  {
    *v137 = ASAFeatures::LogRmsStdDev;
    v137[1] = 0;
    v150 = (float (**)(uint64_t, uint64_t))(v137 + 2);
  }
  *((_QWORD *)v17 + 17) = v150;
  v162 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v150 >= v162)
  {
    v164 = ((char *)v150 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v164 + 1) >> 60)
      goto LABEL_627;
    v165 = v162 - (_QWORD)*v830;
    v166 = v165 >> 3;
    if (v165 >> 3 <= (unint64_t)(v164 + 1))
      v166 = v164 + 1;
    if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFF0)
      v167 = 0xFFFFFFFFFFFFFFFLL;
    else
      v167 = v166;
    v168 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v167);
    v169 = (float (**)(uint64_t, uint64_t))&v168[16 * v164];
    v171 = &v168[16 * v170];
    *v169 = ASAFeatures::ModEnergy;
    v169[1] = 0;
    v163 = v169 + 2;
    v173 = (char *)*((_QWORD *)v17 + 16);
    v172 = (char *)*((_QWORD *)v17 + 17);
    if (v172 != v173)
    {
      do
      {
        v174 = *((_OWORD *)v172 - 1);
        v172 -= 16;
        *((_OWORD *)v169 - 1) = v174;
        v169 -= 2;
      }
      while (v172 != v173);
      v172 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v169;
    *((_QWORD *)v17 + 17) = v163;
    *((_QWORD *)v17 + 18) = v171;
    if (v172)
      operator delete(v172);
  }
  else
  {
    *v150 = ASAFeatures::ModEnergy;
    v150[1] = 0;
    v163 = v150 + 2;
  }
  *((_QWORD *)v17 + 17) = v163;
  v175 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v163 >= v175)
  {
    v177 = ((char *)v163 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v177 + 1) >> 60)
      goto LABEL_627;
    v178 = v175 - (_QWORD)*v830;
    v179 = v178 >> 3;
    if (v178 >> 3 <= (unint64_t)(v177 + 1))
      v179 = v177 + 1;
    if ((unint64_t)v178 >= 0x7FFFFFFFFFFFFFF0)
      v180 = 0xFFFFFFFFFFFFFFFLL;
    else
      v180 = v179;
    v181 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v180);
    v182 = (float (**)(uint64_t, uint64_t))&v181[16 * v177];
    v184 = &v181[16 * v183];
    *v182 = ASAFeatures::ModEnergy2;
    v182[1] = 0;
    v176 = v182 + 2;
    v186 = (char *)*((_QWORD *)v17 + 16);
    v185 = (char *)*((_QWORD *)v17 + 17);
    if (v185 != v186)
    {
      do
      {
        v187 = *((_OWORD *)v185 - 1);
        v185 -= 16;
        *((_OWORD *)v182 - 1) = v187;
        v182 -= 2;
      }
      while (v185 != v186);
      v185 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v182;
    *((_QWORD *)v17 + 17) = v176;
    *((_QWORD *)v17 + 18) = v184;
    if (v185)
      operator delete(v185);
  }
  else
  {
    *v163 = ASAFeatures::ModEnergy2;
    v163[1] = 0;
    v176 = v163 + 2;
  }
  *((_QWORD *)v17 + 17) = v176;
  v188 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v176 >= v188)
  {
    v190 = ((char *)v176 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v190 + 1) >> 60)
      goto LABEL_627;
    v191 = v188 - (_QWORD)*v830;
    v192 = v191 >> 3;
    if (v191 >> 3 <= (unint64_t)(v190 + 1))
      v192 = v190 + 1;
    if ((unint64_t)v191 >= 0x7FFFFFFFFFFFFFF0)
      v193 = 0xFFFFFFFFFFFFFFFLL;
    else
      v193 = v192;
    v194 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v193);
    v195 = &v194[16 * v190];
    v197 = &v194[16 * v196];
    *(_QWORD *)v195 = ASAFeatures::LowEnergyFrac;
    *((_QWORD *)v195 + 1) = 0;
    v189 = v195 + 16;
    v199 = (char *)*((_QWORD *)v17 + 16);
    v198 = (char *)*((_QWORD *)v17 + 17);
    if (v198 != v199)
    {
      do
      {
        v200 = *((_OWORD *)v198 - 1);
        v198 -= 16;
        *((_OWORD *)v195 - 1) = v200;
        v195 -= 16;
      }
      while (v198 != v199);
      v198 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v195;
    *((_QWORD *)v17 + 17) = v189;
    *((_QWORD *)v17 + 18) = v197;
    if (v198)
      operator delete(v198);
  }
  else
  {
    *v176 = ASAFeatures::LowEnergyFrac;
    v176[1] = 0;
    v189 = v176 + 2;
  }
  *((_QWORD *)v17 + 17) = v189;
  v201 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v189 >= v201)
  {
    v203 = ((char *)v189 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v203 + 1) >> 60)
      goto LABEL_627;
    v204 = v201 - (_QWORD)*v830;
    v205 = v204 >> 3;
    if (v204 >> 3 <= (unint64_t)(v203 + 1))
      v205 = v203 + 1;
    if ((unint64_t)v204 >= 0x7FFFFFFFFFFFFFF0)
      v206 = 0xFFFFFFFFFFFFFFFLL;
    else
      v206 = v205;
    v207 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v206);
    v208 = &v207[16 * v203];
    v210 = &v207[16 * v209];
    *(_QWORD *)v208 = ASAFeatures::SpectralRolloffHzVar;
    *((_QWORD *)v208 + 1) = 0;
    v202 = v208 + 16;
    v212 = (char *)*((_QWORD *)v17 + 16);
    v211 = (char *)*((_QWORD *)v17 + 17);
    if (v211 != v212)
    {
      do
      {
        v213 = *((_OWORD *)v211 - 1);
        v211 -= 16;
        *((_OWORD *)v208 - 1) = v213;
        v208 -= 16;
      }
      while (v211 != v212);
      v211 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v208;
    *((_QWORD *)v17 + 17) = v202;
    *((_QWORD *)v17 + 18) = v210;
    if (v211)
      operator delete(v211);
  }
  else
  {
    *v189 = ASAFeatures::SpectralRolloffHzVar;
    v189[1] = 0;
    v202 = v189 + 2;
  }
  *((_QWORD *)v17 + 17) = v202;
  v214 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v202 >= v214)
  {
    v216 = ((char *)v202 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v216 + 1) >> 60)
      goto LABEL_627;
    v217 = v214 - (_QWORD)*v830;
    v218 = v217 >> 3;
    if (v217 >> 3 <= (unint64_t)(v216 + 1))
      v218 = v216 + 1;
    if ((unint64_t)v217 >= 0x7FFFFFFFFFFFFFF0)
      v219 = 0xFFFFFFFFFFFFFFFLL;
    else
      v219 = v218;
    v220 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v219);
    v221 = &v220[16 * v216];
    v223 = &v220[16 * v222];
    *(_QWORD *)v221 = ASAFeatures::CentroidVar;
    *((_QWORD *)v221 + 1) = 0;
    v215 = (float (**)(float **, uint64_t))(v221 + 16);
    v225 = (char *)*((_QWORD *)v17 + 16);
    v224 = (char *)*((_QWORD *)v17 + 17);
    if (v224 != v225)
    {
      do
      {
        v226 = *((_OWORD *)v224 - 1);
        v224 -= 16;
        *((_OWORD *)v221 - 1) = v226;
        v221 -= 16;
      }
      while (v224 != v225);
      v224 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v221;
    *((_QWORD *)v17 + 17) = v215;
    *((_QWORD *)v17 + 18) = v223;
    if (v224)
      operator delete(v224);
  }
  else
  {
    *v202 = ASAFeatures::CentroidVar;
    v202[1] = 0;
    v215 = (float (**)(float **, uint64_t))(v202 + 2);
  }
  *((_QWORD *)v17 + 17) = v215;
  v227 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v215 >= v227)
  {
    v229 = ((char *)v215 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v229 + 1) >> 60)
      goto LABEL_627;
    v230 = v227 - (_QWORD)*v830;
    v231 = v230 >> 3;
    if (v230 >> 3 <= (unint64_t)(v229 + 1))
      v231 = v229 + 1;
    if ((unint64_t)v230 >= 0x7FFFFFFFFFFFFFF0)
      v232 = 0xFFFFFFFFFFFFFFFLL;
    else
      v232 = v231;
    v233 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v232);
    v234 = (float (**)(float **, uint64_t))&v233[16 * v229];
    v236 = &v233[16 * v235];
    *v234 = ASAFeatures::FluxVar;
    v234[1] = 0;
    v228 = v234 + 2;
    v238 = (char *)*((_QWORD *)v17 + 16);
    v237 = (char *)*((_QWORD *)v17 + 17);
    if (v237 != v238)
    {
      do
      {
        v239 = *((_OWORD *)v237 - 1);
        v237 -= 16;
        *((_OWORD *)v234 - 1) = v239;
        v234 -= 2;
      }
      while (v237 != v238);
      v237 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v234;
    *((_QWORD *)v17 + 17) = v228;
    *((_QWORD *)v17 + 18) = v236;
    if (v237)
      operator delete(v237);
  }
  else
  {
    *v215 = ASAFeatures::FluxVar;
    v215[1] = 0;
    v228 = v215 + 2;
  }
  *((_QWORD *)v17 + 17) = v228;
  v240 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v228 >= v240)
  {
    v242 = ((char *)v228 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v242 + 1) >> 60)
      goto LABEL_627;
    v243 = v240 - (_QWORD)*v830;
    v244 = v243 >> 3;
    if (v243 >> 3 <= (unint64_t)(v242 + 1))
      v244 = v242 + 1;
    if ((unint64_t)v243 >= 0x7FFFFFFFFFFFFFF0)
      v245 = 0xFFFFFFFFFFFFFFFLL;
    else
      v245 = v244;
    v246 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v245);
    v247 = &v246[16 * v242];
    v249 = &v246[16 * v248];
    *(_QWORD *)v247 = ASAFeatures::ReconDiffVar;
    *((_QWORD *)v247 + 1) = 0;
    v241 = (float (**)(uint64_t, uint64_t))(v247 + 16);
    v251 = (char *)*((_QWORD *)v17 + 16);
    v250 = (char *)*((_QWORD *)v17 + 17);
    if (v250 != v251)
    {
      do
      {
        v252 = *((_OWORD *)v250 - 1);
        v250 -= 16;
        *((_OWORD *)v247 - 1) = v252;
        v247 -= 16;
      }
      while (v250 != v251);
      v250 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v247;
    *((_QWORD *)v17 + 17) = v241;
    *((_QWORD *)v17 + 18) = v249;
    if (v250)
      operator delete(v250);
  }
  else
  {
    *v228 = ASAFeatures::ReconDiffVar;
    v228[1] = 0;
    v241 = (float (**)(uint64_t, uint64_t))(v228 + 2);
  }
  *((_QWORD *)v17 + 17) = v241;
  v253 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v241 >= v253)
  {
    v255 = ((char *)v241 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v255 + 1) >> 60)
      goto LABEL_627;
    v256 = v253 - (_QWORD)*v830;
    v257 = v256 >> 3;
    if (v256 >> 3 <= (unint64_t)(v255 + 1))
      v257 = v255 + 1;
    if ((unint64_t)v256 >= 0x7FFFFFFFFFFFFFF0)
      v258 = 0xFFFFFFFFFFFFFFFLL;
    else
      v258 = v257;
    v259 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v258);
    v260 = (float (**)(uint64_t, uint64_t))&v259[16 * v255];
    v262 = &v259[16 * v261];
    *v260 = ASAFeatures::CepstralSparsity;
    v260[1] = 0;
    v254 = v260 + 2;
    v264 = (char *)*((_QWORD *)v17 + 16);
    v263 = (char *)*((_QWORD *)v17 + 17);
    if (v263 != v264)
    {
      do
      {
        v265 = *((_OWORD *)v263 - 1);
        v263 -= 16;
        *((_OWORD *)v260 - 1) = v265;
        v260 -= 2;
      }
      while (v263 != v264);
      v263 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v260;
    *((_QWORD *)v17 + 17) = v254;
    *((_QWORD *)v17 + 18) = v262;
    if (v263)
      operator delete(v263);
  }
  else
  {
    *v241 = ASAFeatures::CepstralSparsity;
    v241[1] = 0;
    v254 = v241 + 2;
  }
  *((_QWORD *)v17 + 17) = v254;
  v266 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v254 >= v266)
  {
    v268 = ((char *)v254 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v268 + 1) >> 60)
      goto LABEL_627;
    v269 = v266 - (_QWORD)*v830;
    v270 = v269 >> 3;
    if (v269 >> 3 <= (unint64_t)(v268 + 1))
      v270 = v268 + 1;
    if ((unint64_t)v269 >= 0x7FFFFFFFFFFFFFF0)
      v271 = 0xFFFFFFFFFFFFFFFLL;
    else
      v271 = v270;
    v272 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v271);
    v273 = &v272[16 * v268];
    v275 = &v272[16 * v274];
    *(_QWORD *)v273 = ASAFeatures::CepstralVariance;
    *((_QWORD *)v273 + 1) = 0;
    v267 = (float (**)(uint64_t, uint64_t))(v273 + 16);
    v277 = (char *)*((_QWORD *)v17 + 16);
    v276 = (char *)*((_QWORD *)v17 + 17);
    if (v276 != v277)
    {
      do
      {
        v278 = *((_OWORD *)v276 - 1);
        v276 -= 16;
        *((_OWORD *)v273 - 1) = v278;
        v273 -= 16;
      }
      while (v276 != v277);
      v276 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v273;
    *((_QWORD *)v17 + 17) = v267;
    *((_QWORD *)v17 + 18) = v275;
    if (v276)
      operator delete(v276);
  }
  else
  {
    *v254 = ASAFeatures::CepstralVariance;
    v254[1] = 0;
    v267 = (float (**)(uint64_t, uint64_t))(v254 + 2);
  }
  *((_QWORD *)v17 + 17) = v267;
  v279 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v267 >= v279)
  {
    v281 = ((char *)v267 - (_BYTE *)*v830) >> 4;
    if ((unint64_t)(v281 + 1) >> 60)
      goto LABEL_627;
    v282 = v279 - (_QWORD)*v830;
    v283 = v282 >> 3;
    if (v282 >> 3 <= (unint64_t)(v281 + 1))
      v283 = v281 + 1;
    if ((unint64_t)v282 >= 0x7FFFFFFFFFFFFFF0)
      v284 = 0xFFFFFFFFFFFFFFFLL;
    else
      v284 = v283;
    v285 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v284);
    v286 = (float (**)(uint64_t, uint64_t))&v285[16 * v281];
    v288 = &v285[16 * v287];
    *v286 = ASAFeatures::AvgPitchDensity;
    v286[1] = 0;
    v280 = (char *)(v286 + 2);
    v290 = (char *)*((_QWORD *)v17 + 16);
    v289 = (char *)*((_QWORD *)v17 + 17);
    if (v289 != v290)
    {
      do
      {
        v291 = *((_OWORD *)v289 - 1);
        v289 -= 16;
        *((_OWORD *)v286 - 1) = v291;
        v286 -= 2;
      }
      while (v289 != v290);
      v289 = (char *)*v830;
    }
    *((_QWORD *)v17 + 16) = v286;
    *((_QWORD *)v17 + 17) = v280;
    *((_QWORD *)v17 + 18) = v288;
    if (v289)
      operator delete(v289);
  }
  else
  {
    *v267 = ASAFeatures::AvgPitchDensity;
    v267[1] = 0;
    v280 = (char *)(v267 + 2);
  }
  *((_QWORD *)v17 + 17) = v280;
  v292 = *((_QWORD *)v17 + 18);
  if ((unint64_t)v280 >= v292)
  {
    v294 = (v280 - (_BYTE *)*v830) >> 4;
    if (!((unint64_t)(v294 + 1) >> 60))
    {
      v295 = v292 - (_QWORD)*v830;
      v296 = v295 >> 3;
      if (v295 >> 3 <= (unint64_t)(v294 + 1))
        v296 = v294 + 1;
      if ((unint64_t)v295 >= 0x7FFFFFFFFFFFFFF0)
        v297 = 0xFFFFFFFFFFFFFFFLL;
      else
        v297 = v296;
      v298 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v297);
      v299 = &v298[16 * v294];
      v301 = &v298[16 * v300];
      *(_QWORD *)v299 = ASAFeatures::AvgTonalityPower;
      *((_QWORD *)v299 + 1) = 0;
      v293 = v299 + 16;
      v303 = (char *)*((_QWORD *)v17 + 16);
      v302 = (char *)*((_QWORD *)v17 + 17);
      if (v302 != v303)
      {
        do
        {
          v304 = *((_OWORD *)v302 - 1);
          v302 -= 16;
          *((_OWORD *)v299 - 1) = v304;
          v299 -= 16;
        }
        while (v302 != v303);
        v302 = (char *)*v830;
      }
      *((_QWORD *)v17 + 16) = v299;
      *((_QWORD *)v17 + 17) = v293;
      *((_QWORD *)v17 + 18) = v301;
      if (v302)
        operator delete(v302);
      goto LABEL_260;
    }
LABEL_627:
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
  *(_QWORD *)v280 = ASAFeatures::AvgTonalityPower;
  *((_QWORD *)v280 + 1) = 0;
  v293 = v280 + 16;
LABEL_260:
  *((_QWORD *)v17 + 17) = v293;
  v305 = *(unsigned int *)(*((_QWORD *)v17 + 1) + 8);
  v306 = malloc_type_malloc(4 * v305, 0x2C8E6D5CuLL);
  v307 = v306;
  if ((_DWORD)v305)
    _ZF = v306 == 0;
  else
    _ZF = 0;
  if (_ZF)
    goto LABEL_614;
  bzero(v306, 4 * v305);
  *((_QWORD *)v17 + 28) = v307;
  v309 = *(unsigned int *)(*((_QWORD *)v17 + 1) + 8);
  v310 = malloc_type_malloc(4 * v309, 0x2C8E6D5CuLL);
  v311 = v310;
  if ((_DWORD)v309 && v310 == 0)
    goto LABEL_614;
  bzero(v310, 4 * v309);
  *((_QWORD *)v17 + 29) = v311;
  v313 = *(unsigned int *)(*((_QWORD *)v17 + 1) + 8);
  v314 = malloc_type_malloc(4 * v313, 0x2C8E6D5CuLL);
  v315 = v314;
  if ((_DWORD)v313)
  {
    if (!v314)
      goto LABEL_614;
  }
  bzero(v314, 4 * v313);
  *((_QWORD *)v17 + 30) = v315;
  v316 = (*(_DWORD *)(*((_QWORD *)v17 + 1) + 8) * *(_DWORD *)(*((_QWORD *)v17 + 1) + 8));
  v317 = malloc_type_malloc(4 * v316, 0x2C8E6D5CuLL);
  v318 = v317;
  if ((_DWORD)v316)
  {
    if (!v317)
      goto LABEL_614;
  }
  bzero(v317, 4 * v316);
  *((_QWORD *)v17 + 75) = v318;
  v319 = (*(_DWORD *)(*((_QWORD *)v17 + 1) + 8) * *(_DWORD *)(*((_QWORD *)v17 + 1) + 8));
  v320 = malloc_type_malloc(4 * v319, 0x2C8E6D5CuLL);
  v321 = v320;
  if ((_DWORD)v319)
  {
    if (!v320)
      goto LABEL_614;
  }
  bzero(v320, 4 * v319);
  *((_QWORD *)v17 + 76) = v321;
  v322 = (*((_DWORD *)v17 + 180) * *(_DWORD *)(*((_QWORD *)v17 + 1) + 8));
  v323 = malloc_type_malloc(4 * v322, 0x2C8E6D5CuLL);
  v324 = v323;
  if ((_DWORD)v322)
  {
    if (!v323)
      goto LABEL_614;
  }
  bzero(v323, 4 * v322);
  *((_QWORD *)v17 + 77) = v324;
  v325 = (_QWORD *)operator new();
  *v325 = 0;
  v325[1] = 0;
  v325[2] = 0;
  *((_QWORD *)v17 + 78) = v325;
  v326 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v327 = malloc_type_malloc(4 * v326, 0x2C8E6D5CuLL);
  v328 = v327;
  if ((_DWORD)v326)
  {
    if (!v327)
      goto LABEL_614;
  }
  bzero(v327, 4 * v326);
  *((_QWORD *)v17 + 31) = v328;
  v329 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v330 = malloc_type_malloc(4 * v329, 0x2C8E6D5CuLL);
  v331 = v330;
  if ((_DWORD)v329)
  {
    if (!v330)
      goto LABEL_614;
  }
  bzero(v330, 4 * v329);
  *((_QWORD *)v17 + 32) = v331;
  v332 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v333 = malloc_type_malloc(4 * v332, 0x2C8E6D5CuLL);
  v334 = v333;
  if ((_DWORD)v332)
  {
    if (!v333)
      goto LABEL_614;
  }
  bzero(v333, 4 * v332);
  *((_QWORD *)v17 + 33) = v334;
  v335 = *((unsigned int *)v17 + 183);
  v336 = malloc_type_malloc(4 * v335, 0x2C8E6D5CuLL);
  v337 = v336;
  if ((_DWORD)v335)
  {
    if (!v336)
      goto LABEL_614;
  }
  bzero(v336, 4 * v335);
  *((_QWORD *)v17 + 34) = v337;
  v338 = *((unsigned int *)v17 + 183);
  v339 = malloc_type_malloc(4 * v338, 0x2C8E6D5CuLL);
  v340 = v339;
  if ((_DWORD)v338)
  {
    if (!v339)
      goto LABEL_614;
  }
  bzero(v339, 4 * v338);
  *((_QWORD *)v17 + 35) = v340;
  v341 = *((unsigned int *)v17 + 183);
  v342 = malloc_type_malloc(4 * v341, 0x2C8E6D5CuLL);
  v343 = v342;
  if ((_DWORD)v341)
  {
    if (!v342)
      goto LABEL_614;
  }
  bzero(v342, 4 * v341);
  *((_QWORD *)v17 + 36) = v343;
  v344 = *((unsigned int *)v17 + 183);
  v345 = malloc_type_malloc(4 * v344, 0x2C8E6D5CuLL);
  v346 = v345;
  if ((_DWORD)v344)
  {
    if (!v345)
      goto LABEL_614;
  }
  bzero(v345, 4 * v344);
  *((_QWORD *)v17 + 37) = v346;
  v347 = *((unsigned int *)v17 + 184);
  v348 = malloc_type_malloc(4 * v347, 0x2C8E6D5CuLL);
  v349 = v348;
  if ((_DWORD)v347)
  {
    if (!v348)
      goto LABEL_614;
  }
  bzero(v348, 4 * v347);
  *((_QWORD *)v17 + 38) = v349;
  v350 = *((unsigned int *)v17 + 184);
  v351 = malloc_type_malloc(4 * v350, 0x2C8E6D5CuLL);
  v352 = v351;
  if ((_DWORD)v350)
  {
    if (!v351)
      goto LABEL_614;
  }
  bzero(v351, 4 * v350);
  *((_QWORD *)v17 + 39) = v352;
  v353 = (*((_DWORD *)v17 + 184) * *((_DWORD *)v17 + 183));
  v354 = malloc_type_malloc(4 * v353, 0x2C8E6D5CuLL);
  v355 = v354;
  if ((_DWORD)v353)
  {
    if (!v354)
      goto LABEL_614;
  }
  bzero(v354, 4 * v353);
  *((_QWORD *)v17 + 40) = v355;
  v356 = malloc_type_malloc(0x190uLL, 0x2C8E6D5CuLL);
  if (!v356)
    goto LABEL_614;
  v356[23] = 0u;
  v356[24] = 0u;
  v356[21] = 0u;
  v356[22] = 0u;
  v356[19] = 0u;
  v356[20] = 0u;
  v356[17] = 0u;
  v356[18] = 0u;
  v356[15] = 0u;
  v356[16] = 0u;
  v356[13] = 0u;
  v356[14] = 0u;
  v356[11] = 0u;
  v356[12] = 0u;
  v356[9] = 0u;
  v356[10] = 0u;
  v356[7] = 0u;
  v356[8] = 0u;
  v356[5] = 0u;
  v356[6] = 0u;
  v356[3] = 0u;
  v356[4] = 0u;
  v356[1] = 0u;
  v356[2] = 0u;
  *v356 = 0u;
  *((_QWORD *)v17 + 41) = v356;
  v357 = malloc_type_malloc(0x190uLL, 0x2C8E6D5CuLL);
  if (!v357)
    goto LABEL_614;
  v357[23] = 0u;
  v357[24] = 0u;
  v357[21] = 0u;
  v357[22] = 0u;
  v357[19] = 0u;
  v357[20] = 0u;
  v357[17] = 0u;
  v357[18] = 0u;
  v357[15] = 0u;
  v357[16] = 0u;
  v357[13] = 0u;
  v357[14] = 0u;
  v357[11] = 0u;
  v357[12] = 0u;
  v357[9] = 0u;
  v357[10] = 0u;
  v357[7] = 0u;
  v357[8] = 0u;
  v357[5] = 0u;
  v357[6] = 0u;
  v357[3] = 0u;
  v357[4] = 0u;
  v357[1] = 0u;
  v357[2] = 0u;
  *v357 = 0u;
  *((_QWORD *)v17 + 42) = v357;
  v358 = (_QWORD *)operator new();
  v359 = (*((_DWORD *)v17 + 198) * *(_DWORD *)(*(_QWORD *)v17 + 44) + 1);
  v360 = (void *)operator new[]();
  bzero(v360, 4 * v359);
  *v358 = v360;
  v358[1] = v359;
  bzero(v360, 4 * (int)v359);
  *((_QWORD *)v17 + 49) = v358;
  if (*((_DWORD *)v17 + 198))
  {
    v361 = 0;
    do
    {
      v362 = *((_QWORD *)v17 + 2);
      v363 = *(char **)(v362 + 88);
      if (*(char **)(v362 + 96) == v363)
        goto LABEL_621;
      v364 = *((_QWORD *)v17 + 49);
      v365 = *(_DWORD *)(*(_QWORD *)v17 + 44);
      v366 = *(_DWORD *)(v364 + 8);
      v367 = *(int *)(v364 + 12);
      if (v366 < v365)
        v365 = *(_DWORD *)(v364 + 8);
      v368 = v367 + v365;
      v369 = v367 + v365 - v366;
      if (v369 < 0)
      {
        memcpy((void *)(*(_QWORD *)v364 + 4 * v367), v363, 4 * v365);
      }
      else
      {
        v370 = v366 - v367;
        memcpy((void *)(*(_QWORD *)v364 + 4 * v367), v363, 4 * (v366 - (int)v367));
        memcpy(*(void **)v364, &v363[4 * v370], 4 * v369);
        v368 = v369;
      }
      *(_DWORD *)(v364 + 12) = v368;
    }
    while (++v361 < (unint64_t)*((unsigned int *)v17 + 198));
  }
  v371 = *((unsigned int *)v17 + 184);
  v372 = malloc_type_malloc(4 * v371, 0x2C8E6D5CuLL);
  v373 = v372;
  if ((_DWORD)v371)
  {
    if (!v372)
      goto LABEL_614;
  }
  bzero(v372, 4 * v371);
  *((_QWORD *)v17 + 79) = v373;
  v374 = *((unsigned int *)v17 + 184);
  v375 = malloc_type_malloc(4 * v374, 0x2C8E6D5CuLL);
  v376 = v375;
  if ((_DWORD)v374)
  {
    if (!v375)
      goto LABEL_614;
  }
  bzero(v375, 4 * v374);
  *((_QWORD *)v17 + 80) = v376;
  v377 = (_QWORD *)operator new();
  std::vector<float *>::vector(v377, 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(*(_QWORD *)(*((_QWORD *)v17 + 2) + 48) - *(_QWORD *)(*((_QWORD *)v17 + 2) + 40)) >> 2));
  *((_QWORD *)v17 + 81) = v377;
  v831 = (float32x2_t **)v17;
  if (*(_QWORD *)(*((_QWORD *)v17 + 2) + 48) != *(_QWORD *)(*((_QWORD *)v17 + 2) + 40))
  {
    v378 = 0;
    do
    {
      v379 = *((unsigned int *)v17 + 184);
      v380 = malloc_type_malloc(4 * v379, 0x2C8E6D5CuLL);
      v381 = v380;
      if ((_DWORD)v379 && v380 == 0)
        goto LABEL_614;
      bzero(v380, 4 * v379);
      v383 = **((_QWORD **)v17 + 81);
      if (v378 >= (*(_QWORD *)(*((_QWORD *)v17 + 81) + 8) - v383) >> 3)
        goto LABEL_618;
      *(_QWORD *)(v383 + 8 * v378++) = v381;
      v17 = (ASAFeatures *)v831;
    }
    while (v378 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&v831[2][6] - *(_QWORD *)&v831[2][5]) >> 2));
  }
  v384 = *((unsigned int *)v17 + 198);
  v385 = malloc_type_malloc(4 * v384, 0x2C8E6D5CuLL);
  v386 = v385;
  if ((_DWORD)v384 && !v385)
    goto LABEL_614;
  bzero(v385, 4 * v384);
  *((_QWORD *)v17 + 82) = v386;
  v387 = *(unsigned int *)(*(_QWORD *)v17 + 60);
  v388 = malloc_type_malloc(4 * v387, 0x2C8E6D5CuLL);
  v389 = v388;
  if ((_DWORD)v387)
  {
    if (!v388)
      goto LABEL_614;
  }
  bzero(v388, 4 * v387);
  *((_QWORD *)v17 + 43) = v389;
  v390 = *(unsigned int *)(*(_QWORD *)v17 + 60);
  v391 = malloc_type_malloc(4 * v390, 0x2C8E6D5CuLL);
  v392 = v391;
  if ((_DWORD)v390)
  {
    if (!v391)
      goto LABEL_614;
  }
  bzero(v391, 4 * v390);
  *((_QWORD *)v17 + 44) = v392;
  v393 = *(unsigned int *)(*(_QWORD *)v17 + 60);
  v394 = malloc_type_malloc(4 * v393, 0x2C8E6D5CuLL);
  v395 = v394;
  if ((_DWORD)v393)
  {
    if (!v394)
      goto LABEL_614;
  }
  bzero(v394, 4 * v393);
  *((_QWORD *)v17 + 45) = v395;
  v396 = *(unsigned int *)(*(_QWORD *)v17 + 60);
  v397 = malloc_type_malloc(4 * v396, 0x2C8E6D5CuLL);
  v398 = v397;
  if ((_DWORD)v396)
  {
    if (!v397)
      goto LABEL_614;
  }
  bzero(v397, 4 * v396);
  *((_QWORD *)v17 + 46) = v398;
  v399 = *(unsigned int *)(*(_QWORD *)v17 + 60);
  v400 = malloc_type_malloc(4 * v399, 0x2C8E6D5CuLL);
  v401 = v400;
  if ((_DWORD)v399)
  {
    if (!v400)
      goto LABEL_614;
  }
  bzero(v400, 4 * v399);
  *((_QWORD *)v17 + 47) = v401;
  v402 = *(unsigned int *)(*(_QWORD *)v17 + 60);
  v403 = malloc_type_malloc(4 * v402, 0x2C8E6D5CuLL);
  v404 = v403;
  if ((_DWORD)v402)
  {
    if (!v403)
      goto LABEL_614;
  }
  bzero(v403, 4 * v402);
  *((_QWORD *)v17 + 48) = v404;
  v405 = (_QWORD *)operator new();
  v406 = (float)(*(float *)(*(_QWORD *)v17 + 52) + 1.0);
  v407 = (void *)operator new[]();
  bzero(v407, 4 * v406);
  *v405 = v407;
  v405[1] = v406;
  bzero(v407, 4 * (int)v406);
  *((_QWORD *)v17 + 50) = v405;
  v408 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v409 = malloc_type_malloc(4 * v408, 0x2C8E6D5CuLL);
  v410 = v409;
  if ((_DWORD)v408)
  {
    if (!v409)
      goto LABEL_614;
  }
  bzero(v409, 4 * v408);
  *((_QWORD *)v17 + 51) = v410;
  v411 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v412 = malloc_type_malloc(4 * v411, 0x2C8E6D5CuLL);
  v413 = v412;
  if ((_DWORD)v411)
  {
    if (!v412)
      goto LABEL_614;
  }
  bzero(v412, 4 * v411);
  *((_QWORD *)v17 + 52) = v413;
  v414 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v415 = malloc_type_malloc(4 * v414, 0x2C8E6D5CuLL);
  v416 = v415;
  if ((_DWORD)v414)
  {
    if (!v415)
      goto LABEL_614;
  }
  bzero(v415, 4 * v414);
  *((_QWORD *)v17 + 53) = v416;
  v417 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v418 = malloc_type_malloc(4 * v417, 0x2C8E6D5CuLL);
  v419 = v418;
  if ((_DWORD)v417)
  {
    if (!v418)
      goto LABEL_614;
  }
  bzero(v418, 4 * v417);
  *((_QWORD *)v17 + 54) = v419;
  v420 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v421 = malloc_type_malloc(4 * v420, 0x2C8E6D5CuLL);
  v422 = v421;
  if ((_DWORD)v420)
  {
    if (!v421)
      goto LABEL_614;
  }
  bzero(v421, 4 * v420);
  *((_QWORD *)v17 + 55) = v422;
  v423 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v424 = malloc_type_malloc(4 * v423, 0x2C8E6D5CuLL);
  v425 = v424;
  if ((_DWORD)v423)
  {
    if (!v424)
      goto LABEL_614;
  }
  bzero(v424, 4 * v423);
  *((_QWORD *)v17 + 56) = v425;
  v426 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v427 = malloc_type_malloc(4 * v426, 0x2C8E6D5CuLL);
  v428 = v427;
  if ((_DWORD)v426)
  {
    if (!v427)
      goto LABEL_614;
  }
  bzero(v427, 4 * v426);
  *((_QWORD *)v17 + 57) = v428;
  v429 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v430 = malloc_type_malloc(4 * v429, 0x2C8E6D5CuLL);
  v431 = v430;
  if ((_DWORD)v429)
  {
    if (!v430)
      goto LABEL_614;
  }
  bzero(v430, 4 * v429);
  *((_QWORD *)v17 + 58) = v431;
  v432 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v433 = malloc_type_malloc(4 * v432, 0x2C8E6D5CuLL);
  v434 = v433;
  if ((_DWORD)v432)
  {
    if (!v433)
      goto LABEL_614;
  }
  bzero(v433, 4 * v432);
  *((_QWORD *)v17 + 59) = v434;
  v435 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v436 = malloc_type_malloc(4 * v435, 0x2C8E6D5CuLL);
  v437 = v436;
  if ((_DWORD)v435)
  {
    if (!v436)
      goto LABEL_614;
  }
  bzero(v436, 4 * v435);
  *((_QWORD *)v17 + 60) = v437;
  v438 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v439 = malloc_type_malloc(4 * v438, 0x2C8E6D5CuLL);
  v440 = v439;
  if ((_DWORD)v438)
  {
    if (!v439)
      goto LABEL_614;
  }
  bzero(v439, 4 * v438);
  *((_QWORD *)v17 + 61) = v440;
  v441 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v442 = malloc_type_malloc(4 * v441, 0x2C8E6D5CuLL);
  v443 = v442;
  if ((_DWORD)v441)
  {
    if (!v442)
      goto LABEL_614;
  }
  bzero(v442, 4 * v441);
  *((_QWORD *)v17 + 62) = v443;
  v444 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v445 = malloc_type_malloc(4 * v444, 0x2C8E6D5CuLL);
  v446 = v445;
  if ((_DWORD)v444)
  {
    if (!v445)
      goto LABEL_614;
  }
  bzero(v445, 4 * v444);
  *((_QWORD *)v17 + 63) = v446;
  v447 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v448 = malloc_type_malloc(4 * v447, 0x2C8E6D5CuLL);
  v449 = v448;
  if ((_DWORD)v447)
  {
    if (!v448)
      goto LABEL_614;
  }
  bzero(v448, 4 * v447);
  *((_QWORD *)v17 + 64) = v449;
  v450 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v451 = malloc_type_malloc(4 * v450, 0x2C8E6D5CuLL);
  v452 = v451;
  if ((_DWORD)v450)
  {
    if (!v451)
      goto LABEL_614;
  }
  bzero(v451, 4 * v450);
  *((_QWORD *)v17 + 65) = v452;
  v453 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v454 = malloc_type_malloc(4 * v453, 0x2C8E6D5CuLL);
  v455 = v454;
  if ((_DWORD)v453)
  {
    if (!v454)
      goto LABEL_614;
  }
  bzero(v454, 4 * v453);
  *((_QWORD *)v17 + 66) = v455;
  v456 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v457 = malloc_type_malloc(4 * v456, 0x2C8E6D5CuLL);
  v458 = v457;
  if ((_DWORD)v456)
  {
    if (!v457)
      goto LABEL_614;
  }
  bzero(v457, 4 * v456);
  *((_QWORD *)v17 + 67) = v458;
  v459 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v460 = malloc_type_malloc(4 * v459, 0x2C8E6D5CuLL);
  v461 = v460;
  if ((_DWORD)v459)
  {
    if (!v460)
      goto LABEL_614;
  }
  bzero(v460, 4 * v459);
  *((_QWORD *)v17 + 68) = v461;
  v462 = *(unsigned int *)(*(_QWORD *)v17 + 56);
  v463 = malloc_type_malloc(4 * v462, 0x2C8E6D5CuLL);
  v464 = v463;
  if ((_DWORD)v462)
  {
    if (!v463)
      goto LABEL_614;
  }
  bzero(v463, 4 * v462);
  *((_QWORD *)v17 + 83) = v464;
  v465 = *(unsigned int *)(*(_QWORD *)v17 + 72);
  v466 = malloc_type_malloc(4 * v465, 0x2C8E6D5CuLL);
  v467 = v466;
  if ((_DWORD)v465)
  {
    if (!v466)
      goto LABEL_614;
  }
  bzero(v466, 4 * v465);
  *((_QWORD *)v17 + 84) = v467;
  v468 = *(unsigned int *)(*(_QWORD *)v17 + 72);
  v469 = malloc_type_malloc(4 * v468, 0x2C8E6D5CuLL);
  v470 = v469;
  if ((_DWORD)v468)
  {
    if (!v469)
      goto LABEL_614;
  }
  bzero(v469, 4 * v468);
  *((_QWORD *)v17 + 85) = v470;
  v471 = *(unsigned int *)(*(_QWORD *)v17 + 72);
  v472 = malloc_type_malloc(4 * v471, 0x2C8E6D5CuLL);
  v473 = v472;
  if ((_DWORD)v471)
  {
    if (!v472)
      goto LABEL_614;
  }
  bzero(v472, 4 * v471);
  *((_QWORD *)v17 + 86) = v473;
  v474 = *(unsigned int *)(*(_QWORD *)v17 + 72);
  v475 = malloc_type_malloc(4 * v474, 0x2C8E6D5CuLL);
  v476 = v475;
  if ((_DWORD)v474)
  {
    if (!v475)
      goto LABEL_614;
  }
  bzero(v475, 4 * v474);
  *((_QWORD *)v17 + 87) = v476;
  v477 = *(unsigned int *)(*(_QWORD *)v17 + 72);
  v478 = malloc_type_malloc(4 * v477, 0x2C8E6D5CuLL);
  v479 = v478;
  if ((_DWORD)v477)
  {
    if (!v478)
      goto LABEL_614;
  }
  bzero(v478, 4 * v477);
  *((_QWORD *)v17 + 69) = v479;
  v480 = *(unsigned int *)(*(_QWORD *)v17 + 72);
  v481 = malloc_type_malloc(4 * v480, 0x2C8E6D5CuLL);
  v482 = v481;
  if ((_DWORD)v480)
  {
    if (!v481)
      goto LABEL_614;
  }
  bzero(v481, 4 * v480);
  *((_QWORD *)v17 + 88) = v482;
  v483 = *(unsigned int *)(*(_QWORD *)v17 + 72);
  v484 = malloc_type_malloc(4 * v483, 0x2C8E6D5CuLL);
  v485 = v484;
  if ((_DWORD)v483)
  {
    if (!v484)
      goto LABEL_614;
  }
  bzero(v484, 4 * v483);
  *((_QWORD *)v17 + 89) = v485;
  v486 = *(unsigned int *)(*(_QWORD *)v17 + 56);
  v487 = malloc_type_malloc(4 * v486, 0x2C8E6D5CuLL);
  v488 = v487;
  if ((_DWORD)v486)
  {
    if (!v487)
      goto LABEL_614;
  }
  bzero(v487, 4 * v486);
  *((_QWORD *)v17 + 70) = v488;
  v489 = *(unsigned int *)(*(_QWORD *)v17 + 44);
  v490 = malloc_type_malloc(4 * v489, 0x2C8E6D5CuLL);
  v491 = v490;
  if ((_DWORD)v489)
  {
    if (!v490)
      goto LABEL_614;
  }
  bzero(v490, 4 * v489);
  *((_QWORD *)v17 + 71) = v491;
  v492 = *(unsigned int *)(*(_QWORD *)v17 + 60);
  v493 = malloc_type_malloc(4 * v492, 0x2C8E6D5CuLL);
  v494 = v493;
  if ((_DWORD)v492)
  {
    if (!v493)
      goto LABEL_614;
  }
  bzero(v493, 4 * v492);
  *((_QWORD *)v17 + 72) = v494;
  v495 = *(unsigned int *)(*(_QWORD *)v17 + 72);
  v496 = malloc_type_malloc(4 * v495, 0x2C8E6D5CuLL);
  v497 = v496;
  if ((_DWORD)v495)
  {
    if (!v496)
    {
LABEL_614:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v825 = std::bad_alloc::bad_alloc(exception);
      goto LABEL_617;
    }
  }
  bzero(v496, 4 * v495);
  *((_QWORD *)v17 + 73) = v497;
  v498 = *(unsigned int *)(*((_QWORD *)v17 + 1) + 8);
  v499 = (float *)*((_QWORD *)v17 + 75);
  v500 = (float *)*((_QWORD *)v17 + 76);
  v501 = (double *)VADGenUtils::TwoPi(void)::result;
  if (VADGenUtils::TwoPi(void)::result)
  {
    v502 = *(double *)VADGenUtils::TwoPi(void)::result;
    if (!(_DWORD)v498)
      goto LABEL_401;
  }
  else
  {
    v501 = (double *)operator new();
    *v501 = 6.28318531;
    VADGenUtils::TwoPi(void)::result = (uint64_t)v501;
    v502 = 6.28318531;
    if (!(_DWORD)v498)
      goto LABEL_401;
  }
  v503 = 0;
  v504 = v502 / (double)v498;
  v505 = 4 * v498;
  do
  {
    v506 = 0;
    v507 = v499;
    v508 = v500;
    v509 = v498;
    do
    {
      v510 = __sincos_stret(v504 * (double)v506);
      cosval = v510.__cosval;
      *v507++ = cosval;
      sinval = v510.__sinval;
      *v508++ = -sinval;
      v506 += v503;
      --v509;
    }
    while (v509);
    ++v503;
    v500 = (float *)((char *)v500 + v505);
    v499 = (float *)((char *)v499 + v505);
  }
  while (v503 != v498);
LABEL_401:
  v514 = *v831;
  v513 = v831[1];
  v515 = v513[1].u32[0];
  if (v515)
  {
    v516 = 0;
    v517 = 0;
    v518 = *((unsigned int *)v831 + 180);
    v519 = v513[1].f32[1];
    v520 = v831[77];
    v521 = v514[1].f32[0] * 0.5;
    v522 = (float)(v514[7].i32[1] - 1);
    do
    {
      if ((_DWORD)v518)
      {
        for (i = 0; i != v518; ++i)
        {
          v524 = exp2((float)((float)i + (float)((float)v517 * (float)(1.0 / (float)v515))));
          v520->i32[(v516 + i)] = (float)(unint64_t)((float)((float)((float)(unint64_t)((float)(v519 * v524) + 0.5) / v521)
                                                                                              * v522)
                                                                                      + 0.5);
        }
      }
      ++v517;
      v516 += v518;
    }
    while (v517 != v515);
  }
  v525 = (float *)v831[79];
  v526 = v831[81];
  v527 = *((unsigned int *)v831 + 184);
  v528 = v831[2];
  v529 = v514[1].f32[1];
  v531 = v528[1].f32[0];
  v530 = v528[1].f32[1];
  if ((_DWORD)v527)
  {
    v532 = (float *)v831[80];
    v533 = (float)(v527 - 1);
    v534 = 0.5 / v533;
    v535 = 0.0;
    v536 = (float *)v831[79];
    v537 = *((unsigned int *)v831 + 184);
    v538 = 0.0;
    v539 = 3.1416 / v533;
    do
    {
      *v536++ = v538;
      *v532++ = v535;
      v538 = v534 + v538;
      v535 = v539 + v535;
      --v537;
    }
    while (v537);
  }
  v541 = v528[5];
  v540 = v528[6];
  if (*(_QWORD *)&v540 != *(_QWORD *)&v541)
  {
    v542 = 0;
    v543 = 0;
    v544 = v529 * 60.0;
    v545 = v531 / v544;
    v546 = v530 / v544;
    while (v542 < (uint64_t)(*(_QWORD *)&v526[1] - *(_QWORD *)v526) >> 3)
    {
      v547 = *(float **)(*(_QWORD *)v526 + 8 * v542);
      v548 = (float)*(unsigned int *)(*(_QWORD *)&v541 + 12 * v542 + 4);
      v549 = v546 * v548;
      v550 = log((float)(v545 * v548));
      v551 = log(v549);
      if ((_DWORD)v527)
      {
        v552 = _D15;
        v553 = (v550 + v551) * 0.5;
        v554 = (v551 - v553) * (v551 - v553);
        v555 = v525;
        v556 = v527;
        do
        {
          v557 = 0.0;
          if (*v555 != 0.0)
          {
            v558 = log(*v555);
            if (v501)
            {
              v559 = *v501;
            }
            else
            {
              v501 = (double *)operator new();
              *v501 = 6.28318531;
              VADGenUtils::TwoPi(void)::result = (uint64_t)v501;
              v559 = 6.28318531;
            }
            v560 = log(v554 * v559);
            v557 = exp(((v558 - v553) * (v558 - v553) / v554 + v560) * -0.5);
          }
          *v547++ = v557;
          ++v555;
          --v556;
        }
        while (v556);
        v541 = v528[5];
        v540 = v528[6];
        _D15 = v552;
      }
      v542 = ++v543;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&v540 - *(_QWORD *)&v541) >> 2) <= v543)
        goto LABEL_423;
    }
LABEL_618:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
LABEL_423:
  v561 = (unsigned int *)v831;
  v562 = *((unsigned int *)v831 + 198);
  v563 = (float *)v831[82];
  v564 = v562 - 1;
  if ((_DWORD)v562 == 1)
  {
    *v563 = 0.0;
    v573 = 0;
  }
  else
  {
    v565 = 0;
    v566 = 0.0;
    v567 = (float *)v831[82];
    do
    {
      if (v501)
      {
        v568 = *v501;
      }
      else
      {
        v501 = (double *)operator new();
        *v501 = 6.28318531;
        VADGenUtils::TwoPi(void)::result = (uint64_t)v501;
        v568 = 6.28318531;
      }
      v569 = cos(v568 * (float)((float)(v562 + v565 - 2) / (float)(2 * v564 - 2)));
      v570 = v569 * -0.5 + 0.5;
      v566 = v566 + v570;
      *v567++ = v570;
      ++v565;
    }
    while ((_DWORD)v562 - 1 != v565);
    v571 = 1;
    v572 = v563;
    do
    {
      *v572 = (float)(1.0 / v566) * *v572;
      ++v572;
      ++v571;
    }
    while ((_DWORD)v562 != v571);
    v573 = 0;
    v563[v564] = 0.0;
    v561 = (unsigned int *)v831;
    if (!(_DWORD)v562)
    {
      v562 = 0;
      v573 = 1;
      goto LABEL_436;
    }
  }
  v574 = 0.0;
  v575 = v563;
  v576 = v562;
  do
  {
    v577 = *v575;
    *v575 = *v575 - v574;
    ++v575;
    v574 = v577;
    --v576;
  }
  while (v576);
LABEL_436:
  v578 = 0;
  v579 = 0.0;
  v580 = 0.0;
  do
  {
    v581 = 0.0;
    v582 = 0.0;
    if (v562)
    {
      v583 = v563;
      v584 = v562;
      v585 = 0.0;
      do
      {
        v586 = __sincos_stret(v585);
        v587 = *v583++;
        v588 = v586.__cosval * v587;
        v581 = v581 + v588;
        v589 = v586.__sinval * v587;
        v582 = v582 - v589;
        v585 = v585 + v580;
        --v584;
      }
      while (v584);
    }
    v590 = sqrtf((float)(v582 * v582) + (float)(v581 * v581));
    if (v590 > v579)
      v579 = v590;
    v580 = v580 + 0.0061479;
    ++v578;
  }
  while (v578 != 512);
  if ((v573 & 1) == 0)
  {
    do
    {
      *v563 = (float)(1.0 / v579) * *v563;
      ++v563;
      --v562;
    }
    while (v562);
  }
  v591 = *(_QWORD *)v561;
  v592 = *(unsigned int *)(*(_QWORD *)v561 + 56);
  if ((_DWORD)v592)
  {
    v593 = 0;
    v594 = *((_QWORD *)v561 + 83);
    do
    {
      *(float *)(v594 + 4 * v593) = (float)v593;
      ++v593;
    }
    while (v592 != v593);
  }
  v595 = *(float *)(v591 + 32);
  v596 = *(float *)(v591 + 36);
  v597 = *(float *)(v591 + 8);
  v598 = (void *)*((_QWORD *)v561 + 84);
  v599 = *(unsigned int *)(v591 + 72);
  bzero(v598, 4 * v599);
  v600 = log(v595);
  if (VADGenUtils::LogTwo(void)::result)
  {
    v601 = *(double *)VADGenUtils::LogTwo(void)::result;
  }
  else
  {
    v602 = (_QWORD *)operator new();
    *v602 = 0x3FE62E42FEFA39EFLL;
    VADGenUtils::LogTwo(void)::result = (uint64_t)v602;
    v601 = 0.693147181;
  }
  v603 = 0.0;
  if (v599 >= 2)
  {
    v604 = v601 * v596 * (v601 * v596);
    v605 = (double *)VADGenUtils::TwoPi(void)::result;
    v606 = 1;
    v607 = 1.0 / v597;
    do
    {
      v608 = log((float)(v607 * (float)v606));
      if (v605)
      {
        v609 = *v605;
      }
      else
      {
        v605 = (double *)operator new();
        *v605 = 6.28318531;
        VADGenUtils::TwoPi(void)::result = (uint64_t)v605;
        v609 = 6.28318531;
      }
      v610 = log(v604 * v609);
      v611 = exp(((-v608 - v600) * (-v608 - v600) / v604 + v610) * -0.5);
      *((float *)v598 + v606) = v611;
      v603 = v603 + v611;
      ++v606;
    }
    while ((_DWORD)v599 != (_DWORD)v606);
  }
  *(float *)&__B = 1.0 / v603;
  vDSP_vsmul((const float *)v598, 1, (const float *)&__B, (float *)v598, 1, v599);
  ASAFeatures::computeCepstralSpeechWindow(*((ASAFeatures **)v561 + 84), *(float *)(*((_QWORD *)v561 + 12) + 8), *(float *)(*(_QWORD *)v561 + 76), *((float **)v561 + 85), (float *)*(unsigned int *)(*(_QWORD *)v561 + 72));
  ASAFeatures::computeCepstralSpeechWindow(*((ASAFeatures **)v561 + 84), *(float *)(*((_QWORD *)v561 + 13) + 12), *(float *)(*(_QWORD *)v561 + 76), *((float **)v561 + 88), (float *)*(unsigned int *)(*(_QWORD *)v561 + 72));
  v612 = *(_QWORD *)v561;
  v613 = *(unsigned int *)(*(_QWORD *)v561 + 72);
  if ((_DWORD)v613)
  {
    v614 = 0;
    v615 = *((_QWORD *)v561 + 89);
    do
    {
      *(float *)(v615 + 4 * v614) = (float)(unint64_t)(v614 + 1);
      ++v614;
    }
    while (v613 != v614);
  }
  v616 = *((_QWORD *)v561 + 3);
  v617 = v561[207];
  v618 = 0.0;
  v619 = 0.0;
  if (v617)
  {
    v620 = (float)v617;
    v619 = 0.0;
    v621 = 1;
    do
    {
      v619 = (float)(1.0 - *(float *)(v616 + 12)) + (float)(*(float *)(v616 + 12) * v619);
      v622 = (float)v621++;
    }
    while (v622 < v620);
  }
  *((float *)v561 + 238) = v619;
  v623 = v561[219];
  v624 = 0.0;
  v625 = 0.0;
  v626 = 0.0;
  v627 = 0.0;
  if (v623)
  {
    v631 = 0.0;
    v632 = 0.0;
    v618 = 0.0;
    do
    {
      v624 = v618;
      v626 = v625;
      v618 = v627;
      v627 = 1.0;
      v628 = *((double *)v561 + 110);
      v629 = *((double *)v561 + 111);
      v630 = *((double *)v561 + 112);
      v625 = (float)((float)(v625 * v628) + (float)(v630 * (float)((float)((float)(v618 + 1.0) - v624) - v632)))
           + (float)(v629 * v631);
      v631 = v626;
      v632 = v624;
      --v623;
    }
    while (v623);
  }
  *((float *)v561 + 239) = v627;
  *((float *)v561 + 240) = v618;
  *((float *)v561 + 241) = v624;
  *((float *)v561 + 242) = v625;
  *((float *)v561 + 243) = v626;
  v561[251] = 0;
  *(_OWORD *)(v561 + 247) = 0u;
  v633 = *(unsigned int *)(v612 + 44);
  if ((_DWORD)v633)
  {
    v634 = 0;
    v635 = *((_QWORD *)v561 + 6);
    v636 = *(_QWORD *)(v635 + 40);
    v637 = (*(_QWORD *)(v635 + 48) - v636) >> 2;
    while (v637 != v634)
    {
      *(_DWORD *)(*((_QWORD *)v561 + 59) + 4 * v634) = *(_DWORD *)(v636 + 4 * v634);
      if (v633 == ++v634)
        goto LABEL_470;
    }
    goto LABEL_621;
  }
LABEL_470:
  v638 = *(unsigned int *)(v612 + 60);
  if ((_DWORD)v638)
  {
    v639 = 0;
    v640 = *(_QWORD *)(v616 + 32);
    v641 = (*(_QWORD *)(v616 + 40) - v640) >> 2;
    while (v641 != v639)
    {
      *(_DWORD *)(*((_QWORD *)v561 + 44) + 4 * v639) = *(_DWORD *)(v640 + 4 * v639);
      if (v638 == ++v639)
        goto LABEL_474;
    }
    goto LABEL_621;
  }
LABEL_474:
  v642 = (_OWORD *)*((_QWORD *)v561 + 19);
  *((_QWORD *)v561 + 20) = v642;
  v643 = *((_QWORD *)v561 + 21) - (_QWORD)v642;
  if ((unint64_t)v643 >= 0x90)
  {
    v642[7] = 0u;
    v642[8] = 0u;
    v642[5] = 0u;
    v642[6] = 0u;
    v642[3] = 0u;
    v642[4] = 0u;
    v642[1] = 0u;
    v642[2] = 0u;
    *v642 = 0u;
    *((_QWORD *)v561 + 20) = v642 + 9;
  }
  else
  {
    v644 = v643 >> 2;
    if (v644 <= 0x12)
      v645 = 18;
    else
      v645 = v644;
    if (v645 >> 61)
LABEL_623:
      std::__throw_bad_array_new_length[abi:ne180100]();
    v561 = (unsigned int *)v831;
    v646 = (float32x2_t *)operator new(8 * v645);
    *(_OWORD *)v646[14].f32 = 0u;
    *(_OWORD *)v646[16].f32 = 0u;
    *(_OWORD *)v646[10].f32 = 0u;
    *(_OWORD *)v646[12].f32 = 0u;
    *(_OWORD *)v646[6].f32 = 0u;
    *(_OWORD *)v646[8].f32 = 0u;
    *(_OWORD *)v646[2].f32 = 0u;
    *(_OWORD *)v646[4].f32 = 0u;
    *(_OWORD *)v646->f32 = 0u;
    v831[19] = v646;
    v831[20] = v646 + 18;
    v831[21] = &v646[v645];
    if (v642)
      operator delete(v642);
  }
  v648 = *(float *)(*(_QWORD *)v561 + 48);
  v647 = *(float *)(*(_QWORD *)v561 + 52);
  v649 = operator new();
  v650 = *(_DWORD *)(*((_QWORD *)v561 + 1) + 24);
  std::vector<float>::vector(&__B, 1uLL);
  v651 = __B;
  v652 = *(_QWORD *)&v837;
  v653 = *(_QWORD *)&v837 - *(_QWORD *)&__B;
  if (*(_QWORD *)&v837 == *(_QWORD *)&__B)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  v654 = (unint64_t)(float)(unint64_t)(v648 + 0.5);
  v655 = (unint64_t)(float)(unint64_t)(v647 + 0.5);
  **(_DWORD **)&__B = v650;
  *(_QWORD *)v649 = v654;
  *(_QWORD *)(v649 + 8) = v655;
  *(_QWORD *)(v649 + 24) = 0;
  *(_QWORD *)(v649 + 32) = 0;
  *(_QWORD *)(v649 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v649 + 16), *(const void **)&v651, v652, v653 >> 2);
  *(_QWORD *)(v649 + 40) = 1;
  *(_DWORD *)(v649 + 48) = 1;
  v656 = (uint64_t *)*((_QWORD *)v561 + 19);
  if (*((uint64_t **)v561 + 20) == v656)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *v656 = v649;
  if (__B != 0.0)
  {
    v837 = __B;
    operator delete(*(void **)&__B);
  }
  v657 = operator new();
  v658 = *((_QWORD *)v561 + 2);
  v659 = v561[183];
  *(_QWORD *)&v660 = *v827;
  *((_QWORD *)&v660 + 1) = HIDWORD(*v827);
  *(_OWORD *)v657 = v660;
  *(_QWORD *)(v657 + 24) = 0;
  *(_QWORD *)(v657 + 32) = 0;
  *(_QWORD *)(v657 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v657 + 16), *(const void **)(v658 + 64), *(_QWORD *)(v658 + 72), (uint64_t)(*(_QWORD *)(v658 + 72) - *(_QWORD *)(v658 + 64)) >> 2);
  *(_QWORD *)(v657 + 40) = v659;
  *(_DWORD *)(v657 + 48) = 1;
  v661 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v661) < 9)
    goto LABEL_615;
  *(_QWORD *)(v661 + 8) = v657;
  v662 = operator new();
  v663 = v561[206];
  v664 = *((_QWORD *)v561 + 3);
  v665 = *(unsigned int *)(*(_QWORD *)v561 + 60);
  *(_QWORD *)v662 = v663;
  *(_QWORD *)(v662 + 8) = v663;
  *(_QWORD *)(v662 + 24) = 0;
  *(_QWORD *)(v662 + 32) = 0;
  *(_QWORD *)(v662 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v662 + 16), *(const void **)(v664 + 32), *(_QWORD *)(v664 + 40), (uint64_t)(*(_QWORD *)(v664 + 40) - *(_QWORD *)(v664 + 32)) >> 2);
  *(_QWORD *)(v662 + 40) = v665;
  *(_DWORD *)(v662 + 48) = 1;
  v666 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v666) < 0x11)
LABEL_615:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v666 + 16) = v662;
  v667 = *(float *)(*((_QWORD *)v561 + 4) + 12);
  std::vector<float>::vector(&__B, 1uLL);
  if (*(_QWORD *)&v837 == *(_QWORD *)&__B)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  **(float **)&__B = v667 * 0.11513;
  __exp10((float)(*(float *)(*((_QWORD *)v561 + 4) + 8) / 20.0));
  v668 = operator new();
  *(_QWORD *)v668 = v654;
  *(_QWORD *)(v668 + 8) = v655;
  *(_QWORD *)(v668 + 24) = 0;
  *(_QWORD *)(v668 + 32) = 0;
  *(_QWORD *)(v668 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v668 + 16), *(const void **)&__B, *(uint64_t *)&v837, (uint64_t)(*(_QWORD *)&v837 - *(_QWORD *)&__B) >> 2);
  *(_QWORD *)(v668 + 40) = 1;
  *(_DWORD *)(v668 + 48) = 3;
  v669 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v669) < 0x19)
    goto LABEL_629;
  *(_QWORD *)(v669 + 24) = v668;
  v670 = operator new();
  v671 = *(_DWORD *)(*((_QWORD *)v561 + 5) + 12);
  std::vector<float>::vector(&__p, 1uLL);
  v672 = __p;
  v673 = (uint64_t)v835;
  v674 = v835 - (_BYTE *)__p;
  if (v835 == __p)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)__p = v671;
  *(_QWORD *)v670 = v654;
  *(_QWORD *)(v670 + 8) = v655;
  *(_QWORD *)(v670 + 24) = 0;
  *(_QWORD *)(v670 + 32) = 0;
  *(_QWORD *)(v670 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v670 + 16), v672, v673, v674 >> 2);
  *(_QWORD *)(v670 + 40) = 1;
  *(_DWORD *)(v670 + 48) = 1;
  v675 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v675) <= 0x20)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v675 + 32) = v670;
  if (__p)
  {
    v835 = __p;
    operator delete(__p);
  }
  v676 = operator new();
  v677 = v561[218];
  v678 = *((_QWORD *)v561 + 6);
  v679 = *(unsigned int *)(*(_QWORD *)v561 + 44);
  *(_QWORD *)v676 = v677;
  *(_QWORD *)(v676 + 8) = v677;
  *(_QWORD *)(v676 + 24) = 0;
  *(_QWORD *)(v676 + 32) = 0;
  *(_QWORD *)(v676 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v676 + 16), *(const void **)(v678 + 40), *(_QWORD *)(v678 + 48), (uint64_t)(*(_QWORD *)(v678 + 48) - *(_QWORD *)(v678 + 40)) >> 2);
  *(_QWORD *)(v676 + 40) = v679;
  *(_DWORD *)(v676 + 48) = 1;
  v680 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v680) <= 0x28)
LABEL_629:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v680 + 40) = v676;
  v681 = operator new();
  v682 = *(_DWORD *)(*((_QWORD *)v561 + 6) + 64);
  std::vector<float>::vector(&__p, 1uLL);
  v683 = __p;
  v684 = (uint64_t)v835;
  v685 = v835 - (_BYTE *)__p;
  if (v835 == __p)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)__p = v682;
  *(_QWORD *)v681 = v654;
  *(_QWORD *)(v681 + 8) = v655;
  *(_QWORD *)(v681 + 24) = 0;
  *(_QWORD *)(v681 + 32) = 0;
  *(_QWORD *)(v681 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v681 + 16), v683, v684, v685 >> 2);
  *(_QWORD *)(v681 + 40) = 1;
  *(_DWORD *)(v681 + 48) = 1;
  v686 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v686) <= 0x30)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v686 + 48) = v681;
  if (__p)
  {
    v835 = __p;
    operator delete(__p);
  }
  v687 = __exp10((float)(*(float *)(*((_QWORD *)v561 + 4) + 12) / 20.0));
  std::vector<float>::vector(&__p, 1uLL);
  if (v835 == __p)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  v688 = v687;
  *(float *)__p = v688;
  v689 = operator new();
  *(_QWORD *)v689 = v654;
  *(_QWORD *)(v689 + 8) = v655;
  *(_QWORD *)(v689 + 24) = 0;
  *(_QWORD *)(v689 + 32) = 0;
  *(_QWORD *)(v689 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v689 + 16), __p, (uint64_t)v835, (v835 - (_BYTE *)__p) >> 2);
  *(_QWORD *)(v689 + 40) = 1;
  *(_DWORD *)(v689 + 48) = 1;
  v690 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v690) < 0x39)
    goto LABEL_630;
  *(_QWORD *)(v690 + 56) = v689;
  v691 = operator new();
  v692 = *(_DWORD *)(*((_QWORD *)v561 + 8) + 12);
  std::vector<float>::vector(&v832, 1uLL);
  v693 = v832;
  v694 = (uint64_t)v833;
  v695 = v833 - (_BYTE *)v832;
  if (v833 == v832)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)v832 = v692;
  *(_QWORD *)v691 = v654;
  *(_QWORD *)(v691 + 8) = v655;
  *(_QWORD *)(v691 + 24) = 0;
  *(_QWORD *)(v691 + 32) = 0;
  *(_QWORD *)(v691 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v691 + 16), v693, v694, v695 >> 2);
  *(_QWORD *)(v691 + 40) = 1;
  *(_DWORD *)(v691 + 48) = 3;
  v696 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v696) <= 0x40)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v696 + 64) = v691;
  if (v832)
  {
    v833 = v832;
    operator delete(v832);
  }
  v697 = operator new();
  v698 = *(_DWORD *)(*((_QWORD *)v561 + 9) + 8);
  std::vector<float>::vector(&v832, 1uLL);
  v699 = v832;
  v700 = (uint64_t)v833;
  v701 = v833 - (_BYTE *)v832;
  if (v833 == v832)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)v832 = v698;
  *(_QWORD *)v697 = v654;
  *(_QWORD *)(v697 + 8) = v655;
  *(_QWORD *)(v697 + 24) = 0;
  *(_QWORD *)(v697 + 32) = 0;
  *(_QWORD *)(v697 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v697 + 16), v699, v700, v701 >> 2);
  *(_QWORD *)(v697 + 40) = 1;
  *(_DWORD *)(v697 + 48) = 3;
  v702 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v702) <= 0x48)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v702 + 72) = v697;
  if (v832)
  {
    v833 = v832;
    operator delete(v832);
  }
  v703 = operator new();
  v704 = *(_DWORD *)(*((_QWORD *)v561 + 10) + 8);
  std::vector<float>::vector(&v832, 1uLL);
  v705 = v832;
  v706 = (uint64_t)v833;
  v707 = v833 - (_BYTE *)v832;
  if (v833 == v832)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)v832 = v704;
  *(_QWORD *)v703 = v654;
  *(_QWORD *)(v703 + 8) = v655;
  *(_QWORD *)(v703 + 24) = 0;
  *(_QWORD *)(v703 + 32) = 0;
  *(_QWORD *)(v703 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v703 + 16), v705, v706, v707 >> 2);
  *(_QWORD *)(v703 + 40) = 1;
  *(_DWORD *)(v703 + 48) = 3;
  v708 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v708) <= 0x50)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v708 + 80) = v703;
  if (v832)
  {
    v833 = v832;
    operator delete(v832);
  }
  v709 = operator new();
  v710 = *(_DWORD *)(*((_QWORD *)v561 + 11) + 8);
  std::vector<float>::vector(&v832, 1uLL);
  v711 = v832;
  v712 = (uint64_t)v833;
  v713 = v833 - (_BYTE *)v832;
  if (v833 == v832)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)v832 = v710;
  *(_QWORD *)v709 = v654;
  *(_QWORD *)(v709 + 8) = v655;
  *(_QWORD *)(v709 + 24) = 0;
  *(_QWORD *)(v709 + 32) = 0;
  *(_QWORD *)(v709 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v709 + 16), v711, v712, v713 >> 2);
  *(_QWORD *)(v709 + 40) = 1;
  *(_DWORD *)(v709 + 48) = 3;
  v714 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v714) <= 0x58)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v714 + 88) = v709;
  if (v832)
  {
    v833 = v832;
    operator delete(v832);
  }
  v715 = operator new();
  v716 = *(_DWORD *)(*((_QWORD *)v561 + 12) + 12);
  std::vector<float>::vector(&v832, 1uLL);
  v717 = v832;
  v718 = (uint64_t)v833;
  v719 = v833 - (_BYTE *)v832;
  if (v833 == v832)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)v832 = v716;
  *(_QWORD *)v715 = v654;
  *(_QWORD *)(v715 + 8) = v655;
  *(_QWORD *)(v715 + 24) = 0;
  *(_QWORD *)(v715 + 32) = 0;
  *(_QWORD *)(v715 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v715 + 16), v717, v718, v719 >> 2);
  *(_QWORD *)(v715 + 40) = 1;
  *(_DWORD *)(v715 + 48) = 3;
  v720 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v720) <= 0x60)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v720 + 96) = v715;
  if (v832)
  {
    v833 = v832;
    operator delete(v832);
  }
  v721 = operator new();
  v722 = *(_DWORD *)(*((_QWORD *)v561 + 13) + 16);
  std::vector<float>::vector(&v832, 1uLL);
  v723 = v832;
  v724 = (uint64_t)v833;
  v725 = v833 - (_BYTE *)v832;
  if (v833 == v832)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)v832 = v722;
  *(_QWORD *)v721 = v654;
  *(_QWORD *)(v721 + 8) = v655;
  *(_QWORD *)(v721 + 24) = 0;
  *(_QWORD *)(v721 + 32) = 0;
  *(_QWORD *)(v721 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v721 + 16), v723, v724, v725 >> 2);
  *(_QWORD *)(v721 + 40) = 1;
  *(_DWORD *)(v721 + 48) = 1;
  v726 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v726) <= 0x68)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v726 + 104) = v721;
  if (v832)
  {
    v833 = v832;
    operator delete(v832);
  }
  v727 = operator new();
  v728 = *(_DWORD *)(*((_QWORD *)v561 + 14) + 16);
  std::vector<float>::vector(&v832, 1uLL);
  v729 = v832;
  v730 = (uint64_t)v833;
  v731 = v833 - (_BYTE *)v832;
  if (v833 == v832)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)v832 = v728;
  *(_QWORD *)v727 = v654;
  *(_QWORD *)(v727 + 8) = v655;
  *(_QWORD *)(v727 + 24) = 0;
  *(_QWORD *)(v727 + 32) = 0;
  *(_QWORD *)(v727 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v727 + 16), v729, v730, v731 >> 2);
  *(_QWORD *)(v727 + 40) = 1;
  *(_DWORD *)(v727 + 48) = 1;
  v732 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v732) <= 0x70)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v732 + 112) = v727;
  if (v832)
  {
    v833 = v832;
    operator delete(v832);
  }
  v733 = operator new();
  *(_QWORD *)v733 = v654;
  *(_QWORD *)(v733 + 8) = v655;
  *(_QWORD *)(v733 + 24) = 0;
  *(_QWORD *)(v733 + 32) = 0;
  *(_QWORD *)(v733 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v733 + 16), __p, (uint64_t)v835, (v835 - (_BYTE *)__p) >> 2);
  *(_QWORD *)(v733 + 40) = 1;
  *(_DWORD *)(v733 + 48) = 1;
  v734 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v734) <= 0x78)
LABEL_630:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v734 + 120) = v733;
  v735 = operator new();
  v736 = *(_DWORD *)(*((_QWORD *)v561 + 15) + 16);
  std::vector<float>::vector(&v832, 1uLL);
  v737 = v832;
  v738 = (uint64_t)v833;
  v739 = v833 - (_BYTE *)v832;
  if (v833 == v832)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)v832 = v736;
  *(_QWORD *)v735 = v654;
  *(_QWORD *)(v735 + 8) = v655;
  *(_QWORD *)(v735 + 24) = 0;
  *(_QWORD *)(v735 + 32) = 0;
  *(_QWORD *)(v735 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v735 + 16), v737, v738, v739 >> 2);
  *(_QWORD *)(v735 + 40) = 1;
  *(_DWORD *)(v735 + 48) = 1;
  v740 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v740) <= 0x80)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v740 + 128) = v735;
  if (v832)
  {
    v833 = v832;
    operator delete(v832);
  }
  v741 = operator new();
  v742 = *(_DWORD *)(*((_QWORD *)v561 + 15) + 20);
  std::vector<float>::vector(&v832, 1uLL);
  v743 = v832;
  v744 = (uint64_t)v833;
  v745 = v833 - (_BYTE *)v832;
  if (v833 == v832)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_DWORD *)v832 = v742;
  *(_QWORD *)v741 = v654;
  *(_QWORD *)(v741 + 8) = v655;
  *(_QWORD *)(v741 + 24) = 0;
  *(_QWORD *)(v741 + 32) = 0;
  *(_QWORD *)(v741 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v741 + 16), v743, v744, v745 >> 2);
  *(_QWORD *)(v741 + 40) = 1;
  *(_DWORD *)(v741 + 48) = 1;
  v746 = *((_QWORD *)v561 + 19);
  if ((unint64_t)(*((_QWORD *)v561 + 20) - v746) <= 0x88)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(_QWORD *)(v746 + 136) = v741;
  if (v832)
  {
    v833 = v832;
    operator delete(v832);
  }
  if (__p)
  {
    v835 = __p;
    operator delete(__p);
  }
  if (__B != 0.0)
  {
    v837 = __B;
    operator delete(*(void **)&__B);
  }
  v747 = (void *)*((_QWORD *)v561 + 22);
  *((_QWORD *)v561 + 23) = v747;
  if (*((_QWORD *)v561 + 24) - (_QWORD)v747 < 0x90uLL)
  {
    v748 = (char *)operator new(0x90uLL);
    *((_QWORD *)v561 + 22) = v748;
    *((_QWORD *)v561 + 23) = v748;
    *((_QWORD *)v561 + 24) = v748 + 144;
    if (v747)
      operator delete(v747);
  }
  for (j = 0; j != 18; ++j)
  {
    v750 = *((_QWORD *)v561 + 19);
    if (j >= (*((_QWORD *)v561 + 20) - v750) >> 3)
      goto LABEL_615;
    v751 = *(_QWORD *)(v750 + 8 * j);
    v753 = *(_QWORD *)(v751 + 16);
    v752 = *(_QWORD *)(v751 + 24);
    if (v752 != v753 && v752 - v753 < 0
      || ((v754 = malloc_type_malloc(v752 - v753, 0x2C8E6D5CuLL), v755 = v754, v752 != v753)
        ? (v756 = v754 == 0)
        : (v756 = 0),
          v756))
    {
      v826 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v825 = std::bad_alloc::bad_alloc(v826);
LABEL_617:
    }
    bzero(v754, v752 - v753);
    v757 = v831[19];
    if (j >= v831[20] - v757)
      goto LABEL_615;
    v759 = (int **)(*(_QWORD *)&v757[j] + 16);
    v758 = *v759;
    v760 = (char *)v759[1] - (char *)*v759;
    if (v760)
    {
      v761 = v760 >> 2;
      if (v761 <= 1)
        v761 = 1;
      v762 = v755;
      do
      {
        v763 = *v758++;
        *v762++ = v763;
        --v761;
      }
      while (v761);
    }
    v764 = operator new();
    v765 = v764;
    v766 = v831[19];
    if (j >= v831[20] - v766)
      std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
    v767 = (int64x2_t *)v766[j];
    v768 = v767[2].i32[2];
    v769 = v767[3].i32[0];
    *(_QWORD *)v764 = &off_1E69C56E0;
    *(_DWORD *)(v764 + 8) = v768;
    v770 = (uint32x2_t)vmovn_s64(*v767);
    *(uint32x2_t *)(v764 + 12) = v770;
    *(float32x2_t *)(v764 + 20) = vdiv_f32(_D15, vcvt_f32_u32(v770));
    *(_OWORD *)(v764 + 97) = 0u;
    *(_OWORD *)(v764 + 88) = 0u;
    *(_OWORD *)(v764 + 72) = 0u;
    *(_OWORD *)(v764 + 56) = 0u;
    *(_OWORD *)(v764 + 40) = 0u;
    *(_DWORD *)(v764 + 116) = 0;
    *(_DWORD *)(v764 + 120) = v769;
    *(_QWORD *)(v764 + 128) = 0;
    *(_DWORD *)(v764 + 28) = -(v770.i32[1] * v768);
    *(_DWORD *)(v764 + 32) = v768 - v770.i32[1] * v768;
    FeatureAverager<float>::allocateStorage(v764);
    (*(void (**)(uint64_t, _DWORD *))(*(_QWORD *)v765 + 32))(v765, v755);
    v772 = v831[23];
    v771 = (unint64_t)v831[24];
    if ((unint64_t)v772 >= v771)
    {
      v774 = v831[22];
      v775 = v772 - v774;
      v776 = v775 + 1;
      if ((unint64_t)(v775 + 1) >> 61)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v777 = v771 - (_QWORD)v774;
      if (v777 >> 2 > v776)
        v776 = v777 >> 2;
      if ((unint64_t)v777 >= 0x7FFFFFFFFFFFFFF8)
        v778 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v778 = v776;
      if (v778)
      {
        if (v778 >> 61)
          goto LABEL_623;
        v779 = (char *)operator new(8 * v778);
      }
      else
      {
        v779 = 0;
      }
      v780 = (uint64_t *)&v779[8 * v775];
      *v780 = v765;
      v773 = (float32x2_t *)(v780 + 1);
      if (v772 == v774)
      {
        v782 = v831;
      }
      else
      {
        do
        {
          v781 = (uint64_t)v772[-1];
          --v772;
          *--v780 = v781;
        }
        while (v772 != v774);
        v782 = v831;
        v772 = v831[22];
      }
      v782[22] = (float32x2_t *)v780;
      v782[23] = v773;
      v782[24] = (float32x2_t *)&v779[8 * v778];
      if (v772)
        operator delete(v772);
    }
    else
    {
      *v772 = (float32x2_t)v765;
      v773 = v772 + 1;
    }
    v831[23] = v773;
    v561 = (unsigned int *)v831;
    free(v755);
  }
  __B = __exp10(v831[4][1].f32[1] / 20.0);
  v783 = (*v831)[6];
  v784 = operator new();
  *(_QWORD *)v784 = &off_1E69C5720;
  *(_DWORD *)(v784 + 8) = 1;
  v785 = (int64x2_t)vcvtq_u64_f64(vcvtq_f64_f32(vcvt_f32_f64(vcvtq_f64_u64(vcvtq_u64_f64(vaddq_f64(vcvtq_f64_f32(v783), v829))))));
  v786 = vmovn_s64(v785);
  *(int32x2_t *)(v784 + 12) = v786;
  v787.i64[0] = 0xFFFFFFFFLL;
  v787.i64[1] = 0xFFFFFFFFLL;
  v788 = vcvtq_f64_u64((uint64x2_t)vandq_s8((int8x16_t)v785, v787));
  __asm { FMOV            V2.2D, #1.0 }
  *(float64x2_t *)(v784 + 24) = vdivq_f64(_Q2, v788);
  *(_OWORD *)(v784 + 48) = 0u;
  *(_OWORD *)(v784 + 64) = 0u;
  *(_OWORD *)(v784 + 80) = 0u;
  *(_OWORD *)(v784 + 96) = 0u;
  *(_OWORD *)(v784 + 105) = 0u;
  *(_QWORD *)(v784 + 124) = 0x300000000;
  *(_QWORD *)(v784 + 136) = 0;
  *(int32x2_t *)(v784 + 40) = vsub_s32((int32x2_t)0x100000000, vdup_lane_s32(v786, 1));
  FeatureAverager<double>::allocateStorage(v784);
  (*(void (**)(uint64_t, double *))(*(_QWORD *)v784 + 32))(v784, &__B);
  v831[74] = (float32x2_t *)v784;
  if ((a14 & 2) != 0)
  {
    v790 = v831[25];
    v831[26] = v790;
    v791 = *((unsigned int *)v831 + 183);
    if (v791 > v831[27] - v790)
    {
      v792 = (float32x2_t *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v791);
      v795 = v831[25];
      v794 = v831[26];
      v796 = v792;
      if (v794 != v795)
      {
        do
        {
          v797 = v794[-1];
          --v794;
          v796[-1] = v797;
          --v796;
        }
        while (v794 != v795);
        v794 = v831[25];
      }
      v831[25] = v796;
      v831[26] = v792;
      v831[27] = &v792[v793];
      if (v794)
        operator delete(v794);
    }
    if (*((_DWORD *)v831 + 183))
    {
      v798 = 0;
      do
      {
        v799 = operator new();
        v800 = *((_DWORD *)v831 + 181);
        v801 = *((_DWORD *)v831 + 182);
        v802 = *((unsigned int *)v831 + 184);
        *(_QWORD *)v799 = &off_1E69C5760;
        *(_QWORD *)(v799 + 8) = v802;
        *(_DWORD *)(v799 + 16) = v800;
        *(_DWORD *)(v799 + 20) = v801;
        *(_OWORD *)(v799 + 32) = 0u;
        *(_OWORD *)(v799 + 48) = 0u;
        *(_OWORD *)(v799 + 64) = 0u;
        *(_OWORD *)(v799 + 80) = 0u;
        *(_OWORD *)(v799 + 96) = 0u;
        *(_BYTE *)(v799 + 112) = 0;
        *(_QWORD *)(v799 + 116) = 0;
        *(_QWORD *)(v799 + 132) = 0;
        *(_QWORD *)(v799 + 124) = 0;
        *(_DWORD *)(v799 + 140) = 0;
        *(_DWORD *)(v799 + 24) = -(v802 * v801);
        *(_DWORD *)(v799 + 28) = v802 - v802 * v801;
        SlidingWindowDTFT<float>::allocateStorage(v799);
        (*(void (**)(uint64_t))(*(_QWORD *)v799 + 32))(v799);
        v804 = (uint64_t *)v831[26];
        v803 = (unint64_t)v831[27];
        if ((unint64_t)v804 >= v803)
        {
          v806 = v831[25];
          v807 = ((char *)v804 - (char *)v806) >> 3;
          if ((unint64_t)(v807 + 1) >> 61)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          v808 = v803 - (_QWORD)v806;
          v809 = v808 >> 2;
          if (v808 >> 2 <= (unint64_t)(v807 + 1))
            v809 = v807 + 1;
          if ((unint64_t)v808 >= 0x7FFFFFFFFFFFFFF8)
            v810 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v810 = v809;
          if (v810)
            v810 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v810);
          else
            v811 = 0;
          v812 = (uint64_t *)(v810 + 8 * v807);
          *v812 = v799;
          v805 = (float32x2_t *)(v812 + 1);
          v814 = v831[25];
          v813 = v831[26];
          if (v813 == v814)
          {
            v816 = v831;
          }
          else
          {
            do
            {
              v815 = (uint64_t)v813[-1];
              --v813;
              *--v812 = v815;
            }
            while (v813 != v814);
            v816 = v831;
            v813 = v831[25];
          }
          v816[25] = (float32x2_t *)v812;
          v816[26] = v805;
          v816[27] = (float32x2_t *)(v810 + 8 * v811);
          if (v813)
            operator delete(v813);
        }
        else
        {
          *v804 = v799;
          v805 = (float32x2_t *)(v804 + 1);
        }
        v831[26] = v805;
        v817 = v831[2];
        v818 = v817[14];
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&v817[15] - *(_QWORD *)&v818) >> 3) <= v798)
          std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
        v819 = *(_QWORD *)&v818 + 24 * v798;
        __B = 0.0;
        v837 = 0.0;
        v838 = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__B, *(const void **)v819, *(_QWORD *)(v819 + 8), (uint64_t)(*(_QWORD *)(v819 + 8) - *(_QWORD *)v819) >> 2);
        v820 = *(float **)v819;
        if (*(_QWORD *)(v819 + 8) == *(_QWORD *)v819)
          std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
        v821 = v831[25];
        if (v798 >= v831[26] - v821)
          std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
        v822 = (uint64_t)(*(_QWORD *)(v819 + 8) - *(_QWORD *)v819) >> 2;
        v823 = (_QWORD *)v821[v798];
        do
        {
          (*(void (**)(_QWORD *, _QWORD, _QWORD, float))(*v823 + 16))(v823, v823[10], v823[11], *v820++);
          --v822;
        }
        while (v822);
        if (__B != 0.0)
        {
          v837 = __B;
          operator delete(*(void **)&__B);
        }
        ++v798;
      }
      while (v798 < *((unsigned int *)v831 + 183));
    }
  }
}

void sub_1B60FD2C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void **a11, void **a12, uint64_t a13, uint64_t a14, void **a15, _QWORD *a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24)
{
  uint64_t v24;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;

  if (__p)
    operator delete(__p);
  MEMORY[0x1BCC95CEC](v24, 0x1080C400DE93FC6);
  if (a20)
    operator delete(a20);
  if (a23)
    operator delete(a23);
  v26 = *a12;
  if (*a12)
  {
    a16[97] = v26;
    operator delete(v26);
  }
  v27 = *a11;
  if (*a11)
  {
    a16[94] = v27;
    operator delete(v27);
  }
  v28 = (void *)a16[25];
  if (v28)
  {
    a16[26] = v28;
    operator delete(v28);
  }
  v29 = (void *)a16[22];
  if (v29)
  {
    a16[23] = v29;
    operator delete(v29);
  }
  v30 = (void *)a16[19];
  if (v30)
  {
    a16[20] = v30;
    operator delete(v30);
  }
  v31 = *a15;
  if (*a15)
  {
    a16[17] = v31;
    operator delete(v31);
  }
  _Unwind_Resume(a1);
}

void SlidingWindowDTFT<float>::allocateStorage(uint64_t a1)
{
  unint64_t v1;
  void *v3;
  void *v5;
  unint64_t v6;
  void *v7;
  void *v8;
  unint64_t v9;
  void *v10;
  void *v11;
  unint64_t v12;
  void *v13;
  void *v14;
  unint64_t v15;
  void *v16;
  void *v17;
  unint64_t v18;
  void *v19;
  void *v20;
  unint64_t v21;
  void *v22;
  void *v23;
  unint64_t v24;
  void *v25;
  void *v26;
  unint64_t v27;
  void *v28;
  void *v29;
  unint64_t v30;
  void *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  void *v35;
  _QWORD *v36;
  uint64_t v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  void *v41;
  std::bad_alloc *exception;
  std::bad_alloc *v43;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1 >> 62)
    goto LABEL_34;
  v3 = malloc_type_malloc(4 * v1, 0x2C8E6D5CuLL);
  if (v1 && v3 == 0)
    goto LABEL_34;
  v5 = v3;
  bzero(v3, 4 * v1);
  *(_QWORD *)(a1 + 32) = v5;
  v6 = *(_QWORD *)(a1 + 8);
  if (v6 >> 62)
    goto LABEL_34;
  v7 = malloc_type_malloc(4 * v6, 0x2C8E6D5CuLL);
  v8 = v7;
  if (v6)
  {
    if (!v7)
      goto LABEL_34;
  }
  bzero(v7, 4 * v6);
  *(_QWORD *)(a1 + 40) = v8;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9 >> 62)
    goto LABEL_34;
  v10 = malloc_type_malloc(4 * v9, 0x2C8E6D5CuLL);
  v11 = v10;
  if (v9)
  {
    if (!v10)
      goto LABEL_34;
  }
  bzero(v10, 4 * v9);
  *(_QWORD *)(a1 + 48) = v11;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12 >> 62)
    goto LABEL_34;
  v13 = malloc_type_malloc(4 * v12, 0x2C8E6D5CuLL);
  v14 = v13;
  if (v12)
  {
    if (!v13)
      goto LABEL_34;
  }
  bzero(v13, 4 * v12);
  *(_QWORD *)(a1 + 56) = v14;
  v15 = *(_QWORD *)(a1 + 8);
  if (v15 >> 62)
    goto LABEL_34;
  v16 = malloc_type_malloc(4 * v15, 0x2C8E6D5CuLL);
  v17 = v16;
  if (v15)
  {
    if (!v16)
      goto LABEL_34;
  }
  bzero(v16, 4 * v15);
  *(_QWORD *)(a1 + 64) = v17;
  v18 = *(_QWORD *)(a1 + 8);
  if (v18 >> 62)
    goto LABEL_34;
  v19 = malloc_type_malloc(4 * v18, 0x2C8E6D5CuLL);
  v20 = v19;
  if (v18)
  {
    if (!v19)
      goto LABEL_34;
  }
  bzero(v19, 4 * v18);
  *(_QWORD *)(a1 + 72) = v20;
  v21 = *(_QWORD *)(a1 + 8);
  if (v21 >> 62)
    goto LABEL_34;
  v22 = malloc_type_malloc(4 * v21, 0x2C8E6D5CuLL);
  v23 = v22;
  if (v21)
  {
    if (!v22)
      goto LABEL_34;
  }
  bzero(v22, 4 * v21);
  *(_QWORD *)(a1 + 80) = v23;
  v24 = *(_QWORD *)(a1 + 8);
  if (v24 >> 62)
    goto LABEL_34;
  v25 = malloc_type_malloc(4 * v24, 0x2C8E6D5CuLL);
  v26 = v25;
  if (v24)
  {
    if (!v25)
      goto LABEL_34;
  }
  bzero(v25, 4 * v24);
  *(_QWORD *)(a1 + 88) = v26;
  v27 = *(_QWORD *)(a1 + 8);
  if (v27 >> 62)
    goto LABEL_34;
  v28 = malloc_type_malloc(4 * v27, 0x2C8E6D5CuLL);
  v29 = v28;
  if (v27)
  {
    if (!v28)
      goto LABEL_34;
  }
  bzero(v28, 4 * v27);
  *(_QWORD *)(a1 + 96) = v29;
  v30 = *(_QWORD *)(a1 + 8);
  if (v30 >> 62 || (v31 = malloc_type_malloc(4 * v30, 0x2C8E6D5CuLL), v32 = v31, v30) && !v31)
  {
LABEL_34:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v43 = std::bad_alloc::bad_alloc(exception);
  }
  bzero(v31, 4 * v30);
  *(_QWORD *)(a1 + 104) = v32;
  v33 = (_QWORD *)operator new();
  v34 = (*(_DWORD *)(a1 + 20) + 1);
  v35 = (void *)operator new[]();
  bzero(v35, 4 * v34);
  *v33 = v35;
  v33[1] = v34;
  bzero(v35, 4 * (int)v34);
  *(_QWORD *)(a1 + 120) = v33;
  v36 = (_QWORD *)operator new();
  v37 = (*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 20) + 1);
  v38 = (void *)operator new[]();
  bzero(v38, 4 * v37);
  *v36 = v38;
  v36[1] = v37;
  bzero(v38, 4 * (int)v37);
  *(_QWORD *)(a1 + 128) = v36;
  v39 = (_QWORD *)operator new();
  v40 = (*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 20) + 1);
  v41 = (void *)operator new[]();
  bzero(v41, 4 * v40);
  *v39 = v41;
  v39[1] = v40;
  bzero(v41, 4 * (int)v40);
  *(_QWORD *)(a1 + 136) = v39;
}

void sub_1B60FD9CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x1080C40FC6463CFLL);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(unint64_t a1)
{
  if (a1 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a1);
}

_QWORD *SlidingWindowDTFT<float>::~SlidingWindowDTFT(_QWORD *a1)
{
  *a1 = &off_1E69C5760;
  SlidingWindowDTFT<float>::deallocateStorage(a1);
  return a1;
}

void SlidingWindowDTFT<float>::~SlidingWindowDTFT(_QWORD *a1)
{
  *a1 = &off_1E69C5760;
  SlidingWindowDTFT<float>::deallocateStorage(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void *SlidingWindowDTFT<float>::Update(uint64_t a1, void *a2, void *a3, float a4)
{
  unsigned int v8;
  float *v9;
  const float *v10;
  float *v11;
  float v12;
  int v13;
  uint64_t v14;
  int v15;
  char v16;
  float v17;
  float *v18;
  float *v19;
  const float *v20;
  const float *v21;
  const float *v22;
  const float *v23;
  vDSP_Length v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  char *v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  void *result;
  float __B;

  v8 = *(_DWORD *)(a1 + 116) + 1;
  *(_DWORD *)(a1 + 116) = v8;
  if (v8 >= 2)
  {
    vDSP_vadd(*(const float **)(a1 + 40), 1, *(const float **)(a1 + 32), 1, *(float **)(a1 + 40), 1, *(_QWORD *)(a1 + 8));
    v10 = *(const float **)(a1 + 40);
    v9 = *(float **)(a1 + 48);
    v11 = *(float **)(a1 + 56);
    __B = *(float *)(a1 + 8);
    v12 = __B;
    vvcosf(v9, v10, (const int *)&__B);
    __B = v12;
    vvsinf(v11, v10, (const int *)&__B);
    v8 = *(_DWORD *)(a1 + 116);
  }
  if (v8 <= *(_DWORD *)(a1 + 16))
  {
    v16 = 0;
LABEL_9:
    *(_BYTE *)(a1 + 112) = v16;
    v17 = 0.0;
    goto LABEL_12;
  }
  v13 = *(_DWORD *)(a1 + 20);
  if (v8 <= v13)
  {
    v16 = 1;
    goto LABEL_9;
  }
  *(_BYTE *)(a1 + 112) = 2;
  v14 = *(_QWORD *)(a1 + 120);
  if (v13 < 1)
    v15 = (*(_DWORD *)(v14 + 12) - v13) % *(_DWORD *)(v14 + 8);
  else
    v15 = *(_DWORD *)(v14 + 8) + ~((*(_DWORD *)(v14 + 8) + v13 + ~*(_DWORD *)(v14 + 12)) % *(_DWORD *)(v14 + 8));
  v17 = *(float *)(*(_QWORD *)v14 + 4 * v15);
  MRRingBuffer<float>::GetSampleRange(*(uint64_t **)(a1 + 128), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 28), *(float **)(a1 + 64));
  MRRingBuffer<float>::GetSampleRange(*(uint64_t **)(a1 + 136), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 28), *(float **)(a1 + 72));
LABEL_12:
  v18 = *(float **)(a1 + 80);
  v19 = *(float **)(a1 + 88);
  v20 = *(const float **)(a1 + 48);
  v21 = *(const float **)(a1 + 56);
  v22 = *(const float **)(a1 + 64);
  v23 = *(const float **)(a1 + 72);
  v24 = *(_QWORD *)(a1 + 8);
  __B = a4;
  vDSP_vsma(v20, 1, &__B, v18, 1, v18, 1, v24);
  __B = -v17;
  vDSP_vsma(v22, 1, &__B, v18, 1, v18, 1, v24);
  __B = -a4;
  vDSP_vsma(v21, 1, &__B, v19, 1, v19, 1, v24);
  __B = v17;
  vDSP_vsma(v23, 1, &__B, v19, 1, v19, 1, v24);
  memcpy(a2, *(const void **)(a1 + 80), 4 * *(_QWORD *)(a1 + 8));
  memcpy(a3, *(const void **)(a1 + 88), 4 * *(_QWORD *)(a1 + 8));
  v25 = *(_QWORD *)(a1 + 120);
  v26 = *(int *)(v25 + 12);
  *(float *)(*(_QWORD *)v25 + 4 * v26) = a4;
  *(_DWORD *)(v25 + 12) = ((int)v26 + 1) % *(_DWORD *)(v25 + 8);
  v27 = *(_QWORD *)(a1 + 128);
  v28 = *(_QWORD *)(a1 + 48);
  v29 = *(_DWORD *)(a1 + 8);
  v30 = *(_DWORD *)(v27 + 8);
  v31 = *(int *)(v27 + 12);
  if (v30 < v29)
    v29 = *(_DWORD *)(v27 + 8);
  v32 = v31 + v29;
  v33 = v31 + v29 - v30;
  if (v33 < 0)
  {
    memcpy((void *)(*(_QWORD *)v27 + 4 * v31), *(const void **)(a1 + 48), 4 * v29);
  }
  else
  {
    v34 = v30 - v31;
    memcpy((void *)(*(_QWORD *)v27 + 4 * v31), *(const void **)(a1 + 48), 4 * (v30 - (int)v31));
    memcpy(*(void **)v27, (const void *)(v28 + 4 * v34), 4 * v33);
    v32 = v33;
  }
  *(_DWORD *)(v27 + 12) = v32;
  v35 = *(_QWORD *)(a1 + 136);
  v36 = *(char **)(a1 + 56);
  v37 = *(_DWORD *)(a1 + 8);
  v38 = *(_DWORD *)(v35 + 8);
  v39 = *(int *)(v35 + 12);
  if (v38 < v37)
    v37 = *(_DWORD *)(v35 + 8);
  v40 = v39 + v37;
  v41 = v39 + v37 - v38;
  if (v41 < 0)
  {
    result = memcpy((void *)(*(_QWORD *)v35 + 4 * v39), v36, 4 * v37);
  }
  else
  {
    v42 = v38 - v39;
    memcpy((void *)(*(_QWORD *)v35 + 4 * v39), v36, 4 * (v38 - (int)v39));
    result = memcpy(*(void **)v35, &v36[4 * v42], 4 * v41);
    v40 = v41;
  }
  *(_DWORD *)(v35 + 12) = v40;
  return result;
}

_QWORD *SlidingWindowDTFT<float>::initializeTables(_QWORD *result)
{
  uint64_t v1;
  float *v2;
  uint64_t v3;
  float v4;
  _DWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  _DWORD *v9;

  v1 = result[1];
  v2 = (float *)result[4];
  if (v1 == 1)
  {
    *v2 = 1.5708;
  }
  else
  {
    if (!v1)
      return result;
    v3 = 4 * v1;
    v4 = 0.0;
    do
    {
      *v2++ = v4;
      v4 = (float)(3.1416 / (float)(unint64_t)(v1 - 1)) + v4;
      v3 -= 4;
    }
    while (v3);
  }
  v6 = (_DWORD *)result[8];
  v5 = (_DWORD *)result[9];
  v8 = (_DWORD *)result[6];
  v7 = (_DWORD *)result[7];
  v9 = (_DWORD *)result[5];
  do
  {
    *v9++ = 0;
    *v8++ = 1065353216;
    *v7++ = 0;
    *v6++ = 1065353216;
    *v5++ = 0;
    --v1;
  }
  while (v1);
  return result;
}

float MRRingBuffer<float>::GetSampleRange(uint64_t *a1, int a2, int a3, float *a4)
{
  uint64_t v4;
  int v5;
  float result;

  if (a2 < a3)
  {
    v4 = *a1;
    do
    {
      if (a2 < 0)
        v5 = *((_DWORD *)a1 + 2) + ~((*((_DWORD *)a1 + 2) - a2 + ~*((_DWORD *)a1 + 3)) % *((_DWORD *)a1 + 2));
      else
        v5 = (*((_DWORD *)a1 + 3) + a2) % *((_DWORD *)a1 + 2);
      result = *(float *)(v4 + 4 * v5);
      *a4++ = result;
      ++a2;
    }
    while (a2 != a3);
  }
  return result;
}

uint64_t SlidingWindowDTFT<float>::deallocateStorage(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;

  v2 = (_QWORD *)a1[17];
  if (v2)
  {
    if (*v2)
      MEMORY[0x1BCC95CC8](*v2, 0x1000C8052888210);
    MEMORY[0x1BCC95CEC](v2, 0x1080C40FC6463CFLL);
  }
  v3 = (_QWORD *)a1[16];
  if (v3)
  {
    if (*v3)
      MEMORY[0x1BCC95CC8](*v3, 0x1000C8052888210);
    MEMORY[0x1BCC95CEC](v3, 0x1080C40FC6463CFLL);
  }
  v4 = (_QWORD *)a1[15];
  if (v4)
  {
    if (*v4)
      MEMORY[0x1BCC95CC8](*v4, 0x1000C8052888210);
    MEMORY[0x1BCC95CEC](v4, 0x1080C40FC6463CFLL);
  }
  v5 = a1[13];
  if (v5)
    MEMORY[0x1BCC95CEC](v5, 0x1000C4052888210);
  v6 = a1[12];
  if (v6)
    MEMORY[0x1BCC95CEC](v6, 0x1000C4052888210);
  v7 = a1[11];
  if (v7)
    MEMORY[0x1BCC95CEC](v7, 0x1000C4052888210);
  v8 = a1[10];
  if (v8)
    MEMORY[0x1BCC95CEC](v8, 0x1000C4052888210);
  v9 = a1[9];
  if (v9)
    MEMORY[0x1BCC95CEC](v9, 0x1000C4052888210);
  v10 = a1[8];
  if (v10)
    MEMORY[0x1BCC95CEC](v10, 0x1000C4052888210);
  v11 = a1[7];
  if (v11)
    MEMORY[0x1BCC95CEC](v11, 0x1000C4052888210);
  v12 = a1[6];
  if (v12)
    MEMORY[0x1BCC95CEC](v12, 0x1000C4052888210);
  v13 = a1[5];
  if (v13)
    MEMORY[0x1BCC95CEC](v13, 0x1000C4052888210);
  result = a1[4];
  if (result)
    JUMPOUT(0x1BCC95CECLL);
  return result;
}

void FeatureAverager<float>::allocateStorage(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  BOOL v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  _QWORD *v30;
  uint64_t v31;
  void *v32;
  std::bad_alloc *exception;
  std::bad_alloc *v34;

  v2 = *(unsigned int *)(a1 + 8);
  v3 = malloc_type_malloc(4 * v2, 0x2C8E6D5CuLL);
  if ((_DWORD)v2)
    v4 = v3 == 0;
  else
    v4 = 0;
  if (v4)
    goto LABEL_22;
  v5 = v3;
  bzero(v3, 4 * v2);
  *(_QWORD *)(a1 + 40) = v5;
  v6 = *(unsigned int *)(a1 + 8);
  v7 = malloc_type_malloc(4 * v6, 0x2C8E6D5CuLL);
  v8 = v7;
  if ((_DWORD)v6)
  {
    if (!v7)
      goto LABEL_22;
  }
  bzero(v7, 4 * v6);
  *(_QWORD *)(a1 + 48) = v8;
  v9 = *(unsigned int *)(a1 + 8);
  v10 = malloc_type_malloc(4 * v9, 0x2C8E6D5CuLL);
  v11 = v10;
  if ((_DWORD)v9)
  {
    if (!v10)
      goto LABEL_22;
  }
  bzero(v10, 4 * v9);
  *(_QWORD *)(a1 + 56) = v11;
  v12 = *(unsigned int *)(a1 + 8);
  v13 = malloc_type_malloc(4 * v12, 0x2C8E6D5CuLL);
  v14 = v13;
  if ((_DWORD)v12)
  {
    if (!v13)
      goto LABEL_22;
  }
  bzero(v13, 4 * v12);
  *(_QWORD *)(a1 + 64) = v14;
  v15 = *(unsigned int *)(a1 + 8);
  v16 = malloc_type_malloc(4 * v15, 0x2C8E6D5CuLL);
  v17 = v16;
  if ((_DWORD)v15)
  {
    if (!v16)
      goto LABEL_22;
  }
  bzero(v16, 4 * v15);
  *(_QWORD *)(a1 + 72) = v17;
  v18 = *(unsigned int *)(a1 + 8);
  v19 = malloc_type_malloc(4 * v18, 0x2C8E6D5CuLL);
  v20 = v19;
  if ((_DWORD)v18)
  {
    if (!v19)
      goto LABEL_22;
  }
  bzero(v19, 4 * v18);
  *(_QWORD *)(a1 + 80) = v20;
  v21 = *(unsigned int *)(a1 + 8);
  v22 = malloc_type_malloc(4 * v21, 0x2C8E6D5CuLL);
  v23 = v22;
  if ((_DWORD)v21)
  {
    if (!v22)
      goto LABEL_22;
  }
  bzero(v22, 4 * v21);
  *(_QWORD *)(a1 + 88) = v23;
  v24 = *(unsigned int *)(a1 + 8);
  v25 = malloc_type_malloc(4 * v24, 0x2C8E6D5CuLL);
  v26 = v25;
  if ((_DWORD)v24)
  {
    if (!v25)
      goto LABEL_22;
  }
  bzero(v25, 4 * v24);
  *(_QWORD *)(a1 + 96) = v26;
  v27 = *(unsigned int *)(a1 + 8);
  v28 = malloc_type_malloc(4 * v27, 0x2C8E6D5CuLL);
  v29 = v28;
  if ((_DWORD)v27)
  {
    if (!v28)
    {
LABEL_22:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v34 = std::bad_alloc::bad_alloc(exception);
    }
  }
  bzero(v28, 4 * v27);
  *(_QWORD *)(a1 + 104) = v29;
  v30 = (_QWORD *)operator new();
  v31 = (*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 16) + 1);
  v32 = (void *)operator new[]();
  bzero(v32, 4 * v31);
  *v30 = v32;
  v30[1] = v31;
  bzero(v32, 4 * (int)v31);
  *(_QWORD *)(a1 + 128) = v30;
}

void sub_1B60FE334(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x1080C40FC6463CFLL);
  _Unwind_Resume(a1);
}

_QWORD *FeatureAverager<float>::~FeatureAverager(_QWORD *a1)
{
  *a1 = &off_1E69C56E0;
  FeatureAverager<float>::deallocateStorage(a1);
  return a1;
}

void FeatureAverager<float>::~FeatureAverager(_QWORD *a1)
{
  *a1 = &off_1E69C56E0;
  FeatureAverager<float>::deallocateStorage(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void FeatureAverager<float>::Update(uint64_t a1, const float *__A, void *__dst, void *a4)
{
  unsigned int v8;
  int v9;
  float *v10;
  float v11;
  float *v12;
  vDSP_Length v13;
  float *v14;
  float *v15;
  float v16;
  vDSP_Length v17;
  float v18;
  float *v19;
  int v20;
  const float *v21;
  const float *v22;
  float *v23;
  vDSP_Length v24;
  vDSP_Length v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  float __B;

  v8 = *(_DWORD *)(a1 + 116) + 1;
  *(_DWORD *)(a1 + 116) = v8;
  if (v8 <= *(_DWORD *)(a1 + 12))
  {
    *(_BYTE *)(a1 + 112) = 0;
    v14 = *(float **)(a1 + 40);
    v15 = *(float **)(a1 + 104);
    v16 = *(float *)(a1 + 20);
    v17 = *(unsigned int *)(a1 + 8);
    vDSP_vsub(*(const float **)(a1 + 56), 1, __A, 1, v15, 1, v17);
    __B = v16;
    vDSP_vsma(v15, 1, &__B, v14, 1, v14, 1, v17);
    v11 = 0.0;
  }
  else
  {
    if (v8 <= *(_DWORD *)(a1 + 16))
      v9 = 1;
    else
      v9 = 2;
    *(_BYTE *)(a1 + 112) = v9;
    v10 = *(float **)(a1 + 40);
    v11 = 0.0;
    if (v9 == 2)
    {
      MRRingBuffer<float>::GetSampleRange(*(uint64_t **)(a1 + 128), *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 32), *(float **)(a1 + 72));
      v12 = *(float **)(a1 + 104);
      v18 = *(float *)(a1 + 24);
      v13 = *(unsigned int *)(a1 + 8);
      vDSP_vsub(*(const float **)(a1 + 72), 1, __A, 1, v12, 1, v13);
      __B = v18;
    }
    else
    {
      v11 = 1.0 / (float)v8;
      v12 = *(float **)(a1 + 104);
      v13 = *(unsigned int *)(a1 + 8);
      vDSP_vsub(*(const float **)(a1 + 40), 1, __A, 1, v12, 1, v13);
      __B = v11;
    }
    vDSP_vsma(v12, 1, &__B, v10, 1, v10, 1, v13);
  }
  memcpy(__dst, *(const void **)(a1 + 40), 4 * *(unsigned int *)(a1 + 8));
  if ((*(_BYTE *)(a1 + 120) & 2) != 0)
  {
    vDSP_vmul(__A, 1, __A, 1, *(float **)(a1 + 88), 1, *(unsigned int *)(a1 + 8));
    v19 = *(float **)(a1 + 48);
    v20 = *(unsigned __int8 *)(a1 + 112);
    if (v20 == 2)
    {
      vDSP_vmul(*(const float **)(a1 + 72), 1, *(const float **)(a1 + 72), 1, *(float **)(a1 + 80), 1, *(unsigned int *)(a1 + 8));
      v21 = *(const float **)(a1 + 80);
      v22 = *(const float **)(a1 + 88);
      v23 = *(float **)(a1 + 104);
      v11 = *(float *)(a1 + 24);
    }
    else
    {
      if (v20 == 1)
      {
        v22 = *(const float **)(a1 + 88);
        v23 = *(float **)(a1 + 104);
        v24 = *(unsigned int *)(a1 + 8);
        v21 = *(const float **)(a1 + 48);
        goto LABEL_18;
      }
      if (*(_BYTE *)(a1 + 112))
      {
LABEL_19:
        memcpy(a4, *(const void **)(a1 + 48), 4 * *(unsigned int *)(a1 + 8));
        vDSP_vmul(*(const float **)(a1 + 40), 1, *(const float **)(a1 + 40), 1, *(float **)(a1 + 96), 1, *(unsigned int *)(a1 + 8));
        vDSP_vsub(*(const float **)(a1 + 96), 1, (const float *)a4, 1, (float *)a4, 1, *(unsigned int *)(a1 + 8));
        v25 = *(unsigned int *)(a1 + 8);
        __B = 0.0;
        vDSP_vthres((const float *)a4, 1, &__B, (float *)a4, 1, v25);
        goto LABEL_20;
      }
      v21 = *(const float **)(a1 + 64);
      v22 = *(const float **)(a1 + 88);
      v23 = *(float **)(a1 + 104);
      v11 = *(float *)(a1 + 20);
    }
    v24 = *(unsigned int *)(a1 + 8);
LABEL_18:
    vDSP_vsub(v21, 1, v22, 1, v23, 1, v24);
    __B = v11;
    vDSP_vsma(v23, 1, &__B, v19, 1, v19, 1, v24);
    goto LABEL_19;
  }
LABEL_20:
  v26 = *(_DWORD *)(a1 + 8);
  v27 = *(_QWORD *)(a1 + 128);
  if (v26 == 1)
  {
    v28 = *(int *)(v27 + 12);
    *(float *)(*(_QWORD *)v27 + 4 * v28) = *__A;
    *(_DWORD *)(v27 + 12) = ((int)v28 + 1) % *(_DWORD *)(v27 + 8);
  }
  else
  {
    v29 = *(_DWORD *)(v27 + 8);
    v30 = *(int *)(v27 + 12);
    if (v29 < v26)
      v26 = *(_DWORD *)(v27 + 8);
    v31 = v30 + v26;
    v32 = v30 + v26 - v29;
    if (v32 < 0)
    {
      memcpy((void *)(*(_QWORD *)v27 + 4 * v30), __A, 4 * v26);
    }
    else
    {
      v33 = v29 - v30;
      memcpy((void *)(*(_QWORD *)v27 + 4 * v30), __A, 4 * (v29 - (int)v30));
      memcpy(*(void **)v27, &__A[v33], 4 * v32);
      v31 = v32;
    }
    *(_DWORD *)(v27 + 12) = v31;
  }
}

void FeatureAverager<float>::initializeTables(uint64_t a1, const void *a2)
{
  uint64_t v3;
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  float v9;
  uint64_t v10;
  float *v11;
  float v12;
  void *v13;

  memcpy(*(void **)(a1 + 56), a2, 4 * *(unsigned int *)(a1 + 8));
  memcpy(*(void **)(a1 + 40), *(const void **)(a1 + 56), 4 * *(unsigned int *)(a1 + 8));
  vDSP_vmul(*(const float **)(a1 + 56), 1, *(const float **)(a1 + 56), 1, *(float **)(a1 + 64), 1, *(unsigned int *)(a1 + 8));
  v3 = *(unsigned int *)(a1 + 8);
  v4 = 4 * v3;
  if ((_DWORD)v3)
  {
    v5 = 0;
    v6 = 0;
    v7 = *(_QWORD *)(a1 + 56);
    do
    {
      v8 = *(float *)(v7 + v5);
      if (v8 <= 1.0)
      {
        v11 = (float *)(*(_QWORD *)(a1 + 64) + v5);
        v9 = *v11;
        v12 = 1.01;
      }
      else
      {
        v9 = (float)(0.01 / v8) + 1.0;
        v10 = *(_QWORD *)(a1 + 64);
        v11 = (float *)(v10 + 4 * v6);
        v12 = *(float *)(v10 + v5);
      }
      *v11 = v9 * v12;
      ++v6;
      v5 += 4;
    }
    while (v4 != v5);
  }
  v13 = *(void **)(a1 + 48);
  if ((*(_BYTE *)(a1 + 120) & 2) != 0)
    memcpy(v13, *(const void **)(a1 + 64), v4);
  else
    bzero(v13, v4);
}

void FeatureAverager<float>::deallocateStorage(_QWORD *a1)
{
  _QWORD *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  v2 = (_QWORD *)a1[16];
  if (v2)
  {
    if (*v2)
      MEMORY[0x1BCC95CC8](*v2, 0x1000C8052888210);
    MEMORY[0x1BCC95CEC](v2, 0x1080C40FC6463CFLL);
  }
  v3 = (void *)a1[13];
  if (v3)
    free(v3);
  v4 = (void *)a1[12];
  if (v4)
    free(v4);
  v5 = (void *)a1[11];
  if (v5)
    free(v5);
  v6 = (void *)a1[10];
  if (v6)
    free(v6);
  v7 = (void *)a1[9];
  if (v7)
    free(v7);
  v8 = (void *)a1[8];
  if (v8)
    free(v8);
  v9 = (void *)a1[7];
  if (v9)
    free(v9);
  v10 = (void *)a1[6];
  if (v10)
    free(v10);
  v11 = (void *)a1[5];
  if (v11)
    free(v11);
}

void FeatureAverager<double>::allocateStorage(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  BOOL v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  _QWORD *v30;
  uint64_t v31;
  void *v32;
  std::bad_alloc *exception;
  std::bad_alloc *v34;

  v2 = *(unsigned int *)(a1 + 8);
  v3 = malloc_type_malloc(8 * v2, 0x2C8E6D5CuLL);
  if ((_DWORD)v2)
    v4 = v3 == 0;
  else
    v4 = 0;
  if (v4)
    goto LABEL_22;
  v5 = v3;
  bzero(v3, 8 * v2);
  *(_QWORD *)(a1 + 48) = v5;
  v6 = *(unsigned int *)(a1 + 8);
  v7 = malloc_type_malloc(8 * v6, 0x2C8E6D5CuLL);
  v8 = v7;
  if ((_DWORD)v6)
  {
    if (!v7)
      goto LABEL_22;
  }
  bzero(v7, 8 * v6);
  *(_QWORD *)(a1 + 56) = v8;
  v9 = *(unsigned int *)(a1 + 8);
  v10 = malloc_type_malloc(8 * v9, 0x2C8E6D5CuLL);
  v11 = v10;
  if ((_DWORD)v9)
  {
    if (!v10)
      goto LABEL_22;
  }
  bzero(v10, 8 * v9);
  *(_QWORD *)(a1 + 64) = v11;
  v12 = *(unsigned int *)(a1 + 8);
  v13 = malloc_type_malloc(8 * v12, 0x2C8E6D5CuLL);
  v14 = v13;
  if ((_DWORD)v12)
  {
    if (!v13)
      goto LABEL_22;
  }
  bzero(v13, 8 * v12);
  *(_QWORD *)(a1 + 72) = v14;
  v15 = *(unsigned int *)(a1 + 8);
  v16 = malloc_type_malloc(8 * v15, 0x2C8E6D5CuLL);
  v17 = v16;
  if ((_DWORD)v15)
  {
    if (!v16)
      goto LABEL_22;
  }
  bzero(v16, 8 * v15);
  *(_QWORD *)(a1 + 80) = v17;
  v18 = *(unsigned int *)(a1 + 8);
  v19 = malloc_type_malloc(8 * v18, 0x2C8E6D5CuLL);
  v20 = v19;
  if ((_DWORD)v18)
  {
    if (!v19)
      goto LABEL_22;
  }
  bzero(v19, 8 * v18);
  *(_QWORD *)(a1 + 88) = v20;
  v21 = *(unsigned int *)(a1 + 8);
  v22 = malloc_type_malloc(8 * v21, 0x2C8E6D5CuLL);
  v23 = v22;
  if ((_DWORD)v21)
  {
    if (!v22)
      goto LABEL_22;
  }
  bzero(v22, 8 * v21);
  *(_QWORD *)(a1 + 96) = v23;
  v24 = *(unsigned int *)(a1 + 8);
  v25 = malloc_type_malloc(8 * v24, 0x2C8E6D5CuLL);
  v26 = v25;
  if ((_DWORD)v24)
  {
    if (!v25)
      goto LABEL_22;
  }
  bzero(v25, 8 * v24);
  *(_QWORD *)(a1 + 104) = v26;
  v27 = *(unsigned int *)(a1 + 8);
  v28 = malloc_type_malloc(8 * v27, 0x2C8E6D5CuLL);
  v29 = v28;
  if ((_DWORD)v27)
  {
    if (!v28)
    {
LABEL_22:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v34 = std::bad_alloc::bad_alloc(exception);
    }
  }
  bzero(v28, 8 * v27);
  *(_QWORD *)(a1 + 112) = v29;
  v30 = (_QWORD *)operator new();
  v31 = (*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 16) + 1);
  v32 = (void *)operator new[]();
  bzero(v32, 8 * v31);
  *v30 = v32;
  v30[1] = v31;
  bzero(v32, 8 * (int)v31);
  *(_QWORD *)(a1 + 136) = v30;
}

void sub_1B60FEBA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x1080C40FC6463CFLL);
  _Unwind_Resume(a1);
}

_QWORD *FeatureAverager<double>::~FeatureAverager(_QWORD *a1)
{
  *a1 = &off_1E69C5720;
  FeatureAverager<double>::deallocateStorage(a1);
  return a1;
}

void FeatureAverager<double>::~FeatureAverager(_QWORD *a1)
{
  *a1 = &off_1E69C5720;
  FeatureAverager<double>::deallocateStorage(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void FeatureAverager<double>::Update(uint64_t a1, const double *__A, void *__dst, void *a4)
{
  unsigned int v8;
  int v9;
  double *v10;
  double v11;
  double *v12;
  vDSP_Length v13;
  double *v14;
  double *v15;
  double v16;
  vDSP_Length v17;
  int v18;
  int v19;
  const double *v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;
  int v24;
  _QWORD *v25;
  int v26;
  double v27;
  double *v28;
  int v29;
  const double *v30;
  const double *v31;
  double *v32;
  vDSP_Length v33;
  vDSP_Length v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  double __B;

  v8 = *(_DWORD *)(a1 + 124) + 1;
  *(_DWORD *)(a1 + 124) = v8;
  if (v8 <= *(_DWORD *)(a1 + 12))
  {
    *(_BYTE *)(a1 + 120) = 0;
    v14 = *(double **)(a1 + 48);
    v15 = *(double **)(a1 + 112);
    v16 = *(double *)(a1 + 24);
    v17 = *(unsigned int *)(a1 + 8);
    vDSP_vsubD(*(const double **)(a1 + 64), 1, __A, 1, v15, 1, v17);
    __B = v16;
    vDSP_vsmaD(v15, 1, &__B, v14, 1, v14, 1, v17);
    v11 = 0.0;
  }
  else
  {
    if (v8 <= *(_DWORD *)(a1 + 16))
      v9 = 1;
    else
      v9 = 2;
    *(_BYTE *)(a1 + 120) = v9;
    v10 = *(double **)(a1 + 48);
    v11 = 0.0;
    if (v9 == 2)
    {
      v18 = *(_DWORD *)(a1 + 40);
      v19 = *(_DWORD *)(a1 + 44);
      v20 = *(const double **)(a1 + 80);
      if (v18 < v19)
      {
        v21 = *(uint64_t **)(a1 + 136);
        v22 = *v21;
        v23 = -v18;
        v24 = -v19;
        v25 = *(_QWORD **)(a1 + 80);
        do
        {
          if (v18 < 0)
            v26 = *((_DWORD *)v21 + 2)
                + ~((v23 + *((_DWORD *)v21 + 2) - *((_DWORD *)v21 + 3) - 1) % *((_DWORD *)v21 + 2));
          else
            v26 = (v18 + *((_DWORD *)v21 + 3)) % *((_DWORD *)v21 + 2);
          *v25++ = *(_QWORD *)(v22 + 8 * v26);
          ++v18;
          --v23;
        }
        while (v24 != v23);
      }
      v12 = *(double **)(a1 + 112);
      v27 = *(double *)(a1 + 32);
      v13 = *(unsigned int *)(a1 + 8);
      vDSP_vsubD(v20, 1, __A, 1, v12, 1, v13);
      __B = v27;
    }
    else
    {
      v11 = 1.0 / (double)v8;
      v12 = *(double **)(a1 + 112);
      v13 = *(unsigned int *)(a1 + 8);
      vDSP_vsubD(*(const double **)(a1 + 48), 1, __A, 1, v12, 1, v13);
      __B = v11;
    }
    vDSP_vsmaD(v12, 1, &__B, v10, 1, v10, 1, v13);
  }
  memcpy(__dst, *(const void **)(a1 + 48), 8 * *(unsigned int *)(a1 + 8));
  if ((*(_BYTE *)(a1 + 128) & 2) != 0)
  {
    vDSP_vmulD(__A, 1, __A, 1, *(double **)(a1 + 96), 1, *(unsigned int *)(a1 + 8));
    v28 = *(double **)(a1 + 56);
    v29 = *(unsigned __int8 *)(a1 + 120);
    if (v29 == 2)
    {
      vDSP_vmulD(*(const double **)(a1 + 80), 1, *(const double **)(a1 + 80), 1, *(double **)(a1 + 88), 1, *(unsigned int *)(a1 + 8));
      v30 = *(const double **)(a1 + 88);
      v31 = *(const double **)(a1 + 96);
      v32 = *(double **)(a1 + 112);
      v11 = *(double *)(a1 + 32);
    }
    else
    {
      if (v29 == 1)
      {
        v31 = *(const double **)(a1 + 96);
        v32 = *(double **)(a1 + 112);
        v33 = *(unsigned int *)(a1 + 8);
        v30 = *(const double **)(a1 + 56);
        goto LABEL_24;
      }
      if (*(_BYTE *)(a1 + 120))
      {
LABEL_25:
        memcpy(a4, *(const void **)(a1 + 56), 8 * *(unsigned int *)(a1 + 8));
        vDSP_vmulD(*(const double **)(a1 + 48), 1, *(const double **)(a1 + 48), 1, *(double **)(a1 + 104), 1, *(unsigned int *)(a1 + 8));
        vDSP_vsubD(*(const double **)(a1 + 104), 1, (const double *)a4, 1, (double *)a4, 1, *(unsigned int *)(a1 + 8));
        v34 = *(unsigned int *)(a1 + 8);
        __B = 0.0;
        vDSP_vthresD((const double *)a4, 1, &__B, (double *)a4, 1, v34);
        goto LABEL_26;
      }
      v30 = *(const double **)(a1 + 72);
      v31 = *(const double **)(a1 + 96);
      v32 = *(double **)(a1 + 112);
      v11 = *(double *)(a1 + 24);
    }
    v33 = *(unsigned int *)(a1 + 8);
LABEL_24:
    vDSP_vsubD(v30, 1, v31, 1, v32, 1, v33);
    __B = v11;
    vDSP_vsmaD(v32, 1, &__B, v28, 1, v28, 1, v33);
    goto LABEL_25;
  }
LABEL_26:
  v35 = *(_DWORD *)(a1 + 8);
  v36 = *(_QWORD *)(a1 + 136);
  if (v35 == 1)
  {
    v37 = *(int *)(v36 + 12);
    *(double *)(*(_QWORD *)v36 + 8 * v37) = *__A;
    *(_DWORD *)(v36 + 12) = ((int)v37 + 1) % *(_DWORD *)(v36 + 8);
  }
  else
  {
    v38 = *(_DWORD *)(v36 + 8);
    v39 = *(int *)(v36 + 12);
    if (v38 < v35)
      v35 = *(_DWORD *)(v36 + 8);
    v40 = v39 + v35;
    v41 = v39 + v35 - v38;
    if (v41 < 0)
    {
      memcpy((void *)(*(_QWORD *)v36 + 8 * v39), __A, 8 * v35);
    }
    else
    {
      v42 = v38 - v39;
      memcpy((void *)(*(_QWORD *)v36 + 8 * v39), __A, 8 * (v38 - (int)v39));
      memcpy(*(void **)v36, &__A[v42], 8 * v41);
      v40 = v41;
    }
    *(_DWORD *)(v36 + 12) = v40;
  }
}

void FeatureAverager<double>::initializeTables(uint64_t a1, const void *a2)
{
  uint64_t v3;
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  double v9;
  uint64_t v10;
  double *v11;
  double v12;
  void *v13;

  memcpy(*(void **)(a1 + 64), a2, 8 * *(unsigned int *)(a1 + 8));
  memcpy(*(void **)(a1 + 48), *(const void **)(a1 + 64), 8 * *(unsigned int *)(a1 + 8));
  vDSP_vmulD(*(const double **)(a1 + 64), 1, *(const double **)(a1 + 64), 1, *(double **)(a1 + 72), 1, *(unsigned int *)(a1 + 8));
  v3 = *(unsigned int *)(a1 + 8);
  v4 = 8 * v3;
  if ((_DWORD)v3)
  {
    v5 = 0;
    v6 = 0;
    v7 = *(_QWORD *)(a1 + 64);
    do
    {
      v8 = *(double *)(v7 + v5);
      if (v8 <= 1.0)
      {
        v11 = (double *)(*(_QWORD *)(a1 + 72) + v5);
        v9 = *v11;
        v12 = 1.01;
      }
      else
      {
        v9 = 0.01 / v8 + 1.0;
        v10 = *(_QWORD *)(a1 + 72);
        v11 = (double *)(v10 + 8 * v6);
        v12 = *(double *)(v10 + v5);
      }
      *v11 = v9 * v12;
      ++v6;
      v5 += 8;
    }
    while (v4 != v5);
  }
  v13 = *(void **)(a1 + 56);
  if ((*(_BYTE *)(a1 + 128) & 2) != 0)
    memcpy(v13, *(const void **)(a1 + 72), v4);
  else
    bzero(v13, v4);
}

void FeatureAverager<double>::deallocateStorage(_QWORD *a1)
{
  _QWORD *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  v2 = (_QWORD *)a1[17];
  if (v2)
  {
    if (*v2)
      MEMORY[0x1BCC95CC8](*v2, 0x1000C8000313F17);
    MEMORY[0x1BCC95CEC](v2, 0x1080C40FC6463CFLL);
  }
  v3 = (void *)a1[14];
  if (v3)
    free(v3);
  v4 = (void *)a1[13];
  if (v4)
    free(v4);
  v5 = (void *)a1[12];
  if (v5)
    free(v5);
  v6 = (void *)a1[11];
  if (v6)
    free(v6);
  v7 = (void *)a1[10];
  if (v7)
    free(v7);
  v8 = (void *)a1[9];
  if (v8)
    free(v8);
  v9 = (void *)a1[8];
  if (v9)
    free(v9);
  v10 = (void *)a1[7];
  if (v10)
    free(v10);
  v11 = (void *)a1[6];
  if (v11)
    free(v11);
}

float ASAFeatures::computeCepstralSpeechWindow(ASAFeatures *this, float a2, float a3, float *a4, float *a5)
{
  vDSP_Length v6;
  float result;
  float v8;
  float __B;
  float v10;
  float v11;

  v10 = a3;
  v11 = a2;
  __B = -a3;
  v6 = a5;
  vDSP_vsadd((const float *)this, 1, &__B, a4, 1, a5);
  vDSP_vsmul(a4, 1, &v11, a4, 1, v6);
  vDSP_vsadd(a4, 1, &v10, a4, 1, v6);
  v8 = 0.0;
  vDSP_sve(a4, 1, &v8, v6);
  v8 = 1.0 / v8;
  vDSP_vsmul(a4, 1, &v8, a4, 1, v6);
  return result;
}

_QWORD *std::vector<float *>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::tuple<unsigned int,float>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B60FF310(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float ASAFeatures::ChromaHiFreq(uint64_t a1, uint64_t a2)
{
  vDSP_Length v3;
  float *v4;
  double v5;
  double v6;
  int v7;
  uint64_t v8;
  unsigned int *v9;
  float v10;
  float *v11;
  int v12;
  float v13;
  int v14;
  unsigned int v15;
  float v16;
  const float *v17;
  float *v18;
  const float *v19;
  float *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  float v24;
  vDSP_Length __P;
  unsigned int v26;
  float *v27;
  float *v28;
  float v29;
  uint64_t v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v36;
  int v37;
  float __B;

  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 8);
  v4 = *(float **)(a1 + 224);
  v5 = 0.0;
  v6 = 0.0;
  if ((_DWORD)v3)
  {
    v7 = 0;
    v8 = *(_QWORD *)(a2 + 24);
    v9 = *(unsigned int **)(a1 + 616);
    v10 = 0.0;
    v11 = v4;
    v12 = *(_DWORD *)(a1 + 720);
    do
    {
      *v11 = 0.0;
      v13 = 0.0;
      if (v12)
      {
        v14 = v12;
        do
        {
          v15 = *v9++;
          v13 = *(float *)(v8 + 4 * v15) + v13;
          *v11 = v13;
          --v14;
        }
        while (v14);
      }
      v10 = v10 + (float)(v13 * v13);
      ++v11;
      ++v7;
    }
    while (v7 != (_DWORD)v3);
    v6 = v10;
  }
  v16 = 1.0 / sqrt(v6);
  __B = v16;
  vDSP_vsmul(v4, 1, &__B, v4, 1, v3);
  v17 = *(const float **)(a1 + 608);
  v19 = *(const float **)(a1 + 224);
  v18 = *(float **)(a1 + 232);
  v20 = *(float **)(a1 + 240);
  v21 = *(_QWORD *)(a1 + 8);
  v23 = *(_DWORD *)(v21 + 16);
  v22 = *(unsigned int *)(v21 + 20);
  v24 = *(float *)(v21 + 28);
  __P = *(unsigned int *)(v21 + 8);
  vDSP_mmul(*(const float **)(a1 + 600), 1, v19, 1, v18, 1, __P, 1uLL, __P);
  vDSP_mmul(v17, 1, v19, 1, v20, 1, __P, 1uLL, __P);
  v26 = v23 - 1;
  if (v23 - 1 != (_DWORD)v22)
  {
    v27 = &v20[v26];
    v28 = &v18[v26];
    v29 = 0.0;
    v30 = 4 * v22 - 4 * v26;
    do
    {
      v31 = *v28++;
      v32 = v31;
      v33 = *v27++;
      v29 = v29 + (float)((float)(v33 * v33) + (float)(v32 * v32));
      v30 -= 4;
    }
    while (v30);
    v5 = v29;
  }
  v34 = sqrt(v5 * v24);
  __B = 1.0 - v34;
  v36 = 0.0;
  v37 = 0;
  (*(void (**)(_QWORD, float *, float *, int *))(***(_QWORD ***)(a1 + 176) + 16))(**(_QWORD **)(a1 + 176), &__B, &v36, &v37);
  return log(v36 / (1.0 - v36));
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(unint64_t a1)
{
  if (a1 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a1);
}

float ASAFeatures::BeatsV2(uint64_t a1, uint64_t a2)
{
  const float *v2;
  vDSP_Length realp_low;
  float *v4;
  float *v5;
  float *v6;
  float *v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  float *v20;
  float *v21;
  float v22;
  int v23;
  int v24;
  uint64_t v25;
  float *v26;
  int v27;
  float v28;
  uint64_t v29;
  float *v30;
  const float *v31;
  uint64_t v32;
  float *v33;
  int v34;
  float *v35;
  const float *v36;
  vDSP_Length v37;
  float *v38;
  float *v39;
  unint64_t v40;
  float v41;
  uint64_t v42;
  float *v43;
  vDSP_Length v44;
  const float *v45;
  const float *v46;
  float *v47;
  vDSP_Length v48;
  int v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  float *v53;
  float *v54;
  float *v55;
  _DWORD *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  float *v63;
  float *v64;
  vDSP_Length v65;
  vDSP_Length v66;
  const float *v67;
  _DWORD *v68;
  _DWORD *v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  float v73;
  float v74;
  uint64_t v75;
  unsigned int v76;
  uint64_t v77;
  float v78;
  float v79;
  unsigned int v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  unsigned int v90;
  unsigned int v91;
  uint64_t v93;
  float v94;
  uint64_t v95;
  float v96;
  float v97;
  int *v98;
  int *v99;
  int v100;
  int v101;
  const float *v102;
  int v103;
  vDSP_Length v104;
  double v105;
  float v106;
  float v107;
  float v108;
  uint64_t v109;
  long double v110;
  uint64_t v111;
  long double v112;
  float *v113;
  float v114;
  float v115;
  float *v117;
  uint64_t v118;
  int v119;
  int v120;
  float *v121;
  _DWORD *v122;
  _DWORD *v123;
  uint64_t v125;
  _QWORD *v126;
  float __C;
  DSPSplitComplex __A;
  float __B[3];

  v2 = *(const float **)(a2 + 32);
  v5 = *(float **)(a1 + 248);
  v4 = *(float **)(a1 + 256);
  v6 = *(float **)(a1 + 264);
  v7 = *(float **)(a1 + 568);
  v8 = *(float **)(a1 + 656);
  v9 = *(unsigned int *)(a1 + 792);
  v10 = *(_QWORD *)(a1 + 392);
  LODWORD(__A.realp) = *(_DWORD *)(*(_QWORD *)a1 + 44);
  realp_low = LODWORD(__A.realp);
  vvlogf(v5, v2, (const int *)&__A);
  v11 = *(_DWORD *)(v10 + 8);
  v12 = *(int *)(v10 + 12);
  if (v11 >= (int)realp_low)
    v13 = realp_low;
  else
    v13 = *(_DWORD *)(v10 + 8);
  v14 = v12 + v13;
  v15 = v12 + v13 - v11;
  if (v15 < 0)
  {
    memcpy((void *)(*(_QWORD *)v10 + 4 * v12), v5, 4 * v13);
  }
  else
  {
    v16 = v11 - v12;
    memcpy((void *)(*(_QWORD *)v10 + 4 * v12), v5, 4 * (v11 - (int)v12));
    memcpy(*(void **)v10, &v5[v16], 4 * v15);
    v14 = v15;
  }
  *(_DWORD *)(v10 + 12) = v14;
  v17 = a1;
  if ((_DWORD)realp_low)
  {
    v18 = ~v14 + realp_low;
    v19 = -(int)realp_low;
    v20 = v4;
    do
    {
      *v20 = 0.0;
      if ((_DWORD)v9)
      {
        v21 = *(float **)v10;
        v22 = 0.0;
        v23 = v19;
        v24 = v18;
        v25 = 4 * v9;
        v26 = v8;
        do
        {
          if (v23 + 1 <= 0)
            v27 = *(_DWORD *)(v10 + 8) + ~((v24 + *(_DWORD *)(v10 + 8)) % *(_DWORD *)(v10 + 8));
          else
            v27 = (v14 + v23) % *(_DWORD *)(v10 + 8);
          v28 = *v26++;
          v22 = v22 + (float)(v28 * v21[v27]);
          *v20 = v22;
          v24 += realp_low;
          v23 -= realp_low;
          v25 -= 4;
        }
        while (v25);
      }
      ++v20;
      --v18;
      ++v19;
    }
    while (v20 != &v4[realp_low]);
    v29 = 4 * realp_low;
    v30 = v4;
    do
    {
      if (*v30 < 0.0)
        *v30 = 0.0;
      ++v30;
      v29 -= 4;
    }
    while (v29);
  }
  VADGenUtils::VectorSigmoid<float>(v4, v4, v6, v7, realp_low, 0.8, 3.0);
  v31 = *(const float **)(a1 + 256);
  v32 = *(unsigned int *)(a1 + 732);
  v33 = *(float **)(a1 + 272);
  v34 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16);
  if (v34)
  {
    v35 = *(float **)(a1 + 568);
    v36 = *(const float **)(a1 + 296);
    v37 = *(unsigned int *)(*(_QWORD *)a1 + 44);
    __B[0] = -1.0;
    __C = 1.0;
    vDSP_vsmsa(v31, 1, __B, &__C, v35, 1, v37);
    vDSP_vdiv(v35, 1, v31, 1, v35, 1, v37);
    LODWORD(__A.realp) = v37;
    vvlogf(v35, v35, (const int *)&__A);
    if ((_DWORD)v32)
    {
      v38 = &v35[v32];
      v39 = (float *)v36;
      do
      {
        v40 = 0;
        *v39 = 0.0;
        v41 = 0.0;
        do
        {
          v41 = v41 + v35[v40 / 4];
          *v39 = v41;
          v40 += 4;
        }
        while (4 * (2 * v34) + 4 != v40);
        *v39++ = (float)(1.0 / (float)((2 * v34) | 1u)) * v41;
        ++v35;
      }
      while (v35 != v38);
      LODWORD(__A.realp) = v32;
      vvexpf(v33, v36, (const int *)&__A);
      v42 = 4 * v32;
      do
      {
        *v33 = *v33 / (float)(*v33 + 1.0);
        ++v33;
        v42 -= 4;
      }
      while (v42);
    }
    else
    {
      LODWORD(__A.realp) = 0;
      vvexpf(v33, v36, (const int *)&__A);
    }
  }
  else
  {
    memcpy(*(void **)(a1 + 272), *(const void **)(a1 + 256), 4 * v32);
  }
  v43 = *(float **)(a1 + 272);
  LODWORD(__A.realp) = *(_DWORD *)(a1 + 732);
  vvlogf(v43, v43, (const int *)&__A);
  v44 = *(unsigned int *)(a1 + 732);
  v46 = *(const float **)(a1 + 272);
  v45 = *(const float **)(a1 + 280);
  v47 = *(float **)(a1 + 296);
  (*(void (**)(_QWORD, const float *, const float *, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 176) + 8)
                                                                       + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 8), v46, v45, *(_QWORD *)(a1 + 288));
  vDSP_vsub(v45, 1, v46, 1, v47, 1, v44);
  v48 = *(unsigned int *)(a1 + 736);
  v49 = *(_DWORD *)(a1 + 732);
  v50 = *(_QWORD *)(a1 + 320);
  v51 = *(uint64_t **)(a1 + 200);
  v52 = 4 * v48;
  if (v51 != *(uint64_t **)(a1 + 208))
  {
    v54 = *(float **)(a1 + 304);
    v53 = *(float **)(a1 + 312);
    v55 = *(float **)(a1 + 320);
    v56 = *(_DWORD **)(a1 + 296);
    do
    {
      v58 = *v51++;
      v57 = v58;
      LODWORD(v58) = *v56++;
      (*(void (**)(uint64_t, float *, float *, float))(*(_QWORD *)v57 + 16))(v57, v54, v53, *(float *)&v58);
      __A.realp = v54;
      __A.imagp = v53;
      vDSP_zvabs(&__A, 1, v55, 1, v48);
      v55 = (float *)((char *)v55 + v52);
    }
    while (v51 != *(uint64_t **)(a1 + 208));
  }
  v59 = (v49 * v48);
  if ((_DWORD)v59)
  {
    v60 = 0;
    v61 = 4 * v59;
    do
    {
      v62 = v50 + v60;
      *(_DWORD *)v62 = 0;
      *(float *)(v62 + 4) = *(float *)(v50 + v60 + 4) * 0.5;
      v60 += v52;
    }
    while (v61 != v60);
  }
  v63 = *(float **)(a1 + 304);
  v64 = *(float **)(a1 + 288);
  v65 = *(unsigned int *)(a1 + 736);
  v66 = *(unsigned int *)(a1 + 732);
  v67 = *(const float **)(a1 + 320);
  v68 = *(_DWORD **)(a1 + 328);
  v69 = *(_DWORD **)(a1 + 336);
  v126 = *(_QWORD **)(a1 + 648);
  LODWORD(__A.realp) = -1054867456;
  v117 = v64;
  vDSP_vfill((const float *)&__A, v64, 1, v66);
  v119 = v66;
  if ((_DWORD)v66)
  {
    v70 = 0;
    v71 = *(_QWORD *)(a1 + 752) - *(_QWORD *)(a1 + 744);
    v118 = v71 & 0x3FFFFFFFCLL;
    v125 = (v71 >> 2);
    v123 = v68;
    v121 = v117;
    v122 = v69;
    do
    {
      v120 = v70;
      if (v118)
      {
        v72 = 0;
        v73 = -10.0;
        do
        {
          if (v72 >= (uint64_t)(v126[1] - *v126) >> 3)
            std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
          vDSP_vmul(*(const float **)(*v126 + 8 * v72), 1, v67, 1, v63, 1, v65);
          v74 = *v63;
          if ((_DWORD)v65)
          {
            v75 = 0;
            v76 = 0;
            v77 = 4 * v65;
            v78 = *v63;
            do
            {
              v79 = v63[v75];
              if (v79 <= v78)
              {
                v78 = v63[v75];
              }
              else if (v79 >= v74)
              {
                v76 = v75;
                v74 = v63[v75];
              }
              ++v75;
              v77 -= 4;
            }
            while (v77);
          }
          else
          {
            v76 = 0;
            v78 = *v63;
          }
          if (v74 != v78)
          {
            v80 = v65 - 2;
            if (v76 != (_DWORD)v65 - 1)
              v80 = v76;
            if (!v76)
              v80 = 1;
            v81 = *(_QWORD *)(v17 + 744);
            if (v72 >= (*(_QWORD *)(v17 + 752) - v81) >> 2)
              std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
            v82 = *(_DWORD *)(v81 + 4 * v72);
            if (v82)
            {
              v83 = 0;
              v84 = v63[v80 - 1];
              v85 = v63[v80 + 1];
              v86 = v85 + (float)(v84 - (float)(v63[v80] + v63[v80]));
              v87 = (float)((float)((float)(v84 - v85) / (float)(v86 + v86)) + (float)v80) + 1.0;
              while (1)
              {
                v88 = (double)v83 + 0.5;
                v89 = (double)v83 + 1.5;
                v90 = (float)(unint64_t)((float)(v87 * v88) + 0.5) - 1;
                v91 = (float)(unint64_t)((float)(v87 * v89) + 0.5) - 1;
                if (v90 >= v65 || v91 >= v65)
                  break;
                v68[v83] = v90;
                v69[v83++] = v91;
                if (v82 == (_DWORD)v83)
                  goto LABEL_66;
              }
              v82 = v83;
            }
LABEL_66:
            v93 = *(_QWORD *)(v17 + 768);
            if (v72 >= (*(_QWORD *)(v17 + 776) - v93) >> 2)
              std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
            v94 = *(float *)(v93 + 4 * v72);
            if (v82)
            {
              v95 = 4 * v82;
              v96 = 1.0;
              v97 = 0.0;
              v98 = v68;
              v99 = v69;
              do
              {
                v101 = *v98++;
                v100 = v101;
                v102 = &v67[v101];
                v103 = *v99++;
                v104 = (float)(v103 - v100 + 1);
                LODWORD(__A.realp) = 0;
                vDSP_svesq(v102, 1, (float *)&__A, v104);
                __B[0] = 0.0;
                v105 = sqrt(*(float *)&__A.realp);
                vDSP_svemg(v102, 1, __B, v104);
                v106 = log((double)v104 / (__B[0] / v105 * (__B[0] / v105)));
                v97 = v97 + (float)(v96 * v106);
                v96 = v96 * v94;
                v95 -= 4;
              }
              while (v95);
            }
            else
            {
              v97 = 0.0;
            }
            v107 = pow(v94, (double)v82);
            v108 = (float)((float)(1.0 - v94) / (float)(1.0 - v107)) * v97;
            v17 = a1;
            v69 = v122;
            v68 = v123;
            if (v108 > v73)
            {
              *v121 = v108;
              v73 = v108;
            }
          }
          ++v72;
        }
        while (v72 != v125);
      }
      v67 += v65;
      ++v121;
      v70 = v120 + 1;
    }
    while (v120 + 1 != v119);
  }
  v109 = *(unsigned int *)(v17 + 732);
  v110 = *(float *)(*(_QWORD *)(v17 + 16) + 20);
  if ((_DWORD)v109)
  {
    v111 = 4 * v109;
    v112 = 0.0;
    v113 = v117;
    do
    {
      v114 = *v113++;
      v112 = v112 + pow(v114, v110);
      v111 -= 4;
    }
    while (v111);
  }
  else
  {
    v112 = 0.0;
  }
  v115 = pow(v112, 1.0 / v110);
  return log(v115 + 2.2204e-16);
}

float ASAFeatures::HarmonicConsistency(uint64_t a1, uint64_t a2)
{
  float *v3;
  double v4;
  double v5;
  double v6;
  uint64_t v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  uint64_t v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  const float *v21;
  const float *v22;
  float *v23;
  float *v24;
  float *v25;
  float *v26;
  float *v27;
  vDSP_Length v28;
  float *v29;
  float v30;
  float v31;
  const float *v32;
  vDSP_Length v33;
  float v34;
  int v36;
  float __B;
  float __C;

  v3 = *(float **)(a1 + 344);
  v4 = *(double *)(a1 + 800);
  v5 = *(double *)(a1 + 808);
  v6 = *(double *)(a1 + 816);
  v7 = *(unsigned int *)(*(_QWORD *)a1 + 60);
  v8 = 4 * v7;
  memcpy(v3, *(const void **)(a2 + 24), 4 * v7);
  v36 = v7;
  vvlogf(v3, v3, &v36);
  if ((_DWORD)v7)
  {
    v12 = 0.0;
    v13 = 4 * v7;
    v14 = v3;
    v15 = 0.0;
    v16 = 0.0;
    v17 = 0.0;
    v18 = 0.0;
    do
    {
      v19 = *v14;
      v9 = v4;
      v10 = v5;
      v11 = v6;
      v20 = (float)((float)(v15 * v9) + (float)(v11 * (float)((float)((float)(v18 + *v14) - v17) - v16)))
          + (float)(v10 * v12);
      *v14++ = v20;
      v12 = v15;
      v15 = v20;
      v16 = v17;
      v17 = v18;
      v18 = v19;
      v13 -= 4;
    }
    while (v13);
    do
    {
      if (*v3 < 0.0)
        *v3 = 0.0;
      ++v3;
      v8 -= 4;
    }
    while (v8);
  }
  if (*(_DWORD *)(a1 + 1008) <= *(_DWORD *)(a1 + 824))
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 176) + 16) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 16), *(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 352), *(_QWORD *)(a1 + 368));
  v22 = *(const float **)(a1 + 344);
  v21 = *(const float **)(a1 + 352);
  v24 = *(float **)(a1 + 376);
  v23 = *(float **)(a1 + 384);
  v25 = *(float **)(a1 + 360);
  v26 = *(float **)(a1 + 368);
  v27 = *(float **)(a1 + 576);
  v28 = *(unsigned int *)(*(_QWORD *)a1 + 60);
  v29 = *(float **)(a1 + 24);
  v30 = v29[6];
  v31 = v29[7];
  __B = v29[3];
  *(float *)(a1 + 952) = *(float *)(a1 + 952) * __B;
  vDSP_vsmul(v21, 1, (const float *)(a1 + 952), v23, 1, v28);
  vDSP_vsub(v22, 1, v24, 1, v24, 1, v28);
  vDSP_vsma(v24, 1, &__B, v22, 1, v25, 1, v28);
  memcpy(v24, v25, 4 * v28);
  vDSP_vadd(v25, 1, v23, 1, v25, 1, v28);
  VADGenUtils::VectorSigmoid<float>(v25, v25, v26, v27, v28, v30, v31);
  v32 = *(const float **)(a1 + 360);
  v33 = *(unsigned int *)(*(_QWORD *)a1 + 60);
  __C = 0.0;
  vDSP_svesq(v32, 1, &__C, v33);
  v34 = sqrt(__C / (double)v33);
  return log(v34 / (1.0 - v34));
}

float ASAFeatures::FilteredRmsDB(uint64_t a1, ASAFeatures **a2)
{
  float v3;
  float v4;
  float result;
  float v6;
  float v7;

  v6 = 0.0;
  ASAFeatures::getRMS(a1, a2, &v7, &v6);
  v3 = v6 - *(float *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = *(float *)(a1 + 992);
  result = (float)((float)(v4 * *(float *)(a1 + 832))
                 + (float)(*(float *)(a1 + 840) * (float)(v3 - *(float *)(a1 + 988))))
         + (float)(*(float *)(a1 + 836) * *(float *)(a1 + 996));
  *(float *)(a1 + 996) = v4;
  *(float *)(a1 + 992) = result;
  *(float *)(a1 + 988) = v3;
  return result;
}

float ASAFeatures::FilteredRmsDBDeriv(uint64_t a1, ASAFeatures **a2)
{
  float v3;
  float result;
  float v5;
  float v6;

  v5 = 0.0;
  ASAFeatures::getRMS(a1, a2, &v6, &v5);
  v3 = v5 - *(float *)(*(_QWORD *)(a1 + 32) + 8);
  result = (float)(v3 - *(float *)(a1 + 1000))
         + (float)(*(float *)(a1 + 844) * (float)(*(float *)(a1 + 1004) - (float)(v3 - *(float *)(a1 + 1000))));
  *(float *)(a1 + 1004) = result;
  *(float *)(a1 + 1000) = v3;
  return result;
}

float ASAFeatures::RmsDynamicRange(_QWORD *a1, ASAFeatures **a2)
{
  float v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  float v10;
  int v11;
  int v12;
  int v13;
  float v14;
  float v16;
  float v17;

  v16 = 0.0;
  ASAFeatures::getRMS((uint64_t)a1, a2, &v17, &v16);
  v3 = v16 * 0.11513;
  v4 = (uint64_t *)a1[50];
  v5 = *v4;
  v6 = *((_DWORD *)v4 + 2);
  v7 = *((int *)v4 + 3);
  *(float *)(*v4 + 4 * v7) = v16 * 0.11513;
  v8 = ((int)v7 + 1) % v6;
  *((_DWORD *)v4 + 3) = v8;
  v9 = (int)(float)(1.0 - *(float *)(*a1 + 52));
  if (v9 < 0)
  {
    v11 = -v9;
    v12 = v6 - v8;
    v10 = v3;
    do
    {
      v13 = v6 + ~((v12 + v11) % v6);
      v14 = *(float *)(v5 + 4 * v13);
      if (v10 > v14)
        v10 = *(float *)(v5 + 4 * v13);
      if (v3 < v14)
        v3 = *(float *)(v5 + 4 * v13);
      --v11;
    }
    while (v11);
  }
  else
  {
    v10 = v3;
  }
  return log((float)(v3 - v10));
}

float ASAFeatures::NormRms(uint64_t a1, ASAFeatures **a2)
{
  double v4;
  double v5;
  double v6;
  float v7;
  float v8;

  v8 = 0.0;
  ASAFeatures::getRMS(a1, a2, &v8, &v7);
  v6 = v8;
  v4 = 0.0;
  v5 = 0.0;
  (*(void (**)(_QWORD, double *, double *, double *))(**(_QWORD **)(a1 + 592) + 16))(*(_QWORD *)(a1 + 592), &v6, &v5, &v4);
  return log10(sqrt(v4) / v5) * 20.0;
}

float ASAFeatures::LogRmsStdDev(uint64_t a1, ASAFeatures **a2)
{
  uint64_t v4;
  float v5;
  float v6;

  v5 = 0.0;
  ASAFeatures::getRMS(a1, a2, &v6, &v5);
  v5 = v5 * 0.11513;
  v4 = 0;
  (*(void (**)(_QWORD, float *, char *, uint64_t *))(**(_QWORD **)(*(_QWORD *)(a1 + 176) + 24) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 24), &v5, (char *)&v4 + 4, &v4);
  return log((float)(*(float *)&v4 + 0.000821));
}

float ASAFeatures::ModEnergy(uint64_t a1, uint64_t a2)
{
  float *v3;
  float *v4;
  float *v5;
  float *v6;
  double v7;
  double v8;
  double v9;
  float *v10;
  vDSP_Length v11;
  float *v12;
  uint64_t v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float *v21;
  float *v22;
  int v23;
  float v24;
  float __C;

  v3 = *(float **)(a1 + 408);
  v4 = *(float **)(a1 + 432);
  v21 = *(float **)(a1 + 424);
  v22 = *(float **)(a1 + 416);
  v6 = *(float **)(a1 + 448);
  v5 = *(float **)(a1 + 456);
  v7 = *(double *)(a1 + 848);
  v8 = *(double *)(a1 + 856);
  v9 = *(double *)(a1 + 864);
  v10 = *(float **)(a1 + 440);
  v11 = *(unsigned int *)(*(_QWORD *)a1 + 44);
  if ((_DWORD)v11)
  {
    v12 = *(float **)(a2 + 32);
    v13 = 4 * v11;
    v14 = *(float **)(a1 + 408);
    do
    {
      v15 = *v12++;
      v16 = log(v15);
      *v14++ = v16;
      v13 -= 4;
    }
    while (v13);
  }
  v17 = v9;
  v18 = v8;
  v19 = v7;
  VADGenUtils::TwoPoleBandpass_Array<float>(v3, v22, v21, v4, v6, v5, v10, v11, v19, v18, v17);
  ASAFeatures::backupBandpassArrayStates((ASAFeatures *)v3, v22, v21, v4, v10, v6, v5, v11, v21);
  __C = 0.0;
  vDSP_svesq(v10, 1, &__C, v11);
  __C = sqrtf(__C);
  v23 = 0;
  v24 = 0.0;
  (*(void (**)(_QWORD, float *, float *, int *))(**(_QWORD **)(*(_QWORD *)(a1 + 176) + 32) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 32), &__C, &v24, &v23);
  return log(v24);
}

float ASAFeatures::ModEnergy2(uint64_t a1, uint64_t a2)
{
  const float *v3;
  float *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  float *v10;
  float *v11;
  float *v12;
  float *v13;
  float *v14;
  float *v15;
  const float *v16;
  float *v17;
  float *v18;
  float v19;
  float v20;
  float v21;
  vDSP_Length v22;
  float v23;
  float *v24;
  double v25;
  double v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float *v39;
  float *v40;
  float *v41;
  float *v42;
  float v43;
  float v44;
  float v45;
  float v46;
  vDSP_Length v47;
  float v48;
  unsigned int v50;
  float *v51;
  int v52;
  float v53;
  float __B;

  v3 = *(const float **)(a2 + 32);
  v4 = *(float **)(a1 + 464);
  v5 = *(_QWORD *)(a1 + 472);
  v6 = *(_QWORD *)(a1 + 544);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 176) + 40);
  v8 = *(_DWORD *)(a1 + 1008);
  v9 = *(_DWORD *)(a1 + 872);
  __B = *(float *)(*(_QWORD *)a1 + 44);
  vvlogf(v4, v3, (const int *)&__B);
  if (v8 <= v9)
    (*(void (**)(uint64_t, float *, uint64_t, uint64_t))(*(_QWORD *)v7 + 16))(v7, v4, v5, v6);
  v10 = *(float **)(a1 + 480);
  v11 = *(float **)(a1 + 488);
  v13 = *(float **)(a1 + 496);
  v12 = *(float **)(a1 + 504);
  v14 = *(float **)(a1 + 512);
  v15 = *(float **)(a1 + 520);
  v17 = *(float **)(a1 + 464);
  v16 = *(const float **)(a1 + 472);
  v18 = *(float **)(a1 + 528);
  v51 = v18;
  v19 = *(double *)(a1 + 880);
  v20 = *(double *)(a1 + 888);
  v21 = *(double *)(a1 + 896);
  v22 = *(unsigned int *)(*(_QWORD *)a1 + 44);
  v23 = 0.0;
  __B = (float)((float)(*(float *)(a1 + 968) * v19)
              + (float)(v21
                      * (float)((float)((float)(*(float *)(a1 + 956) + 0.0) - *(float *)(a1 + 960))
                              - *(float *)(a1 + 964))))
      + (float)(v20 * *(float *)(a1 + 972));
  vDSP_vsmul(v16, 1, &__B, v18, 1, v22);
  *(_QWORD *)(a1 + 960) = *(_QWORD *)(a1 + 956);
  *(_DWORD *)(a1 + 956) = 0;
  *(_DWORD *)(a1 + 972) = *(_DWORD *)(a1 + 968);
  *(float *)(a1 + 968) = __B;
  VADGenUtils::TwoPoleBandpass_Array<float>(v17, v10, v11, v13, v14, v15, v12, v22, v19, v20, v21);
  ASAFeatures::backupBandpassArrayStates((ASAFeatures *)v17, v10, v11, v13, v12, v14, v15, v22, v50);
  vDSP_vadd(v12, 1, v51, 1, v12, 1, v22);
  v24 = *(float **)(a1 + 536);
  v25 = *(double *)(a1 + 904);
  v26 = *(double *)(a1 + 912);
  v27 = *(double *)(a1 + 920);
  v28 = *(unsigned int *)(*(_QWORD *)a1 + 44);
  v29 = 4 * v28;
  memcpy(v24, *(const void **)(a1 + 504), 4 * v28);
  if ((_DWORD)v28)
  {
    v33 = 0.0;
    v34 = 0.0;
    v35 = 0.0;
    v36 = 0.0;
    do
    {
      v37 = *v24;
      v30 = v25;
      v31 = v26;
      v32 = v27;
      v38 = (float)((float)(v33 * v30) + (float)(v32 * (float)((float)((float)(v36 + *v24) - v35) - v34)))
          + (float)(v31 * v23);
      *v24++ = v38;
      v23 = v33;
      v33 = v38;
      v34 = v35;
      v35 = v36;
      v36 = v37;
      v29 -= 4;
    }
    while (v29);
  }
  v39 = *(float **)(a1 + 536);
  v40 = *(float **)(a1 + 544);
  v41 = *(float **)(a1 + 568);
  v42 = *(float **)(a1 + 48);
  v43 = v42[6];
  v44 = v42[7];
  v45 = v42[8];
  v46 = v42[9];
  v47 = *(unsigned int *)(*(_QWORD *)a1 + 44);
  vDSP_vabs(v39, 1, v39, 1, v47);
  VADGenUtils::VectorSigmoid<float>(v39, v39, v40, v41, v47, v43, v44);
  __B = 0.0;
  vDSP_vsq(v39, 1, v39, 1, v47);
  vDSP_sve(v39, 1, &__B, v47);
  v48 = exp((float)((float)(sqrtf(__B) - v45) * v46));
  __B = v48 / (float)(v48 + 1.0);
  v52 = 0;
  v53 = 0.0;
  (*(void (**)(_QWORD, float *, float *, int *))(**(_QWORD **)(*(_QWORD *)(a1 + 176) + 48) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 48), &__B, &v53, &v52);
  return log(v53 / (1.0 - v53));
}

float ASAFeatures::LowEnergyFrac(_QWORD *a1, ASAFeatures **a2)
{
  float RMS;
  uint64_t v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  float v9;
  int v10;
  unsigned int v11;
  double v12;
  unsigned int v13;
  int v15;
  float v16;
  float v17;
  int v18;
  float v19;

  v18 = 0;
  RMS = ASAFeatures::getRMS((uint64_t)a1, a2, (float *)&v18, &v17);
  v15 = 0;
  v16 = 0.0;
  (*(void (**)(_QWORD, int *, float *, int *, float))(**(_QWORD **)(a1[22] + 56) + 16))(*(_QWORD *)(a1[22] + 56), &v18, &v16, &v15, RMS);
  v4 = *(_QWORD *)(a1[22] + 56);
  if (*(_BYTE *)(v4 + 112))
  {
    if (*(_BYTE *)(v4 + 112) == 1)
      v5 = *(_DWORD *)(v4 + 116);
    else
      v5 = *(float *)(*a1 + 52);
    if (v5)
    {
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = v16 * *(float *)(a1[7] + 8);
      v10 = -v5;
      do
      {
        v19 = 0.0;
        --v6;
        MRRingBuffer<float>::GetSampleRange(*(uint64_t **)(v4 + 128), *(_DWORD *)(v4 + 8) * v6, *(_DWORD *)(v4 + 8) * v6 + *(_DWORD *)(v4 + 8), &v19);
        if (v19 >= v9)
          v11 = v8;
        else
          v11 = v8 + 1;
        if (v19 > 0.00055)
        {
          v8 = v11;
          ++v7;
        }
      }
      while (v10 != v6);
    }
    else
    {
      v8 = 0;
      v7 = 0;
    }
    if (v7 <= 1)
      v13 = 1;
    else
      v13 = v7;
    v12 = (float)((float)((float)v8 / (float)v13) + 0.025);
  }
  else
  {
    v12 = 0.0250000004;
  }
  return log(v12 / (1.0 - v12));
}

float ASAFeatures::SpectralRolloffHzVar(_QWORD *a1, uint64_t a2)
{
  const float *v3;
  float v4;
  float v5;
  vDSP_Length v6;
  float v7;
  float v8;
  float v9;
  BOOL v10;
  float *v11;
  int v12;
  float v13;
  float v15;
  int v16;
  float __C;

  v3 = *(const float **)(a2 + 40);
  v4 = *(float *)(a1[8] + 8);
  v5 = *(float *)(*a1 + 68);
  v6 = *(unsigned int *)(*a1 + 56);
  __C = 0.0;
  vDSP_sve(v3, 1, &__C, v6);
  v7 = __C * v4;
  v8 = *v3;
  v9 = 0.0;
  if ((_DWORD)v6)
    v10 = v8 < v7;
  else
    v10 = 0;
  if (v10)
  {
    v11 = (float *)(v3 + 1);
    v12 = 1;
    while ((_DWORD)v6 != v12)
    {
      v13 = *v11++;
      v8 = v8 + v13;
      ++v12;
      if (v8 >= v7)
      {
        LODWORD(v6) = v12 - 1;
        break;
      }
    }
    v9 = (float)v6;
  }
  __C = v9 * (float)v5;
  v15 = 0.0;
  v16 = 0;
  (*(void (**)(_QWORD, float *, int *, float *))(**(_QWORD **)(a1[22] + 64) + 16))(*(_QWORD *)(a1[22] + 64), &__C, &v16, &v15);
  return sqrtf(v15);
}

float ASAFeatures::CentroidVar(_QWORD *a1, uint64_t a2)
{
  const float *v3;
  float v4;
  const float *v5;
  float *v6;
  vDSP_Length v7;
  float v8;
  float v10;
  int v11;
  float __C;

  v3 = *(const float **)(a2 + 40);
  v4 = (float)*(float *)(*a1 + 68);
  v5 = (const float *)a1[83];
  v6 = (float *)a1[70];
  v7 = *(unsigned int *)(*a1 + 56);
  __C = 0.0;
  vDSP_sve(v3, 1, &__C, v7);
  v8 = __C;
  vDSP_vmul(v3, 1, v5, 1, v6, 1, v7);
  __C = 0.0;
  vDSP_sve(v6, 1, &__C, v7);
  __C = (float)(__C / v8) * v4;
  v10 = 0.0;
  v11 = 0;
  (*(void (**)(_QWORD, float *, int *, float *))(**(_QWORD **)(a1[22] + 72) + 16))(*(_QWORD *)(a1[22] + 72), &__C, &v11, &v10);
  return sqrtf(v10);
}

float ASAFeatures::FluxVar(float **a1, uint64_t a2)
{
  float *v4;
  uint64_t v6;
  float v7;
  float __C;

  __C = 0.0;
  vDSP_vsub(*(const float **)(a2 + 48), 1, *(const float **)(a2 + 40), 1, a1[70], 1, *((unsigned int *)*a1 + 14));
  vDSP_svesq(a1[70], 1, &__C, *((unsigned int *)*a1 + 14));
  v4 = *a1;
  __C = sqrtf(__C) * (*a1)[3];
  v7 = 0.0;
  vDSP_svesq(*(const float **)(a2 + 40), 1, &v7, *((unsigned int *)v4 + 14));
  __C = __C / sqrtf(v7);
  v6 = 0;
  (*(void (**)(_QWORD, float *, char *, uint64_t *))(**((_QWORD **)a1[22] + 10) + 16))(*((_QWORD *)a1[22] + 10), &__C, (char *)&v6 + 4, &v6);
  return log(*(float *)&v6);
}

float ASAFeatures::ReconDiffVar(_QWORD *a1, uint64_t a2)
{
  uint64_t v5;
  float v6;
  float __C;

  __C = 0.0;
  vDSP_svesq(*(const float **)(a2 + 56), 1, &__C, *(unsigned int *)(*a1 + 56));
  __C = sqrtf(__C);
  v6 = 0.0;
  vDSP_svesq(*(const float **)(a2 + 16), 1, &v6, *(unsigned int *)(*a1 + 56));
  __C = __C / sqrtf(v6);
  v5 = 0;
  (*(void (**)(_QWORD, float *, char *, uint64_t *))(**(_QWORD **)(a1[22] + 88) + 16))(*(_QWORD *)(a1[22] + 88), &__C, (char *)&v5 + 4, &v5);
  return log(*(float *)&v5);
}

float ASAFeatures::CepstralSparsity(uint64_t a1, uint64_t a2)
{
  const float *v3;
  const float *v4;
  float *v5;
  float *v6;
  vDSP_Length v7;
  const float *v8;
  const float *v9;
  vDSP_Length v10;
  float v12;
  uint64_t __B;

  v3 = *(const float **)(a2 + 88);
  v4 = *(const float **)(a1 + 680);
  v5 = *(float **)(a1 + 688);
  v6 = *(float **)(a1 + 696);
  v7 = *(unsigned int *)(*(_QWORD *)a1 + 72);
  HIDWORD(__B) = *(_DWORD *)(a1 + 928);
  vDSP_vsmul(v3, 1, (const float *)&__B + 1, v5, 1, v7);
  vDSP_vmul(v3, 1, v4, 1, v6, 1, v7);
  *v5 = 0.0;
  *v6 = 0.0;
  v8 = *(const float **)(a1 + 688);
  v9 = *(const float **)(a1 + 696);
  v10 = *(unsigned int *)(*(_QWORD *)a1 + 72);
  __B = 0;
  vDSP_svemg(v8, 1, (float *)&__B + 1, v10);
  vDSP_svesq(v9, 1, (float *)&__B, v10);
  *((float *)&__B + 1) = sqrtf(*(float *)&__B) / *((float *)&__B + 1);
  v12 = 0.0;
  LODWORD(__B) = 0;
  (*(void (**)(_QWORD, char *, uint64_t *, float *))(**(_QWORD **)(*(_QWORD *)(a1 + 176) + 96) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 96), (char *)&__B + 4, &__B, &v12);
  return log(v12);
}

float ASAFeatures::CepstralVariance(_QWORD *a1, uint64_t a2)
{
  vDSP_Length v3;
  float *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  long double v8;
  float v9;
  float v10;
  const float *v11;
  const float *v12;
  float *v13;
  vDSP_Length v14;
  float v16;
  float __C;
  float v18;
  float __B;

  v3 = *(unsigned int *)(*a1 + 72);
  v4 = (float *)a1[69];
  if ((_DWORD)v3)
  {
    v5 = 0;
    v6 = *(_QWORD *)(a2 + 88);
    v7 = a1[88];
    v8 = *(float *)(a1[13] + 8);
    v9 = 0.0;
    do
    {
      v10 = 0.0;
      if (v5 * 4)
        v10 = pow(fabsf(*(float *)(v6 + v5 * 4) * *(float *)(v7 + v5 * 4)), v8);
      v9 = v10 + v9;
      v4[v5++] = v10;
    }
    while (v3 != v5);
  }
  else
  {
    v9 = 0.0;
  }
  __B = 1.0 / v9;
  vDSP_vsmul(v4, 1, &__B, v4, 1, v3);
  __C = 0.0;
  v18 = 0.0;
  v11 = (const float *)a1[69];
  v12 = (const float *)a1[89];
  v13 = (float *)a1[73];
  v14 = *(unsigned int *)(*a1 + 72);
  vDSP_vmul(v11, 1, v12, 1, v13, 1, v14);
  vDSP_sve(v13, 1, &__C, v14);
  __B = -1.0;
  vDSP_vsmsa(v12, 1, &__B, &__C, v13, 1, v14);
  vDSP_vsq(v13, 1, v13, 1, v14);
  vDSP_vmul(v13, 1, v11, 1, v13, 1, v14);
  vDSP_sve(v13, 1, &v18, v14);
  __B = *(float *)(*a1 + 8) * (float)(*(float *)(*a1 + 8) / v18);
  v16 = 0.0;
  (*(void (**)(_QWORD, float *, float *, float *))(**(_QWORD **)(a1[22] + 104) + 16))(*(_QWORD *)(a1[22] + 104), &__B, &v16, &__C);
  return log(v16);
}

float ASAFeatures::AvgPitchDensity(uint64_t a1, uint64_t a2)
{
  vDSP_Length v3;
  float v4;
  const float *v5;
  float v6;
  int v8;
  float v9;
  float __C;

  v3 = *(unsigned int *)(a1 + 944);
  v4 = *(float *)(a1 + 948);
  v5 = (const float *)(*(_QWORD *)(a2 + 88) + 4 * *(unsigned int *)(a1 + 936));
  __C = 0.0;
  vDSP_svemg(v5, 1, &__C, v3);
  __C = v4 * __C;
  v8 = 0;
  v9 = 0.0;
  (*(void (**)(_QWORD, float *, float *, int *))(**(_QWORD **)(*(_QWORD *)(a1 + 176) + 112) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 112), &__C, &v9, &v8);
  v6 = log(v9);
  return -v6;
}

float ASAFeatures::AvgTonalityPower(_QWORD *a1, uint64_t a2)
{
  const float *v4;
  vDSP_Length v5;
  float v6;
  float v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  float v12;
  uint64_t v13;
  float v14;
  int v15;
  float v16;
  float __C;

  v15 = 0;
  v16 = 0.0;
  ASAFeatures::getRMS((uint64_t)a1, (ASAFeatures **)a2, &v16, (float *)&v15);
  v4 = *(const float **)(a2 + 88);
  v5 = *(unsigned int *)(*a1 + 72);
  v6 = *(float *)(a1[15] + 8);
  __C = 0.0;
  vDSP_maxmgv(v4, 1, &__C, v5);
  v7 = 0.0;
  if (__C > v6)
    v7 = 1.0;
  __C = v7 + (float)((float)(1.0 - v7) * 0.005);
  v14 = __C * v16;
  v13 = 0;
  v12 = 0.0;
  (*(void (**)(_QWORD, float *, char *, int *))(**(_QWORD **)(a1[22] + 120) + 16))(*(_QWORD *)(a1[22] + 120), &v16, (char *)&v13 + 4, &v15);
  (*(void (**)(_QWORD, float *, uint64_t *, int *))(**(_QWORD **)(a1[22] + 128) + 16))(*(_QWORD *)(a1[22] + 128), &__C, &v13, &v15);
  (*(void (**)(_QWORD, float *, float *, int *))(**(_QWORD **)(a1[22] + 136) + 16))(*(_QWORD *)(a1[22] + 136), &v14, &v12, &v15);
  v8 = *(_QWORD *)(a1[22] + 120);
  v9 = *(unsigned __int8 *)(v8 + 112);
  if (v9 == 2)
  {
    v10 = *(_DWORD *)(v8 + 16);
  }
  else if (v9 == 1)
  {
    v10 = *(_DWORD *)(v8 + 116);
  }
  else
  {
    v10 = 0;
    if (!*(_BYTE *)(v8 + 112))
      v10 = *(_DWORD *)(v8 + 12);
  }
  return log((float)((float)((float)(v12 * (float)v10)
                           / (float)((float)(*(float *)&v13 * (float)v10) + *(float *)(a1[15] + 12)))
                   / *((float *)&v13 + 1)));
}

float ASAFeatures::getRMS(uint64_t a1, ASAFeatures **a2, float *a3, float *a4)
{
  float v7;
  float v8;
  float result;

  if (*(_BYTE *)(a1 + 976))
  {
    v7 = ASAFeatures::computeCenteredRMS(*a2, *(unsigned int *)(*(_QWORD *)a1 + 64), *(_DWORD *)(*(_QWORD *)a1 + 16));
    *(float *)(a1 + 980) = v7;
    v8 = log10(v7);
    *(float *)(a1 + 984) = v8 * 20.0;
  }
  else
  {
    v7 = *(float *)(a1 + 980);
  }
  *a3 = v7;
  result = *(float *)(a1 + 984);
  *a4 = result;
  return result;
}

float ASAFeatures::computeCenteredRMS(ASAFeatures *this, vDSP_Length __N, int a3)
{
  unsigned int v3;
  float __C;

  v3 = __N;
  __C = 0.0;
  vDSP_svesq((const float *)this+ (unint64_t)(float)(unint64_t)((float)((float)(a3 - __N) * 0.5) + 0.5), 1, &__C, __N);
  return sqrt(__C / (double)v3);
}

void ASAFeatures::backupBandpassArrayStates(ASAFeatures *this, float *a2, float *__A, float *__C, const float *a5, float *a6, float *a7, vDSP_Length __M, unsigned int a9)
{
  vDSP_Length v15;

  v15 = __M;
  vDSP_mmov(__A, __C, __M, 1uLL, __M, __M);
  vDSP_mmov(a2, __A, v15, 1uLL, v15, v15);
  vDSP_mmov((const float *)this, a2, v15, 1uLL, v15, v15);
  vDSP_mmov(a6, a7, v15, 1uLL, v15, v15);
  vDSP_mmov(a5, a6, v15, 1uLL, v15, v15);
}

void std::vector<unsigned int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz)
{
  std::vector<unsigned int>::pointer begin;
  std::vector<unsigned int>::pointer end;
  std::vector<unsigned int>::size_type v5;
  std::vector<unsigned int>::size_type v6;
  std::__compressed_pair<unsigned int *> *p_end_cap;
  unsigned int *value;
  uint64_t v9;
  std::vector<unsigned int>::size_type v10;
  unint64_t v11;
  char *v12;
  std::vector<unsigned int>::pointer v13;
  std::vector<unsigned int>::pointer v14;
  char *v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int *v18;
  int v19;
  unsigned int *v20;

  begin = this->__begin_;
  end = this->__end_;
  v5 = end - this->__begin_;
  if (__sz <= v5)
  {
    if (__sz >= v5)
      return;
    v20 = &begin[__sz];
    goto LABEL_15;
  }
  v6 = __sz - v5;
  p_end_cap = &this->__end_cap_;
  value = this->__end_cap_.__value_;
  if (__sz - v5 <= value - end)
  {
    bzero(end, 4 * v6);
    v20 = &end[v6];
LABEL_15:
    this->__end_ = v20;
    return;
  }
  if (__sz >> 62)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  v9 = (char *)value - (char *)begin;
  v10 = v9 >> 1;
  if (v9 >> 1 <= __sz)
    v10 = __sz;
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL)
    v11 = 0x3FFFFFFFFFFFFFFFLL;
  else
    v11 = v10;
  v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)p_end_cap, v11);
  v13 = this->__begin_;
  v14 = this->__end_;
  v15 = &v12[4 * v5];
  v17 = (unsigned int *)&v12[4 * v16];
  bzero(v15, 4 * v6);
  v18 = (unsigned int *)&v15[4 * v6];
  while (v14 != v13)
  {
    v19 = *--v14;
    *((_DWORD *)v15 - 1) = v19;
    v15 -= 4;
  }
  this->__begin_ = (std::vector<unsigned int>::pointer)v15;
  this->__end_ = v18;
  this->__end_cap_.__value_ = v17;
  if (v13)
    operator delete(v13);
}

void VADGenUtils::TwoPoleBandpassCoeff<double>(double *a1, double *a2, double *a3, double a4)
{
  double v7;
  unsigned int v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v18;
  double v19;

  v7 = a4;
  v8 = 0;
  v9 = a4 * 0.5;
  v18 = a4 + -0.0001;
  v19 = a4 + 0.0001;
  do
  {
    v10 = (v9 + v7) * 0.5;
    v11 = 1.0 / ((v10 + 1.0) * (v10 + 1.0));
    v12 = v10 * v11;
    v13 = (v10 * v10 + -1.0) * -2.0 * v11;
    v14 = -((v10 + -1.0) * (v10 + -1.0)) * v11;
    v15 = VADGenUtils::priv_TwopoleBandpass_Evalmagresp<double>(v19, v13, v14, v10 * v11);
    v16 = v15 - VADGenUtils::priv_TwopoleBandpass_Evalmagresp<double>(v18, v13, v14, v12);
    if (v16 < 0.0)
      v9 = (v9 + v7) * 0.5;
    if (v16 > 0.0)
      v7 = v10;
    if (v16 == 0.0)
      break;
  }
  while (v8++ < 0x31);
  *a3 = v12;
  *a1 = v13;
  *a2 = v14;
}

double VADGenUtils::priv_TwopoleBandpass_Evalmagresp<double>(double a1, double a2, double a3, double a4)
{
  double v7;
  double v8;
  __double2 v9;
  __double2 v10;
  __double2 v11;

  v7 = a1 + a1;
  v8 = a1 + a1 + a1;
  v9 = __sincos_stret(a1);
  v10 = __sincos_stret(v7);
  v11 = __sincos_stret(v8);
  return sqrt(((v10.__sinval - v9.__sinval + v11.__sinval) * (v10.__sinval - v9.__sinval + v11.__sinval)+ (v9.__cosval + 1.0 - v10.__cosval - v11.__cosval) * (v9.__cosval + 1.0 - v10.__cosval - v11.__cosval))/ ((v10.__sinval * a3 + a2 * v9.__sinval) * (v10.__sinval * a3 + a2 * v9.__sinval)+ (1.0 - a2 * v9.__cosval - a3 * v10.__cosval) * (1.0 - a2 * v9.__cosval - a3 * v10.__cosval)))* a4;
}

void AULittleLateNightMode::~AULittleLateNightMode(AULittleLateNightMode *this)
{
  void **v2;

  *(_QWORD *)this = &off_1E69C5798;
  v2 = (void **)((char *)this + 592);
  std::vector<std::unique_ptr<OpaqueAudioComponentInstance,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioComponentInstance*,&(AudioComponentInstanceDispose)>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  *(_QWORD *)this = &off_1E69ED840;
  v2 = (void **)((char *)this + 528);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v2);
  ausdk::AUBase::~AUBase(this);
}

{
  void **v2;

  *(_QWORD *)this = &off_1E69C5798;
  v2 = (void **)((char *)this + 592);
  std::vector<std::unique_ptr<OpaqueAudioComponentInstance,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioComponentInstance*,&(AudioComponentInstanceDispose)>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  *(_QWORD *)this = &off_1E69ED840;
  v2 = (void **)((char *)this + 528);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v2);
  ausdk::AUBase::~AUBase(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AULittleLateNightMode::Initialize(int64x2_t *this)
{
  ausdk::AUScope *v2;
  __int32 v3;
  double v4;
  uint64_t v5;
  CFPropertyListRef v7;
  AudioUnit *i;
  uint64_t Element;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  __int32 v13;
  _OWORD v14[2];
  uint64_t v15;
  _OWORD inData[2];
  uint64_t v17;

  v2 = (ausdk::AUScope *)&this[5];
  v3 = *(__int16 *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[5], 0) + 108);
  if (v3 != *(__int16 *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[8], 0) + 108))
    return 4294956428;
  this[39].i32[0] = v3;
  v4 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[8], 0) + 80);
  if (v4 != *(double *)(ausdk::AUScope::SafeGetElement(v2, 0) + 80))
    return 4294956428;
  if (!this[38].i8[8])
  {
    v7 = presetCreateForNumberOfChannels(this[39].u32[0], this[39].u8[12]);
    v5 = (*(uint64_t (**)(int64x2_t *, CFPropertyListRef))(this->i64[0] + 288))(this, v7);
    CFRelease(v7);
    if ((_DWORD)v5)
      return v5;
  }
  for (i = (AudioUnit *)this[37].i64[0]; i != (AudioUnit *)this[37].i64[1]; ++i)
  {
    Element = ausdk::AUScope::SafeGetElement(v2, 0);
    v10 = *(_OWORD *)(Element + 96);
    inData[0] = *(_OWORD *)(Element + 80);
    inData[1] = v10;
    v17 = *(_QWORD *)(Element + 112);
    v11 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[8], 0);
    v12 = *(_OWORD *)(v11 + 96);
    v14[0] = *(_OWORD *)(v11 + 80);
    v14[1] = v12;
    v15 = *(_QWORD *)(v11 + 112);
    v13 = this[21].i32[0];
    if (AudioUnitSetProperty(*i, 8u, 1u, 0, inData, 0x28u)
      || AudioUnitSetProperty(*i, 8u, 2u, 0, v14, 0x28u)
      || AudioUnitSetProperty(*i, 0xEu, 0, 0, &v13, 4u)
      || AudioUnitInitialize(*i))
    {
      break;
    }
  }
  return ausdk::AUEffectBase::Initialize(this);
}

uint64_t AULittleLateNightMode::Cleanup(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  BOOL v4;

  v1 = *(_QWORD *)(this + 592);
  v2 = *(_QWORD *)(this + 600);
  if (v1 != v2)
  {
    v3 = v1 + 8;
    do
    {
      this = AudioUnitUninitialize(*(AudioUnit *)(v3 - 8));
      if ((_DWORD)this)
        v4 = 1;
      else
        v4 = v3 == v2;
      v3 += 8;
    }
    while (!v4);
  }
  return this;
}

uint64_t AULittleLateNightMode::Reset(AULittleLateNightMode *this)
{
  AudioUnit *v2;
  AudioUnit *i;
  _QWORD *v4;
  _QWORD *v5;

  v2 = (AudioUnit *)*((_QWORD *)this + 74);
  for (i = (AudioUnit *)*((_QWORD *)this + 75);
        v2 != i && !AudioUnitReset(*v2, 0, 0);
        i = (AudioUnit *)*((_QWORD *)this + 75))
  {
    ++v2;
  }
  v4 = (_QWORD *)*((_QWORD *)this + 66);
  v5 = (_QWORD *)*((_QWORD *)this + 67);
  while (v4 != v5)
  {
    if (*v4)
      (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 16))(*v4);
    ++v4;
  }
  return 0;
}

uint64_t AULittleLateNightMode::GetPropertyInfo(AULittleLateNightMode *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  unsigned int v7;
  BOOL v8;

  if (a3)
    return 4294956417;
  v7 = 4;
  v8 = 1;
  result = 4294956417;
  if (a2 > 6619)
  {
    if (a2 != 1635022431 && a2 != 6625)
    {
      if (a2 != 6620)
        return result;
      v8 = 0;
      v7 = 8;
    }
    goto LABEL_10;
  }
  if (a2 == 21 || a2 == 29)
  {
LABEL_10:
    result = 0;
    *a6 = v8;
    *a5 = v7;
  }
  return result;
}

uint64_t AULittleLateNightMode::GetProperty(AULittleLateNightMode *this, const __CFString *a2, int a3, AudioUnitElement a4, _QWORD *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  int v10;
  UInt32 ioDataSize;
  uint64_t v13;
  uint64_t v14;

  if (a3)
    return 4294956417;
  v13 = v5;
  v14 = v6;
  result = 4294956417;
  if ((int)a2 <= 6619)
  {
    if ((_DWORD)a2 == 21)
    {
      result = 0;
      v10 = *((unsigned __int8 *)this + 552);
    }
    else
    {
      if ((_DWORD)a2 != 29)
        return result;
      result = 0;
      v10 = *((unsigned __int8 *)this + 554);
    }
    goto LABEL_15;
  }
  if ((_DWORD)a2 == 6620)
  {
    result = 0;
    *a5 = (char *)this + 592;
    return result;
  }
  if ((_DWORD)a2 != 6625)
  {
    if ((_DWORD)a2 != 1635022431)
      return result;
    result = 0;
    v10 = *((unsigned __int8 *)this + 636);
LABEL_15:
    *(_DWORD *)a5 = v10;
    return result;
  }
  result = (uint64_t)AULittleLateNightMode::findAudioUnitWithSubType(this, a2);
  if (result)
  {
    ioDataSize = 4;
    AudioUnitGetProperty((AudioUnit)result, 0x19E1u, 0, a4, a5, &ioDataSize);
    return 0;
  }
  return result;
}

uint64_t AULittleLateNightMode::SetProperty(AULittleLateNightMode *this, const __CFString *a2, int a3, unsigned int a4, int *a5, unsigned int a6)
{
  OpaqueAudioComponentInstance *AudioUnitWithSubType;

  if (a3)
    return ausdk::AUEffectBase::SetProperty(this, (int)a2, a3, a4, a5, a6);
  if ((_DWORD)a2 == 6625)
  {
    AudioUnitWithSubType = AULittleLateNightMode::findAudioUnitWithSubType(this, a2);
    if (AudioUnitWithSubType)
      AudioUnitSetProperty(AudioUnitWithSubType, 0x19E1u, 0, a4, a5, a6);
  }
  else
  {
    if ((_DWORD)a2 != 1635022431)
    {
      a3 = 0;
      return ausdk::AUEffectBase::SetProperty(this, (int)a2, a3, a4, a5, a6);
    }
    *((_BYTE *)this + 636) = *a5 != 0;
  }
  return 0;
}

uint64_t AULittleLateNightMode::SetParameter(AULittleLateNightMode *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  OpaqueAudioComponentInstance *v10;
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  AudioUnitParameterID inID[2];

  if (a2 <= 1)
  {
    if (a2 == 1)
      *((float *)this + 158) = DspLib::dB2Amp(this, a5);
    else
      *((float *)this + 157) = DspLib::dB2Amp(this, a5);
    goto LABEL_7;
  }
  *(_QWORD *)inID = 0;
  v10 = AULittleLateNightMode::audioUnitForParameterID(this, a2 - 2, &inID[1], inID);
  if (v10)
  {
    AudioUnitSetParameter(v10, inID[0], 0, 0, a5, 0);
LABEL_7:
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
    return 0;
  }
  return 4294956418;
}

uint64_t ausdk::AUEffectBase::CanScheduleParameters(ausdk::AUEffectBase *this)
{
  return 1;
}

uint64_t AULittleLateNightMode::ProcessBufferLists(AULittleLateNightMode *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *ioData, vDSP_Length __N)
{
  uint64_t result;
  UInt32 v7;
  unint64_t v9;
  unint64_t v10;
  void **p_mData;
  void **v12;
  __int128 v13;
  __int128 v14;
  unint64_t v15;
  void **v16;
  float *v17;
  AudioUnit *v18;
  AudioUnit *v19;
  unint64_t v20;
  void **v21;
  float *v22;
  AudioUnitRenderActionFlags ioActionFlags;
  AudioTimeStamp inTimeStamp;

  if (*((_DWORD *)this + 84) < __N)
    return 4294956422;
  if (!*((_BYTE *)this + 17))
    return 4294956421;
  v7 = __N;
  v9 = *((unsigned int *)this + 156);
  if ((_DWORD)v9)
  {
    v10 = 0;
    p_mData = &ioData->mBuffers[0].mData;
    v12 = &a3->mBuffers[0].mData;
    do
    {
      if (v7 && *v12 != *p_mData)
      {
        memmove(*p_mData, *v12, 4 * v7);
        v9 = *((unsigned int *)this + 156);
      }
      ++v10;
      p_mData += 2;
      v12 += 2;
    }
    while (v10 < v9);
  }
  else
  {
    v9 = 0;
  }
  if (*((_BYTE *)this + 552))
    return 0;
  v13 = *((_OWORD *)this + 18);
  *(_OWORD *)&inTimeStamp.mSampleTime = *((_OWORD *)this + 17);
  *(_OWORD *)&inTimeStamp.mRateScalar = v13;
  v14 = *((_OWORD *)this + 20);
  *(_OWORD *)&inTimeStamp.mSMPTETime.mSubframes = *((_OWORD *)this + 19);
  *(_OWORD *)&inTimeStamp.mSMPTETime.mHours = v14;
  ioActionFlags = 512;
  if (v9)
  {
    v15 = 0;
    v16 = &ioData->mBuffers[0].mData;
    do
    {
      v17 = (float *)*v16;
      v16 += 2;
      DspLib::multiply(v17, v7, *((float *)this + 157));
      ++v15;
      v9 = *((unsigned int *)this + 156);
    }
    while (v15 < v9);
  }
  v18 = (AudioUnit *)*((_QWORD *)this + 74);
  v19 = (AudioUnit *)*((_QWORD *)this + 75);
  if (v18 == v19)
  {
LABEL_21:
    if ((_DWORD)v9)
    {
      v20 = 0;
      v21 = &ioData->mBuffers[0].mData;
      do
      {
        v22 = (float *)*v21;
        v21 += 2;
        DspLib::multiply(v22, v7, *((float *)this + 158));
        ++v20;
      }
      while (v20 < *((unsigned int *)this + 156));
    }
    return 0;
  }
  while (1)
  {
    result = AudioUnitProcess(*v18, &ioActionFlags, &inTimeStamp, v7, ioData);
    if ((_DWORD)result)
      return result;
    if (++v18 == v19)
    {
      LODWORD(v9) = *((_DWORD *)this + 156);
      goto LABEL_21;
    }
  }
}

uint64_t AULittleLateNightMode::GetParameterInfo(AULittleLateNightMode *this, AudioUnitScope a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  char *v5;
  uint64_t v6;
  AudioUnitParameterOptions *p_flags;
  const __CFString *v8;
  uint64_t result;
  OpaqueAudioComponentInstance *v11;
  AudioUnitElement inElement;
  unsigned int v13;
  UInt32 ioDataSize;

  ioDataSize = 104;
  if (a3 <= 1)
  {
    v5 = (char *)&kAUHostParameters + 104 * a3;
    *(_OWORD *)&buffer->clumpID = *((_OWORD *)v5 + 4);
    *(_OWORD *)&buffer->name[48] = *((_OWORD *)v5 + 3);
    *(_OWORD *)&buffer->unit = *((_OWORD *)v5 + 5);
    *(_OWORD *)buffer->name = *(_OWORD *)v5;
    *(_OWORD *)&buffer->name[16] = *((_OWORD *)v5 + 1);
    *(_OWORD *)&buffer->name[32] = *((_OWORD *)v5 + 2);
    v6 = *((_QWORD *)v5 + 12);
    *(_QWORD *)&buffer->flags = v6;
    p_flags = &buffer->flags;
    v8 = (const __CFString *)*((_QWORD *)v5 + 9);
    buffer->cfNameString = v8;
    buffer->flags = v6 | 0x8000010;
    CFStringGetCString(v8, buffer->name, 52, 0x8000100u);
    result = 0;
    buffer->clumpID = 0;
LABEL_5:
    *p_flags |= 0x100000u;
    return result;
  }
  inElement = 0;
  v13 = 0;
  v11 = AULittleLateNightMode::audioUnitForParameterID(this, a3 - 2, &v13, &inElement);
  if (v11)
  {
    result = AudioUnitGetProperty(v11, 4u, a2, inElement, buffer, &ioDataSize);
    buffer->clumpID = v13 + 1;
    p_flags = &buffer->flags;
    goto LABEL_5;
  }
  return 4294956421;
}

uint64_t AULittleLateNightMode::SaveState(AULittleLateNightMode *this, ausdk **a2)
{
  ausdk::AUBase::SaveState(this, a2);
  return 0;
}

uint64_t AULittleLateNightMode::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t v3;
  uint64_t v4;
  float Parameter;

  v3 = ausdk::AUBase::RestoreState(this, a2);
  if (*((_DWORD *)this + 155))
  {
    v4 = 0;
    do
    {
      Parameter = ausdk::AUEffectBase::GetParameter((ausdk::AUEffectBase *)this, v4);
      (*((void (**)(OpaqueAudioComponentInstance **, uint64_t, _QWORD, _QWORD, _QWORD, float))*this + 19))(this, v4, 0, 0, 0, Parameter);
      v4 = (v4 + 1);
    }
    while (v4 < *((_DWORD *)this + 155));
  }
  *((_BYTE *)this + 616) = 1;
  return v3;
}

uint64_t AULittleLateNightMode::CopyClumpName(AULittleLateNightMode *this, int a2, unsigned int a3, unsigned int a4, const __CFString **a5)
{
  uint64_t v6;
  OpaqueAudioComponent *Component;

  if (a2)
    return 4294956430;
  if (!a3)
    return 4294956428;
  v6 = *((_QWORD *)this + 74);
  if (a3 > (unint64_t)((*((_QWORD *)this + 75) - v6) >> 3))
    return 4294956428;
  Component = AudioComponentInstanceGetComponent(*(AudioComponentInstance *)(v6 + 8 * (a3 - 1)));
  AudioComponentCopyName(Component, a5);
  return 0;
}

double AULittleLateNightMode::GetLatency(AULittleLateNightMode *this)
{
  AudioUnit *v1;
  double v3;
  OSStatus Property;
  UInt32 ioDataSize;
  double outData;

  v1 = (AudioUnit *)*((_QWORD *)this + 74);
  if (v1 == *((AudioUnit **)this + 75))
    return 0.0;
  v3 = 0.0;
  while (1)
  {
    outData = 0.0;
    ioDataSize = 8;
    Property = AudioUnitGetProperty(*v1, 0xCu, 0, 0, &outData, &ioDataSize);
    if (Property)
      break;
    v3 = v3 + outData;
    if (++v1 == *((AudioUnit **)this + 75))
      return v3;
  }
  return (double)Property;
}

double AULittleLateNightMode::GetTailTime(AULittleLateNightMode *this)
{
  AudioUnit *v1;
  double v3;
  OSStatus Property;
  UInt32 ioDataSize;
  double outData;

  v1 = (AudioUnit *)*((_QWORD *)this + 74);
  if (v1 == *((AudioUnit **)this + 75))
    return 0.0;
  v3 = 0.0;
  while (1)
  {
    outData = 0.0;
    ioDataSize = 8;
    Property = AudioUnitGetProperty(*v1, 0x14u, 0, 0, &outData, &ioDataSize);
    if (Property)
      break;
    v3 = v3 + outData;
    if (++v1 == *((AudioUnit **)this + 75))
      return v3;
  }
  return (double)Property;
}

uint64_t AULittleLateNightMode::SupportsTail(AULittleLateNightMode *this)
{
  return 1;
}

uint64_t AULittleLateNightMode::SupportedNumChannels(AULittleLateNightMode *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AULittleLateNightMode::SupportedNumChannels(AUChannelInfo const**)::kSupportedNumChannels;
  return 32;
}

uint64_t AULittleLateNightMode::SetAudioChannelLayout(AULittleLateNightMode *this, unsigned int a2, unsigned int a3, const AudioChannelLayout *a4)
{
  return 0;
}

void ausdk::AUEffectBase::NewKernel(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t ausdk::AUEffectBase::SetBypassEffect(uint64_t this, char a2)
{
  *(_BYTE *)(this + 552) = a2;
  return this;
}

uint64_t ausdk::AUEffectBase::ShouldBypassEffect(ausdk::AUEffectBase *this)
{
  return *((unsigned __int8 *)this + 552);
}

float ausdk::AUEffectBase::GetParameter(ausdk::AUEffectBase *this, unsigned int a2)
{
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  ausdk::AUElement ***v7;

  v4 = *((_QWORD *)this + 9);
  if (v4)
  {
    v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  }
  else
  {
    v7 = (ausdk::AUElement ***)((char *)this + 48);
    v6 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (v7[1] == v6)
      v5 = 0;
    else
      v5 = *v6;
  }
  return ausdk::AUElement::GetParameter(v5, a2);
}

OpaqueAudioComponentInstance *AULittleLateNightMode::audioUnitForParameterID(AULittleLateNightMode *this, unsigned int a2, unsigned int *a3, unsigned int *a4)
{
  OpaqueAudioComponentInstance **v4;
  unsigned int v9;
  OpaqueAudioComponentInstance *v10;
  UInt32 outDataSize;

  *a3 = 0;
  v4 = (OpaqueAudioComponentInstance **)*((_QWORD *)this + 74);
  if (v4 == *((OpaqueAudioComponentInstance ***)this + 75))
    return 0;
  v9 = 0;
  while (1)
  {
    *a4 = a2 - v9;
    v10 = *v4;
    outDataSize = 0;
    AudioUnitGetPropertyInfo(v10, 3u, 0, 0, &outDataSize, 0);
    v9 += outDataSize >> 2;
    if (v9 > a2)
      break;
    ++*a3;
    if (++v4 == *((OpaqueAudioComponentInstance ***)this + 75))
      return 0;
  }
  return *v4;
}

AudioComponentInstance AULittleLateNightMode::findAudioUnitWithSubType(AULittleLateNightMode *this, const __CFString *a2)
{
  int v3;
  AudioComponentInstance *v4;
  int v5;
  OpaqueAudioComponent *Component;
  AudioComponentDescription outDesc;

  v3 = convertCFStringToOSType(CFSTR("'mozs'"));
  if (!v3)
    return 0;
  v4 = (AudioComponentInstance *)*((_QWORD *)this + 74);
  if (v4 == *((AudioComponentInstance **)this + 75))
    return 0;
  v5 = v3;
  while (1)
  {
    Component = AudioComponentInstanceGetComponent(*v4);
    AudioComponentGetDescription(Component, &outDesc);
    if (v5 == outDesc.componentSubType)
      break;
    if (++v4 == *((AudioComponentInstance **)this + 75))
      return 0;
  }
  return *v4;
}

uint64_t convertCFStringToOSType(const __CFString *a1)
{
  uint64_t v2;
  int v3;
  CFIndex i;

  if (!a1 || CFStringGetLength(a1) < 6)
    return 0;
  LODWORD(v2) = 0;
  v3 = 24;
  for (i = 1; i != 5; ++i)
  {
    v2 = (CFStringGetCharacterAtIndex(a1, i) << v3) + (int)v2;
    v3 -= 8;
  }
  return v2;
}

CFPropertyListRef presetCreateForNumberOfChannels(unsigned int a1, int a2)
{
  char *v2;
  const UInt8 *v3;
  CFIndex v4;
  const __CFData *v5;
  CFPropertyListRef v6;

  v2 = MAC_stereo_Mitch_2017_05_22_aupreset;
  if (a2)
    v2 = (char *)&ATV_stereo_2017_05_22_aupreset;
  if (a1 <= 2)
    v3 = (const UInt8 *)v2;
  else
    v3 = (const UInt8 *)&ATV_MAC_surround_2017_05_22_aupreset;
  if (a1 <= 2)
    v4 = 1013;
  else
    v4 = 1019;
  v5 = CFDataCreate(0, v3, v4);
  v6 = CFPropertyListCreateWithData(0, v5, 0, 0, 0);
  CFRelease(v5);
  return v6;
}

void std::vector<std::unique_ptr<OpaqueAudioComponentInstance,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioComponentInstance*,&(AudioComponentInstanceDispose)>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  OpaqueAudioComponentInstance **v2;
  OpaqueAudioComponentInstance **v4;
  void *v5;

  v1 = *a1;
  v2 = (OpaqueAudioComponentInstance **)**a1;
  if (v2)
  {
    v4 = (OpaqueAudioComponentInstance **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<OpaqueAudioComponentInstance,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioComponentInstance*,&(AudioComponentInstanceDispose)>>::reset[abi:ne180100](--v4);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

OpaqueAudioComponentInstance *std::unique_ptr<OpaqueAudioComponentInstance,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioComponentInstance*,&(AudioComponentInstanceDispose)>>::reset[abi:ne180100](OpaqueAudioComponentInstance **a1)
{
  OpaqueAudioComponentInstance *result;

  result = *a1;
  *a1 = 0;
  if (result)
    return (OpaqueAudioComponentInstance *)AudioComponentInstanceDispose(result);
  return result;
}

float lmsfilt_v3::preemphasisFilter(lmsfilt_v3 *this, const float *a2, float *a3, float *a4, float *a5)
{
  int v7;
  int v9;
  float result;
  float __B;

  v7 = (int)a2;
  __B = -0.9;
  v9 = (_DWORD)a2 - 1;
  memcpy(a4 + 1, this, 4 * ((int)a2 - 1));
  vDSP_vsma(a4, 1, &__B, (const float *)this, 1, a4, 1, v7);
  *a4 = *(float *)this + (float)(__B * *a3);
  result = *((float *)this + v9);
  *a3 = result;
  return result;
}

void lmsfilt_v3::initLmsFilter(int a1, int a2, int a3, uint64_t a4, float ***a5)
{
  int v9;
  int v10;
  _QWORD *v11;
  int v12;
  int v13;
  float *v14;
  float *v16;
  float *v17;
  float *v19;
  float *v20;
  float *v22;
  float *v23;
  float *v24;
  float *v25;
  float *v26;
  float **v27;
  int v28;
  int v29;
  int v30;
  std::bad_alloc *exception;
  std::bad_alloc *v32;
  float __A;

  __A = 0.0;
  v9 = *(_DWORD *)(a4 + 16);
  v10 = *(_DWORD *)(a4 + 44);
  v11 = malloc_type_malloc(0x58uLL, 0x2C8E6D5CuLL);
  if (!v11)
    goto LABEL_28;
  v11[10] = 0;
  *((_OWORD *)v11 + 3) = 0u;
  *((_OWORD *)v11 + 4) = 0u;
  *((_OWORD *)v11 + 1) = 0u;
  *((_OWORD *)v11 + 2) = 0u;
  *(_OWORD *)v11 = 0u;
  *a5 = (float **)v11;
  v12 = v10 * v9;
  *((_DWORD *)v11 + 8) = v10;
  *((_DWORD *)v11 + 9) = v10 * v9;
  v13 = 4 * v10 * v9;
  v14 = (float *)malloc_type_malloc(v13, 0x2C8E6D5CuLL);
  if (v13 && v14 == 0)
    goto LABEL_28;
  v16 = v14;
  bzero(v14, v13);
  **a5 = v16;
  v17 = (float *)malloc_type_malloc(v13, 0x2C8E6D5CuLL);
  if (v13 && v17 == 0)
    goto LABEL_28;
  v19 = v17;
  bzero(v17, v13);
  (*a5)[1] = v19;
  v20 = (float *)malloc_type_malloc(v13, 0x2C8E6D5CuLL);
  if (v13 && v20 == 0)
    goto LABEL_28;
  v22 = v20;
  bzero(v20, v13);
  (*a5)[2] = v22;
  v23 = (float *)malloc_type_malloc(v13, 0x2C8E6D5CuLL);
  v24 = v23;
  if (v13)
  {
    if (!v23)
      goto LABEL_28;
  }
  bzero(v23, v13);
  (*a5)[3] = v24;
  v25 = (float *)malloc_type_malloc(v13, 0x2C8E6D5CuLL);
  v26 = v25;
  if (v13)
  {
    if (!v25)
    {
LABEL_28:
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v32 = std::bad_alloc::bad_alloc(exception);
    }
  }
  bzero(v25, v13);
  (*a5)[6] = v26;
  vDSP_vfill(&__A, **a5, 1, v12);
  vDSP_vfill(&__A, (*a5)[1], 1, v12);
  vDSP_vfill(&__A, (*a5)[2], 1, v12);
  vDSP_vfill(&__A, (*a5)[3], 1, v12);
  vDSP_vfill(&__A, (*a5)[6], 1, v12);
  v27 = *a5;
  *((float *)v27 + 10) = (float)(1.0 - *(float *)(a4 + 88)) + (float)(1.0 - *(float *)(a4 + 88));
  *((_DWORD *)v27 + 11) = 1;
  v27[7] = 0;
  *((_DWORD *)v27 + 16) = 0;
  *((_DWORD *)v27 + 17) = a1;
  *((_DWORD *)v27 + 18) = 0;
  *((_DWORD *)v27 + 19) = v10 - 1;
  v28 = a3 / v9;
  if (a3 / v9 >= v10)
    v28 = v10;
  v29 = (a3 - a2) / v9;
  *((_DWORD *)v27 + 20) = v29;
  *((_DWORD *)v27 + 21) = v28;
  if (v28 - v29 <= 1)
  {
    if (v10 == 4)
      v30 = -1;
    else
      v30 = 0;
    if (v10 > 4)
      v30 = -2;
    *((_DWORD *)v27 + 20) = v28 + v30;
  }
}

void lmsfilt_v3::removeLmsFilter(uint64_t *a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      if (*(_QWORD *)v2)
      {
        free(*(void **)v2);
        *(_QWORD *)v2 = 0;
        v2 = *a1;
      }
      v3 = *(void **)(v2 + 8);
      if (v3)
      {
        free(v3);
        *(_QWORD *)(v2 + 8) = 0;
        v2 = *a1;
      }
      v4 = *(void **)(v2 + 16);
      if (v4)
      {
        free(v4);
        *(_QWORD *)(v2 + 16) = 0;
        v2 = *a1;
      }
      v5 = *(void **)(v2 + 24);
      if (v5)
      {
        free(v5);
        *(_QWORD *)(v2 + 24) = 0;
        v2 = *a1;
      }
      v6 = *(void **)(v2 + 48);
      if (!v6 || (free(v6), *(_QWORD *)(v2 + 48) = 0, (v2 = *a1) != 0))
      {
        free((void *)v2);
        *a1 = 0;
      }
    }
  }
}

void lmsfilt_v3::runLmsFilter_v3(DSPSplitComplex *this, DSPSplitComplex *a2, uint64_t a3, uint64_t a4, uint64_t a5, float *a6, float *a7, float *a8, float *a9, int *a10, int a11, int a12)
{
  int v12;
  int v18;
  DSPSplitComplex *v19;
  vDSP_Length __N;
  float v21;
  float v22;
  int v23;
  float *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  float *v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  float *v35;
  DSPSplitComplex *v36;
  DSPSplitComplex __B;
  DSPSplitComplex __A;
  DSPSplitComplex __D;

  v12 = (int)a8;
  v18 = (int)a2;
  v19 = this;
  __D = *this;
  __N = (int)a2;
  vDSP_vclr(__D.realp, 1, (int)a2);
  vDSP_vclr(v19->imagp, 1, __N);
  v21 = 0.0;
  v22 = 0.0;
  if (v12 <= (int)a9)
  {
    v35 = a7;
    v36 = v19;
    v33 = v12 * v18;
    v34 = v12;
    v32 = (_DWORD)a9 - v12;
    v23 = (_DWORD)a9 - v12 + 1;
    v24 = &a7[v12];
    v25 = 4 * v33;
    v26 = 4 * __N;
    do
    {
      v27 = *(_DWORD *)v24++;
      __A.realp = (float *)(a3 + v25);
      __A.imagp = (float *)(a4 + v25);
      __B.realp = (float *)(a5 + 4 * v27 * v18);
      __B.imagp = &a6[v27 * v18];
      vDSP_zvma(&__A, 1, &__B, 1, &__D, 1, &__D, 1, __N);
      v25 += v26;
      --v23;
    }
    while (v23);
    v28 = v32 + 1;
    v29 = 4 * v33;
    v22 = 0.0;
    v21 = 0.0;
    v19 = v36;
    v30 = &v35[v34];
    do
    {
      v31 = *(_DWORD *)v30++;
      v21 = v21 + (float)(*(float *)(a3 + v29) * *(float *)(a5 + 4 * v31 * v18));
      v22 = v22 + (float)(*(float *)(a4 + v29) * a6[v31 * v18]);
      v29 += v26;
      --v28;
    }
    while (v28);
  }
  *v19->realp = v21;
  *v19->imagp = v22;
}

void std::default_delete<NoiseSuppression::Noise::LPCPitch>::operator()[abi:ne180100](_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;

  v2 = (void *)a1[18];
  if (v2)
  {
    a1[19] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[15];
  if (v3)
  {
    a1[16] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[12];
  if (v4)
  {
    a1[13] = v4;
    operator delete(v4);
  }
  v5 = (void *)a1[9];
  if (v5)
  {
    a1[10] = v5;
    operator delete(v5);
  }
  v6 = a1[8];
  a1[8] = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 6));
  JUMPOUT(0x1BCC95CECLL);
}

NoiseSuppression::Noise::VPv3 *NoiseSuppression::Noise::VPv3::VPv3(NoiseSuppression::Noise::VPv3 *this, float a2, int a3, float a4)
{
  _OWORD *v6;

  *((float *)this + 2) = a2;
  *((_DWORD *)this + 3) = a3;
  *((float *)this + 4) = a4;
  *((_DWORD *)this + 5) = 0;
  *((_BYTE *)this + 24) = 0;
  *((_DWORD *)this + 7) = 981668463;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_QWORD *)this = &off_1E69CBB38;
  *((_DWORD *)this + 20) = 1025758986;
  *((_DWORD *)this + 22) = 0;
  *(_QWORD *)((char *)this + 92) = 0x3F0000003EAA7EFALL;
  *((_QWORD *)this + 13) = 0x4140000042480000;
  *((_DWORD *)this + 28) = 0x40000000;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 15) = 0;
  *((float *)this + 36) = a2;
  *((_DWORD *)this + 37) = a3;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 19) = 0;
  v6 = operator new(0x30uLL);
  *((_QWORD *)this + 20) = v6 + 3;
  *((_QWORD *)this + 21) = v6 + 3;
  *v6 = xmmword_1B66A04E0;
  v6[1] = xmmword_1B66A04F0;
  *((_QWORD *)v6 + 4) = 0x40E00000453B8000;
  *((_DWORD *)v6 + 11) = 1088421888;
  *((_QWORD *)this + 19) = v6;
  *((float *)v6 + 10) = a2 * 0.5;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  return this;
}

void sub_1B6102AC0(_Unwind_Exception *a1)
{
  NoiseSuppression::Noise::NoiseEstimator *v1;

  NoiseSuppression::Noise::NoiseEstimator::~NoiseEstimator(v1);
  _Unwind_Resume(a1);
}

VPTimeFreqConverter *std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100](VPTimeFreqConverter **a1, VPTimeFreqConverter *a2)
{
  VPTimeFreqConverter *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void NoiseSuppression::Noise::NoiseEstimator::~NoiseEstimator(NoiseSuppression::Noise::NoiseEstimator *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = off_1E69E6580;
  v2 = (void *)*((_QWORD *)this + 7);
  if (v2)
    operator delete(v2);
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
  {
    *((_QWORD *)this + 5) = v3;
    operator delete(v3);
  }
}

uint64_t NoiseSuppression::Noise::NoiseEstimator::GetNoiseBins(NoiseSuppression::Noise::NoiseEstimator *this)
{
  return (uint64_t)this + 56;
}

float NoiseSuppression::Noise::NoiseEstimator::GetNoiseMinInit(NoiseSuppression::Noise::NoiseEstimator *this)
{
  return *((float *)this + 7);
}

uint64_t NoiseSuppression::Noise::NoiseEstimator::SetNoiseMinInit(uint64_t this, float a2)
{
  *(float *)(this + 28) = a2;
  return this;
}

uint64_t NoiseSuppression::Noise::LPCLevinson::Init(NoiseSuppression::Noise::LPCLevinson *this)
{
  IIRFilterFloat32 *v2;
  uint64_t v3;
  IIRFilterFloat32 *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  uint64_t v18;
  int64x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64x2_t v27;
  double v28;
  float v29;
  float v30;
  uint64_t result;
  int64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  int64x2_t v35;
  uint64x2_t v36;
  int64x2_t v37;
  float v38;
  uint64x2_t v39;
  float v40;
  double v41;
  int32x2_t v42;
  int32x2_t v43;
  int64x2_t v44;
  int64x2_t v45;
  int v46;
  AudioStreamBasicDescription v47;
  AudioStreamBasicDescription v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD v53[2];
  __int128 v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  *((_BYTE *)this + 8) = 0;
  v48.mSampleRate = *((float *)this + 3);
  *(_OWORD *)&v48.mFormatID = xmmword_1B6626900;
  *(_OWORD *)&v48.mBytesPerFrame = xmmword_1B6626910;
  v47.mSampleRate = v48.mSampleRate;
  *(_OWORD *)&v47.mFormatID = xmmword_1B6626900;
  *(_OWORD *)&v47.mBytesPerFrame = xmmword_1B6626910;
  v2 = NewIIRFilter(&v48, &v47, (const CAStreamBasicDescription *)1);
  v3 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = v2;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = NewIIRFilter(&v48, &v47, (const CAStreamBasicDescription *)1);
  v5 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = v4;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 4);
  if (!v6 || !*((_QWORD *)this + 5))
    return 4294956428;
  v53[0] = 0;
  v53[1] = 0;
  v54 = xmmword_1B66A0500;
  v55 = 0;
  v49 = xmmword_1B66A0510;
  v51 = 0;
  v52 = 0;
  v50 = 0x3FF0000000000000;
  (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v6 + 16))(v6, 1, v53);
  (*(void (**)(_QWORD, uint64_t, __int128 *))(**((_QWORD **)this + 5) + 16))(*((_QWORD *)this + 5), 1, &v49);
  std::vector<float>::resize((uint64_t)this + 72, *((unsigned int *)this + 4));
  v7 = *((unsigned int *)this + 4);
  v46 = 0;
  std::vector<float>::assign((char **)this + 9, v7, &v46);
  std::vector<float>::resize((uint64_t)this + 192, (*((_DWORD *)this + 5) + 1));
  std::vector<float>::resize((uint64_t)this + 216, (*((_DWORD *)this + 5) + 1));
  std::vector<float>::resize((uint64_t)this + 48, (2 * *((_DWORD *)this + 4)));
  v8 = (2 * *((_DWORD *)this + 4));
  v46 = 0;
  std::vector<float>::assign((char **)this + 6, v8, &v46);
  std::vector<float>::resize((uint64_t)this + 96, (2 * *((_DWORD *)this + 4)));
  std::vector<float>::resize((uint64_t)this + 120, (uint64_t)(*((_QWORD *)this + 7) - *((_QWORD *)this + 6)) >> 2);
  std::vector<float>::resize((uint64_t)this + 144, (*((_DWORD *)this + 5) + 1));
  v9 = (uint64_t)(*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2;
  v46 = 0;
  std::vector<float>::assign((char **)this + 18, v9, &v46);
  v10 = *((_QWORD *)this + 12);
  v11 = *((_QWORD *)this + 13) - v10;
  if (v11)
  {
    v12 = 0;
    v13 = v11 >> 2;
    v14 = (v13 + 1) & 0xFFFFFFFFFFFFFFFELL;
    v35 = vdupq_n_s64(v13);
    v36 = (uint64x2_t)vdupq_n_s64(v13 - 1);
    v34 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)((float)((float)v13 * 2.0) + -1.0)), 0);
    v15 = (uint64x2_t)xmmword_1B6626830;
    v16 = (float32x2_t)vdup_n_s32(0xBEEB851E);
    v17 = (float32x2_t)vdup_n_s32(0x3F0A3D71u);
    v32 = vdupq_n_s64(2uLL);
    v33 = (float64x2_t)vdupq_n_s64(0x401921FB54442D18uLL);
    do
    {
      v42 = vmovn_s64((int64x2_t)vcgeq_u64(v36, v15));
      v44 = (int64x2_t)v15;
      v18 = v12 + 1;
      v19.i64[0] = v12;
      v19.i64[1] = v12 + 1;
      *(float32x2_t *)v19.i8 = vcvt_f32_f64(vdivq_f64(vmulq_f64(vcvtq_f64_u64((uint64x2_t)vaddq_s64(v19, v35)), v33), v34));
      v38 = *(float *)v19.i32;
      v40 = cosf(*(float *)&v19.i32[1]);
      v20.f32[0] = cosf(v38);
      v20.f32[1] = v40;
      v21 = vmla_f32(v17, v16, v20);
      if ((v42.i8[0] & 1) != 0)
        *(_DWORD *)(v10 + 4 * v12) = v21.i32[0];
      if ((v42.i8[4] & 1) != 0)
        *(_DWORD *)(v10 + 4 * v12 + 4) = v21.i32[1];
      v15 = (uint64x2_t)vaddq_s64(v44, v32);
      v12 += 2;
    }
    while (v18 + 1 != v14);
  }
  std::vector<float>::resize((uint64_t)this + 168, (uint64_t)(*((_QWORD *)this + 28) - *((_QWORD *)this + 27)) >> 2);
  v22 = *((_QWORD *)this + 21);
  v23 = *((_QWORD *)this + 22) - v22;
  if (v23)
  {
    v24 = 0;
    v25 = v23 >> 2;
    if (v25 <= 1)
      v25 = 1;
    v26 = (v25 + 1) & 0xFFFFFFFFFFFFFFFELL;
    v39 = (uint64x2_t)vdupq_n_s64(v25 - 1);
    v27 = (uint64x2_t)xmmword_1B6626830;
    v37 = vdupq_n_s64(2uLL);
    do
    {
      v43 = vmovn_s64((int64x2_t)vcgeq_u64(v39, v27));
      v45 = (int64x2_t)v27;
      v41 = pow(0.949999988, (double)(int)v24);
      v28 = pow(0.949999988, (double)((int)v24 + 1));
      if ((v43.i8[0] & 1) != 0)
      {
        v29 = v41;
        *(float *)(v22 + 4 * v24) = v29;
      }
      if ((v43.i8[4] & 1) != 0)
      {
        v30 = v28;
        *(float *)(v22 + 4 * v24 + 4) = v30;
      }
      v24 += 2;
      v27 = (uint64x2_t)vaddq_s64(v45, v37);
    }
    while (v26 != v24);
  }
  result = 0;
  *((_BYTE *)this + 8) = 1;
  return result;
}

void NoiseSuppression::Noise::LPCLevinson::~LPCLevinson(NoiseSuppression::Noise::LPCLevinson *this)
{
  NoiseSuppression::Noise::LPCLevinson::~LPCLevinson(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)this = &off_1E69C5AD0;
  v2 = (void *)*((_QWORD *)this + 27);
  if (v2)
  {
    *((_QWORD *)this + 28) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 24);
  if (v3)
  {
    *((_QWORD *)this + 25) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 21);
  if (v4)
  {
    *((_QWORD *)this + 22) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 18);
  if (v5)
  {
    *((_QWORD *)this + 19) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 15);
  if (v6)
  {
    *((_QWORD *)this + 16) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 12);
  if (v7)
  {
    *((_QWORD *)this + 13) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 9);
  if (v8)
  {
    *((_QWORD *)this + 10) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 6);
  if (v9)
  {
    *((_QWORD *)this + 7) = v9;
    operator delete(v9);
  }
  v10 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  v11 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
}

void *NoiseSuppression::Noise::LPCLevinson::Process(NoiseSuppression::Noise::LPCLevinson *this, float *a2, NoiseSuppression::Noise::LPCLevinson *a3, float *a4)
{
  _DWORD v8[4];
  NoiseSuppression::Noise::LPCLevinson *v9;
  _DWORD v10[4];
  float *v11;

  if (!*((_BYTE *)this + 24))
    return NoiseSuppression::Noise::LPCLevinson::ProcessBlock(this, a2, a3, a4);
  v10[0] = 1;
  v10[2] = 1;
  v10[3] = 4 * (_DWORD)a4;
  v11 = a2;
  v8[0] = 1;
  v8[2] = 1;
  v8[3] = 4 * (_DWORD)a4;
  v9 = a3;
  (*(void (**)(_QWORD, float *, _DWORD *, _DWORD *))(**((_QWORD **)this + 4) + 32))(*((_QWORD *)this + 4), a4, v10, v8);
  memcpy(*((void **)this + 6), (const void *)(*((_QWORD *)this + 6) + 4 * *((unsigned int *)this + 4)), 4 * *((unsigned int *)this + 4));
  memcpy((void *)(*((_QWORD *)this + 6) + 4 * *((unsigned int *)this + 4)), a3, 4 * *((unsigned int *)this + 4));
  NoiseSuppression::Noise::LPCLevinson::ProcessBlock(this, (float *)a3, *((NoiseSuppression::Noise::LPCLevinson **)this + 9), a4);
  v11 = (float *)*((_QWORD *)this + 9);
  v9 = a3;
  return (void *)(*(uint64_t (**)(_QWORD, float *, _DWORD *, _DWORD *))(**((_QWORD **)this + 5) + 32))(*((_QWORD *)this + 5), a4, v10, v8);
}

uint64_t NoiseSuppression::Noise::LPCLevinson::GetInternalBuffer(NoiseSuppression::Noise::LPCLevinson *this)
{
  return (uint64_t)this + 48;
}

void *NoiseSuppression::Noise::LPCLevinson::ProcessBlock(NoiseSuppression::Noise::LPCLevinson *this, float *a2, NoiseSuppression::Noise::LPCLevinson *a3, float *a4)
{
  float *v8;
  float v9;

  vDSP_vmul(*((const float **)this + 6), 1, *((const float **)this + 12), 1, *((float **)this + 15), 1, (uint64_t)(*((_QWORD *)this + 7) - *((_QWORD *)this + 6)) >> 2);
  NoiseSuppression::Noise::LPCLevinson::Correlation(*((_QWORD *)this + 15), *((_QWORD *)this + 16), (uint64_t)this + 192);
  v8 = (float *)*((_QWORD *)this + 24);
  v9 = (float)(*v8 + 2.2204e-16) * 1.01;
  *v8 = v9;
  NoiseSuppression::Noise::LPCLevinson::Levinson((uint64_t *)this + 24, (uint64_t)this + 216, *((_DWORD *)this + 5));
  return NoiseSuppression::Noise::LPCLevinson::Filter(a3, a2, *((const float **)this + 27), *((float **)this + 18), a4, *((_DWORD *)this + 5));
}

void NoiseSuppression::Noise::LPCLevinson::Correlation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  size_t v5;
  vDSP_Length v6;
  uint64_t v7;
  const float *v8;
  const void *v9;
  _BYTE v10[4];
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a3 + 8) - *(_QWORD *)a3;
  v5 = a2 - a1;
  v6 = (a2 - a1) >> 2;
  MEMORY[0x1E0C80A78](a1);
  v8 = (const float *)&v10[-v7];
  memcpy(&v10[-v7], v9, v5);
  bzero((char *)v8 + v5, v4 - 4);
  v11 = 0;
  std::vector<float>::assign((char **)a3, v4 >> 2, &v11);
  vDSP_conv(v8, 1, v8, 1, *(float **)a3, 1, v4 >> 2, v6);
}

void NoiseSuppression::Noise::LPCLevinson::Levinson(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6;
  char *v7;
  float **v8;
  float v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  float *v17;
  size_t v18;
  uint64_t v19;
  float v20;
  float *v21;
  uint64_t v22;
  float v23;
  float v24;
  float v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  float *v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v33 - v6;
  v9 = **v8;
  v11 = (uint64_t)(v10[1] - *v10) >> 2;
  HIDWORD(v33) = 0;
  std::vector<float>::assign((char **)a2, v11, (_DWORD *)&v33 + 1);
  bzero(v7, 4 * a3);
  if (a3 >= 1)
  {
    v12 = 0;
    v13 = 0;
    v14 = a3;
    v15 = *a1;
    v16 = *(char **)a2;
    v17 = (float *)(*(_QWORD *)a2 + 4);
    v18 = 4 * a3;
    do
    {
      v19 = v13++;
      v20 = *(float *)(v15 + 4 * v13);
      if (v19)
      {
        v21 = v17;
        v22 = v12;
        do
        {
          v23 = *v21++;
          v20 = v20 - (float)(v23 * *(float *)(v15 + v22));
          v22 -= 4;
        }
        while (v22);
        v24 = v20 / v9;
        *(float *)&v16[4 * v13] = v24;
        v25 = -v24;
        v26 = 4;
        v27 = v12;
        do
        {
          *(float *)&v16[v26] = *(float *)&v7[v26 - 4] + (float)(v25 * *(float *)&v7[v27 - 4]);
          v26 += 4;
          v27 -= 4;
        }
        while (v27);
      }
      else
      {
        v24 = v20 / v9;
        *(float *)&v16[4 * v13] = v24;
        v25 = -v24;
      }
      v9 = v9 * (float)((float)(v25 * v24) + 1.0);
      memcpy(v7, v17, v18);
      v12 += 4;
    }
    while (v13 != v14);
  }
  v28 = *(char **)a2;
  v29 = *(_QWORD *)(a2 + 8);
  *(_DWORD *)v28 = 1065353216;
  if ((unint64_t)(v29 - (_QWORD)v28) >= 5)
  {
    v30 = (v29 - (uint64_t)v28) >> 2;
    if (v30 <= 2)
      v30 = 2;
    v31 = v30 - 1;
    v32 = (float *)(v28 + 4);
    do
    {
      *v32 = -*v32;
      ++v32;
      --v31;
    }
    while (v31);
  }
}

void *NoiseSuppression::Noise::LPCLevinson::Filter(NoiseSuppression::Noise::LPCLevinson *this, float *a2, const float *a3, float *a4, float *a5, unsigned int a6)
{
  unsigned int v7;
  uint64_t v12;
  const float *v13;
  const void *v14;
  _QWORD v16[2];

  v7 = a5;
  v16[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](this);
  v13 = (const float *)((char *)v16 - v12);
  memcpy((char *)v16 - v12, v14, 4 * a6);
  memcpy((void *)&v13[a6], a2, 4 * v7);
  vDSP_conv(v13, 1, &a3[a6], -1, (float *)this, 1, v7, a6 + 1);
  return memcpy(a4, &v13[v7], 4 * a6);
}

void NoiseSuppression::Noise::LPCore::TimeBuffer2PowerSpectrum(NoiseSuppression::Noise::LPCore *this, float *a2, float *a3, VPTimeFreqConverter *a4, VPTimeFreqConverter *a5, float *a6, float *a7)
{
  unsigned int v7;
  float v9;
  unsigned __int8 v10;
  DSPSplitComplex v11;

  v7 = a3;
  v11.realp = (float *)a5;
  v11.imagp = a6;
  VPTimeFreqConverter::Analyze(a4, (const float *)this, &v11);
  v9 = *v11.realp;
  vDSP_zvmags(&v11, 1, a2, 1, v7);
  *a2 = v9 * v9;
  if ((v10 & 1) == 0
  {
    NoiseSuppression::Noise::LPCore::TimeBuffer2PowerSpectrum(float *,float *,unsigned int,VPTimeFreqConverter *,float *,float *)::scaleup = 1317011456;
  }
  vDSP_vsmul(a2, 1, (const float *)&NoiseSuppression::Noise::LPCore::TimeBuffer2PowerSpectrum(float *,float *,unsigned int,VPTimeFreqConverter *,float *,float *)::scaleup, a2, 1, v7);
}

void fb::ComplexMat::transposed(fb::ComplexMat *this, const float *a2)
{
  vDSP_Length v2;
  vDSP_Length v3;

  v3 = *(int *)a2;
  v2 = *((int *)a2 + 1);
  *(_DWORD *)this = v2;
  *((_DWORD *)this + 1) = v3;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_QWORD *)this + 25) = 0;
  if ((int)v3 * (int)v2 >= 26)
    __assert_rtn("ComplexMat", "fbComplexMat.h", 41, "mNumRows * mNumCols <= mCapacity");
  vDSP_mtrans(a2 + 2, 2, (float *)this + 2, 2, v2, v3);
  vDSP_mtrans(a2 + 3, 2, (float *)this + 3, 2, *((int *)a2 + 1), *(int *)a2);
}

void fb::ComplexMat::pseudoInverse(fb::ComplexMat *this, const fb::ComplexMat *a2, const fb::ComplexMat *a3)
{
  _BYTE v5[208];
  float v6[52];

  fb::operator*((uint64_t)v6, (const float *)a2, (uint64_t)a3);
  fb::ComplexMat::inversed((fb::ComplexMat *)v5, v6);
  fb::operator*((uint64_t)this, (const float *)a3, (uint64_t)v5);
}

_DWORD *fb::ComplexMat::stabilize(_DWORD *this, float a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  float *v6;

  LODWORD(v2) = *this;
  v3 = this[1];
  if ((signed int)v3 >= *this)
    v2 = v2;
  else
    v2 = v3;
  if ((int)v2 >= 1)
  {
    v4 = 0;
    v5 = v3 + 1;
    do
    {
      if (v4 >= 0x19)
        std::__throw_out_of_range[abi:ne180100]("array::at");
      v6 = (float *)&this[2 * v4 + 2];
      if (*v6 < 0.000000001)
        *(_QWORD *)v6 = 814313567;
      v4 += v5;
      --v2;
    }
    while (v2);
  }
  return this;
}

void fb::operator*(uint64_t a1, const float *a2, uint64_t a3)
{
  vDSP_Length v3;
  vDSP_Length v7;
  vDSP_Length v8;
  float *v9;
  const float *v10;
  const float *v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  vDSP_Length v15;
  vDSP_Length v16;
  float *v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v3 = *((int *)a2 + 1);
  if ((_DWORD)v3 != *(_DWORD *)a3)
    __assert_rtn("operator*", "fbComplexMat.h", 157, "lhs.mNumCols == rhs.mNumRows");
  v7 = *(int *)a2;
  v8 = *(int *)(a3 + 4);
  *(_DWORD *)a1 = v7;
  *(_DWORD *)(a1 + 4) = v8;
  *(_OWORD *)(a1 + 8) = 0u;
  v9 = (float *)(a1 + 8);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_QWORD *)(a1 + 200) = 0;
  if ((int)v8 * (int)v7 >= 26)
    __assert_rtn("ComplexMat", "fbComplexMat.h", 41, "mNumRows * mNumCols <= mCapacity");
  v10 = (const float *)(a3 + 8);
  vDSP_mmul(a2 + 2, 2, (const float *)(a3 + 8), 2, v9, 2, v7, v8, v3);
  v11 = (const float *)(a3 + 4);
  MEMORY[0x1E0C80A78](v12);
  v14 = (float *)((char *)v18 - v13);
  vDSP_mmul(a2 + 3, 2, v11 + 2, 2, (float *)((char *)v18 - v13), 1, v15, v16, *((int *)a2 + 1));
  vDSP_vsub(v14, 1, v9, 2, v9, 2, *(int *)v11 * (uint64_t)*(int *)a2);
  v17 = (float *)(a1 + 12);
  vDSP_mmul(a2 + 3, 2, v10, 2, v17, 2, *(int *)a2, *(int *)v11, *((int *)a2 + 1));
  vDSP_mmul(a2 + 2, 2, v11 + 2, 2, v14, 1, *(int *)a2, *(int *)v11, *((int *)a2 + 1));
  vDSP_vadd(v14, 1, v17, 2, v17, 2, *(int *)v11 * (uint64_t)*(int *)a2);
}

void fb::ComplexMat::inversed(fb::ComplexMat *this, float *a2)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  int v19;
  float32x2_t v20;
  float v21;
  int v22;
  int v23;
  float v24;
  int v25;
  int v26;
  float v27;
  int v28;
  float32x2_t v29;
  float v30;
  float v31;
  float v32;
  float v33;

  if (*(_DWORD *)a2 != *((_DWORD *)a2 + 1))
    __assert_rtn("inversed", "fbComplexMat.h", 132, "mNumRows == mNumCols");
  if (*(_DWORD *)a2 != 2)
    __assert_rtn("inversed", "fbComplexMat.h", 133, "mNumRows == 2");
  v4 = a2[8];
  v5 = a2[9];
  v32 = a2[3];
  v33 = a2[2];
  v6 = std::operator*[abi:ne180100]<float>(v33, v32, v4, v5);
  v8 = v7;
  v9 = a2[6];
  v10 = a2[7];
  v11 = a2[4];
  v12 = a2[5];
  v13 = v6 - std::operator*[abi:ne180100]<float>(v9, v10, v11, v12);
  v15 = v8 - v14;
  if (v13 == 0.0 && v15 == 0.0)
    __assert_rtn("inversed", "fbComplexMat.h", 135, "det != Complexf{0.f}");
  v30 = std::operator/[abi:ne180100]<float>(1.0, 0.0, v13, v15);
  v31 = v16;
  v29 = (float32x2_t)__PAIR64__(LODWORD(v16), LODWORD(v30));
  v17 = std::operator*[abi:ne180100]<float>(v30, v16, v4, v5);
  v19 = v18;
  v20 = vneg_f32(v29);
  v21 = std::operator*[abi:ne180100]<float>(v20.f32[0], v20.f32[1], v11, v12);
  v23 = v22;
  v24 = std::operator*[abi:ne180100]<float>(v20.f32[0], v20.f32[1], v9, v10);
  v26 = v25;
  v27 = std::operator*[abi:ne180100]<float>(v30, v31, v33, v32);
  *(_QWORD *)this = 0x200000002;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_QWORD *)this + 25) = 0;
  *((float *)this + 2) = v17;
  *((_DWORD *)this + 3) = v19;
  *((float *)this + 4) = v21;
  *((_DWORD *)this + 5) = v23;
  *((float *)this + 6) = v24;
  *((_DWORD *)this + 7) = v26;
  *((float *)this + 8) = v27;
  *((_DWORD *)this + 9) = v28;
}

float std::operator*[abi:ne180100]<float>(float a1, float a2, float a3, float a4)
{
  return (float)(a1 * a3) - (float)(a2 * a4);
}

float std::operator/[abi:ne180100]<float>(float a1, float a2, float a3, float a4)
{
  float v4;
  int v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v14;
  float v15;

  v15 = a3;
  v4 = logb(fmaxf(fabsf(a3), fabsf(a4)));
  if ((LODWORD(v4) & 0x7FFFFFFFu) > 0x7F7FFFFF)
  {
    v5 = 0;
    v7 = a4;
  }
  else
  {
    v5 = (int)v4;
    v6 = scalbn(v15, -(int)v4);
    v15 = v6;
    v7 = scalbn(a4, -(int)v4);
  }
  v14 = v7;
  v8 = (float)(v7 * v7) + (float)(v15 * v15);
  v9 = scalbn((float)((float)((float)(v7 * a2) + (float)(a1 * v15)) / v8), -v5);
  scalbn((float)((float)((float)(a2 * v15) - (float)(a1 * v14)) / v8), -v5);
  return v9;
}

void AULando::LRCLsRs::algoUpmixPI(AULando::LRCLsRs *this, AULando::LRCLsRs *a2, const float *__C, float *__E, float *a5, float *a6, float *a7, float *a8, float *a9, _QWORD **a10, AULando::Tools *a11)
{
  uint64_t v16;
  AULando::LRCLsRs *v17;
  uint64_t v18;
  uint64_t v19;
  const float *v20;
  uint64_t v21;
  uint64_t v22;
  const float *v23;
  uint64_t v24;
  uint64_t v25;
  const float *v26;
  uint64_t v27;
  void (*v28)(uint64_t, float);
  float *v29;
  vDSP_Length v30;
  uint64_t v31;
  float *v32;
  float *v33;
  _QWORD v34[5];

  v34[4] = *MEMORY[0x1E0C80C00];
  if ((_BYTE)a9)
  {
    v31 = (uint64_t)&v31;
    v33 = a8;
    MEMORY[0x1E0C80A78](this);
    v17 = (AULando::LRCLsRs *)((char *)&v31 - ((v16 + 15) & 0x7FFFFFFF0));
    MEMORY[0x1E0C80A78](v18);
    v20 = (const float *)((char *)&v31 - v19);
    MEMORY[0x1E0C80A78](v21);
    v23 = (const float *)((char *)&v31 - v22);
    MEMORY[0x1E0C80A78](v24);
    v26 = (const float *)((char *)&v31 - v25);
    v34[2] = v17;
    v34[3] = v20;
    v27 = (uint64_t)*a10;
    v28 = *(void (**)(uint64_t, float))(**a10 + 40);
    v32 = v29;
    v28(v27, 1.0);
    v34[0] = v23;
    v34[1] = v26;
    (*(void (**)(_QWORD *, const float *, _QWORD *, uint64_t, AULando::LRCLsRs *, _QWORD, float))(*a10[1] + 40))(a10[1], __C, v34, 2, this, 0, 1.0);
    BYTE4(v30) = 1;
    LODWORD(v30) = (_DWORD)this;
    AULando::LRCLsRs::decode_PI(v17, v20, v23, v26, __E, a5, a6, v32, v33, v30, v31, SBYTE4(v31));
  }
  else
  {
    BYTE4(a10) = 0;
    LODWORD(a10) = (_DWORD)this;
    AULando::LRCLsRs::decode_PI(a2, (const float *)a2, __C, __C, __E, a5, a6, a7, a8, (vDSP_Length)a10, a11, SBYTE4(a11));
  }
}

void AULando::LRCLsRs::decode_PI(AULando::LRCLsRs *this, const float *a2, const float *__C, const float *a4, float *__E, float *a6, float *a7, float *a8, float *a9, vDSP_Length a10, unsigned int a11, BOOL a12)
{
  float v18;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float __D;
  float __B;

  __D = 0.057827;
  __B = 0.40819;
  vDSP_vsmsma((const float *)this, 1, &__B, __C, 1, &__D, __E, 1, a10);
  v26 = 0.40819;
  v27 = 0.057827;
  vDSP_vsmsma((const float *)this, 1, &v27, __C, 1, &v26, a6, 1, a10);
  v24 = 0.32953;
  v25 = 0.32953;
  vDSP_vsmsma((const float *)this, 1, &v25, __C, 1, &v24, a7, 1, a10);
  if (BYTE4(a10))
    v18 = 1.0;
  else
    v18 = -1.0;
  v22 = v18 * 0.14956;
  v23 = v18 * -0.32752;
  vDSP_vsmsma(a2, 1, &v23, a4, 1, &v22, a8, 1, a10);
  v20 = v18 * 0.32752;
  v21 = v18 * -0.14956;
  vDSP_vsmsma(a2, 1, &v21, a4, 1, &v20, a9, 1, a10);
}

void AULando::LRCLsRs::algoUpmixPISteered(AULando::LRCLsRs *this, unsigned int a2, AULando::LRCLsRs *a3, const float *a4, float *a5, float *a6, float *a7, float *a8, float a9, float a10, float a11, float *a12, BOOL a13, BOOL a14, BOOL a15, BOOL a16, AULando::Tools *a17)
{
  uint64_t v19;
  const float *v20;
  float v21;
  float32x2_t v22;
  vDSP_Length v23;
  float v24;
  AULando::Tools *v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  AULando::Tools *v29;
  unsigned int v30;
  BOOL v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  float v35;
  int v36;
  uint64_t v37;
  float v38;
  int v39;
  int v40;
  int v41;
  vDSP_Length __N;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  float v47;
  float v48;
  _OWORD *v49;
  uint64_t i;
  uint64_t v51;
  uint64_t v52;
  float *v53;
  float v54;
  unsigned int v55;
  uint64_t v56;
  int v57;
  float v58;
  float *v59;
  __int128 v60;
  float *v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  _OWORD *v68;
  uint64_t v69;
  float *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  float *v74;
  uint64_t v75;
  const float *v76;
  uint64_t v77;
  float *v78;
  float *v79;
  float *v80;
  float v81;
  uint64_t v82;
  float v83;
  float v84;
  float v85;
  float v86;
  unsigned int v87;
  float v88;
  unsigned int v89;
  float v90;
  unsigned int v91;
  unsigned int v92;
  float v93;
  unsigned int v94;
  float v95;
  unsigned int v96;
  __int128 v97;
  float *v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  int v104;
  int v105;
  unsigned int v106;
  vDSP_Length v107;
  unsigned int v108;
  BOOL v109;
  float v110;
  float v111;
  unint64_t v112;
  char *v113;
  float v114;
  float v115;
  _BOOL4 v116;
  float v117;
  unsigned int v118;
  uint64_t v119;
  const float *v120;
  IR::FixedIntegerDelay *v121;
  _OWORD *v122;
  IR::FixedIntegerDelay *v123;
  _BOOL4 v124;
  _BOOL4 v125;
  _BOOL4 v126;
  const float *v127;
  _OWORD *v128;
  const float *v129;
  AULando::LRCLsRs *v130;
  uint64_t v131;
  float *v132;
  AULando::Tools *v133;
  float *v134;
  float *v135;
  float *v136;
  float *v137;
  int v138;
  unsigned int *v139;
  int v140;
  const float *v141;
  float *v142;
  float *v143;
  const float *v144;
  float *v145;
  const float *v146;
  const float *v147;
  _BYTE v148[208];
  __int128 v149;
  _OWORD v150[2];
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  float v161;
  uint64_t v162;
  uint64_t v163;
  float v164[52];
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float v172[5];
  _QWORD v173[26];
  _OWORD v174[5];
  _OWORD v175[7];
  uint64_t v176;
  uint64_t v177;

  v117 = a10;
  v134 = a8;
  v135 = a6;
  v136 = a7;
  v137 = a5;
  v129 = a4;
  v130 = a3;
  v147 = (const float *)this;
  v177 = *MEMORY[0x1E0C80C00];
  v118 = a2;
  if (a2)
  {
    v126 = a16;
    BYTE4(v107) = a13;
    LODWORD(v107) = v118;
    v132 = a12;
    AULando::LRCLsRs::decode_PI(v130, (const float *)v130, v129, v129, v137, v135, v136, v134, a12, v107, v108, v109);
    v19 = 0;
    v124 = a15;
    v116 = a14 && a15;
    v114 = 1.0 - a9;
    v115 = a9 + 1.0;
    v127 = v147 + 156;
    v141 = v147 + 52;
    v123 = (AULando::Tools *)((char *)a17 + 16);
    v121 = (AULando::Tools *)((char *)a17 + 72);
    v120 = v147 + 208;
    v112 = v118;
    v113 = (char *)a17 + 240;
    v128 = v150;
    v20 = v147 + 158;
    v125 = a13;
    if (a13)
      v21 = 1.0;
    else
      v21 = -1.0;
    v146 = v147 + 210;
    v122 = v175;
    v111 = 0.01;
    v110 = 0.99;
    v22 = (float32x2_t)vdup_n_s32(0x44800000u);
    v133 = a17;
    do
    {
      v131 = v19;
      v138 = v118 - v19;
      if ((int)(v118 - v19) >= 256)
        v23 = 256;
      else
        v23 = v118 - v19;
      if ((int)v23 <= 0)
        __assert_rtn("algoUpmixPISteered", "AULando_LRCLsRs.cpp", 95, "N1 > 0");
      v163 = 0;
      v162 = 0;
      v161 = 0.0;
      v119 = v19;
      LODWORD(v174[0]) = 0;
      vDSP_normalize(&v137[v19], 1, 0, 1, (float *)v174, (float *)&v163 + 1, v23);
      vDSP_normalize(&v135[v119], 1, 0, 1, (float *)v174, (float *)&v163, v23);
      vDSP_normalize(&v136[v119], 1, 0, 1, (float *)v174, (float *)&v162 + 1, v23);
      vDSP_normalize(&v134[v119], 1, 0, 1, (float *)v174, (float *)&v162, v23);
      vDSP_normalize(&v132[v119], 1, 0, 1, (float *)v174, &v161, v23);
      *((float *)&v163 + 1) = v115 * (float)(*((float *)&v163 + 1) * *((float *)&v163 + 1));
      *(float *)&v163 = v115 * (float)(*(float *)&v163 * *(float *)&v163);
      *((float *)&v162 + 1) = v115 * (float)(*((float *)&v162 + 1) * *((float *)&v162 + 1));
      *(float *)&v162 = v114 * (float)(*(float *)&v162 * *(float *)&v162);
      v161 = v114 * (float)(v161 * v161);
      v172[0] = *((float *)&v163 + 1);
      LODWORD(v172[1]) = v163;
      v172[2] = *((float *)&v162 + 1);
      LODWORD(v172[3]) = v162;
      v172[4] = v161;
      v24 = 1.0;
      if (v116)
      {
        v25 = v133;
        v26 = (*((_DWORD *)v133 + 95) + 1) % 0x8Cu;
        *((_DWORD *)v133 + 95) = v26;
        if (v113[v26])
          --*((_DWORD *)v25 + 96);
        LODWORD(v174[0]) = 1065353216;
        vDSP_meanv(v172, 1, (float *)v174, 5uLL);
        v27 = 0;
        v28 = 0;
        v29 = v133;
        v30 = *((_DWORD *)v133 + 99);
        do
        {
          v28 |= (v172[v27] >= (float)(*(float *)v174 * flt_1B662C398[((v30 >> v27) & 1) == 0])) << v27;
          ++v27;
        }
        while (v27 != 5);
        v31 = v30 == v28;
        v113[*((unsigned int *)v133 + 95)] = v30 != v28;
        *((_DWORD *)v29 + 99) = v28;
        v32 = *((_DWORD *)v29 + 96);
        if (!v31)
          *((_DWORD *)v29 + 96) = ++v32;
        v33 = *((_DWORD *)v29 + 97);
        v24 = 1.0;
        if (v32 > v33)
        {
          v34 = *((_DWORD *)v29 + 98);
          v24 = 0.0;
          if (v32 < v34)
            v24 = 1.0 - (float)((float)(v32 - v33) / (float)(v34 - v33));
        }
        v35 = *((float *)v29 + 100);
        if (v24 > v35)
          v24 = (float)(v24 * v111) + (float)(v35 * v110);
        *((float *)v29 + 100) = v24;
      }
      v36 = 0;
      v37 = 0;
      v38 = v24 * v117;
      do
      {
        v39 = v36;
        v40 = dword_1B66A2A00[2 * v37];
        v41 = dword_1B66A2A00[2 * v37 + 1];
        if (v138 - v40 >= v41)
          __N = v41;
        else
          __N = (v138 - v40);
        if ((int)__N < 1)
          break;
        v43 = HIDWORD(v163);
        v44 = v163;
        v45 = HIDWORD(v162);
        v46 = v162;
        v47 = (float)(int)__N;
        v48 = v161;
        *(_QWORD *)&v149 = 0x500000005;
        v49 = v128;
        *((_QWORD *)v128 + 22) = 0;
        v49[9] = 0u;
        v49[10] = 0u;
        v49[7] = 0u;
        v49[8] = 0u;
        v49[5] = 0u;
        v49[6] = 0u;
        v49[3] = 0u;
        v49[4] = 0u;
        v49[1] = 0u;
        v49[2] = 0u;
        *v49 = 0u;
        *((_QWORD *)&v149 + 1) = v43;
        DWORD2(v151) = v44;
        DWORD2(v154) = v45;
        DWORD2(v157) = v46;
        *((_QWORD *)&v160 + 1) = LODWORD(v48);
        for (i = 8; i != 248; i += 48)
          *(float32x2_t *)((char *)&v150[-1] + i) = vmul_f32(*(float32x2_t *)((char *)&v150[-1] + i), v22);
        v51 = 0;
        v52 = (int)v131 + (uint64_t)v40;
        do
        {
          v53 = (float *)&v150[v51 - 1];
          v53[2] = powf(*((float *)&v150[v51 - 1] + 2), v38);
          v53[3] = 0.0;
          v51 += 3;
        }
        while (v51 != 15);
        v54 = powf(a11, (float)(int)__N * 0.0039062);
        if (v54 != 0.0)
        {
          v55 = 0;
          v56 = 0;
          v57 = *((_DWORD *)v147 + 157) + 1;
          do
          {
            if (v55 >= 0x19)
              std::__throw_out_of_range[abi:ne180100]("array::at");
            v58 = v20[2 * v55] * v54;
            v59 = (float *)&v150[v56 - 1];
            if (v58 < *((float *)&v150[v56 - 1] + 2))
              v58 = *((float *)&v150[v56 - 1] + 2);
            v59[2] = v58;
            v59[3] = 0.0;
            v56 += 3;
            v55 += v57;
          }
          while (v56 != 15);
        }
        v140 = v39;
        fb::ComplexMat::stabilize(&v149, v54);
        v60 = v159;
        v61 = (float *)v127;
        *((_OWORD *)v127 + 10) = v158;
        *((_OWORD *)v61 + 11) = v60;
        *((_OWORD *)v61 + 12) = v160;
        v62 = v155;
        *((_OWORD *)v61 + 6) = v154;
        *((_OWORD *)v61 + 7) = v62;
        v63 = v157;
        *((_OWORD *)v61 + 8) = v156;
        *((_OWORD *)v61 + 9) = v63;
        v64 = v151;
        *((_OWORD *)v61 + 2) = v150[1];
        *((_OWORD *)v61 + 3) = v64;
        v65 = v153;
        *((_OWORD *)v61 + 4) = v152;
        *((_OWORD *)v61 + 5) = v65;
        v66 = v150[0];
        *(_OWORD *)v61 = v149;
        *((_OWORD *)v61 + 1) = v66;
        fb::operator*((uint64_t)v173, v147, (uint64_t)&v149);
        fb::operator*((uint64_t)v174, (const float *)v173, (uint64_t)v141);
        fb::ComplexMat::inversed((fb::ComplexMat *)v173, (float *)v174);
        fb::operator*((uint64_t)v164, (const float *)&v149, (uint64_t)v141);
        fb::operator*((uint64_t)v148, v164, (uint64_t)v173);
        if (v126)
        {
          v68 = v122;
          *((_QWORD *)v122 + 14) = 0;
          v68[5] = 0u;
          v68[6] = 0u;
          v68[3] = 0u;
          v68[4] = 0u;
          v68[1] = 0u;
          v68[2] = 0u;
          *v68 = 0u;
          memset(&v174[2], 0, 48);
          v174[0] = xmmword_1B662F794;
          v174[1] = *(_OWORD *)algn_1B662F7A4;
          *(_QWORD *)v148 = 0x200000005;
          *(_QWORD *)&v148[200] = v176;
          *(_OWORD *)&v148[168] = v175[5];
          *(_OWORD *)&v148[184] = v175[6];
          memset(&v148[40], 0, 48);
          *(_OWORD *)&v148[8] = xmmword_1B662F794;
          *(_OWORD *)&v148[24] = *(_OWORD *)algn_1B662F7A4;
          *(_OWORD *)&v148[136] = v175[3];
          *(_OWORD *)&v148[152] = v175[4];
          *(_OWORD *)&v148[104] = v175[1];
          *(_OWORD *)&v148[120] = v175[2];
          *(_OWORD *)&v148[88] = v175[0];
        }
        v139 = &v108;
        MEMORY[0x1E0C80A78](v67);
        v70 = (float *)((char *)&v108 - ((v69 + 15) & 0x7FFFFFFF0));
        MEMORY[0x1E0C80A78](v71);
        MEMORY[0x1E0C80A78](v72);
        v74 = (float *)((char *)&v108 - v73);
        MEMORY[0x1E0C80A78](v75);
        v145 = (float *)((char *)&v108 - v77);
        if (v125)
        {
          *(_QWORD *)&v174[0] = v70;
          v144 = v76;
          *((_QWORD *)&v174[0] + 1) = v76;
          (*(void (**)(_QWORD, char *, _OWORD *, uint64_t, vDSP_Length, _QWORD, float))(**(_QWORD **)v133
                                                                                                + 40))(*(_QWORD *)v133, (char *)v130 + 4 * (int)v52, v174, 2, __N, 0, 1.0);
          v52 = (int)v52;
          v173[0] = v74;
          v173[1] = v145;
          (*(void (**)(_QWORD, const float *, _QWORD *, uint64_t, vDSP_Length, _QWORD, float))(**((_QWORD **)v133 + 1) + 40))(*((_QWORD *)v133 + 1), &v129[(int)v52], v173, 2, __N, 0, 1.0);
        }
        else
        {
          IR::FixedIntegerDelay::process(v123, (float *)v130 + v52, v70, __N);
          IR::FixedIntegerDelay::process(v121, (float *)&v129[v52], v74, __N);
          v144 = v70;
          v145 = v74;
        }
        v78 = &v137[v52];
        v79 = &v135[v52];
        v142 = &v134[v52];
        v143 = &v136[v52];
        v80 = &v132[v52];
        if (v124)
        {
          v81 = 1.0 / v47;
          *(float *)v174 = v147[210];
          *(float *)v173 = (float)(1.0 / v47) * (float)(*(float *)&v148[8] - *(float *)v174);
          vDSP_vrampmul(v70, 1, (float *)v174, (const float *)v173, v78, 1, __N);
          *(float *)v174 = v147[212];
          *(float *)v173 = (float)(1.0 / v47) * (float)(*(float *)&v148[16] - *(float *)v174);
          vDSP_vrampmuladd(v74, 1, (float *)v174, (const float *)v173, v78, 1, __N);
          v82 = *((unsigned int *)v147 + 209);
          if (v82 >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v83 = v146[2 * v82];
          *(float *)v174 = v83;
          if (*(_DWORD *)&v148[4] >= 0x19u)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          *(float *)v173 = v81 * (float)(*(float *)&v148[8 * *(unsigned int *)&v148[4] + 8] - v83);
          vDSP_vrampmul(v70, 1, (float *)v174, (const float *)v173, v79, 1, __N);
          if ((*((_DWORD *)v147 + 209) + 1) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v84 = v146[2 * (*((_DWORD *)v147 + 209) + 1)];
          *(float *)v174 = v84;
          if ((*(_DWORD *)&v148[4] + 1) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          *(float *)v173 = v81 * (float)(*(float *)&v148[8 * (*(_DWORD *)&v148[4] + 1) + 8] - v84);
          vDSP_vrampmuladd(v74, 1, (float *)v174, (const float *)v173, v79, 1, __N);
          if ((2 * *((_DWORD *)v147 + 209)) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v85 = v146[4 * *((_DWORD *)v147 + 209)];
          *(float *)v174 = v85;
          if ((2 * *(_DWORD *)&v148[4]) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          *(float *)v173 = v81 * (float)(*(float *)&v148[16 * *(_DWORD *)&v148[4] + 8] - v85);
          vDSP_vrampmul(v70, 1, (float *)v174, (const float *)v173, v143, 1, __N);
          if (((2 * *((_DWORD *)v147 + 209)) | 1u) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v86 = v146[2 * ((2 * *((_DWORD *)v147 + 209)) | 1)];
          *(float *)v174 = v86;
          if (((2 * *(_DWORD *)&v148[4]) | 1u) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          *(float *)v173 = v81 * (float)(*(float *)&v148[8 * ((2 * *(_DWORD *)&v148[4]) | 1) + 8] - v86);
          vDSP_vrampmuladd(v74, 1, (float *)v174, (const float *)v173, v143, 1, __N);
          v87 = 3 * *((_DWORD *)v147 + 209);
          if (v87 >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v88 = v21 * v146[2 * v87 + 1];
          *(float *)v174 = v88;
          if ((3 * *(_DWORD *)&v148[4]) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          *(float *)v173 = v81 * (float)-(float)(v88 - (float)(v21 * *(float *)&v148[24 * *(_DWORD *)&v148[4] + 12]));
          vDSP_vrampmul(v144, 1, (float *)v174, (const float *)v173, v142, 1, __N);
          v89 = 3 * *((_DWORD *)v147 + 209) + 1;
          if (v89 >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v90 = v21 * v146[2 * v89 + 1];
          *(float *)v174 = v90;
          v91 = 3 * *(_DWORD *)&v148[4] + 1;
          if (v91 >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          *(float *)v173 = v81 * (float)-(float)(v90 - (float)(v21 * *(float *)&v148[8 * v91 + 12]));
          vDSP_vrampmuladd(v145, 1, (float *)v174, (const float *)v173, v142, 1, __N);
          v92 = 4 * *((_DWORD *)v147 + 209);
          if (v92 >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v93 = v21 * v146[2 * v92 + 1];
          *(float *)v174 = v93;
          if ((4 * *(_DWORD *)&v148[4]) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          *(float *)v173 = v81 * (float)-(float)(v93 - (float)(v21 * *(float *)&v148[32 * *(_DWORD *)&v148[4] + 12]));
          vDSP_vrampmul(v144, 1, (float *)v174, (const float *)v173, v80, 1, __N);
          v94 = (4 * *((_DWORD *)v147 + 209)) | 1;
          if (v94 >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v95 = v21 * v146[2 * v94 + 1];
          *(float *)v174 = v95;
          v96 = (4 * *(_DWORD *)&v148[4]) | 1;
          if (v96 >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          *(float *)v173 = v81 * (float)-(float)(v95 - (float)(v21 * *(float *)&v148[8 * v96 + 12]));
          vDSP_vrampmuladd(v145, 1, (float *)v174, (const float *)v173, v80, 1, __N);
          v97 = *(_OWORD *)&v148[176];
          v98 = (float *)v120;
          *((_OWORD *)v120 + 10) = *(_OWORD *)&v148[160];
          *((_OWORD *)v98 + 11) = v97;
          *((_OWORD *)v98 + 12) = *(_OWORD *)&v148[192];
          v99 = *(_OWORD *)&v148[112];
          *((_OWORD *)v98 + 6) = *(_OWORD *)&v148[96];
          *((_OWORD *)v98 + 7) = v99;
          v100 = *(_OWORD *)&v148[144];
          *((_OWORD *)v98 + 8) = *(_OWORD *)&v148[128];
          *((_OWORD *)v98 + 9) = v100;
          v101 = *(_OWORD *)&v148[48];
          *((_OWORD *)v98 + 2) = *(_OWORD *)&v148[32];
          *((_OWORD *)v98 + 3) = v101;
          v102 = *(_OWORD *)&v148[80];
          *((_OWORD *)v98 + 4) = *(_OWORD *)&v148[64];
          *((_OWORD *)v98 + 5) = v102;
          v103 = *(_OWORD *)&v148[16];
          *(_OWORD *)v98 = *(_OWORD *)v148;
          *((_OWORD *)v98 + 1) = v103;
        }
        else
        {
          LODWORD(v174[0]) = *(_DWORD *)&v148[8];
          LODWORD(v173[0]) = *(_DWORD *)&v148[16];
          vDSP_vsmsma(v70, 1, (const float *)v174, v74, 1, (const float *)v173, v78, 1, __N);
          if (*(_DWORD *)&v148[4] >= 0x19u)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v164[0] = *(float *)&v148[8 * *(unsigned int *)&v148[4] + 8];
          if (*(_DWORD *)&v148[4] == 24)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v171 = *(float *)&v148[8 * (*(_DWORD *)&v148[4] + 1) + 8];
          vDSP_vsmsma(v70, 1, v164, v74, 1, &v171, v79, 1, __N);
          if ((2 * *(_DWORD *)&v148[4]) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v170 = *(float *)&v148[16 * *(_DWORD *)&v148[4] + 8];
          if (((2 * *(_DWORD *)&v148[4]) | 1u) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v169 = *(float *)&v148[8 * ((2 * *(_DWORD *)&v148[4]) | 1) + 8];
          vDSP_vsmsma(v70, 1, &v170, v74, 1, &v169, v143, 1, __N);
          v104 = 3 * *(_DWORD *)&v148[4];
          if ((3 * *(_DWORD *)&v148[4]) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v168 = v21 * *(float *)&v148[8 * v104 + 12];
          if (*(_DWORD *)&v148[4] == 8)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v167 = v21 * *(float *)&v148[8 * (v104 + 1) + 12];
          vDSP_vsmsma(v144, 1, &v168, v145, 1, &v167, v142, 1, __N);
          v105 = 4 * *(_DWORD *)&v148[4];
          if ((4 * *(_DWORD *)&v148[4]) >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v166 = v21 * *(float *)&v148[8 * v105 + 12];
          v106 = v105 | 1;
          if (v106 >= 0x19)
            std::__throw_out_of_range[abi:ne180100]("array::at");
          v165 = v21 * *(float *)&v148[8 * v106 + 12];
          vDSP_vsmsma(v144, 1, &v166, v145, 1, &v165, v80, 1, __N);
        }
        v36 = 1;
        v37 = 1;
      }
      while ((v140 & 1) == 0);
      v19 = v119 + 256;
    }
    while (v119 + 256 < v112);
  }
}

void AUMixSwitch::~AUMixSwitch(AUMixSwitch *this)
{
  AUMixSwitch::~AUMixSwitch(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  NSObject *v2;
  void *v3;
  void *v4;
  int v5;
  AUMixSwitch *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E69C5B08;
  if (getAUMixSwitchLog(void)::onceToken != -1)
    dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
  v2 = getAUMixSwitchLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    v5 = 134217984;
    v6 = this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_INFO, "[%p] destroyed", (uint8_t *)&v5, 0xCu);
  }
  v3 = (void *)*((_QWORD *)this + 70);
  if (v3)
  {
    *((_QWORD *)this + 71) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 67);
  if (v4)
  {
    *((_QWORD *)this + 68) = v4;
    operator delete(v4);
  }
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUMixSwitch::Initialize(AUMixSwitch *this)
{
  NSObject *v2;
  double v3;
  double v4;
  NSObject *v5;
  const char *v6;
  float v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _BYTE v13[36];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (getAUMixSwitchLog(void)::onceToken != -1)
    dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
  v2 = getAUMixSwitchLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)v13 = 134217984;
    *(_QWORD *)&v13[4] = this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_INFO, "[%p] initialize", v13, 0xCu);
  }
  if (!*((_BYTE *)this + 376))
  {
    if (getAUMixSwitchLog(void)::onceToken != -1)
      dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
    v5 = getAUMixSwitchLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294956421;
    *(_DWORD *)v13 = 134217984;
    *(_QWORD *)&v13[4] = this;
    v6 = "[%p] failed to initialize - cannot operate in variable block size mode";
    goto LABEL_31;
  }
  (*(void (**)(_BYTE *__return_ptr, AUMixSwitch *, uint64_t, _QWORD))(*(_QWORD *)this + 392))(v13, this, 1, 0);
  v3 = *(double *)v13;
  (*(void (**)(_BYTE *__return_ptr, AUMixSwitch *, uint64_t, uint64_t))(*(_QWORD *)this + 392))(v13, this, 1, 1);
  v4 = *(double *)v13;
  (*(void (**)(_BYTE *__return_ptr, AUMixSwitch *, uint64_t, _QWORD))(*(_QWORD *)this + 392))(v13, this, 2, 0);
  if (v3 != *(double *)v13)
  {
    if (getAUMixSwitchLog(void)::onceToken != -1)
      dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
    v5 = getAUMixSwitchLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294956421;
    *(_DWORD *)v13 = 134217984;
    *(_QWORD *)&v13[4] = this;
    v6 = "[%p] failed to initialize - sample rates of FrontMic input bus and main output bus must be equal";
    goto LABEL_31;
  }
  if (v4 != *(double *)v13)
  {
    if (getAUMixSwitchLog(void)::onceToken != -1)
      dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
    v5 = getAUMixSwitchLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294956421;
    *(_DWORD *)v13 = 134217984;
    *(_QWORD *)&v13[4] = this;
    v6 = "[%p] failed to initialize - sample rates of BackMic input bus and main output bus must be equal";
    goto LABEL_31;
  }
  v7 = *((float *)this + 146);
  if (v7 < 0.0)
  {
    if (getAUMixSwitchLog(void)::onceToken != -1)
      dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
    v5 = getAUMixSwitchLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294956421;
    *(_DWORD *)v13 = 134217984;
    *(_QWORD *)&v13[4] = this;
    v6 = "[%p] failed to initialize - parameter mix frequency must be positive";
    goto LABEL_31;
  }
  if (*(double *)v13 > v7)
  {
    v8 = *((_DWORD *)this + 84);
    *((_DWORD *)this + 147) = vcvtmd_u64_f64((float)(v7 * (float)v8) / *(double *)v13);
    *(_DWORD *)v13 = 0;
    std::vector<float>::assign((char **)this + 67, 2 * v8, v13);
    v9 = *((unsigned int *)this + 84);
    *(_DWORD *)v13 = 1056964608;
    std::vector<float>::assign((char **)this + 67, v9, v13);
    v10 = (2 * *((_DWORD *)this + 84));
    *(_DWORD *)v13 = 0;
    std::vector<float>::assign((char **)this + 70, v10, v13);
    v11 = *((unsigned int *)this + 84);
    *(_DWORD *)v13 = 1056964608;
    std::vector<float>::assign((char **)this + 70, v11, v13);
    (*(void (**)(AUMixSwitch *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
    return 0;
  }
  if (getAUMixSwitchLog(void)::onceToken != -1)
    dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
  v5 = getAUMixSwitchLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v13 = 134217984;
    *(_QWORD *)&v13[4] = this;
    v6 = "[%p] failed to initialize - parameter mix frequency must not exceed Nyquist frequency";
LABEL_31:
    _os_log_error_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_ERROR, v6, v13, 0xCu);
  }
  return 4294956421;
}

uint64_t AUMixSwitch::GetPropertyInfo(AUMixSwitch *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  char v8;
  int v9;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 1651335778)
  {
    if (a2 == 1651335779 || a2 == 1718444643)
    {
      *a6 = 1;
      v9 = 8 * *((_DWORD *)this + 84);
LABEL_14:
      result = 0;
      *a5 = v9;
      return result;
    }
    if (a2 != 1886222438)
      return result;
    goto LABEL_10;
  }
  if (a2 == 21)
  {
    v8 = 1;
    goto LABEL_13;
  }
  if (a2 == 3700)
  {
LABEL_10:
    v8 = *((_BYTE *)this + 17) ^ 1;
LABEL_13:
    *a6 = v8;
    v9 = 4;
    goto LABEL_14;
  }
  return result;
}

uint64_t AUMixSwitch::GetProperty(AUMixSwitch *this, int a2, int a3, unsigned int a4, _DWORD *__dst)
{
  uint64_t result;
  int v7;
  const void *v8;
  uint64_t v9;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 1651335778)
  {
    if (a2 == 21)
    {
      result = 0;
      v7 = *((unsigned __int8 *)this + 528);
    }
    else
    {
      if (a2 != 3700)
        return result;
      result = 0;
      v7 = *((unsigned __int8 *)this + 376);
    }
    *__dst = v7;
    return result;
  }
  switch(a2)
  {
    case 1651335779:
      v8 = (const void *)*((_QWORD *)this + 70);
      v9 = *((_QWORD *)this + 71);
LABEL_14:
      memcpy(__dst, v8, v9 - (_QWORD)v8);
      return 0;
    case 1718444643:
      v8 = (const void *)*((_QWORD *)this + 67);
      v9 = *((_QWORD *)this + 68);
      goto LABEL_14;
    case 1886222438:
      result = 0;
      *__dst = *((_DWORD *)this + 146);
      break;
  }
  return result;
}

uint64_t AUMixSwitch::SetProperty(AUMixSwitch *this, int a2, int a3, unsigned int a4, char *__src, unsigned int a6)
{
  uint64_t result;
  char *v8;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 1651335778)
  {
    if (a2 == 1651335779)
    {
      v8 = (char *)this + 560;
    }
    else
    {
      if (a2 != 1718444643)
      {
        if (a2 == 1886222438)
        {
          result = 0;
          *((_DWORD *)this + 146) = *(_DWORD *)__src;
        }
        return result;
      }
      v8 = (char *)this + 536;
    }
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v8, __src, (uint64_t)&__src[4 * (a6 >> 2)], a6 >> 2);
    return 0;
  }
  if (a2 == 21)
  {
    result = 0;
    *((_BYTE *)this + 528) = *(_DWORD *)__src != 0;
  }
  else if (a2 == 3700)
  {
    result = 0;
    *((_BYTE *)this + 376) = __src != 0;
  }
  return result;
}

uint64_t AUMixSwitch::CanScheduleParameters(AUMixSwitch *this)
{
  return 0;
}

uint64_t ausdk::AUBase::ProcessBufferLists(ausdk::AUBase *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4)
{
  return 4294967292;
}

uint64_t AUMixSwitch::ProcessMultipleBufferLists(AUMixSwitch *this, unsigned int *a2, unsigned int a3, int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7)
{
  float *mData;
  size_t mDataByteSize;
  float *v13;
  ausdk::AUScope *v14;
  ausdk::AUElement *v15;
  float v16;
  ausdk::AUScope *v17;
  ausdk::AUElement *v18;
  ausdk::AUElement *v19;
  float v20;
  ausdk::AUElement *v21;
  ausdk::AUElement *v22;
  float v23;
  ausdk::AUElement *v24;
  ausdk::AUElement *v25;
  float v26;
  ausdk::AUElement *v27;
  ausdk::AUElement *v28;
  float v29;
  ausdk::AUElement *v30;
  float *v31;
  float *v32;
  size_t v33;
  uint64_t result;
  const AudioBufferList *v35;
  float *v36;
  size_t v37;
  uint64_t v38;
  ausdk::AUElement *v39;
  ausdk::AUElement **v40;
  int Parameter;
  uint64_t v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  ausdk::AUElement *Element;
  float v49;
  ausdk::AUElement *v50;
  float v51;
  ausdk::AUElement *v52;
  ausdk::AUElement *v53;
  float v54;
  ausdk::AUElement *v55;
  float v56;
  ausdk::AUElement *v57;
  ausdk::AUElement *v58;
  float v59;
  ausdk::AUElement *v60;
  float v61;
  _BOOL4 v62;
  float v63;
  ausdk::AUElement *v64;
  ausdk::AUElement *v65;
  float v66;
  ausdk::AUElement *v67;
  float v68;
  ausdk::AUElement *v69;
  ausdk::AUElement *v70;
  float v71;
  ausdk::AUElement *v72;
  float v73;
  ausdk::AUElement *v74;
  float *v75;
  ausdk::AUScope *v76;
  ausdk::AUElement *v77;
  float v78;
  ausdk::AUScope *v79;
  ausdk::AUElement *v80;
  ausdk::AUElement *v81;
  float v82;
  ausdk::AUElement *v83;
  ausdk::AUElement *v84;
  float v85;
  ausdk::AUElement *v86;
  ausdk::AUElement *v87;
  float v88;
  ausdk::AUElement *v89;
  ausdk::AUElement *v90;
  float v91;
  ausdk::AUElement *v92;
  NSObject *v93;
  uint64_t v94;
  const char *v95;
  NSObject *v96;
  uint64_t v97;
  int v98;
  DSPSplitComplex __E;
  DSPSplitComplex __D;
  DSPSplitComplex __C;
  DSPSplitComplex __B;
  float __A;
  _BYTE v104[18];
  __int16 v105;
  int v106;
  uint64_t v107;

  v107 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 84) < a3)
  {
    if (getAUMixSwitchLog(void)::onceToken != -1)
      dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
    v93 = getAUMixSwitchLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      v98 = *((_DWORD *)this + 84);
      *(_DWORD *)v104 = 134218496;
      *(_QWORD *)&v104[4] = this;
      *(_WORD *)&v104[12] = 1024;
      *(_DWORD *)&v104[14] = a3;
      v105 = 1024;
      v106 = v98;
      _os_log_error_impl(&dword_1B5ED0000, v93, OS_LOG_TYPE_ERROR, "[%p] cannot process %u frames (maximum frame size is %u)", v104, 0x18u);
    }
    return 4294956422;
  }
  if (a4 != 2)
  {
    if (getAUMixSwitchLog(void)::onceToken != -1)
      dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
    v94 = getAUMixSwitchLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294967246;
    *(_DWORD *)v104 = 134218496;
    *(_QWORD *)&v104[4] = this;
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = a4;
    v105 = 1024;
    v106 = 2;
    v95 = "[%p] cannot process %u input busses (expected input bus count is %u)";
    v96 = v94;
    goto LABEL_37;
  }
  if (a6 != 1)
  {
    if (getAUMixSwitchLog(void)::onceToken != -1)
      dispatch_once(&getAUMixSwitchLog(void)::onceToken, &__block_literal_global_96);
    v97 = getAUMixSwitchLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUMixSwitchLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294967246;
    *(_DWORD *)v104 = 134218496;
    *(_QWORD *)&v104[4] = this;
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = a6;
    v105 = 1024;
    v106 = 1;
    v95 = "[%p] cannot process %u output busses (expected output bus count is %u)";
    v96 = v97;
LABEL_37:
    _os_log_error_impl(&dword_1B5ED0000, v96, OS_LOG_TYPE_ERROR, v95, v104, 0x18u);
    return 4294967246;
  }
  mData = (float *)(*a5)->mBuffers[0].mData;
  mDataByteSize = (*a5)->mBuffers[0].mDataByteSize;
  v13 = (float *)(*a7)->mBuffers[0].mData;
  if (*((_BYTE *)this + 528))
    goto LABEL_5;
  v35 = a5[1];
  v36 = (float *)v35->mBuffers[0].mData;
  v37 = v35->mBuffers[0].mDataByteSize;
  v38 = *((_QWORD *)this + 9);
  if (v38)
  {
    v39 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v38 + 32))(v38, 0);
  }
  else
  {
    v40 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v40)
      v39 = 0;
    else
      v39 = *v40;
  }
  Parameter = (int)ausdk::AUElement::GetParameter(v39, 0);
  if (Parameter == 2)
  {
    v42 = *((unsigned int *)this + 147);
    v43 = hypotf(*(float *)(*((_QWORD *)this + 67) + 4 * v42), *(float *)(*((_QWORD *)this + 67) + 4 * (v42 + a3)));
    v44 = hypotf(*(float *)(*((_QWORD *)this + 70) + 4 * v42), *(float *)(*((_QWORD *)this + 70) + 4 * (v42 + a3)));
    v45 = v43 + v44;
    v46 = 0.0;
    v47 = 1.0;
    if ((float)(v43 + v44) > 0.0)
    {
      v47 = v43 / v45;
      v46 = v44 / v45;
    }
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 0);
    v49 = ausdk::AUElement::GetParameter(Element, 0);
    v50 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 1u);
    v51 = (float)(v46 * ausdk::AUElement::GetParameter(v50, 0)) + (float)(v49 * v47);
    v52 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 128), 0);
    ausdk::AUElement::SetParameter(v52, 0, v51, 0);
    v53 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 0);
    v54 = ausdk::AUElement::GetParameter(v53, 1u);
    v55 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 1u);
    v56 = (float)(v46 * ausdk::AUElement::GetParameter(v55, 1u)) + (float)(v54 * v47);
    v57 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 128), 0);
    ausdk::AUElement::SetParameter(v57, 1u, v56, 0);
    v58 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 0);
    v59 = ausdk::AUElement::GetParameter(v58, 2u);
    v60 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 1u);
    v61 = ausdk::AUElement::GetParameter(v60, 2u);
    v62 = v59 == 1.0;
    if (v61 != 1.0)
      v62 = 0;
    v63 = (float)v62;
    v64 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 128), 0);
    ausdk::AUElement::SetParameter(v64, 2u, v63, 0);
    v65 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 0);
    v66 = ausdk::AUElement::GetParameter(v65, 3u);
    v67 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 1u);
    v68 = (float)(v46 * ausdk::AUElement::GetParameter(v67, 3u)) + (float)(v66 * v47);
    v69 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 128), 0);
    ausdk::AUElement::SetParameter(v69, 3u, v68, 0);
    v70 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 0);
    v71 = ausdk::AUElement::GetParameter(v70, 4u);
    v72 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 1u);
    v73 = (float)(v46 * ausdk::AUElement::GetParameter(v72, 4u)) + (float)(v71 * v47);
    v74 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 128), 0);
    ausdk::AUElement::SetParameter(v74, 4u, v73, 0);
    __A = 0.0;
    *(_QWORD *)v104 = mData;
    *(_QWORD *)&v104[8] = &mData[a3];
    __B.realp = (float *)*((_QWORD *)this + 67);
    __B.imagp = &__B.realp[a3];
    __C.realp = v36;
    __C.imagp = &v36[a3];
    v75 = (float *)(*((_QWORD *)this + 70) + 4 * a3);
    __D.realp = (float *)*((_QWORD *)this + 70);
    __D.imagp = v75;
    __E.realp = v13;
    __E.imagp = &v13[a3];
    vDSP_vfill(&__A, v13, 1, 2 * a3);
    vDSP_zvmmaa((const DSPSplitComplex *)v104, 1, &__B, 1, &__C, 1, &__D, 1, &__E, 1, &__E, 1, a3);
    return 0;
  }
  if (Parameter == 1)
  {
    v76 = (AUMixSwitch *)((char *)this + 80);
    v77 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 1u);
    v78 = ausdk::AUElement::GetParameter(v77, 0);
    v79 = (AUMixSwitch *)((char *)this + 128);
    v80 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v79, 0);
    ausdk::AUElement::SetParameter(v80, 0, v78, 0);
    v81 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v76, 1u);
    v82 = ausdk::AUElement::GetParameter(v81, 1u);
    v83 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v79, 0);
    ausdk::AUElement::SetParameter(v83, 1u, v82, 0);
    v84 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v76, 1u);
    v85 = ausdk::AUElement::GetParameter(v84, 2u);
    v86 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v79, 0);
    ausdk::AUElement::SetParameter(v86, 2u, v85, 0);
    v87 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v76, 1u);
    v88 = ausdk::AUElement::GetParameter(v87, 3u);
    v89 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v79, 0);
    ausdk::AUElement::SetParameter(v89, 3u, v88, 0);
    v90 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v76, 1u);
    v91 = ausdk::AUElement::GetParameter(v90, 4u);
    v92 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v79, 0);
    ausdk::AUElement::SetParameter(v92, 4u, v91, 0);
    v31 = v13;
    v32 = v36;
    v33 = v37;
    goto LABEL_6;
  }
  result = 0;
  if (!Parameter)
  {
LABEL_5:
    v14 = (AUMixSwitch *)((char *)this + 80);
    v15 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUMixSwitch *)((char *)this + 80), 0);
    v16 = ausdk::AUElement::GetParameter(v15, 0);
    v17 = (AUMixSwitch *)((char *)this + 128);
    v18 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v17, 0);
    ausdk::AUElement::SetParameter(v18, 0, v16, 0);
    v19 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v14, 0);
    v20 = ausdk::AUElement::GetParameter(v19, 1u);
    v21 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v17, 0);
    ausdk::AUElement::SetParameter(v21, 1u, v20, 0);
    v22 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v14, 0);
    v23 = ausdk::AUElement::GetParameter(v22, 2u);
    v24 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v17, 0);
    ausdk::AUElement::SetParameter(v24, 2u, v23, 0);
    v25 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v14, 0);
    v26 = ausdk::AUElement::GetParameter(v25, 3u);
    v27 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v17, 0);
    ausdk::AUElement::SetParameter(v27, 3u, v26, 0);
    v28 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v14, 0);
    v29 = ausdk::AUElement::GetParameter(v28, 4u);
    v30 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v17, 0);
    ausdk::AUElement::SetParameter(v30, 4u, v29, 0);
    v31 = v13;
    v32 = mData;
    v33 = mDataByteSize;
LABEL_6:
    memcpy(v31, v32, v33);
    return 0;
  }
  return result;
}

uint64_t ausdk::AUBase::Render(ausdk::AUBase *this, unsigned int *a2, const AudioTimeStamp *a3)
{
  return 0;
}

uint64_t AUMixSwitch::GetParameterList(AUMixSwitch *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;

  if (a2 == 2 || a2 == 1)
  {
    *a4 = 5;
    if (a3)
    {
      result = 0;
      *(_OWORD *)a3 = xmmword_1B6626920;
      a3[4] = 4;
      return result;
    }
    return 0;
  }
  if (!a2)
  {
    *a4 = 1;
    if (a3)
    {
      result = 0;
      *a3 = 0;
      return result;
    }
    return 0;
  }
  *a4 = 0;
  return 4294956430;
}

uint64_t AUMixSwitch::GetParameterInfo(AUMixSwitch *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  int v5;
  AudioUnitParameterValue v6;
  AudioUnitParameterUnit v7;
  const __CFString *v8;
  int v9;
  uint64_t result;
  AudioUnitParameterOptions v11;

  if (a2 == 2)
  {
    buffer->unitName = 0;
    buffer->flags = 0x2000;
    v5 = 1073774592;
    v7 = kAudioUnitParameterUnit_Ratio;
    v8 = CFSTR("EC delta EIR");
    v6 = 1000.0;
    switch(a3)
    {
      case 0:
        goto LABEL_15;
      case 1:
LABEL_8:
        v7 = kAudioUnitParameterUnit_Milliseconds;
        v8 = CFSTR("EC main lobe delay");
        v9 = 1137180672;
        break;
      case 2:
LABEL_11:
        v6 = 1.0;
        v7 = kAudioUnitParameterUnit_Boolean;
        v8 = CFSTR("EC adaptation state");
        goto LABEL_15;
      case 3:
LABEL_12:
        v7 = kAudioUnitParameterUnit_Generic;
        v8 = CFSTR("EC time aligned ref signal energy");
        v9 = 1148846080;
        break;
      case 4:
LABEL_14:
        v7 = kAudioUnitParameterUnit_Generic;
        v6 = 1.0;
        v8 = CFSTR("EC mic LEE signal cross-correlation");
        goto LABEL_15;
      default:
        return 4294956418;
    }
    v6 = *(float *)&v9;
  }
  else
  {
    if (a2 == 1)
    {
      buffer->unitName = 0;
      buffer->flags = 0x2000;
      v5 = 1073774592;
      v7 = kAudioUnitParameterUnit_Ratio;
      v8 = CFSTR("EC delta EIR");
      v6 = 1000.0;
      switch(a3)
      {
        case 0:
          goto LABEL_15;
        case 1:
          goto LABEL_8;
        case 2:
          goto LABEL_11;
        case 3:
          goto LABEL_12;
        case 4:
          goto LABEL_14;
        default:
          return 4294956418;
      }
    }
    if (a2)
      return 4294956430;
    buffer->unitName = 0;
    buffer->flags = 0x2000;
    if (a3)
      return 4294956418;
    v5 = -1073741824;
    v6 = 2.0;
    v7 = kAudioUnitParameterUnit_Indexed;
    v8 = CFSTR("Beam");
  }
LABEL_15:
  buffer->cfNameString = v8;
  buffer->flags = 134225920;
  CFStringGetCString(v8, buffer->name, 52, 0x8000100u);
  result = 0;
  buffer->unit = v7;
  buffer->minValue = 0.0;
  buffer->maxValue = v6;
  v11 = buffer->flags | v5;
  buffer->defaultValue = 0.0;
  buffer->flags = v11;
  return result;
}

uint64_t AUMixSwitch::GetParameterValueStrings(AUMixSwitch *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  const __CFArray *v6;
  uint64_t i;
  const void *v8;
  _QWORD v9[2];
  _BYTE v10[8];
  uint64_t v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 0;
  if (a2)
    return 4294956430;
  if (a3)
    return 4294956418;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)v10, "Front Mic");
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v11, "Back Mic");
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)v12, "Beam Mics");
  v9[0] = v10;
  v9[1] = 3;
  v6 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::StringRef>((uint64_t)v9);
  for (i = 16; i != -8; i -= 8)
  {
    v8 = *(const void **)&v10[i];
    if (v8)
      CFRelease(v8);
  }
  result = 0;
  *a4 = v6;
  return result;
}

void sub_1B61066B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t i;

  for (i = 16; i != -8; i -= 8)
    applesauce::CF::StringRef::~StringRef((const void **)(&a11 + i));
  _Unwind_Resume(a1);
}

double ausdk::AUBase::GetLatency(ausdk::AUBase *this)
{
  return 0.0;
}

double AUMixSwitch::GetTailTime(AUMixSwitch *this)
{
  return 0.0;
}

uint64_t AUMixSwitch::SupportsTail(AUMixSwitch *this)
{
  return 1;
}

BOOL AUMixSwitch::StreamFormatWritable(AUMixSwitch *this, int a2, unsigned int a3)
{
  _BOOL4 v3;
  _BOOL4 v4;

  v3 = a3 == 0;
  v4 = a3 < 2;
  if (a2 != 1)
    v4 = 0;
  if (a2 != 2)
    v3 = v4;
  return !*((_BYTE *)this + 17) && v3;
}

uint64_t AUMixSwitch::SupportedNumChannels(AUMixSwitch *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUMixSwitch::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

BOOL AUMixSwitch::ValidFormat(AUMixSwitch *this, unsigned int a2, unsigned int a3, const AudioStreamBasicDescription *a4)
{
  return a4->mBitsPerChannel == 64 && a4->mFormatID == 1718773105 && a4->mChannelsPerFrame == 1;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::StringRef>(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  CFArrayRef CFArray;
  void *__p[3];

  std::vector<void const*>::vector(__p, *(_QWORD *)(a1 + 8));
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(uint64_t **)a1;
    v4 = __p[0];
    v5 = 8 * v2;
    do
    {
      v6 = *v3++;
      *v4++ = v6;
      v5 -= 8;
    }
    while (v5);
  }
  CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return CFArray;
}

void sub_1B610680C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

os_log_t ___Z17getAUMixSwitchLogv_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreaudio", "AUMixSwitch");
  getAUMixSwitchLog(void)::gLog = (uint64_t)result;
  return result;
}

const void **ausdk::Owned<__CFString const*>::operator=(const void **a1, const void *a2)
{
  const void *v3;

  v3 = *a1;
  if (v3 != a2)
  {
    ausdk::Owned<__CFString const*>::releaseRef(v3);
    *a1 = a2;
    ausdk::Owned<__CFString const*>::retainRef(a2);
  }
  return a1;
}

void ausdk::Owned<__CFString const*>::releaseRef(const void *a1)
{
  if (a1)
    CFRelease(a1);
}

CFTypeRef ausdk::Owned<__CFString const*>::retainRef(CFTypeRef result)
{
  if (result)
    return CFRetain(result);
  return result;
}

void AUMixGainCompensation::~AUMixGainCompensation(AUMixGainCompensation *this)
{
  ausdk::AUBase::~AUBase(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AUMixGainCompensation::Initialize(AUMixGainCompensation *this)
{
  uint64_t Element;
  const AudioStreamBasicDescription *v3;
  CA::Implementation *v4;
  int v5;
  uint64_t v6;

  Element = ausdk::AUScope::SafeGetElement((AUMixGainCompensation *)((char *)this + 80), 0);
  v3 = (const AudioStreamBasicDescription *)ausdk::AUScope::SafeGetElement((AUMixGainCompensation *)((char *)this + 128), 0);
  v4 = (CA::Implementation *)(Element + 80);
  if (*(double *)(Element + 80) != v3[2].mSampleRate
    || *(_DWORD *)(Element + 88) != v3[2].mFormatID
    || *(_DWORD *)(Element + 96) != v3[2].mBytesPerPacket
    || *(_DWORD *)(Element + 100) != v3[2].mFramesPerPacket
    || *(_DWORD *)(Element + 108) != v3[2].mChannelsPerFrame)
  {
    return 4294956428;
  }
  v5 = *(_DWORD *)(Element + 112);
  v6 = 4294956428;
  if (v5 == v3[2].mBitsPerChannel)
  {
    if (CA::Implementation::EquivalentFormatFlags(v4, v3 + 2, 0, 0))
      return 0;
    else
      return 4294956428;
  }
  return v6;
}

uint64_t AUMixGainCompensation::Reset(AUMixGainCompensation *this)
{
  return 0;
}

uint64_t AUMixGainCompensation::GetPropertyInfo(AUMixGainCompensation *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;

  if (a3 || a2 != 1920035958 && a2 != 21)
    return 4294956417;
  result = 0;
  *a6 = 1;
  *a5 = 4;
  return result;
}

uint64_t AUMixGainCompensation::GetProperty(AUMixGainCompensation *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  int v6;

  if (a3)
    return 4294956417;
  if (a2 == 1920035958)
  {
    v6 = *((_DWORD *)this + 134);
  }
  else
  {
    if (a2 != 21)
      return 4294956417;
    v6 = *((unsigned __int8 *)this + 528);
  }
  result = 0;
  *a5 = v6;
  return result;
}

uint64_t AUMixGainCompensation::SetProperty(AUMixGainCompensation *this, int a2, int a3, unsigned int a4, _DWORD *a5, unsigned int a6)
{
  uint64_t result;

  if (a3)
    return 4294956417;
  if (a2 != 1920035958)
  {
    if (a2 != 21)
      return 4294956417;
    if (a6 >= 4)
    {
      result = 0;
      *((_BYTE *)this + 528) = *a5 != 0;
      return result;
    }
    return 4294956445;
  }
  if (a6 < 4)
    return 4294956445;
  result = 0;
  *((_DWORD *)this + 134) = *a5;
  return result;
}

uint64_t AUMixGainCompensation::SetParameter(AUMixGainCompensation *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  ausdk::AUScope *v12;
  ausdk::AUElement *v13;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  if (ausdk::AUElement::GetParameter(Element, a2) != a5)
  {
    v12 = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    v13 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v12, a4);
    ausdk::AUElement::SetParameter(v13, a2, a5, 0);
    if (!a2)
      *((float *)this + 133) = a5;
  }
  return 0;
}

uint64_t AUMixGainCompensation::CanScheduleParameters(AUMixGainCompensation *this)
{
  return 0;
}

uint64_t AUMixGainCompensation::ProcessBufferLists(AUMixGainCompensation *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, unsigned int a5)
{
  unint64_t mNumberBuffers;
  uint64_t v10;
  unint64_t v11;
  size_t mDataByteSize;
  void *mData;
  void *v14;
  int v16;
  float v17;
  float v18;
  float v19;
  float v20;
  unint64_t v21;
  void **p_mData;
  void **v23;
  const float *v24;
  const float *v25;
  float *v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  float __B;

  if (*((_DWORD *)this + 84) < a5)
    return 4294956422;
  if (*((_BYTE *)this + 528))
    goto LABEL_4;
  v16 = *((_DWORD *)this + 134);
  v17 = 0.0;
  if (v16 > 19)
  {
    if (v16 == 20)
    {
      v17 = 0.66667;
    }
    else if (v16 == 30)
    {
      v17 = 1.3333;
    }
    goto LABEL_20;
  }
  if (v16)
  {
    if (v16 == 10)
      v17 = 0.33333;
LABEL_20:
    v18 = *((float *)this + 133);
    v19 = v17 * v18;
    if (v19 <= -7.0)
      v20 = v19;
    else
      v20 = -7.0;
    if (v18 <= -7.0)
      v19 = v20;
    v21 = 0;
    __B = __exp10f((float)(v19 - v18) * 0.05);
    p_mData = &a3->mBuffers[0].mData;
    v23 = &a4->mBuffers[0].mData;
    while (v21 < *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUMixGainCompensation *)((char *)this + 128), 0)
                                  + 108))
    {
      v25 = (const float *)*p_mData;
      p_mData += 2;
      v24 = v25;
      v26 = (float *)*v23;
      v23 += 2;
      vDSP_vsmul(v24, 1, &__B, v26, 1, a5);
      ++v21;
    }
    v27 = *((_QWORD *)this + 9);
    if (v27)
    {
      v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
    }
    else
    {
      v29 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v29)
        v28 = 0;
      else
        v28 = *v29;
    }
    ausdk::AUElement::SetParameter(v28, 1u, __B, 0);
    return 0;
  }
LABEL_4:
  mNumberBuffers = a3->mNumberBuffers;
  if (mNumberBuffers == a4->mNumberBuffers && a3->mNumberBuffers)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      mDataByteSize = a3->mBuffers[v10].mDataByteSize;
      if ((_DWORD)mDataByteSize == a4->mBuffers[v10].mDataByteSize)
      {
        mData = a3->mBuffers[v10].mData;
        v14 = a4->mBuffers[v10].mData;
        if (mData != v14)
        {
          memcpy(v14, mData, mDataByteSize);
          mNumberBuffers = a3->mNumberBuffers;
        }
      }
      ++v11;
      ++v10;
    }
    while (v11 < mNumberBuffers);
  }
  return 0;
}

uint64_t AUMixGainCompensation::Render(AUMixGainCompensation *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v7;
  uint64_t Element;
  uint64_t v9;
  ausdk::AUInputElement *v10;
  uint64_t result;
  const AudioBufferList *BufferList;
  AudioBufferList *v13;
  unsigned int *v14;
  unsigned int v15;

  v7 = (AUMixGainCompensation *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AUMixGainCompensation *)((char *)this + 80), 0);
  v9 = ausdk::AUScope::SafeGetElement((AUMixGainCompensation *)((char *)this + 128), 0);
  v15 = 0;
  v10 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v7, 0);
  result = ausdk::AUInputElement::PullInput(v10, &v15, a3, 0, a4);
  if (!(_DWORD)result)
  {
    BufferList = (const AudioBufferList *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    v13 = (AudioBufferList *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v9 + 144));
    return AUMixGainCompensation::ProcessBufferLists(this, v14, BufferList, v13, a4);
  }
  return result;
}

uint64_t AUMixGainCompensation::GetParameterList(AUMixGainCompensation *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;

  if (a2)
    return 4294956430;
  if (a3)
    *(_QWORD *)a3 = 0x100000000;
  result = 0;
  *a4 = 2;
  return result;
}

uint64_t AUMixGainCompensation::GetParameterInfo(AUMixGainCompensation *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  uint64_t v6;
  int v7;
  const __CFString *v8;
  AudioUnitParameterOptions v9;

  buffer->flags = -1073741824;
  buffer->unitName = 0;
  if (a2)
    return 4294956418;
  if (!a3)
  {
    v6 = 0x41400000C2C00000;
    v7 = -1073733632;
    v8 = CFSTR("Input mix gain");
    goto LABEL_7;
  }
  if (a3 == 1)
  {
    v6 = 0x42400000C1400000;
    v7 = 1073782784;
    v8 = CFSTR("Applied compensation gain");
LABEL_7:
    buffer->cfNameString = v8;
    buffer->flags = -939524096;
    CFStringGetCString(v8, buffer->name, 52, 0x8000100u);
    result = 0;
    buffer->unit = kAudioUnitParameterUnit_Generic;
    *(_QWORD *)&buffer->minValue = v6;
    v9 = buffer->flags | v7;
    buffer->defaultValue = 0.0;
    buffer->flags = v9;
    return result;
  }
  return 0;
}

double AUMixGainCompensation::GetTailTime(AUMixGainCompensation *this)
{
  return 0.0;
}

uint64_t AUMixGainCompensation::SupportsTail(AUMixGainCompensation *this)
{
  return 1;
}

BOOL AUMixGainCompensation::StreamFormatWritable(AUMixGainCompensation *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUMixGainCompensation::SupportedNumChannels(AUMixGainCompensation *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUMixGainCompensation::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  return 1;
}

void vtRunFFT(uint64_t a1, int a2)
{
  if (a2 < 1)
  {
    vDSP_fft_zrip(*(FFTSetup *)(a1 + 24), (const DSPSplitComplex *)(a1 + 32), 1, *(int *)(a1 + 20), -1);
    vDSP_ztoc((const DSPSplitComplex *)(a1 + 32), 1, *(DSPComplex **)a1, 2, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
  }
  else
  {
    vDSP_ctoz(*(const DSPComplex **)a1, 2, (const DSPSplitComplex *)(a1 + 32), 1, (uint64_t)(*(_DWORD *)(a1 + 16) + (*(int *)(a1 + 16) < 0)) >> 1);
    vDSP_fft_zrip(*(FFTSetup *)(a1 + 24), (const DSPSplitComplex *)(a1 + 32), 1, *(int *)(a1 + 20), 1);
  }
}

void MicIssueDetectorCorev1::~MicIssueDetectorCorev1(MicIssueDetectorCorev1 *this)
{
  MicIssueDetectorCorev1::~MicIssueDetectorCorev1(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void **v35;

  *(_QWORD *)this = &off_1E69C5FE8;
  v2 = (void *)*((_QWORD *)this + 149);
  if (v2)
  {
    *((_QWORD *)this + 150) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 146);
  if (v3)
  {
    *((_QWORD *)this + 147) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 143);
  if (v4)
  {
    *((_QWORD *)this + 144) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 140);
  if (v5)
  {
    *((_QWORD *)this + 141) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 137);
  if (v6)
  {
    *((_QWORD *)this + 138) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 134);
  if (v7)
  {
    *((_QWORD *)this + 135) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 130);
  if (v8)
  {
    *((_QWORD *)this + 131) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 127);
  if (v9)
  {
    *((_QWORD *)this + 128) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 124);
  if (v10)
  {
    *((_QWORD *)this + 125) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 121);
  if (v11)
  {
    *((_QWORD *)this + 122) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 118);
  if (v12)
  {
    *((_QWORD *)this + 119) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 115);
  if (v13)
  {
    *((_QWORD *)this + 116) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 112);
  if (v14)
  {
    *((_QWORD *)this + 113) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 109);
  if (v15)
  {
    *((_QWORD *)this + 110) = v15;
    operator delete(v15);
  }
  v16 = (void *)*((_QWORD *)this + 106);
  if (v16)
  {
    *((_QWORD *)this + 107) = v16;
    operator delete(v16);
  }
  v35 = (void **)((char *)this + 824);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v35);
  v35 = (void **)((char *)this + 800);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v35);
  v17 = (void *)*((_QWORD *)this + 97);
  if (v17)
  {
    *((_QWORD *)this + 98) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 94);
  if (v18)
  {
    *((_QWORD *)this + 95) = v18;
    operator delete(v18);
  }
  v19 = (void *)*((_QWORD *)this + 91);
  if (v19)
  {
    *((_QWORD *)this + 92) = v19;
    operator delete(v19);
  }
  v20 = (void *)*((_QWORD *)this + 88);
  if (v20)
  {
    *((_QWORD *)this + 89) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 85);
  if (v21)
  {
    *((_QWORD *)this + 86) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 82);
  if (v22)
  {
    *((_QWORD *)this + 83) = v22;
    operator delete(v22);
  }
  v23 = (void *)*((_QWORD *)this + 79);
  if (v23)
  {
    *((_QWORD *)this + 80) = v23;
    operator delete(v23);
  }
  v24 = (void *)*((_QWORD *)this + 76);
  if (v24)
  {
    *((_QWORD *)this + 77) = v24;
    operator delete(v24);
  }
  v25 = (void *)*((_QWORD *)this + 73);
  if (v25)
  {
    *((_QWORD *)this + 74) = v25;
    operator delete(v25);
  }
  v26 = (void *)*((_QWORD *)this + 70);
  if (v26)
  {
    *((_QWORD *)this + 71) = v26;
    operator delete(v26);
  }
  v27 = (void *)*((_QWORD *)this + 67);
  if (v27)
  {
    *((_QWORD *)this + 68) = v27;
    operator delete(v27);
  }
  v28 = (void *)*((_QWORD *)this + 64);
  if (v28)
  {
    *((_QWORD *)this + 65) = v28;
    operator delete(v28);
  }
  v29 = (void *)*((_QWORD *)this + 61);
  if (v29)
  {
    *((_QWORD *)this + 62) = v29;
    operator delete(v29);
  }
  v30 = (void *)*((_QWORD *)this + 58);
  if (v30)
  {
    *((_QWORD *)this + 59) = v30;
    operator delete(v30);
  }
  v31 = (void *)*((_QWORD *)this + 55);
  if (v31)
  {
    *((_QWORD *)this + 56) = v31;
    operator delete(v31);
  }
  v32 = (void *)*((_QWORD *)this + 52);
  if (v32)
  {
    *((_QWORD *)this + 53) = v32;
    operator delete(v32);
  }
  v35 = (void **)((char *)this + 392);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v35);
  v33 = (void *)*((_QWORD *)this + 46);
  if (v33)
  {
    *((_QWORD *)this + 47) = v33;
    operator delete(v33);
  }
  v34 = (void *)*((_QWORD *)this + 43);
  if (v34)
  {
    *((_QWORD *)this + 44) = v34;
    operator delete(v34);
  }
  v35 = (void **)((char *)this + 320);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v35);
  v35 = (void **)((char *)this + 296);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v35);
  v35 = (void **)((char *)this + 272);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v35);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 112);
  MicIssueDetectorCore::~MicIssueDetectorCore(this);
}

char *MicIssueDetectorCorev1::initialize(uint64_t a1, int a2, unsigned int a3, _QWORD *a4, float a5)
{
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char **v16;
  char **v17;
  char **v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char **v23;
  unsigned int v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  std::vector<unsigned int>::size_type v34;
  uint64_t v35;
  __int128 v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  char **v58;
  unint64_t v59;
  char **v60;
  unsigned int v61;
  unint64_t v62;
  std::vector<unsigned int>::value_type __u;

  v7 = (std::__shared_weak_count *)a4[1];
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  *(_DWORD *)(a1 + 76) = a2;
  *(_DWORD *)(a1 + 80) = (float)((float)((a2 - 1) * a2) * 0.5);
  *(_DWORD *)(a1 + 64) = a3;
  *(_DWORD *)(a1 + 68) = 2 * a3;
  *(_DWORD *)(a1 + 72) = a3 + 1;
  *(float *)(a1 + 56) = a5;
  *(float *)(a1 + 60) = a5 / (float)a3;
  if (v7)
  {
    v10 = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v12 = *(unsigned int *)(a1 + 76);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 296), v12);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 272), v12);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 392), v12);
  if (*(_DWORD *)(a1 + 76))
  {
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = *(unsigned int *)(a1 + 72);
      v16 = (char **)(*(_QWORD *)(a1 + 296) + v13);
      v17 = (char **)(*(_QWORD *)(a1 + 272) + v13);
      v18 = (char **)(*(_QWORD *)(a1 + 392) + v13);
      __u = 0;
      std::vector<float>::assign(v16, v15, &__u);
      __u = 0;
      std::vector<float>::assign(v17, v15, &__u);
      __u = 0;
      std::vector<float>::assign(v18, v15, &__u);
      ++v14;
      v13 += 24;
    }
    while (v14 < *(unsigned int *)(a1 + 76));
  }
  v19 = *(unsigned int *)(a1 + 80);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 320), v19);
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)(a1 + 344), v19);
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)(a1 + 368), v19);
  if (*(_DWORD *)(a1 + 80))
  {
    v20 = 0;
    v21 = 0;
    do
    {
      v22 = *(unsigned int *)(a1 + 68);
      v23 = (char **)(*(_QWORD *)(a1 + 320) + v20);
      __u = 0;
      std::vector<float>::assign(v23, v22, &__u);
      ++v21;
      v20 += 24;
    }
    while (v21 < *(unsigned int *)(a1 + 80));
  }
  std::vector<float>::resize(a1 + 1192, *(unsigned int *)(a1 + 68));
  v24 = *(_DWORD *)(a1 + 76);
  if (v24)
  {
    v25 = 0;
    v26 = 0;
    do
    {
      v27 = v26 + 1;
      if (v26 + 1 < v24)
      {
        v28 = 0;
        v29 = *(_QWORD *)(a1 + 344);
        v30 = *(_QWORD *)(a1 + 368);
        do
        {
          *(_DWORD *)(v29 + 4 * (v25 + v28)) = v26;
          *(_DWORD *)(v30 + 4 * (v25 + v28)) = v26 + v28 + 1;
          v24 = *(_DWORD *)(a1 + 76);
          ++v28;
        }
        while (v26 + v28 + 1 < v24);
        v25 += v28;
      }
      ++v26;
    }
    while (v27 < v24);
  }
  v31 = *(unsigned int *)(a1 + 72);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 416), v31, &__u);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 88), v31, &__u);
  v32 = *(unsigned int *)(a1 + 76);
  __u = -1017380864;
  std::vector<float>::assign((char **)(a1 + 560), v32, &__u);
  __u = -1017380864;
  std::vector<float>::assign((char **)(a1 + 488), v32, &__u);
  __u = -1017380864;
  std::vector<float>::assign((char **)(a1 + 512), v32, &__u);
  __u = -1017380864;
  std::vector<float>::assign((char **)(a1 + 536), v32, &__u);
  v33 = *(unsigned int *)(a1 + 76);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 440), v33, &__u);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 608), v33, &__u);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 632), v33, &__u);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 848), v33, &__u);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 584), v33, &__u);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 1040), v33, &__u);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 1072), v33, &__u);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 1096), v33, &__u);
  v34 = *(unsigned int *)(a1 + 76);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)(a1 + 680), v34, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)(a1 + 656), v34, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)(a1 + 704), v34, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)(a1 + 728), v34, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)(a1 + 752), v34, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)(a1 + 776), v34, &__u);
  if (*a4)
  {
    v35 = a4[1];
    *(_QWORD *)&v36 = *a4;
    *((_QWORD *)&v36 + 1) = v35;
    if (v35)
    {
      v37 = (unint64_t *)(v35 + 8);
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
    }
    v39 = *(std::__shared_weak_count **)(a1 + 120);
    *(_OWORD *)(a1 + 112) = v36;
    if (v39)
    {
      v40 = (unint64_t *)&v39->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
  }
  v42 = *(unsigned int *)(*(_QWORD *)(a1 + 112) + 120);
  std::vector<float>::resize(a1 + 872, v42);
  std::vector<float>::resize(a1 + 920, v42);
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)(a1 + 896), v42);
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)(a1 + 944), v42);
  std::vector<float>::resize(a1 + 968, v42);
  std::vector<float>::resize(a1 + 992, v42);
  std::vector<float>::resize(a1 + 1016, v42);
  v43 = *(_QWORD *)(a1 + 112);
  v44 = *(unsigned int *)(v43 + 120);
  if (!(_DWORD)v44)
    goto LABEL_37;
  memmove(*(void **)(a1 + 872), *(const void **)(v43 + 128), 4 * v44);
  v45 = *(_QWORD *)(a1 + 112);
  v46 = *(unsigned int *)(v45 + 120);
  if (!(_DWORD)v46)
    goto LABEL_37;
  memmove(*(void **)(a1 + 920), (const void *)(*(_QWORD *)(v45 + 128) + 4 * v46), 4 * v46);
  v47 = *(_QWORD *)(a1 + 112);
  v48 = *(unsigned int *)(v47 + 120);
  if (!(_DWORD)v48)
    goto LABEL_37;
  memmove(*(void **)(a1 + 968), (const void *)(*(_QWORD *)(v47 + 128) + 4 * (2 * v48)), 4 * v48);
  v49 = *(_QWORD *)(a1 + 112);
  v50 = *(unsigned int *)(v49 + 120);
  if ((_DWORD)v50
    && (memmove(*(void **)(a1 + 992), (const void *)(*(_QWORD *)(v49 + 128) + 4 * (3 * v50)), 4 * v50),
        v51 = *(_QWORD *)(a1 + 112),
        v52 = *(unsigned int *)(v51 + 120),
        (_DWORD)v52))
  {
    memmove(*(void **)(a1 + 1016), (const void *)(*(_QWORD *)(v51 + 128) + 4 * (4 * v52)), 4 * v52);
    v53 = *(unsigned int *)(*(_QWORD *)(a1 + 112) + 120);
  }
  else
  {
LABEL_37:
    v53 = 0;
  }
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 800), v53);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 824), v53);
  LODWORD(v54) = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 120);
  if ((_DWORD)v54)
  {
    v55 = 0;
    v56 = 0;
    do
    {
      v57 = *(unsigned int *)(a1 + 76);
      v58 = (char **)(*(_QWORD *)(a1 + 800) + v55);
      __u = -1017380864;
      std::vector<float>::assign(v58, v57, &__u);
      v59 = *(unsigned int *)(a1 + 76);
      v60 = (char **)(*(_QWORD *)(a1 + 824) + v55);
      __u = 1065353216;
      std::vector<float>::assign(v60, v59, &__u);
      ++v56;
      v54 = *(unsigned int *)(*(_QWORD *)(a1 + 112) + 120);
      v55 += 24;
    }
    while (v56 < v54);
  }
  v61 = *(_DWORD *)(a1 + 72);
  if (v61 <= v54)
    v62 = v54;
  else
    v62 = v61;
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 1120), v62, &__u);
  __u = 0;
  std::vector<float>::assign((char **)(a1 + 1144), v62, &__u);
  __u = 0;
  return std::vector<float>::assign((char **)(a1 + 1168), v62, &__u);
}

void MicIssueDetectorCorev1::reset(MicIssueDetectorCorev1 *this)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  char **v6;
  char **v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char **v11;
  unint64_t v12;
  unint64_t v13;
  std::vector<unsigned int>::size_type v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char **v18;
  std::vector<unsigned int>::value_type __u;

  *(_QWORD *)((char *)this + 172) = 0;
  *((_DWORD *)this + 64) = 0;
  *((_QWORD *)this + 25) = 0;
  LODWORD(v2) = *((_DWORD *)this + 19);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *((unsigned int *)this + 18);
      v6 = (char **)(*((_QWORD *)this + 37) + v3);
      v7 = (char **)(*((_QWORD *)this + 34) + v3);
      __u = 0;
      std::vector<float>::assign(v6, v5, &__u);
      __u = 0;
      std::vector<float>::assign(v7, v5, &__u);
      ++v4;
      v2 = *((unsigned int *)this + 19);
      v3 += 24;
    }
    while (v4 < v2);
  }
  if (*((_DWORD *)this + 20))
  {
    v8 = 0;
    v9 = 0;
    do
    {
      v10 = *((unsigned int *)this + 17);
      v11 = (char **)(*((_QWORD *)this + 40) + v8);
      __u = 0;
      std::vector<float>::assign(v11, v10, &__u);
      ++v9;
      v8 += 24;
    }
    while (v9 < *((unsigned int *)this + 20));
    LODWORD(v2) = *((_DWORD *)this + 19);
  }
  v12 = v2;
  __u = -1017380864;
  std::vector<float>::assign((char **)this + 61, v2, &__u);
  __u = -1017380864;
  std::vector<float>::assign((char **)this + 64, v12, &__u);
  __u = -1017380864;
  std::vector<float>::assign((char **)this + 67, v12, &__u);
  v13 = *((unsigned int *)this + 19);
  __u = 0;
  std::vector<float>::assign((char **)this + 55, v13, &__u);
  __u = 0;
  std::vector<float>::assign((char **)this + 76, v13, &__u);
  __u = 0;
  std::vector<float>::assign((char **)this + 79, v13, &__u);
  __u = 0;
  std::vector<float>::assign((char **)this + 130, v13, &__u);
  __u = 0;
  std::vector<float>::assign((char **)this + 134, v13, &__u);
  __u = 0;
  std::vector<float>::assign((char **)this + 137, v13, &__u);
  v14 = *((unsigned int *)this + 19);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)((char *)this + 680), v14, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)((char *)this + 656), v14, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)((char *)this + 704), v14, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)((char *)this + 728), v14, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)((char *)this + 752), v14, &__u);
  __u = 0;
  std::vector<unsigned int>::assign((std::vector<unsigned int> *)((char *)this + 776), v14, &__u);
  if (*(_DWORD *)(*((_QWORD *)this + 14) + 120))
  {
    v15 = 0;
    v16 = 0;
    do
    {
      v17 = *((unsigned int *)this + 19);
      v18 = (char **)(*((_QWORD *)this + 100) + v15);
      __u = -1017380864;
      std::vector<float>::assign(v18, v17, &__u);
      ++v16;
      v15 += 24;
    }
    while (v16 < *(unsigned int *)(*((_QWORD *)this + 14) + 120));
  }
}

float MicIssueDetectorCorev1::propagateStaticParameterChanges(MicIssueDetectorCorev1 *this, int32x2_t a2)
{
  uint64_t v3;
  float32x2_t v4;
  float v5;
  float v6;
  float v7;
  float v8;
  int32x2_t v9;
  unint64_t v10;
  float v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  unint64_t v19;
  float v20;
  float v21;
  float v22;
  unint64_t v23;
  unint64_t v24;
  float v25;
  float32x2_t v26;
  float32x2_t v27;
  int64x2_t v28;
  int32x2_t v29;
  float v30;
  float v31;
  unint64_t v32;
  unint64_t v33;
  float v34;
  float32x2_t v35;
  float32x2_t v36;
  float v37;
  float32x2_t v43;
  uint64_t v44;
  float32x2_t v45;
  uint64_t v46;
  float result;
  float v48;
  float v49;
  int32x2_t v50;
  float v51;
  float v52;
  float v53;

  *(float *)a2.i32 = *((float *)this + 14) / (float)*((unsigned int *)this + 17);
  v50 = a2;
  v53 = *((float *)this + 15);
  v3 = *((_QWORD *)this + 1);
  *((float *)this + 52) = expf(-1.0 / (float)((float)(*(float *)(v3 + 28) * 0.001) * v53));
  *((float *)this + 53) = expf(-1.0 / (float)(v53 * (float)(*(float *)(v3 + 32) * 0.001)));
  *((float *)this + 54) = expf(-1.0 / (float)(v53 * (float)(*(float *)(v3 + 36) * 0.001)));
  v4 = (float32x2_t)vdup_n_s32(0x3A83126Fu);
  *(uint32x2_t *)((char *)this + 164) = vcvt_u32_f32(vrndm_f32(vmul_n_f32(vmul_f32(*(float32x2_t *)(v3 + 40), v4), v53)));
  v5 = exp(*(float *)(v3 + 20) * 0.115129255);
  *((float *)this + 65) = v5;
  v6 = exp(*(float *)(v3 + 24) * 0.115129255);
  *((float *)this + 66) = v6;
  *((float *)this + 67) = expf(-1.0 / (float)(v53 * (float)(*(float *)(v3 + 72) * 0.001)));
  v9 = (int32x2_t)vcvt_u32_f32(vrndm_f32(vmul_n_f32(vmul_f32(*(float32x2_t *)(v3 + 76), v4), v53)));
  *((int32x2_t *)this + 24) = v9;
  v7 = *(float *)(v3 + 84);
  v8 = roundf(fabsf(*(float *)(v3 + 88) / *(float *)v50.i32));
  *(float *)v9.i32 = (float)*((unsigned int *)this + 16);
  if (v8 > *(float *)v9.i32)
    v8 = (float)*((unsigned int *)this + 16);
  *((_DWORD *)this + 267) = (unint64_t)v8;
  v10 = (unint64_t)v8;
  v11 = roundf(fabsf(v7 / *(float *)v50.i32));
  if (v11 > (float)v10)
    v11 = (float)v10;
  *((_DWORD *)this + 266) = (unint64_t)v11;
  v12 = *((_QWORD *)this + 14);
  if (*(_DWORD *)(v12 + 120))
  {
    v13 = 0;
    v14 = *((_QWORD *)this + 115);
    v15 = *((_QWORD *)this + 118);
    v16 = *((_QWORD *)this + 109);
    v17 = *((_QWORD *)this + 112);
    do
    {
      v18 = roundf(fabsf(*(float *)(v14 + 4 * v13) / *(float *)v50.i32));
      if (v18 > (float)*((unsigned int *)this + 16))
        v18 = (float)*((unsigned int *)this + 16);
      *(_DWORD *)(v15 + 4 * v13) = (unint64_t)v18;
      v19 = (unint64_t)v18;
      v20 = roundf(fabsf(*(float *)(v16 + 4 * v13) / *(float *)v50.i32));
      if (v20 > (float)v19)
        v20 = (float)v19;
      *(_DWORD *)(v17 + 4 * v13++) = (unint64_t)v20;
    }
    while (v13 < *(unsigned int *)(v12 + 120));
    *(float *)v9.i32 = (float)*((unsigned int *)this + 16);
  }
  v21 = roundf(fabsf(*(float *)v12 / *(float *)v50.i32));
  v22 = roundf(fabsf(*(float *)(v12 + 16) / *(float *)v50.i32));
  if (v22 > *(float *)v9.i32)
    v22 = *(float *)v9.i32;
  v23 = (unint64_t)v22;
  v24 = (unint64_t)v22;
  v25 = roundf(fabsf(*(float *)(v12 + 12) / *(float *)v50.i32));
  if (v25 > (float)v24)
    v25 = (float)v24;
  *((_DWORD *)this + 36) = (unint64_t)v25;
  *((_DWORD *)this + 37) = v23;
  v26 = (float32x2_t)vdup_lane_s32(v50, 0);
  v27 = vrnda_f32(vabs_f32(vdiv_f32(*(float32x2_t *)(v12 + 4), v26)));
  v28 = (int64x2_t)vcvtq_u64_f64(vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, (float32x2_t)__PAIR64__((float)v24, v9.u32[0])), (int8x8_t)__PAIR64__((float)v24, v9.u32[0]), (int8x8_t)v27)));
  v29 = vmovn_s64(v28);
  v30 = (float)v28.u32[0];
  if (v21 > v30)
    v21 = v30;
  *((_DWORD *)this + 33) = (unint64_t)v21;
  v31 = roundf(fabsf(*(float *)(v12 + 52) / *(float *)v50.i32));
  if (v31 > *(float *)v9.i32)
    v31 = *(float *)v9.i32;
  v32 = (unint64_t)v31;
  v33 = (unint64_t)v31;
  v34 = roundf(fabsf(*(float *)(v12 + 48) / *(float *)v50.i32));
  if (v34 > (float)v33)
    v34 = (float)v33;
  *((int32x2_t *)this + 17) = v29;
  *((_DWORD *)this + 38) = (unint64_t)v34;
  *((_DWORD *)this + 39) = v32;
  v35 = vrnda_f32(vabs_f32(vdiv_f32(*(float32x2_t *)(v12 + 92), v26)));
  v36 = (float32x2_t)vdup_lane_s32(v9, 0);
  *(int32x2_t *)((char *)this + 180) = vmovn_s64((int64x2_t)vcvtq_u64_f64(vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v36), (int8x8_t)v36, (int8x8_t)v35))));
  v37 = roundf(fabsf(*(float *)(v12 + 100) / *(float *)v50.i32));
  if (v37 <= *(float *)v9.i32)
    *(float *)v9.i32 = v37;
  *((_DWORD *)this + 47) = (unint64_t)*(float *)v9.i32;
  __asm { FMOV            V11.2S, #-1.0 }
  v43 = vdiv_f32(_D11, vmul_n_f32(vmul_f32(*(float32x2_t *)(v12 + 72), v4), v53));
  v48 = v43.f32[0];
  v51 = expf(v43.f32[1]);
  *(float *)&v44 = expf(v48);
  *((float *)&v44 + 1) = v51;
  *((_QWORD *)this + 28) = v44;
  v45 = vdiv_f32(_D11, vmul_n_f32(vmul_f32(*(float32x2_t *)(v12 + 36), v4), v53));
  v49 = v45.f32[0];
  v52 = expf(v45.f32[1]);
  *(float *)&v46 = expf(v49);
  *((float *)&v46 + 1) = v52;
  *(_QWORD *)((char *)this + 236) = v46;
  *((float *)this + 55) = expf(-1.0 / (float)(v53 * (float)((float)*(unsigned int *)(v12 + 116) * 0.001)));
  *((float *)this + 58) = floorf(v53 * (float)(*(float *)(v12 + 80) * 0.001));
  result = floorf(v53 * (float)(*(float *)(v12 + 44) * 0.001));
  *((float *)this + 61) = result;
  return result;
}

void MicIssueDetectorCorev1::process(MicIssueDetectorCorev1 *this, _QWORD *a2, _QWORD *a3, uint64_t a4, const void ***a5, _QWORD *a6, uint64_t a7, double a8, double a9, float a10)
{
  float v14;
  float v15;
  unint64_t v16;
  BOOL v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  float *v22;
  float *v23;
  uint64_t v24;
  float v25;
  float v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  float *v30;
  float *v31;
  vDSP_Length v32;
  float *v33;
  unint64_t v34;
  float v35;
  float v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  float v40;
  float v41;
  BOOL v42;
  float *v43;
  uint64_t v44;
  vDSP_Length v45;
  vDSP_Length v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  float *v51;
  vDSP_Length v52;
  float *v53;
  float *v54;
  float *v55;
  uint64_t v56;
  uint64_t v57;
  float v58;
  float v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  vDSP_Length v66;
  uint64_t v67;
  vDSP_Length v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  float v73;
  float v74;
  int v75;
  float v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  float *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t *v85;
  float *v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  float *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  float v97;
  uint64_t v98;
  _QWORD *v99;
  float v100;
  float v101;
  int v102;
  int v103;
  int v104;
  float v105;
  unint64_t v106;
  uint64_t v107;
  float v108;
  float v109;
  float v110;
  float v111;
  BOOL v112;
  unint64_t v113;
  _QWORD *v114;
  float v115;
  float v116;
  uint64_t v117;
  float *v118;
  unsigned int v119;
  unsigned int v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  float v126;
  float *v127;
  float v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  float v135;
  unint64_t v136;
  unsigned int v137;
  unsigned int v138;
  uint64_t v139;
  unsigned int v140;
  unsigned int v141;
  float *v142;
  float *v143;
  uint64_t v144;
  float *v145;
  float v146;
  float v147;
  float v148;
  float v149;
  unint64_t v150;
  unsigned __int8 v151;
  unsigned int v152;
  float v153;
  float v154;
  char v155;
  float v156;
  uint64_t v157;
  BOOL v158;
  BOOL v159;
  float *v160;
  float *v161;
  float v162;
  uint64_t v163;
  float v164;
  int v165;
  _BOOL4 v166;
  uint64_t v167;
  float v168;
  unsigned int v169;
  unsigned int v170;
  int v171;
  uint64_t v172;
  int v173;
  int v174;
  uint64_t v175;
  float v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  _QWORD *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  float v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float v195;
  unsigned int v196;
  float v197;
  float v198;
  float v199;
  float v200;
  unsigned int v201;
  float v202;
  unsigned int v203;
  float *v204;
  uint64_t v205;
  float *v206;
  uint64_t v207;
  unsigned int realp;
  float v209;
  int v210;
  int v211;
  _QWORD *v212;
  uint64_t v213;
  float *v214;
  float v215;
  uint64_t v216;
  char v217;
  float *v218;
  uint64_t v219;
  float v220;
  char v221;
  float *v222;
  float v223;
  float v224;
  unint64_t v225;
  unsigned int v226;
  uint64_t v227;
  uint64_t v228;
  unsigned int v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  unint64_t v233;
  unint64_t v234;
  uint64_t v235;
  unint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  float v240;
  float *v241;
  float *v242;
  uint64_t v243;
  float v244;
  float v245;
  float v246;
  uint64_t v247;
  uint64_t v248;
  unsigned int v249;
  uint64_t v250;
  const void **v251;
  uint64_t v252;
  BOOL v253;
  unint64_t v254;
  int v255;
  _BOOL4 v256;
  unint64_t v257;
  unint64_t v258;
  unint64_t v259;
  const float *v260;
  uint64_t v261;
  float *v262;
  const float *v263;
  float *v264;
  const float *v265;
  float v266;
  vDSP_Length v267;
  const float *v268;
  uint64_t v269;
  float *v270;
  const float *v271;
  float *v272;
  const float *v273;
  float v274;
  vDSP_Length v275;
  uint64_t v276;
  float v277;
  uint64_t v278;
  unsigned int v279;
  float v280;
  uint64_t v281;
  int64_t v282;
  char v283;
  float v284;
  uint64_t v286;
  unint64_t v287;
  uint64_t v288;
  float *v289;
  uint64_t v290;
  uint64_t v293;
  unsigned int v294;
  uint64_t v295;
  uint64_t v296;
  _QWORD *v298;
  _QWORD *v299;
  float v300;
  float v301;
  DSPSplitComplex __D;
  DSPSplitComplex __B;
  DSPSplitComplex __A;

  v14 = *(float *)(*((_QWORD *)this + 1) + 12);
  if (v14 >= 0.0)
    *(_DWORD *)(*((_QWORD *)this + 14) + 152) = (int)v14;
  v15 = *((float *)this + 65);
  LODWORD(v16) = *((_DWORD *)this + 19);
  v17 = v15 <= 0.0 || v15 == 1.0;
  v289 = (float *)((char *)this + 260);
  if (v17)
    goto LABEL_10;
  if ((_DWORD)v16)
  {
    v18 = 0;
    v19 = 0;
    do
    {
      vDSP_vsmul(*(const float **)(*a2 + v18), 1, (const float *)this + 65, *(float **)(*a2 + v18), 1, (uint64_t)(*(_QWORD *)(*a2 + v18 + 8) - *(_QWORD *)(*a2 + v18)) >> 2);
      ++v19;
      v16 = *((unsigned int *)this + 19);
      v18 += 24;
    }
    while (v19 < v16);
LABEL_10:
    if ((_DWORD)v16)
    {
      v20 = 0;
      v21 = 0;
      do
      {
        v22 = *(float **)(*((_QWORD *)this + 37) + v20);
        v23 = *(float **)(*((_QWORD *)this + 34) + v20);
        v24 = *((unsigned int *)this + 16);
        __A.realp = *(float **)(*a2 + v20);
        __A.imagp = &__A.realp[v24];
        v25 = *__A.realp;
        v26 = *__A.imagp;
        v27 = *((_DWORD *)this + 18) - 1;
        vDSP_zvmags(&__A, 1, v23, 1, v27);
        *v23 = v25 * v25;
        v23[v27] = v26 * v26;
        LODWORD(__B.realp) = *((_DWORD *)this + 52);
        *(float *)&__D.realp = 1.0 - *(float *)&__B.realp;
        vDSP_vsmsma(v22, 1, (const float *)&__B, v23, 1, (const float *)&__D, v22, 1, *((unsigned int *)this + 18));
        ++v21;
        v16 = *((unsigned int *)this + 19);
        v20 += 24;
      }
      while (v21 < v16);
    }
  }
  if (*((_DWORD *)this + 20))
  {
    v28 = 0;
    v29 = 0;
    do
    {
      v30 = *(float **)(*a2 + 24 * *(unsigned int *)(*((_QWORD *)this + 46) + 4 * v29));
      v31 = *(float **)(*((_QWORD *)this + 40) + v28);
      v32 = *((unsigned int *)this + 16);
      v33 = (float *)(*(_QWORD *)(*a2 + 24 * *(unsigned int *)(*((_QWORD *)this + 43) + 4 * v29)) + 4 * v32);
      __A.realp = *(float **)(*a2 + 24 * *(unsigned int *)(*((_QWORD *)this + 43) + 4 * v29));
      __A.imagp = v33;
      __B.realp = v30;
      __B.imagp = &v30[v32];
      __D.realp = (float *)*((_QWORD *)this + 149);
      __D.imagp = &__D.realp[v32];
      vDSP_zvcmul(&__B, 1, &__A, 1, &__D, 1, v32);
      *__D.realp = *__A.realp * *__B.realp;
      *__D.imagp = *__A.imagp * *__B.imagp;
      v301 = *((float *)this + 52);
      v300 = 1.0 - v301;
      vDSP_vsmsma(v31, 1, &v301, *((const float **)this + 149), 1, &v300, v31, 1, *((unsigned int *)this + 16));
      vDSP_vsmsma(&v31[*((unsigned int *)this + 16)], 1, &v301, (const float *)(*((_QWORD *)this + 149) + 4 * *((unsigned int *)this + 16)), 1, &v300, &v31[*((unsigned int *)this + 16)], 1, *((unsigned int *)this + 16));
      ++v29;
      v28 += 24;
    }
    while (v29 < *((unsigned int *)this + 20));
    LODWORD(v16) = *((_DWORD *)this + 19);
  }
  v299 = a2;
  if ((_DWORD)v16)
  {
    v34 = 0;
    do
    {
      *(float *)(*((_QWORD *)this + 61) + 4 * v34) = MicIssueDetectorCorev1::calculateMeanEnergyInFreqRange((float **)this, *((_DWORD *)this + 35), *((_DWORD *)this + 36), *((float *)this + 53), *(float *)(*((_QWORD *)this + 61) + 4 * v34), a10, *(const float **)(*((_QWORD *)this + 37) + 24 * v34));
      *(float *)(*((_QWORD *)this + 64) + 4 * v34) = MicIssueDetectorCorev1::calculateMeanEnergyInFreqRange((float **)this, *((_DWORD *)this + 36), *((_DWORD *)this + 37), *((float *)this + 53), *(float *)(*((_QWORD *)this + 64) + 4 * v34), v35, *(const float **)(*((_QWORD *)this + 37) + 24 * v34));
      *(float *)(*((_QWORD *)this + 67) + 4 * v34) = MicIssueDetectorCorev1::calculateMeanEnergyInFreqRange((float **)this, *((_DWORD *)this + 38), *((_DWORD *)this + 39), *((float *)this + 54), *(float *)(*((_QWORD *)this + 67) + 4 * v34), v36, *(const float **)(*((_QWORD *)this + 34) + 24 * v34));
      if (*(_DWORD *)(*((_QWORD *)this + 14) + 120))
      {
        v37 = 0;
        v38 = 0;
        v39 = *((_QWORD *)this + 100);
        do
        {
          v40 = MicIssueDetectorCorev1::calculateMeanEnergyInFreqRange((float **)this, *(_DWORD *)(*((_QWORD *)this + 112) + 4 * v38), *(_DWORD *)(*((_QWORD *)this + 118) + 4 * v38), *((float *)this + 53), *(float *)(*(_QWORD *)(v39 + v37) + 4 * v34), a10, *(const float **)(*((_QWORD *)this + 37) + 24 * v34));
          v39 = *((_QWORD *)this + 100);
          *(float *)(*(_QWORD *)(v39 + v37) + 4 * v34) = v40;
          ++v38;
          v37 += 24;
        }
        while (v38 < *(unsigned int *)(*((_QWORD *)this + 14) + 120));
      }
      ++v34;
      v16 = *((unsigned int *)this + 19);
    }
    while (v34 < v16);
  }
  LODWORD(__A.realp) = 0;
  LODWORD(__B.realp) = 0;
  vDSP_maxv(*((const float **)this + 61), 1, (float *)&__A, v16);
  vDSP_maxv(*((const float **)this + 64), 1, (float *)&__B, *((unsigned int *)this + 19));
  v41 = *(float *)(*((_QWORD *)this + 14) + 20);
  v42 = *(float *)&__A.realp < v41;
  if (*(float *)&__B.realp >= v41)
    v42 = 0;
  *((_BYTE *)this + 128) = v42;
  v43 = (float *)*((_QWORD *)this + 146);
  vDSP_vfill(&MicIssueDetectorCorev1::kOnef, v43, 1, *((unsigned int *)this + 18));
  v290 = a4;
  v298 = a3;
  if (*((_DWORD *)this + 19))
  {
    v44 = 0;
    v45 = 0;
    do
    {
      vDSP_vfill(&MicIssueDetectorCorev1::kEpsf, *(float **)(*((_QWORD *)this + 49) + v44), 1, *((unsigned int *)this + 18));
      ++v45;
      v46 = *((unsigned int *)this + 19);
      v44 += 24;
    }
    while (v45 < v46);
  }
  else
  {
    v46 = 0;
  }
  vDSP_vfill(&MicIssueDetectorCorev1::kEpsdB, *((float **)this + 70), 1, v46);
  if (*((_DWORD *)this + 20))
  {
    v47 = 0;
    v48 = 0;
    do
    {
      v49 = *(unsigned int *)(*((_QWORD *)this + 43) + 4 * v48);
      v50 = *(unsigned int *)(*((_QWORD *)this + 46) + 4 * v48);
      v51 = (float *)*((_QWORD *)this + 143);
      v52 = *((unsigned int *)this + 16);
      __A.realp = *(float **)(*((_QWORD *)this + 40) + v47);
      __A.imagp = &__A.realp[v52];
      vDSP_zvmags(&__A, 1, *((float **)this + 140), 1, v52);
      v53 = (float *)*((_QWORD *)this + 140);
      *v53 = *__A.realp * *__A.realp;
      v53[*((unsigned int *)this + 16)] = *__A.imagp * *__A.imagp;
      vDSP_vmsa(*(const float **)(*((_QWORD *)this + 37) + 24 * v49), 1, *(const float **)(*((_QWORD *)this + 37) + 24 * v50), 1, &MicIssueDetectorCorev1::kEpsf, v51, 1, *((unsigned int *)this + 18));
      vDSP_vdiv(v51, 1, *((const float **)this + 140), 1, v51, 1, *((unsigned int *)this + 18));
      vDSP_vclip(v51, 1, &AUSpeechLevelEstimator::kVAD_Min, &AUSpeechLevelEstimator::kVAD_Max, v51, 1, *((unsigned int *)this + 18));
      v54 = *(float **)(*((_QWORD *)this + 49) + 24 * v49);
      vDSP_vmax(v54, 1, *((const float **)this + 143), 1, v54, 1, *((unsigned int *)this + 18));
      v55 = *(float **)(*((_QWORD *)this + 49) + 24 * v50);
      vDSP_vmax(v55, 1, *((const float **)this + 143), 1, v55, 1, *((unsigned int *)this + 18));
      vDSP_vmin(v43, 1, *((const float **)this + 143), 1, v43, 1, *((unsigned int *)this + 18));
      v56 = *((_QWORD *)this + 70);
      v57 = *((_QWORD *)this + 67);
      v58 = *(float *)(v56 + 4 * v49);
      if (v58 < *(float *)(v57 + 4 * v50))
        v58 = *(float *)(v57 + 4 * v50);
      *(float *)(v56 + 4 * v49) = v58;
      v59 = *(float *)(v56 + 4 * v50);
      if (v59 < *(float *)(v57 + 4 * v49))
        v59 = *(float *)(v57 + 4 * v49);
      *(float *)(v56 + 4 * v50) = v59;
      ++v48;
      v47 += 24;
    }
    while (v48 < *((unsigned int *)this + 20));
  }
  vDSP_meanv(&v43[*((unsigned int *)this + 38)], 1, (float *)this + 62, (*((_DWORD *)this + 39) - *((_DWORD *)this + 38) + 1));
  v60 = *((unsigned int *)this + 19);
  if ((_DWORD)v60)
  {
    v61 = 0;
    v62 = *((_QWORD *)this + 14);
    do
    {
      if (*(_DWORD *)(v62 + 120))
      {
        v63 = 0;
        v64 = 0;
        do
        {
          v65 = *(unsigned int *)(*((_QWORD *)this + 112) + 4 * v64);
          vDSP_meanv((const float *)(*(_QWORD *)(*((_QWORD *)this + 49) + 24 * v61) + 4 * v65), 1, (float *)(*(_QWORD *)(*((_QWORD *)this + 103) + v63) + 4 * v61), (*(_DWORD *)(*((_QWORD *)this + 118) + 4 * v64++) - v65 + 1));
          v62 = *((_QWORD *)this + 14);
          v63 += 24;
        }
        while (v64 < *(unsigned int *)(v62 + 120));
        v60 = *((unsigned int *)this + 19);
      }
      ++v61;
    }
    while (v61 < v60);
  }
  vDSP_vmax(**((const float ***)this + 49), 1, *(const float **)(*((_QWORD *)this + 49) + 24), 1, *((float **)this + 52), 1, *((unsigned int *)this + 18));
  v66 = *((unsigned int *)this + 19);
  if ((_DWORD)v66)
  {
    v67 = 0;
    v68 = 0;
    v69 = *((_QWORD *)this + 55);
    do
    {
      v70 = *(_QWORD *)(*((_QWORD *)this + 49) + v67);
      v71 = *((unsigned int *)this + 33);
      v72 = *((_DWORD *)this + 34);
      v73 = *((float *)this + 52);
      v74 = *(float *)(v69 + 4 * v68);
      v75 = *((unsigned __int8 *)this + 128);
      LODWORD(__A.realp) = 0;
      v76 = 0.0;
      if (!v75)
      {
        vDSP_meanv((const float *)(v70 + 4 * v71), 1, (float *)&__A, (v72 - v71 + 1));
        v76 = 1.0 - *(float *)&__A.realp;
        v69 = *((_QWORD *)this + 55);
        v66 = *((unsigned int *)this + 19);
      }
      *(float *)(v69 + 4 * v68++) = (float)((float)(1.0 - v73) * v76) + (float)(v73 * v74);
      v67 += 24;
    }
    while (v68 < v66);
  }
  else
  {
    v66 = 0;
  }
  vDSP_vclr(*((float **)this + 106), 1, v66);
  v77 = *((unsigned int *)this + 20);
  if ((_DWORD)v77)
  {
    v78 = 0;
    v79 = *((_QWORD *)this + 43);
    v80 = *((_QWORD *)this + 46);
    v81 = *(unsigned int *)(*((_QWORD *)this + 14) + 120);
    v82 = (float *)*((_QWORD *)this + 140);
    do
    {
      v83 = *(unsigned int *)(v79 + 4 * v78);
      v84 = *(unsigned int *)(v80 + 4 * v78);
      if ((_DWORD)v81)
      {
        v85 = (uint64_t *)*((_QWORD *)this + 100);
        v86 = v82;
        v87 = v81;
        do
        {
          v88 = *v85;
          v85 += 3;
          *v86++ = *(float *)(v88 + 4 * v83) - *(float *)(v88 + 4 * v84);
          --v87;
        }
        while (v87);
      }
      if ((MicIssueDetectorCorev1::isMicBlocked(this, v83, v82, 0) & 1) != 0)
        *(_DWORD *)(*((_QWORD *)this + 106) + 4 * v83) = 1065353216;
      if (MicIssueDetectorCorev1::isMicBlocked(this, v84, v82, 1))
        *(_DWORD *)(*((_QWORD *)this + 106) + 4 * v84) = 1065353216;
      ++v78;
    }
    while (v78 != v77);
  }
  *((_DWORD *)this + 40) = 0;
  if (!*((_DWORD *)this + 19))
  {
    LODWORD(v106) = 0;
    v97 = 1.0;
    v98 = v290;
    v99 = v299;
    goto LABEL_86;
  }
  v89 = 0;
  v90 = *((_QWORD *)this + 4);
  v91 = *(float **)(v90 + 48);
  v92 = *((_QWORD *)this + 106);
  v93 = *((_QWORD *)this + 1);
  v94 = *((_QWORD *)this + 88);
  v95 = *((_QWORD *)this + 91);
  v96 = *(_QWORD *)(v90 + 72);
  v97 = 1.0;
  v98 = v290;
  v99 = v299;
  do
  {
    v100 = (float)((float)(1.0 - *((float *)this + 55)) * *(float *)(v92 + 4 * v89))
         + (float)(*((float *)this + 55) * v91[v89]);
    v91[v89] = v100;
    v101 = *(float *)(v93 + 52);
    v102 = v100 > v101;
    if (*(_DWORD *)(v94 + 4 * v89) == v102)
    {
      v103 = *(_DWORD *)(v95 + 4 * v89);
      if (!v103)
        goto LABEL_71;
      v104 = v103 - 1;
    }
    else if (v100 <= v101)
    {
      v104 = *((_DWORD *)this + 42);
    }
    else
    {
      v104 = *((_DWORD *)this + 41);
    }
    *(_DWORD *)(v95 + 4 * v89) = v104;
    if (v104)
    {
      v105 = *(float *)(v96 + 4 * v89);
      goto LABEL_75;
    }
LABEL_71:
    if (v100 <= v101)
      v105 = 0.0;
    else
      v105 = 1.0;
    *(float *)(v96 + 4 * v89) = v105;
    *(_DWORD *)(v95 + 4 * v89) = *((_DWORD *)this + 41);
LABEL_75:
    *(_DWORD *)(v94 + 4 * v89) = v102;
    if (v105 != 0.0)
      ++*((_DWORD *)this + 40);
    v97 = v97 * v100;
    ++v89;
    v106 = *((unsigned int *)this + 19);
  }
  while (v89 < v106);
  if ((_DWORD)v106)
  {
    v107 = *((unsigned int *)this + 19);
    v108 = v97;
    do
    {
      v109 = *v91++;
      v110 = v109;
      if (v109 >= 1.0e-22)
        v111 = v110;
      else
        v111 = 1.0e-22;
      v108 = v108 + (float)((float)(v97 / v111) * (float)(1.0 - v110));
      --v107;
    }
    while (v107);
    v97 = v108;
  }
LABEL_86:
  *((float *)this + 63) = 1.0 - v97;
  if (*((_BYTE *)this + 128))
    v112 = 1;
  else
    v112 = *((_DWORD *)this + 40) >= (v106 - 1);
  *((_BYTE *)this + 129) = v112;
  if ((_DWORD)v106)
  {
    v113 = 0;
    v114 = (_QWORD *)*((_QWORD *)this + 4);
    while (1)
    {
      v115 = 0.0;
      if (*(float *)(v114[9] + 4 * v113) == 0.0 && !*((_BYTE *)this + 129))
      {
        v115 = *(float *)(*((_QWORD *)this + 55) + 4 * v113);
        v116 = *(float *)(*((_QWORD *)this + 14) + 20);
        if (*(float *)(*((_QWORD *)this + 61) + 4 * v113) < v116
          && *(float *)(*((_QWORD *)this + 64) + 4 * v113) < v116)
        {
          v115 = 0.0;
        }
      }
      v117 = *(_QWORD *)(*((_QWORD *)this + 49) + 24 * v113);
      v118 = (float *)*((_QWORD *)this + 140);
      vDSP_vclr(v118, 1, *((unsigned int *)this + 18));
      v119 = *((_DWORD *)this + 35);
      v120 = *((_DWORD *)this + 37);
      if (v119 <= v120)
      {
        v121 = 1.0 - *(float *)(*((_QWORD *)this + 1) + 48);
        do
        {
          if (*(float *)(v117 + 4 * v119) >= v121)
            v122 = 0.0;
          else
            v122 = 1.0;
          v118[v119++] = v122;
        }
        while (v119 <= v120);
      }
      vDSP_vmul(*(const float **)(*((_QWORD *)this + 37) + 24 * v113), 1, *((const float **)this + 140), 1, *((float **)this + 140), 1, *((unsigned int *)this + 18));
      v124 = 0.0;
      if (v115 > *(float *)(*((_QWORD *)this + 1) + 48))
        v124 = (float)*((unsigned int *)this + 37);
      v125 = MicIssueDetectorCorev1::calculateMeanEnergyInFreqRange((float **)this, *((_DWORD *)this + 35), v124, *((float *)this + 53), *(float *)(*(_QWORD *)(*((_QWORD *)this + 4) + 96) + 4 * v113), v123, *((const float **)this + 140));
      v114 = (_QWORD *)*((_QWORD *)this + 4);
      *(float *)(v114[12] + 4 * v113) = v125;
      if (v125 <= *(float *)(*((_QWORD *)this + 14) + 20))
        v126 = 0.0;
      else
        v126 = v115;
      *(float *)(*v114 + 4 * v113) = v126;
      v127 = (float *)*((_QWORD *)this + 1);
      v128 = v127[12];
      v129 = v126 > v128;
      v130 = *((_QWORD *)this + 94);
      v131 = *((_QWORD *)this + 97);
      v132 = v114[3];
      if (*(_DWORD *)(v130 + 4 * v113) == v129)
      {
        v133 = *(_DWORD *)(v131 + 4 * v113);
        if (!v133)
          goto LABEL_114;
        v134 = v133 - 1;
      }
      else if (v126 <= v128)
      {
        v134 = *((_DWORD *)this + 42);
      }
      else
      {
        v134 = *((_DWORD *)this + 41);
      }
      *(_DWORD *)(v131 + 4 * v113) = v134;
      if (!v134)
      {
LABEL_114:
        if (v126 <= v128)
          v135 = 0.0;
        else
          v135 = 1.0;
        *(float *)(v132 + 4 * v113) = v135;
        *(_DWORD *)(v131 + 4 * v113) = *((_DWORD *)this + 41);
      }
      *(_DWORD *)(v130 + 4 * v113++) = v129;
      if (v113 >= *((unsigned int *)this + 19))
      {
        LODWORD(v136) = *((_DWORD *)this + 19);
        goto LABEL_121;
      }
    }
  }
  LODWORD(v136) = 0;
  v127 = (float *)*((_QWORD *)this + 1);
LABEL_121:
  if (v127[15] == 0.0)
  {
    v167 = 196;
    if (v127[17] == 1.0)
      v167 = 192;
    *((_DWORD *)this + 51) = *(_DWORD *)((char *)this + v167);
    v127[17] = 0.0;
  }
  else
  {
    v137 = v136 - 1;
    v138 = *(_DWORD *)(*((_QWORD *)this + 14) + 152);
    if (v138 >= (int)v136 - 1)
      v139 = v137;
    else
      v139 = v138;
    v140 = v127[16];
    if (v137 >= v140)
      v141 = v140;
    else
      v141 = v136 - 1;
    if ((_DWORD)v136)
    {
      v294 = v141;
      v142 = (float *)*((_QWORD *)this + 130);
      v143 = *(float **)(*((_QWORD *)this + 4) + 144);
      v144 = v136;
      v145 = v142;
      do
      {
        v146 = *((float *)this + 67);
        v147 = *v145;
        v148 = *v143++;
        v149 = exp(v148 * 0.230258509);
        *v145++ = (float)((float)(1.0 - v146) * v149) + (float)(v146 * v147);
        --v144;
      }
      while (v144);
      v150 = 0;
      v151 = 0;
      v152 = 0;
      v154 = log10f(v142[v139] + 2.2204e-16) * 10.0;
      v155 = 1;
      do
      {
        *(float *)(*((_QWORD *)this + 134) + 4 * v150) = MicIssueDetectorCorev1::calculateMeanEnergyInFreqRange((float **)this, *((_DWORD *)this + 266), *((_DWORD *)this + 267), *((float *)this + 53), *(float *)(*((_QWORD *)this + 134) + 4 * v150), v153, *(const float **)(*((_QWORD *)this + 37) + 24 * v150));
        vDSP_meanv((const float *)(*(_QWORD *)(*((_QWORD *)this + 49) + 24 * v150) + 4 * *((unsigned int *)this + 266)), 1, (float *)(*((_QWORD *)this + 137) + 4 * v150), (*((_DWORD *)this + 267) - *((_DWORD *)this + 266) + 1));
        v156 = log10f(*(float *)(*((_QWORD *)this + 130) + 4 * v150) + 2.2204e-16) * 10.0;
        v157 = *((_QWORD *)this + 4);
        v158 = v156 > *(float *)(*(_QWORD *)(v157 + 240) + 4 * v150);
        if (v150 != v139)
        {
          v159 = (float)(v154 - v156) > *(float *)(*(_QWORD *)(v157 + 24 * v150 + 264) + 4 * v139);
          v160 = (float *)*((_QWORD *)this + 1);
          if (v154 <= -60.0)
            v161 = v160 + 25;
          else
            v161 = (float *)(*(_QWORD *)(v157 + 24 * v150 + 456) + 4 * v139);
          if (*(float *)(*((_QWORD *)this + 137) + 4 * v139) >= v160[23])
          {
            v165 = 0;
          }
          else
          {
            v162 = *v161;
            v163 = *((_QWORD *)this + 134);
            v153 = *(float *)(v163 + 4 * v139);
            v164 = v160[24];
            v165 = (float)(*(float *)(v163 + 4 * v150) - v153) > v162;
            if (v153 >= v164)
              v165 = 0;
          }
          v151 |= v159;
          v152 += v165;
        }
        v155 &= v158;
        ++v150;
        v136 = *((unsigned int *)this + 19);
      }
      while (v150 < v136);
      v98 = v290;
      v99 = v299;
      if ((v155 & 1) != 0)
      {
        v141 = v294;
        v166 = v154 > -60.0;
        goto LABEL_149;
      }
      v169 = 0;
      v166 = v154 > -60.0;
    }
    else
    {
      v168 = log10f(*(float *)(*((_QWORD *)this + 130) + 4 * v139) + 2.2204e-16);
      LODWORD(v136) = 0;
      v151 = 0;
      v152 = 0;
      v166 = (float)(v168 * 10.0) > -60.0;
      v157 = *((_QWORD *)this + 4);
LABEL_149:
      v169 = v151 & (*(float *)(*(_QWORD *)(v157 + 24) + 4 * v141) == 0.0);
    }
    v170 = v136 - 1;
    v171 = v136 - 2;
    if ((v136 - 2) <= 1)
      v171 = 1;
    if (!v166)
      v170 = v171;
    if (v152 >= v170)
      v169 = 1;
    v172 = *((_QWORD *)this + 1);
    v173 = *((_DWORD *)this + 48);
    if (*((_QWORD *)this + 24))
    {
      if (*((_DWORD *)this + 50) == v169)
      {
        v174 = *((_DWORD *)this + 51);
        if (v174)
        {
          v173 = v174 - 1;
          goto LABEL_164;
        }
        goto LABEL_165;
      }
      if (!v169)
        v173 = *((_DWORD *)this + 49);
LABEL_164:
      *((_DWORD *)this + 51) = v173;
      if (!v173)
LABEL_165:
        *(float *)(v172 + 68) = (float)v169;
      *((_DWORD *)this + 50) = v169;
    }
    else
    {
      *(float *)(v172 + 68) = (float)v169;
    }
  }
  vDSP_vclr(*((float **)this + 73), 1, v136);
  v175 = *((_QWORD *)this + 14);
  v176 = expf((float)(*((float *)this + 62) - *(float *)(v175 + 56)) * 50.0);
  LODWORD(v177) = *((_DWORD *)this + 19);
  if (!(_DWORD)v177)
    goto LABEL_191;
  v178 = 0;
  v179 = *((_QWORD *)this + 67);
  v180 = *((_QWORD *)this + 73);
  v181 = *((_QWORD *)this + 76);
  v295 = *((_QWORD *)this + 85);
  v296 = *((_QWORD *)this + 70);
  v182 = (_QWORD *)*((_QWORD *)this + 4);
  v183 = v182[12];
  v184 = *((_QWORD *)this + 79);
  v293 = *((_QWORD *)this + 82);
  v185 = v182[9];
  v186 = v182[15];
  v187 = 1.0 / (float)(v176 + 1.0);
  while (2)
  {
    v188 = *(float *)(v179 + 4 * v178) - *(float *)(v296 + 4 * v178);
    if (v188 < 0.0)
      v188 = 0.0;
    v189 = (float)(v187 * *((float *)this + 63)) * v188;
    *(float *)(v180 + 4 * v178) = v189;
    v190 = *(float *)(v179 + 4 * v178);
    v191 = 0.0;
    if (v190 > *(float *)(v175 + 84))
    {
      v192 = *(float *)(v175 + 60);
      v191 = v192 / (float)(expf(-(float)(*(float *)(v175 + 64) * (float)(v189 - *(float *)(v175 + 68)))) + 1.0);
    }
    v193 = fminf(*(float *)(v175 + 88) - v190, 0.0);
    if (v191 >= v193)
      v193 = v191;
    v194 = *(float *)(v181 + 4 * v178);
    if (v193 < v194)
    {
      v195 = *((float *)this + 56);
      goto LABEL_177;
    }
    v195 = *((float *)this + 57);
    if (v193 > v194)
    {
      v196 = *(_DWORD *)(v295 + 4 * v178);
      if (*((float *)this + 58) > (float)v196)
      {
        *(_DWORD *)(v295 + 4 * v178) = v196 + 1;
        v195 = 1.0;
        if ((float)(v194 * -0.9) <= (float)-v193)
LABEL_177:
          *(_DWORD *)(v295 + 4 * v178) = 0;
      }
    }
    *(float *)(v181 + 4 * v178) = (float)(v193 * (float)(1.0 - v195)) + (float)(v195 * v194);
    v197 = *(float *)(v175 + 24);
    v198 = v197
         / (float)(expf(-(float)(*(float *)(v175 + 28) * (float)(*(float *)(v183 + 4 * v178) - *(float *)(v175 + 32))))
                 + 1.0);
    v199 = *(float *)(v184 + 4 * v178);
    if (v198 < v199)
    {
      v200 = *((float *)this + 59);
      goto LABEL_183;
    }
    v200 = *((float *)this + 60);
    if (v198 > v199)
    {
      v201 = *(_DWORD *)(v293 + 4 * v178);
      if (*((float *)this + 61) > (float)v201)
      {
        *(_DWORD *)(v293 + 4 * v178) = v201 + 1;
        v200 = 1.0;
        if ((float)(v199 * -0.9) <= (float)-v198)
LABEL_183:
          *(_DWORD *)(v293 + 4 * v178) = 0;
      }
    }
    v202 = (float)(v198 * (float)(1.0 - v200)) + (float)(v200 * v199);
    *(float *)(v184 + 4 * v178) = v202;
    if (*(float *)(v181 + 4 * v178) < v202)
      v202 = *(float *)(v181 + 4 * v178);
    *(float *)(v186 + 4 * v178) = (float)(1.0 - *(float *)(v185 + 4 * v178)) * expf(v202 * 0.11513);
    ++v178;
    v177 = *((unsigned int *)this + 19);
    if (v178 < v177)
      continue;
    break;
  }
  v98 = v290;
  v99 = v299;
LABEL_191:
  v203 = *(_DWORD *)(v175 + 152);
  if ((int)v177 - 1 < (int)v203)
    v203 = v177 - 1;
  v204 = (float *)*((_QWORD *)this + 1);
  if (v204[15] != 0.0 && v204[17] != 0.0)
  {
    *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 4) + 120) + 4 * v203) = 452053249;
    v203 = v204[16];
    if ((int)v177 - 1 < v203)
      v203 = v177 - 1;
  }
  v205 = *((_QWORD *)this + 4);
  if ((v203 & 0x80000000) != 0)
  {
    v206 = *(float **)(v205 + 120);
  }
  else
  {
    v206 = *(float **)(v205 + 120);
    if (v206[v203] > *(float *)(v175 + 156))
    {
      v207 = v203;
      vDSP_vfill(&MicIssueDetectorCorev1::kEpsf, v206, 1, v177);
      v206 = *(float **)(*((_QWORD *)this + 4) + 120);
      v206[v207] = 1.0;
      LODWORD(v177) = *((_DWORD *)this + 19);
    }
  }
  LODWORD(__B.realp) = -1018691584;
  __A.realp = 0;
  vDSP_maxvi(v206, 1, (float *)&__B, (vDSP_Length *)&__A, v177);
  realp = __A.realp;
  v209 = (float)(unint64_t)__A.realp;
  if (*((float *)this + 64) == (float)(unint64_t)__A.realp)
  {
    v210 = *((_DWORD *)this + 43);
    if (v210)
    {
      v211 = v210 - 1;
      goto LABEL_205;
    }
    v211 = 0;
  }
  else
  {
    v211 = *((_DWORD *)this + 41);
LABEL_205:
    *((_DWORD *)this + 43) = v211;
  }
  v212 = (_QWORD *)*((_QWORD *)this + 4);
  v213 = v212[15];
  v214 = (float *)*((_QWORD *)this + 1);
  v215 = *(float *)(v213 + 4 * v214[2]);
  if (v215 < 1.0e-22)
    v215 = 1.0e-22;
  if (!v211 || (float)(*(float *)(v213 + 4 * realp) / v215) > 1.4125)
  {
    v214[2] = v209;
    *((_DWORD *)this + 43) = *((_DWORD *)this + 41);
  }
  *((float *)this + 64) = v209;
  *(_DWORD *)(v213 + 4 * v214[2]) = 1065353216;
  v216 = *((unsigned int *)this + 19);
  if ((_DWORD)v216)
  {
    v217 = 0;
    v218 = (float *)v212[3];
    v219 = *((unsigned int *)this + 19);
    do
    {
      v220 = *v218++;
      v217 |= v220 != 0.0;
      --v219;
    }
    while (v219);
    v221 = 0;
    *v214 = (float)(v217 & 1);
    v222 = (float *)v212[9];
    do
    {
      v223 = *v222++;
      v221 |= v223 != 0.0;
      --v216;
    }
    while (v216);
    v224 = (float)(v221 & 1);
  }
  else
  {
    *v214 = 0.0;
    v224 = 0.0;
  }
  v214[1] = v224;
  vDSP_vfill(&MicIssueDetectorCorev1::kOnef, *((float **)this + 11), 1, *((unsigned int *)this + 18));
  if (**((float **)this + 1) != 0.0)
  {
    v225 = *((unsigned int *)this + 45);
    v226 = *((_DWORD *)this + 47);
    if (v225 <= v226)
    {
      v227 = *((_QWORD *)this + 14);
      v228 = *((_QWORD *)this + 52);
      v229 = *((_DWORD *)this + 45);
      v230 = *((_QWORD *)this + 11);
      do
      {
        *(float *)(v230 + 4 * v229) = *((float *)this + 66)
                                      + (float)((float)(1.0 - *((float *)this + 66))
                                              * (float)((float)(tanhf(*(float *)(v227 + 104)* (float)(*(float *)(v228 + 4 * v229)- *(float *)(v227 + 108)))+ 1.0)* 0.5));
        ++v229;
      }
      while (v229 <= v226);
    }
    v232 = *((_QWORD *)this + 58);
    v231 = *((_QWORD *)this + 59);
    v233 = (v231 - v232) >> 2;
    v234 = v233 >> 1;
    if (v233 >> 1 > v225)
      v225 = v233 >> 1;
    vDSP_vclr(*((float **)this + 140), 1, (uint64_t)(*((_QWORD *)this + 141) - *((_QWORD *)this + 140)) >> 2);
    v235 = *((unsigned int *)this + 47);
    v236 = v235 - (v233 >> 1);
    if (v225 <= v236)
    {
      if (v233 <= 1)
        v237 = 1;
      else
        v237 = (v231 - v232) >> 2;
      v238 = 4 * v225 - 4 * v234;
      do
      {
        if (v231 != v232)
        {
          v239 = *((_QWORD *)this + 140);
          v240 = *(float *)(v239 + 4 * v225);
          v241 = (float *)(*((_QWORD *)this + 58) + 4 * v233 - 4 * v234);
          v242 = (float *)(*((_QWORD *)this + 11) + v238);
          v243 = v237;
          do
          {
            v244 = *v242++;
            v245 = v244;
            v246 = *v241--;
            v240 = v240 + (float)(v245 * v246);
            *(float *)(v239 + 4 * v225) = v240;
            --v243;
          }
          while (v243);
        }
        ++v225;
        v238 += 4;
      }
      while (v225 <= v236);
    }
    v98 = v290;
    if (v234 <= v236)
    {
      v247 = *((_QWORD *)this + 140);
      v248 = *((_QWORD *)this + 11);
      do
      {
        *(_DWORD *)(v248 + 4 * v234) = *(_DWORD *)(v247 + 4 * v234);
        ++v234;
      }
      while (v234 <= v236);
    }
    v249 = *((_DWORD *)this + 46);
    if (v249 <= v235)
    {
      v250 = *((_QWORD *)this + 11);
      while (*(float *)(v250 + 4 * v249) <= *(float *)(*((_QWORD *)this + 14) + 112))
      {
        if (++v249 > v235)
          goto LABEL_244;
      }
      for (; v249 <= v235; ++v249)
        *(_DWORD *)(v250 + 4 * v249) = 1065353216;
    }
  }
LABEL_244:
  v251 = a5[1];
  if (v251 != *a5
    && ((v252 = a6[1] - *a6) != 0 ? (v253 = (char *)v251 - (char *)*a5 == v252) : (v253 = 0),
        v253
     && (v254 = (2 * *((_DWORD *)this + 16)), v254 <= ((_BYTE *)(*a5)[1] - (_BYTE *)**a5) >> 2)
     && v254 <= (uint64_t)(*(_QWORD *)(*a6 + 8) - *(_QWORD *)*a6) >> 2))
  {
    v256 = *(float *)(*((_QWORD *)this + 1) + 56) == 1.0;
    v255 = 1;
  }
  else
  {
    v255 = 0;
    v256 = 0;
  }
  vDSP_vclr(*(float **)v98, 1, (uint64_t)(*(_QWORD *)(v98 + 8) - *(_QWORD *)v98) >> 2);
  vDSP_vclr(*(float **)a7, 1, (uint64_t)(*(_QWORD *)(a7 + 8) - *(_QWORD *)a7) >> 2);
  LODWORD(__A.realp) = 0;
  vDSP_sve(*(const float **)(*((_QWORD *)this + 4) + 120), 1, (float *)&__A, *((unsigned int *)this + 19));
  LODWORD(v257) = *((_DWORD *)this + 19);
  if ((_DWORD)v257)
  {
    v258 = 0;
    v259 = 0;
    while (2)
    {
      v260 = *(const float **)(*v99 + v258);
      v261 = *((unsigned int *)this + 16);
      v262 = *(float **)(*v298 + v258);
      v263 = &v260[v261];
      v264 = &v262[v261];
      v265 = (const float *)*((_QWORD *)this + 11);
      v266 = *v263;
      v267 = *((unsigned int *)this + 18) - 1;
      vDSP_vmul(v260, 1, v265, 1, v262, 1, v267);
      vDSP_vmul(v263, 1, v265, 1, v264, 1, v267);
      *v264 = v266 * v265[v267];
      if (v256)
      {
        v268 = (const float *)(*a5)[v258 / 8];
        v269 = *((unsigned int *)this + 16);
        v270 = *(float **)(*a6 + v258);
        v271 = &v268[v269];
        v272 = &v270[v269];
        v273 = (const float *)*((_QWORD *)this + 11);
        v274 = *v271;
        v275 = *((unsigned int *)this + 18) - 1;
        vDSP_vmul(v268, 1, v273, 1, v270, 1, v275);
        vDSP_vmul(v271, 1, v273, 1, v272, 1, v275);
        *v272 = v274 * v273[v275];
        v99 = v299;
      }
      else
      {
        v99 = v299;
        if (v255 && 2 * *((_DWORD *)this + 16))
          memmove(*(void **)(*a6 + v258), (*a5)[v258 / 8], 4 * (2 * *((_DWORD *)this + 16)));
      }
      v276 = *(_QWORD *)(v98 + 8) - *(_QWORD *)v98;
      if (!v276)
        goto LABEL_275;
      LODWORD(__B.realp) = 0;
      v277 = *(float *)(*(_QWORD *)(*((_QWORD *)this + 4) + 120) + 4 * v259);
      *(float *)&__B.realp = v277;
      v278 = *((_QWORD *)this + 1);
      v279 = *(float *)(v278 + 16);
      if (v279 != 1)
      {
        if (!v279)
        {
          if (*(float *)(v278 + 8) == (float)(int)v259)
            v280 = 1.0;
          else
            v280 = 0.0;
LABEL_267:
          *(float *)&__B.realp = v280;
        }
        vDSP_vsmul(*(const float **)(*v99 + v258), 1, (const float *)&__B, *((float **)this + 149), 1, v276 >> 2);
        vDSP_vadd(*((const float **)this + 149), 1, *(const float **)v98, 1, *(float **)v98, 1, (uint64_t)(*(_QWORD *)(v98 + 8) - *(_QWORD *)v98) >> 2);
        v281 = *(_QWORD *)(a7 + 8);
        v282 = v281 - *(_QWORD *)a7;
        if (v281 != *(_QWORD *)a7)
        {
          if (v256)
          {
            vDSP_vsmul((const float *)(*a5)[v258 / 8], 1, (const float *)&__B, *((float **)this + 149), 1, v282 >> 2);
            vDSP_vadd(*((const float **)this + 149), 1, *(const float **)a7, 1, *(float **)a7, 1, (uint64_t)(*(_QWORD *)(a7 + 8) - *(_QWORD *)a7) >> 2);
          }
          else
          {
            v283 = v255 ^ 1;
            if (v259)
              v283 = 1;
            if ((v283 & 1) == 0)
              memmove(*(void **)a7, **a5, v282);
          }
        }
LABEL_275:
        ++v259;
        v257 = *((unsigned int *)this + 19);
        v258 += 24;
        if (v259 >= v257)
          goto LABEL_276;
        continue;
      }
      break;
    }
    v280 = v277 / *(float *)&__A.realp;
    goto LABEL_267;
  }
LABEL_276:
  v284 = *v289;
  if (*v289 > 0.0 && v284 != 1.0)
  {
    *(float *)&__B.realp = 1.0 / v284;
    if ((_DWORD)v257)
    {
      v286 = 0;
      v287 = 0;
      do
      {
        vDSP_vsmul(*(const float **)(*v298 + v286), 1, (const float *)&__B, *(float **)(*v298 + v286), 1, (uint64_t)(*(_QWORD *)(*v298 + v286 + 8) - *(_QWORD *)(*v298 + v286)) >> 2);
        ++v287;
        v286 += 24;
      }
      while (v287 < *((unsigned int *)this + 19));
    }
    v288 = *(_QWORD *)(v98 + 8) - *(_QWORD *)v98;
    if (v288)
      vDSP_vsmul(*(const float **)v98, 1, (const float *)&__B, *(float **)v98, 1, v288 >> 2);
  }
}

float MicIssueDetectorCorev1::calculateMeanEnergyInFreqRange(float **this, unsigned int a2, unsigned int a3, float a4, float a5, float a6, const float *a7)
{
  unsigned int v9;
  float v11;
  unsigned int __N;
  float __N_4;
  float __B;

  __B = 1.0e-22;
  __N_4 = -220.0;
  v9 = a3 - a2;
  if (a3 <= a2)
  {
    v11 = -220.0;
  }
  else
  {
    __N = v9 + 1;
    vDSP_vsadd(&a7[a2], 1, &__B, this[143], 1, (int)(v9 + 1));
    vvlog10f(this[143], this[143], (const int *)&__N);
    vDSP_meanv(this[143], 1, &__N_4, (int)__N);
    v11 = __N_4 * 10.0;
  }
  return (float)((float)(1.0 - a4) * v11) + (float)(a4 * a5);
}

uint64_t MicIssueDetectorCorev1::isMicBlocked(MicIssueDetectorCorev1 *this, unsigned int a2, float *a3, int a4)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  _BOOL4 v9;

  v4 = *(unsigned int *)(*((_QWORD *)this + 14) + 120);
  if (!(_DWORD)v4)
    return 1;
  v5 = 0;
  v6 = 0;
  v7 = 24 * v4;
  LODWORD(v4) = 1;
  do
  {
    v8 = a3[v5 / 4];
    if (!a4)
      v8 = -v8;
    v9 = *(float *)(*(_QWORD *)(*((_QWORD *)this + 103) + v6) + 4 * a2) < *(float *)(*((_QWORD *)this + 121) + v5)
      && *(float *)(*(_QWORD *)(*((_QWORD *)this + 100) + v6) + 4 * a2) < *(float *)(*((_QWORD *)this + 124) + v5)
      && v8 > *(float *)(*((_QWORD *)this + 127) + v5);
    v4 = v4 & v9;
    v6 += 24;
    v5 += 4;
  }
  while (v7 != v6);
  return v4;
}

void std::vector<unsigned int>::assign(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n, std::vector<unsigned int>::const_reference __u)
{
  uint64_t value;
  unsigned int *begin;
  std::vector<unsigned int>::size_type v8;
  unint64_t v9;
  std::vector<unsigned int>::pointer v10;
  unsigned int *v11;
  std::vector<unsigned int>::size_type v12;
  std::vector<unsigned int>::pointer end;
  std::vector<unsigned int>::size_type v14;
  std::vector<unsigned int>::size_type v15;
  unsigned int *v16;
  unsigned int *v17;
  std::vector<unsigned int>::size_type v18;

  value = (uint64_t)this->__end_cap_.__value_;
  begin = this->__begin_;
  if (__n <= (value - (uint64_t)begin) >> 2)
  {
    end = this->__end_;
    v14 = end - begin;
    if (v14 >= __n)
      v15 = __n;
    else
      v15 = end - begin;
    if (v15)
    {
      v16 = begin;
      do
      {
        *v16++ = *__u;
        --v15;
      }
      while (v15);
    }
    if (__n <= v14)
    {
      this->__end_ = &begin[__n];
    }
    else
    {
      v17 = &end[__n - v14];
      v18 = 4 * __n - 4 * v14;
      do
      {
        *end++ = *__u;
        v18 -= 4;
      }
      while (v18);
      this->__end_ = v17;
    }
  }
  else
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n >> 62)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v8 = value >> 1;
    if (value >> 1 <= __n)
      v8 = __n;
    if ((unint64_t)value >= 0x7FFFFFFFFFFFFFFCLL)
      v9 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v9 = v8;
    std::vector<unsigned int>::__vallocate[abi:ne180100](this, v9);
    v10 = this->__end_;
    v11 = &v10[__n];
    v12 = 4 * __n;
    do
    {
      *v10++ = *__u;
      v12 -= 4;
    }
    while (v12);
    this->__end_ = v11;
  }
}

void vp::NotificationHandler::create(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  std::string *v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v12;
  unint64_t v13;
  unint64_t *p_shared_weak_owners;
  unint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  const char *v27;
  int *v28;
  NSObject *global_queue;
  unint64_t *v30;
  unint64_t v31;
  NSObject *v32;
  _QWORD v33[5];
  std::__shared_weak_count *v34;
  _QWORD v35[3];
  _QWORD *v36;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v6 = operator new();
  v7 = a3[3];
  if (!v7)
    goto LABEL_4;
  if ((_QWORD *)v7 != a3)
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
LABEL_4:
    v36 = (_QWORD *)v7;
    goto LABEL_6;
  }
  v36 = v35;
  (*(void (**)(_QWORD *, _QWORD *))(*a3 + 24))(a3, v35);
LABEL_6:
  v8 = (std::string *)(v6 + 24);
  *(_QWORD *)v6 = 0;
  *(_QWORD *)(v6 + 8) = 0;
  *(_DWORD *)(v6 + 16) = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *(_QWORD *)(v6 + 40) = *(_QWORD *)(a2 + 16);
  }
  if (!v36)
  {
    v9 = (_QWORD *)(v6 + 72);
    goto LABEL_13;
  }
  if (v36 != v35)
  {
    v9 = &v36;
    *(_QWORD *)(v6 + 72) = v36;
LABEL_13:
    *v9 = 0;
    goto LABEL_15;
  }
  *(_QWORD *)(v6 + 72) = v6 + 48;
  (*(void (**)(_QWORD *))(v35[0] + 24))(v35);
LABEL_15:
  *(_BYTE *)(v6 + 80) = 1;
  *(_QWORD *)(v6 + 88) = 850045863;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + 112) = 0u;
  *(_OWORD *)(v6 + 128) = 0u;
  *(_QWORD *)(v6 + 144) = 0;
  *a1 = v6;
  v33[0] = v6;
  v10 = (std::__shared_weak_count *)operator new();
  v10->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69C60B0;
  v10->__shared_weak_owners_ = 0;
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)v6;
  a1[1] = (uint64_t)v10;
  v12 = *(std::__shared_weak_count **)(v6 + 8);
  if (v12)
  {
    if (v12->__shared_owners_ != -1)
      goto LABEL_28;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v15 = __ldxr(p_shared_weak_owners);
    while (__stxr(v15 + 1, p_shared_weak_owners));
    *(_QWORD *)v6 = v6;
    *(_QWORD *)(v6 + 8) = v10;
    std::__shared_weak_count::__release_weak(v12);
  }
  else
  {
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
    v17 = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
    *(_QWORD *)v6 = v6;
    *(_QWORD *)(v6 + 8) = v10;
  }
  do
    v19 = __ldaxr(p_shared_owners);
  while (__stlxr(v19 - 1, p_shared_owners));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
LABEL_28:
  v20 = v36;
  if (v36 == v35)
  {
    v21 = 4;
    v20 = v35;
  }
  else
  {
    if (!v36)
      goto LABEL_33;
    v21 = 5;
  }
  (*(void (**)(_QWORD *))(*v20 + 8 * v21))(v20);
LABEL_33:
  v22 = (uint64_t *)*a1;
  v24 = *(_QWORD *)*a1;
  v23 = *(std::__shared_weak_count **)(*a1 + 8);
  if (v23)
  {
    v25 = (unint64_t *)&v23->__shared_weak_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  v27 = (const char *)(v22 + 3);
  if (*((char *)v22 + 47) < 0)
    v27 = *(const char **)v27;
  v28 = (int *)(v22 + 2);
  global_queue = dispatch_get_global_queue(0, 0);
  v33[0] = MEMORY[0x1E0C809B0];
  v33[1] = 1174405120;
  v33[2] = ___ZN2vp19NotificationHandler10initializeEv_block_invoke;
  v33[3] = &__block_descriptor_tmp_3;
  v33[4] = v24;
  v34 = v23;
  if (v23)
  {
    v30 = (unint64_t *)&v23->__shared_weak_owners_;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  if (notify_register_dispatch(v27, v28, global_queue, v33))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    if (VPLogScope(void)::scope)
    {
      v32 = *(NSObject **)VPLogScope(void)::scope;
      if (!*(_QWORD *)VPLogScope(void)::scope)
        goto LABEL_50;
    }
    else
    {
      v32 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v38 = "vpNotificationHandler.cpp";
      v39 = 1024;
      v40 = 71;
      _os_log_impl(&dword_1B5ED0000, v32, OS_LOG_TYPE_ERROR, "%25s:%-5d notify_register_dispatch failed", buf, 0x12u);
    }
  }
LABEL_50:
  if (v34)
    std::__shared_weak_count::__release_weak(v34);
  if (v23)
    std::__shared_weak_count::__release_weak(v23);
}

void sub_1B6109EE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void ___ZN2vp19NotificationHandler10initializeEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_weak_owners;
  unint64_t v3;
  _QWORD v4[5];
  std::__shared_weak_count *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 1174405120;
  v4[2] = ___ZN2vp19NotificationHandler10initializeEv_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_111;
  v1 = *(std::__shared_weak_count **)(a1 + 40);
  v4[4] = *(_QWORD *)(a1 + 32);
  v5 = v1;
  if (v1)
  {
    p_shared_weak_owners = (unint64_t *)&v1->__shared_weak_owners_;
    do
      v3 = __ldxr(p_shared_weak_owners);
    while (__stxr(v3 + 1, p_shared_weak_owners));
  }
  ___ZN2vp19NotificationHandler10initializeEv_block_invoke_2((uint64_t)v4);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void sub_1B610A058(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, std::exception a16, __int128 buf, __int128 a18)
{
  NSObject *v19;
  NSObject *v20;
  const char *v21;

  if (!a2)
    _Unwind_Resume(a1);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a16.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5060] + 16);
    __cxa_begin_catch(a1);
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    if (VPLogScope(void)::scope)
    {
      v19 = *(NSObject **)VPLogScope(void)::scope;
      if (!*(_QWORD *)VPLogScope(void)::scope)
      {
LABEL_16:
        std::exception::~exception(&a16);
        __cxa_end_catch();
        goto LABEL_22;
      }
    }
    else
    {
      v19 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v21 = std::exception::what(&a16);
      LODWORD(buf) = 136315650;
      *(_QWORD *)((char *)&buf + 4) = "vpNotificationHandler.cpp";
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = 23;
      WORD1(a18) = 2080;
      *(_QWORD *)((char *)&a18 + 4) = v21;
      _os_log_impl(&dword_1B5ED0000, v19, OS_LOG_TYPE_ERROR, "%25s:%-5d Standard library exception caught: %s", (uint8_t *)&buf, 0x1Cu);
    }
    goto LABEL_16;
  }
  __cxa_begin_catch(a1);
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  if (VPLogScope(void)::scope)
  {
    v20 = *(NSObject **)VPLogScope(void)::scope;
    if (!*(_QWORD *)VPLogScope(void)::scope)
    {
LABEL_20:
      __cxa_end_catch();
LABEL_22:
      JUMPOUT(0x1B610A020);
    }
  }
  else
  {
    v20 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315394;
    *(_QWORD *)((char *)&buf + 4) = "vpNotificationHandler.cpp";
    WORD6(buf) = 1024;
    *(_DWORD *)((char *)&buf + 14) = 25;
    _os_log_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d Unknown exceptiton caught", (uint8_t *)&buf, 0x12u);
  }
  goto LABEL_20;
}

uint64_t __copy_helper_block_e8_32c49_ZTSNSt3__18weak_ptrIN2vp19NotificationHandlerEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c49_ZTSNSt3__18weak_ptrIN2vp19NotificationHandlerEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void ___ZN2vp19NotificationHandler10initializeEv_block_invoke_2(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t state64;
  _BYTE buf[18];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (!v5)
        goto LABEL_19;
      std::mutex::lock((std::mutex *)(v5 + 88));
      if (!*(_BYTE *)(v5 + 80))
      {
LABEL_18:
        std::mutex::unlock((std::mutex *)(v5 + 88));
LABEL_19:
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v12 = __ldaxr(p_shared_owners);
        while (__stlxr(v12 - 1, p_shared_owners));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
        return;
      }
      state64 = 0;
      if (!notify_get_state(*(_DWORD *)(v5 + 16), &state64))
      {
        v7 = state64 & 0xFFFFFFFFFFFFFF00;
        v8 = state64;
        v9 = 1;
LABEL_16:
        *(_QWORD *)buf = v8 | v7;
        *(_QWORD *)&buf[8] = v9;
        v10 = *(_QWORD *)(v5 + 72);
        if (!v10)
          std::__throw_bad_function_call[abi:ne180100]();
        (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v10 + 48))(v10, buf);
        goto LABEL_18;
      }
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      if (VPLogScope(void)::scope)
      {
        v6 = *(NSObject **)VPLogScope(void)::scope;
        if (!*(_QWORD *)VPLogScope(void)::scope)
        {
LABEL_15:
          v7 = 0;
          v9 = 0;
          v8 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        v6 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "vpNotificationHandler.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 81;
        _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d notify_get_state() failed", buf, 0x12u);
      }
      goto LABEL_15;
    }
  }
}

void sub_1B610A418(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

vp::NotificationHandler *std::unique_ptr<vp::NotificationHandler>::reset[abi:ne180100](vp::NotificationHandler **a1)
{
  vp::NotificationHandler *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    vp::NotificationHandler::~NotificationHandler(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void vp::NotificationHandler::~NotificationHandler(vp::NotificationHandler *this)
{
  std::mutex *v2;
  NSObject *v3;
  vp::NotificationHandler *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = (std::mutex *)((char *)this + 88);
  std::mutex::lock((std::mutex *)((char *)this + 88));
  *((_BYTE *)this + 80) = 0;
  std::mutex::unlock(v2);
  if (notify_cancel(*((_DWORD *)this + 4)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    if (VPLogScope(void)::scope)
    {
      v3 = *(NSObject **)VPLogScope(void)::scope;
      if (!*(_QWORD *)VPLogScope(void)::scope)
        goto LABEL_10;
    }
    else
    {
      v3 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v7 = 136315394;
      v8 = "vpNotificationHandler.cpp";
      v9 = 1024;
      v10 = 48;
      _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d notify_cancel() failed", (uint8_t *)&v7, 0x12u);
    }
  }
LABEL_10:
  std::mutex::~mutex(v2);
  v4 = (vp::NotificationHandler *)*((_QWORD *)this + 9);
  if (v4 == (vp::NotificationHandler *)((char *)this + 48))
  {
    v5 = 4;
    v4 = (vp::NotificationHandler *)((char *)this + 48);
  }
  else
  {
    if (!v4)
      goto LABEL_15;
    v5 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v4 + 8 * v5))();
LABEL_15:
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void sub_1B610A5F0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void std::__shared_ptr_pointer<vp::NotificationHandler *,std::shared_ptr<vp::NotificationHandler>::__shared_ptr_default_delete<vp::NotificationHandler,vp::NotificationHandler>,std::allocator<vp::NotificationHandler>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC95CECLL);
}

vp::NotificationHandler *std::__shared_ptr_pointer<vp::NotificationHandler *,std::shared_ptr<vp::NotificationHandler>::__shared_ptr_default_delete<vp::NotificationHandler,vp::NotificationHandler>,std::allocator<vp::NotificationHandler>>::__on_zero_shared(uint64_t a1)
{
  vp::NotificationHandler *result;

  result = *(vp::NotificationHandler **)(a1 + 24);
  if (result)
  {
    vp::NotificationHandler::~NotificationHandler(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

std::runtime_error *std::overflow_error::overflow_error[abi:ne180100](std::runtime_error *a1, const char *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5030] + 16);
  return result;
}

void AUSM::SnapCoordinates::getSnappedCoordinates(uint64_t a1, AUSM::ExclusionZone *a2, AUSM::ExclusionZone *a3, float32x4_t a4, float a5)
{
  float v8;
  float v9;
  uint64_t v10;
  vDSP_Length v11;
  uint64_t v12;
  float *v13;
  uint64_t i;
  uint64_t v15;
  unsigned int v16;
  float v17;
  float v18;
  float v20;
  AUSM::ExclusionZone *v21;
  float32x4_t v22;
  float32x4_t v23;
  float v24;
  float v25;
  float v27;
  float v28;
  int v29;
  float v30;
  float32x4_t *v31;
  float32x4_t v32;
  float v33;
  float v34;
  float32x4_t v35;
  float32x4_t v36;
  uint64_t v37;

  v36 = a4;
  v37 = *MEMORY[0x1E0C80C00];
  if (a5 <= 1.0)
    v8 = a5;
  else
    v8 = 1.0;
  if (a5 >= 0.0)
    v9 = v8;
  else
    v9 = 0.0;
  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(unsigned int *)(v10 + 8);
  MEMORY[0x1E0C80A78](a1);
  v13 = (float *)((char *)v36.f32 - ((v12 + 15) & 0x7FFFFFFF0));
  if ((_DWORD)v11)
  {
    for (i = 0; i != v11; ++i)
    {
      v15 = v10 + 20 * i;
      v16 = *(_DWORD *)(v15 + 12);
      v17 = *(float *)(v15 + 24);
      v18 = 0.0;
      if (v16 > 0x3E || ((0x4000002000000010uLL >> v16) & 1) == 0)
      {
        if (a2 == a3)
        {
LABEL_18:
          v22 = vsubq_f32(v36, *(float32x4_t *)(*(_QWORD *)(a1 + 16) + 16 * i));
          v23 = vmulq_f32(v22, v22);
          v24 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0]);
          v25 = 1.0 / v24;
          if (v24 > 1000.0)
            v25 = 0.001;
          if (v24 >= 0.0001)
            v18 = v25;
          else
            v18 = 10000.0;
        }
        else
        {
          v20 = *(float *)(v15 + 20);
          v21 = a2;
          while (!AUSM::ExclusionZone::isInExclusionZone(v21, v20, v17, v15))
          {
            v21 = (AUSM::ExclusionZone *)((char *)v21 + 28);
            if (v21 == a3)
              goto LABEL_18;
          }
        }
      }
      if (v17 == 0.0 || v9 == 1.0)
        v27 = 1.0;
      else
        v27 = v9;
      v13[i] = v18 * v27;
    }
  }
  v28 = cblas_snrm2(v11, v13, 1);
  cblas_sscal(v11, 1.0 / v28, v13, 1);
  v29 = 3;
  do
  {
    vDSP_vsq(v13, 1, v13, 1, v11);
    --v29;
  }
  while (v29);
  v30 = cblas_snrm2(v11, v13, 1);
  cblas_sscal(v11, 1.0 / v30, v13, 1);
  if ((_DWORD)v11)
  {
    v31 = *(float32x4_t **)(a1 + 16);
    v32 = 0uLL;
    do
    {
      v33 = *v13++;
      v34 = v33;
      v35 = *v31++;
      v32 = vmlaq_n_f32(v32, v35, v34);
      --v11;
    }
    while (v11);
  }
}

BOOL AUSM::ExclusionZone::isInExclusionZone@<W0>(AUSM::ExclusionZone *this@<X0>, float a2@<S0>, float a3@<S1>, BOOL a4@<W8>)
{
  float v8;
  float v9;
  BOOL v10;
  BOOL v11;
  float v12;
  float v13;
  BOOL v14;
  BOOL v15;
  __float2 v16;
  __float2 v17;
  float v18;
  float v19;
  float v20;
  float v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  float v25;
  float v26;
  BOOL v27;
  float v28;
  float v29;
  BOOL v30;

  if (*(_DWORD *)this == 1)
  {
    v16 = __sincosf_stret(a2 * 0.017453);
    v17 = __sincosf_stret(a3 * 0.017453);
    v18 = v16.__sinval * v17.__cosval;
    v19 = v16.__cosval * v17.__cosval;
    v20 = *((float *)this + 1);
    v21 = *((float *)this + 2);
    v22 = (float)(v16.__sinval * v17.__cosval) >= (float)(v20 + -0.000001);
    if ((float)(v16.__sinval * v17.__cosval) <= (float)(v21 + 0.000001))
      v22 = 1;
    v23 = v18 >= (float)(v20 + -0.000001);
    if (v18 > (float)(v21 + 0.000001))
      v23 = 0;
    if (v20 <= v21)
      v24 = v23;
    else
      v24 = v22;
    v25 = *((float *)this + 3);
    v26 = *((float *)this + 4);
    v10 = v19 >= (float)(v25 + -0.000001);
    if (v19 <= (float)(v26 + 0.000001))
      v10 = 1;
    v27 = v19 >= (float)(v25 + -0.000001);
    if (v19 > (float)(v26 + 0.000001))
      v27 = 0;
    if (v25 <= v26)
      v10 = v27;
    v28 = *((float *)this + 5);
    v29 = *((float *)this + 6);
    v14 = v17.__sinval >= (float)(v28 + -0.000001);
    if (v17.__sinval <= (float)(v29 + 0.000001))
      v14 = 1;
    v30 = v17.__sinval >= (float)(v28 + -0.000001);
    if (v17.__sinval > (float)(v29 + 0.000001))
      v30 = 0;
    if (v28 <= v29)
      v14 = v30;
    if (!v24)
      return 0;
    return v10 && v14;
  }
  if (!*(_DWORD *)this)
  {
    v8 = *((float *)this + 3);
    v9 = *((float *)this + 4);
    v10 = (float)(v8 + -0.000001) <= a2;
    if ((float)(v9 + 0.000001) >= a2)
      v10 = 1;
    v11 = (float)(v8 + -0.000001) <= a2;
    if ((float)(v9 + 0.000001) < a2)
      v11 = 0;
    if (v8 <= v9)
      v10 = v11;
    v12 = *((float *)this + 1);
    v13 = *((float *)this + 2);
    v14 = (float)(v12 + -0.000001) <= a3;
    if ((float)(v13 + 0.000001) >= a3)
      v14 = 1;
    v15 = (float)(v12 + -0.000001) <= a3;
    if ((float)(v13 + 0.000001) < a3)
      v15 = 0;
    if (v12 <= v13)
      v14 = v15;
    return v10 && v14;
  }
  return a4;
}

float AUSM::SnapCoordinates::getSnappedCoordinates(uint64_t a1, AUSM::ExclusionZone *a2, AUSM::ExclusionZone *a3, float a4, float a5)
{
  float v8;
  uint64_t v9;
  __float2 v10;
  __float2 v11;
  float32x4_t v12;
  __int128 v13;
  float v14;
  float v15;
  float v16;
  float32x4_t v18;
  __int128 v19;

  v8 = a5 * 0.017453;
  v10 = __sincosf_stret(a4 * 0.017453);
  *(float *)&v9 = v10.__cosval;
  v18.i64[0] = v9;
  v11 = __sincosf_stret(v8);
  v12 = v18;
  v12.i32[1] = LODWORD(v10.__sinval);
  *(float32x2_t *)v12.f32 = vmul_n_f32(*(float32x2_t *)v12.f32, v11.__cosval);
  v12.f32[2] = -v11.__sinval;
  AUSM::SnapCoordinates::getSnappedCoordinates(a1, a2, a3, v12, 1.0);
  v19 = v13;
  v14 = *((float *)&v13 + 1);
  v15 = atan2f(*((float *)&v13 + 1), *(float *)&v13) * 57.296;
  v16 = hypotf(*(float *)&v19, v14);
  atan2f(-*((float *)&v19 + 2), v16);
  return v15;
}

float AUSM::SnapCoordinates::getExcludedCoordinates@<S0>(uint64_t a1@<X0>, AUSM::ExclusionZone **a2@<X1>, BOOL a3@<W8>, float a4@<S0>, float a5@<S1>)
{
  AUSM::ExclusionZone *v7;
  AUSM::ExclusionZone *v8;
  AUSM::ExclusionZone *v11;
  uint64_t v12;
  __float2 v13;
  __float2 v14;
  float32x4_t v15;
  float32x4_t v16;
  float *v17;
  AUSM::ExclusionZone **v18;
  float v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v33;
  float v34;
  float v35;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;

  v7 = *a2;
  v8 = a2[1];
  if (*a2 != v8)
  {
    v11 = *a2;
    while (!AUSM::ExclusionZone::isInExclusionZone(v11, a4, a5, a3))
    {
      v11 = (AUSM::ExclusionZone *)((char *)v11 + 28);
      if (v11 == v8)
        return a4;
    }
    v13 = __sincosf_stret(a4 * 0.017453);
    *(float *)&v12 = v13.__cosval;
    v37.i64[0] = v12;
    v14 = __sincosf_stret(a5 * 0.017453);
    v15 = v37;
    v15.i32[1] = LODWORD(v13.__sinval);
    *(float32x2_t *)v15.f32 = vmul_n_f32(*(float32x2_t *)v15.f32, v14.__cosval);
    v15.f32[2] = -v14.__sinval;
    v39 = v15;
    AUSM::SnapCoordinates::getSnappedCoordinates(a1, v7, v8, v15, 0.5);
    v38 = v16;
    v18 = a2;
    v17 = (float *)*a2;
    v19 = 0.0;
    v20 = v18[1] - (AUSM::ExclusionZone *)v17;
    if (v20)
    {
      v21 = v20 >> 2;
      v22 = 0x6DB6DB6DB6DB6DB7 * v21;
      v23 = 1;
      do
      {
        if (AUSM::ExclusionZone::isInExclusionZone((AUSM::ExclusionZone *)v17, a4, a5, v21))
        {
          *(float *)&v21 = *v17;
          if (!*(_DWORD *)v17)
          {
            v25 = v17[3];
            v24 = v17[4];
            v26 = v17[2];
            v27 = a4 + 360.0;
            if (a4 >= 0.0)
              v27 = a4;
            if (v25 <= v24)
            {
              v28 = v17[4];
            }
            else
            {
              a4 = v27;
              v28 = v24 + 360.0;
            }
            v29 = (float)(v25 + v28) * 0.5;
            v30 = (float)(v26 + v17[1]) * 0.5;
            v31 = sqrtf((float)((float)(v26 - v30) * (float)(v26 - v30)) + (float)((float)(v28 - v29)
                                                                                 * (float)(v28 - v29)));
            v19 = 0.0;
            if (v31 != 0.0)
              v19 = 1.0
                  - (float)(sqrtf((float)((float)(a5 - v30) * (float)(a5 - v30))+ (float)((float)(a4 - v29) * (float)(a4 - v29)))/ v31);
          }
        }
        v17 += 7;
      }
      while (v22 > v23++);
    }
    if (v19 <= 1.0)
      v33 = v19;
    else
      v33 = 1.0;
    if (v19 >= 0.0)
      v34 = v33;
    else
      v34 = 0.0;
    v40 = vmlaq_n_f32(vmulq_n_f32(v39, 1.0 - v34), v38, v34);
    a4 = atan2f(v40.f32[1], v40.f32[0]) * 57.296;
    v35 = hypotf(v40.f32[0], v40.f32[1]);
    atan2f(-v40.f32[2], v35);
  }
  return a4;
}

void BeamformerBase::SetParamDefaults(BeamformerBase *this)
{
  char *v2;
  uint64_t i;
  int v4;

  *((_OWORD *)this + 4) = xmmword_1B6626830;
  *((_QWORD *)this + 10) = 0;
  *(_OWORD *)((char *)this + 88) = xmmword_1B66A0520;
  *((_WORD *)this + 52) = 0;
  *(_QWORD *)((char *)this + 108) = 0;
  *(_QWORD *)((char *)this + 116) = 1065353216;
  *((_DWORD *)this + 31) = 0;
  *((_WORD *)this + 64) = 257;
  *((_DWORD *)this + 33) = 0;
  *((_QWORD *)this + 17) = 0xC2700000C0400000;
  *((_DWORD *)this + 36) = -1032847360;
  *((_WORD *)this + 74) = 0;
  *((_DWORD *)this + 38) = 0;
  *(_QWORD *)((char *)this + 156) = 0x40C0000043FA0000;
  *((_DWORD *)this + 41) = 0;
  *(_OWORD *)((char *)this + 172) = xmmword_1B66A0530;
  *(_OWORD *)((char *)this + 188) = xmmword_1B66A0540;
  *(_OWORD *)((char *)this + 204) = xmmword_1B66A0550;
  *(_QWORD *)((char *)this + 220) = 0x3F4000003E800000;
  *(_OWORD *)((char *)this + 228) = 0u;
  v2 = (char *)this + 228;
  *((_WORD *)this + 84) = 256;
  *(_OWORD *)((char *)this + 516) = 0u;
  *(_OWORD *)((char *)this + 532) = 0u;
  *(_OWORD *)((char *)this + 484) = 0u;
  *(_OWORD *)((char *)this + 500) = 0u;
  *(_OWORD *)((char *)this + 452) = 0u;
  *(_OWORD *)((char *)this + 468) = 0u;
  *(_OWORD *)((char *)this + 420) = 0u;
  *(_OWORD *)((char *)this + 436) = 0u;
  *(_OWORD *)((char *)this + 388) = 0u;
  *(_OWORD *)((char *)this + 404) = 0u;
  *(_OWORD *)((char *)this + 356) = 0u;
  *(_OWORD *)((char *)this + 372) = 0u;
  *(_OWORD *)((char *)this + 324) = 0u;
  *(_OWORD *)((char *)this + 340) = 0u;
  *(_OWORD *)((char *)this + 292) = 0u;
  *(_OWORD *)((char *)this + 308) = 0u;
  *(_OWORD *)((char *)this + 260) = 0u;
  *(_OWORD *)((char *)this + 276) = 0u;
  *(_OWORD *)((char *)this + 244) = 0u;
  memset_pattern16((char *)this + 552, &unk_1B6629FB0, 0x480uLL);
  memset_pattern16(v2 + 1476, &unk_1B6627B80, 0x480uLL);
  for (i = 0; i != 1152; i += 16)
  {
    *(_OWORD *)((char *)this + i + 2856) = 0uLL;
    *(_OWORD *)((char *)this + i + 4008) = 0uLL;
  }
  v4 = 0;
  std::vector<float>::resize((uint64_t)this + 19152, 0x120uLL, &v4);
  BeamformerBase::UpdateLimitWindBoostParameters(this);
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3;

  v3 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v3)
  {
    if (a2 < v3)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<float>::__append((void **)a1, a2 - v3, a3);
  }
}

void BeamformerBase::UpdateLimitWindBoostParameters(BeamformerBase *this)
{
  LimitWindBoost *v2;
  uint64_t v3;
  unint64_t v4;

  v2 = (BeamformerBase *)((char *)this + 19200);
  v3 = *((_QWORD *)this + 2400);
  v4 = *((_QWORD *)this + 2401) - v3;
  if (!v4)
    goto LABEL_23;
  *(float *)v3 = (float)*((unsigned int *)this + 38);
  if (v4 <= 4)
    goto LABEL_23;
  *(_DWORD *)(v3 + 4) = *((_DWORD *)this + 39);
  if (v4 <= 8)
    goto LABEL_23;
  *(_DWORD *)(v3 + 8) = *((_DWORD *)this + 40);
  if (v4 <= 0xC)
    goto LABEL_23;
  *(_DWORD *)(v3 + 12) = *((_DWORD *)this + 41);
  if (v4 <= 0x10)
    goto LABEL_23;
  *(_DWORD *)(v3 + 16) = *((_DWORD *)this + 43);
  if (v4 <= 0x14)
    goto LABEL_23;
  *(_DWORD *)(v3 + 20) = *((_DWORD *)this + 44);
  if (v4 <= 0x18)
    goto LABEL_23;
  *(_DWORD *)(v3 + 24) = *((_DWORD *)this + 45);
  if (v4 <= 0x1C)
    goto LABEL_23;
  *(_DWORD *)(v3 + 28) = *((_DWORD *)this + 46);
  if (v4 <= 0x20)
    goto LABEL_23;
  *(_DWORD *)(v3 + 32) = *((_DWORD *)this + 47);
  if (v4 <= 0x24)
    goto LABEL_23;
  *(_DWORD *)(v3 + 36) = *((_DWORD *)this + 48);
  if (v4 <= 0x28
    || (*(_DWORD *)(v3 + 40) = *((_DWORD *)this + 49), v4 <= 0x2C)
    || (*(_DWORD *)(v3 + 44) = *((_DWORD *)this + 50), v4 <= 0x30)
    || (*(_DWORD *)(v3 + 48) = *((_DWORD *)this + 51), v4 <= 0x34)
    || (*(_DWORD *)(v3 + 52) = *((_DWORD *)this + 52), v4 <= 0x38)
    || (*(_DWORD *)(v3 + 56) = *((_DWORD *)this + 53), v4 <= 0x3C)
    || (*(_DWORD *)(v3 + 60) = *((_DWORD *)this + 54), v4 <= 0x40)
    || (*(_DWORD *)(v3 + 64) = *((_DWORD *)this + 55), v4 <= 0x44))
  {
LABEL_23:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
  *(_DWORD *)(v3 + 68) = *((_DWORD *)this + 56);
  if (*((_BYTE *)this + 16))
  {
    if (*((_BYTE *)this + 19304))
      LimitWindBoost::propagateParameterChanges(v2);
  }
}

void std::vector<float>::__append(void **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _DWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _DWORD *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *i;
  int v25;

  v8 = a1[2];
  v6 = (uint64_t)(a1 + 2);
  v7 = v8;
  v9 = *(_DWORD **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 2)
  {
    if (a2)
    {
      v16 = 4 * a2;
      v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 4;
      }
      while (v16);
      v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    v10 = (char *)v9 - (_BYTE *)*a1;
    v11 = a2 + (v10 >> 2);
    if (v11 >> 62)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v12 = v10 >> 2;
    v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 1 > v11)
      v11 = v13 >> 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
      v14 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v6, v14);
    else
      v15 = 0;
    v18 = &v15[4 * v12];
    v19 = &v18[4 * a2];
    v20 = 4 * a2;
    v21 = v18;
    do
    {
      *(_DWORD *)v21 = *a3;
      v21 += 4;
      v20 -= 4;
    }
    while (v20);
    v22 = &v15[4 * v14];
    v23 = (char *)*a1;
    for (i = (char *)a1[1]; i != v23; i -= 4)
    {
      v25 = *((_DWORD *)i - 1);
      *((_DWORD *)v18 - 1) = v25;
      v18 -= 4;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
      operator delete(v23);
  }
}

const UInt8 *BeamformerBase::ReadVectorFromDictionary(BeamformerBase *this, CFDictionaryRef theDict, const __CFString *key)
{
  const __CFData *Value;
  unsigned int Length;
  unsigned int v6;
  const UInt8 *result;
  _DWORD *v8;
  uint64_t v9;
  unsigned int v10;
  int v11;

  Value = (const __CFData *)CFDictionaryGetValue(theDict, key);
  Length = CFDataGetLength(Value);
  v6 = Length >> 2;
  v11 = 0;
  std::vector<float>::vector(this, Length >> 2, &v11);
  result = CFDataGetBytePtr(Value);
  if (Length >= 4)
  {
    v8 = *(_DWORD **)this;
    if (v6 <= 1)
      v9 = 1;
    else
      v9 = v6;
    do
    {
      v10 = *(_DWORD *)result;
      result += 4;
      *v8++ = bswap32(v10);
      --v9;
    }
    while (v9);
  }
  return result;
}

void sub_1B610B230(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void BeamformerBase::ProcessBufferLists(BeamformerBase *this, const AudioBufferList *a2, const AudioBufferList *a3, AudioBufferList *a4, AudioBufferList *a5, AudioBufferList *a6, AudioBufferList *a7)
{
  unsigned int v11;
  double v12;
  double v13;
  int32x2_t v14;
  int v15;
  unint64_t v16;
  char *v17;
  char *v18;
  unint64_t v19;
  BeamformerBase *v20;
  char *v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int j;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  unint64_t v30;
  char *v31;
  char *v32;
  unsigned int v33;
  char **v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  float v38;
  unsigned int v39;
  char **v40;
  uint64_t v41;
  int v42;
  char *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  BeamformerBase *v47;
  int v48;
  signed int mNumberBuffers;
  unint64_t v50;
  uint64_t v51;
  float *v52;
  uint64_t v53;
  float *v54;
  float v55;
  float *v56;
  uint64_t v57;
  float *v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  float *v63;
  uint64_t v64;
  float *v65;
  float *v66;
  uint64_t v67;
  float *v68;
  uint64_t v69;
  uint64_t v70;
  float *v71;
  uint64_t v72;
  unsigned int i;
  unsigned int v74;
  unsigned int v75;
  unint64_t v76;
  char *v77;
  uint64_t v78;
  _DWORD *v79;
  int v80;
  unint64_t v81;
  void **p_mData;
  const void **v83;
  const void *v84;
  unint64_t v85;
  void **v86;
  const void **v87;
  const void *v88;
  DSPSplitComplex __C;
  float v93;
  float __B;
  DSPSplitComplex __A;
  int __N;
  float __N_4;

  if (!*((_BYTE *)this + 16) || !*((_BYTE *)this + 17))
    return;
  v11 = *((_DWORD *)this + 8);
  v12 = (float)v11;
  v13 = *((double *)this + 3);
  v14 = (int32x2_t)vcvt_u32_f32(vrnda_f32(vcvt_f32_f64(vmulq_n_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)((char *)this + 88)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(v13 * 0.5), 0)), v12))));
  *(int32x2_t *)((char *)this + 36) = v14;
  *(float *)&v12 = *((float *)this + 39) / (v13 * 0.5) * v12;
  *((float *)this + 13) = roundf(*(float *)&v12);
  *((_DWORD *)this + 11) = vsub_s32(vdup_lane_s32(v14, 1), v14).u32[0] + 1;
  *(float *)&v12 = v13 / (double)v11;
  *((float *)this + 12) = expf(-1.0 / (float)(*((float *)this + 24) * *(float *)&v12));
  *((float *)this + 14) = __exp10f(*((float *)this + 40) / 20.0);
  *((float *)this + 15) = __exp10f(*((float *)this + 41) / 20.0);
  BeamformerBase::UpdateLimitWindBoostParameters(this);
  switch(*((_DWORD *)this + 17))
  {
    case 0:
      *((_DWORD *)this + 27) = 0;
      if (*((_DWORD *)this + 3))
      {
        v19 = 0;
        v20 = this;
        do
        {
          (*(void (**)(BeamformerBase *, const AudioBufferList *, uint64_t, unint64_t, _QWORD))(*(_QWORD *)this + 80))(this, a2, (uint64_t)v20 + 12072, v19, 0);
          bzero(*((void **)v20 + 645), *((_QWORD *)v20 + 646) - *((_QWORD *)v20 + 645));
          ++v19;
          v20 = (BeamformerBase *)((char *)v20 + 24);
        }
        while (v19 < *((unsigned int *)this + 3));
      }
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 18984, *((char **)this + 1509), *((_QWORD *)this + 1510), (uint64_t)(*((_QWORD *)this + 1510) - *((_QWORD *)this + 1509)) >> 2);
      bzero(*((void **)this + 2376), *((_QWORD *)this + 2377) - *((_QWORD *)this + 2376));
      goto LABEL_77;
    case 1:
    case 5:
      v15 = *((_DWORD *)this + 19);
      if (v15)
      {
        if (v15 == 1)
        {
          if (*((_DWORD *)this + 3))
          {
            v30 = 0;
            v31 = (char *)this + 5160;
            v32 = (char *)this + 12072;
            do
            {
              (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, char *, unint64_t, _QWORD))(*(_QWORD *)this + 112))(this, a2, v32, v31, v30++, *((unsigned int *)this + 18));
              v31 += 24;
              v32 += 24;
            }
            while (v30 < *((unsigned int *)this + 3));
          }
        }
        else if (v15 == 2 && *((_DWORD *)this + 3))
        {
          v16 = 0;
          v17 = (char *)this + 5160;
          v18 = (char *)this + 12072;
          do
          {
            (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, char *, unint64_t, _QWORD))(*(_QWORD *)this + 120))(this, a2, v18, v17, v16++, *((unsigned int *)this + 18));
            v17 += 24;
            v18 += 24;
          }
          while (v16 < *((unsigned int *)this + 3));
        }
      }
      else if (*((_DWORD *)this + 3))
      {
        v27 = 0;
        v28 = (char *)this + 5160;
        v29 = (char *)this + 12072;
        do
        {
          (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, unint64_t, _QWORD))(*(_QWORD *)this + 80))(this, a2, v29, v27, 0);
          (*(void (**)(BeamformerBase *, char *, char *, unint64_t, _QWORD))(*(_QWORD *)this + 104))(this, v29, v28, v27++, *((unsigned int *)this + 18));
          v28 += 24;
          v29 += 24;
        }
        while (v27 < *((unsigned int *)this + 3));
      }
      if (*((_BYTE *)this + 169))
      {
        (*(void (**)(BeamformerBase *))(*(_QWORD *)this + 136))(this);
        v33 = *((_DWORD *)this + 27);
      }
      else
      {
        v33 = *((_DWORD *)this + 28);
        *((_DWORD *)this + 27) = v33;
      }
      v34 = (char **)((char *)this + 24 * v33 + 12072);
      if ((char **)((char *)this + 18984) != v34)
      {
        v35 = *((_QWORD *)this + 3 * v33 + 1510);
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 18984, *v34, v35, (v35 - (uint64_t)*v34) >> 2);
      }
      if (*((_BYTE *)this + 168))
        (*(void (**)(BeamformerBase *, char *, char *))(*(_QWORD *)this + 88))(this, (char *)this + 24 * *((unsigned int *)this + 28) + 12072, (char *)this + 18984);
      if (a3)
      {
        v36 = *((unsigned int *)this + 27);
        if (*((_BYTE *)this + 168))
          (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)this + 96))(this, a3, (char *)this + 19008, v36, *((unsigned int *)this + 28), 1);
        else
          (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, a3, (char *)this + 19008, v36, 1);
        v37 = (*(float (**)(BeamformerBase *, char *))(*(_QWORD *)this + 152))(this, (char *)this + 18984);
        v38 = (*(float (**)(BeamformerBase *, char *))(*(_QWORD *)this + 152))(this, (char *)this + 19008);
        if (v38 <= *((float *)this + 35) || v37 <= *((float *)this + 36))
        {
          *((_BYTE *)this + 148) = 0;
        }
        else if ((float)(v38 - v37) > *((float *)this + 34))
        {
          *((_BYTE *)this + 148) = 1;
          if (*((_BYTE *)this + 129))
          {
            v39 = *((_DWORD *)this + 33);
            *((_DWORD *)this + 27) = v39;
            v40 = (char **)((char *)this + 24 * v39 + 12072);
            if ((char **)((char *)this + 18984) != v40)
            {
              v41 = *((_QWORD *)this + 3 * v39 + 1510);
              std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 18984, *v40, v41, (v41 - (uint64_t)*v40) >> 2);
            }
            if (*((_BYTE *)this + 168))
            {
              (*(void (**)(BeamformerBase *, char *, char *))(*(_QWORD *)this + 88))(this, (char *)this + 24 * *((unsigned int *)this + 28) + 12072, (char *)this + 18984);
              (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)this + 96))(this, a3, (char *)this + 19008, *((unsigned int *)this + 27), *((unsigned int *)this + 28), 1);
            }
            else
            {
              (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, _QWORD, uint64_t))(*(_QWORD *)this + 80))(this, a3, (char *)this + 19008, *((unsigned int *)this + 27), 1);
            }
          }
        }
      }
      v42 = *((_DWORD *)this + 27);
      if (v42 != *((_DWORD *)this + 28))
        *((_DWORD *)this + 28) = v42;
      if (*((_BYTE *)this + 128))
        (*(void (**)(BeamformerBase *))(*(_QWORD *)this + 128))(this);
      if (*((_DWORD *)this + 17) == 5)
        goto LABEL_61;
      goto LABEL_77;
    case 2:
      *((_DWORD *)this + 27) = *((_DWORD *)this + 20);
      v21 = (char *)this + 18984;
      if (*((_BYTE *)this + 168))
      {
        (*(void (**)(BeamformerBase *, const AudioBufferList *, char *))(*(_QWORD *)this + 96))(this, a2, v21);
        if (!a3)
          goto LABEL_66;
      }
      else
      {
        (*(void (**)(BeamformerBase *, const AudioBufferList *, char *))(*(_QWORD *)this + 80))(this, a2, v21);
        if (!a3)
          goto LABEL_66;
      }
      v43 = (char *)this + 19008;
      v44 = *((unsigned int *)this + 27);
      if (*((_BYTE *)this + 168))
        (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)this + 96))(this, a3, v43, v44, *((unsigned int *)this + 28), 1);
      else
        (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, a3, v43, v44, 1);
LABEL_66:
      if (*((_DWORD *)this + 3))
      {
        v45 = 0;
        v46 = 6912;
        v47 = this;
        do
        {
          if (v45 == *((_DWORD *)this + 27))
          {
            if (v46)
              std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)v47 + 12072, *((char **)this + 2373), *((_QWORD *)this + 2374), (uint64_t)(*((_QWORD *)this + 2374) - *((_QWORD *)this + 2373)) >> 2);
          }
          else
          {
            bzero(*((void **)v47 + 1509), *((_QWORD *)v47 + 1510) - *((_QWORD *)v47 + 1509));
          }
          bzero(*((void **)v47 + 645), *((_QWORD *)v47 + 646) - *((_QWORD *)v47 + 645));
          ++v45;
          v46 -= 24;
          v47 = (BeamformerBase *)((char *)v47 + 24);
        }
        while (v45 < *((unsigned int *)this + 3));
      }
      v48 = *((_DWORD *)this + 27);
      if (v48 != *((_DWORD *)this + 28))
        *((_DWORD *)this + 28) = v48;
      if (*((_BYTE *)this + 128))
        (*(void (**)(BeamformerBase *))(*(_QWORD *)this + 128))(this);
LABEL_77:
      if (*((_BYTE *)this + 548))
      {
        if (!*((_BYTE *)this + 105) || *((_DWORD *)this + 17) == 2)
          goto LABEL_92;
        __N_4 = 2.2204e-16;
        __N = *((_DWORD *)this + 8) + 1;
        mNumberBuffers = a2->mNumberBuffers;
        vDSP_vclr(*((float **)this + 2391), 1, __N);
        if (a2->mNumberBuffers)
        {
          v50 = 0;
          v51 = 16;
          do
          {
            v52 = *(float **)((char *)&a2->mNumberBuffers + v51);
            v53 = *((unsigned int *)this + 8);
            __A.realp = v52 + 1;
            __A.imagp = &v52[v53 + 1];
            v54 = (float *)*((_QWORD *)this + 2388);
            *v54 = *v52 * *v52;
            v54[v53] = v52[v53] * v52[v53];
            vDSP_zvmags(&__A, 1, v54 + 1, 1, (v53 - 1));
            vDSP_vadd(*((const float **)this + 2388), 1, *((const float **)this + 2391), 1, *((float **)this + 2391), 1, __N);
            LODWORD(__C.realp) = 0;
            vDSP_sve(*((const float **)this + 2388), 1, (float *)&__C, __N);
            mNumberBuffers -= *(float *)&__C.realp == 0.0;
            ++v50;
            v51 += 16;
          }
          while (v50 < a2->mNumberBuffers);
        }
        if (mNumberBuffers)
          v55 = 1.0 / (float)mNumberBuffers;
        else
          v55 = 0.0;
        __B = v55;
        vDSP_vsmul(*((const float **)this + 2391), 1, &__B, *((float **)this + 2391), 1, __N);
        v93 = 0.0;
        vDSP_vthr(*((const float **)this + 2391), 1, &v93, *((float **)this + 2391), 1, __N);
        vvsqrtf(*((float **)this + 2391), *((const float **)this + 2391), &__N);
        v56 = (float *)*((_QWORD *)this + 2373);
        v57 = *((unsigned int *)this + 8);
        __A.realp = v56 + 1;
        __A.imagp = &v56[v57 + 1];
        v58 = (float *)*((_QWORD *)this + 2388);
        *v58 = fabsf(*v56);
        v58[v57] = fabsf(v56[v57]);
        vDSP_zvabs(&__A, 1, v58 + 1, 1, (v57 - 1));
        vDSP_vthr(*((const float **)this + 2388), 1, &__N_4, *((float **)this + 2388), 1, __N);
        vDSP_vdiv(*((const float **)this + 2388), 1, *((const float **)this + 2391), 1, *((float **)this + 2391), 1, __N);
        v59 = *((_QWORD *)this + 2391);
        *v56 = *(float *)v59 * *v56;
        v60 = *((unsigned int *)this + 8);
        v56[v57] = *(float *)(v59 + 4 * v60) * v56[v57];
        vDSP_zrvmul(&__A, 1, (const float *)(v59 + 4), 1, &__A, 1, (v60 - 1));
        if (a3)
        {
          vDSP_vclr(*((float **)this + 2391), 1, __N);
          if (a3->mNumberBuffers)
          {
            v61 = 0;
            v62 = 16;
            do
            {
              v63 = *(float **)((char *)&a3->mNumberBuffers + v62);
              v64 = *((unsigned int *)this + 8);
              __C.realp = v63 + 1;
              __C.imagp = &v63[v64 + 1];
              v65 = (float *)*((_QWORD *)this + 2388);
              *v65 = *v63 * *v63;
              v65[v64] = v63[v64] * v63[v64];
              vDSP_zvmags(&__C, 1, v65 + 1, 1, (v64 - 1));
              vDSP_vadd(*((const float **)this + 2388), 1, *((const float **)this + 2391), 1, *((float **)this + 2391), 1, __N);
              ++v61;
              v62 += 16;
            }
            while (v61 < a3->mNumberBuffers);
          }
          vDSP_vsmul(*((const float **)this + 2391), 1, &__B, *((float **)this + 2391), 1, __N);
          vDSP_vthr(*((const float **)this + 2391), 1, &v93, *((float **)this + 2391), 1, __N);
          vvsqrtf(*((float **)this + 2391), *((const float **)this + 2391), &__N);
          v66 = (float *)*((_QWORD *)this + 2376);
          v67 = *((unsigned int *)this + 8);
          __C.realp = v66 + 1;
          __C.imagp = &v66[v67 + 1];
          v68 = (float *)*((_QWORD *)this + 2388);
          *v68 = fabsf(*v66);
          v68[v67] = fabsf(v66[v67]);
          vDSP_zvabs(&__C, 1, v68 + 1, 1, (v67 - 1));
          vDSP_vthr(*((const float **)this + 2388), 1, &__N_4, *((float **)this + 2388), 1, __N);
          vDSP_vdiv(*((const float **)this + 2388), 1, *((const float **)this + 2391), 1, *((float **)this + 2391), 1, __N);
          v69 = *((_QWORD *)this + 2391);
          *v66 = *(float *)v69 * *v66;
          v70 = *((unsigned int *)this + 8);
          v66[v67] = *(float *)(v69 + 4 * v70) * v66[v67];
          vDSP_zrvmul(&__C, 1, (const float *)(v69 + 4), 1, &__C, 1, (v70 - 1));
        }
        if (*((_BYTE *)this + 548))
        {
LABEL_92:
          v71 = (float *)((char *)a2->mBuffers[*((unsigned int *)this + 38)].mData + 4 * *((unsigned int *)this + 8));
          __A.realp = (float *)a2->mBuffers[*((unsigned int *)this + 38)].mData;
          __A.imagp = v71;
          vDSP_zvmags(&__A, 1, *((float **)this + 2379), 1, (unint64_t)*((float *)this + 13));
          v72 = *((_QWORD *)this + 2400);
          if ((unint64_t)(*((_QWORD *)this + 2401) - v72) <= 0x10)
            std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
          *(_DWORD *)(v72 + 16) = 0;
          if (*((_DWORD *)this + 17) == 4)
          {
            v74 = *((_DWORD *)this + 20);
            for (i = *((_DWORD *)this + 21); v74 <= i; ++v74)
            {
              if (*((_BYTE *)this + 149) && *((_BYTE *)this + 19304))
                LimitWindBoost::process((uint64_t)this + 19200, (uint64_t *)this + 2379, (uint64_t)this + 24 * v74 + 12072, &a2->mNumberBuffers, (const float **)&__A.realp, v74);
            }
          }
          else
          {
            v75 = *((_DWORD *)this + 3);
            if (v75)
            {
              v76 = 0;
              v77 = (char *)this + 12072;
              do
              {
                if (*((_BYTE *)this + 149) && *((_BYTE *)this + 19304))
                {
                  LimitWindBoost::process((uint64_t)this + 19200, (uint64_t *)this + 2379, (uint64_t)v77, &a2->mNumberBuffers, (const float **)&__A.realp, v76);
                  v75 = *((_DWORD *)this + 3);
                }
                ++v76;
                v77 += 24;
              }
              while (v76 < v75);
            }
            if (*((_BYTE *)this + 149) && *((_BYTE *)this + 19304))
              LimitWindBoost::process((uint64_t)this + 19200, (uint64_t *)this + 2379, (uint64_t)this + 18984, &a2->mNumberBuffers, (const float **)&__A.realp, v75);
          }
        }
      }
      v78 = *((_QWORD *)this + 2400);
      if ((unint64_t)(*((_QWORD *)this + 2401) - v78) <= 0xF)
        __assert_rtn("getParameter", "LimitWindBoost.cpp", 159, "index <= mParameter.size()");
      *((_DWORD *)this + 43) = *(_DWORD *)(v78 + 16);
      v79 = (_DWORD *)((char *)this + 4 * *((unsigned int *)this + 27));
      v80 = v79[714];
      *((_DWORD *)this + 29) = v79[426];
      *((_DWORD *)this + 30) = v80;
      *((_DWORD *)this + 31) = v79[1002];
      if (a4)
        memcpy(a4->mBuffers[0].mData, *((const void **)this + 2373), a4->mBuffers[0].mDataByteSize);
      if (a5)
        memcpy(a5->mBuffers[0].mData, *((const void **)this + 2376), a5->mBuffers[0].mDataByteSize);
      if (a6 && a6->mNumberBuffers)
      {
        v81 = 0;
        p_mData = &a6->mBuffers[0].mData;
        v83 = (const void **)((char *)this + 12072);
        do
        {
          v84 = *v83;
          v83 += 3;
          memcpy(*p_mData, v84, *((unsigned int *)p_mData - 1));
          ++v81;
          p_mData += 2;
        }
        while (v81 < a6->mNumberBuffers);
      }
      if (a7 && a7->mNumberBuffers)
      {
        v85 = 0;
        v86 = &a7->mBuffers[0].mData;
        v87 = (const void **)((char *)this + 5160);
        do
        {
          v88 = *v87;
          v87 += 3;
          memcpy(*v86, v88, *((unsigned int *)v86 - 1));
          ++v85;
          v86 += 2;
        }
        while (v85 < a7->mNumberBuffers);
      }
      return;
    case 3:
      v22 = *((unsigned int *)this + 20);
      v23 = *((_DWORD *)this + 21);
      v24 = *((_DWORD *)this + 19);
      if (v24 >= 2)
      {
        if (v24 == 2 && v22 <= v23)
        {
          do
          {
            (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, char *, uint64_t, _QWORD))(*(_QWORD *)this + 120))(this, a2, (char *)this + 24 * v22 + 12072, (char *)this + 24 * v22 + 5160, v22, *((unsigned int *)this + 18));
            v22 = (v22 + 1);
          }
          while (v22 <= v23);
        }
      }
      else
      {
        for (; v22 <= v23; v22 = (v22 + 1))
          (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, char *, uint64_t, _QWORD))(*(_QWORD *)this + 112))(this, a2, (char *)this + 24 * v22 + 12072, (char *)this + 24 * v22 + 5160, v22, *((unsigned int *)this + 18));
      }
      bzero(*((void **)this + 2373), *((_QWORD *)this + 2374) - *((_QWORD *)this + 2373));
      bzero(*((void **)this + 2376), *((_QWORD *)this + 2377) - *((_QWORD *)this + 2376));
LABEL_61:
      (*(void (**)(BeamformerBase *))(*(_QWORD *)this + 48))(this);
      goto LABEL_77;
    case 4:
      *((_DWORD *)this + 27) = 0;
      v26 = *((unsigned int *)this + 20);
      for (j = *((_DWORD *)this + 21); v26 <= j; v26 = (v26 + 1))
        (*(void (**)(BeamformerBase *, const AudioBufferList *, char *, uint64_t, _QWORD))(*(_QWORD *)this + 80))(this, a2, (char *)this + 24 * v26 + 12072, v26, 0);
      goto LABEL_77;
    default:
      goto LABEL_77;
  }
}

void SCTwoInputMixer::~SCTwoInputMixer(SCTwoInputMixer *this)
{
  DSPGraph::Box::~Box(this);
  JUMPOUT(0x1BCC95CECLL);
}

const char *SCTwoInputMixer::ClassName(SCTwoInputMixer *this)
{
  return "SCTwoInputMixer";
}

uint64_t DSPGraph::Box::canBypass(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::isBypassed(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::canProcessInPlace(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::selfLatencyInTicks(DSPGraph::Box *this)
{
  return 0;
}

void SCTwoInputMixer::setParameter(SCTwoInputMixer *this, int a2, float a3)
{
  switch(a2)
  {
    case 2:
      *((float *)this + 195) = __exp10f(a3 * 0.05);
      break;
    case 1:
      *((float *)this + 194) = __exp10f(a3 * 0.05);
      break;
    case 0:
      if (a3 < 0.0)
        a3 = 0.0;
      if (a3 > 1.0)
        a3 = 1.0;
      *((float *)this + 193) = a3;
      break;
  }
}

float SCTwoInputMixer::getParameter(SCTwoInputMixer *this)
{
  return *((float *)this + 193);
}

uint64_t DSPGraph::Box::usesFixedBlockSize(DSPGraph::Box *this)
{
  return 0;
}

double SCTwoInputMixer::desc@<D0>(uint64_t a1@<X8>)
{
  double result;

  result = 3.81584623e185;
  *(_OWORD *)a1 = xmmword_1B66A0560;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

uint64_t DSPGraph::Box::asAUBox(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::asBoxProxy(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::asGraphInput(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::asGraphOutput(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::asFCBox(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::asSRCBox(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::asFreqSRCBox(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::asOperativeFCBox(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::asOperativeSRCBox(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::asOperativeFreqSRCBox(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::hasPresetData(DSPGraph::Box *this)
{
  return 1;
}

void DSPGraph::Box::getComponentName(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

uint64_t DSPGraph::Box::isLatencyDelay(DSPGraph::Box *this)
{
  return 0;
}

uint64_t DSPGraph::Box::isFrequencySafe(DSPGraph::Box *this)
{
  return 1;
}

void SCTwoInputMixer::process(SCTwoInputMixer *this, int a2)
{
  uint64_t v3;
  char *v4;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  float v17;
  float v18;
  uint64_t v19;
  vDSP_Length __N;
  uint64_t v21;
  unsigned int v22;
  float **v23;
  int v24;
  const float *v25;
  unsigned int v26;
  const char *v27;
  _QWORD *v28;
  const char *v29;
  _QWORD *v30;
  const char *v31;
  _QWORD *v32;
  float __D;
  float __B;
  _QWORD v35[3];
  _QWORD v36[3];

  v4 = (char *)this + 64;
  v3 = *((_QWORD *)this + 8);
  if (*((_QWORD *)v4 + 1) == v3)
  {
    std::string::basic_string[abi:ne180100]<0>(v36, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v35, "in");
    v28 = (_QWORD *)((char *)this + 32);
    if (*((char *)this + 55) < 0)
      v28 = (_QWORD *)*v28;
    DSPGraph::strprintf((DSPGraph *)"Box::in inIndex out of range! box %s has %zu inputs but input %u was requested", v27, v28, (uint64_t)(*((_QWORD *)this + 9) - *((_QWORD *)this + 8)) >> 5, 0);
    DSPGraph::ThrowException();
    goto LABEL_35;
  }
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
  v7 = *((_QWORD *)this + 8);
  if ((unint64_t)(*((_QWORD *)this + 9) - v7) <= 0x20)
  {
    std::string::basic_string[abi:ne180100]<0>(v36, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v35, "in");
    v30 = (_QWORD *)((char *)this + 32);
    if (*((char *)this + 55) < 0)
      v30 = (_QWORD *)*v30;
    DSPGraph::strprintf((DSPGraph *)"Box::in inIndex out of range! box %s has %zu inputs but input %u was requested", v29, v30, (uint64_t)(*((_QWORD *)this + 9) - *((_QWORD *)this + 8)) >> 5, 1);
    DSPGraph::ThrowException();
    goto LABEL_35;
  }
  v8 = *(_DWORD **)(*(_QWORD *)(v6 + 56) + 80);
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v7 + 32) + 40))(v7 + 32);
  v10 = *((_QWORD *)this + 11);
  if (*((_QWORD *)this + 12) == v10)
  {
    std::string::basic_string[abi:ne180100]<0>(v36, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v35, "out");
    v32 = (_QWORD *)((char *)this + 32);
    if (*((char *)this + 55) < 0)
      v32 = (_QWORD *)*v32;
    goto LABEL_34;
  }
  v11 = *(int **)(*(_QWORD *)(v9 + 56) + 80);
  v12 = *(unsigned int **)(*(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10) + 56) + 80);
  v13 = *v12;
  if (*v8 != (_DWORD)v13)
    __assert_rtn("process", "SCTwoInputMixer.cpp", 49, "inOneABL->mNumberBuffers == channelCount");
  v14 = *((_QWORD *)this + 11);
  if (*((_QWORD *)this + 12) == v14)
  {
    std::string::basic_string[abi:ne180100]<0>(v36, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v35, "out");
    v32 = (_QWORD *)((char *)this + 32);
    if (*((char *)this + 55) < 0)
      v32 = (_QWORD *)*v32;
    goto LABEL_34;
  }
  v15 = *v11;
  v16 = *(_DWORD *)(*(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14) + 120) + 8);
  v17 = *((float *)this + 193);
  v18 = (1.0 - v17) * *((float *)this + 194);
  __D = v17 * *((float *)this + 195);
  __B = v18;
  v19 = *((_QWORD *)this + 11);
  if (*((_QWORD *)this + 12) == v19)
  {
    std::string::basic_string[abi:ne180100]<0>(v36, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v35, "out");
    v32 = (_QWORD *)((char *)this + 32);
    if (*((char *)this + 55) < 0)
      v32 = (_QWORD *)*v32;
LABEL_34:
    DSPGraph::strprintf((DSPGraph *)"Box::out inIndex out of range! box %s has %zu outputs but input %u was requested", v31, v32, (uint64_t)(*((_QWORD *)this + 12) - *((_QWORD *)this + 11)) >> 5, 0);
    DSPGraph::ThrowException();
LABEL_35:
    __break(1u);
    return;
  }
  __N = (a2 << (v16 == 1718773105));
  if (4 * __N > *(unsigned int *)(*(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 40))(v19) + 56)
                                 + 100))
    __assert_rtn("process", "SCTwoInputMixer.cpp", 59, "out(0).wire()->buffer()->byteCapacity() >= n * sizeof(Float32)");
  if ((_DWORD)v13)
  {
    v21 = 0;
    v22 = v15 - 1;
    v23 = (float **)(v12 + 4);
    do
    {
      if ((int)v13 - 1 >= v21)
        v24 = v21;
      else
        v24 = v13 - 1;
      v25 = *(const float **)&v8[4 * v24 + 4];
      if (v22 >= v21)
        v26 = v21;
      else
        v26 = v22;
      vDSP_vsmsma(v25, 1, &__B, *(const float **)&v11[4 * v26 + 4], 1, &__D, *v23, 1, __N);
      *((_DWORD *)v23 - 1) = 4 * __N;
      ++v21;
      v23 += 2;
    }
    while (v13 != v21);
  }
}

void sub_1B610C628(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a19 < 0)
    operator delete(__p);
  if (a25 < 0)
    operator delete(a20);
  if (a31 < 0)
    operator delete(a26);
  _Unwind_Resume(exception_object);
}

uint64_t SCTwoInputMixer::initialize(SCTwoInputMixer *this)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  const char *v9;
  _QWORD *v10;
  const char *v11;
  _QWORD *v12;
  const char *v13;
  _QWORD *v14;
  _QWORD v15[3];
  _QWORD v16[3];
  _QWORD v17[3];

  DSPGraph::Box::initialize(this);
  v2 = *((_QWORD *)this + 8);
  if (*((_QWORD *)this + 9) == v2)
  {
    std::string::basic_string[abi:ne180100]<0>(v17, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v16, "in");
    v10 = (_QWORD *)((char *)this + 32);
    if (*((char *)this + 55) < 0)
      v10 = (_QWORD *)*v10;
    DSPGraph::strprintf((DSPGraph *)"Box::in inIndex out of range! box %s has %zu inputs but input %u was requested", v9, v10, (uint64_t)(*((_QWORD *)this + 9) - *((_QWORD *)this + 8)) >> 5, 0);
    result = DSPGraph::ThrowException();
    goto LABEL_29;
  }
  v3 = *(_DWORD *)(*(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2) + 120) + 8);
  v4 = *((_QWORD *)this + 8);
  v5 = *((_QWORD *)this + 9) - v4;
  if (v3 != 1819304813)
  {
    if (v5 > 0x20)
    {
      if (*(_DWORD *)(*(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)(v4 + 32) + 40))(v4 + 32) + 120)
                     + 8) != 1718773105)
        goto LABEL_7;
      v8 = *((_QWORD *)this + 11);
      if (*((_QWORD *)this + 12) != v8)
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
        if (*(_DWORD *)(*(_QWORD *)(result + 120) + 8) != 1718773105)
          goto LABEL_7;
        return result;
      }
      std::string::basic_string[abi:ne180100]<0>(v17, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
      std::string::basic_string[abi:ne180100]<0>(v16, "out");
      v14 = (_QWORD *)((char *)this + 32);
      if (*((char *)this + 55) < 0)
        v14 = (_QWORD *)*v14;
LABEL_28:
      DSPGraph::strprintf((DSPGraph *)"Box::out inIndex out of range! box %s has %zu outputs but input %u was requested", v13, v14, (uint64_t)(*((_QWORD *)this + 12) - *((_QWORD *)this + 11)) >> 5, 0);
      result = DSPGraph::ThrowException();
      goto LABEL_29;
    }
    std::string::basic_string[abi:ne180100]<0>(v17, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v16, "in");
    v12 = (_QWORD *)((char *)this + 32);
    if (*((char *)this + 55) < 0)
      v12 = (_QWORD *)*v12;
LABEL_19:
    DSPGraph::strprintf((DSPGraph *)"Box::in inIndex out of range! box %s has %zu inputs but input %u was requested", v11, v12, (uint64_t)(*((_QWORD *)this + 9) - *((_QWORD *)this + 8)) >> 5, 1);
    result = DSPGraph::ThrowException();
    goto LABEL_29;
  }
  if (v5 <= 0x20)
  {
    std::string::basic_string[abi:ne180100]<0>(v17, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v16, "in");
    v12 = (_QWORD *)((char *)this + 32);
    if (*((char *)this + 55) < 0)
      v12 = (_QWORD *)*v12;
    goto LABEL_19;
  }
  if (*(_DWORD *)(*(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)(v4 + 32) + 40))(v4 + 32) + 120) + 8) != 1819304813)
  {
LABEL_7:
    std::string::basic_string[abi:ne180100]<0>(v17, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/InternalAudioUnits/Effects/AUSpatialCapture/SCTwoInputMixer.hpp");
    std::string::basic_string[abi:ne180100]<0>(v16, "initialize");
    std::string::basic_string[abi:ne180100]<0>(v15, "all formats must be either freq or time domains.");
    result = DSPGraph::ThrowException();
LABEL_29:
    __break(1u);
    return result;
  }
  v6 = *((_QWORD *)this + 11);
  if (*((_QWORD *)this + 12) == v6)
  {
    std::string::basic_string[abi:ne180100]<0>(v17, "/AppleInternal/Library/BuildRoots/c7268dd4-5656-11ef-b8ac-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/System/Library/PrivateFrameworks/AudioToolboxCore.framework/PrivateHeaders/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v16, "out");
    v14 = (_QWORD *)((char *)this + 32);
    if (*((char *)this + 55) < 0)
      v14 = (_QWORD *)*v14;
    goto LABEL_28;
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  if (*(_DWORD *)(*(_QWORD *)(result + 120) + 8) != 1819304813)
    goto LABEL_7;
  return result;
}

void sub_1B610CA98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;

  if (a17 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (*(char *)(v23 - 17) < 0)
    operator delete(*(void **)(v23 - 40));
  _Unwind_Resume(exception_object);
}

uint64_t BypassableIRProcessor::initialize(uint64_t a1, uint64_t a2, uint64_t a3, int a4, CFTypeRef *a5, int a6, uint64_t a7, float a8)
{
  CFTypeRef v15;
  uint64_t v16;
  CFTypeRef *v17;
  const void *v18;
  CFTypeRef v19;
  CFTypeRef v20;
  __int128 v21;
  const void *v22;
  const void *v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int v26;
  IR::IRProcessor *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t result;
  uint64_t *v35;
  uint64_t *v36;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  uint64_t *v40;
  uint64_t *v41;
  uint64_t v42;
  std::string *v43;
  __int128 v44;
  std::string *v45;
  __int128 v46;
  _BYTE *v47;
  const __CFString *v48;
  _BYTE *v49;
  std::string *v50;
  __int128 v51;
  std::string *v52;
  __int128 v53;
  _BYTE *v54;
  std::string v55;
  std::string v56;
  CFTypeRef v57;
  _BYTE v58[24];
  __int128 v59;
  __int128 v60;
  char v61;
  CFTypeRef v62;
  __int128 v63;
  CFTypeRef cf;
  _OWORD v65[2];
  const void *v66;
  uint64_t v67;
  int v68;
  _BYTE v69[12];
  char v70;
  uint8_t buf[4];
  _BYTE *v72;
  __int16 v73;
  _BYTE *v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 208) = 0;
  v15 = *a5;
  if (*a5)
  {
    CFRetain(*a5);
    v57 = v15;
    IR::IRDataAttributes::IRDataAttributes((uint64_t)v58, v15, 128, 1, 0.0);
  }
  else
  {
    IR::IRDataAttributes::IRDataAttributes((uint64_t)v58, a1 + 8);
  }
  v17 = (CFTypeRef *)(a1 + 8);
  v16 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)v58;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)&v58[8];
  *(_OWORD *)(a1 + 32) = v59;
  *(_OWORD *)(a1 + 48) = v60;
  *(_BYTE *)(a1 + 64) = v61;
  v18 = *(const void **)(a1 + 72);
  v19 = cf;
  *(_QWORD *)(a1 + 72) = v62;
  *(_QWORD *)v58 = v16;
  v62 = v18;
  *(_OWORD *)(a1 + 80) = v63;
  v20 = *(CFTypeRef *)(a1 + 96);
  *(_QWORD *)(a1 + 96) = v19;
  v21 = v65[0];
  *(_OWORD *)(a1 + 113) = *(_OWORD *)((char *)v65 + 9);
  *(_OWORD *)(a1 + 104) = v21;
  v22 = *(const void **)(a1 + 136);
  *(_DWORD *)(a1 + 152) = v68;
  v23 = v66;
  v24 = v67;
  cf = v20;
  v66 = v22;
  *(_QWORD *)(a1 + 136) = v23;
  *(_QWORD *)(a1 + 144) = v24;
  if (v22)
  {
    CFRelease(v22);
    v20 = cf;
  }
  if (v20)
    CFRelease(v20);
  if (v62)
    CFRelease(v62);
  if (*(_QWORD *)v58)
    CFRelease(*(CFTypeRef *)v58);
  if (v15)
    CFRelease(v15);
  if (a4)
    *(_DWORD *)(a1 + 220) = a4;
  if (CFURLResourceIsReachable(*(CFURLRef *)(a1 + 8), 0))
  {
    if (*(_QWORD *)(a1 + 168) == *(_QWORD *)(a1 + 160))
    {
LABEL_23:
      result = 0;
      *(_BYTE *)(a1 + 208) = 1;
      return result;
    }
    v25 = 0;
    v26 = 1;
    while (1)
    {
      v27 = (IR::IRProcessor *)operator new();
      IR::IRProcessor::IRProcessor(v27, (const IR::IRDataAttributes *)(a1 + 8), a6);
      v28 = *(_QWORD *)(a1 + 160);
      v29 = *(_QWORD *)(v28 + 8 * v25);
      *(_QWORD *)(v28 + 8 * v25) = v27;
      if (v29)
        (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
      v30 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * v25);
      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, float))(*(_QWORD *)v30 + 16))(v30, a2, a3, 0, 0, a7, 0, a8))
      {
        break;
      }
      v31 = *(_QWORD *)(a1 + 184);
      v32 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * v25);
      v33 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v32 + 72))(v32);
      *(_DWORD *)v58 = 0;
      std::vector<float>::resize(v31 + 24 * v25, v33, v58);
      (*(void (**)(_QWORD, uint64_t, float))(**(_QWORD **)(*(_QWORD *)(a1 + 160) + 8 * v25) + 144))(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * v25), 7, (float)((v26 - 1) | 0x10000));
      v25 = v26++;
      if (v25 >= (uint64_t)(*(_QWORD *)(a1 + 168) - *(_QWORD *)(a1 + 160)) >> 3)
        goto LABEL_23;
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v39 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v55, "BypassableIRProcessor");
      v50 = std::string::append(&v55, "::", 2uLL);
      v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
      v56.__r_.__value_.__r.__words[2] = v50->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v51;
      v50->__r_.__value_.__l.__size_ = 0;
      v50->__r_.__value_.__r.__words[2] = 0;
      v50->__r_.__value_.__r.__words[0] = 0;
      v52 = std::string::append(&v56, "initialize", 0xAuLL);
      v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
      *(_QWORD *)&v58[16] = *((_QWORD *)&v52->__r_.__value_.__l + 2);
      *(_OWORD *)v58 = v53;
      v52->__r_.__value_.__l.__size_ = 0;
      v52->__r_.__value_.__r.__words[2] = 0;
      v52->__r_.__value_.__r.__words[0] = 0;
      v54 = v58;
      if (v58[23] < 0)
        v54 = *(_BYTE **)v58;
      *(_DWORD *)v69 = 136315138;
      *(_QWORD *)&v69[4] = v54;
      _os_log_error_impl(&dword_1B5ED0000, v39, OS_LOG_TYPE_ERROR, "%s: Could not initialize bypassable IR processor", v69, 0xCu);
      if ((v58[23] & 0x80000000) != 0)
        operator delete(*(void **)v58);
      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v56.__r_.__value_.__l.__data_);
      if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v55.__r_.__value_.__l.__data_);
    }
    v41 = *(uint64_t **)(a1 + 160);
    v40 = *(uint64_t **)(a1 + 168);
    while (v41 != v40)
    {
      v42 = *v41;
      *v41 = 0;
      if (v42)
        (*(void (**)(uint64_t))(*(_QWORD *)v42 + 8))(v42);
      ++v41;
    }
  }
  else
  {
    v36 = *(uint64_t **)(a1 + 160);
    v35 = *(uint64_t **)(a1 + 168);
    while (v36 != v35)
    {
      v37 = *v36;
      *v36 = 0;
      if (v37)
        (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
      ++v36;
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v38 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v55, "BypassableIRProcessor");
      v43 = std::string::append(&v55, "::", 2uLL);
      v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
      v56.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v44;
      v43->__r_.__value_.__l.__size_ = 0;
      v43->__r_.__value_.__r.__words[2] = 0;
      v43->__r_.__value_.__r.__words[0] = 0;
      v45 = std::string::append(&v56, "initialize", 0xAuLL);
      v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
      *(_QWORD *)&v58[16] = *((_QWORD *)&v45->__r_.__value_.__l + 2);
      *(_OWORD *)v58 = v46;
      v45->__r_.__value_.__l.__size_ = 0;
      v45->__r_.__value_.__r.__words[2] = 0;
      v45->__r_.__value_.__r.__words[0] = 0;
      if (v58[23] >= 0)
        v47 = v58;
      else
        v47 = *(_BYTE **)v58;
      v48 = CFCopyDescription(*v17);
      applesauce::CF::details::CFString_get_value<true>(v48, (uint64_t)v69);
      if (v48)
        CFRelease(v48);
      v49 = v69;
      if (v70 < 0)
        v49 = *(_BYTE **)v69;
      *(_DWORD *)buf = 136315394;
      v72 = v47;
      v73 = 2080;
      v74 = v49;
      _os_log_error_impl(&dword_1B5ED0000, v38, OS_LOG_TYPE_ERROR, "%s: Could not locate an IR file at %s", buf, 0x16u);
      if (v70 < 0)
        operator delete(*(void **)v69);
      if ((v58[23] & 0x80000000) != 0)
        operator delete(*(void **)v58);
      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v56.__r_.__value_.__l.__data_);
      if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v55.__r_.__value_.__l.__data_);
    }
  }
  return 4294956445;
}

void sub_1B610D0E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void BypassableIRProcessor::process(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7;
  float *v8;
  float v9;
  NSObject *v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  void **v15;
  std::string v16;
  std::string v17;
  void *__p[2];
  int64_t v19;
  uint8_t buf[4];
  void **v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 208))
  {
    v7 = *(_QWORD *)(a1 + 160);
    if (a4 < (unint64_t)((*(_QWORD *)(a1 + 168) - v7) >> 3))
    {
      v8 = *(float **)(v7 + 8 * a4);
      v9 = 3000.0;
      if (a7)
        v9 = -1.0;
      v8[100] = v9;
      (*(void (**)(float *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, a2, a3, a5, a6, 0);
    }
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v10 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v16, "BypassableIRProcessor");
      v11 = std::string::append(&v16, "::", 2uLL);
      v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      v17.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      v13 = std::string::append(&v17, "process", 7uLL);
      v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
      v19 = v13->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v14;
      v13->__r_.__value_.__l.__size_ = 0;
      v13->__r_.__value_.__r.__words[2] = 0;
      v13->__r_.__value_.__r.__words[0] = 0;
      v15 = __p;
      if (v19 < 0)
        v15 = (void **)__p[0];
      *(_DWORD *)buf = 136315138;
      v21 = v15;
      _os_log_error_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_ERROR, "%s: Uninitialized", buf, 0xCu);
      if (SHIBYTE(v19) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v17.__r_.__value_.__l.__data_);
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v16.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1B610D394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void BypassableIRProcessor::processMultipleInputs(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  float *v9;
  float v10;
  NSObject *v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  void **v16;
  std::string v17;
  std::string v18;
  void *__p[2];
  int64_t v20;
  uint8_t buf[4];
  void **v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 208))
  {
    v8 = *(_QWORD *)(a1 + 160);
    if (a4 < (unint64_t)((*(_QWORD *)(a1 + 168) - v8) >> 3))
    {
      v9 = *(float **)(v8 + 8 * a4);
      v10 = 3000.0;
      if (a8)
        v10 = -1.0;
      v9[100] = v10;
      (*(void (**)(float *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v9 + 48))(v9, a2, a3, a5, a6, a7, 0);
    }
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v11 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v17, "BypassableIRProcessor");
      v12 = std::string::append(&v17, "::", 2uLL);
      v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      v14 = std::string::append(&v18, "processMultipleInputs", 0x15uLL);
      v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v20 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      v16 = __p;
      if (v20 < 0)
        v16 = (void **)__p[0];
      *(_DWORD *)buf = 136315138;
      v22 = v16;
      _os_log_error_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_ERROR, "%s: Uninitialized", buf, 0xCu);
      if (SHIBYTE(v20) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v18.__r_.__value_.__l.__data_);
      if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v17.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1B610D5B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void BypassableIRProcessor::crossFade(BypassableIRProcessor *this, const float *__src, float *__dst, unsigned int a4, unsigned int a5, unsigned int a6)
{
  uint64_t v10;
  unsigned int v13;
  vDSP_Length v14;
  float *v15;
  float v16;
  unsigned int v17;
  NSObject *v18;
  std::string *v19;
  __int128 v20;
  std::string *v21;
  __int128 v22;
  __int128 *p_Start;
  std::string v24;
  std::string __Step;
  __int128 __Start;
  int64_t v27;
  uint8_t buf[4];
  __int128 *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 208))
  {
    v10 = *((unsigned int *)this + 54);
    if (v10 >= a6)
    {
      if (*((_BYTE *)this + 209))
        memcpy(__dst, __src, 4 * a6);
    }
    else
    {
      if ((_DWORD)v10 && *((_BYTE *)this + 209))
      {
        memcpy(__dst, __src, 4 * v10);
        LODWORD(v10) = *((_DWORD *)this + 54);
      }
      v13 = *((_DWORD *)this + 53);
      if (a6 - v10 >= v13)
        v14 = v13;
      else
        v14 = a6 - v10;
      if ((_DWORD)v14)
      {
        v15 = (float *)(*(_QWORD *)(*((_QWORD *)this + 23) + 24 * a4) + 4 * a5);
        *(float *)&__Start = 1.0 - *v15;
        v16 = -1.0;
        if (*((_BYTE *)this + 209))
          v16 = 1.0;
        *(float *)&__Step.__r_.__value_.__l.__data_ = v16 / (float)*((unsigned int *)this + 55);
        vDSP_vrampmul(&__dst[v10], 1, v15, (const float *)&__Step, &__dst[v10], 1, v14);
        *(float *)&__Step.__r_.__value_.__l.__data_ = -*(float *)&__Step.__r_.__value_.__l.__data_;
        vDSP_vrampmuladd(&__src[*((unsigned int *)this + 54)], 1, (float *)&__Start, (const float *)&__Step, &__dst[*((unsigned int *)this + 54)], 1, v14);
        LODWORD(v10) = *((_DWORD *)this + 54);
      }
      v17 = v10 + v14;
      if (a6 > v17 && !*((_BYTE *)this + 209))
        memcpy(&__dst[v17], &__src[v17], 4 * (a6 - v17));
    }
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v18 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v24, "BypassableIRProcessor");
      v19 = std::string::append(&v24, "::", 2uLL);
      v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
      __Step.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__Step.__r_.__value_.__l.__data_ = v20;
      v19->__r_.__value_.__l.__size_ = 0;
      v19->__r_.__value_.__r.__words[2] = 0;
      v19->__r_.__value_.__r.__words[0] = 0;
      v21 = std::string::append(&__Step, "crossFade", 9uLL);
      v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
      v27 = v21->__r_.__value_.__r.__words[2];
      __Start = v22;
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      p_Start = &__Start;
      if (v27 < 0)
        p_Start = (__int128 *)__Start;
      *(_DWORD *)buf = 136315138;
      v29 = p_Start;
      _os_log_error_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_ERROR, "%s: Uninitialized", buf, 0xCu);
      if (SHIBYTE(v27) < 0)
        operator delete((void *)__Start);
      if (SHIBYTE(__Step.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__Step.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v24.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1B610D8E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t BypassableIRProcessor::reset(uint64_t this, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;

  if (*(_BYTE *)(this + 208))
  {
    v2 = *(uint64_t **)(this + 160);
    for (i = *(uint64_t **)(this + 168);
          v2 != i;
          this = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 192))(v5, a2))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)*v2 + 32))(*v2);
      v5 = *v2++;
    }
  }
  return this;
}

void BypassableIRProcessor::initializeFadingParameters(BypassableIRProcessor *this, int a2, int a3)
{
  NSObject *v4;
  _QWORD *v5;
  unint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  std::string *v15;
  __int128 v16;
  std::string *v17;
  __int128 v18;
  __int128 *p_A;
  std::string v20;
  std::string v21;
  __int128 __A;
  int64_t v23;
  uint8_t buf[4];
  __int128 *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 208))
  {
    if (a2)
    {
      *((_DWORD *)this + 53) = 0;
      *((_DWORD *)this + 54) = 0;
    }
    else if (!*((_BYTE *)this + 209) || (a3 & 1) != 0)
    {
      if (!*((_BYTE *)this + 209) && a3)
      {
        *((_DWORD *)this + 53) = *((_DWORD *)this + 55);
        LODWORD(__A) = 1065353216;
        if (*((_QWORD *)this + 21) == *((_QWORD *)this + 20))
        {
          *((_DWORD *)this + 54) = 0;
        }
        else
        {
          v10 = 0;
          v11 = 1;
          do
          {
            vDSP_vfill((const float *)&__A, *(float **)(*((_QWORD *)this + 23) + 24 * v10), 1, (uint64_t)(*(_QWORD *)(*((_QWORD *)this + 23) + 24 * v10 + 8)- *(_QWORD *)(*((_QWORD *)this + 23) + 24 * v10)) >> 2);
            v10 = v11;
            v13 = (_QWORD *)*((_QWORD *)this + 20);
            v12 = (_QWORD *)*((_QWORD *)this + 21);
            ++v11;
          }
          while (v10 < v12 - v13);
          v14 = *((unsigned __int8 *)this + 208);
          *((_DWORD *)this + 54) = 0;
          if (v14 && !*((_DWORD *)this + 53))
          {
            while (v13 != v12)
            {
              if (*v13)
                (*(void (**)(_QWORD))(*(_QWORD *)*v13 + 32))(*v13);
              ++v13;
            }
          }
        }
      }
    }
    else
    {
      *((_DWORD *)this + 53) = *((_DWORD *)this + 55);
      v5 = (_QWORD *)*((_QWORD *)this + 21);
      if (v5 == *((_QWORD **)this + 20))
        goto LABEL_14;
      v6 = 0;
      v7 = 1;
      do
      {
        vDSP_vclr(*(float **)(*((_QWORD *)this + 23) + 24 * v6), 1, (uint64_t)(*(_QWORD *)(*((_QWORD *)this + 23) + 24 * v6 + 8) - *(_QWORD *)(*((_QWORD *)this + 23) + 24 * v6)) >> 2);
        v6 = v7;
        v5 = (_QWORD *)*((_QWORD *)this + 20);
        v8 = (_QWORD *)*((_QWORD *)this + 21);
        ++v7;
      }
      while (v6 < v8 - v5);
      if (*((_BYTE *)this + 208))
      {
LABEL_14:
        v9 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v5 + 56))(*v5);
        v5 = (_QWORD *)*((_QWORD *)this + 20);
        v8 = (_QWORD *)*((_QWORD *)this + 21);
      }
      else
      {
        v9 = 0;
      }
      *((_DWORD *)this + 54) = v9;
      while (v5 != v8)
      {
        if (*v5)
          (*(void (**)(_QWORD))(*(_QWORD *)*v5 + 32))(*v5);
        ++v5;
      }
    }
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v4 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v20, "BypassableIRProcessor");
      v15 = std::string::append(&v20, "::", 2uLL);
      v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
      v21.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v16;
      v15->__r_.__value_.__l.__size_ = 0;
      v15->__r_.__value_.__r.__words[2] = 0;
      v15->__r_.__value_.__r.__words[0] = 0;
      v17 = std::string::append(&v21, "initializeFadingParameters", 0x1AuLL);
      v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
      v23 = v17->__r_.__value_.__r.__words[2];
      __A = v18;
      v17->__r_.__value_.__l.__size_ = 0;
      v17->__r_.__value_.__r.__words[2] = 0;
      v17->__r_.__value_.__r.__words[0] = 0;
      p_A = &__A;
      if (v23 < 0)
        p_A = (__int128 *)__A;
      *(_DWORD *)buf = 136315138;
      v25 = p_A;
      _os_log_error_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_ERROR, "%s: Uninitialized", buf, 0xCu);
      if (SHIBYTE(v23) < 0)
        operator delete((void *)__A);
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v21.__r_.__value_.__l.__data_);
      if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v20.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1B610DC70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void BypassableIRProcessor::updateFadingParameters(BypassableIRProcessor *this, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;
  NSObject *v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  void **v12;
  std::string v13;
  std::string v14;
  void *__p[2];
  int64_t v16;
  uint8_t buf[4];
  void **v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 208))
  {
    v2 = *((_DWORD *)this + 54);
    if (v2 >= a2)
    {
      *((_DWORD *)this + 54) = v2 - a2;
    }
    else
    {
      v3 = *((_DWORD *)this + 53);
      if (v3)
      {
        v4 = a2 - v2;
        v5 = v3 >= v4;
        v6 = v3 - v4;
        if (!v5)
          v6 = 0;
        *((_DWORD *)this + 53) = v6;
      }
      *((_DWORD *)this + 54) = 0;
    }
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v7 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v13, "BypassableIRProcessor");
      v8 = std::string::append(&v13, "::", 2uLL);
      v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v14.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      v10 = std::string::append(&v14, "updateFadingParameters", 0x16uLL);
      v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v16 = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      v12 = __p;
      if (v16 < 0)
        v12 = (void **)__p[0];
      *(_DWORD *)buf = 136315138;
      v18 = v12;
      _os_log_error_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_ERROR, "%s: Uninitialized", buf, 0xCu);
      if (SHIBYTE(v16) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v14.__r_.__value_.__l.__data_);
      if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v13.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1B610DE54(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t BypassableIRProcessor::setIsProcessing(uint64_t this, char a2)
{
  *(_BYTE *)(this + 209) = a2;
  return this;
}

uint64_t BypassableIRProcessor::getIRDataAttributes@<X0>(BypassableIRProcessor *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;

  if (!*((_BYTE *)this + 208))
    return IR::getPresetDataAttributes();
  v3 = **((_QWORD **)this + 20);
  if (!v3)
    return IR::getPresetDataAttributes();
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 224))(v3);
  return IR::IRDataAttributes::IRDataAttributes(a2, v4);
}

uint64_t BypassableIRProcessor::setCoordinate(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;

  if (*(_BYTE *)(result + 208))
  {
    v3 = *(_QWORD *)(result + 160);
    if (a3 < (unint64_t)((*(_QWORD *)(result + 168) - v3) >> 3))
    {
      result = *(_QWORD *)(v3 + 8 * a3);
      if (result)
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 144))(result);
    }
  }
  return result;
}

float BypassableIRProcessor::getCoordinate(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  float result;

  if (!*(_BYTE *)(a1 + 208))
    return 0.0;
  v3 = *(_QWORD *)(a1 + 160);
  if (a3 >= (unint64_t)((*(_QWORD *)(a1 + 168) - v3) >> 3))
    return 0.0;
  v4 = *(_QWORD *)(v3 + 8 * a3);
  if (!v4)
    return 0.0;
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 152))(v4);
  return result;
}

uint64_t BypassableIRProcessor::getMaxDelay(BypassableIRProcessor *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;

  if (*((_BYTE *)this + 208)
    && (v2 = *((_QWORD *)this + 20), a2 < (unint64_t)((*((_QWORD *)this + 21) - v2) >> 3))
    && (v3 = *(_QWORD *)(v2 + 8 * a2)) != 0)
  {
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 96))(v3);
  }
  else
  {
    return 0;
  }
}

float BypassableIRProcessor::getCurrentDelay(BypassableIRProcessor *this, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  float result;

  if (!*((_BYTE *)this + 208))
    return 0.0;
  v3 = *((_QWORD *)this + 20);
  if (a2 >= (unint64_t)((*((_QWORD *)this + 21) - v3) >> 3))
    return 0.0;
  v4 = *(_QWORD *)(v3 + 8 * a2);
  if (!v4)
    return 0.0;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 112))(v4, a3);
  return result;
}

uint64_t IR::IRDataAttributes::IRDataAttributes(uint64_t a1, uint64_t a2)
{
  CFTypeRef v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(CFTypeRef *)a2;
  if (*(_QWORD *)a2)
    CFRetain(*(CFTypeRef *)a2);
  *(_QWORD *)a1 = v4;
  v5 = *(_OWORD *)(a2 + 8);
  v6 = *(_OWORD *)(a2 + 24);
  v7 = *(_OWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v7;
  *(_OWORD *)(a1 + 24) = v6;
  *(_OWORD *)(a1 + 8) = v5;
  v8 = *(_QWORD *)(a2 + 64);
  if (v8)
    CFRetain(*(CFTypeRef *)(a2 + 64));
  *(_QWORD *)(a1 + 64) = v8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  v9 = *(_QWORD *)(a2 + 88);
  if (v9)
    CFRetain(*(CFTypeRef *)(a2 + 88));
  *(_QWORD *)(a1 + 88) = v9;
  v10 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 105) = *(_OWORD *)(a2 + 105);
  *(_OWORD *)(a1 + 96) = v10;
  v11 = *(_QWORD *)(a2 + 128);
  if (v11)
    CFRetain(*(CFTypeRef *)(a2 + 128));
  *(_QWORD *)(a1 + 128) = v11;
  v12 = *(_QWORD *)(a2 + 136);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 136) = v12;
  return a1;
}

uint64_t IR::IRDataAttributes::IRDataAttributes(uint64_t a1, CFTypeRef cf, int a3, char a4, float a5)
{
  CFURLRef v11;

  if (cf)
    CFRetain(cf);
  v11 = (CFURLRef)cf;
  IR::IRDataAttributes::IRDataAttributes(a1, &v11, a3, a4, a5);
  if (cf)
    CFRelease(cf);
  return a1;
}

void sub_1B610E0F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::URLRef::~URLRef((const void **)va);
  _Unwind_Resume(a1);
}

void applesauce::CF::URLRef::~URLRef(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

IR::IRProcessor *IR::IRProcessor::IRProcessor(IR::IRProcessor *this, const IR::IRDataAttributes *a2, int a3)
{
  *(_QWORD *)this = &off_1E69E7F58;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((IR::IRProcessor *)((char *)this + 20));
  IR::IRDataAttributes::IRDataAttributes((uint64_t)this + 24, (uint64_t)a2);
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_BYTE *)this + 176) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_BYTE *)this + 208) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  IR::IRCoordinates::IRCoordinates((IR::IRProcessor *)((char *)this + 360));
  *((_DWORD *)this + 99) = 0;
  *((_QWORD *)this + 50) = 0x3F800000453B8000;
  *((_BYTE *)this + 408) = 1;
  *((_DWORD *)this + 103) = a3;
  *((_WORD *)this + 208) = 1;
  *((_DWORD *)this + 105) = 0;
  *((_QWORD *)this + 53) = 0;
  *((_DWORD *)this + 109) = -65536;
  *((_BYTE *)this + 440) = 0;
  return this;
}

void sub_1B610E224(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _QWORD *v2;
  IR::IRDataAttributes *v3;
  uint64_t v4;
  void *v6;
  void *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  v6 = (void *)v2[42];
  if (v6)
  {
    v2[43] = v6;
    operator delete(v6);
  }
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  v7 = (void *)v2[33];
  if (v7)
  {
    v2[34] = v7;
    operator delete(v7);
  }
  std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<IR::DelayLine>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  v8 = v2[25];
  v2[25] = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v4);
  IR::IRDataAttributes::~IRDataAttributes(v3);
  _Unwind_Resume(a1);
}

void std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = MEMORY[0x1BCC94D68](v4 - 40);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 7;
        std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<IR::DelayLine>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        IR::DelayLine::~DelayLine((IR::DelayLine *)(v4 - 304));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void IR::IRDataAttributes::~IRDataAttributes(IR::IRDataAttributes *this)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)*((_QWORD *)this + 16);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 11);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 8);
  if (v4)
    CFRelease(v4);
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
}

void std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
}

uint64_t IR::IRDataAttributes::IRDataAttributes(uint64_t a1, CFURLRef *a2, int a3, char a4, float a5)
{
  CFURLRef v6;
  const void *v7;
  const void *v9;

  *(_QWORD *)a1 = 0;
  *(float *)(a1 + 8) = a5;
  *(_DWORD *)(a1 + 12) = a3;
  *(_BYTE *)(a1 + 16) = a4;
  *(_BYTE *)(a1 + 17) = 0;
  *(_DWORD *)(a1 + 20) = 2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 40) = xmmword_1B66A0570;
  *(_BYTE *)(a1 + 56) = 1;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_DWORD *)(a1 + 108) = 1500;
  *(_BYTE *)(a1 + 112) = 1;
  *(_DWORD *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  if (*a2)
  {
    v6 = CFURLCopyAbsoluteURL(*a2);
    applesauce::CF::URLRef::URLRef((applesauce::CF::URLRef *)&v9, v6);
    v7 = *(const void **)a1;
    *(_QWORD *)a1 = v9;
    v9 = v7;
    if (v7)
      CFRelease(v7);
  }
  return a1;
}

void sub_1B610E574(_Unwind_Exception *a1)
{
  const void **v1;
  const void **v2;
  const void **v3;

  applesauce::CF::DictionaryRef::~DictionaryRef(v3);
  applesauce::CF::URLRef::~URLRef(v1 + 11);
  applesauce::CF::URLRef::~URLRef(v2);
  applesauce::CF::URLRef::~URLRef(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::URLRef *applesauce::CF::URLRef::URLRef(applesauce::CF::URLRef *this, CFTypeRef cf)
{
  CFTypeID v3;
  std::runtime_error *exception;

  *(_QWORD *)this = cf;
  if (cf)
  {
    v3 = CFGetTypeID(cf);
    if (v3 != CFURLGetTypeID())
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
  }
  return this;
}

{
  if (cf)
    CFRetain(cf);
  *(_QWORD *)this = cf;
  return this;
}

void sub_1B610E620(_Unwind_Exception *a1)
{
  CFTypeRef *v1;
  void *v2;

  __cxa_free_exception(v2);
  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(a1);
}

void BypassableIRProcessor::BypassableIRProcessor(BypassableIRProcessor *this, const IR::IRDataAttributes *a2, unsigned int a3)
{
  NSObject *v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  __int128 v30;
  void **v31;
  std::string v32;
  std::string v33;
  void *__p[2];
  int64_t v35;
  uint8_t buf[4];
  void **v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E69E1688;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)this + 8, (uint64_t)a2);
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 53) = 0;
  *((_DWORD *)this + 54) = 0;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_WORD *)this + 104) = 0;
  *((_DWORD *)this + 55) = 512;
  if (!a3)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v5 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      std::string::basic_string[abi:ne180100]<0>(&v32, "BypassableIRProcessor");
      v27 = std::string::append(&v32, "::", 2uLL);
      v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      v33.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      v29 = std::string::append(&v33, "BypassableIRProcessor", 0x15uLL);
      v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
      v35 = v29->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v30;
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      v29->__r_.__value_.__r.__words[0] = 0;
      v31 = __p;
      if (v35 < 0)
        v31 = (void **)__p[0];
      *(_DWORD *)buf = 136315138;
      v37 = v31;
      _os_log_error_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_ERROR, "%s: inNumIRProcessors cannot be zero when creating an instance of this class", buf, 0xCu);
      if (SHIBYTE(v35) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v33.__r_.__value_.__l.__data_);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v32.__r_.__value_.__l.__data_);
    }
  }
  v7 = (_QWORD *)*((_QWORD *)this + 20);
  v6 = (_QWORD *)*((_QWORD *)this + 21);
  v8 = v6 - v7;
  if (a3 <= v8)
  {
    if (a3 < v8)
    {
      v19 = &v7[a3];
      while (v6 != v19)
      {
        v21 = *--v6;
        v20 = v21;
        *v6 = 0;
        if (v21)
          (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
      }
      *((_QWORD *)this + 21) = v19;
    }
  }
  else
  {
    v9 = a3 - v8;
    v10 = *((_QWORD *)this + 22);
    if (v9 <= (v10 - (uint64_t)v6) >> 3)
    {
      bzero(*((void **)this + 21), 8 * v9);
      *((_QWORD *)this + 21) = &v6[v9];
    }
    else
    {
      v11 = v10 - (_QWORD)v7;
      v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)a3)
        v12 = a3;
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v14 = (char *)operator new(8 * v13);
      v15 = &v14[8 * v8];
      v16 = &v14[8 * v13];
      bzero(v15, 8 * v9);
      v17 = &v15[8 * v9];
      while (v6 != v7)
      {
        v18 = *--v6;
        *v6 = 0;
        *((_QWORD *)v15 - 1) = v18;
        v15 -= 8;
      }
      v22 = *((_OWORD *)this + 10);
      *((_QWORD *)this + 20) = v15;
      *((_QWORD *)this + 21) = v17;
      *((_QWORD *)this + 22) = v16;
      v23 = (_QWORD *)*((_QWORD *)&v22 + 1);
      v24 = (_QWORD *)v22;
      while (v23 != v24)
      {
        v26 = *--v23;
        v25 = v26;
        *v23 = 0;
        if (v26)
          (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
      }
      if (v24)
        operator delete(v24);
    }
  }
  std::vector<std::vector<float>>::resize((uint64_t *)this + 23, a3);
}

void sub_1B610E960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23)
{
  IR::IRDataAttributes *v23;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  IR::IRDataAttributes::~IRDataAttributes(v23);
  _Unwind_Resume(a1);
}

void NoiseSuppression::Noise::VPv3::~VPv3(NoiseSuppression::Noise::VPv3 *this)
{
  NoiseSuppression::Noise::VPv3::~VPv3(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  *(_QWORD *)this = &off_1E69CBB38;
  v2 = (void *)*((_QWORD *)this + 38);
  if (v2)
    operator delete(v2);
  v3 = (void *)*((_QWORD *)this + 35);
  if (v3)
  {
    *((_QWORD *)this + 36) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 32);
  if (v4)
  {
    *((_QWORD *)this + 33) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 29);
  if (v5)
  {
    *((_QWORD *)this + 30) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 26);
  if (v6)
  {
    *((_QWORD *)this + 27) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 23);
  if (v7)
  {
    *((_QWORD *)this + 24) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 19);
  if (v8)
  {
    *((_QWORD *)this + 20) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 15);
  if (v9)
  {
    *((_QWORD *)this + 16) = v9;
    operator delete(v9);
  }
  NoiseSuppression::Noise::NoiseEstimator::~NoiseEstimator(this);
}

void NoiseSuppression::Noise::VPv3::Init(NoiseSuppression::Noise::VPv3 *this)
{
  float v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  float *v9;
  vDSP_Length v10;
  float *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  float v16;
  float v17;
  float *v18;
  float *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  unsigned int v27;
  float v28;
  float v29;
  uint64_t v30;
  int v31;
  int v32;

  v2 = *((float *)this + 4);
  *((float *)this + 21) = expf(-1.0 / (float)(*((float *)this + 20) * v2));
  *((float *)this + 25) = 1.0 - expf(-1.0 / (float)(v2 * *((float *)this + 24)));
  std::vector<float>::resize((uint64_t)this + 184, *((unsigned int *)this + 3));
  v3 = (uint64_t)(*((_QWORD *)this + 24) - *((_QWORD *)this + 23)) >> 2;
  v32 = 0;
  std::vector<float>::assign((char **)this + 23, v3, &v32);
  std::vector<float>::resize((uint64_t)this + 208, *((unsigned int *)this + 3));
  v4 = (uint64_t)(*((_QWORD *)this + 27) - *((_QWORD *)this + 26)) >> 2;
  v32 = 0;
  std::vector<float>::assign((char **)this + 26, v4, &v32);
  std::vector<float>::resize((uint64_t)this + 232, *((unsigned int *)this + 3));
  v5 = (uint64_t)(*((_QWORD *)this + 30) - *((_QWORD *)this + 29)) >> 2;
  v32 = 0;
  std::vector<float>::assign((char **)this + 29, v5, &v32);
  std::vector<float>::resize((uint64_t)this + 256, *((unsigned int *)this + 3));
  std::vector<float>::assign((char **)this + 32, (uint64_t)(*((_QWORD *)this + 33) - *((_QWORD *)this + 32)) >> 2, &AUFTSpatialAC::kFTSpatialMinWindow_XY_size);
  std::vector<float>::resize((uint64_t)this + 280, *((unsigned int *)this + 3));
  v6 = *((unsigned int *)this + 3);
  v32 = 0;
  std::vector<float>::assign((char **)this + 35, v6, &v32);
  std::vector<BOOL>::resize((uint64_t)this + 304, *((unsigned int *)this + 3), 0);
  v7 = *((unsigned int *)this + 3);
  LOBYTE(v32) = 0;
  std::vector<BOOL>::assign((uint64_t)this + 304, v7, &v32);
  std::vector<float>::resize((uint64_t)this + 120, *((unsigned int *)this + 37));
  v8 = *((unsigned int *)this + 37);
  v32 = 0;
  std::vector<float>::assign((char **)this + 15, v8, &v32);
  v9 = (float *)*((_QWORD *)this + 15);
  v10 = (uint64_t)(*((_QWORD *)this + 16) - (_QWORD)v9) >> 2;
  v11 = (float *)*((_QWORD *)this + 19);
  v12 = *((_QWORD *)this + 20);
  v13 = ((v12 - (uint64_t)v11) >> 3) - 1;
  if ((v12 - (uint64_t)v11) >> 3 != 1)
  {
    v14 = 0;
    LODWORD(v15) = 0;
    v16 = (float)v10 / (float)(*(float *)(v12 - 8) - *v11);
    v17 = *v11 * v16;
    do
    {
      v18 = &v11[2 * v14];
      v14 = (v14 + 1);
      v19 = &v11[2 * v14];
      v20 = v18[1];
      v22 = *v19;
      v21 = v19[1];
      v23 = v16 * (float)((float)(*v18 + *v19) * 0.5);
      v24 = (float)(v20 + v21) * 0.5;
      if (v17 < v23)
      {
        v25 = v16 * *v18;
        v15 = (int)v15;
        do
        {
          v9[v15++] = v20
                    + (float)((float)((float)((float)(v17 - v25) / (float)(v23 - v25))
                                    * (float)((float)(v17 - v25) / (float)(v23 - v25)))
                            * (float)(v24 - v20));
          v17 = v17 + 1.0;
        }
        while (v17 < v23);
      }
      v26 = v16 * v22;
      if (v17 < v26)
      {
        v27 = *((_DWORD *)this + 37);
        v28 = v23 - v26;
        v29 = v21 - v24;
        v30 = (int)v15;
        if (v15 <= v27)
          LODWORD(v15) = *((_DWORD *)this + 37);
        while (v27 > v30)
        {
          v31 = v30 + 1;
          v9[v30] = v24
                  + (float)((float)(1.0 - (float)((float)((float)(v17 - v26) / v28) * (float)((float)(v17 - v26) / v28)))
                          * v29);
          v17 = v17 + 1.0;
          ++v30;
          if (v17 >= v26)
          {
            LODWORD(v15) = v31;
            break;
          }
        }
      }
    }
    while (v13 > v14);
  }
  vDSP_vneg(v9, 1, v9, 1, v10);
  *((_DWORD *)this + 44) = 0;
  *((_BYTE *)this + 24) = 1;
}

void NoiseSuppression::Noise::VPv3::Process(NoiseSuppression::Noise::VPv3 *this, const float *__A, float *a3, unsigned int a4)
{
  const float *v6;
  int v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  unint64_t v15;
  float v16;
  unsigned int v17;
  const float *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  float v25;
  float v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float v31;
  float v32;
  float __B;

  v6 = __A;
  v8 = *((_DWORD *)this + 44);
  if (v8 == 2)
  {
LABEL_11:
    v10 = (float *)*((_QWORD *)this + 23);
    v11 = *((_QWORD *)this + 35);
    v12 = 1.0 - *((float *)this + 21);
    v13 = *((float *)this + 23);
    v32 = v12 * (float)(1.0 - v13);
    __B = v12 * v13;
    *(_DWORD *)v11 = 0;
    vDSP_vsmul(v6, 1, &__B, (float *)(v11 + 4), 1, a4 - 1);
    vDSP_vsma(v6 + 1, 1, &__B, (const float *)v11, 1, (float *)v11, 1, a4 - 1);
    vDSP_vsma(v6, 1, &v32, (const float *)v11, 1, (float *)v11, 1, a4);
    vDSP_vsma(v10, 1, (const float *)this + 21, (const float *)v11, 1, v10, 1, a4);
    v14 = *((float *)this + 4);
    LODWORD(v15) = *((_DWORD *)this + 5);
    if (v14 * 0.5 <= (double)v15)
      v16 = v14 * *((float *)this + 28);
    else
      v16 = v14 * 0.2;
    v17 = *((_DWORD *)this + 22) + 1;
    *((_DWORD *)this + 22) = v17;
    if (v16 >= (float)v17)
    {
      vDSP_vmin(*((const float **)this + 26), 1, *((const float **)this + 23), 1, *((float **)this + 26), 1, (uint64_t)(*((_QWORD *)this + 27) - *((_QWORD *)this + 26)) >> 2);
      vDSP_vmin(*((const float **)this + 29), 1, *((const float **)this + 23), 1, *((float **)this + 29), 1, (uint64_t)(*((_QWORD *)this + 27) - *((_QWORD *)this + 26)) >> 2);
    }
    else
    {
      v18 = (const float *)*((_QWORD *)this + 29);
      *((_DWORD *)this + 22) = 0;
      vDSP_vmin(v18, 1, *((const float **)this + 23), 1, *((float **)this + 26), 1, (uint64_t)(*((_QWORD *)this + 27) - *((_QWORD *)this + 26)) >> 2);
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 232, *((char **)this + 23), *((_QWORD *)this + 24), (uint64_t)(*((_QWORD *)this + 24) - *((_QWORD *)this + 23)) >> 2);
    }
    vDSP_vma(*((const float **)this + 26), 1, *((const float **)this + 15), 1, *((const float **)this + 23), 1, *((float **)this + 35), 1, (uint64_t)(*((_QWORD *)this + 27) - *((_QWORD *)this + 26)) >> 2);
    if (!a4)
      goto LABEL_33;
    v19 = 0;
    v20 = *((_QWORD *)this + 32);
    v21 = *((_QWORD *)this + 35);
    v22 = *((_QWORD *)this + 26);
    v23 = *((_QWORD *)this + 38);
    while (1)
    {
      v24 = v6[v19];
      v25 = *(float *)(v22 + 4 * v19);
      v26 = v24 - (float)(v25 * *((float *)this + 27));
      if (*(float *)(v21 + 4 * v19) >= v26)
        v26 = *(float *)(v21 + 4 * v19);
      v27 = v19 >> 6;
      v28 = 1 << v19;
      if (v26 <= 0.0)
        v29 = *(_QWORD *)(v23 + 8 * v27) | v28;
      else
        v29 = *(_QWORD *)(v23 + 8 * v27) & ~v28;
      v30 = *((float *)this + 25);
      v31 = *(float *)(v20 + 4 * v19);
      *(_QWORD *)(v23 + 8 * v27) = v29;
      if ((v29 & v28) != 0)
        goto LABEL_27;
      if (*(float *)(*((_QWORD *)this + 23) + 4 * v19) < (float)(v25 * *((float *)this + 26)))
        break;
LABEL_28:
      if (a3)
        a3[v19] = v31;
      if (a4 == ++v19)
        goto LABEL_33;
    }
    v24 = (float)((float)(1.0 - v30) * v31) + (float)(v24 * v30);
LABEL_27:
    *(float *)(v20 + 4 * v19) = v24;
    v31 = v24;
    goto LABEL_28;
  }
  if (v8 == 1)
  {
    *((_DWORD *)this + 44) = 2;
    memcpy(*((void **)this + 32), __A, 4 * a4);
    memcpy(*((void **)this + 26), v6, 4 * a4);
    v8 = *((_DWORD *)this + 44);
LABEL_10:
    if (v8 != 2)
      goto LABEL_33;
    goto LABEL_11;
  }
  if (v8)
    goto LABEL_10;
  if (a4)
  {
    v9 = 4 * a4;
    while (*v6 == 0.0)
    {
      ++v6;
      v9 -= 4;
      if (!v9)
        goto LABEL_33;
    }
    *((_DWORD *)this + 44) = 1;
  }
LABEL_33:
  ++*((_DWORD *)this + 5);
}

uint64_t NoiseSuppression::Noise::VPv3::GetNoiseBins(NoiseSuppression::Noise::VPv3 *this)
{
  return (uint64_t)this + 304;
}

void std::vector<BOOL>::assign(uint64_t a1, unint64_t a2, _BYTE *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  __int128 v13;
  char *v14;
  __int128 v15;

  *(_QWORD *)(a1 + 8) = 0;
  if (a2)
  {
    v6 = *(_QWORD *)(a1 + 16);
    v7 = v6 << 6;
    if (v6 << 6 >= a2)
    {
      *(_QWORD *)(a1 + 8) = a2;
    }
    else
    {
      v14 = 0;
      v15 = 0uLL;
      if ((a2 & 0x8000000000000000) != 0)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v8 = v6 << 7;
      if (v8 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0))
        v8 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0;
      if (v7 <= 0x3FFFFFFFFFFFFFFELL)
        v9 = v8;
      else
        v9 = 0x7FFFFFFFFFFFFFFFLL;
      std::vector<BOOL>::reserve(&v14, v9);
      v11 = v14;
      v12 = *((_QWORD *)&v15 + 1);
      v14 = *(char **)a1;
      v10 = v14;
      v13 = *(_OWORD *)(a1 + 8);
      *(_QWORD *)a1 = v11;
      *(_QWORD *)(a1 + 8) = a2;
      *(_QWORD *)(a1 + 16) = v12;
      v15 = v13;
      if (v10)
        operator delete(v10);
    }
    if (*a3)
    {
      v14 = *(char **)a1;
      LODWORD(v15) = 0;
      std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(&v14, a2);
    }
    else
    {
      v14 = *(char **)a1;
      LODWORD(v15) = 0;
      std::__fill_n[abi:ne180100]<false,std::__bitset<1ul,8ul>>((uint64_t)&v14, a2);
    }
  }
}

void sub_1B610F0F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void AUEchoGateV3::~AUEchoGateV3(void **this)
{
  AUEchoGateV3::~AUEchoGateV3(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  *this = &off_1E69C6378;
  AUEchoGateV3::Cleanup((AUEchoGateV3 *)this);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)(this + 101));
  if (*((char *)this + 759) < 0)
    operator delete(this[92]);
  v2 = this[86];
  if (v2)
  {
    this[87] = v2;
    operator delete(v2);
  }
  v3 = this[83];
  if (v3)
  {
    this[84] = v3;
    operator delete(v3);
  }
  v4 = this[80];
  if (v4)
  {
    this[81] = v4;
    operator delete(v4);
  }
  v5 = this[77];
  if (v5)
  {
    this[78] = v5;
    operator delete(v5);
  }
  ausdk::AUBase::~AUBase((ausdk::AUBase *)this);
}

uint64_t AUEchoGateV3::Initialize(AUEchoGateV3 *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  int32x2_t *v7;
  unsigned int v8;
  char v9;
  double v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  double v14;
  double v15;
  uint64_t result;
  uint64_t Element;
  __int128 v18;
  double v19;
  unsigned int v20;
  unsigned int v21;
  unint64_t v22;
  int32x2_t v23;
  float32x2_t v24;
  uint32x2_t v25;
  uint32x2_t v26;
  BOOL v27;
  int v28;
  float32x2_t v31;
  float v32;
  float v33;
  float v34;
  signed int v35;
  NSObject **v36;
  NSObject *v37;
  _QWORD *v38;
  double v39;
  double v40;
  double v41;
  float v42;
  unsigned int v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float *v48;
  uint64_t v49;
  float v50;
  float v51;
  int v52;
  int v53;
  size_t v54;
  void *v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  std::bad_alloc *exception;
  std::bad_alloc *v63;
  uint64_t v64;
  float v65;
  float __A;
  _OWORD v67[2];
  uint64_t v68;
  uint8_t buf[4];
  const char *v70;
  __int16 v71;
  int v72;
  __int16 v73;
  _QWORD *v74;
  __int16 v75;
  double v76;
  __int16 v77;
  double v78;
  __int16 v79;
  double v80;
  __int16 v81;
  double v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 21);
  if (v2)
    LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  else
    v3 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
  v4 = *((_QWORD *)this + 15);
  if (v4)
    LODWORD(v5) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  else
    v5 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  v6 = 0;
  v7 = (int32x2_t *)((char *)this + 596);
  v8 = 2;
  do
  {
    v9 = v6;
    v10 = *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v8 - 1) + 80);
    if (v10 != *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v8) + 80))
      return 4294956428;
    v8 = 3;
    v6 = 1;
  }
  while ((v9 & 1) == 0);
  if (v5 >= 6)
  {
    v11 = 5;
    do
    {
      v12 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v11 - 1) + 88);
      if (v12 != *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v11) + 88))
        return 4294956428;
    }
    while ((_DWORD)v5 != ++v11);
  }
  if (v3 >= 2)
  {
    v13 = 1;
    do
    {
      v14 = *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), v13 - 1) + 80);
      if (v14 != *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), v13) + 80))
        return 4294956428;
    }
    while ((_DWORD)v3 != ++v13);
  }
  *((_BYTE *)this + 793) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), 0) + 88) == 1718773105;
  v15 = *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), 0) + 80);
  if (v15 != *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), 0) + 80))
    return 4294956428;
  Element = ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), 0);
  v18 = *(_OWORD *)(Element + 96);
  v67[0] = *(_OWORD *)(Element + 80);
  v67[1] = v18;
  v68 = *(_QWORD *)(Element + 112);
  v19 = *(double *)(ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), 0) + 80);
  *((double *)this + 100) = v19;
  v20 = *((_DWORD *)this + 149);
  if (v19 * 0.5 < (double)v20)
    return 4294956445;
  v21 = *((_DWORD *)this + 150);
  result = 4294956445;
  if (v20 - 1 >= v21 && v19 * 0.5 >= (double)v21)
  {
    v22 = *((unsigned int *)this + 84);
    v23 = vdup_n_s32(v22);
    v24 = vcvt_f32_u32((uint32x2_t)vmul_s32(v23, (int32x2_t)__PAIR64__(v21, v20)));
    v25 = vcvt_u32_f32(vrndp_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vadd_f32(v24, v24)), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v19, 0)))));
    v26 = vmin_u32((uint32x2_t)v23, v25);
    if (v26.i32[1])
      v27 = v22 > v25.i32[1];
    else
      v27 = 0;
    v28 = v27;
    *(uint32x2_t *)((char *)this + 604) = v26;
    if ((v22 <= v25.i32[0] || v26.i32[0] == 0) && v28 == 0)
      goto LABEL_65;
    *(_DWORD *)buf = 0;
    std::vector<float>::assign((char **)this + 77, (2 * v22), buf);
    *(_DWORD *)buf = 0;
    std::vector<float>::assign((char **)this + 80, (2 * v22), buf);
    *(_DWORD *)buf = 0;
    std::vector<float>::assign((char **)this + 83, (2 * v22), buf);
    *(_DWORD *)buf = 1065353216;
    std::vector<float>::assign((char **)this + 86, v22, buf);
    if (!*(_QWORD *)v7)
    {
LABEL_65:
      v52 = *((_DWORD *)this + 84);
      *((_DWORD *)this + 193) = v52;
      v53 = v52 + 1;
      *((_DWORD *)this + 194) = v52 + 1;
      v54 = 4 * (v52 + 1);
      v55 = malloc_type_malloc(v54, 0x2C8E6D5CuLL);
      v56 = v55;
      if (v53 && !v55)
      {
        exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
        v63 = std::bad_alloc::bad_alloc(exception);
      }
      bzero(v55, v54);
      *((_QWORD *)this + 98) = v56;
      v57 = *((_QWORD *)this + 67);
      if (v57)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v57 + 8))(v57);
        *((_QWORD *)this + 67) = 0;
      }
      v58 = operator new();
      *(_DWORD *)(v58 + 8) = 0;
      *(_OWORD *)(v58 + 16) = 0u;
      *(_OWORD *)(v58 + 32) = 0u;
      *(_QWORD *)(v58 + 48) = 0;
      *(_QWORD *)v58 = &off_1E69D0B70;
      *(_BYTE *)(v58 + 56) = 0;
      *(_OWORD *)(v58 + 248) = 0u;
      *(_QWORD *)(v58 + 280) = 0;
      *(_DWORD *)(v58 + 292) = 1065353216;
      *(int32x4_t *)(v58 + 740) = vdupq_n_s32(0x3C23D70Au);
      *(_DWORD *)(v58 + 756) = 1008981770;
      *(_DWORD *)(v58 + 812) = 0;
      *(_QWORD *)(v58 + 848) = 0;
      *(_QWORD *)(v58 + 944) = 0;
      *(_QWORD *)(v58 + 768) = 0;
      *(_OWORD *)(v58 + 776) = 0u;
      *(_OWORD *)(v58 + 872) = 0u;
      *(_OWORD *)(v58 + 888) = 0u;
      *(_OWORD *)(v58 + 904) = 0u;
      *(_OWORD *)(v58 + 920) = 0u;
      *(_OWORD *)(v58 + 972) = xmmword_1B664DD34;
      *(_OWORD *)(v58 + 988) = unk_1B664DD44;
      *(_OWORD *)(v58 + 1000) = unk_1B664DD50;
      *(_OWORD *)(v58 + 1016) = xmmword_1B664DD60;
      *(_QWORD *)(v58 + 1032) = 0x3DCCCCCD3ECCCCCDLL;
      *(_QWORD *)(v58 + 1040) = 0x3F8000003DCCCCCDLL;
      *(_DWORD *)(v58 + 1048) = 1052602532;
      *(_OWORD *)(v58 + 1052) = xmmword_1B664DD78;
      *(_OWORD *)(v58 + 1068) = unk_1B664DD88;
      *(_QWORD *)(v58 + 1148) = 0x3B51B7173B83126FLL;
      *(_OWORD *)(v58 + 1116) = xmmword_1B664DDB8;
      *(_OWORD *)(v58 + 1132) = unk_1B664DDC8;
      *(_OWORD *)(v58 + 1084) = xmmword_1B664DD98;
      *(_OWORD *)(v58 + 1100) = unk_1B664DDA8;
      *(_QWORD *)(v58 + 1176) = 0;
      *(_OWORD *)(v58 + 1160) = 0u;
      *(_OWORD *)(v58 + 1288) = 0u;
      *(_OWORD *)(v58 + 1304) = 0u;
      *(_OWORD *)(v58 + 1256) = 0u;
      *(_OWORD *)(v58 + 1272) = 0u;
      *(_OWORD *)(v58 + 1224) = 0u;
      *(_OWORD *)(v58 + 1240) = 0u;
      *(_DWORD *)(v58 + 1332) = 1;
      *(_QWORD *)(v58 + 1336) = 0x3F80000000000000;
      *(_BYTE *)(v58 + 1348) = 0;
      *(_BYTE *)(v58 + 1416) = 0;
      *(_BYTE *)(v58 + 1440) = 0;
      *(_QWORD *)(v58 + 1464) = 0;
      *(_OWORD *)(v58 + 1448) = 0u;
      *(_BYTE *)(v58 + 1493) = 0;
      *(_QWORD *)(v58 + 1496) = 1065353216;
      std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v58 + 1504), "default");
      *(_DWORD *)(v58 + 1528) = 1;
      *(_OWORD *)(v58 + 1576) = xmmword_1B66A0580;
      *(_OWORD *)(v58 + 1592) = xmmword_1B66A0590;
      *(_OWORD *)(v58 + 1608) = xmmword_1B66A05A0;
      *(_OWORD *)(v58 + 1624) = xmmword_1B66A05B0;
      *(_OWORD *)(v58 + 1640) = xmmword_1B66A05C0;
      *(_QWORD *)(v58 + 1656) = 1086324736;
      *(_DWORD *)(v58 + 80) = 1;
      *(_QWORD *)(v58 + 88) = 1;
      *(_QWORD *)(v58 + 96) = 0;
      *(_DWORD *)(v58 + 104) = 1;
      *(_QWORD *)(v58 + 112) = 1;
      *(_QWORD *)(v58 + 120) = 0;
      *(_DWORD *)(v58 + 176) = 1;
      *(_QWORD *)(v58 + 184) = 1;
      *(_QWORD *)(v58 + 192) = 0;
      *(_DWORD *)(v58 + 128) = 1;
      *(_QWORD *)(v58 + 136) = 1;
      *(_QWORD *)(v58 + 144) = 0;
      *(_DWORD *)(v58 + 152) = 1;
      *(_QWORD *)(v58 + 160) = 1;
      *(_QWORD *)(v58 + 168) = 0;
      *(_DWORD *)(v58 + 200) = 1;
      *(_DWORD *)(v58 + 208) = 1;
      *(_QWORD *)(v58 + 64) = 0;
      *(_DWORD *)(v58 + 60) = 0;
      *(_OWORD *)(v58 + 212) = 0u;
      *(_OWORD *)(v58 + 228) = 0u;
      *(_DWORD *)(v58 + 244) = 0;
      *(_QWORD *)(v58 + 280) = 0;
      *(_OWORD *)(v58 + 264) = 0u;
      *(_QWORD *)(v58 + 312) = 1092616192;
      *(_DWORD *)(v58 + 320) = 0;
      *(_OWORD *)(v58 + 648) = 0u;
      *(_OWORD *)(v58 + 664) = 0u;
      *(_DWORD *)(v58 + 680) = 0;
      *(_QWORD *)(v58 + 704) = 0;
      *(_DWORD *)(v58 + 712) = 0;
      *(_OWORD *)(v58 + 688) = 0u;
      *(_DWORD *)(v58 + 732) = 1065353216;
      *(_BYTE *)(v58 + 737) = 1;
      *(_BYTE *)(v58 + 736) = 1;
      *(_DWORD *)(v58 + 484) = 0;
      *(_DWORD *)(v58 + 1184) = 0;
      *(_OWORD *)(v58 + 1188) = xmmword_1B66A05D0;
      *((_QWORD *)this + 67) = v58;
      *((_DWORD *)this + 144) = *((_DWORD *)this + 145);
      AUEchoGateV3::ApplyParameters((uint64_t)this);
      (*(void (**)(_QWORD, _QWORD, _QWORD, _OWORD *, _QWORD))(**((_QWORD **)this + 67) + 64))(*((_QWORD *)this + 67), *((unsigned int *)this + 84), *((unsigned int *)this + 191), v67, *((unsigned __int8 *)this + 793));
      v59 = *((_QWORD *)this + 67);
      if (v59)
      {
        std::string::operator=((std::string *)(v59 + 1504), (const std::string *)((char *)this + 736));
        v59 = *((_QWORD *)this + 67);
        *(_DWORD *)(v59 + 1528) = *((_DWORD *)this + 190);
        *(_DWORD *)(v59 + 1500) = *((_DWORD *)this + 183);
        *(_BYTE *)(v59 + 1493) = *((_BYTE *)this + 769);
      }
      if (!*((_BYTE *)this + 568))
        return 0;
      v60 = *(unsigned __int8 *)(v59 + 1440);
      v61 = *((_QWORD *)this + 70);
      *(_OWORD *)(v59 + 1416) = *((_OWORD *)this + 34);
      *(_QWORD *)(v59 + 1432) = v61;
      if (v60)
        return 0;
      result = 0;
      *(_BYTE *)(v59 + 1440) = 1;
      return result;
    }
    v31 = vcvt_f32_u32((uint32x2_t)vmul_s32(*v7, v23));
    v64 = *((uint64_t *)this + 100);
    *(uint32x2_t *)((char *)this + 604) = vmin_u32((uint32x2_t)v23, vcvt_u32_f32(vrndp_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vadd_f32(v31, v31)), (float64x2_t)vdupq_lane_s64(v64, 0))))));
    v65 = 1.0;
    __A = 1.0;
    v32 = *((float *)this + 180);
    v33 = *((float *)this + 178);
    vDSP_vfill(&__A, *((float **)this + 86), 1, v22);
    if ((float)*((unsigned int *)this + 149) >= (float)*((unsigned int *)this + 150))
      v34 = (float)*((unsigned int *)this + 149);
    else
      v34 = (float)*((unsigned int *)this + 150);
    if (*((_DWORD *)this + 151) <= *((_DWORD *)this + 152))
      v35 = *((_DWORD *)this + 152);
    else
      v35 = *((_DWORD *)this + 151);
    v36 = (NSObject **)egt3Subsystem();
    if (v36)
    {
      v37 = *v36;
      if (!*v36)
      {
LABEL_53:
        v42 = __exp10f(*((float *)this + 179) * -0.05);
        if (v33 >= v32)
        {
          v44 = v42;
          v45 = *(double *)&v64;
          v46 = v45 / (float)((float)v22 + (float)v22);
          do
          {
            v47 = (float)(v32 + v34) / v46;
            v43 = vcvtms_u32_f32(v47);
            v65 = v44 * v65;
            vDSP_vfill(&v65, (float *)(*((_QWORD *)this + 86) + 4 * v35), 1, v43 - v35);
            v34 = floorf(v46 * (float)floorf(v47));
            v33 = v33 - v32;
            v35 = v43;
          }
          while (v33 >= v32);
        }
        else
        {
          v43 = v35;
        }
        vDSP_vfill(&v65, (float *)(*((_QWORD *)this + 86) + 4 * v43), 1, v22 - v43);
        if (*((_DWORD *)this + 150) && (_DWORD)v22)
        {
          v48 = (float *)*((_QWORD *)this + 86);
          v49 = (uint64_t)(*((_QWORD *)this + 87) - (_QWORD)v48) >> 2;
          do
          {
            if (!v49)
              std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
            v50 = *v48;
            v51 = v65;
            if (*v48 != 1.0)
            {
              v51 = 1.0;
              if (v50 != v65)
                v51 = 1.0 - v50;
            }
            *v48++ = v51;
            --v49;
            --v22;
          }
          while (v22);
        }
        goto LABEL_65;
      }
    }
    else
    {
      v37 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
    {
      v38 = (_QWORD *)((char *)this + 736);
      if (*((char *)this + 759) < 0)
        v38 = (_QWORD *)*v38;
      v39 = *((float *)this + 178);
      v40 = *((float *)this + 179);
      v41 = *((float *)this + 180);
      *(_DWORD *)buf = 136316674;
      v70 = "AUEchoGateV3.cpp";
      v71 = 1024;
      v72 = 402;
      v73 = 2080;
      v74 = v38;
      v75 = 2048;
      v76 = v34;
      v77 = 2048;
      v78 = v39;
      v79 = 2048;
      v80 = v40;
      v81 = 2048;
      v82 = v41;
      _os_log_impl(&dword_1B5ED0000, v37, OS_LOG_TYPE_INFO, "%25s:%-5d AUEchoGateV3: Gate [%s], Cutoff = %f, Transition band = %f @ %fdB/%fHz", buf, 0x44u);
    }
    goto LABEL_53;
  }
  return result;
}

void sub_1B610FAF8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  v6 = *v4;
  if (*v4)
  {
    v1[182] = v6;
    operator delete(v6);
  }
  v7 = (void *)v1[162];
  if (v7)
  {
    v1[163] = v7;
    operator delete(v7);
  }
  v8 = (void *)v1[159];
  if (v8)
  {
    v1[160] = v8;
    operator delete(v8);
  }
  v9 = (void *)v1[156];
  if (v9)
  {
    v1[157] = v9;
    operator delete(v9);
  }
  v10 = *v3;
  if (*v3)
  {
    v1[154] = v10;
    operator delete(v10);
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v2);
  *v1 = off_1E69D0B20;
  MEMORY[0x1BCC95CEC](v1, 0x10B3C40485114A4);
  _Unwind_Resume(a1);
}

uint64_t AUEchoGateV3::Cleanup(AUEchoGateV3 *this)
{
  void *v2;
  uint64_t result;

  v2 = (void *)*((_QWORD *)this + 98);
  if (v2)
  {
    free(v2);
    *((_QWORD *)this + 98) = 0;
  }
  result = *((_QWORD *)this + 67);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  *((_QWORD *)this + 67) = 0;
  return result;
}

uint64_t AUEchoGateV3::Reset(AUEchoGateV3 *this)
{
  float *v2;

  v2 = (float *)*((_QWORD *)this + 98);
  if (v2)
    vDSP_vclr(v2, 1, *((unsigned int *)this + 194));
  return 0;
}

uint64_t AUEchoGateV3::GetPropertyInfo(AUEchoGateV3 *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  char v8;
  int v9;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 2199)
  {
    if (a2 <= 2299)
    {
      if (a2 != 2200)
      {
        if (a2 != 2210)
          return result;
        *a6 = 1;
        v9 = 4 * *((_DWORD *)this + 194);
        goto LABEL_18;
      }
    }
    else if (a2 != 2300 && a2 != 2400)
    {
      if (a2 != 3700)
        return result;
LABEL_10:
      *a6 = 0;
      goto LABEL_17;
    }
LABEL_15:
    v8 = 1;
LABEL_16:
    *a6 = v8;
LABEL_17:
    v9 = 4;
LABEL_18:
    result = 0;
    *a5 = v9;
    return result;
  }
  switch(a2)
  {
    case 2117:
      *a6 = 1;
      v9 = 24;
      goto LABEL_18;
    case 2118:
      *a6 = 1;
      v9 = *(_DWORD *)(*((_QWORD *)this + 67) + 1472);
      goto LABEL_18;
    case 2119:
    case 2120:
    case 2121:
    case 2122:
    case 2126:
    case 2127:
    case 2128:
      v8 = *((_BYTE *)this + 17) ^ 1;
      goto LABEL_16;
    case 2123:
    case 2129:
      goto LABEL_15;
    case 2124:
      goto LABEL_10;
    case 2125:
      *a6 = *((_BYTE *)this + 17) ^ 1;
      v9 = 9;
      goto LABEL_18;
    default:
      if (a2 == 21)
        goto LABEL_15;
      break;
  }
  return result;
}

uint64_t AUEchoGateV3::GetProperty(const void **this, int a2, int a3, unsigned int a4, _DWORD *__dst)
{
  uint64_t result;
  int v8;
  __int128 v9;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 2199)
  {
    if (a2 > 2299)
    {
      if (a2 == 2300)
      {
        result = 0;
        v8 = *((unsigned __int8 *)this + 768);
      }
      else
      {
        if (a2 != 3700)
          return result;
        result = 0;
        v8 = *((unsigned __int8 *)this + 376);
      }
    }
    else
    {
      if (a2 != 2200)
      {
        if (a2 == 2210)
        {
          memcpy(__dst, this[98], 4 * (*((_DWORD *)this + 84) + 1));
          return 0;
        }
        return result;
      }
      result = 0;
      v8 = *((_DWORD *)this + 191);
    }
LABEL_22:
    *__dst = v8;
    return result;
  }
  switch(a2)
  {
    case 21:
      v8 = (*((uint64_t (**)(const void **))*this + 72))(this);
      result = 0;
      goto LABEL_22;
    case 2117:
      result = 0;
      if (*((_BYTE *)this + 568))
      {
        v9 = *((_OWORD *)this + 34);
        *((_QWORD *)__dst + 2) = this[70];
        *(_OWORD *)__dst = v9;
      }
      else
      {
        *(_QWORD *)__dst = 0;
        *((_QWORD *)__dst + 1) = 0;
        *((_QWORD *)__dst + 2) = 0;
      }
      break;
    case 2124:
      result = (uint64_t)this[67];
      if (result)
      {
        (*(void (**)(uint64_t, uint64_t, _DWORD *))(*(_QWORD *)result + 40))(result, 7, __dst);
        return 0;
      }
      break;
  }
  return result;
}

uint64_t AUEchoGateV3::SetProperty(AUEchoGateV3 *this, int a2, int a3, unsigned int a4, _DWORD *__src, size_t __n)
{
  uint64_t result;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  size_t v14;
  int v15;
  uint64_t v16;
  const __CFString **v17;
  void **v18;
  __int128 v19;
  uint64_t v20;
  const void *v21;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 2199)
  {
    if (a2 > 2299)
    {
      if (a2 == 2300)
      {
        if ((_DWORD)__n == 4)
        {
          result = 0;
          *((_BYTE *)this + 768) = *__src != 0;
          return result;
        }
      }
      else
      {
        if (a2 != 2400)
          return result;
        if ((_DWORD)__n == 4)
        {
          result = 0;
          *((_BYTE *)this + 769) = *__src != 0;
          return result;
        }
      }
    }
    else if (a2 == 2200)
    {
      if ((_DWORD)__n == 4)
      {
        result = 0;
        *((_DWORD *)this + 191) = *__src;
        return result;
      }
    }
    else
    {
      if (a2 != 2210)
        return result;
      if (__n == 4 * (*((_DWORD *)this + 84) + 1))
      {
        if ((*((_DWORD *)this + 191) - 3) <= 1)
        {
          result = *((_QWORD *)this + 98);
          if (!result)
            return result;
          memcpy((void *)result, __src, __n);
        }
        return 0;
      }
    }
    return 4294956445;
  }
  switch(a2)
  {
    case 2117:
      if ((_DWORD)__n != 24)
        return 4294956445;
      v8 = *((unsigned __int8 *)this + 568);
      v9 = *((_QWORD *)__src + 2);
      *((_OWORD *)this + 34) = *(_OWORD *)__src;
      *((_QWORD *)this + 70) = v9;
      if (v8)
        return 0;
      result = 0;
      *((_BYTE *)this + 568) = 1;
      return result;
    case 2118:
      v12 = *((_QWORD *)this + 67);
      v13 = *(_DWORD *)(v12 + 1472);
      if (v13 >= __n)
        v14 = __n;
      else
        v14 = v13;
      memcpy(*(void **)(v12 + 1448), __src, v14);
      result = 0;
      *(_DWORD *)(*((_QWORD *)this + 67) + 1476) = v14 >> 2;
      return result;
    case 2119:
      if (*((_BYTE *)this + 17))
        goto LABEL_58;
      if (__n < 4)
        return 4294956445;
      result = 0;
      *((_DWORD *)this + 149) = *__src;
      return result;
    case 2120:
      if (*((_BYTE *)this + 17))
        goto LABEL_58;
      if (__n < 4)
        return 4294956445;
      result = 0;
      *((_DWORD *)this + 150) = *__src;
      return result;
    case 2121:
      if (*((_BYTE *)this + 17))
        goto LABEL_58;
      if (__n < 4)
        return 4294956445;
      result = 0;
      *((_DWORD *)this + 181) = *__src;
      return result;
    case 2122:
      if (*((_BYTE *)this + 17))
        goto LABEL_58;
      if (__n < 4)
        return 4294956445;
      result = 0;
      *((_DWORD *)this + 183) = *__src;
      return result;
    case 2123:
      if (__n < 4)
        return 4294956445;
      v15 = *__src;
      *((_DWORD *)this + 182) = *__src;
      v16 = *((_QWORD *)this + 67);
      if (!v16)
        return 0;
      result = 0;
      *(_DWORD *)(v16 + 1496) = v15;
      return result;
    case 2124:
      return result;
    case 2125:
      if ((_DWORD)__n != 8)
        return 4294956445;
      applesauce::CF::StringRef::from_get((applesauce::CF::StringRef *)&v21, *(CFTypeRef *)__src);
      v17 = (const __CFString **)applesauce::CF::StringRef::operator->(&v21);
      applesauce::CF::convert_to<std::string,0>(*v17, (uint64_t)&v19);
      v18 = (void **)((char *)this + 736);
      if (*((char *)this + 759) < 0)
        operator delete(*v18);
      *(_OWORD *)v18 = v19;
      *((_QWORD *)this + 94) = v20;
      applesauce::CF::StringRef::~StringRef(&v21);
      return 0;
    case 2126:
      if (*((_BYTE *)this + 17))
        goto LABEL_58;
      if (__n < 4)
        return 4294956445;
      result = 0;
      *((_DWORD *)this + 178) = *__src;
      return result;
    case 2127:
      if (*((_BYTE *)this + 17))
        goto LABEL_58;
      if (__n < 4)
        return 4294956445;
      result = 0;
      *((_DWORD *)this + 179) = *__src;
      return result;
    case 2128:
      if (*((_BYTE *)this + 17))
        goto LABEL_58;
      if (__n < 4)
        return 4294956445;
      result = 0;
      *((_DWORD *)this + 180) = *__src;
      return result;
    case 2129:
      if (*((_BYTE *)this + 17))
      {
LABEL_58:
        result = 4294956447;
      }
      else
      {
        if (__n < 4)
          return 4294956445;
        result = 0;
        *((_DWORD *)this + 190) = *__src;
      }
      break;
    default:
      if (a2 != 21)
        return result;
      if (__n < 4)
        return 4294956445;
      v10 = *__src;
      v11 = *__src != 0;
      if (v11 != (*(unsigned int (**)(AUEchoGateV3 *))(*(_QWORD *)this + 576))(this))
        (*(void (**)(AUEchoGateV3 *, BOOL))(*(_QWORD *)this + 584))(this, v10 != 0);
      return 0;
  }
  return result;
}

void sub_1B6110170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t AUEchoGateV3::SetParameter(AUEchoGateV3 *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  if (a2 > 0x2A || ((1 << a2) & 0x428000E4819) == 0)
    ++*((_DWORD *)this + 145);
  return 0;
}

uint64_t AUEchoGateV3::CanScheduleParameters(AUEchoGateV3 *this)
{
  return 0;
}

uint64_t AUEchoGateV3::ProcessMultipleBufferLists(AUEchoGateV3 *this, unsigned int *a2, unsigned int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v12;
  vDSP_Length v13;
  const float *mData;
  unint64_t v15;
  uint64_t v16;
  AudioBufferList *v17;
  uint64_t Element;
  BOOL *v19;
  uint64_t v20;
  uint64_t message;
  float *v22;
  caulk::concurrent::message *v23;
  uint64_t v24;
  float v25;
  ausdk::AUElement *v26;
  unsigned int v27;
  int v28;
  ausdk::AUElement *v29;
  float Parameter;
  float v31;
  const AudioBufferList *v32;
  void *v33;
  const AudioBufferList *v34;
  void *v35;
  const AudioBufferList *v36;
  void *v37;
  const AudioBufferList *v38;
  void *v39;
  int v40;
  void *v41;
  const float *v42;
  const float *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  float v47;
  float v48;
  float *v49;
  uint64_t v50;
  void *v52;
  void *v54;
  float *v55;
  float v56;
  _QWORD v57[2];
  AudioStreamBasicDescription v58;
  const float *v59;

  v10 = *((_QWORD *)this + 9);
  if (v10)
  {
    v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
  }
  else
  {
    v12 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v12)
      v11 = 0;
    else
      v11 = *v12;
  }
  v13 = *((unsigned int *)this + 84);
  mData = (const float *)a5[2]->mBuffers[0].mData;
  if (*a7)
  {
    v55 = (float *)(*a7)->mBuffers[0].mData;
  }
  else
  {
    v55 = 0;
    *((_BYTE *)this + 793) = 0;
    *(_BYTE *)(*((_QWORD *)this + 67) + 56) = 0;
  }
  v15 = 0;
  v16 = 0;
  *(_QWORD *)&v58.mBitsPerChannel = mData;
  v59 = &mData[v13];
  do
  {
    LOBYTE(v58.mSampleRate) = 0;
    v17 = (AudioBufferList *)a5[v15];
    Element = ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), v15);
    AudioDSP::Utility::DetectNonFinites(0, v17, (const AudioBufferList *)(Element + 80), &v58, v19);
    if (LOBYTE(v58.mSampleRate))
    {
      if (v15 >= 5)
        std::__throw_out_of_range[abi:ne180100]("bitset set argument out of range");
      v16 |= 1 << v15;
    }
    ++v15;
  }
  while (v15 != 6);
  if ((v16 & 0x1F) != 0)
  {
    v20 = _os_log_pack_size();
    message = caulk::deferred_logger::create_message(*((caulk::deferred_logger **)this + 101), v20 + 88, 16);
    v22 = v55;
    if (message)
    {
      v23 = (caulk::concurrent::message *)message;
      v24 = _os_log_pack_fill();
      *(_DWORD *)v24 = 134217984;
      *(_QWORD *)(v24 + 4) = v16;
      caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(*((_QWORD *)this + 101) + 16), v23);
    }
    (*(void (**)(AUEchoGateV3 *))(*(_QWORD *)this + 576))(this);
    goto LABEL_18;
  }
  if (!(*(unsigned int (**)(AUEchoGateV3 *))(*(_QWORD *)this + 576))(this))
  {
    v28 = *((_DWORD *)this + 145);
    if (v28 != *((_DWORD *)this + 144))
    {
      AUEchoGateV3::ApplyParameters((uint64_t)this);
      *((_DWORD *)this + 144) = v28;
    }
    v29 = v11;
    Parameter = ausdk::AUElement::GetParameter(v11, 0x11u);
    v31 = ausdk::AUElement::GetParameter(v11, 0x13u);
    v32 = a5[4];
    if (v32)
      v33 = v32->mBuffers[0].mData;
    else
      v33 = 0;
    v34 = a5[5];
    if (v34)
      v35 = v34->mBuffers[0].mData;
    else
      v35 = 0;
    if (a4 < 7)
    {
      v37 = 0;
    }
    else
    {
      v36 = a5[6];
      if (v36)
        v37 = v36->mBuffers[0].mData;
      else
        v37 = 0;
      v38 = a5[7];
      if (v38)
      {
        v39 = v38->mBuffers[0].mData;
        goto LABEL_42;
      }
    }
    v39 = 0;
LABEL_42:
    v40 = *((_DWORD *)this + 191);
    v54 = v37;
    v52 = v39;
    if ((v40 - 1) >= 2)
    {
      if (v40)
        goto LABEL_48;
      if (!*((_BYTE *)this + 792))
      {
        vDSP_vclr(*((float **)this + 98), 1, *((unsigned int *)this + 194));
        *((_BYTE *)this + 792) = 1;
      }
    }
    else
    {
      v41 = (*a5)->mBuffers[0].mData;
      if (v41)
      {
        memcpy(*((void **)this + 98), v41, *((unsigned int *)this + 193));
        *(_DWORD *)(*((_QWORD *)this + 98) + 4 * *((unsigned int *)this + 193)) = 0;
LABEL_48:
        *((_BYTE *)this + 792) = 0;
      }
    }
    v42 = (const float *)a5[3]->mBuffers[0].mData;
    v43 = (const float *)a5[1]->mBuffers[0].mData;
    if (!*((_DWORD *)this + 149) && !*((_DWORD *)this + 150))
      goto LABEL_64;
    vDSP_vmul(mData, 1, *((const float **)this + 86), 1, *((float **)this + 77), 1, v13);
    vDSP_vmul(&mData[v13], 1, *((const float **)this + 86), 1, (float *)(*((_QWORD *)this + 77) + 4 * v13), 1, v13);
    v44 = *((_QWORD *)this + 77);
    v45 = (*((_QWORD *)this + 78) - v44) >> 2;
    if (*((_DWORD *)this + 149))
    {
      if (v45 > v13)
      {
        *(_DWORD *)(v44 + 4 * v13) = 0;
        goto LABEL_55;
      }
    }
    else if (v45 > v13)
    {
LABEL_55:
      if (!*((_DWORD *)this + 181))
      {
LABEL_64:
        v58.mChannelsPerFrame = ausdk::AUElement::GetParameter(v29, 4u);
        (*(void (**)(_QWORD, uint64_t, UInt32 *))(**((_QWORD **)this + 67) + 32))(*((_QWORD *)this + 67), 1, &v58.mChannelsPerFrame);
        v58.mBytesPerFrame = ausdk::AUElement::GetParameter(v29, 3u);
        (*(void (**)(_QWORD, uint64_t, UInt32 *))(**((_QWORD **)this + 67) + 32))(*((_QWORD *)this + 67), 6, &v58.mBytesPerFrame);
        v58.mBytesPerPacket = ausdk::AUElement::GetParameter(v29, 0);
        (*(void (**)(_QWORD, uint64_t, UInt32 *))(**((_QWORD **)this + 67) + 32))(*((_QWORD *)this + 67), 4, &v58.mBytesPerPacket);
        v58.mFramesPerPacket = ausdk::AUElement::GetParameter(v29, 0xEu);
        (*(void (**)(_QWORD, uint64_t, UInt32 *))(**((_QWORD **)this + 67) + 32))(*((_QWORD *)this + 67), 9, &v58.mFramesPerPacket);
        *(float *)(*((_QWORD *)this + 67) + 1536) = ausdk::AUElement::GetParameter(v29, 0x23u);
        *(float *)(*((_QWORD *)this + 67) + 1544) = ausdk::AUElement::GetParameter(v29, 0x25u);
        v48 = ausdk::AUElement::GetParameter(v29, 0x12u);
        v49 = (float *)*((_QWORD *)this + 67);
        v49[407] = v48;
        if (*((_BYTE *)this + 590))
        {
          v50 = *((unsigned int *)this + 84);
          *(_QWORD *)&v58.mSampleRate = v42;
          *(_QWORD *)&v58.mFormatID = &v42[v50];
          v57[0] = v43;
          v57[1] = &v43[v50];
          (*(void (**)(float *, _QWORD *, UInt32 *, AudioStreamBasicDescription *, void *, void *, void *, void *, float, float, _QWORD, float *))(*(_QWORD *)v49 + 24))(v49, v57, &v58.mBitsPerChannel, &v58, v33, v35, v54, v52, Parameter, v31, *((_QWORD *)this + 98), v55);
          v49 = (float *)*((_QWORD *)this + 67);
        }
        (*(void (**)(float *, uint64_t, AudioStreamBasicDescription *))(*(_QWORD *)v49 + 40))(v49, 5, &v58);
        ausdk::AUElement::SetParameter(v29, 1u, *(float *)&v58.mSampleRate, 0);
        (*(void (**)(_QWORD, uint64_t, UInt32 *))(**((_QWORD **)this + 67) + 40))(*((_QWORD *)this + 67), 6, &v58.mBytesPerFrame);
        ausdk::AUElement::SetParameter(v29, 2u, *(float *)&v58.mBytesPerFrame, 0);
        LODWORD(v57[0]) = 1065353216;
        (*(void (**)(_QWORD, uint64_t, _QWORD *))(**((_QWORD **)this + 67) + 40))(*((_QWORD *)this + 67), 7, v57);
        ausdk::AUElement::SetParameter(v29, 0xBu, *(float *)v57, 0);
        v56 = 0.0;
        (*(void (**)(_QWORD, uint64_t, float *))(**((_QWORD **)this + 67) + 40))(*((_QWORD *)this + 67), 18, &v56);
        v25 = v56;
        v26 = v29;
        v27 = 42;
        goto LABEL_67;
      }
      vDSP_vmul(v42, 1, *((const float **)this + 86), 1, *((float **)this + 80), 1, v13);
      vDSP_vmul(&v42[v13], 1, *((const float **)this + 86), 1, (float *)(*((_QWORD *)this + 80) + 4 * v13), 1, v13);
      vDSP_vmul(v43, 1, *((const float **)this + 86), 1, *((float **)this + 83), 1, v13);
      vDSP_vmul(&v43[v13], 1, *((const float **)this + 86), 1, (float *)(*((_QWORD *)this + 83) + 4 * v13), 1, v13);
      v42 = (const float *)*((_QWORD *)this + 80);
      v46 = (uint64_t)(*((_QWORD *)this + 81) - (_QWORD)v42) >> 2;
      if (*((_DWORD *)this + 149))
      {
        if (v46 > v13)
        {
          v42[v13] = 0.0;
          v43 = (const float *)*((_QWORD *)this + 83);
          if (v13 < (uint64_t)(*((_QWORD *)this + 84) - (_QWORD)v43) >> 2)
          {
            v47 = 0.0;
LABEL_63:
            v43[v13] = v47;
            goto LABEL_64;
          }
          goto LABEL_71;
        }
      }
      else if (v46 > v13)
      {
        v42[v13] = *(const float *)(v44 + 4 * v13);
        v43 = (const float *)*((_QWORD *)this + 83);
        if (v13 < (uint64_t)(*((_QWORD *)this + 84) - (_QWORD)v43) >> 2)
        {
          v47 = *(float *)(v44 + 4 * v13);
          goto LABEL_63;
        }
LABEL_71:
        std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
      }
      std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
    }
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
  v22 = v55;
  if (*((_BYTE *)this + 768))
  {
LABEL_18:
    if (v22)
      vDSP_vclr(v22, 1, (*((_DWORD *)this + 193) << *((_BYTE *)this + 793)));
    ausdk::AUElement::SetParameter(v11, 2u, 0.0, 0);
    ausdk::AUElement::SetParameter(v11, 0xBu, 0.0, 0);
    v25 = 0.0;
    v26 = v11;
    v27 = 1;
    goto LABEL_67;
  }
  if (*((_BYTE *)this + 590))
    (*(void (**)(_QWORD, UInt32 *, float *))(**((_QWORD **)this + 67) + 72))(*((_QWORD *)this + 67), &v58.mBitsPerChannel, v55);
  ausdk::AUElement::SetParameter(v11, 0xBu, 1.0, 0);
  v25 = ausdk::AUElement::GetParameter(v11, 3u);
  v26 = v11;
  v27 = 2;
LABEL_67:
  ausdk::AUElement::SetParameter(v26, v27, v25, 0);
  return 0;
}

uint64_t AUEchoGateV3::Render(AUEchoGateV3 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  uint64_t Element;
  uint64_t v10;
  ausdk::AUInputElement *v11;
  uint64_t result;
  AudioBufferList *BufferList;

  v8 = (AUEchoGateV3 *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 80), 0);
  v10 = ausdk::AUScope::SafeGetElement((AUEchoGateV3 *)((char *)this + 128), 0);
  if (!ausdk::AUBase::HasInput(this, 0))
    return 4294956420;
  v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  result = ausdk::AUInputElement::PullInput(v11, a2, a3, 0, a4);
  if (!(_DWORD)result)
  {
    BufferList = (AudioBufferList *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    ausdk::AUBufferList::CopyBufferContentsTo((_QWORD *)(Element + 144), BufferList);
    return 0;
  }
  return result;
}

BOOL AUEchoGateV3::BusCountWritable(AUEchoGateV3 *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AUEchoGateV3::GetParameterInfo(AUEchoGateV3 *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v6;
  AudioUnitParameterUnit v7;
  AudioUnitParameterValue v8;
  AudioUnitParameterValue v9;
  AudioUnitParameterValue v10;
  int v11;

  buffer->flags = 0x40000000;
  buffer->unitName = 0;
  result = 4294956418;
  if (!a2 && a3 <= 0x2E)
  {
    v6 = off_1E69C65C8[a3];
    v7 = dword_1B662F7FC[a3];
    v8 = flt_1B662F8B8[a3];
    v9 = flt_1B662F974[a3];
    v10 = flt_1B662FA30[a3];
    v11 = dword_1B662FAEC[a3];
    buffer->cfNameString = v6;
    buffer->flags = 1207959552;
    CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
    result = 0;
    buffer->unit = v7;
    buffer->minValue = v8;
    buffer->maxValue = v9;
    buffer->defaultValue = v10;
    buffer->flags |= v11;
  }
  return result;
}

uint64_t AUEchoGateV3::GetPresets(AUEchoGateV3 *this, const __CFArray **a2)
{
  __CFArray *Mutable;

  if (a2)
  {
    Mutable = CFArrayCreateMutable(0, 1, 0);
    CFArrayAppendValue(Mutable, &sAUEchoGateV3Presets);
    *a2 = Mutable;
  }
  return 0;
}

uint64_t AUEchoGateV3::NewFactoryPresetSet(AUEchoGateV3 *this, const AUPreset *a2)
{
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  uint64_t v7;
  float v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  float v14[4];

  if (a2->presetNumber)
    return 4294956445;
  v4 = *((_QWORD *)this + 9);
  if (v4)
  {
    v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  }
  else
  {
    v6 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v6)
      v5 = 0;
    else
      v5 = *v6;
  }
  v9 = xmmword_1B66A0580;
  v10 = xmmword_1B66A0590;
  v11 = xmmword_1B66A05A0;
  v12 = xmmword_1B66A05B0;
  v13 = xmmword_1B66A05C0;
  *(_QWORD *)v14 = 1086324736;
  v7 = *((_QWORD *)this + 67);
  if (v7)
  {
    (*(void (**)(uint64_t, uint64_t, __int128 *))(*(_QWORD *)v7 + 32))(v7, 8, &v9);
    v8 = *(float *)&v9;
  }
  else
  {
    v8 = -90.0;
  }
  *((_DWORD *)this + 146) = 0;
  ausdk::AUElement::SetParameter(v5, 6u, v8, 0);
  ausdk::AUElement::SetParameter(v5, 7u, *((float *)&v10 + 3), 0);
  ausdk::AUElement::SetParameter(v5, 8u, *(float *)&v11, 0);
  ausdk::AUElement::SetParameter(v5, 9u, *((float *)&v9 + 1), 0);
  ausdk::AUElement::SetParameter(v5, 0xAu, *((float *)&v9 + 2), 0);
  ausdk::AUElement::SetParameter(v5, 0xCu, *((float *)&v9 + 3), 0);
  ausdk::AUElement::SetParameter(v5, 0xDu, *((float *)&v11 + 1), 0);
  ausdk::AUElement::SetParameter(v5, 0xFu, *((float *)&v11 + 3), 0);
  ausdk::AUElement::SetParameter(v5, 0x10u, *(float *)&v12, 0);
  ausdk::AUElement::SetParameter(v5, 0x12u, *((float *)&v12 + 1), 0);
  ausdk::AUElement::SetParameter(v5, 0x14u, *((float *)&v12 + 2), 0);
  ausdk::AUElement::SetParameter(v5, 0x15u, *((float *)&v12 + 3), 0);
  ausdk::AUElement::SetParameter(v5, 0x16u, *(float *)&v13, 0);
  ausdk::AUElement::SetParameter(v5, 0x17u, *((float *)&v13 + 1), 0);
  ausdk::AUElement::SetParameter(v5, 0x18u, *((float *)&v13 + 2), 0);
  ausdk::AUElement::SetParameter(v5, 0x19u, *((float *)&v13 + 3), 0);
  ausdk::AUElement::SetParameter(v5, 0x1Au, v14[0], 0);
  ausdk::AUElement::SetParameter(v5, 5u, v14[1], 0);
  ausdk::AUElement::SetParameter(v5, 0x1Eu, *(float *)&v10, 0);
  ausdk::AUElement::SetParameter(v5, 0x1Fu, *((float *)&v10 + 1), 0);
  ausdk::AUElement::SetParameter(v5, 0x20u, *((float *)&v10 + 2), 0);
  ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, &sAUEchoGateV3Presets);
  return 0;
}

double AUEchoGateV3::GetLatency(AUEchoGateV3 *this)
{
  return 0.0;
}

double AUEchoGateV3::GetTailTime(AUEchoGateV3 *this)
{
  return 0.0;
}

uint64_t AUEchoGateV3::SupportsTail(AUEchoGateV3 *this)
{
  return 1;
}

BOOL AUEchoGateV3::StreamFormatWritable(AUEchoGateV3 *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUEchoGateV3::SupportedNumChannels(AUEchoGateV3 *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUEchoGateV3::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

uint64_t AUEchoGateV3::ValidFormat(AUEchoGateV3 *this, const AudioStreamBasicDescription *a2, int a3, AudioStreamBasicDescription *a4)
{
  int v6;
  uint64_t result;
  AudioFormatID mFormatID;
  UInt32 v9;
  UInt32 v10;
  _BOOL4 v11;
  UInt32 mChannelsPerFrame;
  UInt32 mBytesPerPacket;
  UInt32 mBytesPerFrame;
  UInt32 mBitsPerChannel;
  int v16;
  AudioFormatFlags mFormatFlags;
  int v18;
  _BOOL4 v19;
  _BOOL4 v20;
  BOOL v21;
  _BOOL4 v22;
  int v23;

  v6 = (int)a2;
  result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if ((_DWORD)result)
    result = (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
  if (v6 == 1)
  {
    if ((a3 - 1) <= 2 && result != 1 && a4->mFormatID == 1718773105)
    {
      v11 = 0;
      mChannelsPerFrame = a4->mChannelsPerFrame;
      if (a4->mFramesPerPacket == 1
        && (mBytesPerPacket = a4->mBytesPerPacket, mBytesPerFrame = a4->mBytesPerFrame,
                                                   mBytesPerFrame == mBytesPerPacket)
        && (mBitsPerChannel = a4->mBitsPerChannel, mBitsPerChannel >> 3 <= mBytesPerFrame))
      {
        v16 = 0;
        if (mChannelsPerFrame)
        {
          mFormatFlags = a4->mFormatFlags;
          if ((mFormatFlags & 0x20) != 0
            || (v21 = mBytesPerPacket == mBytesPerPacket / mChannelsPerFrame * mChannelsPerFrame,
                mBytesPerPacket /= mChannelsPerFrame,
                v21))
          {
            v18 = 8 * mBytesPerPacket;
            v19 = mBytesPerPacket == 8 && (a4->mFormatFlags & 0x1F84) == 0;
            if ((mFormatFlags & 1) != 0)
            {
              v20 = (a4->mFormatFlags & 0x1F84) == 0;
            }
            else
            {
              v19 = 0;
              v20 = 1;
            }
            v21 = v18 == mBitsPerChannel;
            v22 = v18 == mBitsPerChannel && v19;
            v23 = !v21 || v20;
            v11 = (mFormatFlags & 2) == 0 && v22;
            if ((a4->mFormatFlags & 2) != 0)
              v16 = 1;
            else
              v16 = v23;
          }
          else
          {
            v11 = 0;
            v16 = 0;
          }
        }
      }
      else
      {
        v16 = 0;
      }
      LODWORD(result) = v11 & v16;
    }
    else
    {
      mChannelsPerFrame = a4->mChannelsPerFrame;
    }
    if (mChannelsPerFrame == 1)
      return result;
    else
      return 0;
  }
  else if (v6 == 2)
  {
    mFormatID = a4->mFormatID;
    v10 = a4->mBytesPerFrame;
    v9 = a4->mChannelsPerFrame;
    return v10 == 8 && mFormatID == 1718773105 && v9 == 1 || v10 == 4 && mFormatID == 1819304813 && v9 == 1;
  }
  return result;
}

uint64_t AUEchoGateV3::ChangeStreamFormat(AUEchoGateV3 *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  unsigned int v6;
  int v7;
  uint64_t result;

  v6 = a3;
  v7 = a2;
  ausdk::AUBase::ChangeStreamFormat(this, a2, a3, a4, a5);
  result = 0;
  if (v7 == 1 && v6 - 1 <= 2)
  {
    if (a5->mFormatID == 1718773105)
      result = 0;
    else
      result = 4294967246;
    *((_BYTE *)this + v6 + 588) = a5->mFormatID == 1718773105;
  }
  return result;
}

uint64_t AUEchoGateV3::ShouldBypassEffect(AUEchoGateV3 *this)
{
  return *((unsigned __int8 *)this + 528);
}

uint64_t AUEchoGateV3::SetBypassEffect(uint64_t this, char a2)
{
  *(_BYTE *)(this + 528) = a2;
  return this;
}

_QWORD *ausdk::AUBufferList::CopyBufferContentsTo(_QWORD *this, AudioBufferList *a2)
{
  UInt32 mNumberBuffers;
  UInt32 v4;
  uint64_t v5;
  uint64_t v6;
  void **p_mData;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  ausdk::AUException *exception;
  _DWORD v12[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)this)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v12[0] = 67109120;
      v12[1] = -1;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)v12, 8u);
    }
    exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(exception, -1);
  }
  mNumberBuffers = a2->mNumberBuffers;
  if (a2->mNumberBuffers)
  {
    v4 = 0;
    v5 = this[1];
    v6 = v5 + 56;
    p_mData = &a2->mBuffers[0].mData;
    do
    {
      if (v4 < *(_DWORD *)(v5 + 48))
        v8 = 0;
      else
        v8 = -1;
      v9 = v6 + 16 * v8;
      this = *p_mData;
      v10 = *(void **)(v9 + 8);
      if (*p_mData != v10)
      {
        this = memmove(this, v10, *(unsigned int *)(v9 + 4));
        mNumberBuffers = a2->mNumberBuffers;
      }
      *((_DWORD *)p_mData - 1) = *(_DWORD *)(v9 + 4);
      ++v4;
      v6 = v9 + 16;
      p_mData += 2;
    }
    while (v4 < mNumberBuffers);
  }
  return this;
}

void sub_1B6111168(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t AUEchoGateV3::ApplyParameters(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  float Parameter;
  float v6;
  float v7;
  float *v8;
  float v9;
  float *v10;
  _DWORD v11[22];

  if (*(_QWORD *)(this + 536))
  {
    v1 = this;
    v2 = *(_QWORD *)(this + 72);
    if (v2)
    {
      v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
    }
    else
    {
      v4 = *(ausdk::AUElement ***)(v1 + 48);
      if (*(ausdk::AUElement ***)(v1 + 56) == v4)
        v3 = 0;
      else
        v3 = *v4;
    }
    v11[10] = 0;
    v11[0] = ausdk::AUElement::GetParameter(v3, 6u);
    v11[7] = ausdk::AUElement::GetParameter(v3, 7u);
    v11[8] = ausdk::AUElement::GetParameter(v3, 8u);
    v11[1] = ausdk::AUElement::GetParameter(v3, 9u);
    v11[2] = ausdk::AUElement::GetParameter(v3, 0xAu);
    v11[3] = ausdk::AUElement::GetParameter(v3, 0xCu);
    v11[4] = ausdk::AUElement::GetParameter(v3, 0x1Eu);
    v11[5] = ausdk::AUElement::GetParameter(v3, 0x1Fu);
    v11[6] = ausdk::AUElement::GetParameter(v3, 0x20u);
    v11[9] = ausdk::AUElement::GetParameter(v3, 0xDu);
    v11[11] = ausdk::AUElement::GetParameter(v3, 0xFu);
    v11[12] = ausdk::AUElement::GetParameter(v3, 0x10u);
    v11[13] = ausdk::AUElement::GetParameter(v3, 0x12u);
    v11[14] = ausdk::AUElement::GetParameter(v3, 0x14u);
    v11[15] = ausdk::AUElement::GetParameter(v3, 0x15u);
    v11[16] = ausdk::AUElement::GetParameter(v3, 0x16u);
    v11[17] = ausdk::AUElement::GetParameter(v3, 0x17u);
    v11[18] = ausdk::AUElement::GetParameter(v3, 0x18u);
    v11[19] = ausdk::AUElement::GetParameter(v3, 0x19u);
    v11[20] = ausdk::AUElement::GetParameter(v3, 0x1Au);
    v11[21] = ausdk::AUElement::GetParameter(v3, 5u);
    (*(void (**)(_QWORD, uint64_t, _DWORD *))(**(_QWORD **)(v1 + 536) + 32))(*(_QWORD *)(v1 + 536), 8, v11);
    *(_BYTE *)(*(_QWORD *)(v1 + 536) + 1492) = ausdk::AUElement::GetParameter(v3, 0x1Cu) != 0.0;
    *(float *)(*(_QWORD *)(v1 + 536) + 1480) = ausdk::AUElement::GetParameter(v3, 0x21u);
    *(float *)(*(_QWORD *)(v1 + 536) + 1484) = ausdk::AUElement::GetParameter(v3, 0x22u);
    *(float *)(*(_QWORD *)(v1 + 536) + 1488) = ausdk::AUElement::GetParameter(v3, 0x1Bu);
    *(_DWORD *)(*(_QWORD *)(v1 + 536) + 1532) = ausdk::AUElement::GetParameter(v3, 0x24u);
    Parameter = ausdk::AUElement::GetParameter(v3, 0x26u);
    *(float *)(*(_QWORD *)(v1 + 536) + 1540) = __exp10f(Parameter * 0.05);
    v6 = ausdk::AUElement::GetParameter(v3, 0x27u);
    *(float *)(*(_QWORD *)(v1 + 536) + 1548) = __exp10f(v6 * -0.05);
    *(float *)(*(_QWORD *)(v1 + 536) + 1560) = ausdk::AUElement::GetParameter(v3, 0x2Bu);
    *(float *)(*(_QWORD *)(v1 + 536) + 1564) = ausdk::AUElement::GetParameter(v3, 0x2Cu);
    *(float *)(*(_QWORD *)(v1 + 536) + 1568) = ausdk::AUElement::GetParameter(v3, 0x2Du);
    *(float *)(*(_QWORD *)(v1 + 536) + 1572) = ausdk::AUElement::GetParameter(v3, 0x2Eu);
    v7 = ausdk::AUElement::GetParameter(v3, 0x28u);
    v8 = *(float **)(v1 + 536);
    v8[388] = v7;
    (*(void (**)(float *, uint64_t, float *))(*(_QWORD *)v8 + 32))(v8, 16, v8 + 388);
    v9 = ausdk::AUElement::GetParameter(v3, 0x29u);
    v10 = *(float **)(v1 + 536);
    v10[389] = v9;
    return (*(uint64_t (**)(float *, uint64_t, float *))(*(_QWORD *)v10 + 32))(v10, 17, v10 + 389);
  }
  return this;
}

applesauce::CF::StringRef *applesauce::CF::StringRef::from_get(applesauce::CF::StringRef *this, CFTypeRef cf)
{
  applesauce::CF::StringRef *v2;

  v2 = this;
  if (cf)
  {
    CFRetain(cf);
    return applesauce::CF::StringRef::StringRef(v2, cf);
  }
  else
  {
    *(_QWORD *)this = 0;
  }
  return this;
}

uint64_t egt3Subsystem(void)
{
  unint64_t v0;
  char v2;
  char **v3;
  char *v4;

  v0 = atomic_load(&egt3Subsystem(void)::onceflag);
  if (v0 != -1)
  {
    v4 = &v2;
    v3 = &v4;
    std::__call_once(&egt3Subsystem(void)::onceflag, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<egt3Subsystem(void)::$_0 &&>>);
  }
  return egt3Subsystem(void)::scope;
}

os_log_t std::__call_once_proxy[abi:ne180100]<std::tuple<egt3Subsystem(void)::$_0 &&>>()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "egt3");
  *v0 = result;
  egt3Subsystem(void)::scope = (uint64_t)v0;
  return result;
}

uint64_t VoiceProcessorV3::RunUplinkEchoDSP(void **this, AudioTimeStamp *a2)
{
  VoiceProcessorV3 *v3;
  size_t v4;
  int v5;
  uint64_t v6;
  const AudioBufferList *v7;
  const AudioBufferList *v8;
  unsigned int v9;
  unsigned int *v10;
  void *v11;
  const void **v12;
  _QWORD *v13;
  NSObject *v14;
  int v15;
  int *v16;
  OpaqueAudioComponentInstance *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  UInt32 v21;
  uint64_t v22;
  AudioBufferList *v23;
  _DWORD *v24;
  unint64_t v25;
  uint64_t v26;
  AudioBufferList *v27;
  uint64_t v28;
  AudioBufferList *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int *v39;
  void *v40;
  const void **v41;
  NSObject *v42;
  NSObject *v43;
  int v44;
  int *v45;
  void *Parameter;
  BOOL *v47;
  int v48;
  uint64_t v49;
  float v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  float *v54;
  VPTimeFreqConverter *v55;
  uint64_t v56;
  float *v57;
  VPTimeFreqConverter *v58;
  float *v59;
  VPTimeFreqConverter *v60;
  uint64_t v61;
  float *v62;
  VPTimeFreqConverter *v63;
  float *v64;
  VPTimeFreqConverter *v65;
  uint64_t v66;
  OpaqueAudioComponentInstance *v67;
  OpaqueAudioComponentInstance *v68;
  float v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int v72;
  uint64_t v73;
  int v74;
  AudioUnitParameterValue v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  _BOOL4 v79;
  _BOOL4 v80;
  char v81;
  uint64_t v82;
  OpaqueAudioComponentInstance *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  const AudioBufferList *v87;
  OpaqueAudioComponentInstance *v88;
  uint64_t v89;
  OpaqueAudioComponentInstance *v90;
  uint64_t v91;
  uint64_t v92;
  OpaqueAudioComponentInstance *v93;
  AudioUnitParameterID v94;
  OpaqueAudioComponentInstance *v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  OpaqueAudioComponentInstance *v99;
  uint64_t v100;
  uint64_t v101;
  AudioBufferList **v102;
  uint64_t v103;
  uint64_t v104;
  const AudioBufferList *v105;
  float *v107;
  const float *v108;
  float *v109;
  unsigned int v111;
  OpaqueAudioComponentInstance *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unsigned int v116;
  AudioUnitParameterValue v117;
  unsigned int v118;
  char v119;
  uint64_t v120;
  OpaqueAudioComponentInstance *v121;
  AudioUnitParameterID v122;
  OpaqueAudioComponentInstance *v123;
  unsigned int v124;
  OpaqueAudioComponentInstance *v125;
  uint64_t v126;
  OpaqueAudioComponentInstance *v127;
  OpaqueAudioComponentInstance *v128;
  UInt32 mNumberBuffers;
  OpaqueAudioComponentInstance *v130;
  uint64_t v132;
  AudioUnitParameterValue v133;
  AudioUnitParameterValue v134;
  char v135;
  UInt32 ioDataSize;
  DSPSplitComplex v137;
  AudioBufferList ioData;
  AudioBufferList ioActionFlags;
  AudioUnitRenderActionFlags v140;
  AudioUnitParameterValue outValue;
  AudioBufferList *p_ioActionFlags;
  uint64_t v143;
  uint64_t v144;
  _BYTE buf[24];
  uint64_t v146;
  __int128 v147;
  AudioBufferList *ioOutputBufferLists;
  __int128 v149;
  uint64_t v150;

  v3 = (VoiceProcessorV3 *)this;
  v150 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)this[135];
  if ((_DWORD)v4)
    bzero(this[176], v4);
  if (*((_BYTE *)v3 + 1404))
    VoiceProcessorV2::PostSRCMicClipDetection(v3);
  if (!*((_BYTE *)v3 + 2083))
    VoiceProcessorV2::GetAbsoluteChIndexForEpmicAndApplyPreDigitalGain(v3);
  v5 = *((unsigned __int8 *)v3 + 15897);
  if (*((_BYTE *)v3 + 15897)
    && (VoiceProcessorV2::InjectionFilesReadSignal(v3, 7, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 134)),
        v5 = *((unsigned __int8 *)v3 + 15897),
        *((_BYTE *)v3 + 15897))
    && (VoiceProcessorV2::InjectionFilesReadSignal(v3, 8, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 135)),
        v5 = *((unsigned __int8 *)v3 + 15897),
        *((_BYTE *)v3 + 15897))
    && *((_BYTE *)v3 + 15896)
    || *((_BYTE *)v3 + 15899))
  {
    bzero(*(void **)(*((_QWORD *)v3 + 134) + 16), *(unsigned int *)(*((_QWORD *)v3 + 134) + 12));
    v5 = *((unsigned __int8 *)v3 + 15897);
  }
  v6 = *((unsigned int *)v3 + 127);
  if (v5 || *((_BYTE *)v3 + 15898))
  {
    this = (void **)VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 4u, v6, *((const AudioBufferList **)v3 + 134), a2);
    v6 = *((unsigned int *)v3 + 127);
    v7 = (const AudioBufferList *)*((_QWORD *)v3 + 135);
    if (*((_BYTE *)v3 + 15897))
      goto LABEL_19;
  }
  else
  {
    v7 = (const AudioBufferList *)*((_QWORD *)v3 + 135);
  }
  if (!*((_BYTE *)v3 + 15898))
  {
    v8 = (const AudioBufferList *)*((_QWORD *)v3 + 177);
    goto LABEL_22;
  }
LABEL_19:
  this = (void **)VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 5u, v6, v7, a2);
  v6 = *((unsigned int *)v3 + 127);
  v8 = (const AudioBufferList *)*((_QWORD *)v3 + 177);
  if (*((_BYTE *)v3 + 15897))
  {
LABEL_23:
    this = (void **)VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Au, v6, v8, a2);
    goto LABEL_24;
  }
LABEL_22:
  if (*((_BYTE *)v3 + 15898))
    goto LABEL_23;
LABEL_24:
  outValue = 0.0;
  if (!*((_BYTE *)v3 + 2083)
    && !*((_BYTE *)v3 + 2085)
    && !*((_BYTE *)v3 + 472)
    && (*((_QWORD *)v3 + 582) || (*((_BYTE *)v3 + 4664) & 0x7F) != 0))
  {
    v140 = 0;
    ioOutputBufferLists = (AudioBufferList *)1;
    v149 = 0uLL;
    v149 = *(_OWORD *)(*((_QWORD *)v3 + 134) + 8);
    MEMORY[0x1E0C80A78](this);
    v23 = (AudioBufferList *)((char *)&v133 - ((v22 + 15) & 0x3FFFFFFFF0));
    v24 = (_DWORD *)*((_QWORD *)v3 + 135);
    if (*v24)
    {
      v25 = 0;
      v26 = 2;
      v27 = v23;
      do
      {
        *(_QWORD *)&v27->mNumberBuffers = 0;
        *(_QWORD *)&v27->mBuffers[0].mNumberChannels = 0;
        v27->mBuffers[0].mData = 0;
        v27->mNumberBuffers = v21;
        v27->mBuffers[0] = *(AudioBuffer *)&v24[v26];
        ++v25;
        v26 += 4;
        ++v27;
      }
      while (v25 < *v24);
    }
    v28 = *((_QWORD *)v3 + 582);
    if ((v28 & 2) != 0 && (*((_BYTE *)v3 + 4672) & 2) != 0)
    {
      v20 = *((_QWORD *)v3 + 348);
      if (v20)
      {
        v140 = 512;
        AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), v23);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Bu, *((unsigned int *)v3 + 127), v23, a2);
        v20 = (uint64_t)CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 138), v23);
        v28 = *((_QWORD *)v3 + 582);
      }
    }
    if ((v28 & 4) != 0 && (*((_BYTE *)v3 + 4672) & 4) != 0)
    {
      v20 = *((_QWORD *)v3 + 349);
      if (v20)
      {
        v140 = 512;
        AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), v23 + 1);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Cu, *((unsigned int *)v3 + 127), v23 + 1, a2);
        v20 = (uint64_t)CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 139), v23 + 1);
        v28 = *((_QWORD *)v3 + 582);
      }
    }
    if ((v28 & 8) != 0 && (*((_BYTE *)v3 + 4672) & 8) != 0)
    {
      v20 = *((_QWORD *)v3 + 350);
      if (v20)
      {
        v140 = 512;
        v29 = v23 + 2;
        AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), v29);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Du, *((unsigned int *)v3 + 127), v29, a2);
        v20 = (uint64_t)CADeprecated::CABufferList::CopyDataFrom(*((void **)v3 + 140), v29);
      }
    }
    *(_QWORD *)&ioActionFlags.mBuffers[0].mNumberChannels = 0;
    ioActionFlags.mBuffers[0].mData = 0;
    ioData.mBuffers[0].mData = 0;
    *(_QWORD *)&ioActionFlags.mNumberBuffers = 1;
    *(_QWORD *)&ioData.mNumberBuffers = 1;
    *(_QWORD *)&ioData.mBuffers[0].mNumberChannels = 0;
    v30 = *((_QWORD *)v3 + 135);
    if (*(_DWORD *)v30 < 3u)
    {
      ioActionFlags.mBuffers[0] = *(AudioBuffer *)(v30 + 8);
      if (*(_DWORD *)v30 < 2u)
      {
        v32 = 0;
        v31 = 0;
      }
      else
      {
        v31 = 0;
        ioData.mBuffers[0] = *(AudioBuffer *)(v30 + 24);
        v32 = 1;
      }
    }
    else
    {
      ioActionFlags.mBuffers[0] = *(AudioBuffer *)(v30 + 24);
      ioData.mBuffers[0] = *(AudioBuffer *)(v30 + 40);
      v31 = 1;
      v32 = 2;
    }
    v33 = *((_QWORD *)v3 + 582);
    if ((v33 & 0x20) != 0 && (*((_BYTE *)v3 + 4672) & 0x20) != 0)
    {
      v20 = *((_QWORD *)v3 + 352);
      if (v20)
      {
        v140 = 512;
        *(_QWORD *)buf = &ioActionFlags;
        p_ioActionFlags = &ioActionFlags;
        v20 = AudioUnitProcessMultiple((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)buf, 1u, &p_ioActionFlags);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          v20 = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x72u, *((unsigned int *)v3 + 127), &ioActionFlags, a2);
        v33 = *((_QWORD *)v3 + 582);
      }
    }
    if ((v33 & 0x40) != 0 && (*((_BYTE *)v3 + 4672) & 0x40) != 0)
    {
      v20 = *((_QWORD *)v3 + 353);
      if (v20)
      {
        v140 = 512;
        v20 = AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), &ioActionFlags);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          v20 = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 6u, *((unsigned int *)v3 + 127), &ioActionFlags, a2);
      }
    }
    if ((*((_BYTE *)v3 + 4656) & 0x80) != 0 && (*((_BYTE *)v3 + 4672) & 0x80) != 0)
    {
      v20 = *((_QWORD *)v3 + 354);
      if (v20)
      {
        v140 = 512;
        v20 = AudioUnitProcess((AudioUnit)v20, &v140, a2, *((_DWORD *)v3 + 127), &ioData);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          v20 = VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 7u, *((unsigned int *)v3 + 127), &ioData, a2);
      }
    }
    if ((*((_BYTE *)v3 + 4657) & 0x10) == 0 || (*((_BYTE *)v3 + 4673) & 0x10) == 0 || !*((_QWORD *)v3 + 359))
    {
      v38 = 0;
      while (((*((_DWORD *)v3 + 116) >> v38) & 1) == 0)
      {
        if (++v38 == 32)
        {
          v38 = 33;
          break;
        }
      }
      v39 = (unsigned int *)*((_QWORD *)v3 + 135);
      if (v38 >= *v39)
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v42 = CALog::LogObjIfEnabled(1, VPLogScope(void)::scope);
        if (v42)
        {
          v43 = v42;
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            v44 = **((_DWORD **)v3 + 135);
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = "vpProcessUplink_v3.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 255;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v38;
            LOWORD(v146) = 1024;
            *(_DWORD *)((char *)&v146 + 2) = v44;
            _os_log_impl(&dword_1B5ED0000, v43, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", buf, 0x1Eu);
          }
        }
        v45 = (int *)*((_QWORD *)v3 + 1570);
        if (v45 && (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898)))
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          CALegacyLog::log(v45, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v3/vpProcessUplink_v3.cpp", 255, "RunUplinkEchoDSP", "ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", v38, **((_DWORD **)v3 + 135));
        }
        v40 = *(void **)(*((_QWORD *)v3 + 136) + 16);
        v41 = (const void **)*((_QWORD *)v3 + 135);
      }
      else
      {
        v40 = *(void **)(*((_QWORD *)v3 + 136) + 16);
        v41 = (const void **)&v39[4 * v38];
      }
      Parameter = memcpy(v40, v41[2], *((unsigned int *)v41 + 3));
      v48 = 0;
LABEL_138:
      if ((*((_BYTE *)v3 + 4657) & 0x20) == 0 || (*((_BYTE *)v3 + 4673) & 0x20) == 0 || !*((_QWORD *)v3 + 360))
      {
        v53 = 0;
        goto LABEL_148;
      }
      *(_QWORD *)buf = &ioData;
      *(_QWORD *)&buf[8] = &ioOutputBufferLists;
      MEMORY[0x1E0C80A78](Parameter);
      v49 = *((_QWORD *)v3 + 419);
      *((_QWORD *)&v133 - 4) = *((_QWORD *)v3 + 136);
      *((_QWORD *)&v133 - 3) = v49;
      v132 = *((_QWORD *)v3 + 424);
      v140 = 512;
      v50 = 1.0;
      if (!*(_BYTE *)(*((_QWORD *)v3 + 176) + v32))
        v50 = 0.0;
      AudioUnitSetParameter(*((AudioUnit *)v3 + 360), 4u, 0, 0, v50, 0);
      AudioUnitSetParameter(*((AudioUnit *)v3 + 360), 5u, 0, 0, *((AudioUnitParameterValue *)v3 + 1092), 0);
      AudioUnitProcessMultiple(*((AudioUnit *)v3 + 360), &v140, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 3u, (AudioBufferList **)&v133 - 4);
      v51 = *((unsigned int *)v3 + 127);
      if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
      {
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xDu, v51, *((const AudioBufferList **)v3 + 419), a2);
        v51 = *((unsigned int *)v3 + 127);
        v52 = *((_QWORD *)v3 + 136);
        if (*((_BYTE *)v3 + 15897))
          goto LABEL_230;
      }
      else
      {
        v52 = *((_QWORD *)v3 + 136);
      }
      if (!*((_BYTE *)v3 + 15898))
      {
LABEL_231:
        memcpy(ioData.mBuffers[0].mData, *(const void **)(v52 + 16), 4 * v51);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 3u, 0, 0, (AudioUnitParameterValue *)v3 + 1047);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 8u, 0, 0, (AudioUnitParameterValue *)v3 + 1051);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 0x21u, 0, 0, (AudioUnitParameterValue *)v3 + 1055);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 0x22u, 0, 0, (AudioUnitParameterValue *)v3 + 1059);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 0x25u, 0, 0, (AudioUnitParameterValue *)v3 + 1063);
        AudioUnitGetParameter(*((AudioUnit *)v3 + 360), 0x24u, 0, 0, (AudioUnitParameterValue *)v3 + 1067);
        v53 = 1;
LABEL_148:
        v54 = (float *)(*(_QWORD *)(*((_QWORD *)v3 + 510) + 16) + 4 * *((unsigned int *)v3 + 127));
        v137.realp = *(float **)(*((_QWORD *)v3 + 510) + 16);
        v137.imagp = v54;
        v55 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 518);
        if (v55)
          VPTimeFreqConverter::Analyze(v55, *((const float **)&v149 + 1), &v137);
        if ((*((_BYTE *)v3 + 4657) & 0x10) != 0 && (*((_BYTE *)v3 + 4673) & 0x10) != 0 && *((_QWORD *)v3 + 359))
        {
          v56 = *((unsigned int *)v3 + 127);
          v57 = (float *)(*(_QWORD *)(*((_QWORD *)v3 + 428) + 16) + 4 * v56);
          v137.realp = *(float **)(*((_QWORD *)v3 + 428) + 16);
          v137.imagp = v57;
          v58 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 512);
          if (v58)
          {
            VPTimeFreqConverter::Analyze(v58, (const float *)ioActionFlags.mBuffers[0].mData, &v137);
            v56 = *((unsigned int *)v3 + 127);
          }
          v59 = (float *)(*(_QWORD *)(*((_QWORD *)v3 + 504) + 16) + 4 * v56);
          v137.realp = *(float **)(*((_QWORD *)v3 + 504) + 16);
          v137.imagp = v59;
          v60 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 516);
          if (v60)
            VPTimeFreqConverter::Analyze(v60, *(const float **)(*((_QWORD *)v3 + 418) + 16), &v137);
        }
        if ((*((_BYTE *)v3 + 4657) & 0x20) != 0 && (*((_BYTE *)v3 + 4673) & 0x20) != 0 && *((_QWORD *)v3 + 360))
        {
          v61 = *((unsigned int *)v3 + 127);
          v62 = (float *)(*(_QWORD *)(*((_QWORD *)v3 + 505) + 16) + 4 * v61);
          v137.realp = *(float **)(*((_QWORD *)v3 + 505) + 16);
          v137.imagp = v62;
          v63 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 513);
          if (v63)
          {
            VPTimeFreqConverter::Analyze(v63, (const float *)ioData.mBuffers[0].mData, &v137);
            v61 = *((unsigned int *)v3 + 127);
          }
          v64 = (float *)(*(_QWORD *)(*((_QWORD *)v3 + 504) + 32) + 4 * v61);
          v137.realp = *(float **)(*((_QWORD *)v3 + 504) + 32);
          v137.imagp = v64;
          v65 = (VPTimeFreqConverter *)*((_QWORD *)v3 + 517);
          if (v65)
            VPTimeFreqConverter::Analyze(v65, *(const float **)(*((_QWORD *)v3 + 419) + 16), &v137);
        }
        v66 = *((_QWORD *)v3 + 582);
        if ((v66 & 0x20000000) == 0
          || (*((_BYTE *)v3 + 4675) & 0x20) == 0
          || (v67 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 376)) == 0)
        {
          v74 = 0;
          if ((v66 & 0x40000000) == 0)
            goto LABEL_191;
          goto LABEL_178;
        }
        AudioUnitSetProperty(v67, 0x457u, 0, 0, (char *)v3 + 2316, 4u);
        if ((*((_BYTE *)v3 + 4659) & 0x40) != 0 && (*((_BYTE *)v3 + 4675) & 0x40) != 0)
        {
          v68 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 376);
          if (*((_QWORD *)v3 + 377))
          {
            v69 = (float)*((unsigned int *)v3 + 684);
            goto LABEL_171;
          }
        }
        else
        {
          v68 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 376);
        }
        v69 = 2.0;
LABEL_171:
        AudioUnitSetParameter(v68, 0x1Bu, 0, 0, v69, 0);
        if ((*((_BYTE *)v3 + 4657) & 0x10) != 0 && (*((_BYTE *)v3 + 4673) & 0x10) != 0 && *((_QWORD *)v3 + 359))
          AudioUnitSetParameter(*((AudioUnit *)v3 + 376), 0x3Fu, 0, 0, *((float *)v3 + 1054) * *((float *)v3 + 1055), 0);
        v70 = *((_QWORD *)v3 + 138) + 24;
        v71 = *((_QWORD *)v3 + 139) + 24;
        v72 = **((_DWORD **)v3 + 135);
        if (v72 < 3)
          v73 = 0;
        else
          v73 = *((_QWORD *)v3 + 140) + 24;
        *(_QWORD *)buf = *((_QWORD *)v3 + 138) + 24;
        *(_QWORD *)&buf[8] = v71;
        v77 = *((_QWORD *)v3 + 134);
        *(_QWORD *)&buf[16] = v73;
        v146 = v77;
        v147 = *((_OWORD *)v3 + 209);
        if (v72 >= 3)
        {
          *(_QWORD *)buf = v71;
          *(_QWORD *)&buf[8] = v73;
          *(_QWORD *)&buf[16] = v70;
        }
        p_ioActionFlags = 0;
        v140 = 512;
        AudioUnitSetParameter(*((AudioUnit *)v3 + 376), 0x2Cu, 0, 0, *((AudioUnitParameterValue *)v3 + 1090), 0);
        v74 = 1;
        AudioUnitProcessMultiple(*((AudioUnit *)v3 + 376), &v140, a2, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)buf, 1u, &p_ioActionFlags);
        if ((*((_QWORD *)v3 + 582) & 0x40000000) == 0)
          goto LABEL_191;
LABEL_178:
        if ((*((_BYTE *)v3 + 4675) & 0x40) != 0 && *((_QWORD *)v3 + 377))
        {
          memcpy(*(void **)(*((_QWORD *)v3 + 434) + 16 * *((unsigned int *)v3 + 1040) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
          memcpy(*(void **)(*((_QWORD *)v3 + 434) + 16 * *((unsigned int *)v3 + 1041) + 16), *(const void **)(*((_QWORD *)v3 + 505) + 16), 4 * (2 * *((_DWORD *)v3 + 127)));
          if (*((float *)v3 + 1066) == 0.0 && *((float *)v3 + 1067) == 0.0)
            v75 = 0.0;
          else
            v75 = 1.0;
          AudioUnitSetParameter(*((AudioUnit *)v3 + 377), 0x20u, 0, 0, v75, 0);
          *(_QWORD *)buf = *((_QWORD *)v3 + 434);
          p_ioActionFlags = (AudioBufferList *)*((_QWORD *)v3 + 429);
          v140 = 512;
          AudioUnitProcessMultiple(*((AudioUnit *)v3 + 377), &v140, a2, *((_DWORD *)v3 + 127), 1u, (const AudioBufferList **)buf, 1u, &p_ioActionFlags);
          ioDataSize = 8 * *((_DWORD *)v3 + 127);
          AudioUnitGetProperty(*((AudioUnit *)v3 + 377), 0xE7Au, 0, 0, *(void **)(*((_QWORD *)v3 + 537) + 16), &ioDataSize);
          ioDataSize = 8 * *((_DWORD *)v3 + 127);
          AudioUnitGetProperty(*((AudioUnit *)v3 + 377), 0xE79u, 0, 0, *(void **)(*((_QWORD *)v3 + 537) + 32), &ioDataSize);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xAu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 429), a2);
          v76 = 1;
LABEL_192:
          v135 = 0;
          VoiceProcessorV2::SignalParamSwitchMix((AudioUnit *)v3, v76, v74, &v135, v47);
          VoiceProcessorV2::TimeAlignedReferenceAndOtherHandling(v3, v48, v53, v76, v135);
          memcpy(*(void **)(*((_QWORD *)v3 + 432) + 16), *(const void **)(*((_QWORD *)v3 + 504) + 16), *((unsigned int *)v3 + 1071));
          v78 = *((_QWORD *)v3 + 582);
          if ((v78 & 0x10000000000000) != 0 && (*((_BYTE *)v3 + 4678) & 0x10) != 0 && *((_QWORD *)v3 + 399))
            v79 = 1;
          else
            v79 = (v78 & 0x40000000000000) != 0 && (*((_BYTE *)v3 + 4678) & 0x40) != 0 && *((_QWORD *)v3 + 401) != 0;
          *(float *)&ioDataSize = 0.0;
          v134 = 0.0;
          AudioUnitGetParameter(*((AudioUnit *)v3 + 385), 0x1Du, 0, 0, (AudioUnitParameterValue *)&ioDataSize);
          v80 = *(float *)&ioDataSize < 1.0 && v79;
          if (v79)
          {
            *(_DWORD *)buf = 1065353216;
            if (*(float *)&ioDataSize < 1.0)
              vDSP_vfill((const float *)buf, *(float **)(*((_QWORD *)v3 + 501) + 16), 1, *((unsigned int *)v3 + 127));
            vDSP_vfill((const float *)buf, *(float **)(*((_QWORD *)v3 + 499) + 16), 1, *((unsigned int *)v3 + 127));
          }
          else if ((*((_BYTE *)v3 + 4660) & 0x40) == 0 || (*((_BYTE *)v3 + 4676) & 0x40) == 0 || !*((_QWORD *)v3 + 385))
          {
            v81 = 0;
            goto LABEL_215;
          }
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x61u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 428), a2);
          v81 = 1;
LABEL_215:
          v82 = *((_QWORD *)v3 + 582);
          if ((v82 & 0x8000000000) == 0
            || (*((_BYTE *)v3 + 4676) & 0x80) == 0
            || (v83 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 386)) == 0)
          {
LABEL_237:
            if ((v82 & 0x8000000000000) != 0 && (*((_BYTE *)v3 + 4678) & 8) != 0)
            {
              v88 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 398);
              if (v88)
              {
                v89 = *((_QWORD *)v3 + 499);
                *(_QWORD *)buf = *((_QWORD *)v3 + 428);
                *(_QWORD *)&buf[8] = v89;
                p_ioActionFlags = (AudioBufferList *)*((_QWORD *)v3 + 431);
                v143 = v89;
                v140 = 512;
                AudioUnitProcessMultiple(v88, &v140, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 2u, &p_ioActionFlags);
                if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x62u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 428), a2);
                v82 = *((_QWORD *)v3 + 582);
              }
            }
            if ((v82 & 0x10000000000000) != 0
              && (*((_BYTE *)v3 + 4678) & 0x10) != 0
              && (v90 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 399)) != 0)
            {
              v91 = *((_QWORD *)v3 + 499);
              *(_QWORD *)buf = *((_QWORD *)v3 + 428);
              *(_QWORD *)&buf[8] = v91;
              v92 = *((_QWORD *)v3 + 501);
              p_ioActionFlags = (AudioBufferList *)*((_QWORD *)v3 + 429);
              v143 = v92;
              v140 = 512;
              AudioUnitProcessMultiple(v90, &v140, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 2u, &p_ioActionFlags);
              if ((*((_BYTE *)v3 + 4662) & 8) != 0 && (*((_BYTE *)v3 + 4678) & 8) != 0 && *((_QWORD *)v3 + 398))
                vDSP_vmin(*(const float **)(*((_QWORD *)v3 + 501) + 16), 1, *(const float **)(*((_QWORD *)v3 + 500) + 16), 1, *(float **)(*((_QWORD *)v3 + 501) + 16), 1, *((unsigned int *)v3 + 127));
              AudioUnitGetParameter(*((AudioUnit *)v3 + 399), 1u, 0, 0, &outValue);
              if ((*((_BYTE *)v3 + 4664) & 2) == 0 || (*((_BYTE *)v3 + 4680) & 2) == 0 || !*((_QWORD *)v3 + 412))
                goto LABEL_263;
              v93 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 399);
              v94 = 2;
            }
            else
            {
              if ((v82 & 0x40000000000000) == 0
                || (*((_BYTE *)v3 + 4678) & 0x40) == 0
                || (v95 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 401)) == 0)
              {
                v98 = 1;
                goto LABEL_268;
              }
              AudioUnitSetParameter(v95, 0x14u, 0, 0, *((AudioUnitParameterValue *)v3 + 4172), 0);
              v96 = *((_QWORD *)v3 + 431);
              *(_QWORD *)buf = *((_QWORD *)v3 + 428);
              *(_QWORD *)&buf[8] = v96;
              *(_QWORD *)&buf[16] = *((_QWORD *)v3 + 499);
              v97 = *((_QWORD *)v3 + 436);
              p_ioActionFlags = (AudioBufferList *)*((_QWORD *)v3 + 429);
              v143 = v97;
              v144 = *((_QWORD *)v3 + 501);
              v140 = 512;
              AudioUnitProcessMultiple(*((AudioUnit *)v3 + 401), &v140, a2, *((_DWORD *)v3 + 127), 3u, (const AudioBufferList **)buf, 3u, &p_ioActionFlags);
              AudioUnitGetParameter(*((AudioUnit *)v3 + 401), 2u, 0, 0, &outValue);
              if ((*((_BYTE *)v3 + 4664) & 2) == 0 || (*((_BYTE *)v3 + 4680) & 2) == 0 || !*((_QWORD *)v3 + 412))
              {
LABEL_263:
                if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x27u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 429), a2);
                v98 = 0;
LABEL_268:
                if ((*((_BYTE *)v3 + 4660) & 0x40) == 0)
                  goto LABEL_292;
                if ((*((_BYTE *)v3 + 4676) & 0x40) == 0
                  || (v99 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 385)) == 0)
                {
LABEL_286:
                  if ((*((_BYTE *)v3 + 4676) & 0x40) != 0 && *((_QWORD *)v3 + 385) && v80)
                  {
                    v107 = *(float **)(*((_QWORD *)v3 + 501) + 16);
                    vDSP_vmin(*(const float **)(*((_QWORD *)v3 + 499) + 16), 1, v107, 1, v107, 1, *((unsigned int *)v3 + 127));
                    v108 = *(const float **)(*((_QWORD *)v3 + 428) + 16);
                    v109 = *(float **)(*((_QWORD *)v3 + 429) + 16);
                    vDSP_vmul(v108, 1, v107, 1, v109, 1, *((unsigned int *)v3 + 127));
                    vDSP_vmul(&v108[*((unsigned int *)v3 + 127) + 1], 1, v107 + 1, 1, &v109[*((unsigned int *)v3 + 127) + 1], 1, (*((_DWORD *)v3 + 127) - 1));
                    v108[*((unsigned int *)v3 + 127)] = v108[*((unsigned int *)v3 + 127)]
                                                      * v107[*((_DWORD *)v3 + 127) - 1];
LABEL_299:
                    if (((v81 & 1) != 0
                       || (*((_BYTE *)v3 + 4660) & 0x40) != 0
                       && (*((_BYTE *)v3 + 4676) & 0x40) != 0
                       && *((_QWORD *)v3 + 385))
                      && (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898)))
                    {
                      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x60u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 429), a2);
                    }
                    if ((*((_BYTE *)v3 + 4663) & 0x10) != 0 && (*((_BYTE *)v3 + 4679) & 0x10) != 0)
                    {
                      v112 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 407);
                      if (v112)
                      {
                        AudioUnitSetParameter(v112, 0, 0, 0, *((AudioUnitParameterValue *)v3 + 3117), 0);
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 4u, 0, 0, *((AudioUnitParameterValue *)v3 + 1046), 0);
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 0x13u, 0, 0, *((AudioUnitParameterValue *)v3 + 1050), 0);
                        AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 3u, 0, 0, outValue, 0);
                        v113 = *((_QWORD *)v3 + 510);
                        *(_QWORD *)buf = *((_QWORD *)v3 + 418);
                        *(_QWORD *)&buf[8] = v113;
                        v114 = *((_QWORD *)v3 + 432);
                        *(_QWORD *)&buf[16] = *((_QWORD *)v3 + 429);
                        v146 = v114;
                        v115 = *((_QWORD *)v3 + 501);
                        *(_QWORD *)&v147 = *((_QWORD *)v3 + 499);
                        *((_QWORD *)&v147 + 1) = v115;
                        p_ioActionFlags = (AudioBufferList *)*((_QWORD *)v3 + 136);
                        v140 = 512;
                        AudioUnitProcessMultiple(*((AudioUnit *)v3 + 407), &v140, a2, *((_DWORD *)v3 + 127), 6u, (const AudioBufferList **)buf, 1u, &p_ioActionFlags);
                        v133 = 0.0;
                        AudioUnitGetParameter(*((AudioUnit *)v3 + 407), 1u, 0, 0, &v133);
                        *((AudioUnitParameterValue *)v3 + 3118) = v133;
                        if ((*((_BYTE *)v3 + 4664) & 2) != 0
                          && (*((_BYTE *)v3 + 4680) & 2) != 0
                          && *((_QWORD *)v3 + 412))
                        {
                          AudioUnitGetParameter(*((AudioUnit *)v3 + 407), 2u, 0, 0, &outValue);
                          AudioUnitSetParameter(*((AudioUnit *)v3 + 412), 0x23u, 0, 0, outValue, 0);
                        }
                      }
                    }
                    goto LABEL_313;
                  }
LABEL_292:
                  if ((*((_BYTE *)v3 + 8836) & 0x40) != 0
                    && (*((_BYTE *)v3 + 8844) & 0x40) != 0
                    && *((_QWORD *)v3 + 475)
                    && !v79)
                  {
                    *(_DWORD *)buf = 1065353216;
                    v111 = *((_DWORD *)v3 + 127);
                    vDSP_vfill((const float *)buf, *(float **)(*((_QWORD *)v3 + 501) + 16), 1, v111);
                    memcpy(*(void **)(*((_QWORD *)v3 + 429) + 16), *(const void **)(*((_QWORD *)v3 + 428) + 16), 8 * v111);
                  }
                  goto LABEL_299;
                }
                AudioUnitSetParameter(v99, 6u, 0, 0, *((AudioUnitParameterValue *)v3 + 1054), 0);
                AudioUnitSetParameter(*((AudioUnit *)v3 + 385), 7u, 0, 0, *((AudioUnitParameterValue *)v3 + 1058), 0);
                AudioUnitSetParameter(*((AudioUnit *)v3 + 385), 0xDu, 0, 0, *((AudioUnitParameterValue *)v3 + 1062), 0);
                v100 = *((_QWORD *)v3 + 432);
                *(_QWORD *)buf = *((_QWORD *)v3 + 428);
                *(_QWORD *)&buf[8] = v100;
                v101 = *((_QWORD *)v3 + 501);
                *(_QWORD *)&buf[16] = *((_QWORD *)v3 + 511);
                v146 = v101;
                if (v80)
                {
                  v102 = (AudioBufferList **)((char *)v3 + 3448);
                  v101 = *((_QWORD *)v3 + 499);
                }
                else
                {
                  v146 = 0;
                  v102 = (AudioBufferList **)((char *)v3 + 3432);
                }
                p_ioActionFlags = *v102;
                v143 = v101;
                v140 = 512;
                AudioUnitProcessMultiple(*((AudioUnit *)v3 + 385), &v140, a2, *((_DWORD *)v3 + 127), 4u, (const AudioBufferList **)buf, 2u, &p_ioActionFlags);
                if ((v98 | !v80) == 1)
                  AudioUnitGetParameter(*((AudioUnit *)v3 + 385), 0x20u, 0, 0, &outValue);
                v103 = *((unsigned int *)v3 + 127);
                v104 = 3432;
                if (v80)
                  v104 = 3448;
                if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
                {
                  VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x24u, v103, *(const AudioBufferList **)((char *)v3 + v104), a2);
                  v103 = *((unsigned int *)v3 + 127);
                  v105 = (const AudioBufferList *)*((_QWORD *)v3 + 499);
                  if (*((_BYTE *)v3 + 15897))
                  {
LABEL_284:
                    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x4Fu, v103, v105, a2);
LABEL_285:
                    if ((*((_BYTE *)v3 + 4660) & 0x40) == 0)
                      goto LABEL_292;
                    goto LABEL_286;
                  }
                }
                else
                {
                  v105 = (const AudioBufferList *)*((_QWORD *)v3 + 499);
                }
                if (!*((_BYTE *)v3 + 15898))
                  goto LABEL_285;
                goto LABEL_284;
              }
              v93 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 401);
              v94 = 9;
            }
            AudioUnitGetParameter(v93, v94, 0, 0, &v134);
            AudioUnitSetParameter(*((AudioUnit *)v3 + 412), 0x12u, 0, 0, v134, 0);
            goto LABEL_263;
          }
          AudioUnitSetParameter(v83, 6u, 0, 0, *((AudioUnitParameterValue *)v3 + 1055), 0);
          AudioUnitSetParameter(*((AudioUnit *)v3 + 386), 7u, 0, 0, *((AudioUnitParameterValue *)v3 + 1059), 0);
          AudioUnitSetParameter(*((AudioUnit *)v3 + 386), 0xDu, 0, 0, *((AudioUnitParameterValue *)v3 + 1063), 0);
          memcpy(*(void **)(*((_QWORD *)v3 + 433) + 16), *(const void **)(*((_QWORD *)v3 + 504) + 32), *((unsigned int *)v3 + 1071));
          v84 = *((_QWORD *)v3 + 433);
          *(_QWORD *)buf = *((_QWORD *)v3 + 505);
          *(_QWORD *)&buf[8] = v84;
          *(_QWORD *)&buf[16] = *((_QWORD *)v3 + 511);
          v146 = 0;
          v85 = *((_QWORD *)v3 + 500);
          p_ioActionFlags = (AudioBufferList *)*((_QWORD *)v3 + 431);
          v143 = v85;
          v140 = 512;
          AudioUnitProcessMultiple(*((AudioUnit *)v3 + 386), &v140, a2, *((_DWORD *)v3 + 127), 4u, (const AudioBufferList **)buf, 2u, &p_ioActionFlags);
          v86 = *((unsigned int *)v3 + 127);
          if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          {
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x25u, v86, *((const AudioBufferList **)v3 + 431), a2);
            v86 = *((unsigned int *)v3 + 127);
            v87 = (const AudioBufferList *)*((_QWORD *)v3 + 500);
            if (*((_BYTE *)v3 + 15897))
              goto LABEL_235;
          }
          else
          {
            v87 = (const AudioBufferList *)*((_QWORD *)v3 + 500);
          }
          if (!*((_BYTE *)v3 + 15898))
          {
LABEL_236:
            v82 = *((_QWORD *)v3 + 582);
            goto LABEL_237;
          }
LABEL_235:
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x50u, v86, v87, a2);
          goto LABEL_236;
        }
LABEL_191:
        v76 = 0;
        goto LABEL_192;
      }
LABEL_230:
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Du, v51, (const AudioBufferList *)v52, a2);
      v52 = *((_QWORD *)v3 + 136);
      LODWORD(v51) = *((_DWORD *)v3 + 127);
      goto LABEL_231;
    }
    *(_QWORD *)buf = &ioActionFlags;
    *(_QWORD *)&buf[8] = &ioOutputBufferLists;
    MEMORY[0x1E0C80A78](v20);
    v34 = *((_QWORD *)v3 + 418);
    *((_QWORD *)&v133 - 4) = *((_QWORD *)v3 + 136);
    *((_QWORD *)&v133 - 3) = v34;
    v132 = *((_QWORD *)v3 + 423);
    v140 = 512;
    v35 = 1.0;
    if (!*(_BYTE *)(*((_QWORD *)v3 + 176) + v31))
      v35 = 0.0;
    AudioUnitSetParameter(*((AudioUnit *)v3 + 359), 4u, 0, 0, v35, 0);
    AudioUnitSetParameter(*((AudioUnit *)v3 + 359), 5u, 0, 0, *((AudioUnitParameterValue *)v3 + 1092), 0);
    AudioUnitProcessMultiple(*((AudioUnit *)v3 + 359), &v140, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 3u, (AudioBufferList **)&v133 - 4);
    v36 = *((unsigned int *)v3 + 127);
    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
    {
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0xCu, v36, *((const AudioBufferList **)v3 + 418), a2);
      v36 = *((unsigned int *)v3 + 127);
      v37 = *((_QWORD *)v3 + 136);
      if (*((_BYTE *)v3 + 15897))
        goto LABEL_226;
    }
    else
    {
      v37 = *((_QWORD *)v3 + 136);
    }
    if (!*((_BYTE *)v3 + 15898))
    {
LABEL_227:
      memcpy(ioActionFlags.mBuffers[0].mData, *(const void **)(v37 + 16), 4 * v36);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 359), 3u, 0, 0, (AudioUnitParameterValue *)v3 + 1046);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 359), 8u, 0, 0, (AudioUnitParameterValue *)v3 + 1050);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 359), 0x21u, 0, 0, (AudioUnitParameterValue *)v3 + 1054);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 359), 0x22u, 0, 0, (AudioUnitParameterValue *)v3 + 1058);
      AudioUnitGetParameter(*((AudioUnit *)v3 + 359), 0x25u, 0, 0, (AudioUnitParameterValue *)v3 + 1062);
      Parameter = (void *)AudioUnitGetParameter(*((AudioUnit *)v3 + 359), 0x24u, 0, 0, (AudioUnitParameterValue *)v3 + 1066);
      v48 = 1;
      goto LABEL_138;
    }
LABEL_226:
    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x1Cu, v36, (const AudioBufferList *)v37, a2);
    v37 = *((_QWORD *)v3 + 136);
    LODWORD(v36) = *((_DWORD *)v3 + 127);
    goto LABEL_227;
  }
  v9 = 0;
  while (((*((_DWORD *)v3 + 116) >> v9) & 1) == 0)
  {
    if (++v9 == 32)
    {
      v9 = 33;
      break;
    }
  }
  v10 = (unsigned int *)*((_QWORD *)v3 + 135);
  if (v9 >= *v10)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v13 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v14 = (*v13 ? *v13 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v15 = **((_DWORD **)v3 + 135);
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "vpProcessUplink_v3.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 49;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v9;
        LOWORD(v146) = 1024;
        *(_DWORD *)((char *)&v146 + 2) = v15;
        _os_log_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", buf, 0x1Eu);
      }
    }
    v16 = (int *)*((_QWORD *)v3 + 1570);
    if (v16 && (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      CALegacyLog::log(v16, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v3/vpProcessUplink_v3.cpp", 49, "RunUplinkEchoDSP", "ERROR: mPrimaryEpMicIndex is %d, but epmic only has %d channels", v9, **((_DWORD **)v3 + 135));
    }
    v11 = *(void **)(*((_QWORD *)v3 + 136) + 16);
    v12 = (const void **)*((_QWORD *)v3 + 135);
  }
  else
  {
    v11 = *(void **)(*((_QWORD *)v3 + 136) + 16);
    v12 = (const void **)&v10[4 * v9];
  }
  memcpy(v11, v12[2], *((unsigned int *)v12 + 3));
  if (*((_BYTE *)v3 + 2085))
  {
    if ((*((_BYTE *)v3 + 4662) & 0x10) != 0 && (*((_BYTE *)v3 + 4678) & 0x10) != 0)
    {
      v17 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 399);
      if (v17)
      {
        v18 = *((_QWORD *)v3 + 499);
        *(_QWORD *)buf = *((_QWORD *)v3 + 136);
        *(_QWORD *)&buf[8] = v18;
        v19 = *((_QWORD *)v3 + 501);
        ioOutputBufferLists = *(AudioBufferList **)buf;
        *(_QWORD *)&v149 = v19;
        ioActionFlags.mNumberBuffers = 512;
        AudioUnitProcessMultiple(v17, &ioActionFlags.mNumberBuffers, a2, *((_DWORD *)v3 + 127), 2u, (const AudioBufferList **)buf, 2u, &ioOutputBufferLists);
        if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
          VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x27u, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
        if ((*((_BYTE *)v3 + 4664) & 2) != 0 && (*((_BYTE *)v3 + 4680) & 2) != 0 && *((_QWORD *)v3 + 412))
        {
          AudioUnitGetParameter(*((AudioUnit *)v3 + 399), 1u, 0, 0, &outValue);
          AudioUnitSetParameter(*((AudioUnit *)v3 + 412), 0x23u, 0, 0, outValue, 0);
        }
      }
    }
  }
LABEL_313:
  *(_DWORD *)buf = 0;
  v116 = VoiceProcessorV2::LocalVoiceDuckingForMediaChatEnabled(v3);
  v118 = v116;
  if (!*((_BYTE *)v3 + 2080))
  {
    if ((v116 & 1) == 0)
    {
LABEL_334:
      *((_DWORD *)v3 + 4110) = 0;
      goto LABEL_335;
    }
    VoiceProcessorV2::DetectVoiceActivity(v3, a2, v117);
LABEL_322:
    v120 = *((_QWORD *)v3 + 582);
    if ((v120 & 0x2000000000000000) != 0
      && (*((_BYTE *)v3 + 4679) & 0x20) != 0
      && (v121 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 408)) != 0)
    {
      v122 = 1936748646;
    }
    else
    {
      if ((v120 & 0x1000000000000000) == 0
        || (*((_BYTE *)v3 + 4679) & 0x10) == 0
        || (v121 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 407)) == 0)
      {
        *(AudioUnitParameterValue *)buf = outValue;
        goto LABEL_332;
      }
      v122 = 2;
    }
    AudioUnitGetParameter(v121, v122, 0, 0, (AudioUnitParameterValue *)buf);
    goto LABEL_332;
  }
  if (*((_QWORD *)v3 + 2054))
    v119 = 1;
  else
    v119 = v116;
  if ((v119 & 1) != 0)
  {
    VoiceProcessorV2::DetectVoiceActivity(v3, a2, v117);
    if ((v118 & 1) != 0)
      goto LABEL_322;
  }
LABEL_332:
  if (!*((_BYTE *)v3 + 2080))
    goto LABEL_334;
  bzero(*(void **)(*((_QWORD *)v3 + 136) + 16), 4 * *((unsigned int *)v3 + 127));
  *(_DWORD *)buf = 0;
LABEL_335:
  if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
    VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Au, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
  if ((*((_BYTE *)v3 + 8833) & 0x80) != 0 && (*((_BYTE *)v3 + 8841) & 0x80) != 0)
  {
    v123 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 452);
    v124 = v123 ? v118 : 0;
    if (v124 == 1)
      AudioUnitSetParameter(v123, 0x12u, 0, 0, *(AudioUnitParameterValue *)buf, 0);
  }
  if ((*((_QWORD *)v3 + 582) & 0x8000000000000000) != 0 && (*((_QWORD *)v3 + 584) & 0x8000000000000000) != 0)
  {
    v125 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 410);
    if (v125)
    {
      LODWORD(ioOutputBufferLists) = 512;
      AudioUnitProcess(v125, (AudioUnitRenderActionFlags *)&ioOutputBufferLists, a2, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
      if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
        VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Cu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
    }
  }
  v126 = *((_QWORD *)v3 + 583);
  if ((v126 & 1) != 0 && (*((_BYTE *)v3 + 4680) & 1) != 0)
  {
    v127 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 411);
    if (v127)
    {
      LODWORD(ioOutputBufferLists) = 512;
      AudioUnitProcess(v127, (AudioUnitRenderActionFlags *)&ioOutputBufferLists, a2, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
      v126 = *((_QWORD *)v3 + 583);
    }
  }
  if ((v126 & 2) != 0
    && (*((_BYTE *)v3 + 4680) & 2) != 0
    && (v128 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 412)) != 0)
  {
    LODWORD(ioOutputBufferLists) = 512;
    AudioUnitProcess(v128, (AudioUnitRenderActionFlags *)&ioOutputBufferLists, a2, *((_DWORD *)v3 + 127), *((AudioBufferList **)v3 + 136));
    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Du, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
    if ((*((_BYTE *)v3 + 4663) & 0x10) != 0 && (*((_BYTE *)v3 + 4679) & 0x10) != 0 && *((_QWORD *)v3 + 407))
    {
      ioActionFlags.mNumberBuffers = 0;
      AudioUnitGetParameter(*((AudioUnit *)v3 + 412), 1u, 0, 0, (AudioUnitParameterValue *)&ioActionFlags.mNumberBuffers);
      AudioUnitSetParameter(*((AudioUnit *)v3 + 407), 0x11u, 0, 0, *(AudioUnitParameterValue *)&ioActionFlags.mNumberBuffers, 0);
    }
    ioActionFlags.mNumberBuffers = 0;
    AudioUnitGetParameter(*((AudioUnit *)v3 + 412), 0x1Bu, 0, 0, (AudioUnitParameterValue *)&ioActionFlags.mNumberBuffers);
    mNumberBuffers = ioActionFlags.mNumberBuffers;
    if (*((float *)v3 + 572) != *(float *)&ioActionFlags.mNumberBuffers)
    {
      if ((*((_BYTE *)v3 + 4663) & 0x10) != 0 && (*((_BYTE *)v3 + 4679) & 0x10) != 0)
      {
        v130 = (OpaqueAudioComponentInstance *)*((_QWORD *)v3 + 407);
        if (v130)
        {
          AudioUnitSetParameter(v130, 0x12u, 0, 0, *(AudioUnitParameterValue *)&ioActionFlags.mNumberBuffers, 0);
          mNumberBuffers = ioActionFlags.mNumberBuffers;
        }
      }
      *((_DWORD *)v3 + 572) = mNumberBuffers;
    }
  }
  else if ((*((_BYTE *)v3 + 4663) & 0x40) != 0 && ((*((_BYTE *)v3 + 4679) & 0x40) != 0 || *((_BYTE *)v3 + 472)))
  {
    LODWORD(ioOutputBufferLists) = __exp10f(*((float *)v3 + 1091) / 20.0);
    vDSP_vsmul(*(const float **)(*((_QWORD *)v3 + 136) + 16), 1, (const float *)&ioOutputBufferLists, *(float **)(*((_QWORD *)v3 + 136) + 16), 1, *((unsigned int *)v3 + 127));
    if (*((_BYTE *)v3 + 15897) || *((_BYTE *)v3 + 15898))
      VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)v3, 0x2Bu, *((unsigned int *)v3 + 127), *((const AudioBufferList **)v3 + 136), a2);
  }
  return 0;
}

void *CADeprecated::CABufferList::CopyDataFrom(void *this, const AudioBufferList *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  size_t mDataByteSize;
  BOOL v8;
  void *v9;
  void *mData;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2->mNumberBuffers)
  {
    v3 = (uint64_t)this;
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = *(_DWORD *)(v3 + 16);
      mDataByteSize = a2->mBuffers[v4].mDataByteSize;
      if (v6)
        v8 = mDataByteSize > v6;
      else
        v8 = 0;
      if (v8)
      {
        if (os_log_type_enabled(0, OS_LOG_TYPE_ERROR))
        {
          v11 = 136315394;
          v12 = "CABufferList.h";
          v13 = 1024;
          v14 = 120;
          _os_log_impl(&dword_1B5ED0000, 0, OS_LOG_TYPE_ERROR, "%25s:%-5d ASSERTION FAILURE [(mBufferCapacity == 0 || other.mBuffers[i].mDataByteSize <= mBufferCapacity) != 0 is false]: ", (uint8_t *)&v11, 0x12u);
        }
        __break(1u);
      }
      v9 = *(void **)(v3 + v4 * 16 + 40);
      mData = a2->mBuffers[v4].mData;
      *(_DWORD *)(v3 + v4 * 16 + 36) = mDataByteSize;
      this = memcpy(v9, mData, mDataByteSize);
      ++v5;
      ++v4;
    }
    while (v5 < a2->mNumberBuffers);
  }
  return this;
}

uint64_t CALog::LogObjIfEnabled(int a1, uint64_t a2)
{
  int v3;
  uint64_t result;

  if (!a2)
    return 0;
  v3 = CALegacyLog::LogEnabled(a1, a2, 0);
  result = 0;
  if (v3)
  {
    if (*(_QWORD *)a2)
      return *(_QWORD *)a2;
    else
      return MEMORY[0x1E0C81028];
  }
  return result;
}

void AUAmbienceLeveler::~AUAmbienceLeveler(AUAmbienceLeveler *this)
{
  AUAmbienceLeveler::~AUAmbienceLeveler(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  *(_QWORD *)this = &off_1E69C6768;
  v2 = (void *)*((_QWORD *)this + 293);
  if (v2)
  {
    *((_QWORD *)this + 294) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 290);
  if (v3)
  {
    *((_QWORD *)this + 291) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 287);
  if (v4)
  {
    *((_QWORD *)this + 288) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 284);
  if (v5)
  {
    *((_QWORD *)this + 285) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 281);
  if (v6)
  {
    *((_QWORD *)this + 282) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 278);
  if (v7)
  {
    *((_QWORD *)this + 279) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 275);
  if (v8)
  {
    *((_QWORD *)this + 276) = v8;
    operator delete(v8);
  }
  AUDspLib::~AUDspLib(this);
}

uint64_t AUAmbienceLeveler::Initialize(AUAmbienceLeveler *this)
{
  int v2;

  v2 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUAmbienceLeveler *)((char *)this + 80), 0) + 108);
  if (v2 == 2 || v2 == *((unsigned __int16 *)this + 900))
    return AUDspLib::Initialize(this);
  else
    return 4294956428;
}

uint64_t AUAmbienceLeveler::GetPropertyInfo(AUAmbienceLeveler *this, int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  if ((a2 - 23777) > 6)
    return AUDspLib::GetPropertyInfo(this, a2, a3, a4, a5, a6);
  *a6 = 0;
  *a5 = 8;
  return 0;
}

uint64_t AUAmbienceLeveler::GetProperty(AUAmbienceLeveler *this, unsigned int a2, unsigned int a3, unsigned int a4, void *a5)
{
  uint64_t v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  CFDictionaryRef *v9;
  int *v10;
  CFDictionaryRef *v11;
  char *v12;
  DspLib::AmbienceLeveler::Algorithm *v13;
  char *v14;
  float v15;
  _DWORD *v16;
  _DWORD *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  uint64_t result;
  _QWORD *v29;
  uint64_t v30;
  float v31;
  float *v32;
  unint64_t v33;
  float v34;
  float v35;
  char *v36;
  float v37;
  unint64_t v38;
  float v39;
  unint64_t v40;
  float v41;
  CFArrayRef CFArray;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  unsigned int v52;
  char *v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  unsigned int v58;
  CFArrayRef v59;
  char __dst[8196];
  uint64_t v61;

  MEMORY[0x1E0C80A78](this);
  v11 = v9;
  v12 = (char *)v5;
  switch(v6)
  {
    case 23777:
      v13 = *(DspLib::AmbienceLeveler::Algorithm **)(v5 + 528);
      if (!v13)
        return AUDspLib::GetProperty((AUDspLib *)v12, v6, v7, v8, v9, v10);
      v14 = (char *)v13 + 115992;
      v15 = DspLib::AmbienceLeveler::Algorithm::computeEQFilters(v13);
      v16 = *(_DWORD **)v14;
      v17 = (_DWORD *)*((_QWORD *)v14 + 1);
      v18 = (char *)*((_QWORD *)v14 + 3);
      v19 = (char *)*((_QWORD *)v14 + 4);
      v20 = (char *)*((_QWORD *)v14 + 6);
      v21 = (char *)*((_QWORD *)v14 + 7);
      if (v17 == *(_DWORD **)v14)
      {
        v27 = 0;
      }
      else
      {
        v22 = 0;
        v23 = *((_QWORD *)v12 + 278);
        do
        {
          v24 = v16[1];
          v25 = v16[2];
          v26 = v16[3];
          *(_DWORD *)(v23 + 4 * v22) = *v16;
          v27 = v22 + 1;
          if (v26 == 1)
          {
            *(_DWORD *)(v23 + 4 * v27) = v24;
            *(_DWORD *)(v23 + 4 * (v22 + 2)) = v25;
            v27 = v22 + 3;
          }
          v16 += 4;
          v22 = v27;
        }
        while (v16 != v17);
      }
      if (v19 == v18)
      {
        v52 = v27;
      }
      else
      {
        v47 = &v18[16 * ((v19 - v18) >> 4)];
        v48 = *((_QWORD *)v12 + 278);
        do
        {
          v49 = *((_DWORD *)v18 + 1);
          v50 = *((_DWORD *)v18 + 2);
          v51 = *((_DWORD *)v18 + 3);
          *(_DWORD *)(v48 + 4 * v27) = *(_DWORD *)v18;
          v52 = v27 + 1;
          if (v51 == 1)
          {
            *(_DWORD *)(v48 + 4 * v52) = v49;
            *(_DWORD *)(v48 + 4 * (v27 + 2)) = v50;
            v52 = v27 + 3;
          }
          v18 += 16;
          v27 = v52;
        }
        while (v18 != v47);
      }
      v36 = v12 + 2224;
      if (v21 != v20)
      {
        v53 = &v20[16 * ((v21 - v20) >> 4)];
        v54 = *((_QWORD *)v12 + 278);
        do
        {
          v55 = *((_DWORD *)v20 + 1);
          v56 = *((_DWORD *)v20 + 2);
          v57 = *((_DWORD *)v20 + 3);
          *(_DWORD *)(v54 + 4 * v52) = *(_DWORD *)v20;
          v58 = v52 + 1;
          if (v57 == 1)
          {
            *(_DWORD *)(v54 + 4 * v58) = v55;
            *(_DWORD *)(v54 + 4 * (v52 + 2)) = v56;
            v58 = v52 + 3;
          }
          v20 += 16;
          v52 = v58;
        }
        while (v20 != v53);
      }
      *(float *)(*((_QWORD *)v12 + 279) - 4) = v15;
      goto LABEL_45;
    case 23778:
      if (!*(_QWORD *)(v5 + 528))
        return 4294956429;
      v29 = (_QWORD *)(v5 + 2200);
      goto LABEL_22;
    case 23779:
      v30 = *(_QWORD *)(v5 + 528);
      if (!v30)
        return 4294956429;
      v31 = *(double *)(v30 + 520);
      v32 = *(float **)(v5 + 2272);
      *v32 = v31;
      v33 = *(_QWORD *)(v30 + 512);
      v34 = 0.0;
      v35 = 0.0;
      if (v33 >= 2)
        v35 = *(double *)(v30 + 528) / (double)(v33 - 1);
      v36 = (char *)(v5 + 2272);
      v32[1] = v35;
      v37 = *(double *)(v30 + 560);
      v32[2] = v37;
      v38 = *(_QWORD *)(v30 + 552);
      if (v38 >= 2)
        v34 = *(double *)(v30 + 568) / (double)(v38 - 1);
      v32[3] = v34;
      v39 = *(double *)(v30 + 600);
      v32[4] = v39;
      v40 = *(_QWORD *)(v30 + 592);
      v41 = 0.0;
      if (v40 >= 2)
        v41 = *(double *)(v30 + 608) / (double)(v40 - 1);
      v32[5] = v41;
      v32[6] = (float)v33;
      goto LABEL_45;
    case 23780:
      if (!*(_QWORD *)(v5 + 528))
        return 4294956429;
      v29 = (_QWORD *)(v5 + 2248);
LABEL_22:
      CFArray = applesauce::CF::details::make_CFArrayRef<unsigned int>(v29);
      goto LABEL_46;
    case 23781:
      v43 = *(_QWORD *)(v5 + 528);
      if (!v43)
        return 4294956429;
      memcpy(__dst, (const void *)(v43 + 75008), sizeof(__dst));
      v44 = v12 + 2296;
      goto LABEL_29;
    case 23782:
      v45 = *(_QWORD *)(v5 + 528);
      if (!v45)
        return 4294956429;
      memcpy(__dst, (const void *)(v45 + 50420), sizeof(__dst));
      v44 = v12 + 2320;
      goto LABEL_29;
    case 23783:
      v46 = *(_QWORD *)(v5 + 528);
      if (!v46)
        return 4294956429;
      memcpy(__dst, (const void *)(v46 + 58616), sizeof(__dst));
      v44 = v12 + 2344;
LABEL_29:
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v44, __dst, (uint64_t)&v61, 0x801uLL);
      v36 = v44;
LABEL_45:
      CFArray = applesauce::CF::details::make_CFArrayRef<float>(v36);
LABEL_46:
      v59 = CFArray;
      result = 0;
      *v11 = v59;
      return result;
    default:
      return AUDspLib::GetProperty((AUDspLib *)v12, v6, v7, v8, v9, v10);
  }
}

uint64_t AUDspLib::CanScheduleParameters(AUDspLib *this)
{
  return 1;
}

uint64_t AUAmbienceLeveler::ProcessBufferLists(DspLib::AmbienceLeveler::Algorithm **this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  uint64_t v6;
  DspLib::AmbienceLeveler::Algorithm *v7;
  float v8;
  ausdk::AUElement *Element;
  AudioBufferList *v11;
  const AudioBufferList *v12;

  v11 = a4;
  v12 = a3;
  v6 = (*((uint64_t (**)(DspLib::AmbienceLeveler::Algorithm **, unsigned int *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))*this
        + 23))(this, a2, a5, 1, &v12, 1, &v11);
  v7 = this[66];
  if (v7)
  {
    v8 = DspLib::AmbienceLeveler::Algorithm::gainInDecibels(v7);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(this + 4), 0);
    ausdk::AUElement::SetParameter(Element, 0x64u, v8, 0);
  }
  return v6;
}

uint64_t AUAmbienceLeveler::GetParameterInfo(AUAmbienceLeveler *this, unsigned int a2, uint64_t a3, AudioUnitParameterInfo *buffer)
{
  if ((_DWORD)a3 != 100)
    return AUDspLibWithNewParameters::GetParameterInfo(this, a2, a3, buffer);
  buffer->unit = kAudioUnitParameterUnit_Decibels;
  *(_QWORD *)&buffer->minValue = 0x41400000C1C00000;
  *(_QWORD *)&buffer->defaultValue = 0x4980800000000000;
  buffer->cfNameString = CFSTR("Gain");
  CFStringGetCString(CFSTR("Gain"), buffer->name, 52, 0x8000100u);
  return 0;
}

uint64_t AUDspLib::SupportsTail(AUDspLib *this)
{
  return 1;
}

BOOL AUDspLib::StreamFormatWritable(AUDspLib *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUAmbienceLeveler::SupportedNumChannels(AUAmbienceLeveler *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUAmbienceLeveler::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  return 1;
}

uint64_t AUDspLib::GetScopeExtended(AUDspLib *this, int a2)
{
  if (a2 == 4)
    return (uint64_t)this + 1536;
  else
    return 0;
}

uint64_t AUAmbienceLeveler::Version(AUAmbienceLeveler *this)
{
  return 33751040;
}

DspLib::AmbienceLeveler::Algorithm *AUAmbienceLeveler::newDspLibAlgorithm(AUAmbienceLeveler *this)
{
  DspLib::AmbienceLeveler::Algorithm *v1;

  v1 = (DspLib::AmbienceLeveler::Algorithm *)operator new();
  DspLib::AmbienceLeveler::Algorithm::Algorithm(v1);
  return v1;
}

void sub_1B6113BA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10E1C40575DA8B0);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::algorithm(AUDspLib *this, unsigned int a2)
{
  return *((_QWORD *)this + 7 * a2 + 66);
}

uint64_t AUDspLibWithNewParameters::parameterConverters(AUDspLibWithNewParameters *this)
{
  return *((_QWORD *)this + 271);
}

void AUResidualEchoSuppressorV5::~AUResidualEchoSuppressorV5(AUResidualEchoSuppressorV5 *this)
{
  AUResidualEchoSuppressorV5::~AUResidualEchoSuppressorV5(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E69C6A08;
  AUResidualEchoSuppressorV5::Cleanup(this);
  v2 = (void *)*((_QWORD *)this + 83);
  if (v2)
  {
    *((_QWORD *)this + 84) = v2;
    operator delete(v2);
  }
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUResidualEchoSuppressorV5::Initialize(AUResidualEchoSuppressorV5 *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t result;
  unsigned int v9;
  uint64_t Element;
  unsigned int v11;
  uint64_t v12;
  double v13;
  int v14;
  BOOL v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const AudioStreamBasicDescription *v20;
  double v21;
  double v22;
  const AudioStreamBasicDescription *v23;
  double v24;
  FILE **v25;
  FILE *v26;
  const char *v27;
  const AudioStreamBasicDescription *v28;
  const AudioStreamBasicDescription *v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  uint64_t v33;
  ausdk::AUElement *v34;
  ausdk::AUElement **v35;
  uint64_t v36;
  ausdk::AUElement *v37;
  ausdk::AUElement **v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  ausdk::AUElement **v44;
  float v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  ausdk::AUElement **v48;
  float v49;
  uint64_t v50;
  ausdk::AUElement *v51;
  ausdk::AUElement **v52;
  float v53;
  uint64_t v54;
  ausdk::AUElement *v55;
  ausdk::AUElement **v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  ausdk::AUElement **v59;
  uint64_t v60;
  ausdk::AUElement *v61;
  ausdk::AUElement **v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  ausdk::AUElement **v65;
  float v66;
  uint64_t v67;
  ausdk::AUElement *v68;
  ausdk::AUElement **v69;
  float v70;
  uint64_t v71;
  ausdk::AUElement *v72;
  ausdk::AUElement **v73;
  float v74;
  uint64_t v75;
  ausdk::AUElement *v76;
  ausdk::AUElement **v77;
  uint64_t v78;
  ausdk::AUElement *v79;
  ausdk::AUElement **v80;
  uint64_t v81;
  ausdk::AUElement *v82;
  ausdk::AUElement **v83;
  uint64_t v84;
  ausdk::AUElement *v85;
  ausdk::AUElement **v86;
  uint64_t v87;
  ausdk::AUElement *v88;
  ausdk::AUElement **v89;
  uint64_t v90;
  ausdk::AUElement *v91;
  ausdk::AUElement **v92;
  uint64_t v93;
  ausdk::AUElement *v94;
  ausdk::AUElement **v95;
  uint64_t v96;
  ausdk::AUElement *v97;
  ausdk::AUElement **v98;
  uint64_t v99;
  ausdk::AUElement *v100;
  ausdk::AUElement **v101;
  uint64_t v102;
  ausdk::AUElement *v103;
  ausdk::AUElement **v104;
  uint64_t v105;
  ausdk::AUElement *v106;
  ausdk::AUElement **v107;
  BOOL v108;
  uint64_t v109;
  ausdk::AUElement *v110;
  ausdk::AUElement **v111;
  uint64_t v112;
  ausdk::AUElement *v113;
  ausdk::AUElement **v114;
  uint64_t v115;
  ausdk::AUElement *v116;
  ausdk::AUElement **v117;
  uint64_t v118;
  ausdk::AUElement *v119;
  ausdk::AUElement **v120;
  unsigned int v121;
  uint64_t v122;
  ausdk::AUElement *v123;
  ausdk::AUElement **v124;
  uint64_t v125;
  ausdk::AUElement *v126;
  ausdk::AUElement **v127;
  uint64_t v128;
  ausdk::AUElement *v129;
  ausdk::AUElement **v130;
  uint64_t v131;
  ausdk::AUElement *v132;
  ausdk::AUElement **v133;
  uint64_t v134;
  ausdk::AUElement *v135;
  ausdk::AUElement **v136;
  uint64_t v137;
  ausdk::AUElement *v138;
  ausdk::AUElement **v139;
  float v140;
  float v141;
  uint64_t v142;
  ausdk::AUElement *v143;
  ausdk::AUElement **v144;
  uint64_t v145;
  ausdk::AUElement *v146;
  ausdk::AUElement **v147;
  uint64_t v148;
  ausdk::AUElement *v149;
  ausdk::AUElement **v150;
  int mSampleRate;
  float v152;
  float v153;
  float v154;
  float v155;
  float v156;
  float v157;
  float v158;
  NSObject *v159;
  int v160;
  uint64_t v161;
  float v162;
  uint64_t v163;
  unsigned int v164;
  float v165;
  float v166;
  float v167;
  unsigned int v168;
  int v169;
  float v170;
  uint64_t v171;
  uint64_t v172;
  ausdk::AUElement *v173;
  ausdk::AUElement **v174;
  uint64_t v175;
  ausdk::AUElement *v176;
  ausdk::AUElement **v177;
  float v178;
  uint64_t v179;
  uint64_t v180;
  ausdk::AUElement *v181;
  int v182;
  ausdk::AUElement **v183;
  int v184;
  NSObject *v185;
  uint64_t v186;
  float *inited;
  double v188;
  unsigned int v189;
  unsigned int v190;
  float v191;
  unsigned int v192;
  BOOL v193;
  float v194;
  float v195;
  float v196;
  float v197;
  float v198;
  float v199;
  float v200;
  float v201;
  float v202;
  float v203;
  float v204;
  float v205;
  float v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float Parameter;
  float v212;
  float v213;
  int v214;
  int v215;
  BOOL v216[9];

  v2 = *((_QWORD *)this + 15);
  if (v2)
    LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  else
    v3 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  *((_DWORD *)this + 141) = v3;
  v4 = *((_QWORD *)this + 21);
  if (v4)
  {
    LODWORD(v5) = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4 + 24))(*((_QWORD *)this + 21));
    LODWORD(v3) = *((_DWORD *)this + 141);
  }
  else
  {
    v5 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
  }
  *((_DWORD *)this + 142) = v5;
  v6 = v5 - 5;
  if ((v3 - 7) < 0xFFFFFFFC || v6 < 0xFFFFFFFC)
    return 4294956428;
  v9 = 1;
  do
  {
    Element = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), v9 - 1);
    if (*(double *)(Element + 80) != *(double *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), v9)+ 80))return 4294956428;
    ++v9;
  }
  while (v9 < *((_DWORD *)this + 141));
  if (*((_DWORD *)this + 142) >= 2u)
  {
    v11 = 1;
    do
    {
      v12 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), v11 - 1);
      if (*(double *)(v12 + 80) != *(double *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), v11)+ 80))return 4294956428;
    }
    while (++v11 < *((_DWORD *)this + 142));
  }
  v13 = *(double *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0) + 80);
  if (v13 != *(double *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 0) + 80))
    return 4294956428;
  v14 = *((_DWORD *)this + 84);
  *((_DWORD *)this + 138) = v14;
  *((_DWORD *)this + 139) = v14 + 1;
  *((_BYTE *)this + 540) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0)+ 88) == 1718773105;
  *((_BYTE *)this + 541) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 1u)+ 88) == 1718773105;
  *((_BYTE *)this + 542) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 2u)+ 88) == 1718773105;
  if (*((_DWORD *)this + 141) <= 3u)
  {
    *((_BYTE *)this + 543) = 0;
    goto LABEL_26;
  }
  *((_BYTE *)this + 543) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 3u)+ 88) == 1718773105;
  if (*((_DWORD *)this + 141) <= 4u)
  {
LABEL_26:
    *((_BYTE *)this + 544) = 0;
    goto LABEL_27;
  }
  *((_BYTE *)this + 544) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 4u)+ 88) == 1718773105;
  if (*((_DWORD *)this + 141) >= 6u)
  {
    v15 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 5u) + 88) == 1718773105;
    goto LABEL_28;
  }
LABEL_27:
  v15 = 1;
LABEL_28:
  *((_BYTE *)this + 545) = v15;
  *((_BYTE *)this + 546) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 0)+ 88) == 1718773105;
  if (*((_DWORD *)this + 142) <= 1u)
  {
    *((_BYTE *)this + 547) = 1;
    goto LABEL_33;
  }
  *((_BYTE *)this + 547) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 1u)+ 88) == 1718773105;
  if (*((_DWORD *)this + 142) <= 2u)
  {
LABEL_33:
    v16 = 0;
    *((_BYTE *)this + 548) = 0;
    goto LABEL_34;
  }
  *((_BYTE *)this + 548) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 2u)+ 88) == 1718773105;
  v16 = *((_DWORD *)this + 142) >= 4u
     && *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 3u) + 88) == 1718773105;
LABEL_34:
  *((_BYTE *)this + 549) = v16;
  v17 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
  v18 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 1u);
  v19 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 2u);
  v21 = *(double *)(v17 + 80);
  v20 = (const AudioStreamBasicDescription *)(v17 + 80);
  v22 = v21;
  v24 = *(double *)(v18 + 80);
  v23 = (const AudioStreamBasicDescription *)(v18 + 80);
  v216[0] = 0;
  if (v22 != v24)
  {
    v25 = (FILE **)MEMORY[0x1E0C80C10];
    v26 = (FILE *)*MEMORY[0x1E0C80C10];
    v27 = "_vpio_res: check 1 failed!\n";
LABEL_43:
    fwrite(v27, 0x1BuLL, 1uLL, v26);
    fflush(*v25);
    return 4294956428;
  }
  v28 = (const AudioStreamBasicDescription *)v19;
  if (checkASBD(v20, v216))
  {
    v25 = (FILE **)MEMORY[0x1E0C80C10];
    v26 = (FILE *)*MEMORY[0x1E0C80C10];
    v27 = "_vpio_res: check 2 failed!\n";
    goto LABEL_43;
  }
  if (checkASBD(v23, v216))
  {
    v25 = (FILE **)MEMORY[0x1E0C80C10];
    v26 = (FILE *)*MEMORY[0x1E0C80C10];
    v27 = "_vpio_res: check 3 failed!\n";
    goto LABEL_43;
  }
  if (checkASBD(v28 + 2, v216))
  {
    v25 = (FILE **)MEMORY[0x1E0C80C10];
    v26 = (FILE *)*MEMORY[0x1E0C80C10];
    v27 = "_vpio_res: check 4 failed!\n";
    goto LABEL_43;
  }
  if (*((_DWORD *)this + 141) >= 6u)
  {
    v29 = (const AudioStreamBasicDescription *)ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 5u);
    if (checkASBD(v29 + 2, v216))
    {
      v25 = (FILE **)MEMORY[0x1E0C80C10];
      v26 = (FILE *)*MEMORY[0x1E0C80C10];
      v27 = "_vpio_res: check 6 failed!\n";
      goto LABEL_43;
    }
  }
  v30 = *((_QWORD *)this + 9);
  if (v30)
  {
    v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
  }
  else
  {
    v32 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v32)
      v31 = 0;
    else
      v31 = *v32;
  }
  Parameter = ausdk::AUElement::GetParameter(v31, 1u);
  v33 = *((_QWORD *)this + 9);
  if (v33)
  {
    v34 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v33 + 32))(v33, 0);
  }
  else
  {
    v35 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v35)
      v34 = 0;
    else
      v34 = *v35;
  }
  v210 = ausdk::AUElement::GetParameter(v34, 2u);
  v36 = *((_QWORD *)this + 9);
  if (v36)
  {
    v37 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v36 + 32))(v36, 0);
  }
  else
  {
    v38 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v38)
      v37 = 0;
    else
      v37 = *v38;
  }
  *((_DWORD *)this + 140) = ausdk::AUElement::GetParameter(v37, 8u);
  v39 = *((_QWORD *)this + 9);
  if (v39)
  {
    v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
  }
  else
  {
    v41 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v41)
      v40 = 0;
    else
      v40 = *v41;
  }
  v209 = ausdk::AUElement::GetParameter(v40, 9u);
  v42 = *((_QWORD *)this + 9);
  if (v42)
  {
    v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v42 + 32))(v42, 0);
  }
  else
  {
    v44 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v44)
      v43 = 0;
    else
      v43 = *v44;
  }
  v45 = ausdk::AUElement::GetParameter(v43, 0xAu);
  v46 = *((_QWORD *)this + 9);
  if (v46)
  {
    v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 0);
  }
  else
  {
    v48 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v48)
      v47 = 0;
    else
      v47 = *v48;
  }
  v49 = ausdk::AUElement::GetParameter(v47, 0xBu);
  v50 = *((_QWORD *)this + 9);
  if (v50)
  {
    v51 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v50 + 32))(v50, 0);
  }
  else
  {
    v52 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v52)
      v51 = 0;
    else
      v51 = *v52;
  }
  v53 = ausdk::AUElement::GetParameter(v51, 0xCu);
  v54 = *((_QWORD *)this + 9);
  if (v54)
  {
    v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v54 + 32))(v54, 0);
  }
  else
  {
    v56 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v56)
      v55 = 0;
    else
      v55 = *v56;
  }
  v208 = ausdk::AUElement::GetParameter(v55, 0xDu);
  v57 = *((_QWORD *)this + 9);
  if (v57)
  {
    v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v57 + 32))(v57, 0);
  }
  else
  {
    v59 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v59)
      v58 = 0;
    else
      v58 = *v59;
  }
  v207 = ausdk::AUElement::GetParameter(v58, 0xEu);
  v60 = *((_QWORD *)this + 9);
  if (v60)
  {
    v61 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v60 + 32))(v60, 0);
  }
  else
  {
    v62 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v62)
      v61 = 0;
    else
      v61 = *v62;
  }
  v206 = ausdk::AUElement::GetParameter(v61, 0xFu);
  v63 = *((_QWORD *)this + 9);
  if (v63)
  {
    v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v63 + 32))(v63, 0);
  }
  else
  {
    v65 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v65)
      v64 = 0;
    else
      v64 = *v65;
  }
  v66 = ausdk::AUElement::GetParameter(v64, 0x10u);
  v67 = *((_QWORD *)this + 9);
  if (v67)
  {
    v68 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v67 + 32))(v67, 0);
  }
  else
  {
    v69 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v69)
      v68 = 0;
    else
      v68 = *v69;
  }
  v70 = ausdk::AUElement::GetParameter(v68, 0x11u);
  v71 = *((_QWORD *)this + 9);
  if (v71)
  {
    v72 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v71 + 32))(v71, 0);
  }
  else
  {
    v73 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v73)
      v72 = 0;
    else
      v72 = *v73;
  }
  v74 = ausdk::AUElement::GetParameter(v72, 0x12u);
  v75 = *((_QWORD *)this + 9);
  if (v75)
  {
    v76 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v75 + 32))(v75, 0);
  }
  else
  {
    v77 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v77)
      v76 = 0;
    else
      v76 = *v77;
  }
  v213 = ausdk::AUElement::GetParameter(v76, 0x13u);
  v78 = *((_QWORD *)this + 9);
  if (v78)
  {
    v79 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v78 + 32))(v78, 0);
  }
  else
  {
    v80 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v80)
      v79 = 0;
    else
      v79 = *v80;
  }
  v212 = ausdk::AUElement::GetParameter(v79, 0x14u);
  v81 = *((_QWORD *)this + 9);
  if (v81)
  {
    v82 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v81 + 32))(v81, 0);
  }
  else
  {
    v83 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v83)
      v82 = 0;
    else
      v82 = *v83;
  }
  v204 = ausdk::AUElement::GetParameter(v82, 0x15u);
  v84 = *((_QWORD *)this + 9);
  if (v84)
  {
    v85 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v84 + 32))(v84, 0);
  }
  else
  {
    v86 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v86)
      v85 = 0;
    else
      v85 = *v86;
  }
  v205 = ausdk::AUElement::GetParameter(v85, 0x16u);
  v87 = *((_QWORD *)this + 9);
  if (v87)
  {
    v88 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v87 + 32))(v87, 0);
  }
  else
  {
    v89 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v89)
      v88 = 0;
    else
      v88 = *v89;
  }
  v203 = ausdk::AUElement::GetParameter(v88, 0x17u);
  v90 = *((_QWORD *)this + 9);
  if (v90)
  {
    v91 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v90 + 32))(v90, 0);
  }
  else
  {
    v92 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v92)
      v91 = 0;
    else
      v91 = *v92;
  }
  v202 = ausdk::AUElement::GetParameter(v91, 0x18u);
  v93 = *((_QWORD *)this + 9);
  if (v93)
  {
    v94 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v93 + 32))(v93, 0);
  }
  else
  {
    v95 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v95)
      v94 = 0;
    else
      v94 = *v95;
  }
  v199 = ausdk::AUElement::GetParameter(v94, 0x19u);
  v96 = *((_QWORD *)this + 9);
  if (v96)
  {
    v97 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v96 + 32))(v96, 0);
  }
  else
  {
    v98 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v98)
      v97 = 0;
    else
      v97 = *v98;
  }
  v201 = ausdk::AUElement::GetParameter(v97, 0x1Au);
  v99 = *((_QWORD *)this + 9);
  if (v99)
  {
    v100 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v99 + 32))(v99, 0);
  }
  else
  {
    v101 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v101)
      v100 = 0;
    else
      v100 = *v101;
  }
  v200 = ausdk::AUElement::GetParameter(v100, 0x1Bu);
  v102 = *((_QWORD *)this + 9);
  if (v102)
  {
    v103 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v102 + 32))(v102, 0);
  }
  else
  {
    v104 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v104)
      v103 = 0;
    else
      v103 = *v104;
  }
  v198 = ausdk::AUElement::GetParameter(v103, 0x1Cu);
  v105 = *((_QWORD *)this + 9);
  if (v105)
  {
    v106 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v105 + 32))(v105, 0);
  }
  else
  {
    v107 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v107)
      v106 = 0;
    else
      v106 = *v107;
  }
  v108 = ausdk::AUElement::GetParameter(v106, 0x25u) != 0.0;
  *((_BYTE *)this + 616) = v108;
  *((_BYTE *)this + 617) = v108;
  v109 = *((_QWORD *)this + 9);
  if (v109)
  {
    v110 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v109 + 32))(v109, 0);
  }
  else
  {
    v111 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v111)
      v110 = 0;
    else
      v110 = *v111;
  }
  *((_BYTE *)this + 618) = ausdk::AUElement::GetParameter(v110, 0x26u) != 0.0;
  v112 = *((_QWORD *)this + 9);
  if (v112)
  {
    v113 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v112 + 32))(v112, 0);
  }
  else
  {
    v114 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v114)
      v113 = 0;
    else
      v113 = *v114;
  }
  *((_DWORD *)this + 155) = (int)ausdk::AUElement::GetParameter(v113, 0x27u);
  v115 = *((_QWORD *)this + 9);
  if (v115)
  {
    v116 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v115 + 32))(v115, 0);
  }
  else
  {
    v117 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v117)
      v116 = 0;
    else
      v116 = *v117;
  }
  *((float *)this + 156) = ausdk::AUElement::GetParameter(v116, 0x28u);
  v118 = *((_QWORD *)this + 9);
  if (v118)
  {
    v119 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v118 + 32))(v118, 0);
  }
  else
  {
    v120 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v120)
      v119 = 0;
    else
      v119 = *v120;
  }
  v121 = ausdk::AUElement::GetParameter(v119, 0x2Bu);
  if (v121 >= 2)
    v121 = 2;
  *((_DWORD *)this + 157) = v121;
  v122 = *((_QWORD *)this + 9);
  if (v122)
  {
    v123 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v122 + 32))(v122, 0);
  }
  else
  {
    v124 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v124)
      v123 = 0;
    else
      v123 = *v124;
  }
  *((_BYTE *)this + 640) = ausdk::AUElement::GetParameter(v123, 0x2Cu) != 0.0;
  v125 = *((_QWORD *)this + 9);
  if (v125)
  {
    v126 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v125 + 32))(v125, 0);
  }
  else
  {
    v127 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v127)
      v126 = 0;
    else
      v126 = *v127;
  }
  *((float *)this + 161) = ausdk::AUElement::GetParameter(v126, 0x2Du);
  v128 = *((_QWORD *)this + 9);
  if (v128)
  {
    v129 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v128 + 32))(v128, 0);
  }
  else
  {
    v130 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v130)
      v129 = 0;
    else
      v129 = *v130;
  }
  *((_DWORD *)this + 162) = (int)ausdk::AUElement::GetParameter(v129, 0x2Eu);
  v131 = *((_QWORD *)this + 9);
  if (v131)
  {
    v132 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v131 + 32))(v131, 0);
  }
  else
  {
    v133 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v133)
      v132 = 0;
    else
      v132 = *v133;
  }
  *((_DWORD *)this + 163) = (int)ausdk::AUElement::GetParameter(v132, 0x2Fu);
  v134 = *((_QWORD *)this + 9);
  if (v134)
  {
    v135 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v134 + 32))(v134, 0);
  }
  else
  {
    v136 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v136)
      v135 = 0;
    else
      v135 = *v136;
  }
  *((_DWORD *)this + 173) = ausdk::AUElement::GetParameter(v135, 0x30u);
  v137 = *((_QWORD *)this + 9);
  if (v137)
  {
    v138 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v137 + 32))(v137, 0);
  }
  else
  {
    v139 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v139)
      v138 = 0;
    else
      v138 = *v139;
  }
  v140 = ausdk::AUElement::GetParameter(v138, 0x31u);
  v141 = 0.0;
  if (v140 >= 0.0)
  {
    v141 = 1.0;
    if (v140 <= 1.0)
      v141 = v140;
  }
  *((float *)this + 174) = v141;
  if (*((_BYTE *)this + 616))
  {
    if (*((_DWORD *)this + 163) == 1)
      *((_DWORD *)this + 162) = 0;
  }
  else
  {
    *((_BYTE *)this + 617) = 0;
    *((_QWORD *)this + 81) = 0;
  }
  if (*((_DWORD *)this + 157) == 2)
  {
    *((_BYTE *)this + 617) = 0;
    *((_QWORD *)this + 81) = 0;
  }
  v142 = *((_QWORD *)this + 9);
  if (v142)
  {
    v143 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v142 + 32))(v142, 0);
  }
  else
  {
    v144 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v144)
      v143 = 0;
    else
      v143 = *v144;
  }
  v196 = ausdk::AUElement::GetParameter(v143, 0x1Eu);
  v145 = *((_QWORD *)this + 9);
  if (v145)
  {
    v146 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v145 + 32))(v145, 0);
  }
  else
  {
    v147 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v147)
      v146 = 0;
    else
      v146 = *v147;
  }
  v195 = ausdk::AUElement::GetParameter(v146, 0x1Du);
  v148 = *((_QWORD *)this + 9);
  if (v148)
  {
    v149 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v148 + 32))(v148, 0);
  }
  else
  {
    v150 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v150)
      v149 = 0;
    else
      v149 = *v150;
  }
  v197 = ausdk::AUElement::GetParameter(v149, 0x1Fu);
  mSampleRate = v20->mSampleRate;
  (*(void (**)(AUResidualEchoSuppressorV5 *))(*(_QWORD *)this + 64))(this);
  v152 = __exp10f(v45 * 0.1);
  v194 = __exp10f(v49 * 0.1);
  v153 = __exp10f(v53 * 0.1);
  v154 = __exp10f(v66 * 0.1);
  v155 = __exp10f(v70 * 0.1);
  v156 = __exp10f(v74 * 0.1);
  v157 = __exp10f(v213 * 0.1);
  v158 = __exp10f(v212 * 0.1);
  v159 = CResidualSuppressorV3::speex_preprocess_state_res_init((CResidualSuppressorV3 *)*((unsigned int *)this + 84), mSampleRate);
  *((_QWORD *)this + 72) = v159;
  if (!v159)
    return 4294956421;
  v214 = mSampleRate;
  v160 = (int)v196;
  HIDWORD(v159[28].isa) = *((_DWORD *)this + 173);
  LODWORD(v159[29].isa) = *((_DWORD *)this + 174);
  CResidualSuppressorV4::speex_preprocess_state_res_initV4((CResidualSuppressorV4 *)v159);
  *((_QWORD *)this + 73) = v161;
  *(_BYTE *)(*((_QWORD *)this + 72) + 736) = *((_BYTE *)this + 700);
  v162 = __exp10f(*((float *)this + 176) * 0.1);
  v163 = *((_QWORD *)this + 72);
  *(float *)(v163 + 740) = v162;
  *(int32x2_t *)(v163 + 36) = vneg_s32(vabs_s32((int32x2_t)__PAIR64__((int)v210, (int)Parameter)));
  *(_DWORD *)(v163 + 44) = *((_DWORD *)this + 140);
  *(_DWORD *)(v163 + 496) = v209;
  *(float *)(v163 + 500) = v152;
  *(float *)(v163 + 504) = v194;
  *(float *)(v163 + 508) = v153;
  *(float *)(v163 + 556) = v208;
  *(float *)(v163 + 512) = v207;
  *(float *)(v163 + 516) = v206;
  *(float *)(v163 + 520) = v154;
  *(float *)(v163 + 524) = v155;
  *(float *)(v163 + 528) = v156;
  *(float *)(v163 + 532) = v157;
  *(float *)(v163 + 536) = v158;
  *(_DWORD *)(v163 + 540) = v204;
  *(float *)(v163 + 548) = v205;
  *(float *)(v163 + 552) = v203;
  *(_DWORD *)(v163 + 572) = v202;
  *(_DWORD *)(v163 + 576) = v199;
  v164 = (float)*(int *)(v163 + 8);
  v165 = (float)*(int *)(v163 + 12) * 0.5;
  v166 = v165 / (float)v164;
  v167 = fmaxf(v201, 300.0);
  if (v167 < v165)
    v165 = v167;
  v168 = vcvtms_u32_f32(v165 / v166);
  if (v168 < v164)
    v164 = v168;
  *(_DWORD *)(v163 + 664) = v164;
  *(float *)(v163 + 668) = v200;
  *(float *)(v163 + 672) = v198;
  *(_DWORD *)v163 = (int)v195;
  if (v160 < 0)
    v169 = (int)v196;
  else
    v169 = -v160;
  *(_DWORD *)(v163 + 32) = v169;
  v170 = __exp10f((float)v169 * 0.1);
  *(float *)(v163 + 56) = v170;
  *(float *)(v163 + 60) = sqrtf(v170);
  v171 = *((_QWORD *)this + 72);
  *(float *)(v171 + 48) = v197;
  *(float *)(v171 + 52) = __exp10f(v197 * 0.1);
  *(_DWORD *)(*((_QWORD *)this + 72) + 220) = 0;
  v172 = *((_QWORD *)this + 9);
  if (v172)
  {
    v173 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v172 + 32))(v172, 0);
  }
  else
  {
    v174 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v174)
      v173 = 0;
    else
      v173 = *v174;
  }
  *(float *)(*((_QWORD *)this + 72) + 688) = ausdk::AUElement::GetParameter(v173, 0x21u);
  v175 = *((_QWORD *)this + 9);
  if (v175)
  {
    v176 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v175 + 32))(v175, 0);
  }
  else
  {
    v177 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v177)
      v176 = 0;
    else
      v176 = *v177;
  }
  v178 = ausdk::AUElement::GetParameter(v176, 0x22u);
  v179 = *((_QWORD *)this + 72);
  *(float *)(v179 + 680) = 1.0
                         - expf(-1.0 / (float)(v178 * (float)((float)*(int *)(v179 + 12) / (float)*(int *)(v179 + 8))));
  v180 = *((_QWORD *)this + 9);
  if (v180)
  {
    v181 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v180 + 32))(v180, 0);
    v182 = v214;
  }
  else
  {
    v183 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    v182 = v214;
    if (*((ausdk::AUElement ***)this + 7) == v183)
      v181 = 0;
    else
      v181 = *v183;
  }
  v184 = (int)ausdk::AUElement::GetParameter(v181, 0x24u);
  if (*((_DWORD *)this + 141) < 4u)
    v184 = 0;
  *(_DWORD *)(*((_QWORD *)this + 73) + 8) = v184;
  v185 = CResidualSuppressorV3::speex_preprocess_state_res_init((CResidualSuppressorV3 *)*((unsigned int *)this + 84), v182);
  *((_QWORD *)this + 74) = v185;
  if (!v185)
    return 4294956421;
  *((float *)&v185[62].isa + 1) = v152;
  CResidualSuppressorV4::speex_preprocess_state_res_initV4((CResidualSuppressorV4 *)v185);
  *((_QWORD *)this + 75) = v186;
  inited = (float *)CResidualSuppressorV5::speex_preprocess_state_res_initV5((CResidualSuppressorV5 *)*((unsigned int *)this + 84), *((unsigned __int8 *)this + 616), *((unsigned __int8 *)this + 640), *((_DWORD *)this + 157), *((_BYTE *)this + 632), *((_BYTE *)this + 633), *((float *)this + 159));
  *((_QWORD *)this + 76) = inited;
  inited[16] = __exp10f(*((float *)this + 161) / 20.0);
  v188 = *(double *)(ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0) + 80);
  v189 = *((_DWORD *)this + 164);
  if (v188 * 0.5 < (double)v189)
    return 4294956445;
  result = 0;
  v190 = *((_DWORD *)this + 84);
  v191 = (float)((float)(v190 * v189) + (float)(v190 * v189)) / v188;
  v192 = vcvtps_u32_f32(v191);
  v193 = v190 > v192;
  if (v190 < v192)
    v192 = *((_DWORD *)this + 84);
  *((_DWORD *)this + 165) = v192;
  if (v193)
  {
    if (v192)
    {
      v215 = 0;
      std::vector<float>::assign((char **)this + 83, 2 * v190, &v215);
      return 0;
    }
  }
  return result;
}

void AUResidualEchoSuppressorV5::Cleanup(AUResidualEchoSuppressorV5 *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  v2 = *((_QWORD *)this + 72);
  if (v2)
  {
    CResidualSuppressorV3::speex_preprocess_state_res_destroy(v2);
    *((_QWORD *)this + 72) = 0;
  }
  v3 = (void *)*((_QWORD *)this + 73);
  if (v3)
  {
    free(v3);
    *((_QWORD *)this + 73) = 0;
  }
  v4 = *((_QWORD *)this + 74);
  if (v4)
  {
    CResidualSuppressorV3::speex_preprocess_state_res_destroy(v4);
    *((_QWORD *)this + 74) = 0;
  }
  v5 = (void *)*((_QWORD *)this + 75);
  if (v5)
  {
    free(v5);
    *((_QWORD *)this + 75) = 0;
  }
  v6 = *((_QWORD *)this + 76);
  if (v6)
  {
    if (*(_QWORD *)v6)
    {
      free(*(void **)v6);
      *(_QWORD *)v6 = 0;
    }
    v7 = *(void **)(v6 + 16);
    if (v7)
    {
      free(v7);
      *(_QWORD *)(v6 + 16) = 0;
    }
    v8 = *(void **)(v6 + 32);
    if (v8)
    {
      free(v8);
      *(_QWORD *)(v6 + 32) = 0;
    }
    v9 = *(void **)(v6 + 48);
    if (v9)
    {
      free(v9);
      *(_QWORD *)(v6 + 48) = 0;
    }
    v10 = *(void **)(v6 + 80);
    if (v10)
    {
      if (!*(_QWORD *)(v6 + 72)
        || (free(*(void **)(v6 + 72)), *(_QWORD *)(v6 + 72) = 0, (v10 = *(void **)(v6 + 80)) != 0))
      {
        free(v10);
        *(_QWORD *)(v6 + 80) = 0;
      }
    }
    v11 = *(void **)(v6 + 88);
    if (v11)
    {
      free(v11);
      *(_QWORD *)(v6 + 88) = 0;
    }
    v12 = *(void **)(v6 + 96);
    if (v12)
      free(v12);
    free((void *)v6);
    *((_QWORD *)this + 76) = 0;
  }
}

uint64_t AUResidualEchoSuppressorV5::Reset(AUResidualEchoSuppressorV5 *this)
{
  return 0;
}

uint64_t AUResidualEchoSuppressorV5::GetPropertyInfo(AUResidualEchoSuppressorV5 *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  int v8;
  char v9;
  int v10;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 8099)
  {
    if (a2 <= 8000)
    {
      if (a2 != 21)
      {
        if (a2 != 3700)
          return result;
        *a6 = 0;
        goto LABEL_23;
      }
      goto LABEL_21;
    }
    if (a2 == 8001)
    {
      v9 = *((_BYTE *)this + 17) ^ 1;
      goto LABEL_22;
    }
    if (a2 != 8010)
    {
      v8 = 8020;
LABEL_12:
      if (a2 != v8)
        return result;
    }
  }
  else
  {
    if (a2 <= 8499)
    {
      if (a2 != 8100 && a2 != 8200)
      {
        v8 = 8300;
        goto LABEL_12;
      }
      *a6 = 0;
LABEL_25:
      v10 = 4 * *((_DWORD *)this + 84) + 4;
      goto LABEL_26;
    }
    if (a2 != 8500 && a2 != 8600)
    {
      if (a2 != 8700)
        return result;
      *a6 = 1;
      goto LABEL_25;
    }
  }
LABEL_21:
  v9 = 1;
LABEL_22:
  *a6 = v9;
LABEL_23:
  v10 = 4;
LABEL_26:
  result = 0;
  *a5 = v10;
  return result;
}

uint64_t AUResidualEchoSuppressorV5::GetProperty(AUResidualEchoSuppressorV5 *this, int a2, int a3, unsigned int a4, _DWORD *__dst)
{
  uint64_t result;
  int v8;
  int v9;
  const void *v10;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 8099)
  {
    if (a2 <= 8000)
    {
      if (a2 == 21)
      {
        v8 = (*(uint64_t (**)(AUResidualEchoSuppressorV5 *))(*(_QWORD *)this + 576))(this);
        result = 0;
      }
      else
      {
        if (a2 != 3700)
          return result;
        result = 0;
        v8 = *((unsigned __int8 *)this + 376);
      }
      goto LABEL_32;
    }
    switch(a2)
    {
      case 8001:
        result = 0;
        v8 = *((_DWORD *)this + 164);
        break;
      case 8010:
        result = 0;
        v8 = *((unsigned __int8 *)this + 700);
        break;
      case 8020:
        result = 0;
        v9 = *((_DWORD *)this + 176);
        goto LABEL_30;
      default:
        return result;
    }
  }
  else
  {
    if (a2 <= 8499)
    {
      if (a2 != 8100)
      {
        if (a2 != 8200)
        {
          if (a2 != 8300)
            return result;
          result = 0;
          v8 = *((unsigned __int8 *)this + 632);
          goto LABEL_32;
        }
        if (*((_BYTE *)this + 17))
        {
          v10 = *(const void **)(*((_QWORD *)this + 76) + 96);
          goto LABEL_24;
        }
        return 0;
      }
LABEL_17:
      if (*((_BYTE *)this + 17))
      {
        v10 = *(const void **)(*((_QWORD *)this + 76) + 88);
LABEL_24:
        memcpy(__dst, v10, 4 * (*((_DWORD *)this + 84) + 1));
      }
      return 0;
    }
    if (a2 != 8500)
    {
      if (a2 != 8600)
      {
        if (a2 != 8700)
          return result;
        goto LABEL_17;
      }
      result = 0;
      v9 = *((_DWORD *)this + 159);
LABEL_30:
      *__dst = v9;
      return result;
    }
    result = 0;
    v8 = *((unsigned __int8 *)this + 633);
  }
LABEL_32:
  *__dst = v8;
  return result;
}

uint64_t AUResidualEchoSuppressorV5::SetProperty(AUResidualEchoSuppressorV5 *this, int a2, int a3, unsigned int a4, float *__src, unsigned int a6)
{
  uint64_t result;
  float v8;
  float v9;
  size_t v10;
  float v11;
  int v12;
  BOOL v13;
  float v14;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 8299)
  {
    if (a2 <= 8599)
    {
      if (a2 == 8300)
      {
        if (a6 == 4)
        {
          result = 0;
          *((_BYTE *)this + 632) = *(_DWORD *)__src != 0;
          return result;
        }
      }
      else
      {
        if (a2 != 8500)
          return result;
        if (a6 == 4)
        {
          result = 0;
          *((_BYTE *)this + 633) = *(_DWORD *)__src != 0;
          return result;
        }
      }
      return 4294956445;
    }
    if (a2 != 8600)
    {
      if (a2 != 8700)
        return result;
      if (*((_BYTE *)this + 17))
      {
        v10 = 4 * (*((_DWORD *)this + 84) + 1);
        if (v10 > a6)
          return 4294956445;
        memcpy(*(void **)(*((_QWORD *)this + 76) + 88), __src, v10);
      }
      return 0;
    }
    if (a6 != 4)
      return 4294956445;
    result = 0;
    v14 = *__src;
    if (*__src < 0.0)
      v14 = 0.0;
    *((float *)this + 159) = v14;
  }
  else
  {
    if (a2 <= 8009)
    {
      if (a2 != 21)
      {
        if (a2 != 8001)
          return result;
        if (*((_BYTE *)this + 17))
          return 4294956447;
        if (a6 >= 4)
        {
          result = 0;
          *((float *)this + 164) = *__src;
          return result;
        }
        return 4294956445;
      }
      if (a6 >= 4)
      {
        v11 = *__src;
        v12 = *(_DWORD *)__src != 0;
        if (v12 != (*(unsigned int (**)(AUResidualEchoSuppressorV5 *))(*(_QWORD *)this + 576))(this))
          (*(void (**)(AUResidualEchoSuppressorV5 *, BOOL))(*(_QWORD *)this + 584))(this, LODWORD(v11) != 0);
        return 0;
      }
      return 4294956445;
    }
    if (a2 == 8010)
    {
      if (a6 == 4)
      {
        v13 = *(_DWORD *)__src != 0;
        *((_BYTE *)this + 700) = v13;
        if (*((_BYTE *)this + 17))
        {
          result = 0;
          *(_BYTE *)(*((_QWORD *)this + 72) + 736) = v13;
          return result;
        }
        return 0;
      }
      return 4294956445;
    }
    if (a2 != 8020)
      return result;
    if (a6 != 4)
      return 4294956445;
    v8 = *__src;
    result = 4294956445;
    if (*__src <= 20.0 && v8 >= 0.0)
    {
      *((float *)this + 176) = v8;
      if (*((_BYTE *)this + 17))
      {
        v9 = __exp10f(v8 * 0.1);
        result = 0;
        *(float *)(*((_QWORD *)this + 72) + 740) = v9;
        return result;
      }
      return 0;
    }
  }
  return result;
}

uint64_t AUResidualEchoSuppressorV5::SetParameter(AUResidualEchoSuppressorV5 *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  uint64_t v13;
  ausdk::AUElement *Element;
  ausdk::AUElement **v15;
  ausdk::AUScope *Scope;

  if (a2 > 0x30)
    goto LABEL_17;
  if (((1 << a2) & 0x1E156FFFFDF27) == 0)
  {
    if (((1 << a2) & 0x182000000000) != 0)
    {
      if (!*((_BYTE *)this + 17))
        ++*((_DWORD *)this + 133);
      v13 = *((_QWORD *)this + 9);
      if (v13)
      {
        Element = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
      }
      else
      {
        v15 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v15)
          Element = 0;
        else
          Element = *v15;
      }
      goto LABEL_19;
    }
LABEL_17:
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
LABEL_19:
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
    return 0;
  }
  v9 = *((_QWORD *)this + 9);
  if (v9)
  {
    v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
  }
  else
  {
    v11 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v11)
      v10 = 0;
    else
      v10 = *v11;
  }
  ausdk::AUElement::SetParameter(v10, a2, a5, 0);
  ++*((_DWORD *)this + 133);
  return 0;
}

uint64_t AUResidualEchoSuppressorV5::CanScheduleParameters(AUResidualEchoSuppressorV5 *this)
{
  return 0;
}

uint64_t AUResidualEchoSuppressorV5::ProcessMultipleBufferLists(AUResidualEchoSuppressorV5 *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  unsigned int v10;
  AudioBufferList *v11;
  unsigned int mDataByteSize;
  AudioBufferList *v13;
  void *mData;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  float Parameter;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  float v25;
  uint64_t v26;
  ausdk::AUElement *v27;
  ausdk::AUElement **v28;
  float v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  float v33;
  uint64_t v34;
  ausdk::AUElement *v35;
  ausdk::AUElement **v36;
  float v37;
  uint64_t v38;
  ausdk::AUElement *v39;
  ausdk::AUElement **v40;
  float v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  ausdk::AUElement **v44;
  float v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  ausdk::AUElement **v48;
  uint64_t v49;
  ausdk::AUElement *v50;
  ausdk::AUElement **v51;
  uint64_t v52;
  ausdk::AUElement *v53;
  ausdk::AUElement **v54;
  uint64_t v55;
  ausdk::AUElement *v56;
  ausdk::AUElement **v57;
  uint64_t v58;
  ausdk::AUElement *v59;
  ausdk::AUElement **v60;
  uint64_t v61;
  ausdk::AUElement *v62;
  ausdk::AUElement **v63;
  uint64_t v64;
  ausdk::AUElement *v65;
  ausdk::AUElement **v66;
  uint64_t v67;
  ausdk::AUElement *v68;
  ausdk::AUElement **v69;
  uint64_t v70;
  ausdk::AUElement *v71;
  ausdk::AUElement **v72;
  float v73;
  uint64_t v74;
  ausdk::AUElement *v75;
  ausdk::AUElement **v76;
  uint64_t v77;
  ausdk::AUElement *v78;
  ausdk::AUElement **v79;
  uint64_t v80;
  ausdk::AUElement *v81;
  ausdk::AUElement **v82;
  int v83;
  unsigned int v84;
  unsigned int v85;
  uint64_t v86;
  ausdk::AUElement *v87;
  ausdk::AUElement **v88;
  float v89;
  uint64_t v90;
  uint64_t v91;
  ausdk::AUElement *v92;
  ausdk::AUElement **v93;
  uint64_t v94;
  ausdk::AUElement *v95;
  ausdk::AUElement **v96;
  uint64_t v97;
  ausdk::AUElement *v98;
  ausdk::AUElement **v99;
  uint64_t v100;
  ausdk::AUElement *v101;
  ausdk::AUElement **v102;
  float v103;
  uint64_t v104;
  ausdk::AUElement *v105;
  ausdk::AUElement **v106;
  unsigned int v107;
  unsigned int v108;
  int v109;
  int v110;
  uint64_t v111;
  ausdk::AUElement *v112;
  ausdk::AUElement **v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  uint64_t v122;
  unsigned int v123;
  float v124;
  float v125;
  float v126;
  unsigned int v127;
  int v128;
  float v129;
  uint64_t v130;
  float v131;
  uint64_t v132;
  ausdk::AUElement *v133;
  ausdk::AUElement **v134;
  uint64_t v135;
  ausdk::AUElement *v136;
  ausdk::AUElement **v137;
  float v138;
  uint64_t v139;
  uint64_t v140;
  ausdk::AUElement *v141;
  ausdk::AUElement **v142;
  int v143;
  _DWORD *v144;
  uint64_t v145;
  ausdk::AUElement *v146;
  ausdk::AUElement **v147;
  BOOL v149;
  uint64_t v150;
  ausdk::AUElement *v151;
  ausdk::AUElement **v152;
  uint64_t v153;
  ausdk::AUElement *v154;
  ausdk::AUElement **v155;
  uint64_t v156;
  ausdk::AUElement *v157;
  ausdk::AUElement **v158;
  uint64_t v159;
  ausdk::AUElement *v160;
  ausdk::AUElement **v161;
  unsigned int v162;
  uint64_t v163;
  ausdk::AUElement *v164;
  ausdk::AUElement **v165;
  uint64_t v166;
  ausdk::AUElement *v167;
  ausdk::AUElement **v168;
  uint64_t v169;
  ausdk::AUElement *v170;
  ausdk::AUElement **v171;
  uint64_t v172;
  ausdk::AUElement *v173;
  ausdk::AUElement **v174;
  uint64_t v175;
  ausdk::AUElement *v176;
  ausdk::AUElement **v177;
  int v178;
  uint64_t v179;
  ausdk::AUElement *v180;
  ausdk::AUElement **v181;
  float v182;
  uint64_t v183;
  ausdk::AUElement *v184;
  ausdk::AUElement **v185;
  float v186;
  uint64_t v187;
  ausdk::AUElement *v188;
  ausdk::AUElement **v189;
  float v190;
  uint64_t v191;
  ausdk::AUElement *v192;
  ausdk::AUElement **v193;
  float v194;
  uint64_t v195;
  ausdk::AUElement *v196;
  ausdk::AUElement **v197;
  float v198;
  uint64_t v199;
  ausdk::AUElement *v200;
  ausdk::AUElement **v201;
  int v202;
  float v203;
  int v204;
  int v205;
  uint64_t v206;
  ausdk::AUElement *v207;
  ausdk::AUElement **v208;
  float v209;
  int *v210;
  uint64_t v211;
  ausdk::AUElement *v212;
  ausdk::AUElement **v213;
  float v214;
  float v215;
  uint64_t v216;
  float *v217;
  float *v218;
  float *v219;
  float *v220;
  const AudioBufferList *v221;
  float *v222;
  float *v223;
  char *v224;
  float *v225;
  float *v226;
  uint64_t v227;
  float v228;
  int v229;
  vDSP_Length v230;
  float *v231;
  const float *v232;
  float *v233;
  unsigned int v234;
  const AudioBufferList *v235;
  const float *v236;
  const AudioBufferList *v237;
  uint64_t v238;
  int *v239;
  _BOOL4 v242;
  unsigned __int8 v244;
  _BOOL4 v245;
  AudioBufferList **v246;
  AudioBufferList *v248;
  _BOOL4 v249;
  char v250;
  uint64_t v251;
  const void *v252;
  const void *v253;
  char *v254;
  uint64_t v255;
  char *v256;
  AudioBufferList *v257;
  float *v258;
  char v259;
  const AudioBufferList *v260;
  BOOL v261;
  uint64_t v262;
  char *v263;
  uint64_t v264;
  const void *v265;
  const void *v266;
  char *v267;
  uint64_t v268;
  char *v269;
  AudioBufferList *v270;
  float *v271;
  char v272;
  const AudioBufferList *v273;
  const void *v274;
  float *v275;
  vDSP_Length v276;
  AudioBufferList *v277;
  unsigned int v278;
  void *v279;
  uint64_t v280;
  ausdk::AUElement *v281;
  ausdk::AUElement **v282;
  uint64_t v283;
  uint64_t v284;
  ausdk::AUElement *v285;
  ausdk::AUElement **v286;
  uint64_t v288;
  float v289;
  float v290;
  float v291;
  float v292;
  float v293;
  float v294;
  float v295;
  float v296;
  float v297;
  float v298;
  float v299;
  float v300;
  float *v301;
  float *v302;
  const AudioBufferList **v303;
  AudioBufferList **v304;
  float __A;
  const void *v306[2];
  DSPSplitComplex v307;
  float *v308[2];
  DSPSplitComplex __B;
  uint64_t v310;

  v310 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 84) != a3)
    return 4294956422;
  if ((*(unsigned int (**)(AUResidualEchoSuppressorV5 *, unsigned int *))(*(_QWORD *)this + 576))(this, a2))
  {
    v10 = *((_DWORD *)this + 142);
    if (v10 >= 3)
    {
      v11 = a7[2];
      mDataByteSize = v11->mBuffers[0].mDataByteSize;
      if (mDataByteSize >= 4)
        memset_pattern16(v11->mBuffers[0].mData, &unk_1B6627B80, mDataByteSize & 0xFFFFFFFC);
      if (v10 >= 4)
        vDSP_vclr((float *)a7[3]->mBuffers[0].mData, 1, *((unsigned int *)this + 138));
    }
    if (*((unsigned __int8 *)this + 540) == *((unsigned __int8 *)this + 546))
    {
      memcpy((*a7)->mBuffers[0].mData, (*a5)->mBuffers[0].mData, (*a7)->mBuffers[0].mDataByteSize);
      if (*((_DWORD *)this + 142) >= 2u)
      {
        v13 = a7[1];
        if (v13)
        {
          mData = v13->mBuffers[0].mData;
          if (mData)
            memcpy(mData, a5[1]->mBuffers[0].mData, v13->mBuffers[0].mDataByteSize);
        }
      }
    }
    else
    {
      bzero((*a7)->mBuffers[0].mData, (*a7)->mBuffers[0].mDataByteSize);
    }
    return 0;
  }
  v16 = *((_DWORD *)this + 133);
  v17 = *((_DWORD *)this + 134);
  v303 = a5;
  v304 = a7;
  if (v16 != v17)
  {
    v18 = *((_QWORD *)this + 9);
    if (v18)
    {
      v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
    }
    else
    {
      v20 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v20)
        v19 = 0;
      else
        v19 = *v20;
    }
    Parameter = ausdk::AUElement::GetParameter(v19, 1u);
    v22 = *((_QWORD *)this + 9);
    if (v22)
    {
      v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
    }
    else
    {
      v24 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v24)
        v23 = 0;
      else
        v23 = *v24;
    }
    v25 = ausdk::AUElement::GetParameter(v23, 2u);
    v26 = *((_QWORD *)this + 9);
    if (v26)
    {
      v27 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 32))(v26, 0);
    }
    else
    {
      v28 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v28)
        v27 = 0;
      else
        v27 = *v28;
    }
    v29 = ausdk::AUElement::GetParameter(v27, 8u);
    v30 = *((_QWORD *)this + 9);
    if (v30)
    {
      v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
    }
    else
    {
      v32 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v32)
        v31 = 0;
      else
        v31 = *v32;
    }
    v33 = ausdk::AUElement::GetParameter(v31, 9u);
    v34 = *((_QWORD *)this + 9);
    if (v34)
    {
      v35 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v34 + 32))(v34, 0);
    }
    else
    {
      v36 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v36)
        v35 = 0;
      else
        v35 = *v36;
    }
    v37 = ausdk::AUElement::GetParameter(v35, 0xAu);
    v38 = *((_QWORD *)this + 9);
    if (v38)
    {
      v39 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v38 + 32))(v38, 0);
    }
    else
    {
      v40 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v40)
        v39 = 0;
      else
        v39 = *v40;
    }
    v41 = ausdk::AUElement::GetParameter(v39, 0xBu);
    v42 = *((_QWORD *)this + 9);
    if (v42)
    {
      v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v42 + 32))(v42, 0);
    }
    else
    {
      v44 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v44)
        v43 = 0;
      else
        v43 = *v44;
    }
    v45 = ausdk::AUElement::GetParameter(v43, 0xCu);
    v46 = *((_QWORD *)this + 9);
    if (v46)
    {
      v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 0);
    }
    else
    {
      v48 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v48)
        v47 = 0;
      else
        v47 = *v48;
    }
    LODWORD(v302) = ausdk::AUElement::GetParameter(v47, 0xDu);
    v49 = *((_QWORD *)this + 9);
    if (v49)
    {
      v50 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v49 + 32))(v49, 0);
    }
    else
    {
      v51 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v51)
        v50 = 0;
      else
        v50 = *v51;
    }
    LODWORD(v301) = ausdk::AUElement::GetParameter(v50, 0xEu);
    v52 = *((_QWORD *)this + 9);
    if (v52)
    {
      v53 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v52 + 32))(v52, 0);
    }
    else
    {
      v54 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v54)
        v53 = 0;
      else
        v53 = *v54;
    }
    v300 = ausdk::AUElement::GetParameter(v53, 0xFu);
    v55 = *((_QWORD *)this + 9);
    if (v55)
    {
      v56 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v55 + 32))(v55, 0);
    }
    else
    {
      v57 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v57)
        v56 = 0;
      else
        v56 = *v57;
    }
    v299 = ausdk::AUElement::GetParameter(v56, 0x10u);
    v58 = *((_QWORD *)this + 9);
    if (v58)
    {
      v59 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v58 + 32))(v58, 0);
    }
    else
    {
      v60 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v60)
        v59 = 0;
      else
        v59 = *v60;
    }
    v298 = ausdk::AUElement::GetParameter(v59, 0x11u);
    v61 = *((_QWORD *)this + 9);
    if (v61)
    {
      v62 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v61 + 32))(v61, 0);
    }
    else
    {
      v63 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v63)
        v62 = 0;
      else
        v62 = *v63;
    }
    v297 = ausdk::AUElement::GetParameter(v62, 0x12u);
    v64 = *((_QWORD *)this + 9);
    if (v64)
    {
      v65 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v64 + 32))(v64, 0);
    }
    else
    {
      v66 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v66)
        v65 = 0;
      else
        v65 = *v66;
    }
    v296 = ausdk::AUElement::GetParameter(v65, 0x13u);
    v67 = *((_QWORD *)this + 9);
    if (v67)
    {
      v68 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v67 + 32))(v67, 0);
    }
    else
    {
      v69 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v69)
        v68 = 0;
      else
        v68 = *v69;
    }
    v295 = ausdk::AUElement::GetParameter(v68, 0x14u);
    v70 = *((_QWORD *)this + 9);
    if (v70)
    {
      v71 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v70 + 32))(v70, 0);
    }
    else
    {
      v72 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v72)
        v71 = 0;
      else
        v71 = *v72;
    }
    v73 = ausdk::AUElement::GetParameter(v71, 0x15u);
    v74 = *((_QWORD *)this + 9);
    if (v74)
    {
      v75 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v74 + 32))(v74, 0);
    }
    else
    {
      v76 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v76)
        v75 = 0;
      else
        v75 = *v76;
    }
    v294 = ausdk::AUElement::GetParameter(v75, 0x16u);
    v77 = *((_QWORD *)this + 9);
    if (v77)
    {
      v78 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v77 + 32))(v77, 0);
    }
    else
    {
      v79 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v79)
        v78 = 0;
      else
        v78 = *v79;
    }
    v293 = ausdk::AUElement::GetParameter(v78, 0x17u);
    v80 = *((_QWORD *)this + 9);
    if (v80)
    {
      v81 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v80 + 32))(v80, 0);
    }
    else
    {
      v82 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v82)
        v81 = 0;
      else
        v81 = *v82;
    }
    v83 = (int)Parameter;
    v84 = ausdk::AUElement::GetParameter(v81, 0x18u);
    if (*((_DWORD *)this + 141) >= 4u)
      v85 = v84;
    else
      v85 = 0;
    v86 = *((_QWORD *)this + 9);
    if (v86)
    {
      v87 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v86 + 32))(v86, 0);
    }
    else
    {
      v88 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v88)
        v87 = 0;
      else
        v87 = *v88;
    }
    v89 = ausdk::AUElement::GetParameter(v87, 0x19u);
    v90 = *((_QWORD *)this + 72);
    *(int32x2_t *)(v90 + 36) = vneg_s32(vabs_s32((int32x2_t)__PAIR64__((int)v25, v83)));
    *(_DWORD *)(v90 + 44) = v29;
    v91 = *((_QWORD *)this + 9);
    if (v91)
    {
      v92 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v91 + 32))(v91, 0);
    }
    else
    {
      v93 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v93)
        v92 = 0;
      else
        v92 = *v93;
    }
    v292 = ausdk::AUElement::GetParameter(v92, 0x1Au);
    v94 = *((_QWORD *)this + 9);
    if (v94)
    {
      v95 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v94 + 32))(v94, 0);
    }
    else
    {
      v96 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v96)
        v95 = 0;
      else
        v95 = *v96;
    }
    v291 = ausdk::AUElement::GetParameter(v95, 0x1Bu);
    v97 = *((_QWORD *)this + 9);
    if (v97)
    {
      v98 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v97 + 32))(v97, 0);
    }
    else
    {
      v99 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v99)
        v98 = 0;
      else
        v98 = *v99;
    }
    v290 = ausdk::AUElement::GetParameter(v98, 0x1Cu);
    v100 = *((_QWORD *)this + 9);
    if (v100)
    {
      v101 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v100 + 32))(v100, 0);
    }
    else
    {
      v102 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v102)
        v101 = 0;
      else
        v101 = *v102;
    }
    v103 = ausdk::AUElement::GetParameter(v101, 0x1Eu);
    v104 = *((_QWORD *)this + 9);
    if (v104)
    {
      v105 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v104 + 32))(v104, 0);
    }
    else
    {
      v106 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v106)
        v105 = 0;
      else
        v105 = *v106;
    }
    v107 = v33;
    v108 = v89;
    v109 = (int)v103;
    v110 = (int)ausdk::AUElement::GetParameter(v105, 0x1Du);
    v111 = *((_QWORD *)this + 9);
    if (v111)
    {
      v112 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v111 + 32))(v111, 0);
    }
    else
    {
      v113 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v113)
        v112 = 0;
      else
        v112 = *v113;
    }
    v289 = ausdk::AUElement::GetParameter(v112, 0x1Fu);
    v114 = __exp10f(v37 / 10.0);
    v115 = __exp10f(v41 / 10.0);
    v116 = __exp10f(v45 / 10.0);
    v117 = __exp10f(v299 / 10.0);
    v118 = __exp10f(v298 / 10.0);
    v119 = __exp10f(v297 / 10.0);
    v120 = __exp10f(v296 / 10.0);
    v121 = __exp10f(v295 / 10.0);
    v122 = *((_QWORD *)this + 72);
    *(_DWORD *)(v122 + 496) = v107;
    *(float *)(v122 + 500) = v114;
    *(float *)(v122 + 504) = v115;
    *(float *)(v122 + 508) = v116;
    *(_DWORD *)(v122 + 556) = (_DWORD)v302;
    *(_DWORD *)(v122 + 512) = (_DWORD)v301;
    *(float *)(v122 + 516) = v300;
    *(float *)(v122 + 520) = v117;
    *(float *)(v122 + 524) = v118;
    *(float *)(v122 + 528) = v119;
    *(float *)(v122 + 532) = v120;
    *(float *)(v122 + 536) = v121;
    *(_DWORD *)(v122 + 540) = v73;
    *(float *)(v122 + 548) = v294;
    *(float *)(v122 + 552) = v293;
    *(_DWORD *)(v122 + 572) = v85;
    *(_DWORD *)(v122 + 576) = v108;
    v123 = (float)*(int *)(v122 + 8);
    v124 = (float)*(int *)(v122 + 12) * 0.5;
    v125 = v124 / (float)v123;
    v126 = fmaxf(v292, 300.0);
    if (v126 < v124)
      v124 = v126;
    v127 = vcvtms_u32_f32(v124 / v125);
    if (v127 < v123)
      v123 = v127;
    *(_DWORD *)(v122 + 664) = v123;
    *(float *)(v122 + 668) = v291;
    *(float *)(v122 + 672) = v290;
    *(_DWORD *)v122 = v110;
    if (v109 < 0)
      v128 = v109;
    else
      v128 = -v109;
    *(_DWORD *)(v122 + 32) = v128;
    v129 = __exp10f((float)v128 * 0.1);
    *(float *)(v122 + 56) = v129;
    *(float *)(v122 + 60) = sqrtf(v129);
    v130 = *((_QWORD *)this + 72);
    v131 = v289;
    *(float *)(v130 + 48) = v289;
    *(float *)(v130 + 52) = __exp10f(v131 * 0.1);
    v132 = *((_QWORD *)this + 9);
    if (v132)
    {
      v133 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v132 + 32))(v132, 0);
      a5 = v303;
    }
    else
    {
      v134 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      a5 = v303;
      if (*((ausdk::AUElement ***)this + 7) == v134)
        v133 = 0;
      else
        v133 = *v134;
    }
    *(float *)(*((_QWORD *)this + 72) + 688) = ausdk::AUElement::GetParameter(v133, 0x21u);
    v135 = *((_QWORD *)this + 9);
    if (v135)
    {
      v136 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v135 + 32))(v135, 0);
    }
    else
    {
      v137 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v137)
        v136 = 0;
      else
        v136 = *v137;
    }
    v138 = ausdk::AUElement::GetParameter(v136, 0x22u);
    v139 = *((_QWORD *)this + 72);
    *(float *)(v139 + 680) = 1.0
                           - expf(-1.0 / (float)(v138 * (float)((float)*(int *)(v139 + 12) / (float)*(int *)(v139 + 8))));
    v140 = *((_QWORD *)this + 9);
    if (v140)
    {
      v141 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v140 + 32))(v140, 0);
    }
    else
    {
      v142 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v142)
        v141 = 0;
      else
        v141 = *v142;
    }
    v143 = (int)ausdk::AUElement::GetParameter(v141, 0x24u);
    if (*((_DWORD *)this + 141) < 5u)
      v143 = 0;
    *(_DWORD *)(*((_QWORD *)this + 73) + 8) = v143;
    v144 = (_DWORD *)*((_QWORD *)this + 72);
    if (!*v144)
      v144[169] = 0;
    v145 = *((_QWORD *)this + 9);
    if (v145)
    {
      v146 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v145 + 32))(v145, 0);
    }
    else
    {
      v147 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v147)
        v146 = 0;
      else
        v146 = *v147;
    }
    v149 = ausdk::AUElement::GetParameter(v146, 0x25u) != 0.0 && *((_DWORD *)this + 141) > 5u;
    *((_BYTE *)this + 616) = v149;
    v150 = *((_QWORD *)this + 9);
    if (v150)
    {
      v151 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v150 + 32))(v150, 0);
    }
    else
    {
      v152 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v152)
        v151 = 0;
      else
        v151 = *v152;
    }
    *((_BYTE *)this + 618) = ausdk::AUElement::GetParameter(v151, 0x26u) != 0.0;
    v153 = *((_QWORD *)this + 9);
    if (v153)
    {
      v154 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v153 + 32))(v153, 0);
    }
    else
    {
      v155 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v155)
        v154 = 0;
      else
        v154 = *v155;
    }
    *((_DWORD *)this + 155) = (int)ausdk::AUElement::GetParameter(v154, 0x27u);
    v156 = *((_QWORD *)this + 9);
    if (v156)
    {
      v157 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v156 + 32))(v156, 0);
    }
    else
    {
      v158 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v158)
        v157 = 0;
      else
        v157 = *v158;
    }
    *((float *)this + 156) = ausdk::AUElement::GetParameter(v157, 0x28u);
    v159 = *((_QWORD *)this + 9);
    if (v159)
    {
      v160 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v159 + 32))(v159, 0);
    }
    else
    {
      v161 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v161)
        v160 = 0;
      else
        v160 = *v161;
    }
    v162 = ausdk::AUElement::GetParameter(v160, 0x2Bu);
    if (v162 >= 2)
      v162 = 2;
    *((_DWORD *)this + 157) = v162;
    v163 = *((_QWORD *)this + 9);
    if (v163)
    {
      v164 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v163 + 32))(v163, 0);
    }
    else
    {
      v165 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v165)
        v164 = 0;
      else
        v164 = *v165;
    }
    *((_DWORD *)this + 140) = ausdk::AUElement::GetParameter(v164, 8u);
    v166 = *((_QWORD *)this + 9);
    if (v166)
    {
      v167 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v166 + 32))(v166, 0);
    }
    else
    {
      v168 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v168)
        v167 = 0;
      else
        v167 = *v168;
    }
    *((_BYTE *)this + 640) = ausdk::AUElement::GetParameter(v167, 0x2Cu) != 0.0;
    v169 = *((_QWORD *)this + 9);
    if (v169)
    {
      v170 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v169 + 32))(v169, 0);
    }
    else
    {
      v171 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v171)
        v170 = 0;
      else
        v170 = *v171;
    }
    *((float *)this + 161) = ausdk::AUElement::GetParameter(v170, 0x2Du);
    v172 = *((_QWORD *)this + 9);
    if (v172)
    {
      v173 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v172 + 32))(v172, 0);
    }
    else
    {
      v174 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v174)
        v173 = 0;
      else
        v173 = *v174;
    }
    *((_DWORD *)this + 162) = (int)ausdk::AUElement::GetParameter(v173, 0x2Eu);
    v175 = *((_QWORD *)this + 9);
    if (v175)
    {
      v176 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v175 + 32))(v175, 0);
    }
    else
    {
      v177 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v177)
        v176 = 0;
      else
        v176 = *v177;
    }
    v178 = (int)ausdk::AUElement::GetParameter(v176, 0x2Fu);
    *((_DWORD *)this + 163) = v178;
    if (*((_BYTE *)this + 616))
    {
      if (v178 == 1)
        *((_DWORD *)this + 162) = 0;
    }
    else
    {
      v178 = 0;
      *((_BYTE *)this + 617) = 0;
      *((_QWORD *)this + 81) = 0;
    }
    if (*((_DWORD *)this + 157) == 2)
    {
      v178 = 0;
      *((_BYTE *)this + 617) = 0;
      *((_QWORD *)this + 81) = 0;
    }
    *(_DWORD *)(*((_QWORD *)this + 76) + 68) = v178;
    v179 = *((_QWORD *)this + 9);
    if (v179)
    {
      v180 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v179 + 32))(v179, 0);
    }
    else
    {
      v181 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v181)
        v180 = 0;
      else
        v180 = *v181;
    }
    v182 = ausdk::AUElement::GetParameter(v180, 0x30u);
    *((_DWORD *)this + 173) = v182;
    *(_DWORD *)(*((_QWORD *)this + 72) + 228) = v182;
    *((_DWORD *)this + 134) = v16;
  }
  v183 = *((_QWORD *)this + 9);
  if (v183)
  {
    v184 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v183 + 32))(v183, 0);
  }
  else
  {
    v185 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v185)
      v184 = 0;
    else
      v184 = *v185;
  }
  v186 = ausdk::AUElement::GetParameter(v184, 6u);
  v187 = *((_QWORD *)this + 9);
  if (v187)
  {
    v188 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v187 + 32))(v187, 0);
  }
  else
  {
    v189 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v189)
      v188 = 0;
    else
      v188 = *v189;
  }
  v190 = ausdk::AUElement::GetParameter(v188, 7u);
  v191 = *((_QWORD *)this + 9);
  if (v191)
  {
    v192 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v191 + 32))(v191, 0);
  }
  else
  {
    v193 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v193)
      v192 = 0;
    else
      v192 = *v193;
  }
  v194 = ausdk::AUElement::GetParameter(v192, 0xDu);
  v195 = *((_QWORD *)this + 9);
  if (v195)
  {
    v196 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v195 + 32))(v195, 0);
  }
  else
  {
    v197 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v197)
      v196 = 0;
    else
      v196 = *v197;
  }
  v198 = ausdk::AUElement::GetParameter(v196, 0x29u);
  v199 = *((_QWORD *)this + 9);
  if (v199)
  {
    v200 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v199 + 32))(v199, 0);
  }
  else
  {
    v201 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v201)
      v200 = 0;
    else
      v200 = *v201;
  }
  v202 = (int)v186;
  v203 = ausdk::AUElement::GetParameter(v200, 0x2Au);
  v204 = *((unsigned __int8 *)this + 616);
  if (*((_DWORD *)this + 141) >= 6u)
    v205 = *((unsigned __int8 *)this + 616);
  else
    v205 = 0;
  *((_BYTE *)this + 617) = v205;
  if (v204 && *((_BYTE *)this + 618))
  {
    v206 = *((_QWORD *)this + 9);
    if (v206)
    {
      v207 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v206 + 32))(v206, 0);
    }
    else
    {
      v208 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v208)
        v207 = 0;
      else
        v207 = *v208;
    }
    v209 = ausdk::AUElement::GetParameter(v207, 0x27u);
    *((_DWORD *)this + 155) = (int)v209;
    if ((int)v209 != 1)
      goto LABEL_287;
    *((_BYTE *)this + 617) = 1;
  }
  else if (!v205)
  {
    goto LABEL_288;
  }
  if (*((_DWORD *)this + 162) == 1 && (float)(v203 - v198) < *((float *)this + 156))
LABEL_287:
    *((_BYTE *)this + 617) = 0;
LABEL_288:
  v210 = (int *)*((_QWORD *)this + 72);
  v210[122] = v202;
  *((float *)v210 + 123) = v190;
  *((float *)v210 + 139) = v194;
  if (*((_DWORD *)this + 173))
  {
    v211 = *((_QWORD *)this + 9);
    if (v211)
    {
      v212 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v211 + 32))(v211, 0);
    }
    else
    {
      v213 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v213)
        v212 = 0;
      else
        v212 = *v213;
    }
    v214 = ausdk::AUElement::GetParameter(v212, 0x31u);
    v215 = 0.0;
    if (v214 >= 0.0)
    {
      v215 = 1.0;
      if (v214 <= 1.0)
        v215 = v214;
    }
    *((float *)this + 174) = v215;
    v210 = (int *)*((_QWORD *)this + 72);
    *((float *)v210 + 58) = v215;
  }
  v216 = *((unsigned int *)this + 84);
  if (*v210 >= 3)
  {
    v217 = 0;
    v218 = 0;
    v219 = 0;
    v220 = 0;
    v222 = 0;
    v223 = 0;
    goto LABEL_309;
  }
  v217 = (float *)a5[1]->mBuffers[0].mData;
  v218 = &v217[v216];
  v219 = (float *)a5[2]->mBuffers[0].mData;
  v220 = &v219[v216];
  if (*((_DWORD *)this + 141) >= 6u && (v221 = a5[5]) != 0)
  {
    v222 = (float *)v221->mBuffers[0].mData;
    v223 = &v222[v216];
    if (*((_BYTE *)this + 616))
    {
      if (*((_DWORD *)this + 163) == 1)
        *((_DWORD *)this + 162) = 0;
      goto LABEL_307;
    }
  }
  else
  {
    v222 = 0;
    v223 = 0;
    *((_BYTE *)this + 616) = 0;
    *((_DWORD *)this + 157) = 0;
  }
  *((_BYTE *)this + 617) = 0;
  *((_QWORD *)this + 81) = 0;
LABEL_307:
  if (*((_DWORD *)this + 157) == 2)
  {
    *((_BYTE *)this + 617) = 0;
    *((_QWORD *)this + 81) = 0;
  }
LABEL_309:
  v224 = (char *)(*a5)->mBuffers[0].mData;
  v225 = (float *)&v224[4 * v216];
  if (*((_DWORD *)this + 164))
  {
    v226 = (float *)(*a5)->mBuffers[0].mData;
    if ((_DWORD)v216 != *((_DWORD *)this + 165))
    {
      v301 = v220;
      v302 = v218;
      LODWORD(__B.realp) = 1023504128;
      memcpy(*((void **)this + 83), v224, 4 * (2 * v216));
      v226 = (float *)*((_QWORD *)this + 83);
      v225 = &v226[v216];
      *v225 = *v225 * 0.0316;
      v227 = *((unsigned int *)this + 165);
      if (v227 < v216)
      {
        v228 = *(float *)&__B.realp;
        if (*(float *)&__B.realp < 0.5)
          v228 = 0.5;
        v229 = v216 - v227;
        while (1)
        {
          v226[v227] = v228 * v226[v227];
          v225[v227] = v228 * v225[v227];
          v228 = v228 * 0.5;
          if (v228 <= 0.0316)
            break;
          ++v227;
          if (!--v229)
            goto LABEL_320;
        }
        v230 = (v216 - v227);
        v231 = &v225[v227];
        vDSP_vsmul(&v226[v227], 1, (const float *)&__B, &v226[v227], 1, v230);
        v232 = v231;
        v233 = v231;
        a5 = v303;
        vDSP_vsmul(v232, 1, (const float *)&__B, v233, 1, v230);
      }
LABEL_320:
      v218 = v302;
      v220 = v301;
    }
  }
  else
  {
    v226 = (float *)(*a5)->mBuffers[0].mData;
  }
  v234 = *((_DWORD *)this + 141);
  if (v234 < 4)
  {
    v236 = 0;
  }
  else
  {
    v235 = a5[3];
    if (v235)
      v236 = (const float *)v235->mBuffers[0].mData;
    else
      v236 = 0;
    if (v234 >= 5)
    {
      v237 = a5[4];
      if (v237)
      {
        v238 = (uint64_t)v237->mBuffers[0].mData;
        goto LABEL_330;
      }
    }
  }
  v238 = 0;
LABEL_330:
  __B.realp = v217;
  __B.imagp = v218;
  v308[0] = v219;
  v308[1] = v220;
  v307.realp = v222;
  v307.imagp = v223;
  v239 = (int *)*((_QWORD *)this + 72);
  v242 = *v239 < 2 && v217 != 0 && v219 != 0;
  if (*v239 <= 1 && !v242)
  {
    v244 = 0;
    if (v217)
    {
LABEL_346:
      v245 = *((_BYTE *)this + 541) != 0;
      goto LABEL_349;
    }
  }
  else
  {
    v244 = *((_BYTE *)this + 541);
    if (v244)
      v244 = *((_BYTE *)this + 542) != 0;
    if (v217)
      goto LABEL_346;
  }
  v245 = 0;
LABEL_349:
  v246 = v304;
  if (v222)
    LOBYTE(v222) = v234 > 5 && *((_BYTE *)this + 545) != 0;
  v249 = *((_DWORD *)this + 142) >= 2u
      && (v248 = v304[1]) != 0
      && v248->mBuffers[0].mData
      && *((_BYTE *)this + 547) != 0;
  v250 = v244 ^ 1;
  if (*((_BYTE *)this + 540) && v226 && ((v244 ^ 1) & 1) == 0)
  {
    v306[0] = v226;
    v306[1] = v225;
    CResidualSuppressorV5::speex_preprocess_run_freq((uint64_t)v239, v306, &__B, v308, v236, *((float **)this + 73), v238, *((unsigned __int8 *)this + 617), &v307, *((_QWORD *)this + 74), *((float **)this + 75), *((_QWORD *)this + 76), *((_BYTE *)this + 640), *((_DWORD *)this + 157));
    if (!*((_BYTE *)this + 546))
      goto LABEL_399;
    v251 = *((_QWORD *)this + 72);
    v252 = *(const void **)(v251 + 344);
    v253 = *(const void **)(v251 + 352);
    v254 = (char *)(*v304)->mBuffers[0].mData;
    v255 = *((unsigned int *)this + 84);
    v256 = &v254[4 * v255];
    memcpy(v254, v252, 4 * v255);
    memcpy(v256, v253, 4 * *((unsigned int *)this + 84));
    if (*((_DWORD *)this + 142) >= 3u)
      memcpy(v304[2]->mBuffers[0].mData, *(const void **)(*((_QWORD *)this + 72) + 112), 4 * *(int *)(*((_QWORD *)this + 72) + 8));
    if (!v249)
      goto LABEL_399;
    v257 = v304[1];
    v258 = (float *)v257->mBuffers[0].mData;
    v259 = v222 ^ 1;
    if (!*((_BYTE *)this + 617))
      v259 = 1;
    if ((v259 & 1) == 0)
    {
      v260 = v303[5];
LABEL_392:
      memcpy(v257->mBuffers[0].mData, v260->mBuffers[0].mData, v257->mBuffers[0].mDataByteSize);
      goto LABEL_399;
    }
    if (v245)
    {
      v260 = v303[1];
      goto LABEL_392;
    }
    __A = 0.0;
    vDSP_vfill(&__A, v258, 1, (2 * *((_DWORD *)this + 84)));
LABEL_399:
    if (*((_DWORD *)this + 140) == 2)
    {
      v277 = v246[1];
      v278 = v277->mBuffers[0].mDataByteSize;
      if (v278 >= 4)
        memset_pattern16(v277->mBuffers[0].mData, &unk_1B6627B80, v278 & 0xFFFFFFFC);
    }
    v15 = 0;
    goto LABEL_403;
  }
  if (*((_BYTE *)this + 540))
    v261 = 1;
  else
    v261 = v224 == 0;
  if (v261)
    v250 = 1;
  if ((v250 & 1) == 0)
  {
    MEMORY[0x1E0C80A78](v239);
    v263 = (char *)&v288 - ((v262 + 15) & 0x7FFFFFFF0);
    memcpy(v263, v224, 4 * *((unsigned int *)this + 84));
    CResidualSuppressorV5::speex_preprocess_run(*((_QWORD *)this + 72), v263, (uint64_t)&__B, (uint64_t)v308, (uint64_t)v236, *((_QWORD *)this + 73), v238, *((unsigned __int8 *)this + 617), &v307, *((_QWORD *)this + 74), *((float **)this + 75), *((_QWORD *)this + 76), *((_BYTE *)this + 640), *((_DWORD *)this + 157));
    if (*((_BYTE *)this + 546))
    {
      v264 = *((_QWORD *)this + 72);
      v265 = *(const void **)(v264 + 344);
      v266 = *(const void **)(v264 + 352);
      v246 = v304;
      v267 = (char *)(*v304)->mBuffers[0].mData;
      v268 = *((unsigned int *)this + 84);
      v269 = &v267[4 * v268];
      memcpy(v267, v265, 4 * v268);
      memcpy(v269, v266, 4 * *((unsigned int *)this + 84));
      if (*((_DWORD *)this + 142) >= 3u)
        memcpy(v246[2]->mBuffers[0].mData, *(const void **)(*((_QWORD *)this + 72) + 112), 4 * *(int *)(*((_QWORD *)this + 72) + 8));
      if (!v249)
        goto LABEL_399;
      v270 = v246[1];
      v271 = (float *)v270->mBuffers[0].mData;
      v272 = v222 ^ 1;
      if (!*((_BYTE *)this + 617))
        v272 = 1;
      if ((v272 & 1) == 0)
      {
        v273 = v303[5];
LABEL_395:
        memcpy(v270->mBuffers[0].mData, v273->mBuffers[0].mData, v270->mBuffers[0].mDataByteSize);
        goto LABEL_399;
      }
      if (v245)
      {
        v273 = v303[1];
        goto LABEL_395;
      }
      LODWORD(v306[0]) = 0;
      v276 = (2 * *((_DWORD *)this + 84));
      v275 = v271;
    }
    else
    {
      v274 = v263;
      v246 = v304;
      memcpy((*v304)->mBuffers[0].mData, v274, 4 * *((unsigned int *)this + 84));
      if (!v249)
        goto LABEL_399;
      v275 = (float *)v246[1]->mBuffers[0].mData;
      LODWORD(v306[0]) = 0;
      v276 = (2 * *((_DWORD *)this + 84));
    }
    vDSP_vfill((const float *)v306, v275, 1, v276);
    goto LABEL_399;
  }
  v15 = 0xFFFFFFFFLL;
LABEL_403:
  if (*((_DWORD *)this + 142) >= 4u)
  {
    v279 = v246[3]->mBuffers[0].mData;
    if (v279)
      memcpy(v279, *(const void **)(*((_QWORD *)this + 76) + 88), 4 * *((unsigned int *)this + 138));
  }
  v280 = *((_QWORD *)this + 9);
  if (v280)
  {
    v281 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v280 + 32))(v280, 0);
  }
  else
  {
    v282 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v282)
      v281 = 0;
    else
      v281 = *v282;
  }
  ausdk::AUElement::SetParameter(v281, 0x20u, *(float *)(*((_QWORD *)this + 72) + 224), 0);
  v283 = *((_QWORD *)this + 72);
  if (*(int *)v283 >= 1)
  {
    v284 = *((_QWORD *)this + 9);
    if (v284)
    {
      v285 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v284 + 32))(v284, 0);
      v283 = *((_QWORD *)this + 72);
    }
    else
    {
      v286 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v286)
        v285 = 0;
      else
        v285 = *v286;
    }
    ausdk::AUElement::SetParameter(v285, 0x23u, *(float *)(v283 + 676), 0);
  }
  return v15;
}

uint64_t AUResidualEchoSuppressorV5::Render(AUResidualEchoSuppressorV5 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  uint64_t Element;
  ausdk::AUInputElement *v9;
  uint64_t v10;
  ausdk::AUInputElement *v11;
  uint64_t v12;
  uint64_t BufferList;
  uint64_t v15;
  uint64_t v16;
  ausdk::AUInputElement *v17;
  uint64_t v18;
  uint64_t v19;
  ausdk::AUInputElement *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  ausdk::AUInputElement *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  ausdk::AUInputElement *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD v38[7];

  v38[6] = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 84) != (_DWORD)a4)
    return 4294956422;
  if (!ausdk::AUBase::HasInput(this, 0))
    return 4294956420;
  Element = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 128), 0);
  v9 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
  v10 = ausdk::AUInputElement::PullInput(v9, a2, a3, 0, a4);
  if (!(_DWORD)v10)
  {
    if (ausdk::AUBase::HasInput(this, 1u))
    {
      v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 1u);
      v10 = ausdk::AUInputElement::PullInput(v11, a2, a3, 1, a4);
      v12 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 1u);
      BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v12 + 144));
      if ((_DWORD)v10)
        return v10;
    }
    else
    {
      v15 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
      BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v15 + 144));
    }
    v16 = BufferList;
    if (ausdk::AUBase::HasInput(this, 2u))
    {
      v17 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 2u);
      v10 = ausdk::AUInputElement::PullInput(v17, a2, a3, 2, a4);
      v18 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 2u);
      v36 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v18 + 144));
      if ((_DWORD)v10)
        return v10;
    }
    else
    {
      v19 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
      v36 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v19 + 144));
    }
    if (ausdk::AUBase::HasInput(this, 3u))
    {
      v20 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 3u);
      v10 = ausdk::AUInputElement::PullInput(v20, a2, a3, 3, a4);
      v21 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 3u);
      v22 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v21 + 144));
      if ((_DWORD)v10)
        return v10;
    }
    else
    {
      v23 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
      v22 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v23 + 144));
    }
    v24 = v22;
    if (ausdk::AUBase::HasInput(this, 4u))
    {
      v25 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 4u);
      v10 = ausdk::AUInputElement::PullInput(v25, a2, a3, 4, a4);
      v26 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 4u);
      v27 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v26 + 144));
      if ((_DWORD)v10)
        return v10;
    }
    else
    {
      v28 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
      v27 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v28 + 144));
    }
    v29 = v27;
    if (!ausdk::AUBase::HasInput(this, 5u))
    {
      v33 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
      v32 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v33 + 144));
LABEL_27:
      v34 = v32;
      v35 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 0);
      v38[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v35 + 144));
      v38[1] = v16;
      v38[2] = v36;
      v38[3] = v24;
      v38[4] = v29;
      v38[5] = v34;
      v37 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
      return (*(uint64_t (**)(AUResidualEchoSuppressorV5 *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, uint64_t *))(*(_QWORD *)this + 184))(this, a2, a4, 6, v38, 1, &v37);
    }
    v30 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 5u);
    v10 = ausdk::AUInputElement::PullInput(v30, a2, a3, 5, a4);
    v31 = ausdk::AUScope::SafeGetElement((AUResidualEchoSuppressorV5 *)((char *)this + 80), 5u);
    v32 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v31 + 144));
    if (!(_DWORD)v10)
      goto LABEL_27;
  }
  return v10;
}

BOOL AUResidualEchoSuppressorV5::BusCountWritable(AUResidualEchoSuppressorV5 *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AUResidualEchoSuppressorV5::GetParameterInfo(AUResidualEchoSuppressorV5 *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v6;
  AudioUnitParameterUnit v7;
  AudioUnitParameterValue v8;
  AudioUnitParameterValue v9;
  AudioUnitParameterValue v10;
  int v11;

  buffer->unitName = 0;
  buffer->flags = 0x40000000;
  result = 4294956418;
  if (!a2 && a3 <= 0x31)
  {
    v6 = off_1E69C6C88[a3];
    v7 = dword_1B662FCF4[a3];
    v8 = flt_1B662FDBC[a3];
    v9 = flt_1B662FE84[a3];
    v10 = flt_1B662FF4C[a3];
    v11 = dword_1B6630014[a3];
    buffer->cfNameString = v6;
    buffer->flags = 1207959552;
    CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
    result = 0;
    buffer->unit = v7;
    buffer->minValue = v8;
    buffer->maxValue = v9;
    buffer->defaultValue = v10;
    buffer->flags |= v11;
  }
  return result;
}

uint64_t AUResidualEchoSuppressorV5::GetParameterValueStrings(AUResidualEchoSuppressorV5 *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  __int128 *v6;
  CFIndex v7;
  const __CFArray *v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 0;
  if (a2)
    return 4294956430;
  if (a3 == 48)
  {
    v6 = &xmmword_1E69C6C70;
  }
  else
  {
    if (a3 != 43)
    {
      *(_QWORD *)&v9 = CFSTR("Parameter Name Unimplemented");
      v7 = 1;
      goto LABEL_11;
    }
    v6 = &xmmword_1E69C6C58;
  }
  v9 = *v6;
  v10 = *((_QWORD *)v6 + 2);
  v7 = 3;
LABEL_11:
  v8 = CFArrayCreate(0, (const void **)&v9, v7, 0);
  result = 0;
  *a4 = v8;
  return result;
}

double AUResidualEchoSuppressorV5::GetLatency(AUResidualEchoSuppressorV5 *this)
{
  return 0.0;
}

double AUResidualEchoSuppressorV5::GetTailTime(AUResidualEchoSuppressorV5 *this)
{
  return 0.0;
}

uint64_t AUResidualEchoSuppressorV5::SupportsTail(AUResidualEchoSuppressorV5 *this)
{
  return 1;
}

BOOL AUResidualEchoSuppressorV5::StreamFormatWritable(AUResidualEchoSuppressorV5 *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUResidualEchoSuppressorV5::SupportedNumChannels(AUResidualEchoSuppressorV5 *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUResidualEchoSuppressorV5::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

BOOL AUResidualEchoSuppressorV5::ValidFormat(AUResidualEchoSuppressorV5 *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  int v6;
  _BOOL8 result;
  _BOOL4 v8;
  UInt32 v9;
  UInt32 v10;
  UInt32 v11;
  _BOOL4 v12;
  AudioFormatFlags v13;
  char v14;
  _BOOL4 v15;
  int v16;
  UInt32 mBytesPerPacket;
  UInt32 mBytesPerFrame;
  AudioFormatFlags mFormatFlags;
  UInt32 mBitsPerChannel;
  UInt32 v21;
  int v22;
  _BOOL4 v23;
  _BOOL4 v24;
  int v25;
  int v26;

  if (a4->mChannelsPerFrame != 1)
    return 0;
  v6 = (int)a2;
  result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if (v6 == 1)
  {
    v14 = a4->mFormatID != 1718773105 || result;
    if ((v14 & 1) == 0)
    {
      result = 0;
      if (a3 <= 5 && ((1 << a3) & 0x27) != 0)
      {
        if (a4->mFramesPerPacket == 1)
        {
          v15 = 0;
          v16 = 0;
          mBytesPerPacket = a4->mBytesPerPacket;
          mBytesPerFrame = a4->mBytesPerFrame;
          if (mBytesPerFrame == mBytesPerPacket)
          {
            mFormatFlags = a4->mFormatFlags;
            mBitsPerChannel = a4->mBitsPerChannel;
            v21 = mBitsPerChannel >> 3;
            v22 = 8 * mBytesPerPacket;
            v23 = mBytesPerPacket == 8 && (a4->mFormatFlags & 0x1F84) == 0;
            if ((mFormatFlags & 1) != 0)
            {
              v24 = (a4->mFormatFlags & 0x1F84) == 0;
            }
            else
            {
              v23 = 0;
              v24 = 1;
            }
            if (v22 == mBitsPerChannel)
            {
              v25 = v24;
            }
            else
            {
              v23 = 0;
              v25 = 1;
            }
            v15 = (mFormatFlags & 2) == 0 && v23;
            if ((a4->mFormatFlags & 2) != 0)
              v26 = 1;
            else
              v26 = v25;
            if (v21 <= mBytesPerFrame)
            {
              v16 = v26;
            }
            else
            {
              v15 = 0;
              v16 = 0;
            }
          }
        }
        else
        {
          v15 = 0;
          v16 = 0;
        }
        return v15 & v16;
      }
    }
  }
  else if (v6 == 2 && a3 <= 1 && !result && a4->mFormatID == 1718773105)
  {
    v8 = 0;
    if (a4->mFramesPerPacket == 1 && (v9 = a4->mBytesPerPacket, v10 = a4->mBytesPerFrame, v10 == v9))
    {
      v11 = a4->mBitsPerChannel;
      v12 = 0;
      if (v11 >> 3 <= v10)
      {
        v8 = 0;
        v13 = a4->mFormatFlags;
        v12 = 1;
        if ((v13 & 2) == 0 && 8 * v9 == v11 && (v13 & 1) != 0)
        {
          v12 = (a4->mFormatFlags & 0x1F84) == 0;
          v8 = v9 == 8 && (a4->mFormatFlags & 0x1F84) == 0;
        }
      }
    }
    else
    {
      v12 = 0;
    }
    return v8 && v12;
  }
  return result;
}

uint64_t AUResidualEchoSuppressorV5::ChangeStreamFormat(AUResidualEchoSuppressorV5 *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  unsigned int v6;
  int v7;
  AudioFormatID mFormatID;
  BOOL *v10;

  v6 = a3;
  v7 = a2;
  ausdk::AUBase::ChangeStreamFormat(this, a2, a3, a4, a5);
  if (v7 == 2 && v6 <= 1)
  {
    mFormatID = a5->mFormatID;
    v10 = (BOOL *)this + v6 + 546;
    goto LABEL_8;
  }
  if (v7 == 1 && v6 <= 5 && ((1 << v6) & 0x27) != 0)
  {
    mFormatID = a5->mFormatID;
    v10 = (BOOL *)this + v6 + 540;
LABEL_8:
    *v10 = mFormatID == 1718773105;
  }
  return 0;
}

uint64_t AUResidualEchoSuppressorV5::ShouldBypassEffect(AUResidualEchoSuppressorV5 *this)
{
  return *((unsigned __int8 *)this + 528);
}

uint64_t AUResidualEchoSuppressorV5::SetBypassEffect(uint64_t this, char a2)
{
  *(_BYTE *)(this + 528) = a2;
  return this;
}

uint64_t checkASBD(const AudioStreamBasicDescription *a1, BOOL *a2)
{
  AudioFormatID mFormatID;
  AudioFormatFlags mFormatFlags;
  uint64_t result;

  *a2 = 0;
  mFormatID = a1->mFormatID;
  if (mFormatID != 1819304813 && mFormatID != 1718773105)
    return 0xFFFFFFFFLL;
  mFormatFlags = a1->mFormatFlags;
  if ((mFormatFlags & 2) != 0 || a1->mChannelsPerFrame != 1)
    return 0xFFFFFFFFLL;
  if ((mFormatFlags & 1) == 0)
  {
    if (a1->mBytesPerFrame == 2)
    {
      result = 0;
      *a2 = 1;
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void SeparationBase::SeparationBase(SeparationBase *this, int a2, unsigned int a3, float a4, float a5, float a6, float a7, float a8, float a9, char a10, float a11, int a12, float a13, float a14, float a15, float a16, float a17, float a18, float a19)
{
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  float v51;
  uint64_t v52;
  uint64_t v53;
  double v54;
  double v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  _QWORD *v69;
  _QWORD *v70;
  uint64_t v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  _QWORD *v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  uint64_t v95;
  _QWORD *v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  void *v103;
  void *v104;

  *(_QWORD *)this = off_1E69EA598;
  *((float *)this + 2) = a4;
  *((float *)this + 3) = a5;
  *((float *)this + 4) = 1.0 - a5;
  *((float *)this + 5) = a6;
  *((float *)this + 6) = a7;
  *((float *)this + 7) = a8;
  *((float *)this + 8) = a9;
  *((float *)this + 9) = a11;
  *((_DWORD *)this + 10) = a12;
  *((_DWORD *)this + 11) = a2;
  *((_DWORD *)this + 12) = a3;
  *((_DWORD *)this + 13) = a2 * a2;
  *((_QWORD *)this + 7) = 5;
  *((_DWORD *)this + 16) = 0;
  *((float *)this + 17) = a16;
  *((float *)this + 18) = a15;
  *((float *)this + 19) = a13;
  *((float *)this + 20) = a14;
  *((_BYTE *)this + 92) = a10;
  *((_QWORD *)this + 12) = *(_QWORD *)&a17;
  *((float *)this + 26) = a19;
  *(_OWORD *)((char *)this + 108) = xmmword_1B66A05E0;
  LODWORD(v103) = 1065353216;
  std::vector<float>::vector((_QWORD *)this + 16, a3, &v103);
  v20 = *((unsigned int *)this + 12);
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 19, v20, &v103);
  v21 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 22, v21, &v103);
  v22 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 25, v22, &v103);
  v23 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 28, v23, &v103);
  v24 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 31, v24, &v103);
  v25 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 34, v25, &v103);
  v26 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 37, v26, &v103);
  v27 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 40, v27, &v103);
  v28 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 43, v28, &v103);
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 46, *((unsigned int *)this + 11));
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 49, *((unsigned int *)this + 11));
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 52, *((unsigned int *)this + 11));
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 55, *((unsigned int *)this + 11));
  v29 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 58, v29, &v103);
  v30 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 61, v30, &v103);
  v31 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 64, v31, &v103);
  v32 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 67, v32, &v103);
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 70, *((unsigned int *)this + 13));
  v33 = *((unsigned int *)this + 12);
  v102 = 0;
  std::vector<float>::vector(&v103, v33, &v102);
  std::vector<std::vector<float>>::vector((_QWORD *)this + 73, 2uLL, (uint64_t)&v103);
  if (v103)
  {
    v104 = v103;
    operator delete(v103);
  }
  v34 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 76, v34, &v103);
  v35 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 79, v35, &v103);
  v36 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 82, v36, &v103);
  v37 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 11));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 85, v37, &v103);
  v38 = *((unsigned int *)this + 12);
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 88, v38, &v103);
  v39 = *((unsigned int *)this + 12);
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 91, v39, &v103);
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 94, *((unsigned int *)this + 11));
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 97, *((unsigned int *)this + 11));
  *((_QWORD *)this + 100) = *((_QWORD *)this + 88);
  *((_QWORD *)this + 101) = *((_QWORD *)this + 91);
  v40 = *((unsigned int *)this + 12);
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 102, v40, &v103);
  v41 = *((unsigned int *)this + 11);
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 105, v41, &v103);
  v42 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 108, v42, &v103);
  v43 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 111, v43, &v103);
  v44 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 114, v44, &v103);
  v45 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 117, v45, &v103);
  v46 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 120, v46, &v103);
  v47 = (*((_DWORD *)this + 12) * *((_DWORD *)this + 13));
  LODWORD(v103) = 0;
  std::vector<float>::vector((_QWORD *)this + 123, v47, &v103);
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 126, *((unsigned int *)this + 13));
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 129, *((unsigned int *)this + 13));
  std::vector<DSPSplitComplex>::vector((_QWORD *)this + 132, *((unsigned int *)this + 13));
  v48 = *((unsigned int *)this + 11);
  std::vector<float>::vector(&v103, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  std::vector<std::vector<float>>::vector((_QWORD *)this + 135, v48, (uint64_t)&v103);
  if (v103)
  {
    v104 = v103;
    operator delete(v103);
  }
  v49 = *((unsigned int *)this + 11);
  std::vector<float>::vector(&v103, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  std::vector<std::vector<float>>::vector((_QWORD *)this + 138, v49, (uint64_t)&v103);
  if (v103)
  {
    v104 = v103;
    operator delete(v103);
  }
  v50 = *((unsigned int *)this + 11);
  std::vector<DSPSplitComplex>::vector(&v103, *((unsigned int *)this + 13));
  std::vector<std::vector<DSPSplitComplex>>::vector((_QWORD *)this + 141, v50, (uint64_t)&v103);
  if (v103)
  {
    v104 = v103;
    operator delete(v103);
  }
  v51 = *((float *)this + 2);
  v53 = *((unsigned int *)this + 11);
  v52 = *((unsigned int *)this + 12);
  v54 = (double)v52 + -1.0;
  *((_DWORD *)this + 14) = ((float)(v51 * *((float *)this + 18)) / v54);
  v55 = v51 / (v54 + v54);
  *(float *)&v55 = v55;
  *(uint32x2_t *)((char *)this + 84) = vmin_u32(vcvt_u32_f32(vrnda_f32(vabs_f32(vdiv_f32(*(float32x2_t *)((char *)this + 76), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v55, 0))))), (uint32x2_t)vdup_n_s32((int)v52 - 1));
  if ((_DWORD)v53)
  {
    v56 = 0;
    v57 = *((_QWORD *)this + 22);
    v58 = *((_QWORD *)this + 25);
    v59 = *((_QWORD *)this + 28);
    v60 = *((_QWORD *)this + 31);
    v61 = *((_QWORD *)this + 34);
    v62 = *((_QWORD *)this + 37);
    v63 = *((_QWORD *)this + 40);
    v64 = *((_QWORD *)this + 43);
    v65 = *((_QWORD *)this + 76);
    v66 = (_QWORD *)(*((_QWORD *)this + 97) + 8);
    v67 = (_QWORD *)(*((_QWORD *)this + 46) + 8);
    v68 = *((_QWORD *)this + 79);
    v69 = (_QWORD *)(*((_QWORD *)this + 94) + 8);
    v70 = (_QWORD *)(*((_QWORD *)this + 49) + 8);
    v71 = *((_QWORD *)this + 82);
    v72 = (_QWORD *)(*((_QWORD *)this + 55) + 8);
    v73 = (_QWORD *)(*((_QWORD *)this + 52) + 8);
    v74 = v53;
    v75 = *((_QWORD *)this + 85);
    do
    {
      *(v67 - 1) = v57 + 4 * v56;
      *v67 = v58 + 4 * v56;
      v67 += 2;
      *(v70 - 1) = v59 + 4 * v56;
      *v70 = v60 + 4 * v56;
      v70 += 2;
      *(v73 - 1) = v61 + 4 * v56;
      *v73 = v62 + 4 * v56;
      v73 += 2;
      *(v72 - 1) = v63 + 4 * v56;
      *v72 = v64 + 4 * v56;
      v72 += 2;
      *(v69 - 1) = v65 + 4 * v56;
      *v69 = v68 + 4 * v56;
      v69 += 2;
      *(v66 - 1) = v71 + 4 * v56;
      *v66 = v75 + 4 * v56;
      v66 += 2;
      v56 += v52;
      --v74;
    }
    while (v74);
  }
  if ((_DWORD)v52)
  {
    v76 = 0;
    v77 = *((_QWORD *)this + 102);
    do
    {
      *(float *)(v77 + 4 * v76) = (float)((float)((float)v52 + -1.0)
                                        + (float)((float)v52 + -1.0))
                                * (float)((float)((float)(*((float *)this + 7) * (float)v76)
                                                / (float)v52)
                                        + 1.0);
      ++v76;
    }
    while (v52 != v76);
  }
  if ((_DWORD)v53)
  {
    v78 = 0;
    v79 = *((unsigned int *)this + 13);
    do
    {
      if ((_DWORD)v79)
      {
        v80 = 0;
        v81 = *(_QWORD *)(*((_QWORD *)this + 135) + 24 * v78);
        v82 = *(_QWORD *)(*((_QWORD *)this + 138) + 24 * v78);
        v83 = (_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 141) + 24 * v78) + 8);
        v84 = v79;
        do
        {
          *(v83 - 1) = v81 + 4 * v80;
          *v83 = v82 + 4 * v80;
          v83 += 2;
          v80 += v52;
          --v84;
        }
        while (v84);
      }
      ++v78;
    }
    while (v78 != v53);
  }
  SeparationBase::ResetiV(this);
  v85 = *((unsigned int *)this + 13);
  if ((_DWORD)v85)
  {
    v86 = 0;
    v87 = *((_DWORD *)this + 12);
    v88 = *((_QWORD *)this + 108);
    v89 = *((_QWORD *)this + 117);
    v90 = *((_QWORD *)this + 111);
    v91 = *((_QWORD *)this + 120);
    v92 = *((_QWORD *)this + 114);
    v93 = *((_QWORD *)this + 123);
    v94 = (_QWORD *)(*((_QWORD *)this + 70) + 8);
    v95 = *((_QWORD *)this + 64);
    v96 = (_QWORD *)(*((_QWORD *)this + 126) + 8);
    v97 = (_QWORD *)(*((_QWORD *)this + 132) + 8);
    v98 = (_QWORD *)(*((_QWORD *)this + 129) + 8);
    v99 = *((_QWORD *)this + 67);
    do
    {
      *(v96 - 1) = v88 + 4 * v86;
      *v96 = v89 + 4 * v86;
      *(v98 - 1) = v90 + 4 * v86;
      *v98 = v91 + 4 * v86;
      *(v97 - 1) = v92 + 4 * v86;
      *v97 = v93 + 4 * v86;
      v100 = v95 + 4 * v86;
      v101 = v99 + 4 * v86;
      v86 += v87;
      *(v94 - 1) = v100;
      *v94 = v101;
      v94 += 2;
      v96 += 2;
      v97 += 2;
      v98 += 2;
      --v85;
    }
    while (v85);
  }
  SeparationBase::ResetWA(this);
}

void sub_1B6117E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, void **a10, void **a11, void **a12, void **a13, void **a14, void **a15, void **a16, void **a17, void **a18, uint64_t a19, void **a20,void **a21,void **a22,void **a23,void **a24,void **a25,void **a26,void **a27,void **a28,void **a29,void **a30,void **a31,void **a32,void **a33,void **a34,void **a35)
{
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  void **v38;
  void **v39;
  uint64_t v40;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;

  v42 = *(void **)(v40 - 112);
  if (v42)
  {
    *(_QWORD *)(v40 - 104) = v42;
    operator delete(v42);
  }
  *(_QWORD *)(v40 - 112) = v36;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v40 - 112));
  *(_QWORD *)(v40 - 112) = v37;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v40 - 112));
  v43 = *v39;
  if (*v39)
  {
    v35[133] = v43;
    operator delete(v43);
  }
  v44 = *v38;
  if (*v38)
  {
    v35[130] = v44;
    operator delete(v44);
  }
  v45 = *a9;
  if (*a9)
  {
    v35[127] = v45;
    operator delete(v45);
  }
  v46 = *a10;
  if (*a10)
  {
    v35[124] = v46;
    operator delete(v46);
  }
  v47 = *a11;
  if (*a11)
  {
    v35[121] = v47;
    operator delete(v47);
  }
  v48 = *a12;
  if (*a12)
  {
    v35[118] = v48;
    operator delete(v48);
  }
  v49 = *a13;
  if (*a13)
  {
    v35[115] = v49;
    operator delete(v49);
  }
  v50 = *a14;
  if (*a14)
  {
    v35[112] = v50;
    operator delete(v50);
  }
  v51 = *a15;
  if (*a15)
  {
    v35[109] = v51;
    operator delete(v51);
  }
  v52 = *a16;
  if (*a16)
  {
    v35[106] = v52;
    operator delete(v52);
  }
  v53 = *a27;
  if (*a27)
  {
    v35[103] = v53;
    operator delete(v53);
  }
  v54 = *a28;
  if (*a28)
  {
    v35[98] = v54;
    operator delete(v54);
  }
  v55 = *a29;
  if (*a29)
  {
    v35[95] = v55;
    operator delete(v55);
  }
  v56 = *a17;
  if (*a17)
  {
    v35[92] = v56;
    operator delete(v56);
  }
  v57 = *a18;
  if (*a18)
  {
    v35[89] = v57;
    operator delete(v57);
  }
  v58 = *a30;
  if (*a30)
  {
    v35[86] = v58;
    operator delete(v58);
  }
  v59 = *a31;
  if (*a31)
  {
    v35[83] = v59;
    operator delete(v59);
  }
  v60 = *a32;
  if (*a32)
  {
    v35[80] = v60;
    operator delete(v60);
  }
  v61 = *a33;
  if (*a33)
  {
    v35[77] = v61;
    operator delete(v61);
  }
  *(_QWORD *)(v40 - 112) = a19;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v40 - 112));
  v62 = *a20;
  if (*a20)
  {
    v35[71] = v62;
    operator delete(v62);
  }
  v63 = *a21;
  if (*a21)
  {
    v35[68] = v63;
    operator delete(v63);
  }
  v64 = *a22;
  if (*a22)
  {
    v35[65] = v64;
    operator delete(v64);
  }
  v65 = *a23;
  if (*a23)
  {
    v35[62] = v65;
    operator delete(v65);
  }
  v66 = *a24;
  if (*a24)
  {
    v35[59] = v66;
    operator delete(v66);
  }
  v67 = *a34;
  if (*a34)
  {
    v35[56] = v67;
    operator delete(v67);
  }
  v68 = *a35;
  if (*a35)
  {
    v35[53] = v68;
    operator delete(v68);
  }
  v69 = **(void ***)(v40 - 200);
  if (v69)
  {
    v35[50] = v69;
    operator delete(v69);
  }
  v70 = **(void ***)(v40 - 192);
  if (v70)
  {
    v35[47] = v70;
    operator delete(v70);
  }
  v71 = **(void ***)(v40 - 184);
  if (v71)
  {
    v35[44] = v71;
    operator delete(v71);
  }
  v72 = **(void ***)(v40 - 176);
  if (v72)
  {
    v35[41] = v72;
    operator delete(v72);
  }
  v73 = **(void ***)(v40 - 168);
  if (v73)
  {
    v35[38] = v73;
    operator delete(v73);
  }
  v74 = **(void ***)(v40 - 160);
  if (v74)
  {
    v35[35] = v74;
    operator delete(v74);
  }
  v75 = **(void ***)(v40 - 152);
  if (v75)
  {
    v35[32] = v75;
    operator delete(v75);
  }
  v76 = **(void ***)(v40 - 144);
  if (v76)
  {
    v35[29] = v76;
    operator delete(v76);
  }
  v77 = **(void ***)(v40 - 136);
  if (v77)
  {
    v35[26] = v77;
    operator delete(v77);
  }
  v78 = **(void ***)(v40 - 128);
  if (v78)
  {
    v35[23] = v78;
    operator delete(v78);
  }
  v79 = *a25;
  if (*a25)
  {
    v35[20] = v79;
    operator delete(v79);
  }
  v80 = *a26;
  if (*a26)
  {
    v35[17] = v80;
    operator delete(v80);
  }
  _Unwind_Resume(a1);
}

_QWORD *std::vector<DSPSplitComplex>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<DSPSplitComplex>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 16 * a2);
    a1[1] = &v4[16 * a2];
  }
  return a1;
}

void sub_1B6118388(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<std::vector<DSPSplitComplex>>::vector(_QWORD *a1, unint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = 3 * a2;
    v8 = &v6[3 * a2];
    v9 = 8 * v7;
    do
    {
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      std::vector<DSPSplitComplex>::__init_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(v6, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 4);
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_1B611843C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void SeparationBase::ResetiV(SeparationBase *this)
{
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unsigned int i;
  float v6;
  float v7;
  float __A;

  *((_DWORD *)this + 15) = 0;
  *((_DWORD *)this + 16) = 0;
  if (*((_DWORD *)this + 11))
  {
    v2 = 0;
    do
    {
      vDSP_vclr(*(float **)(*((_QWORD *)this + 135) + 24 * v2), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
      vDSP_vclr(*(float **)(*((_QWORD *)this + 138) + 24 * v2), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
      v3 = *((_DWORD *)this + 11);
      v4 = v2 + 1;
      if (v3)
      {
        for (i = 0; i < v3; ++i)
        {
          if (*((_BYTE *)this + 92))
            v6 = 1.0;
          else
            v6 = (float)v4;
          v7 = (float)(1.0 / *((float *)this + 8)) * v6;
          __A = v7;
          if (*((_DWORD *)this + 10) == 1)
            __A = (float)(1.0 / v7) * (float)(1.0 / v7);
          vDSP_vfill(&__A, (float *)(*(_QWORD *)(*((_QWORD *)this + 135) + 24 * v2) + 4 * (i + i * v3) * *((_DWORD *)this + 12)), 1, *((unsigned int *)this + 12));
          v3 = *((_DWORD *)this + 11);
        }
      }
      ++v2;
    }
    while (v4 < v3);
  }
}

void SeparationBase::ResetWA(SeparationBase *this)
{
  unsigned int v2;
  unsigned int i;

  vDSP_vclr(*((float **)this + 111), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 120), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 114), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 123), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 108), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  vDSP_vclr(*((float **)this + 117), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 13)));
  v2 = *((_DWORD *)this + 11);
  if (v2)
  {
    for (i = 0; i < v2; ++i)
    {
      vDSP_vfill((const float *)this + 27, (float *)(*((_QWORD *)this + 111) + 4 * (i + i * v2) * *((_DWORD *)this + 12)), 1, *((unsigned int *)this + 12));
      vDSP_vfill((const float *)this + 27, (float *)(*((_QWORD *)this + 114) + 4 * (i + i * *((_DWORD *)this + 11)) * *((_DWORD *)this + 12)), 1, *((unsigned int *)this + 12));
      vDSP_vfill((const float *)this + 27, (float *)(*((_QWORD *)this + 108) + 4 * (i + i * *((_DWORD *)this + 11)) * *((_DWORD *)this + 12)), 1, *((unsigned int *)this + 12));
      v2 = *((_DWORD *)this + 11);
    }
  }
}

char *std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

_QWORD *std::vector<DSPSplitComplex>::__init_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<DSPSplitComplex>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B6118734(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<DSPSplitComplex>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void SeparationBase::Cleanup(SeparationBase *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (void *)*((_QWORD *)this + 16);
  v3 = *((_QWORD *)this + 17) - (_QWORD)v2;
  if (v3 >= 1)
    memset_pattern16(v2, &unk_1B6627B80, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
  bzero(*((void **)this + 19), *((_QWORD *)this + 20) - *((_QWORD *)this + 19));
  bzero(*((void **)this + 22), *((_QWORD *)this + 23) - *((_QWORD *)this + 22));
  bzero(*((void **)this + 25), *((_QWORD *)this + 26) - *((_QWORD *)this + 25));
  bzero(*((void **)this + 28), *((_QWORD *)this + 29) - *((_QWORD *)this + 28));
  bzero(*((void **)this + 31), *((_QWORD *)this + 32) - *((_QWORD *)this + 31));
  bzero(*((void **)this + 34), *((_QWORD *)this + 35) - *((_QWORD *)this + 34));
  bzero(*((void **)this + 37), *((_QWORD *)this + 38) - *((_QWORD *)this + 37));
  bzero(*((void **)this + 40), *((_QWORD *)this + 41) - *((_QWORD *)this + 40));
  bzero(*((void **)this + 43), *((_QWORD *)this + 44) - *((_QWORD *)this + 43));
  bzero(*((void **)this + 58), *((_QWORD *)this + 59) - *((_QWORD *)this + 58));
  bzero(*((void **)this + 61), *((_QWORD *)this + 62) - *((_QWORD *)this + 61));
  vec::cleanup<float>((uint64_t *)this + 73);
  bzero(*((void **)this + 76), *((_QWORD *)this + 77) - *((_QWORD *)this + 76));
  bzero(*((void **)this + 79), *((_QWORD *)this + 80) - *((_QWORD *)this + 79));
  bzero(*((void **)this + 82), *((_QWORD *)this + 83) - *((_QWORD *)this + 82));
  bzero(*((void **)this + 85), *((_QWORD *)this + 86) - *((_QWORD *)this + 85));
  bzero(*((void **)this + 88), *((_QWORD *)this + 89) - *((_QWORD *)this + 88));
  bzero(*((void **)this + 91), *((_QWORD *)this + 92) - *((_QWORD *)this + 91));
  bzero(*((void **)this + 102), *((_QWORD *)this + 103) - *((_QWORD *)this + 102));
  bzero(*((void **)this + 105), *((_QWORD *)this + 106) - *((_QWORD *)this + 105));
  vec::cleanup<float>((uint64_t *)this + 135);
  vec::cleanup<float>((uint64_t *)this + 138);
  bzero(*((void **)this + 108), *((_QWORD *)this + 109) - *((_QWORD *)this + 108));
  bzero(*((void **)this + 111), *((_QWORD *)this + 112) - *((_QWORD *)this + 111));
  bzero(*((void **)this + 114), *((_QWORD *)this + 115) - *((_QWORD *)this + 114));
  bzero(*((void **)this + 117), *((_QWORD *)this + 118) - *((_QWORD *)this + 117));
  bzero(*((void **)this + 120), *((_QWORD *)this + 121) - *((_QWORD *)this + 120));
  bzero(*((void **)this + 123), *((_QWORD *)this + 124) - *((_QWORD *)this + 123));
  bzero(*((void **)this + 64), *((_QWORD *)this + 65) - *((_QWORD *)this + 64));
  bzero(*((void **)this + 67), *((_QWORD *)this + 68) - *((_QWORD *)this + 67));
  v4 = *((unsigned int *)this + 12);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = *((_QWORD *)this + 102);
    do
    {
      *(float *)(v6 + 4 * v5) = (float)((float)((float)v4 + -1.0) + (float)((float)v4 + -1.0))
                              * (float)((float)((float)(*((float *)this + 7) * (float)v5)
                                              / (float)v4)
                                      + 1.0);
      ++v5;
    }
    while (v4 != v5);
  }
  SeparationBase::ResetiV(this);
  SeparationBase::ResetWA(this);
}

void vec::cleanup<float>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  unsigned int v4;

  v1 = *a1;
  if (a1[1] != *a1)
  {
    v3 = 0;
    v4 = 1;
    do
    {
      bzero(*(void **)(v1 + 24 * v3), *(_QWORD *)(v1 + 24 * v3 + 8) - *(_QWORD *)(v1 + 24 * v3));
      v3 = v4;
      v1 = *a1;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) > v4++);
  }
}

{
  uint64_t v1;
  uint64_t v3;
  unsigned int v4;

  v1 = *a1;
  if (a1[1] != *a1)
  {
    v3 = 0;
    v4 = 1;
    do
    {
      vec::cleanup<float>((uint64_t *)(v1 + 24 * v3));
      v3 = v4;
      v1 = *a1;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) > v4++);
  }
}

void SeparationBase::ProcessBufferList(SeparationBase *this, const AudioBufferList *a2, AudioBufferList *a3)
{
  unint64_t v6;
  unint64_t v7;
  void **p_mData;
  float v9;
  const float *v10;
  unint64_t v12;
  void **v13;
  void **v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  unint64_t v19;
  void **v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  vDSP_Length v28;
  float v29;
  float *v30;
  float *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  unint64_t v42;
  void **v43;
  DSPSplitComplex v44;
  DSPSplitComplex __C;

  LODWORD(v6) = *((_DWORD *)this + 11);
  if ((_DWORD)v6)
  {
    v7 = 0;
    p_mData = &a2->mBuffers[0].mData;
    v9 = 0.0;
    do
    {
      v10 = (const float *)*p_mData;
      p_mData += 2;
      v9 = cblas_sdsdot(2 * *((_DWORD *)this + 12) - 2, v9, v10, 1, v10, 1);
      ++v7;
      v6 = *((unsigned int *)this + 11);
    }
    while (v7 < v6);
  }
  else
  {
    v9 = 0.0;
  }
  if (v9 > *((float *)this + 30) && (LODWORD(v9) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    if ((_DWORD)v6)
    {
      v18 = 0;
      v19 = 0;
      v20 = &a2->mBuffers[0].mData;
      do
      {
        memcpy(*(void **)(*((_QWORD *)this + 52) + v18 * 8), v20[v18], 4 * *((unsigned int *)this + 12));
        memcpy((void *)(*(_QWORD *)(*((_QWORD *)this + 52) + v18 * 8 + 8) + 4), (char *)v20[v18] + 4 * *((unsigned int *)this + 12), 4 * (*((_DWORD *)this + 12) - 2));
        ++v19;
        v21 = *((unsigned int *)this + 11);
        v18 += 2;
      }
      while (v19 < v21);
      if ((_DWORD)v21)
      {
        v22 = 0;
        v23 = 0;
        do
        {
          vDSP_zrvmul((const DSPSplitComplex *)(*((_QWORD *)this + 52) + v22), 1, *((const float **)this + 102), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 55) + v22), 1, *((unsigned int *)this + 12));
          ++v23;
          v22 += 16;
        }
        while (v23 < *((unsigned int *)this + 11));
      }
    }
    v24 = *((_DWORD *)this + 15);
    if (v24 >= *((_DWORD *)this + 14))
      *((_DWORD *)this + 16) = 1;
    else
      *((_DWORD *)this + 15) = v24 + 1;
    SeparationBase::GenerateOutput((uint64_t)this, (_QWORD *)this + 55, (float ***)this + 46);
    if (*((_DWORD *)this + 11))
    {
      v25 = 0;
      v26 = 0;
      v27 = *((unsigned int *)this + 21);
      v28 = (*((_DWORD *)this + 22) - v27);
      do
      {
        LODWORD(__C.realp) = 0;
        LODWORD(v44.realp) = 0;
        vDSP_svesq((const float *)(*(_QWORD *)(*((_QWORD *)this + 46) + v25) + 4 * v27), 1, (float *)&__C, v28);
        vDSP_svesq((const float *)(*(_QWORD *)(*((_QWORD *)this + 46) + v25 + 8) + 4 * v27), 1, (float *)&v44, v28);
        v29 = *((float *)this + 6);
        *(float *)(*((_QWORD *)this + 105) + 4 * v26++) = v29
                                                        + powf((float)(*(float *)&__C.realp + *(float *)&v44.realp)+ *((float *)this + 30), *((float *)this + 5));
        v25 += 16;
      }
      while (v26 < *((unsigned int *)this + 11));
    }
    (*(void (**)(SeparationBase *))(*(_QWORD *)this + 8))(this);
    if (*((_DWORD *)this + 16))
      (**(void (***)(SeparationBase *))this)(this);
    SeparationBase::GenerateOutput((uint64_t)this, (_QWORD *)this + 52, (float ***)this + 49);
    v30 = (float *)*((_QWORD *)this + 37);
    __C.realp = (float *)*((_QWORD *)this + 34);
    __C.imagp = v30;
    v31 = (float *)*((_QWORD *)this + 31);
    v44.realp = (float *)*((_QWORD *)this + 28);
    v44.imagp = v31;
    vDSP_zvmags(&v44, 1, *((float **)this + 61), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
    vDSP_zvmags(&__C, 1, *((float **)this + 58), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
    vDSP_vsmul(*((const float **)this + 58), 1, (const float *)this + 17, *((float **)this + 58), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
    v32 = *((unsigned int *)this + 11);
    if ((_DWORD)v32)
    {
      v33 = 0;
      v34 = 0;
      v35 = *((unsigned int *)this + 12);
      do
      {
        if ((_DWORD)v35)
        {
          v36 = 0;
          v37 = *((_QWORD *)this + 61);
          v38 = *((_QWORD *)this + 58);
          do
          {
            if (*(float *)(v37 + 4 * (v33 + v36)) > *(float *)(v38 + 4 * (v33 + v36)))
            {
              v39 = (_QWORD *)(*((_QWORD *)this + 52) + 16 * v34);
              v40 = (_QWORD *)(*((_QWORD *)this + 49) + 16 * v34);
              *(_DWORD *)(*v40 + 4 * v36) = *(_DWORD *)(*v39 + 4 * v36);
              *(_DWORD *)(v40[1] + 4 * v36) = *(_DWORD *)(v39[1] + 4 * v36);
            }
            ++v36;
          }
          while (v35 != v36);
        }
        ++v34;
        v33 += v35;
      }
      while (v34 != v32);
      v41 = 0;
      v42 = 0;
      v43 = &a3->mBuffers[0].mData;
      do
      {
        memcpy(v43[v41], *(const void **)(*((_QWORD *)this + 49) + v41 * 8), 4 * *((unsigned int *)this + 12));
        memcpy((char *)v43[v41] + 4 * *((unsigned int *)this + 12), (const void *)(*(_QWORD *)(*((_QWORD *)this + 49) + v41 * 8 + 8) + 4), 4 * (*((_DWORD *)this + 12) - 2));
        ++v42;
        v41 += 2;
      }
      while (v42 < *((unsigned int *)this + 11));
    }
  }
  else if ((_DWORD)v6)
  {
    v12 = 0;
    v13 = &a2->mBuffers[0].mData;
    v14 = &a3->mBuffers[0].mData;
    do
    {
      v16 = *v14;
      v14 += 2;
      v15 = v16;
      v17 = *v13;
      v13 += 2;
      memcpy(v15, v17, 4 * (2 * *((_DWORD *)this + 12) - 2));
      ++v12;
    }
    while (v12 < *((unsigned int *)this + 11));
  }
}

void SeparationBase::GenerateOutput(uint64_t a1, _QWORD *a2, float ***a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;

  vDSP_vclr(**a3, 1, (*(_DWORD *)(a1 + 48) * *(_DWORD *)(a1 + 44)));
  vDSP_vclr((*a3)[1], 1, (*(_DWORD *)(a1 + 48) * *(_DWORD *)(a1 + 44)));
  LODWORD(v6) = *(_DWORD *)(a1 + 44);
  if ((_DWORD)v6)
  {
    v7 = 0;
    do
    {
      if ((_DWORD)v6)
      {
        v8 = 0;
        v9 = 0;
        do
        {
          vDSP_zvma((const DSPSplitComplex *)(*(_QWORD *)(a1 + 1008) + 16 * (v9++ + v7 * v6)), 1, (const DSPSplitComplex *)(*a2 + v8), 1, (const DSPSplitComplex *)&(*a3)[2 * v7], 1, (const DSPSplitComplex *)&(*a3)[2 * v7], 1, *(unsigned int *)(a1 + 48));
          v6 = *(unsigned int *)(a1 + 44);
          v8 += 16;
        }
        while (v9 < v6);
      }
      ++v7;
    }
    while (v7 < v6);
  }
}

void SeparationBase::rank1WInverseA(SeparationBase *this, unsigned int a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  float *v8;
  float **v9;
  float *v10;
  float *v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  const DSPSplitComplex *v18;
  DSPSplitComplex __C;
  DSPSplitComplex __A;

  vDSP_vclr(*((float **)this + 76), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
  vDSP_vclr(*((float **)this + 79), 1, (*((_DWORD *)this + 12) * *((_DWORD *)this + 11)));
  LODWORD(v4) = *((_DWORD *)this + 11);
  if ((_DWORD)v4)
  {
    v5 = 0;
    do
    {
      if ((_DWORD)v4)
      {
        v6 = 0;
        v7 = 0;
        do
        {
          vDSP_zvcma((const DSPSplitComplex *)(*((_QWORD *)this + 97) + v6), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 132) + 16 * (v5 + v4 * v7++)), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 94) + 16 * v5), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 94) + 16 * v5), 1, *((unsigned int *)this + 12));
          v4 = *((unsigned int *)this + 11);
          v6 += 16;
        }
        while (v7 < v4);
      }
      ++v5;
    }
    while (v5 < v4);
  }
  vDSP_vsadd(*(const float **)(*((_QWORD *)this + 94) + 16 * a2), 1, (const float *)this + 27, *((float **)this + 100), 1, *((unsigned int *)this + 12));
  memcpy(*((void **)this + 101), *(const void **)(*((_QWORD *)this + 94) + 16 * a2 + 8), 4 * *((unsigned int *)this + 12));
  v8 = (float *)*((_QWORD *)this + 19);
  __A.realp = (float *)*((_QWORD *)this + 16);
  __A.imagp = v8;
  v9 = (float **)*((_QWORD *)this + 73);
  v10 = *v9;
  v11 = v9[3];
  __C.realp = v10;
  __C.imagp = v11;
  vDSP_zvdiv((const DSPSplitComplex *)this + 50, 1, &__A, 1, &__C, 1, *((unsigned int *)this + 12));
  vDSP_zvneg(&__C, 1, &__C, 1, *((unsigned int *)this + 12));
  LODWORD(v12) = *((_DWORD *)this + 11);
  if ((_DWORD)v12)
  {
    v13 = 0;
    do
    {
      vDSP_zvmul((const DSPSplitComplex *)(*((_QWORD *)this + 132) + 16 * (a2 + (_DWORD)v12 * v13)), 1, &__C, 1, (const DSPSplitComplex *)(*((_QWORD *)this + 70) + 16 * (a2 + (_DWORD)v12 * v13)), 1, *((unsigned int *)this + 12), 1);
      ++v13;
      LODWORD(v12) = *((_DWORD *)this + 11);
    }
    while (v13 < v12);
    if ((_DWORD)v12)
    {
      v14 = 0;
      do
      {
        v15 = 0;
        v16 = 0;
        do
        {
          v17 = v12 * v14;
          v18 = (const DSPSplitComplex *)(*((_QWORD *)this + 132) + 16 * (v16 + v17));
          vDSP_zvma((const DSPSplitComplex *)(*((_QWORD *)this + 70) + 16 * (v17 + a2)), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 94) + v15), 1, v18, 1, v18, 1, *((unsigned int *)this + 12));
          ++v16;
          v12 = *((unsigned int *)this + 11);
          v15 += 16;
        }
        while (v16 < v12);
        ++v14;
      }
      while (v14 < v12);
    }
  }
}

void SeparationBase::minimumDistrotionPrinciple(SeparationBase *this)
{
  unint64_t v1;
  unint64_t i;
  unint64_t j;

  v1 = *((unsigned int *)this + 11);
  if ((_DWORD)v1)
  {
    for (i = 0; i < v1; ++i)
    {
      if (v1)
      {
        for (j = 0; j < v1; ++j)
        {
          vDSP_zvmul((const DSPSplitComplex *)(*((_QWORD *)this + 129) + 16 * (j + i * v1)), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 132) + 16 * (i + i * v1)), 1, (const DSPSplitComplex *)(*((_QWORD *)this + 126) + 16 * (j + i * v1)), 1, *((unsigned int *)this + 12), 1);
          v1 = *((unsigned int *)this + 11);
        }
      }
    }
  }
}

void AUDspLib::CreateExtendedElements(int64x2_t *this)
{
  unint64_t i;
  CFStringRef v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (this[99].i8[2])
  {
    ausdk::AUScope::Initialize(this + 96, (ausdk::AUBase *)this, 4, 18);
    for (i = 0; i != 18; ++i)
    {
      v3 = CFStringCreateWithFormat(0, 0, CFSTR("channel %d"), i);
      v4 = this[98].i64[1];
      if (v4)
      {
        v5 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v4 + 32))(v4, i);
      }
      else
      {
        v6 = this[97].i64[0];
        if (i >= (this[97].i64[1] - v6) >> 3)
          v5 = 0;
        else
          v5 = *(_QWORD *)(v6 + 8 * i);
      }
      ausdk::Owned<__CFString const*>::operator=((const void **)(v5 + 72), v3);
      CFRelease(v3);
    }
  }
}

uint64_t AUDspLib::Initialize(AUDspLib *this)
{
  BOOL AppBooleanValue;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  __int16 *i;
  unsigned int v10;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t Element;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  _DWORD *v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  int v26;
  double v27;
  uint64_t result;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  DspLib::AlgorithmBase **v44;
  _OWORD v45[2];
  uint64_t v46;
  BOOL v47[16];
  __int128 v48;
  uint64_t v49;
  _QWORD v50[3];
  _QWORD *v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 1585))
    (*(void (**)(AUDspLib *))(*(_QWORD *)this + 64))(this);
  *((_BYTE *)this + 1584) = 0;
  v47[0] = 0;
  AppBooleanValue = CACFPreferencesGetAppBooleanValue(CFSTR("FactoryDiagsMode"), CFSTR("com.apple.coreaudio"), v47);
  if (v47[0])
    *((_BYTE *)this + 1584) = AppBooleanValue;
  v3 = *((_QWORD *)this + 21);
  if (v3)
    LODWORD(v4) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  else
    v4 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
  if (v4 > 1)
    return 4294956428;
  v5 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0) + 108);
  v6 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0) + 108);
  *(_QWORD *)v47 = 0;
  v7 = (*(uint64_t (**)(AUDspLib *, BOOL *))(*(_QWORD *)this + 376))(this, v47);
  if (!v7)
    return 4294956428;
  v8 = v7;
  for (i = (__int16 *)(*(_QWORD *)v47 + 2); v5 != *(i - 1) || v6 != *i; i += 2)
  {
    if (!--v8)
      return 4294956428;
  }
  v10 = 0;
  v11 = (void **)((char *)this + 2144);
  *((_QWORD *)this + 269) = *((_QWORD *)this + 268);
  while (1)
  {
    v12 = *((_QWORD *)this + 15);
    if (v12)
      LODWORD(v13) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    else
      v13 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (v10 >= v13)
      break;
    Element = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), v10);
    v15 = Element;
    v16 = (char *)*((_QWORD *)this + 269);
    v17 = *((_QWORD *)this + 270);
    if ((unint64_t)v16 >= v17)
    {
      v19 = (char *)*v11;
      v20 = (v16 - (_BYTE *)*v11) >> 2;
      v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 62)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v22 = v17 - (_QWORD)v19;
      if (v22 >> 1 > v21)
        v21 = v22 >> 1;
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL)
        v23 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v23 = v21;
      if (v23)
      {
        v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)this + 2160, v23);
        v16 = (char *)*((_QWORD *)this + 269);
        v19 = (char *)*((_QWORD *)this + 268);
      }
      else
      {
        v24 = 0;
      }
      v25 = &v24[4 * v20];
      *(_DWORD *)v25 = *(_DWORD *)(v15 + 108);
      v18 = v25 + 4;
      while (v16 != v19)
      {
        v26 = *((_DWORD *)v16 - 1);
        v16 -= 4;
        *((_DWORD *)v25 - 1) = v26;
        v25 -= 4;
      }
      *((_QWORD *)this + 268) = v25;
      *((_QWORD *)this + 269) = v18;
      *((_QWORD *)this + 270) = &v24[4 * v23];
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_DWORD *)v16 = *(_DWORD *)(Element + 108);
      v18 = v16 + 4;
    }
    *((_QWORD *)this + 269) = v18;
    ++v10;
  }
  if (*(double *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0) + 80) <= 0.0)
    return 4294956428;
  *((_DWORD *)this + 453) = vcvtad_u64_f64(*(double *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0)+ 80));
  v27 = *(double *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0) + 80);
  if (v27 != *(double *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0) + 80))
    return 4294956428;
  *((_DWORD *)this + 452) = *((_DWORD *)this + 84);
  if (!*((_DWORD *)this + 397))
  {
    *(_DWORD *)v47 = 0;
    v31 = 1;
LABEL_45:
    v32 = 0;
    while (1)
    {
      v50[0] = &off_1E69C7350;
      v50[1] = this;
      v50[2] = v47;
      v51 = v50;
      (*(void (**)(AUDspLib *, uint64_t, _QWORD *))(*(_QWORD *)this + 624))(this, v32, v50);
      v33 = v51;
      if (v51 == v50)
        break;
      if (v51)
      {
        v34 = 5;
LABEL_50:
        (*(void (**)(void))(*v33 + 8 * v34))();
      }
      v32 = (*(_DWORD *)v47 + 1);
      *(_DWORD *)v47 = v32;
      if (v32 >= v31)
      {
        v29 = (unsigned int *)*((_QWORD *)this + 268);
        v30 = (unsigned int *)*((_QWORD *)this + 269);
        goto LABEL_53;
      }
    }
    v33 = v50;
    v34 = 4;
    goto LABEL_50;
  }
  v29 = (unsigned int *)*((_QWORD *)this + 268);
  v30 = (unsigned int *)*((_QWORD *)this + 269);
  if (v29 == v30)
    goto LABEL_59;
  v31 = *v29;
  *(_DWORD *)v47 = 0;
  if (v31)
    goto LABEL_45;
LABEL_53:
  if (v29 != v30)
  {
    v35 = *v29;
    if (v35 == 1)
    {
      v36 = 6553601;
      goto LABEL_58;
    }
    if (v35 == 2)
    {
      v36 = 6619138;
LABEL_58:
      *((_DWORD *)this + 450) = v36;
    }
  }
LABEL_59:
  (*(void (**)(AUDspLib *))(*(_QWORD *)this + 584))(this);
  v37 = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0);
  v38 = *(_OWORD *)(v37 + 96);
  *(_OWORD *)v47 = *(_OWORD *)(v37 + 80);
  v48 = v38;
  v49 = *(_QWORD *)(v37 + 112);
  v39 = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0);
  v40 = *(_OWORD *)(v39 + 96);
  v45[0] = *(_OWORD *)(v39 + 80);
  v45[1] = v40;
  v46 = *(_QWORD *)(v39 + 112);
  SimpleMeters::Initialize((AUDspLib *)((char *)this + 1832), (const CAStreamBasicDescription *)v47, (const CAStreamBasicDescription *)v45);
  v41 = *((_QWORD *)this + 15);
  if (v41)
    LODWORD(v42) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v41 + 24))(v41);
  else
    v42 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  std::vector<DspLibBuffer>::resize((_QWORD *)this + 265, v42);
  v43 = 0;
  *((_BYTE *)this + 1585) = 1;
  v44 = (DspLib::AlgorithmBase **)((char *)this + 528);
  do
  {
    AUDspLib::allocateStatusQueueForInstance(this, v43, *v44);
    result = 0;
    ++v43;
    v44 += 7;
  }
  while (v43 != 18);
  return result;
}

void sub_1B6119738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char *a23)
{
  char *v24;
  uint64_t v25;

  v24 = a23;
  if (a23 == &a20)
  {
    v25 = 4;
    v24 = &a20;
  }
  else
  {
    if (!a23)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void AUDspLib::Cleanup(AUDspLib *this)
{
  uint64_t v2;
  uint64_t v3;

  (*(void (**)(AUDspLib *))(*(_QWORD *)this + 592))(this);
  *((_BYTE *)this + 1585) = 0;
  *((_QWORD *)this + 226) = 0;
  *((_QWORD *)this + 230) = *((_QWORD *)this + 229);
  *((_QWORD *)this + 233) = *((_QWORD *)this + 232);
  v2 = *((_QWORD *)this + 266);
  v3 = *((_QWORD *)this + 265);
  while (v2 != v3)
    DspLibBuffer::~DspLibBuffer((DspLibBuffer *)(v2 - 96));
  *((_QWORD *)this + 266) = v3;
  *((_QWORD *)this + 269) = *((_QWORD *)this + 268);
}

uint64_t AUDspLib::Reset(AUDspLib *this)
{
  uint64_t i;
  uint64_t v3;

  if (*((_BYTE *)this + 1585))
  {
    caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
    for (i = 0; i != 1008; i += 56)
    {
      v3 = *(_QWORD *)((char *)this + i + 528);
      if (v3)
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 152))(v3);
    }
    caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
  }
  SimpleMeters::Reset((uint64_t)this + 1832);
  return 0;
}

void sub_1B6119860(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex *v1;

  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::GetPropertyInfo(AUDspLib *this, int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t v7;
  BOOL v8;
  unsigned int v9;
  uint64_t result;
  unsigned int v11;
  int v12;

  if (a2 == 3007)
  {
    v8 = 1;
    v9 = 4;
LABEL_13:
    result = 0;
    *a5 = v9;
    *a6 = v8;
    return result;
  }
  if (a2 == 3099)
  {
    if (a3 > 1)
      v7 = 0;
    else
      v7 = (uint64_t)(*((_QWORD *)this + 230) - *((_QWORD *)this + 229)) >> 7;
    if ((a3 & 0xFFFFFFFD) == 0)
      v7 += (uint64_t)(*((_QWORD *)this + 233) - *((_QWORD *)this + 232)) >> 7;
    v8 = 0;
    v9 = 16 * v7;
    goto LABEL_13;
  }
  if (a2 != 21 || a3)
  {
    result = 4294956417;
    switch(a2)
    {
      case 6600:
        if ((a3 & 0xFFFFFFFB) == 0)
          goto LABEL_29;
        return 4294956430;
      case 6601:
        goto LABEL_25;
      case 6602:
      case 6604:
        v12 = *((unsigned __int8 *)this + 1586);
        if (v12)
          result = 4294956430;
        else
          result = 4294956446;
        if (a3 || !v12)
          return result;
        result = 0;
        *a6 = 1;
        if (a2 == 6604)
          v11 = 8;
        else
          v11 = 4;
        break;
      case 6603:
      case 6605:
      case 6606:
      case 6607:
      case 6608:
      case 6609:
        return result;
      case 6610:
LABEL_29:
        result = 0;
        *a6 = 0;
        goto LABEL_30;
      default:
        if (a2 != 6626 && a2 != 6650)
          return result;
LABEL_25:
        if ((a3 & 0xFFFFFFFB) != 0)
          return 4294956430;
        result = 0;
        *a6 = 1;
LABEL_30:
        v11 = 8;
        break;
    }
  }
  else
  {
    result = 0;
    *a6 = 1;
    v11 = 4;
  }
  *a5 = v11;
  return result;
}

uint64_t AUDspLib::GetProperty(AUDspLib *this, int a2, unsigned int a3, unsigned int a4, CFDictionaryRef *a5, int *a6)
{
  uint64_t result;
  int v12;
  CFDataRef v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t valuePtr;
  unsigned int v22;
  void *values;
  CFNumberRef v24;
  __int128 bytes;
  _DWORD v26[4];
  uint64_t v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  if (SimpleMeters::HandleGetProperty((AUDspLib *)((char *)this + 1832), a2, a3, a5, &v22, a6))
    return v22;
  if (a2 == 21 && !a3)
  {
    result = 0;
    v12 = *((unsigned __int8 *)this + 2113);
LABEL_6:
    *(_DWORD *)a5 = v12;
    return result;
  }
  if (a2 == 6610)
  {
    v28 = 0;
    v27 = 0;
    LODWORD(bytes) = (*(uint64_t (**)(AUDspLib *))(*(_QWORD *)this + 576))(this);
    strcpy((char *)&bytes + 4, "Aug  9 2024");
    strcpy((char *)v26, "18:35:36");
    v26[3] = *((_DWORD *)this + 397);
    v13 = CFDataCreate(0, (const UInt8 *)&bytes, 44);
    result = 0;
    *a5 = v13;
    return result;
  }
  result = 4294956417;
  switch(a2)
  {
    case 6600:
      return AUDspLib::getPropertyStatus(this, a3, a4, a5);
    case 6601:
      v14 = *((_DWORD *)this + 397);
      if (a3 && !v14 || a3 != 4 && v14 == 1)
        return 4294956430;
      if (a4 > 0x11)
        return 4294956419;
      LOBYTE(bytes) = 0;
      if (v14)
        v15 = a4;
      else
        v15 = 0;
      caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
      v16 = *((_QWORD *)this + 7 * v15 + 66);
      if (v16)
        LOBYTE(bytes) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 192))(v16);
      *a5 = CFDataCreate(0, (const UInt8 *)&bytes, 1);
      caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
      return 0;
    case 6602:
    case 6604:
      if (*((_BYTE *)this + 1586))
        result = 4294956430;
      else
        result = 4294956446;
      if (a3 || !*((_BYTE *)this + 1586))
        return result;
      if (a2 == 6604)
      {
        AUDspLib::getChannelSplitMode(this, a5);
        return 0;
      }
      result = 0;
      v12 = *((_DWORD *)this + 397);
      goto LABEL_6;
    case 6603:
      return result;
    default:
      if (a2 != 6626)
      {
        if (a2 == 6650)
          return AUDspLib::getPropertyDspLibAUParameters(this, a3, a4, a5);
        return result;
      }
      v17 = *((_DWORD *)this + 397);
      if (a3 && !v17 || a3 != 4 && v17 == 1)
        return 4294956430;
      if (a4 > 0x11)
        return 4294956419;
      v18 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0) + 108);
      if (v18 == 1)
      {
        v19 = 6553601;
        goto LABEL_46;
      }
      if (v18 == 2)
      {
        v19 = 6619138;
LABEL_46:
        *((_DWORD *)this + 450) = v19;
        goto LABEL_48;
      }
      v19 = *((unsigned int *)this + 450);
LABEL_48:
      *(_QWORD *)&bytes = CFSTR("SelectedAudioChannelLayout");
      *((_QWORD *)&bytes + 1) = CFSTR("DefaultAudioChannelLayout");
      valuePtr = v19;
      v20 = *((unsigned int *)this + 451);
      values = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      v24 = CFNumberCreate(0, kCFNumberSInt64Type, &v20);
      *a5 = CFDictionaryCreate(0, (const void **)&bytes, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFRelease(values);
      CFRelease(v24);
      return 0;
  }
}

void sub_1B6119D80(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t AUDspLib::SetProperty(AUDspLib *this, int a2, int a3, unsigned int a4, int *a5, void *a6, int *a7)
{
  unsigned int v7;
  uint64_t result;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  char *v20;
  DspLib::AlgorithmBase *v21;
  caulk::pooled_semaphore_mutex *v22;
  uint64_t v23;
  int v24;
  const __CFNumber *v25;
  CFTypeID v26;
  double v27;
  unint64_t v28;
  unsigned int v29;
  UInt8 buffer;
  CFRange v31;

  v7 = a6;
  v29 = 0;
  if (SimpleMeters::HandleSetProperty((AUDspLib *)((char *)this + 1832), a2, a3, a5, a6, (int *)&v29, a7))
    return v29;
  if (a2 == 21 && !a3)
  {
    if (v7 < 4)
      return 4294956445;
    v15 = *a5;
    if ((v15 != 0) != (*((_BYTE *)this + 2113) != 0))
    {
      if (!v15 && *((_BYTE *)this + 2113))
      {
        if (*((_BYTE *)this + 17))
          (*(void (**)(AUDspLib *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
      }
      result = 0;
      *((_BYTE *)this + 2113) = v15 != 0;
      return result;
    }
    return 0;
  }
  result = 4294956417;
  if (a2 <= 6603)
  {
    if (a2 != 6601)
    {
      v14 = 6602;
      goto LABEL_12;
    }
    v16 = *((_DWORD *)this + 397);
    if ((!a3 || v16) && (a3 == 4 || v16 != 1))
    {
      if (a4 <= 0x11)
      {
        buffer = 0;
        if (v7 != 8)
          return 4294956445;
        if (v16)
          v17 = a4;
        else
          v17 = 0;
        v31.location = 0;
        v31.length = 1;
        CFDataGetBytes(*(CFDataRef *)a5, v31, &buffer);
        v18 = buffer;
        v19 = buffer != 0;
        *((_BYTE *)this + 2112) = buffer > 1u;
        v20 = (char *)this + 56 * v17;
        v20[536] = v19;
        v21 = (DspLib::AlgorithmBase *)(*(uint64_t (**)(AUDspLib *, uint64_t))(*(_QWORD *)this + 632))(this, v17);
        AUDspLib::allocateStatusQueueForInstance(this, v17, v21);
        v22 = (AUDspLib *)((char *)this + 1824);
        caulk::pooled_semaphore_mutex::_lock(v22);
        v23 = *((_QWORD *)v20 + 66);
        if (v23)
          (*(void (**)(uint64_t, BOOL))(*(_QWORD *)v23 + 200))(v23, v18 != 0);
        caulk::pooled_semaphore_mutex::_unlock(v22);
        return 0;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  if (a2 == 6626)
  {
    v24 = *((_DWORD *)this + 397);
    if ((!a3 || v24) && (a3 == 4 || v24 != 1))
    {
      if (a4 <= 0x11)
      {
        result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)a5, CFSTR("DefaultAudioChannelLayout"));
        if (!result)
          return result;
        v25 = (const __CFNumber *)result;
        v26 = CFGetTypeID((CFTypeRef)result);
        if (v26 == CFNumberGetTypeID())
        {
          v28 = 0;
          CFNumberGetValue(v25, kCFNumberSInt64Type, &v28);
          if (HIDWORD(v28))
            return 4294901760;
          if (*((_DWORD *)this + 451) != (_DWORD)v28)
          {
            *((_DWORD *)this + 451) = v28;
            if (*((_DWORD *)this + 450) == -65536)
            {
              caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
              AUDspLib::initializeDspLibAlgorithms((uint64_t)this, v27);
              caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
            }
          }
        }
        return 0;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  v14 = 6604;
LABEL_12:
  if (a2 == v14)
  {
    if (*((_BYTE *)this + 1586))
    {
      if (*((_BYTE *)this + 1585))
        result = 4294956447;
      else
        result = 4294956430;
      if (!a3 && !*((_BYTE *)this + 1585))
      {
        if (a2 == 6604)
        {
          if (v7 != 8)
            return 4294956445;
          return AUDspLib::setChannelSplitMode(this, *(CFDictionaryRef *)a5);
        }
        else
        {
          if (v7 != 4)
            return 4294956445;
          result = 0;
          *((_DWORD *)this + 397) = *a5;
        }
      }
    }
    else
    {
      return 4294956446;
    }
  }
  return result;
}

void sub_1B611A0DC(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex *v1;

  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::SetParameter(AUDspLib *this, unsigned int a2, unsigned int a3, uint64_t a4, float a5)
{
  unsigned int v7;
  int v11;
  uint64_t v12;
  ausdk::AUElement *v13;
  unsigned int v14;
  uint64_t v15;
  char *v16;
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;

  if (a4 > 0x11)
    return 4294956419;
  v7 = a4;
  if (*((_DWORD *)this + 439) <= a2)
  {
    if (a2 != 1937141612 && a2 != 1869769061)
      return 4294956418;
  }
  else
  {
    v11 = *((_DWORD *)this + 397);
    if (!(v11 | a3))
    {
      *(float *)(*((_QWORD *)this + 68) + 4 * *(unsigned int *)(*((_QWORD *)this + 211) + 4 * a2)) = a5;
      ++*((_DWORD *)this + 142);
    }
    if (a3 == 4 && v11 == 1)
    {
      v12 = *((_QWORD *)this + 197);
      if (v12)
      {
        v13 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v12 + 32))(v12, a4);
        v14 = v7;
      }
      else
      {
        v14 = a4;
        v15 = *((_QWORD *)this + 194);
        if (a4 >= (unint64_t)((*((_QWORD *)this + 195) - v15) >> 3))
          v13 = 0;
        else
          v13 = *(ausdk::AUElement **)(v15 + 8 * a4);
      }
      ausdk::AUElement::SetParameter(v13, a2, a5, 0);
      v16 = (char *)this + 56 * v14;
      *(float *)(*((_QWORD *)v16 + 68) + 4 * *(unsigned int *)(*((_QWORD *)this + 211) + 4 * a2)) = a5;
      ++*((_DWORD *)v16 + 142);
    }
  }
  *((_BYTE *)this + 1820) = 1;
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, v7);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  return 0;
}

uint64_t AUDspLib::ProcessBufferLists(AUDspLib *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  AudioBufferList *v6;
  const AudioBufferList *v7;

  v6 = a4;
  v7 = a3;
  return (*(uint64_t (**)(AUDspLib *, unsigned int *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))(*(_QWORD *)this + 184))(this, a2, a5, 1, &v7, 1, &v6);
}

uint64_t AUDspLib::ProcessMultipleBufferLists(AUDspLib *this, unsigned int *a2, uint64_t a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, const AudioBufferList **a7)
{
  uint64_t result;
  unint64_t v15;
  uint64_t i;
  unsigned int *v17;
  unint64_t v18;
  const void *v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  float *const *v24;
  uint64_t Element;
  int v26;
  void **p_mData;
  float **v28;
  uint64_t v29;
  float *v30;
  float *const *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  void **v36;
  float **v37;
  uint64_t v38;
  float *v39;
  int v40;
  int v41;
  unint64_t v42;
  DspLib::AlgorithmBase **v43;
  uint64_t v44;
  int v45;
  unsigned int *v46;
  unint64_t v47;
  double v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  char *v52;
  size_t v53;
  unint64_t j;
  unsigned int v55;
  DspLibBuffer *v56;
  unsigned int v57;
  uint64_t cycle_count;
  unsigned __int8 v59;
  uint64_t v60;
  unsigned int *v61;
  uint64_t *v62;
  SimpleMeters *v63;
  uint64_t v64;
  const AudioBufferList **v65;
  unsigned int v66;
  unsigned int v67;
  _QWORD v68[3];
  _BYTE v69[96];
  char *v70;
  char v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 452) < a3)
    return 4294956422;
  if (!*((_BYTE *)this + 1585))
    return 4294956429;
  result = SimpleMeters::ProcessInputBufferList((AUDspLib *)((char *)this + 1832), a3, *a5);
  if (!(_DWORD)result)
  {
    v67 = a6;
    v63 = (AUDspLib *)((char *)this + 1832);
    v61 = a2;
    if (a5 != a7)
    {
      v15 = 0;
      for (i = 16; ; i += 16)
      {
        v17 = (unsigned int *)*((_QWORD *)this + 268);
        v18 = v17 == *((unsigned int **)this + 269) ? 0 : *v17;
        if (v15 >= v18)
          break;
        v19 = *(const void **)((char *)&(*a5)->mNumberBuffers + i);
        result = *(_QWORD *)((char *)&(*a7)->mNumberBuffers + i);
        if (v19 != (const void *)result)
          result = (uint64_t)memcpy((void *)result, v19, 4 * a3);
        ++v15;
      }
    }
    v20 = a4;
    if (a4)
    {
      v21 = 0;
      v22 = 1;
      do
      {
        result = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), v21);
        if (*(_DWORD *)(result + 108) > v22)
          v22 = *(_DWORD *)(result + 108);
        ++v21;
      }
      while (a4 != v21);
    }
    else
    {
      v22 = 1;
    }
    v66 = a4;
    v62 = &v60;
    MEMORY[0x1E0C80A78](result);
    v24 = (float *const *)((char *)&v60 - v23);
    Element = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0);
    v26 = *(_DWORD *)(Element + 108);
    if (v26)
    {
      p_mData = &(*a7)->mBuffers[0].mData;
      v28 = (float **)v24;
      v29 = *(unsigned int *)(Element + 108);
      do
      {
        v30 = (float *)*p_mData;
        p_mData += 2;
        *v28++ = v30;
        --v29;
      }
      while (v29);
    }
    v64 = a3;
    v65 = a7;
    DspLibBuffer::initializeWithExternalChannels(*((_QWORD *)this + 265), v24, a3, v26);
    if (v66 >= 2)
    {
      v31 = &v24[v22];
      v32 = 1;
      do
      {
        v33 = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), v32);
        v34 = *(_DWORD *)(v33 + 108);
        if (v34)
        {
          v35 = v32 * v22;
          v36 = &a5[v32]->mBuffers[0].mData;
          v37 = (float **)v31;
          v38 = *(unsigned int *)(v33 + 108);
          do
          {
            v39 = (float *)*v36;
            v36 += 2;
            *v37++ = v39;
            --v38;
          }
          while (v38);
        }
        else
        {
          v35 = v32 * v22;
        }
        DspLibBuffer::initializeWithExternalChannels(*((_QWORD *)this + 265) + 96 * v32++, &v24[v35], a3, v34);
        v31 += v22;
      }
      while (v32 != v20);
    }
    v70 = (char *)this + 1824;
    v40 = caulk::pooled_semaphore_mutex::try_lock((AUDspLib *)((char *)this + 1824));
    v71 = v40;
    if (*((_BYTE *)this + 2113))
      v41 = 0;
    else
      v41 = v40;
    if (v41 == 1)
    {
      v42 = 0;
      v43 = (DspLib::AlgorithmBase **)((char *)this + 528);
      v44 = v66;
      while (1)
      {
        v45 = *((_DWORD *)this + 397);
        if (v45)
        {
          v46 = (unsigned int *)*((_QWORD *)this + 268);
          v47 = v46 == *((unsigned int **)this + 269) ? 0 : *v46;
        }
        else
        {
          v47 = 1;
        }
        if (v42 >= v47)
          break;
        if (*v43)
        {
          if (v43[3] != v43[2] && *((_DWORD *)v43 + 10) != *((_DWORD *)v43 + 11))
          {
            (*(void (**)(AUDspLib *, unint64_t))(*(_QWORD *)this + 616))(this, v42);
            *((_DWORD *)v43 + 11) = *((_DWORD *)v43 + 10);
            v45 = *((_DWORD *)this + 397);
          }
          if (v45)
          {
            if (v45 == 1)
            {
              v48 = DspLibBuffer::channelBuffer(*((DspLibBuffer **)this + 265), v42, (uint64_t)v69);
              (*(void (**)(DspLib::AlgorithmBase *, _BYTE *, _BYTE *, uint64_t, uint64_t, double))(*(_QWORD *)*v43 + 160))(*v43, v69, v69, 1, 1, v48);
              DspLibBuffer::~DspLibBuffer((DspLibBuffer *)v69);
            }
          }
          else
          {
            (*(void (**)(DspLib::AlgorithmBase *, _QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)*v43 + 160))(*v43, *((_QWORD *)this + 265), *((_QWORD *)this + 265), v44, v67);
          }
          AUDspLib::enqueueStatusForInstance(this, v42, *v43, a3);
        }
        ++v42;
        v43 += 7;
      }
      if (*((_QWORD *)this + 66)
        && DspLibBuffer::numChannels(*((DspLibBuffer **)this + 265))
        && vp::utility::CPU_Profiler::get_instruction_count(*((vp::utility::CPU_Profiler **)this + 265)))
      {
        v49 = DspLibBuffer::numChannels(*((DspLibBuffer **)this + 265));
        MEMORY[0x1E0C80A78](v49);
        v52 = (char *)&v60 - v51;
        if (v50 >= 0x200)
          v53 = 512;
        else
          v53 = v50;
        bzero((char *)&v60 - v51, v53);
        for (j = 0; ; ++j)
        {
          v55 = DspLibBuffer::numChannels(*((DspLibBuffer **)this + 265));
          v56 = (DspLibBuffer *)*((_QWORD *)this + 265);
          if (j >= v55)
            break;
          *(_QWORD *)&v52[8 * j] = DspLibBuffer::channel(v56, j);
        }
        v57 = DspLibBuffer::numChannels(v56);
        cycle_count = vp::utility::CPU_Profiler::get_cycle_count(*((vp::utility::CPU_Profiler **)this + 265));
        v68[0] = v52;
        v68[1] = v57;
        v68[2] = cycle_count;
        v59 = DspLib::maxMagnitude(v68) == 0.0;
        *v61 = *v61 & 0xFFFFFFEF | (16 * (v59 & 1));
        atomic_store(v59, (unsigned __int8 *)this + 1821);
      }
    }
    SimpleMeters::ProcessOutputBufferList(v63, v64, *v65);
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v70);
    return 0;
  }
  return result;
}

void sub_1B611A788(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100](v1 - 112);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::Render(AUDspLib *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  ausdk::AUInputElement *Element;
  uint64_t result;
  uint64_t v11;
  uint64_t BufferList;
  uint64_t v13;
  uint64_t v14;

  v8 = (AUDspLib *)((char *)this + 80);
  Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0);
  result = ausdk::AUInputElement::PullInput(Element, a2, a3, 0, a4);
  if (!(_DWORD)result)
  {
    v11 = ausdk::AUScope::SafeGetElement(v8, 0);
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v11 + 144));
    v13 = ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 128), 0);
    v14 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v13 + 144));
    return (*(uint64_t (**)(AUDspLib *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 176))(this, a2, BufferList, v14, a4);
  }
  return result;
}

uint64_t AUDspLib::GetParameterInfo(AUDspLib *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v8;
  AudioUnitParameterValue v9;
  int v10;
  const __CFString *v11;

  if ((a2 & 0xFFFFFFFB) != 0)
    return 4294956418;
  if (*((_DWORD *)this + 439) <= a3)
    return 4294956418;
  v6 = *(unsigned int *)(*((_QWORD *)this + 211) + 4 * a3);
  if (v6 >= *((_DWORD *)this + 438))
    return 4294956418;
  v8 = a3;
  v9 = *(float *)(*((_QWORD *)this + 205) + 4 * v6);
  v10 = *(_DWORD *)(*((_QWORD *)this + 203) + 4 * v6);
  buffer->unit = *(_DWORD *)(*((_QWORD *)this + 201) + 4 * v6);
  buffer->minValue = v9;
  buffer->maxValue = *(AudioUnitParameterValue *)(*((_QWORD *)this + 207) + 4 * v6);
  buffer->defaultValue = *(AudioUnitParameterValue *)(*((_QWORD *)this + 213) + 4 * a3);
  v11 = *(const __CFString **)(*((_QWORD *)this + 199) + 8 * v6);
  buffer->cfNameString = v11;
  buffer->flags = (v10 - 1048576000) | 0x8000000;
  CFStringGetCString(v11, buffer->name, 52, 0x8000100u);
  result = 0;
  if (*((_QWORD *)this + 216))
  {
    buffer->clumpID = *(_DWORD *)(*((_QWORD *)this + 215) + 4 * v8);
    buffer->flags |= 0x100000u;
  }
  return result;
}

uint64_t AUDspLib::SaveState(AUDspLib *this, ausdk **a2)
{
  CFTypeID v4;
  CFNumberRef v5;
  uint64_t valuePtr;

  ausdk::AUBase::SaveState(this, a2);
  if (a2)
  {
    v4 = CFGetTypeID(*a2);
    if (v4 == CFDictionaryGetTypeID())
    {
      valuePtr = *((unsigned int *)this + 451);
      v5 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionarySetValue(*a2, CFSTR("DefaultAudioChannelLayout"), v5);
      CFRelease(v5);
    }
  }
  return 0;
}

UInt8 *AUDspLib::SaveExtendedScopes(AUDspLib *this, __CFData *a2)
{
  ausdk::AUScope *Scope;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);
  return ausdk::AUScope::SaveState(Scope, a2);
}

uint64_t AUDspLib::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t v3;
  int v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int i;
  OpaqueAudioComponentInstance *v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v14;
  _QWORD v15[3];
  _QWORD *v16;
  _QWORD v17[3];
  _QWORD *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::RestoreState(this, a2);
  v4 = *((_DWORD *)this + 397);
  if (v4 == 1)
  {
    for (i = 0; ; i = v12 + 1)
    {
      v14 = i;
      v8 = this[268];
      if (v8 == this[269])
        v9 = 0;
      else
        v9 = *(_DWORD *)v8;
      if (i >= v9)
        goto LABEL_20;
      v15[0] = &off_1E69C73E0;
      v15[1] = this;
      v15[2] = &v14;
      v16 = v15;
      (*((void (**)(OpaqueAudioComponentInstance **))*this + 78))(this);
      v10 = v16;
      if (v16 == v15)
      {
        v10 = v15;
        v11 = 4;
      }
      else
      {
        if (!v16)
          goto LABEL_16;
        v11 = 5;
      }
      (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_16:
      v12 = v14;
      ++LODWORD(this[7 * v14 + 71]);
    }
  }
  if (!v4)
  {
    v17[0] = &off_1E69C7398;
    v17[1] = this;
    v18 = v17;
    (*((void (**)(OpaqueAudioComponentInstance **, _QWORD, _QWORD *))*this + 78))(this, 0, v17);
    v5 = v18;
    if (v18 == v17)
    {
      v6 = 4;
      v5 = v17;
    }
    else
    {
      if (!v18)
      {
LABEL_19:
        ++*((_DWORD *)this + 142);
        goto LABEL_20;
      }
      v6 = 5;
    }
    (*(void (**)(void))(*v5 + 8 * v6))();
    goto LABEL_19;
  }
LABEL_20:
  *((_BYTE *)this + 1820) = 1;
  return v3;
}

void sub_1B611ABD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v19;
  uint64_t v20;

  v19 = a17;
  if (a17 == v17)
  {
    v20 = 4;
    v19 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t AUDspLib::CopyClumpName(AUDspLib *this, unsigned int a2, unsigned int a3, unsigned int a4, const __CFString **a5)
{
  uint64_t result;

  if (*((_QWORD *)this + 218) <= (unint64_t)a3)
    return 4294956419;
  result = 0;
  *a5 = *(const __CFString **)(*((_QWORD *)this + 217) + 8 * a3);
  return result;
}

uint64_t AUDspLib::GetPresets(AUDspLib *this, const __CFArray **a2)
{
  __CFArray *Mutable;
  uint64_t v5;
  unint64_t v6;

  if (a2)
  {
    Mutable = CFArrayCreateMutable(0, *((unsigned int *)this + 444), 0);
    if (*((_DWORD *)this + 444))
    {
      v5 = 0;
      v6 = 0;
      do
      {
        CFArrayAppendValue(Mutable, (const void *)(*((_QWORD *)this + 224) + v5));
        ++v6;
        v5 += 16;
      }
      while (v6 < *((unsigned int *)this + 444));
    }
    *a2 = Mutable;
  }
  return 0;
}

uint64_t AUDspLib::NewFactoryPresetSet(AUDspLib *this, const AUPreset *a2)
{
  uint64_t v3;
  uint64_t v4;
  SInt32 presetNumber;
  int *v6;
  int *v7;
  int v8;
  unsigned int v10;
  uint64_t v11;
  int v12;
  unint64_t i;
  unsigned int *v14;
  unint64_t v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  uint64_t v18;

  v3 = *((unsigned int *)this + 444);
  if ((_DWORD)v3)
  {
    v4 = 0;
    presetNumber = a2->presetNumber;
    v6 = (int *)*((_QWORD *)this + 224);
    v7 = v6;
    while (1)
    {
      v8 = *v7;
      v7 += 4;
      if (presetNumber == v8)
        break;
      if (v3 == ++v4)
        goto LABEL_5;
    }
    v10 = *((_DWORD *)this + 439);
    if (v10)
    {
      v11 = 0;
      do
      {
        v12 = *((_DWORD *)this + 397);
        if (v12)
        {
          if (v12 == 1)
          {
            for (i = 0; ; ++i)
            {
              v14 = (unsigned int *)*((_QWORD *)this + 268);
              v15 = v14 == *((unsigned int **)this + 269) ? 0 : *v14;
              if (i >= v15)
                break;
              v16 = *((_QWORD *)this + 197);
              if (v16)
              {
                v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v16 + 32))(v16, i);
              }
              else
              {
                v18 = *((_QWORD *)this + 194);
                if (i >= (*((_QWORD *)this + 195) - v18) >> 3)
                  v17 = 0;
                else
                  v17 = *(ausdk::AUElement **)(v18 + 8 * i);
              }
              ausdk::AUElement::SetParameter(v17, v11, *(float *)(*((_QWORD *)this + 221) + 4 * (v11 + *((_DWORD *)this + 439) * presetNumber)), 0);
            }
          }
        }
        else
        {
          (*(void (**)(AUDspLib *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, v11, 0, 0, 0, *(float *)(*((_QWORD *)this + 221) + 4 * (v11 + v10 * presetNumber)));
        }
        v11 = (v11 + 1);
        v10 = *((_DWORD *)this + 439);
      }
      while (v11 < v10);
      v6 = (int *)*((_QWORD *)this + 224);
    }
    ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, (const AUPreset *)&v6[4 * v4]);
    return 0;
  }
  else
  {
LABEL_5:
    *((_BYTE *)this + 1820) = 1;
    return 4294956445;
  }
}

_BYTE *AUDspLib::GetLatency(_BYTE *this)
{
  uint64_t v1;
  unint64_t v2;
  _DWORD *i;
  unsigned int *v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  double v8;
  uint64_t j;
  uint64_t v10;
  double v11;

  if (!this[2113])
  {
    v1 = (uint64_t)this;
    if (this[1585] && this[1820])
    {
      this[1820] = 0;
      caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(this + 1824));
      v2 = 0;
      for (i = (_DWORD *)(v1 + 572); ; i += 14)
      {
        if (*(_DWORD *)(v1 + 1588))
        {
          v4 = *(unsigned int **)(v1 + 2144);
          v5 = v4 == *(unsigned int **)(v1 + 2152) ? 0 : *v4;
        }
        else
        {
          v5 = 1;
        }
        if (v2 >= v5)
          break;
        v6 = *(i - 1);
        if (v6 != *i)
        {
          *i = v6;
          if (*(_QWORD *)(i - 11))
            (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)v1 + 616))(v1, v2);
        }
        ++v2;
      }
      v7 = *(_QWORD *)(v1 + 528);
      if (v7)
        v8 = (*(double (**)(uint64_t))(*(_QWORD *)v7 + 80))(v7);
      else
        v8 = 0.0;
      for (j = 0; j != 952; j += 56)
      {
        v10 = *(_QWORD *)(v1 + 584 + j);
        if (v10)
        {
          v11 = (*(double (**)(uint64_t))(*(_QWORD *)v10 + 80))(v10);
          if (v11 != v8 && v8 < v11)
            v8 = v11;
        }
      }
      *(_DWORD *)(v1 + 1816) = v8;
      caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v1 + 1824));
    }
    return (_BYTE *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
  }
  return this;
}

void sub_1B611AF90(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex *v1;

  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::GetTailTime(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  double v3;
  uint64_t i;
  uint64_t v5;
  double v6;

  if (!*(_BYTE *)(this + 2113))
  {
    v1 = this;
    if (*(_BYTE *)(this + 1585))
    {
      v2 = *(_QWORD *)(this + 528);
      if (v2)
        v3 = (*(double (**)(uint64_t, double))(*(_QWORD *)v2 + 88))(v2, 0.0);
      else
        v3 = 0.0;
      for (i = 0; i != 952; i += 56)
      {
        v5 = *(_QWORD *)(v1 + 584 + i);
        if (v5)
        {
          v6 = (*(double (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5);
          if (v3 < v6)
            v3 = v6;
        }
      }
    }
    return ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0);
  }
  return this;
}

uint64_t AUDspLib::SupportedNumChannels(AUDspLib *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUDspLib::SupportedNumChannels(AUChannelInfo const**)::kSupportedNumChannels;
  return 18;
}

uint64_t AUDspLib::SetAudioChannelLayout(AUDspLib *this, unsigned int a2, unsigned int a3, const AudioChannelLayout *a4)
{
  AudioChannelLayoutTag mChannelLayoutTag;
  double v7;

  mChannelLayoutTag = a4->mChannelLayoutTag;
  if ((a4->mChannelLayoutTag | 0x10000) == 0x10000)
    return 4294956428;
  if (*((_DWORD *)this + 450) != mChannelLayoutTag)
  {
    *((_DWORD *)this + 450) = mChannelLayoutTag;
    if (*((_BYTE *)this + 17))
    {
      if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUDspLib *)((char *)this + 80), 0) + 108) != LOWORD(a4->mChannelLayoutTag))
        return 4294956428;
      caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
      AUDspLib::initializeDspLibAlgorithms((uint64_t)this, v7);
      caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
    }
  }
  return 0;
}

void sub_1B611B108(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex *v1;

  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::Version(AUDspLib *this)
{
  return 0;
}

uint64_t AUDspLib::createAlgorithms(AUDspLib *this)
{
  caulk::pooled_semaphore_mutex *v2;
  double v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unint64_t v10;
  unint64_t v11;
  _DWORD *i;
  unsigned int *v13;
  unint64_t v14;

  v2 = (AUDspLib *)((char *)this + 1824);
  caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
  v4 = *((unsigned int *)this + 397);
  v5 = v4;
  if ((_DWORD)v4 != 1)
  {
    if ((_DWORD)v4 || (v6 = (unsigned int *)*((_QWORD *)this + 268), v6 == *((unsigned int **)this + 269)))
      v5 = 0;
    else
      v5 = *v6;
  }
  v7 = 0;
  v8 = 528;
  if (!(_DWORD)v4)
    goto LABEL_9;
LABEL_7:
  v9 = (unsigned int *)*((_QWORD *)this + 268);
  if (v9 == *((unsigned int **)this + 269))
    v10 = 0;
  else
    v10 = *v9;
  while (v7 < v10)
  {
    if (!*(_QWORD *)((char *)this + v8))
    {
      *(_QWORD *)((char *)this + v8) = (*(uint64_t (**)(AUDspLib *, uint64_t))(*(_QWORD *)this + 600))(this, v5);
      LODWORD(v4) = *((_DWORD *)this + 397);
    }
    ++v7;
    v8 += 56;
    if ((_DWORD)v4)
      goto LABEL_7;
LABEL_9:
    v10 = 1;
  }
  if (*((_QWORD *)this + 66))
  {
    AUDspLib::initializeDspLibAlgorithms((uint64_t)this, v3);
    v11 = 0;
    for (i = (_DWORD *)((char *)this + 572); ; i += 14)
    {
      if (*((_DWORD *)this + 397))
      {
        v13 = (unsigned int *)*((_QWORD *)this + 268);
        v14 = v13 == *((unsigned int **)this + 269) ? 0 : *v13;
      }
      else
      {
        v14 = 1;
      }
      if (v11 >= v14)
        break;
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(i - 11) + 200))(*(_QWORD *)(i - 11), *((unsigned __int8 *)i - 36));
      if (*(_QWORD *)(i - 5) != *(_QWORD *)(i - 7))
      {
        (*(void (**)(AUDspLib *, unint64_t))(*(_QWORD *)this + 616))(this, v11);
        *i = *(i - 1);
      }
      ++v11;
    }
  }
  *((_BYTE *)this + 1820) = 1;
  caulk::pooled_semaphore_mutex::_unlock(v2);
  return 0;
}

void sub_1B611B2A8(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex *v1;

  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::deleteAlgorithms(AUDspLib *this)
{
  caulk::pooled_semaphore_mutex *v2;
  uint64_t i;
  char *v4;
  uint64_t v5;

  v2 = (AUDspLib *)((char *)this + 1824);
  caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
  for (i = 0; i != 1008; i += 56)
  {
    v4 = (char *)this + i;
    v5 = *(_QWORD *)((char *)this + i + 528);
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      *((_QWORD *)v4 + 66) = 0;
    }
    *((_QWORD *)v4 + 71) = 0;
  }
  caulk::pooled_semaphore_mutex::_unlock(v2);
  return 0;
}

uint64_t AUDspLib::numStatus(AUDspLib *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 66);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 176))(result);
  return result;
}

uint64_t AUDspLib::setParametersOnInstance(AUDspLib *this, unsigned int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 7 * a2 + 66);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 144))(v2);
}

uint64_t AUDspLib::gatherParametersForInstance(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  ausdk::AUScope *v8;
  uint64_t v9;
  ausdk::AUElement *Element;
  float Parameter;
  uint64_t v12;

  if (*(_DWORD *)(result + 1756))
  {
    v5 = result;
    v6 = 0;
    v7 = a2;
    v8 = (ausdk::AUScope *)(result + 32);
    do
    {
      if (*(_DWORD *)(v5 + 1588) == 1)
      {
        v9 = *(_QWORD *)(v5 + 1576);
        if (v9)
        {
          Element = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 32))(v9, a2);
        }
        else
        {
          v12 = *(_QWORD *)(v5 + 1552);
          if (v7 >= (*(_QWORD *)(v5 + 1560) - v12) >> 3)
            Element = 0;
          else
            Element = *(ausdk::AUElement **)(v12 + 8 * v7);
        }
      }
      else
      {
        Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v8, 0);
      }
      Parameter = ausdk::AUElement::GetParameter(Element, v6);
      result = *(_QWORD *)(a3 + 24);
      if (result)
        result = std::function<void ()(unsigned int,unsigned int,float)>::operator()(result, *(_DWORD *)(*(_QWORD *)(v5 + 1688) + 4 * v6), v6, Parameter);
      ++v6;
    }
    while (v6 < *(unsigned int *)(v5 + 1756));
  }
  return result;
}

uint64_t std::function<void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, int a2, int a3, float a4)
{
  float v5;
  int v6;
  int v7;

  v7 = a2;
  v6 = a3;
  v5 = a4;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *, int *, float *))(*(_QWORD *)a1 + 48))(a1, &v7, &v6, &v5);
}

uint64_t AUDspLib::initializeDspLibAlgorithms(uint64_t this, double a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t *i;
  int v5;
  unsigned int *v6;
  unint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  uint64_t v11;

  v2 = this;
  v3 = 0;
  for (i = (uint64_t *)(this + 528); ; i += 7)
  {
    v5 = *(_DWORD *)(v2 + 1588);
    if (v5)
    {
      v6 = *(unsigned int **)(v2 + 2144);
      v7 = v6 == *(unsigned int **)(v2 + 2152) ? 0 : *v6;
    }
    else
    {
      v7 = 1;
    }
    if (v3 >= v7)
      break;
    v8 = *i;
    if (!*i)
      goto LABEL_17;
    if (v5 == 1)
    {
      v11 = 6553601;
    }
    else
    {
      if (v5)
        goto LABEL_17;
      v9 = *(int **)(v2 + 2144);
      if (v9 == *(int **)(v2 + 2152))
        v10 = 0;
      else
        v10 = *v9;
      v11 = DspLibFinalChannelLayout(*(unsigned int *)(v2 + 1800), *(unsigned int *)(v2 + 1804), v10);
    }
    LODWORD(a2) = *(_DWORD *)(v2 + 1812);
    this = (*(uint64_t (**)(uint64_t, uint64_t, double))(*(_QWORD *)v8 + 16))(v8, v11, (double)*(unint64_t *)&a2);
LABEL_17:
    ++v3;
  }
  return this;
}

void std::__function::__func<AUDspLib::RestoreState(void const*)::$_1,std::allocator<AUDspLib::RestoreState(void const*)::$_1>,void ()(unsigned int,unsigned int,float)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<AUDspLib::RestoreState(void const*)::$_1,std::allocator<AUDspLib::RestoreState(void const*)::$_1>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69C73E0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AUDspLib::RestoreState(void const*)::$_1,std::allocator<AUDspLib::RestoreState(void const*)::$_1>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69C73E0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

float std::__function::__func<AUDspLib::RestoreState(void const*)::$_1,std::allocator<AUDspLib::RestoreState(void const*)::$_1>,void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3, float *a4)
{
  float result;

  result = *a4;
  *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 56 * **(unsigned int **)(a1 + 16) + 544) + 4 * *a2) = *a4;
  return result;
}

void std::__function::__func<AUDspLib::RestoreState(void const*)::$_0,std::allocator<AUDspLib::RestoreState(void const*)::$_0>,void ()(unsigned int,unsigned int,float)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<AUDspLib::RestoreState(void const*)::$_0,std::allocator<AUDspLib::RestoreState(void const*)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E69C7398;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AUDspLib::RestoreState(void const*)::$_0,std::allocator<AUDspLib::RestoreState(void const*)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E69C7398;
  a2[1] = v2;
  return result;
}

float std::__function::__func<AUDspLib::RestoreState(void const*)::$_0,std::allocator<AUDspLib::RestoreState(void const*)::$_0>,void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3, float *a4)
{
  float result;

  result = *a4;
  *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 544) + 4 * *a2) = *a4;
  return result;
}

uint64_t ausdk::AUBase::GetScope(ausdk::AUBase *this, unsigned int a2)
{
  uint64_t result;
  ausdk::AUException *exception;

  if (a2 < 4)
    return (uint64_t)this + 48 * a2 + 32;
  result = (*(uint64_t (**)(ausdk::AUBase *))(*(_QWORD *)this + 408))(this);
  if (!result)
  {
    exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(exception, -10866);
  }
  return result;
}

void sub_1B611B6F0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t SimpleMeters::ProcessInputBufferList(SimpleMeters *this, int a2, const AudioBufferList *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  void **p_mData;
  const float *v10;

  if (!*((_DWORD *)this + 12))
    return 0;
  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1);
  if (a3->mNumberBuffers == (v5 - *(_QWORD *)this) >> 7)
  {
    if (v5 != v4)
    {
      v7 = 0;
      v8 = 0;
      p_mData = &a3->mBuffers[0].mData;
      do
      {
        v10 = (const float *)*p_mData;
        p_mData += 2;
        PowerMeter::Process((unsigned __int8 *)(v4 + v7), v10, a2);
        ++v8;
        v4 = *(_QWORD *)this;
        v7 += 128;
      }
      while (v8 < (uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 7);
    }
    return 0;
  }
  return 4294967246;
}

_QWORD *AUDspLib::enqueueStatusForInstance(_QWORD *this, unsigned int a2, DspLib::AlgorithmBase *a3, unint64_t a4)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _BYTE *v8;

  if (a3)
  {
    v4 = this;
    this = (_QWORD *)this[a2 + 246];
    if (this)
    {
      if (*((_BYTE *)v4 + 2112))
      {
        v5 = this[7];
        v6 = this[6] + a4;
        this[6] = v6;
        this[9] = a4;
        if (v6 + (a4 >> 1) >= v5)
        {
          this[8] = v6;
          this[6] = 0;
          return (_QWORD *)AUDspLibStatus::Queue::push((AUDspLibStatus::Queue *)this, a3);
        }
      }
      else
      {
        v7 = &v4[7 * a2];
        if (*((_BYTE *)v7 + 576))
        {
          v8 = v7 + 72;
          this = (_QWORD *)AUDspLibStatus::Queue::push((AUDspLibStatus::Queue *)this, a3);
          *v8 = 0;
        }
      }
    }
  }
  return this;
}

uint64_t SimpleMeters::ProcessOutputBufferList(SimpleMeters *this, int a2, const AudioBufferList *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  void **p_mData;
  const float *v10;

  if (!*((_DWORD *)this + 13))
    return 0;
  v4 = *((_QWORD *)this + 3);
  v5 = *((_QWORD *)this + 4);
  if (a3->mNumberBuffers == (v5 - v4) >> 7)
  {
    if (v5 != v4)
    {
      v7 = 0;
      v8 = 0;
      p_mData = &a3->mBuffers[0].mData;
      do
      {
        v10 = (const float *)*p_mData;
        p_mData += 2;
        PowerMeter::Process((unsigned __int8 *)(v4 + v7), v10, a2);
        ++v8;
        v4 = *((_QWORD *)this + 3);
        v7 += 128;
      }
      while (v8 < (*((_QWORD *)this + 4) - v4) >> 7);
    }
    return 0;
  }
  return 4294967246;
}

uint64_t AUDspLibStatus::Queue::push(AUDspLibStatus::Queue *this, DspLib::AlgorithmBase *a2)
{
  unsigned int *v4;
  unsigned int v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  double v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  char *v22;
  __int128 v23;
  unsigned int v24;
  _QWORD v25[3];
  __int128 v26;
  __int128 v27;

  ++*((_QWORD *)this + 5);
  v4 = (unsigned int *)((char *)this + 32);
  v5 = atomic_load((unsigned int *)this + 8);
  v6 = (uint64_t *)(*((_QWORD *)this + 1) + 24 * v5);
  v7 = *v6;
  v8 = (v6[1] - *v6) >> 2;
  v26 = 0u;
  v27 = 0u;
  (*(void (**)(_QWORD *__return_ptr, DspLib::AlgorithmBase *))(*(_QWORD *)a2 + 208))(v25, a2);
  v10 = (int32x2_t)v25[0];
  v9 = v25[1];
  v11 = v25[2];
  (*(void (**)(DspLib::AlgorithmBase *, uint64_t, uint64_t))(*(_QWORD *)a2 + 184))(a2, v7, v8);
  v12 = *((_QWORD *)this + 5);
  v14 = *((_QWORD *)this + 8);
  v13 = *((_QWORD *)this + 9);
  result = (*(uint64_t (**)(DspLib::AlgorithmBase *))(*(_QWORD *)a2 + 80))(a2);
  v17 = *((_QWORD *)this + 12);
  v18 = 4;
  if ((unint64_t)(v17 + 1) < 4)
    v18 = v17 + 1;
  v19 = (v17 - v18 + 5) % 5uLL - (5 - v18) + 1;
  v20 = atomic_load((unint64_t *)this + 20);
  if (v19 != v20)
  {
    v21 = v16 / *((double *)this + 10) * 1000.0;
    v22 = (char *)this + 104 * v17 + 96;
    *((int32x2_t *)v22 + 9) = vrev64_s32(v10);
    *((_QWORD *)v22 + 10) = v9;
    *((_QWORD *)v22 + 11) = v14;
    *((_QWORD *)v22 + 12) = v12;
    *((_QWORD *)v22 + 13) = v13;
    v23 = v27;
    *((_OWORD *)v22 + 7) = v26;
    *((_OWORD *)v22 + 8) = v23;
    *((float *)v22 + 36) = v21;
    *(_QWORD *)(v22 + 148) = v11;
    *((_QWORD *)v22 + 20) = v7;
    *((_QWORD *)v22 + 21) = v8;
    atomic_store(v19, (unint64_t *)this + 12);
    v24 = atomic_load(v4);
    atomic_store((v24 + 1) % (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3)), v4);
  }
  return result;
}

BOOL SimpleMeters::HandleSetProperty(SimpleMeters *this, int a2, int a3, int *a4, const void *a5, int *a6, int *a7)
{
  int v8;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double *v15;
  double *v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double *v27;
  double *v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;

  *a6 = 0;
  if (a2 == 3007)
  {
    if (a5 <= 3)
    {
      v8 = -50;
LABEL_4:
      *a6 = v8;
      return a2 == 3007;
    }
    if (a3 == 2)
    {
      v10 = *a4;
      v11 = *((_DWORD *)this + 12);
    }
    else if (a3 == 1)
    {
      v10 = *((_DWORD *)this + 13);
      v11 = *a4;
    }
    else
    {
      if (a3)
      {
        v8 = -10866;
        goto LABEL_4;
      }
      v10 = *a4;
      v11 = *a4;
    }
    if (v11 && !*((_DWORD *)this + 12))
    {
      v12 = *((_QWORD *)this + 1);
      if (v12 == *(_QWORD *)this)
      {
        std::vector<PowerMeter>::resize((void **)this, *((unsigned int *)this + 21));
      }
      else
      {
        v13 = *(_QWORD *)this + 52;
        do
        {
          *(_QWORD *)(v13 + 12) = 0;
          *(_WORD *)(v13 + 4) = 0;
          *(_QWORD *)(v13 + 36) = 0;
          *(_QWORD *)(v13 + 28) = 0;
          *(_QWORD *)(v13 + 52) = 0;
          *(_QWORD *)(v13 + 44) = 0;
          *(_QWORD *)(v13 + 68) = 0;
          v14 = v13 + 76;
          *(_QWORD *)(v13 + 60) = 0;
          *(_QWORD *)(v13 - 4) = 0xFFFFFFFFLL;
          v13 += 128;
        }
        while (v14 != v12);
      }
      v15 = *(double **)this;
      v16 = (double *)*((_QWORD *)this + 1);
      if (*(double **)this != v16)
      {
        v17 = *((double *)this + 7);
        if (v17 * 2.5 >= 2.22507386e-308)
          v18 = -2.76310211 / v17;
        else
          v18 = -INFINITY;
        v19 = exp(v18);
        if (v18 >= -708.4)
          v20 = v19;
        else
          v20 = 0.0;
        if (v17 * 1.24 >= 2.22507386e-308)
          v21 = -5.57077039 / v17;
        else
          v21 = -INFINITY;
        v22 = exp(v21);
        if (v21 < -708.4)
          v22 = 0.0;
        do
        {
          v15[1] = v17;
          v15[2] = v20;
          v15[4] = v22;
          v15 += 16;
        }
        while (v15 != v16);
      }
    }
    if (v10 && !*((_DWORD *)this + 13))
    {
      v24 = *((_QWORD *)this + 3);
      v23 = *((_QWORD *)this + 4);
      if (v23 == v24)
      {
        std::vector<PowerMeter>::resize((void **)this + 3, *((unsigned int *)this + 31));
      }
      else
      {
        v25 = v24 + 52;
        do
        {
          *(_QWORD *)(v25 + 12) = 0;
          *(_WORD *)(v25 + 4) = 0;
          *(_QWORD *)(v25 + 36) = 0;
          *(_QWORD *)(v25 + 28) = 0;
          *(_QWORD *)(v25 + 52) = 0;
          *(_QWORD *)(v25 + 44) = 0;
          *(_QWORD *)(v25 + 68) = 0;
          v26 = v25 + 76;
          *(_QWORD *)(v25 + 60) = 0;
          *(_QWORD *)(v25 - 4) = 0xFFFFFFFFLL;
          v25 += 128;
        }
        while (v26 != v23);
      }
      v27 = (double *)*((_QWORD *)this + 3);
      v28 = (double *)*((_QWORD *)this + 4);
      if (v27 != v28)
      {
        v29 = *((double *)this + 12);
        if (v29 * 2.5 >= 2.22507386e-308)
          v30 = -2.76310211 / v29;
        else
          v30 = -INFINITY;
        v31 = exp(v30);
        if (v30 >= -708.4)
          v32 = v31;
        else
          v32 = 0.0;
        if (v29 * 1.24 >= 2.22507386e-308)
          v33 = -5.57077039 / v29;
        else
          v33 = -INFINITY;
        v34 = exp(v33);
        if (v33 < -708.4)
          v34 = 0.0;
        do
        {
          v27[1] = v29;
          v27[2] = v32;
          v27[4] = v34;
          v27 += 16;
        }
        while (v27 != v28);
      }
    }
    __dmb(0xBu);
    *((_DWORD *)this + 12) = v11;
    *((_DWORD *)this + 13) = v10;
  }
  return a2 == 3007;
}

uint64_t AUDspLib::setChannelSplitMode(AUDspLib *this, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  const __CFNumber *v4;
  CFTypeID v5;
  uint64_t result;
  unint64_t valuePtr;

  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("channelSplitMode"));
  if (!Value)
    return 4294956445;
  v4 = Value;
  v5 = CFGetTypeID(Value);
  if (v5 != CFNumberGetTypeID())
    return 4294956445;
  valuePtr = 0;
  if (!CFNumberGetValue(v4, kCFNumberSInt64Type, &valuePtr) || HIDWORD(valuePtr))
    return 4294956445;
  result = 0;
  *((_DWORD *)this + 397) = valuePtr;
  return result;
}

_BYTE *AUDspLib::allocateStatusQueueForInstance(_BYTE *this, unsigned int a2, DspLib::AlgorithmBase *a3)
{
  _BYTE *v3;
  uint64_t v5;
  unsigned int v6;
  uint64_t Element;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  _BYTE *v13;
  void *__p[3];

  if (this[56 * a2 + 536])
  {
    v3 = this;
    if (this[1585])
    {
      v5 = a2;
      v6 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)this + 608))(this);
      Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v3 + 80), 0);
      v8 = operator new();
      LODWORD(v9) = *((_DWORD *)v3 + 453);
      v10 = *(unsigned int *)(Element + 108);
      v11 = (double)v9;
      *(_QWORD *)v8 = v6;
      *(_QWORD *)(v8 + 8) = 0;
      *(_QWORD *)(v8 + 160) = 0;
      *(_DWORD *)(v8 + 32) = 0;
      *(_QWORD *)(v8 + 16) = 0;
      *(_QWORD *)(v8 + 24) = 0;
      *(_OWORD *)(v8 + 88) = 0u;
      *(_OWORD *)(v8 + 72) = 0u;
      *(_OWORD *)(v8 + 56) = 0u;
      v12 = 4;
      *(_OWORD *)(v8 + 40) = 0u;
      do
      {
        std::vector<float>::vector(__p, *(_QWORD *)v8);
        std::vector<std::vector<float>>::emplace_back<std::vector<float>>((uint64_t *)(v8 + 8), (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        --v12;
      }
      while (v12);
      *(double *)(v8 + 80) = v11;
      *(_QWORD *)(v8 + 88) = v10;
      *(_QWORD *)(v8 + 56) = vcvtad_u64_f64(v11 / 20.0);
      v13 = v3 + 1968;
      this = *(_BYTE **)&v13[8 * v5];
      *(_QWORD *)&v13[8 * v5] = v8;
      if (this)
        this = (_BYTE *)std::default_delete<AUDspLibStatus::Queue>::operator()[abi:ne180100]((uint64_t)this);
      if (a3)
        return (_BYTE *)AUDspLibStatus::Queue::push(*(AUDspLibStatus::Queue **)&v13[8 * v5], a3);
    }
  }
  return this;
}

void sub_1B611BF08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v11;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  unint64_t v19;

  v13 = atomic_load((unint64_t *)(v11 + 96));
  v14 = *(_QWORD *)(v11 + 160);
  v15 = v14 - v13;
  v18 = v14 > v13;
  v16 = 5;
  if (!v18)
    v16 = 0;
  if (v16 != v15)
  {
    v17 = v16 + v13;
    v19 = v17 - 5;
    v18 = v17 > 5;
    if (v17 == 5)
      v17 = 0;
    if (v18)
      v17 = v19;
    atomic_store(v17, (unint64_t *)(v11 + 160));
  }
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  MEMORY[0x1BCC95CEC](v11, 0x1020C406132200BLL);
  _Unwind_Resume(a1);
}

uint64_t std::default_delete<AUDspLibStatus::Queue>::operator()[abi:ne180100](uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  BOOL v8;
  unint64_t v9;
  void **v11;

  v2 = atomic_load((unint64_t *)(a1 + 96));
  v3 = *(_QWORD *)(a1 + 160);
  v7 = v3 >= v2;
  v4 = v3 - v2;
  v8 = v3 == v2;
  v5 = 5;
  if (v8 || !v7)
    v5 = 0;
  if (v5 != v4)
  {
    v6 = v5 + v2;
    v7 = v6 >= 5;
    v9 = v6 - 5;
    v8 = v6 == 5;
    if (v6 == 5)
      v6 = 0;
    if (!v8 && v7)
      v6 = v9;
    atomic_store(v6, (unint64_t *)(a1 + 160));
  }
  v11 = (void **)(a1 + 8);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
  return MEMORY[0x1BCC95CEC](a1, 0x1020C406132200BLL);
}

uint64_t std::vector<std::vector<float>>::emplace_back<std::vector<float>>(uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v10;
    v16[4] = result;
    v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::__fs::filesystem::path>>(result, v12);
    v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((_QWORD *)v14 + 1) = 0;
    *((_QWORD *)v14 + 2) = 0;
    *(_QWORD *)v14 = 0;
    *(_OWORD *)v14 = *(_OWORD *)a2;
    *((_QWORD *)v14 + 2) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v16);
    v8 = (_QWORD *)a1[1];
    result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)v7 = *(_OWORD *)a2;
    v7[2] = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1B611C134(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<PowerMeter>::resize(void **a1, unint64_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  _BYTE *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  char *v24;

  v5 = (char *)*a1;
  v4 = (char *)a1[1];
  v6 = (v4 - (_BYTE *)*a1) >> 7;
  if (a2 <= v6)
  {
    if (a2 < v6)
      a1[1] = &v5[128 * a2];
  }
  else
  {
    v7 = a1[2];
    if (a2 - v6 <= (v7 - v4) >> 7)
    {
      v24 = &v4[128 * (a2 - v6)];
      do
      {
        *v4 = 0;
        *(_OWORD *)(v4 + 8) = xmmword_1B66A05F0;
        *(_OWORD *)(v4 + 24) = xmmword_1B66A0600;
        *((_QWORD *)v4 + 8) = 0;
        *((_WORD *)v4 + 28) = 0;
        *((_QWORD *)v4 + 10) = 0;
        *((_QWORD *)v4 + 11) = 0;
        *((_QWORD *)v4 + 12) = 0;
        *((_QWORD *)v4 + 13) = 0;
        *((_QWORD *)v4 + 14) = 0;
        *((_QWORD *)v4 + 15) = 0;
        *((_QWORD *)v4 + 5) = 0x3F90624DD2F1A9FCLL;
        *((_QWORD *)v4 + 6) = 0xFFFFFFFFLL;
        v4 += 128;
      }
      while (v4 != v24);
      a1[1] = v24;
    }
    else
    {
      if (a2 >> 57)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v8 = v7 - v5;
      v9 = (v7 - v5) >> 6;
      if (v9 <= a2)
        v9 = a2;
      if (v8 >= 0x7FFFFFFFFFFFFF80)
        v10 = 0x1FFFFFFFFFFFFFFLL;
      else
        v10 = v9;
      if (v10 >> 57)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v11 = (char *)operator new(v10 << 7);
      v12 = &v11[128 * v6];
      v13 = &v11[128 * a2];
      v14 = v12;
      do
      {
        *v14 = 0;
        *(_OWORD *)(v14 + 8) = xmmword_1B66A05F0;
        *(_OWORD *)(v14 + 24) = xmmword_1B66A0600;
        *((_QWORD *)v14 + 8) = 0;
        *((_WORD *)v14 + 28) = 0;
        *((_QWORD *)v14 + 10) = 0;
        *((_QWORD *)v14 + 11) = 0;
        *((_QWORD *)v14 + 12) = 0;
        *((_QWORD *)v14 + 13) = 0;
        *((_QWORD *)v14 + 14) = 0;
        *((_QWORD *)v14 + 15) = 0;
        *((_QWORD *)v14 + 5) = 0x3F90624DD2F1A9FCLL;
        *((_QWORD *)v14 + 6) = 0xFFFFFFFFLL;
        v14 += 128;
      }
      while (v14 != v13);
      v15 = &v11[128 * v10];
      v17 = (char *)*a1;
      v16 = (char *)a1[1];
      if (v16 != *a1)
      {
        do
        {
          v18 = *((_OWORD *)v16 - 8);
          v19 = *((_OWORD *)v16 - 7);
          v20 = *((_OWORD *)v16 - 5);
          *((_OWORD *)v12 - 6) = *((_OWORD *)v16 - 6);
          *((_OWORD *)v12 - 5) = v20;
          *((_OWORD *)v12 - 8) = v18;
          *((_OWORD *)v12 - 7) = v19;
          v21 = *((_OWORD *)v16 - 4);
          v22 = *((_OWORD *)v16 - 3);
          v23 = *((_OWORD *)v16 - 1);
          *((_OWORD *)v12 - 2) = *((_OWORD *)v16 - 2);
          *((_OWORD *)v12 - 1) = v23;
          *((_OWORD *)v12 - 4) = v21;
          *((_OWORD *)v12 - 3) = v22;
          v12 -= 128;
          v16 -= 128;
        }
        while (v16 != v17);
        v16 = (char *)*a1;
      }
      *a1 = v12;
      a1[1] = v13;
      a1[2] = v15;
      if (v16)
        operator delete(v16);
    }
  }
}

uint64_t SimpleMeters::HandleGetProperty(SimpleMeters *this, int a2, unsigned int a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t Value;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  uint64_t v26;
  uint64_t i;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;

  *a5 = 0;
  if (a2 == 3099)
  {
    if (a3 > 1 || (v10 = *(_QWORD *)this, v11 = *((_QWORD *)this + 1), *(_QWORD *)this == v11))
    {
      v12 = 0;
      v13 = 0;
      v14 = 0;
    }
    else
    {
      v12 = 0;
      v13 = 0;
      v14 = 0;
      do
      {
        Value = PowerMeter::GetValue((PowerMeter *)v10);
        v17 = Value;
        v18 = v16;
        if ((unint64_t)v13 >= v14)
        {
          v19 = ((char *)v13 - (char *)v12) >> 4;
          v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 60)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          if ((uint64_t)(v14 - (_QWORD)v12) >> 3 > v20)
            v20 = (uint64_t)(v14 - (_QWORD)v12) >> 3;
          if (v14 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0)
            v21 = 0xFFFFFFFFFFFFFFFLL;
          else
            v21 = v20;
          if (v21)
            v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v21);
          else
            v22 = 0;
          v23 = (unint64_t *)(v21 + 16 * v19);
          *v23 = v17;
          v23[1] = v18;
          if (v13 == v12)
          {
            v25 = (unint64_t *)(v21 + 16 * v19);
          }
          else
          {
            v24 = v21 + 16 * v19;
            do
            {
              v25 = (unint64_t *)(v24 - 16);
              *(_OWORD *)(v24 - 16) = *((_OWORD *)v13 - 1);
              v13 -= 2;
              v24 -= 16;
            }
            while (v13 != v12);
          }
          v14 = v21 + 16 * v22;
          v13 = v23 + 2;
          if (v12)
            operator delete(v12);
          v12 = v25;
        }
        else
        {
          *v13 = Value;
          v13[1] = v16;
          v13 += 2;
        }
        *(_WORD *)(v10 + 56) = 0;
        *(_DWORD *)(v10 + 52) = 0;
        v10 += 128;
      }
      while (v10 != v11);
    }
    if ((a3 & 0xFFFFFFFD) == 0)
    {
      v26 = *((_QWORD *)this + 3);
      for (i = *((_QWORD *)this + 4); v26 != i; v26 += 128)
      {
        v28 = PowerMeter::GetValue((PowerMeter *)v26);
        v30 = v28;
        v31 = v29;
        if ((unint64_t)v13 >= v14)
        {
          v32 = ((char *)v13 - (char *)v12) >> 4;
          v33 = v32 + 1;
          if ((unint64_t)(v32 + 1) >> 60)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          if ((uint64_t)(v14 - (_QWORD)v12) >> 3 > v33)
            v33 = (uint64_t)(v14 - (_QWORD)v12) >> 3;
          if (v14 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0)
            v34 = 0xFFFFFFFFFFFFFFFLL;
          else
            v34 = v33;
          if (v34)
            v34 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v34);
          else
            v35 = 0;
          v36 = (unint64_t *)(v34 + 16 * v32);
          *v36 = v30;
          v36[1] = v31;
          if (v13 == v12)
          {
            v38 = (unint64_t *)(v34 + 16 * v32);
          }
          else
          {
            v37 = v34 + 16 * v32;
            do
            {
              v38 = (unint64_t *)(v37 - 16);
              *(_OWORD *)(v37 - 16) = *((_OWORD *)v13 - 1);
              v13 -= 2;
              v37 -= 16;
            }
            while (v13 != v12);
          }
          v14 = v34 + 16 * v35;
          v13 = v36 + 2;
          if (v12)
            operator delete(v12);
          v12 = v38;
        }
        else
        {
          *v13 = v28;
          v13[1] = v29;
          v13 += 2;
        }
        *(_WORD *)(v26 + 56) = 0;
        *(_DWORD *)(v26 + 52) = 0;
      }
    }
    memcpy(a4, v12, (char *)v13 - (char *)v12);
    if (v12)
      operator delete(v12);
    return 1;
  }
  result = 0;
  if (a2 != 3007)
    return result;
  if (a3 == 2)
  {
    v9 = *((_DWORD *)this + 13);
  }
  else if (a3 == 1)
  {
    v9 = *((_DWORD *)this + 12);
  }
  else
  {
    if (a3)
    {
      *a5 = -10866;
      return 1;
    }
    v9 = *((_DWORD *)this + 12);
    if (v9)
      v9 = *((_DWORD *)this + 13) != 0;
  }
  *a4 = v9;
  return 1;
}

void sub_1B611C5C8(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void AUDspLib::getChannelSplitMode(AUDspLib *this, const __CFDictionary **a2)
{
  CFNumberRef v3;
  __CFDictionary *Mutable;

  v3 = CFNumberCreate(0, kCFNumberIntType, (char *)this + 1588);
  Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("channelSplitMode"), v3);
  *a2 = CFDictionaryCreateCopy(0, Mutable);
  CFRelease(v3);
  CFRelease(Mutable);
}

uint64_t AUDspLib::getPropertyStatus(AUDspLib *this, int a2, unsigned int a3, CFDictionaryRef *a4)
{
  int v6;
  uint64_t result;
  uint64_t v8;
  unint64_t *v9;
  CFMutableArrayRef Mutable;
  CFDataRef v11;
  CFTypeRef v12;
  __CFArray *v13;
  CFDictionaryRef CFDictionaryRef;
  uint64_t v15;
  const void *v16;
  const void *v17;
  uint64_t v18;
  CFDictionaryRef v19;
  uint64_t i;
  const void *v21;
  const void *v22;
  unsigned int v23;
  unint64_t *v24;
  std::runtime_error *exception;
  std::runtime_error *v26;
  std::runtime_error *v27;
  unint64_t *v28;
  unint64_t *v29;
  CFTypeRef cf;
  __int128 *v31;
  uint64_t v32;
  CFMutableArrayRef v33;
  void *v34[2];
  __int128 v35;
  _OWORD v36[2];
  __int128 v37;
  int v38;
  const UInt8 *v39;
  uint64_t v40;
  void *__p;
  _BYTE *v42;
  uint64_t valuePtr;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  int v49;
  void *v50;
  int64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _BYTE v55[16];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v6 = *((_DWORD *)this + 397);
  if (a2 && !v6 || a2 != 4 && v6 == 1)
    return 4294956430;
  if (a3 > 0x11)
    return 4294956419;
  if (v6)
    v8 = a3;
  else
    v8 = 0;
  v9 = (unint64_t *)*((_QWORD *)this + v8 + 246);
  if (!v9)
    return 4294956417;
  if (*((_BYTE *)this + 2112))
  {
    std::vector<float>::vector(&__p, *v9);
    *(_OWORD *)v34 = 0u;
    v35 = 0u;
    memset(v36, 0, sizeof(v36));
    v37 = 0u;
    v38 = 0;
    v39 = (const UInt8 *)__p;
    v40 = (v42 - (_BYTE *)__p) >> 2;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v28 = v9;
    v33 = Mutable;
    v29 = v9 + 12;
    while (1)
    {
      *(_QWORD *)&v44 = v34;
      if (!boost::lockfree::detail::compile_time_sized_ringbuffer<AUDspLibStatus::Status,4ul>::consume_one<boost::lockfree::detail::consume_via_copy<AUDspLibStatus::Status>>(v29, (uint64_t *)&v44))break;
      v11 = CFDataCreate(0, v39, 4 * v40);
      if (!v11)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cf, v11);
      applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v44, "buffer");
      v12 = cf;
      if (cf)
        CFRetain(cf);
      *((_QWORD *)&v44 + 1) = v12;
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>((applesauce::CF::TypeRef *)&v45, "statusCounter", (uint64_t *)&v35 + 1);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>((applesauce::CF::TypeRef *)&v46, "audioBlockSize", (uint64_t *)v36);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>((applesauce::CF::TypeRef *)&v47, "numFramesForStatus", (uint64_t *)&v35);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v48, "percentCPUAverage", (int *)v34 + 1);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v49, "percentCPUPeak", (int *)v34);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v51, "megaCyclesPerSecondAverage", (int *)&v34[1]);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v52, "megaCyclesPerSecondPeak", (int *)((unint64_t)v34 | 0xC));
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v53, "latencyInMilliseconds", (int *)&v37 + 2);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)&v54, "megaInstructionsPerSecondAverage", (int *)&v37 + 3);
      applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>((applesauce::CF::TypeRef *)v55, "megaInstructionsPerSecondPeak", &v38);
      v13 = Mutable;
      v31 = &v44;
      v32 = 11;
      CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v31);
      v15 = 0;
      valuePtr = (uint64_t)CFDictionaryRef;
      do
      {
        v16 = *(const void **)&v55[v15 + 8];
        if (v16)
          CFRelease(v16);
        v17 = *(const void **)&v55[v15];
        if (v17)
          CFRelease(v17);
        v15 -= 16;
      }
      while (v15 != -176);
      if (cf)
        CFRelease(cf);
      Mutable = v13;
      CFArrayAppendValue(v13, CFDictionaryRef);
      if (CFDictionaryRef)
        CFRelease(CFDictionaryRef);
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v44, "queueSize");
    valuePtr = 4;
    *((_QWORD *)&v44 + 1) = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
    if (!*((_QWORD *)&v44 + 1))
    {
      v26 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v26, "Could not construct");
    }
    applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>((applesauce::CF::TypeRef *)&v45, "numAudioChannels", (uint64_t *)v28 + 11);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v46, "audioSampleRate");
    valuePtr = v28[10];
    *((_QWORD *)&v46 + 1) = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    if (!*((_QWORD *)&v46 + 1))
    {
      v27 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v27, "Could not construct");
    }
    if (Mutable)
      CFRetain(Mutable);
    applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&valuePtr, Mutable);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v47, "arrayOfDictionaries");
    v18 = valuePtr;
    if (valuePtr)
      CFRetain((CFTypeRef)valuePtr);
    *((_QWORD *)&v47 + 1) = v18;
    v31 = &v44;
    v32 = 4;
    v19 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v31);
    for (i = 0; i != -64; i -= 16)
    {
      v21 = *(const void **)((char *)&v47 + i + 8);
      if (v21)
        CFRelease(v21);
      v22 = *(const void **)((char *)&v47 + i);
      if (v22)
        CFRelease(v22);
    }
    if (valuePtr)
      CFRelease((CFTypeRef)valuePtr);
    if (Mutable)
      CFRelease(Mutable);
    if (__p)
    {
      v42 = __p;
      operator delete(__p);
    }
    result = 0;
    *a4 = v19;
  }
  else
  {
    v23 = (*(uint64_t (**)(AUDspLib *))(*(_QWORD *)this + 608))(this);
    std::vector<float>::vector(v34, v23);
    v44 = 0u;
    v45 = 0u;
    v46 = 0u;
    v47 = 0u;
    v48 = 0u;
    v49 = 0;
    v50 = v34[0];
    v51 = ((char *)v34[1] - (char *)v34[0]) >> 2;
    do
    {
      v24 = (unint64_t *)(*((_QWORD *)this + v8 + 246) + 96);
      __p = &v44;
    }
    while (boost::lockfree::detail::compile_time_sized_ringbuffer<AUDspLibStatus::Status,4ul>::consume_one<boost::lockfree::detail::consume_via_copy<AUDspLibStatus::Status>>(v24, (uint64_t *)&__p));
    *((_BYTE *)this + 56 * v8 + 576) = 1;
    *a4 = CFDataCreate(0, (const UInt8 *)v34[0], (char *)v34[1] - (char *)v34[0]);
    if (v34[0])
    {
      v34[1] = v34[0];
      operator delete(v34[0]);
    }
    return 0;
  }
  return result;
}

void sub_1B611CC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,const void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,uint64_t a47,char a48,int a49,__int16 a50,char a51,char a52,CFTypeRef a53,uint64_t a54,uint64_t a55,uint64_t a56,CFTypeRef cf)
{
  const void **v57;

  if (cf)
    CFRelease(cf);
  applesauce::CF::TypeRef::~TypeRef(v57);
  while (v57 != (const void **)&a50)
  {
    v57 -= 2;
    applesauce::CF::TypeRefPair::~TypeRefPair((applesauce::CF::TypeRefPair *)v57);
  }
  applesauce::CF::ObjectRef<__CFArray *>::~ObjectRef(&a30);
  if (__p)
  {
    a46 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t AUDspLib::getPropertyDspLibAUParameters(AUDspLib *this, int a2, unsigned int a3, CFMutableDictionaryRef *a4)
{
  int v7;
  uint64_t result;
  CFMutableDictionaryRef Mutable;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  CFMutableDictionaryRef v13;
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v7 = *((_DWORD *)this + 397);
  if (a2 && !v7 || a2 != 4 && v7 == 1)
    return 4294956430;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (*((_DWORD *)this + 397))
    v10 = a3;
  else
    v10 = 0;
  v13 = Mutable;
  v14[0] = &off_1E69C7428;
  v14[1] = &v13;
  v15 = v14;
  (*(void (**)(AUDspLib *, uint64_t, _QWORD *))(*(_QWORD *)this + 624))(this, v10, v14);
  v11 = v15;
  if (v15 == v14)
  {
    v12 = 4;
    v11 = v14;
    goto LABEL_13;
  }
  if (v15)
  {
    v12 = 5;
LABEL_13:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
  result = 0;
  *a4 = v13;
  return result;
}

void sub_1B611CF38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void std::__function::__func<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0,std::allocator<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0>,void ()(unsigned int,unsigned int,float)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0,std::allocator<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E69C7428;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0,std::allocator<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E69C7428;
  a2[1] = v2;
  return result;
}

void std::__function::__func<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0,std::allocator<AUDspLib::getPropertyDspLibAUParameters(unsigned int,unsigned int,void *)::$_0>,void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3, int *a4)
{
  uint64_t v5;
  const __CFAllocator *v6;
  CFStringRef v7;
  CFNumberRef v8;
  int valuePtr;

  v5 = *a3;
  valuePtr = *a4;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d"), v5);
  v8 = CFNumberCreate(v6, kCFNumberFloatType, &valuePtr);
  CFDictionaryAddValue(**(CFMutableDictionaryRef **)(a1 + 8), v7, v8);
  CFRelease(v7);
  CFRelease(v8);
}

BOOL boost::lockfree::detail::compile_time_sized_ringbuffer<AUDspLibStatus::Status,4ul>::consume_one<boost::lockfree::detail::consume_via_copy<AUDspLibStatus::Status>>(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  __int128 v10;
  uint64_t v11;

  v2 = atomic_load(a1);
  v3 = a1[8];
  if (v2 != v3)
  {
    v5 = a1 + 9;
    v6 = (uint64_t)&a1[13 * v3 + 9];
    v7 = *a2;
    v8 = *(_QWORD *)(v6 + 96);
    if (v8)
    {
      memmove(*(void **)(v7 + 88), (const void *)v5[13 * v3 + 11], 4 * v8);
      v8 = *(_QWORD *)(v6 + 96);
    }
    *(_QWORD *)(v7 + 96) = v8;
    v9 = &v5[13 * v3];
    v10 = *((_OWORD *)v9 + 1);
    *(_OWORD *)v7 = *(_OWORD *)v6;
    *(_OWORD *)(v7 + 16) = v10;
    *(_QWORD *)(v7 + 32) = v9[4];
    *(_QWORD *)(v7 + 40) = v9[5];
    *(_QWORD *)(v7 + 48) = v9[6];
    *(_QWORD *)(v7 + 72) = v9[9];
    *(_DWORD *)(v7 + 80) = *((_DWORD *)v9 + 20);
    v11 = 4;
    if (v3 + 1 < 4)
      v11 = v3 + 1;
    atomic_store((v3 - v11 + 5) % 5 - (5 - v11) + 1, a1 + 8);
  }
  return v2 != v3;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long &>(applesauce::CF::TypeRef *a1, char *a2, uint64_t *a3)
{
  CFNumberRef v5;
  std::runtime_error *exception;
  uint64_t valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B611D204(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B611D2CC(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

unint64_t PowerMeter::GetValue(PowerMeter *this)
{
  double v2;
  unsigned int v3;
  uint64_t v4;
  double v5;
  unsigned int v6;
  unint64_t v7;

  v2 = *((double *)this + 14);
  if (v2 <= 0.000001)
  {
    v4 = 3270508544;
  }
  else
  {
    *(float *)&v3 = log10(fmax(v2, 2.22507386e-308)) * 20.0;
    v4 = v3;
  }
  v5 = *((double *)this + 15);
  if (v5 <= 0.000001)
  {
    v7 = 0xC2F0000000000000;
  }
  else
  {
    *(float *)&v6 = log10(fmax(v5, 2.22507386e-308)) * 20.0;
    v7 = (unint64_t)v6 << 32;
  }
  return v7 | v4;
}

uint64_t SimpleMeters::Reset(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_DWORD *)(this + 48))
  {
    v1 = *(_QWORD *)(this + 8);
    if (*(_QWORD *)this != v1)
    {
      v2 = *(_QWORD *)this + 52;
      do
      {
        *(_QWORD *)(v2 + 12) = 0;
        *(_WORD *)(v2 + 4) = 0;
        *(_QWORD *)(v2 + 36) = 0;
        *(_QWORD *)(v2 + 28) = 0;
        *(_QWORD *)(v2 + 52) = 0;
        *(_QWORD *)(v2 + 44) = 0;
        *(_QWORD *)(v2 + 68) = 0;
        v3 = v2 + 76;
        *(_QWORD *)(v2 + 60) = 0;
        *(_QWORD *)(v2 - 4) = 0xFFFFFFFFLL;
        v2 += 128;
      }
      while (v3 != v1);
    }
  }
  if (*(_DWORD *)(this + 52))
  {
    v5 = *(_QWORD *)(this + 24);
    v4 = *(_QWORD *)(this + 32);
    if (v5 != v4)
    {
      v6 = v5 + 52;
      do
      {
        *(_QWORD *)(v6 + 12) = 0;
        *(_WORD *)(v6 + 4) = 0;
        *(_QWORD *)(v6 + 36) = 0;
        *(_QWORD *)(v6 + 28) = 0;
        *(_QWORD *)(v6 + 52) = 0;
        *(_QWORD *)(v6 + 44) = 0;
        *(_QWORD *)(v6 + 68) = 0;
        v7 = v6 + 76;
        *(_QWORD *)(v6 + 60) = 0;
        *(_QWORD *)(v6 - 4) = 0xFFFFFFFFLL;
        v6 += 128;
      }
      while (v7 != v4);
    }
  }
  return this;
}

void SimpleMeters::Initialize(SimpleMeters *this, const CAStreamBasicDescription *a2, const CAStreamBasicDescription *a3)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  double *v8;
  double *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double *v16;
  double *v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;

  v4 = *(_OWORD *)a2;
  v5 = *((_OWORD *)a2 + 1);
  *((_QWORD *)this + 11) = *((_QWORD *)a2 + 4);
  *(_OWORD *)((char *)this + 72) = v5;
  *(_OWORD *)((char *)this + 56) = v4;
  v6 = *(_OWORD *)a3;
  v7 = *((_OWORD *)a3 + 1);
  *((_QWORD *)this + 16) = *((_QWORD *)a3 + 4);
  *((_OWORD *)this + 6) = v6;
  *((_OWORD *)this + 7) = v7;
  if (*((_DWORD *)this + 12))
  {
    std::vector<PowerMeter>::resize((void **)this, *((unsigned int *)this + 21));
    v8 = *(double **)this;
    v9 = (double *)*((_QWORD *)this + 1);
    if (*(double **)this != v9)
    {
      v10 = *((double *)this + 7);
      if (v10 * 2.5 >= 2.22507386e-308)
        v11 = -2.76310211 / v10;
      else
        v11 = -INFINITY;
      v12 = exp(v11);
      if (v11 >= -708.4)
        v13 = v12;
      else
        v13 = 0.0;
      if (v10 * 1.24 >= 2.22507386e-308)
        v14 = -5.57077039 / v10;
      else
        v14 = -INFINITY;
      v15 = exp(v14);
      if (v14 < -708.4)
        v15 = 0.0;
      do
      {
        v8[1] = v10;
        v8[2] = v13;
        v8[4] = v15;
        v8 += 16;
      }
      while (v8 != v9);
    }
  }
  if (*((_DWORD *)this + 13))
  {
    std::vector<PowerMeter>::resize((void **)this + 3, *((unsigned int *)this + 31));
    v16 = (double *)*((_QWORD *)this + 3);
    v17 = (double *)*((_QWORD *)this + 4);
    if (v16 != v17)
    {
      v18 = *((double *)this + 12);
      if (v18 * 2.5 >= 2.22507386e-308)
        v19 = -2.76310211 / v18;
      else
        v19 = -INFINITY;
      v20 = exp(v19);
      if (v19 >= -708.4)
        v21 = v20;
      else
        v21 = 0.0;
      if (v18 * 1.24 >= 2.22507386e-308)
        v22 = -5.57077039 / v18;
      else
        v22 = -INFINITY;
      v23 = exp(v22);
      if (v22 < -708.4)
        v23 = 0.0;
      do
      {
        v16[1] = v18;
        v16[2] = v21;
        v16[4] = v23;
        v16 += 16;
      }
      while (v16 != v17);
    }
  }
}

void std::vector<DspLibBuffer>::resize(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;
  DspLibBuffer *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  DspLibBuffer *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t i;
  uint64_t v21;
  const DspLibBuffer *v22;
  DspLibBuffer *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  char *v29;
  _BYTE v30[24];
  _QWORD *v31;

  v4 = *a1;
  v5 = (DspLibBuffer *)a1[1];
  v6 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *a1) >> 5);
  v7 = a2 - v6;
  if (a2 <= v6)
  {
    if (a2 < v6)
    {
      v23 = (DspLibBuffer *)(v4 + 96 * a2);
      while (v5 != v23)
      {
        v5 = (DspLibBuffer *)((char *)v5 - 96);
        DspLibBuffer::~DspLibBuffer(v5);
      }
      a1[1] = v23;
    }
  }
  else
  {
    v8 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)v5) >> 5) >= v7)
    {
      v24 = (char *)v5 + 96 * v7;
      v25 = 96 * a2 - 32 * (((uint64_t)v5 - *a1) >> 5);
      do
      {
        DspLibBuffer::DspLibBuffer(v5);
        v5 = (DspLibBuffer *)((char *)v5 + 96);
        v25 -= 96;
      }
      while (v25);
      a1[1] = v24;
    }
    else
    {
      if (a2 > 0x2AAAAAAAAAAAAAALL)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v9 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v4) >> 5);
      v10 = 2 * v9;
      if (2 * v9 <= a2)
        v10 = a2;
      if (v9 >= 0x155555555555555)
        v11 = 0x2AAAAAAAAAAAAAALL;
      else
        v11 = v10;
      v31 = a1 + 2;
      if (v11 > 0x2AAAAAAAAAAAAAALL)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v12 = 3 * v11;
      v13 = (char *)operator new(96 * v11);
      v14 = (DspLibBuffer *)&v13[96 * v6];
      v29 = v13;
      *(_QWORD *)v30 = v14;
      *(_QWORD *)&v30[8] = v14;
      *(_QWORD *)&v30[16] = &v13[32 * v12];
      v15 = 3 * a2;
      v16 = &v13[96 * a2];
      v17 = 32 * v15 - 96 * v6;
      do
      {
        DspLibBuffer::DspLibBuffer(v14);
        v14 = (DspLibBuffer *)((char *)v14 + 96);
        v17 -= 96;
      }
      while (v17);
      *(_QWORD *)&v30[8] = v16;
      v19 = *a1;
      v18 = a1[1];
      for (i = 96; ; i -= 96)
      {
        v21 = *(_QWORD *)v30 + i;
        if (v18 + i - 96 == v19)
          break;
        v22 = (const DspLibBuffer *)(v18 + i - 192);
        DspLibBuffer::DspLibBuffer((DspLibBuffer *)(v21 - 192), v22);
      }
      v26 = a1[2];
      v27 = *(_OWORD *)&v30[8];
      v28 = *(_OWORD *)a1;
      *a1 = v21 - 96;
      *(_OWORD *)v30 = v28;
      *(_OWORD *)(a1 + 1) = v27;
      *(_QWORD *)&v30[16] = v26;
      v29 = (char *)v28;
      std::__split_buffer<DspLibBuffer>::~__split_buffer((uint64_t)&v29);
    }
  }
}

uint64_t std::__split_buffer<DspLibBuffer>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 96;
    DspLibBuffer::~DspLibBuffer((DspLibBuffer *)(i - 96));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__function::__func<AUDspLib::Initialize(void)::$_0,std::allocator<AUDspLib::Initialize(void)::$_0>,void ()(unsigned int,unsigned int,float)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

__n128 std::__function::__func<AUDspLib::Initialize(void)::$_0,std::allocator<AUDspLib::Initialize(void)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E69C7350;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AUDspLib::Initialize(void)::$_0,std::allocator<AUDspLib::Initialize(void)::$_0>,void ()(unsigned int,unsigned int,float)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E69C7350;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

float std::__function::__func<AUDspLib::Initialize(void)::$_0,std::allocator<AUDspLib::Initialize(void)::$_0>,void ()(unsigned int,unsigned int,float)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3, float *a4)
{
  float result;

  result = *a4;
  *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 56 * **(unsigned int **)(a1 + 16) + 544) + 4 * *a2) = *a4;
  return result;
}

uint64_t ausdk::AUScope::Initialize(int64x2_t *this, ausdk::AUBase *a2, __int32 a3, uint64_t a4)
{
  uint64_t v5;

  this->i64[0] = (uint64_t)a2;
  this->i32[2] = a3;
  v5 = this[2].i64[1];
  if (!v5)
    return ausdk::AUScope::SetNumberOfElements(this, a4);
  *(_QWORD *)(v5 + 8) = a2;
  *(_DWORD *)(v5 + 16) = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 16))(v5, a4);
}

uint64_t AUDspLibWithNewParameters::SetParameter(AUDspLibWithNewParameters *this, uint64_t a2, unsigned int a3, uint64_t a4, float a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v13;
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  uint64_t v23;
  _BYTE v24[12];
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  if (a4 > 0x11)
    return 4294956419;
  v25 = v8;
  v26 = v7;
  v27 = v5;
  v28 = v6;
  v13 = a2;
  if ((_DWORD)a2 == 1869769061 || (_DWORD)a2 == 1937141612)
    goto LABEL_5;
  v17 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 271) + 8))(*((_QWORD *)this + 271), a2);
  *(_QWORD *)v24 = v17;
  *(_DWORD *)&v24[8] = v18;
  if (DspLib::isValid((uint64_t)this + 2176, (int *)v24))
  {
    v19 = *((_QWORD *)this + 66);
    if (v19)
    {
      v20 = *((_DWORD *)this + 397);
      if (!(v20 | a3))
      {
        (*(void (**)(_QWORD, _QWORD, uint64_t, float))(*(_QWORD *)v19 + 272))(*((_QWORD *)this + 66), *(_QWORD *)&v24[4], v17, a5);
        v20 = *((_DWORD *)this + 397);
      }
      if (a3 == 4 && v20 == 1)
      {
        v21 = *((_QWORD *)this + 197);
        if (v21)
        {
          v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v21 + 32))(v21, a4);
        }
        else
        {
          v23 = *((_QWORD *)this + 194);
          if (a4 >= (unint64_t)((*((_QWORD *)this + 195) - v23) >> 3))
            v22 = 0;
          else
            v22 = *(ausdk::AUElement **)(v23 + 8 * a4);
        }
        ausdk::AUElement::SetParameter(v22, v13, a5, 0);
        (*(void (**)(uint64_t, _QWORD, uint64_t, float))(*(_QWORD *)v19 + 272))(v19, *(_QWORD *)&v24[4], v17, a5);
      }
    }
LABEL_5:
    *((_BYTE *)this + 1820) = 1;
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    ausdk::AUElement::SetParameter(Element, v13, a5, 0);
    return 0;
  }
  return 4294956418;
}

uint64_t AUDspLibWithNewParameters::GetParameterInfo(AUDspLibWithNewParameters *this, unsigned int a2, uint64_t a3, AudioUnitParameterInfo *a4)
{
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  AudioUnitParameterUnit v12;
  uint64_t result;
  const __CFString *v14;
  UInt32 v15;
  uint64_t v16;
  unsigned int v17;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 271) + 8))(*((_QWORD *)this + 271), a3);
  v9 = v8;
  v16 = v7;
  v17 = v8;
  if (!DspLib::isValid((uint64_t)this + 2176, (int *)&v16))
    return 4294956418;
  v10 = DspLib::SystemParametersDefinition::operator[]((uint64_t)this + 2176, v7, v9);
  v11 = *(unsigned int *)(v10 + 8);
  if (v11 > 0x11)
    v12 = kAudioUnitParameterUnit_Decibels;
  else
    v12 = dword_1B66300DC[v11];
  a4->unit = v12;
  a4->flags = -1048576000;
  *(_QWORD *)&a4->minValue = *(_QWORD *)(v10 + 16);
  a4->defaultValue = *(AudioUnitParameterValue *)(v10 + 12);
  v14 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(const char **)v10, 0x8000100u);
  a4->cfNameString = v14;
  a4->flags |= 0x8000010u;
  CFStringGetCString(v14, a4->name, 52, 0x8000100u);
  v15 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 271) + 16))(*((_QWORD *)this + 271), a3);
  result = 0;
  a4->clumpID = v15;
  a4->flags |= 0x100000u;
  return result;
}

uint64_t AUDspLibWithNewParameters::CopyClumpName(AUDspLibWithNewParameters *this, unsigned int a2, uint64_t a3, unsigned int a4, CFMutableStringRef *a5)
{
  unsigned int v8;
  const char ***v9;
  const char **v10;
  const __CFAllocator *v11;
  const __CFString *v12;
  unsigned int v13;
  const char *v14;
  const __CFString *v15;
  CFMutableStringRef Mutable;

  v8 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 271) + 24))(*((_QWORD *)this + 271), a3);
  if (*((_DWORD *)this + 548) + 1 <= v8
    || (!v8
      ? (v9 = (const char ***)((char *)this + 2176))
      : (v9 = (const char ***)(*((_QWORD *)this + 273) + 8 * (v8 - 1))),
        v10 = *v9,
        v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00],
        v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], **v9, 0x8000100u),
        v13 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 271) + 32))(*((_QWORD *)this + 271), a3), v14 = v10[1], v13 >= *((_DWORD *)v14 + 2)))
  {
    abort();
  }
  v15 = CFStringCreateWithCString(v11, *(const char **)(*(_QWORD *)v14 + 16 * v13), 0x8000100u);
  Mutable = CFStringCreateMutable(v11, 0);
  CFStringAppend(Mutable, v12);
  CFStringAppend(Mutable, CFSTR(", "));
  CFStringAppend(Mutable, v15);
  CFRelease(v12);
  CFRelease(v15);
  *a5 = Mutable;
  return 0;
}

void AUDspLibWithNewParameters::setParametersOnInstance(AUDspLibWithNewParameters *this, unsigned int a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  _QWORD *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  void *__p;
  void *v12;
  uint64_t v13;

  if (*((_DWORD *)this + 548) != -1)
  {
    v3 = 0;
    v4 = 0;
    v5 = *((_QWORD *)this + 7 * a2 + 66);
    v6 = (_QWORD *)((char *)this + 56 * a2 + 544);
    do
    {
      v7 = v4;
      v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 248))(v5, v3);
      v10 = *(_QWORD *)v8;
      v12 = 0;
      v13 = 0;
      __p = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)(v8 + 8), *(_QWORD *)(v8 + 16), (uint64_t)(*(_QWORD *)(v8 + 16) - *(_QWORD *)(v8 + 8)) >> 2);
      for (i = 0; ; i = (i + 1))
      {
        v4 = v7 + i;
        if (i >= DspLib::groupOffset(v10, *(_DWORD *)(*(_QWORD *)(v10 + 8) + 8)))
          break;
        DspLib::AlgorithmParametersInstance::setValue((DspLib::AlgorithmParametersInstance *)&v10, i, *(float *)(*v6 + 4 * v4));
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(_QWORD *)v5 + 256))(v5, &v10, v3);
      if (__p)
      {
        v12 = __p;
        operator delete(__p);
      }
      v3 = (v3 + 1);
    }
    while (v3 < *((_DWORD *)this + 548) + 1);
  }
}

void sub_1B611DE78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t AUDspLibWithNewParameters::gatherParametersForInstance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  ausdk::AUScope *v9;
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  ausdk::AUElement *Element;
  float Parameter;
  uint64_t v17;
  uint64_t v18;

  v6 = 0;
  v7 = a1 + 2176;
  v8 = a2;
  v9 = (ausdk::AUScope *)(a1 + 32);
  while (1)
  {
    result = DspLib::algorithmOffset(v7, *(_DWORD *)(a1 + 2192) + 1);
    if (v6 >= result)
      break;
    v11 = DspLib::parameterAddress(v7, v6);
    v13 = (***(uint64_t (****)(_QWORD, uint64_t, _QWORD))(a1 + 2168))(*(_QWORD *)(a1 + 2168), v11, v12);
    if (*(_DWORD *)(a1 + 1588) == 1)
    {
      v14 = *(_QWORD *)(a1 + 1576);
      if (v14)
      {
        Element = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 32))(v14, a2);
      }
      else
      {
        v18 = *(_QWORD *)(a1 + 1552);
        if (v8 >= (*(_QWORD *)(a1 + 1560) - v18) >> 3)
          Element = 0;
        else
          Element = *(ausdk::AUElement **)(v18 + 8 * v8);
      }
    }
    else
    {
      Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v9, 0);
    }
    Parameter = ausdk::AUElement::GetParameter(Element, v13);
    v17 = *(_QWORD *)(a3 + 24);
    if (v17)
      std::function<void ()(unsigned int,unsigned int,float)>::operator()(v17, v6, v13, Parameter);
    v6 = (v6 + 1);
  }
  return result;
}

BOOL DspLib::isValid(uint64_t a1, int *a2)
{
  int v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *a2;
  if (*a2 >= (*(_DWORD *)(a1 + 16) + 1))
    return 0;
  v3 = (uint64_t *)(v2 ? *(_QWORD *)(a1 + 8) + 8 * (v2 - 1) : a1);
  v4 = *v3;
  v5 = a2[1];
  v6 = *(_QWORD *)(v4 + 8);
  return v5 < *(_DWORD *)(v6 + 8)
      && a2[2] < *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v6 + 16 * v5 + 8) + 8);
}

uint64_t AUDspLib::AUDspLib(uint64_t a1, OpaqueAudioComponentInstance *a2, uint64_t a3, __int128 *a4, uint64_t a5, char a6)
{
  ausdk::AUBase *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  unint64_t v22;
  unint64_t v23;
  float v24;
  ausdk::AUElement *Element;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  ausdk::AUElement *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void **v34;
  int64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;

  v11 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  v12 = 0;
  *(_QWORD *)v11 = off_1E69C6E28;
  do
  {
    v13 = a1 + v12;
    *(_QWORD *)(v13 + 528) = 0;
    *(_BYTE *)(v13 + 536) = 0;
    *(_OWORD *)(v13 + 544) = 0uLL;
    *(_OWORD *)(v13 + 560) = 0uLL;
    v12 += 56;
    *(_BYTE *)(v13 + 576) = 0;
  }
  while (v12 != 1008);
  *(_QWORD *)(a1 + 1536) = 0;
  *(_DWORD *)(a1 + 1544) = 0;
  *(_OWORD *)(a1 + 1552) = 0u;
  *(_OWORD *)(a1 + 1568) = 0u;
  *(_WORD *)(a1 + 1584) = 0;
  *(_BYTE *)(a1 + 1586) = a6;
  *(_DWORD *)(a1 + 1588) = 0;
  v14 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a1 + 1592) = *(_OWORD *)a3;
  *(_OWORD *)(a1 + 1608) = v14;
  v15 = *(_OWORD *)(a3 + 32);
  v16 = *(_OWORD *)(a3 + 48);
  v17 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)(a1 + 1656) = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(a1 + 1672) = v17;
  *(_OWORD *)(a1 + 1624) = v15;
  *(_OWORD *)(a1 + 1640) = v16;
  v18 = *(_OWORD *)(a3 + 96);
  v19 = *(_OWORD *)(a3 + 112);
  v20 = *(_OWORD *)(a3 + 144);
  *(_OWORD *)(a1 + 1720) = *(_OWORD *)(a3 + 128);
  *(_OWORD *)(a1 + 1736) = v20;
  *(_OWORD *)(a1 + 1688) = v18;
  *(_OWORD *)(a1 + 1704) = v19;
  *(_DWORD *)(a1 + 1752) = *(_QWORD *)(a3 + 88);
  *(_DWORD *)(a1 + 1756) = *(_QWORD *)(a3 + 104);
  v21 = *a4;
  *(_QWORD *)(a1 + 1776) = *((_QWORD *)a4 + 2);
  *(_OWORD *)(a1 + 1760) = v21;
  *(_QWORD *)(a1 + 1784) = a5;
  *(_QWORD *)(a1 + 1792) = 0;
  *(_QWORD *)(a1 + 1800) = 0xFFFF0000FFFF0000;
  *(_QWORD *)(a1 + 1808) = 0;
  *(_QWORD *)(a1 + 1813) = 0;
  *(_BYTE *)(a1 + 1821) = 1;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(a1 + 1824));
  *(_OWORD *)(a1 + 2098) = 0u;
  *(_OWORD *)(a1 + 2072) = 0u;
  *(_OWORD *)(a1 + 2088) = 0u;
  *(_OWORD *)(a1 + 2040) = 0u;
  *(_OWORD *)(a1 + 2056) = 0u;
  *(_OWORD *)(a1 + 2008) = 0u;
  *(_OWORD *)(a1 + 2024) = 0u;
  *(_OWORD *)(a1 + 1976) = 0u;
  *(_OWORD *)(a1 + 1992) = 0u;
  *(_OWORD *)(a1 + 1944) = 0u;
  *(_OWORD *)(a1 + 1960) = 0u;
  *(_OWORD *)(a1 + 1912) = 0u;
  *(_OWORD *)(a1 + 1928) = 0u;
  *(_OWORD *)(a1 + 1880) = 0u;
  *(_OWORD *)(a1 + 1896) = 0u;
  *(_OWORD *)(a1 + 1848) = 0u;
  *(_OWORD *)(a1 + 1864) = 0u;
  *(_OWORD *)(a1 + 1832) = 0u;
  *(_OWORD *)(a1 + 2136) = 0u;
  *(_OWORD *)(a1 + 2152) = 0u;
  *(_OWORD *)(a1 + 2120) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  LODWORD(v22) = *(_DWORD *)(a1 + 1756);
  if ((_DWORD)v22)
  {
    v23 = 0;
    do
    {
      v24 = *(float *)(*(_QWORD *)(a1 + 1704) + 4 * v23);
      Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
      ausdk::AUElement::SetParameter(Element, v23++, v24, 0);
      v22 = *(unsigned int *)(a1 + 1756);
    }
    while (v23 < v22);
  }
  if (*(_BYTE *)(a1 + 1586))
  {
    v26 = 0;
    v27 = 18;
    do
    {
      if ((_DWORD)v22)
      {
        v28 = 0;
        do
        {
          v29 = *(_QWORD *)(a1 + 1576);
          if (v29)
          {
            v30 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v29 + 32))(v29, v26);
          }
          else
          {
            v31 = *(_QWORD *)(a1 + 1552);
            if (v26 >= (*(_QWORD *)(a1 + 1560) - v31) >> 3)
              v30 = 0;
            else
              v30 = *(ausdk::AUElement **)(v31 + 8 * v26);
          }
          ausdk::AUElement::SetParameter(v30, v28, *(float *)(*(_QWORD *)(a1 + 1704) + 4 * v28), 0);
          ++v28;
          v22 = *(unsigned int *)(a1 + 1756);
        }
        while (v28 < v22);
      }
      ++v26;
    }
    while (v26 != 18);
  }
  else
  {
    v27 = 1;
  }
  v32 = 0;
  v33 = 56 * v27;
  do
  {
    v34 = (void **)(a1 + v32 + 544);
    std::vector<float>::resize((uint64_t)v34, *(unsigned int *)(a1 + 1752));
    v35 = *(_QWORD *)(a1 + v32 + 552) - (_QWORD)*v34;
    v36 = *(unsigned int *)(a1 + 1752);
    if (v36 != v35 >> 2)
      goto LABEL_32;
    if ((_DWORD)v36)
      memmove(*v34, *(const void **)(a1 + 1672), v35);
    v32 += 56;
  }
  while (v33 != v32);
  v37 = *(unsigned int *)(a1 + 1776);
  if ((_DWORD)v37)
  {
    v38 = (char *)malloc_type_malloc(16 * v37, 0x10600407B16006EuLL);
    *(_QWORD *)(a1 + 1792) = v38;
    if (v38)
      goto LABEL_26;
LABEL_32:
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
    return a1;
  }
  v38 = *(char **)(a1 + 1792);
  if (!v38)
    goto LABEL_32;
LABEL_26:
  v39 = *(unsigned int *)(a1 + 1776);
  if ((_DWORD)v39)
  {
    v40 = 0;
    v41 = *(_QWORD *)(a1 + 1760);
    v42 = v38 + 8;
    do
    {
      *((_DWORD *)v42 - 2) = v40;
      *v42 = *(_QWORD *)(v41 + 8 * v40);
      v42 += 2;
      ++v40;
    }
    while (v39 != v40);
  }
  return a1;
}

void sub_1B611E32C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t v11;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;

  v13 = *(void **)(v10 + 2144);
  if (v13)
  {
    *(_QWORD *)(v10 + 2152) = v13;
    operator delete(v13);
  }
  std::vector<DspLibBuffer>::__destroy_vector::operator()[abi:ne180100](&a10);
  v14 = 0;
  v15 = v10 + 2104;
  while (1)
  {
    v16 = *(_QWORD *)(v15 + v14);
    *(_QWORD *)(v15 + v14) = 0;
    if (v16)
      std::default_delete<AUDspLibStatus::Queue>::operator()[abi:ne180100](v16);
    v14 -= 8;
    if (v14 == -144)
    {
      vp::vx::io::Direction_Pair<std::vector<std::tuple<unsigned int,vp::services::Audio_Issue_Detector_Node_ID>>>::~Direction_Pair(v11);
      a10 = (void **)(v10 + 1552);
      std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a10);
      v17 = 1008;
      while (1)
      {
        v18 = *(void **)(v10 + v17 + 488);
        if (v18)
        {
          *(_QWORD *)(v10 + v17 + 496) = v18;
          operator delete(v18);
        }
        v17 -= 56;
        if (!v17)
        {
          ausdk::AUBase::~AUBase((ausdk::AUBase *)v10);
          _Unwind_Resume(a1);
        }
      }
    }
  }
}

void std::vector<DspLibBuffer>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        DspLibBuffer::~DspLibBuffer((DspLibBuffer *)(v4 - 96));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void AUDspLib::~AUDspLib(AUDspLib *this)
{
  uint64_t i;
  void *v3;
  void *v4;
  uint64_t j;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void **v11;

  *(_QWORD *)this = off_1E69C6E28;
  AUDspLib::Cleanup(this);
  for (i = 0; i != 1008; i += 56)
  {
    caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
    *(_QWORD *)((char *)this + i + 552) = *(_QWORD *)((char *)this + i + 544);
    caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
  }
  v3 = (void *)*((_QWORD *)this + 224);
  if (v3)
  {
    free(v3);
    *((_QWORD *)this + 224) = 0;
  }
  v4 = (void *)*((_QWORD *)this + 268);
  if (v4)
  {
    *((_QWORD *)this + 269) = v4;
    operator delete(v4);
  }
  v11 = (void **)((char *)this + 2120);
  std::vector<DspLibBuffer>::__destroy_vector::operator()[abi:ne180100](&v11);
  for (j = 2104; j != 1960; j -= 8)
  {
    v6 = *(_QWORD *)((char *)this + j);
    *(_QWORD *)((char *)this + j) = 0;
    if (v6)
      std::default_delete<AUDspLibStatus::Queue>::operator()[abi:ne180100](v6);
  }
  v7 = (void *)*((_QWORD *)this + 232);
  if (v7)
  {
    *((_QWORD *)this + 233) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 229);
  if (v8)
  {
    *((_QWORD *)this + 230) = v8;
    operator delete(v8);
  }
  v11 = (void **)((char *)this + 1552);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v11);
  v9 = 1008;
  do
  {
    v10 = *(void **)((char *)this + v9 + 488);
    if (v10)
    {
      *(_QWORD *)((char *)this + v9 + 496) = v10;
      operator delete(v10);
    }
    v9 -= 56;
  }
  while (v9);
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUDspLib::loadDefaultAudioChannelLayout(AUDspLib *this, CFDictionaryRef theDict)
{
  uint64_t result;
  const __CFNumber *v4;
  CFTypeID v5;
  int *v6;
  int v7;
  double v8;
  unint64_t valuePtr;

  result = (uint64_t)CFDictionaryGetValue(theDict, CFSTR("DefaultAudioChannelLayout"));
  if (result)
  {
    v4 = (const __CFNumber *)result;
    v5 = CFGetTypeID((CFTypeRef)result);
    if (v5 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      CFNumberGetValue(v4, kCFNumberSInt64Type, &valuePtr);
      if (HIDWORD(valuePtr))
        return 4294956428;
      if (*((_DWORD *)this + 450) == -65536)
      {
        v6 = (int *)*((_QWORD *)this + 268);
        if (v6 == *((int **)this + 269))
          v7 = 0;
        else
          v7 = *v6;
        if (v7 != (unsigned __int16)valuePtr)
          return 4294956428;
        if (*((_DWORD *)this + 451) != (_DWORD)valuePtr)
        {
          *((_DWORD *)this + 451) = valuePtr;
          caulk::pooled_semaphore_mutex::_lock((AUDspLib *)((char *)this + 1824));
          AUDspLib::initializeDspLibAlgorithms((uint64_t)this, v8);
          caulk::pooled_semaphore_mutex::_unlock((AUDspLib *)((char *)this + 1824));
        }
      }
      else if (*((_DWORD *)this + 451) != (_DWORD)valuePtr)
      {
        *((_DWORD *)this + 451) = valuePtr;
      }
    }
    return 0;
  }
  return result;
}

void sub_1B611E65C(_Unwind_Exception *a1)
{
  caulk::pooled_semaphore_mutex *v1;

  caulk::pooled_semaphore_mutex::_unlock(v1);
  _Unwind_Resume(a1);
}

__CFArray *AUDspLib::CFArrayOfStringsCreateWithCArrayOfStrings(const char **this, const char *const *a2)
{
  unsigned int v2;
  const __CFAllocator *v4;
  __CFArray *Mutable;
  uint64_t v6;
  const char *v7;
  CFStringRef v8;

  v2 = a2;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  v6 = v2;
  do
  {
    v7 = *this++;
    v8 = CFStringCreateWithCString(v4, v7, 0x8000100u);
    CFArrayAppendValue(Mutable, v8);
    CFRelease(v8);
    --v6;
  }
  while (v6);
  return Mutable;
}

int64x2_t *AUDspLibWithNewParameters::AUDspLibWithNewParameters(int64x2_t *a1, OpaqueAudioComponentInstance *a2, uint64_t a3, int64x2_t *a4, uint64_t a5)
{
  int64x2_t v8;
  uint64_t i;
  unsigned int v10;
  _QWORD *v11;
  uint64_t v12;
  __int128 v14;
  int v15;
  _OWORD v16[10];
  _QWORD v17[3];
  _QWORD *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  memset(v16, 0, sizeof(v16));
  v14 = 0uLL;
  v15 = 0;
  AUDspLib::AUDspLib((uint64_t)a1, a2, (uint64_t)v16, &v14, a5, 0);
  a1->i64[0] = (uint64_t)off_1E69C70B8;
  v8 = *a4;
  a1[137].i64[0] = a4[1].i64[0];
  a1[136] = v8;
  ausdk::AUBase::CreateElements(a1);
  a1[135].i64[1] = a3;
  for (i = 68; i != 194; i += 7)
  {
    v10 = DspLib::algorithmOffset((uint64_t)a1[136].i64, a1[137].i32[0] + 1);
    std::vector<float>::resize((uint64_t)&a1->i64[i], v10);
  }
  v17[0] = &off_1E69C7470;
  v17[1] = a1;
  v18 = v17;
  DspLib::forAllParametersOf((int64x2_t *)a1[136].i64, (uint64_t)v17);
  v11 = v18;
  if (v18 == v17)
  {
    v12 = 4;
    v11 = v17;
    goto LABEL_7;
  }
  if (v18)
  {
    v12 = 5;
LABEL_7:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
  return a1;
}

void sub_1B611E844(_Unwind_Exception *a1)
{
  AUDspLib *v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;

  v4 = *(_QWORD **)(v2 - 48);
  if (v4 == (_QWORD *)(v2 - 72))
  {
    v5 = 4;
    v4 = (_QWORD *)(v2 - 72);
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  AUDspLib::~AUDspLib(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<AUDspLibWithNewParameters::registerParameters(void)::$_0,std::allocator<AUDspLibWithNewParameters::registerParameters(void)::$_0>,void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<AUDspLibWithNewParameters::registerParameters(void)::$_0,std::allocator<AUDspLibWithNewParameters::registerParameters(void)::$_0>,void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E69C7470;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AUDspLibWithNewParameters::registerParameters(void)::$_0,std::allocator<AUDspLibWithNewParameters::registerParameters(void)::$_0>,void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E69C7470;
  a2[1] = v2;
  return result;
}

void std::__function::__func<AUDspLibWithNewParameters::registerParameters(void)::$_0,std::allocator<AUDspLibWithNewParameters::registerParameters(void)::$_0>,void ()(DspLib::SystemParameterAddress,DspLib::ParameterDefinition)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3;
  uint64_t v4;
  unsigned int v5;
  ausdk::AUElement *Element;
  unint64_t i;
  uint64_t v8;
  ausdk::AUElement *v9;
  uint64_t v10;

  v3 = *(float *)(a3 + 12);
  v4 = *(_QWORD *)(a1 + 8);
  v5 = (***(uint64_t (****)(_QWORD, _QWORD, _QWORD))(v4 + 2168))(*(_QWORD *)(v4 + 2168), *(_QWORD *)a2, *(unsigned int *)(a2 + 8));
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v4 + 32), 0);
  ausdk::AUElement::SetParameter(Element, v5, v3, 0);
  if (*(_BYTE *)(v4 + 1586))
  {
    for (i = 0; i != 18; ++i)
    {
      v8 = *(_QWORD *)(v4 + 1576);
      if (v8)
      {
        v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v8 + 32))(v8, i);
      }
      else
      {
        v10 = *(_QWORD *)(v4 + 1552);
        if (i >= (*(_QWORD *)(v4 + 1560) - v10) >> 3)
          v9 = 0;
        else
          v9 = *(ausdk::AUElement **)(v10 + 8 * i);
      }
      ausdk::AUElement::SetParameter(v9, v5, v3, 0);
    }
  }
}

void dspLibMessenger(uint64_t *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  __int128 *v4;
  __int128 v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  __int128 v12;
  std::string v13;
  char v14;
  _BYTE v15[29];

  *a1 = 0;
  a1[1] = 0;
  v2 = (std::__shared_weak_count *)dspLibMessenger(void)::sMessengerCache;
  if (dspLibMessenger(void)::sMessengerCache)
  {
    v2 = std::__shared_weak_count::lock((std::__shared_weak_count *)dspLibMessenger(void)::sMessengerCache);
    a1[1] = (uint64_t)v2;
    if (v2)
    {
      v3 = dspLibMessenger(void)::sMessengerCache;
      *a1 = dspLibMessenger(void)::sMessengerCache;
      if (v3)
        goto LABEL_16;
    }
  }
  v4 = (__int128 *)caulk::concurrent::messenger::shared_high_priority((caulk::concurrent::messenger *)v2);
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](&v13, v4);
  v5 = v4[2];
  *(_OWORD *)&v15[13] = *(__int128 *)((char *)v4 + 45);
  *(_OWORD *)v15 = v5;
  if (v14)
  {
    std::string::__assign_external(&v13, "DspLib messenger");
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&v13, "DspLib messenger");
    v14 = 1;
  }
  std::allocate_shared[abi:ne180100]<caulk::concurrent::messenger,std::allocator<caulk::concurrent::messenger>,caulk::concurrent::messenger::thread_strategy &,caulk::thread::attributes &,void>((uint64_t *)&v12, 1, (uint64_t)&v13);
  std::shared_ptr<vp::xml::_xmlNode const>::operator=[abi:ne180100]((uint64_t)a1, &v12);
  v6 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (v14 && SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v13.__r_.__value_.__l.__data_);
  v3 = *a1;
  v2 = (std::__shared_weak_count *)a1[1];
  if (v2)
  {
LABEL_16:
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
  }
  dspLibMessenger(void)::sMessengerCache = v3;
  v11 = (std::__shared_weak_count *)dspLibMessenger(void)::sMessengerCache;
  dspLibMessenger(void)::sMessengerCache = (uint64_t)v2;
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
}

void sub_1B611EB28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  uint64_t v17;

  if (a17)
  {
    if (a16 < 0)
      operator delete(__p);
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v17);
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<caulk::concurrent::messenger,std::allocator<caulk::concurrent::messenger>,caulk::concurrent::messenger::thread_strategy &,caulk::thread::attributes &,void>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0x28uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1E69DA7E0;
  result = MEMORY[0x1BCC94FFC](v6 + 3, a2, a3);
  *a1 = result;
  a1[1] = (uint64_t)v6;
  return result;
}

void sub_1B611EBB8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<caulk::concurrent::messenger>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69DA7E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::concurrent::messenger>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69DA7E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void std::__shared_ptr_emplace<caulk::concurrent::messenger>::__on_zero_shared()
{
  JUMPOUT(0x1BCC95008);
}

void CrossFader::~CrossFader(CrossFader *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

void VoiceProcessorV4::~VoiceProcessorV4(VoiceProcessorV4 *this)
{
  VoiceProcessorV4::~VoiceProcessorV4(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  VPTimeFreqConverter *v2;
  VPTimeFreqConverter *v3;
  void **v4;

  *(_QWORD *)this = &off_1E69C74D8;
  caulk::details::lifetime_guard_base<VoiceProcessorV2>::invalidate((uint64_t)this + 16600);
  v2 = (VPTimeFreqConverter *)*((_QWORD *)this + 2096);
  if (v2)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v2);
    MEMORY[0x1BCC95CEC]();
    *((_QWORD *)this + 2096) = 0;
  }
  v3 = (VPTimeFreqConverter *)*((_QWORD *)this + 2097);
  if (v3)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v3);
    MEMORY[0x1BCC95CEC]();
    *((_QWORD *)this + 2097) = 0;
  }
  myFreeABLDynamic((AudioBufferList **)this + 2128);
  CAUnregisterUIOrientation();
  CAUnregisterDeviceOrientation();
  if (VoiceProcessorV4::mNotifyTokenProx)
    notify_cancel(VoiceProcessorV4::mNotifyTokenProx);
  v4 = (void **)((char *)this + 16784);
  std::vector<std::unique_ptr<ECApplicator>>::__destroy_vector::operator()[abi:ne180100](&v4);
  VoiceProcessorV3::~VoiceProcessorV3(this);
}

uint64_t VoiceProcessorV4::GetVersion(VoiceProcessorV4 *this)
{
  return 4;
}

uint64_t VoiceProcessorV2::SupportsSWB(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV4::Initialize(VoiceProcessorV4 *this)
{
  uint64_t v2;

  v2 = VoiceProcessorV2::Initialize(this);
  if (!(_DWORD)v2)
  {
    VoiceProcessorV4::InitializeV4Specifics(this);
    (*(void (**)(VoiceProcessorV4 *))(*(_QWORD *)this + 696))(this);
  }
  return v2;
}

void VoiceProcessorV4::SetupUplinkBasicAUChain(VoiceProcessorV4 *this)
{
  unint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  char *v7;
  int v8;

  v2 = (unint64_t *)((char *)this + 4656);
  v7 = (char *)this + 4656;
  v8 = 0;
  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)&v7);
  v3 = *((_QWORD *)this + 582);
  v4 = *((_QWORD *)this + 583);
  *((_QWORD *)this + 583) = v4 | 0x11;
  *((_QWORD *)this + 582) = v3 | 0xC020010000001040;
  if (*((_BYTE *)this + 1676))
    *v2 = v3 | 0xD020010000001040;
  v5 = *((_DWORD *)this + 571);
  if (v5 == 1 || v5 == -1)
    *((_QWORD *)this + 583) = v4 | 0x13;
}

void VoiceProcessorV4::SetupUplinkLiteAUChain(VoiceProcessorV4 *this)
{
  unint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  char *v7;
  int v8;

  v2 = (unint64_t *)((char *)this + 4656);
  v7 = (char *)this + 4656;
  v8 = 0;
  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)&v7);
  v3 = *((_QWORD *)this + 582);
  v4 = *((_QWORD *)this + 583);
  *((_QWORD *)this + 583) = v4 | 0x10;
  *((_QWORD *)this + 582) = v3 | 0xC000010000001040;
  if (*((_BYTE *)this + 1676))
    *v2 = v3 | 0xD000010000001040;
  v5 = *((_DWORD *)this + 571);
  if (v5 == 1 || v5 == -1)
    *((_QWORD *)this + 583) = v4 | 0x12;
}

uint64_t VoiceProcessorV4::SetupUplink_MMNS(uint64_t this, unsigned int a2)
{
  unint64_t v2;

  if (a2 != 1)
  {
    v2 = *(_QWORD *)(this + 4656) & 0xFF5FFDFFFFFFDF7FLL;
    *(_QWORD *)(this + 4656) = v2 | 0x80020000002080;
    if (a2)
    {
      *(_QWORD *)(this + 4656) = v2 | 0x80020000002086;
      if (a2 >= 3)
      {
        *(_QWORD *)(this + 4656) = v2 | 0x8002000000208ELL;
        if (a2 != 3)
          *(_QWORD *)(this + 4656) = v2 | 0x8002018000E29ELL;
      }
    }
  }
  return this;
}

uint64_t VoiceProcessorV4::SetupUplink_BF_MS(uint64_t this, unsigned int a2, char a3)
{
  uint64_t v3;
  uint64_t v4;

  if (a2 < 2)
  {
    if (a2 && (a3 & 1) == 0)
    {
      v4 = *(_QWORD *)(this + 4656) | 2;
      goto LABEL_8;
    }
  }
  else
  {
    v3 = *(_QWORD *)(this + 4656);
    *(_QWORD *)(this + 4656) = v3 | 0x60002081;
    if ((a3 & 1) == 0)
    {
      *(_QWORD *)(this + 4656) = v3 | 0x60002087;
      if (a2 != 2)
      {
        v4 = v3 | 0x6000208F;
LABEL_8:
        *(_QWORD *)(this + 4656) = v4;
      }
    }
  }
  return this;
}

uint64_t VoiceProcessorV4::SetupUplink_MS(uint64_t this, unsigned int a2)
{
  uint64_t v2;

  if (a2 != 1)
  {
    v2 = *(_QWORD *)(this + 4656);
    *(_QWORD *)(this + 4656) = v2 | 0x20002081;
    if (a2)
    {
      *(_QWORD *)(this + 4656) = v2 | 0x20002087;
      if (a2 >= 3)
        *(_QWORD *)(this + 4656) = v2 | 0x2000208F;
    }
  }
  return this;
}

void VoiceProcessorV4::SetupDownlinkBasicAUChain(VoiceProcessorV4 *this)
{
  uint64_t v2;
  uint64_t v3;
  BOOL AppBooleanValue;
  _BOOL4 v5;
  long double v6;
  long double v7;
  int v8;
  _DWORD *v9;
  unsigned int v10;
  unint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  int *v15;
  int v16;
  int *v17;
  BOOL v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 1104);
  if (*((_BYTE *)this + 2084))
  {
    v3 = 671088640;
  }
  else
  {
    *((_QWORD *)this + 1104) = v2 | 0x100;
    v18 = 0;
    CFRetain(CFSTR("com.apple.coreaudio"));
    AppBooleanValue = CACFPreferencesGetAppBooleanValue(CFSTR("vp_use_vareq"), CFSTR("com.apple.coreaudio"), &v18);
    if (v18 && !AppBooleanValue)
      *((_QWORD *)this + 1104) &= ~0x100uLL;
    if (*((double *)this + 103) == *((double *)this + 41))
      v5 = 1;
    else
      v5 = (*(unsigned int (**)(VoiceProcessorV4 *))(*(_QWORD *)this + 232))(this)
        && (v6 = *((double *)this + 103), v6 > 0.0)
        && (v7 = *((double *)this + 41), v7 > 0.0)
        && fmod(v7, v6) == 0.0;
    v8 = (*(unsigned int (**)(VoiceProcessorV4 *))(*(_QWORD *)this + 112))(this) > 5 || v5;
    if (v8
      && *((_DWORD *)this + 208) == 1819304813
      && (*((_DWORD *)this + 209) & 1) != 0
      && *((_DWORD *)this + 84) == 1819304813
      && (*((_DWORD *)this + 85) & 1) != 0
      && (~*((_DWORD *)this + 112) & 5) == 0
      && (v9 = (_DWORD *)*((_QWORD *)this + 292), v9 != *((_DWORD **)this + 293))
      && *v9 == 1886545251)
    {
      v10 = (*(uint64_t (**)(VoiceProcessorV4 *))(*(_QWORD *)this + 112))(this);
      v11 = *((_QWORD *)this + 1104);
      if (v10 >= 6)
      {
        *((_QWORD *)this + 1104) = v11 | 0x80000000000;
        *((_BYTE *)this + 481) = *((double *)this + 103) != *((double *)this + 41);
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v12 = CALog::LogObjIfEnabled(3, VPLogScope(void)::scope);
        if (v12)
        {
          v13 = v12;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            v14 = *((unsigned __int8 *)this + 481);
            *(_DWORD *)buf = 136315650;
            v20 = "VoiceProcessor_v4.cpp";
            v21 = 1024;
            v22 = 328;
            v23 = 1024;
            v24 = v14;
            _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> Should enable TweakaLeakIR sample rate converter: %d", buf, 0x18u);
          }
        }
        v15 = (int *)*((_QWORD *)this + 1570);
        if (v15 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
        {
          if (VPLogScope(void)::once != -1)
          {
            v17 = (int *)*((_QWORD *)this + 1570);
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            v15 = v17;
          }
          CALegacyLog::log(v15, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v4/VoiceProcessor_v4.cpp", 328, "SetupDownlinkBasicAUChain", "Should enable TweakaLeakIR sample rate converter: %d", *((unsigned __int8 *)this + 481));
        }
        if (*((_DWORD *)this + 127) <= *((_DWORD *)this + 121))
          v16 = *((_DWORD *)this + 121);
        else
          v16 = *((_DWORD *)this + 127);
        myAllocABLDynamic((const AudioStreamBasicDescription *)((char *)this + 904), v16, (AudioBufferList **)this + 2128);
        v11 = *((_QWORD *)this + 1104);
      }
    }
    else
    {
      v11 = *((_QWORD *)this + 1104) & 0xFFFFF7FFFFFFFFFFLL;
    }
    *((_QWORD *)this + 1104) = v11 | 0x208044;
    AUPropAndParamHelper::AddItemToAUParamList((uint64_t)this + 9352, 0, *((float *)this + 3119));
    v2 = *((_QWORD *)this + 1104);
    v3 = 0x3E8000000;
  }
  *((_QWORD *)this + 1104) = v2 | v3 & 0xFFFFFFFFFFFFLL | 0x1800000000000000;
}

uint64_t VoiceProcessorV2::ShouldThirdPartyAppUseFaceTimeDSPAndTuning(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::ShouldApplyThirdPartyAppTuningOverride(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::SetChatFlavor(uint64_t a1)
{
  _QWORD *v2;
  NSObject *v3;
  int *v4;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v2 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
  {
    v3 = (*v2 ? *v2 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v6 = 136315394;
      v7 = "VoiceProcessor_v2.h";
      v8 = 1024;
      v9 = 2074;
      _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Chat flavor not supported in this vp version", (uint8_t *)&v6, 0x12u);
    }
  }
  v4 = *(int **)(a1 + 12560);
  if (v4 && (*(_BYTE *)(a1 + 15897) || *(_BYTE *)(a1 + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v4, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/VoiceProcessor_v2.h", 2074, "SetChatFlavor", "Chat flavor not supported in this vp version");
  }
  return 0xFFFFFFFFLL;
}

uint64_t VoiceProcessorV2::GetRequestedChatFlavor(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::IsAutomaticChatFlavorEnabled(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::IsInGenericVoiceIsolationMode(VoiceProcessorV2 *this)
{
  return 0;
}

BOOL VoiceProcessorV2::ShouldUseFullIOCycle(VoiceProcessorV2 *this)
{
  return *((_DWORD *)this + 19) != 1;
}

uint64_t VoiceProcessorV2::ShouldUsePowerEfficientSingleChannelVoiceIsolation(VoiceProcessorV2 *this)
{
  return 0;
}

uint64_t VoiceProcessorV2::GetTelephonyVoiceIsolationUseCaseOverrideTuning4CC(VoiceProcessorV2 *this)
{
  return 0;
}

void VoiceProcessorV4::ApplyCustomTelephonyDSPOverrides(int8x16_t *this, CFDictionaryRef theDict, int a3)
{
  const __CFNumber *Value;
  const __CFNumber *v7;
  uint64_t v8;
  const __CFNumber *v9;
  const __CFNumber *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  __int8 *v17;
  float v18;
  int v19;
  const __CFArray *v20;
  const __CFArray *v21;
  unsigned int Count;
  uint64_t v23;
  int8x16_t *v24;
  uint64_t v25;
  uint64_t v26;
  CFIndex v27;
  __int8 *v28;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  const __CFNumber *v35;
  const __CFNumber *v36;
  const void *v37;
  float valuePtr;

  if (theDict && CFDictionaryGetCount(theDict))
  {
    if (a3)
    {
      if (CFDictionaryContainsKey(theDict, CFSTR("noise suppression")))
      {
        Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("noise suppression"));
        if (Value)
        {
          v7 = Value;
          CFRetain(Value);
          valuePtr = 0.0;
          CFNumberGetValue(v7, kCFNumberFloat32Type, &valuePtr);
          CFRelease(v7);
          v8 = this[291].i64[0];
          this[291].i64[1] |= 0x10uLL;
          this[291].i64[0] = v8 & 0xFF5FFFFFFFFFFFFFLL | 0x20000000000000;
          AUPropAndParamHelper::AddItemToAUParamList((uint64_t)&this[372].i64[1], 0, valuePtr);
        }
      }
      if (CFDictionaryContainsKey(theDict, CFSTR("agc")))
      {
        v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("agc"));
        if (v9)
        {
          v10 = v9;
          CFRetain(v9);
          valuePtr = 0.0;
          CFNumberGetValue(v10, kCFNumberIntType, &valuePtr);
          CFRelease(v10);
          v11 = this[291].i64[1];
          v12 = v11 & 0xFFFFFFFFFFFFFFFDLL;
          v13 = v11 | 0x12;
          if (LODWORD(valuePtr) == 1)
            v14 = v13;
          else
            v14 = v12;
          this[291].i64[1] = v14;
        }
      }
    }
    if (CFDictionaryContainsKey(theDict, CFSTR("gain")))
    {
      v15 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("gain"));
      if (v15)
      {
        v16 = v15;
        CFRetain(v15);
        valuePtr = 0.0;
        CFNumberGetValue(v16, kCFNumberFloat32Type, &valuePtr);
        CFRelease(v16);
        if (a3)
        {
          this[291] = vorrq_s8(this[291], (int8x16_t)xmmword_1B66A0610);
          v17 = &this[436].i8[8];
          v18 = valuePtr;
          v19 = 1;
        }
        else
        {
          this[552].i64[0] |= 0x1800000000000000uLL;
          AUPropAndParamHelper::AddItemToAUParamList((uint64_t)&this[678].i64[1], 0, valuePtr);
          v18 = valuePtr;
          v17 = &this[678].i8[8];
          v19 = 8;
        }
        AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v17, v19, v18);
      }
    }
    if (CFDictionaryContainsKey(theDict, CFSTR("eq")))
    {
      v20 = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("eq"));
      if (v20)
      {
        v21 = v20;
        CFRetain(v20);
        Count = CFArrayGetCount(v21);
        v23 = 9640;
        if (a3)
        {
          v23 = 6200;
          this[291].i64[0] |= 0x8000000000000000;
          v24 = (int8x16_t *)((char *)this + 4664);
          v25 = 16;
        }
        else
        {
          v24 = this + 552;
          v25 = 0x1000000200000000;
        }
        v24->i64[0] |= v25;
        if (Count >= 0xA)
          v26 = 10;
        else
          v26 = Count;
        if ((_DWORD)v26)
        {
          v27 = 0;
          v28 = &this->i8[v23];
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v21, v27);
            if (ValueAtIndex)
            {
              v30 = ValueAtIndex;
              CFRetain(ValueAtIndex);
              if (CFDictionaryContainsKey(v30, CFSTR("AUNBandEQ_FilterType"))
                && CFDictionaryContainsKey(v30, CFSTR("AUNBandEQ_FilterFrequency")))
              {
                AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 1000, 0.0);
                v31 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("AUNBandEQ_FilterType"));
                if (v31)
                {
                  v32 = v31;
                  CFRetain(v31);
                  valuePtr = 0.0;
                  CFNumberGetValue(v32, kCFNumberIntType, &valuePtr);
                  CFRelease(v32);
                  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 2000, (float)LODWORD(valuePtr));
                }
                v33 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("AUNBandEQ_FilterFrequency"));
                if (v33)
                {
                  v34 = v33;
                  CFRetain(v33);
                  valuePtr = 0.0;
                  CFNumberGetValue(v34, kCFNumberFloat32Type, &valuePtr);
                  CFRelease(v34);
                  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 3000, valuePtr);
                }
              }
              if (CFDictionaryContainsKey(v30, CFSTR("AUNBandEQ_FilterGain")))
              {
                v35 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("AUNBandEQ_FilterGain"));
                if (v35)
                {
                  v36 = v35;
                  CFRetain(v35);
                  valuePtr = 0.0;
                  CFNumberGetValue(v36, kCFNumberFloat32Type, &valuePtr);
                  CFRelease(v36);
                  AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 4000, valuePtr);
                }
              }
              if (CFDictionaryContainsKey(v30, CFSTR("AUNBandEQ_FilterBandwidth")))
              {
                v37 = CFDictionaryGetValue(v30, CFSTR("AUNBandEQ_FilterBandwidth"));
                CFRetain(v37);
                valuePtr = 0.0;
                CFNumberGetValue((CFNumberRef)v37, kCFNumberFloat32Type, &valuePtr);
                CFRelease(v37);
                AUPropAndParamHelper::AddItemToAUParamList((uint64_t)v28, v27 + 5000, valuePtr);
              }
              CFRelease(v30);
            }
            ++v27;
          }
          while (v26 != v27);
        }
        CFRelease(v21);
      }
    }
  }
}

__n128 VoiceProcessorV4::CorrectDownlinkTimeStamp@<Q0>(const AudioTimeStamp *a1@<X1>, uint64_t a2@<X8>)
{
  __int128 v3;
  __n128 result;
  __int128 v5;

  v3 = *(_OWORD *)&a1->mRateScalar;
  *(_OWORD *)a2 = *(_OWORD *)&a1->mSampleTime;
  *(_OWORD *)(a2 + 16) = v3;
  result = *(__n128 *)&a1->mSMPTETime.mSubframes;
  v5 = *(_OWORD *)&a1->mSMPTETime.mHours;
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v5;
  return result;
}

uint64_t VoiceProcessorV4::SetupECApplicator(VoiceProcessorV4 *this)
{
  ECApplicator **v2;
  ECApplicator **v3;
  ECApplicator *v4;
  ECApplicator **v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  ECApplicator **v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  ECApplicator *v18;
  int64x2_t v19;
  ECApplicator *v20;
  unint64_t v21;
  ECApplicator *v22;
  ECApplicator **v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  ECApplicator **v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  ECApplicator *v36;
  int64x2_t v37;
  ECApplicator *v38;
  unint64_t v39;
  ECApplicator *v40;
  ECApplicator **v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  ECApplicator **v49;
  unint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  ECApplicator *v54;
  int64x2_t v55;
  ECApplicator *v56;
  unint64_t v57;
  ECApplicator *v58;
  ECApplicator **v59;
  unint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  ECApplicator **v68;
  unint64_t v69;
  _QWORD *v70;
  _QWORD *v71;
  ECApplicator *v72;
  int64x2_t v73;
  ECApplicator *v74;
  unint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  AudioBufferList **v81[3];
  AudioBufferList *v82[2];
  AudioBufferList **v83[3];
  AudioBufferList *v84[2];
  AudioBufferList **v85[3];
  AudioBufferList *v86[2];
  AudioBufferList *v87[2];
  AudioBufferList **v88;
  int64x2_t v89;
  unint64_t v90;
  char *v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v2 = (ECApplicator **)*((_QWORD *)this + 2099);
  v3 = (ECApplicator **)*((_QWORD *)this + 2098);
  while (v2 != v3)
    std::unique_ptr<ECApplicator>::reset[abi:ne180100](--v2);
  *((_QWORD *)this + 2099) = v3;
  v4 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v4, this, 12, 3);
  v85[0] = (AudioBufferList **)v4;
  v5 = (ECApplicator **)*((_QWORD *)this + 2099);
  v6 = *((_QWORD *)this + 2100);
  if ((unint64_t)v5 >= v6)
  {
    v7 = *((_QWORD *)this + 2098);
    v8 = ((uint64_t)v5 - v7) >> 3;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v10 = v6 - v7;
    if (v10 >> 2 > v9)
      v9 = v10 >> 2;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    v91 = (char *)this + 16800;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v11);
    else
      v12 = 0;
    v13 = (ECApplicator **)(v11 + 8 * v8);
    v14 = v11 + 8 * v12;
    v90 = v14;
    v85[0] = 0;
    *v13 = v4;
    v15 = v13 + 1;
    v89.i64[1] = (uint64_t)(v13 + 1);
    v16 = (_QWORD *)*((_QWORD *)this + 2099);
    v17 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v16 == v17)
    {
      v20 = 0;
      v19 = vdupq_n_s64((unint64_t)v16);
    }
    else
    {
      do
      {
        v18 = (ECApplicator *)*--v16;
        *v16 = 0;
        *--v13 = v18;
      }
      while (v16 != v17);
      v19 = *((int64x2_t *)this + 1049);
      v15 = (_QWORD *)v89.i64[1];
      v14 = v90;
      v20 = (ECApplicator *)v85[0];
    }
    *((_QWORD *)this + 2098) = v13;
    *((_QWORD *)this + 2099) = v15;
    v89 = v19;
    v21 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v14;
    v90 = v21;
    v88 = (AudioBufferList **)v19.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v88);
    *((_QWORD *)this + 2099) = v15;
    if (v20)
    {
      ECApplicator::~ECApplicator(v20);
      MEMORY[0x1BCC95CEC]();
    }
  }
  else
  {
    *v5 = v4;
    *((_QWORD *)this + 2099) = v5 + 1;
  }
  v22 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v22, this, 13, 3);
  v85[0] = (AudioBufferList **)v22;
  v23 = (ECApplicator **)*((_QWORD *)this + 2099);
  v24 = *((_QWORD *)this + 2100);
  if ((unint64_t)v23 >= v24)
  {
    v25 = *((_QWORD *)this + 2098);
    v26 = ((uint64_t)v23 - v25) >> 3;
    v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v28 = v24 - v25;
    if (v28 >> 2 > v27)
      v27 = v28 >> 2;
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
      v29 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v29 = v27;
    v91 = (char *)this + 16800;
    if (v29)
      v29 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v29);
    else
      v30 = 0;
    v31 = (ECApplicator **)(v29 + 8 * v26);
    v32 = v29 + 8 * v30;
    v90 = v32;
    v85[0] = 0;
    *v31 = v22;
    v33 = v31 + 1;
    v89.i64[1] = (uint64_t)(v31 + 1);
    v34 = (_QWORD *)*((_QWORD *)this + 2099);
    v35 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v34 == v35)
    {
      v38 = 0;
      v37 = vdupq_n_s64((unint64_t)v34);
    }
    else
    {
      do
      {
        v36 = (ECApplicator *)*--v34;
        *v34 = 0;
        *--v31 = v36;
      }
      while (v34 != v35);
      v37 = *((int64x2_t *)this + 1049);
      v33 = (_QWORD *)v89.i64[1];
      v32 = v90;
      v38 = (ECApplicator *)v85[0];
    }
    *((_QWORD *)this + 2098) = v31;
    *((_QWORD *)this + 2099) = v33;
    v89 = v37;
    v39 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v32;
    v90 = v39;
    v88 = (AudioBufferList **)v37.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v88);
    *((_QWORD *)this + 2099) = v33;
    if (v38)
    {
      ECApplicator::~ECApplicator(v38);
      MEMORY[0x1BCC95CEC]();
    }
  }
  else
  {
    *v23 = v22;
    *((_QWORD *)this + 2099) = v23 + 1;
  }
  v40 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v40, this, 14, 3);
  v85[0] = (AudioBufferList **)v40;
  v41 = (ECApplicator **)*((_QWORD *)this + 2099);
  v42 = *((_QWORD *)this + 2100);
  if ((unint64_t)v41 >= v42)
  {
    v43 = *((_QWORD *)this + 2098);
    v44 = ((uint64_t)v41 - v43) >> 3;
    v45 = v44 + 1;
    if ((unint64_t)(v44 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v46 = v42 - v43;
    if (v46 >> 2 > v45)
      v45 = v46 >> 2;
    if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8)
      v47 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v47 = v45;
    v91 = (char *)this + 16800;
    if (v47)
      v47 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v47);
    else
      v48 = 0;
    v49 = (ECApplicator **)(v47 + 8 * v44);
    v50 = v47 + 8 * v48;
    v90 = v50;
    v85[0] = 0;
    *v49 = v40;
    v51 = v49 + 1;
    v89.i64[1] = (uint64_t)(v49 + 1);
    v52 = (_QWORD *)*((_QWORD *)this + 2099);
    v53 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v52 == v53)
    {
      v56 = 0;
      v55 = vdupq_n_s64((unint64_t)v52);
    }
    else
    {
      do
      {
        v54 = (ECApplicator *)*--v52;
        *v52 = 0;
        *--v49 = v54;
      }
      while (v52 != v53);
      v55 = *((int64x2_t *)this + 1049);
      v51 = (_QWORD *)v89.i64[1];
      v50 = v90;
      v56 = (ECApplicator *)v85[0];
    }
    *((_QWORD *)this + 2098) = v49;
    *((_QWORD *)this + 2099) = v51;
    v89 = v55;
    v57 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v50;
    v90 = v57;
    v88 = (AudioBufferList **)v55.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v88);
    *((_QWORD *)this + 2099) = v51;
    if (v56)
    {
      ECApplicator::~ECApplicator(v56);
      MEMORY[0x1BCC95CEC]();
    }
  }
  else
  {
    *v41 = v40;
    *((_QWORD *)this + 2099) = v41 + 1;
  }
  v58 = (ECApplicator *)operator new();
  ECApplicator::ECApplicator(v58, this, 15, 3);
  v85[0] = (AudioBufferList **)v58;
  v59 = (ECApplicator **)*((_QWORD *)this + 2099);
  v60 = *((_QWORD *)this + 2100);
  if ((unint64_t)v59 >= v60)
  {
    v62 = *((_QWORD *)this + 2098);
    v63 = ((uint64_t)v59 - v62) >> 3;
    if ((unint64_t)(v63 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v64 = v60 - v62;
    v65 = v64 >> 2;
    if (v64 >> 2 <= (unint64_t)(v63 + 1))
      v65 = v63 + 1;
    if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8)
      v66 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v66 = v65;
    v91 = (char *)this + 16800;
    if (v66)
      v66 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v66);
    else
      v67 = 0;
    v68 = (ECApplicator **)(v66 + 8 * v63);
    v69 = v66 + 8 * v67;
    v90 = v69;
    v85[0] = 0;
    *v68 = v58;
    v61 = (uint64_t *)(v68 + 1);
    v89.i64[1] = (uint64_t)(v68 + 1);
    v70 = (_QWORD *)*((_QWORD *)this + 2099);
    v71 = (_QWORD *)*((_QWORD *)this + 2098);
    if (v70 == v71)
    {
      v74 = 0;
      v73 = vdupq_n_s64((unint64_t)v70);
    }
    else
    {
      do
      {
        v72 = (ECApplicator *)*--v70;
        *v70 = 0;
        *--v68 = v72;
      }
      while (v70 != v71);
      v73 = *((int64x2_t *)this + 1049);
      v61 = (uint64_t *)v89.i64[1];
      v69 = v90;
      v74 = (ECApplicator *)v85[0];
    }
    *((_QWORD *)this + 2098) = v68;
    *((_QWORD *)this + 2099) = v61;
    v89 = v73;
    v75 = *((_QWORD *)this + 2100);
    *((_QWORD *)this + 2100) = v69;
    v90 = v75;
    v88 = (AudioBufferList **)v73.i64[0];
    std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer((uint64_t)&v88);
    *((_QWORD *)this + 2099) = v61;
    if (v74)
    {
      ECApplicator::~ECApplicator(v74);
      MEMORY[0x1BCC95CEC]();
      v61 = (uint64_t *)*((_QWORD *)this + 2099);
    }
  }
  else
  {
    *v59 = v58;
    v61 = (uint64_t *)(v59 + 1);
    *((_QWORD *)this + 2099) = v61;
  }
  v87[0] = (AudioBufferList *)((char *)this + 16808);
  v87[1] = (AudioBufferList *)((char *)this + 17000);
  v88 = (AudioBufferList **)((char *)this + 1088);
  v89.i64[0] = (uint64_t)this + 3344;
  v89.i64[1] = (uint64_t)this + 3384;
  v86[0] = (AudioBufferList *)((char *)this + 16832);
  v86[1] = (AudioBufferList *)((char *)this + 17000);
  v85[0] = (AudioBufferList **)((char *)this + 1088);
  v85[1] = (AudioBufferList **)((char *)this + 3352);
  v85[2] = (AudioBufferList **)((char *)this + 3392);
  v84[0] = (AudioBufferList *)((char *)this + 16856);
  v84[1] = (AudioBufferList *)((char *)this + 17000);
  v83[0] = (AudioBufferList **)((char *)this + 1088);
  v83[1] = (AudioBufferList **)((char *)this + 3368);
  v83[2] = (AudioBufferList **)((char *)this + 3392);
  v82[0] = (AudioBufferList *)((char *)this + 16880);
  v82[1] = (AudioBufferList *)((char *)this + 17000);
  v81[0] = (AudioBufferList **)((char *)this + 1088);
  v81[1] = (AudioBufferList **)((char *)this + 3360);
  v81[2] = (AudioBufferList **)((char *)this + 3408);
  v76 = (uint64_t *)*((_QWORD *)this + 2098);
  if (v61 == v76)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  ECApplicator::setInputOutputABLs(*v76, v87, &v88);
  v77 = *((_QWORD *)this + 2098);
  if ((unint64_t)(*((_QWORD *)this + 2099) - v77) <= 8)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  ECApplicator::setInputOutputABLs(*(_QWORD *)(v77 + 8), v86, v85);
  v78 = *((_QWORD *)this + 2098);
  if ((unint64_t)(*((_QWORD *)this + 2099) - v78) <= 0x10)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  ECApplicator::setInputOutputABLs(*(_QWORD *)(v78 + 16), v84, v83);
  v79 = *((_QWORD *)this + 2098);
  if ((unint64_t)(*((_QWORD *)this + 2099) - v79) <= 0x18)
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  return ECApplicator::setInputOutputABLs(*(_QWORD *)(v79 + 24), v82, v81);
}

void sub_1B611FF48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  std::unique_ptr<ECApplicator>::reset[abi:ne180100]((ECApplicator **)va);
  _Unwind_Resume(a1);
}

ECApplicator *std::unique_ptr<ECApplicator>::reset[abi:ne180100](ECApplicator **a1)
{
  ECApplicator *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    ECApplicator::~ECApplicator(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

uint64_t std::__split_buffer<std::unique_ptr<ECApplicator>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::unique_ptr<ECApplicator>::reset[abi:ne180100]((ECApplicator **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void AUPropAndParamHelper::AddItemToAUParamList(uint64_t a1, int a2, float a3)
{
  float *v6;
  float *v7;
  int64_t v9;
  unint64_t v10;
  unsigned int v11;
  float *v12;
  float *v13;
  float v14;
  unint64_t v16;
  float *v17;
  unint64_t v18;
  uint64_t v19;
  BOOL v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;

  v6 = *(float **)a1;
  v7 = *(float **)(a1 + 8);
  v9 = (char *)v7 - (char *)v6;
  v10 = ((char *)v7 - (char *)v6) >> 3;
  if (v7 != v6)
  {
    v9 = 0;
    v11 = 1;
    while (1)
    {
      if (LODWORD(v6[2 * v9]) == a2)
      {
        v12 = &v6[2 * v9];
        v14 = v12[1];
        v13 = v12 + 1;
        if (v14 != a3)
          break;
      }
      v9 = v11;
      if (v10 <= v11++)
        goto LABEL_8;
    }
    LODWORD(v6[2 * v9]) = a2;
    *v13 = a3;
  }
LABEL_8:
  if (v10 == v9)
  {
    v16 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)v7 >= v16)
    {
      v18 = v10 + 1;
      if ((v10 + 1) >> 61)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v19 = v16 - (_QWORD)v6;
      if (v19 >> 2 > v18)
        v18 = v19 >> 2;
      v20 = (unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8;
      v21 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v20)
        v21 = v18;
      if (v21)
      {
        v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v21);
        v6 = *(float **)a1;
        v7 = *(float **)(a1 + 8);
      }
      else
      {
        v22 = 0;
      }
      v23 = v21 + 8 * v10;
      v24 = v21 + 8 * v22;
      *(_DWORD *)v23 = a2;
      *(float *)(v23 + 4) = a3;
      v17 = (float *)(v23 + 8);
      if (v7 != v6)
      {
        do
        {
          v25 = *((_QWORD *)v7 - 1);
          v7 -= 2;
          *(_QWORD *)(v23 - 8) = v25;
          v23 -= 8;
        }
        while (v7 != v6);
        v6 = *(float **)a1;
      }
      *(_QWORD *)a1 = v23;
      *(_QWORD *)(a1 + 8) = v17;
      *(_QWORD *)(a1 + 16) = v24;
      if (v6)
        operator delete(v6);
    }
    else
    {
      *(_DWORD *)v7 = a2;
      v7[1] = a3;
      v17 = v7 + 2;
    }
    *(_QWORD *)(a1 + 8) = v17;
  }
}

void std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>(uint64_t a1)
{
  int v2;
  _QWORD *v3;
  unint64_t v4;
  char v5;
  unint64_t v6;
  _QWORD *v7;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_QWORD **)a1;
  if (!v2)
  {
    v5 = 71;
    v6 = 1;
LABEL_8:
    bzero(v3, 8 * v6);
    goto LABEL_9;
  }
  if ((64 - v2) >= 0x47uLL)
    v4 = 71;
  else
    v4 = (64 - v2);
  *v3++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v2 - v4)) & (-1 << v2));
  v5 = 71 - v4;
  *(_QWORD *)a1 = v3;
  v6 = (71 - v4) >> 6;
  if (v4 <= 7)
    goto LABEL_8;
LABEL_9:
  if ((v5 & 0x3F) != 0)
  {
    v7 = &v3[v6];
    *(_QWORD *)a1 = v7;
    *v7 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v5 & 0x3F));
  }
}

void VoiceProcessorV4::InitializeV4Specifics(VoiceProcessorV4 *this)
{
  VPTimeFreqConverter **v2;
  VPTimeFreqConverter *v3;
  VPTimeFreqConverter *v4;

  v2 = (VPTimeFreqConverter **)((char *)this + 16768);
  v3 = (VPTimeFreqConverter *)*((_QWORD *)this + 2096);
  if (v3)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v3);
    MEMORY[0x1BCC95CEC]();
  }
  v4 = (VPTimeFreqConverter *)*((_QWORD *)this + 2097);
  if (v4)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v4);
    MEMORY[0x1BCC95CEC]();
  }
  VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), v2);
  VPTimeFreqConverter_Create(2, *((_DWORD *)this + 127), (VPTimeFreqConverter **)this + 2097);
}

void std::vector<std::unique_ptr<ECApplicator>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  ECApplicator **v2;
  ECApplicator **v4;
  void *v5;

  v1 = *a1;
  v2 = (ECApplicator **)**a1;
  if (v2)
  {
    v4 = (ECApplicator **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<ECApplicator>::reset[abi:ne180100](--v4);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void VoiceProcessorV4::VoiceProcessorV4(VoiceProcessorV4 *this, const vp::Context *a2)
{
  char *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  NSObject *global_queue;
  uint32_t v11;
  _QWORD *v12;
  NSObject *v13;
  int *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint32_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = (char *)this + 16808;
  VoiceProcessorV3::VoiceProcessorV3(this, a2);
  *(_QWORD *)v4 = &off_1E69C74D8;
  *(_QWORD *)(v4 + 17024) = 0;
  v3[224] = 0;
  *(_OWORD *)(v4 + 16768) = 0u;
  *(_OWORD *)(v4 + 16784) = 0u;
  *(_QWORD *)(v4 + 16800) = 0;
  caulk::details::lifetime_guard_base<VoiceProcessorV2>::weak_T_ptr(&v16, *(_QWORD *)(v4 + 16600), *(std::__shared_weak_count **)(v4 + 16616));
  v5 = v17;
  v15 = v17;
  if (v17)
  {
    p_shared_weak_owners = (unint64_t *)&v17->__shared_weak_owners_;
    do
      v7 = __ldxr(p_shared_weak_owners);
    while (__stxr(v7 + 1, p_shared_weak_owners));
  }
  CARegisterUIOrientation();
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  CARegisterDeviceOrientation();
  global_queue = dispatch_get_global_queue(0, 0);
  v11 = notify_register_dispatch("com.apple.backboard.proximity.changed", &VoiceProcessorV4::mNotifyTokenProx, global_queue, &__block_literal_global_457);
  if (v11)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v12 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v13 = (*v12 ? *v12 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v19 = "VoiceProcessor_v4.cpp";
        v20 = 1024;
        v21 = 45;
        v22 = 1024;
        v23 = v11;
        _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> notify_register_check failed (com.apple.backboard.proximity.changed), status=%d\n", buf, 0x18u);
      }
    }
    v14 = (int *)*((_QWORD *)this + 1570);
    if (v14 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      CALegacyLog::log(v14, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v4/VoiceProcessor_v4.cpp", 45, "VoiceProcessorV4", "notify_register_check failed (com.apple.backboard.proximity.changed), status=%d\n", v11);
    }
    VoiceProcessorV4::mNotifyTokenProx = 0;
  }
  else
  {
    dispatch_async(global_queue, &__block_literal_global_15);
  }
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *(_DWORD *)v3 = 1;
  *((_DWORD *)v3 + 6) = 1;
  *((_DWORD *)v3 + 12) = 1;
  *((_DWORD *)v3 + 18) = 1;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_QWORD *)v3 + 26) = 0;
  *((_DWORD *)v3 + 24) = 1;
  *((_DWORD *)v3 + 30) = 1;
  *((_DWORD *)v3 + 36) = 1;
  *((_DWORD *)v3 + 42) = 1;
  *((_DWORD *)v3 + 48) = 1;
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  if (v15)
    std::__shared_weak_count::__release_weak(v15);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void sub_1B612073C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  VoiceProcessorV3 *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;

  if (a16)
    std::__shared_weak_count::__release_weak(a16);
  if (a22)
    std::__shared_weak_count::__release_weak(a22);
  if (v23)
    std::__shared_weak_count::__release_weak(v23);
  *(_QWORD *)(v24 - 112) = (char *)v22 + 16784;
  std::vector<std::unique_ptr<ECApplicator>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v24 - 112));
  VoiceProcessorV3::~VoiceProcessorV3(v22);
  _Unwind_Resume(a1);
}

void caulk::details::lifetime_guard_base<VoiceProcessorV2>::weak_T_ptr(_QWORD *a1, uint64_t a2, std::__shared_weak_count *a3)
{
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  unint64_t v8;

  if (a3)
  {
    p_shared_owners = (unint64_t *)&a3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    *a1 = a2;
    a1[1] = a3;
    p_shared_weak_owners = (unint64_t *)&a3->__shared_weak_owners_;
    do
      v7 = __ldxr(p_shared_weak_owners);
    while (__stxr(v7 + 1, p_shared_weak_owners));
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  else
  {
    *a1 = a2;
    a1[1] = 0;
  }
}

void ___ZN16VoiceProcessorV4C2ERKN2vp7ContextE_block_invoke(uint64_t a1, unsigned int a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  _QWORD *v8;
  NSObject *v9;
  int *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  int *v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unsigned int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 32);
      if (v7)
      {
        atomic_store(a2, (unsigned int *)(v7 + 2308));
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v8 = (_QWORD *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
        {
          v9 = (*v8 ? *v8 : MEMORY[0x1E0C81028]);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            v15 = "VoiceProcessor_v2.cpp";
            v16 = 1024;
            v17 = 870;
            v18 = 1024;
            v19 = a2;
            _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> UI orientation is set to %d", buf, 0x18u);
          }
        }
        v10 = *(int **)(v7 + 12560);
        if (v10 && (*(_BYTE *)(v7 + 15897) || *(_BYTE *)(v7 + 15898)))
        {
          if (VPLogScope(void)::once != -1)
          {
            v13 = *(int **)(v7 + 12560);
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            v10 = v13;
          }
          CALegacyLog::log(v10, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/VoiceProcessor_v2.cpp", 870, "SetUIOrientation", "UI orientation is set to %d", a2);
        }
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_1B6120A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN16VoiceProcessorV4C2ERKN2vp7ContextE_block_invoke_4(uint64_t a1, unsigned int a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  _QWORD *v8;
  NSObject *v9;
  int *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  int *v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unsigned int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 32);
      if (v7)
      {
        atomic_store(a2, (unsigned int *)(v7 + 2320));
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v8 = (_QWORD *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
        {
          v9 = (*v8 ? *v8 : MEMORY[0x1E0C81028]);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            v15 = "VoiceProcessor_v2.cpp";
            v16 = 1024;
            v17 = 861;
            v18 = 1024;
            v19 = a2;
            _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> device orientation is set to %d", buf, 0x18u);
          }
        }
        v10 = *(int **)(v7 + 12560);
        if (v10 && (*(_BYTE *)(v7 + 15897) || *(_BYTE *)(v7 + 15898)))
        {
          if (VPLogScope(void)::once != -1)
          {
            v13 = *(int **)(v7 + 12560);
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            v10 = v13;
          }
          CALegacyLog::log(v10, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/VoiceProcessor_v2.cpp", 861, "SetDeviceOrientation", "device orientation is set to %d", a2);
        }
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_1B6120C7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN16VoiceProcessorV4C2ERKN2vp7ContextE_block_invoke_12()
{
  uint64_t result;
  uint64_t state64;

  state64 = 0;
  result = notify_get_state(VoiceProcessorV4::mNotifyTokenProx, &state64);
  atomic_store(state64, VoiceProcessorV4::mIsOnEar);
  return result;
}

uint64_t ___ZN16VoiceProcessorV4C2ERKN2vp7ContextE_block_invoke_7()
{
  uint64_t result;
  uint64_t state64;

  state64 = 0;
  result = notify_get_state(VoiceProcessorV4::mNotifyTokenProx, &state64);
  atomic_store(state64, VoiceProcessorV4::mIsOnEar);
  return result;
}

uint64_t __copy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16VoiceProcessorV2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16VoiceProcessorV2EE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void vp::v4::create(vp::v4 *this@<X0>, VoiceProcessorV4 **a2@<X8>)
{
  VoiceProcessorV4 *v5;

  v5 = (VoiceProcessorV4 *)operator new();
  VoiceProcessorV4::VoiceProcessorV4(v5, this);
  *a2 = v5;
}

void sub_1B6120D8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10F3C40EECCF9F7);
  _Unwind_Resume(a1);
}

void AULevelDrivenSuppressor::~AULevelDrivenSuppressor(AULevelDrivenSuppressor *this)
{
  AULevelDrivenSuppressor::~AULevelDrivenSuppressor(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void (**v2)(AULevelDrivenSuppressor *__hidden);
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;

  v2 = &off_1E69C7888;
  *(_QWORD *)this = &off_1E69C7888;
  v3 = *((_QWORD *)this + 84);
  if (v3)
  {
    MultiRadixFFT_Dispose(v3);
    v2 = *(void (***)(AULevelDrivenSuppressor *__hidden))this;
  }
  v2[8](this);
  v4 = (void *)*((_QWORD *)this + 223);
  if (v4)
  {
    *((_QWORD *)this + 224) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 220);
  if (v5)
  {
    *((_QWORD *)this + 221) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 217);
  if (v6)
  {
    *((_QWORD *)this + 218) = v6;
    operator delete(v6);
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 1720);
  v7 = (void *)*((_QWORD *)this + 201);
  if (v7)
  {
    *((_QWORD *)this + 202) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 198);
  if (v8)
  {
    *((_QWORD *)this + 199) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 195);
  if (v9)
  {
    *((_QWORD *)this + 196) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 192);
  if (v10)
  {
    *((_QWORD *)this + 193) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 189);
  if (v11)
  {
    *((_QWORD *)this + 190) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 186);
  if (v12)
  {
    *((_QWORD *)this + 187) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 183);
  if (v13)
  {
    *((_QWORD *)this + 184) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 180);
  if (v14)
  {
    *((_QWORD *)this + 181) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 177);
  if (v15)
  {
    *((_QWORD *)this + 178) = v15;
    operator delete(v15);
  }
  v16 = (void *)*((_QWORD *)this + 173);
  if (v16)
  {
    *((_QWORD *)this + 174) = v16;
    operator delete(v16);
  }
  v17 = (void *)*((_QWORD *)this + 170);
  if (v17)
  {
    *((_QWORD *)this + 171) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 167);
  if (v18)
  {
    *((_QWORD *)this + 168) = v18;
    operator delete(v18);
  }
  v19 = (void *)*((_QWORD *)this + 164);
  if (v19)
  {
    *((_QWORD *)this + 165) = v19;
    operator delete(v19);
  }
  v20 = (void *)*((_QWORD *)this + 161);
  if (v20)
  {
    *((_QWORD *)this + 162) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 158);
  if (v21)
  {
    *((_QWORD *)this + 159) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 155);
  if (v22)
  {
    *((_QWORD *)this + 156) = v22;
    operator delete(v22);
  }
  v23 = (void *)*((_QWORD *)this + 152);
  if (v23)
  {
    *((_QWORD *)this + 153) = v23;
    operator delete(v23);
  }
  v24 = (void *)*((_QWORD *)this + 149);
  if (v24)
  {
    *((_QWORD *)this + 150) = v24;
    operator delete(v24);
  }
  v25 = (void *)*((_QWORD *)this + 146);
  if (v25)
  {
    *((_QWORD *)this + 147) = v25;
    operator delete(v25);
  }
  v26 = (void *)*((_QWORD *)this + 143);
  if (v26)
  {
    *((_QWORD *)this + 144) = v26;
    operator delete(v26);
  }
  v27 = (void *)*((_QWORD *)this + 140);
  if (v27)
  {
    *((_QWORD *)this + 141) = v27;
    operator delete(v27);
  }
  v28 = (void *)*((_QWORD *)this + 130);
  if (v28)
  {
    *((_QWORD *)this + 131) = v28;
    operator delete(v28);
  }
  v29 = (void *)*((_QWORD *)this + 127);
  if (v29)
  {
    *((_QWORD *)this + 128) = v29;
    operator delete(v29);
  }
  v30 = (void *)*((_QWORD *)this + 124);
  if (v30)
  {
    *((_QWORD *)this + 125) = v30;
    operator delete(v30);
  }
  v31 = (void *)*((_QWORD *)this + 118);
  if (v31)
  {
    *((_QWORD *)this + 119) = v31;
    operator delete(v31);
  }
  v32 = (void *)*((_QWORD *)this + 115);
  if (v32)
  {
    *((_QWORD *)this + 116) = v32;
    operator delete(v32);
  }
  v33 = (void *)*((_QWORD *)this + 112);
  if (v33)
  {
    *((_QWORD *)this + 113) = v33;
    operator delete(v33);
  }
  v34 = (void *)*((_QWORD *)this + 109);
  if (v34)
  {
    *((_QWORD *)this + 110) = v34;
    operator delete(v34);
  }
  v35 = (void *)*((_QWORD *)this + 106);
  if (v35)
  {
    *((_QWORD *)this + 107) = v35;
    operator delete(v35);
  }
  v36 = (void *)*((_QWORD *)this + 103);
  if (v36)
  {
    *((_QWORD *)this + 104) = v36;
    operator delete(v36);
  }
  v37 = (void *)*((_QWORD *)this + 100);
  if (v37)
  {
    *((_QWORD *)this + 101) = v37;
    operator delete(v37);
  }
  v38 = (void *)*((_QWORD *)this + 97);
  if (v38)
  {
    *((_QWORD *)this + 98) = v38;
    operator delete(v38);
  }
  v39 = (void *)*((_QWORD *)this + 94);
  if (v39)
  {
    *((_QWORD *)this + 95) = v39;
    operator delete(v39);
  }
  v40 = (void *)*((_QWORD *)this + 91);
  if (v40)
  {
    *((_QWORD *)this + 92) = v40;
    operator delete(v40);
  }
  v41 = (void *)*((_QWORD *)this + 88);
  if (v41)
  {
    *((_QWORD *)this + 89) = v41;
    operator delete(v41);
  }
  v42 = (void *)*((_QWORD *)this + 74);
  if (v42)
  {
    *((_QWORD *)this + 75) = v42;
    operator delete(v42);
  }
  v43 = (void *)*((_QWORD *)this + 71);
  if (v43)
  {
    *((_QWORD *)this + 72) = v43;
    operator delete(v43);
  }
  ausdk::AUBase::~AUBase(this);
}

uint64_t AULevelDrivenSuppressor::Initialize(AULevelDrivenSuppressor *this)
{
  ausdk::AUScope *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t Element;
  int v9;
  float v10;
  int32x2_t v11;
  float *realp;
  DSPComplex *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  float *imagp;
  MultiRadixRealFFT *v21;
  vDSP_Length v22;
  vDSP_Length v23;
  float v24;
  unint64_t v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  float **v38;
  unint64_t v39;
  float v40;
  float *v41;
  float v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  unint64_t v46;
  float *v47;
  uint64_t v48;
  uint64_t v49;
  float v50;
  int v51;
  uint64_t v52;
  NSObject *v53;
  vDSP_Length v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  float v59;
  float v60;
  float *v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  float *v65;
  float v66;
  float v67;
  DSPSplitComplex v68;
  _BYTE __A[18];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v2 = (AULevelDrivenSuppressor *)((char *)this + 80);
  v3 = *((_QWORD *)this + 15);
  if (v3)
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    v5 = *((_QWORD *)this + 15);
    *((_DWORD *)this + 140) = v4;
    if (v5)
      LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    else
      v6 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  }
  else
  {
    v6 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    *((_DWORD *)this + 140) = v6;
  }
  if (v6 >= 2)
  {
    v7 = 1;
    do
    {
      Element = ausdk::AUScope::SafeGetElement(v2, v7 - 1);
      if (*(double *)(Element + 80) != *(double *)(ausdk::AUScope::SafeGetElement(v2, v7) + 80))
        return 4294956428;
    }
    while ((_DWORD)v6 != ++v7);
  }
  if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v2, 0) + 108) != 1)
    return 4294956428;
  v9 = *((_DWORD *)this + 84);
  *((_DWORD *)this + 162) = v9;
  *((_DWORD *)this + 163) = v9;
  *((_DWORD *)this + 164) = 2 * v9;
  *((_DWORD *)this + 165) = v9 + 1;
  v10 = *(double *)(ausdk::AUScope::SafeGetElement(v2, 0) + 80);
  *((float *)this + 161) = v10;
  *((float *)this + 166) = v10 / (float)*((unsigned int *)this + 162);
  v11 = *(int32x2_t *)((char *)this + 656);
  *((float *)this + 170) = 1.0 / (float)v11.u32[0];
  *(int32x2_t *)((char *)this + 692) = vshl_n_s32(v11, 2uLL);
  std::vector<float>::resize((uint64_t)this + 1312, v11.u32[0]);
  std::vector<float>::resize((uint64_t)this + 1336, *((unsigned int *)this + 164));
  *((_DWORD *)this + 171) = 1065353216;
  realp = (float *)*((_QWORD *)this + 164);
  v13 = (DSPComplex *)*((_QWORD *)this + 167);
  CreateMagicalWindow((uint64_t)v13, *((_DWORD *)this + 164));
  v14 = (uint64_t *)((char *)this + 672);
  v15 = *((_QWORD *)this + 84);
  if (v15)
    MultiRadixFFT_Dispose(v15);
  *((_QWORD *)this + 84) = 0;
  v16 = MultiRadixRealFFT_Create(*((_DWORD *)this + 164), (MultiRadixRealFFT **)this + 84);
  if (!(_DWORD)v16)
  {
    imagp = &realp[*((unsigned int *)this + 162)];
    v68.realp = realp;
    v68.imagp = imagp;
    vDSP_vsmul((const float *)v13, 1, (const float *)this + 170, (float *)v13, 1, *((unsigned int *)this + 164));
    v21 = (MultiRadixRealFFT *)*((_QWORD *)this + 84);
    if (v21)
    {
      MultiRadixRealFFT::RealOutOfPlaceForwardTransform(v21, v13, &v68, 1.0);
      realp = v68.realp;
      imagp = v68.imagp;
    }
    v22 = *((unsigned int *)this + 162);
    *(_QWORD *)__A = realp;
    *(_QWORD *)&__A[8] = imagp;
    vDSP_zvmags((const DSPSplitComplex *)__A, 1, (float *)v13, 1, v22);
    v13->real = *realp * *realp;
    *(&v13->real + v22) = *imagp * *imagp;
    v23 = *((unsigned int *)this + 165);
    *(_DWORD *)__A = 0;
    if ((_DWORD)v23)
    {
      vDSP_sve((const float *)v13, 1, (float *)__A, v23);
      v24 = (float)(*(float *)__A / (float)v23) + 1.0e-20;
      v25 = *((unsigned int *)this + 165);
    }
    else
    {
      v25 = 0;
      v24 = 1.0e-20;
    }
    *((float *)this + 171) = 0.861 / v24;
    std::vector<float>::resize((uint64_t)this + 568, v25);
    std::vector<float>::resize((uint64_t)this + 592, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 704, *((unsigned int *)this + 164));
    std::vector<float>::resize((uint64_t)this + 728, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 752, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 776, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 800, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 824, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 848, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 872, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 896, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 920, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 944, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 992, *((unsigned int *)this + 164));
    std::vector<float>::resize((uint64_t)this + 1016, *((unsigned int *)this + 164));
    std::vector<float>::resize((uint64_t)this + 1040, *((unsigned int *)this + 164));
    v26 = *((float *)this + 166);
    v67 = v26;
    v27 = -1.0 / (v26 * 0.005);
    *((float *)this + 242) = expf(v27);
    v28 = -1.0 / (v26 * 0.02);
    v29 = expf(v28);
    *((float *)this + 243) = v29;
    *((float *)this + 244) = v29;
    *((float *)this + 266) = expf(-1.0 / (float)(v26 * 0.04));
    *((float *)this + 267) = 1.0 - expf(-1.0 / (float)(v26 * 0.1));
    *((float *)this + 268) = 1.0 - expf(-1.0 / (float)(v26 * 0.05));
    *((_DWORD *)this + 269) = 1094713344;
    v30 = expf(-1.0 / (float)(v26 * 0.5));
    *((float *)this + 271) = v30;
    *((float *)this + 270) = 1.0 - v30;
    *((_QWORD *)this + 136) = 1112014848;
    *((_DWORD *)this + 274) = 0;
    *((_DWORD *)this + 352) = 7;
    *((_WORD *)this + 550) = 1;
    std::vector<float>::resize((uint64_t)this + 1120, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1144, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1168, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1192, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1216, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1240, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1264, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1288, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1360, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1384, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1488, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1512, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1536, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1464, *((unsigned int *)this + 165));
    std::vector<float>::resize((uint64_t)this + 1416, *((unsigned int *)this + 352));
    v31 = *((_QWORD *)this + 177);
    *(_OWORD *)v31 = xmmword_1B66A0620;
    *(_QWORD *)(v31 + 16) = 0x457A0000453B8000;
    *(_DWORD *)(v31 + 24) = 1174011904;
    std::vector<float>::resize((uint64_t)this + 1440, *((unsigned int *)this + 352));
    v32 = *((_QWORD *)this + 180);
    *(_OWORD *)v32 = xmmword_1B66A0630;
    __asm { FMOV            V0.2S, #7.0 }
    *(_QWORD *)(v32 + 16) = _D0;
    *(_DWORD *)(v32 + 24) = 1088421888;
    v38 = (float **)((char *)this + 1560);
    std::vector<float>::resize((uint64_t)this + 1560, *((unsigned int *)this + 165));
    v39 = *((unsigned int *)this + 165);
    if ((_DWORD)v39)
    {
      v40 = (float)(*((float *)this + 161) * 0.5) / (float)*((unsigned int *)this + 162);
      v41 = *v38;
      v42 = 0.0;
      v43 = *((unsigned int *)this + 165);
      do
      {
        *v41++ = v42;
        v42 = v40 + v42;
        v67 = v42;
        --v43;
      }
      while (v43);
    }
    else
    {
      v39 = 0;
    }
    v44 = (uint64_t *)((char *)this + 1584);
    std::vector<float>::resize((uint64_t)this + 1584, v39);
    std::vector<float>::resize((uint64_t)this + 1608, *((unsigned int *)this + 165));
    v45 = *((unsigned int *)this + 165);
    if ((_DWORD)v45)
    {
      v46 = 0;
      v47 = *v38;
      v48 = *((_QWORD *)this + 201);
      v49 = 4 * v45;
      do
      {
        v50 = v47[v46 / 4];
        if (v50 >= 200.0)
        {
          if (v50 >= 400.0)
          {
            if (v50 >= 800.0)
            {
              v52 = *v44;
              if (v50 >= 2000.0)
              {
                *(_DWORD *)(v52 + v46) = -1061158912;
                v51 = 1048609554;
              }
              else
              {
                *(_DWORD *)(v52 + v46) = -1056964608;
                v51 = 1042401985;
              }
            }
            else
            {
              *(_DWORD *)(*v44 + v46) = -1054867456;
              v51 = 1036831949;
            }
          }
          else
          {
            *(_DWORD *)(*v44 + v46) = -1052770304;
            v51 = 1031879315;
          }
        }
        else
        {
          *(_DWORD *)(*v44 + v46) = -1049624576;
          v51 = -1123979520;
        }
        *(_DWORD *)(v48 + v46) = v51;
        v46 += 4;
      }
      while (v49 != v46);
    }
    v17 = MultiRadixRealFFT::Initialize((AULevelDrivenSuppressor *)((char *)this + 1720), *((_DWORD *)this + 164));
    if (!(_DWORD)v17)
      goto LABEL_57;
    if (AUlsupLogScope(void)::once != -1)
      dispatch_once(&AUlsupLogScope(void)::once, &__block_literal_global_474);
    if (AUlsupLogScope(void)::scope)
    {
      v53 = *(NSObject **)AUlsupLogScope(void)::scope;
      if (!*(_QWORD *)AUlsupLogScope(void)::scope)
      {
LABEL_57:
        std::vector<float>::resize((uint64_t)this + 1736, *((unsigned int *)this + 164));
        std::vector<float>::resize((uint64_t)this + 1760, *((unsigned int *)this + 165));
        std::vector<float>::resize((uint64_t)this + 1784, *((unsigned int *)this + 165));
        *((_DWORD *)this + 452) = 1132068864;
        v54 = *((unsigned int *)this + 164);
        v55 = (float)((float)((float)((float)v54 + (float)v54) * 250.0)
                                  / *((float *)this + 161));
        v56 = v55 >> 1;
        if (v55 <= 1)
          v56 = 1;
        *((_DWORD *)this + 453) = v56;
        v57 = *((_DWORD *)this + 163);
        if (v56 > v57)
          *((_DWORD *)this + 453) = v57 - 1;
        v67 = 0.0;
        vDSP_vfill(&v67, *((float **)this + 217), 1, v54);
        v58 = *((_DWORD *)this + 453);
        v59 = 6.2832 / (float)(2 * v58 - 1);
        v67 = v59 * (float)(v58 - 1);
        v60 = cosf(v67) * -0.5 + 0.5;
        v61 = (float *)*((_QWORD *)this + 217);
        *v61 = v60;
        if (v58)
        {
          if (v58 + 1 > 2)
            v62 = v58 + 1;
          else
            v62 = 2;
          v63 = v62 - 1;
          v64 = *((_DWORD *)this + 164) - 1;
          v65 = v61 + 1;
          do
          {
            v67 = v59 * (float)v58;
            v66 = cosf(v67) * -0.5 + 0.5;
            *v65++ = v66;
            v61[v64] = v66;
            ++v58;
            --v64;
            --v63;
          }
          while (v63);
        }
        AULevelDrivenSuppressor::Reset(this);
        AULevelDrivenSuppressor::InitializeInternals(this);
        return v17;
      }
    }
    else
    {
      v53 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__A = 136315394;
      *(_QWORD *)&__A[4] = "AULevelDrivenSuppressor.cpp";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 315;
      _os_log_impl(&dword_1B5ED0000, v53, OS_LOG_TYPE_ERROR, "%25s:%-5d MultiRadixRealFFT_Create() returned an error. Invalid block size?", __A, 0x12u);
    }
    goto LABEL_57;
  }
  v17 = v16;
  if (*v14)
    MultiRadixFFT_Dispose(*v14);
  if (AUlsupLogScope(void)::once != -1)
    dispatch_once(&AUlsupLogScope(void)::once, &__block_literal_global_474);
  if (AUlsupLogScope(void)::scope)
  {
    v18 = *(NSObject **)AUlsupLogScope(void)::scope;
    if (!*(_QWORD *)AUlsupLogScope(void)::scope)
      return v17;
  }
  else
  {
    v18 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__A = 136315394;
    *(_QWORD *)&__A[4] = "AULevelDrivenSuppressor.cpp";
    *(_WORD *)&__A[12] = 1024;
    *(_DWORD *)&__A[14] = 191;
    _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d MultiRadixRealFFT_Create() returned an error. Invalid block size?", __A, 0x12u);
  }
  return v17;
}

uint64_t AULevelDrivenSuppressor::Reset(AULevelDrivenSuppressor *this)
{
  void *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;

  *(_OWORD *)((char *)this + 536) = xmmword_1B6627BC0;
  if (*((_BYTE *)this + 17))
  {
    v2 = (void *)*((_QWORD *)this + 74);
    v3 = *((_QWORD *)this + 75) - (_QWORD)v2;
    if (v3 >= 1)
      bzero(v2, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
    v4 = (void *)*((_QWORD *)this + 88);
    v5 = *((_QWORD *)this + 89) - (_QWORD)v4;
    if (v5 >= 1)
      bzero(v4, 4 * (((unint64_t)v5 >> 2) - ((unint64_t)v5 > 3)) + 4);
    v6 = (void *)*((_QWORD *)this + 91);
    v7 = *((_QWORD *)this + 92) - (_QWORD)v6;
    if (v7 >= 1)
      bzero(v6, 4 * (((unint64_t)v7 >> 2) - ((unint64_t)v7 > 3)) + 4);
    v8 = (void *)*((_QWORD *)this + 94);
    v9 = *((_QWORD *)this + 95) - (_QWORD)v8;
    if (v9 >= 1)
      bzero(v8, 4 * (((unint64_t)v9 >> 2) - ((unint64_t)v9 > 3)) + 4);
    v10 = (void *)*((_QWORD *)this + 97);
    v11 = *((_QWORD *)this + 98) - (_QWORD)v10;
    if (v11 >= 1)
      memset_pattern16(v10, &unk_1B6627B80, 4 * (((unint64_t)v11 >> 2) - ((unint64_t)v11 > 3)) + 4);
    v12 = (void *)*((_QWORD *)this + 100);
    v13 = *((_QWORD *)this + 101) - (_QWORD)v12;
    if (v13 >= 1)
      memset_pattern16(v12, &unk_1B6627B80, 4 * (((unint64_t)v13 >> 2) - ((unint64_t)v13 > 3)) + 4);
    v14 = (void *)*((_QWORD *)this + 103);
    v15 = *((_QWORD *)this + 104) - (_QWORD)v14;
    if (v15 >= 1)
      memset_pattern16(v14, &unk_1B6627B80, 4 * (((unint64_t)v15 >> 2) - ((unint64_t)v15 > 3)) + 4);
    v16 = (void *)*((_QWORD *)this + 106);
    v17 = *((_QWORD *)this + 107) - (_QWORD)v16;
    if (v17 >= 1)
      memset_pattern16(v16, &unk_1B6627B80, 4 * (((unint64_t)v17 >> 2) - ((unint64_t)v17 > 3)) + 4);
    v18 = (void *)*((_QWORD *)this + 124);
    v19 = *((_QWORD *)this + 125) - (_QWORD)v18;
    if (v19 >= 1)
      bzero(v18, 4 * (((unint64_t)v19 >> 2) - ((unint64_t)v19 > 3)) + 4);
    v20 = (void *)*((_QWORD *)this + 127);
    v21 = *((_QWORD *)this + 128) - (_QWORD)v20;
    if (v21 >= 1)
      bzero(v20, 4 * (((unint64_t)v21 >> 2) - ((unint64_t)v21 > 3)) + 4);
    v22 = (void *)*((_QWORD *)this + 130);
    v23 = *((_QWORD *)this + 131) - (_QWORD)v22;
    if (v23 >= 1)
      bzero(v22, 4 * (((unint64_t)v23 >> 2) - ((unint64_t)v23 > 3)) + 4);
    v24 = (void *)*((_QWORD *)this + 140);
    v25 = *((_QWORD *)this + 141) - (_QWORD)v24;
    if (v25 >= 1)
      bzero(v24, 4 * (((unint64_t)v25 >> 2) - ((unint64_t)v25 > 3)) + 4);
    v26 = (void *)*((_QWORD *)this + 143);
    v27 = *((_QWORD *)this + 144) - (_QWORD)v26;
    if (v27 >= 1)
      bzero(v26, 4 * (((unint64_t)v27 >> 2) - ((unint64_t)v27 > 3)) + 4);
    v28 = (void *)*((_QWORD *)this + 146);
    v29 = *((_QWORD *)this + 147) - (_QWORD)v28;
    if (v29 >= 1)
      bzero(v28, 4 * (((unint64_t)v29 >> 2) - ((unint64_t)v29 > 3)) + 4);
    v30 = (void *)*((_QWORD *)this + 149);
    v31 = *((_QWORD *)this + 150) - (_QWORD)v30;
    if (v31 >= 1)
      bzero(v30, 4 * (((unint64_t)v31 >> 2) - ((unint64_t)v31 > 3)) + 4);
    v32 = (void *)*((_QWORD *)this + 152);
    v33 = *((_QWORD *)this + 153) - (_QWORD)v32;
    if (v33 >= 1)
      bzero(v32, 4 * (((unint64_t)v33 >> 2) - ((unint64_t)v33 > 3)) + 4);
    v34 = (void *)*((_QWORD *)this + 155);
    v35 = *((_QWORD *)this + 156) - (_QWORD)v34;
    if (v35 >= 1)
      bzero(v34, 4 * (((unint64_t)v35 >> 2) - ((unint64_t)v35 > 3)) + 4);
    v36 = (void *)*((_QWORD *)this + 158);
    v37 = *((_QWORD *)this + 159) - (_QWORD)v36;
    if (v37 >= 1)
      bzero(v36, 4 * (((unint64_t)v37 >> 2) - ((unint64_t)v37 > 3)) + 4);
    v38 = (void *)*((_QWORD *)this + 161);
    v39 = *((_QWORD *)this + 162) - (_QWORD)v38;
    if (v39 >= 1)
      bzero(v38, 4 * (((unint64_t)v39 >> 2) - ((unint64_t)v39 > 3)) + 4);
    v40 = (void *)*((_QWORD *)this + 186);
    v41 = *((_QWORD *)this + 187) - (_QWORD)v40;
    if (v41 >= 1)
      bzero(v40, 4 * (((unint64_t)v41 >> 2) - ((unint64_t)v41 > 3)) + 4);
    v42 = (void *)*((_QWORD *)this + 220);
    v43 = *((_QWORD *)this + 221) - (_QWORD)v42;
    if (v43 >= 1)
      bzero(v42, 4 * (((unint64_t)v43 >> 2) - ((unint64_t)v43 > 3)) + 4);
    v44 = (void *)*((_QWORD *)this + 112);
    v45 = *((_QWORD *)this + 113) - (_QWORD)v44;
    if (v45 >= 1)
      bzero(v44, 4 * (((unint64_t)v45 >> 2) - ((unint64_t)v45 > 3)) + 4);
    v46 = (void *)*((_QWORD *)this + 115);
    v47 = *((_QWORD *)this + 116) - (_QWORD)v46;
    if (v47 >= 1)
      bzero(v46, 4 * (((unint64_t)v47 >> 2) - ((unint64_t)v47 > 3)) + 4);
    v48 = (void *)*((_QWORD *)this + 118);
    v49 = *((_QWORD *)this + 119) - (_QWORD)v48;
    if (v49 >= 1)
      bzero(v48, 4 * (((unint64_t)v49 >> 2) - ((unint64_t)v49 > 3)) + 4);
  }
  *(_QWORD *)((char *)this + 1092) = 0;
  *((_BYTE *)this + 1100) = 1;
  *((_DWORD *)this + 138) = 0;
  *((_DWORD *)this + 276) = 0;
  *((_DWORD *)this + 278) = 0;
  return 0;
}

uint64_t AULevelDrivenSuppressor::GetPropertyInfo(AULevelDrivenSuppressor *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  int v8;
  char v9;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 8000)
  {
    if (a2 != 21)
    {
      if (a2 != 3700)
        return result;
      *a6 = 0;
      goto LABEL_13;
    }
    v9 = 1;
LABEL_12:
    *a6 = v9;
LABEL_13:
    v8 = 4;
    goto LABEL_14;
  }
  if (a2 == 8001)
  {
    v9 = *((_BYTE *)this + 17) ^ 1;
    goto LABEL_12;
  }
  if (a2 != 8020)
    return result;
  *a6 = 1;
  v8 = 4 * *((_DWORD *)this + 84) + 4;
LABEL_14:
  result = 0;
  *a5 = v8;
  return result;
}

uint64_t AULevelDrivenSuppressor::GetProperty(AULevelDrivenSuppressor *this, int a2, int a3, unsigned int a4, float *__C)
{
  uint64_t result;
  int v7;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 8000)
  {
    if (a2 == 21)
    {
      result = 0;
      v7 = *((unsigned __int8 *)this + 557);
    }
    else
    {
      if (a2 != 3700)
        return result;
      result = 0;
      v7 = *((unsigned __int8 *)this + 376);
    }
    goto LABEL_13;
  }
  if (a2 == 8001)
  {
    result = 0;
    v7 = *((_DWORD *)this + 141);
LABEL_13:
    *(_DWORD *)__C = v7;
    return result;
  }
  if (a2 == 8020)
  {
    if (*((_BYTE *)this + 17))
      memcpy(__C, *((const void **)this + 71), 4 * (*((_DWORD *)this + 84) + 1));
    else
      vDSP_vclr(__C, 1, (*((_DWORD *)this + 84) + 1));
    return 0;
  }
  return result;
}

uint64_t AULevelDrivenSuppressor::SetProperty(AULevelDrivenSuppressor *this, int a2, int a3, unsigned int a4, _DWORD *__src, size_t __n)
{
  uint64_t result;
  FILE **v8;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 8000)
  {
    if (a2 == 8001)
    {
      if ((_DWORD)__n == 4 && *((_DWORD *)this + 141) <= 6u)
      {
        result = 0;
        *((_DWORD *)this + 141) = *__src;
        return result;
      }
    }
    else
    {
      if (a2 != 8020)
        return result;
      if (!*((_BYTE *)this + 17))
        return 0;
      if (__n == 4 * (*((_DWORD *)this + 84) + 1))
      {
        memcpy(*((void **)this + 71), __src, __n);
        return 0;
      }
    }
    return 4294956445;
  }
  if (a2 == 21)
  {
    *((_BYTE *)this + 557) = *__src != 0;
    v8 = (FILE **)MEMORY[0x1E0C80C20];
    fprintf((FILE *)*MEMORY[0x1E0C80C20], "%4d %s %s \n", 584, "SetProperty", "18:35:24");
    fflush(*v8);
    return 0;
  }
  if (a2 == 3700)
  {
    result = 4294956445;
    if (__n >= 4)
    {
      if (*(_BYTE *)__src)
        return 0;
      else
        return 4294956445;
    }
  }
  return result;
}

uint64_t AULevelDrivenSuppressor::SetParameter(AULevelDrivenSuppressor *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  ausdk::AUElement *v11;

  if (a3)
  {
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  }
  else
  {
    v11 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 32), a4);
    ausdk::AUElement::SetParameter(v11, a2, a5, 0);
    if (a2 <= 4)
      ++*((_DWORD *)this + 134);
  }
  return 0;
}

uint64_t AULevelDrivenSuppressor::CanScheduleParameters(AULevelDrivenSuppressor *this)
{
  return 0;
}

uint64_t AULevelDrivenSuppressor::ProcessMultipleBufferLists(AULevelDrivenSuppressor *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  int v11;
  int v12;
  const float *mData;
  float *v14;
  size_t v15;
  void *v16;
  void *v17;
  const AudioBufferList *v19;
  float *realp;
  vDSP_Length v21;
  float *v22;
  vDSP_Length v23;
  float v24;
  float v25;
  float v26;
  int v27;
  void *v28;
  const void *v29;
  float *v30;
  uint64_t v31;
  float *v32;
  float *v33;
  DSPComplex *v34;
  float v35;
  vDSP_Length v36;
  vDSP_Length v37;
  float *v38;
  float *v39;
  const float *v40;
  uint64_t v41;
  float *v42;
  float *v43;
  float v44;
  float v45;
  vDSP_Length v46;
  float v47;
  uint64_t v48;
  float *v49;
  const float *v50;
  float *v51;
  float *v52;
  float *v53;
  vDSP_Length v54;
  float v55;
  float v56;
  float v57;
  float v58;
  const float *v59;
  float *v60;
  const float *v61;
  float *v62;
  float *v63;
  const float *v64;
  float *v65;
  float *v66;
  vDSP_Length v67;
  uint64_t v68;
  uint64_t v69;
  char *v70;
  float *v71;
  float *v72;
  const float *v73;
  const float *v74;
  uint64_t v75;
  float *v76;
  uint64_t v77;
  float *v78;
  float *v79;
  float *v80;
  vDSP_Length v81;
  float *v82;
  const float *v83;
  uint64_t v84;
  float v85;
  float *v86;
  vDSP_Length v87;
  float v88;
  uint64_t v89;
  float v90;
  float v91;
  int v92;
  float v93;
  float v94;
  float v95;
  float *v96;
  float *v97;
  float *v98;
  const float *v99;
  const float *v100;
  float v101;
  float v102;
  const float *v103;
  const float *v104;
  const float *v105;
  uint64_t v106;
  float *v107;
  float *v108;
  float *v109;
  float *v110;
  float *v111;
  float *v112;
  vDSP_Length v113;
  float *v114;
  float *v115;
  uint64_t v116;
  float v117;
  unsigned int v118;
  float v119;
  float v120;
  uint64_t v121;
  float v122;
  vDSP_Length v123;
  float *v124;
  float *v125;
  uint64_t i;
  float *v127;
  vDSP_Length v128;
  float *v129;
  uint64_t v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  void *v139;
  float *v140;
  float *v141;
  float *v142;
  float *v143;
  uint64_t v144;
  unsigned int v145;
  float *v146;
  float *v147;
  float *v148;
  uint64_t v149;
  float v150;
  double v151;
  float v152;
  float v153;
  const float *v154;
  float *v155;
  const float *v156;
  float *v157;
  vDSP_Length v158;
  float v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float *v164;
  const float *v165;
  vDSP_Length v166;
  const float *v167;
  float *v168;
  const float *v169;
  float *v170;
  float *v171;
  float *v172;
  float v173;
  float __B;
  DSPSplitComplex __A;
  float v176;
  float __C;

  if (*((_DWORD *)this + 84) != a3)
    return 4294956422;
  v11 = *((_DWORD *)this + 134);
  if (*((_DWORD *)this + 135) != v11)
  {
    AULevelDrivenSuppressor::InitializeInternals(this);
    *((_DWORD *)this + 135) = v11;
  }
  v12 = *((_DWORD *)this + 136);
  if (*((_DWORD *)this + 137) != v12)
    *((_DWORD *)this + 137) = v12;
  mData = (const float *)(*a5)->mBuffers[0].mData;
  v14 = (float *)(*a7)->mBuffers[0].mData;
  if (!*((_BYTE *)this + 557))
  {
    memcpy(*((void **)this + 88), (*a5)->mBuffers[0].mData, *((unsigned int *)this + 173));
    if (a4 >= 2)
    {
      if (*((_DWORD *)this + 141))
      {
        if (*((_DWORD *)this + 140) >= 2u)
        {
          v19 = a5[1];
          if (v19)
          {
            memcpy(*((void **)this + 74), v19->mBuffers[0].mData, 4 * *((unsigned int *)this + 162));
            *(_DWORD *)(*((_QWORD *)this + 74) + 4 * *((unsigned int *)this + 162)) = 0;
          }
        }
      }
    }
    v21 = *((unsigned int *)this + 162);
    v22 = (float *)*((_QWORD *)this + 91);
    __A.realp = (float *)*((_QWORD *)this + 88);
    realp = __A.realp;
    __A.imagp = &__A.realp[v21];
    vDSP_zvmags(&__A, 1, v22, 1, v21);
    *v22 = *realp * *realp;
    v22[v21] = realp[v21] * realp[v21];
    vDSP_vsmul(v22, 1, (const float *)this + 171, v22, 1, *((unsigned int *)this + 165));
    v23 = *((unsigned int *)this + 165);
    LODWORD(__A.realp) = 0;
    if ((_DWORD)v23)
    {
      vDSP_sve(v22, 1, (float *)&__A, v23);
      v24 = (float)(*(float *)&__A.realp / (float)v23) + 1.0e-20;
    }
    else
    {
      v24 = 1.0e-20;
    }
    v25 = log10f(v24) * 10.0;
    *((float *)this + 172) = v25;
    v26 = *((float *)this + 157) - v25;
    v176 = v26;
    __B = 0.0316;
    v27 = *((_DWORD *)this + 141);
    if (v27 == 3)
    {
      v28 = (void *)*((_QWORD *)this + 140);
      v29 = (const void *)*((_QWORD *)this + 74);
    }
    else
    {
      if (v27 != 6)
      {
        v176 = __exp10f(v26 * 0.1);
        v96 = (float *)*((_QWORD *)this + 164);
        v97 = (float *)*((_QWORD *)this + 167);
        v98 = (float *)*((_QWORD *)this + 140);
        v99 = (const float *)*((_QWORD *)this + 143);
        vDSP_vsmul(v22, 1, &v176, v96, 1, *((unsigned int *)this + 165));
        vDSP_vsmul(v99, 1, &__B, v97, 1, *((unsigned int *)this + 165));
        vDSP_vadd(v96, 1, v97, 1, v98, 1, *((unsigned int *)this + 165));
        switch(*((_DWORD *)this + 141))
        {
          case 1:
            v100 = (const float *)*((_QWORD *)this + 74);
            goto LABEL_84;
          case 2:
            v103 = (const float *)*((_QWORD *)this + 74);
            goto LABEL_86;
          case 4:
            v100 = (const float *)*((_QWORD *)this + 71);
LABEL_84:
            vDSP_vmin(v98, 1, v100, 1, v98, 1, *((unsigned int *)this + 165));
            break;
          case 5:
            v103 = (const float *)*((_QWORD *)this + 71);
LABEL_86:
            vDSP_vmax(v98, 1, v103, 1, v98, 1, *((unsigned int *)this + 165));
            break;
          default:
            break;
        }
LABEL_22:
        v169 = mData;
        v170 = v14;
        if (*((_BYTE *)this + 532))
        {
          v30 = (float *)*((_QWORD *)this + 88);
          v31 = *((unsigned int *)this + 162);
          v32 = (float *)*((_QWORD *)this + 164);
          v33 = &v32[v31];
          __A.realp = v32;
          __A.imagp = v33;
          v34 = (DSPComplex *)*((_QWORD *)this + 167);
          v35 = 1.0e-20;
          *v32 = logf((float)(*v30 * *v30) + 1.0e-20);
          v36 = *((unsigned int *)this + 163);
          if (v36 >= 2)
          {
            v37 = v36 - 1;
            v38 = v32 + 1;
            v39 = v30 + 1;
            do
            {
              v173 = (float)((float)(v39[v31] * v39[v31]) + (float)(*v39 * *v39)) + 1.0e-20;
              *v38++ = logf(v173) * 0.5;
              ++v39;
              --v37;
            }
            while (v37);
          }
          v173 = 0.0;
          vDSP_vfill(&v173, v33, 1, v36);
          MultiRadixRealFFT::RealOutOfPlaceInverseTransform((const vDSP_DFT_SetupStruct ***)this + 215, &__A, v34);
          vDSP_vmul((const float *)v34, 1, *((const float **)this + 217), 1, (float *)v34, 1, *((unsigned int *)this + 164));
          MultiRadixRealFFT::RealOutOfPlaceForwardTransform((AULevelDrivenSuppressor *)((char *)this + 1720), v34, &__A, 1.0);
          v40 = (const float *)*((_QWORD *)this + 220);
          v41 = *((unsigned int *)this + 162);
          if ((_DWORD)v41)
          {
            v42 = __A.realp;
            v43 = (float *)*((_QWORD *)this + 220);
            do
            {
              v44 = *v43 + 1.0e-20;
              v45 = *v42++;
              *v43++ = (float)(v44 + expf(v45)) * 0.5;
              --v41;
            }
            while (v41);
          }
          v46 = *((unsigned int *)this + 165);
          v40[(v46 - 1)] = 0.0;
          __C = 0.0;
          if ((_DWORD)v46)
          {
            vDSP_sve(v40, 1, &__C, v46);
            v35 = (float)(__C / (float)v46) + 1.0e-20;
          }
          v173 = log10f(v35) * 10.0;
          __B = (float)(*((float *)this + 154) + 6.0) - v173;
          __B = fminf(__exp10f(__B * 0.1), 1.0e10);
          vDSP_vsmul(v40, 1, &__B, *((float **)this + 223), 1, *((unsigned int *)this + 165));
        }
        else
        {
          v176 = 0.0;
          vDSP_vfill(&v176, *((float **)this + 223), 1, *((unsigned int *)this + 165));
        }
        v47 = 1.0 - *((float *)this + 266);
        *(float *)&__A.realp = v47 * 0.333;
        __C = v47 * 0.667;
        v48 = *((_QWORD *)this + 164);
        v49 = (float *)*((_QWORD *)this + 167);
        v50 = (const float *)*((_QWORD *)this + 91);
        v51 = (float *)*((_QWORD *)this + 152);
        v52 = (float *)*((_QWORD *)this + 155);
        v53 = (float *)*((_QWORD *)this + 158);
        v171 = (float *)*((_QWORD *)this + 161);
        v54 = *((unsigned int *)this + 165);
        *(_DWORD *)v48 = 0;
        vDSP_vsmul(v50, 1, (const float *)&__A, (float *)(v48 + 4), 1, (v54 - 1));
        vDSP_vsma(v50 + 1, 1, (const float *)&__A, (const float *)v48, 1, (float *)v48, 1, (v54 - 1));
        vDSP_vsma(v50, 1, &__C, (const float *)v48, 1, (float *)v48, 1, v54);
        vDSP_vsma(v51, 1, (const float *)this + 266, (const float *)v48, 1, v51, 1, v54);
        v55 = *((float *)this + 166);
        v56 = v55 * 0.2;
        v57 = *((float *)this + 273);
        if (v57 >= (float)(v55 * 0.2))
        {
          v56 = v55 * 0.5;
          if (v57 >= (float)(v55 * 0.5))
            v56 = v55 + v55;
        }
        if (v56 < (float)*((unsigned int *)this + 274) || *((_BYTE *)this + 1100))
        {
          *((_DWORD *)this + 274) = 0;
          vDSP_vmin(v53, 1, v51, 1, v52, 1, *((unsigned int *)this + 165));
          memcpy(v53, v51, *((unsigned int *)this + 174));
        }
        else
        {
          vDSP_vmin(v52, 1, v51, 1, v52, 1, *((unsigned int *)this + 165));
          vDSP_vmin(v53, 1, v51, 1, v53, 1, *((unsigned int *)this + 165));
        }
        v176 = 1.0e-20;
        vDSP_vsadd(v51, 1, &v176, (float *)v48, 1, *((unsigned int *)this + 165));
        vDSP_vsadd(v52, 1, &v176, v49, 1, *((unsigned int *)this + 165));
        vDSP_vdiv(v49, 1, (const float *)v48, 1, v171, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v52, 1, *((const float **)this + 183), 1, (float *)v48, 1, *((unsigned int *)this + 165));
        vDSP_vsub((const float *)v48, 1, v51, 1, *((float **)this + 186), 1, *((unsigned int *)this + 165));
        v58 = *((float *)this + 273) + 1.0;
        if ((float)(*((float *)this + 166) * 30.0) < v58)
          v58 = *((float *)this + 166) * 30.0;
        *((float *)this + 273) = v58;
        ++*((_DWORD *)this + 274);
        v59 = (const float *)*((_QWORD *)this + 91);
        v60 = (float *)*((_QWORD *)this + 167);
        v61 = (const float *)*((_QWORD *)this + 140);
        v62 = (float *)*((_QWORD *)this + 170);
        vDSP_vsmul(v59, 1, (const float *)this + 270, v62, 1, *((unsigned int *)this + 165));
        v63 = (float *)*((_QWORD *)this + 149);
        vDSP_vsma(v63, 1, (const float *)this + 271, v62, 1, v62, 1, *((unsigned int *)this + 165));
        v64 = (const float *)*((_QWORD *)this + 155);
        vDSP_vsmul(v64, 1, (const float *)this + 269, v60, 1, *((unsigned int *)this + 165));
        v65 = (float *)*((_QWORD *)this + 189);
        vDSP_vsub(v60, 1, v59, 1, v65, 1, *((unsigned int *)this + 165));
        v66 = (float *)*((_QWORD *)this + 192);
        vDSP_vmax(*((const float **)this + 186), 1, v65, 1, v66, 1, *((unsigned int *)this + 165));
        v67 = *((unsigned int *)this + 165);
        if ((_DWORD)v67)
        {
          v68 = 0;
          v69 = *((_QWORD *)this + 152);
          do
          {
            if (v66[v68] <= 0.0 && (v70 = (char *)v59, !*((_BYTE *)this + 1101))
              || (v70 = (char *)v62, *(float *)(v69 + v68 * 4) < (float)(*((float *)this + 272) * v64[v68])))
            {
              v63[v68] = *(float *)&v70[v68 * 4];
            }
            ++v68;
          }
          while (v67 != v68);
        }
        else
        {
          v67 = 0;
        }
        vDSP_vmax(v63, 1, v61, 1, v63, 1, v67);
        v71 = (float *)*((_QWORD *)this + 124);
        v72 = (float *)*((_QWORD *)this + 127);
        v73 = (const float *)*((_QWORD *)this + 94);
        v74 = (const float *)*((_QWORD *)this + 149);
        v75 = *((_QWORD *)this + 167);
        v76 = (float *)*((_QWORD *)this + 170);
        v77 = *((_QWORD *)this + 130);
        v78 = (float *)*((_QWORD *)this + 164);
        vDSP_vmax(*((const float **)this + 91), 1, v74, 1, v78, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 507307272;
        v79 = (float *)*((_QWORD *)this + 170);
        vDSP_vsadd(v74, 1, (const float *)&__A, v79, 1, *((unsigned int *)this + 165));
        v80 = (float *)*((_QWORD *)this + 167);
        v81 = *((unsigned int *)this + 165);
        v172 = v76;
        if ((_DWORD)v81)
        {
          v82 = v79;
          v83 = (const float *)*((_QWORD *)this + 167);
          v84 = *((unsigned int *)this + 165);
          do
          {
            v85 = *v82++;
            *v80++ = 1.0 / v85;
            --v84;
          }
          while (v84);
        }
        else
        {
          v83 = (const float *)*((_QWORD *)this + 167);
          v81 = 0;
        }
        v86 = (float *)*((_QWORD *)this + 173);
        vDSP_vadd(v73, 1, v79, 1, v86, 1, v81);
        vDSP_vdiv(v86, 1, v73, 1, v86, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v86, 1, v86, 1, v86, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 1063507722;
        vDSP_vsmul(v86, 1, (const float *)&__A, v86, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 1036831949;
        vDSP_vsadd(v86, 1, (const float *)&__A, v86, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v78, 1, v83, 1, v71, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = -1082130432;
        vDSP_vsadd(v71, 1, (const float *)&__A, v71, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 1120403456;
        __C = 0.0;
        vDSP_vclip(v71, 1, &__C, (const float *)&__A, v72, 1, *((unsigned int *)this + 165));
        vDSP_vmin(v71, 1, v72, 1, v71, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v72, 1, v86, 1, v72, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = -1082130432;
        vDSP_vsadd(v86, 1, (const float *)&__A, v86, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v73, 1, v86, 1, v86, 1, *((unsigned int *)this + 165));
        vDSP_vmul(v83, 1, v86, 1, v86, 1, *((unsigned int *)this + 165));
        vDSP_vsub(v86, 1, v72, 1, v72, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 1120403456;
        __C = -1.0e20;
        vDSP_vclip(v72, 1, &__C, (const float *)&__A, v72, 1, *((unsigned int *)this + 165));
        vDSP_vsub(v72, 1, (const float *)v77, 1, (float *)v75, 1, *((unsigned int *)this + 165));
        LODWORD(__A.realp) = 0;
        vDSP_vfill((const float *)&__A, v172, 1, *((unsigned int *)this + 165));
        vDSP_vmax(v172, 1, (const float *)v75, 1, v172, 1, *((unsigned int *)this + 165));
        vDSP_vsub(v172, 1, (const float *)v75, 1, (float *)v75, 1, *((unsigned int *)this + 165));
        vDSP_vsmul((const float *)v75, 1, (const float *)this + 242, (float *)v75, 1, *((unsigned int *)this + 165));
        vDSP_vadd((const float *)v75, 1, v72, 1, (float *)v75, 1, *((unsigned int *)this + 165));
        vDSP_vsmul(v172, 1, (const float *)this + 243, v78, 1, 5uLL);
        vDSP_vadd(v78, 1, (const float *)v75, 1, (float *)v77, 1, 5uLL);
        vDSP_vsmul(v172 + 5, 1, (const float *)this + 244, v78 + 5, 1, (*((_DWORD *)this + 165) - 5));
        vDSP_vadd(v78 + 5, 1, (const float *)(v75 + 20), 1, (float *)(v77 + 20), 1, (*((_DWORD *)this + 165) - 5));
        v87 = *((unsigned int *)this + 165);
        if ((_DWORD)v87)
        {
          v88 = 0.0;
          v89 = *((unsigned int *)this + 165);
          do
          {
            v90 = *(float *)v77;
            v77 += 4;
            v91 = v90;
            if (v90 <= 3.0)
              v91 = -0.0;
            v88 = v88 + v91;
            --v89;
          }
          while (v89);
        }
        else
        {
          v88 = 0.0;
        }
        *((float *)this + 138) = (float)((float)(1.0
                                               / (float)((float)(0.5 / (float)(v88 / (float)v87)) + 1.0))
                                       * 0.899)
                               + 0.1;
        if (*((_BYTE *)this + 532))
        {
          vDSP_vsub(*((const float **)this + 223), 1, *((const float **)this + 91), 1, *((float **)this + 109), 1, v87);
          LODWORD(__A.realp) = 0;
          vDSP_vthr(*((const float **)this + 109), 1, (const float *)&__A, *((float **)this + 109), 1, *((unsigned int *)this + 165));
          memcpy(*((void **)this + 112), *((const void **)this + 109), *((unsigned int *)this + 174));
          vDSP_vadd(*((const float **)this + 112), 1, *((const float **)this + 112), 1, *((float **)this + 112), 1, *((unsigned int *)this + 165));
          vDSP_vadd(*((const float **)this + 112), 1, (const float *)(*((_QWORD *)this + 109) + 4), 1, *((float **)this + 112), 1, *((unsigned int *)this + 162));
          vDSP_vadd((const float *)(*((_QWORD *)this + 112) + 4), 1, *((const float **)this + 109), 1, *((float **)this + 112), 1, *((unsigned int *)this + 162));
          __C = 0.0079;
          vDSP_vsmul(*((const float **)this + 112), 1, &__C, *((float **)this + 112), 1, *((unsigned int *)this + 165));
          __C = 0.1;
          vDSP_vsmul(*((const float **)this + 115), 1, &__C, *((float **)this + 170), 1, *((unsigned int *)this + 165));
          memcpy(*((void **)this + 115), *((const void **)this + 112), *((unsigned int *)this + 165));
          vDSP_vadd(*((const float **)this + 112), 1, *((const float **)this + 170), 1, *((float **)this + 112), 1, *((unsigned int *)this + 165));
        }
        else
        {
          LODWORD(__A.realp) = 0;
          vDSP_vfill((const float *)&__A, *((float **)this + 115), 1, v87);
        }
        v92 = *((_DWORD *)this + 132);
        if (v92 == 1)
        {
          v101 = *((float *)this + 172);
          v102 = *((float *)this + 154);
          if (v101 > (float)(v102 + 6.0))
          {
            v95 = 0.25119;
            goto LABEL_92;
          }
          v95 = 0.1;
          if (v101 > v102 || v101 > (float)(v102 + -6.0))
          {
LABEL_92:
            v104 = (const float *)*((_QWORD *)this + 127);
            v105 = (const float *)*((_QWORD *)this + 124);
            v106 = *((_QWORD *)this + 130);
            v107 = (float *)*((_QWORD *)this + 97);
            v108 = (float *)*((_QWORD *)this + 100);
            v109 = (float *)*((_QWORD *)this + 164);
            v110 = (float *)*((_QWORD *)this + 167);
            v111 = (float *)*((_QWORD *)this + 170);
            v112 = (float *)*((_QWORD *)this + 173);
            LODWORD(__A.realp) = 1065353216;
            vDSP_vsadd(v104, 1, (const float *)&__A, v112, 1, *((unsigned int *)this + 165));
            vDSP_vdiv(v112, 1, v104, 1, v110, 1, *((unsigned int *)this + 165));
            vDSP_vsadd(v105, 1, (const float *)&__A, v109, 1, *((unsigned int *)this + 165));
            vDSP_vmul(v109, 1, v110, 1, v109, 1, *((unsigned int *)this + 165));
            v113 = *((unsigned int *)this + 165);
            if ((_DWORD)v113)
            {
              v114 = v109;
              v115 = v107;
              v116 = *((unsigned int *)this + 165);
              do
              {
                v117 = *v114;
                v118 = vcvtms_s32_f32(v117 + v117);
                v119 = 1.0;
                if ((v118 & 0x80000000) == 0)
                {
                  if (*((_DWORD *)this + 408) - 2 >= v118)
                  {
                    v120 = -(float)(floorf(v117 + v117) - (float)(v117 * 2.0));
                    v119 = (float)((float)(v120 * *((float *)this + v118 + 410))
                                 + (float)((float)(1.0 - v120) * *((float *)this + v118 + 409)))
                         / sqrtf(v117 + 0.0001);
                  }
                  else
                  {
                    v119 = (float)(0.1296 / v117) + 1.0;
                  }
                }
                *v115++ = v119;
                ++v114;
                --v116;
              }
              while (v116);
            }
            else
            {
              v113 = 0;
            }
            vDSP_vmul(v110, 1, v107, 1, v107, 1, v113);
            __C = -1.0e20;
            vDSP_vclip(v107, 1, &__C, (const float *)&__A, v107, 1, *((unsigned int *)this + 165));
            v121 = *((unsigned int *)this + 165);
            if ((_DWORD)v121)
            {
              do
              {
                if (*v110 == 0.0)
                  v122 = 0.0;
                else
                  v122 = *v107 / *v110;
                *v111++ = v122;
                ++v107;
                ++v110;
                --v121;
              }
              while (v121);
              v123 = *((unsigned int *)this + 165);
              v124 = (float *)*((_QWORD *)this + 170);
              v125 = v170;
              if ((_DWORD)v123)
              {
                for (i = 0; i != v123; ++i)
                  v124[i] = (float)((float)(1.0 / (float)((float)(0.5 / *(float *)(v106 + i * 4)) + 1.0)) * 0.899) + 0.1;
              }
              else
              {
                v123 = 0;
              }
            }
            else
            {
              v123 = 0;
              v124 = (float *)*((_QWORD *)this + 170);
              v125 = v170;
            }
            v127 = (float *)*((_QWORD *)this + 173);
            LODWORD(__A.realp) = *((_DWORD *)this + 138);
            vDSP_vsmul(v124, 1, (const float *)&__A, v127, 1, v123);
            vDSP_vneg(v109, 1, v109, 1, *((unsigned int *)this + 165));
            LODWORD(__A.realp) = 1065353216;
            vDSP_vsadd(v104, 1, (const float *)&__A, v124, 1, *((unsigned int *)this + 165));
            v128 = *((unsigned int *)this + 165);
            if ((_DWORD)v128)
            {
              v129 = v108;
              v130 = *((unsigned int *)this + 165);
              do
              {
                v131 = *v127++;
                v132 = (float)(1.0 - v131) / v131;
                if (v131 == 0.0)
                  v133 = 1.0e20;
                else
                  v133 = v132;
                v134 = *v124++;
                v135 = v133 * v134;
                v136 = *v109++;
                v137 = (float)(v135 * expf(v136)) + 1.0;
                if (v137 == 0.0)
                  v138 = 1.0;
                else
                  v138 = 1.0 / v137;
                *v129++ = v138;
                --v130;
              }
              while (v130);
            }
            else
            {
              v128 = 0;
            }
            __C = 0.0;
            LODWORD(__A.realp) = 1065353216;
            vDSP_vclip(v108, 1, &__C, (const float *)&__A, v108, 1, v128);
            v176 = 1.0;
            __B = v95;
            v139 = (void *)*((_QWORD *)this + 97);
            v140 = (float *)*((_QWORD *)this + 100);
            vDSP_vclip(v140, 1, &__B, &v176, v140, 1, *((unsigned int *)this + 165));
            v141 = (float *)*((_QWORD *)this + 100);
            LODWORD(__A.realp) = 1048576000;
            __C = 0.5;
            v142 = (float *)*((_QWORD *)this + 167);
            v143 = (float *)*((_QWORD *)this + 170);
            *v142 = 0.0;
            *v143 = 0.0;
            vDSP_vsmul(v141 + 1, 1, (const float *)&__A, v143 + 1, 1, (*((_DWORD *)this + 165) - 1));
            memcpy(v142, v143, 4 * *((unsigned int *)this + 165));
            vDSP_vadd(v142, 1, v143 + 1, 1, v142, 1, (*((_DWORD *)this + 165) - 1));
            vDSP_vsmul(v141, 1, &__C, v143, 1, *((unsigned int *)this + 165));
            vDSP_vadd(v142, 1, v143, 1, v142, 1, *((unsigned int *)this + 165));
            *v142 = (float)(*v141 + v141[1]) * 0.5;
            v144 = *((unsigned int *)this + 165);
            v142[(v144 - 1)] = (float)(v141[(v144 - 1)] + v141[(v144 - 2)])
                                           * 0.5;
            memcpy(v141, v142, 4 * v144);
            memcpy(v139, v140, 4 * *((unsigned int *)this + 165));
            LODWORD(__A.realp) = 0;
            if (*((_BYTE *)this + 532))
            {
              v145 = *((_DWORD *)this + 165);
              if (v145)
              {
                v146 = (float *)*((_QWORD *)this + 112);
                v147 = (float *)*((_QWORD *)this + 91);
                v148 = (float *)*((_QWORD *)this + 118);
                v149 = *((unsigned int *)this + 165);
                do
                {
                  v150 = *v146++;
                  v151 = v150;
                  v152 = *v147++;
                  v153 = v151 / (v152 + 1.0e-20);
                  if (v153 > 1.0)
                    v153 = 1.0;
                  *v148++ = sqrtf(v153);
                  --v149;
                }
                while (v149);
              }
              v154 = v169;
            }
            else
            {
              vDSP_vfill((const float *)&__A, *((float **)this + 118), 1, *((unsigned int *)this + 165));
              v145 = *((_DWORD *)this + 165);
              v154 = v169;
              if (!*((_BYTE *)this + 532))
                goto LABEL_132;
            }
            vDSP_vmax((const float *)v139, 1, *((const float **)this + 118), 1, (float *)v139, 1, v145);
            v145 = *((_DWORD *)this + 165);
LABEL_132:
            v155 = (float *)*((_QWORD *)this + 94);
            v156 = (const float *)*((_QWORD *)this + 91);
            v157 = (float *)*((_QWORD *)this + 164);
            __C = 0.8;
            v173 = 0.2;
            vDSP_vmul((const float *)v139, 1, (const float *)v139, 1, v157, 1, v145);
            vDSP_vmul(v157, 1, v156, 1, v157, 1, *((unsigned int *)this + 165));
            vDSP_vsmul(v157, 1, &__C, v157, 1, *((unsigned int *)this + 165));
            vDSP_vsmul(v155, 1, &v173, v155, 1, *((unsigned int *)this + 165));
            vDSP_vadd(v155, 1, v157, 1, v155, 1, *((unsigned int *)this + 165));
            vDSP_vmul(v156, 1, (const float *)v139, 1, v157, 1, *((unsigned int *)this + 165));
            vDSP_vmul(v157, 1, (const float *)v139, 1, v157, 1, *((unsigned int *)this + 165));
            v158 = *((unsigned int *)this + 165);
            LODWORD(__A.realp) = 0;
            if ((_DWORD)v158)
            {
              vDSP_sve(v157, 1, (float *)&__A, v158);
              v159 = (float)(*(float *)&__A.realp / (float)v158) + 1.0e-20;
            }
            else
            {
              v159 = 1.0e-20;
            }
            v160 = log10f(v159) * 10.0;
            *((float *)this + 277) = v160;
            v161 = v160;
            if (!*((_BYTE *)this + 1100))
              v161 = (float)(v160 * 0.8) + (float)(*((float *)this + 278) * 0.2);
            *((float *)this + 278) = v161;
            __C = 1.0;
            v162 = *((float *)this + 156);
            if (v160 >= (float)(v162 + -10.0))
            {
              if (v161 >= (float)(v162 + -5.0))
              {
                if (v161 >= v162)
                {
LABEL_144:
                  vDSP_vsmul((const float *)v139, 1, &__C, (float *)v139, 1, *((unsigned int *)this + 165));
                  if (*((_BYTE *)this + 532))
                    vDSP_vmax((const float *)v139, 1, *((const float **)this + 118), 1, (float *)v139, 1, *((unsigned int *)this + 165));
                  v164 = (float *)*((_QWORD *)this + 103);
                  if (*((_BYTE *)this + 1100))
                  {
                    memcpy(*((void **)this + 103), v139, 4 * *((unsigned int *)this + 165));
                  }
                  else
                  {
                    __C = 0.1;
                    vDSP_vsmul(v164, 1, &__C, v164, 1, *((unsigned int *)this + 165));
                    __C = 0.9;
                    vDSP_vsmul((const float *)v139, 1, &__C, (float *)v139, 1, *((unsigned int *)this + 165));
                    vDSP_vadd((const float *)v139, 1, v164, 1, v164, 1, *((unsigned int *)this + 165));
                  }
                  __B = 0.0;
                  vDSP_vclip(*((const float **)this + 97), 1, &__B, &v176, *((float **)this + 97), 1, *((unsigned int *)this + 165));
                  v165 = (const float *)*((_QWORD *)this + 97);
                  v166 = *((unsigned int *)this + 162);
                  v167 = &v154[v166];
                  v168 = &v125[v166];
                  vDSP_vmul(v154, 1, v165, 1, v125, 1, v166);
                  vDSP_vmul(v167 + 1, 1, v165 + 1, 1, v168 + 1, 1, (v166 - 1));
                  *v168 = *v167 * v165[v166];
                  *((_BYTE *)this + 1100) = 0;
                  std::vector<float>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>((char *)this + 848, *((char **)this + 97), *((_QWORD *)this + 98), (uint64_t)(*((_QWORD *)this + 98) - *((_QWORD *)this + 97)) >> 2);
                  *((_DWORD *)this + 276) = *((_DWORD *)this + 277);
                  memcpy(*((void **)this + 143), *((const void **)this + 140), 4 * *((unsigned int *)this + 165));
                  v17 = (void *)*((_QWORD *)this + 91);
                  v16 = (void *)*((_QWORD *)this + 94);
                  v15 = 4 * *((unsigned int *)this + 165);
                  goto LABEL_150;
                }
                v163 = 0.0065;
              }
              else
              {
                v163 = 0.0045;
              }
            }
            else
            {
              v163 = 0.0025;
            }
            __C = v163;
            goto LABEL_144;
          }
          if (v101 > (float)(v102 + -14.0))
          {
LABEL_88:
            v95 = 0.031623;
            goto LABEL_92;
          }
        }
        else if (!v92)
        {
          v93 = *((float *)this + 172);
          v94 = *((float *)this + 154);
          if (v93 > (float)(v94 + 6.0))
          {
            v95 = 0.50119;
            goto LABEL_92;
          }
          if (v93 > v94)
          {
            v95 = 0.31623;
            goto LABEL_92;
          }
          if (v93 > (float)(v94 + -6.0))
          {
            v95 = 0.1;
            goto LABEL_92;
          }
          if (v93 > (float)(v94 + -12.0))
            goto LABEL_88;
          if (v93 > (float)(v94 + -20.0))
          {
            v95 = 0.01;
            goto LABEL_92;
          }
        }
        v95 = 0.0031623;
        goto LABEL_92;
      }
      v28 = (void *)*((_QWORD *)this + 140);
      v29 = (const void *)*((_QWORD *)this + 71);
    }
    memcpy(v28, v29, 4 * *((unsigned int *)this + 165));
    goto LABEL_22;
  }
  v15 = *((unsigned int *)this + 173);
  v16 = (*a7)->mBuffers[0].mData;
  v17 = (*a5)->mBuffers[0].mData;
LABEL_150:
  memcpy(v16, v17, v15);
  return 0;
}

uint64_t AULevelDrivenSuppressor::Render(AULevelDrivenSuppressor *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  uint64_t Element;
  ausdk::AUInputElement *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t BufferList;
  ausdk::AUInputElement *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  _QWORD v18[3];

  v18[2] = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 84) != (_DWORD)a4)
    return 4294956422;
  Element = ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 128), 0);
  if (!ausdk::AUBase::HasInput(this, 0))
    return 4294956420;
  v9 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 80), 0);
  v10 = ausdk::AUInputElement::PullInput(v9, a2, a3, 0, a4);
  if (!(_DWORD)v10)
  {
    v11 = ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 80), 0);
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v11 + 144));
    if (!ausdk::AUBase::HasInput(this, 1u))
    {
      v15 = 0;
LABEL_10:
      v18[0] = BufferList;
      v18[1] = v15;
      v17 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
      return (*(uint64_t (**)(AULevelDrivenSuppressor *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, uint64_t *))(*(_QWORD *)this + 184))(this, a2, a4, 2, v18, 1, &v17);
    }
    v13 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 80), 1u);
    v10 = ausdk::AUInputElement::PullInput(v13, a2, a3, 1, a4);
    v14 = ausdk::AUScope::SafeGetElement((AULevelDrivenSuppressor *)((char *)this + 80), 1u);
    v15 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v14 + 144));
    if (!(_DWORD)v10)
      goto LABEL_10;
  }
  return v10;
}

BOOL AULevelDrivenSuppressor::BusCountWritable(AULevelDrivenSuppressor *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AULevelDrivenSuppressor::GetParameterList(AULevelDrivenSuppressor *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;

  if (a2)
    return 4294956430;
  if (a3)
  {
    *(_OWORD *)a3 = xmmword_1B6626920;
    a3[4] = 4;
  }
  result = 0;
  *a4 = 5;
  return result;
}

uint64_t AULevelDrivenSuppressor::GetParameterInfo(AULevelDrivenSuppressor *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v6;
  AudioUnitParameterUnit v7;
  AudioUnitParameterValue v8;
  AudioUnitParameterValue v9;
  AudioUnitParameterValue v10;

  buffer->flags = 0x40000000;
  buffer->unitName = 0;
  result = 4294956418;
  if (!a2 && a3 <= 4)
  {
    v6 = off_1E69C7B08[a3];
    v7 = dword_1B6630128[a3];
    v8 = flt_1B663013C[a3];
    v9 = flt_1B6630150[a3];
    v10 = flt_1B6630164[a3];
    buffer->cfNameString = v6;
    buffer->flags = 1207959552;
    CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
    result = 0;
    buffer->unit = v7;
    buffer->minValue = v8;
    buffer->maxValue = v9;
    buffer->defaultValue = v10;
    buffer->flags |= 0x80000000;
  }
  return result;
}

uint64_t AULevelDrivenSuppressor::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
  {
    ++*((_DWORD *)this + 134);
    ++*((_DWORD *)this + 136);
  }
  return result;
}

double AULevelDrivenSuppressor::GetLatency(AULevelDrivenSuppressor *this)
{
  return 0.0;
}

double AULevelDrivenSuppressor::GetTailTime(AULevelDrivenSuppressor *this)
{
  return 0.0;
}

uint64_t AULevelDrivenSuppressor::SupportsTail(AULevelDrivenSuppressor *this)
{
  return 1;
}

BOOL AULevelDrivenSuppressor::StreamFormatWritable(AULevelDrivenSuppressor *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AULevelDrivenSuppressor::SupportedNumChannels(AULevelDrivenSuppressor *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AULevelDrivenSuppressor::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

BOOL AULevelDrivenSuppressor::ValidFormat(AULevelDrivenSuppressor *this, const AudioStreamBasicDescription *a2, int a3, AudioStreamBasicDescription *a4)
{
  _BOOL8 result;

  if ((_DWORD)a2 != 1)
  {
    if ((_DWORD)a2 != 2 || a3)
      goto LABEL_17;
LABEL_12:
    if (a4->mBytesPerFrame != 8 || a4->mFormatID != 1718773105)
      return 0;
    return a4->mChannelsPerFrame == 1;
  }
  if (!a3)
    goto LABEL_12;
  if (a3 == 1)
  {
    if (a4->mBytesPerFrame != 4 || a4->mFormatID != 1819304813)
      return 0;
    return a4->mChannelsPerFrame == 1;
  }
LABEL_17:
  result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if (!(_DWORD)result)
    return result;
  if ((a4->mFormatFlags & 0x20) == 0)
    return a4->mChannelsPerFrame == 1;
  return 1;
}

float AULevelDrivenSuppressor::InitializeInternals(AULevelDrivenSuppressor *this)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  unsigned int Parameter;
  uint64_t v6;
  ausdk::AUElement *v7;
  ausdk::AUElement **v8;
  float v9;
  int v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  float v14;
  int v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  float v19;
  int v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  float result;

  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v4 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  Parameter = ausdk::AUElement::GetParameter(v3, 0);
  if (Parameter >= 2)
    Parameter = 2;
  *((_DWORD *)this + 132) = Parameter;
  v6 = *((_QWORD *)this + 9);
  if (v6)
  {
    v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
  }
  else
  {
    v8 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v8)
      v7 = 0;
    else
      v7 = *v8;
  }
  v9 = ausdk::AUElement::GetParameter(v7, 1u);
  *((float *)this + 154) = v9;
  v10 = 0;
  if (v9 > 0.0 || (v10 = -1024458752, v9 < -120.0))
  {
    *((_DWORD *)this + 154) = v10;
    v9 = *(float *)&v10;
  }
  *((float *)this + 158) = __exp10f(v9 * 0.1);
  v11 = *((_QWORD *)this + 9);
  if (v11)
  {
    v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
  }
  else
  {
    v13 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v13)
      v12 = 0;
    else
      v12 = *v13;
  }
  v14 = ausdk::AUElement::GetParameter(v12, 2u);
  *((float *)this + 155) = v14;
  v15 = 0;
  if (v14 > 0.0 || (v15 = -1018691584, v14 < -200.0))
  {
    *((_DWORD *)this + 155) = v15;
    v14 = *(float *)&v15;
  }
  *((float *)this + 160) = __exp10f(v14 * 0.1);
  v16 = *((_QWORD *)this + 9);
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  v19 = ausdk::AUElement::GetParameter(v17, 3u);
  *((float *)this + 156) = v19;
  v20 = 0;
  if (v19 > 0.0 || (v20 = -1024458752, v19 < -120.0))
    *((_DWORD *)this + 156) = v20;
  v21 = *((_QWORD *)this + 9);
  if (v21)
  {
    v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
  }
  else
  {
    v23 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v23)
      v22 = 0;
    else
      v22 = *v23;
  }
  *((_BYTE *)this + 532) = ausdk::AUElement::GetParameter(v22, 4u) != 0;
  *((float *)this + 157) = *((float *)this + 154) + *((float *)this + 155);
  result = *((float *)this + 158) * 0.25;
  *((float *)this + 159) = result;
  return result;
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned int>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, 4 * v15);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

os_log_t ___ZL14AUlsupLogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "aulsup");
  *v0 = result;
  AUlsupLogScope(void)::scope = (uint64_t)v0;
  return result;
}

void VoiceProcessorV2::VPAUProcessingBlock::~VPAUProcessingBlock(VoiceProcessorV2::VPAUProcessingBlock *this)
{
  AUProcessingBlockBase::~AUProcessingBlockBase(this);
  JUMPOUT(0x1BCC95CECLL);
}

OpaqueAudioComponent *VoiceProcessorV2::VPAUProcessingBlock::GetAvailableAUs(uint64_t a1, uint64_t a2)
{
  OpaqueAudioComponent *v3;
  OpaqueAudioComponent *Next;
  OSType componentSubType;
  OSType componentType;
  OSType componentManufacturer;
  unint64_t v8;
  OSType *v9;
  _DWORD *v10;
  OSType *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  OSType *v17;
  OSType *v18;
  uint64_t v19;
  OSType v20;
  OpaqueAudioComponent *result;
  OSType v22;
  int v23;
  OSType v24;
  OSType v25;
  unint64_t v26;
  OSType *v27;
  _DWORD *v28;
  OSType *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  OSType *v35;
  OSType *v36;
  uint64_t v37;
  OSType v38;
  AudioComponentDescription outDesc;
  AudioComponentDescription inDesc;

  v3 = 0;
  inDesc.componentFlagsMask = 0;
  *(_OWORD *)&inDesc.componentType = *(_OWORD *)"xaua";
  while (1)
  {
    Next = AudioComponentFindNext(v3, &inDesc);
    v3 = Next;
    if (!Next)
      break;
    AudioComponentGetDescription(Next, &outDesc);
    componentType = outDesc.componentType;
    componentSubType = outDesc.componentSubType;
    componentManufacturer = outDesc.componentManufacturer;
    v9 = *(OSType **)(a2 + 8);
    v8 = *(_QWORD *)(a2 + 16);
    if ((unint64_t)v9 >= v8)
    {
      v11 = *(OSType **)a2;
      v12 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - *(_QWORD *)a2) >> 2);
      v13 = v12 + 1;
      if (v12 + 1 > 0x1555555555555555)
LABEL_82:
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - (_QWORD)v11) >> 2);
      if (2 * v14 > v13)
        v13 = 2 * v14;
      if (v14 >= 0xAAAAAAAAAAAAAAALL)
        v15 = 0x1555555555555555;
      else
        v15 = v13;
      if (v15)
      {
        v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AudioClassDescription>>(v15);
        v11 = *(OSType **)a2;
        v9 = *(OSType **)(a2 + 8);
      }
      else
      {
        v16 = 0;
      }
      v17 = (OSType *)(v15 + 12 * v12);
      *v17 = componentType;
      v17[1] = componentSubType;
      v17[2] = componentManufacturer;
      v18 = v17;
      if (v9 != v11)
      {
        do
        {
          v19 = *(_QWORD *)(v9 - 3);
          v9 -= 3;
          v20 = v9[2];
          *(_QWORD *)(v18 - 3) = v19;
          v18 -= 3;
          v18[2] = v20;
        }
        while (v9 != v11);
        v11 = *(OSType **)a2;
      }
      v10 = v17 + 3;
      *(_QWORD *)a2 = v18;
      *(_QWORD *)(a2 + 8) = v17 + 3;
      *(_QWORD *)(a2 + 16) = v15 + 12 * v16;
      if (v11)
        operator delete(v11);
    }
    else
    {
      *v9 = outDesc.componentType;
      v9[1] = componentSubType;
      v10 = v9 + 3;
      v9[2] = componentManufacturer;
    }
    *(_QWORD *)(a2 + 8) = v10;
  }
  *(_QWORD *)&inDesc.componentFlags = 0;
  *(_QWORD *)&inDesc.componentSubType = 0;
  inDesc.componentType = 1635083896;
  while (1)
  {
    result = AudioComponentFindNext(v3, &inDesc);
    if (!result)
      return result;
    v3 = result;
    AudioComponentGetDescription(result, &outDesc);
    v22 = outDesc.componentSubType;
    if ((int)outDesc.componentSubType <= 1836280881)
    {
      if ((int)outDesc.componentSubType > 1684366706)
      {
        if ((int)outDesc.componentSubType > 1818583858)
        {
          if ((int)outDesc.componentSubType > 1835298865)
          {
            if (outDesc.componentSubType == 1835298866)
              goto LABEL_64;
            v23 = 1835954996;
          }
          else
          {
            if (outDesc.componentSubType == 1818583859)
              goto LABEL_64;
            v23 = 1835298419;
          }
        }
        else if ((int)outDesc.componentSubType > 1701278770)
        {
          if (outDesc.componentSubType == 1701278771)
            goto LABEL_64;
          v23 = 1718186598;
        }
        else
        {
          if (outDesc.componentSubType == 1684366707)
            goto LABEL_64;
          v23 = 1685677163;
        }
        goto LABEL_63;
      }
      if ((int)outDesc.componentSubType > 1651338853)
      {
        if ((int)outDesc.componentSubType > 1651866218)
        {
          if (outDesc.componentSubType == 1651866219)
            goto LABEL_64;
          v23 = 1668179822;
        }
        else
        {
          if (outDesc.componentSubType == 1651338854)
            goto LABEL_64;
          v23 = 1651402355;
        }
        goto LABEL_63;
      }
      if (outDesc.componentSubType != 1634165554 && outDesc.componentSubType != 1635284067)
      {
        v23 = 1651323502;
        goto LABEL_63;
      }
      goto LABEL_64;
    }
    if ((int)outDesc.componentSubType > 1936089963)
    {
      if ((int)outDesc.componentSubType > 1953330035)
      {
        if ((int)outDesc.componentSubType > 1986159981)
        {
          if (outDesc.componentSubType == 1987211570)
            goto LABEL_64;
          v23 = 1986159982;
        }
        else
        {
          if (outDesc.componentSubType == 1953330036)
            goto LABEL_64;
          v23 = 1953790309;
        }
        goto LABEL_63;
      }
      if (outDesc.componentSubType - 1936748594 < 2 || outDesc.componentSubType == 1936089964)
        goto LABEL_64;
      v23 = 1936745838;
LABEL_63:
      if (outDesc.componentSubType == v23)
        goto LABEL_64;
    }
    else
    {
      if ((int)outDesc.componentSubType <= 1868787314)
      {
        if ((int)outDesc.componentSubType > 1851942256)
        {
          if (outDesc.componentSubType == 1851942257)
            goto LABEL_64;
          v23 = 1868787301;
        }
        else
        {
          if (outDesc.componentSubType == 1836280882)
            goto LABEL_64;
          v23 = 1836282987;
        }
        goto LABEL_63;
      }
      if (outDesc.componentSubType - 1919251251 >= 2 && outDesc.componentSubType != 1868787315)
      {
        v23 = 1869509428;
        goto LABEL_63;
      }
LABEL_64:
      v24 = outDesc.componentType;
      v25 = outDesc.componentManufacturer;
      v27 = *(OSType **)(a2 + 8);
      v26 = *(_QWORD *)(a2 + 16);
      if ((unint64_t)v27 >= v26)
      {
        v29 = *(OSType **)a2;
        v30 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v27 - *(_QWORD *)a2) >> 2);
        v31 = v30 + 1;
        if (v30 + 1 > 0x1555555555555555)
          goto LABEL_82;
        v32 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - (_QWORD)v29) >> 2);
        if (2 * v32 > v31)
          v31 = 2 * v32;
        if (v32 >= 0xAAAAAAAAAAAAAAALL)
          v33 = 0x1555555555555555;
        else
          v33 = v31;
        if (v33)
        {
          v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AudioClassDescription>>(v33);
          v29 = *(OSType **)a2;
          v27 = *(OSType **)(a2 + 8);
        }
        else
        {
          v34 = 0;
        }
        v35 = (OSType *)(v33 + 12 * v30);
        *v35 = v24;
        v35[1] = v22;
        v35[2] = v25;
        v36 = v35;
        if (v27 != v29)
        {
          do
          {
            v37 = *(_QWORD *)(v27 - 3);
            v27 -= 3;
            v38 = v27[2];
            *(_QWORD *)(v36 - 3) = v37;
            v36 -= 3;
            v36[2] = v38;
          }
          while (v27 != v29);
          v29 = *(OSType **)a2;
        }
        v28 = v35 + 3;
        *(_QWORD *)a2 = v36;
        *(_QWORD *)(a2 + 8) = v35 + 3;
        *(_QWORD *)(a2 + 16) = v33 + 12 * v34;
        if (v29)
          operator delete(v29);
      }
      else
      {
        *v27 = outDesc.componentType;
        v27[1] = v22;
        v28 = v27 + 3;
        v27[2] = v25;
      }
      *(_QWORD *)(a2 + 8) = v28;
    }
  }
}

uint64_t AUProcessingBlock_AU::AUGetPropertyInfo(int a1, AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, UInt32 *outDataSize, Boolean *outWritable)
{
  return AudioUnitGetPropertyInfo(inUnit, inID, inScope, inElement, outDataSize, outWritable);
}

uint64_t AUProcessingBlock_AU::AUGetProperty(int a1, AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void *outData, UInt32 *ioDataSize)
{
  return AudioUnitGetProperty(inUnit, inID, inScope, inElement, outData, ioDataSize);
}

uint64_t AUProcessingBlock_AU::AUSetProperty(int a1, AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void *inData, UInt32 inDataSize)
{
  return AudioUnitSetProperty(inUnit, inID, inScope, inElement, inData, inDataSize);
}

uint64_t AUProcessingBlock_AU::AUGetParameter(int a1, AudioUnit inUnit, AudioUnitParameterID inID, AudioUnitScope inScope, AudioUnitElement inElement, AudioUnitParameterValue *outValue)
{
  return AudioUnitGetParameter(inUnit, inID, inScope, inElement, outValue);
}

uint64_t AUProcessingBlock_AU::AUSetParameter(int a1, AudioUnit inUnit, AudioUnitParameterID inID, AudioUnitScope inScope, AudioUnitElement inElement, AudioUnitParameterValue a6)
{
  return AudioUnitSetParameter(inUnit, inID, inScope, inElement, a6, 0);
}

AUProcessingBlockBase *VoiceProcessorV2::VPAUProcessingBlock::RemoveAUAtIndex(AUProcessingBlockBase *this, unsigned int a2)
{
  AUProcessingBlockBase *v2;

  if (*(_QWORD *)(*((_QWORD *)this + 3) + 24 * a2 + 16))
  {
    v2 = this;
    AUPBUnregisterAU();
    AUProcessingBlockBase::RemoveAUAtIndex(v2);
    return (AUProcessingBlockBase *)AUPBPropertiesChanged();
  }
  return this;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<AudioClassDescription>>(unint64_t a1)
{
  if (a1 >= 0x1555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(12 * a1);
}

unint64_t VoiceProcessorV2::VPAUProcessingBlock::FindIndex(const AUPBUnit *this, const AUPBUnit *a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v5;
  unint64_t result;
  unint64_t v7;
  _DWORD *v8;

  v3 = a2 - this;
  if (a2 == this)
    return 0xFFFFFFFFLL;
  v5 = 0;
  result = 0;
  v7 = 0xAAAAAAAAAAAAAAABLL * (v3 >> 3);
  while (1)
  {
    v8 = (_DWORD *)((char *)this + 24 * v5);
    if (*v8 == *(_DWORD *)a3
      && v8[1] == *(_DWORD *)(a3 + 4)
      && v8[2] == *(_DWORD *)(a3 + 8)
      && *((_QWORD *)this + 3 * v5 + 2) == *(_QWORD *)(a3 + 16))
    {
      break;
    }
    v5 = (result + 1);
    result = v5;
    if (v7 <= v5)
      return 0xFFFFFFFFLL;
  }
  return result;
}

BOOL VoiceProcessorV2::AUIsInDownLinkProcessingChain(VoiceProcessorV2 *this, const AUPBUnit *a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t *v10;
  unsigned int v11;
  BOOL v12;
  uint64_t *v13;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  BOOL v20;
  const AUPBUnit *v21;
  int v22;
  int v23;
  VoiceProcessorV2 *v24;
  uint64_t __dst[56];

  __dst[55] = *MEMORY[0x1E0C80C00];
  if ((v2 & 1) == 0)
  {
    v24 = this;
    v21 = a2;
    a2 = v21;
    v23 = v22;
    this = v24;
    if (v23)
    {
      memcpy(__dst, "2qrv\b", 0x1B8uLL);
      std::multimap<unsigned int,unsigned int>::multimap[abi:ne180100](__dst, 55);
      __cxa_atexit((void (*)(void *))std::multimap<unsigned int,unsigned int>::~multimap[abi:ne180100], &VoiceProcessorV2::AUIsInDownLinkProcessingChain(AUPBUnit const&)::downlinkProcessingDB, &dword_1B5ED0000);
      this = v24;
      a2 = v21;
    }
  }
  v3 = qword_1EF134DD0;
  if (!qword_1EF134DD0)
  {
LABEL_9:
    v7 = *((_QWORD *)a2 + 2);
    return v7 == *((_QWORD *)this + 1551);
  }
  v4 = *((_DWORD *)a2 + 1);
  v5 = &qword_1EF134DD0;
  while (1)
  {
    v6 = *(_DWORD *)(v3 + 28);
    if (v4 >= v6)
      break;
    v5 = (uint64_t *)v3;
LABEL_8:
    v3 = *(_QWORD *)v3;
    if (!v3)
      goto LABEL_9;
  }
  if (v6 < v4)
  {
    v3 += 8;
    goto LABEL_8;
  }
  v9 = *(_QWORD *)v3;
  v10 = (uint64_t *)v3;
  if (*(_QWORD *)v3)
  {
    v10 = (uint64_t *)v3;
    do
    {
      v11 = *(_DWORD *)(v9 + 28);
      v12 = v11 >= v4;
      if (v11 >= v4)
        v13 = (uint64_t *)v9;
      else
        v13 = (uint64_t *)(v9 + 8);
      if (v12)
        v10 = (uint64_t *)v9;
      v9 = *v13;
    }
    while (*v13);
  }
  v14 = *(_QWORD *)(v3 + 8);
  if (v14)
  {
    do
    {
      v15 = *(_DWORD *)(v14 + 28);
      v16 = v4 >= v15;
      if (v4 >= v15)
        v17 = (uint64_t *)(v14 + 8);
      else
        v17 = (uint64_t *)v14;
      if (!v16)
        v5 = (uint64_t *)v14;
      v14 = *v17;
    }
    while (*v17);
  }
  v7 = *((_QWORD *)a2 + 2);
  if (v10 == v5)
    return v7 == *((_QWORD *)this + 1551);
  while (v7 != *((_QWORD *)this + *((unsigned int *)v10 + 8) + 437))
  {
    v18 = (uint64_t *)v10[1];
    if (v18)
    {
      do
      {
        v19 = v18;
        v18 = (uint64_t *)*v18;
      }
      while (v18);
    }
    else
    {
      do
      {
        v19 = (uint64_t *)v10[2];
        v20 = *v19 == (_QWORD)v10;
        v10 = v19;
      }
      while (!v20);
    }
    v10 = v19;
    if (v19 == v5)
      return v7 == *((_QWORD *)this + 1551);
  }
  return 1;
}

void sub_1B6124A10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *std::multimap<unsigned int,unsigned int>::multimap[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  BOOL v10;
  uint64_t *v11;
  uint64_t **v12;

  qword_1EF134DD8 = 0;
  qword_1EF134DD0 = 0;
  VoiceProcessorV2::AUIsInDownLinkProcessingChain(AUPBUnit const&)::downlinkProcessingDB = (uint64_t)&qword_1EF134DD0;
  if (a2)
  {
    v2 = result;
    v3 = &result[a2];
    do
    {
      v4 = (uint64_t *)operator new(0x28uLL);
      v5 = *v2;
      *(uint64_t *)((char *)v4 + 28) = *v2;
      v7 = &qword_1EF134DD0;
      v6 = qword_1EF134DD0;
      if ((uint64_t *)VoiceProcessorV2::AUIsInDownLinkProcessingChain(AUPBUnit const&)::downlinkProcessingDB == &qword_1EF134DD0)
        goto LABEL_16;
      v8 = qword_1EF134DD0;
      if (qword_1EF134DD0)
      {
        do
        {
          v7 = (uint64_t *)v8;
          v8 = *(_QWORD *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        v9 = &qword_1EF134DD0;
        do
        {
          v7 = (uint64_t *)v9[2];
          v10 = *v7 == (_QWORD)v9;
          v9 = v7;
        }
        while (v10);
      }
      if (*((_DWORD *)v7 + 7) <= v5)
      {
LABEL_16:
        if (qword_1EF134DD0)
          v11 = v7;
        else
          v11 = &qword_1EF134DD0;
        if (qword_1EF134DD0)
          v12 = (uint64_t **)(v7 + 1);
        else
          v12 = (uint64_t **)&qword_1EF134DD0;
      }
      else if (qword_1EF134DD0)
      {
        do
        {
          while (1)
          {
            v11 = (uint64_t *)v6;
            if (*(_DWORD *)(v6 + 28) <= v5)
              break;
            v6 = *(_QWORD *)v6;
            v12 = (uint64_t **)v11;
            if (!*v11)
              goto LABEL_22;
          }
          v6 = *(_QWORD *)(v6 + 8);
        }
        while (v6);
        v12 = (uint64_t **)(v11 + 1);
      }
      else
      {
        v11 = &qword_1EF134DD0;
        v12 = (uint64_t **)&qword_1EF134DD0;
      }
LABEL_22:
      result = std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at((uint64_t **)&VoiceProcessorV2::AUIsInDownLinkProcessingChain(AUPBUnit const&)::downlinkProcessingDB, (uint64_t)v11, v12, v4);
      ++v2;
    }
    while (v2 != v3);
  }
  return result;
}

void sub_1B6124B4C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy((_QWORD *)qword_1EF134DD0);
  _Unwind_Resume(a1);
}

uint64_t std::multimap<unsigned int,unsigned int>::~multimap[abi:ne180100](uint64_t a1)
{
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*(_QWORD **)(a1 + 8));
  return a1;
}

void std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

void VoiceProcessorV2::PListCopyDictionaryForWrite(VoiceProcessorV2 *this, __CFDictionary **a2)
{
  const __CFArray *v3;
  char *v5;
  int Count;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v8;
  void *v9;
  const __CFArray *Value;
  CFIndex v11;
  const __CFNumber *v12;
  CFTypeRef v13;
  const __CFArray *v14;
  CFIndex v15;
  const __CFNumber *v16;
  const __CFArray *v17;
  CFIndex v18;
  const __CFNumber *v19;
  const __CFArray *v20;
  CFIndex v21;
  const __CFString *v22;
  CFStringEncoding SystemEncoding;
  const char *CStringPtr;
  size_t v25;
  size_t v26;
  CFTypeRef cf;
  int v28;
  int v29;
  int valuePtr;
  CFTypeRef v31;
  void *key[33];

  key[32] = *(void **)MEMORY[0x1E0C80C00];
  *a2 = 0;
  v3 = (const __CFArray *)*((_QWORD *)this + 1884);
  if (v3)
  {
    v5 = (char *)this + 12844;
    Count = CFArrayGetCount(v3);
    if (Count)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 1884), (Count - 1));
      v31 = 0;
      if (ValueAtIndex)
      {
        v8 = ValueAtIndex;
        valuePtr = 0;
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 3);
        v9 = key[0];
        v31 = key[0];
        Value = (const __CFArray *)CFDictionaryGetValue(v8, key[0]);
        v11 = CFArrayGetCount(Value);
        v12 = (const __CFNumber *)CFArrayGetValueAtIndex(Value, v11 - 1);
        CFNumberGetValue(v12, kCFNumberIntType, &valuePtr);
        if (valuePtr == *((_DWORD *)this + 3112))
        {
          v29 = 0;
          VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 2);
          v13 = key[0];
          v31 = key[0];
          key[0] = v9;
          if (v9)
            CFRelease(v9);
          v14 = (const __CFArray *)CFDictionaryGetValue(v8, v13);
          v15 = CFArrayGetCount(v14);
          v16 = (const __CFNumber *)CFArrayGetValueAtIndex(v14, v15 - 1);
          CFNumberGetValue(v16, kCFNumberIntType, &v29);
          if (v29 == *((_DWORD *)this + 3113))
          {
            v28 = 0;
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 17);
            v9 = key[0];
            v31 = key[0];
            key[0] = (void *)v13;
            if (v13)
              CFRelease(v13);
            v17 = (const __CFArray *)CFDictionaryGetValue(v8, v9);
            v18 = CFArrayGetCount(v17);
            v19 = (const __CFNumber *)CFArrayGetValueAtIndex(v17, v18 - 1);
            CFNumberGetValue(v19, kCFNumberIntType, &v28);
            if (v28 != *((_DWORD *)this + 3114))
              goto LABEL_17;
            snprintf((char *)key, 0x100uLL, "%s%d%02d%02d.%02d%02d%02d.%03u", "vp.", *((_DWORD *)this + 3210), *v5, *((char *)this + 12845), *((char *)this + 12846), *((char *)this + 12847), (int)*((double *)this + 1606), *((_DWORD *)this + 3214));
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 1);
            v13 = cf;
            v31 = cf;
            cf = v9;
            if (v9)
              CFRelease(v9);
            v20 = (const __CFArray *)CFDictionaryGetValue(v8, v13);
            v21 = CFArrayGetCount(v20);
            v22 = (const __CFString *)CFArrayGetValueAtIndex(v20, v21 - 1);
            SystemEncoding = CFStringGetSystemEncoding();
            CStringPtr = CFStringGetCStringPtr(v22, SystemEncoding);
            v25 = strlen(CStringPtr);
            if (!strncmp(CStringPtr, (const char *)key, v25))
            {
              *a2 = v8;
              CFRetain(v8);
LABEL_26:
              if (v13)
                CFRelease(v13);
              return;
            }
          }
          v9 = (void *)v13;
        }
      }
      else
      {
        v9 = 0;
      }
    }
    else
    {
      v9 = 0;
      v31 = 0;
    }
LABEL_17:
    *a2 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 3);
    WriteItemToDictionary(a2, (const void **)key, 1, 4uLL, (const char *)this + 12448);
    if (key[0])
      CFRelease(key[0]);
    VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 2);
    WriteItemToDictionary(a2, (const void **)key, 1, 4uLL, (const char *)this + 12452);
    if (key[0])
      CFRelease(key[0]);
    VPGetPropsPListStringForKey((applesauce::CF::StringRef *)key, 17);
    WriteItemToDictionary(a2, (const void **)key, 1, 4uLL, (const char *)this + 12456);
    if (key[0])
      CFRelease(key[0]);
    snprintf((char *)key, 0x100uLL, "%s%d%02d%02d.%02d%02d%02d.%03u", "vp.", *((_DWORD *)this + 3210), *v5, *((char *)this + 12845), *((char *)this + 12846), *((char *)this + 12847), (int)*((double *)this + 1606), *((_DWORD *)this + 3214));
    VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 1);
    v26 = strlen((const char *)key);
    WriteItemToDictionary(a2, &cf, 0, v26 + 1, (const char *)key);
    if (cf)
      CFRelease(cf);
    CFArrayAppendValue(*((CFMutableArrayRef *)this + 1884), *a2);
    v13 = v9;
    goto LABEL_26;
  }
}

void sub_1B6124FC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,int a22,__int16 a23,char a24,char a25)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteInitializeHwInputParameters(VoiceProcessorV2 *this)
{
  __CFDictionary *v2;
  const char *v3;
  size_t v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  CFTypeRef *v8;
  unint64_t v9;
  uint64_t v10;
  CFTypeRef *v11;
  __int128 v12;
  size_t v13;
  __int128 v14;
  size_t v15;
  std::runtime_error *exception;
  std::runtime_error *v17;
  CFTypeRef cf[2];
  __int128 v19;
  uint64_t v20;
  CFTypeRef v21;
  CFTypeRef v22;
  int v23;
  int valuePtr;
  __CFDictionary *v25;
  char __s[512];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 1884))
  {
    v25 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v25);
    v2 = v25;
    if (v25)
    {
      v3 = (char *)this + 32;
      if (*((char *)this + 55) < 0)
        v3 = *(const char **)v3;
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 0);
      v4 = strlen(v3);
      WriteItemToDictionary(&v25, cf, 0, v4 + 1, v3);
      if (cf[0])
        CFRelease(cf[0]);
      v5 = *((unsigned __int8 *)this + 60);
      if (*((_BYTE *)this + 60))
        v5 = *((_DWORD *)this + 14);
      valuePtr = v5;
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 64);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)&valuePtr);
      if (cf[0])
        CFRelease(cf[0]);
      v23 = *((_DWORD *)this + 16);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 77);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)&v23);
      if (cf[0])
        CFRelease(cf[0]);
      if (*((_QWORD *)this + 292) != *((_QWORD *)this + 293))
      {
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 6);
        WriteItemToDictionary(&v25, cf, 1, 4uLL, *((const char **)this + 292));
        if (cf[0])
          CFRelease(cf[0]);
        if (*((_QWORD *)this + 293) - *((_QWORD *)this + 292) >= 5uLL)
        {
          v6 = 1;
          v7 = 4;
          do
          {
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v21, 6);
            if (!v21)
            {
              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(exception, "Could not construct");
            }
            applesauce::CF::convert_to<std::string,0>((const __CFString *)v21, (uint64_t)cf);
            if ((SBYTE7(v19) & 0x80u) == 0)
              v8 = cf;
            else
              v8 = (CFTypeRef *)cf[0];
            applesauce::CF::make_StringRef(CFSTR("%s%lu"), (applesauce::CF::StringRef *)&v22, v8, v6);
            if (SBYTE7(v19) < 0)
              operator delete((void *)cf[0]);
            if (v21)
              CFRelease(v21);
            WriteItemToDictionary(&v25, &v22, 1, 4uLL, (const char *)(*((_QWORD *)this + 292) + v7));
            if (v22)
              CFRelease(v22);
            ++v6;
            v7 += 4;
          }
          while (v6 < (uint64_t)(*((_QWORD *)this + 293) - *((_QWORD *)this + 292)) >> 2);
        }
      }
      if (*((_QWORD *)this + 295) != *((_QWORD *)this + 296))
      {
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 9);
        WriteItemToDictionary(&v25, cf, 1, 4uLL, *((const char **)this + 295));
        if (cf[0])
          CFRelease(cf[0]);
        if (*((_QWORD *)this + 296) - *((_QWORD *)this + 295) >= 5uLL)
        {
          v9 = 1;
          v10 = 4;
          do
          {
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v21, 9);
            if (!v21)
            {
              v17 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v17, "Could not construct");
            }
            applesauce::CF::convert_to<std::string,0>((const __CFString *)v21, (uint64_t)cf);
            if ((SBYTE7(v19) & 0x80u) == 0)
              v11 = cf;
            else
              v11 = (CFTypeRef *)cf[0];
            applesauce::CF::make_StringRef(CFSTR("%s%lu"), (applesauce::CF::StringRef *)&v22, v11, v9);
            if (SBYTE7(v19) < 0)
              operator delete((void *)cf[0]);
            if (v21)
              CFRelease(v21);
            WriteItemToDictionary(&v25, &v22, 1, 4uLL, (const char *)(*((_QWORD *)this + 295) + v10));
            if (v22)
              CFRelease(v22);
            ++v9;
            v10 += 4;
          }
          while (v9 < (uint64_t)(*((_QWORD *)this + 296) - *((_QWORD *)this + 295)) >> 2);
        }
      }
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 35);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 2384);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 41);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 2388);
      if (cf[0])
        CFRelease(cf[0]);
      v12 = *(_OWORD *)((char *)this + 600);
      *(_OWORD *)cf = *(_OWORD *)((char *)this + 584);
      v19 = v12;
      v20 = *((_QWORD *)this + 77);
      ASBDToText((const CAStreamBasicDescription *)cf, __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 4);
      v13 = strlen(__s);
      WriteItemToDictionary(&v25, cf, 0, v13 + 1, __s);
      if (cf[0])
        CFRelease(cf[0]);
      v14 = *((_OWORD *)this + 40);
      *(_OWORD *)cf = *((_OWORD *)this + 39);
      v19 = v14;
      v20 = *((_QWORD *)this + 82);
      ASBDToText((const CAStreamBasicDescription *)cf, __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 7);
      v15 = strlen(__s);
      WriteItemToDictionary(&v25, cf, 0, v15 + 1, __s);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 5);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 492);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 8);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 496);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 42);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1148);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 43);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1152);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 10);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1168);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 11);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1164);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 12);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1176);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 13);
      WriteItemToDictionary(&v25, cf, 1, 4uLL, (const char *)this + 1172);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 39);
      WriteItemToDictionary(&v25, cf, 2, 4uLL, (const char *)this + 1156);
      if (cf[0])
        CFRelease(cf[0]);
      CFRelease(v2);
    }
  }
}

void sub_1B61256E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteInitializeOutputParameters(VoiceProcessorV2 *this)
{
  __CFDictionary *v2;
  __int128 v3;
  size_t v4;
  CFTypeRef cf[2];
  __int128 v6;
  uint64_t v7;
  __CFDictionary *v8;
  char __s[512];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 1884))
  {
    v8 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v8);
    v2 = v8;
    if (v8)
    {
      v3 = *(_OWORD *)((char *)this + 1000);
      *(_OWORD *)cf = *(_OWORD *)((char *)this + 984);
      v6 = v3;
      v7 = *((_QWORD *)this + 127);
      ASBDToText((const CAStreamBasicDescription *)cf, __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 14);
      v4 = strlen(__s);
      WriteItemToDictionary(&v8, cf, 0, v4 + 1, __s);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 42);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1148);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 43);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1152);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 10);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1168);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 11);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1164);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 12);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1176);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 13);
      WriteItemToDictionary(&v8, cf, 1, 4uLL, (const char *)this + 1172);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 39);
      WriteItemToDictionary(&v8, cf, 2, 4uLL, (const char *)this + 1156);
      if (cf[0])
        CFRelease(cf[0]);
      CFRelease(v2);
    }
  }
}

void sub_1B6125A24(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteInitializeDLPParameters(VoiceProcessorV2 *this)
{
  __CFDictionary *v2;
  size_t v3;
  size_t v4;
  __int128 v5;
  size_t v6;
  CFTypeRef cf[2];
  __int128 v8;
  uint64_t v9;
  __CFDictionary *v10;
  char __s[512];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 1884))
  {
    v10 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v10);
    v2 = v10;
    if (v10)
    {
      ASBDToText((VoiceProcessorV2 *)((char *)this + 328), __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 18);
      v3 = strlen(__s);
      WriteItemToDictionary(&v10, cf, 0, v3 + 1, __s);
      if (cf[0])
        CFRelease(cf[0]);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 19);
      WriteItemToDictionary(&v10, cf, 1, 4uLL, (const char *)this + 484);
      if (cf[0])
        CFRelease(cf[0]);
      ASBDToText((VoiceProcessorV2 *)((char *)this + 208), __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 20);
      v4 = strlen(__s);
      WriteItemToDictionary(&v10, cf, 0, v4 + 1, __s);
      if (cf[0])
        CFRelease(cf[0]);
      if (*((_DWORD *)this + 1127) == 1)
      {
        v9 = *((_QWORD *)this + 77);
        v5 = *(_OWORD *)((char *)this + 600);
        *(_OWORD *)cf = *(_OWORD *)((char *)this + 584);
        v8 = v5;
        ASBDToText((const CAStreamBasicDescription *)cf, __s);
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 4);
        v6 = strlen(__s);
        WriteItemToDictionary(&v10, cf, 0, v6 + 1, __s);
        if (cf[0])
          CFRelease(cf[0]);
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)cf, 5);
        WriteItemToDictionary(&v10, cf, 1, 4uLL, (const char *)this + 492);
        if (cf[0])
          CFRelease(cf[0]);
      }
      CFRelease(v2);
    }
  }
}

void sub_1B6125C50(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteInitializeSpkrTelParameters(VoiceProcessorV2 *this)
{
  __CFDictionary *v2;
  size_t v3;
  CFTypeRef cf;
  __CFDictionary *v5;
  char __s[512];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 1884))
  {
    v5 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v5);
    v2 = v5;
    if (v5)
    {
      ASBDToText((VoiceProcessorV2 *)((char *)this + 1488), __s);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 32);
      v3 = strlen(__s);
      WriteItemToDictionary(&v5, &cf, 0, v3 + 1, __s);
      if (cf)
        CFRelease(cf);
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 33);
      WriteItemToDictionary(&v5, &cf, 1, 4uLL, (const char *)this + 1528);
      if (cf)
        CFRelease(cf);
      CFRelease(v2);
    }
  }
}

void sub_1B6125D8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteSetPropertyParameters(VoiceProcessorV2 *this, int a2)
{
  CFTypeRef v4;
  const void **v5;
  const void **v6;
  CFDictionaryRef v7;
  uint64_t v8;
  const void *v9;
  const void *v10;
  const void **v11;
  CFDictionaryRef CFDictionaryRef;
  uint64_t v13;
  const void *v14;
  const void *v15;
  unsigned int v16;
  const void *v17;
  const void *v18;
  const void **v19;
  uint64_t v20;
  CFDictionaryRef v21;
  CFTypeRef cf;
  const void *valuePtr[2];
  _QWORD v24[3];

  v24[2] = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 1884))
  {
    cf = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, (__CFDictionary **)&cf);
    v4 = cf;
    if (cf)
    {
      if (a2 > 1635085676)
      {
        if (a2 > 1868653666)
        {
          if (a2 <= 1937141090)
          {
            switch(a2)
            {
              case 1868653667:
                applesauce::CF::NumberRef::NumberRef<unsigned int,void>((CFNumberRef *)&v18, *((_DWORD *)this + 4141));
                applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],applesauce::CF::NumberRef>((applesauce::CF::TypeRef *)valuePtr, &v18);
                if (*((_BYTE *)this + 16560))
                  v11 = (const void **)MEMORY[0x1E0C9AE50];
                else
                  v11 = (const void **)MEMORY[0x1E0C9AE40];
                v17 = *v11;
                applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[22],applesauce::CF::BooleanRef>((applesauce::CF::TypeRef *)v24, &v17);
                v19 = valuePtr;
                v20 = 2;
                CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v19);
                v13 = 0;
                v21 = CFDictionaryRef;
                do
                {
                  v14 = (const void *)v24[v13 + 1];
                  if (v14)
                    CFRelease(v14);
                  v15 = valuePtr[v13 + 2];
                  if (v15)
                    CFRelease(v15);
                  v13 -= 2;
                }
                while (v13 != -4);
                applesauce::CF::BooleanRef::~BooleanRef(&v17);
                applesauce::CF::NumberRef::~NumberRef(&v18);
                valuePtr[0] = CFDictionaryRef;
                VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v19, 75);
                WriteItemToDictionary((__CFDictionary **)&cf, (const void **)&v19, 4, 8uLL, (const char *)valuePtr);
                break;
              case 1936744803:
                LODWORD(v19) = *((unsigned __int8 *)this + 2245);
                VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 68);
                WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
                goto LABEL_68;
              case 1936746595:
                applesauce::CF::NumberRef::NumberRef<unsigned int,void>((CFNumberRef *)&v18, *((_DWORD *)this + 4098));
                applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],applesauce::CF::NumberRef>((applesauce::CF::TypeRef *)valuePtr, "SpatialMode", &v18);
                if (*((_BYTE *)this + 16396))
                  v6 = (const void **)MEMORY[0x1E0C9AE50];
                else
                  v6 = (const void **)MEMORY[0x1E0C9AE40];
                v17 = *v6;
                applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],applesauce::CF::BooleanRef>((applesauce::CF::TypeRef *)v24, "HeadTracking", &v17);
                v19 = valuePtr;
                v20 = 2;
                v7 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v19);
                v8 = 0;
                v21 = v7;
                do
                {
                  v9 = (const void *)v24[v8 + 1];
                  if (v9)
                    CFRelease(v9);
                  v10 = valuePtr[v8 + 2];
                  if (v10)
                    CFRelease(v10);
                  v8 -= 2;
                }
                while (v8 != -4);
                applesauce::CF::BooleanRef::~BooleanRef(&v17);
                applesauce::CF::NumberRef::~NumberRef(&v18);
                valuePtr[0] = v7;
                VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v19, 73);
                WriteItemToDictionary((__CFDictionary **)&cf, (const void **)&v19, 4, 8uLL, (const char *)valuePtr);
                break;
              default:
                goto LABEL_70;
            }
            applesauce::CF::StringRef::~StringRef((const void **)&v19);
            applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v21);
            goto LABEL_70;
          }
          switch(a2)
          {
            case 1937141091:
              v16 = atomic_load((unsigned int *)this + 562);
              LODWORD(v19) = v16;
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 71);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 2, 4uLL, (const char *)&v19);
              applesauce::CF::StringRef::~StringRef(valuePtr);
              v4 = cf;
              break;
            case 1953915762:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 40);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 2, 4uLL, (const char *)this + 2200);
              goto LABEL_68;
            case 1953915764:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 26);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)this + 2196);
              goto LABEL_68;
          }
        }
        else if (a2 > 1768514914)
        {
          switch(a2)
          {
            case 1768514915:
              LODWORD(v19) = *((unsigned __int8 *)this + 16568);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 76);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 1835361379:
              LODWORD(v19) = *((unsigned __int8 *)this + 2244);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 67);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 1836082532:
              LODWORD(v19) = *((unsigned __int8 *)this + 2246);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 74);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
          }
        }
        else
        {
          switch(a2)
          {
            case 1635085677:
              LODWORD(v19) = *((unsigned __int8 *)this + 2268);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 80);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 1718384242:
              LODWORD(v19) = *((_DWORD *)this + 4134);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 69);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 1751933808:
              valuePtr[0] = *((const void **)this + 279);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&v19, 65);
              WriteItemToDictionary((__CFDictionary **)&cf, (const void **)&v19, 4, 8uLL, (const char *)valuePtr);
              v5 = (const void **)&v19;
LABEL_69:
              applesauce::CF::StringRef::~StringRef(v5);
              break;
          }
        }
      }
      else
      {
        if (a2 > 32782)
        {
          switch(a2)
          {
            case 32783:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 27);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 4, 8uLL, (const char *)this + 2208);
              goto LABEL_68;
            case 32784:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 28);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 4, 8uLL, (const char *)this + 2216);
              goto LABEL_68;
            case 32785:
            case 32787:
            case 32789:
            case 32790:
            case 32791:
            case 32793:
            case 32795:
            case 32796:
              goto LABEL_70;
            case 32786:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 31);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)this + 2736);
              goto LABEL_68;
            case 32788:
              LODWORD(v19) = *((unsigned __int8 *)this + 2085);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 34);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 32792:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 44);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)this + 1144);
              goto LABEL_68;
            case 32794:
              LODWORD(v19) = *((unsigned __int8 *)this + 2082);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 61);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              goto LABEL_68;
            case 32797:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 66);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 2, 4uLL, (const char *)this + 2240);
              goto LABEL_68;
            case 32798:
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 62);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 4, 8uLL, (const char *)this + 2224);
              goto LABEL_68;
            default:
              if (a2 != 1634758259)
                goto LABEL_70;
              LODWORD(v19) = *((unsigned __int8 *)this + 16596);
              VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 79);
              WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
              break;
          }
          goto LABEL_68;
        }
        switch(a2)
        {
          case 32769:
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 16);
            WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)this + 2284);
            goto LABEL_68;
          case 32772:
            LODWORD(v19) = *((unsigned __int8 *)this + 2080);
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 60);
            WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
            goto LABEL_68;
          case 32773:
            LODWORD(v19) = *((unsigned __int8 *)this + 2083);
            VPGetPropsPListStringForKey((applesauce::CF::StringRef *)valuePtr, 29);
            WriteItemToDictionary((__CFDictionary **)&cf, valuePtr, 1, 4uLL, (const char *)&v19);
LABEL_68:
            v5 = valuePtr;
            goto LABEL_69;
        }
      }
LABEL_70:
      CFRelease(v4);
    }
  }
}

void sub_1B612656C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

CFNumberRef *applesauce::CF::NumberRef::NumberRef<unsigned int,void>(CFNumberRef *a1, int a2)
{
  CFNumberRef v3;
  std::runtime_error *exception;
  int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *a1 = v3;
  if (!v3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B6126734(_Unwind_Exception *exception_object)
{
  CFTypeRef *v1;

  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(exception_object);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],applesauce::CF::NumberRef>(applesauce::CF::TypeRef *a1, const void **a2)
{
  const void *v4;

  applesauce::CF::TypeRef::TypeRef(a1, "DuckingLevel");
  v4 = *a2;
  if (v4)
    CFRetain(v4);
  *((_QWORD *)a1 + 1) = v4;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[22],applesauce::CF::BooleanRef>(applesauce::CF::TypeRef *a1, const void **a2)
{
  const void *v4;

  applesauce::CF::TypeRef::TypeRef(a1, "EnableAdvancedDucking");
  v4 = *a2;
  if (v4)
    CFRetain(v4);
  *((_QWORD *)a1 + 1) = v4;
  return a1;
}

void VoiceProcessorV2::PListWriteSetModeParameters(VoiceProcessorV2 *this)
{
  __CFDictionary *v2;
  CFTypeRef cf;
  __CFDictionary *v4;

  if (*((_QWORD *)this + 1884))
  {
    v4 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v4);
    v2 = v4;
    if (v4)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 22);
      WriteItemToDictionary(&v4, &cf, 1, 4uLL, (const char *)this + 76);
      if (cf)
        CFRelease(cf);
      CFRelease(v2);
    }
  }
}

void sub_1B612686C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  applesauce::CF::StringRef::~StringRef(&a9);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::PListWriteSetDeviceOrientationParameters(VoiceProcessorV2 *this, int a2)
{
  __CFDictionary *v2;
  CFTypeRef cf;
  __CFDictionary *v4;
  int valuePtr;

  valuePtr = a2;
  if (*((_QWORD *)this + 1884))
  {
    v4 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v4);
    v2 = v4;
    if (v4)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 38);
      WriteItemToDictionary(&v4, &cf, 1, 4uLL, (const char *)&valuePtr);
      if (cf)
        CFRelease(cf);
      CFRelease(v2);
    }
  }
}

void sub_1B61268FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::PListWriteSetUIOrientationParameters(VoiceProcessorV2 *this, int a2)
{
  __CFDictionary *v2;
  CFTypeRef cf;
  __CFDictionary *v4;
  int valuePtr;

  valuePtr = a2;
  if (*((_QWORD *)this + 1884))
  {
    v4 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v4);
    v2 = v4;
    if (v4)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 54);
      WriteItemToDictionary(&v4, &cf, 1, 4uLL, (const char *)&valuePtr);
      if (cf)
        CFRelease(cf);
      CFRelease(v2);
    }
  }
}

void sub_1B612698C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::PListWriteMicTrimGainParameters(VoiceProcessorV2 *a1, float **a2)
{
  __CFDictionary *v3;
  float *v4;
  unint64_t v5;
  size_t v6;
  __CFDictionary *v7;
  char __source[8];
  char __str[512];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)a1 + 1884))
  {
    if (*a2 != a2[1])
    {
      v7 = 0;
      VoiceProcessorV2::PListCopyDictionaryForWrite(a1, &v7);
      v3 = v7;
      if (v7)
      {
        snprintf(__str, 0x200uLL, "%f", **a2);
        v4 = *a2;
        if ((unint64_t)((char *)a2[1] - (char *)*a2) >= 5)
        {
          v5 = 1;
          do
          {
            snprintf(__source, 0x200uLL, ", %f", v4[v5]);
            strlcat(__str, __source, 0x200uLL);
            ++v5;
            v4 = *a2;
          }
          while (v5 < a2[1] - *a2);
        }
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)__source, 24);
        v6 = strlen(__str);
        WriteItemToDictionary(&v7, (const void **)__source, 0, v6 + 1, __str);
        if (*(_QWORD *)__source)
          CFRelease(*(CFTypeRef *)__source);
        CFRelease(v3);
      }
    }
  }
}

void sub_1B6126AE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteRefTrimGainParameters(VoiceProcessorV2 *a1, float **a2)
{
  __CFDictionary *v3;
  float *v4;
  unint64_t v5;
  size_t v6;
  __CFDictionary *v7;
  char __source[8];
  char __str[512];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)a1 + 1884))
  {
    if (*a2 != a2[1])
    {
      v7 = 0;
      VoiceProcessorV2::PListCopyDictionaryForWrite(a1, &v7);
      v3 = v7;
      if (v7)
      {
        snprintf(__str, 0x200uLL, "%f", **a2);
        v4 = *a2;
        if ((unint64_t)((char *)a2[1] - (char *)*a2) >= 5)
        {
          v5 = 1;
          do
          {
            snprintf(__source, 0x200uLL, ", %f", v4[v5]);
            strlcat(__str, __source, 0x200uLL);
            ++v5;
            v4 = *a2;
          }
          while (v5 < a2[1] - *a2);
        }
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)__source, 25);
        v6 = strlen(__str);
        WriteItemToDictionary(&v7, (const void **)__source, 0, v6 + 1, __str);
        if (*(_QWORD *)__source)
          CFRelease(*(CFTypeRef *)__source);
        CFRelease(v3);
      }
    }
  }
}

void sub_1B6126C5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteSpeakerCalibrationParameters(VoiceProcessorV2 *this, const __CFArray *a2)
{
  __CFDictionary *v2;
  CFTypeRef cf;
  __CFDictionary *v4;
  const __CFArray *valuePtr;

  valuePtr = a2;
  if (a2)
  {
    v4 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v4);
    v2 = v4;
    if (v4)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 63);
      WriteItemToDictionary(&v4, &cf, 4, 8uLL, (const char *)&valuePtr);
      if (cf)
        CFRelease(cf);
      CFRelease(v2);
    }
  }
}

void sub_1B6126D00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::PListWriteSpkInputDataSrcParameters(VoiceProcessorV2 *this, unsigned int *a2, unsigned int a3)
{
  __CFDictionary *v5;
  uint64_t v6;
  unsigned int *v7;
  size_t v8;
  __CFDictionary *v9;
  char __source[8];
  char __str[512];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (*((_QWORD *)this + 1884))
    {
      v9 = 0;
      VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v9);
      v5 = v9;
      if (v9)
      {
        snprintf(__str, 0x200uLL, "%d", *a2);
        if (a3 >= 2)
        {
          v6 = a3 - 1;
          v7 = a2 + 1;
          do
          {
            snprintf(__source, 0x200uLL, ", %d", *v7);
            strlcat(__str, __source, 0x200uLL);
            ++v7;
            --v6;
          }
          while (v6);
        }
        VPGetPropsPListStringForKey((applesauce::CF::StringRef *)__source, 57);
        v8 = strlen(__str);
        WriteItemToDictionary(&v9, (const void **)__source, 0, v8 + 1, __str);
        if (*(_QWORD *)__source)
          CFRelease(*(CFTypeRef *)__source);
        CFRelease(v5);
      }
    }
  }
}

void sub_1B6126E44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void VoiceProcessorV2::PListWriteRefPhysicalDevSR(VoiceProcessorV2 *this, double *a2)
{
  __CFDictionary *v3;
  CFTypeRef cf;
  __CFDictionary *v5;

  if (*((_QWORD *)this + 1884))
  {
    v5 = 0;
    VoiceProcessorV2::PListCopyDictionaryForWrite(this, &v5);
    v3 = v5;
    if (v5)
    {
      VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&cf, 59);
      WriteItemToDictionary(&v5, &cf, 3, 8uLL, (const char *)a2);
      if (cf)
        CFRelease(cf);
      CFRelease(v3);
    }
  }
}

void sub_1B6126EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  applesauce::CF::StringRef::~StringRef(&a9);
  _Unwind_Resume(a1);
}

const void **applesauce::CF::ObjectRef<__CFReadStream *>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void std::vector<long long>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,float>>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t SubbandDOA::Set(SubbandDOA *this, unsigned int a2, float a3, float a4)
{
  unsigned int v4;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v4 = *(_DWORD *)this + 1;
  if (v4 <= a2)
    __assert_rtn("Set", "SubbandDOA.h", 49, "bandIdx < GetNumBands()");
  if (a4 < -90.0 || a4 > 90.0)
    __assert_rtn("Set", "SubbandDOA.h", 50, "elevation >= -90.0 && elevation <= 90.0");
  v7 = *((_QWORD *)this + 1);
  v8 = *((_QWORD *)this + 2);
  result = (uint64_t)this + 8;
  v9 = (v8 - v7) >> 2;
  if (v9 <= a2 || (*(float *)(v7 + 4 * a2) = a3, v10 = a2 + (unint64_t)v4, v9 <= v10))
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  *(float *)(v7 + 4 * v10) = a4;
  return result;
}

uint64_t CmhBEAM::initialize(int32x2_t *this, int a2, __int32 a3, int a4)
{
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;
  int32x2_t v12;
  int32x2_t v13;
  int32x2_t v14;
  __int32 v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t i;
  uint64_t v20;
  int v21;
  uint64_t j;
  uint64_t v23;
  int32x2_t v24;
  int32x2_t v25;
  int32x2_t v26;
  uint64_t result;
  int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  unsigned __int16 v37;
  int v38;
  signed int v39;
  uint64_t v40;
  uint64_t v41;
  __int32 v42;
  __int32 v43;
  float v44;
  __int32 v45;
  float v46;
  double v47;
  _BOOL4 v48;
  _BOOL4 v49;
  float v50;
  float v51;
  void *v52;
  size_t v53;
  void *v54;
  void *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  size_t v60;
  size_t v61;
  const std::nothrow_t *v62;
  void *v63;
  uint64_t v64;
  const std::nothrow_t *v65;
  void *v66;
  uint64_t v67;
  const std::nothrow_t *v68;
  void *v69;
  size_t v70;
  void *v71;
  uint64_t v72;
  const std::nothrow_t *v73;
  uint64_t v74;
  size_t v75;
  size_t v76;
  void *v77;
  size_t v78;
  size_t v79;
  void *v80;
  void *v81;
  size_t v82;
  void *v83;
  uint64_t v84;
  const std::nothrow_t *v85;
  uint64_t v86;
  size_t v87;
  size_t v88;
  void *v89;
  int v90;
  size_t v91;
  char *v92;
  uint64_t v93;
  size_t v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  char *v98;
  size_t v99;
  char *v100;
  int v101;
  size_t v102;
  int v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  char *v107;
  size_t v108;
  size_t v109;
  void *v110;
  size_t v111;
  void *v112;
  size_t v113;
  void *v114;
  uint64_t v115;
  void *v116;
  uint64_t v117;
  const std::nothrow_t *v118;
  uint64_t v119;
  size_t v120;
  size_t v121;
  void *v122;
  uint64_t v124;
  int v125;
  uint64_t v126;

  v8 = this[4];
  if (v8)
  {
    MEMORY[0x1BCC95CC8](*(_QWORD *)&v8, 0x80C80B8603338);
    this[4] = 0;
  }
  v9 = this[5];
  if (v9)
  {
    MEMORY[0x1BCC95CC8](*(_QWORD *)&v9, 0x80C80B8603338);
    this[5] = 0;
  }
  v10 = this[6];
  if (v10)
  {
    MEMORY[0x1BCC95CC8](*(_QWORD *)&v10, 0x80C80B8603338);
    this[6] = 0;
  }
  v11 = this[10];
  if (v11)
  {
    MEMORY[0x1BCC95CC8](*(_QWORD *)&v11, 0x1000C8052888210);
    this[10] = 0;
  }
  v12 = this[7];
  if (v12)
  {
    MEMORY[0x1BCC95CC8](*(_QWORD *)&v12, 0x80C80B8603338);
    this[7] = 0;
  }
  v13 = this[8];
  if (v13)
  {
    MEMORY[0x1BCC95CC8](*(_QWORD *)&v13, 0x80C80B8603338);
    this[8] = 0;
  }
  v14 = this[9];
  if (v14)
  {
    MEMORY[0x1BCC95CC8](*(_QWORD *)&v14, 0x80C80B8603338);
    this[9] = 0;
  }
  if (this[15].i32[1])
  {
    if (this[7])
    {
      v15 = this->i32[0];
      if (this->i32[0] >= 1)
      {
        v16 = 0;
        do
        {
          v17 = *(_QWORD *)(*(_QWORD *)&this[7] + 8 * v16);
          if (v17)
          {
            MEMORY[0x1BCC95CC8](v17, 0x1000C8052888210);
            v15 = this->i32[0];
          }
          ++v16;
        }
        while (v16 < v15);
      }
    }
    if (this[8])
    {
      v18 = this[1].i32[0];
      if (v18 >= 1)
      {
        for (i = 0; i < v18; ++i)
        {
          v20 = *(_QWORD *)(*(_QWORD *)&this[8] + 8 * i);
          if (v20)
          {
            MEMORY[0x1BCC95CC8](v20, 0x1000C8052888210);
            v18 = this[1].i32[0];
          }
        }
      }
    }
    if (this[9])
    {
      v21 = this->i32[1];
      if (v21 >= 1)
      {
        for (j = 0; j < v21; ++j)
        {
          v23 = *(_QWORD *)(*(_QWORD *)&this[9] + 8 * j);
          if (v23)
          {
            MEMORY[0x1BCC95CC8](v23, 0x1000C8052888210);
            v21 = this->i32[1];
          }
        }
      }
    }
  }
  v24 = this[7];
  if (v24)
  {
    MEMORY[0x1BCC95CC8](*(_QWORD *)&v24, 0x80C80B8603338);
    this[7] = 0;
  }
  v25 = this[8];
  if (v25)
  {
    MEMORY[0x1BCC95CC8](*(_QWORD *)&v25, 0x80C80B8603338);
    this[8] = 0;
  }
  if (this->i32[1] >= 1)
  {
    v26 = this[9];
    if (v26)
    {
      MEMORY[0x1BCC95CC8](*(_QWORD *)&v26, 0x80C80B8603338);
      this[9] = 0;
    }
  }
  if ((a4 - 3) < 0xFFFFFFFE)
    return 5;
  if ((a3 - 46) < 0xFFFFFFDC)
    return 6;
  if (a2 > 23999)
  {
    if (a2 > 47999)
    {
      if (a2 != 48000)
      {
        if (a2 != 88200 && a2 != 96000)
          goto LABEL_182;
        v30 = 1024;
        v28 = 1;
        goto LABEL_64;
      }
LABEL_63:
      v28 = 0;
      v30 = 512;
LABEL_64:
      v29 = 1;
      goto LABEL_66;
    }
    if (a2 != 24000 && a2 != 32000)
    {
      if (a2 != 44100)
        goto LABEL_182;
      goto LABEL_63;
    }
    goto LABEL_55;
  }
  if (a2 <= 11999)
  {
    if (a2 == 8000)
    {
      v28 = 0;
      v29 = 0;
      v30 = 64;
      goto LABEL_66;
    }
    if (a2 != 11025)
    {
LABEL_182:
      this[13] = 0;
      return 1;
    }
LABEL_62:
    v28 = 0;
    v29 = 0;
    v30 = 128;
    goto LABEL_66;
  }
  if (a2 == 12000 || a2 == 16000)
    goto LABEL_62;
  if (a2 != 22050)
    goto LABEL_182;
LABEL_55:
  v28 = 0;
  v29 = 0;
  v30 = 256;
LABEL_66:
  this[13].i32[0] = a2;
  this[13].i32[1] = v30;
  v31 = v30 >> 1;
  v32 = (5 * v30) >> 3;
  this[14].i32[1] = 0;
  this[16].i32[0] = 0;
  if (!v28 || !v29)
  {
    if (((v31 - 1) & 0x100) != 0)
    {
      if (0x100 % v32)
        return 2;
      v33 = 4;
    }
    else
    {
      v33 = 3;
      v32 = v30 >> 1;
    }
    this[14].i32[1] = v32;
    this[15].i32[1] = 0;
    this[16].i32[0] = v33;
    v34 = 0x100 / v32;
    goto LABEL_79;
  }
  if ((v30 & 0x1C0) == 0)
  {
    v33 = 3;
    v32 = v30 >> 1;
    goto LABEL_76;
  }
  if (((5 * (_WORD)v30) & 0x7C0) != 0)
    return 2;
  v33 = 4;
LABEL_76:
  v34 = 0;
  this[14].i32[1] = v32;
  this[15].i32[1] = v32 >> 8;
  this[16].i32[0] = v33;
LABEL_79:
  this[15].i32[0] = v34;
  this[18].i32[1] = a3;
  this[17] = vadd_s32(vdup_n_s32(v31), (int32x2_t)0x1FFFFFFFFLL);
  v35 = -1;
  LOWORD(v31) = v30;
  do
  {
    v31 = (unsigned __int16)v31 >> 1;
    ++v35;
  }
  while (v31);
  this[14].i32[0] = v35;
  this[16].i32[1] = v33 * v30;
  CmhBEAMprocOpt::deallocate_memory(&this[11]);
  this[12].i32[1] = a4;
  v36 = this[14].i32[0];
  if (v36 < 1)
  {
    v38 = 1;
  }
  else
  {
    v37 = 1;
    do
    {
      v37 *= 2;
      --v36;
    }
    while (v36);
    v38 = v37;
  }
  v39 = this[13].i32[1];
  this[22].i32[0] = v39 != v38;
  if (this[11].i32[0])
  {
    LODWORD(v40) = this[18].i32[0];
    LODWORD(v41) = a4;
  }
  else
  {
    this[11].i32[0] = 1;
    v40 = this[18].i32[0];
    if ((int)v40 < 0)
      v70 = -1;
    else
      v70 = 8 * v40;
    v71 = operator new[](v70, MEMORY[0x1E0DE4E10]);
    this[28] = (int32x2_t)v71;
    if (!v71)
      return 4;
    bzero(v71, 8 * (int)v40);
    if ((int)v40 >= 1)
    {
      v72 = 0;
      v73 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
      while (1)
      {
        v74 = this[13].i32[1];
        v75 = 4 * v74;
        v76 = (int)v74 < 0 ? -1 : 4 * v74;
        *(_QWORD *)(*(_QWORD *)&this[28] + 8 * v72) = operator new[](v76, v73);
        v77 = *(void **)(*(_QWORD *)&this[28] + 8 * v72);
        if (!v77)
          return 4;
        bzero(v77, v75);
        ++v72;
        v40 = this[18].i32[0];
        if (v72 >= v40)
        {
          v39 = this[13].i32[1];
          break;
        }
      }
    }
    v78 = 4 * v39;
    v79 = v39 < 0 ? -1 : 4 * v39;
    v80 = operator new[](v79, MEMORY[0x1E0DE4E10]);
    this[31] = (int32x2_t)v80;
    if (!v80)
      return 4;
    bzero(v80, v78);
    v81 = operator new[](v79, MEMORY[0x1E0DE4E10]);
    this[32] = (int32x2_t)v81;
    if (!v81)
      return 4;
    bzero(v81, v78);
    v41 = this[12].i32[1];
    v82 = (int)v41 < 0 ? -1 : 8 * v41;
    v83 = operator new[](v82, MEMORY[0x1E0DE4E10]);
    this[27] = (int32x2_t)v83;
    if (!v83)
      return 4;
    bzero(v83, 8 * (int)v41);
    if ((int)v41 >= 1)
    {
      v84 = 0;
      v85 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
      while (1)
      {
        v86 = this[13].i32[1];
        v87 = 4 * v86;
        v88 = (int)v86 < 0 ? -1 : 4 * v86;
        *(_QWORD *)(*(_QWORD *)&this[27] + 8 * v84) = operator new[](v88, v85);
        v89 = *(void **)(*(_QWORD *)&this[27] + 8 * v84);
        if (!v89)
          return 4;
        bzero(v89, v87);
        if (++v84 >= this[12].i32[1])
        {
          LODWORD(v40) = this[18].i32[0];
          LODWORD(v41) = this[12].i32[1];
          break;
        }
      }
    }
    v90 = v40 + 1;
    v91 = (int)v40 < -1 ? -1 : 16 * v90;
    v92 = (char *)operator new[](v91, MEMORY[0x1E0DE4E10]);
    this[30] = (int32x2_t)v92;
    if (!v92)
      return 4;
    v126 = v90;
    if ((v40 & 0x80000000) == 0)
    {
      v93 = this[13].i32[1];
      if ((int)v93 < 0)
        v94 = -1;
      else
        v94 = 4 * v93;
      v95 = (uint64_t)(int)(v93 + ((int)v93 < 0)) >> 1;
      v96 = v126;
      v97 = v92 + 8;
      do
      {
        v98 = (char *)operator new[](v94, MEMORY[0x1E0DE4E10]);
        *(v97 - 1) = v98;
        if (!v98)
          return 4;
        *v97 = &v98[4 * v95];
        v97 += 2;
      }
      while (--v96);
    }
    v99 = (int)v41 < 0 ? -1 : 16 * (int)v41;
    v100 = (char *)operator new[](v99, MEMORY[0x1E0DE4E10]);
    this[29] = (int32x2_t)v100;
    if (!v100)
      return 4;
    v101 = this[13].i32[1];
    if ((int)v41 > 0)
    {
      v124 = 4 * v101;
      v125 = this[13].i32[1];
      if (v101 < 0)
        v102 = -1;
      else
        v102 = 4 * v101;
      if (v101 >= 0)
        v103 = this[13].i32[1];
      else
        v103 = v101 + 1;
      v104 = (uint64_t)v103 >> 1;
      v105 = v41;
      v106 = v100 + 8;
      while (1)
      {
        v107 = (char *)operator new[](v102, MEMORY[0x1E0DE4E10]);
        *(v106 - 1) = v107;
        if (!v107)
          return 4;
        *v106 = &v107[4 * v104];
        v106 += 2;
        if (!--v105)
        {
          v108 = v124;
          v101 = v125;
          goto LABEL_184;
        }
      }
    }
    v108 = 4 * v101;
LABEL_184:
    if (v101 < 0)
      v109 = -1;
    else
      v109 = v108;
    v110 = operator new[](v109, MEMORY[0x1E0DE4E10]);
    this[33] = (int32x2_t)v110;
    if (!v110)
      return 4;
    bzero(v110, v108);
    v111 = (int)v40 < -1 ? -1 : 8 * v126;
    v112 = operator new[](v111, MEMORY[0x1E0DE4E10]);
    this[23] = (int32x2_t)v112;
    if (!v112)
      return 4;
    v113 = 8 * (int)v40 + 8;
    bzero(v112, v113);
    v114 = operator new[](v111, MEMORY[0x1E0DE4E10]);
    this[24] = (int32x2_t)v114;
    if (!v114)
      return 4;
    bzero(v114, v113);
    if ((v40 & 0x80000000) == 0)
    {
      v115 = 0;
      do
      {
        *(_QWORD *)(*(_QWORD *)&this[23] + v115) = 0;
        *(_QWORD *)(*(_QWORD *)&this[24] + v115) = 0;
        v115 += 8;
      }
      while (8 * v126 != v115);
    }
    v116 = operator new[](v111, MEMORY[0x1E0DE4E10]);
    this[25] = (int32x2_t)v116;
    if (!v116)
      return 4;
    bzero(v116, v113);
    if ((v40 & 0x80000000) == 0)
    {
      v117 = 0;
      v118 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
      while (1)
      {
        v119 = this[13].i32[1];
        v120 = 4 * v119;
        v121 = (int)v119 < 0 ? -1 : 4 * v119;
        *(_QWORD *)(*(_QWORD *)&this[25] + 8 * v117) = operator new[](v121, v118);
        v122 = *(void **)(*(_QWORD *)&this[25] + 8 * v117);
        if (!v122)
          return 4;
        bzero(v122, v120);
        v40 = this[18].i32[0];
        if (v117++ >= v40)
        {
          LODWORD(v41) = this[12].i32[1];
          v39 = this[13].i32[1];
          goto LABEL_88;
        }
      }
    }
    v39 = v101;
  }
LABEL_88:
  if (LPFilterBank::Initialize((LPFilterBank *)&this[185], (int)v40 + 1, v41, v39, this[14].i32[1], this[16].i32[0]))return 4;
  if (CmhBEAM2NOpt::initialize((CmhBEAM2NOpt *)&this[34], this[13].i32[0], this[13].i32[1], this[14].i32[1], this[18].i32[1], this[12].i32[1]))return 4;
  v42 = this[12].i32[1];
  Cns::deallocate_memory((uint64_t)&this[143]);
  this[146].i32[1] = v42;
  if (Cns::init((Cns *)&this[143]))
    return 4;
  v43 = this[14].i32[1];
  Cns::deallocate_memory((uint64_t)&this[143]);
  this[145].i32[1] = v43;
  if (Cns::init((Cns *)&this[143]))
    return 4;
  v44 = (float)this[13].i32[0];
  Cns::deallocate_memory((uint64_t)&this[143]);
  *(float *)this[145].i32 = v44;
  if (Cns::init((Cns *)&this[143]))
    return 4;
  v45 = this[13].i32[1];
  Cns::deallocate_memory((uint64_t)&this[143]);
  this[146].i32[0] = v45;
  if (Cns::init((Cns *)&this[143]))
    return 4;
  v46 = 628.318531 / (float)this[13].i32[0];
  v47 = (float)(1.0 - v46) + (float)(v46 * v46) * 0.5;
  v48 = v47 <= -0.9999;
  v49 = v47 < 0.9999 || v47 <= -0.9999;
  if (v47 >= 0.9999)
    v48 = 1;
  v50 = 0.9999;
  if (v49)
    v50 = -0.9999;
  v51 = v47;
  if (v48)
    v51 = v50;
  *(float *)this[21].i32 = v51;
  *(float *)&this[21].i32[1] = (float)(v51 + 1.0) * 0.5;
  this[19] = 0;
  this[20] = 0;
  *this = (int32x2_t)2;
  this[1].i32[0] = a4;
  this[1].i32[1] = a2;
  this[2].i32[0] = 256;
  this[2].i32[1] = a3;
  this[3].i32[0] = 0;
  v52 = operator new[](0x10uLL, MEMORY[0x1E0DE4E10]);
  this[4] = (int32x2_t)v52;
  if (v52)
  {
    v53 = a4 < 0 ? -1 : 8 * a4;
    v54 = operator new[](v53, MEMORY[0x1E0DE4E10]);
    this[5] = (int32x2_t)v54;
    if (v54)
    {
      v55 = operator new[](0x800uLL, MEMORY[0x1E0DE4E10]);
      this[10] = (int32x2_t)v55;
      if (v55)
      {
        v56 = operator new[](0x10uLL, MEMORY[0x1E0DE4E10]);
        this[7] = (int32x2_t)v56;
        if (v56)
        {
          *v56 = 0;
          v56[1] = 0;
          v57 = operator new[](v53, MEMORY[0x1E0DE4E10]);
          this[8] = (int32x2_t)v57;
          if (v57)
          {
            bzero(v57, 8 * a4);
            if (!this[15].i32[1])
            {
LABEL_126:
              result = 0;
              this[3].i32[1] = 0;
              return result;
            }
            v58 = 0;
            v59 = this[14].i32[1];
            if ((int)v59 < 0)
              v60 = -1;
            else
              v60 = 4 * v59;
            v61 = 4 * (int)v59;
            v62 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
            while (1)
            {
              *(_QWORD *)(*(_QWORD *)&this[7] + 8 * v58) = operator new[](v60, v62);
              v63 = *(void **)(*(_QWORD *)&this[7] + 8 * v58);
              if (!v63)
                break;
              bzero(v63, v61);
              if (++v58 >= this->i32[0])
              {
                if (this[1].i32[0] < 1)
                {
LABEL_122:
                  if (this->i32[1] < 1)
                    goto LABEL_126;
                  v67 = 0;
                  v68 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
                  while (1)
                  {
                    *(_QWORD *)(*(_QWORD *)&this[9] + 8 * v67) = operator new[](v60, v68);
                    v69 = *(void **)(*(_QWORD *)&this[9] + 8 * v67);
                    if (!v69)
                      break;
                    bzero(v69, v61);
                    if (++v67 >= this->i32[1])
                      goto LABEL_126;
                  }
                }
                else
                {
                  v64 = 0;
                  v65 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
                  while (1)
                  {
                    *(_QWORD *)(*(_QWORD *)&this[8] + 8 * v64) = operator new[](v60, v65);
                    v66 = *(void **)(*(_QWORD *)&this[8] + 8 * v64);
                    if (!v66)
                      break;
                    bzero(v66, v61);
                    if (++v64 >= this[1].i32[0])
                      goto LABEL_122;
                  }
                }
                return 4294967294;
              }
            }
          }
        }
      }
    }
  }
  return 4294967294;
}

uint64_t CmhBEAM::deinterleave(uint64_t this, float **a2, float **a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int *v7;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  float *v16;
  float *v17;
  uint64_t v18;

  if (a4 >= 1)
  {
    v4 = *(int *)(this + 16);
    v5 = *(unsigned int *)(this + 16);
    if ((_DWORD)v4)
    {
      v6 = v4 * a4;
      v7 = (int *)*a2;
      v8 = *(_DWORD **)(this + 80);
      do
      {
        v9 = *v7++;
        *v8++ = v9;
        --v6;
      }
      while (v6);
    }
    v10 = 0;
    v11 = 4 * v4;
    v12 = a3;
    v13 = a4;
    do
    {
      *v12++ = (float *)((char *)*a2 + v10);
      v10 += v11;
      --v13;
    }
    while (v13);
    v14 = 0;
    for (i = 0; i != a4; ++i)
    {
      if ((int)v5 >= 1)
      {
        v16 = a3[i];
        v17 = (float *)(*(_QWORD *)(this + 80) + v14);
        v18 = v5;
        do
        {
          *v16++ = *v17;
          v17 += a4;
          --v18;
        }
        while (v18);
      }
      v14 += 4;
    }
  }
  return this;
}

float CmhBEAM::interleave(CmhBEAM *this, float **a2, float **a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  float *v8;
  uint64_t v9;
  float v10;
  float result;
  int v12;
  float *v13;
  float *v14;
  float v15;

  if (a4 >= 1)
  {
    v4 = 0;
    v5 = 0;
    v6 = *((unsigned int *)this + 4);
    do
    {
      if ((int)v6 >= 1)
      {
        v7 = a2[v5];
        v8 = (float *)(*((_QWORD *)this + 10) + v4);
        v9 = v6;
        do
        {
          v10 = *v7++;
          result = v10;
          *v8 = v10;
          v8 += a4;
          --v9;
        }
        while (v9);
      }
      ++v5;
      v4 += 4;
    }
    while (v5 != a4);
    if ((_DWORD)v6)
    {
      v12 = v6 * a4;
      v13 = (float *)*((_QWORD *)this + 10);
      v14 = *a3;
      do
      {
        v15 = *v13++;
        result = v15;
        *v14++ = v15;
        --v12;
      }
      while (v12);
    }
  }
  return result;
}

float CmhBEAM::setParameter(CmhBEAM *this, int a2, CmhBEAM2NOpt *a3, double a4, double a5)
{
  float v5;
  uint64_t v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  CmhBEAM2NOpt *v14;
  int v15;
  CmhMicCheck *v16;
  float v17;
  uint64_t v18;
  int v19;
  float v20;
  int v21;
  int v22;
  int v23;
  float v24;
  uint64_t v25;
  CmhMicCheck *v26;
  float v27;
  int v28;
  float v29;
  float v31;

  switch(a2)
  {
    case 3:
      *(_DWORD *)(*((_QWORD *)this + 137) + 44) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 4:
      v5 = *(float *)a3;
      *((_DWORD *)this + 133) = *(_DWORD *)a3;
      goto LABEL_97;
    case 5:
      *((_DWORD *)this + 162) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 6:
      if (*((_DWORD *)this + 287) + *((_DWORD *)this + 293) >= 1)
      {
        v6 = 0;
        v7 = *(float *)a3;
        v8 = *((_QWORD *)this + 144);
        do
          *(float *)(v8 + 4 * v6++) = v7;
        while (v6 < *((int *)this + 287) + (uint64_t)*((int *)this + 293));
      }
      return *(float *)&a4;
    case 7:
      Cns::setMinGain((uint64_t)this + 1144, *(float *)a3);
      return *(float *)&a4;
    case 11:
      CmhBEAM2NOpt::setSpatialFilterReal((uint64_t)this + 272, (float *)a3);
      return *(float *)&a4;
    case 12:
      CmhBEAM2NOpt::setSpatialFilterImag((uint64_t)this + 272, (float *)a3);
      return *(float *)&a4;
    case 15:
      CmhBEAM2NOpt::setModelSpatialFilterReal((CmhBEAM *)((char *)this + 272), a3, 0);
      return *(float *)&a4;
    case 16:
      CmhBEAM2NOpt::setModelSpatialFilterImag((CmhBEAM *)((char *)this + 272), a3, 0);
      return *(float *)&a4;
    case 17:
      CmhBEAM2NOpt::setModelSpatialFilterReal((CmhBEAM *)((char *)this + 272), a3, 1u);
      return *(float *)&a4;
    case 18:
      CmhBEAM2NOpt::setModelSpatialFilterImag((CmhBEAM *)((char *)this + 272), a3, 1u);
      return *(float *)&a4;
    case 19:
      *(float *)&a4 = CmhBEAMprocOpt::setModelFreqCompVector((CmhBEAM *)((char *)this + 88), a3);
      return *(float *)&a4;
    case 20:
      CmhBEAM2NOpt::setModelOmniEQVector((CmhBEAM *)((char *)this + 272), a3);
      return *(float *)&a4;
    case 21:
      *(float *)&a4 = CmhBEAM2NOpt::setModelFreqCompVector((CmhBEAM *)((char *)this + 272), a3, 0);
      return *(float *)&a4;
    case 22:
      CmhBEAM2NOpt::setModelOmniEQVector((CmhBEAM *)((char *)this + 272), a3, 0);
      return *(float *)&a4;
    case 23:
      *(float *)&a4 = CmhBEAM2NOpt::setModelFreqCompVector((CmhBEAM *)((char *)this + 272), a3, 1u);
      return *(float *)&a4;
    case 24:
      CmhBEAM2NOpt::setModelOmniEQVector((CmhBEAM *)((char *)this + 272), a3, 1u);
      return *(float *)&a4;
    case 34:
      v9 = *((unsigned int *)this + 70);
      if ((int)v9 >= 1)
      {
        LODWORD(a4) = *(_DWORD *)a3;
        v10 = (_DWORD *)(*((_QWORD *)this + 85) + 64);
        do
        {
          *v10 = LODWORD(a4);
          v10 += 34;
          --v9;
        }
        while (v9);
      }
      return *(float *)&a4;
    case 35:
      CmhBEAMprocOpt::setWNG((CmhBEAM *)((char *)this + 88), *(float *)a3);
      return *(float *)&a4;
    case 36:
      CmhBEAMprocOpt::setModelFreqEQVector((CmhBEAM *)((char *)this + 88), a3);
      return *(float *)&a4;
    case 37:
      CmhBEAM2NOpt::setModelFreqEQVector((CmhBEAM *)((char *)this + 272), a3, 0);
      return *(float *)&a4;
    case 38:
      CmhBEAM2NOpt::setModelFreqEQVector((CmhBEAM *)((char *)this + 272), a3, 1u);
      return *(float *)&a4;
    case 39:
      v11 = *(float *)a3;
      v12 = *((_QWORD *)this + 85);
      *(_DWORD *)(v12 + 108) = *(_DWORD *)a3;
      if (*((int *)this + 70) >= 2)
        *(float *)(v12 + 244) = v11;
      return *(float *)&a4;
    case 42:
      LODWORD(a4) = *(_DWORD *)a3;
      v13 = *((_QWORD *)this + 85);
      *(_DWORD *)(v13 + 112) = *(_DWORD *)a3;
      if (*((int *)this + 70) >= 2)
        *(_DWORD *)(v13 + 248) = LODWORD(a4);
      return *(float *)&a4;
    case 43:
      *((_DWORD *)this + 139) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 44:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 140) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 45:
      v29 = *(float *)a3;
      if (*(_DWORD *)a3 <= 1u)
        *((float *)this + 69) = v29;
      *((float *)this + 23) = v29;
      return *(float *)&a4;
    case 46:
      CmhBEAM2NOpt::setABFVector((uint64_t)this + 272, (float *)a3);
      return *(float *)&a4;
    case 47:
      v14 = (CmhBEAM *)((char *)this + 272);
      v15 = 0;
      goto LABEL_45;
    case 48:
      v14 = (CmhBEAM *)((char *)this + 272);
      v15 = 1;
LABEL_45:
      *(float *)&a4 = CmhBEAM2NOpt::setABFVector(v14, v15, (float *)a3);
      return *(float *)&a4;
    case 51:
      *((_DWORD *)this + 52) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 65:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 100) = (int)*(float *)a3;
      return *(float *)&a4;
    case 66:
      *((_DWORD *)this + 128) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 67:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 193) = *(_DWORD *)a3;
      goto LABEL_104;
    case 68:
      *((_DWORD *)this + 133) = *(_DWORD *)a3;
      return *(float *)&a4;
    case 69:
      v5 = *(float *)a3;
LABEL_97:
      *((float *)this + 134) = v5;
      return *(float *)&a4;
    case 70:
      v17 = *(float *)a3;
      v18 = *((_QWORD *)this + 144);
      v19 = (*((_DWORD *)this + 293) + *((_DWORD *)this + 287) - 1) & ((*((_DWORD *)this + 293)
                                                                      + *((_DWORD *)this + 287)
                                                                      - 1) >> 31);
      goto LABEL_53;
    case 71:
      v17 = *(float *)a3;
      v18 = *((_QWORD *)this + 144);
      v19 = *((_DWORD *)this + 293) + *((_DWORD *)this + 287) - 1;
      if (v19 >= 1)
        v19 = 1;
LABEL_53:
      *(float *)(v18 + 4 * v19) = v17;
      return *(float *)&a4;
    case 72:
      Cns::setMinGain((uint64_t)this + 1144, *(float *)a3, 0);
      return *(float *)&a4;
    case 73:
      Cns::setMinGain((uint64_t)this + 1144, *(float *)a3, 1);
      return *(float *)&a4;
    case 74:
      v20 = *(float *)a3;
      v21 = *((_DWORD *)this + 70);
      if (v21 >= 1)
        v21 = 1;
      goto LABEL_61;
    case 75:
      v20 = *(float *)a3;
      v21 = *((_DWORD *)this + 70);
      if (v21 >= 2)
        v21 = 2;
LABEL_61:
      *(float *)(*((_QWORD *)this + 85) + 136 * v21 - 28) = v20;
      return *(float *)&a4;
    case 76:
      LODWORD(a4) = *(_DWORD *)a3;
      v22 = *((_DWORD *)this + 70);
      if (v22 >= 1)
        v22 = 1;
      goto LABEL_66;
    case 77:
      LODWORD(a4) = *(_DWORD *)a3;
      v22 = *((_DWORD *)this + 70);
      if (v22 >= 2)
        v22 = 2;
LABEL_66:
      *(_DWORD *)(*((_QWORD *)this + 85) + 136 * v22 - 24) = LODWORD(a4);
      return *(float *)&a4;
    case 78:
      *(float *)&a4 = (float)((float)*(int *)a3 / (float)*((int *)this + 71)) * (float)*((int *)this + 72);
      *((_DWORD *)this + 76) = *(_DWORD *)a3;
      v23 = *((_DWORD *)this + 74) - 1;
      if (v23 >= (int)*(float *)&a4)
        v23 = (int)*(float *)&a4;
      *((_DWORD *)this + 132) = v23;
      return *(float *)&a4;
    case 81:
      v24 = *(float *)a3;
      *((_DWORD *)this + 102) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((float *)this + 211) = v24;
      goto LABEL_104;
    case 82:
      v31 = *(float *)a3;
      *(float *)&a4 = v31;
      *(float *)&a4 = CmhBEAM2NOpt::setParameter((CmhBEAM *)((char *)this + 272), 59, (CmhBEAM2NOpt *)&v31, a4, a5);
      return *(float *)&a4;
    case 83:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 194) = *(_DWORD *)a3;
      goto LABEL_104;
    case 84:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 195) = *(_DWORD *)a3;
      goto LABEL_104;
    case 85:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 196) = *(_DWORD *)a3;
      goto LABEL_104;
    case 86:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 197) = *(_DWORD *)a3;
      goto LABEL_104;
    case 87:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 198) = *(_DWORD *)a3;
      goto LABEL_104;
    case 88:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 199) = *(_DWORD *)a3;
      goto LABEL_104;
    case 89:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 200) = *(_DWORD *)a3;
      goto LABEL_104;
    case 90:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 201) = *(_DWORD *)a3;
      goto LABEL_104;
    case 91:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 202) = *(_DWORD *)a3;
      goto LABEL_104;
    case 92:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 203) = *(_DWORD *)a3;
      goto LABEL_104;
    case 93:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 204) = *(_DWORD *)a3;
      goto LABEL_104;
    case 94:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 205) = *(_DWORD *)a3;
      goto LABEL_104;
    case 95:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 206) = *(_DWORD *)a3;
      goto LABEL_104;
    case 96:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 207) = *(_DWORD *)a3;
      goto LABEL_104;
    case 97:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 208) = *(_DWORD *)a3;
      goto LABEL_104;
    case 98:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 209) = *(_DWORD *)a3;
      goto LABEL_104;
    case 99:
      LODWORD(a4) = *(_DWORD *)a3;
      v16 = (CmhBEAM *)((char *)this + 736);
      *((_DWORD *)this + 210) = *(_DWORD *)a3;
LABEL_104:
      v26 = v16;
      goto LABEL_105;
    case 100:
      v25 = 0;
      do
      {
        LODWORD(a4) = *(_DWORD *)((char *)a3 + v25);
        *(_DWORD *)((char *)this + v25 + 772) = LODWORD(a4);
        v25 += 4;
      }
      while ((_DWORD)v25 != 76);
      v26 = (CmhBEAM *)((char *)this + 736);
LABEL_105:
      LODWORD(a4) = CmhMicCheck::init_check_mics(v26, a4, a5).u32[0];
      return *(float *)&a4;
    case 101:
      *((_DWORD *)this + 78) = *(_DWORD *)a3;
      goto LABEL_87;
    case 102:
LABEL_87:
      *((_DWORD *)this + 262) = *(_DWORD *)a3;
      break;
    case 103:
    case 106:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 163) = *(_DWORD *)a3;
      break;
    case 104:
      v27 = *(float *)a3;
      *((_DWORD *)this + 103) = *(_DWORD *)a3;
      v28 = (int)(float)((float)(v27 / (float)*((int *)this + 71)) * (float)*((int *)this + 72));
      if (*((_DWORD *)this + 74) - 1 < v28)
        v28 = *((_DWORD *)this + 74) - 1;
      *(float *)&a4 = (float)v28;
      *((float *)this + 164) = (float)v28;
      break;
    case 105:
      LODWORD(a4) = *(_DWORD *)a3;
      *((_DWORD *)this + 165) = *(_DWORD *)a3;
      break;
    case 107:
      *((_DWORD *)this + 104) = *(_DWORD *)a3;
      break;
    default:
      return *(float *)&a4;
  }
  return *(float *)&a4;
}

void AUSubBandMultEchoCanceler::~AUSubBandMultEchoCanceler(AUSubBandMultEchoCanceler *this)
{
  AUSubBandMultEchoCanceler::~AUSubBandMultEchoCanceler(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  *(_QWORD *)this = &off_1E69C7B40;
  freeMatrix(*((_DWORD *)this + 928), (float ***)this + 463);
  AUsubMAEC::myAecCore::~myAecCore((AUSubBandMultEchoCanceler *)((char *)this + 568));
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUSubBandMultEchoCanceler::Initialize(AUSubBandMultEchoCanceler *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  double v7;
  unsigned int v8;
  double v9;
  double v10;

  v2 = *((_QWORD *)this + 15);
  if (v2)
    LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  else
    v3 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  v4 = *((_QWORD *)this + 21);
  if (v4)
    LODWORD(v5) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  else
    v5 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
  if (v3 >= 2)
  {
    v6 = 1;
    do
    {
      v7 = *(double *)(ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 80), v6 - 1) + 80);
      if (v7 != *(double *)(ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 80), v6) + 80))
        return 4294956428;
    }
    while ((_DWORD)v3 != ++v6);
  }
  if (v5 >= 2)
  {
    v8 = 1;
    do
    {
      v9 = *(double *)(ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 128), v8 - 1) + 80);
      if (v9 != *(double *)(ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 128), v8) + 80))
        return 4294956428;
    }
    while ((_DWORD)v5 != ++v8);
  }
  v10 = *(double *)(ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 80), 0) + 80);
  if (v10 != *(double *)(ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 128), 0) + 80))
    return 4294956428;
  *((_DWORD *)this + 134) = *((_DWORD *)this + 133);
  AUSubBandMultEchoCanceler::InitializeEC(this);
  return 0;
}

void AUSubBandMultEchoCanceler::Cleanup(AUSubBandMultEchoCanceler *this)
{
  freeMatrix(*((_DWORD *)this + 928), (float ***)this + 463);
}

uint64_t AUSubBandMultEchoCanceler::Reset(AUSubBandMultEchoCanceler *this)
{
  return 0;
}

uint64_t AUSubBandMultEchoCanceler::GetPropertyInfo(AUSubBandMultEchoCanceler *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  BOOL v7;

  if (a3)
    return 4294956417;
  if (a2 == 21)
  {
    v7 = 1;
  }
  else
  {
    if (a2 != 3700)
      return 4294956417;
    v7 = 0;
  }
  result = 0;
  *a6 = v7;
  *a5 = 4;
  return result;
}

uint64_t AUSubBandMultEchoCanceler::GetProperty(AUSubBandMultEchoCanceler *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  int v7;

  if (a3)
    return 4294956417;
  if (a2 == 3700)
  {
    v7 = *((unsigned __int8 *)this + 376);
    goto LABEL_7;
  }
  if (a2 == 21)
  {
    v7 = (*(uint64_t (**)(AUSubBandMultEchoCanceler *))(*(_QWORD *)this + 576))(this);
LABEL_7:
    result = 0;
    *a5 = v7;
    return result;
  }
  return 4294956417;
}

uint64_t AUSubBandMultEchoCanceler::SetProperty(AUSubBandMultEchoCanceler *this, int a2, int a3, unsigned int a4, int *a5, unsigned int a6)
{
  uint64_t result;
  int v8;
  int v9;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    if (a6 >= 4)
    {
      v8 = *a5;
      v9 = *a5 != 0;
      if (v9 != (*(unsigned int (**)(AUSubBandMultEchoCanceler *))(*(_QWORD *)this + 576))(this))
        (*(void (**)(AUSubBandMultEchoCanceler *, BOOL))(*(_QWORD *)this + 584))(this, v8 != 0);
      return 0;
    }
    else
    {
      return 4294956445;
    }
  }
  return result;
}

uint64_t AUSubBandMultEchoCanceler::SetParameter(AUSubBandMultEchoCanceler *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  _BOOL4 v10;
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  uint64_t v14;
  ausdk::AUElement **v15;

  v10 = (a2 == 2 || (a2 & 0xFFFFFFFD) == 1 || a2 - 11 < 2) && a3 == 0;
  if (!(a3 | a2) || v10)
  {
    if (*((_BYTE *)this + 17))
      ++*((_DWORD *)this + 133);
    v14 = *((_QWORD *)this + 9);
    if (v14)
    {
      Element = (ausdk::AUElement *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v14 + 32))(*((_QWORD *)this + 9), 0);
    }
    else
    {
      v15 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v15)
        Element = 0;
      else
        Element = *v15;
    }
  }
  else
  {
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  }
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  return 0;
}

uint64_t AUSubBandMultEchoCanceler::CanScheduleParameters(AUSubBandMultEchoCanceler *this)
{
  return 0;
}

uint64_t AUSubBandMultEchoCanceler::ProcessMultipleBufferLists(AUSubBandMultEchoCanceler *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  int v10;
  int *mData;
  BOOL v12;
  unint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  float Parameter;
  float v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  _DWORD *v28;
  uint64_t v29;
  int *v30;
  _DWORD *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  float v38;
  uint64_t v39;
  float *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  const float *v52;
  _DWORD *v53;
  uint64_t v54;
  float *v55;
  int v56;
  _DWORD *v57;
  _DWORD *v58;
  _DWORD *v59;
  _DWORD *v60;
  _DWORD *v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  uint64_t v67;
  float v68;
  float v69;
  uint64_t v70;
  uint64_t v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  double v77;
  double v78;
  float v79;
  float v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  float v84;
  int *v85;
  uint64_t v86;
  uint64_t v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  unsigned int v93;
  uint64_t v97;
  uint64_t v98;
  int *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  int *v105;
  uint64_t v106;
  uint64_t v107;
  AUsubMAEC::myFilter *v108;
  AUsubMAEC::myFilter *v109;
  AUsubMAEC::Kalman *v110;
  float **v111;
  float **v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  size_t v118;
  int *v119;
  int *v120;
  int *v121;
  uint64_t v122;
  int v123;
  uint64_t v124;
  int v125;
  int v126;
  uint64_t v127;
  int v128;
  int v129;
  float *v130;
  float *v131;
  int v132;
  int v133;
  BOOL v134;
  int v135;
  int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  signed int v140;
  uint64_t v141;
  ausdk::AUElement *v142;
  ausdk::AUElement **v143;
  uint64_t v144;
  ausdk::AUElement *v145;
  ausdk::AUElement **v146;
  uint64_t v147;
  ausdk::AUElement *v148;
  ausdk::AUElement **v149;
  AUsubMAEC::Kalman *v150;
  float *v151;
  float *v152;
  float *v153;
  float v154;
  float v155;
  float __A;
  DSPSplitComplex v157;

  if (*((_DWORD *)this + 84) != a3)
    return 4294956422;
  v10 = *((_DWORD *)this + 133);
  if (*((_DWORD *)this + 134) != v10)
  {
    AUSubBandMultEchoCanceler::InitializeEC(this);
    *((_DWORD *)this + 134) = v10;
  }
  mData = (int *)(*a5)->mBuffers[0].mData;
  if (mData)
    v12 = a5[1]->mBuffers[0].mData == 0;
  else
    v12 = 1;
  if (v12)
    return 0xFFFFFFFFLL;
  v151 = (float *)a7[1]->mBuffers[0].mData;
  v152 = (float *)a7[2]->mBuffers[0].mData;
  v153 = (float *)(*a7)->mBuffers[0].mData;
  if (*((_DWORD *)this + 928))
  {
    v14 = 0;
    v15 = 4 * *((_DWORD *)this + 137);
    v16 = 16;
    do
    {
      memcpy(*(void **)(*((_QWORD *)this + 463) + 8 * v14++), *(const void **)((char *)&a5[1]->mNumberBuffers + v16), v15);
      v16 += 16;
    }
    while (v14 < *((unsigned int *)this + 928));
  }
  v17 = *((_QWORD *)this + 463);
  v18 = *((_QWORD *)this + 9);
  if (v18)
  {
    v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
  }
  else
  {
    v20 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v20)
      v19 = 0;
    else
      v19 = *v20;
  }
  Parameter = ausdk::AUElement::GetParameter(v19, 0xAu);
  v22 = *((float *)this + 905);
  if (v22 < *((float *)this + 906))
    *((float *)this + 905) = v22 + (float)(*((float *)this + 880) / 1000.0);
  AUsubMAEC::dftBuffer::GetIndexSequence((_DWORD *)this + 170, 1);
  v23 = *((unsigned int *)this + 874);
  v24 = *((int *)this + 878);
  if ((int)v23 >= 1)
  {
    v25 = 0;
    v26 = ((*((_DWORD *)this + 879) - 1) * v24);
    v27 = (*((_DWORD *)this + 879) - 1) * v24;
    do
    {
      if (v27 >= 1)
      {
        v28 = *(_DWORD **)(*((_QWORD *)this + 88) + 8 * v25);
        v29 = v26;
        do
        {
          *v28 = v28[v24];
          ++v28;
          --v29;
        }
        while (v29);
      }
      if ((int)v24 >= 1)
      {
        v30 = *(int **)(v17 + 8 * v25);
        v31 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 88) + 8 * v25) + 4 * (int)v26);
        v32 = v24;
        do
        {
          v33 = *v30++;
          *v31++ = v33;
          --v32;
        }
        while (v32);
      }
      ++v25;
    }
    while (v25 != v23);
  }
  vDSP_svesq(**((const float ***)this + 88), 1, (float *)this + 930, (int)v24 * (int)v23);
  v155 = 0.0;
  if (*((int *)this + 183) < 1)
  {
    v38 = 0.0;
  }
  else
  {
    v34 = 0;
    v35 = *((_DWORD *)this + 182);
    v36 = *((_DWORD *)this + 188);
    LODWORD(v157.realp) = 0;
    v37 = v36 * v35;
    v38 = 0.0;
    do
    {
      AUsubMAEC::dft::dftAnalysis((AUSubBandMultEchoCanceler *)((char *)this + 576), *(const float **)(*((_QWORD *)this + 88) + 8 * v34), (float *)(*(_QWORD *)(*((_QWORD *)this + 85) + 8 * v34) + 4 * v37), (float *)(*(_QWORD *)(*((_QWORD *)this + 86) + 8 * v34) + 4 * v37), (float *)&v157);
      v38 = v38 + *(float *)&v157.realp;
      ++v34;
    }
    while (v34 < *((int *)this + 183));
  }
  if (*((int *)this + 925) > 1)
    AUsubMAEC::dftBuffer::GetIndexSequence((_DWORD *)this + 170, 0);
  __A = 0.0;
  vDSP_vfill(&__A, *((float **)this + 87), 1, *((int *)this + 188));
  if (*((int *)this + 183) >= 1)
  {
    v39 = 0;
    do
    {
      v40 = *(float **)(*((_QWORD *)this + 86) + 8 * v39);
      v157.realp = *(float **)(*((_QWORD *)this + 85) + 8 * v39);
      v157.imagp = v40;
      vDSP_zvmags(&v157, 1, *((float **)this + 95), 1, *((int *)this + 184) * (uint64_t)*((int *)this + 188));
      if (*((int *)this + 184) >= 1)
      {
        v41 = 0;
        v42 = *((_QWORD *)this + 87);
        do
        {
          v43 = *((_QWORD *)this + 95) + 4 * *((_DWORD *)this + 188) * *(_DWORD *)(*((_QWORD *)this + 89) + 4 * v41);
          vDSP_vadd((const float *)(v42 + 4), 1, (const float *)(v43 + 4), 1, (float *)(v42 + 4), 1, *((int *)this + 187));
          v42 = *((_QWORD *)this + 87);
          *(float *)v42 = *(float *)v43 + *(float *)v42;
          *(float *)(v42 + 4 * *((int *)this + 186)) = *(float *)(v43 + 4 * *((int *)this + 186))
                                                       + *(float *)(v42 + 4 * *((int *)this + 186));
          ++v41;
        }
        while (v41 < *((int *)this + 184));
      }
      if (*((int *)this + 185) >= 1)
      {
        v44 = 0;
        v45 = *((_QWORD *)this + 87);
        do
        {
          v46 = *((_QWORD *)this + 95) + 4 * *((_DWORD *)this + 188) * *(_DWORD *)(*((_QWORD *)this + 90) + 4 * v44);
          vDSP_vadd((const float *)(v45 + 4), 1, (const float *)v46, 1, (float *)(v45 + 4), 1, *((int *)this + 187));
          v45 = *((_QWORD *)this + 87);
          *(float *)v45 = *(float *)(v46 + 4) + *(float *)v45;
          *(float *)(v45 + 4 * *((int *)this + 186)) = *(float *)(v46 + 4 * *((int *)this + 186) - 4)
                                                       + *(float *)(v45 + 4 * *((int *)this + 186));
          ++v44;
          v47 = *((int *)this + 185);
        }
        while (v44 < v47);
        if ((int)v47 >= 1)
        {
          v48 = 0;
          do
          {
            v49 = *((_QWORD *)this + 95) + 4 * *((_DWORD *)this + 188) * *(_DWORD *)(*((_QWORD *)this + 90) + 4 * v48);
            vDSP_vadd((const float *)(v45 + 4), 1, (const float *)(v49 + 8), 1, (float *)(v45 + 4), 1, *((int *)this + 187));
            v45 = *((_QWORD *)this + 87);
            *(float *)v45 = *(float *)(v49 + 8) + *(float *)v45;
            *(float *)(v45 + 4 * *((int *)this + 186)) = *(float *)(v49 + 4 * *((int *)this + 186) - 8)
                                                         + *(float *)(v45 + 4 * *((int *)this + 186));
            ++v48;
          }
          while (v48 < *((int *)this + 185));
        }
      }
      ++v39;
    }
    while (v39 < *((int *)this + 183));
  }
  __A = 1.0e-12;
  vDSP_vsadd(*((const float **)this + 87), 1, &__A, *((float **)this + 87), 1, *((int *)this + 877));
  v50 = *((int *)this + 878);
  v51 = (*((_DWORD *)this + 879) - 1) * v50;
  v52 = (const float *)*((_QWORD *)this + 442);
  if (v51 >= 1)
  {
    v53 = (_DWORD *)*((_QWORD *)this + 442);
    v54 = ((*((_DWORD *)this + 879) - 1) * v50);
    do
    {
      *v53 = v53[v50];
      ++v53;
      --v54;
    }
    while (v54);
  }
  if ((int)v50 >= 1)
  {
    v55 = (float *)&v52[v51];
    v50 = v50;
    do
    {
      v56 = *mData++;
      *(_DWORD *)v55++ = v56;
      --v50;
    }
    while (v50);
  }
  AUsubMAEC::dft::dftAnalysis((AUSubBandMultEchoCanceler *)((char *)this + 576), v52, *((float **)this + 443), *((float **)this + 444), &v155);
  AUsubMAEC::myFilter::runFilter((AUSubBandMultEchoCanceler *)((char *)this + 768), (DSPSplitComplex *)((char *)this + 1000), (DSPSplitComplex *)((char *)this + 1016), *((float ***)this + 85), *((float ***)this + 86), *((int **)this + 89), *((int **)this + 90), *((unsigned __int8 *)this + 570));
  AUsubMAEC::myFilter::runFilter((AUSubBandMultEchoCanceler *)((char *)this + 840), (DSPSplitComplex *)this + 68, (DSPSplitComplex *)this + 69, *((float ***)this + 85), *((float ***)this + 86), *((int **)this + 89), *((int **)this + 90), *((unsigned __int8 *)this + 570));
  AUsubMAEC::myFilter::runFilter((AUSubBandMultEchoCanceler *)((char *)this + 912), (DSPSplitComplex *)((char *)this + 1176), (DSPSplitComplex *)((char *)this + 1192), *((float ***)this + 85), *((float ***)this + 86), *((int **)this + 89), *((int **)this + 90), 0);
  AUsubMAEC::Kalman::runKFFilter((AUSubBandMultEchoCanceler *)((char *)this + 2504), (AUSubBandMultEchoCanceler *)((char *)this + 680), *((DSPSplitComplex *)this + 79), *((DSPSplitComplex *)this + 80), 1, *((unsigned __int8 *)this + 570));
  v150 = (AUSubBandMultEchoCanceler *)((char *)this + 2504);
  *((_OWORD *)this + 174) = *(_OWORD *)((char *)this + 2504);
  AUsubMAEC::Kalman::runKFFilter((AUSubBandMultEchoCanceler *)((char *)this + 2784), (AUSubBandMultEchoCanceler *)((char *)this + 680), *(DSPSplitComplex *)((char *)this + 1352), *(DSPSplitComplex *)((char *)this + 1368), 0, *((unsigned __int8 *)this + 570));
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)((char *)this + 1000), 1, (const DSPSplitComplex *)((char *)this + 1032), 1, *((int *)this + 264));
  v57 = (_DWORD *)*((_QWORD *)this + 130);
  *v57 = 0;
  v57[*((int *)this + 265)] = 0;
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)this + 68, 1, (const DSPSplitComplex *)this + 70, 1, *((int *)this + 286));
  v58 = (_DWORD *)*((_QWORD *)this + 141);
  *v58 = 0;
  v58[*((int *)this + 287)] = 0;
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)((char *)this + 1176), 1, (const DSPSplitComplex *)((char *)this + 1208), 1, *((int *)this + 308));
  v59 = (_DWORD *)*((_QWORD *)this + 152);
  *v59 = 0;
  v59[*((int *)this + 309)] = 0;
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)this + 79, 1, (const DSPSplitComplex *)this + 81, 1, *((int *)this + 330));
  v60 = (_DWORD *)*((_QWORD *)this + 163);
  *v60 = 0;
  v60[*((int *)this + 331)] = 0;
  vDSP_zvsub((const DSPSplitComplex *)((char *)this + 3544), 1, (const DSPSplitComplex *)((char *)this + 1352), 1, (const DSPSplitComplex *)((char *)this + 1384), 1, *((int *)this + 352));
  v61 = (_DWORD *)*((_QWORD *)this + 174);
  *v61 = 0;
  v61[*((int *)this + 353)] = 0;
  v157 = (DSPSplitComplex)*((_OWORD *)this + 81);
  vDSP_zvmags(&v157, 1, *((float **)this + 324), 1, *((int *)this + 641));
  v62 = v155;
  *((float *)this + 375) = v38;
  *((float *)this + 376) = v62;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 1424), *((const float **)this + 129), *((const float **)this + 130), *((const float **)this + 125), *((const float **)this + 126));
  *((float *)this + 429) = v38;
  *((float *)this + 430) = v62;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 1640), *((const float **)this + 140), *((const float **)this + 141), *((const float **)this + 136), *((const float **)this + 137));
  *((float *)this + 483) = v38;
  *((float *)this + 484) = v62;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 1856), *((const float **)this + 151), *((const float **)this + 152), *((const float **)this + 147), *((const float **)this + 148));
  *((float *)this + 537) = v38;
  *((float *)this + 538) = v62;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 2072), *((const float **)this + 162), *((const float **)this + 163), *((const float **)this + 158), *((const float **)this + 159));
  *((float *)this + 591) = v38;
  *((float *)this + 592) = v62;
  AUsubMAEC::learnRate::updateTimeStatistics2((AUSubBandMultEchoCanceler *)((char *)this + 2288), *((const float **)this + 173), *((const float **)this + 174), *((const float **)this + 169), *((const float **)this + 170));
  v63 = *((float *)this + 364);
  if (v63 >= *((float *)this + 472))
    v63 = *((float *)this + 472);
  if (v63 >= *((float *)this + 526))
    v63 = *((float *)this + 526);
  *((float *)this + 904) = v63;
  AUsubMAEC::learnRate::micEchoXcorrForDTD((AUSubBandMultEchoCanceler *)((char *)this + 1424), *(DSPSplitComplex *)((char *)this + 3544), *(DSPSplitComplex *)((char *)this + 1000));
  AUsubMAEC::learnRate::micEchoXcorrForDTD((AUSubBandMultEchoCanceler *)((char *)this + 1856), *(DSPSplitComplex *)((char *)this + 3544), *(DSPSplitComplex *)((char *)this + 1176));
  AUsubMAEC::learnRate::micEchoXcorrForDTD((AUSubBandMultEchoCanceler *)((char *)this + 2072), *(DSPSplitComplex *)((char *)this + 3544), *((DSPSplitComplex *)this + 79));
  *((_DWORD *)this + 362) = *((_DWORD *)this + 524);
  *((_DWORD *)this + 524) = *((_DWORD *)this + 470);
  AUsubMAEC::learnRate::getLeakage((AUSubBandMultEchoCanceler *)((char *)this + 1424), *((float **)this + 129), *((float **)this + 130), *((float **)this + 125), *((float **)this + 126));
  AUsubMAEC::learnRate::getLeakage((AUSubBandMultEchoCanceler *)((char *)this + 2072), *((float **)this + 162), *((float **)this + 163), *((float **)this + 158), *((float **)this + 159));
  *((_DWORD *)this + 931) = *((_DWORD *)this + 524);
  *((_DWORD *)this + 929) = *((unsigned __int8 *)this + 2220);
  vDSP_vdiv(*((const float **)this + 87), 1, *((const float **)this + 178), 1, *((float **)this + 178), 1, *((int *)this + 877));
  if (*((_BYTE *)this + 1884))
  {
    v64 = 0.35;
  }
  else
  {
    if (*((float *)this + 905) >= *((float *)this + 906))
      v65 = -15.0;
    else
      v65 = -5.0;
    if (*((float *)this + 904) >= v65)
      v64 = 0.01;
    else
      v64 = 0.25;
  }
  v154 = v64;
  vDSP_svdiv(&v154, *((const float **)this + 87), 1, *((float **)this + 232), 1, *((int *)this + 877));
  AUsubMAEC::learnRate::adaptFilter((const float **)this + 178, *(DSPSplitComplex *)((char *)this + 1032), (AUSubBandMultEchoCanceler *)((char *)this + 680), (AUSubBandMultEchoCanceler *)((char *)this + 768));
  AUsubMAEC::learnRate::adaptFilter((const float **)this + 232, *(DSPSplitComplex *)((char *)this + 1208), (AUSubBandMultEchoCanceler *)((char *)this + 680), (AUSubBandMultEchoCanceler *)((char *)this + 912));
  v66 = *((float *)this + 379);
  v67 = *((_QWORD *)this + 88);
  v68 = v155;
  v69 = *((float *)this + 692);
  *((float *)this + 693) = v69;
  LODWORD(v157.realp) = 0;
  LODWORD(v70) = *((_DWORD *)this + 638);
  if ((int)v70 < 1)
  {
    v72 = 0.0;
  }
  else
  {
    v71 = 0;
    v72 = 0.0;
    do
    {
      vDSP_measqv(*(const float **)(v67 + 8 * v71), 1, (float *)&v157, *((int *)this + 639));
      v72 = v72 + *(float *)&v157.realp;
      ++v71;
      v70 = *((int *)this + 638);
    }
    while (v71 < v70);
    v69 = *((float *)this + 693);
  }
  v73 = (float)(v72 * (float)(1.0 / (float)(int)v70)) + 1.0e-20;
  v74 = log10f(v73) * 10.0;
  *((float *)this + 692) = v74;
  v75 = *((float *)this + 685);
  if (v69 >= v75 || v74 >= v75)
  {
    v76 = *((float *)this + 684);
    v77 = (float)(v76 * *((float *)this + 650));
    v78 = (float)((float)(1.0 - v76) * (float)(1.0 - *((float *)this + 653)));
    if (v66 >= v68)
      v79 = v68;
    else
      v79 = v66;
    v80 = v77 + v78 * ((v79 + 1.0e-20) / (v38 + 1.0e-20));
    *((float *)this + 650) = v80;
  }
  v81 = *((unsigned int *)this + 641);
  v82 = *((_DWORD *)this + 660);
  if ((int)v81 < 1)
  {
    v84 = 0.0;
  }
  else
  {
    v83 = 0;
    v84 = 0.0;
    do
    {
      if (v82 >= 1)
      {
        v85 = (int *)*((_QWORD *)this + 331);
        v86 = *((unsigned int *)this + 660);
        do
        {
          v87 = *v85++;
          v84 = v84 + *(float *)(*(_QWORD *)(*((_QWORD *)this + 317) + 8 * v83) + 4 * v87);
          --v86;
        }
        while (v86);
      }
      ++v83;
    }
    while (v83 != v81);
  }
  v88 = (float)((float)(1.0 - *((float *)this + 684)) * (float)(v84 / (float)((float)(int)v81 * (float)v82)))
      + (float)(*((float *)this + 684) * *((float *)this + 689));
  *((float *)this + 689) = v88;
  v89 = (v88 + 1.0e-20) / (*((float *)this + 650) + 1.0e-20);
  v90 = log10f(v89) * 10.0;
  v91 = *((float *)this + 690);
  v92 = *((float *)this + 691);
  if (v91 < v92)
  {
    v91 = v91 + *((float *)this + 646);
    *((float *)this + 690) = v91;
  }
  v93 = Parameter;
  if (v90 <= *((float *)this + 686) || v91 <= v92)
  {
    if (v90 < *((float *)this + 687) && v91 > v92 && (int)v81 >= 1)
    {
      v97 = 0;
      do
      {
        vDSP_vclr(*(float **)(*((_QWORD *)this + 317) + 8 * v97), 1, *((int *)this + 694) * (uint64_t)v82);
        vDSP_vclr(*(float **)(*((_QWORD *)this + 318) + 8 * v97), 1, *((int *)this + 694) * (uint64_t)*((int *)this + 660));
        v82 = *((_DWORD *)this + 660);
        if (v82 >= 1)
        {
          v98 = *(_QWORD *)(*((_QWORD *)this + 317) + 8 * v97);
          v99 = (int *)*((_QWORD *)this + 331);
          v100 = *((unsigned int *)this + 660);
          do
          {
            v101 = *v99++;
            *(float *)(v98 + 4 * v101) = *((float *)this + 688) * *((float *)this + 650);
            --v100;
          }
          while (v100);
        }
        ++v97;
      }
      while (v97 < *((int *)this + 641));
    }
  }
  else if ((int)v81 >= 1)
  {
    v102 = 0;
    do
    {
      vDSP_vclr(*(float **)(*((_QWORD *)this + 317) + 8 * v102), 1, *((int *)this + 694) * (uint64_t)*((int *)this + 660));
      vDSP_vclr(*(float **)(*((_QWORD *)this + 318) + 8 * v102), 1, *((int *)this + 694) * (uint64_t)*((int *)this + 660));
      v103 = *((_DWORD *)this + 660);
      if (v103 >= 1)
      {
        v104 = *(_QWORD *)(*((_QWORD *)this + 317) + 8 * v102);
        v105 = (int *)*((_QWORD *)this + 331);
        v106 = *((unsigned int *)this + 660);
        do
        {
          v107 = *v105++;
          *(float *)(v104 + 4 * v107) = *((float *)this + 688) * *((float *)this + 650);
          --v106;
        }
        while (v106);
      }
      vDSP_vclr(*(float **)(*((_QWORD *)this + 315) + 8 * v102), 1, v103);
      vDSP_vclr(*(float **)(*((_QWORD *)this + 316) + 8 * v102++), 1, *((int *)this + 660));
    }
    while (v102 < *((int *)this + 641));
  }
  if (*((_DWORD *)this + 924) == v93)
  {
    *((_DWORD *)this + 924) = 0;
    v109 = (AUSubBandMultEchoCanceler *)((char *)this + 840);
    v108 = (AUSubBandMultEchoCanceler *)((char *)this + 768);
    v110 = (AUSubBandMultEchoCanceler *)((char *)this + 2504);
    if (!v93)
      AUsubMAEC::Kalman::adaptKalmanFilter(v150, *((DSPSplitComplex *)this + 81), *((float **)this + 259));
  }
  else
  {
    v110 = (AUSubBandMultEchoCanceler *)((char *)this + 2504);
    AUsubMAEC::Kalman::adaptKalmanFilter(v150, *((DSPSplitComplex *)this + 81), *((float **)this + 259));
    ++*((_DWORD *)this + 924);
    v109 = (AUSubBandMultEchoCanceler *)((char *)this + 840);
    v108 = (AUSubBandMultEchoCanceler *)((char *)this + 768);
  }
  *((_QWORD *)this + 383) = (char *)this + 984;
  AUsubMAEC::dualEC::dualECProcess((AUSubBandMultEchoCanceler *)((char *)this + 3064), v108, v109, 0, 0, (AUSubBandMultEchoCanceler *)((char *)this + 1424), (AUSubBandMultEchoCanceler *)((char *)this + 1640), (void **)this + 123, (const void **)this + 134, 0);
  *((_QWORD *)this + 410) = (char *)this + 1248;
  AUsubMAEC::dualEC::dualECProcess((AUSubBandMultEchoCanceler *)((char *)this + 3280), 0, 0, v110, (AUSubBandMultEchoCanceler *)((char *)this + 2784), (AUSubBandMultEchoCanceler *)((char *)this + 2072), (AUSubBandMultEchoCanceler *)((char *)this + 2288), (void **)this + 156, (const void **)this + 167, 1);
  v111 = (float **)*((_QWORD *)this + 383);
  v112 = (float **)*((_QWORD *)this + 410);
  v113 = *((float *)this + 486);
  v114 = *((float *)this + 540);
  v115 = log10(*((float *)this + 378) + 1.0e-15) * 10.0;
  v116 = log10(v113 + 1.0e-15) * 10.0;
  v117 = log10(v114 + 1.0e-15) * 10.0;
  v118 = 4 * *((_DWORD *)this + 892) - 4;
  memmove((void *)(*((_QWORD *)this + 449) + 4), *((const void **)this + 449), v118);
  memmove((void *)(*((_QWORD *)this + 448) + 4), *((const void **)this + 448), v118);
  memmove((void *)(*((_QWORD *)this + 450) + 4), *((const void **)this + 450), v118);
  v119 = (int *)*((_QWORD *)this + 448);
  *v119 = (float)(v117 + -1.0) > v116;
  v120 = (int *)*((_QWORD *)this + 449);
  *v120 = (float)(v115 + -1.0) > v116;
  v121 = (int *)*((_QWORD *)this + 450);
  *v121 = (float)(v117 + -1.5) > v115;
  v122 = *((unsigned int *)this + 892);
  if ((int)v122 < 1)
  {
    v126 = 0;
    v123 = 0;
    v129 = 0;
    v130 = v153;
    v131 = v151;
  }
  else
  {
    v123 = 0;
    v124 = *((unsigned int *)this + 892);
    do
    {
      v125 = *v119++;
      v123 += v125;
      --v124;
    }
    while (v124);
    v126 = 0;
    v127 = *((unsigned int *)this + 892);
    do
    {
      v128 = *v120++;
      v126 += v128;
      --v127;
    }
    while (v127);
    v129 = 0;
    v130 = v153;
    v131 = v151;
    do
    {
      v132 = *v121++;
      v129 += v132;
      --v122;
    }
    while (v122);
  }
  v133 = *((_DWORD *)this + 893);
  *((_BYTE *)this + 2100) = v123 > v133;
  *((_BYTE *)this + 1452) = v126 > v133;
  *((_BYTE *)this + 1884) = v123 > v133;
  if (v129 <= v133)
  {
    *((_DWORD *)this + 894) = 0;
    v111 = v112;
    v134 = v123 <= v133;
  }
  else
  {
    *((_DWORD *)this + 894) = 1;
    v134 = v126 <= v133;
  }
  if (!v134)
  {
    v111 = (float **)((char *)this + 1160);
    *((_DWORD *)this + 894) = 2;
  }
  *((_QWORD *)this + 445) = v111;
  AUsubMAEC::myAecCore::sigOLA((AUSubBandMultEchoCanceler *)((char *)this + 568), v111[2], v111[3], *((DSPComplex **)this + 454), *((float **)this + 458), v131);
  AUsubMAEC::myAecCore::sigOLA((AUSubBandMultEchoCanceler *)((char *)this + 568), *((float **)this + 443), *((float **)this + 444), *((DSPComplex **)this + 454), *((float **)this + 461), v152);
  AUsubMAEC::myAecCore::sigOLA((AUSubBandMultEchoCanceler *)((char *)this + 568), *(float **)(*((_QWORD *)this + 445) + 48), *(float **)(*((_QWORD *)this + 445) + 56), *((DSPComplex **)this + 454), *((float **)this + 455), v130);
  v135 = *((_DWORD *)this + 182);
  v136 = v135 + 1;
  v137 = *((_DWORD *)this + 184);
  v138 = ~v135 + (v136 >> 31) + (v136 & ~(v136 >> 31));
  if (v137 <= 1)
    v139 = 1;
  else
    v139 = *((_DWORD *)this + 184);
  v140 = v136 + v137 + v137 * (v138 / v139 + (v136 >> 31));
  do
    v140 -= v137;
  while (v140 >= (int)v137);
  *((_DWORD *)this + 182) = v140;
  v141 = *((_QWORD *)this + 9);
  if (v141)
  {
    v142 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v141 + 32))(v141, 0);
  }
  else
  {
    v143 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v143)
      v142 = 0;
    else
      v142 = *v143;
  }
  ausdk::AUElement::SetParameter(v142, 8u, (float)*((int *)this + 929), 0);
  v144 = *((_QWORD *)this + 9);
  if (v144)
  {
    v145 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v144 + 32))(v144, 0);
  }
  else
  {
    v146 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v146)
      v145 = 0;
    else
      v145 = *v146;
  }
  ausdk::AUElement::SetParameter(v145, 9u, *((float *)this + 930), 0);
  v147 = *((_QWORD *)this + 9);
  if (v147)
  {
    v148 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v147 + 32))(v147, 0);
  }
  else
  {
    v149 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v149)
      v148 = 0;
    else
      v148 = *v149;
  }
  ausdk::AUElement::SetParameter(v148, 7u, *((float *)this + 931), 0);
  return 0;
}

uint64_t AUSubBandMultEchoCanceler::Render(AUSubBandMultEchoCanceler *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  uint64_t Element;
  uint64_t v10;
  ausdk::AUInputElement *v11;
  uint64_t result;
  AudioBufferList *BufferList;

  if (*((_DWORD *)this + 84) != (_DWORD)a4)
    return 4294956422;
  v8 = (AUSubBandMultEchoCanceler *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 80), 0);
  v10 = ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 128), 0);
  if (!ausdk::AUBase::HasInput(this, 0))
    return 4294956420;
  v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  result = ausdk::AUInputElement::PullInput(v11, a2, a3, 0, a4);
  if (!(_DWORD)result)
  {
    BufferList = (AudioBufferList *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    ausdk::AUBufferList::CopyBufferContentsTo((_QWORD *)(Element + 144), BufferList);
    return 0;
  }
  return result;
}

BOOL AUSubBandMultEchoCanceler::BusCountWritable(AUSubBandMultEchoCanceler *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AUSubBandMultEchoCanceler::GetParameterInfo(AUSubBandMultEchoCanceler *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v6;
  AudioUnitParameterUnit v7;
  AudioUnitParameterValue v8;
  AudioUnitParameterValue v9;
  AudioUnitParameterValue v10;
  int v11;

  buffer->flags = 0x40000000;
  buffer->unitName = 0;
  result = 4294956418;
  if (!a2 && a3 <= 0xC)
  {
    v6 = off_1E69C7D90[a3];
    v7 = dword_1B6630354[a3];
    v8 = flt_1B6630388[a3];
    v9 = flt_1B66303BC[a3];
    v10 = flt_1B66303F0[a3];
    v11 = dword_1B6630424[a3];
    buffer->cfNameString = v6;
    buffer->flags = 1207959552;
    CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
    result = 0;
    buffer->unit = v7;
    buffer->minValue = v8;
    buffer->maxValue = v9;
    buffer->defaultValue = v10;
    buffer->flags |= v11;
  }
  return result;
}

uint64_t AUSubBandMultEchoCanceler::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
    ++*((_DWORD *)this + 133);
  return result;
}

double AUSubBandMultEchoCanceler::GetLatency(AUSubBandMultEchoCanceler *this)
{
  return 0.0;
}

double AUSubBandMultEchoCanceler::GetTailTime(AUSubBandMultEchoCanceler *this)
{
  return 0.0;
}

uint64_t AUSubBandMultEchoCanceler::SupportsTail(AUSubBandMultEchoCanceler *this)
{
  return 1;
}

BOOL AUSubBandMultEchoCanceler::StreamFormatWritable(AUSubBandMultEchoCanceler *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUSubBandMultEchoCanceler::SupportedNumChannels(AUSubBandMultEchoCanceler *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUSubBandMultEchoCanceler::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 1;
}

uint64_t AUSubBandMultEchoCanceler::ValidFormat(AUSubBandMultEchoCanceler *this, const AudioStreamBasicDescription *a2, int a3, AudioStreamBasicDescription *a4)
{
  uint64_t result;

  result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if ((_DWORD)result)
  {
    if ((a4->mFormatFlags & 0x20) != 0)
    {
      result = 1;
      if (a3)
        return result;
      goto LABEL_5;
    }
    result = a4->mChannelsPerFrame == 1;
  }
  if (a3)
    return result;
LABEL_5:
  if (a4->mChannelsPerFrame == 1)
    return result;
  else
    return 0;
}

uint64_t AUSubBandMultEchoCanceler::ShouldBypassEffect(AUSubBandMultEchoCanceler *this)
{
  return *((unsigned __int8 *)this + 528);
}

uint64_t AUSubBandMultEchoCanceler::SetBypassEffect(uint64_t this, char a2)
{
  *(_BYTE *)(this + 528) = a2;
  return this;
}

void AUSubBandMultEchoCanceler::InitializeEC(AUSubBandMultEchoCanceler *this)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  uint64_t v5;
  ausdk::AUElement *v6;
  ausdk::AUElement **v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  uint64_t v14;
  ausdk::AUElement *v15;
  ausdk::AUElement **v16;
  uint64_t v17;
  ausdk::AUElement *v18;
  ausdk::AUElement **v19;
  uint64_t v20;
  ausdk::AUElement *v21;
  ausdk::AUElement **v22;
  uint64_t v23;
  ausdk::AUElement *v24;
  ausdk::AUElement **v25;
  uint64_t v26;
  ausdk::AUElement *v27;
  ausdk::AUElement **v28;
  float Parameter;
  unsigned int v30;
  int v31;
  signed int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  __int16 v38;
  char v39;
  int v40;
  float v41;
  int32x2_t v42;
  float v48;
  float v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  int v53;
  size_t v54;
  char *v55;
  char *v56;
  int32x2_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64x2_t v60;
  uint64x2_t v61;
  int32x4_t v62;
  _DWORD *v63;
  int8x16_t v67;
  float32x4_t v68;
  int8x16_t v69;
  float32x4_t v70;
  int8x16_t v71;
  int8x16_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int32x4_t v77;
  int8x16_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float v81;
  float32x4_t v82;
  float v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int16x4_t v90;
  int32x4_t v91;
  void *v92;
  void *v93;
  char *v94;
  char *v95;
  int32x2_t v96;
  int32x2_t v97;
  __int128 v98;
  int v99;
  __int128 v100;
  int v101;
  int v102;
  void *v103;
  void *v104;
  int v105;
  void *v106;
  void *v107;
  int v108;
  void *v109;
  void *v110;
  int v111;
  int v112;
  void *v113;
  void *v114;
  double inited;
  double v116;
  double v117;
  double v118;
  int32x2_t v119;
  int32x2_t v120;
  int v121;
  int v122;
  int v123;
  void *v124;
  void *v125;
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  uint64_t v130;
  void *v131;
  void *v132;
  uint64_t v133;
  char *v134;
  char *v135;
  uint64_t v136;
  size_t v137;
  int v138;
  void *v139;
  void *v140;
  size_t v141;
  void *v142;
  void *v143;
  void *v144;
  void *v145;
  void *v146;
  void *v147;
  void *v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  std::bad_alloc *exception;
  std::bad_alloc *v157;
  int64x2_t v158;
  float32x4_t v159;
  float64x2_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  uint64x2_t v164;
  int8x16_t v165;
  int32x4_t v166;
  int8x16_t v167;
  int32x4_t v168;
  int8x16_t v169;
  int32x4_t v170;
  int64x2_t v171;
  int64x2_t v172;
  float32x4_t v173;
  float v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;

  *((_DWORD *)this + 136) = *(double *)(ausdk::AUScope::SafeGetElement((AUSubBandMultEchoCanceler *)((char *)this + 80), 0)+ 80);
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v4 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  *((_DWORD *)this + 138) = ausdk::AUElement::GetParameter(v3, 2u);
  v5 = *((_QWORD *)this + 9);
  if (v5)
  {
    v6 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
  }
  else
  {
    v7 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v7)
      v6 = 0;
    else
      v6 = *v7;
  }
  *((_DWORD *)this + 135) = ausdk::AUElement::GetParameter(v6, 0);
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  *((_DWORD *)this + 140) = ausdk::AUElement::GetParameter(v9, 1u);
  v11 = *((_QWORD *)this + 9);
  if (v11)
  {
    v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
  }
  else
  {
    v13 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v13)
      v12 = 0;
    else
      v12 = *v13;
  }
  *((_DWORD *)this + 137) = ausdk::AUElement::GetParameter(v12, 3u);
  v14 = *((_QWORD *)this + 9);
  if (v14)
  {
    v15 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 32))(v14, 0);
  }
  else
  {
    v16 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v16)
      v15 = 0;
    else
      v15 = *v16;
  }
  *((_BYTE *)this + 556) = ausdk::AUElement::GetParameter(v15, 4u) != 0.0;
  v17 = *((_QWORD *)this + 9);
  if (v17)
  {
    v18 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 32))(v17, 0);
  }
  else
  {
    v19 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v19)
      v18 = 0;
    else
      v18 = *v19;
  }
  *((_BYTE *)this + 557) = ausdk::AUElement::GetParameter(v18, 5u) != 0.0;
  v20 = *((_QWORD *)this + 9);
  if (v20)
  {
    v21 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 32))(v20, 0);
  }
  else
  {
    v22 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v22)
      v21 = 0;
    else
      v21 = *v22;
  }
  *((_BYTE *)this + 558) = ausdk::AUElement::GetParameter(v21, 6u) != 0.0;
  v23 = *((_QWORD *)this + 9);
  if (v23)
  {
    v24 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
  }
  else
  {
    v25 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v25)
      v24 = 0;
    else
      v24 = *v25;
  }
  *((_DWORD *)this + 928) = ausdk::AUElement::GetParameter(v24, 0xBu);
  v26 = *((_QWORD *)this + 9);
  if (v26)
  {
    v27 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 32))(v26, 0);
  }
  else
  {
    v28 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v28)
      v27 = 0;
    else
      v27 = *v28;
  }
  Parameter = ausdk::AUElement::GetParameter(v27, 0xCu);
  *((_DWORD *)this + 141) = Parameter;
  if ((Parameter | 2) != 3)
    *((_DWORD *)this + 141) = 1;
  v30 = *((_DWORD *)this + 928);
  if (v30 >= 3)
    *((_DWORD *)this + 140) = 1;
  v31 = *((_DWORD *)this + 137);
  if (*((_DWORD *)this + 138) < (2 * v31))
    *((_DWORD *)this + 138) = 2 * v31;
  *((_QWORD *)this + 463) = allocMatrix(v30, v31);
  v32 = *((_DWORD *)this + 138);
  v33 = *((_DWORD *)this + 137);
  v34 = *((_DWORD *)this + 136);
  v35 = *((_DWORD *)this + 928);
  v36 = *((_DWORD *)this + 135);
  v37 = *((_DWORD *)this + 140);
  v38 = *((_WORD *)this + 278);
  v39 = *((_BYTE *)this + 558);
  v40 = *((_DWORD *)this + 141);
  fwrite("Initializing EC", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
  *((_WORD *)this + 284) = v38;
  *((_BYTE *)this + 570) = v39;
  *((_DWORD *)this + 156) = v35;
  *((_DWORD *)this + 153) = v37;
  *((_DWORD *)this + 149) = v33;
  *((_DWORD *)this + 146) = v32;
  *((_DWORD *)this + 147) = v32 >> 1;
  *((_DWORD *)this + 148) = (v32 >> 1) - 1;
  *((_DWORD *)this + 150) = (v32 >> 1) + 1;
  *((_DWORD *)this + 161) = (int)(float)(v32 / v33);
  *((_DWORD *)this + 160) = v40;
  v41 = (float)v33;
  *(float *)v42.i32 = (float)v32;
  __asm { FMOV            V3.2S, #1.0 }
  _D3.f32[0] = v41 + v41;
  *((float32x2_t *)this + 77) = vdiv_f32(_D3, (float32x2_t)vdup_lane_s32(v42, 0));
  *((_DWORD *)this + 152) = v34;
  if (v34 < 1)
    v48 = 0.0;
  else
    v48 = (float)(v41 / (float)v34) * 1000.0;
  *((float *)this + 151) = v48;
  MultiRadixRealFFT_Create(v32, (MultiRadixRealFFT **)this + 72);
  v49 = (float)v36 / *((float *)this + 151);
  v50 = vcvtps_s32_f32(v49);
  *((_DWORD *)this + 157) = v50;
  v51 = vcvtps_s32_f32((float)(int)ceilf(v49) * 0.5);
  v52 = *((_DWORD *)this + 160) - 1;
  if (*((_DWORD *)this + 160) == 1)
    v51 = 0;
  *((_DWORD *)this + 158) = v51;
  *((_DWORD *)this + 159) = (v50 + v51 * v52) * *((_DWORD *)this + 156);
  v53 = 4 * *((_DWORD *)this + 146);
  v54 = v53;
  v55 = (char *)malloc_type_malloc(v53, 0x2C8E6D5CuLL);
  v56 = v55;
  if (v53 && !v55)
    goto LABEL_115;
  bzero(v55, v53);
  *((_QWORD *)this + 81) = v56;
  v58 = *((unsigned int *)this + 146);
  if ((int)v58 >= 1)
  {
    *(float *)v57.i32 = (float)(int)v58;
    v163 = (float32x4_t)vdupq_lane_s32(v57, 0);
    v164 = (uint64x2_t)vdupq_n_s64(v58 - 1);
    v59 = (v58 + 3) & 0x1FFFFFFFCLL;
    v60 = (uint64x2_t)xmmword_1B6627110;
    v61 = (uint64x2_t)xmmword_1B6626830;
    v62 = (int32x4_t)xmmword_1B6626920;
    v63 = v56 + 8;
    __asm { FMOV            V1.4S, #4.0 }
    v162 = _Q1;
    __asm { FMOV            V1.4S, #1.0 }
    v173 = _Q1;
    __asm { FMOV            V4.4S, #3.0 }
    v160 = (float64x2_t)vdupq_n_s64(0x3FF459A5D6E6692DuLL);
    v161 = _Q4;
    v158 = vdupq_n_s64(4uLL);
    v159 = (float32x4_t)vdupq_n_s32(0x3FC90FDBu);
    do
    {
      v171 = (int64x2_t)v61;
      v172 = (int64x2_t)v60;
      v67 = (int8x16_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v164, v61), (int32x4_t)vcgeq_u64(v164, v60));
      v170 = v62;
      v68 = vdivq_f32(vmulq_f32(vcvtq_f32_s32(v62), v162), v163);
      v69 = (int8x16_t)vcgtq_f32(v173, v68);
      v70.i64[0] = 0x4000000040000000;
      v70.i64[1] = 0x4000000040000000;
      v71 = (int8x16_t)vcgtq_f32(v70, v68);
      v72 = (int8x16_t)vcgtq_f32(v161, v68);
      v73 = vsubq_f32(v70, v68);
      v74.i64[0] = 0xC0000000C0000000;
      v74.i64[1] = 0xC0000000C0000000;
      v75 = vandq_s8(v67, v69);
      v76 = vbicq_s8(v67, v69);
      v77 = (int32x4_t)vandq_s8(v76, v71);
      v78 = vbicq_s8(v76, v71);
      v168 = (int32x4_t)vandq_s8(v78, v72);
      v169 = v75;
      v166 = (int32x4_t)vbicq_s8(v78, v72);
      v167 = (int8x16_t)v77;
      v79 = (float32x4_t)vbslq_s8((int8x16_t)v166, (int8x16_t)vaddq_f32(v73, v70), vbslq_s8((int8x16_t)v168, (int8x16_t)vaddq_f32(v68, v74), vbslq_s8((int8x16_t)v77, (int8x16_t)v73, (int8x16_t)v68)));
      v165 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vorn_s8((int8x8_t)vmovn_s32(v166), vorr_s8((int8x8_t)vmovn_s32(v168), (int8x8_t)vmovn_s32(v77)))), 0x1FuLL));
      v177 = vmulq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v79.f32), v160)), vmulq_f64(vcvt_hight_f64_f32(v79), v160)), v159);
      v174 = cosf(v177.f32[1]);
      v80.f32[0] = cosf(v177.f32[0]);
      v80.f32[1] = v174;
      v175 = v80;
      v81 = cosf(v177.f32[2]);
      v82 = v175;
      v82.f32[2] = v81;
      v176 = v82;
      v83 = cosf(v177.f32[3]);
      v84 = v176;
      v84.f32[3] = v83;
      v85.i64[0] = 0x3F0000003F000000;
      v85.i64[1] = 0x3F0000003F000000;
      v86.i64[0] = 0xBF000000BF000000;
      v86.i64[1] = 0xBF000000BF000000;
      v87 = vmlaq_f32(v85, v86, v84);
      v88 = vmulq_f32(v87, v87);
      v89 = vsqrtq_f32((float32x4_t)vbslq_s8(v165, (int8x16_t)v88, (int8x16_t)vsubq_f32(v173, v88)));
      v90 = vmovn_s32((int32x4_t)vorrq_s8(vorrq_s8((int8x16_t)v166, vorrq_s8(v169, v167)), (int8x16_t)v168));
      if ((v90.i8[0] & 1) != 0)
        *(v63 - 2) = v89.i32[0];
      if ((v90.i8[2] & 1) != 0)
        *(v63 - 1) = v89.i32[1];
      if ((v90.i8[4] & 1) != 0)
        *v63 = v89.i32[2];
      if ((v90.i8[6] & 1) != 0)
        v63[1] = v89.i32[3];
      v60 = (uint64x2_t)vaddq_s64(v172, v158);
      v61 = (uint64x2_t)vaddq_s64(v171, v158);
      v91.i64[0] = 0x400000004;
      v91.i64[1] = 0x400000004;
      v62 = vaddq_s32(v170, v91);
      v63 += 4;
      v59 -= 4;
    }
    while (v59);
  }
  v92 = malloc_type_malloc(v54, 0x2C8E6D5CuLL);
  v93 = v92;
  if ((_DWORD)v54)
  {
    if (!v92)
      goto LABEL_115;
  }
  bzero(v92, v54);
  *((_QWORD *)this + 82) = v93;
  v94 = (char *)malloc_type_malloc(v54, 0x2C8E6D5CuLL);
  v95 = v94;
  if ((_DWORD)v54)
  {
    if (!v94)
      goto LABEL_115;
  }
  bzero(v94, v54);
  v96 = *(int32x2_t *)((char *)this + 584);
  v97 = *(int32x2_t *)((char *)this + 596);
  *(int32x2_t *)&v98 = v96;
  *((int32x2_t *)&v98 + 1) = vrev64_s32(v97);
  *((_QWORD *)this + 83) = v95;
  *((_QWORD *)this + 84) = &v95[4 * v96.i32[1]];
  v99 = *((_DWORD *)this + 156);
  *((_DWORD *)this + 874) = v99;
  *(_OWORD *)((char *)this + 3500) = v98;
  *((_DWORD *)this + 879) = *((_DWORD *)this + 161);
  *((_DWORD *)this + 881) = *((_DWORD *)this + 153);
  *((_DWORD *)this + 880) = *((_DWORD *)this + 151);
  *((_DWORD *)this + 925) = *((_DWORD *)this + 160);
  *(_QWORD *)&v100 = *(_QWORD *)((char *)this + 628);
  *((_DWORD *)this + 882) = v100;
  DWORD2(v100) = vdup_lane_s32(v96, 1).u32[0];
  HIDWORD(v100) = *((_DWORD *)this + 148);
  *((_DWORD *)this + 183) = v99;
  *((_OWORD *)this + 46) = v100;
  *((int8x8_t *)this + 94) = vext_s8((int8x8_t)v97, (int8x8_t)v96, 4uLL);
  v101 = v97.i32[1] * v100;
  *((_QWORD *)this + 85) = allocMatrix(v99, v97.i32[1] * (int)v100);
  *((_QWORD *)this + 86) = allocMatrix(*((_DWORD *)this + 183), v101);
  *((_QWORD *)this + 88) = allocMatrix(*((_DWORD *)this + 183), *((_DWORD *)this + 189));
  *((_DWORD *)this + 182) = 0;
  v102 = 4 * *((_DWORD *)this + 188);
  v103 = malloc_type_malloc(v102, 0x2C8E6D5CuLL);
  v104 = v103;
  if (v102)
  {
    if (!v103)
      goto LABEL_115;
  }
  bzero(v103, v102);
  *((_QWORD *)this + 87) = v104;
  v105 = 4 * *((_DWORD *)this + 188) * *((_DWORD *)this + 184);
  v106 = malloc_type_malloc(v105, 0x2C8E6D5CuLL);
  v107 = v106;
  if (v105)
  {
    if (!v106)
      goto LABEL_115;
  }
  bzero(v106, v105);
  *((_QWORD *)this + 95) = v107;
  v108 = 4 * *((_DWORD *)this + 184);
  v109 = malloc_type_malloc(v108, 0x2C8E6D5CuLL);
  v110 = v109;
  if (v108)
  {
    if (!v109)
      goto LABEL_115;
  }
  bzero(v109, v108);
  *((_QWORD *)this + 89) = v110;
  v111 = *((_DWORD *)this + 185);
  if (v111)
  {
    v112 = 4 * v111;
    v113 = malloc_type_malloc(4 * v111, 0x2C8E6D5CuLL);
    v114 = v113;
    if (v112 && !v113)
      goto LABEL_115;
    bzero(v113, v112);
    *((_QWORD *)this + 90) = v114;
  }
  AUsubMAEC::myFilter::initFilter((uint64_t)this + 768, (_DWORD *)this + 144);
  AUsubMAEC::myFilter::initFilter((uint64_t)this + 840, (_DWORD *)this + 144);
  AUsubMAEC::myFilter::initFilter((uint64_t)this + 912, (_DWORD *)this + 144);
  AUsubMAEC::myAecBuffers::myAecBuffersInit((uint64_t)this + 984, (_DWORD *)this + 144, *((unsigned __int8 *)this + 570));
  AUsubMAEC::myAecBuffers::myAecBuffersInit((uint64_t)this + 1072, (_DWORD *)this + 144, *((unsigned __int8 *)this + 570));
  AUsubMAEC::myAecBuffers::myAecBuffersInit((uint64_t)this + 1160, (_DWORD *)this + 144, 0);
  AUsubMAEC::myAecBuffers::myAecBuffersInit((uint64_t)this + 1248, (_DWORD *)this + 144, *((unsigned __int8 *)this + 570));
  AUsubMAEC::myAecBuffers::myAecBuffersInit((uint64_t)this + 1336, (_DWORD *)this + 144, *((unsigned __int8 *)this + 570));
  AUsubMAEC::learnRate::initStatistics((uint64_t)this + 1424, (_DWORD *)this + 144);
  AUsubMAEC::learnRate::initStatistics((uint64_t)this + 1640, (_DWORD *)this + 144);
  AUsubMAEC::learnRate::initStatistics((uint64_t)this + 1856, (_DWORD *)this + 144);
  AUsubMAEC::learnRate::initStatistics((uint64_t)this + 2072, (_DWORD *)this + 144);
  AUsubMAEC::learnRate::initStatistics((uint64_t)this + 2288, (_DWORD *)this + 144);
  AUsubMAEC::Kalman::initKalman((uint64_t)this + 2504, (_DWORD *)this + 144, 0);
  inited = AUsubMAEC::Kalman::initKalman((uint64_t)this + 2784, (_DWORD *)this + 144, 1);
  AUsubMAEC::dualEC::initDualEC((uint64_t)this + 3064, (_DWORD *)this + 144, inited, v116);
  AUsubMAEC::dualEC::initDualEC((uint64_t)this + 3280, (_DWORD *)this + 144, v117, v118);
  v119.i32[0] = *((_DWORD *)this + 151);
  *((_DWORD *)this + 902) = v119.i32[0];
  v120 = vcvt_s32_f32(vrndp_f32(vdiv_f32((float32x2_t)0x42B4000042C80000, (float32x2_t)vdup_lane_s32(v119, 0))));
  *((int32x2_t *)this + 446) = v120;
  v121 = v120.i32[0];
  if (v120.i32[1] > v120.i32[0])
  {
    v121 = v120.i32[1] + 1;
    *((_DWORD *)this + 892) = v120.i32[1] + 1;
  }
  v122 = 4 * v121;
  v123 = 4 * v121;
  v124 = malloc_type_malloc(4 * v121, 0x2C8E6D5CuLL);
  v125 = v124;
  if (v122)
  {
    if (!v124)
      goto LABEL_115;
  }
  bzero(v124, v122);
  *((_QWORD *)this + 450) = v125;
  v126 = malloc_type_malloc(v122, 0x2C8E6D5CuLL);
  v127 = v126;
  if (v123)
  {
    if (!v126)
      goto LABEL_115;
  }
  bzero(v126, v122);
  *((_QWORD *)this + 448) = v127;
  v128 = malloc_type_malloc(v122, 0x2C8E6D5CuLL);
  v129 = v128;
  if (v123)
  {
    if (!v128)
      goto LABEL_115;
  }
  bzero(v128, v122);
  *((_QWORD *)this + 449) = v129;
  *((_DWORD *)this + 894) = 0;
  v130 = *((int *)this + 875);
  v131 = malloc_type_malloc(4 * v130, 0x2C8E6D5CuLL);
  v132 = v131;
  if ((_DWORD)v130)
  {
    if (!v131)
      goto LABEL_115;
  }
  bzero(v131, 4 * v130);
  *((_QWORD *)this + 442) = v132;
  v133 = *((int *)this + 877);
  v134 = (char *)malloc_type_malloc(8 * v133, 0x2C8E6D5CuLL);
  v135 = v134;
  if ((_DWORD)v133)
  {
    if (!v134)
      goto LABEL_115;
  }
  bzero(v134, 8 * v133);
  *((_QWORD *)this + 443) = v135;
  *((_QWORD *)this + 444) = &v135[4 * *((int *)this + 877)];
  *((_QWORD *)this + 452) = 0;
  *((_DWORD *)this + 906) = 1082130432;
  v136 = *((int *)this + 875);
  v137 = 4 * v136;
  v138 = *((_DWORD *)this + 878);
  v139 = malloc_type_malloc(4 * v136, 0x2C8E6D5CuLL);
  v140 = v139;
  if ((_DWORD)v136)
  {
    if (!v139)
      goto LABEL_115;
  }
  v141 = ((int)v136 / v138 * v137);
  bzero(v139, v137);
  *((_QWORD *)this + 454) = v140;
  v142 = malloc_type_malloc(v141, 0x2C8E6D5CuLL);
  v143 = v142;
  if ((_DWORD)v141)
  {
    if (!v142)
      goto LABEL_115;
  }
  bzero(v142, v141);
  *((_QWORD *)this + 455) = v143;
  v144 = malloc_type_malloc(v141, 0x2C8E6D5CuLL);
  v145 = v144;
  if ((_DWORD)v141)
  {
    if (!v144)
      goto LABEL_115;
  }
  bzero(v144, v141);
  *((_QWORD *)this + 456) = v145;
  v146 = malloc_type_malloc(v141, 0x2C8E6D5CuLL);
  v147 = v146;
  if ((_DWORD)v141)
  {
    if (!v146)
      goto LABEL_115;
  }
  bzero(v146, v141);
  *((_QWORD *)this + 457) = v147;
  v148 = malloc_type_malloc(v141, 0x2C8E6D5CuLL);
  v149 = v148;
  if ((_DWORD)v141)
  {
    if (!v148)
      goto LABEL_115;
  }
  bzero(v148, v141);
  *((_QWORD *)this + 458) = v149;
  v150 = malloc_type_malloc(v141, 0x2C8E6D5CuLL);
  v151 = v150;
  if ((_DWORD)v141)
  {
    if (!v150)
      goto LABEL_115;
  }
  bzero(v150, v141);
  *((_QWORD *)this + 461) = v151;
  *(_OWORD *)((char *)this + 3672) = 0u;
  if (!*((_BYTE *)this + 570))
    return;
  if ((v152 = malloc_type_malloc(v141, 0x2C8E6D5CuLL), v153 = v152, (_DWORD)v141) && !v152
    || (bzero(v152, v141),
        *((_QWORD *)this + 459) = v153,
        v154 = malloc_type_malloc(v141, 0x2C8E6D5CuLL),
        v155 = v154,
        (_DWORD)v141)
    && !v154)
  {
LABEL_115:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v157 = std::bad_alloc::bad_alloc(exception);
  }
  bzero(v154, v141);
  *((_QWORD *)this + 460) = v155;
}

BOOL ChannelLayoutTagIsSupportedHOA(int a1)
{
  double v2;

  if (a1 == 7012356)
    return 1;
  if ((a1 & 0xFFFE0000 | 0x10000) != 0xBF0000 || (unsigned __int16)a1 - 65026 < 0xFFFF01FF)
    return 0;
  v2 = sqrt((double)(unsigned __int16)a1);
  return vabdd_f64(v2, round(v2)) <= 0.000000999999997;
}

uint64_t GetHOAOrderForNumberOfChannels(unsigned int a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  BOOL v6;

  v1 = 0x40000000;
  do
  {
    v2 = v1;
    v1 >>= 2;
  }
  while (v2 > a1);
  v3 = 0;
  if (v2)
  {
    do
    {
      v4 = v3 + v2;
      v5 = 2 * v2;
      if (a1 < v3 + v2)
      {
        v4 = 0;
        v5 = 0;
      }
      a1 -= v4;
      v3 = (v5 + v3) >> 1;
      v6 = v2 > 3;
      v2 >>= 2;
    }
    while (v6);
  }
  if (v3)
    return v3 - 1;
  else
    return 0;
}

uint64_t std::map<std::string,unsigned int>::map[abi:ne180100](uint64_t a1, __int128 *a2, uint64_t a3)
{
  _QWORD *v4;
  __int128 *v5;
  __int128 *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;
  char **v11;
  char *v12;
  std::string *v13;
  __int128 v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v18;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v5 = a2;
    v6 = &a2[2 * a3];
    do
    {
      v7 = *(_QWORD **)(a1 + 8);
      if (*(_QWORD **)a1 == v4)
      {
        v9 = v4;
        if (!v7)
          goto LABEL_15;
      }
      else
      {
        v8 = v4;
        if (v7)
        {
          do
          {
            v9 = v7;
            v7 = (_QWORD *)v7[1];
          }
          while (v7);
        }
        else
        {
          do
          {
            v9 = (_QWORD *)v8[2];
            v10 = *v9 == (_QWORD)v8;
            v8 = v9;
          }
          while (v10);
        }
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v9 + 4, (void **)v5) & 0x80) == 0)
        {
          v11 = (char **)std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__find_equal<std::string>(a1, &v18, (void **)v5);
          goto LABEL_12;
        }
        if (!*v4)
        {
LABEL_15:
          v18 = v4;
          v11 = (char **)v4;
LABEL_16:
          v12 = (char *)operator new(0x40uLL);
          v13 = (std::string *)(v12 + 32);
          if (*((char *)v5 + 23) < 0)
          {
            std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)v5, *((_QWORD *)v5 + 1));
          }
          else
          {
            v14 = *v5;
            *((_QWORD *)v12 + 6) = *((_QWORD *)v5 + 2);
            *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
          }
          *((_DWORD *)v12 + 14) = *((_DWORD *)v5 + 6);
          v15 = v18;
          *(_QWORD *)v12 = 0;
          *((_QWORD *)v12 + 1) = 0;
          *((_QWORD *)v12 + 2) = v15;
          *v11 = v12;
          v16 = **(_QWORD **)a1;
          if (v16)
          {
            *(_QWORD *)a1 = v16;
            v12 = *v11;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 8), (uint64_t *)v12);
          ++*(_QWORD *)(a1 + 16);
          goto LABEL_22;
        }
      }
      v18 = v9;
      v11 = (char **)(v9 + 1);
LABEL_12:
      if (!*v11)
        goto LABEL_16;
LABEL_22:
      v5 += 2;
    }
    while (v5 != v6);
  }
  return a1;
}

void sub_1B612A8E8(_Unwind_Exception *a1)
{
  void *v1;
  char **v2;

  operator delete(v1);
  std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(*v2);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::basic_istringstream[abi:ne180100](uint64_t a1, const std::string *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  std::string::size_type v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;

  v4 = MEMORY[0x1E0DE4FD8];
  v5 = MEMORY[0x1E0DE4FD8] + 64;
  *(_QWORD *)(a1 + 120) = MEMORY[0x1E0DE4FD8] + 64;
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 8);
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 16);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = v7;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 16));
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v4 + 24;
  *(_QWORD *)(a1 + 120) = v5;
  std::streambuf::basic_streambuf();
  v9 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 16) = v9;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 8;
  std::string::operator=((std::string *)(a1 + 80), a2);
  *(_QWORD *)(a1 + 104) = 0;
  v10 = *(_BYTE *)(a1 + 103);
  if (v10 < 0)
  {
    v11 = *(_QWORD *)(a1 + 80);
    v12 = *(_QWORD *)(a1 + 88);
  }
  else
  {
    v11 = a1 + 80;
    v12 = *(unsigned __int8 *)(a1 + 103);
  }
  v13 = *(_DWORD *)(a1 + 112);
  if ((v13 & 8) != 0)
  {
    *(_QWORD *)(a1 + 104) = v11 + v12;
    *(_QWORD *)(a1 + 32) = v11;
    *(_QWORD *)(a1 + 40) = v11;
    *(_QWORD *)(a1 + 48) = v11 + v12;
  }
  if ((v13 & 0x10) != 0)
  {
    *(_QWORD *)(a1 + 104) = v11 + v12;
    v14 = v10 < 0 ? (*(_QWORD *)(a1 + 96) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize((std::string *)(a1 + 80), v14, 0);
    v15 = *(char *)(a1 + 103) < 0 ? *(_QWORD *)(a1 + 88) : *(unsigned __int8 *)(a1 + 103);
    *(_QWORD *)(a1 + 56) = v11;
    *(_QWORD *)(a1 + 64) = v11;
    *(_QWORD *)(a1 + 72) = v11 + v15;
    if ((*(_BYTE *)(a1 + 112) & 3) != 0)
    {
      if (v12 >> 31)
      {
        v16 = ((v12 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        v17 = 0x7FFFFFFF * ((v16 + ((v12 - 0x80000000 - v16) >> 1)) >> 30);
        v11 += v17 + 0x7FFFFFFF;
        v12 = v12 - v17 - 0x7FFFFFFF;
        *(_QWORD *)(a1 + 64) = v11;
      }
      if (v12)
        *(_QWORD *)(a1 + 64) = v11 + v12;
    }
  }
  return a1;
}

void sub_1B612AAD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::istream::~istream();
  MEMORY[0x1BCC95BE4](v1);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::~istringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F58];
  v3 = *MEMORY[0x1E0DE4F58];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F58];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 16) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1BCC95BE4](a1 + 120);
  return a1;
}

void std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(*(_QWORD *)a1);
    std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy(*((_QWORD *)a1 + 1));
    if (a1[55] < 0)
      operator delete(*((void **)a1 + 4));
    operator delete(a1);
  }
}

void GetStringFromAudioChannelLayoutTag(_QWORD *a1, int a2)
{
  unsigned __int16 v2;
  unsigned int v4;
  int v5;
  BOOL v6;
  std::string *v7;
  __int128 v8;
  std::string *p_p;
  std::string::size_type size;
  std::string *v11;
  __int128 v12;
  int v13;
  BOOL v14;
  char *v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  std::string __p;
  std::string v21;
  std::string v22;

  v2 = a2;
  v4 = a2 & 0xFFFF0000;
  if ((a2 & 0xFFFF0000) == 0x930000)
  {
    std::string::basic_string[abi:ne180100]<0>(&v21, "DiscreteInOrder");
    v11 = std::string::append(&v21, " ", 1uLL);
    v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, v2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
  }
  else if (v4 == 12517376)
  {
    v13 = llroundf(sqrtf((float)(unsigned __int16)a2));
    if (v13)
      v14 = v13 * v13 == (unsigned __int16)a2;
    else
      v14 = 0;
    if (!v14)
      goto LABEL_25;
    std::string::basic_string[abi:ne180100]<0>(&v21, "HOA_ACN_N3D");
    v16 = std::string::append(&v21, " ", 1uLL);
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, v13 - 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
  }
  else
  {
    if (v4 != 12451840)
    {
      if (a2 <= 10027011)
      {
        if (a2 > 8126469)
        {
          if (a2 <= 9043972)
          {
            if (a2 > 8585218)
            {
              if (a2 <= 8781827)
              {
                switch(a2)
                {
                  case 8585219:
                    v15 = "ITU_2_1";
                    goto LABEL_26;
                  case 8650756:
                    v15 = "ITU_2_2";
                    goto LABEL_26;
                  case 8716291:
                    v15 = "DVD_4";
                    goto LABEL_26;
                }
              }
              else if (a2 > 8912899)
              {
                if (a2 == 8912900)
                {
                  v15 = "DVD_10";
                  goto LABEL_26;
                }
                if (a2 == 8978437)
                {
                  v15 = "DVD_11";
                  goto LABEL_26;
                }
              }
              else
              {
                if (a2 == 8781828)
                {
                  v15 = "DVD_5";
                  goto LABEL_26;
                }
                if (a2 == 8847365)
                {
                  v15 = "DVD_6";
                  goto LABEL_26;
                }
              }
            }
            else if (a2 <= 8323079)
            {
              switch(a2)
              {
                case 8126470:
                  v15 = "MPEG_5_1_D";
                  goto LABEL_26;
                case 8192007:
                  v15 = "MPEG_6_1_A";
                  goto LABEL_26;
                case 8257544:
                  v15 = "MPEG_7_1_A";
                  goto LABEL_26;
              }
            }
            else if (a2 > 8454151)
            {
              if (a2 == 8454152)
              {
                v15 = "Emagic_Default_7_1";
                goto LABEL_26;
              }
              if (a2 == 8519688)
              {
                v15 = "SMPTE_DTV";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 8323080)
              {
                v15 = "MPEG_7_1_B";
                goto LABEL_26;
              }
              if (a2 == 8388616)
              {
                v15 = "MPEG_7_1_C";
                goto LABEL_26;
              }
            }
          }
          else if (a2 <= 9502735)
          {
            if (a2 <= 9240581)
            {
              switch(a2)
              {
                case 9043973:
                  v15 = "DVD_18";
                  goto LABEL_26;
                case 9109510:
                  v15 = "AudioUnit_6_0";
                  goto LABEL_26;
                case 9175047:
                  v15 = "AudioUnit_7_0";
                  goto LABEL_26;
              }
            }
            else if (a2 > 9371654)
            {
              if (a2 == 9371655)
              {
                v15 = "AAC_7_0";
                goto LABEL_26;
              }
              if (a2 == 9437192)
              {
                v15 = "AAC_Octagonal";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 9240582)
              {
                v15 = "AAC_6_0";
                goto LABEL_26;
              }
              if (a2 == 9306119)
              {
                v15 = "AAC_6_1";
                goto LABEL_26;
              }
            }
          }
          else if (a2 > 9764865)
          {
            if (a2 > 9895939)
            {
              if (a2 == 9895940)
              {
                v15 = "AC3_3_1";
                goto LABEL_26;
              }
              if (a2 == 9961476)
              {
                v15 = "AC3_3_0_1";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 9764866)
              {
                v15 = "AC3_1_0_1";
                goto LABEL_26;
              }
              if (a2 == 9830403)
              {
                v15 = "AC3_3_0";
                goto LABEL_26;
              }
            }
          }
          else if (a2 >= 9633792)
          {
            if (a2 == 9633792)
            {
              v15 = "DiscreteInOrder";
              goto LABEL_26;
            }
            if (a2 == 9699335)
            {
              v15 = "AudioUnit_7_0_Front";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 9502736)
            {
              v15 = "TMH_10_2_std";
              goto LABEL_26;
            }
            if (a2 == 9568277)
            {
              v15 = "TMH_10_2_full";
              goto LABEL_26;
            }
          }
        }
        else if (a2 <= 7143428)
        {
          if (a2 > 6684673)
          {
            if (a2 <= 6881281)
            {
              switch(a2)
              {
                case 6684674:
                  v15 = "StereoHeadphones";
                  goto LABEL_26;
                case 6750210:
                  v15 = "MatrixStereo";
                  goto LABEL_26;
                case 6815746:
                  v15 = "MidSide";
                  goto LABEL_26;
              }
            }
            else if (a2 > 7012355)
            {
              if (a2 == 7012356)
              {
                v15 = "Ambisonic_B_Format";
                goto LABEL_26;
              }
              if (a2 == 7077892)
              {
                v15 = "Quadraphonic";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 6881282)
              {
                v15 = "XY";
                goto LABEL_26;
              }
              if (a2 == 6946818)
              {
                v15 = "Binaural";
                goto LABEL_26;
              }
            }
          }
          else if (a2 < 0)
          {
            if (a2 == -268435456)
            {
              v15 = "BeginReserved";
              goto LABEL_26;
            }
            if (a2 == -65537)
            {
              v15 = "EndReserved";
              goto LABEL_26;
            }
          }
          else if (a2 > 6553600)
          {
            if (a2 == 6553601)
            {
              v15 = "Mono";
              goto LABEL_26;
            }
            if (a2 == 6619138)
            {
              v15 = "Stereo";
              goto LABEL_26;
            }
          }
          else
          {
            if (!a2)
            {
              v15 = "UseChannelDescriptions";
              goto LABEL_26;
            }
            if (a2 == 0x10000)
            {
              v15 = "UseChannelBitmap";
              goto LABEL_26;
            }
          }
        }
        else if (a2 <= 7602179)
        {
          if (a2 <= 7340039)
          {
            switch(a2)
            {
              case 7143429:
                v15 = "Pentagonal";
                goto LABEL_26;
              case 7208966:
                v15 = "Hexagonal";
                goto LABEL_26;
              case 7274504:
                v15 = "Octagonal";
                goto LABEL_26;
            }
          }
          else if (a2 > 7471106)
          {
            if (a2 == 7471107)
            {
              v15 = "MPEG_3_0_B";
              goto LABEL_26;
            }
            if (a2 == 7536644)
            {
              v15 = "MPEG_4_0_A";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 7340040)
            {
              v15 = "Cube";
              goto LABEL_26;
            }
            if (a2 == 7405571)
            {
              v15 = "MPEG_3_0_A";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 7864324)
        {
          if (a2 > 7995397)
          {
            if (a2 == 7995398)
            {
              v15 = "MPEG_5_1_B";
              goto LABEL_26;
            }
            if (a2 == 8060934)
            {
              v15 = "MPEG_5_1_C";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 7864325)
            {
              v15 = "MPEG_5_0_D";
              goto LABEL_26;
            }
            if (a2 == 7929862)
            {
              v15 = "MPEG_5_1_A";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 7733252)
        {
          if (a2 == 7733253)
          {
            v15 = "MPEG_5_0_B";
            goto LABEL_26;
          }
          if (a2 == 7798789)
          {
            v15 = "MPEG_5_0_C";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 7602180)
          {
            v15 = "MPEG_4_0_B";
            goto LABEL_26;
          }
          if (a2 == 7667717)
          {
            v15 = "MPEG_5_0_A";
            goto LABEL_26;
          }
        }
      }
      else if (a2 <= 11927558)
      {
        if (a2 <= 10944519)
        {
          if (a2 > 10485767)
          {
            if (a2 <= 10682375)
            {
              switch(a2)
              {
                case 10485768:
                  v15 = "EAC3_7_1_A";
                  goto LABEL_26;
                case 10551304:
                  v15 = "EAC3_7_1_B";
                  goto LABEL_26;
                case 10616840:
                  v15 = "EAC3_7_1_C";
                  goto LABEL_26;
              }
            }
            else if (a2 > 10813447)
            {
              if (a2 == 10813448)
              {
                v15 = "EAC3_7_1_F";
                goto LABEL_26;
              }
              if (a2 == 10878984)
              {
                v15 = "EAC3_7_1_G";
                goto LABEL_26;
              }
            }
            else
            {
              if (a2 == 10682376)
              {
                v15 = "EAC3_7_1_D";
                goto LABEL_26;
              }
              if (a2 == 10747912)
              {
                v15 = "EAC3_7_1_E";
                goto LABEL_26;
              }
            }
          }
          else if (a2 <= 10223622)
          {
            switch(a2)
            {
              case 10027012:
                v15 = "AC3_2_1_1";
                goto LABEL_26;
              case 10092549:
                v15 = "AC3_3_1_1";
                goto LABEL_26;
              case 10158086:
                v15 = "EAC_6_0_A";
                goto LABEL_26;
            }
          }
          else if (a2 > 10354694)
          {
            if (a2 == 10354695)
            {
              v15 = "EAC3_6_1_B";
              goto LABEL_26;
            }
            if (a2 == 10420231)
            {
              v15 = "EAC3_6_1_C";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 10223623)
            {
              v15 = "EAC_7_0_A";
              goto LABEL_26;
            }
            if (a2 == 10289159)
            {
              v15 = "EAC3_6_1_A";
              goto LABEL_26;
            }
          }
        }
        else if (a2 <= 11403270)
        {
          if (a2 <= 11141125)
          {
            switch(a2)
            {
              case 10944520:
                v15 = "EAC3_7_1_H";
                goto LABEL_26;
              case 11010052:
                v15 = "DTS_3_1";
                goto LABEL_26;
              case 11075589:
                v15 = "DTS_4_1";
                goto LABEL_26;
            }
          }
          else if (a2 > 11272197)
          {
            if (a2 == 11272198)
            {
              v15 = "DTS_6_0_C";
              goto LABEL_26;
            }
            if (a2 == 11337735)
            {
              v15 = "DTS_6_1_A";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 11141126)
            {
              v15 = "DTS_6_0_A";
              goto LABEL_26;
            }
            if (a2 == 11206662)
            {
              v15 = "DTS_6_0_B";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 11665415)
        {
          if (a2 > 11796488)
          {
            if (a2 == 11796489)
            {
              v15 = "DTS_8_1_A";
              goto LABEL_26;
            }
            if (a2 == 11862025)
            {
              v15 = "DTS_8_1_B";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 11665416)
            {
              v15 = "DTS_8_0_A";
              goto LABEL_26;
            }
            if (a2 == 11730952)
            {
              v15 = "DTS_8_0_B";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 11534342)
        {
          if (a2 == 11534343)
          {
            v15 = "DTS_7_0";
            goto LABEL_26;
          }
          if (a2 == 11599880)
          {
            v15 = "DTS_7_1";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 11403271)
          {
            v15 = "DTS_6_1_B";
            goto LABEL_26;
          }
          if (a2 == 11468807)
          {
            v15 = "DTS_6_1_C";
            goto LABEL_26;
          }
        }
      }
      else if (a2 > 12910595)
      {
        if (a2 <= 13369367)
        {
          if (a2 <= 13107206)
          {
            switch(a2)
            {
              case 12910596:
                v15 = "Logic_4_0_C";
                goto LABEL_26;
              case 12976134:
                v15 = "Logic_6_0_B";
                goto LABEL_26;
              case 13041671:
                v15 = "Logic_6_1_B";
                goto LABEL_26;
            }
          }
          else if (a2 > 13238283)
          {
            if (a2 == 13238284)
            {
              v15 = "Logic_Atmos_7_1_4_B";
              goto LABEL_26;
            }
            if (a2 == 13303822)
            {
              v15 = "Logic_Atmos_7_1_6";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 13107207)
            {
              v15 = "Logic_6_1_D";
              goto LABEL_26;
            }
            if (a2 == 13172744)
            {
              v15 = "Logic_7_1_B";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 13631499)
        {
          if (a2 > 13762571)
          {
            if (a2 == 13762572)
            {
              v15 = "CICP_19";
              goto LABEL_26;
            }
            if (a2 == 13828110)
            {
              v15 = "CICP_20";
              goto LABEL_26;
            }
          }
          else
          {
            if (a2 == 13631500)
            {
              v15 = "CICP_17";
              goto LABEL_26;
            }
            if (a2 == 13697038)
            {
              v15 = "CICP_18";
              goto LABEL_26;
            }
          }
        }
        else if (a2 > 13500427)
        {
          if (a2 == 13500428)
          {
            v15 = "CICP_15";
            goto LABEL_26;
          }
          if (a2 == 13565962)
          {
            v15 = "CICP_16";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 13369368)
          {
            v15 = "CICP_13";
            goto LABEL_26;
          }
          if (a2 == 13434888)
          {
            v15 = "CICP_14";
            goto LABEL_26;
          }
        }
      }
      else if (a2 <= 12386311)
      {
        if (a2 <= 12124163)
        {
          switch(a2)
          {
            case 11927559:
              v15 = "DTS_6_1_D";
              goto LABEL_26;
            case 11993096:
              v15 = "AAC_7_1_B";
              goto LABEL_26;
            case 12058632:
              v15 = "AAC_7_1_C";
              goto LABEL_26;
          }
        }
        else if (a2 > 12255237)
        {
          if (a2 == 12255238)
          {
            v15 = "WAVE_5_1_B";
            goto LABEL_26;
          }
          if (a2 == 12320775)
          {
            v15 = "WAVE_6_1";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 12124164)
          {
            v15 = "WAVE_4_0_B";
            goto LABEL_26;
          }
          if (a2 == 12189701)
          {
            v15 = "WAVE_5_0_B";
            goto LABEL_26;
          }
        }
      }
      else if (a2 > 12648463)
      {
        if (a2 > 12779529)
        {
          if (a2 == 12779530)
          {
            v15 = "Atmos_5_1_4";
            goto LABEL_26;
          }
          if (a2 == 12845066)
          {
            v15 = "Atmos_7_1_2";
            goto LABEL_26;
          }
        }
        else
        {
          if (a2 == 12648464)
          {
            v15 = "Atmos_9_1_6";
            goto LABEL_26;
          }
          if (a2 == 12713992)
          {
            v15 = "Atmos_5_1_2";
            goto LABEL_26;
          }
        }
      }
      else if (a2 >= 12517376)
      {
        if (a2 == 12517376)
        {
          v15 = "HOA_ACN_N3D";
          goto LABEL_26;
        }
        if (a2 == 12582924)
        {
          v15 = "Atmos_7_1_4";
          goto LABEL_26;
        }
      }
      else
      {
        if (a2 == 12386312)
        {
          v15 = "WAVE_7_1";
          goto LABEL_26;
        }
        if (a2 == 12451840)
        {
          v15 = "HOA_ACN_SN3D";
          goto LABEL_26;
        }
      }
LABEL_25:
      v15 = "Unknown";
LABEL_26:
      std::string::basic_string[abi:ne180100]<0>(a1, v15);
      return;
    }
    v5 = llroundf(sqrtf((float)(unsigned __int16)a2));
    if (v5)
      v6 = v5 * v5 == (unsigned __int16)a2;
    else
      v6 = 0;
    if (!v6)
      goto LABEL_25;
    std::string::basic_string[abi:ne180100]<0>(&v21, "HOA_ACN_SN3D");
    v7 = std::string::append(&v21, " ", 1uLL);
    v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, v5 - 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
  }
  v18 = std::string::append(&v22, (const std::string::value_type *)p_p, size);
  v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  a1[2] = *((_QWORD *)&v18->__r_.__value_.__l + 2);
  *(_OWORD *)a1 = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
}

void sub_1B612BDB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void PrintAudioChannelLayout(std::string *a1, int *a2)
{
  unint64_t v4;
  int *v5;
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  int v10;
  char *v11;
  CFTypeRef v12;
  void **v13;
  std::string::size_type v14;
  std::string *v15;
  __int128 v16;
  void **v17;
  std::string::size_type v18;
  int v19;
  int v20;
  int v21;
  std::string *v22;
  std::string::size_type v23;
  unint64_t v24;
  std::string *v25;
  std::string::size_type size;
  std::runtime_error *exception;
  void *__p[2];
  uint64_t v29;
  std::string v30;
  std::string v31;
  std::string v32;
  void *v33[2];
  uint64_t v34;
  CFTypeRef cf;
  UInt32 ioPropertyDataSize;
  CFTypeRef outPropertyData;
  int inSpecifier[5];
  __int128 v39;
  uint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  GetStringFromAudioChannelLayoutTag(a1, *a2);
  if (*a2 == 0x10000)
  {
    v24 = a2[1];
    v40 = 6;
    v39 = v24;
    memset(&v32, 0, sizeof(v32));
    v33[0] = (void *)1;
    v33[1] = &v39;
    v34 = 6;
    std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)&v32, "bitmap={:08X}", 13, (uint64_t *)v33);
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v25 = &v32;
    else
      v25 = (std::string *)v32.__r_.__value_.__r.__words[0];
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v32.__r_.__value_.__r.__words[2]);
    else
      size = v32.__r_.__value_.__l.__size_;
    std::string::append(a1, (const std::string::value_type *)v25, size);
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v32.__r_.__value_.__l.__data_);
  }
  else if (!*a2 && a2[2])
  {
    v4 = 0;
    v5 = a2 + 7;
    do
    {
      std::to_string(&v30, v4);
      v6 = std::string::insert(&v30, 0, "\n", 1uLL);
      v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v31.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      v8 = std::string::append(&v31, ": ", 2uLL);
      v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v32.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      v10 = *(v5 - 4);
      std::string::basic_string[abi:ne180100]<0>(__p, "");
      if (v10 == 100)
      {
        if (SHIBYTE(v29) < 0)
        {
          __p[1] = (void *)14;
          v11 = (char *)__p[0];
        }
        else
        {
          HIBYTE(v29) = 14;
          v11 = (char *)__p;
        }
        strcpy(v11, "UseCoordinates");
      }
      else
      {
        inSpecifier[0] = v10;
        outPropertyData = 0;
        ioPropertyDataSize = 8;
        if (!AudioFormatGetProperty(0x63736E6Du, 0x14u, inSpecifier, &ioPropertyDataSize, &outPropertyData)
          && ioPropertyDataSize)
        {
          v12 = outPropertyData;
          if (outPropertyData)
            CFRetain(outPropertyData);
          applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v12);
          if (!cf)
          {
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Could not construct");
          }
          applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)&v39);
          if (SHIBYTE(v29) < 0)
            operator delete(__p[0]);
          *(_OWORD *)__p = v39;
          v29 = v40;
          HIBYTE(v40) = 0;
          LOBYTE(v39) = 0;
          if (cf)
            CFRelease(cf);
          CFRelease(outPropertyData);
        }
      }
      if (v29 >= 0)
        v13 = __p;
      else
        v13 = (void **)__p[0];
      if (v29 >= 0)
        v14 = HIBYTE(v29);
      else
        v14 = (std::string::size_type)__p[1];
      v15 = std::string::append(&v32, (const std::string::value_type *)v13, v14);
      v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
      v34 = v15->__r_.__value_.__r.__words[2];
      *(_OWORD *)v33 = v16;
      v15->__r_.__value_.__l.__size_ = 0;
      v15->__r_.__value_.__r.__words[2] = 0;
      v15->__r_.__value_.__r.__words[0] = 0;
      if (v34 >= 0)
        v17 = v33;
      else
        v17 = (void **)v33[0];
      if (v34 >= 0)
        v18 = HIBYTE(v34);
      else
        v18 = (std::string::size_type)v33[1];
      std::string::append(a1, (const std::string::value_type *)v17, v18);
      if (SHIBYTE(v34) < 0)
        operator delete(v33[0]);
      if (SHIBYTE(v29) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v32.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
      v19 = *(v5 - 2);
      v39 = *(v5 - 3);
      v20 = *(v5 - 1);
      LODWORD(v40) = v19;
      v41 = v20;
      v21 = *v5;
      v43 = 304422;
      v42 = v21;
      memset(&v32, 0, sizeof(v32));
      v33[0] = (void *)4;
      v33[1] = &v39;
      v34 = 304422;
      std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)&v32, ", flags={:08X}, coords=[{:.1f}, {:.1f}, {:.1f}]", 47, (uint64_t *)v33);
      if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v22 = &v32;
      else
        v22 = (std::string *)v32.__r_.__value_.__r.__words[0];
      if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v23 = HIBYTE(v32.__r_.__value_.__r.__words[2]);
      else
        v23 = v32.__r_.__value_.__l.__size_;
      std::string::append(a1, (const std::string::value_type *)v22, v23);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v32.__r_.__value_.__l.__data_);
      ++v4;
      v5 += 5;
    }
    while (v4 < a2[2]);
  }
}

void sub_1B612C21C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,char a42)
{
  uint64_t v42;

  if (a33 < 0)
    operator delete(__p);
  if (*(char *)(v42 + 23) < 0)
    operator delete(*(void **)v42);
  _Unwind_Resume(exception_object);
}

uint64_t std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(uint64_t a1, char *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  char *v5;
  char *v6;
  const char *v7;
  uint64_t *v8;
  int v9;
  char *v10;
  std::locale v12;
  char v13;
  uint64_t *v14;
  __int128 v15;
  uint64_t v16;
  std::locale v17;
  char v18;
  char *v19[2];
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  _BYTE v24[256];
  _BYTE *v25;
  __int128 v26;
  void (*v27)(unint64_t, std::string::size_type, uint64_t);
  _BYTE *v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v26 = xmmword_1B66A0640;
  v25 = v24;
  v27 = std::__format::__output_buffer<char>::__output_buffer[abi:ne180100]<std::__format::__format_buffer<std::back_insert_iterator<std::string>,char>>(char *,unsigned long,std::__format::__format_buffer<std::back_insert_iterator<std::string>,char> *)::{lambda(char *,unsigned long,void *)#1}::__invoke;
  v28 = v24;
  v29 = a1;
  v4 = *a4;
  v5 = &a2[a3];
  v19[0] = a2;
  v19[1] = &a2[a3];
  v20 = 0;
  v21 = 0;
  v22 = v4;
  v15 = *(_OWORD *)a4;
  v16 = a4[2];
  LOBYTE(v12.__locale_) = 0;
  v13 = 0;
  v14 = (uint64_t *)&v25;
  LOBYTE(v17.__locale_) = 0;
  v18 = 0;
  if (!a3)
    return ((uint64_t (*)(_BYTE *, _QWORD, _BYTE *))v27)(v25, *((_QWORD *)&v26 + 1), v28);
  v6 = a2;
  v7 = "The format string terminates at a '{'";
  do
  {
    v8 = v14;
    while (1)
    {
      v9 = *v6;
      if (v9 == 125)
      {
        if (++v6 == v5 || *v6 != 125)
        {
          v7 = "The format string contains an invalid escape sequence";
LABEL_18:
          std::__throw_format_error[abi:ne180100](v7);
        }
        goto LABEL_11;
      }
      if (v9 == 123)
      {
        if (++v6 == v5)
          goto LABEL_18;
        if (*v6 != 123)
          break;
      }
LABEL_11:
      v23 = v8;
      std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v23, *v6++);
      if (v6 == v5)
        goto LABEL_14;
    }
    v14 = v8;
    std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v6, v5, v19, &v14);
    v6 = v10;
  }
  while (v10 != v5);
LABEL_14:
  if (v18)
    std::locale::~locale(&v17);
  return ((uint64_t (*)(_BYTE *, _QWORD, _BYTE *))v27)(v25, *((_QWORD *)&v26 + 1), v28);
}

void sub_1B612C4C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(exception_object);
}

void std::__format::__output_buffer<char>::__output_buffer[abi:ne180100]<std::__format::__format_buffer<std::back_insert_iterator<std::string>,char>>(char *,unsigned long,std::__format::__format_buffer<std::back_insert_iterator<std::string>,char> *)::{lambda(char *,unsigned long,void *)#1}::__invoke(unint64_t a1, std::string::size_type __n_add, uint64_t a3)
{
  std::string::value_type *v4;
  unint64_t v5;
  std::string::size_type v6;
  std::string::value_type *v7;
  std::string::size_type v8;
  std::string::size_type v10;
  unint64_t v11;
  std::string *v13;
  std::string::size_type size;
  std::string::size_type v15;
  std::string::size_type v16;
  unint64_t v17;
  std::string::size_type v18;
  _BYTE *v19;
  char v20;
  std::string::size_type v21;
  std::string::value_type *v22;
  std::string::value_type v23;
  std::string v24;

  v4 = (std::string::value_type *)a1;
  v5 = *(_QWORD *)(a3 + 296);
  if (*(char *)(v5 + 23) < 0)
  {
    if (!__n_add)
      return;
    v7 = (std::string::value_type *)(a1 + __n_add);
    v8 = *(_QWORD *)(v5 + 8);
    if (*(_QWORD *)v5 > a1 || *(_QWORD *)v5 + *(_QWORD *)(v5 + 8) + 1 <= a1)
    {
      v6 = *(_QWORD *)(v5 + 8);
      v10 = (*(_QWORD *)(v5 + 16) & 0x7FFFFFFFFFFFFFFFLL) - 1;
      if (v10 - v6 >= __n_add)
      {
        v11 = *(_QWORD *)v5;
        goto LABEL_30;
      }
LABEL_15:
      std::string::__grow_by((std::string *)v5, v10, v6 + __n_add - v10, v6, v8, 0, __n_add);
      *(_QWORD *)(v5 + 8) = v6 + __n_add;
      v11 = *(_QWORD *)v5;
      goto LABEL_33;
    }
  }
  else
  {
    if (!__n_add)
      return;
    v6 = *(unsigned __int8 *)(v5 + 23);
    v7 = (std::string::value_type *)(a1 + __n_add);
    v8 = v6;
    if (v5 > a1 || v5 + *(unsigned __int8 *)(v5 + 23) + 1 <= a1)
    {
      v10 = 22;
      v11 = *(_QWORD *)(a3 + 296);
      if (22 - v6 >= __n_add)
      {
LABEL_30:
        if (v6 == v8)
          v6 = v8;
        else
          memmove((void *)(v11 + v8 + __n_add), (const void *)(v11 + v8), v6 - v8);
LABEL_33:
        v18 = v6 + __n_add;
        if (*(char *)(v5 + 23) < 0)
          *(_QWORD *)(v5 + 8) = v18;
        else
          *(_BYTE *)(v5 + 23) = v18 & 0x7F;
        *(_BYTE *)(v11 + v18) = 0;
        v19 = (_BYTE *)(v11 + v8);
        do
        {
          v20 = *v4++;
          *v19++ = v20;
        }
        while (v4 != v7);
        return;
      }
      goto LABEL_15;
    }
  }
  memset(&v24, 0, sizeof(v24));
  do
    std::string::push_back(&v24, *v4++);
  while (v4 != v7);
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = &v24;
  else
    v13 = (std::string *)v24.__r_.__value_.__r.__words[0];
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v24.__r_.__value_.__r.__words[2]);
  else
    size = v24.__r_.__value_.__l.__size_;
  if (*(char *)(v5 + 23) < 0)
  {
    v15 = *(_QWORD *)(v5 + 8);
    v16 = (*(_QWORD *)(v5 + 16) & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v16 - v15 >= __n_add)
    {
      v17 = *(_QWORD *)v5;
      goto LABEL_40;
    }
LABEL_28:
    std::string::__grow_by((std::string *)v5, v16, v15 + __n_add - v16, v15, v8, 0, __n_add);
    *(_QWORD *)(v5 + 8) = v15 + __n_add;
    v17 = *(_QWORD *)v5;
    goto LABEL_43;
  }
  v15 = *(unsigned __int8 *)(v5 + 23);
  v16 = 22;
  v17 = v5;
  if (22 - v15 < __n_add)
    goto LABEL_28;
LABEL_40:
  if (v15 == v8)
    v15 = v8;
  else
    memmove((void *)(v17 + v8 + __n_add), (const void *)(v17 + v8), v15 - v8);
LABEL_43:
  v21 = v15 + __n_add;
  if (*(char *)(v5 + 23) < 0)
    *(_QWORD *)(v5 + 8) = v21;
  else
    *(_BYTE *)(v5 + 23) = v21 & 0x7F;
  *(_BYTE *)(v17 + v21) = 0;
  if (size)
  {
    v22 = (std::string::value_type *)(v17 + v8);
    do
    {
      v23 = v13->__r_.__value_.__s.__data_[0];
      v13 = (std::string *)((char *)v13 + 1);
      *v22++ = v23;
      --size;
    }
    while (size);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
}

void sub_1B612C75C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__throw_format_error[abi:ne180100](const char *a1)
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::format_error::format_error[abi:ne180100](exception, a1);
}

void sub_1B612C7E0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, char *a2, char **a3, _QWORD *a4)
{
  char *v7;
  unsigned int v8;
  int v9;
  unint64_t v10;
  uint64_t v11;

  v7 = std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(a1, a2, (uint64_t)a3);
  if (v7 != a2)
  {
    v9 = *v7;
    if (v9 == 125)
      goto LABEL_5;
    if (v9 == 58)
    {
      ++v7;
LABEL_5:
      *a3 = v7;
      v10 = a4[1];
      if (v10 > v8)
      {
        if (v10 > 0xC)
          LODWORD(v11) = *(unsigned __int8 *)(a4[2] + 32 * v8 + 16);
        else
          v11 = (a4[3] >> (5 * v8)) & 0x1FLL;
        __asm { BR              X11 }
      }
      std::__throw_format_error[abi:ne180100]("The argument index value is too large for the number of arguments supplied");
    }
  }
  std::__throw_format_error[abi:ne180100]("The argument index should end with a ':' or a '}'");
}

uint64_t **std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](uint64_t **a1, char a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *a1;
  v4 = **a1;
  v5 = (*a1)[2];
  v3[2] = v5 + 1;
  *(_BYTE *)(v4 + v5) = a2;
  if (v3[2] == v3[1])
  {
    ((void (*)(uint64_t))v3[3])(*v3);
    v3[2] = 0;
  }
  return a1;
}

char *std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(char *result, char *a2, uint64_t a3)
{
  int v4;
  int v5;
  int v6;
  int v7;

  v4 = *result;
  if (v4 == 125 || v4 == 58)
  {
    v6 = *(_DWORD *)(a3 + 16);
    if (v6)
    {
      if (v6 == 1)
        std::__throw_format_error[abi:ne180100]("Using automatic argument numbering in manual argument numbering mode");
    }
    else
    {
      *(_DWORD *)(a3 + 16) = 2;
    }
    ++*(_QWORD *)(a3 + 24);
  }
  else if (v4 == 48)
  {
    v5 = *(_DWORD *)(a3 + 16);
    if (v5)
    {
      if (v5 == 2)
LABEL_13:
        std::__throw_format_error[abi:ne180100]("Using manual argument numbering in automatic argument numbering mode");
    }
    else
    {
      *(_DWORD *)(a3 + 16) = 1;
    }
    ++result;
  }
  else
  {
    if ((v4 - 58) <= 0xF5u)
      std::__throw_format_error[abi:ne180100]("The argument index starts with an invalid character");
    result = std::__format::__parse_number[abi:ne180100]<char const*>((unint64_t)result, a2);
    v7 = *(_DWORD *)(a3 + 16);
    if (v7)
    {
      if (v7 == 2)
        goto LABEL_13;
    }
    else
    {
      *(_DWORD *)(a3 + 16) = 1;
    }
  }
  return result;
}

uint64_t std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, _QWORD *a2)
{
  uint64_t v2;
  char v5;
  uint64_t v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v22[15];
  uint64_t v23;
  uint64_t v24;
  char v25;
  _BYTE v26[31];

  *(_QWORD *)&v26[23] = *MEMORY[0x1E0C80C00];
  v5 = *a1;
  v6 = a1[1];
  v7 = *((_WORD *)a1 + 1);
  v8 = *((unsigned int *)a1 + 1);
  if ((v7 & 0x4000) != 0)
  {
    v9 = (int)v8;
    v10 = a2[1];
    if (v10 <= (int)v8)
    {
      LOBYTE(v12) = 0;
    }
    else if (v10 > 0xC)
    {
      v13 = a2[2] + 32 * (int)v8;
      v2 = *(_QWORD *)v13;
      v9 = *(_QWORD *)(v13 + 8);
      LOBYTE(v12) = *(_BYTE *)(v13 + 16);
      *(_QWORD *)v22 = *(_QWORD *)(v13 + 17);
      *(_QWORD *)&v22[7] = *(_QWORD *)(v13 + 24);
    }
    else
    {
      v11 = a2[2];
      v12 = (a2[3] >> (5 * v8)) & 0x1FLL;
      v2 = *(_QWORD *)(v11 + 16 * (int)v8);
      v9 = *(_QWORD *)(v11 + 16 * (int)v8 + 8);
    }
    v23 = v2;
    v24 = v9;
    v25 = v12;
    *(_QWORD *)v26 = *(_QWORD *)v22;
    *(_QWORD *)&v26[7] = *(_QWORD *)&v22[7];
    std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v23);
    v8 = v14;
    v7 = *((_WORD *)a1 + 1);
  }
  v15 = *((_DWORD *)a1 + 2);
  if (v7 < 0)
  {
    v16 = v15;
    v17 = a2[1];
    if (v17 <= v15)
    {
      LOBYTE(v19) = 0;
    }
    else if (v17 > 0xC)
    {
      v20 = a2[2] + 32 * v15;
      v2 = *(_QWORD *)v20;
      v16 = *(_QWORD *)(v20 + 8);
      LOBYTE(v19) = *(_BYTE *)(v20 + 16);
      *(_QWORD *)v22 = *(_QWORD *)(v20 + 17);
      *(_QWORD *)&v22[7] = *(_QWORD *)(v20 + 24);
    }
    else
    {
      v18 = a2[2];
      v19 = (a2[3] >> (5 * v15)) & 0x1FLL;
      v2 = *(_QWORD *)(v18 + 16 * v15);
      v16 = *(_QWORD *)(v18 + 16 * v15 + 8);
    }
    v23 = v2;
    v24 = v16;
    v25 = v19;
    *(_QWORD *)v26 = *(_QWORD *)v22;
    *(_QWORD *)&v26[7] = *(_QWORD *)&v22[7];
    std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v23);
  }
  return (v6 << 8) | (v8 << 32) | v5 & 0x7F;
}

_QWORD *std::__formatter::__format_integer[abi:ne180100]<unsigned long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, uint64_t *a2, unint64_t a3, unint64_t a4, char *a5, uint64_t a6, _BYTE *a7, unsigned int a8)
{
  char *v8;
  unsigned int v12;
  char *v13;
  char v14;
  char v15;
  unsigned __int8 *v16;
  int v17;
  char *v18;
  const std::locale::facet *v19;
  int64_t v20;
  std::string::value_type *locale;
  uint64_t v22;
  std::locale::__imp *v23;
  _QWORD *v24;
  char *v25;
  std::string::value_type v26;
  uint64_t v27;
  std::string::value_type *v28;
  std::string::value_type *v29;
  std::string::value_type *v30;
  int v31;
  BOOL v32;
  char v33;
  _QWORD *v34;
  unint64_t v35;
  unsigned __int8 v36;
  int v37;
  unsigned __int8 v38;
  uint64_t v39;
  unint64_t v40;
  std::string __p;
  std::locale v43;
  uint64_t v44;
  unsigned __int8 v45;

  v8 = a5;
  v12 = (a3 >> 3) & 3;
  if (v12 == 2)
  {
    v14 = 43;
    goto LABEL_5;
  }
  v13 = a5;
  if (v12 == 3)
  {
    v14 = 32;
LABEL_5:
    *a5 = v14;
    v13 = a5 + 1;
  }
  if ((a3 & 0x20) != 0)
  {
    if (a7)
    {
      v15 = *a7;
      if (*a7)
      {
        v16 = a7 + 1;
        do
        {
          *v13++ = v15;
          v17 = *v16++;
          v15 = v17;
        }
        while (v17);
      }
    }
  }
  v18 = std::__to_chars_integral[abi:ne180100]<unsigned long long>(v13, a6, a1, a8);
  if ((a3 & 0x40) == 0)
    goto LABEL_38;
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](&v43, (uint64_t)a2);
  v19 = std::locale::use_facet(&v43, MEMORY[0x1E0DE4CC0]);
  v20 = v18 - v13;
  std::locale::~locale(&v43);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v19->__vftable[1].__on_zero_shared)(&v43, v19);
  if ((char)v45 < 0)
  {
    locale = (std::string::value_type *)v43.__locale_;
    v22 = v44;
    if (v44 && v20 > *(char *)v43.__locale_)
    {
      v23 = v43.__locale_;
      goto LABEL_19;
    }
    operator delete(v43.__locale_);
LABEL_38:
    v35 = HIDWORD(a3);
    if ((a3 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>((_QWORD *)*a2, v8, v13 - v8);
      v36 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v13 - (int)v8)
        v37 = (_DWORD)v13 - (_DWORD)v8;
      else
        v37 = HIDWORD(a3);
      v35 = (HIDWORD(a3) - v37);
      v38 = 48;
      v8 = v13;
    }
    else
    {
      v38 = BYTE4(a4);
      v36 = a3;
    }
    v34 = (_QWORD *)*a2;
    v39 = a3 & 0xFFFFFF00 | (v35 << 32) | v36;
    v40 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v38 << 32);
    if ((a3 & 0xFF00) == 0x700)
      std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v8, v18, *a2, v39);
    else
      std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v8, v18 - v8, (_QWORD *)*a2, v39, v40, v18 - v8);
    return v34;
  }
  if (!v45 || v20 <= SLOBYTE(v43.__locale_))
    goto LABEL_38;
  locale = (std::string::value_type *)&v43;
  v23 = v43.__locale_;
  v22 = v44;
LABEL_19:
  v24 = (_QWORD *)*a2;
  memset(&__p, 0, sizeof(__p));
  v25 = (char *)v23 + v22;
  if ((v45 & 0x80u) == 0)
    v25 = (char *)&v43 + v45;
  v26 = *locale;
  v27 = v20 - *locale;
  if (v27 >= 1)
  {
    v28 = v25 - 1;
    do
    {
      std::string::push_back(&__p, v26);
      if (locale == v28)
      {
        v26 = *v28;
        locale = v28;
      }
      else
      {
        v29 = locale + 1;
        v30 = locale + 1;
        do
        {
          v31 = *v30++;
          v26 = v31;
          if (v31)
            v32 = 1;
          else
            v32 = v29 == v28;
          v29 = v30;
        }
        while (!v32);
        locale = v30 - 1;
      }
      v27 -= v26;
    }
    while (v27 > 0);
  }
  std::string::push_back(&__p, v26 + v27);
  v33 = ((uint64_t (*)(const std::locale::facet *))v19->__vftable[1].~facet_0)(v19);
  v34 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v24, v8, v13, (int)v18, (uint64_t *)&__p, v33, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if ((char)v45 < 0)
    operator delete(v43.__locale_);
  return v34;
}

void sub_1B612EE38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15.__locale_);
  _Unwind_Resume(exception_object);
}

char *std::__to_chars_integral[abi:ne180100]<unsigned long long>(char *a1, uint64_t a2, unint64_t a3, unsigned int a4)
{
  int v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v9;
  int v10;
  unint64_t v11;
  _BYTE *v12;
  BOOL v13;
  uint64_t v16;

  HIDWORD(v5) = a4;
  LODWORD(v5) = a4 - 2;
  v4 = v5 >> 1;
  switch(v4)
  {
    case 4:
      if (a2 - (uint64_t)a1 > 19)
        return std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
      v6 = (1233 * (64 - __clz(a3 | 1))) >> 12;
      if (a2 - (uint64_t)a1 >= v6 - (std::__itoa::__pow10_64[v6] > a3) + 1)
        return std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
      break;
    case 0:
      return (char *)std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    case 3:
      return (char *)std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    case 7:
      return (char *)std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    default:
      v9 = a2 - (_QWORD)a1;
      v16 = a2;
      v10 = std::__to_chars_integral_width[abi:ne180100]<unsigned long long>(a3, a4);
      v11 = a3;
      a2 = v16;
      if (v9 >= v10)
      {
        a2 = (uint64_t)&a1[v10];
        v12 = (_BYTE *)(a2 - 1);
        do
        {
          *v12-- = a0123456789abcd[v11 % a4];
          v13 = v11 >= a4;
          v11 /= a4;
        }
        while (v13);
      }
      break;
  }
  return (char *)a2;
}

std::locale *std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](std::locale *this, uint64_t a2)
{
  std::locale *v3;
  std::locale v6;

  v3 = (std::locale *)(a2 + 32);
  if (!*(_BYTE *)(a2 + 40))
  {
    MEMORY[0x1BCC95B24](&v6);
    if (*(_BYTE *)(a2 + 40))
    {
      std::locale::operator=(v3, &v6);
    }
    else
    {
      std::locale::locale(v3, &v6);
      *(_BYTE *)(a2 + 40) = 1;
    }
    std::locale::~locale(&v6);
  }
  return std::locale::locale(this, v3);
}

_QWORD *std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(_QWORD *a1, char *__src, char *a3, int a4, uint64_t *a5, char a6, unint64_t a7, unint64_t a8)
{
  unsigned __int16 v8;
  char *v11;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char *v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  uint64_t v24;
  size_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;

  v8 = a7;
  v11 = a3;
  v13 = HIDWORD(a7);
  v14 = HIDWORD(a8);
  LODWORD(v15) = *((unsigned __int8 *)a5 + 23);
  if ((v15 & 0x80u) != 0)
    v15 = a5[1];
  v16 = a4 - (_DWORD)__src - 1 + v15;
  v17 = a7 & 7;
  if ((_DWORD)v17 == 4)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, __src, a3 - __src);
    if ((int)v13 > v16)
      std::__format::__output_buffer<char>::__fill[abi:ne180100](a1, (int)v13 - v16, 48);
  }
  else
  {
    if (SHIDWORD(a7) > v16)
      __asm { BR              X10 }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, __src, a3 - __src);
  }
  v18 = *((unsigned __int8 *)a5 + 23);
  v19 = (char)v18;
  v20 = (char *)a5 + v18;
  if (v19 >= 0)
    v21 = v20;
  else
    v21 = (char *)(*a5 + a5[1]);
  if (v19 >= 0)
    v22 = a5;
  else
    v22 = (uint64_t *)*a5;
  v23 = (char *)v22 + 1;
  v24 = v8 & 0xFF00;
  while (1)
  {
    v26 = v21 - 1;
    v25 = *(v21 - 1);
    if (v24 == 1792)
    {
      v27 = &v11[v25];
      std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>((uint64_t)a1, v11, &v11[v25]);
      v11 = v27;
    }
    else
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, v11, v25);
      v11 += *v26;
    }
    if (v21 == v23)
      break;
    v28 = *a1;
    v29 = a1[2];
    a1[2] = v29 + 1;
    *(_BYTE *)(v28 + v29) = a6;
    --v21;
    if (a1[2] == a1[1])
    {
      ((void (*)(_QWORD))a1[3])(*a1);
      a1[2] = 0;
      v21 = v26;
    }
  }
  return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, 0, v14);
}

_QWORD *std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(_QWORD *result, char *__src, size_t __len)
{
  size_t v3;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  size_t v8;

  v3 = __len;
  v5 = result;
  v7 = result[1];
  v6 = result[2];
  if (v6 + __len >= v7)
  {
    result = (_QWORD *)((uint64_t (*)(_QWORD))result[3])(*result);
    v6 = 0;
    v5[2] = 0;
    v7 = v5[1];
  }
  if (v3 >= v7)
  {
    do
    {
      if (v5[1] >= v3)
        v8 = v3;
      else
        v8 = v5[1];
      if (v8)
        memmove((void *)(*v5 + v6), __src, v8);
      v5[2] = v8;
      __src += v8;
      v3 -= v8;
      result = (_QWORD *)((uint64_t (*)(_QWORD, size_t, _QWORD))v5[3])(*v5, v8, v5[4]);
      v6 = 0;
      v5[2] = 0;
    }
    while (v3);
  }
  else
  {
    if (v3)
    {
      result = memmove((void *)(*v5 + v6), __src, v3);
      v6 = v5[2];
    }
    v5[2] = v6 + v3;
  }
  return result;
}

_QWORD *std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t __len, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a4 >> 32 > a6)
    __asm { BR              X10 }
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a3, __src, __len);
  return a3;
}

uint64_t std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *a1, char *a2, uint64_t a3, uint64_t a4)
{
  if (a4 >> 32 > a2 - a1)
    __asm { BR              X10 }
  std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>(a3, a1, a2);
  return a3;
}

uint64_t std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>(uint64_t result, char *a2, char *a3)
{
  char *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  char v10;
  int v11;
  char v12;
  uint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  char *v17;
  char v18;
  int v19;
  char v20;

  v4 = a2;
  v5 = result;
  v6 = a3 - a2;
  v8 = *(_QWORD *)(result + 8);
  v7 = *(_QWORD *)(result + 16);
  if (v7 + v6 >= v8)
  {
    result = (*(uint64_t (**)(_QWORD))(result + 24))(*(_QWORD *)result);
    v7 = 0;
    *(_QWORD *)(v5 + 16) = 0;
    v8 = *(_QWORD *)(v5 + 8);
  }
  if (v6 >= v8)
  {
    do
    {
      v13 = *(_QWORD *)v5;
      v14 = *(_QWORD *)(v5 + 8);
      if (v14 >= v6)
        v14 = v6;
      if (v14)
      {
        v15 = (_BYTE *)(v13 + v7);
        v16 = v14;
        v17 = v4;
        do
        {
          v19 = *v17++;
          v18 = v19;
          v20 = v19 - 32;
          if ((v19 - 97) < 6)
            v18 = v20;
          *v15++ = v18;
          --v16;
        }
        while (v16);
        v13 = *(_QWORD *)v5;
      }
      v4 += v14;
      *(_QWORD *)(v5 + 16) = v14;
      v6 -= v14;
      result = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(v5 + 24))(v13, v14, *(_QWORD *)(v5 + 32));
      v7 = 0;
      *(_QWORD *)(v5 + 16) = 0;
    }
    while (v6);
  }
  else
  {
    if (v4 != a3)
    {
      v9 = (_BYTE *)(*(_QWORD *)v5 + v7);
      do
      {
        v11 = *v4++;
        v10 = v11;
        v12 = v11 - 32;
        if ((v11 - 97) < 6)
          v10 = v12;
        *v9++ = v10;
      }
      while (v4 != a3);
      v7 = *(_QWORD *)(v5 + 16);
    }
    *(_QWORD *)(v5 + 16) = v7 + v6;
  }
  return result;
}

_QWORD *std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(_QWORD *a1, size_t __len, int a3)
{
  size_t v3;
  unsigned int v5;
  size_t v6;
  int __src;

  v3 = __len;
  v5 = __clz(~(_BYTE)a3) - 24;
  __src = a3;
  if ((_BYTE)a3 == 0xFF)
    v6 = 8;
  else
    v6 = v5;
  if ((_DWORD)v6)
  {
    if (__len)
    {
      do
      {
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, (char *)&__src, v6);
        --v3;
      }
      while (v3);
    }
  }
  else
  {
    std::__format::__output_buffer<char>::__fill[abi:ne180100](a1, __len, (char)a3);
  }
  return a1;
}

_QWORD *std::__format::__output_buffer<char>::__fill[abi:ne180100](_QWORD *result, size_t __len, int __c)
{
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  size_t v9;

  v5 = (uint64_t)result;
  v7 = result[1];
  v6 = result[2];
  if (v6 + __len >= v7)
  {
    result = (_QWORD *)((uint64_t (*)(_QWORD))result[3])(*result);
    v6 = 0;
    *(_QWORD *)(v5 + 16) = 0;
    v7 = *(_QWORD *)(v5 + 8);
  }
  if (v7 <= __len)
  {
    do
    {
      v8 = *(_QWORD *)v5;
      if (*(_QWORD *)(v5 + 8) >= __len)
        v9 = __len;
      else
        v9 = *(_QWORD *)(v5 + 8);
      if (v9)
      {
        memset((void *)(v8 + v6), __c, v9);
        v8 = *(_QWORD *)v5;
      }
      *(_QWORD *)(v5 + 16) = v9;
      __len -= v9;
      result = (_QWORD *)(*(uint64_t (**)(uint64_t, size_t, _QWORD))(v5 + 24))(v8, v9, *(_QWORD *)(v5 + 32));
      v6 = 0;
      *(_QWORD *)(v5 + 16) = 0;
    }
    while (__len);
  }
  else
  {
    if (__len)
    {
      result = memset((void *)(*(_QWORD *)v5 + v6), __c, __len);
      v6 = *(_QWORD *)(v5 + 16);
    }
    *(_QWORD *)(v5 + 16) = v6 + __len;
  }
  return result;
}

char *std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](char *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v4;

  v2 = a2;
  if (!HIDWORD(a2))
    return std::__itoa::__base_10_u32[abi:ne180100](a1, a2);
  if (a2 > 0x2540BE3FFLL)
  {
    v4 = a2 / 0x2540BE400;
    a1 = std::__itoa::__base_10_u32[abi:ne180100](a1, a2 / 0x2540BE400);
    v2 -= 10000000000 * v4;
  }
  return (char *)std::__itoa::__append10[abi:ne180100]<unsigned long long>(a1, v2);
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  _BYTE *v8;

  v3 = 64 - __clz(a3 | 1);
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x11)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 4;
      *(_DWORD *)(v5 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v5 -= 4;
      v7 = a3 > 0x10F;
      a3 >>= 4;
    }
    while (v7);
  }
  v8 = (_BYTE *)(v5 - 1);
  do
  {
    *v8-- = a01[v6 & 1];
    v7 = v6 > 1;
    v6 >>= 1;
  }
  while (v7);
  return v4;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  BOOL v8;

  v3 = (86 * (66 - __clz(a3 | 1))) >> 8;
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x41)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 6;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x40);
  }
  v7 = (_BYTE *)(v5 - 1);
  do
  {
    *v7-- = a01234567[v6 & 7];
    v8 = v6 > 7;
    v6 >>= 3;
  }
  while (v8);
  return v4;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  BOOL v8;

  v3 = 67 - __clz(a3 | 1);
  if (a2 - a1 < (uint64_t)(v3 >> 2))
    return a2;
  v4 = a1 + (v3 >> 2);
  if (a3 < 0x101)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + (v3 >> 2);
    do
    {
      v6 = a3 >> 8;
      *(_WORD *)(v5 - 2) = *(_WORD *)&std::__itoa::__base_16_lut[2 * a3];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x100);
  }
  v7 = (_BYTE *)(v5 - 1);
  do
  {
    *v7-- = a0123456789abcd_0[v6 & 0xF];
    v8 = v6 > 0xF;
    v6 >>= 4;
  }
  while (v8);
  return v4;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned long long>(unint64_t a1, unsigned int a2)
{
  int v3;
  unint64_t v4;
  unint64_t v5;

  if (a2 > a1)
    return 1;
  v3 = 0;
  v4 = a2 * a2;
  v5 = (v4 * v4);
  while (1)
  {
    if (a1 < v4)
      return v3 | 2u;
    if (a1 < v4 * a2)
      return v3 | 3u;
    if (a1 < v5)
      break;
    a1 /= v5;
    v3 += 4;
    if (a1 < a2)
      return v3 | 1u;
  }
  return (v3 + 4);
}

char *std::__itoa::__base_10_u32[abi:ne180100](_WORD *a1, unsigned int a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned __int16 v4;
  unsigned int v5;
  unsigned __int16 v6;
  unsigned int v7;
  unsigned __int16 v8;
  unsigned int v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 v12;

  if (a2 >= 0xF4240)
  {
    if (a2 >= 0x5F5E100)
    {
      v7 = a2 / 0x5F5E100;
      if (a2 > 0x3B9AC9FF)
      {
        *a1 = std::__itoa::__digits_base_10[v7];
        a1[1] = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240];
        a1[2] = std::__itoa::__digits_base_10[a2 % 0x5F5E100 % 0xF4240 / 0x2710uLL];
        v12 = a2 % 0x5F5E100 % 0xF4240 % 0x2710;
        a1[3] = std::__itoa::__digits_base_10[v12 / 0x64u];
        a1[4] = std::__itoa::__digits_base_10[v12 % 0x64u];
        v2 = 10;
      }
      else
      {
        *(_BYTE *)a1 = v7 + 48;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240];
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[a2 % 0x5F5E100 % 0xF4240 / 0x2710uLL];
        v8 = a2 % 0x5F5E100 % 0xF4240 % 0x2710;
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[v8 / 0x64u];
        *(_WORD *)((char *)a1 + 7) = std::__itoa::__digits_base_10[v8 % 0x64u];
        v2 = 9;
      }
    }
    else
    {
      v3 = a2 / 0xF4240;
      if (a2 > 0x98967F)
      {
        *a1 = std::__itoa::__digits_base_10[v3];
        a1[1] = std::__itoa::__digits_base_10[a2 % 0xF4240 / 0x2710uLL];
        v10 = a2 % 0xF4240 % 0x2710;
        a1[2] = std::__itoa::__digits_base_10[v10 / 0x64u];
        a1[3] = std::__itoa::__digits_base_10[v10 % 0x64u];
        v2 = 8;
      }
      else
      {
        *(_BYTE *)a1 = v3 + 48;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[a2 % 0xF4240 / 0x2710uLL];
        v4 = a2 % 0xF4240 % 0x2710;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v4 / 0x64u];
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[v4 % 0x64u];
        v2 = 7;
      }
    }
  }
  else if (a2 >> 4 > 0x270)
  {
    v5 = a2 / 0x2710;
    if (a2 >> 5 > 0xC34)
    {
      *a1 = std::__itoa::__digits_base_10[v5];
      v11 = a2 % 0x2710;
      a1[1] = std::__itoa::__digits_base_10[v11 / 0x64u];
      a1[2] = std::__itoa::__digits_base_10[v11 % 0x64u];
      v2 = 6;
    }
    else
    {
      *(_BYTE *)a1 = v5 + 48;
      v6 = a2 % 0x2710;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[v6 / 0x64u];
      *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v6 % 0x64u];
      v2 = 5;
    }
  }
  else if (a2 > 0x63)
  {
    v9 = (unsigned __int16)a2 / 0x64u;
    if (a2 > 0x3E7)
    {
      *a1 = std::__itoa::__digits_base_10[v9];
      a1[1] = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      v2 = 4;
    }
    else
    {
      *(_BYTE *)a1 = v9 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      v2 = 3;
    }
  }
  else if (a2 > 9)
  {
    *a1 = std::__itoa::__digits_base_10[a2];
    v2 = 2;
  }
  else
  {
    *(_BYTE *)a1 = a2 + 48;
    v2 = 1;
  }
  return (char *)a1 + v2;
}

_WORD *std::__itoa::__append10[abi:ne180100]<unsigned long long>(_WORD *a1, unint64_t a2)
{
  unsigned int v2;

  *a1 = std::__itoa::__digits_base_10[(a2 / 0x5F5E100)];
  v2 = a2 % 0x5F5E100;
  a1[1] = std::__itoa::__digits_base_10[v2 / 0xF4240uLL];
  v2 %= 0xF4240u;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  LOWORD(v2) = v2 % 0x2710;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

void std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1)
{
  __asm { BR              X10 }
}

uint64_t sub_1B612FDC4(unsigned int *a1)
{
  uint64_t result;

  result = *a1;
  if ((result & 0x80000000) != 0)
    std::__throw_format_error[abi:ne180100]("An argument index may not have a negative value");
  return result;
}

void sub_1B612FE28()
{
  std::__throw_format_error[abi:ne180100]("The argument index value is too large for the number of arguments supplied");
}

unsigned __int8 *std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(uint64_t a1, char **a2, char a3)
{
  unsigned __int8 *v3;
  char *v4;
  unsigned __int8 *v8;
  int v9;
  char v10;
  int v11;
  char v12;
  uint64_t v13;
  size_t v14;
  int v15;
  int v16;
  char v17;
  int v18;
  int v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  char v25;
  int v26;
  unsigned __int8 *v28[2];

  v4 = *a2;
  v3 = (unsigned __int8 *)a2[1];
  if (*a2 == (char *)v3)
    return (unsigned __int8 *)*a2;
  v28[0] = (unsigned __int8 *)*a2;
  v28[1] = v3;
  if ((std::__unicode::__code_point_view<char>::__consume[abi:ne180100](v28) & 0x80000000) != 0)
    std::__throw_format_error[abi:ne180100]("The format specifier contains malformed Unicode characters");
  v8 = v28[0];
  if (v28[0] >= v3)
    goto LABEL_8;
  v9 = (char)*v28[0];
  switch(v9)
  {
    case '<':
      v10 = 1;
      goto LABEL_18;
    case '>':
      v10 = 3;
LABEL_18:
      *(_BYTE *)a1 = *(_BYTE *)a1 & 0xF8 | v10;
      v14 = v8 - (unsigned __int8 *)v4;
      if (v8 - (unsigned __int8 *)v4 == 1)
      {
        v15 = *v4;
        if (v15 == 125 || v15 == 123)
          std::__throw_format_error[abi:ne180100]("The fill option contains an invalid value");
      }
      else if (v8 == (unsigned __int8 *)v4)
      {
LABEL_24:
        v13 = v14 + 1;
        goto LABEL_25;
      }
      memmove((void *)(a1 + 12), v4, v14);
      goto LABEL_24;
    case '^':
      v10 = 2;
      goto LABEL_18;
  }
LABEL_8:
  v11 = *v4;
  switch(v11)
  {
    case '<':
      v12 = 1;
      break;
    case '>':
      v12 = 3;
      break;
    case '^':
      v12 = 2;
      break;
    default:
      goto LABEL_26;
  }
  *(_BYTE *)a1 = *(_BYTE *)a1 & 0xF8 | v12;
  v13 = 1;
LABEL_25:
  v4 += v13;
  if (v4 == (char *)v3)
    return v3;
LABEL_26:
  if ((a3 & 1) == 0)
    goto LABEL_34;
  v16 = *v4;
  switch(v16)
  {
    case ' ':
      v17 = *(_BYTE *)a1 | 0x18;
      goto LABEL_33;
    case '+':
      v17 = *(_BYTE *)a1 & 0xE7 | 0x10;
LABEL_33:
      *(_BYTE *)a1 = v17;
      if (++v4 == (char *)v3)
        return v3;
      break;
    case '-':
      v17 = *(_BYTE *)a1 & 0xE7 | 8;
      goto LABEL_33;
  }
LABEL_34:
  if ((a3 & 2) != 0 && *v4 == 35)
  {
    *(_BYTE *)a1 |= 0x20u;
    if (++v4 == (char *)v3)
      return v3;
  }
  if ((a3 & 4) == 0)
    goto LABEL_42;
  v18 = *v4;
  if (v18 != 48)
    goto LABEL_43;
  if ((*(_BYTE *)a1 & 7) == 0)
    *(_BYTE *)a1 = *(_BYTE *)a1 & 0xF8 | 4;
  if (++v4 != (char *)v3)
  {
LABEL_42:
    v18 = *v4;
LABEL_43:
    if (v18 == 123)
    {
      v4 = std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(v4 + 1, (char *)v3, (uint64_t)a2);
      *(_WORD *)(a1 + 2) |= 0x4000u;
    }
    else
    {
      if (v18 == 48)
        std::__throw_format_error[abi:ne180100]("The width option should not have a leading zero");
      if ((v18 - 58) < 0xFFFFFFF6)
      {
LABEL_49:
        if ((a3 & 8) == 0 || *v4 != 46)
          goto LABEL_89;
        v20 = (unsigned __int8 *)(v4 + 1);
        if (v4 + 1 == (char *)v3)
          std::__throw_format_error[abi:ne180100]("End of input while parsing format specifier precision");
        v21 = *v20;
        if (v21 == 123)
        {
          v4 = std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(v4 + 2, (char *)v3, (uint64_t)a2);
          *(_WORD *)(a1 + 2) |= 0x8000u;
          *(_DWORD *)(a1 + 8) = v22;
        }
        else
        {
          if ((v21 - 58) <= 0xFFFFFFF5)
            std::__throw_format_error[abi:ne180100]("The precision option does not contain a value or an argument index");
          v4 = std::__format::__parse_number[abi:ne180100]<char const*>((unint64_t)v20, (char *)v3);
          *(_DWORD *)(a1 + 8) = v23;
          *(_WORD *)(a1 + 2) &= ~0x8000u;
        }
        if (v3 != (unsigned __int8 *)v4)
        {
LABEL_89:
          if ((a3 & 0x10) == 0 || *v4 != 76 || (*(_BYTE *)a1 |= 0x40u, ++v4, v4 != (char *)v3))
          {
            v24 = *v4;
            if (v24 <= 96)
            {
              v26 = v24 - 65;
              v25 = 12;
              switch(v26)
              {
                case 0:
                  goto LABEL_78;
                case 1:
                  v25 = 3;
                  goto LABEL_78;
                case 4:
                  v25 = 14;
                  goto LABEL_78;
                case 5:
                  v25 = 16;
                  goto LABEL_78;
                case 6:
                  v25 = 18;
LABEL_78:
                  *(_BYTE *)(a1 + 1) = v25;
                  ++v4;
                  break;
                default:
                  break;
              }
            }
            else
            {
              switch(*v4)
              {
                case 'a':
                  v25 = 11;
                  goto LABEL_78;
                case 'b':
                  v25 = 2;
                  goto LABEL_78;
                case 'c':
                  v25 = 10;
                  goto LABEL_78;
                case 'd':
                  v25 = 5;
                  goto LABEL_78;
                case 'e':
                  v25 = 13;
                  goto LABEL_78;
                case 'f':
                  v25 = 15;
                  goto LABEL_78;
                case 'g':
                  v25 = 17;
                  goto LABEL_78;
                case 'o':
                  v25 = 4;
                  goto LABEL_78;
                case 'p':
                  v25 = 8;
                  goto LABEL_78;
                case 's':
                  v25 = 1;
                  goto LABEL_78;
                case 'x':
                  v25 = 6;
                  goto LABEL_78;
                default:
                  break;
              }
            }
            if (v4 != (char *)v3)
            {
              v3 = (unsigned __int8 *)v4;
              if (*v4 != 125)
                std::__throw_format_error[abi:ne180100]("The format specifier should consume the input or end with a '}'");
            }
          }
        }
        return v3;
      }
      v4 = std::__format::__parse_number[abi:ne180100]<char const*>((unint64_t)v4, (char *)v3);
    }
    *(_DWORD *)(a1 + 4) = v19;
    if (v3 == (unsigned __int8 *)v4)
      return v3;
    goto LABEL_49;
  }
  return v3;
}

void std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](const char *a1)
{
  size_t v2;
  std::string *v3;
  __int128 v4;
  std::string *v5;
  __int128 v6;
  const char *v7;
  std::string v8;
  std::string v9;
  __int128 v10;
  int64_t v11;

  std::string::basic_string[abi:ne180100]<0>(&v8, "The type option contains an invalid value for ");
  v2 = strlen(a1);
  v3 = std::string::append(&v8, a1, v2);
  v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  v5 = std::string::append(&v9, " formatting argument", 0x14uLL);
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v11 = v5->__r_.__value_.__r.__words[2];
  v10 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (v11 >= 0)
    v7 = (const char *)&v10;
  else
    v7 = (const char *)v10;
  std::__throw_format_error[abi:ne180100](v7);
}

void sub_1B6130324(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;

  if (*(char *)(v21 - 25) < 0)
    operator delete(*(void **)(v21 - 48));
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

char *std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(char *a1, char *a2, uint64_t a3)
{
  char *v4;

  if (a1 == a2)
    std::__throw_format_error[abi:ne180100]("End of input while parsing an argument index");
  v4 = std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(a1, a2, a3);
  if (v4 == a2 || *v4 != 125)
    std::__throw_format_error[abi:ne180100]("The argument index is invalid");
  return v4 + 1;
}

char *std::__format::__parse_number[abi:ne180100]<char const*>(unint64_t a1, char *a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  unsigned int v4;
  int v5;
  uint64_t v6;

  if ((uint64_t)&a2[-a1] <= 9)
    v2 = (unsigned __int8 *)a2;
  else
    v2 = (unsigned __int8 *)(a1 + 9);
  v3 = (unsigned __int8 *)(a1 + 1);
  v4 = *(char *)a1 - 48;
  if ((unsigned __int8 *)(a1 + 1) == v2)
  {
LABEL_8:
    if (v2 == (unsigned __int8 *)a2)
    {
      return a2;
    }
    else
    {
      v6 = *v2;
      if ((v6 - 48) > 9)
      {
        return (char *)v2;
      }
      else if ((v6 + 10 * (unint64_t)v4 - 48) >> 31
             || (v3 = (unsigned __int8 *)(a1 + 2), (char *)(a1 + 2) != a2) && *v3 - 48 <= 9)
      {
        std::__throw_format_error[abi:ne180100]("The numeric value of the format specifier is too large");
      }
    }
  }
  else
  {
    a1 += (unint64_t)&v2[~a1];
    while (1)
    {
      v5 = *v3;
      if ((v5 - 58) < 0xFFFFFFF6)
        break;
      v4 = v5 + 10 * v4 - 48;
      if (++v3 == v2)
        goto LABEL_8;
    }
  }
  return (char *)v3;
}

uint64_t std::__unicode::__code_point_view<char>::__consume[abi:ne180100](unsigned __int8 **a1)
{
  unsigned __int8 *v1;
  int v2;
  unsigned int v3;
  int v4;
  uint64_t v5;
  char v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;

  v1 = *a1;
  v2 = **a1;
  v3 = __clz(v2 ^ 0xFF) - 24;
  if (v2 == 255)
    v4 = 8;
  else
    v4 = v3;
  switch(v4)
  {
    case 0:
      *a1 = v1 + 1;
      v5 = *v1;
      break;
    case 2:
      if (a1[1] - v1 < 2 || (v1[1] & 0xC0) != 0x80)
        goto LABEL_35;
      *a1 = v1 + 1;
      v6 = *v1;
      *a1 = v1 + 2;
      v7 = v1[1] & 0x3F | ((v6 & 0x1F) << 6);
      if (v7 >= 0x80)
        v5 = v7;
      else
        v5 = 2147549181;
      break;
    case 3:
      if (a1[1] - v1 < 3)
        goto LABEL_35;
      v8 = 1;
      do
        v9 = v1[v8] & 0xC0;
      while (v9 == 128 && (_DWORD)v8++ != 2);
      if (v9 != 128)
        goto LABEL_35;
      v5 = 2147549181;
      *a1 = v1 + 1;
      v11 = *v1 & 0xF;
      *a1 = v1 + 2;
      v12 = (v11 << 12) | ((v1[1] & 0x3F) << 6);
      *a1 = v1 + 3;
      v13 = v12 & 0xFFFFFFC0 | v1[2] & 0x3F;
      if (v13 >= 0x800)
      {
        if ((v12 & 0xF800) == 0xD800)
          v5 = 2147549181;
        else
          v5 = v13;
      }
      break;
    case 4:
      if (a1[1] - v1 < 4)
        goto LABEL_35;
      v14 = 1;
      do
        v15 = v1[v14] & 0xC0;
      while (v15 == 128 && (_DWORD)v14++ != 3);
      if (v15 != 128)
        goto LABEL_35;
      v5 = 2147549181;
      *a1 = v1 + 1;
      v17 = *v1 & 7;
      *a1 = v1 + 2;
      v18 = (v17 << 12) | ((v1[1] & 0x3F) << 6);
      *a1 = v1 + 3;
      v19 = v18 & 0xFFFFFFC0 | v1[2] & 0x3F;
      *a1 = v1 + 4;
      v20 = v1[3] & 0x3F | (v19 << 6);
      if (v20 >= 0x10000)
      {
        if (v20 >= 0x110000)
          v5 = 2147549181;
        else
          v5 = v20;
      }
      break;
    default:
LABEL_35:
      v5 = 2147549181;
      *a1 = v1 + 1;
      break;
  }
  return v5;
}

unsigned __int8 *std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(uint64_t a1, char **a2)
{
  unsigned __int8 *result;
  unsigned int v4;

  result = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(a1, a2, 40);
  v4 = *(unsigned __int8 *)(a1 + 1);
  if (v4 >= 2 && v4 != 19)
    std::__throw_format_error[abi:ne180100]("The type option contains an invalid value for a string formatting argument");
  return result;
}

_QWORD *std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  int v9;
  uint64_t v10;

  if ((a5 & 0x80000000) != 0)
    return std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, a2, a3, a4, a5);
  v9 = std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>((unsigned __int8 *)__src, a2, a5, 0);
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, v10 - (_QWORD)__src, a3, a4, a5, v9);
}

_QWORD *std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t __len, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10;

  if (a4 <= 0)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a3, __src, __len);
  }
  else
  {
    v10 = std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>((unsigned __int8 *)__src, __len, HIDWORD(a4), 1);
    std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, __len, a3, a4, a5, v10);
  }
  return a3;
}

unint64_t std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>(unsigned __int8 *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t result;
  unint64_t v6;
  uint64_t v8;
  unsigned __int8 *v9;
  int v10;
  unsigned __int8 *v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  unint64_t v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int8 v23;
  int v24;
  BOOL v25;
  BOOL v26;
  _BOOL4 v27;
  unint64_t v28;
  unsigned int *v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int *v32;
  unsigned int v33;
  BOOL v34;
  uint64_t v35;
  unint64_t v36;
  BOOL v37;
  int64_t v38;
  int v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  int v43;
  char v44;

  result = 0;
  if (a2)
  {
    v6 = a3;
    if (a3)
    {
      if ((char)*a1 < 0)
      {
        v9 = a1;
      }
      else
      {
        v8 = 0;
        v9 = &a1[a3 - 1];
        while (1)
        {
          if (a2 - 1 == v8)
            return a2;
          if (a3 - 1 == v8)
            break;
          v10 = (char)a1[++v8];
          if (v10 < 0)
          {
            v6 = a3 - v8 + 1;
            v9 = &a1[v8 - 1];
            goto LABEL_10;
          }
        }
        if (((char)a1[a3] & 0x80000000) == 0)
          return a3;
        v6 = 1;
      }
LABEL_10:
      v38 = v9 - a1;
      v11 = &a1[a2];
      v41 = v9;
      v42 = &a1[a2];
      v12 = std::__unicode::__code_point_view<char>::__consume[abi:ne180100](&v41);
      v13 = v12 & 0x7FFFFFFF;
      v43 = v12 & 0x7FFFFFFF;
      LOBYTE(v14) = std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](v12 & 0x7FFFFFFF);
      v44 = v14;
      if (v9 != v11)
      {
        v15 = 0;
        v40 = v11;
        while (1)
        {
          v16 = v41;
          if (v41 == v42)
          {
            v20 = v13;
LABEL_53:
            LOBYTE(v14) = 15;
            v44 = 15;
            goto LABEL_54;
          }
          v17 = 0;
          v18 = 1;
          v19 = v14;
          v20 = v13;
          while (2)
          {
            v21 = a4;
            v39 = v18;
            LOBYTE(v14) = v19;
            while (1)
            {
              do
              {
                while (1)
                {
                  do
                  {
                    v22 = v17;
                    v16 = v41;
                    if (v41 == v42)
                    {
                      a4 = v21;
                      v11 = v40;
                      goto LABEL_53;
                    }
                    v23 = v14;
                    v24 = std::__unicode::__code_point_view<char>::__consume[abi:ne180100](&v41);
                    v20 = v24 & 0x7FFFFFFF;
                    v43 = v24 & 0x7FFFFFFF;
                    v14 = std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](v24 & 0x7FFFFFFF);
                    v44 = v14;
                    v17 = v22 | (v23 == 3);
                  }
                  while (!v23 && v14 == 5);
                  if (v23 <= 5u && ((1 << v23) & 0x23) != 0 || v14 <= 5 && ((1 << v14) & 0x23) != 0)
                    goto LABEL_49;
                  if (v23 == 12 || v23 == 6)
                    break;
                  if (v23 != 4 || v14 - 4 >= 9 || ((0x10Du >> (v14 - 4)) & 1) == 0)
                    goto LABEL_29;
                }
              }
              while ((v14 - 11) < 2u);
LABEL_29:
              v25 = v23 == 11 || v23 == 7;
              if ((!v25 || v14 != 11) && (v14 > 0xD || ((1 << v14) & 0x2404) == 0) && v23 != 8)
              {
                v26 = v23 == 13 && v14 == 3;
                v27 = v26;
                if ((v27 & v22 & 1) == 0)
                  break;
              }
            }
            if (v23 != 9)
            {
LABEL_49:
              a4 = v21;
LABEL_50:
              v11 = v40;
              break;
            }
            a4 = v21;
            if (v14 != 9)
              goto LABEL_50;
            v18 = v39 ^ 1;
            v19 = 9;
            v11 = v40;
            if (v39)
              continue;
            break;
          }
LABEL_54:
          if ((v13 - 262142) < 0xFFFC1102)
            goto LABEL_64;
          v28 = 108;
          v29 = (unsigned int *)&std::__width_estimation_table::__entries;
          do
          {
            v30 = v28 >> 1;
            v31 = &v29[v28 >> 1];
            v33 = *v31;
            v32 = v31 + 1;
            v28 += ~(v28 >> 1);
            if ((((_DWORD)v13 << 14) | 0x3FFFu) < v33)
              v28 = v30;
            else
              v29 = v32;
          }
          while (v28);
          if (v29 == (unsigned int *)&std::__width_estimation_table::__entries)
          {
LABEL_64:
            v35 = 1;
          }
          else
          {
            v34 = (*(v29 - 1) & 0x3FFF) + (*(v29 - 1) >> 14) >= v13;
            v35 = 1;
            if (v34)
              v35 = 2;
          }
          v36 = v15 + v35;
          if ((_DWORD)a4 || v36 <= v6)
          {
            v37 = v16 == v11 || v36 > v6;
            v13 = v20;
            v15 = v36;
            if (!v37)
              continue;
          }
          return v38 + v15;
        }
      }
      v15 = 0;
      return v38 + v15;
    }
  }
  return result;
}

uint64_t std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](unsigned int a1)
{
  unint64_t v1;
  unsigned int *v2;
  unint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v1 = 1496;
  v2 = (unsigned int *)&std::__extended_grapheme_custer_property_boundary::__entries;
  do
  {
    v3 = v1 >> 1;
    v4 = &v2[v1 >> 1];
    v6 = *v4;
    v5 = v4 + 1;
    v1 += ~(v1 >> 1);
    if (((a1 << 11) | 0x7FF) < v6)
      v1 = v3;
    else
      v2 = v5;
  }
  while (v1);
  v7 = 16;
  if (v2 != (unsigned int *)&std::__extended_grapheme_custer_property_boundary::__entries)
  {
    v8 = *(v2 - 1);
    v9 = ((v8 >> 4) & 0x7F) + (v8 >> 11);
    v10 = v8 & 0xF;
    if (v9 >= a1)
      return v10;
    else
      return 16;
  }
  return v7;
}

_QWORD *std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(_QWORD *a1, uint64_t a2, uint64_t a3, char a4, int a5)
{
  char v6;
  int v7;
  char *p_src;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  unsigned __int8 v12;
  char __src;
  _BYTE v15[3];

  if ((a4 & 1) != 0)
  {
    v6 = 45;
  }
  else
  {
    v7 = (a2 >> 3) & 3;
    if (v7 == 2)
    {
      v6 = 43;
    }
    else
    {
      if (v7 != 3)
      {
        p_src = &__src;
        goto LABEL_8;
      }
      v6 = 32;
    }
  }
  p_src = v15;
  __src = v6;
LABEL_8:
  if (BYTE1(a2) <= 0x10u && ((1 << SBYTE1(a2)) & 0x15000) != 0)
  {
    v9 = 6;
  }
  else
  {
    v9 = 6;
    if (BYTE1(a2) != 18)
      v9 = 0;
  }
  v10 = 3;
  if (!a5)
    v10 = 0;
  v11 = &aInfnaninfnan[v9 + v10];
  *(_WORD *)p_src = *(_WORD *)v11;
  p_src[2] = v11[2];
  if ((a2 & 7) == 4)
    v12 = a2 & 0xF8 | 3;
  else
    v12 = a2;
  std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, p_src - &__src + 3, a1, a2 & 0xFFFFFFFFFFFFFF00 | v12, a3, p_src - &__src + 3);
  return a1;
}

_QWORD *std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,double,char>(_QWORD *a1, uint64_t a2, char **a3, std::locale *this, uint64_t a5, unint64_t a6)
{
  const std::locale::facet *v11;
  char *v12;
  char *v13;
  std::string::size_type size;
  std::string::size_type v15;
  int64_t v16;
  std::string *p_p;
  std::string::value_type v18;
  char *v19;
  char *v20;
  uint64_t v21;
  std::string::value_type *v22;
  std::string::value_type *v23;
  std::string::value_type *v24;
  int v25;
  BOOL v26;
  unint64_t v27;
  char *v28;
  std::string::size_type v29;
  int v30;
  uint64_t v31;
  char *v32;
  std::string::size_type v33;
  char *v34;
  std::string *v35;
  char *v36;
  char v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  int64_t __len;
  std::string v48;
  std::string __p;

  v11 = std::locale::use_facet(this, MEMORY[0x1E0DE4CC0]);
  ((void (*)(std::string *__return_ptr))v11->__vftable[1].__on_zero_shared)(&__p);
  v12 = a3[2];
  v13 = *a3;
  if (v12 >= a3[1])
    v12 = a3[1];
  __len = v12 - v13;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __p.__r_.__value_.__l.__size_;
    if (!__p.__r_.__value_.__l.__size_)
      goto LABEL_29;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    v16 = *__p.__r_.__value_.__l.__data_;
    if (__len <= v16)
    {
      *__p.__r_.__value_.__l.__data_ = 0;
      __p.__r_.__value_.__l.__size_ = 0;
      goto LABEL_29;
    }
    v18 = *__p.__r_.__value_.__l.__data_;
    v15 = __p.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((_BYTE *)&__p.__r_.__value_.__s + 23))
      goto LABEL_29;
    if (__len <= __p.__r_.__value_.__s.__data_[0])
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
      goto LABEL_29;
    }
    size = __p.__r_.__value_.__l.__size_;
    v15 = __p.__r_.__value_.__r.__words[0];
    v16 = __p.__r_.__value_.__s.__data_[0];
    p_p = &__p;
    v18 = __p.__r_.__value_.__s.__data_[0];
  }
  memset(&v48, 0, sizeof(v48));
  v19 = (char *)(v15 + size);
  v20 = (char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v20 = v19;
  v21 = __len - v16;
  if (__len - v16 >= 1)
  {
    v22 = v20 - 1;
    do
    {
      std::string::push_back(&v48, v18);
      if (p_p == (std::string *)v22)
      {
        v18 = *v22;
        p_p = (std::string *)v22;
      }
      else
      {
        v23 = &p_p->__r_.__value_.__s.__data_[1];
        v24 = &p_p->__r_.__value_.__s.__data_[1];
        do
        {
          v25 = *v24++;
          v18 = v25;
          if (v25)
            v26 = 1;
          else
            v26 = v23 == v22;
          v23 = v24;
        }
        while (!v26);
        p_p = (std::string *)(v24 - 1);
      }
      v21 -= v18;
    }
    while (v21 > 0);
  }
  std::string::push_back(&v48, v18 + v21);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  __p = v48;
LABEL_29:
  v27 = HIDWORD(a6);
  v28 = *(char **)(a2 + 16);
  v29 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v29 = __p.__r_.__value_.__l.__size_;
  v30 = a5 & 7;
  if (a5 >> 32 > (uint64_t)(a3[3] - v28 + *(int *)(a2 + 4) + v29 - (v29 != 0)))
  {
    if (v30 == 4)
      v31 = 3;
    else
      v31 = a5 & 7;
    __asm { BR              X12 }
  }
  if (v30 == 4 && v13 != v28)
  {
    v48.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
    std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v48, *v28);
  }
  std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, 0, v27);
  if (v30 != 4)
  {
    v32 = *(char **)(a2 + 16);
    if (v13 != v32)
    {
      v48.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
      std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v48, *v32);
    }
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v33 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if (*((_BYTE *)&__p.__r_.__value_.__s + 23))
    {
      v34 = &__p.__r_.__value_.__s.__data_[1];
      v35 = &__p;
      goto LABEL_47;
    }
LABEL_51:
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, v13, __len);
    goto LABEL_52;
  }
  v33 = __p.__r_.__value_.__l.__size_;
  if (!__p.__r_.__value_.__l.__size_)
    goto LABEL_51;
  v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
  v34 = (char *)(__p.__r_.__value_.__r.__words[0] + 1);
LABEL_47:
  v36 = (char *)v35 + v33;
  v37 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet_0)(v11);
  while (1)
  {
    v38 = v36 - 1;
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, v13, *(v36 - 1));
    if (v36 == v34)
      break;
    v13 += *(v36 - 1);
    v39 = *a1;
    v40 = a1[2];
    a1[2] = v40 + 1;
    *(_BYTE *)(v39 + v40) = v37;
    --v36;
    if (a1[2] == a1[1])
    {
      ((void (*)(_QWORD))a1[3])(*a1);
      a1[2] = 0;
      v36 = v38;
    }
  }
LABEL_52:
  v41 = a3[1];
  if (v41 != a3[3])
  {
    v42 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet)(v11);
    v43 = *a1;
    v44 = a1[2];
    a1[2] = v44 + 1;
    *(_BYTE *)(v43 + v44) = v42;
    if (a1[2] == a1[1])
    {
      ((void (*)(_QWORD))a1[3])(*a1);
      a1[2] = 0;
    }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, a3[1] + 1, a3[2] - (a3[1] + 1));
    std::__format::__output_buffer<char>::__fill[abi:ne180100](a1, *(int *)(a2 + 4), 48);
    v41 = a3[3];
  }
  v45 = a3[2];
  if (v45 != v41)
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, v45, v41 - v45);
  std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, 0, v27);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return a1;
}

void sub_1B61310D8()
{
  JUMPOUT(0x1B6130EECLL);
}

void sub_1B61310E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  __asm { BR              X10 }
}

_QWORD *sub_1B61311A4(int a1, int a2, int a3, int a4, unint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  _QWORD *v18;
  char *v19;
  size_t v20;
  size_t v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  _QWORD *v25;

  v24 = HIDWORD(a5);
  v25 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v18, v20, SHIDWORD(a5));
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v25, v23, v19 - v23);
  std::__format::__output_buffer<char>::__fill[abi:ne180100](v18, v21, 48);
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v18, v19, v22 - (_QWORD)v19);
  return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v18, 0, v24);
}

_BYTE *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,long double>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  _BYTE *result;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;

  *(_DWORD *)(a2 + 4) = 0;
  *a1 = a4;
  v6 = MEMORY[0x1BCC95BB4](a4, *(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8), 3, a3);
  a1[3] = v6;
  result = (_BYTE *)(a4 + 1);
  if (a4 + 1 == v6)
  {
    a1[1] = v6;
    a1[2] = v6;
  }
  else
  {
    v8 = v6 - (_QWORD)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a1[2] = v6;
      result = memchr(result, 46, v8);
      if (result)
        v11 = result;
      else
        v11 = (_BYTE *)v6;
      a1[1] = v11;
    }
    else
    {
      v9 = 6;
      if (v8 < 6)
        v9 = v6 - (_QWORD)result;
      v10 = -v9;
      while (*(_BYTE *)(v6 + v10) != 101)
      {
        if (++v10 == -3)
          goto LABEL_8;
      }
      v12 = v6 + v10;
      if (*result == 46)
        v13 = a4 + 1;
      else
        v13 = v6;
      a1[1] = v13;
      a1[2] = v12;
    }
  }
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,long double>(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  int v10;
  uint64_t v11;
  void *v12;

  *a1 = a5;
  v7 = a3 + a2;
  if (a4 == -1)
    result = std::to_chars();
  else
    result = MEMORY[0x1BCC95BB4](a5, v7, 4);
  a1[3] = result;
  v10 = *(unsigned __int8 *)(a5 + 1);
  v9 = a5 + 1;
  if (v10 == 46)
  {
    v11 = result - 2;
    v12 = memchr((void *)(result - 6), 112, 4uLL);
    result = v9;
    if (v12)
      v9 = (uint64_t)v12;
    else
      v9 = v11;
  }
  a1[1] = result;
  a1[2] = v9;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,long double>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *a1 = a5;
  result = MEMORY[0x1BCC95BB4](a5, a3 + a2, 1);
  a1[3] = result;
  v8 = a5 + 1;
  if (*(_BYTE *)(a5 + 1) == 46)
  {
    a1[1] = v8;
    v9 = result - a5 - 2;
    v8 = result;
    if (v9 >= 4)
    {
      v10 = 6;
      if ((unint64_t)v9 < 6)
        v10 = result - a5 - 2;
      v11 = -v10;
      while (*(_BYTE *)(result + v11) != 101)
      {
        if (++v11 == -3)
        {
          v8 = result;
          goto LABEL_11;
        }
      }
      v8 = result + v11;
    }
  }
  else
  {
    a1[1] = result;
  }
LABEL_11:
  a1[2] = v8;
  return result;
}

_BYTE *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,double>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  _BYTE *result;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;

  *(_DWORD *)(a2 + 4) = 0;
  *a1 = a4;
  v6 = MEMORY[0x1BCC95B90](a4, *(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8), 3, a3);
  a1[3] = v6;
  result = (_BYTE *)(a4 + 1);
  if (a4 + 1 == v6)
  {
    a1[1] = v6;
    a1[2] = v6;
  }
  else
  {
    v8 = v6 - (_QWORD)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a1[2] = v6;
      result = memchr(result, 46, v8);
      if (result)
        v11 = result;
      else
        v11 = (_BYTE *)v6;
      a1[1] = v11;
    }
    else
    {
      v9 = 6;
      if (v8 < 6)
        v9 = v6 - (_QWORD)result;
      v10 = -v9;
      while (*(_BYTE *)(v6 + v10) != 101)
      {
        if (++v10 == -3)
          goto LABEL_8;
      }
      v12 = v6 + v10;
      if (*result == 46)
        v13 = a4 + 1;
      else
        v13 = v6;
      a1[1] = v13;
      a1[2] = v12;
    }
  }
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,double>(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  int v10;
  uint64_t v11;
  void *v12;

  *a1 = a5;
  v7 = a3 + a2;
  if (a4 == -1)
    result = std::to_chars();
  else
    result = MEMORY[0x1BCC95B90](a5, v7, 4);
  a1[3] = result;
  v10 = *(unsigned __int8 *)(a5 + 1);
  v9 = a5 + 1;
  if (v10 == 46)
  {
    v11 = result - 2;
    v12 = memchr((void *)(result - 6), 112, 4uLL);
    result = v9;
    if (v12)
      v9 = (uint64_t)v12;
    else
      v9 = v11;
  }
  a1[1] = result;
  a1[2] = v9;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,double>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *a1 = a5;
  result = MEMORY[0x1BCC95B90](a5, a3 + a2, 1);
  a1[3] = result;
  v8 = a5 + 1;
  if (*(_BYTE *)(a5 + 1) == 46)
  {
    a1[1] = v8;
    v9 = result - a5 - 2;
    v8 = result;
    if (v9 >= 4)
    {
      v10 = 6;
      if ((unint64_t)v9 < 6)
        v10 = result - a5 - 2;
      v11 = -v10;
      while (*(_BYTE *)(result + v11) != 101)
      {
        if (++v11 == -3)
        {
          v8 = result;
          goto LABEL_11;
        }
      }
      v8 = result + v11;
    }
  }
  else
  {
    a1[1] = result;
  }
LABEL_11:
  a1[2] = v8;
  return result;
}

_BYTE *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<float,float>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  _BYTE *result;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;

  *(_DWORD *)(a2 + 4) = 0;
  *a1 = a4;
  v6 = MEMORY[0x1BCC95BD8](a4, *(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8), 3, a3);
  a1[3] = v6;
  result = (_BYTE *)(a4 + 1);
  if (a4 + 1 == v6)
  {
    a1[1] = v6;
    a1[2] = v6;
  }
  else
  {
    v8 = v6 - (_QWORD)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a1[2] = v6;
      result = memchr(result, 46, v8);
      if (result)
        v11 = result;
      else
        v11 = (_BYTE *)v6;
      a1[1] = v11;
    }
    else
    {
      v9 = 6;
      if (v8 < 6)
        v9 = v6 - (_QWORD)result;
      v10 = -v9;
      while (*(_BYTE *)(v6 + v10) != 101)
      {
        if (++v10 == -3)
          goto LABEL_8;
      }
      v12 = v6 + v10;
      if (*result == 46)
        v13 = a4 + 1;
      else
        v13 = v6;
      a1[1] = v13;
      a1[2] = v12;
    }
  }
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<float,float>(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  int v10;
  uint64_t v11;
  void *v12;

  *a1 = a5;
  v7 = a3 + a2;
  if (a4 == -1)
    result = std::to_chars();
  else
    result = MEMORY[0x1BCC95BD8](a5, v7, 4);
  a1[3] = result;
  v10 = *(unsigned __int8 *)(a5 + 1);
  v9 = a5 + 1;
  if (v10 == 46)
  {
    v11 = result - 2;
    v12 = memchr((void *)(result - 5), 112, 3uLL);
    result = v9;
    if (v12)
      v9 = (uint64_t)v12;
    else
      v9 = v11;
  }
  a1[1] = result;
  a1[2] = v9;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<float,float>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *a1 = a5;
  result = MEMORY[0x1BCC95BD8](a5, a3 + a2, 1);
  a1[3] = result;
  v8 = a5 + 1;
  if (*(_BYTE *)(a5 + 1) == 46)
  {
    a1[1] = v8;
    v9 = result - a5 - 2;
    v8 = result;
    if (v9 >= 4)
    {
      v10 = 6;
      if ((unint64_t)v9 < 6)
        v10 = result - a5 - 2;
      v11 = -v10;
      while (*(_BYTE *)(result + v11) != 101)
      {
        if (++v11 == -3)
        {
          v8 = result;
          goto LABEL_11;
        }
      }
      v8 = result + v11;
    }
  }
  else
  {
    a1[1] = result;
  }
LABEL_11:
  a1[2] = v8;
  return result;
}

uint64_t std::__format_spec::__process_parsed_integer[abi:ne180100]<char>(uint64_t result)
{
  int v1;
  _BYTE *v3;

  v1 = *(unsigned __int8 *)(result + 1);
  if ((v1 - 2) >= 6 && v1 != 0)
  {
    if (v1 != 10)
      std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("an integer");
    v3 = (_BYTE *)result;
    result = std::__format_spec::__parser<char>::__validate[abi:ne180100](result, "an integer");
    if ((*v3 & 7) == 0)
      *v3 = *v3 & 0xF8 | 1;
  }
  return result;
}

void std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  __asm { BR              X10 }
}

_QWORD *sub_1B6131880(unint64_t a1, unint64_t a2, uint64_t *a3, unint64_t a4, unint64_t a5, char a6, int a7, int a8, uint64_t a9, int a10, int a11, int a12, char a13, char __src, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  char v34;
  _BYTE v35[3];

  return std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, a6, &v34, (uint64_t)v35, 0, 0xAu);
}

_QWORD *std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, unint64_t a2, uint64_t *a3, unint64_t a4, unint64_t a5, char a6, char *__src, uint64_t a8, _BYTE *a9, unsigned int a10)
{
  char *v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char v16;
  char v17;
  int v18;
  char *v19;
  char v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unint64_t v27;
  char *v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  unint64_t v33;
  char *v34;
  char *v35;
  unint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  const std::locale::facet *v39;
  int64_t v40;
  std::string::value_type *locale;
  uint64_t v42;
  std::locale::__imp *v43;
  _QWORD *v44;
  char *v45;
  std::string::value_type v46;
  uint64_t v47;
  std::string::value_type *v48;
  std::string::value_type *v49;
  std::string::value_type *v50;
  int v51;
  BOOL v52;
  char v53;
  _QWORD *v54;
  unint64_t v55;
  unsigned __int8 v56;
  int v57;
  unsigned __int8 v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v62;
  int v63;
  char *v64;
  uint64_t v65;
  BOOL v66;
  unint64_t v67;
  std::string v72;
  std::locale v73;
  uint64_t v74;
  unsigned __int8 v75;

  v10 = (char *)a8;
  v11 = __src;
  v12 = a5;
  v13 = a4;
  v14 = a2;
  v15 = a1;
  v16 = a4;
  if ((a6 & 1) != 0)
  {
    v17 = 45;
LABEL_7:
    *__src = v17;
    v19 = __src + 1;
    goto LABEL_8;
  }
  v18 = (a4 >> 3) & 3;
  if (v18 == 2)
  {
    v17 = 43;
    goto LABEL_7;
  }
  v19 = __src;
  if (v18 == 3)
  {
    v17 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a4 & 0x20) != 0)
  {
    if (a9)
    {
      v20 = *a9;
      if (*a9)
      {
        v21 = a9 + 1;
        do
        {
          *v19++ = v20;
          v22 = *v21++;
          v20 = v22;
        }
        while (v22);
      }
    }
  }
  HIDWORD(v24) = a10;
  LODWORD(v24) = a10 - 2;
  v23 = v24 >> 1;
  if (v23 != 4)
  {
    if (v23)
    {
      if (v23 == 3)
      {
        v30 = std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)v19, a8, a1, a2);
      }
      else
      {
        if (v23 != 7)
        {
          v62 = a8 - (_QWORD)v19;
          v63 = std::__to_chars_integral_width[abi:ne180100]<unsigned __int128>(a1, a2, a10);
          if (v62 >= v63)
          {
            v10 = &v19[v63];
            v64 = v10 - 1;
            do
            {
              v65 = __udivti3();
              v66 = __PAIR128__(v14, v15) >= a10;
              *v64-- = a0123456789abcd[v15 - (_DWORD)v65 * a10];
              v15 = v65;
              v14 = v67;
            }
            while (v66);
          }
          goto LABEL_30;
        }
        v30 = std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)v19, a8, a1, a2);
      }
    }
    else
    {
      v30 = std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)v19, a8, a1, a2);
    }
LABEL_23:
    v10 = (char *)v30;
    goto LABEL_30;
  }
  v25 = a8 - (_QWORD)v19;
  if (!a2)
  {
    if (v25 <= 19)
    {
      v29 = (1233 * (64 - __clz(a1 | 1))) >> 12;
      if (v25 < v29 - (std::__itoa::__pow10_64[v29] > a1) + 1)
        goto LABEL_30;
    }
    v30 = (uint64_t)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](v19, a1);
    goto LABEL_23;
  }
  if (v25 > 38
    || (v26 = (1233 * (128 - __clz(a2))) >> 12,
        v25 >= v26 - (__PAIR128__(a2, a1) < std::__itoa::__pow10_128[v26]) + 1))
  {
    if (__PAIR128__(a2, a1) >= __PAIR128__(0x4B3B4CA85A86C47ALL, 0x98A224000000000))
    {
      *v19 = __udivti3() | 0x30;
      v31 = __udivti3();
      v19[1] = v31 / 0x5F5E100 + 48;
      *((_WORD *)v19 + 1) = std::__itoa::__digits_base_10[v31 % 0x5F5E100 / 0xF4240];
      v32 = v31 % 0x5F5E100 % 0xF4240;
      *((_WORD *)v19 + 2) = std::__itoa::__digits_base_10[v32 / 0x2710uLL];
      LOWORD(v32) = v32 % 0x2710;
      *((_WORD *)v19 + 3) = std::__itoa::__digits_base_10[(unsigned __int16)v32 / 0x64u];
      *((_WORD *)v19 + 4) = std::__itoa::__digits_base_10[(unsigned __int16)v32 % 0x64u];
      v33 = __udivti3();
      v34 = v19 + 10;
    }
    else
    {
      v27 = __udivti3();
      if (!HIDWORD(v27))
      {
        v28 = std::__itoa::__base_10_u32[abi:ne180100](v19, v27);
LABEL_29:
        v35 = v28;
        v36 = __umodti3();
        *v35 = v36 / 0x2540BE400 / 0x5F5E100 + 48;
        v37 = v36 / 0x2540BE400 % 0x5F5E100;
        *(_WORD *)(v35 + 1) = std::__itoa::__digits_base_10[v37 / 0xF4240];
        v37 %= 0xF4240u;
        *(_WORD *)(v35 + 3) = std::__itoa::__digits_base_10[v37 / 0x2710uLL];
        LOWORD(v37) = v37 % 0x2710;
        *(_WORD *)(v35 + 5) = std::__itoa::__digits_base_10[(unsigned __int16)v37 / 0x64u];
        *(_WORD *)(v35 + 7) = std::__itoa::__digits_base_10[(unsigned __int16)v37 % 0x64u];
        v10 = (char *)std::__itoa::__append10[abi:ne180100]<unsigned long long>(v35 + 9, v36 % 0x2540BE400);
        v11 = __src;
        v12 = a5;
        v13 = a4;
        goto LABEL_30;
      }
      v34 = v19;
      if (v27 > 0x2540BE3FFLL)
      {
        v34 = std::__itoa::__base_10_u32[abi:ne180100](v19, v27 / 0x2540BE400);
        v27 %= 0x2540BE400uLL;
      }
      v33 = v27;
    }
    v28 = (char *)std::__itoa::__append10[abi:ne180100]<unsigned long long>(v34, v33);
    goto LABEL_29;
  }
LABEL_30:
  v38 = a3;
  if ((v16 & 0x40) == 0)
    goto LABEL_57;
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](&v73, (uint64_t)a3);
  v39 = std::locale::use_facet(&v73, MEMORY[0x1E0DE4CC0]);
  v40 = v10 - v19;
  std::locale::~locale(&v73);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v39->__vftable[1].__on_zero_shared)(&v73, v39);
  if ((char)v75 < 0)
  {
    locale = (std::string::value_type *)v73.__locale_;
    v42 = v74;
    if (v74 && v40 > *(char *)v73.__locale_)
    {
      v43 = v73.__locale_;
      goto LABEL_38;
    }
    operator delete(v73.__locale_);
    v38 = a3;
LABEL_57:
    v55 = HIDWORD(v13);
    if ((v16 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>((_QWORD *)*v38, v11, v19 - v11);
      v56 = v13 & 0xF8 | 3;
      if (SHIDWORD(v13) >= (int)v19 - (int)v11)
        v57 = (_DWORD)v19 - (_DWORD)v11;
      else
        v57 = HIDWORD(v13);
      v55 = (HIDWORD(v13) - v57);
      v58 = 48;
      v11 = v19;
    }
    else
    {
      v58 = BYTE4(v12);
      v56 = v13;
    }
    v54 = (_QWORD *)*v38;
    v59 = v13 & 0xFFFFFF00 | (v55 << 32) | v56;
    v60 = v12 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v58 << 32);
    if ((v13 & 0xFF00) == 0x700)
      std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v11, v10, *v38, v59);
    else
      std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v11, v10 - v11, (_QWORD *)*v38, v59, v60, v10 - v11);
    return v54;
  }
  if (!v75 || v40 <= SLOBYTE(v73.__locale_))
    goto LABEL_57;
  locale = (std::string::value_type *)&v73;
  v43 = v73.__locale_;
  v42 = v74;
LABEL_38:
  v44 = (_QWORD *)*a3;
  memset(&v72, 0, sizeof(v72));
  v45 = (char *)v43 + v42;
  if ((v75 & 0x80u) == 0)
    v45 = (char *)&v73 + v75;
  v46 = *locale;
  v47 = v40 - *locale;
  if (v47 >= 1)
  {
    v48 = v45 - 1;
    do
    {
      std::string::push_back(&v72, v46);
      if (locale == v48)
      {
        v46 = *v48;
        locale = v48;
      }
      else
      {
        v49 = locale + 1;
        v50 = locale + 1;
        do
        {
          v51 = *v50++;
          v46 = v51;
          if (v51)
            v52 = 1;
          else
            v52 = v49 == v48;
          v49 = v50;
        }
        while (!v52);
        locale = v50 - 1;
      }
      v47 -= v46;
    }
    while (v47 > 0);
  }
  std::string::push_back(&v72, v46 + v47);
  v53 = ((uint64_t (*)(const std::locale::facet *))v39->__vftable[1].~facet_0)(v39);
  v54 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v44, v11, v19, (int)v10, (uint64_t *)&v72, v53, v13, v12);
  if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v72.__r_.__value_.__l.__data_);
  if ((char)v75 < 0)
    operator delete(v73.__locale_);
  return v54;
}

void sub_1B6132100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::locale a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a20 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21.__locale_);
  _Unwind_Resume(exception_object);
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  int64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  BOOL v11;
  unint64_t v12;
  _BYTE *v13;
  unint64_t v14;
  __int128 v15;

  v4 = __clz(a3 | 1) | 0x40;
  v5 = __clz(a4);
  if (a4)
    v4 = v5;
  v6 = 128 - v4;
  if (a2 - a1 < v6)
    return a2;
  v7 = a1 + v6;
  if (__PAIR128__(a4, a3) < 0x11)
  {
    v9 = a3;
    v12 = a4;
    v8 = v7;
  }
  else
  {
    v8 = a1 + v6;
    do
    {
      *((_QWORD *)&v10 + 1) = a4;
      *(_QWORD *)&v10 = a3;
      v9 = v10 >> 4;
      v11 = a3 <= 0x10F;
      v12 = a4 >> 4;
      *(_DWORD *)(v8 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v8 -= 4;
      a3 = v9;
      a4 >>= 4;
    }
    while (!v11);
  }
  v13 = (_BYTE *)(v8 - 1);
  do
  {
    v14 = v9 & 1;
    v11 = v9 <= 1;
    *((_QWORD *)&v15 + 1) = v12;
    *(_QWORD *)&v15 = v9;
    v9 = v15 >> 1;
    v12 >>= 1;
    *v13-- = a01[v14];
  }
  while (!v11);
  return v7;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  _BYTE *v11;
  unint64_t v12;
  BOOL v13;
  __int128 v14;

  v4 = __clz(a3 | 1) | 0x40;
  v5 = __clz(a4);
  if (a4)
    v4 = v5;
  v6 = (-126 - v4) / 3u;
  if (a2 - a1 < v6)
    return a2;
  v7 = a1 + v6;
  if (__PAIR128__(a4, a3) < 0x41)
  {
    v9 = a3;
    v8 = v7;
  }
  else
  {
    v8 = a1 + v6;
    do
    {
      *((_QWORD *)&v10 + 1) = a4;
      *(_QWORD *)&v10 = a3;
      v9 = v10 >> 6;
      a4 >>= 6;
      *(_WORD *)(v8 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v8 -= 2;
      a3 = v9;
    }
    while (v9 > 0x40);
  }
  v11 = (_BYTE *)(v8 - 1);
  do
  {
    v12 = v9 & 7;
    v13 = v9 <= 7;
    *((_QWORD *)&v14 + 1) = a4;
    *(_QWORD *)&v14 = v9;
    v9 = v14 >> 3;
    a4 >>= 3;
    *v11-- = a01234567[v12];
  }
  while (!v13);
  return v7;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  _BYTE *v11;
  unint64_t v12;
  BOOL v13;
  __int128 v14;

  v4 = __clz(a3 | 1) | 0x40;
  v5 = __clz(a4);
  if (a4)
    v4 = v5;
  v6 = 131 - v4;
  if (a2 - a1 < (uint64_t)(v6 >> 2))
    return a2;
  v7 = a1 + (v6 >> 2);
  if (__PAIR128__(a4, a3) < 0x101)
  {
    v9 = a3;
    v8 = v7;
  }
  else
  {
    v8 = a1 + (v6 >> 2);
    do
    {
      *((_QWORD *)&v10 + 1) = a4;
      *(_QWORD *)&v10 = a3;
      v9 = v10 >> 8;
      a4 >>= 8;
      *(_WORD *)(v8 - 2) = *(_WORD *)&std::__itoa::__base_16_lut[2 * a3];
      v8 -= 2;
      a3 = v9;
    }
    while (v9 > 0x100);
  }
  v11 = (_BYTE *)(v8 - 1);
  do
  {
    v12 = v9 & 0xF;
    v13 = v9 <= 0xF;
    *((_QWORD *)&v14 + 1) = a4;
    *(_QWORD *)&v14 = v9;
    v9 = v14 >> 4;
    a4 >>= 4;
    *v11-- = a0123456789abcd_0[v12];
  }
  while (!v13);
  return v7;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned __int128>(uint64_t a1, unint64_t a2, unsigned int a3)
{
  int v5;
  unsigned int v6;
  unsigned int v7;

  if (__PAIR128__(a2, a1) < a3)
    return 1;
  v5 = 0;
  v6 = a3 * a3;
  v7 = a3 * a3 * a3;
  while (1)
  {
    if (__PAIR128__(a2, a1) < v6)
      return v5 | 2u;
    if (__PAIR128__(a2, a1) < v7)
      return v5 | 3u;
    if (__PAIR128__(a2, a1) < v6 * v6)
      break;
    a1 = __udivti3();
    v5 += 4;
    if (__PAIR128__(a2, a1) < a3)
      return v5 | 1u;
  }
  return (v5 + 4);
}

uint64_t std::__format_spec::__parser<char>::__validate[abi:ne180100](uint64_t result, const char *a2)
{
  const char *v2;

  if ((*(_BYTE *)result & 0x18) != 0)
  {
    v2 = "sign";
    goto LABEL_11;
  }
  if ((*(_BYTE *)result & 0x20) != 0)
  {
    v2 = "alternate form";
    goto LABEL_11;
  }
  if ((*(_BYTE *)result & 7) == 4)
  {
    v2 = "zero-padding";
    goto LABEL_11;
  }
  if (*(_DWORD *)(result + 8) != -1)
  {
    v2 = "precision";
LABEL_11:
    std::__format_spec::__throw_invalid_option_format_error[abi:ne180100](a2, v2);
  }
  if (*(unsigned __int8 *)(result + 1) >= 0x20u)
    std::__throw_format_error[abi:ne180100]("The type does not fit in the mask");
  return result;
}

void std::__format_spec::__throw_invalid_option_format_error[abi:ne180100](const char *a1, const char *a2)
{
  size_t v4;
  std::string *v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  size_t v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  const char *v14;
  std::string v15;
  std::string v16;
  std::string v17;
  std::string v18;
  __int128 v19;
  int64_t v20;

  std::string::basic_string[abi:ne180100]<0>(&v15, "The format specifier for ");
  v4 = strlen(a1);
  v5 = std::string::append(&v15, a1, v4);
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  v7 = std::string::append(&v16, " does not allow the ", 0x14uLL);
  v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  v9 = strlen(a2);
  v10 = std::string::append(&v17, a2, v9);
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v18.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  v12 = std::string::append(&v18, " option", 7uLL);
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v20 = v12->__r_.__value_.__r.__words[2];
  v19 = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (v20 >= 0)
    v14 = (const char *)&v19;
  else
    v14 = (const char *)v19;
  std::__throw_format_error[abi:ne180100](v14);
}

void sub_1B61325DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;

  if (*(char *)(v28 - 25) < 0)
    operator delete(*(void **)(v28 - 48));
  if (*(char *)(v28 - 57) < 0)
    operator delete(*(void **)(v28 - 80));
  if (a28 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2, __int16 a3)
{
  __asm { BR              X10 }
}

_QWORD *sub_1B6132690(unint64_t a1, uint64_t *a2, unint64_t a3, unint64_t a4, char a5)
{
  char v6;
  _BYTE v7[6];

  return std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, &v6, (uint64_t)v7, 0, 0xAu);
}

_QWORD *std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, uint64_t *a2, unint64_t a3, unint64_t a4, char a5, char *a6, uint64_t a7, _BYTE *a8, unsigned int a9)
{
  char *v9;
  char v13;
  char v14;
  int v15;
  char *v16;
  char v17;
  unsigned __int8 *v18;
  int v19;
  char *v20;
  const std::locale::facet *v21;
  int64_t v22;
  std::string::value_type *locale;
  uint64_t v24;
  std::locale::__imp *v25;
  _QWORD *v26;
  char *v27;
  std::string::value_type v28;
  uint64_t v29;
  std::string::value_type *v30;
  std::string::value_type *v31;
  std::string::value_type *v32;
  int v33;
  BOOL v34;
  char v35;
  _QWORD *v36;
  unint64_t v37;
  unsigned __int8 v38;
  int v39;
  unsigned __int8 v40;
  uint64_t v41;
  unint64_t v42;
  std::string __p;
  std::locale v45;
  uint64_t v46;
  unsigned __int8 v47;

  v9 = a6;
  v13 = a3;
  if ((a5 & 1) != 0)
  {
    v14 = 45;
LABEL_7:
    *a6 = v14;
    v16 = a6 + 1;
    goto LABEL_8;
  }
  v15 = (a3 >> 3) & 3;
  if (v15 == 2)
  {
    v14 = 43;
    goto LABEL_7;
  }
  v16 = a6;
  if (v15 == 3)
  {
    v14 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      v17 = *a8;
      if (*a8)
      {
        v18 = a8 + 1;
        do
        {
          *v16++ = v17;
          v19 = *v18++;
          v17 = v19;
        }
        while (v19);
      }
    }
  }
  v20 = std::__to_chars_integral[abi:ne180100]<unsigned long long>(v16, a7, a1, a9);
  if ((v13 & 0x40) == 0)
    goto LABEL_40;
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](&v45, (uint64_t)a2);
  v21 = std::locale::use_facet(&v45, MEMORY[0x1E0DE4CC0]);
  v22 = v20 - v16;
  std::locale::~locale(&v45);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v21->__vftable[1].__on_zero_shared)(&v45, v21);
  if ((char)v47 < 0)
  {
    locale = (std::string::value_type *)v45.__locale_;
    v24 = v46;
    if (v46 && v22 > *(char *)v45.__locale_)
    {
      v25 = v45.__locale_;
      goto LABEL_21;
    }
    operator delete(v45.__locale_);
LABEL_40:
    v37 = HIDWORD(a3);
    if ((v13 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>((_QWORD *)*a2, v9, v16 - v9);
      v38 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v16 - (int)v9)
        v39 = (_DWORD)v16 - (_DWORD)v9;
      else
        v39 = HIDWORD(a3);
      v37 = (HIDWORD(a3) - v39);
      v40 = 48;
      v9 = v16;
    }
    else
    {
      v40 = BYTE4(a4);
      v38 = a3;
    }
    v36 = (_QWORD *)*a2;
    v41 = a3 & 0xFFFFFF00 | (v37 << 32) | v38;
    v42 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v40 << 32);
    if ((a3 & 0xFF00) == 0x700)
      std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20, *a2, v41);
    else
      std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20 - v9, (_QWORD *)*a2, v41, v42, v20 - v9);
    return v36;
  }
  if (!v47 || v22 <= SLOBYTE(v45.__locale_))
    goto LABEL_40;
  locale = (std::string::value_type *)&v45;
  v25 = v45.__locale_;
  v24 = v46;
LABEL_21:
  v26 = (_QWORD *)*a2;
  memset(&__p, 0, sizeof(__p));
  v27 = (char *)v25 + v24;
  if ((v47 & 0x80u) == 0)
    v27 = (char *)&v45 + v47;
  v28 = *locale;
  v29 = v22 - *locale;
  if (v29 >= 1)
  {
    v30 = v27 - 1;
    do
    {
      std::string::push_back(&__p, v28);
      if (locale == v30)
      {
        v28 = *v30;
        locale = v30;
      }
      else
      {
        v31 = locale + 1;
        v32 = locale + 1;
        do
        {
          v33 = *v32++;
          v28 = v33;
          if (v33)
            v34 = 1;
          else
            v34 = v31 == v30;
          v31 = v32;
        }
        while (!v34);
        locale = v32 - 1;
      }
      v29 -= v28;
    }
    while (v29 > 0);
  }
  std::string::push_back(&__p, v28 + v29);
  v35 = ((uint64_t (*)(const std::locale::facet *))v21->__vftable[1].~facet_0)(v21);
  v36 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v26, v9, v16, (int)v20, (uint64_t *)&__p, v35, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if ((char)v47 < 0)
    operator delete(v45.__locale_);
  return v36;
}

void sub_1B6132A80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15.__locale_);
  _Unwind_Resume(exception_object);
}

void std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2, __int16 a3)
{
  __asm { BR              X10 }
}

_QWORD *sub_1B6132AFC(unsigned int a1, uint64_t *a2, unint64_t a3, unint64_t a4, char a5, int a6, int a7, int a8, int a9, char a10, char __src, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  char v19;
  uint64_t v20;

  return std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, &v19, (uint64_t)&v20, 0, 0xAu);
}

_QWORD *std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unsigned int a1, uint64_t *a2, unint64_t a3, unint64_t a4, char a5, char *__src, uint64_t a7, _BYTE *a8, unsigned int a9)
{
  char *v9;
  char *v10;
  unsigned int v14;
  char v15;
  char v16;
  int v17;
  char *v18;
  char v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t v25;
  const std::locale::facet *v26;
  int64_t v27;
  std::string::value_type *locale;
  uint64_t v29;
  std::locale::__imp *v30;
  _QWORD *v31;
  char *v32;
  std::string::value_type v33;
  uint64_t v34;
  std::string::value_type *v35;
  std::string::value_type *v36;
  std::string::value_type *v37;
  int v38;
  BOOL v39;
  char v40;
  _QWORD *v41;
  unint64_t v42;
  unsigned __int8 v43;
  int v44;
  unsigned __int8 v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v49;
  int v50;
  char *v51;
  BOOL v52;
  std::string __p;
  std::locale v54;
  uint64_t v55;
  unsigned __int8 v56;

  v9 = (char *)a7;
  v10 = __src;
  v14 = a1;
  v15 = a3;
  if ((a5 & 1) != 0)
  {
    v16 = 45;
LABEL_7:
    *__src = v16;
    v18 = __src + 1;
    goto LABEL_8;
  }
  v17 = (a3 >> 3) & 3;
  if (v17 == 2)
  {
    v16 = 43;
    goto LABEL_7;
  }
  v18 = __src;
  if (v17 == 3)
  {
    v16 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      v19 = *a8;
      if (*a8)
      {
        v20 = a8 + 1;
        do
        {
          *v18++ = v19;
          v21 = *v20++;
          v19 = v21;
        }
        while (v21);
      }
    }
  }
  HIDWORD(v23) = a9;
  LODWORD(v23) = a9 - 2;
  v22 = v23 >> 1;
  switch(v22)
  {
    case 4:
      if (a7 - (uint64_t)v18 > 9
        || (v24 = (1233 * (32 - __clz(a1 | 1))) >> 12,
            a7 - (uint64_t)v18 >= (((__PAIR64__(v24, a1) - std::__itoa::__pow10_32[v24]) >> 32) + 1)))
      {
        v25 = (uint64_t)std::__itoa::__base_10_u32[abi:ne180100](v18, a1);
LABEL_17:
        v9 = (char *)v25;
      }
      break;
    case 0:
      v25 = std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)v18, a7, a1);
      goto LABEL_17;
    case 3:
      v25 = std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)v18, a7, a1);
      goto LABEL_17;
    case 7:
      v25 = std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)v18, a7, a1);
      goto LABEL_17;
    default:
      v49 = a7 - (_QWORD)v18;
      v50 = std::__to_chars_integral_width[abi:ne180100]<unsigned int>(a1, a9);
      if (v49 >= v50)
      {
        v9 = &v18[v50];
        v51 = v9 - 1;
        do
        {
          *v51-- = a0123456789abcd[v14 - v14 / a9 * a9];
          v52 = v14 >= a9;
          v14 /= a9;
        }
        while (v52);
      }
      break;
  }
  if ((v15 & 0x40) == 0)
    goto LABEL_45;
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100](&v54, (uint64_t)a2);
  v26 = std::locale::use_facet(&v54, MEMORY[0x1E0DE4CC0]);
  v27 = v9 - v18;
  std::locale::~locale(&v54);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v26->__vftable[1].__on_zero_shared)(&v54, v26);
  if ((char)v56 < 0)
  {
    locale = (std::string::value_type *)v54.__locale_;
    v29 = v55;
    if (v55 && v27 > *(char *)v54.__locale_)
    {
      v30 = v54.__locale_;
      goto LABEL_26;
    }
    operator delete(v54.__locale_);
LABEL_45:
    v42 = HIDWORD(a3);
    if ((v15 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>((_QWORD *)*a2, v10, v18 - v10);
      v43 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v18 - (int)v10)
        v44 = (_DWORD)v18 - (_DWORD)v10;
      else
        v44 = HIDWORD(a3);
      v42 = (HIDWORD(a3) - v44);
      v45 = 48;
      v10 = v18;
    }
    else
    {
      v45 = BYTE4(a4);
      v43 = a3;
    }
    v41 = (_QWORD *)*a2;
    v46 = a3 & 0xFFFFFF00 | (v42 << 32) | v43;
    v47 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v45 << 32);
    if ((a3 & 0xFF00) == 0x700)
      std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v10, v9, *a2, v46);
    else
      std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v10, v9 - v10, (_QWORD *)*a2, v46, v47, v9 - v10);
    return v41;
  }
  if (!v56 || v27 <= SLOBYTE(v54.__locale_))
    goto LABEL_45;
  locale = (std::string::value_type *)&v54;
  v30 = v54.__locale_;
  v29 = v55;
LABEL_26:
  v31 = (_QWORD *)*a2;
  memset(&__p, 0, sizeof(__p));
  v32 = (char *)v30 + v29;
  if ((v56 & 0x80u) == 0)
    v32 = (char *)&v54 + v56;
  v33 = *locale;
  v34 = v27 - *locale;
  if (v34 >= 1)
  {
    v35 = v32 - 1;
    do
    {
      std::string::push_back(&__p, v33);
      if (locale == v35)
      {
        v33 = *v35;
        locale = v35;
      }
      else
      {
        v36 = locale + 1;
        v37 = locale + 1;
        do
        {
          v38 = *v37++;
          v33 = v38;
          if (v38)
            v39 = 1;
          else
            v39 = v36 == v35;
          v36 = v37;
        }
        while (!v39);
        locale = v37 - 1;
      }
      v34 -= v33;
    }
    while (v34 > 0);
  }
  std::string::push_back(&__p, v33 + v34);
  v40 = ((uint64_t (*)(const std::locale::facet *))v26->__vftable[1].~facet_0)(v26);
  v41 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v31, v10, v18, (int)v9, (uint64_t *)&__p, v40, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if ((char)v56 < 0)
    operator delete(v54.__locale_);
  return v41;
}

void sub_1B6132FEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15.__locale_);
  _Unwind_Resume(exception_object);
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  _BYTE *v8;

  v3 = 32 - __clz(a3 | 1);
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x11)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 4;
      *(_DWORD *)(v5 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v5 -= 4;
      v7 = a3 > 0x10F;
      a3 >>= 4;
    }
    while (v7);
  }
  v8 = (_BYTE *)(v5 - 1);
  do
  {
    *v8-- = a01[v6 & 1];
    v7 = v6 > 1;
    v6 >>= 1;
  }
  while (v7);
  return v4;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  _BYTE *v7;
  BOOL v8;

  v3 = (86 * (34 - __clz(a3 | 1))) >> 8;
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x41)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 6;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x40);
  }
  v7 = (_BYTE *)(v5 - 1);
  do
  {
    *v7-- = a01234567[v6 & 7];
    v8 = v6 > 7;
    v6 >>= 3;
  }
  while (v8);
  return v4;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  _BYTE *v7;
  BOOL v8;

  v3 = (35 - __clz(a3 | 1)) >> 2;
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x101)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 8;
      *(_WORD *)(v5 - 2) = *(_WORD *)&std::__itoa::__base_16_lut[2 * a3];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x100);
  }
  v7 = (_BYTE *)(v5 - 1);
  do
  {
    *v7-- = a0123456789abcd_0[v6 & 0xF];
    v8 = v6 > 0xF;
    v6 >>= 4;
  }
  while (v8);
  return v4;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned int>(unsigned int a1, unsigned int a2)
{
  int v3;
  unsigned int v4;
  unsigned int v5;

  if (a1 < a2)
    return 1;
  v3 = 0;
  v4 = a2 * a2;
  v5 = v4 * v4;
  while (1)
  {
    if (a1 < v4)
      return v3 | 2u;
    if (a1 < a2 * a2 * a2)
      return v3 | 3u;
    if (a1 < v5)
      break;
    a1 /= v5;
    v3 += 4;
    if (a1 < a2)
      return v3 | 1u;
  }
  return (v3 + 4);
}

std::runtime_error *std::format_error::format_error[abi:ne180100](std::runtime_error *a1, const char *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&off_1E69CEEE8;
  return result;
}

void std::format_error::~format_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1BCC95CECLL);
}

void GetChannelLayoutSphericalCoordinates(AudioChannelLayout *a1, float *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  float *v9;
  float v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  float *v15;
  UInt32 v16;
  float v17;
  uint8x8_t v18;
  unsigned int v19;
  std::vector<char>::pointer begin;
  int v21;
  unint64_t v22;
  int end;
  int v24;
  AudioFormatPropertyID v25;
  float *v26;
  char *v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  _DWORD *v31;
  _DWORD *v32;
  _DWORD *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  char *v39;
  int v40;
  char *v41;
  _DWORD *v42;
  _DWORD *v43;
  _DWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  int v51;
  char *v52;
  _DWORD *v53;
  _DWORD *v54;
  _DWORD *v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  char *v60;
  char *v61;
  int v62;
  std::vector<char> outPropertyData;
  UInt32 ioPropertyDataSize;
  UInt32 inSpecifier;
  void *v66;
  _DWORD *v67;
  unint64_t v68;
  void *v69;
  _DWORD *v70;
  unint64_t v71;
  void *__p;
  _DWORD *v73;
  unint64_t v74;

  __p = 0;
  v73 = 0;
  v74 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  if (*(_DWORD *)a2 == 0x10000)
  {
    v18 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)a2 + 1));
    v18.i16[0] = vaddlv_u8(v18);
    v19 = v18.i32[0];
LABEL_24:
    LOBYTE(inSpecifier) = 0;
    std::vector<char>::vector(&outPropertyData, 0x20uLL, (const std::vector<char>::value_type *)&inSpecifier);
    begin = outPropertyData.__begin_;
    *(_QWORD *)outPropertyData.__begin_ = 0;
    *((_DWORD *)begin + 2) = 0;
    if (v19 <= 1)
      v21 = 1;
    else
      v21 = v19;
    v22 = (20 * v21 + 12);
    LOBYTE(inSpecifier) = 0;
    end = (int)outPropertyData.__end_;
    if (v22 <= outPropertyData.__end_ - begin)
    {
      if (v22 < outPropertyData.__end_ - begin)
      {
        end = (_DWORD)begin + v22;
        outPropertyData.__end_ = &begin[v22];
      }
    }
    else
    {
      std::vector<char>::__append(&outPropertyData, v22 - (outPropertyData.__end_ - begin), (std::vector<char>::const_reference)&inSpecifier);
      begin = outPropertyData.__begin_;
      end = (int)outPropertyData.__end_;
    }
    *((_DWORD *)begin + 2) = v19;
    v24 = *(_DWORD *)a2;
    inSpecifier = end - (_DWORD)begin;
    if (v24 == 0x10000)
      v25 = 1668116578;
    else
      v25 = 1668116588;
    if (v24 == 0x10000)
      v26 = a2 + 1;
    else
      v26 = a2;
    AudioFormatGetProperty(v25, 4u, v26, &inSpecifier, begin);
    v27 = outPropertyData.__begin_;
    v28 = *((unsigned int *)outPropertyData.__begin_ + 2);
    if (v28 > (outPropertyData.__end_ - outPropertyData.__begin_ - 12) / 0x14uLL)
LABEL_89:
      __assert_rtn("GetNumberChannelDescriptions", "CoreAudioBaseTypes.hpp", 2237, "GetAudioChannelLayout().mNumberChannelDescriptions <= (mStorage.size() - kHeaderSize) / sizeof(AudioChannelDescription)");
    v29 = 0;
    while (v29 < v28)
    {
      v30 = &v27[20 * v29 + 20];
      v31 = v73;
      if ((unint64_t)v73 >= v74)
      {
        v33 = __p;
        v34 = ((char *)v73 - (_BYTE *)__p) >> 2;
        v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) >> 62)
          goto LABEL_98;
        v36 = v74 - (_QWORD)__p;
        if ((uint64_t)(v74 - (_QWORD)__p) >> 1 > v35)
          v35 = v36 >> 1;
        if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL)
          v37 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v37 = v35;
        if (v37)
        {
          v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v74, v37);
          v33 = __p;
          v31 = v73;
        }
        else
        {
          v38 = 0;
        }
        v39 = &v38[4 * v34];
        *(_DWORD *)v39 = *(_DWORD *)v30;
        v32 = v39 + 4;
        while (v31 != v33)
        {
          v40 = *--v31;
          *((_DWORD *)v39 - 1) = v40;
          v39 -= 4;
        }
        __p = v39;
        v73 = v32;
        v74 = (unint64_t)&v38[4 * v37];
        if (v33)
          operator delete(v33);
      }
      else
      {
        *v73 = *(_DWORD *)v30;
        v32 = v31 + 1;
      }
      v73 = v32;
      v41 = &outPropertyData.__begin_[20 * v29 + 24];
      v42 = v70;
      if ((unint64_t)v70 >= v71)
      {
        v44 = v69;
        v45 = ((char *)v70 - (_BYTE *)v69) >> 2;
        v46 = v45 + 1;
        if ((unint64_t)(v45 + 1) >> 62)
          goto LABEL_98;
        v47 = v71 - (_QWORD)v69;
        if ((uint64_t)(v71 - (_QWORD)v69) >> 1 > v46)
          v46 = v47 >> 1;
        if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL)
          v48 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v48 = v46;
        if (v48)
        {
          v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v71, v48);
          v44 = v69;
          v42 = v70;
        }
        else
        {
          v49 = 0;
        }
        v50 = &v49[4 * v45];
        *(_DWORD *)v50 = *(_DWORD *)v41;
        v43 = v50 + 4;
        while (v42 != v44)
        {
          v51 = *--v42;
          *((_DWORD *)v50 - 1) = v51;
          v50 -= 4;
        }
        v69 = v50;
        v70 = v43;
        v71 = (unint64_t)&v49[4 * v48];
        if (v44)
          operator delete(v44);
      }
      else
      {
        *v70 = *(_DWORD *)v41;
        v43 = v42 + 1;
      }
      v70 = v43;
      v52 = &outPropertyData.__begin_[20 * v29 + 28];
      v53 = v67;
      if ((unint64_t)v67 >= v68)
      {
        v55 = v66;
        v56 = ((char *)v67 - (_BYTE *)v66) >> 2;
        v57 = v56 + 1;
        if ((unint64_t)(v56 + 1) >> 62)
LABEL_98:
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v58 = v68 - (_QWORD)v66;
        if ((uint64_t)(v68 - (_QWORD)v66) >> 1 > v57)
          v57 = v58 >> 1;
        if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFFCLL)
          v59 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v59 = v57;
        if (v59)
        {
          v60 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v68, v59);
          v55 = v66;
          v53 = v67;
        }
        else
        {
          v60 = 0;
        }
        v61 = &v60[4 * v56];
        *(_DWORD *)v61 = *(_DWORD *)v52;
        v54 = v61 + 4;
        while (v53 != v55)
        {
          v62 = *--v53;
          *((_DWORD *)v61 - 1) = v62;
          v61 -= 4;
        }
        v66 = v61;
        v67 = v54;
        v68 = (unint64_t)&v60[4 * v59];
        if (v55)
          operator delete(v55);
      }
      else
      {
        *v67 = *(_DWORD *)v52;
        v54 = v53 + 1;
      }
      v67 = v54;
      ++v29;
      v27 = outPropertyData.__begin_;
      v28 = *((unsigned int *)outPropertyData.__begin_ + 2);
      if (v28 > (outPropertyData.__end_ - outPropertyData.__begin_ - 12) / 0x14uLL)
        goto LABEL_89;
    }
    outPropertyData.__end_ = v27;
    operator delete(v27);
    goto LABEL_91;
  }
  if (*(_DWORD *)a2)
  {
    v19 = (unsigned __int16)*(_DWORD *)a2;
    goto LABEL_24;
  }
  v4 = *((unsigned int *)a2 + 2);
  LODWORD(outPropertyData.__begin_) = 0;
  std::vector<float>::resize((uint64_t)&__p, v4, &outPropertyData);
  v5 = *((unsigned int *)a2 + 2);
  LODWORD(outPropertyData.__begin_) = 0;
  std::vector<float>::resize((uint64_t)&v69, v5, &outPropertyData);
  v6 = *((unsigned int *)a2 + 2);
  LODWORD(outPropertyData.__begin_) = 0;
  std::vector<float>::resize((uint64_t)&v66, v6, &outPropertyData);
  v7 = *((unsigned int *)a2 + 2);
  if ((_DWORD)v7)
  {
    v8 = 0;
    v9 = a2 + 7;
    do
    {
      if ((*(_DWORD *)(v9 - 3) & 3) == 1)
      {
        v12 = *(v9 - 2);
        v13 = *(v9 - 1);
        v14 = *v9;
        v15 = (float *)v66;
        *((float *)v66 + v8) = sqrtf((float)((float)(v13 * v13) + (float)(v12 * v12)) + (float)(*v9 * *v9));
        if (fabsf(v12) < 0.000001 && fabsf(v13) < 0.000001)
        {
          *((_DWORD *)__p + v8) = 0;
          if (v14 <= 0.0)
          {
            if (v14 < 0.0)
              *((_DWORD *)v69 + v8) = -1028390912;
            else
              *((_DWORD *)v69 + v8) = 0;
          }
          else
          {
            *((_DWORD *)v69 + v8) = 1119092736;
          }
          goto LABEL_17;
        }
        v17 = atan2f(v12, v13) * 57.2957795;
        *((float *)__p + v8) = v17;
        v10 = asinf(v14 / v15[v8]) * 57.2957795;
        v11 = (float *)v69;
      }
      else
      {
        if ((*(_DWORD *)(v9 - 3) & 3) != 2)
        {
          v16 = *((_DWORD *)v9 - 4);
          ioPropertyDataSize = 20;
          inSpecifier = v16;
          if (!AudioFormatGetProperty(0x6473636Cu, 4u, &inSpecifier, &ioPropertyDataSize, &outPropertyData))
          {
            *((_DWORD *)__p + v8) = outPropertyData.__end_;
            *((_DWORD *)v69 + v8) = HIDWORD(outPropertyData.__end_);
            *((_DWORD *)v66 + v8) = outPropertyData.__end_cap_.__value_;
          }
          v7 = *((unsigned int *)a2 + 2);
          goto LABEL_17;
        }
        *((float *)__p + v8) = *(v9 - 2);
        *((float *)v69 + v8) = *(v9 - 1);
        v10 = *v9;
        v11 = (float *)v66;
      }
      v11[v8] = v10;
LABEL_17:
      v9 += 5;
      ++v8;
    }
    while (v8 < v7);
  }
LABEL_91:
  *(_QWORD *)&a1->mChannelLayoutTag = 0;
  *(_QWORD *)&a1->mNumberChannelDescriptions = 0;
  *(_QWORD *)&a1->mChannelDescriptions[0].mChannelFlags = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1, __p, (uint64_t)v73, ((char *)v73 - (_BYTE *)__p) >> 2);
  *(_QWORD *)&a1->mChannelDescriptions[0].mCoordinates[1] = 0;
  *(_QWORD *)&a1[1].mChannelLayoutTag = 0;
  *(_QWORD *)&a1[1].mNumberChannelDescriptions = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&a1->mChannelDescriptions[0].mCoordinates[1], v69, (uint64_t)v70, ((char *)v70 - (_BYTE *)v69) >> 2);
  *(_QWORD *)&a1[1].mChannelDescriptions[0].mChannelFlags = 0;
  *(_QWORD *)&a1[1].mChannelDescriptions[0].mCoordinates[1] = 0;
  *(_QWORD *)&a1[2].mChannelLayoutTag = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&a1[1].mChannelDescriptions[0].mChannelFlags, v66, (uint64_t)v67, ((char *)v67 - (_BYTE *)v66) >> 2);
  if (v66)
  {
    v67 = v66;
    operator delete(v66);
  }
  if (v69)
  {
    v70 = v69;
    operator delete(v69);
  }
  if (__p)
  {
    v73 = __p;
    operator delete(__p);
  }
}

void sub_1B6133908(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p)
    operator delete(__p);
  if (a14)
    operator delete(a14);
  if (a17)
    operator delete(a17);
  if (a20)
    operator delete(a20);
  _Unwind_Resume(exception_object);
}

__n128 std::__memberwise_forward_assign[abi:ne180100]<std::tuple<std::vector<float> &,std::vector<float> &,std::vector<float> &>,std::tuple<std::vector<float>,std::vector<float>,std::vector<float>>,std::vector<float>,std::vector<float>,std::vector<float>,0ul,1ul,2ul>(void ***a1, uint64_t a2)
{
  void **v4;
  void *v5;
  void **v6;
  void *v7;
  void **v8;
  void *v9;
  __n128 result;

  v4 = *a1;
  v5 = **a1;
  if (v5)
  {
    v4[1] = v5;
    operator delete(v5);
    *v4 = 0;
    v4[1] = 0;
    v4[2] = 0;
  }
  *(_OWORD *)v4 = *(_OWORD *)a2;
  v4[2] = *(void **)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v6 = a1[1];
  v7 = *v6;
  if (*v6)
  {
    v6[1] = v7;
    operator delete(v7);
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
  }
  *(_OWORD *)v6 = *(_OWORD *)(a2 + 24);
  v6[2] = *(void **)(a2 + 40);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v8 = a1[2];
  v9 = *v8;
  if (*v8)
  {
    v8[1] = v9;
    operator delete(v9);
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
  }
  result = *(__n128 *)(a2 + 48);
  *(__n128 *)v8 = result;
  v8[2] = *(void **)(a2 + 64);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  return result;
}

void std::vector<char>::__append(std::vector<char> *this, std::vector<char>::size_type __n, std::vector<char>::const_reference __x)
{
  std::vector<char>::size_type v4;
  char *value;
  char *end;
  int64_t v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  std::vector<char>::value_type *v16;
  std::vector<char>::pointer begin;
  char v18;

  v4 = __n;
  end = this->__end_;
  value = this->__end_cap_.__value_;
  if (value - end >= __n)
  {
    if (__n)
    {
      v13 = &end[__n];
      do
      {
        *end++ = *__x;
        --v4;
      }
      while (v4);
      end = v13;
    }
    this->__end_ = end;
  }
  else
  {
    v8 = end - this->__begin_;
    v9 = v8 + __n;
    if ((uint64_t)(v8 + __n) < 0)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v10 = value - this->__begin_;
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)operator new(v11);
    else
      v12 = 0;
    v14 = &v12[v8];
    v15 = &v12[v8 + v4];
    v16 = &v12[v8];
    do
    {
      *v16++ = *__x;
      --v4;
    }
    while (v4);
    begin = this->__begin_;
    if (end != this->__begin_)
    {
      do
      {
        v18 = *--end;
        *--v14 = v18;
      }
      while (end != begin);
      end = this->__begin_;
    }
    this->__begin_ = v14;
    this->__end_ = v15;
    this->__end_cap_.__value_ = &v12[v11];
    if (end)
      operator delete(end);
  }
}

void GetChannelLayoutSphericalCoordinates(AudioChannelLayout *a1)
{
  std::vector<char>::pointer begin;
  std::vector<char> __p;
  std::vector<char>::value_type __x;

  __x = 0;
  std::vector<char>::vector(&__p, 0x20uLL, &__x);
  begin = __p.__begin_;
  *((_DWORD *)__p.__begin_ + 1) = 0;
  *((_DWORD *)begin + 2) = 0;
  *(_DWORD *)begin = 6619138;
  GetChannelLayoutSphericalCoordinates(a1, (float *)begin);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_1B6133BF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void GetChannelLayoutChannelLabels(const AudioChannelLayout *this, int *a2)
{
  unsigned int v4;
  uint8x8_t v5;
  uint64_t v6;
  std::vector<char>::pointer begin;
  unsigned int v8;
  char *v9;
  int end;
  _DWORD *v11;
  int *v12;
  int v13;
  int v14;
  AudioFormatPropertyID v15;
  int *v16;
  char *v17;
  std::vector<char>::pointer v18;
  _DWORD *v19;
  int v20;
  std::vector<char>::value_type v21[4];
  std::vector<char> __x;

  if (*a2 == 0x10000)
  {
    v5 = (uint8x8_t)vcnt_s8((int8x8_t)a2[1]);
    v5.i16[0] = vaddlv_u8(v5);
    v4 = v5.i32[0];
  }
  else if (*a2)
  {
    v4 = (unsigned __int16)*a2;
  }
  else
  {
    v4 = a2[2];
  }
  v6 = v4;
  LODWORD(__x.__begin_) = -1;
  std::vector<unsigned int>::vector((std::vector<unsigned int> *)this, v4, (const std::vector<unsigned int>::value_type *)&__x);
  if (*a2)
  {
    v21[0] = 0;
    std::vector<char>::vector(&__x, 0x20uLL, v21);
    begin = __x.__begin_;
    *(_QWORD *)__x.__begin_ = 0;
    *((_DWORD *)begin + 2) = 0;
    if (v4 <= 1)
      v8 = 1;
    else
      v8 = v4;
    v9 = (char *)(20 * v8 + 12);
    v21[0] = 0;
    end = (int)__x.__end_;
    if (v9 <= (std::vector<char>::pointer)(__x.__end_ - begin))
    {
      if (v9 < (std::vector<char>::pointer)(__x.__end_ - begin))
      {
        end = (_DWORD)begin + (_DWORD)v9;
        __x.__end_ = &v9[(_QWORD)begin];
      }
    }
    else
    {
      std::vector<char>::__append(&__x, (std::vector<char>::size_type)&v9[-(__x.__end_ - begin)], v21);
      begin = __x.__begin_;
      end = (int)__x.__end_;
    }
    *((_DWORD *)begin + 2) = v4;
    v14 = *a2;
    *(_DWORD *)v21 = end - (_DWORD)begin;
    if (v14 == 0x10000)
      v15 = 1668116578;
    else
      v15 = 1668116588;
    if (v14 == 0x10000)
      v16 = a2 + 1;
    else
      v16 = a2;
    AudioFormatGetProperty(v15, 4u, v16, (UInt32 *)v21, begin);
    v17 = __x.__begin_;
    if (v4)
    {
      v18 = __x.__begin_ + 12;
      v19 = *(_DWORD **)&this->mChannelLayoutTag;
      do
      {
        v20 = *(_DWORD *)v18;
        v18 += 20;
        *v19++ = v20;
        --v6;
      }
      while (v6);
    }
    else if (!__x.__begin_)
    {
      return;
    }
    __x.__end_ = v17;
    operator delete(v17);
  }
  else if (v4)
  {
    v11 = *(_DWORD **)&this->mChannelLayoutTag;
    v12 = a2 + 3;
    do
    {
      v13 = *v12;
      v12 += 5;
      *v11++ = v13;
      --v6;
    }
    while (v6);
  }
}

void sub_1B6133D84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v11;
  void *v13;

  if (__p)
    operator delete(__p);
  v13 = *(void **)v11;
  if (*(_QWORD *)v11)
  {
    *(_QWORD *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n, const std::vector<unsigned int>::value_type *__x)
{
  std::vector<unsigned int>::pointer end;
  unsigned int *v7;
  std::vector<unsigned int>::size_type v8;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<unsigned int>::__vallocate[abi:ne180100](this, __n);
    end = this->__end_;
    v7 = &end[__n];
    v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_1B6133E20(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<unsigned int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz, std::vector<unsigned int>::const_reference __x)
{
  std::vector<unsigned int>::pointer end;
  std::vector<unsigned int>::pointer begin;
  std::vector<unsigned int>::size_type v7;
  std::__compressed_pair<unsigned int *> *p_end_cap;
  unsigned int *value;
  unint64_t v11;
  std::vector<unsigned int>::size_type v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  std::vector<unsigned int>::size_type v18;
  unsigned int *v19;
  unsigned int *v20;
  std::vector<unsigned int>::pointer v21;
  std::vector<unsigned int>::pointer i;
  unsigned int v23;
  unsigned int *v24;
  std::vector<unsigned int>::size_type v25;

  begin = this->__begin_;
  end = this->__end_;
  v7 = end - this->__begin_;
  if (__sz <= v7)
  {
    if (__sz < v7)
      this->__end_ = &begin[__sz];
  }
  else
  {
    p_end_cap = &this->__end_cap_;
    value = this->__end_cap_.__value_;
    if (__sz - v7 <= value - end)
    {
      v24 = &end[__sz - v7];
      v25 = 4 * __sz - 4 * v7;
      do
      {
        *end++ = *__x;
        v25 -= 4;
      }
      while (v25);
      this->__end_ = v24;
    }
    else
    {
      if (__sz >> 62)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v11 = (char *)value - (char *)begin;
      v12 = ((char *)value - (char *)begin) >> 1;
      if (v12 <= __sz)
        v12 = __sz;
      if (v11 >= 0x7FFFFFFFFFFFFFFCLL)
        v13 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)p_end_cap, v13);
      v16 = (unsigned int *)&v14[4 * v7];
      v17 = (unsigned int *)&v14[4 * __sz];
      v18 = 4 * __sz - 4 * v7;
      v19 = v16;
      do
      {
        *v19++ = *__x;
        v18 -= 4;
      }
      while (v18);
      v20 = (unsigned int *)&v14[4 * v15];
      v21 = this->__begin_;
      for (i = this->__end_; i != v21; --i)
      {
        v23 = *(i - 1);
        *--v16 = v23;
      }
      this->__begin_ = v16;
      this->__end_ = v17;
      this->__end_cap_.__value_ = v20;
      if (v21)
        operator delete(v21);
    }
  }
}

void SpectralProfile::SetProfile(SpectralProfile *this, CFTypeRef cf)
{
  unint64_t v2;
  NSObject *v5;
  const char *v6;
  os_log_type_t v7;
  const __CFData *v8;
  unsigned int Length;
  unsigned int v10;
  const UInt8 *BytePtr;
  _DWORD *v12;
  uint64_t v13;
  unsigned int v14;
  CAXException *exception;
  CAXException *v16;
  CAXException *v17;
  int v18;
  CFDataRef theData;
  void *value;
  unsigned int valuePtr;
  _BYTE buf[18];
  __int16 v23;
  unsigned int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!cf)
  {
    exception = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(exception, "The CFDictionary object is invalid.", -1);
  }
  CFRetain(cf);
  valuePtr = 0;
  value = 0;
  if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)cf, CFSTR("SampleRate"), (const void **)&value))
  {
    CFRelease(cf);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "SpectralProfile.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 75;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d Sample rate is not present in the dictionary.\n", buf, 0x12u);
    }
    v16 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v16, "Sample rate is not present in the dictionary.", -1);
  }
  if (CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
      goto LABEL_9;
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "SpectralProfile.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 66;
    v23 = 1024;
    v24 = valuePtr;
    v5 = MEMORY[0x1E0C81028];
    v6 = "%25s:%-5d Successfully retrieved sample rate (%iHz).\n";
    v7 = OS_LOG_TYPE_INFO;
  }
  else
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_9;
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "SpectralProfile.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 68;
    v23 = 1024;
    v24 = valuePtr;
    v5 = MEMORY[0x1E0C81028];
    v6 = "%25s:%-5d Sample rate retrieved ambiguously (%iHz).\n";
    v7 = OS_LOG_TYPE_DEFAULT;
  }
  _os_log_impl(&dword_1B5ED0000, v5, v7, v6, buf, 0x18u);
LABEL_9:
  theData = 0;
  if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)cf, CFSTR("NoiseProfile"), (const void **)&theData))
  {
    CFRelease(cf);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "SpectralProfile.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 97;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d Profile vector is not present in the dictionary.\n", buf, 0x12u);
    }
    v17 = (CAXException *)__cxa_allocate_exception(0x110uLL);
    CAXException::CAXException(v17, "Profile vector is not present in the dictionary.", -1);
  }
  v8 = theData;
  Length = CFDataGetLength(theData);
  v10 = Length >> 2;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "SpectralProfile.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 105;
    v23 = 1024;
    v24 = Length >> 2;
    _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO, "%25s:%-5d Successfully retrieved profile vector (length %i).\n", buf, 0x18u);
  }
  v18 = 0;
  std::vector<float>::vector(buf, v10, &v18);
  BytePtr = CFDataGetBytePtr(v8);
  if (Length >= 4)
  {
    v12 = *(_DWORD **)buf;
    if (v10 <= 1)
      v13 = 1;
    else
      v13 = v10;
    do
    {
      v14 = *(_DWORD *)BytePtr;
      BytePtr += 4;
      *v12++ = bswap32(v14);
      --v13;
    }
    while (v13);
  }
  CFRelease(cf);
  LODWORD(v2) = valuePtr;
  if (buf != (_BYTE *)this)
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this, *(char **)buf, *(uint64_t *)&buf[8], (uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 2);
  *((double *)this + 3) = (double)v2;
  *((_DWORD *)this + 8) = 2 * v10;
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
}

void sub_1B613438C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  void *v14;

  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void CAXException::CAXException(CAXException *this, const char *__s, int a3)
{
  size_t v5;
  char *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  *(_QWORD *)this = &off_1E69EE170;
  *((_DWORD *)this + 66) = a3;
  if (__s)
  {
    v5 = strlen(__s);
    v6 = (char *)this + 8;
    if (v5 < 0x100)
    {
      strlcpy(v6, __s, 0x100uLL);
    }
    else
    {
      v7 = *(_OWORD *)__s;
      v8 = *((_OWORD *)__s + 1);
      v9 = *((_OWORD *)__s + 3);
      *(_OWORD *)((char *)this + 40) = *((_OWORD *)__s + 2);
      *(_OWORD *)((char *)this + 56) = v9;
      *(_OWORD *)v6 = v7;
      *(_OWORD *)((char *)this + 24) = v8;
      v10 = *((_OWORD *)__s + 4);
      v11 = *((_OWORD *)__s + 5);
      v12 = *((_OWORD *)__s + 7);
      *(_OWORD *)((char *)this + 104) = *((_OWORD *)__s + 6);
      *(_OWORD *)((char *)this + 120) = v12;
      *(_OWORD *)((char *)this + 72) = v10;
      *(_OWORD *)((char *)this + 88) = v11;
      v13 = *((_OWORD *)__s + 8);
      v14 = *((_OWORD *)__s + 9);
      v15 = *((_OWORD *)__s + 11);
      *(_OWORD *)((char *)this + 168) = *((_OWORD *)__s + 10);
      *(_OWORD *)((char *)this + 184) = v15;
      *(_OWORD *)((char *)this + 136) = v13;
      *(_OWORD *)((char *)this + 152) = v14;
      v16 = *((_OWORD *)__s + 12);
      v17 = *((_OWORD *)__s + 13);
      v18 = *((_OWORD *)__s + 14);
      *(_OWORD *)((char *)this + 247) = *(_OWORD *)(__s + 239);
      *(_OWORD *)((char *)this + 216) = v17;
      *(_OWORD *)((char *)this + 232) = v18;
      *(_OWORD *)((char *)this + 200) = v16;
      *((_BYTE *)this + 263) = 0;
    }
  }
  else
  {
    *((_BYTE *)this + 8) = 0;
  }
}

void sub_1B6134480(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void SpectralProfile::GetProfile(SpectralProfile *this, double a2, uint64_t a3, unsigned int a4, float a5, unsigned int a6)
{
  unint64_t v11;
  float *v12;
  uint64_t v13;
  unint64_t v14;
  double v15;
  uint64_t v17;
  float v18;
  float v19;
  float v20;
  float *v21;
  float v22;
  float v23;
  unsigned int v24;
  unint64_t v25;
  float v26;
  float v27;
  void *__p[2];
  uint64_t v29;
  float v30;

  v30 = a5;
  v11 = a4;
  std::vector<float>::vector(__p, a4, &v30);
  v12 = *(float **)a3;
  v13 = *(_QWORD *)(a3 + 8);
  if (v13 == *(_QWORD *)a3)
  {
LABEL_12:
    *(_OWORD *)this = *(_OWORD *)__p;
    *((_QWORD *)this + 2) = v29;
    return;
  }
  v14 = (v13 - *(_QWORD *)a3) >> 2;
  v15 = *(double *)(a3 + 24);
  if (v14 != v11 || v15 != a2)
  {
    if (a4)
    {
      v17 = 0;
      v18 = a2;
      v19 = v18 / (float)a6;
      v20 = v15;
      v21 = (float *)__p[0];
      v22 = (float)*(unsigned int *)(a3 + 32) / v20;
      do
      {
        v23 = v19 * (float)v17;
        v24 = vcvtms_u32_f32(v22 * v23);
        v25 = v24 + 1;
        if (v14 <= v25)
        {
          v27 = *(float *)(v13 - 4);
        }
        else
        {
          v26 = -(float)(floorf(v22 * v23) - (float)(v23 * v22));
          v27 = (float)((float)(1.0 - v26) * v12[v24]) + (float)(v12[v25] * v26);
        }
        v21[v17++] = v27;
      }
      while (v11 != v17);
    }
    goto LABEL_12;
  }
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(this, v12, v13, v11);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1B61345CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t VoiceProcessorV2::PreflightDownlink(VoiceProcessorV2 *this, unsigned int ExpectedNumberOfOutputFrames, unsigned int *a3, unsigned int *a4)
{
  unsigned int *v7;
  unsigned int v8;
  float v9;
  uint64_t v10;
  CA::AudioSampleRateConverter **v11;
  CA::AudioSampleRateConverter **v12;
  int v13;
  unsigned int RequiredNumberOfInputFrames;
  unsigned int v15;

  v7 = (unsigned int *)((char *)this + 2484);
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 + 1, v7));
  if (*((_DWORD *)this + 620))
  {
    v9 = flt_1B662C470[*((_BYTE *)this + 476) == 0];
    if (*((_BYTE *)this + 476))
      VoiceProcessorV2::LogIOError((uint64_t)this, v9, (float)*((unsigned int *)this + 3112), (float)*((unsigned int *)this + 3113), 0.0, "preflight downlink: tryer acquire failed");
    else
      VoiceProcessorV2::LogIOError((uint64_t)this, v9, (float)*((unsigned int *)this + 3112), (float)*((unsigned int *)this + 3113), 0.0, "preflight downlink: not ok to process?!");
LABEL_7:
    CADeprecated::CAMutex::Lock((VoiceProcessorV2 *)((char *)this + 2576));
    ++*((_DWORD *)this + 3112);
    CADeprecated::CAMutex::Unlock((VoiceProcessorV2 *)((char *)this + 2576));
    v10 = 1937006964;
    if (*((_DWORD *)this + 3112) == 1)
      VoiceProcessorV2::LogNonTransientErrors(this, 0);
    goto LABEL_21;
  }
  if (!*((_BYTE *)this + 476))
  {
    VoiceProcessorV2::LogIOError((uint64_t)this, 32.005, (float)*((unsigned int *)this + 3112), (float)*((unsigned int *)this + 3113), 0.0, "preflight downlink: not ok to process?!");
    goto LABEL_7;
  }
  v11 = (CA::AudioSampleRateConverter **)*((_QWORD *)this + 47);
  if (v11)
    ExpectedNumberOfOutputFrames = CA::AudioSampleRateConverter::GetExpectedNumberOfOutputFrames(*v11);
  v12 = (CA::AudioSampleRateConverter **)*((_QWORD *)this + 48);
  if (!v12)
  {
    v13 = ExpectedNumberOfOutputFrames / *((_DWORD *)this + 121) * *((_DWORD *)this + 121);
    goto LABEL_17;
  }
  v13 = CA::AudioSampleRateConverter::GetExpectedNumberOfOutputFrames(*v12)
      / *((_DWORD *)this + 121)
      * *((_DWORD *)this + 121);
  if (!*((_QWORD *)this + 48))
  {
LABEL_17:
    RequiredNumberOfInputFrames = v13;
    goto LABEL_18;
  }
  RequiredNumberOfInputFrames = AudioSampleRateConverterGetRequiredNumberOfInputFrames();
LABEL_18:
  if (*((_QWORD *)this + 47))
    RequiredNumberOfInputFrames = AudioSampleRateConverterGetRequiredNumberOfInputFrames();
  v10 = 0;
  *a3 = RequiredNumberOfInputFrames;
  *a4 = v13;
  do
LABEL_21:
    v15 = __ldaxr(v7);
  while (__stlxr(v15 - 1, v7));
  return v10;
}

void sub_1B6134774(_Unwind_Exception *a1)
{
  unsigned int *v1;
  unsigned int v2;

  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2OutputElement::~AUSpatialMixerV2OutputElement(AUSpatialMixerV2OutputElement *this)
{
  _QWORD *v2;
  void *v3;

  *(_QWORD *)this = off_1E69C7E08;
  *((_QWORD *)this + 22) = &unk_1E69C7EB0;
  *((_QWORD *)this + 28) = &off_1E69E0768;
  std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(*((_QWORD **)this + 34));
  if (*((char *)this + 255) < 0)
    operator delete(*((void **)this + 29));
  if (*((char *)this + 223) < 0)
    operator delete(*((void **)this + 25));
  *(_QWORD *)this = off_1E69ED7C0;
  v2 = (_QWORD *)*((_QWORD *)this + 19);
  if (v2)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v2);
    *((_QWORD *)this + 19) = 0;
  }
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 36) = 0;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
  }
  ausdk::AUElement::~AUElement((const void **)this);
}

{
  _QWORD *v2;
  void *v3;

  *(_QWORD *)this = off_1E69C7E08;
  *((_QWORD *)this + 22) = &unk_1E69C7EB0;
  *((_QWORD *)this + 28) = &off_1E69E0768;
  std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(*((_QWORD **)this + 34));
  if (*((char *)this + 255) < 0)
    operator delete(*((void **)this + 29));
  if (*((char *)this + 223) < 0)
    operator delete(*((void **)this + 25));
  *(_QWORD *)this = off_1E69ED7C0;
  v2 = (_QWORD *)*((_QWORD *)this + 19);
  if (v2)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v2);
    *((_QWORD *)this + 19) = 0;
  }
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 36) = 0;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
  }
  ausdk::AUElement::~AUElement((const void **)this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t ausdk::AUElement::GetNumberOfParameters(ausdk::AUElement *this)
{
  uint64_t v1;
  uint64_t v2;
  char v3;
  uint64_t v4;

  v1 = 56;
  if (!*((_BYTE *)this + 40))
    v1 = 24;
  v2 = 48;
  if (!*((_BYTE *)this + 40))
    v2 = 16;
  v3 = 2;
  v4 = *(_QWORD *)((char *)this + v1);
  if (!*((_BYTE *)this + 40))
    v3 = 3;
  return (v4 - *(_QWORD *)((char *)this + v2)) >> v3;
}

uint64_t AUSpatialMixerV2OutputElement::SetStreamFormat(AUSpatialMixerV2OutputElement *this, const AudioChannelLayout *a2)
{
  int16x8_t v4;
  NSObject *v5;
  _QWORD *v6;
  void **v7;
  int v8;
  const AudioChannelLayout *v9;
  NSObject *v10;
  _QWORD *v11;
  uint64_t v12;
  void *__p[2];
  char v15;
  _BYTE buf[32];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = *(int16x8_t *)&a2->mChannelDescriptions[0].mChannelFlags;
  *(_OWORD *)buf = *(_OWORD *)&a2->mChannelLayoutTag;
  *(int16x8_t *)&buf[16] = v4;
  v17 = *(_QWORD *)&a2[1].mChannelLayoutTag;
  CA::StreamDescription::AsString((CA::StreamDescription *)buf, (uint64_t)__p, v4);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v5 = getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (_QWORD *)((char *)this + 200);
    if (*((char *)this + 223) < 0)
      v6 = (_QWORD *)*v6;
    v7 = __p;
    if (v15 < 0)
      v7 = (void **)__p[0];
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = v6;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "SetStreamFormat";
    *(_WORD *)&buf[22] = 2080;
    *(_QWORD *)&buf[24] = v7;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting output stream format: %s", buf, 0x20u);
  }
  if (*(double *)&a2->mChannelLayoutTag <= 0.0)
  {
    v12 = 4294967246;
  }
  else
  {
    ausdk::AUIOElement::SetStreamFormat(this, a2);
    (*(void (**)(AUSpatialMixerV2OutputElement *, _QWORD))(*(_QWORD *)this + 64))(this, 0);
    v8 = *((_DWORD *)this + 27);
    if (v8 != ausdk::AUChannelLayout::NumberChannels(*((ausdk::AUChannelLayout **)this + 15), v9))
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v10 = getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
      {
        v11 = (_QWORD *)((char *)this + 200);
        if (*((char *)this + 223) < 0)
          v11 = (_QWORD *)*v11;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v11;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "SetStreamFormat";
        _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEFAULT, "[%s|%s] Number of channels in stream format changed", buf, 0x16u);
      }
      AUSpatialMixerV2OutputElement::ResetOutputChannelLayout(this);
      AUSpatialMixerV2::InitializeOutputConverter(*((AudioConverterRef **)this + 23));
    }
    v12 = 0;
  }
  if (v15 < 0)
    operator delete(__p[0]);
  return v12;
}

void sub_1B6134B70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::AUOutputElement::NeedsBufferSpace(ausdk::AUOutputElement *this)
{
  return 1;
}

uint64_t AUSpatialMixerV2OutputElement::Initialize(AUSpatialMixerV2OutputElement *this, const AudioChannelLayout *a2)
{
  int v3;
  uint64_t result;
  NSObject *v5;
  const AudioChannelLayout *v6;
  _QWORD *v7;
  int v8;
  int v9;
  int v10;
  _QWORD *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = *((_DWORD *)this + 27);
  if (v3 == ausdk::AUChannelLayout::NumberChannels(*((ausdk::AUChannelLayout **)this + 15), a2))
  {
    result = 0;
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v5 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      v7 = (_QWORD *)((char *)this + 200);
      if (*((char *)this + 223) < 0)
        v7 = (_QWORD *)*v7;
      v8 = ausdk::AUChannelLayout::NumberChannels(*((ausdk::AUChannelLayout **)this + 15), v6);
      v9 = *((_DWORD *)this + 27);
      v10 = 136315906;
      v11 = v7;
      v12 = 2080;
      v13 = "Initialize";
      v14 = 1024;
      v15 = v8;
      v16 = 1024;
      v17 = v9;
      _os_log_error_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_ERROR, "[%s|%s] Number of channels in AudioChannelLayout = %u does not match number of channels in stream format = %u. Reverting to default layout.", (uint8_t *)&v10, 0x22u);
    }
    AUSpatialMixerV2OutputElement::ResetOutputChannelLayout(this);
    result = 4294956428;
  }
  *((_BYTE *)this + 196) = 1;
  return result;
}

uint64_t AUSpatialMixerV2OutputElement::Reset(AUSpatialMixerV2OutputElement *this)
{
  return 0;
}

uint64_t AUSpatialMixerV2OutputElement::Cleanup(AUSpatialMixerV2OutputElement *this)
{
  *((_BYTE *)this + 196) = 0;
  return 0;
}

uint64_t AUSpatialMixerV2OutputElement::PropertyChanged(AUSpatialMixerV2OutputElement *this, int a2)
{
  AudioChannelLayoutTag v2;

  if (a2 != 3220)
    return 0;
  v2 = atomic_load((unsigned int *)this + 74);
  if (*((_BYTE *)this + 197) || v2 > 0xFFFEFFFF)
    return 0;
  else
    return AUSpatialMixerV2OutputElement::SetFullLayoutFromTag(this, v2, 1);
}

uint64_t AUSpatialMixerV2OutputElement::PropertyObserverIsInitialized(AUSpatialMixerV2OutputElement *this)
{
  return *((unsigned __int8 *)this + 196);
}

uint64_t `non-virtual thunk to'AUSpatialMixerV2OutputElement::PropertyChanged(AUSpatialMixerV2OutputElement *this, int a2)
{
  AudioChannelLayoutTag v2;

  if (a2 != 3220)
    return 0;
  v2 = atomic_load((unsigned int *)this + 30);
  if (*((_BYTE *)this + 21) || v2 > 0xFFFEFFFF)
    return 0;
  else
    return AUSpatialMixerV2OutputElement::SetFullLayoutFromTag((AUSpatialMixerV2OutputElement *)((char *)this - 176), v2, 1);
}

uint64_t `non-virtual thunk to'AUSpatialMixerV2OutputElement::PropertyObserverIsInitialized(AUSpatialMixerV2OutputElement *this)
{
  return *((unsigned __int8 *)this + 20);
}

uint64_t AUSpatialMixerV2OutputElement::SetFullLayoutFromTag(AUSpatialMixerV2OutputElement *this, AudioChannelLayoutTag a2, int a3)
{
  AudioChannelLayout *begin;
  uint64_t v7;
  std::vector<char> __p;
  std::vector<char>::value_type __x;

  __x = 0;
  std::vector<char>::vector(&__p, 0x20uLL, &__x);
  begin = (AudioChannelLayout *)__p.__begin_;
  *((_DWORD *)__p.__begin_ + 1) = 0;
  begin->mNumberChannelDescriptions = 0;
  begin->mChannelLayoutTag = a2;
  v7 = AUSpatialMixerV2OutputElement::SetFullLayout(this, begin, a3);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
  return v7;
}

void sub_1B6134DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t AUSpatialMixerV2OutputElement::SetFullLayout(AUSpatialMixerV2OutputElement *this, const AudioChannelLayout *a2, int a3)
{
  AudioChannelLayoutTag mChannelLayoutTag;
  UInt32 mNumberChannelDescriptions;
  uint8x8_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  _QWORD *v13;
  std::string *v14;
  uint64_t v15;
  unsigned __int8 v16;
  unsigned int i;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *Element;
  unsigned __int8 v21;
  unsigned __int8 v22;
  char v23;
  NSObject *v24;
  _QWORD *v25;
  std::string *v26;
  _QWORD *v28;
  std::string *v29;
  const char *v30;
  _QWORD *v31;
  std::string *v32;
  NSObject *v33;
  _QWORD *v34;
  std::string *p_p;
  std::string __p;
  _BYTE buf[12];
  __int16 v38;
  const char *v39;
  __int16 v40;
  _QWORD v41[3];

  v41[2] = *MEMORY[0x1E0C80C00];
  mChannelLayoutTag = a2->mChannelLayoutTag;
  if ((a2->mChannelLayoutTag & 0xFFFEFFFF) != 0 && **((_DWORD **)this + 15) == mChannelLayoutTag)
  {
LABEL_43:
    v11 = 0;
    goto LABEL_44;
  }
  if (mChannelLayoutTag == 0x10000)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2->mChannelBitmap);
    v9.i16[0] = vaddlv_u8(v9);
    mNumberChannelDescriptions = v9.i32[0];
  }
  else if (mChannelLayoutTag)
  {
    mNumberChannelDescriptions = (unsigned __int16)a2->mChannelLayoutTag;
  }
  else
  {
    mNumberChannelDescriptions = a2->mNumberChannelDescriptions;
  }
  if (mNumberChannelDescriptions <= 1)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v10 = getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
LABEL_14:
      v11 = 4294956445;
      goto LABEL_46;
    }
    v34 = (_QWORD *)((char *)this + 200);
    if (*((char *)this + 223) < 0)
      v34 = (_QWORD *)*v34;
    GetStringFromAudioChannelLayoutTag(&__p, mChannelLayoutTag);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v34;
    v38 = 2080;
    v39 = "SetFullLayout";
    v40 = 1024;
    LODWORD(v41[0]) = mNumberChannelDescriptions;
    WORD2(v41[0]) = 2080;
    *(_QWORD *)((char *)v41 + 6) = p_p;
    v30 = "[%s|%s] Unsupported number of channels %u in audio channel layout %s: must be two or more";
    goto LABEL_79;
  }
  if (!*((_BYTE *)this + 196))
  {
    if (((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 23) + 608))(*((_QWORD *)this + 23)) & 1) == 0
      && *((_DWORD *)this + 27) != mNumberChannelDescriptions
      && (a3 & 1) == 0)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v10 = getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
        goto LABEL_14;
      v28 = (_QWORD *)((char *)this + 200);
      if (*((char *)this + 223) < 0)
        v28 = (_QWORD *)*v28;
      GetStringFromAudioChannelLayoutTag(&__p, mChannelLayoutTag);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v29 = &__p;
      else
        v29 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v28;
      v38 = 2080;
      v39 = "SetFullLayout";
      v40 = 1024;
      LODWORD(v41[0]) = mNumberChannelDescriptions;
      WORD2(v41[0]) = 2080;
      *(_QWORD *)((char *)v41 + 6) = v29;
      v30 = "[%s|%s] Number of channels %u in requested audio channel layout %s is different than in the stream format.";
LABEL_79:
      v33 = v10;
LABEL_80:
      _os_log_error_impl(&dword_1B5ED0000, v33, OS_LOG_TYPE_ERROR, v30, buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_82;
    }
    goto LABEL_29;
  }
  if (*((_DWORD *)this + 27) == mNumberChannelDescriptions)
  {
LABEL_29:
    ausdk::AUIOElement::ForceSetAudioChannelLayout(this, a2);
    v15 = *((_QWORD *)this + 23);
    v16 = atomic_load((unsigned __int8 *)(v15 + 7441));
    if ((v16 & 1) != 0)
    {
      *(_QWORD *)buf = v15 + 3352;
      buf[8] = 1;
      std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v15 + 3352));
      for (i = 0; ; ++i)
      {
        v18 = *(_QWORD *)(v15 + 120);
        if (v18)
          LODWORD(v19) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
        else
          v19 = (*(_QWORD *)(v15 + 104) - *(_QWORD *)(v15 + 96)) >> 3;
        if (i >= v19)
          break;
        Element = (unsigned __int8 *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v15 + 80), i);
        v21 = atomic_load(Element + 680);
        if ((v21 & 1) == 0)
        {
          v22 = atomic_load(Element + 681);
          if ((v22 & 1) == 0)
            continue;
        }
        AUSpatialMixerV2InputElement::InitializeChannelProcessors((AUSpatialMixerV2InputElement *)Element);
      }
      std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
      AUSpatialMixerV2::UpdateReverbIfNecessary(v15, -1, 0, 0);
    }
    v23 = a3 ^ 1;
    if (*((_BYTE *)this + 197))
      v23 = 1;
    *((_BYTE *)this + 197) = v23;
    AUSpatialMixerV2::UpdateDiffuseProcessors(*((AUSpatialMixerV2 **)this + 23));
    goto LABEL_43;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v12 = getAUSMV2Log(void)::gLog;
  if (a3)
  {
    v11 = 0;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
      goto LABEL_44;
    v13 = (_QWORD *)((char *)this + 200);
    if (*((char *)this + 223) < 0)
      v13 = (_QWORD *)*v13;
    GetStringFromAudioChannelLayoutTag(&__p, mChannelLayoutTag);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v14 = &__p;
    else
      v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v13;
    v38 = 2080;
    v39 = "SetFullLayout";
    v40 = 1024;
    LODWORD(v41[0]) = mNumberChannelDescriptions;
    WORD2(v41[0]) = 2080;
    *(_QWORD *)((char *)v41 + 6) = v14;
    _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEFAULT, "[%s|%s] Number of channels %u in requested audio channel layout is different than in the stream format. Default audio channel layout tag %s from preset is ignored.", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_43;
  }
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    v31 = (_QWORD *)((char *)this + 200);
    if (*((char *)this + 223) < 0)
      v31 = (_QWORD *)*v31;
    GetStringFromAudioChannelLayoutTag(&__p, mChannelLayoutTag);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v32 = &__p;
    else
      v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v31;
    v38 = 2080;
    v39 = "SetFullLayout";
    v40 = 1024;
    LODWORD(v41[0]) = mNumberChannelDescriptions;
    WORD2(v41[0]) = 2080;
    *(_QWORD *)((char *)v41 + 6) = v32;
    v30 = "[%s|%s] Number of channels %u in requested audio channel layout %s is different than in the stream format.";
    v33 = v12;
    goto LABEL_80;
  }
LABEL_82:
  v11 = 4294956445;
LABEL_44:
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
LABEL_46:
  v24 = getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v25 = (_QWORD *)((char *)this + 200);
    if (*((char *)this + 223) < 0)
      v25 = (_QWORD *)*v25;
    PrintAudioChannelLayout(&__p, *((int **)this + 15));
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v26 = &__p;
    else
      v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = v25;
    v38 = 2080;
    v39 = "SetFullLayout";
    v40 = 2080;
    v41[0] = v26;
    _os_log_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_DEFAULT, "[%s|%s] Current output audio channel layout is %s", buf, 0x20u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v11;
}

void sub_1B61353B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(exception_object);
}

double ausdk::AUIOElement::ForceSetAudioChannelLayout(ausdk::AUIOElement *this, const AudioChannelLayout *a2)
{
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  unint64_t v7;
  void *v8;
  double result;
  void *__dst[2];
  uint64_t v11;

  v4 = 20 * a2->mNumberChannelDescriptions + 12;
  v5 = (v4 & 0x1C) == 0;
  v6 = v4 >> 5;
  if (v5)
    v7 = v6;
  else
    v7 = v6 + 1;
  std::vector<AudioChannelLayout>::vector(__dst, v7);
  memcpy(__dst[0], a2, 20 * a2->mNumberChannelDescriptions + 12);
  v8 = (void *)*((_QWORD *)this + 15);
  if (v8)
  {
    *((_QWORD *)this + 16) = v8;
    operator delete(v8);
  }
  result = *(double *)__dst;
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)__dst;
  *((_QWORD *)this + 17) = v11;
  return result;
}

_QWORD *std::vector<AudioChannelLayout>::vector(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >> 59)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v4 = 32 * a2;
    v5 = (char *)operator new(32 * a2);
    *a1 = v5;
    a1[2] = &v5[32 * a2];
    bzero(v5, 32 * a2);
    a1[1] = &v5[v4];
  }
  return a1;
}

void sub_1B61354D4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::AUChannelLayout::NumberChannels(ausdk::AUChannelLayout *this, const AudioChannelLayout *a2)
{
  uint8x8_t v3;

  if (*(_DWORD *)this == 0x10000)
  {
    v3 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)this + 1));
    v3.i16[0] = vaddlv_u8(v3);
    return v3.u32[0];
  }
  else if (*(_DWORD *)this)
  {
    return (unsigned __int16)*(_DWORD *)this;
  }
  else
  {
    return *((unsigned int *)this + 2);
  }
}

void AUSpatialMixerV2OutputElement::ResetOutputChannelLayout(AUSpatialMixerV2OutputElement *this)
{
  int v2;
  int v3;
  int v4;
  NSObject *v5;
  _QWORD *v6;
  void **v7;
  void *__p[2];
  char v9;
  uint8_t buf[4];
  _QWORD *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  void **v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = *((_DWORD *)this + 27);
  v3 = v2 - 1;
  if ((v2 - 1) < 0x10 && ((0x89FFu >> v3) & 1) != 0)
    v4 = dword_1B66397E0[v3];
  else
    v4 = v2 | 0x930000;
  AUSpatialMixerV2OutputElement::SetFullLayoutFromTag(this, v4, 0);
  *((_BYTE *)this + 197) = 0;
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v5 = getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (_QWORD *)((char *)this + 200);
    if (*((char *)this + 223) < 0)
      v6 = (_QWORD *)*v6;
    GetStringFromAudioChannelLayoutTag(__p, v4);
    if (v9 >= 0)
      v7 = __p;
    else
      v7 = (void **)__p[0];
    *(_DWORD *)buf = 136315906;
    v11 = v6;
    v12 = 2080;
    v13 = "ResetOutputChannelLayout";
    v14 = 2080;
    v15 = v7;
    v16 = 1024;
    v17 = v2;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting default audio channel layout tag = %s for %u channels", buf, 0x26u);
    if (v9 < 0)
      operator delete(__p[0]);
  }
}

void std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(_QWORD *a1)
{
  uint64_t v2;

  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(a1[1]);
    v2 = a1[5];
    a1[5] = 0;
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    operator delete(a1);
  }
}

void ausdk::AUElement::~AUElement(const void **this)
{
  void *v2;
  void *v3;

  *this = &off_1E69EDDC8;
  ausdk::Owned<__CFString const*>::releaseRef(this[9]);
  v2 = (void *)this[6];
  if (v2)
  {
    this[7] = v2;
    operator delete(v2);
  }
  v3 = (void *)this[2];
  if (v3)
  {
    this[3] = v3;
    operator delete(v3);
  }
}

{
  ausdk::AUElement::~AUElement(this);
  JUMPOUT(0x1BCC95CECLL);
}

ausdk::AUChannelLayout *ausdk::AUChannelLayout::AUChannelLayout(ausdk::AUChannelLayout *this, const ausdk::AUChannelLayout *a2)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  ausdk::AUChannelLayout::CopyStorage(this, a2);
  return this;
}

void sub_1B6135780(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *ausdk::AUChannelLayout::CopyStorage(ausdk::AUChannelLayout *this, const ausdk::AUChannelLayout *a2)
{
  void *v4;
  void *v5;
  __int128 v7;
  uint64_t v8;

  std::vector<AudioChannelLayout>::vector(&v7, (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 5);
  v4 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v4;
    operator delete(v4);
  }
  v5 = (void *)v7;
  *(_OWORD *)this = v7;
  *((_QWORD *)this + 2) = v8;
  return memcpy(v5, *(const void **)a2, *((_QWORD *)a2 + 1) - *(_QWORD *)a2);
}

void WindDetectorAndSuppressor::UpdateWindSuppressorCoreState(WindDetectorAndSuppressor *this)
{
  float32x2_t *v2;
  unint64_t v3;
  float v4;
  uint64_t v5;
  unint64_t v6;
  float32x2_t *v7;
  unint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  unint64_t v12;
  uint64x2_t v13;
  float32x2_t v14;
  float32x2_t *v15;
  uint64_t i;
  float v17;
  float v18;

  v2 = (float32x2_t *)*((_QWORD *)this + 62);
  v3 = *((_QWORD *)this + 63) - (_QWORD)v2;
  if (!v3)
    goto LABEL_31;
  v4 = *((float *)this + 34);
  v2->f32[0] = v4;
  if (v3 <= 4)
    goto LABEL_31;
  v2->i32[1] = *((_DWORD *)this + 62);
  if (v3 <= 8)
    goto LABEL_31;
  v2[1].i32[0] = *((_DWORD *)this + 41);
  if (v3 <= 0xC)
    goto LABEL_31;
  v2[1].i32[1] = *((_DWORD *)this + 39);
  if (v3 <= 0x10)
    goto LABEL_31;
  v2[2].i32[0] = *((_DWORD *)this + 38);
  if (v3 <= 0x14)
    goto LABEL_31;
  v2[2].i32[1] = *((_DWORD *)this + 43);
  if (v3 <= 0x18
    || (v2[3].i32[0] = *((_DWORD *)this + 63), v3 <= 0x1C)
    || (v2[3].i32[1] = *((_DWORD *)this + 65), v3 <= 0x20)
    || (v2[4].i32[0] = *((_DWORD *)this + 64), v3 <= 0x24)
    || (v2[4].i32[1] = *((_DWORD *)this + 66), v3 <= 0x28)
    || (v2[5].i32[0] = *((_DWORD *)this + 33), v3 <= 0x2C)
    || (v2[5].i32[1] = *((_DWORD *)this + 67), v3 <= 0x30)
    || (v2[6].i32[0] = *((_DWORD *)this + 68), v3 <= 0x34))
  {
LABEL_31:
    std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
  }
  v2[6].i32[1] = *((_DWORD *)this + 69);
  if (*((_BYTE *)this + 8))
  {
    if (!*((_BYTE *)this + 832))
      __assert_rtn("propagateParameterChanges", "WindSuppressorCore.cpp", 129, "mInitialized");
    v5 = *((_QWORD *)this + 80);
    v6 = *((unsigned int *)this + 131);
    if (v6 > (*((_QWORD *)this + 81) - v5) >> 2)
      __assert_rtn("propagateParameterChanges", "WindSuppressorCore.cpp", 130, "mRampedGainFloor.size() >= mCplxVectorSize");
    v7 = (float32x2_t *)*((_QWORD *)this + 101);
    v8 = 0x8E38E38E38E38E39 * ((uint64_t)(*((_QWORD *)this + 102) - (_QWORD)v7) >> 3);
    v9 = *((unsigned int *)this + 133);
    if (v8 != v9)
      __assert_rtn("propagateParameterChanges", "WindSuppressorCore.cpp", 131, "mWindTracker.size() == mNumInputChannels");
    *((float *)this + 140) = __exp10f(v4 / 20.0);
    v10 = *((double *)this + 69);
    v18 = v10 / (float)*((unsigned int *)this + 132);
    *((float *)this + 143) = expf(-1.0 / (float)(v2[3].f32[0] * v18));
    *((float *)this + 144) = expf(-1.0 / (float)(v18 * v2[3].f32[1]));
    *((float *)this + 145) = expf(-1.0 / (float)(v18 * v2[4].f32[1]));
    *((float *)this + 146) = expf(-1.0 / (float)(v18 * v2[6].f32[1]));
    if ((_DWORD)v9)
    {
      v11 = v2[5].f32[0];
      v12 = (unint64_t)(float)(v18 * v2[4].f32[0]);
      v13 = vcvtq_u64_f64(vcvtq_f64_f32(vmul_n_f32(v2[3], v18)));
      v14 = vdiv_f32((float32x2_t)0xBF8000003F800000, vadd_f32(vcvt_f32_f64(vcvtq_f64_u64(v13)), (float32x2_t)vdup_n_s32(0x25800000u)));
      v15 = v7 + 3;
      do
      {
        v15[-3].f32[0] = v11;
        v15[-3].f32[1] = v11 * 0.5;
        v15[1] = *(float32x2_t *)v13.i8;
        v15[2] = (float32x2_t)v12;
        v15[3] = (float32x2_t)v13.u64[1];
        v15[-2] = (float32x2_t)0x3F80000000000000;
        *v15 = v14;
        v15 += 9;
        --v8;
      }
      while (v8);
    }
    if ((_DWORD)v6)
    {
      for (i = 0; i != v6; ++i)
      {
        v17 = (float)(2.0 / (float)(expf(-(float)(v2->f32[1] * (float)(int)i)) + 1.0)) + -1.0;
        *(float *)(v5 + 4 * i) = v17;
        if (*((float *)this + 140) >= v17)
          v17 = *((float *)this + 140);
        *(float *)(v5 + 4 * i) = v17;
      }
    }
  }
}

void WindDetectorAndSuppressor::~WindDetectorAndSuppressor(WindDetectorAndSuppressor *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  WindSuppressorCore::~WindSuppressorCore((WindDetectorAndSuppressor *)((char *)this + 496));
  v2 = (void *)*((_QWORD *)this + 59);
  if (v2)
  {
    *((_QWORD *)this + 60) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 56);
  if (v3)
  {
    *((_QWORD *)this + 57) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 53);
  if (v4)
  {
    *((_QWORD *)this + 54) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 50);
  if (v5)
  {
    *((_QWORD *)this + 51) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 47);
  if (v6)
  {
    *((_QWORD *)this + 48) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 44);
  if (v7)
  {
    *((_QWORD *)this + 45) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 41);
  if (v8)
  {
    *((_QWORD *)this + 42) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 38);
  if (v9)
  {
    *((_QWORD *)this + 39) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 35);
  if (v10)
  {
    *((_QWORD *)this + 36) = v10;
    operator delete(v10);
  }
}

float WindDetectorAndSuppressor::UpdateNonTrivialParameters(WindDetectorAndSuppressor *this, double a2, double a3, double a4)
{
  double v5;
  unsigned int v6;
  double v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float result;

  v5 = *((double *)this + 2);
  v6 = *((_DWORD *)this + 6);
  v7 = v5 / (float)((float)v6 + (float)v6);
  *(float *)&a4 = (float)(v6 - 1);
  v8.i64[0] = *(_QWORD *)((char *)this + 140);
  v8.i64[1] = *((_QWORD *)this + 20);
  *(float *)&v7 = v7;
  v9 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
  v10 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
  *(uint32x4_t *)((char *)this + 28) = vcvtq_u32_f32(vminnmq_f32(vmaxnmq_f32(vrndaq_f32(vdivq_f32(v8, v9)), (float32x4_t)0), v10));
  v8.f32[0] = fminf(fmaxf(roundf(*((float *)this + 42) / *(float *)&v7), 0.0), *(float *)&a4);
  *((_DWORD *)this + 11) = v8.f32[0];
  *((_DWORD *)this + 12) = v8.f32[0] + 1;
  *(uint32x2_t *)((char *)this + 52) = vcvt_u32_f32(vminnm_f32(vmaxnm_f32(vrnda_f32(vdiv_f32(*(float32x2_t *)((char *)this + 204), *(float32x2_t *)v9.f32)), 0), *(float32x2_t *)v10.f32));
  *((_DWORD *)this + 15) = fminf(fmaxf(roundf(*((float *)this + 53) / *(float *)&v7), 0.0), *(float *)&a4);
  v11 = v5 / (double)v6;
  v12 = exp(-1.0 / (float)(*((float *)this + 37) * v11));
  *((float *)this + 16) = v12;
  v13 = exp(-1.0 / (float)(*((float *)this + 54) * v11));
  v14 = floorf(*((float *)this + 44) * v11);
  *((float *)this + 17) = v13;
  *((float *)this + 18) = v14;
  *((float *)this + 20) = floorf(*((float *)this + 58) * v11);
  result = __exp10(*((float *)this + 34) / 20.0);
  *((float *)this + 22) = result;
  return result;
}

void WindDetectorAndSuppressor::Reset(WindDetectorAndSuppressor *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  void *v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  unsigned int v15;
  size_t v16;
  int v17;
  int v18;
  int v19;

  v2 = *((unsigned int *)this + 6);
  v19 = 0;
  std::vector<float>::assign((char **)this + 35, v2, &v19);
  v3 = *((unsigned int *)this + 6);
  v18 = 0;
  std::vector<float>::assign((char **)this + 38, v3, &v18);
  v4 = (2 * *((_DWORD *)this + 6));
  v17 = 0;
  std::vector<float>::assign((char **)this + 41, v4, &v17);
  *(_QWORD *)((char *)this + 100) = 0;
  *(_QWORD *)((char *)this + 92) = 0;
  *(_QWORD *)((char *)this + 108) = 0;
  *((_DWORD *)this + 19) = *((float *)this + 18);
  *((_DWORD *)this + 21) = *((float *)this + 20);
  *((_BYTE *)this + 116) = 0;
  WindDetectorAndSuppressor::ResetOutputPropertiesAndParams(this);
  if (*((_BYTE *)this + 8))
  {
    if (!*((_BYTE *)this + 832))
      __assert_rtn("reset", "WindSuppressorCore.cpp", 88, "mInitialized");
    v5 = (void *)*((_QWORD *)this + 98);
    v6 = *((unsigned int *)this + 133);
    if ((_DWORD)v6 + 1 != (uint64_t)(*((_QWORD *)this + 99) - (_QWORD)v5) >> 2)
      __assert_rtn("reset", "WindSuppressorCore.cpp", 89, "mAggregateOmniMicWeight.size() == mNumInputChannels + 1");
    v7 = 0x8E38E38E38E38E39 * ((uint64_t)(*((_QWORD *)this + 102) - *((_QWORD *)this + 101)) >> 3);
    if (v7 != v6)
      __assert_rtn("reset", "WindSuppressorCore.cpp", 90, "mWindTracker.size() == mNumInputChannels");
    if (v7 != (uint64_t)(*((_QWORD *)this + 93) - *((_QWORD *)this + 92)) >> 2)
      __assert_rtn("reset", "WindSuppressorCore.cpp", 91, "mGainApplicationCutoffIndex.size() == mNumInputChannels");
    v8 = (_QWORD *)*((_QWORD *)this + 95);
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 96) - (_QWORD)v8) >> 3) != v7)
      __assert_rtn("reset", "WindSuppressorCore.cpp", 92, "mSmoothSuppressionGains.size() == mNumInputChannels");
    if (*((_DWORD *)this + 131) != (uint64_t)(v8[1] - *v8) >> 2)
      __assert_rtn("reset", "WindSuppressorCore.cpp", 93, "mSmoothSuppressionGains[0].size() == mCplxVectorSize");
    if (!(_DWORD)v6)
    {
      v16 = 4;
      goto LABEL_14;
    }
    v9 = 0;
    v10 = 0;
    v11 = 0;
    do
    {
      *(_DWORD *)(*((_QWORD *)this + 92) + 4 * v11) = 0;
      v12 = *((_QWORD *)this + 101) + v9;
      *(_DWORD *)(v12 + 16) = 0;
      *(_QWORD *)(v12 + 56) = 1;
      *(_DWORD *)(v12 + 64) = 0;
      std::vector<float>::assign((char **)(*((_QWORD *)this + 95) + v10), *((unsigned int *)this + 131), &WindSuppressorCore::kDefaultGains);
      ++v11;
      v13 = *((unsigned int *)this + 133);
      v10 += 24;
      v9 += 72;
    }
    while (v11 < v13);
    v14 = __CFADD__((_DWORD)v13, 1);
    v15 = v13 + 1;
    if (!v14)
    {
      v5 = (void *)*((_QWORD *)this + 98);
      v16 = 4 * v15;
LABEL_14:
      memset_pattern16(v5, &unk_1B66A2B30, v16);
    }
  }
}

double WindDetectorAndSuppressor::ResetOutputPropertiesAndParams(WindDetectorAndSuppressor *this)
{
  unint64_t v2;
  double result;
  int v4;

  v2 = *((unsigned int *)this + 6);
  v4 = 1065353216;
  std::vector<float>::assign((char **)this + 44, v2, &v4);
  std::vector<float>::assign((char **)this + 47, *((unsigned int *)this + 6), this);
  *((_BYTE *)this + 120) = 0;
  *(_QWORD *)((char *)this + 124) = 0x4320000000000000;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_DWORD *)this + 50) = 0;
  result = 0.0000305175853;
  *(_QWORD *)((char *)this + 236) = 0x3F0000003F000000;
  return result;
}

void WindDetectorAndSuppressor::GetPSD(uint64_t a1, float *a2, const float **a3)
{
  float *v5;
  float *v6;
  float __D;
  float __B;
  DSPSplitComplex __A;

  v5 = &a2[*(unsigned int *)(a1 + 24)];
  __A.realp = a2;
  __A.imagp = v5;
  vDSP_zvmags(&__A, 1, *(float **)(a1 + 424), 1, *(unsigned int *)(a1 + 48));
  v6 = *(float **)(a1 + 424);
  *v6 = *__A.realp * *__A.realp;
  __B = *(float *)(a1 + 64);
  __D = 1.0 - __B;
  vDSP_vsmsma(*a3, 1, &__B, v6, 1, &__D, (float *)*a3, 1, *(unsigned int *)(a1 + 48));
}

void WindDetectorAndSuppressor::ProcessBufferLists(WindDetectorAndSuppressor *this, const AudioBufferList *a2, AudioBufferList *a3, AudioBufferList *a4, AudioBufferList *a5, double a6, double a7, double a8)
{
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  float *v14;
  float *v15;
  _QWORD *v16;
  float v17;
  unint64_t v18;
  unsigned int v19;
  unsigned int v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  float v25;
  unsigned int v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float *v32;
  float *v33;
  unsigned int v34;
  float v35;
  float v36;
  float v37;
  float v38;
  double v39;
  double v40;
  float v41;
  float v42;
  float *v43;
  float *v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float *v52;
  float *v53;
  unsigned int v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float *v60;
  float *v61;
  float v62;
  float v63;
  float v64;
  float v65;
  unint64_t v66;
  unsigned int v67;
  unsigned int v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float *v74;
  float *v75;
  unsigned int v76;
  float v77;
  float v78;
  float v79;
  double v80;
  float v81;
  float v82;
  float *v83;
  float *v84;
  float v85;
  float v86;
  float v87;
  float v88;
  int v89;
  float v90;
  unsigned int v91;
  int v92;
  float v93;
  _DWORD *v94;
  float v95;
  int v96;
  int v97;
  uint64_t v98;
  unsigned int v99;
  vDSP_Length v100;
  const float *v101;
  const float *v102;
  vDSP_Length v103;
  const float *v104;
  float *v105;
  uint64_t v106;
  float v107;
  uint64_t v108;
  uint64_t v109;
  float v110;
  uint64_t v111;
  unint64_t v112;
  unsigned int v113;
  uint64_t v114;
  uint64_t v115;
  unsigned int v116;
  float v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  float v129;
  float *v130;
  float *v131;
  uint64_t v132;
  float v133;
  float v134;
  float v135;
  uint64_t v136;
  uint64_t v137;
  unsigned int v138;
  uint64_t v139;
  float v140;
  float *v141;
  uint64_t v142;
  float v143;
  vDSP_Length v144;
  const float *v145;
  float *v146;
  const float *v147;
  BOOL v148;
  float v149;
  float *v150;
  uint64_t v151;
  uint64_t v152;
  float v153;
  float v154;
  uint64_t v155;
  uint64_t v156;
  float v157;
  float v158;
  float v159;
  vDSP_Length v160;
  uint64_t v161;
  float *v162;
  vDSP_Length v163;
  unsigned int v164;
  vDSP_Length v165;
  const float *v166;
  vDSP_Length __N;
  uint64_t v168;
  vDSP_Length v169;
  uint64_t v170;
  uint64_t v171;
  vDSP_Length v172;
  char v173;
  char v174;
  const float *mData;
  float *v176;
  float v177;
  float32x2_t v178;
  float32x2_t v179;
  char *v180;
  const float *v181;
  const float *v182;
  float *v183;
  vDSP_Length v184;
  float v185;
  const float *v186;
  _BYTE *v187;
  _BYTE *v188;
  float v189;
  float v190;
  BOOL v191;
  int v192;
  float v193;
  float v194;
  float v195;
  DSPSplitComplex __C;
  DSPSplitComplex __A;
  DSPSplitComplex __B;
  float __D;
  float v202[3];

  if (!*((_BYTE *)this + 8))
    return;
  WindDetectorAndSuppressor::UpdateNonTrivialParameters(this, a6, a7, a8);
  v11 = (_QWORD *)((char *)this + 280);
  WindDetectorAndSuppressor::GetPSD((uint64_t)this, (float *)a2->mBuffers[0].mData, (const float **)this + 35);
  v12 = (_QWORD *)((char *)this + 304);
  WindDetectorAndSuppressor::GetPSD((uint64_t)this, *(float **)&a2[1].mBuffers[0].mNumberChannels, (const float **)this + 38);
  v13 = *((unsigned int *)this + 6);
  __B.realp = (float *)a2->mBuffers[0].mData;
  __B.imagp = &__B.realp[v13];
  v14 = (float *)(*(_QWORD *)&a2[1].mBuffers[0].mNumberChannels + 4 * v13);
  __A.realp = *(float **)&a2[1].mBuffers[0].mNumberChannels;
  __A.imagp = v14;
  __C.realp = (float *)*((_QWORD *)this + 59);
  __C.imagp = &__C.realp[v13];
  vDSP_zvcmul(&__A, 1, &__B, 1, &__C, 1, *((unsigned int *)this + 12));
  *__C.realp = *__B.realp * *__A.realp;
  *__C.imagp = *__B.imagp * *__A.imagp;
  v202[0] = *((float *)this + 16);
  __D = 1.0 - v202[0];
  vDSP_vsmsma(*((const float **)this + 41), 1, v202, *((const float **)this + 59), 1, &__D, *((float **)this + 41), 1, *((unsigned int *)this + 12));
  vDSP_vsmsma((const float *)(*((_QWORD *)this + 41) + 4 * *((unsigned int *)this + 6)), 1, v202, (const float *)(*((_QWORD *)this + 59) + 4 * *((unsigned int *)this + 6)), 1, &__D, (float *)(*((_QWORD *)this + 41) + 4 * *((unsigned int *)this + 6)), 1, *((unsigned int *)this + 12));
  v15 = (float *)(*((_QWORD *)this + 41) + 4 * *((unsigned int *)this + 6));
  __B.realp = (float *)*((_QWORD *)this + 41);
  __B.imagp = v15;
  v16 = (_QWORD *)((char *)this + 424);
  vDSP_zvmags(&__B, 1, *((float **)this + 53), 1, *((unsigned int *)this + 12));
  **((float **)this + 53) = *__B.realp * *__B.realp;
  vDSP_vmsa(*((const float **)this + 35), 1, *((const float **)this + 38), 1, (const float *)this + 1, *((float **)this + 56), 1, *((unsigned int *)this + 12));
  vDSP_vdiv(*((const float **)this + 56), 1, *((const float **)this + 53), 1, *((float **)this + 44), 1, *((unsigned int *)this + 12));
  LODWORD(__B.realp) = 0;
  vDSP_meanv((const float *)(*((_QWORD *)this + 44) + 4 * *((unsigned int *)this + 7)), 1, (float *)&__B, (*((_DWORD *)this + 8) - *((_DWORD *)this + 7) + 1));
  v17 = (float)(*((float *)this + 16) * *((float *)this + 23))
      + (1.0 - *((float *)this + 16)) * (float)(1.0 - *(float *)&__B.realp);
  *((float *)this + 23) = v17;
  v18 = *((unsigned int *)this + 6);
  LODWORD(__B.realp) = 0;
  std::vector<float>::assign((char **)this + 53, v18, &__B);
  v19 = *((_DWORD *)this + 13);
  v20 = *((_DWORD *)this + 15);
  if (v19 <= v20)
  {
    v21 = 1.0 - *((float *)this + 33);
    v22 = *((_QWORD *)this + 44);
    v23 = *((_QWORD *)this + 53);
    v24 = *((_DWORD *)this + 13);
    do
    {
      if (*(float *)(v22 + 4 * v24) >= v21)
        v25 = 0.0;
      else
        v25 = 1.0;
      *(float *)(v23 + 4 * v24++) = v25;
    }
    while (v24 <= v20);
  }
  v26 = *((_DWORD *)this + 14);
  v27 = *((float *)this + 17);
  v28 = *((float *)this + 24);
  v29 = *((float *)this + 1);
  v30 = 0.0;
  v31 = 0.0;
  if (v19 <= v26)
  {
    v32 = (float *)(*v16 + 4 * (int)v19);
    v33 = (float *)(*v11 + 4 * (int)v19);
    v34 = v19;
    do
    {
      v35 = *v33++;
      v36 = v35;
      v37 = *v32++;
      v31 = v31 + (float)(v36 * v37);
      ++v34;
    }
    while (v26 >= v34);
  }
  v38 = log10f(v29 + v31);
  v39 = (float)(v27 * v28);
  v40 = 1.0 - v27;
  v41 = v39 + v40 * (float)(v38 * 10.0);
  *((float *)this + 24) = v41;
  if (v19 <= v26)
  {
    v43 = (float *)(*v16 + 4 * (int)v19);
    v44 = (float *)(*v12 + 4 * (int)v19);
    v30 = 0.0;
    do
    {
      v45 = *v44++;
      v46 = v45;
      v47 = *v43++;
      v30 = v30 + (float)(v46 * v47);
      ++v19;
    }
    while (v26 >= v19);
  }
  v42 = *((float *)this + 25);
  v48 = (float)(v27 * v42) + v40 * (float)(log10f(v29 + v30) * 10.0);
  *((float *)this + 25) = v48;
  *((float *)this + 47) = v41 - v48;
  v50 = 0.0;
  v51 = 0.0;
  if (v26 <= v20)
  {
    v52 = (float *)(*v16 + 4 * (int)v26);
    v53 = (float *)(*v11 + 4 * (int)v26);
    v54 = v26;
    do
    {
      v55 = *v53++;
      v56 = v55;
      v57 = *v52++;
      v51 = v51 + (float)(v56 * v57);
      ++v54;
    }
    while (v20 >= v54);
  }
  v49 = *((float *)this + 26);
  v58 = (float)(v27 * v49) + v40 * (float)(log10f(v29 + v51) * 10.0);
  *((float *)this + 26) = v58;
  if (v26 <= v20)
  {
    v60 = (float *)(*v16 + 4 * (int)v26);
    v61 = (float *)(*v12 + 4 * (int)v26);
    v50 = 0.0;
    do
    {
      v62 = *v61++;
      v63 = v62;
      v64 = *v60++;
      v50 = v50 + (float)(v63 * v64);
      ++v26;
    }
    while (v20 >= v26);
  }
  v59 = *((float *)this + 27);
  v65 = (float)(v27 * v59) + v40 * (float)(log10f(v29 + v50) * 10.0);
  *((float *)this + 27) = v65;
  *((float *)this + 48) = v58 - v65;
  v66 = *((unsigned int *)this + 6);
  LODWORD(__B.realp) = 1065353216;
  std::vector<float>::assign((char **)this + 53, v66, &__B);
  v67 = *((_DWORD *)this + 14);
  v68 = *((_DWORD *)this + 15);
  v69 = *((float *)this + 17);
  v71 = *((float *)this + 1);
  v72 = 0.0;
  v73 = 0.0;
  if (v67 <= v68)
  {
    v74 = (float *)(*v16 + 4 * (int)v67);
    v75 = (float *)(*v11 + 4 * (int)v67);
    v76 = *((_DWORD *)this + 14);
    do
    {
      v77 = *v75++;
      v78 = v77;
      v79 = *v74++;
      v73 = v73 + (float)(v78 * v79);
      ++v76;
    }
    while (v68 >= v76);
  }
  v80 = 1.0 - v69;
  v70 = *((float *)this + 49);
  v81 = (float)(v69 * v70) + v80 * (float)(log10f(v71 + v73) * 10.0);
  *((float *)this + 49) = v81;
  if (v67 <= v68)
  {
    v83 = (float *)(*v16 + 4 * (int)v67);
    v84 = (float *)(*v12 + 4 * (int)v67);
    v72 = 0.0;
    do
    {
      v85 = *v84++;
      v86 = v85;
      v87 = *v83++;
      v72 = v72 + (float)(v86 * v87);
      ++v67;
    }
    while (v68 >= v67);
  }
  v82 = *((float *)this + 50);
  v88 = (float)(v69 * v82) + v80 * (float)(log10f(v71 + v72) * 10.0);
  *((float *)this + 50) = v88;
  v89 = *((_DWORD *)this + 45);
  if (!v89)
  {
    *((_DWORD *)this + 46) = 0;
    v93 = *((float *)this + 23);
    *((float *)this + 31) = v93;
    goto LABEL_44;
  }
  if (v89 == 1)
  {
    if (*((float *)this + 23) <= *((float *)this + 33) || (v90 = *((float *)this + 56), v90 >= v81) && v90 >= v88)
    {
      v91 = 0;
      goto LABEL_32;
    }
    v91 = *((_DWORD *)this + 46);
    if (v91 > 4 || ((1 << v91) & 0x19) == 0)
      goto LABEL_32;
    v189 = *((float *)this + 47);
    v190 = *((float *)this + 55);
    if (fabsf(v189) >= v190 || fabsf(*((float *)this + 48)) >= v190)
    {
      v194 = *((float *)this + 57);
      if (v194 > v81)
      {
        v91 = 1;
        goto LABEL_32;
      }
      v191 = v194 <= v88;
      v91 = 5;
      v192 = 2;
    }
    else
    {
      v191 = v189 <= 0.0;
      v91 = 4;
      v192 = 3;
    }
    if (!v191)
      v91 = v192;
LABEL_32:
    if (*((_DWORD *)this + 28) == v91)
      v92 = *((_DWORD *)this + 21) - 1;
    else
      v92 = *((float *)this + 20);
    *((_DWORD *)this + 21) = v92;
    if (!v92)
    {
      *((_DWORD *)this + 46) = v91;
      *((_DWORD *)this + 21) = *((float *)this + 20);
    }
    v93 = *((float *)this + 23);
    *((float *)this + 31) = v93;
    v94 = (_DWORD *)((char *)this + 124);
    *((_DWORD *)this + 28) = v91;
    if ((*((_DWORD *)this + 46) - 3) >= 2)
      goto LABEL_43;
    goto LABEL_44;
  }
  v93 = *((float *)this + 23);
  *((float *)this + 31) = v93;
  v94 = (_DWORD *)((char *)this + 124);
  if (v89 != 3)
  {
    if (v89 != 2 || (*((_DWORD *)this + 46) & 0xFFFFFFFE) == 2)
      goto LABEL_44;
    goto LABEL_43;
  }
  if (*((_DWORD *)this + 46))
  {
LABEL_43:
    *v94 = 0;
    v93 = 0.0;
  }
LABEL_44:
  v95 = *((float *)this + 33);
  v96 = v93 > v95;
  if (*((unsigned __int8 *)this + 116) == v96)
    v97 = *((_DWORD *)this + 19) - 1;
  else
    v97 = *((float *)this + 18);
  *((_DWORD *)this + 19) = v97;
  if (!v97)
  {
    *((_BYTE *)this + 120) = v96;
    *((_DWORD *)this + 19) = *((float *)this + 18);
  }
  *((_BYTE *)this + 116) = v96;
  if (*((_BYTE *)this + 244))
  {
    if (!*((_BYTE *)this + 8))
      __assert_rtn("GetGains", "WindDetectorAndSuppressor.cpp", 311, "mInitialized");
    *((_BYTE *)this + 588) = *((_BYTE *)this + 120);
    *((float *)this + 141) = v93;
    if (!*((_BYTE *)this + 832))
      __assert_rtn("process", "WindSuppressorCore.cpp", 211, "mInitialized");
    v98 = (*((_QWORD *)this + 48) - *((_QWORD *)this + 47)) >> 2;
    v99 = *((_DWORD *)this + 131);
    if (v99 >= v98)
      v100 = v98;
    else
      v100 = v99;
    *((_DWORD *)this + 134) = v100;
    v101 = (const float *)*((_QWORD *)this + 35);
    if (v100 > (uint64_t)(*((_QWORD *)this + 36) - (_QWORD)v101) >> 2)
      __assert_rtn("process", "WindSuppressorCore.cpp", 215, "psd1.size() >= mNumBinsToProcess");
    v102 = (const float *)*((_QWORD *)this + 38);
    if (v100 > (uint64_t)(*((_QWORD *)this + 39) - (_QWORD)v102) >> 2)
      __assert_rtn("process", "WindSuppressorCore.cpp", 216, "psd2.size() >= mNumBinsToProcess");
    if (v100 > (uint64_t)(*((_QWORD *)this + 45) - *((_QWORD *)this + 44)) >> 2)
      __assert_rtn("process", "WindSuppressorCore.cpp", 217, "coherence.size() >= mNumBinsToProcess");
    vDSP_vmax(v101, 1, v102, 1, *((float **)this + 86), 1, v100);
    if (!*((_BYTE *)this + 832))
      __assert_rtn("computeWindSuppressionGain", "WindSuppressorCore.cpp", 250, "mInitialized");
    v103 = *((unsigned int *)this + 134);
    if (v103 > (uint64_t)(*((_QWORD *)this + 87) - *((_QWORD *)this + 86)) >> 2)
      __assert_rtn("computeWindSuppressionGain", "WindSuppressorCore.cpp", 251, "psd.size() >= mNumBinsToProcess");
    v104 = (const float *)*((_QWORD *)this + 44);
    if (v103 > (uint64_t)(*((_QWORD *)this + 45) - (_QWORD)v104) >> 2)
      __assert_rtn("computeWindSuppressionGain", "WindSuppressorCore.cpp", 252, "coherence.size() >= mNumBinsToProcess");
    v105 = (float *)*((_QWORD *)this + 47);
    if (v103 > (uint64_t)(*((_QWORD *)this + 48) - (_QWORD)v105) >> 2)
      __assert_rtn("computeWindSuppressionGain", "WindSuppressorCore.cpp", 253, "gain.size() >= mNumBinsToProcess");
    v106 = *((_QWORD *)this + 62);
    v107 = *(float *)(v106 + 12);
    __D = -*(float *)(v106 + 16);
    v202[0] = v107;
    vDSP_vsadd(v104, 1, &__D, v105, 1, v103);
    vDSP_vsmul(*((const float **)this + 47), 1, v202, *((float **)this + 47), 1, *((unsigned int *)this + 134));
    vvtanhf(*((float **)this + 47), *((const float **)this + 47), (const int *)this + 134);
    vDSP_vadd(*((const float **)this + 74), 1, *((const float **)this + 47), 1, *((float **)this + 47), 1, *((unsigned int *)this + 134));
    vDSP_vsmul(*((const float **)this + 47), 1, &WindSuppressorCore::kPoint5f, *((float **)this + 47), 1, *((unsigned int *)this + 134));
    WindUtility::EventTracker<float>::update(*((_QWORD *)this + 101), *((float *)this + 141));
    if ((*(_DWORD *)(*((_QWORD *)this + 101) + 64) - 3) >= 2)
    {
      v109 = *((_QWORD *)this + 47);
      LODWORD(v108) = *((_DWORD *)this + 134);
      v110 = 0.0;
    }
    else
    {
      v108 = *((unsigned int *)this + 134);
      v109 = *((_QWORD *)this + 47);
      v110 = 0.0;
      if ((_DWORD)v108)
      {
        v111 = 0;
        while (*(float *)(v109 + 4 * v111) <= *(float *)(*((_QWORD *)this + 62) + 20))
        {
          if (v108 == ++v111)
            goto LABEL_97;
        }
        v110 = (float)(int)v111;
      }
    }
LABEL_97:
    v141 = (float *)*((_QWORD *)this + 92);
    v142 = 576;
    if (v110 > *v141)
      v142 = 572;
    v143 = (float)(v110 * (float)(1.0 - *(float *)((char *)this + v142)))
         + (float)(*(float *)((char *)this + v142) * *v141);
    *v141 = v143;
    vDSP_vfill(&WindSuppressorCore::computeWindSuppressionGain(std::vector<float> const&,std::vector<float> const&,std::vector<float>&,unsigned int)::one, (float *)(v109 + 4 * v143), 1, v108 - v143);
    vDSP_vmax(*((const float **)this + 80), 1, *((const float **)this + 47), 1, *((float **)this + 47), 1, *((unsigned int *)this + 134));
    if (!*((_BYTE *)this + 832))
      __assert_rtn("refineGainsBasedOnEnergy", "WindSuppressorCore.cpp", 314, "mInitialized");
    v144 = *((unsigned int *)this + 134);
    if (v144 > (uint64_t)(*((_QWORD *)this + 87) - *((_QWORD *)this + 86)) >> 2)
      __assert_rtn("refineGainsBasedOnEnergy", "WindSuppressorCore.cpp", 315, "psd.size() >= mNumBinsToProcess");
    v145 = (const float *)*((_QWORD *)this + 47);
    if (v144 > (uint64_t)(*((_QWORD *)this + 48) - (_QWORD)v145) >> 2)
      __assert_rtn("refineGainsBasedOnEnergy", "WindSuppressorCore.cpp", 316, "gain.size() >= mNumBinsToProcess");
    v146 = (float *)*((_QWORD *)this + 89);
    if (v144 > (uint64_t)(*((_QWORD *)this + 90) - (_QWORD)v146) >> 2)
      __assert_rtn("createSmallerThanMask", "WindSuppressorCore.cpp", 447, "vecOut.size() >= numElements");
    vDSP_vsub(v145, 1, *((const float **)this + 74), 1, v146, 1, *((unsigned int *)this + 134));
    LODWORD(__B.realp) = 1036831952;
    if (!*((_BYTE *)this + 832))
      __assert_rtn("createGreterThanMask", "WindSuppressorCore.cpp", 425, "mInitialized");
    if (v144 > (uint64_t)(*((_QWORD *)this + 48) - *((_QWORD *)this + 47)) >> 2)
      __assert_rtn("createGreterThanMask", "WindSuppressorCore.cpp", 426, "vecIn.size() >= numElements");
    v147 = (const float *)*((_QWORD *)this + 89);
    if (v144 > (uint64_t)(*((_QWORD *)this + 90) - (_QWORD)v147) >> 2)
      __assert_rtn("createGreterThanMask", "WindSuppressorCore.cpp", 427, "vecOut.size() >= numElements");
    vDSP_vthrsc(v147, 1, (const float *)&__B, &WindSuppressorCore::kOnef, *((float **)this + 89), 1, v144);
    vDSP_vthr(*((const float **)this + 89), 1, &WindSuppressorCore::kZerof, *((float **)this + 89), 1, v144);
    LODWORD(__B.realp) = 0;
    vDSP_sve(*((const float **)this + 89), 1, (float *)&__B, *((unsigned int *)this + 134));
    vDSP_vmul(*((const float **)this + 86), 1, *((const float **)this + 89), 1, *((float **)this + 89), 1, *((unsigned int *)this + 134));
    LODWORD(__A.realp) = 0;
    vDSP_sve(*((const float **)this + 89), 1, (float *)&__A, *((unsigned int *)this + 134));
    v148 = *(float *)&__B.realp < 2.2204e-16 || *(float *)&__A.realp < 2.2204e-16;
    v149 = *(float *)&__A.realp / *(float *)&__B.realp;
    if (v148)
      v149 = 1.0;
    *(float *)&__A.realp = v149;
    vDSP_vsdiv(*((const float **)this + 89), 1, (const float *)&__A, *((float **)this + 89), 1, *((unsigned int *)this + 134));
    LODWORD(__C.realp) = 1065353216;
    vDSP_vsadd(*((const float **)this + 89), 1, &WindSuppressorCore::kEpsf, *((float **)this + 89), 1, *((unsigned int *)this + 134));
    vDSP_vdbcon(*((const float **)this + 89), 1, (const float *)&__C, *((float **)this + 89), 1, *((unsigned int *)this + 134), 0);
    v150 = (float *)*((_QWORD *)this + 92);
    if (*v150 > 0.0)
    {
      v151 = 0;
      v152 = *((_QWORD *)this + 62);
      v153 = *(float *)(v152 + 44);
      v154 = *(float *)(v152 + 48);
      v155 = *((_QWORD *)this + 89);
      v156 = *((_QWORD *)this + 47);
      v157 = vabds_f32(v153, v154);
      do
      {
        if (v157 >= 2.2204e-16)
        {
          v159 = *(float *)(v155 + 4 * v151);
          v158 = 1.0;
          if (v159 < v153)
            goto LABEL_118;
          if (v159 <= v154)
          {
            v158 = (float)((float)((float)(1.0 - *(float *)(v156 + 4 * v151)) / (float)(v153 - v154))
                         * (float)(v159 - v153))
                 + 1.0;
            goto LABEL_118;
          }
        }
        v158 = *(float *)(v156 + 4 * v151);
LABEL_118:
        *(float *)(v156 + 4 * v151++) = v158;
      }
      while (*v150 > (float)(int)v151);
    }
    if (!*((_BYTE *)this + 832))
      __assert_rtn("applyFrequencySmoothingWindow", "WindSuppressorCore.cpp", 366, "mInitialized");
    v160 = *((unsigned int *)this + 134);
    v161 = *((_QWORD *)this + 47);
    if (v160 > (*((_QWORD *)this + 48) - v161) >> 2)
      __assert_rtn("applyFrequencySmoothingWindow", "WindSuppressorCore.cpp", 367, "input.size() >= inputSize");
    v162 = (float *)*((_QWORD *)this + 83);
    v163 = (uint64_t)(*((_QWORD *)this + 84) - (_QWORD)v162) >> 2;
    v164 = *((_DWORD *)this + 135);
    if (v163 < v164 + v160)
      __assert_rtn("applyFrequencySmoothingWindow", "WindSuppressorCore.cpp", 369, "mTmpVector1.size() >= inputSize + mFilterSize");
    if (v164 <= 1)
      v165 = 0;
    else
      v165 = (v164 >> 1) - 1;
    vDSP_vfill((const float *)(v161 + 4 * (v160 - 1)), v162, 1, v163);
    vDSP_vfill(*((const float **)this + 47), *((float **)this + 83), 1, v165);
    if ((_DWORD)v160)
      memmove((void *)(*((_QWORD *)this + 83) + 4 * v165), *((const void **)this + 47), 4 * v160);
    vDSP_conv(*((const float **)this + 83), 1, (const float *)(*((_QWORD *)this + 77) + 4 * *((unsigned int *)this + 135) - 4), -1, *((float **)this + 47), 1, v160, *((unsigned int *)this + 135));
    if (!*((_BYTE *)this + 832))
      __assert_rtn("smoothGainsInTime", "WindSuppressorCore.cpp", 401, "mInitialized");
    v166 = (const float *)*((_QWORD *)this + 47);
    __N = *((unsigned int *)this + 134);
    if (__N > (uint64_t)(*((_QWORD *)this + 48) - (_QWORD)v166) >> 2)
      __assert_rtn("smoothGainsInTime", "WindSuppressorCore.cpp", 402, "gain.size() >= mNumBinsToProcess");
    v168 = *((_QWORD *)this + 95);
    LODWORD(__A.realp) = *((_DWORD *)this + 145);
    *(float *)&__C.realp = 1.0 - *(float *)&__A.realp;
    vDSP_vsmsma(*(const float **)v168, 1, (const float *)&__A, v166, 1, (const float *)&__C, *(float **)v168, 1, __N);
    if (!*((_BYTE *)this + 832))
      __assert_rtn("generateHighPassCutoffIndex", "WindSuppressorCore.cpp", 483, "mInitialized");
    v169 = *((unsigned int *)this + 134);
    if (v169 > (uint64_t)(*(_QWORD *)(v168 + 8) - *(_QWORD *)v168) >> 2)
      __assert_rtn("generateHighPassCutoffIndex", "WindSuppressorCore.cpp", 484, "gain.size() >= mNumBinsToProcess");
    vDSP_vsub(*(const float **)v168, 1, *((const float **)this + 74), 1, *((float **)this + 83), 1, v169);
    vDSP_vthrsc(*((const float **)this + 83), 1, &WindSuppressorCore::generateHighPassCutoffIndex(std::vector<float> const&)::thr, &WindSuppressorCore::kOnef, *((float **)this + 83), 1, *((unsigned int *)this + 134));
    vDSP_vthr(*((const float **)this + 83), 1, &WindSuppressorCore::kZerof, *((float **)this + 83), 1, *((unsigned int *)this + 134));
    LODWORD(__B.realp) = 0;
    vDSP_sve(*((const float **)this + 83), 1, (float *)&__B, *((unsigned int *)this + 134));
    v140 = *((double *)this + 69)
         / (float)((float)*((unsigned int *)this + 132) + (float)*((unsigned int *)this + 132))
         * *(float *)&__B.realp;
    *((float *)this + 142) = v140;
    v170 = *((unsigned int *)this + 134);
    if ((_DWORD)v170)
    {
      memmove(*((void **)this + 47), **((const void ***)this + 95), 4 * v170);
      v140 = *((float *)this + 142);
    }
  }
  else
  {
    if (v93 > v95)
    {
      v112 = *((unsigned int *)this + 9);
      v113 = *((_DWORD *)this + 11);
      if (v112 <= v113)
      {
        v114 = *((_QWORD *)this + 44);
        v115 = *((_QWORD *)this + 47);
        v116 = *((_DWORD *)this + 9);
        do
        {
          v117 = *((float *)this + 22)
               + (float)(*(float *)this - *((float *)this + 22))
               * ((float)(tanhf(*((float *)this + 39) * (float)(*(float *)(v114 + 4 * v116) - *((float *)this + 38)))
                        + 1.0)
                * 0.5);
          *(float *)(v115 + 4 * v116++) = v117;
        }
        while (v116 <= v113);
      }
      v119 = *((_QWORD *)this + 50);
      v118 = *((_QWORD *)this + 51);
      v120 = (v118 - v119) >> 2;
      v121 = v120 >> 1;
      if (v120 >> 1 <= v112)
        v122 = v112;
      else
        v122 = v120 >> 1;
      v123 = *((unsigned int *)this + 6);
      LODWORD(__B.realp) = 0;
      std::vector<float>::assign((char **)this + 53, v123, &__B);
      v124 = *((unsigned int *)this + 11);
      v125 = v124 - (v120 >> 1);
      if (v122 <= v125)
      {
        if (v120 <= 1)
          v126 = 1;
        else
          v126 = (v118 - v119) >> 2;
        v127 = 4 * v122 - 4 * v121;
        do
        {
          if (v118 != v119)
          {
            v128 = *((_QWORD *)this + 53);
            v129 = *(float *)(v128 + 4 * v122);
            v130 = (float *)(*((_QWORD *)this + 50) + 4 * v120 - 4 * v121);
            v131 = (float *)(*((_QWORD *)this + 47) + v127);
            v132 = v126;
            do
            {
              v133 = *v131++;
              v134 = v133;
              v135 = *v130--;
              v129 = v129 + (float)(v134 * v135);
              *(float *)(v128 + 4 * v122) = v129;
              --v132;
            }
            while (v132);
          }
          ++v122;
          v127 += 4;
        }
        while (v122 <= v125);
      }
      if (v121 <= v125)
      {
        v136 = *((_QWORD *)this + 53);
        v137 = *((_QWORD *)this + 47);
        do
        {
          *(_DWORD *)(v137 + 4 * v121) = *(_DWORD *)(v136 + 4 * v121);
          ++v121;
        }
        while (v121 <= v125);
      }
      v138 = *((_DWORD *)this + 10);
      if (v138 <= v124)
      {
        v139 = *((_QWORD *)this + 47);
        while (*(float *)(v139 + 4 * v138) <= *((float *)this + 43))
        {
          if (++v138 > v124)
            goto LABEL_134;
        }
        v193 = *((double *)this + 2)
             / (float)((float)*((unsigned int *)this + 6) + (float)*((unsigned int *)this + 6))
             * (double)v138;
        *((float *)this + 32) = v193;
        while (v138 <= v124)
          *(_DWORD *)(v139 + 4 * v138++) = *(_DWORD *)this;
      }
      goto LABEL_134;
    }
    std::vector<float>::assign((char **)this + 47, *((unsigned int *)this + 6), this);
    v140 = 160.0;
  }
  *((float *)this + 32) = v140;
LABEL_134:
  if (a3)
  {
    v171 = 0;
    v172 = *((unsigned int *)this + 6);
    v173 = 1;
    do
    {
      v174 = v173;
      mData = (const float *)a2->mBuffers[v171].mData;
      v176 = (float *)a3->mBuffers[v171].mData;
      v177 = mData[v172];
      vDSP_vmul(mData, 1, *((const float **)this + 47), 1, v176, 1, v172);
      vDSP_vmul(&mData[*((unsigned int *)this + 6)], 1, *((const float **)this + 47), 1, &v176[*((unsigned int *)this + 6)], 1, *((unsigned int *)this + 6));
      v173 = 0;
      v172 = *((unsigned int *)this + 6);
      v176[v172] = v177;
      v171 = 1;
    }
    while ((v174 & 1) != 0);
  }
  v178 = (float32x2_t)0x3F0000003F000000;
  if ((*((_DWORD *)this + 46) - 3) <= 1)
  {
    v195 = __exp10f(*((float *)this + 24) * 0.1);
    v179.f32[0] = __exp10f(*((float *)this + 25) * 0.1);
    v179.f32[1] = v195;
    v178 = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(v179), 1.0 / (float)((float)(v195 + v179.f32[0]) + *((float *)this + 1))));
  }
  *(float32x2_t *)((char *)this + 236) = v178;
  v180 = (char *)this + 236;
  if (a4)
  {
    v181 = (const float *)a2->mBuffers[0].mData;
    v182 = *(const float **)&a2[1].mBuffers[0].mNumberChannels;
    v183 = (float *)a4->mBuffers[0].mData;
    v184 = (2 * *((_DWORD *)this + 6));
    if (*((_BYTE *)this + 244))
    {
      if (!*((_BYTE *)this + 832))
        __assert_rtn("updateAggregateOmni", "WindSuppressorCore.cpp", 232, "mInitialized");
      v180 = (char *)*((_QWORD *)this + 98);
      if (*((_QWORD *)this + 99) - (_QWORD)v180 <= 7uLL)
        __assert_rtn("updateAggregateOmni", "WindSuppressorCore.cpp", 233, "mAggregateOmniMicWeight.size() >= 2");
      v185 = (float)((float)(1.0 - *((float *)this + 146)) * v178.f32[0])
           + (float)(*((float *)this + 146) * *(float *)v180);
      *(float *)v180 = v185;
      *((float *)v180 + 1) = 1.0 - v185;
      v186 = (const float *)(v180 + 4);
    }
    else
    {
      v186 = (const float *)((char *)this + 240);
    }
    vDSP_vsmsma(v181, 1, (const float *)v180, v182, 1, v186, v183, 1, v184);
  }
  if (a5)
  {
    v187 = (_BYTE *)*((_QWORD *)this + 47);
    v188 = (_BYTE *)*((_QWORD *)this + 48);
    if (v188 != v187)
      memmove(a5->mBuffers[0].mData, v187, v188 - v187);
  }
}

void ecutils::fcn_vector_init<float>(uint64_t *a1, unsigned int a2, unsigned int a3, float a4)
{
  unint64_t v5;
  void *__p[3];
  float v7;

  v7 = a4;
  v5 = a2;
  std::vector<float>::vector(__p, a3, &v7);
  std::vector<std::vector<float>>::assign(a1, v5, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1B613753C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ecutils::fcn_vector_init<float>(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  unint64_t v7;
  unint64_t v8;
  void **v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  void **v20;
  uint64_t v21;
  void *__p[3];
  uint64_t v23;
  uint64_t v24;
  float v25;
  void **v26;

  v25 = a5;
  v7 = a3;
  std::vector<float>::vector(__p, a4, &v25);
  std::vector<std::vector<float>>::vector(&v23, v7, (uint64_t)__p);
  v8 = a2;
  v9 = *(void ***)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) >= a2)
  {
    v15 = (*(_QWORD *)(a1 + 8) - (_QWORD)v9) / 24;
    if (v15 >= v8)
      v16 = v8;
    else
      v16 = (*(_QWORD *)(a1 + 8) - (_QWORD)v9) / 24;
    for (; v16; --v16)
    {
      if (v9 != (void **)&v23)
        std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((uint64_t)v9, v23, v24, 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 3));
      v9 += 3;
    }
    if (v8 <= v15)
    {
      v20 = *(void ***)(a1 + 8);
      v21 = *(_QWORD *)a1 + 24 * v8;
      while (v20 != (void **)v21)
      {
        v20 -= 3;
        v26 = v20;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v26);
      }
      *(_QWORD *)(a1 + 8) = v21;
    }
    else
    {
      v17 = *(_QWORD **)(a1 + 8);
      v18 = &v17[3 * (v8 - v15)];
      v19 = 24 * v8 - 24 * v15;
      do
      {
        *v17 = 0;
        v17[1] = 0;
        v17[2] = 0;
        std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v17, v23, v24, 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 3));
        v17 += 3;
        v19 -= 24;
      }
      while (v19);
      *(_QWORD *)(a1 + 8) = v18;
    }
  }
  else
  {
    std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a1);
    v10 = 0x5555555555555556 * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3);
    if (v10 <= a2)
      v10 = a2;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v10;
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100]((_QWORD *)a1, v11);
    v12 = *(_QWORD **)(a1 + 8);
    v13 = &v12[3 * a2];
    v14 = 24 * v8;
    do
    {
      *v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v12, v23, v24, 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 3));
      v12 += 3;
      v14 -= 24;
    }
    while (v14);
    *(_QWORD *)(a1 + 8) = v13;
  }
  v26 = (void **)&v23;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v26);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1B613777C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char *a16)
{
  a16 = &a12;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void ecutils::fcn_vector_init<float>(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, float a6)
{
  unint64_t v9;
  unint64_t v10;
  void **v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  void **v23;
  uint64_t v24;
  void *__p[3];
  uint64_t v26[3];
  uint64_t *v27;
  uint64_t *v28;
  float v29;
  void **v30;

  v29 = a6;
  v9 = a4;
  std::vector<float>::vector(__p, a5, &v29);
  std::vector<std::vector<float>>::vector(v26, v9, (uint64_t)__p);
  std::vector<std::vector<std::vector<float>>>::vector(&v27, a3, v26);
  v10 = a2;
  v11 = *(void ***)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) >= v10)
  {
    v18 = (*(_QWORD *)(a1 + 8) - (_QWORD)v11) / 24;
    if (v18 >= v10)
      v19 = v10;
    else
      v19 = (*(_QWORD *)(a1 + 8) - (_QWORD)v11) / 24;
    for (; v19; --v19)
    {
      if (v11 != (void **)&v27)
        std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)v11, v27, v28, 0xAAAAAAAAAAAAAAABLL * (v28 - v27));
      v11 += 3;
    }
    if (v10 <= v18)
    {
      v23 = *(void ***)(a1 + 8);
      v24 = *(_QWORD *)a1 + 24 * v10;
      while (v23 != (void **)v24)
      {
        v23 -= 3;
        v30 = v23;
        std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v30);
      }
      *(_QWORD *)(a1 + 8) = v24;
    }
    else
    {
      v20 = *(_QWORD **)(a1 + 8);
      v21 = &v20[3 * (v10 - v18)];
      v22 = 24 * v10 - 24 * v18;
      do
      {
        *v20 = 0;
        v20[1] = 0;
        v20[2] = 0;
        std::vector<std::vector<std::vector<float>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v20, v27, v28, 0xAAAAAAAAAAAAAAABLL * (v28 - v27));
        v20 += 3;
        v22 -= 24;
      }
      while (v22);
      *(_QWORD *)(a1 + 8) = v21;
    }
  }
  else
  {
    std::vector<std::vector<std::vector<std::vector<float>>>>::__vdeallocate((void ***)a1);
    v12 = 0x5555555555555556 * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3);
    if (v12 <= v10)
      v12 = v10;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) >= 0x555555555555555)
      v13 = 0xAAAAAAAAAAAAAAALL;
    else
      v13 = v12;
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100]((_QWORD *)a1, v13);
    v14 = *(_QWORD **)(a1 + 8);
    v15 = 3 * v10;
    v16 = &v14[3 * v10];
    v17 = 8 * v15;
    do
    {
      *v14 = 0;
      v14[1] = 0;
      v14[2] = 0;
      std::vector<std::vector<std::vector<float>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v14, v27, v28, 0xAAAAAAAAAAAAAAABLL * (v28 - v27));
      v14 += 3;
      v17 -= 24;
    }
    while (v17);
    *(_QWORD *)(a1 + 8) = v16;
  }
  v30 = (void **)&v27;
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v30);
  v30 = (void **)v26;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v30);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1B6137A14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16)
{
  uint64_t v16;

  *(_QWORD *)(v16 - 72) = &a16;
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v16 - 72));
  *(_QWORD *)(v16 - 72) = &a13;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v16 - 72));
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::vector<std::vector<float>>>::vector(_QWORD *a1, unint64_t a2, uint64_t *a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = 3 * a2;
    v8 = &v6[3 * a2];
    v9 = 8 * v7;
    do
    {
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v6, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_1B6137B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::vector<std::vector<std::vector<float>>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::vector<std::vector<std::vector<std::vector<float>>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<std::vector<float>>>*,std::vector<std::vector<std::vector<float>>>*>(_QWORD *result, uint64_t **a2, uint64_t **a3, unint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD v9[3];
  char v10;
  _QWORD *v11;
  _QWORD *v12;

  if (a4)
  {
    v6 = result;
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)v6[1];
    v11 = v7;
    v12 = v7;
    v9[0] = v6 + 2;
    v9[1] = &v11;
    v9[2] = &v12;
    v10 = 0;
    if (a2 == a3)
    {
      v8 = v7;
    }
    else
    {
      v8 = v7;
      do
      {
        *v8 = 0;
        v8[1] = 0;
        v8[2] = 0;
        std::vector<std::vector<std::vector<float>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v8, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2));
        v8 = v12 + 3;
        v12 += 3;
        a2 += 3;
      }
      while (a2 != a3);
    }
    v10 = 1;
    result = (_QWORD *)std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<std::vector<float>>>>,std::vector<std::vector<std::vector<float>>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
    v6[1] = v8;
  }
  return result;
}

void sub_1B6137C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<std::vector<std::vector<float>>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::vector<std::vector<float>>>::__init_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(_QWORD *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)(v6 + 2), a2, a3, (_QWORD *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B6137D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<std::vector<float>>>>,std::vector<std::vector<std::vector<float>>>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  void **v3;
  void **v4;
  void **v5;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = **(void ****)(a1 + 16);
    v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      v5 = v3;
      std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t *v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * ((v6[1] - *v6) >> 3));
      v4 = v11 + 3;
      v11 += 3;
      v6 += 3;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1B6137E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  void **v3;
  void **v4;
  void **v5;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = **(void ****)(a1 + 16);
    v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      v5 = v3;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

void std::vector<std::vector<std::vector<std::vector<float>>>>::__vdeallocate(void ***a1)
{
  void **v1;
  void **v3;
  void **v4;
  void **v5;

  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        v5 = v3;
        std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v8;
  void **v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t *v13;
  uint64_t v14;
  void **v15;
  void **v16;

  v8 = a1 + 16;
  v9 = *(void ***)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) < a4)
  {
    std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v10 = 0x5555555555555556 * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3);
    if (v10 <= a4)
      v10 = a4;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v10;
    std::vector<std::vector<DSPSplitComplex>>::__vallocate[abi:ne180100]((_QWORD *)a1, v11);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v8, a2, a3, *(_QWORD **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v9) >> 3) < a4)
  {
    v13 = &a2[(uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v9) >> 3];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>(a2, v13, (uint64_t)v9);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(v8, v13, a3, *(_QWORD **)(a1 + 8));
LABEL_11:
    *(_QWORD *)(a1 + 8) = v12;
    return;
  }
  v14 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>(a2, a3, (uint64_t)v9);
  v15 = *(void ***)(a1 + 8);
  while (v15 != (void **)v14)
  {
    v15 -= 3;
    v16 = v15;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v16);
  }
  *(_QWORD *)(a1 + 8) = v14;
}

void sub_1B6138090(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B6138098(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v5;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if (v5 != (uint64_t *)a3)
        std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(a3, *v5, v5[1], 0xAAAAAAAAAAAAAAABLL * ((v5[1] - *v5) >> 3));
      v5 += 3;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return a3;
}

void std::vector<std::vector<std::vector<float>>>::__vdeallocate(void ***a1)
{
  void **v1;
  void **v3;
  void **v4;
  void **v5;

  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        v5 = v3;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<float>>::assign(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  char *v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;

  v6 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= a2)
  {
    v13 = (a1[1] - (uint64_t)v6) / 24;
    if (v13 >= a2)
      v14 = a2;
    else
      v14 = (a1[1] - (uint64_t)v6) / 24;
    for (; v14; --v14)
    {
      if (v6 != (char *)a3)
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v6, *(char **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
      v6 += 24;
    }
    if (a2 <= v13)
    {
      v18 = a1[1];
      v19 = *a1 + 24 * a2;
      if (v18 != v19)
      {
        v20 = a1[1];
        do
        {
          v22 = *(void **)(v20 - 24);
          v20 -= 24;
          v21 = v22;
          if (v22)
          {
            *(_QWORD *)(v18 - 16) = v21;
            operator delete(v21);
          }
          v18 = v20;
        }
        while (v20 != v19);
      }
      a1[1] = v19;
    }
    else
    {
      v15 = (_QWORD *)a1[1];
      v16 = &v15[3 * (a2 - v13)];
      v17 = -24 * v13 + 24 * a2;
      do
      {
        *v15 = 0;
        v15[1] = 0;
        v15[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v15, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
        v15 += 3;
        v17 -= 24;
      }
      while (v17);
      a1[1] = (uint64_t)v16;
    }
  }
  else
  {
    std::vector<std::vector<float>>::__vdeallocate(a1);
    v7 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
    if (v7 <= a2)
      v7 = a2;
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555)
      v8 = 0xAAAAAAAAAAAAAAALL;
    else
      v8 = v7;
    std::vector<std::__fs::filesystem::path>::__vallocate[abi:ne180100](a1, v8);
    v9 = (_QWORD *)a1[1];
    v10 = 3 * a2;
    v11 = &v9[3 * a2];
    v12 = 8 * v10;
    do
    {
      *v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v9, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
      v9 += 3;
      v12 -= 24;
    }
    while (v12);
    a1[1] = (uint64_t)v11;
  }
}

void sub_1B613833C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<std::vector<unsigned int>>::resize(_QWORD *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::vector<unsigned int>>::__append((uint64_t)a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      v8 = a1[1];
      do
      {
        v10 = *(void **)(v8 - 24);
        v8 -= 24;
        v9 = v10;
        if (v10)
        {
          *(_QWORD *)(v3 - 16) = v9;
          operator delete(v9);
        }
        v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void std::vector<std::vector<unsigned int>>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;

  v4 = a1 + 16;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - v6) >> 3) >= a2)
  {
    if (a2)
    {
      v12 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(a1 + 8), v12);
      v6 += v12;
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  else
  {
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v6 - *(_QWORD *)a1) >> 3);
    v8 = v7 + a2;
    if (v7 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *(_QWORD *)a1) >> 3);
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x555555555555555)
      v10 = 0xAAAAAAAAAAAAAAALL;
    else
      v10 = v8;
    v18 = v4;
    if (v10)
      v10 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(v10);
    else
      v11 = 0;
    v14 = v10;
    v15 = (char *)(v10 + 24 * v7);
    v17 = v10 + 24 * v11;
    v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v15, v13);
    v16 = &v15[v13];
    std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer((_QWORD *)a1, &v14);
    std::__split_buffer<std::vector<unsigned int>>::~__split_buffer((uint64_t)&v14);
  }
}

_QWORD *std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  __int128 v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (_QWORD *)*result;
  v2 = (_QWORD *)result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    *(_QWORD *)(v4 - 24) = 0;
    *(_QWORD *)(v4 - 16) = 0;
    v4 -= 24;
    *(_QWORD *)(v4 + 16) = 0;
    v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)v4 = v5;
    *(_QWORD *)(v4 + 16) = v2[2];
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  v6 = (_QWORD *)*result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::vector<unsigned int>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v4 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(_QWORD *)(v2 - 16) = v4;
      operator delete(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void AUSpeechEnhancer::~AUSpeechEnhancer(AUSpeechEnhancer *this)
{
  AUSpeechEnhancer::~AUSpeechEnhancer(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  *(_QWORD *)this = &off_1E69C7ED0;
  v2 = (void *)*((_QWORD *)this + 82);
  if (v2)
  {
    *((_QWORD *)this + 83) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 78);
  if (v3)
  {
    *((_QWORD *)this + 79) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 75);
  if (v4)
  {
    *((_QWORD *)this + 76) = v4;
    operator delete(v4);
  }
  std::unique_ptr<SpeechEnhancerCore<float>>::reset[abi:ne180100]((uint64_t *)this + 74, 0);
  v5 = (void *)*((_QWORD *)this + 71);
  if (v5)
  {
    *((_QWORD *)this + 72) = v5;
    operator delete(v5);
  }
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUSpeechEnhancer::Initialize(AUSpeechEnhancer *this)
{
  uint64_t Element;
  int v3;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v9;
  int v10;
  uint64_t result;
  BOOL v13;
  int v14;
  double v15;
  int v16;
  float v17;
  float v18;
  unint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  float *v25;
  unint64_t *v26;
  float v27;
  float v28;
  void **v29;
  char *v30;
  uint64_t v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  unint64_t v38;
  vDSP_Length v39;
  float *i;
  float *v41;
  float v42;
  float *v43;
  unint64_t v44;
  float *v45;
  float *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  float *v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  _OWORD *v58;
  _OWORD *v59;
  float *v60;
  float *v61;
  uint64_t v62;
  uint64_t v63;
  float v64;
  long double v65;
  unint64_t v66;
  NoiseSuppression::Noise::HendriksSPP **v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  VPTimeFreqConverter *v76;
  VPTimeFreqConverter *v77;
  unint64_t v78;
  char **v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  long double v83;
  float v84;
  float v85;
  float v86;
  unint64_t v87;
  NoiseSuppression::Noise::HendriksSPP *v88;
  NoiseSuppression::Noise::HendriksSPP *v89;
  float v90;
  float v91;
  char *v92;
  __int128 v93;
  __int128 v94;
  uint64_t v95;
  unint64_t v96;
  void **v97;
  uint64_t v98;
  unint64_t v99;
  _OWORD *v100;
  _OWORD *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  char *v110;
  char *v111;
  uint64_t *v112;
  __int128 v113;
  unint64_t *v114;
  __int128 v115;
  float __A;
  __int128 v117;
  uint64_t v118;
  float v119;
  float __B[3];

  Element = ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 80), 0);
  v3 = *(_DWORD *)(Element + 88);
  if (v3 != 1819304813 && v3 != 1718773105)
    return 4294956428;
  v5 = Element;
  *((_DWORD *)this + 133) = *(_DWORD *)(Element + 108);
  v6 = ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 128), 0);
  v7 = *(_DWORD *)(v6 + 88);
  if (v7 != 1819304813 && v7 != 1718773105)
    return 4294956428;
  v9 = v6;
  v10 = *(_DWORD *)(v6 + 108);
  *((_DWORD *)this + 134) = v10;
  result = 4294956428;
  if ((v3 == 1718773105) == (v7 == 1718773105)
    && (v3 == 1819304813) == (v7 == 1819304813)
    && *((_DWORD *)this + 133) == v10
    && *(double *)(v5 + 80) == *(double *)(v9 + 80))
  {
    v13 = v3 == 1718773105 && v7 == 1718773105;
    *((_BYTE *)this + 545) = v13;
    *((_DWORD *)this + 132) = (unint64_t)(*(double *)(ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 128), 0)+ 80)+ 0.5);
    v14 = *((_DWORD *)this + 84);
    *((_DWORD *)this + 135) = v14;
    v15 = *((double *)this + 69);
    if (v15 > 0.0)
    {
      v16 = *((_DWORD *)this + 140);
      if (v16)
      {
        v17 = v15;
        v18 = v17 * 0.5;
        v19 = (v16 + 1);
        std::vector<float>::vector(&v117, v19);
        __A = 0.0;
        __B[0] = v18 / (float)(v19 - 1);
        vDSP_vramp(&__A, __B, (float *)v117, 1, v19);
        v20 = (void *)*((_QWORD *)this + 71);
        if (v20)
        {
          *((_QWORD *)this + 72) = v20;
          operator delete(v20);
        }
        *(_OWORD *)((char *)this + 568) = v117;
        *((_QWORD *)this + 73) = v118;
        v14 = *((_DWORD *)this + 135);
      }
    }
    if (v14)
    {
      v21 = operator new();
      v22 = *((unsigned int *)this + 133);
      v23 = *((unsigned int *)this + 135);
      v24 = (float)*((unsigned int *)this + 132);
      *(float *)(v21 + 88) = (float)(v24 * 0.5) + -200.0;
      *(_OWORD *)(v21 + 112) = xmmword_1B6629CB0;
      *(_OWORD *)(v21 + 128) = xmmword_1B6629CC0;
      *(_OWORD *)(v21 + 180) = xmmword_1B66A0650;
      *(_OWORD *)(v21 + 196) = xmmword_1B66A0660;
      *(_OWORD *)(v21 + 212) = xmmword_1B66A0670;
      *(_OWORD *)(v21 + 232) = xmmword_1B66A0680;
      *(_OWORD *)(v21 + 280) = xmmword_1B66305E0;
      *(_OWORD *)(v21 + 296) = unk_1B66305F0;
      *(_OWORD *)(v21 + 264) = unk_1B66305D0;
      *(_OWORD *)v21 = 0u;
      *(_OWORD *)(v21 + 16) = 0u;
      *(_OWORD *)(v21 + 32) = 0u;
      *(_OWORD *)(v21 + 48) = 0u;
      *(_OWORD *)(v21 + 64) = 0u;
      *(_QWORD *)(v21 + 80) = 0;
      *(_QWORD *)(v21 + 100) = 0;
      *(_QWORD *)(v21 + 92) = 0;
      *(float *)(v21 + 108) = v24;
      *(_OWORD *)(v21 + 144) = 0u;
      *(_OWORD *)(v21 + 160) = 0u;
      *(_DWORD *)(v21 + 176) = 0;
      *(_OWORD *)(v21 + 248) = xmmword_1B66305C0;
      *(_QWORD *)(v21 + 312) = v23;
      *(_QWORD *)(v21 + 320) = 2 * v23;
      *(_QWORD *)(v21 + 328) = v23 + 1;
      *(_QWORD *)(v21 + 336) = v22;
      *(_QWORD *)(v21 + 344) = 0;
      *(_DWORD *)(v21 + 352) = 16843009;
      *(_QWORD *)(v21 + 616) = 0;
      *(_OWORD *)(v21 + 584) = 0u;
      *(_OWORD *)(v21 + 600) = 0u;
      *(_OWORD *)(v21 + 552) = 0u;
      *(_OWORD *)(v21 + 568) = 0u;
      *(_OWORD *)(v21 + 520) = 0u;
      *(_OWORD *)(v21 + 536) = 0u;
      *(_OWORD *)(v21 + 488) = 0u;
      *(_OWORD *)(v21 + 504) = 0u;
      *(_OWORD *)(v21 + 456) = 0u;
      *(_OWORD *)(v21 + 472) = 0u;
      *(_OWORD *)(v21 + 424) = 0u;
      *(_OWORD *)(v21 + 440) = 0u;
      *(_OWORD *)(v21 + 392) = 0u;
      *(_OWORD *)(v21 + 408) = 0u;
      *(_OWORD *)(v21 + 360) = 0u;
      *(_OWORD *)(v21 + 376) = 0u;
      v25 = (float *)*std::vector<float>::vector((_QWORD *)(v21 + 624), v23 + 1);
      LODWORD(v117) = 0;
      __A = (float)(v24 * 0.5) / (float)v23;
      vDSP_vramp((const float *)&v117, &__A, v25, 1, v23 + 1);
      v26 = (unint64_t *)(v21 + 1192);
      bzero((void *)(v21 + 648), 0x220uLL);
      v27 = *(float *)(v21 + 180);
      v28 = *(float *)(v21 + 88);
      *(_OWORD *)(v21 + 1192) = 0u;
      *(_QWORD *)(v21 + 1208) = 2;
      v29 = (void **)(v21 + 1224);
      *(_OWORD *)(v21 + 1216) = 0u;
      *(_OWORD *)(v21 + 1232) = 0u;
      *(_OWORD *)(v21 + 1248) = 0u;
      *(_OWORD *)(v21 + 1264) = 0u;
      *(_OWORD *)(v21 + 1280) = 0u;
      *(_OWORD *)(v21 + 1296) = 0u;
      *(_OWORD *)(v21 + 1312) = 0u;
      *(_OWORD *)(v21 + 1328) = 0u;
      *(_OWORD *)(v21 + 1344) = 0u;
      *(_OWORD *)(v21 + 1356) = 0u;
      *(_QWORD *)(v21 + 1380) = 0x3F82613100000004;
      v30 = *(char **)(v21 + 624);
      v31 = *(_QWORD *)(v21 + 632);
      *(_QWORD *)(v21 + 1372) = 0x3DDD2F1B43020000;
      v112 = (uint64_t *)(v21 + 1272);
      std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(v21 + 1272), v30, v31, (v31 - (uint64_t)v30) >> 2);
      if (*(_QWORD *)(v21 + 1280) - *(_QWORD *)(v21 + 1272) <= 7uLL)
        __assert_rtn("SpeechEnhancerFilterBank", "SpeechEnhancerFilterBank.h", 44, "mDFTfrequencies.size() > 1");
      *(float *)(v21 + 1200) = v27;
      if (v28 >= v27)
        v32 = v28;
      else
        v32 = v27;
      *(float *)(v21 + 1204) = v32;
      v33 = *(float *)(v21 + 1376);
      v34 = 1.0 / (float)(v33 * 0.43429);
      v35 = v33 / *(float *)(v21 + 1372);
      v36 = v34 * log10f((float)(v35 * v27) + 1.0);
      v37 = (float)(v34 * log10f((float)(v35 * v32) + 1.0)) - v36;
      v38 = vcvtas_u32_f32(v37);
      *(_QWORD *)(v21 + 1192) = v38;
      std::vector<float>::vector(&v117, v38);
      v39 = *v26;
      v119 = v37 / (float)(*v26 - 1);
      __B[0] = v36;
      vDSP_vramp(__B, &v119, (float *)v117, 1, v39);
      std::vector<float>::reserve((void **)(v21 + 1224), *v26);
      v114 = (unint64_t *)(v21 + 1192);
      v41 = (float *)*((_QWORD *)&v117 + 1);
      for (i = (float *)v117; i != v41; ++i)
      {
        v42 = (__exp10((float)(*i / v34)) + -1.0) / (float)(*(float *)(v21 + 1376) / *(float *)(v21 + 1372));
        v43 = *(float **)(v21 + 1232);
        v44 = *(_QWORD *)(v21 + 1240);
        if ((unint64_t)v43 >= v44)
        {
          v46 = (float *)*v29;
          v47 = ((char *)v43 - (_BYTE *)*v29) >> 2;
          v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 62)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          v49 = v44 - (_QWORD)v46;
          if (v49 >> 1 > v48)
            v48 = v49 >> 1;
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL)
            v50 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v50 = v48;
          if (v50)
          {
            v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v21 + 1240, v50);
            v43 = *(float **)(v21 + 1232);
            v46 = *(float **)(v21 + 1224);
          }
          else
          {
            v51 = 0;
          }
          v52 = (float *)&v51[4 * v47];
          *v52 = v42;
          v45 = v52 + 1;
          while (v43 != v46)
          {
            v53 = *((_DWORD *)v43-- - 1);
            *((_DWORD *)v52-- - 1) = v53;
          }
          *(_QWORD *)(v21 + 1224) = v52;
          *(_QWORD *)(v21 + 1232) = v45;
          *(_QWORD *)(v21 + 1240) = &v51[4 * v50];
          if (v46)
            operator delete(v46);
        }
        else
        {
          *v43 = v42;
          v45 = v43 + 1;
        }
        *(_QWORD *)(v21 + 1232) = v45;
      }
      v54 = ((uint64_t)(*(_QWORD *)(v21 + 1280) - *(_QWORD *)(v21 + 1272)) >> 2) * *(_QWORD *)(v21 + 1192);
      __A = 0.0;
      std::vector<float>::resize(v21 + 1344, v54, &__A);
      v55 = *v114;
      __A = 0.0;
      std::vector<float>::resize(v21 + 1248, v55, &__A);
      v56 = *v114;
      __A = 0.0;
      std::vector<float>::resize(v21 + 1296, v56, &__A);
      v57 = (uint64_t)(*(_QWORD *)(v21 + 1280) - *(_QWORD *)(v21 + 1272)) >> 2;
      __A = 0.0;
      std::vector<float>::resize(v21 + 1320, v57, &__A);
      v58 = operator new(0x58uLL);
      v58[2] = xmmword_1B6630620;
      v58[3] = unk_1B6630630;
      v58[4] = xmmword_1B6630640;
      *((_QWORD *)v58 + 10) = 0x460660004604D000;
      *v58 = xmmword_1B6630600;
      v58[1] = unk_1B6630610;
      v59 = operator new(0x58uLL);
      v59[2] = xmmword_1B6630678;
      v59[3] = unk_1B6630688;
      v59[4] = xmmword_1B6630698;
      *((_QWORD *)v59 + 10) = 0x44E1000044E10000;
      *v59 = xmmword_1B6630658;
      v59[1] = unk_1B6630668;
      v60 = (float *)operator new(0x58uLL);
      v61 = v60;
      v62 = 0;
      *((_QWORD *)v60 + 10) = 0x3BA3D70A3C343958;
      *(_OWORD *)v60 = xmmword_1B66306B0;
      *((_OWORD *)v60 + 1) = unk_1B66306C0;
      *((_OWORD *)v60 + 3) = unk_1B66306E0;
      *((_OWORD *)v60 + 4) = xmmword_1B66306F0;
      *((_OWORD *)v60 + 2) = xmmword_1B66306D0;
      v63 = *v112;
      v64 = *(float *)(*v112 + 4) - *(float *)*v112;
      do
      {
        v60[v62] = (float)(v64 * v60[v62]) / *(float *)((char *)v59 + v62 * 4);
        ++v62;
      }
      while (v62 != 22);
      SpeechEnhancerFilterBank<float>::interp1((float *)v58, 22, v60, v63, (*(_QWORD *)(v21 + 1280) - v63) >> 2, *(_QWORD *)(v21 + 1320), *v60, v60[21]);
      operator delete(v61);
      operator delete(v59);
      operator delete(v58);
      SpeechEnhancerFilterBank<float>::createFilterBank((uint64_t)v114, 1, v65);
      if ((_QWORD)v117)
      {
        *((_QWORD *)&v117 + 1) = v117;
        operator delete((void *)v117);
      }
      *(_DWORD *)(v21 + 1392) = 1101004800;
      *(_DWORD *)(v21 + 1440) = 0;
      *(_OWORD *)(v21 + 1396) = 0u;
      *(_OWORD *)(v21 + 1412) = 0u;
      *(_OWORD *)(v21 + 1422) = 0u;
      v66 = *(_QWORD *)(v21 + 328);
      *(_DWORD *)(v21 + 1448) = 0;
      AWeight<float>::Generate((_QWORD *)(v21 + 1456), v66, v24);
      v67 = (NoiseSuppression::Noise::HendriksSPP **)(v21 + 1480);
      *(_QWORD *)(v21 + 1528) = 0;
      *(_OWORD *)(v21 + 1496) = 0u;
      *(_OWORD *)(v21 + 1512) = 0u;
      *(_OWORD *)(v21 + 1480) = 0u;
      v68 = *(_QWORD *)(v21 + 336);
      std::vector<std::unique_ptr<VPTimeFreqConverter>>::resize((__int128 *)(v21 + 1488), v68);
      std::vector<std::unique_ptr<VPTimeFreqConverter>>::resize((__int128 *)(v21 + 1512), v68);
      std::vector<std::vector<float>>::resize((uint64_t *)(v21 + 1080), v68);
      std::vector<std::vector<float>>::resize((uint64_t *)(v21 + 1104), v68);
      v69 = *(_QWORD *)(v21 + 320);
      __B[0] = 0.0;
      std::vector<float>::assign((char **)(v21 + 360), v69, __B);
      v70 = *(_QWORD *)(v21 + 320);
      __B[0] = 0.0;
      std::vector<float>::assign((char **)(v21 + 1032), v70, __B);
      __B[0] = 0.0;
      std::vector<float>::assign((char **)(v21 + 1056), v70, __B);
      v71 = *(_QWORD *)(v21 + 328);
      __B[0] = 2.2204e-16;
      std::vector<float>::assign((char **)(v21 + 648), v71, __B);
      __B[0] = 2.2204e-16;
      std::vector<float>::assign((char **)(v21 + 936), v71, __B);
      __B[0] = 2.2204e-16;
      std::vector<float>::assign((char **)(v21 + 984), v71, __B);
      __B[0] = 2.2204e-16;
      std::vector<float>::assign((char **)(v21 + 1008), v71, __B);
      __B[0] = 2.2204e-16;
      std::vector<float>::assign((char **)(v21 + 672), v71, __B);
      __B[0] = 2.2204e-16;
      std::vector<float>::assign((char **)(v21 + 912), v71, __B);
      __B[0] = 2.2204e-16;
      std::vector<float>::assign((char **)(v21 + 960), v71, __B);
      v72 = *(_QWORD *)(v21 + 328);
      __B[0] = 1.0;
      std::vector<float>::assign((char **)(v21 + 888), v72, __B);
      __B[0] = 1.0;
      std::vector<float>::assign((char **)(v21 + 600), v72, __B);
      if (*(_QWORD *)(v21 + 336))
      {
        v73 = 0;
        v74 = 0;
        v75 = 0;
        do
        {
          v76 = (VPTimeFreqConverter *)operator new();
          VPTimeFreqConverter::VPTimeFreqConverter(v76, 0, *(_DWORD *)(v21 + 312));
          std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100]((VPTimeFreqConverter **)(*(_QWORD *)(v21 + 1488) + v73), v76);
          v77 = (VPTimeFreqConverter *)operator new();
          VPTimeFreqConverter::VPTimeFreqConverter(v77, 1, *(_DWORD *)(v21 + 312));
          std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100]((VPTimeFreqConverter **)(*(_QWORD *)(v21 + 1512) + v73), v77);
          v78 = *(_QWORD *)(v21 + 320);
          v79 = (char **)(*(_QWORD *)(v21 + 1080) + v74);
          v80 = *(_QWORD *)(v21 + 1104);
          __B[0] = 0.0;
          std::vector<float>::assign(v79, v78, __B);
          __B[0] = 0.0;
          std::vector<float>::assign((char **)(v80 + v74), v78, __B);
          ++v75;
          v74 += 24;
          v73 += 8;
        }
        while (*(_QWORD *)(v21 + 336) > v75);
      }
      v81 = *(_QWORD *)(v21 + 1192);
      *(_QWORD *)(v21 + 40) = v81;
      std::vector<float>::resize(v21 + 384, v81);
      std::vector<float>::resize(v21 + 408, v81);
      std::vector<float>::resize(v21 + 432, v81);
      std::vector<float>::resize(v21 + 456, v81);
      std::vector<float>::resize(v21 + 480, v81);
      std::vector<float>::resize(v21 + 504, v81);
      std::vector<float>::resize(v21 + 528, v81);
      std::vector<float>::resize(v21 + 552, v81);
      std::vector<float>::resize(v21 + 576, v81);
      v82 = *(_QWORD *)(v21 + 40);
      std::vector<float>::resize(v21 + 696, v82);
      std::vector<float>::resize(v21 + 720, v82);
      std::vector<float>::resize(v21 + 744, v82);
      std::vector<float>::resize(v21 + 768, v82);
      std::vector<float>::resize(v21 + 792, v82);
      std::vector<float>::resize(v21 + 816, v82);
      std::vector<float>::resize(v21 + 840, v82);
      std::vector<float>::resize(v21 + 864, v82);
      v83 = exp(*(float *)(v21 + 216) * 0.230258509);
      v84 = (float)*(unint64_t *)(v21 + 328);
      *(float *)&v83 = v83;
      *(float *)(v21 + 160) = *(float *)&v83 / v84;
      v85 = exp(*(float *)(v21 + 220) * 0.230258509);
      *(float *)(v21 + 164) = v85 / v84;
      v86 = *(float *)(v21 + 108);
      v87 = *(_QWORD *)(v21 + 312);
      v88 = (NoiseSuppression::Noise::HendriksSPP *)operator new();
      NoiseSuppression::Noise::HendriksSPP::HendriksSPP(v88, *(float *)(v21 + 108), *(_DWORD *)(v21 + 328), v86 / (float)v87);
      v89 = *v67;
      *v67 = v88;
      if (v89)
      {
        (*(void (**)(NoiseSuppression::Noise::HendriksSPP *))(*(_QWORD *)v89 + 8))(v89);
        v88 = *v67;
      }
      (*(void (**)(NoiseSuppression::Noise::HendriksSPP *))(*(_QWORD *)v88 + 16))(v88);
      SpeechEnhancerCore<float>::getAverageSpeechSpectrum(*(float **)(v21 + 624), *(_QWORD *)(v21 + 328), *(_QWORD *)(v21 + 960));
      v90 = *(float *)(v21 + 188);
      v91 = *(float *)(v21 + 192);
      *(float *)(v21 + 132) = v90;
      __B[0] = (float)(v90 / 10000000.0) / v91;
      vDSP_vsmul(*(const float **)(v21 + 960), 1, __B, *(float **)(v21 + 912), 1, *(_QWORD *)(v21 + 328));
      v92 = (char *)this + 592;
      std::unique_ptr<SpeechEnhancerCore<float>>::reset[abi:ne180100]((uint64_t *)this + 74, v21);
      v95 = *((_QWORD *)this + 82);
      if (*((_QWORD *)this + 83) != v95)
      {
        v96 = 0;
        do
        {
          v97 = *(void ***)v92;
          v98 = v95 + 32 * v96;
          *(_QWORD *)&v93 = *(_QWORD *)(v98 + 16);
          LODWORD(v94) = *(_DWORD *)(v98 + 24);
          v100 = *(_OWORD **)(*(_QWORD *)v92 + 8);
          v99 = *(_QWORD *)(*(_QWORD *)v92 + 16);
          if ((unint64_t)v100 >= v99)
          {
            v102 = ((char *)v100 - (_BYTE *)*v97) >> 4;
            if ((unint64_t)(v102 + 1) >> 60)
              std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
            v103 = v99 - (_QWORD)*v97;
            v104 = v103 >> 3;
            if (v103 >> 3 <= (unint64_t)(v102 + 1))
              v104 = v102 + 1;
            if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF0)
              v105 = 0xFFFFFFFFFFFFFFFLL;
            else
              v105 = v104;
            if (v105)
            {
              v113 = v94;
              v115 = v93;
              if (v105 >> 60)
                std::__throw_bad_array_new_length[abi:ne180100]();
              v106 = (char *)operator new(16 * v105);
              v94 = v113;
              v93 = v115;
            }
            else
            {
              v106 = 0;
            }
            v107 = &v106[16 * v102];
            *(_QWORD *)v107 = v93;
            *((_DWORD *)v107 + 2) = v94;
            *((_DWORD *)v107 + 3) = v94;
            v109 = (char *)*v97;
            v108 = (char *)v97[1];
            v110 = v107;
            if (v108 != *v97)
            {
              do
              {
                v93 = *((_OWORD *)v108 - 1);
                *((_OWORD *)v110 - 1) = v93;
                v110 -= 16;
                v108 -= 16;
              }
              while (v108 != v109);
              v108 = (char *)*v97;
            }
            v111 = &v106[16 * v105];
            v101 = v107 + 16;
            *v97 = v110;
            v97[1] = v107 + 16;
            v97[2] = v111;
            if (v108)
              operator delete(v108);
          }
          else
          {
            DWORD2(v93) = v94;
            HIDWORD(v93) = v94;
            *v100 = v93;
            v101 = v100 + 1;
          }
          v97[1] = v101;
          ++v96;
          v95 = *((_QWORD *)this + 82);
        }
        while (v96 < (*((_QWORD *)this + 83) - v95) >> 5);
      }
      AUSpeechEnhancer::syncParametersWithCore(this);
      std::vector<std::span<float,18446744073709551615ul>>::resize((char **)this + 75, *((unsigned int *)this + 133));
      std::vector<std::span<float,18446744073709551615ul>>::resize((char **)this + 78, *((unsigned int *)this + 134));
    }
    return 0;
  }
  return result;
}

void sub_1B61393A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  uint64_t v41;
  void *v43;

  v43 = *(void **)(v41 - 176);
  if (v43)
  {
    *(_QWORD *)(v41 - 168) = v43;
    operator delete(v43);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AUSpeechEnhancer::Reset(AUSpeechEnhancer *this)
{
  uint64_t v1;
  unint64_t v2;
  float v3;
  float v4;
  float v5;
  NoiseSuppression::Noise::HendriksSPP *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  VPTimeFreqConverter *v10;
  VPTimeFreqConverter *v11;
  float __A;
  int v14;
  float __B;

  if (*((_BYTE *)this + 17))
  {
    v1 = *((_QWORD *)this + 74);
    if (v1)
    {
      v2 = *(_QWORD *)(v1 + 328);
      v14 = 629145600;
      std::vector<float>::assign((char **)(v1 + 936), v2, &v14);
      *(_BYTE *)(v1 + 1436) = 0;
      *(_DWORD *)(v1 + 1420) = 0;
      SpeechEnhancerCore<float>::getAverageSpeechSpectrum(*(float **)(v1 + 624), *(_QWORD *)(v1 + 328), *(_QWORD *)(v1 + 960));
      v3 = *(float *)(v1 + 188);
      v4 = *(float *)(v1 + 192);
      *(float *)(v1 + 132) = v3;
      __B = (float)(v3 / 10000000.0) / v4;
      vDSP_vsmul(*(const float **)(v1 + 960), 1, &__B, *(float **)(v1 + 912), 1, *(_QWORD *)(v1 + 328));
      *(_QWORD *)(v1 + 344) = 0;
      *(_QWORD *)(v1 + 48) = 0;
      *(_DWORD *)(v1 + 116) = 0;
      *(_WORD *)(v1 + 354) = 257;
      __A = 1.0;
      vDSP_vfill(&__A, *(float **)(v1 + 888), 1, *(_QWORD *)(v1 + 328));
      v5 = *(float *)(v1 + 108) / (float)*(unint64_t *)(v1 + 312);
      v6 = (NoiseSuppression::Noise::HendriksSPP *)operator new();
      NoiseSuppression::Noise::HendriksSPP::HendriksSPP(v6, *(float *)(v1 + 108), *(_DWORD *)(v1 + 328), v5);
      v7 = *(_QWORD *)(v1 + 1480);
      *(_QWORD *)(v1 + 1480) = v6;
      if (v7)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
        v6 = *(NoiseSuppression::Noise::HendriksSPP **)(v1 + 1480);
      }
      (*(void (**)(NoiseSuppression::Noise::HendriksSPP *))(*(_QWORD *)v6 + 16))(v6);
      if (*(_QWORD *)(v1 + 336))
      {
        v8 = 0;
        v9 = 0;
        do
        {
          v10 = (VPTimeFreqConverter *)operator new();
          VPTimeFreqConverter::VPTimeFreqConverter(v10, 0, *(_DWORD *)(v1 + 312));
          std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100]((VPTimeFreqConverter **)(*(_QWORD *)(v1 + 1488) + v8), v10);
          v11 = (VPTimeFreqConverter *)operator new();
          VPTimeFreqConverter::VPTimeFreqConverter(v11, 1, *(_DWORD *)(v1 + 312));
          std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100]((VPTimeFreqConverter **)(*(_QWORD *)(v1 + 1512) + v8), v11);
          ++v9;
          v8 += 8;
        }
        while (*(_QWORD *)(v1 + 336) > v9);
      }
    }
  }
  return 0;
}

void sub_1B61399C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x1091C4047E1822DLL);
  _Unwind_Resume(a1);
}

uint64_t AUSpeechEnhancer::GetPropertyInfo(AUSpeechEnhancer *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  int v8;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 1002)
  {
    if (a2 != 21)
    {
      if (a2 != 1001)
        return result;
      *a6 = 1;
      v8 = 4 * *((_DWORD *)this + 84) + 4;
LABEL_13:
      result = 0;
      *a5 = v8;
      return result;
    }
LABEL_11:
    *a6 = 1;
    v8 = 4;
    goto LABEL_13;
  }
  if (a2 == 1003)
  {
    *a6 = 1;
    v8 = 8;
    goto LABEL_13;
  }
  if (a2 == 1004 || a2 == 3700)
    goto LABEL_11;
  return result;
}

uint64_t AUSpeechEnhancer::GetProperty(AUSpeechEnhancer *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  unsigned __int8 *v6;

  if (a3)
    return 4294956417;
  if (a2 == 3700)
  {
    v6 = (unsigned __int8 *)this + 376;
  }
  else
  {
    if (a2 != 21)
      return 4294956417;
    v6 = (unsigned __int8 *)this + 544;
  }
  result = 0;
  *a5 = *v6;
  return result;
}

uint64_t AUSpeechEnhancer::SetProperty(AUSpeechEnhancer *this, int a2, int a3, unsigned int a4, unsigned int *__src, unsigned int a6)
{
  uint64_t result;
  unint64_t v8;
  uint64_t v9;
  double v10;
  float *v11;
  int v12;
  unsigned int *v14;

  if (a3)
    return 4294956417;
  switch(a2)
  {
    case 1001:
      if (!*((_BYTE *)this + 17))
        goto LABEL_29;
      if (!__src)
        goto LABEL_28;
      v8 = a6 >> 2;
      v9 = *((unsigned int *)this + 140);
      if ((_DWORD)v8 != (_DWORD)v9 + 1)
        goto LABEL_28;
      result = 4294956445;
      if ((_DWORD)v9)
      {
        v10 = *((double *)this + 69);
        if (v10 > 0.0)
        {
          v11 = (float *)*((_QWORD *)this + 71);
          if (!v11)
            goto LABEL_28;
          v12 = *((_DWORD *)this + 135);
          if (*((_DWORD *)this + 132) == v10 && v12 == (_DWORD)v9)
          {
            v14 = &__src[v9 + 1];
            if (v14 != __src)
              memmove(*(void **)(*((_QWORD *)this + 74) + 648), __src, (char *)v14 - (char *)__src);
          }
          else
          {
            SpeechEnhancerCore<float>::resampleSpectrum(v11, v8, (float *)__src, *(float **)(*((_QWORD *)this + 74) + 624), (v12 + 1), *(float **)(*((_QWORD *)this + 74) + 648));
          }
          goto LABEL_21;
        }
      }
      break;
    case 1002:
      if (*((_BYTE *)this + 17))
      {
        if (!__src)
          goto LABEL_28;
        SpeechEnhancerCore<float>::setParameterLight(**((_QWORD **)this + 74), *(_QWORD *)(*((_QWORD *)this + 74) + 8), 1uLL, (float)*__src);
LABEL_21:
        result = 0;
      }
      else
      {
LABEL_29:
        result = 4294956429;
      }
      break;
    case 1003:
      if (!__src)
        goto LABEL_28;
      if (*((_BYTE *)this + 17))
        goto LABEL_27;
      result = 0;
      *((_QWORD *)this + 69) = *(_QWORD *)__src;
      break;
    case 1004:
      if (__src)
      {
        if (*((_BYTE *)this + 17))
        {
LABEL_27:
          result = 4294956431;
        }
        else
        {
          result = 0;
          *((_DWORD *)this + 140) = *__src;
        }
      }
      else
      {
LABEL_28:
        result = 4294956445;
      }
      break;
    default:
      if (a2 != 21)
        return 4294956417;
      result = 0;
      *((_BYTE *)this + 544) = *__src != 0;
      break;
  }
  return result;
}

uint64_t AUSpeechEnhancer::SetParameter(AUSpeechEnhancer *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  uint64_t v5;
  uint64_t *v12;
  uint64_t v13;
  float v14;
  uint64_t *v15;
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;

  v5 = *((_QWORD *)this + 82);
  if (a2 > (unint64_t)((*((_QWORD *)this + 83) - v5) >> 5))
    return 4294956418;
  if ((*(_BYTE *)(v5 + 32 * a2 + 13) & 0x80) != 0)
  {
    if (a2 == 52)
    {
      v15 = (uint64_t *)*((_QWORD *)this + 74);
      if (v15)
        SpeechEnhancerCore<float>::setParameterLight(*v15, v15[1], 0x34uLL, a5);
    }
    else if (a2 == 26)
    {
      v12 = (uint64_t *)*((_QWORD *)this + 74);
      if (v12)
      {
        SpeechEnhancerCore<float>::setParameterLight(*v12, v12[1], 0x1AuLL, a5);
        v13 = *((_QWORD *)this + 74);
        if (*(_QWORD *)(v13 + 8) - *(_QWORD *)v13 <= 0x1A0uLL)
          __assert_rtn("parameterValue", "SpeechEnhancerCore.h", 278, "index >= 0 && index < mParameterInfoTable.size()");
        v14 = exp(*(float *)(*(_QWORD *)v13 + 428) * 0.230258509);
        *(float *)(v13 + 140) = v14;
      }
    }
  }
  else
  {
    ++*((_DWORD *)this + 162);
  }
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  return 0;
}

uint64_t AUSpeechEnhancer::CanScheduleParameters(AUSpeechEnhancer *this)
{
  return 0;
}

uint64_t AUSpeechEnhancer::ProcessMultipleBufferLists(AUSpeechEnhancer *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const void *v14;
  void *v15;
  uint64_t v17;
  int v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  void **v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  void **v27;
  int updated;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int i;

  if (!a3)
    return 4294956428;
  if (*((_DWORD *)this + 135) != a3)
    return 4294956422;
  v10 = (a3 << *((_BYTE *)this + 545));
  if (*((_BYTE *)this + 544))
  {
    v11 = *((unsigned int *)this + 133);
    if ((_DWORD)v11)
    {
      v12 = 0;
      v13 = 16;
      do
      {
        v14 = *(const void **)((char *)&(*a5)->mNumberBuffers + v13);
        v15 = *(void **)((char *)&(*a7)->mNumberBuffers + v13);
        if (v14 != v15 && (_DWORD)v10 != 0)
        {
          memmove(v15, v14, 4 * v10);
          v11 = *((unsigned int *)this + 133);
        }
        ++v12;
        v13 += 16;
      }
      while (v12 < v11);
    }
    return 0;
  }
  else
  {
    v19 = *((_DWORD *)this + 162);
    if (v19 != *((_DWORD *)this + 163))
    {
      *((_DWORD *)this + 163) = v19;
      AUSpeechEnhancer::syncParametersWithCore(this);
    }
    v20 = *((unsigned int *)this + 133);
    if ((_DWORD)v20)
    {
      v21 = 0;
      v22 = 16 * v20;
      do
      {
        v23 = (void **)(*((_QWORD *)this + 75) + v21);
        *v23 = (*a5)->mBuffers[v21 / 0x10].mData;
        v23[1] = (void *)v10;
        v21 += 16;
      }
      while (v22 != v21);
    }
    v24 = *((unsigned int *)this + 134);
    if ((_DWORD)v24)
    {
      v25 = 0;
      v26 = 16 * v24;
      do
      {
        v27 = (void **)(*((_QWORD *)this + 78) + v25);
        *v27 = (*a7)->mBuffers[v25 / 0x10].mData;
        v27[1] = (void *)v10;
        v25 += 16;
      }
      while (v26 != v25);
    }
    SpeechEnhancerCore<float>::process(*((_QWORD **)this + 74), (float ***)this + 75, (uint64_t **)this + 78, *((unsigned int *)this + 135), *((unsigned __int8 *)this + 545));
    updated = AUSpeechEnhancer::updateMeterDisplay(this, 1u);
    v29 = AUSpeechEnhancer::updateMeterDisplay(this, 0x20u);
    v30 = AUSpeechEnhancer::updateMeterDisplay(this, 0x16u);
    v31 = AUSpeechEnhancer::updateMeterDisplay(this, 9u);
    v32 = AUSpeechEnhancer::updateMeterDisplay(this, 0xFu);
    v33 = AUSpeechEnhancer::updateMeterDisplay(this, 0x10u);
    v34 = AUSpeechEnhancer::updateMeterDisplay(this, 0x1Au);
    v35 = AUSpeechEnhancer::updateMeterDisplay(this, 0x1Bu);
    v36 = AUSpeechEnhancer::updateMeterDisplay(this, 0x17u);
    v37 = **((_QWORD **)this + 74);
    if ((unint64_t)(*(_QWORD *)(*((_QWORD *)this + 74) + 8) - v37) <= 0x190)
      __assert_rtn("getParameter", "SpeechEnhancerCore.h", 266, "index >= 0 && index < mParameterInfoTable.size()");
    v17 = v29 | updated | v30 | v31 | v32 | v33 | v34 | v35 | v36;
    if (*(float *)(v37 + 412) > 0.5)
    {
      for (i = 33; i != 49; ++i)
        v17 = AUSpeechEnhancer::updateMeterDisplay(this, i) | v17;
    }
  }
  return v17;
}

uint64_t AUSpeechEnhancer::Render(AUSpeechEnhancer *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  ausdk::AUInputElement *Element;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t BufferList;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v8 = (AUSpeechEnhancer *)((char *)this + 80);
  Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 80), 0);
  result = ausdk::AUInputElement::PullInput(Element, &v13, a3, 0, a4);
  if (!(_DWORD)result)
  {
    v11 = ausdk::AUScope::SafeGetElement(v8, 0);
    v15[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v11 + 144));
    v12 = ausdk::AUScope::SafeGetElement((AUSpeechEnhancer *)((char *)this + 128), 0);
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v12 + 144));
    return (*(uint64_t (**)(AUSpeechEnhancer *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, uint64_t *))(*(_QWORD *)this + 184))(this, a2, a4, 1, v15, 1, &BufferList);
  }
  return result;
}

uint64_t AUSpeechEnhancer::GetParameterList(AUSpeechEnhancer *this, int a2, unsigned int *a3, unsigned int *a4)
{
  if (a2)
  {
    *a4 = 0;
    return 4294956430;
  }
  else
  {
    if (a3)
    {
      *((_QWORD *)a3 + 18) = 0x1B0000001ALL;
      *((_OWORD *)a3 + 6) = xmmword_1B66304BC;
      *((_OWORD *)a3 + 7) = unk_1B66304CC;
      *((_OWORD *)a3 + 8) = xmmword_1B66304DC;
      *((_OWORD *)a3 + 2) = xmmword_1B663047C;
      *((_OWORD *)a3 + 3) = unk_1B663048C;
      *((_OWORD *)a3 + 4) = xmmword_1B663049C;
      *((_OWORD *)a3 + 5) = unk_1B66304AC;
      *(_OWORD *)a3 = xmmword_1B663045C;
      *((_OWORD *)a3 + 1) = unk_1B663046C;
      *(_OWORD *)(a3 + 38) = xmmword_1B66A0690;
      *(_OWORD *)(a3 + 42) = xmmword_1B66A06A0;
      *(_OWORD *)(a3 + 46) = xmmword_1B66A06B0;
      *(_OWORD *)(a3 + 50) = xmmword_1B66A06C0;
    }
    *a4 = 54;
    if (*((_QWORD *)this + 83) - *((_QWORD *)this + 82) != 1728)
      __assert_rtn("GetParameterList", "AUSpeechEnhancer.cpp", 311, "outNumParameters == mParameterInfoTable.size()");
    return 0;
  }
}

uint64_t AUSpeechEnhancer::GetParameterInfo(AUSpeechEnhancer *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  signed int v9;
  const __CFString *v10;

  if (a2)
    return 4294956418;
  v5 = *((_QWORD *)this + 82);
  if (a3 >= (unint64_t)((*((_QWORD *)this + 83) - v5) >> 5))
    return 4294956418;
  v6 = v5 + 32 * a3;
  v7 = *(_DWORD *)(v6 + 12);
  buffer->unit = *(_DWORD *)(v6 + 8);
  buffer->minValue = *(AudioUnitParameterValue *)(v6 + 16);
  buffer->maxValue = *(AudioUnitParameterValue *)(v6 + 20);
  buffer->defaultValue = *(AudioUnitParameterValue *)(v6 + 24);
  v8 = v7 + 1098907648;
  buffer->flags = v7 + 1098907648;
  v9 = *(_DWORD *)(v6 + 28);
  if (v9 >= 1)
  {
    buffer->clumpID = v9;
    v8 |= 0x100000u;
  }
  v10 = *(const __CFString **)v6;
  buffer->cfNameString = *(CFStringRef *)v6;
  buffer->flags = v8 | 0x8000000;
  CFStringGetCString(v10, buffer->name, 52, 0x8000100u);
  return 0;
}

uint64_t AUSpeechEnhancer::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
  {
    if (*((_BYTE *)this + 17))
      ++*((_DWORD *)this + 162);
  }
  return result;
}

uint64_t AUSpeechEnhancer::GetParameterValueStrings(AUSpeechEnhancer *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  __int128 *v6;
  const __CFArray *v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a2)
    return 4294956418;
  if (!a4)
    return 0;
  if (a3 == 4)
  {
    v6 = &xmmword_1E69C8120;
    goto LABEL_10;
  }
  if (a3 == 3)
  {
    v6 = &xmmword_1E69C8110;
LABEL_10:
    v8 = *v6;
    v7 = CFArrayCreate(0, (const void **)&v8, 2, 0);
    result = 0;
    *a4 = v7;
    return result;
  }
  return 4294956418;
}

uint64_t AUSpeechEnhancer::GetLatency(uint64_t this)
{
  if (!*(_BYTE *)(this + 545))
    return ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(this + 128), 0);
  return this;
}

double AUSpeechEnhancer::GetTailTime(AUSpeechEnhancer *this)
{
  return 0.0;
}

uint64_t AUSpeechEnhancer::SupportsTail(AUSpeechEnhancer *this)
{
  return 1;
}

BOOL AUSpeechEnhancer::StreamFormatWritable(AUSpeechEnhancer *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUSpeechEnhancer::SupportedNumChannels(AUSpeechEnhancer *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUSpeechEnhancer::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  return 1;
}

uint64_t AUSpeechEnhancer::ValidFormat(AUSpeechEnhancer *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  uint64_t result;
  __int128 v6;
  _OWORD v7[2];
  uint64_t v8;
  int v9;

  result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if ((_DWORD)result)
  {
    if ((a4->mFormatFlags & 0x20) != 0)
      return 1;
    result = a4->mChannelsPerFrame == 1;
  }
  if ((result & 1) == 0 && a4->mFormatID == 1718773105)
  {
    v6 = *(_OWORD *)&a4->mBytesPerPacket;
    v7[0] = *(_OWORD *)&a4->mSampleRate;
    v7[1] = v6;
    v8 = *(_QWORD *)&a4->mBitsPerChannel;
    DWORD2(v7[0]) = 1819304813;
    v9 = 0;
    LODWORD(result) = CAStreamBasicDescription::IdentifyCommonPCMFormat(v7, &v9, 0);
    if (v9 == 4)
      return result;
    else
      return 0;
  }
  return result;
}

uint64_t CAStreamBasicDescription::IdentifyCommonPCMFormat(_DWORD *a1, int *a2, BOOL *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  int v9;
  BOOL v10;

  if (a1[2] != 1819304813)
    return 0;
  if (a1[5] != 1)
    return 0;
  v3 = a1[6];
  if (v3 != a1[4])
    return 0;
  v4 = a1[8];
  if (v3 < v4 >> 3)
    return 0;
  v5 = a1[7];
  if (!v5)
    return 0;
  v6 = a1[3];
  if ((v6 & 0x20) == 0)
  {
    v10 = v3 == v3 / v5 * v5;
    v3 /= v5;
    if (!v10)
      return 0;
  }
  v7 = 0;
  if ((v6 & 2) == 0 && 8 * v3 == v4)
  {
    if ((v6 & 1) != 0)
    {
      if ((v6 & 0x1F84) != 0)
        return 0;
      v7 = 4 * (v3 == 8);
      if (v3 == 4)
        v7 = 1;
    }
    else if ((v6 & 4) != 0)
    {
      v9 = (v6 >> 7) & 0x3F;
      if (v9 == 24 && v3 == 4)
      {
        v7 = 3;
      }
      else if (v9 || v3 != 4)
      {
        v10 = v3 == 2 && v9 == 0;
        if (v10)
          v7 = 2;
        else
          v7 = 0;
      }
      else
      {
        v7 = 5;
      }
    }
    else
    {
      v7 = 0;
    }
  }
  if (a3)
    *a3 = (a1[3] & 0x20) == 0;
  *a2 = v7;
  return 1;
}

float AUSpeechEnhancer::syncParametersWithCore(AUSpeechEnhancer *this)
{
  unint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  float Parameter;
  uint64_t v8;
  float *v9;
  unint64_t v10;
  float v11;
  long double v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  vDSP_Length v17;
  float *v18;
  float v19;
  vDSP_Length v20;
  uint64_t v21;
  uint64_t v22;
  const float *v23;
  float v24;
  float v25;
  float *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float result;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  float v43;
  float __B;
  float __C;

  if (*((_QWORD *)this + 83) != *((_QWORD *)this + 82))
  {
    v2 = 0;
    do
    {
      v3 = (uint64_t *)*((_QWORD *)this + 74);
      v4 = *((_QWORD *)this + 9);
      if (v4)
      {
        v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
      }
      else
      {
        v6 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v6)
          v5 = 0;
        else
          v5 = *v6;
      }
      Parameter = ausdk::AUElement::GetParameter(v5, v2);
      SpeechEnhancerCore<float>::setParameterLight(*v3, v3[1], v2++, Parameter);
    }
    while (v2 < (uint64_t)(*((_QWORD *)this + 83) - *((_QWORD *)this + 82)) >> 5);
  }
  v8 = *((_QWORD *)this + 74);
  v9 = *(float **)v8;
  v10 = *(_QWORD *)(v8 + 8) - *(_QWORD *)v8;
  if (v10 <= 0x60)
    goto LABEL_47;
  v11 = *(float *)(v8 + 108) / (float)*(unint64_t *)(v8 + 312);
  *(float *)(v8 + 76) = expf(-1.0 / (float)(v9[27] * v11));
  if (v10 <= 0x70)
    goto LABEL_47;
  *(float *)(v8 + 64) = expf(-1.0 / (float)(v11 * v9[31]));
  if (v10 <= 0x80)
    goto LABEL_47;
  *(float *)(v8 + 68) = expf(-1.0 / (float)(v11 * v9[35]));
  v12 = exp(v9[23] * 0.230258509);
  *(float *)&v12 = v12;
  *(_DWORD *)(v8 + 72) = LODWORD(v12);
  *(_QWORD *)(v8 + 32) = (unint64_t)(float)(v9[19] + 0.5);
  *(float *)&v12 = v9[15] + 0.5;
  *(_QWORD *)(v8 + 24) = (unint64_t)*(float *)&v12;
  SpeechEnhancerFilterBank<float>::createFilterBank(v8 + 1192, (unint64_t)*(float *)&v12, v12);
  std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(v8 + 864), *(char **)(v8 + 1248), *(_QWORD *)(v8 + 1256), (uint64_t)(*(_QWORD *)(v8 + 1256) - *(_QWORD *)(v8 + 1248)) >> 2);
  if (*(_QWORD *)(v8 + 8) - *(_QWORD *)v8 <= 0x120uLL)
    goto LABEL_47;
  v13 = *(_QWORD *)(v8 + 1224);
  v14 = (*(_QWORD *)(v8 + 1232) - v13) >> 2;
  if (*(_QWORD *)(v8 + 1232) == v13)
  {
LABEL_19:
    v15 = (*(_QWORD *)(v8 + 1232) - v13) >> 2;
  }
  else
  {
    v15 = 0;
    v16 = v14 <= 1 ? 1 : (*(_QWORD *)(v8 + 1232) - v13) >> 2;
    while (*(float *)(v13 + 4 * v15) <= *(float *)(*(_QWORD *)v8 + 300))
    {
      if (v16 == ++v15)
        goto LABEL_19;
    }
  }
  if (v14 >= v15)
    v14 = v15;
  *(_QWORD *)(v8 + 1192) = v14;
  SpeechEnhancerFilterBank<float>::calculateBandImportance(v8 + 1192);
  v17 = *(_QWORD *)(v8 + 1192);
  *(_QWORD *)(v8 + 40) = v17;
  v18 = *(float **)v8;
  if (*(_QWORD *)(v8 + 8) - *(_QWORD *)v8 <= 0x330uLL)
    goto LABEL_47;
  *(float *)(v8 + 168) = v18[207];
  *(float *)(v8 + 172) = v18[199];
  *(float *)(v8 + 176) = v18[203];
  __C = 0.0;
  vDSP_maxv(*(const float **)(v8 + 1296), 1, &__C, v17);
  v19 = logf(1.0 - *(float *)(v8 + 200));
  v20 = *(_QWORD *)(v8 + 40);
  if (v20)
  {
    v21 = 0;
    v22 = *(_QWORD *)(v8 + 1296);
    v23 = *(const float **)(v8 + 696);
    v24 = v19 / __C;
    do
    {
      v23[v21] = 1.0 - expf(v24 * *(float *)(v22 + 4 * v21));
      ++v21;
    }
    while (v20 != v21);
  }
  else
  {
    v23 = *(const float **)(v8 + 696);
  }
  vDSP_vneg(v23, 1, *(float **)(v8 + 720), 1, v20);
  __B = 1.0;
  vDSP_vsadd(*(const float **)(v8 + 720), 1, &__B, *(float **)(v8 + 744), 1, *(_QWORD *)(v8 + 40));
  v43 = 2.0;
  vDSP_vsadd(*(const float **)(v8 + 720), 1, &v43, *(float **)(v8 + 720), 1, *(_QWORD *)(v8 + 40));
  v42 = 1056964608;
  vDSP_vsmul(*(const float **)(v8 + 696), 1, (const float *)&v42, *(float **)(v8 + 768), 1, *(_QWORD *)(v8 + 40));
  vDSP_vmul(*(const float **)(v8 + 768), 1, *(const float **)(v8 + 864), 1, *(float **)(v8 + 768), 1, *(_QWORD *)(v8 + 40));
  if (*(_QWORD *)(v8 + 8) - *(_QWORD *)v8 <= 0x130uLL)
    goto LABEL_47;
  v25 = exp(*(float *)(*(_QWORD *)v8 + 316) * 0.230258509);
  *(float *)(v8 + 80) = v25;
  *(float *)(v8 + 84) = 1.0 / v25;
  vDSP_vsmul(*(const float **)(v8 + 744), 1, (const float *)(v8 + 80), *(float **)(v8 + 792), 1, *(_QWORD *)(v8 + 40));
  __C = 1.0;
  vDSP_svdiv(&__C, *(const float **)(v8 + 792), 1, *(float **)(v8 + 792), 1, *(_QWORD *)(v8 + 40));
  vDSP_vsmsa(*(const float **)(v8 + 744), 1, (const float *)(v8 + 80), (const float *)(v8 + 84), *(float **)(v8 + 816), 1, *(_QWORD *)(v8 + 40));
  vDSP_vadd(*(const float **)(v8 + 720), 1, *(const float **)(v8 + 816), 1, *(float **)(v8 + 816), 1, *(_QWORD *)(v8 + 40));
  vDSP_vdiv(*(const float **)(v8 + 816), 1, *(const float **)(v8 + 768), 1, *(float **)(v8 + 816), 1, *(_QWORD *)(v8 + 40));
  v26 = *(float **)v8;
  v27 = *(_QWORD *)(v8 + 8) - *(_QWORD *)v8;
  if (*(_QWORD *)(v8 + 24))
  {
    if (v27 > 0x1E0)
    {
      v28 = *(_QWORD *)(v8 + 328);
      v29 = vcvtas_u32_f32(v26[123] / (float)(*(float *)(v8 + 108) / (float)*(unint64_t *)(v8 + 320)));
      goto LABEL_32;
    }
LABEL_47:
    __assert_rtn("parameterValue", "SpeechEnhancerCore.h", 278, "index >= 0 && index < mParameterInfoTable.size()");
  }
  if (v27 <= 0x1E0)
    goto LABEL_47;
  v30 = *(_QWORD *)(v8 + 1224);
  v28 = (*(_QWORD *)(v8 + 1232) - v30) >> 2;
  if (*(_QWORD *)(v8 + 1232) == v30)
  {
    v29 = *(_QWORD *)(v8 + 40);
LABEL_32:
    if (v28 >= v29)
      v28 = v29;
    goto LABEL_45;
  }
  v31 = 0;
  if (v28 <= 1)
    v32 = 1;
  else
    v32 = (*(_QWORD *)(v8 + 1232) - v30) >> 2;
  while (*(float *)(v30 + 4 * v31) <= v26[123])
  {
    if (v32 == ++v31)
    {
      v31 = (*(_QWORD *)(v8 + 1232) - v30) >> 2;
      break;
    }
  }
  v28 = *(_QWORD *)(v8 + 40);
  if (v31 < v28)
    v28 = v31;
LABEL_45:
  *(_QWORD *)(v8 + 56) = v28;
  v33 = exp(v26[83] * 0.230258509);
  *(float *)(v8 + 92) = v33;
  v34 = exp(v26[115] * 0.230258509);
  *(float *)(v8 + 96) = v34;
  v35 = exp(v26[87] * 0.230258509);
  *(float *)(v8 + 100) = v35;
  v36 = exp(v26[119] * 0.230258509);
  *(float *)(v8 + 104) = v36;
  result = v26[43];
  v38 = *((_DWORD *)v26 + 47);
  v39 = *((_DWORD *)v26 + 51);
  v40 = *((_DWORD *)v26 + 55);
  v41 = *((_DWORD *)v26 + 59);
  *(float *)(v8 + 1396) = result;
  *(_DWORD *)(v8 + 1400) = v38;
  *(_DWORD *)(v8 + 1404) = v39;
  *(_DWORD *)(v8 + 1408) = v40;
  *(_DWORD *)(v8 + 1412) = v41;
  *(_BYTE *)(v8 + 355) = 1;
  *(_WORD *)(v8 + 353) = 257;
  *(_QWORD *)(v8 + 344) = *(_QWORD *)(v8 + 48);
  return result;
}

void SpeechEnhancerCore<float>::process(_QWORD *a1, float ***a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  float **v5;
  float **v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v10;
  uint64_t v11;
  DSPSplitComplex *v12;
  uint64_t v13;
  uint64_t **v14;
  uint64_t v15;
  uint64_t *v16;
  float **v17;
  uint64_t v18;
  _QWORD *v19;
  float **p_imagp;
  uint64_t *v21;
  float *v22;
  uint64_t v23;
  uint64_t **v24;
  uint64_t v25;
  const float **v26;
  unint64_t v27;
  float **v28;
  float **v29;
  const float *v30;
  const float *v31;
  float v32;
  vDSP_Length v33;
  float *v34;
  uint64_t v35;
  DSPSplitComplex *v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  float *v40;
  DSPSplitComplex *v41;
  uint64_t v42;
  const float **v43;
  unint64_t v44;
  unint64_t v45;
  const float *v46;
  const float **v47;
  float v48;
  vDSP_Length v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  unint64_t v58;
  float ***v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  v5 = a2[1];
  v59 = a2;
  v7 = ((char *)v5 - (char *)v6) >> 4;
  if (v7 != a1[42])
    __assert_rtn("process", "SpeechEnhancerCore.h", 288, "input.size() == mNumChannels");
  v8 = *a3;
  if (v7 != ((char *)a3[1] - (char *)*a3) >> 4)
    __assert_rtn("process", "SpeechEnhancerCore.h", 289, "output.size() == mNumChannels");
  if (a1[39] != a4)
    __assert_rtn("process", "SpeechEnhancerCore.h", 290, "numFrames == mBlockSize");
  v10 = (unint64_t)v6[1];
  v58 = a4;
  v56 = a5;
  if ((_DWORD)a5)
  {
    if (v10 >= 2 * a4)
    {
      if (v8[1] >= 2 * a4)
      {
        v57 = &v55;
        MEMORY[0x1E0C80A78](a1);
        v12 = (DSPSplitComplex *)(&v55 - 2 * v11);
        MEMORY[0x1E0C80A78](v13);
        v16 = &v55 - 2 * v15;
        if (v15)
        {
          v17 = *v59;
          v18 = a1[39];
          v19 = v16 + 1;
          p_imagp = &v12->imagp;
          v21 = *v14;
          do
          {
            v22 = *v17;
            v17 += 2;
            *(p_imagp - 1) = v22;
            *p_imagp = &v22[v18];
            p_imagp += 2;
            v23 = *v21;
            v21 += 2;
            *(v19 - 1) = v23;
            *v19 = v23 + 4 * v18;
            v19 += 2;
            --v15;
          }
          while (v15);
        }
        v24 = v14;
        v25 = SpeechEnhancerCore<float>::processCore((uint64_t)a1, v12);
        if (a1[42])
        {
          v26 = (const float **)v25;
          v27 = 0;
          v28 = (float **)(v16 + 1);
          v29 = &v12->imagp;
          do
          {
            v30 = *v26;
            v31 = *v29;
            v32 = **v29;
            v33 = a1[41] - 1;
            vDSP_vmul(*(v29 - 1), 1, *v26, 1, *(v28 - 1), 1, v33);
            v34 = *v28;
            v28 += 2;
            vDSP_vmul(v31, 1, v30, 1, v34, 1, v33);
            *v34 = v32 * v30[v33];
            ++v27;
            v29 += 2;
          }
          while (a1[42] > v27);
        }
        goto LABEL_22;
      }
LABEL_34:
      __assert_rtn("process", "SpeechEnhancerCore.h", 292, "isFrequencyDomain ? (output[0].size() >= 2 * numFrames) : (output[0].size() >= numFrames)");
    }
LABEL_33:
    __assert_rtn("process", "SpeechEnhancerCore.h", 291, "isFrequencyDomain ? (input[0].size() >= 2 * numFrames) : (input[0].size() >= numFrames)");
  }
  if (v10 < a4)
    goto LABEL_33;
  if (v8[1] < a4)
    goto LABEL_34;
  v24 = a3;
  v57 = &v55;
  MEMORY[0x1E0C80A78](a1);
  v36 = (DSPSplitComplex *)(&v55 - 2 * v35);
  if (a1[42])
  {
    v37 = 0;
    v38 = 0;
    v39 = 0;
    do
    {
      v40 = *(float **)(a1[138] + v37);
      v41 = &v36[v38 / 0x10];
      v41->realp = *(float **)(a1[135] + v37);
      v41->imagp = v40;
      VPTimeFreqConverter::Analyze(*(VPTimeFreqConverter **)(a1[186] + 8 * v39++), (*v59)[v38 / 8], &v36[v38 / 0x10]);
      v38 += 16;
      v37 += 24;
    }
    while (a1[42] > v39);
  }
  v42 = SpeechEnhancerCore<float>::processCore((uint64_t)a1, v36);
  if (a1[42])
  {
    v43 = (const float **)v42;
    v44 = 0;
    v45 = 0;
    do
    {
      v46 = *v43;
      v47 = (const float **)&v36[v44 / 2].imagp;
      v48 = **v47;
      v49 = a1[41] - 1;
      vDSP_vmul(v36[v44 / 2].realp, 1, *v43, 1, v36[v44 / 2].realp, 1, v49);
      vDSP_vmul(*v47, 1, v46, 1, (float *)*v47, 1, v49);
      *(float *)*v47 = v48 * v46[v49];
      VPTimeFreqConverter::Synthesize(*(VPTimeFreqConverter **)(a1[189] + 8 * v45++), &v36[v44 / 2], (float *)(*v24)[v44]);
      v44 += 2;
    }
    while (a1[42] > v45);
  }
LABEL_22:
  v50 = v58;
  if (a1[1] == *a1)
    __assert_rtn("parameterValue", "SpeechEnhancerCore.h", 278, "index >= 0 && index < mParameterInfoTable.size()");
  if (*(float *)(*a1 + 12) > 0.5)
  {
    v51 = a1[42];
    if (v51)
    {
      v52 = 0;
      v53 = 0;
      v54 = 4 * (v58 << v56);
      do
      {
        if (v50)
        {
          memmove((void *)(*v24)[v52], (*v59)[v52], v54);
          v51 = a1[42];
        }
        ++v53;
        v52 += 2;
      }
      while (v51 > v53);
    }
  }
  ++a1[6];
}

uint64_t AUSpeechEnhancer::updateMeterDisplay(AUSpeechEnhancer *this, unsigned int a2)
{
  uint64_t v2;

  v2 = **((_QWORD **)this + 74);
  if (a2 >= (unint64_t)((*(_QWORD *)(*((_QWORD *)this + 74) + 8) - v2) >> 4))
    __assert_rtn("getParameter", "SpeechEnhancerCore.h", 266, "index >= 0 && index < mParameterInfoTable.size()");
  return (*(uint64_t (**)(AUSpeechEnhancer *, float))(*(_QWORD *)this + 152))(this, *(float *)(v2 + 16 * a2 + 12));
}

uint64_t SpeechEnhancerCore<float>::processCore(uint64_t a1, DSPSplitComplex *a2)
{
  float *v2;
  unint64_t v3;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float *v12;
  const float *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  float v19;
  float *v20;
  vDSP_Length v21;
  _DWORD *v22;
  uint64_t v23;
  vDSP_Length v24;
  float *v25;
  vDSP_Length v26;
  _DWORD *v27;
  uint64_t v28;
  vDSP_Length v29;
  float v30;
  float v31;
  float v32;
  float v33;
  const float *v34;
  float *v35;
  vDSP_Length v36;
  const float *p_B;
  vDSP_Length __N;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  uint64_t v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  char v52;
  float v53;
  float v54;
  vDSP_Length *v55;
  float v56;
  float *v57;
  float **v58;
  unint64_t v59;
  const float *v60;
  vDSP_Length v61;
  uint64_t v62;
  uint64_t v63;
  float *v64;
  float *v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  uint64_t v71;
  float *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  float v80;
  uint64_t v81;
  float *v82;
  unint64_t v83;
  float v84;
  uint64_t v86;
  uint64_t v87;
  BOOL v88;
  vDSP_Length *v89;
  float v90;
  float v91;
  vDSP_Length v92;
  float *v93;
  float *v94;
  vDSP_Length v95;
  uint64_t v96;
  vDSP_Length v97;
  float v98;
  float v99;
  float v100;
  vDSP_Length v101;
  uint64_t v102;
  uint64_t v103;
  const float **v104;
  const float **v105;
  vDSP_Length *v106;
  float v107;
  float v108;
  vDSP_Length v109;
  float *v110;
  unint64_t *v111;
  const float *v112;
  const float *v113;
  DSPSplitComplex __B;
  float v115;
  int v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float __D;
  float __C[3];

  v2 = *(float **)a1;
  v3 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v3 <= 0x10)
    goto LABEL_163;
  if (v2[7] <= 0.5)
  {
    if (v3 <= 0x350)
      goto LABEL_163;
    if (v2[211] >= v2[215])
      goto LABEL_21;
    v6 = exp((float)(*(float *)(a1 + 176) / (float)(*(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312)))* 0.230258509);
    *(float *)&__B.realp = v6;
    vDSP_vsmul(*(const float **)(a1 + 936), 1, (const float *)&__B, *(float **)(a1 + 360), 1, *(_QWORD *)(a1 + 328));
    v7 = *(float *)(a1 + 64);
    v8 = *(float *)(a1 + 68);
    __D = 1.0 - v7;
    __C[0] = v7;
    v120 = 1.0 - v8;
    v121 = v8;
    v9 = (float)*(unint64_t *)(a1 + 48);
    v10 = *(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312);
    v11 = *(float *)(a1 + 224);
    if ((float)(v9 / v10) < v11)
    {
      v119 = 1.0 - expf((float)((float)(-3.0 / v11) * v9) / v10);
      vDSP_vsmul(*(const float **)(a1 + 648), 1, &v119, *(float **)(a1 + 648), 1, *(_QWORD *)(a1 + 328));
    }
    v12 = *(float **)(a1 + 936);
    v13 = *(const float **)(a1 + 648);
    if (v7 == v8)
    {
      vDSP_vsmsma(v12, 1, __C, v13, 1, &__D, v12, 1, *(_QWORD *)(a1 + 328));
    }
    else
    {
      vDSP_vsmsma(v12, 1, __C, v13, 1, &__D, *(float **)(a1 + 984), 1, *(_QWORD *)(a1 + 328));
      vDSP_vsmsma(*(const float **)(a1 + 936), 1, &v121, *(const float **)(a1 + 648), 1, &v120, *(float **)(a1 + 1008), 1, *(_QWORD *)(a1 + 328));
      v14 = *(_QWORD *)(a1 + 328);
      if (v14)
      {
        v15 = 0;
        v16 = *(_QWORD *)(a1 + 648);
        v17 = *(_QWORD *)(a1 + 936);
        do
        {
          if (*(float *)(v16 + 4 * v15) <= *(float *)(v17 + 4 * v15))
            v18 = (_QWORD *)(a1 + 1008);
          else
            v18 = (_QWORD *)(a1 + 984);
          *(_DWORD *)(v17 + 4 * v15) = *(_DWORD *)(*v18 + 4 * v15);
          ++v15;
        }
        while (v14 != v15);
      }
    }
    v19 = (float)*(unint64_t *)(a1 + 48) / (float)(*(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312));
    if (v19 > *(float *)(a1 + 224))
    {
      if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 <= 0x70uLL)
        goto LABEL_163;
      if (v19 > (float)(*(float *)(*(_QWORD *)a1 + 124) * 3.0))
        vDSP_vmin(*(const float **)(a1 + 936), 1, *(const float **)(a1 + 360), 1, *(float **)(a1 + 936), 1, *(_QWORD *)(a1 + 328));
    }
    vDSP_vclip(*(const float **)(a1 + 936), 1, (const float *)(a1 + 160), (const float *)(a1 + 164), *(float **)(a1 + 936), 1, *(_QWORD *)(a1 + 328));
    v2 = *(float **)a1;
    v3 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  }
  if (v3 <= 0x180)
    goto LABEL_163;
LABEL_21:
  if (v2[99] <= 0.5)
  {
    v25 = *(float **)(a1 + 1032);
    v26 = *(_QWORD *)(a1 + 312);
    __B = *a2;
    vDSP_zvmags(&__B, 1, v25, 1, v26);
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 1480) + 24))(*(_QWORD *)(a1 + 1480), *(_QWORD *)(a1 + 1032), *(_QWORD *)(a1 + 1056), *(unsigned int *)(a1 + 328));
    vDSP_vsub(*(const float **)(a1 + 1056), 1, *(const float **)(a1 + 1032), 1, *(float **)(a1 + 1032), 1, *(_QWORD *)(a1 + 328));
    vDSP_vthr(*(const float **)(a1 + 1032), 1, &AlgorithmUtils::kepsf, *(float **)(a1 + 1032), 1, *(_QWORD *)(a1 + 328));
    v27 = *(_DWORD **)(a1 + 1032);
    *v27 = 0;
    v28 = *(_QWORD *)(a1 + 328);
    v27[v28 - 1] = 0;
    if (v28)
    {
      memmove(*(void **)(a1 + 360), v27, 4 * v28);
      v29 = *(_QWORD *)(a1 + 328);
    }
    else
    {
      v29 = 0;
    }
    LODWORD(__B.realp) = 0;
    vDSP_sve(*(const float **)(*(_QWORD *)(a1 + 1480) + 112), 1, (float *)&__B, v29);
    if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 <= 0x20uLL)
      goto LABEL_163;
    __N = *(_QWORD *)(a1 + 328);
    if ((float)(*(float *)&__B.realp / (float)__N) > *(float *)(*(_QWORD *)a1 + 44))
    {
      __C[0] = 1.0 - *(float *)(a1 + 76);
      vDSP_vsmsma(*(const float **)(a1 + 912), 1, (const float *)(a1 + 76), *(const float **)(a1 + 360), 1, __C, *(float **)(a1 + 912), 1, __N);
      __N = *(_QWORD *)(a1 + 328);
    }
    vDSP_vsmul(*(const float **)(a1 + 912), 1, (const float *)(a1 + 72), *(float **)(a1 + 672), 1, __N);
    v34 = *(const float **)(a1 + 672);
    p_B = (const float *)(a1 + 140);
    v36 = *(_QWORD *)(a1 + 328);
    v35 = (float *)v34;
  }
  else
  {
    v20 = *(float **)(a1 + 1032);
    v21 = *(_QWORD *)(a1 + 312);
    __B = *a2;
    vDSP_zvmags(&__B, 1, v20, 1, v21);
    v22 = *(_DWORD **)(a1 + 1032);
    *v22 = 0;
    v23 = *(_QWORD *)(a1 + 328);
    v22[v23 - 1] = 0;
    if (v23)
    {
      memmove(*(void **)(a1 + 360), v22, 4 * v23);
      v24 = *(_QWORD *)(a1 + 328);
    }
    else
    {
      v24 = 0;
    }
    vDSP_vsmul(*(const float **)(a1 + 360), 1, (const float *)(a1 + 72), *(float **)(a1 + 360), 1, v24);
    vDSP_sve(*(const float **)(a1 + 360), 1, (float *)(a1 + 136), *(_QWORD *)(a1 + 328));
    v31 = *(float *)(a1 + 136);
    v30 = *(float *)(a1 + 140);
    v32 = exp(*(float *)(a1 + 196) * 0.230258509);
    if ((float)(v31 * v30) <= v32)
    {
      v33 = *(float *)(a1 + 132);
    }
    else
    {
      v33 = (float)(v31 * (float)(1.0 - *(float *)(a1 + 76))) + (float)(*(float *)(a1 + 76) * *(float *)(a1 + 132));
      *(float *)(a1 + 132) = v33;
    }
    *(float *)&__B.realp = (float)(v30 * v33) / 10000000.0;
    v34 = *(const float **)(a1 + 960);
    v35 = *(float **)(a1 + 672);
    v36 = *(_QWORD *)(a1 + 328);
    p_B = (const float *)&__B;
  }
  vDSP_vsmul(v34, 1, p_B, v35, 1, v36);
  v39 = SPLMeter<float,AWeight>::process<std::vector<float>>(a1 + 1448, *(const float **)(a1 + 672), *(_QWORD *)(a1 + 680));
  v40 = SPLMeter<float,AWeight>::process<std::vector<float>>(a1 + 1448, *(const float **)(a1 + 936), *(_QWORD *)(a1 + 944));
  *(float *)(a1 + 148) = v40;
  *(float *)(a1 + 128) = v39 - v40;
  if (vabds_f32(v40, *(float *)(a1 + 152)) > *(float *)(a1 + 208)
    || vabds_f32(v39, *(float *)(a1 + 156)) > *(float *)(a1 + 204)
    || *(float *)(a1 + 140) != *(float *)(a1 + 144))
  {
    *(_BYTE *)(a1 + 353) = 1;
    *(_QWORD *)(a1 + 344) = *(_QWORD *)(a1 + 48);
    *(float *)(a1 + 152) = v40;
    *(float *)(a1 + 156) = v39;
    *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 140);
    goto LABEL_40;
  }
  v46 = *(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312);
  if ((float)((float)(unint64_t)(*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 344)) / v46) <= *(float *)(a1 + 212))
  {
    if (*(_BYTE *)(a1 + 353))
      goto LABEL_40;
  }
  else
  {
    *(_BYTE *)(a1 + 353) = 0;
  }
  if (!*(_BYTE *)(a1 + 354))
  {
    v49 = *(float *)(a1 + 112);
    goto LABEL_69;
  }
LABEL_40:
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 <= 0x1A0uLL)
    goto LABEL_163;
  v41 = *(float *)(*(_QWORD *)a1 + 428);
  if (*(_BYTE *)(a1 + 1436))
  {
    v42 = *(float *)(a1 + 1396);
  }
  else
  {
    *(float *)(a1 + 1432) = v41;
    *(float *)(a1 + 1424) = v41;
    v42 = *(float *)(a1 + 1396);
    *(float *)(a1 + 1428) = v42;
    *(_WORD *)(a1 + 1436) = 1;
  }
  if (v42 > v40)
  {
    *(float *)(a1 + 1432) = v41;
    *(_BYTE *)(a1 + 1437) = 0;
    goto LABEL_46;
  }
  if (!*(_BYTE *)(a1 + 1437))
    goto LABEL_50;
  if (*(float *)(a1 + 1440) > v40)
  {
    *(_BYTE *)(a1 + 1437) = 0;
LABEL_50:
    v44 = 1404;
    if (*(float *)(a1 + 1400) < v40)
      v44 = 1408;
    v43 = (float)(*(float *)(a1 + 1432) + (float)(*(float *)(a1 + v44) * (float)(v40 - *(float *)(a1 + 1428))))
        + (float)(v41 - *(float *)(a1 + 1424));
    *(float *)(a1 + 1432) = v43;
    if (v43 > *(float *)(a1 + 1412))
    {
      *(_BYTE *)(a1 + 1437) = 1;
      *(float *)(a1 + 1440) = v40;
    }
    goto LABEL_59;
  }
  v45 = *(float *)(a1 + 1424);
  if (v45 <= v41)
  {
    v43 = *(float *)(a1 + 1432);
  }
  else
  {
    v43 = (float)(v41 - v45) + *(float *)(a1 + 1432);
    *(float *)(a1 + 1432) = v43;
    *(_BYTE *)(a1 + 1437) = 0;
  }
LABEL_59:
  v47 = *(float *)(a1 + 1412);
  if (v43 > v47)
  {
    *(float *)(a1 + 1432) = v47;
    v43 = v47;
    goto LABEL_63;
  }
  if (v43 >= v41)
    goto LABEL_63;
  *(float *)(a1 + 1432) = v41;
LABEL_46:
  v43 = v41;
LABEL_63:
  *(float *)(a1 + 1424) = v41;
  *(float *)(a1 + 1428) = v40;
  v48 = v43 - v41;
  if ((float)(v43 - v41) > *(float *)(a1 + 1392))
    v48 = *(float *)(a1 + 1392);
  if ((LODWORD(v48) & 0x7FFFFFFFu) >= 0x7F800000)
    v49 = 0.0;
  else
    v49 = v48;
  *(float *)(a1 + 1420) = v49;
  *(float *)(a1 + 112) = v49;
  v46 = *(float *)(a1 + 108) / (float)*(unint64_t *)(a1 + 312);
LABEL_69:
  v50 = *(float *)(a1 + 116);
  v51 = *(float *)(a1 + 168) / v46;
  if ((float)(v49 - v50) <= v51)
  {
    v52 = 0;
  }
  else
  {
    v49 = v50 + v51;
    *(float *)(a1 + 112) = v50 + v51;
    v52 = 1;
  }
  v53 = exp(v49 * 0.230258509);
  *(float *)(a1 + 120) = v53;
  *(_BYTE *)(a1 + 354) = v52;
  *(float *)(a1 + 116) = v49;
  v54 = exp(v49 * 0.115129255);
  *(float *)(a1 + 124) = v54;
  v55 = (vDSP_Length *)(a1 + 328);
  vDSP_vsmul(*(const float **)(a1 + 672), 1, (const float *)(a1 + 120), *(float **)(a1 + 672), 1, *(_QWORD *)(a1 + 328));
  if (*(_QWORD *)(a1 + 48) % *(_QWORD *)(a1 + 240))
    goto LABEL_99;
  v56 = SPLMeter<float,AWeight>::process<std::vector<float>>(a1 + 1448, *(const float **)(a1 + 672), *(_QWORD *)(a1 + 680));
  vDSP_mmul(*(const float **)(a1 + 1344), 1, *(const float **)(a1 + 672), 1, *(float **)(a1 + 384), 1, *(_QWORD *)(a1 + 1192), 1uLL, *(_QWORD *)(a1 + 328));
  vDSP_mmul(*(const float **)(a1 + 1344), 1, *(const float **)(a1 + 936), 1, *(float **)(a1 + 408), 1, *(_QWORD *)(a1 + 1192), 1uLL, *(_QWORD *)(a1 + 328));
  v57 = *(float **)a1;
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 <= 0x1F0uLL)
    goto LABEL_163;
  v58 = (float **)(a1 + 360);
  if (*(float *)(a1 + 148) < v57[127] || v57[71] > 0.5)
  {
    LODWORD(__B.realp) = 1065353216;
    vDSP_vfill((const float *)&__B, *(float **)(a1 + 360), 1, *(_QWORD *)(a1 + 328));
    vDSP_vfill((const float *)&__B, *(float **)(a1 + 888), 1, *(_QWORD *)(a1 + 328));
LABEL_77:
    v59 = 0;
    goto LABEL_78;
  }
  if (!*(_BYTE *)(a1 + 353) && !*(_BYTE *)(a1 + 354) && !*(_BYTE *)(a1 + 355))
  {
    if (*v55)
      memmove(*(void **)(a1 + 360), *(const void **)(a1 + 888), 4 * *v55);
    goto LABEL_77;
  }
  v111 = (unint64_t *)(a1 + 1192);
  LODWORD(__B.realp) = 0;
  v86 = 40;
  if (*(_QWORD *)(a1 + 24) == 1)
    v86 = 328;
  v87 = 384;
  if (*(_QWORD *)(a1 + 24) == 1)
    v87 = 672;
  v88 = 1;
  vDSP_sve(*(const float **)(a1 + v87), 1, (float *)&__B, *(_QWORD *)(a1 + v86));
  v89 = (vDSP_Length *)(a1 + 40);
  vDSP_vma(*(const float **)(a1 + 408), 1, *(const float **)(a1 + 792), 1, *(const float **)(a1 + 384), 1, *(float **)(a1 + 432), 1, *(_QWORD *)(a1 + 40));
  vDSP_vsma(*(const float **)(a1 + 384), 1, (const float *)(a1 + 84), *(const float **)(a1 + 408), 1, *(float **)(a1 + 408), 1, *(_QWORD *)(a1 + 40));
  __C[0] = 0.0;
  vDSP_sve(*(const float **)(a1 + 432), 1, __C, *(_QWORD *)(a1 + 40));
  __D = 1.0 / (float)(__C[0] + 2.2204e-16);
  vDSP_vsmul(*(const float **)(a1 + 432), 1, &__D, *(float **)(a1 + 432), 1, *(_QWORD *)(a1 + 40));
  vDSP_vsmul(*(const float **)(a1 + 408), 1, &__D, *(float **)(a1 + 408), 1, *(_QWORD *)(a1 + 40));
  vDSP_vmul(*(const float **)(a1 + 432), 1, *(const float **)(a1 + 408), 1, *(float **)(a1 + 456), 1, *(_QWORD *)(a1 + 40));
  vDSP_vsq(*(const float **)(a1 + 432), 1, *(float **)(a1 + 480), 1, *(_QWORD *)(a1 + 40));
  vDSP_vsq(*(const float **)(a1 + 408), 1, *(float **)(a1 + 408), 1, *(_QWORD *)(a1 + 40));
  v90 = v56 - *(float *)(a1 + 148);
  v91 = v90 * (float)(1.0 / (float)(log10f(*(float *)(a1 + 80) + 2.2204e-16) * 10.0));
  if (v91 < 0.0)
    v91 = 0.0;
  if (v91 > 1.0)
    v91 = 1.0;
  v121 = v91;
  vDSP_vsmul(*(const float **)(a1 + 816), 1, &v121, *(float **)(a1 + 840), 1, *v89);
  vDSP_vneg(*(const float **)(a1 + 840), 1, *(float **)(a1 + 840), 1, *v89);
  v119 = 0.0;
  v120 = 0.0;
  v92 = *v89;
  if (*v89)
  {
    v93 = *(float **)(a1 + 408);
    if (*v93 <= 2.2204e-16 || (v94 = *(float **)(a1 + 432), *v94 <= 2.2204e-16))
    {
      v88 = 0;
    }
    else
    {
      v95 = 0;
      v96 = 1;
      while (1)
      {
        if (v92 == v96)
        {
          v97 = *v89;
          goto LABEL_137;
        }
        v97 = v96;
        ++v95;
        if (v93[v96] <= 2.2204e-16)
          break;
        v98 = v94[v96++];
        if (v98 <= 2.2204e-16)
          goto LABEL_137;
      }
      v97 = v95;
LABEL_137:
      v88 = v92 <= v97;
    }
  }
  *(_BYTE *)(a1 + 352) = v88;
  v59 = 0;
  if ((float)(*(float *)(a1 + 184) * *(float *)&__B.realp) < INFINITY)
  {
    v112 = (const float *)(a1 + 100);
    v113 = (const float *)(a1 + 92);
    v99 = 0.0;
    v100 = -1000000.0;
    do
    {
      if (v59 > *(_QWORD *)(a1 + 232))
        break;
      v120 = (float)(v99 + v100) * 0.5;
      vDSP_vsma(*(const float **)(a1 + 432), 1, &v120, *(const float **)(a1 + 840), 1, *(float **)(a1 + 504), 1, *(_QWORD *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 408), 1, *(const float **)(a1 + 504), 1, *(float **)(a1 + 528), 1, *(_QWORD *)(a1 + 40));
      vDSP_vma(*(const float **)(a1 + 456), 1, *(const float **)(a1 + 768), 1, *(const float **)(a1 + 528), 1, *(float **)(a1 + 528), 1, *(_QWORD *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 504), 1, *(const float **)(a1 + 456), 1, *(float **)(a1 + 576), 1, *(_QWORD *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 576), 1, *(const float **)(a1 + 720), 1, *(float **)(a1 + 576), 1, *(_QWORD *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 504), 1, *(const float **)(a1 + 480), 1, *(float **)(a1 + 552), 1, *(_QWORD *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 552), 1, *(const float **)(a1 + 744), 1, *(float **)(a1 + 552), 1, *(_QWORD *)(a1 + 40));
      vDSP_vmul(*(const float **)(a1 + 552), 1, *(const float **)(a1 + 528), 1, *(float **)(a1 + 504), 1, *(_QWORD *)(a1 + 40));
      v118 = 4.0;
      vDSP_vsmul(*(const float **)(a1 + 504), 1, &v118, *(float **)(a1 + 504), 1, *(_QWORD *)(a1 + 40));
      vDSP_vsq(*(const float **)(a1 + 576), 1, *(float **)(a1 + 552), 1, *(_QWORD *)(a1 + 40));
      vDSP_vsub(*(const float **)(a1 + 504), 1, *(const float **)(a1 + 552), 1, *(float **)(a1 + 504), 1, *(_QWORD *)(a1 + 40));
      v117 = 0.0;
      vDSP_vthr(*(const float **)(a1 + 504), 1, &v117, *(float **)(a1 + 504), 1, *(_QWORD *)(a1 + 40));
      v116 = *(_QWORD *)(a1 + 40);
      vvsqrtf(*(float **)(a1 + 504), *(const float **)(a1 + 504), &v116);
      vDSP_vsub(*(const float **)(a1 + 576), 1, *(const float **)(a1 + 504), 1, *(float **)(a1 + 504), 1, *(_QWORD *)(a1 + 40));
      vDSP_vdiv(*(const float **)(a1 + 504), 1, *(const float **)(a1 + 528), 1, *(float **)(a1 + 504), 1, *(_QWORD *)(a1 + 40));
      v115 = 2.0;
      vDSP_vsmul(*(const float **)(a1 + 504), 1, &v115, *(float **)(a1 + 504), 1, *(_QWORD *)(a1 + 40));
      v101 = *(_QWORD *)(a1 + 40);
      if (!*(_BYTE *)(a1 + 352) && v101)
      {
        v102 = 0;
        v103 = *(_QWORD *)(a1 + 408);
        do
        {
          if (*(float *)(v103 + 4 * v102) <= 2.2204e-16 || *(float *)(*(_QWORD *)(a1 + 432) + 4 * v102) <= 2.2204e-16)
            *(_DWORD *)(*(_QWORD *)(a1 + 504) + 4 * v102) = 1065353216;
          ++v102;
        }
        while (v101 != v102);
      }
      vDSP_vthr(*(const float **)(a1 + 504), 1, &v117, *(float **)(a1 + 504), 1, v101);
      if (*(_QWORD *)(a1 + 24) == 1)
      {
        SpeechEnhancerFilterBank<float>::convertFilterBankToLinear(v111, *(float **)(a1 + 504), *(_QWORD *)(a1 + 360), *(_QWORD *)(a1 + 32));
        vDSP_vclip(*(const float **)(a1 + 360), 1, v113, v112, *(float **)(a1 + 360), 1, *(_QWORD *)(a1 + 56));
        vDSP_vclip((const float *)(*(_QWORD *)(a1 + 360) + 4 * *(_QWORD *)(a1 + 56)), 1, (const float *)(a1 + 96), (const float *)(a1 + 104), (float *)(*(_QWORD *)(a1 + 360) + 4 * *(_QWORD *)(a1 + 56)), 1, *(_QWORD *)(a1 + 328) - *(_QWORD *)(a1 + 56));
        v104 = (const float **)(a1 + 360);
        v105 = (const float **)(a1 + 672);
        v106 = (vDSP_Length *)(a1 + 328);
      }
      else
      {
        vDSP_vclip(*(const float **)(a1 + 504), 1, v113, v112, *(float **)(a1 + 504), 1, *(_QWORD *)(a1 + 56));
        vDSP_vclip((const float *)(*(_QWORD *)(a1 + 504) + 4 * *(_QWORD *)(a1 + 56)), 1, (const float *)(a1 + 96), (const float *)(a1 + 104), (float *)(*(_QWORD *)(a1 + 504) + 4 * *(_QWORD *)(a1 + 56)), 1, *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 56));
        v104 = (const float **)(a1 + 504);
        v105 = (const float **)(a1 + 384);
        v106 = (vDSP_Length *)(a1 + 40);
      }
      ++v59;
      vDSP_dotpr(*v104, 1, *v105, 1, &v119, *v106);
      v107 = vabds_f32(v119, *(float *)&__B.realp);
      if (v119 <= *(float *)&__B.realp)
        v100 = v120;
      else
        v99 = v120;
    }
    while (v107 > (float)(*(float *)(a1 + 184) * *(float *)&__B.realp));
  }
  if (!*(_QWORD *)(a1 + 24))
    SpeechEnhancerFilterBank<float>::convertFilterBankToLinear(v111, *(float **)(a1 + 504), *(_QWORD *)(a1 + 360), *(_QWORD *)(a1 + 32));
  vvsqrtf(*(float **)(a1 + 360), *(const float **)(a1 + 360), (const int *)(a1 + 328));
  v58 = (float **)(a1 + 360);
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 <= 0x1F0uLL)
LABEL_163:
    __assert_rtn("parameterValue", "SpeechEnhancerCore.h", 278, "index >= 0 && index < mParameterInfoTable.size()");
  v108 = (float)(*(float *)(a1 + 148) - *(float *)(*(_QWORD *)a1 + 508)) * 0.25;
  if (v108 < 1.0)
  {
    v109 = *v55;
    if (*v55)
    {
      v110 = *(float **)(a1 + 360);
      do
      {
        *v110 = powf(*v110, v108);
        ++v110;
        --v109;
      }
      while (v109);
    }
  }
LABEL_78:
  v60 = *(const float **)(a1 + 360);
  v61 = (uint64_t)(*(_QWORD *)(a1 + 368) - (_QWORD)v60) >> 2;
  LODWORD(__B.realp) = 0;
  vDSP_sve(v60, 1, (float *)&__B, v61);
  if ((unint64_t)((uint64_t)__B.realp & 0x7FFFFFFF) >= 0x7F800000)
  {
    LODWORD(__B.realp) = 1065353216;
    vDSP_vfill((const float *)&__B, *v58, 1, *v55);
  }
  *(_BYTE *)(a1 + 355) = 0;
  v62 = *(_QWORD *)(a1 + 328);
  if (v62)
  {
    v63 = 0;
    v64 = *(float **)(a1 + 360);
    v65 = *(float **)(a1 + 888);
    v66 = (float)*(unint64_t *)(a1 + 240);
    v67 = (float)*(unint64_t *)(a1 + 312);
    do
    {
      v68 = v65[v63];
      v69 = v64[v63] / v68;
      v70 = exp((float)((float)(*(float *)(a1 + 172) * v66) / (float)(*(float *)(a1 + 108) / v67)) * 0.115129255);
      if (v69 > v70)
      {
        v64[v63] = v68 * v70;
        *(_BYTE *)(a1 + 355) = 1;
      }
      ++v63;
    }
    while (v62 != v63);
    memmove(v65, v64, 4 * v62);
    if (*v55)
    {
      memmove(*(void **)(a1 + 888), *(const void **)(a1 + 360), 4 * *v55);
      v71 = *(_QWORD *)(a1 + 328);
      if (v71)
        memmove(*(void **)(a1 + 600), *(const void **)(a1 + 360), 4 * v71);
    }
  }
  v72 = *(float **)a1;
  v73 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v73 <= 0x160)
    goto LABEL_163;
  v72[91] = v56;
  if (v73 <= 0x170)
    goto LABEL_163;
  v72[95] = (float)v59;
  if (v73 <= 0x190)
    goto LABEL_163;
  if (v72[103] > 0.5)
  {
    vDSP_vclr((float *)(a1 + 1128), 1, 0x10uLL);
    v74 = *(_QWORD *)(a1 + 328);
    if (v74)
    {
      v75 = 0;
      v76 = 0;
      v77 = 0;
      v78 = *(_QWORD *)(a1 + 624);
      do
      {
        v79 = a1 + 4 * v77;
        if (*(float *)(v78 + 4 * v75) >= *(float *)(v79 + 248))
        {
          v80 = *(float *)(v79 + 1128) / fmaxf((float)v76, 1.0);
          *(float *)(v79 + 1128) = v80;
          if (v77 + 33 >= (unint64_t)((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4))
            goto LABEL_163;
          *(float *)(*(_QWORD *)a1 + 16 * (v77 + 33) + 12) = v80;
          if (++v77 == 16)
            break;
          v76 = 0;
        }
        *(float *)(a1 + 4 * v77 + 1128) = *(float *)(a1 + 4 * v77 + 1128)
                                        + (float)(log10f(*(float *)(*(_QWORD *)(a1 + 600) + 4 * v75) + 2.2204e-16) * 20.0);
        ++v76;
        ++v75;
      }
      while (v74 != v75);
    }
  }
LABEL_99:
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 <= 0x110uLL)
    goto LABEL_163;
  if (*(float *)(*(_QWORD *)a1 + 284) <= 0.5)
  {
    vDSP_vsmul(*(const float **)(a1 + 600), 1, (const float *)(a1 + 124), *(float **)(a1 + 360), 1, *(_QWORD *)(a1 + 328));
    v81 = *(_QWORD *)(a1 + 328);
    if (v81)
      memmove(*(void **)(a1 + 1032), *(const void **)(a1 + 360), 4 * v81);
  }
  else
  {
    LODWORD(__B.realp) = *(_DWORD *)(a1 + 124);
    vDSP_vfill((const float *)&__B, *(float **)(a1 + 1032), 1, *v55);
  }
  v82 = *(float **)a1;
  v83 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v83 <= 0x90)
    goto LABEL_163;
  v82[39] = *(float *)(a1 + 148);
  if (v83 <= 0xF0)
    goto LABEL_163;
  v82[63] = *(float *)(a1 + 128);
  if (v83 <= 0x200)
    goto LABEL_163;
  v84 = 0.0;
  if (*(_BYTE *)(a1 + 353))
    v84 = 1.0;
  v82[131] = v84;
  v82[67] = *(float *)(a1 + 112);
  v82[111] = *(float *)(a1 + 112) + v82[107];
  return a1 + 1032;
}

float SPLMeter<float,AWeight>::process<std::vector<float>>(uint64_t a1, const float *__A, uint64_t a3)
{
  vDSP_Length v3;
  const float *v4;
  float __C;

  v3 = (a3 - (uint64_t)__A) >> 2;
  v4 = *(const float **)(a1 + 8);
  if (v3 != (uint64_t)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 2)
    __assert_rtn("process", "SPLMeter.h", 98, "a.size() == mWeightCurve.size()");
  __C = 0.0;
  vDSP_dotpr(__A, 1, v4, 1, &__C, v3);
  return *(float *)a1 + (float)(log10f(fabsf(__C) + 0.00000011921) * 10.0);
}

float *SpeechEnhancerFilterBank<float>::convertFilterBankToLinear(unint64_t *a1, float *a2, uint64_t a3, uint64_t a4)
{
  float *result;
  unint64_t v9;
  float *v10;
  float *v11;
  unint64_t v12;
  float v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  float v18;
  unint64_t v19;
  _DWORD *v20;

  result = (float *)a1[4];
  v9 = *a1;
  v10 = (float *)a1[10];
  v11 = (float *)a1[11];
  v12 = v11 - v10;
  if (!a4)
    return SpeechEnhancerFilterBank<float>::interp1(result, v9, a2, (uint64_t)v10, v12, a3, 0.0, 1.0);
  v13 = *result;
  v14 = v9 - 2;
  if (v9 >= 2)
    v13 = (float)(v13 + result[1]) * 0.5;
  if (*v10 <= v13)
  {
    v16 = 0;
  }
  else
  {
    v15 = 0;
    while (v14 != v15)
    {
      v16 = v15 + 1;
      v13 = (float)(result[v15 + 2] + result[v15 + 1]) * 0.5;
      ++v15;
      if (*v10 <= v13)
        goto LABEL_12;
    }
    v13 = result[v9 - 1];
    v16 = v9 - 1;
  }
LABEL_12:
  if (v11 == v10)
  {
    v17 = 0;
  }
  else
  {
    v17 = 0;
    while (v10[v17] < *result)
    {
      *(_DWORD *)(a3 + 4 * v17++) = 0;
      if (v12 == v17)
        return result;
    }
  }
  if (v17 >= v12)
  {
LABEL_26:
    v19 = v12 - v17;
    if (v12 > v17)
    {
      v20 = (_DWORD *)(a3 + 4 * v17);
      do
      {
        *v20++ = 1065353216;
        --v19;
      }
      while (v19);
    }
  }
  else
  {
    do
    {
      v18 = v10[v17];
      if (v18 > v13)
      {
        if (v18 >= result[v9 - 1])
          goto LABEL_26;
        do
        {
          v13 = result[v9 - 1];
          if (v14 != v16)
            v13 = (float)(result[v16 + 2] + result[v16 + 1]) * 0.5;
          ++v16;
        }
        while (v18 > v13);
      }
      *(float *)(a3 + 4 * v17++) = a2[v16];
    }
    while (v17 != v12);
  }
  return result;
}

float *SpeechEnhancerFilterBank<float>::interp1(float *result, uint64_t a2, float *a3, uint64_t a4, unint64_t a5, uint64_t a6, float a7, float a8)
{
  float v8;
  float v9;
  float v10;
  float v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  unint64_t v22;
  float *v23;

  v9 = *a3;
  v8 = a3[1];
  v11 = *result;
  v10 = result[1];
  v12 = 0;
  if (a5)
  {
    while (*(float *)(a4 + 4 * v12) < *result)
    {
      *(float *)(a6 + 4 * v12++) = a7;
      if (a5 == v12)
        return result;
    }
  }
  if (v12 >= a5)
  {
LABEL_19:
    v22 = a5 - v12;
    if (a5 > v12)
    {
      v23 = (float *)(a6 + 4 * v12);
      do
      {
        *v23++ = a8;
        --v22;
      }
      while (v22);
    }
  }
  else
  {
    v13 = 0;
    v14 = 1;
    v15 = (float)(v8 - v9) / (float)(v10 - v11);
    do
    {
      v16 = *(float *)(a4 + 4 * v12);
      v17 = result[v14];
      if (v16 >= v17)
      {
        if (v16 <= v17 || v16 >= result[a2 - 1])
        {
          if (v16 == result[v13])
          {
            v18 = a3[v13];
          }
          else
          {
            if (v16 != v17)
              goto LABEL_19;
            v18 = a3[v14];
          }
        }
        else
        {
          do
          {
            v19 = result[++v14];
            ++v13;
          }
          while (v16 > v19);
          v20 = a3[v13];
          v21 = result[v13];
          v15 = (float)(a3[v14] - v20) / (float)(v19 - v21);
          v18 = v20 + (float)(v15 * (float)(v16 - v21));
        }
      }
      else
      {
        v18 = a3[v13] + (float)(v15 * (float)(v16 - result[v13]));
      }
      *(float *)(a6 + 4 * v12++) = v18;
    }
    while (v12 != a5);
  }
  return result;
}

uint64_t SpeechEnhancerCore<float>::setParameterLight(uint64_t result, uint64_t a2, unint64_t a3, float a4)
{
  float *v4;

  if (a3 >= (a2 - result) >> 4)
    __assert_rtn("setParameterLight", "SpeechEnhancerCore.h", 181, "index >= 0 && index < mParameterInfoTable.size()");
  v4 = (float *)(result + 16 * a3);
  if (v4[1] < a4)
    a4 = v4[1];
  if (a4 < *v4)
    a4 = *v4;
  v4[3] = a4;
  return result;
}

void SpeechEnhancerFilterBank<float>::createFilterBank(uint64_t a1, uint64_t a2, long double a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  float *v13;
  unint64_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float *v20;
  _DWORD *v21;
  unint64_t v22;
  uint64_t v24;
  uint64_t v25;
  float *v26;
  uint64_t v27;
  double v28;
  float *v29;
  float *v30;
  _DWORD *v31;
  uint64_t v32;
  double v33;
  uint64_t v34;
  float v35;
  uint64_t v36;
  unint64_t v37;
  float *v38;

  v5 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  v6 = (v4 - v5) >> 2;
  *(_QWORD *)a1 = v6;
  if (*(_QWORD *)(a1 + 16) != a2)
  {
    *(_QWORD *)(a1 + 16) = a2;
    v8 = *(_DWORD **)(a1 + 152);
    v9 = *(_QWORD *)(a1 + 160) - (_QWORD)v8;
    if (v9 >= 1)
      bzero(*(void **)(a1 + 152), 4 * (((unint64_t)v9 >> 2) - ((unint64_t)v9 > 3)) + 4);
    if (a2 == 1)
    {
      if (v4 != v5)
      {
        v24 = 0;
        v25 = *(_QWORD *)(a1 + 56);
        v26 = *(float **)(a1 + 80);
        v38 = *(float **)(a1 + 88);
        if ((unint64_t)(v38 - v26) <= 1)
          v27 = 1;
        else
          v27 = v38 - v26;
        v36 = (v4 - v5) >> 2;
        v37 = ((char *)v38 - (char *)v26) & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          *(float *)(v25 + 4 * v24) = *(float *)(a1 + 192)
                                    * (float)(*(float *)(a1 + 180)
                                            + (float)(*(float *)(a1 + 184) * *(float *)(v5 + 4 * v24)));
          *(_DWORD *)(a1 + 176) = 0;
          if (v38 != v26)
          {
            LODWORD(a3) = *(_DWORD *)(a1 + 188);
            v28 = (double)*(unint64_t *)&a3;
            v29 = v26;
            v30 = v26;
            v31 = v8;
            v32 = v27;
            do
            {
              v33 = (float)(*v30 - *(float *)(v5 + 4 * v24));
              a3 = 1.0 / pow(v33 * v33 / (*(float *)(v25 + 4 * v24) * *(float *)(v25 + 4 * v24)) + 1.0, v28);
              *(float *)&a3 = a3;
              *v31 = LODWORD(a3);
              if (*(float *)(a1 + 176) < *(float *)&a3)
                *(_DWORD *)(a1 + 176) = LODWORD(a3);
              ++v31;
              ++v30;
              --v32;
            }
            while (v32);
            v34 = 0;
            v6 = v36;
            v26 = v29;
            do
            {
              v35 = *(float *)(a1 + 176);
              if (v35 != 0.0)
                *(float *)&v8[v34] = *(float *)&v8[v34] / v35;
              ++v34;
            }
            while (v27 != v34);
          }
          ++v24;
          v8 = (_DWORD *)((char *)v8 + v37);
        }
        while (v24 != v6);
      }
    }
    else if (!a2 && v4 != v5)
    {
      v10 = 0;
      v11 = *(_QWORD *)(a1 + 56);
      v13 = *(float **)(a1 + 80);
      v12 = *(float **)(a1 + 88);
      v14 = v12 - v13;
      if (v14 <= 1)
        v14 = 1;
      do
      {
        v15 = *(float *)(a1 + 180) + (float)(*(float *)(a1 + 184) * *(float *)(v5 + 4 * v10));
        *(float *)(v11 + 4 * v10) = v15;
        if (v12 != v13)
        {
          v16 = *(float *)(v5 + 4 * v10);
          v17 = v15 * 0.5;
          v18 = v16 - (float)(v15 * 0.5);
          v19 = v17 + v16;
          v20 = v13;
          v21 = v8;
          v22 = v14;
          do
          {
            if (*v20 >= v18 && *v20 <= v19)
              *v21 = 1065353216;
            ++v21;
            ++v20;
            --v22;
          }
          while (v22);
        }
        ++v10;
        v8 = (_DWORD *)((char *)v8 + (((char *)v12 - (char *)v13) & 0xFFFFFFFFFFFFFFFCLL));
      }
      while (v10 != v6);
    }
  }
  SpeechEnhancerFilterBank<float>::calculateBandImportance(a1);
}

void SpeechEnhancerFilterBank<float>::calculateBandImportance(uint64_t a1)
{
  float __C;

  vDSP_mmul(*(const float **)(a1 + 152), 1, *(const float **)(a1 + 128), 1, *(float **)(a1 + 104), 1, *(_QWORD *)a1, 1uLL, (uint64_t)(*(_QWORD *)(a1 + 136) - *(_QWORD *)(a1 + 128)) >> 2);
  __C = 0.0;
  vDSP_sve(*(const float **)(a1 + 104), 1, &__C, *(_QWORD *)a1);
  vDSP_vsdiv(*(const float **)(a1 + 104), 1, &__C, *(float **)(a1 + 104), 1, *(_QWORD *)a1);
}

float SpeechEnhancerCore<float>::resampleSpectrum(float *a1, unint64_t a2, float *a3, float *a4, unint64_t a5, float *a6)
{
  float result;
  float __B;

  if (a2 <= 1)
    __assert_rtn("resampleSpectrum", "SpeechEnhancerCore.h", 344, "DFTFrequenciesSizeIn > 1");
  if (a5 <= 1)
    __assert_rtn("resampleSpectrum", "SpeechEnhancerCore.h", 345, "DFTFrequenciesSizeOut > 1");
  SpeechEnhancerFilterBank<float>::interp1(a1, a2, a3, (uint64_t)a4, a5, (uint64_t)a6, *a3, a3[a2 - 1]);
  __B = (float)(a4[1] - *a4) / (float)(a1[1] - *a1);
  vDSP_vsmul(a6, 1, &__B, a6, 1, a5);
  return result;
}

void SpeechEnhancerCore<float>::getAverageSpeechSpectrum(float *a1, unint64_t a2, uint64_t a3)
{
  _DWORD *v6;
  char *v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;

  if (a2 <= 1)
    __assert_rtn("getAverageSpeechSpectrum", "SpeechEnhancerCore.h", 892, "DFTFrequenciesSize > 1");
  v6 = operator new(0x64uLL);
  v6[24] = 1182400512;
  *((_OWORD *)v6 + 2) = xmmword_1B6630514;
  *((_OWORD *)v6 + 3) = unk_1B6630524;
  *((_OWORD *)v6 + 4) = xmmword_1B6630534;
  *((_OWORD *)v6 + 5) = unk_1B6630544;
  *(_OWORD *)v6 = xmmword_1B66304F4;
  *((_OWORD *)v6 + 1) = unk_1B6630504;
  v7 = (char *)operator new(0x64uLL);
  v8 = 0;
  *((_DWORD *)v7 + 24) = 1109576909;
  *((_OWORD *)v7 + 2) = xmmword_1B6630578;
  *((_OWORD *)v7 + 3) = unk_1B6630588;
  *((_OWORD *)v7 + 4) = xmmword_1B6630598;
  *((_OWORD *)v7 + 5) = unk_1B66305A8;
  *(_OWORD *)v7 = xmmword_1B6630558;
  *((_OWORD *)v7 + 1) = unk_1B6630568;
  v9 = a1[1] - *a1;
  do
  {
    v10 = v9 / (float)(*(float *)&v6[v8] * 0.23156);
    v11 = exp(*(float *)&v7[v8 * 4] * 0.230258509);
    *(float *)&v7[v8 * 4] = v10 * v11;
    ++v8;
  }
  while (v8 != 25);
  SpeechEnhancerFilterBank<float>::interp1((float *)v6, 25, (float *)v7, (uint64_t)a1, a2, a3, *(float *)v7, *((float *)v7 + 24));
  operator delete(v7);
  operator delete(v6);
}

void sub_1B613CB5C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<SpeechEnhancerCore<float>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void **v42;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v42 = (void **)(v2 + 1512);
    std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100](&v42);
    v42 = (void **)(v2 + 1488);
    std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100](&v42);
    v3 = *(_QWORD *)(v2 + 1480);
    *(_QWORD *)(v2 + 1480) = 0;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    v4 = *(void **)(v2 + 1456);
    if (v4)
    {
      *(_QWORD *)(v2 + 1464) = v4;
      operator delete(v4);
    }
    v5 = *(void **)(v2 + 1344);
    if (v5)
    {
      *(_QWORD *)(v2 + 1352) = v5;
      operator delete(v5);
    }
    v6 = *(void **)(v2 + 1320);
    if (v6)
    {
      *(_QWORD *)(v2 + 1328) = v6;
      operator delete(v6);
    }
    v7 = *(void **)(v2 + 1296);
    if (v7)
    {
      *(_QWORD *)(v2 + 1304) = v7;
      operator delete(v7);
    }
    v8 = *(void **)(v2 + 1272);
    if (v8)
    {
      *(_QWORD *)(v2 + 1280) = v8;
      operator delete(v8);
    }
    v9 = *(void **)(v2 + 1248);
    if (v9)
    {
      *(_QWORD *)(v2 + 1256) = v9;
      operator delete(v9);
    }
    v10 = *(void **)(v2 + 1224);
    if (v10)
    {
      *(_QWORD *)(v2 + 1232) = v10;
      operator delete(v10);
    }
    v42 = (void **)(v2 + 1104);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v42);
    v42 = (void **)(v2 + 1080);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v42);
    v11 = *(void **)(v2 + 1056);
    if (v11)
    {
      *(_QWORD *)(v2 + 1064) = v11;
      operator delete(v11);
    }
    v12 = *(void **)(v2 + 1032);
    if (v12)
    {
      *(_QWORD *)(v2 + 1040) = v12;
      operator delete(v12);
    }
    v13 = *(void **)(v2 + 1008);
    if (v13)
    {
      *(_QWORD *)(v2 + 1016) = v13;
      operator delete(v13);
    }
    v14 = *(void **)(v2 + 984);
    if (v14)
    {
      *(_QWORD *)(v2 + 992) = v14;
      operator delete(v14);
    }
    v15 = *(void **)(v2 + 960);
    if (v15)
    {
      *(_QWORD *)(v2 + 968) = v15;
      operator delete(v15);
    }
    v16 = *(void **)(v2 + 936);
    if (v16)
    {
      *(_QWORD *)(v2 + 944) = v16;
      operator delete(v16);
    }
    v17 = *(void **)(v2 + 912);
    if (v17)
    {
      *(_QWORD *)(v2 + 920) = v17;
      operator delete(v17);
    }
    v18 = *(void **)(v2 + 888);
    if (v18)
    {
      *(_QWORD *)(v2 + 896) = v18;
      operator delete(v18);
    }
    v19 = *(void **)(v2 + 864);
    if (v19)
    {
      *(_QWORD *)(v2 + 872) = v19;
      operator delete(v19);
    }
    v20 = *(void **)(v2 + 840);
    if (v20)
    {
      *(_QWORD *)(v2 + 848) = v20;
      operator delete(v20);
    }
    v21 = *(void **)(v2 + 816);
    if (v21)
    {
      *(_QWORD *)(v2 + 824) = v21;
      operator delete(v21);
    }
    v22 = *(void **)(v2 + 792);
    if (v22)
    {
      *(_QWORD *)(v2 + 800) = v22;
      operator delete(v22);
    }
    v23 = *(void **)(v2 + 768);
    if (v23)
    {
      *(_QWORD *)(v2 + 776) = v23;
      operator delete(v23);
    }
    v24 = *(void **)(v2 + 744);
    if (v24)
    {
      *(_QWORD *)(v2 + 752) = v24;
      operator delete(v24);
    }
    v25 = *(void **)(v2 + 720);
    if (v25)
    {
      *(_QWORD *)(v2 + 728) = v25;
      operator delete(v25);
    }
    v26 = *(void **)(v2 + 696);
    if (v26)
    {
      *(_QWORD *)(v2 + 704) = v26;
      operator delete(v26);
    }
    v27 = *(void **)(v2 + 672);
    if (v27)
    {
      *(_QWORD *)(v2 + 680) = v27;
      operator delete(v27);
    }
    v28 = *(void **)(v2 + 648);
    if (v28)
    {
      *(_QWORD *)(v2 + 656) = v28;
      operator delete(v28);
    }
    v29 = *(void **)(v2 + 624);
    if (v29)
    {
      *(_QWORD *)(v2 + 632) = v29;
      operator delete(v29);
    }
    v30 = *(void **)(v2 + 600);
    if (v30)
    {
      *(_QWORD *)(v2 + 608) = v30;
      operator delete(v30);
    }
    v31 = *(void **)(v2 + 576);
    if (v31)
    {
      *(_QWORD *)(v2 + 584) = v31;
      operator delete(v31);
    }
    v32 = *(void **)(v2 + 552);
    if (v32)
    {
      *(_QWORD *)(v2 + 560) = v32;
      operator delete(v32);
    }
    v33 = *(void **)(v2 + 528);
    if (v33)
    {
      *(_QWORD *)(v2 + 536) = v33;
      operator delete(v33);
    }
    v34 = *(void **)(v2 + 504);
    if (v34)
    {
      *(_QWORD *)(v2 + 512) = v34;
      operator delete(v34);
    }
    v35 = *(void **)(v2 + 480);
    if (v35)
    {
      *(_QWORD *)(v2 + 488) = v35;
      operator delete(v35);
    }
    v36 = *(void **)(v2 + 456);
    if (v36)
    {
      *(_QWORD *)(v2 + 464) = v36;
      operator delete(v36);
    }
    v37 = *(void **)(v2 + 432);
    if (v37)
    {
      *(_QWORD *)(v2 + 440) = v37;
      operator delete(v37);
    }
    v38 = *(void **)(v2 + 408);
    if (v38)
    {
      *(_QWORD *)(v2 + 416) = v38;
      operator delete(v38);
    }
    v39 = *(void **)(v2 + 384);
    if (v39)
    {
      *(_QWORD *)(v2 + 392) = v39;
      operator delete(v39);
    }
    v40 = *(void **)(v2 + 360);
    if (v40)
    {
      *(_QWORD *)(v2 + 368) = v40;
      operator delete(v40);
    }
    v41 = *(void **)v2;
    if (*(_QWORD *)v2)
    {
      *(_QWORD *)(v2 + 8) = v41;
      operator delete(v41);
    }
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void std::vector<std::span<float,18446744073709551615ul>>::resize(char **a1, unint64_t a2)
{
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;

  v3 = *a1;
  v4 = a1[1];
  v5 = (v4 - *a1) >> 4;
  if (a2 <= v5)
  {
    if (a2 >= v5)
      return;
    v18 = &v3[16 * a2];
    goto LABEL_17;
  }
  v6 = a2 - v5;
  v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 4)
  {
    bzero(a1[1], 16 * v6);
    v18 = &v4[16 * v6];
LABEL_17:
    a1[1] = v18;
    return;
  }
  if (a2 >> 60)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  v8 = v7 - v3;
  v9 = v8 >> 3;
  if (v8 >> 3 <= a2)
    v9 = a2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
    v10 = 0xFFFFFFFFFFFFFFFLL;
  else
    v10 = v9;
  v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float (ASAFeatures::*)(ASAFrontEndInputState const*)>>(v10);
  v12 = &v11[16 * v5];
  v14 = &v11[16 * v13];
  bzero(v12, 16 * v6);
  v15 = &v12[16 * v6];
  v17 = *a1;
  v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      *((_OWORD *)v12 - 1) = *((_OWORD *)v16 - 1);
      v12 -= 16;
      v16 -= 16;
    }
    while (v16 != v17);
    v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
    operator delete(v16);
}

void std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  VPTimeFreqConverter **v2;
  VPTimeFreqConverter **v4;
  void *v5;

  v1 = *a1;
  v2 = (VPTimeFreqConverter **)**a1;
  if (v2)
  {
    v4 = (VPTimeFreqConverter **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100](--v4, 0);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *AWeight<float>::Generate(_QWORD *a1, unint64_t a2, float a3)
{
  _QWORD *result;
  int32x4_t v6;
  uint64x2_t v7;
  unint64_t v8;
  int64x2_t v9;
  int64x2_t v10;
  _DWORD *v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int64x2_t v17;
  uint64x2_t v18;
  uint64x2_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int64x2_t v24;

  result = std::vector<float>::vector(a1, a2);
  if (a2)
  {
    v7 = (uint64x2_t)vdupq_n_s64(a2 - 1);
    v8 = (a2 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    v9 = (int64x2_t)xmmword_1B6627110;
    v10 = (int64x2_t)xmmword_1B6626830;
    v11 = (_DWORD *)(*result + 8);
    v12 = (float32x4_t)vdupq_n_s32(0x43D428CAu);
    v13 = (float32x4_t)vdupq_n_s32(0x4D0DCF73u);
    v14 = (float32x4_t)vdupq_n_s32(0x4D328586u);
    v15 = (float32x4_t)vdupq_n_s32(0x4635145Fu);
    v16 = (float32x4_t)vdupq_n_s32(0x4904EB8Bu);
    v17 = vdupq_n_s64(4uLL);
    do
    {
      v18.i64[0] = v9.i64[0] * v9.i64[0];
      v18.i64[1] = v9.i64[1] * v9.i64[1];
      *(int32x2_t *)v6.i8 = vmovn_s64((int64x2_t)vcgeq_u64(v7, (uint64x2_t)v10));
      v19.i64[0] = v10.i64[0] * v10.i64[0];
      v19.i64[1] = v10.i64[1] * v10.i64[1];
      v20 = vmulq_n_f32(vmulq_n_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vcvtq_f64_u64(v19)), vcvtq_f64_u64(v18)), a3 / (float)(2 * a2 - 2)), a3 / (float)(2 * a2 - 2));
      v21 = vmulq_f32(vdivq_f32(v20, vaddq_f32(v20, v12)), vdivq_f32(v14, vaddq_f32(v20, v13)));
      v22 = vmulq_f32(vdivq_f32(v20, vaddq_f32(v20, v15)), vmulq_f32(v21, v21));
      v23 = vmulq_f32(vdivq_f32(v20, vaddq_f32(v20, v16)), v22);
      if ((vmovn_s32(v6).u8[0] & 1) != 0)
        *(v11 - 2) = v23.i32[0];
      if ((vmovn_s32(v6).i8[2] & 1) != 0)
        *(v11 - 1) = v23.i32[1];
      v24 = (int64x2_t)vcgeq_u64(v7, (uint64x2_t)v9);
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v22, v24)).i32[1] & 1) != 0)
        *v11 = v23.i32[2];
      v6 = vmovn_hight_s64(*(int32x2_t *)v24.i8, v24);
      if ((vmovn_s32(v6).i8[6] & 1) != 0)
        v11[1] = v23.i32[3];
      v9 = vaddq_s64(v9, v17);
      v10 = vaddq_s64(v10, v17);
      v11 += 4;
      v8 -= 4;
    }
    while (v8);
  }
  return result;
}

void std::vector<std::unique_ptr<VPTimeFreqConverter>>::resize(__int128 *a1, unint64_t a2)
{
  _QWORD *v3;
  VPTimeFreqConverter **v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  _QWORD *v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  __int128 v19;
  char *v20;
  VPTimeFreqConverter **v21;
  uint64_t v22;
  __int128 v23;
  char *v24;
  __int128 *v25;

  v3 = *(_QWORD **)a1;
  v4 = (VPTimeFreqConverter **)*((_QWORD *)a1 + 1);
  v5 = ((uint64_t)v4 - *(_QWORD *)a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      v21 = (VPTimeFreqConverter **)&v3[a2];
      while (v4 != v21)
        std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100](--v4, 0);
      *((_QWORD *)a1 + 1) = v21;
    }
  }
  else
  {
    v6 = a2 - v5;
    v7 = *((_QWORD *)a1 + 2);
    if (a2 - v5 <= (v7 - (uint64_t)v4) >> 3)
    {
      bzero(*((void **)a1 + 1), 8 * v6);
      *((_QWORD *)a1 + 1) = &v4[v6];
    }
    else
    {
      if (a2 >> 61)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v25 = a1 + 1;
      v8 = v7 - (_QWORD)v3;
      v9 = v8 >> 2;
      if (v8 >> 2 <= a2)
        v9 = a2;
      if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
        v10 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v10 = v9;
      v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v10);
      v13 = *(_QWORD **)a1;
      v12 = (_QWORD *)*((_QWORD *)a1 + 1);
      v14 = &v11[8 * v5];
      v16 = &v11[8 * v15];
      v24 = v16;
      bzero(v14, 8 * v6);
      v17 = &v14[8 * v6];
      *((_QWORD *)&v23 + 1) = v17;
      if (v12 != v13)
      {
        do
        {
          v18 = *--v12;
          *v12 = 0;
          *((_QWORD *)v14 - 1) = v18;
          v14 -= 8;
        }
        while (v12 != v13);
        v17 = (char *)*((_QWORD *)&v23 + 1);
        v16 = v24;
      }
      v19 = *a1;
      *(_QWORD *)a1 = v14;
      *((_QWORD *)a1 + 1) = v17;
      v23 = v19;
      v20 = (char *)*((_QWORD *)a1 + 2);
      *((_QWORD *)a1 + 2) = v16;
      v24 = v20;
      v22 = v19;
      std::__split_buffer<std::unique_ptr<VPTimeFreqConverter>>::~__split_buffer((uint64_t)&v22);
    }
  }
}

_QWORD *SpeechEnhancerFilterBank<float>::~SpeechEnhancerFilterBank(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v2 = (void *)a1[19];
  if (v2)
  {
    a1[20] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[16];
  if (v3)
  {
    a1[17] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[13];
  if (v4)
  {
    a1[14] = v4;
    operator delete(v4);
  }
  v5 = (void *)a1[10];
  if (v5)
  {
    a1[11] = v5;
    operator delete(v5);
  }
  v6 = (void *)a1[7];
  if (v6)
  {
    a1[8] = v6;
    operator delete(v6);
  }
  v7 = (void *)a1[4];
  if (v7)
  {
    a1[5] = v7;
    operator delete(v7);
  }
  return a1;
}

uint64_t std::__split_buffer<std::unique_ptr<VPTimeFreqConverter>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100]((VPTimeFreqConverter **)(i - 8), 0);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void spen::populateParameterInfoTable(void **a1)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  char *v12;
  char *v13;
  __int128 v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  char *v24;
  char *v25;
  __int128 v26;
  unint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  char *v36;
  char *v37;
  __int128 v38;
  unint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  unint64_t v47;
  char *v48;
  char *v49;
  __int128 v50;
  unint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  unint64_t v59;
  char *v60;
  char *v61;
  __int128 v62;
  unint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  unint64_t v71;
  char *v72;
  char *v73;
  __int128 v74;
  unint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  unint64_t v83;
  char *v84;
  char *v85;
  __int128 v86;
  unint64_t v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  unint64_t v95;
  char *v96;
  char *v97;
  __int128 v98;
  unint64_t v99;
  _QWORD *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  unint64_t v107;
  char *v108;
  char *v109;
  __int128 v110;
  unint64_t v111;
  _QWORD *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  _QWORD *v118;
  unint64_t v119;
  char *v120;
  char *v121;
  __int128 v122;
  unint64_t v123;
  _QWORD *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  _QWORD *v130;
  unint64_t v131;
  char *v132;
  char *v133;
  __int128 v134;
  unint64_t v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  _QWORD *v142;
  unint64_t v143;
  char *v144;
  char *v145;
  __int128 v146;
  unint64_t v147;
  _QWORD *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  unint64_t v152;
  uint64_t v153;
  _QWORD *v154;
  unint64_t v155;
  char *v156;
  char *v157;
  __int128 v158;
  unint64_t v159;
  _QWORD *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  unint64_t v164;
  uint64_t v165;
  _QWORD *v166;
  unint64_t v167;
  char *v168;
  char *v169;
  __int128 v170;
  unint64_t v171;
  _QWORD *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  unint64_t v176;
  uint64_t v177;
  _QWORD *v178;
  unint64_t v179;
  char *v180;
  char *v181;
  __int128 v182;
  unint64_t v183;
  _QWORD *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  _QWORD *v190;
  unint64_t v191;
  char *v192;
  char *v193;
  __int128 v194;
  unint64_t v195;
  _QWORD *v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  unint64_t v200;
  uint64_t v201;
  _QWORD *v202;
  unint64_t v203;
  char *v204;
  char *v205;
  __int128 v206;
  unint64_t v207;
  _QWORD *v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  _QWORD *v214;
  unint64_t v215;
  char *v216;
  char *v217;
  __int128 v218;
  unint64_t v219;
  _QWORD *v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  unint64_t v224;
  uint64_t v225;
  _QWORD *v226;
  unint64_t v227;
  char *v228;
  char *v229;
  __int128 v230;
  unint64_t v231;
  _QWORD *v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  unint64_t v236;
  uint64_t v237;
  _QWORD *v238;
  unint64_t v239;
  char *v240;
  char *v241;
  __int128 v242;
  unint64_t v243;
  _QWORD *v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  unint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  unint64_t v251;
  char *v252;
  char *v253;
  __int128 v254;
  unint64_t v255;
  _QWORD *v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  unint64_t v260;
  uint64_t v261;
  _QWORD *v262;
  unint64_t v263;
  char *v264;
  char *v265;
  __int128 v266;
  unint64_t v267;
  _QWORD *v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  unint64_t v272;
  uint64_t v273;
  _QWORD *v274;
  unint64_t v275;
  char *v276;
  char *v277;
  __int128 v278;
  unint64_t v279;
  _QWORD *v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  unint64_t v284;
  uint64_t v285;
  _QWORD *v286;
  unint64_t v287;
  char *v288;
  char *v289;
  __int128 v290;
  unint64_t v291;
  _QWORD *v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  unint64_t v296;
  uint64_t v297;
  _QWORD *v298;
  unint64_t v299;
  char *v300;
  char *v301;
  __int128 v302;
  unint64_t v303;
  _QWORD *v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  unint64_t v308;
  uint64_t v309;
  _QWORD *v310;
  unint64_t v311;
  char *v312;
  char *v313;
  __int128 v314;
  unint64_t v315;
  _QWORD *v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  unint64_t v320;
  uint64_t v321;
  _QWORD *v322;
  unint64_t v323;
  char *v324;
  char *v325;
  __int128 v326;
  unint64_t v327;
  _QWORD *v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  unint64_t v332;
  uint64_t v333;
  _QWORD *v334;
  unint64_t v335;
  char *v336;
  char *v337;
  __int128 v338;
  unint64_t v339;
  _QWORD *v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  unint64_t v344;
  uint64_t v345;
  _QWORD *v346;
  unint64_t v347;
  char *v348;
  char *v349;
  __int128 v350;
  unint64_t v351;
  _QWORD *v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  unint64_t v356;
  uint64_t v357;
  _QWORD *v358;
  unint64_t v359;
  char *v360;
  char *v361;
  __int128 v362;
  unint64_t v363;
  _QWORD *v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  unint64_t v368;
  uint64_t v369;
  _QWORD *v370;
  unint64_t v371;
  char *v372;
  char *v373;
  __int128 v374;
  unint64_t v375;
  _QWORD *v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  unint64_t v380;
  uint64_t v381;
  _QWORD *v382;
  unint64_t v383;
  char *v384;
  char *v385;
  __int128 v386;
  unint64_t v387;
  _QWORD *v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  unint64_t v392;
  uint64_t v393;
  _QWORD *v394;
  unint64_t v395;
  char *v396;
  char *v397;
  __int128 v398;
  unint64_t v399;
  _QWORD *v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  unint64_t v404;
  uint64_t v405;
  _QWORD *v406;
  unint64_t v407;
  char *v408;
  char *v409;
  __int128 v410;
  unint64_t v411;
  _QWORD *v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  unint64_t v416;
  uint64_t v417;
  _QWORD *v418;
  unint64_t v419;
  char *v420;
  char *v421;
  __int128 v422;
  unint64_t v423;
  _QWORD *v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  unint64_t v428;
  uint64_t v429;
  _QWORD *v430;
  unint64_t v431;
  char *v432;
  char *v433;
  __int128 v434;
  unint64_t v435;
  _QWORD *v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  unint64_t v440;
  uint64_t v441;
  _QWORD *v442;
  unint64_t v443;
  char *v444;
  char *v445;
  __int128 v446;
  unint64_t v447;
  _QWORD *v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  unint64_t v452;
  uint64_t v453;
  _QWORD *v454;
  unint64_t v455;
  char *v456;
  char *v457;
  __int128 v458;
  unint64_t v459;
  _QWORD *v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  unint64_t v464;
  uint64_t v465;
  _QWORD *v466;
  unint64_t v467;
  char *v468;
  char *v469;
  __int128 v470;
  unint64_t v471;
  _QWORD *v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  unint64_t v476;
  uint64_t v477;
  _QWORD *v478;
  unint64_t v479;
  char *v480;
  char *v481;
  __int128 v482;
  unint64_t v483;
  _QWORD *v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  unint64_t v488;
  uint64_t v489;
  _QWORD *v490;
  unint64_t v491;
  char *v492;
  char *v493;
  __int128 v494;
  unint64_t v495;
  _QWORD *v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  unint64_t v500;
  uint64_t v501;
  _QWORD *v502;
  unint64_t v503;
  char *v504;
  char *v505;
  __int128 v506;
  unint64_t v507;
  _QWORD *v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  unint64_t v512;
  uint64_t v513;
  _QWORD *v514;
  unint64_t v515;
  char *v516;
  char *v517;
  __int128 v518;
  unint64_t v519;
  _QWORD *v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  unint64_t v524;
  uint64_t v525;
  _QWORD *v526;
  unint64_t v527;
  char *v528;
  char *v529;
  __int128 v530;
  unint64_t v531;
  _QWORD *v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  unint64_t v536;
  uint64_t v537;
  _QWORD *v538;
  unint64_t v539;
  char *v540;
  char *v541;
  __int128 v542;
  unint64_t v543;
  _QWORD *v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  unint64_t v548;
  uint64_t v549;
  _QWORD *v550;
  unint64_t v551;
  char *v552;
  char *v553;
  __int128 v554;
  unint64_t v555;
  _QWORD *v556;
  uint64_t v557;
  uint64_t v558;
  uint64_t v559;
  unint64_t v560;
  uint64_t v561;
  _QWORD *v562;
  unint64_t v563;
  char *v564;
  char *v565;
  __int128 v566;
  unint64_t v567;
  _QWORD *v568;
  uint64_t v569;
  uint64_t v570;
  uint64_t v571;
  unint64_t v572;
  uint64_t v573;
  _QWORD *v574;
  unint64_t v575;
  char *v576;
  char *v577;
  __int128 v578;
  unint64_t v579;
  _QWORD *v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  unint64_t v584;
  uint64_t v585;
  _QWORD *v586;
  unint64_t v587;
  char *v588;
  char *v589;
  __int128 v590;
  unint64_t v591;
  _QWORD *v592;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  unint64_t v596;
  uint64_t v597;
  _QWORD *v598;
  unint64_t v599;
  char *v600;
  char *v601;
  __int128 v602;
  unint64_t v603;
  _QWORD *v604;
  uint64_t v605;
  uint64_t v606;
  uint64_t v607;
  unint64_t v608;
  uint64_t v609;
  _QWORD *v610;
  unint64_t v611;
  char *v612;
  char *v613;
  __int128 v614;
  unint64_t v615;
  _QWORD *v616;
  uint64_t v617;
  uint64_t v618;
  uint64_t v619;
  unint64_t v620;
  uint64_t v621;
  _QWORD *v622;
  unint64_t v623;
  char *v624;
  char *v625;
  __int128 v626;
  unint64_t v627;
  _QWORD *v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  unint64_t v632;
  uint64_t v633;
  _QWORD *v634;
  unint64_t v635;
  char *v636;
  char *v637;
  __int128 v638;
  unint64_t v639;
  _QWORD *v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t v643;
  unint64_t v644;
  uint64_t v645;
  _QWORD *v646;
  unint64_t v647;
  char *v648;
  char *v649;
  __int128 v650;

  v2 = a1[1];
  v3 = (unint64_t)a1[2];
  if ((unint64_t)v2 >= v3)
  {
    v5 = ((char *)v2 - (_BYTE *)*a1) >> 5;
    v6 = v5 + 1;
    if ((unint64_t)(v5 + 1) >> 59)
      goto LABEL_867;
    v7 = v3 - (_QWORD)*a1;
    if (v7 >> 4 > v6)
      v6 = v7 >> 4;
    if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFE0)
      v8 = 0x7FFFFFFFFFFFFFFLL;
    else
      v8 = v6;
    if (v8)
      v8 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v8);
    else
      v9 = 0;
    v10 = (_QWORD *)(v8 + 32 * v5);
    v11 = v8 + 32 * v9;
    *v10 = CFSTR("Bypass Algorithm");
    v10[1] = 0x8000000000000002;
    v10[2] = 0x3F80000000000000;
    v10[3] = -3229614080;
    v4 = v10 + 4;
    v13 = (char *)*a1;
    v12 = (char *)a1[1];
    if (v12 != *a1)
    {
      do
      {
        v14 = *((_OWORD *)v12 - 1);
        *((_OWORD *)v10 - 2) = *((_OWORD *)v12 - 2);
        *((_OWORD *)v10 - 1) = v14;
        v10 -= 4;
        v12 -= 32;
      }
      while (v12 != v13);
      v12 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v4;
    a1[2] = (void *)v11;
    if (v12)
      operator delete(v12);
  }
  else
  {
    *v2 = CFSTR("Bypass Algorithm");
    v2[1] = 0x8000000000000002;
    v2[2] = 0x3F80000000000000;
    v2[3] = -3229614080;
    v4 = v2 + 4;
  }
  a1[1] = v4;
  v15 = (unint64_t)a1[2];
  if ((unint64_t)v4 >= v15)
  {
    v17 = ((char *)v4 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v17 + 1) >> 59)
      goto LABEL_867;
    v18 = v15 - (_QWORD)*a1;
    v19 = v18 >> 4;
    if (v18 >> 4 <= (unint64_t)(v17 + 1))
      v19 = v17 + 1;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0)
      v20 = 0x7FFFFFFFFFFFFFFLL;
    else
      v20 = v19;
    if (v20)
      v20 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v20);
    else
      v21 = 0;
    v22 = (_QWORD *)(v20 + 32 * v17);
    v23 = v20 + 32 * v21;
    *v22 = CFSTR("Wind Flag");
    v22[1] = 0x800000000000;
    v22[2] = 0x3F80000000000000;
    v22[3] = 0xFFFFFFFF00000000;
    v16 = v22 + 4;
    v25 = (char *)*a1;
    v24 = (char *)a1[1];
    if (v24 != *a1)
    {
      do
      {
        v26 = *((_OWORD *)v24 - 1);
        *((_OWORD *)v22 - 2) = *((_OWORD *)v24 - 2);
        *((_OWORD *)v22 - 1) = v26;
        v22 -= 4;
        v24 -= 32;
      }
      while (v24 != v25);
      v24 = (char *)*a1;
    }
    *a1 = v22;
    a1[1] = v16;
    a1[2] = (void *)v23;
    if (v24)
      operator delete(v24);
  }
  else
  {
    *v4 = CFSTR("Wind Flag");
    v4[1] = 0x800000000000;
    v4[2] = 0x3F80000000000000;
    v4[3] = 0xFFFFFFFF00000000;
    v16 = v4 + 4;
  }
  a1[1] = v16;
  v27 = (unint64_t)a1[2];
  if ((unint64_t)v16 >= v27)
  {
    v29 = ((char *)v16 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v29 + 1) >> 59)
      goto LABEL_867;
    v30 = v27 - (_QWORD)*a1;
    v31 = v30 >> 4;
    if (v30 >> 4 <= (unint64_t)(v29 + 1))
      v31 = v29 + 1;
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFE0)
      v32 = 0x7FFFFFFFFFFFFFFLL;
    else
      v32 = v31;
    if (v32)
      v32 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v32);
    else
      v33 = 0;
    v34 = (_QWORD *)(v32 + 32 * v29);
    v35 = v32 + 32 * v33;
    *v34 = CFSTR("Downlink SPP Threshold");
    v34[1] = 0x8400000000000000;
    v34[2] = 0x3F80000000000000;
    v34[3] = -3241358131;
    v28 = v34 + 4;
    v37 = (char *)*a1;
    v36 = (char *)a1[1];
    if (v36 != *a1)
    {
      do
      {
        v38 = *((_OWORD *)v36 - 1);
        *((_OWORD *)v34 - 2) = *((_OWORD *)v36 - 2);
        *((_OWORD *)v34 - 1) = v38;
        v34 -= 4;
        v36 -= 32;
      }
      while (v36 != v37);
      v36 = (char *)*a1;
    }
    *a1 = v34;
    a1[1] = v28;
    a1[2] = (void *)v35;
    if (v36)
      operator delete(v36);
  }
  else
  {
    *v16 = CFSTR("Downlink SPP Threshold");
    v16[1] = 0x8400000000000000;
    v16[2] = 0x3F80000000000000;
    v16[3] = -3241358131;
    v28 = v16 + 4;
  }
  a1[1] = v28;
  v39 = (unint64_t)a1[2];
  if ((unint64_t)v28 >= v39)
  {
    v41 = ((char *)v28 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v41 + 1) >> 59)
      goto LABEL_867;
    v42 = v39 - (_QWORD)*a1;
    v43 = v42 >> 4;
    if (v42 >> 4 <= (unint64_t)(v41 + 1))
      v43 = v41 + 1;
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFE0)
      v44 = 0x7FFFFFFFFFFFFFFLL;
    else
      v44 = v43;
    if (v44)
      v44 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v44);
    else
      v45 = 0;
    v46 = (_QWORD *)(v44 + 32 * v41);
    v47 = v44 + 32 * v45;
    *v46 = CFSTR("Filter Bank Type");
    v46[1] = 0x8400000000000001;
    v46[2] = 0x3F80000000000000;
    v46[3] = 0x100000000;
    v40 = v46 + 4;
    v49 = (char *)*a1;
    v48 = (char *)a1[1];
    if (v48 != *a1)
    {
      do
      {
        v50 = *((_OWORD *)v48 - 1);
        *((_OWORD *)v46 - 2) = *((_OWORD *)v48 - 2);
        *((_OWORD *)v46 - 1) = v50;
        v46 -= 4;
        v48 -= 32;
      }
      while (v48 != v49);
      v48 = (char *)*a1;
    }
    *a1 = v46;
    a1[1] = v40;
    a1[2] = (void *)v47;
    if (v48)
      operator delete(v48);
  }
  else
  {
    *v28 = CFSTR("Filter Bank Type");
    v28[1] = 0x8400000000000001;
    v28[2] = 0x3F80000000000000;
    v28[3] = 0x100000000;
    v40 = v28 + 4;
  }
  a1[1] = v40;
  v51 = (unint64_t)a1[2];
  if ((unint64_t)v40 >= v51)
  {
    v53 = ((char *)v40 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v53 + 1) >> 59)
      goto LABEL_867;
    v54 = v51 - (_QWORD)*a1;
    v55 = v54 >> 4;
    if (v54 >> 4 <= (unint64_t)(v53 + 1))
      v55 = v53 + 1;
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFE0)
      v56 = 0x7FFFFFFFFFFFFFFLL;
    else
      v56 = v55;
    if (v56)
      v56 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v56);
    else
      v57 = 0;
    v58 = (_QWORD *)(v56 + 32 * v53);
    v59 = v56 + 32 * v57;
    *v58 = CFSTR("Interpolation Type");
    v58[1] = 0x8400000000000001;
    v58[2] = 0x3F80000000000000;
    v58[3] = 0x100000000;
    v52 = v58 + 4;
    v61 = (char *)*a1;
    v60 = (char *)a1[1];
    if (v60 != *a1)
    {
      do
      {
        v62 = *((_OWORD *)v60 - 1);
        *((_OWORD *)v58 - 2) = *((_OWORD *)v60 - 2);
        *((_OWORD *)v58 - 1) = v62;
        v58 -= 4;
        v60 -= 32;
      }
      while (v60 != v61);
      v60 = (char *)*a1;
    }
    *a1 = v58;
    a1[1] = v52;
    a1[2] = (void *)v59;
    if (v60)
      operator delete(v60);
  }
  else
  {
    *v40 = CFSTR("Interpolation Type");
    v40[1] = 0x8400000000000001;
    v40[2] = 0x3F80000000000000;
    v40[3] = 0x100000000;
    v52 = v40 + 4;
  }
  a1[1] = v52;
  v63 = (unint64_t)a1[2];
  if ((unint64_t)v52 >= v63)
  {
    v65 = ((char *)v52 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v65 + 1) >> 59)
      goto LABEL_867;
    v66 = v63 - (_QWORD)*a1;
    v67 = v66 >> 4;
    if (v66 >> 4 <= (unint64_t)(v65 + 1))
      v67 = v65 + 1;
    if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFE0)
      v68 = 0x7FFFFFFFFFFFFFFLL;
    else
      v68 = v67;
    if (v68)
      v68 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v68);
    else
      v69 = 0;
    v70 = (_QWORD *)(v68 + 32 * v65);
    v71 = v68 + 32 * v69;
    *v70 = CFSTR("Loud Speaker Calibration");
    v70[1] = 0x800000000000000DLL;
    v70[2] = 0x43160000C2480000;
    v70[3] = 0x242B40000;
    v64 = v70 + 4;
    v73 = (char *)*a1;
    v72 = (char *)a1[1];
    if (v72 != *a1)
    {
      do
      {
        v74 = *((_OWORD *)v72 - 1);
        *((_OWORD *)v70 - 2) = *((_OWORD *)v72 - 2);
        *((_OWORD *)v70 - 1) = v74;
        v70 -= 4;
        v72 -= 32;
      }
      while (v72 != v73);
      v72 = (char *)*a1;
    }
    *a1 = v70;
    a1[1] = v64;
    a1[2] = (void *)v71;
    if (v72)
      operator delete(v72);
  }
  else
  {
    *v52 = CFSTR("Loud Speaker Calibration");
    v52[1] = 0x800000000000000DLL;
    v52[2] = 0x43160000C2480000;
    v52[3] = 0x242B40000;
    v64 = v52 + 4;
  }
  a1[1] = v64;
  v75 = (unint64_t)a1[2];
  if ((unint64_t)v64 >= v75)
  {
    v77 = ((char *)v64 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v77 + 1) >> 59)
      goto LABEL_867;
    v78 = v75 - (_QWORD)*a1;
    v79 = v78 >> 4;
    if (v78 >> 4 <= (unint64_t)(v77 + 1))
      v79 = v77 + 1;
    if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFE0)
      v80 = 0x7FFFFFFFFFFFFFFLL;
    else
      v80 = v79;
    if (v80)
      v80 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v80);
    else
      v81 = 0;
    v82 = (_QWORD *)(v80 + 32 * v77);
    v83 = v80 + 32 * v81;
    *v82 = CFSTR("Signal Power Smoothing Time");
    v82[1] = 0x8000000000000004;
    v82[2] = 0x4120000000000000;
    v82[3] = 0x240A00000;
    v76 = v82 + 4;
    v85 = (char *)*a1;
    v84 = (char *)a1[1];
    if (v84 != *a1)
    {
      do
      {
        v86 = *((_OWORD *)v84 - 1);
        *((_OWORD *)v82 - 2) = *((_OWORD *)v84 - 2);
        *((_OWORD *)v82 - 1) = v86;
        v82 -= 4;
        v84 -= 32;
      }
      while (v84 != v85);
      v84 = (char *)*a1;
    }
    *a1 = v82;
    a1[1] = v76;
    a1[2] = (void *)v83;
    if (v84)
      operator delete(v84);
  }
  else
  {
    *v64 = CFSTR("Signal Power Smoothing Time");
    v64[1] = 0x8000000000000004;
    v64[2] = 0x4120000000000000;
    v64[3] = 0x240A00000;
    v76 = v64 + 4;
  }
  a1[1] = v76;
  v87 = (unint64_t)a1[2];
  if ((unint64_t)v76 >= v87)
  {
    v89 = ((char *)v76 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v89 + 1) >> 59)
      goto LABEL_867;
    v90 = v87 - (_QWORD)*a1;
    v91 = v90 >> 4;
    if (v90 >> 4 <= (unint64_t)(v89 + 1))
      v91 = v89 + 1;
    if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFE0)
      v92 = 0x7FFFFFFFFFFFFFFLL;
    else
      v92 = v91;
    if (v92)
      v92 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v92);
    else
      v93 = 0;
    v94 = (_QWORD *)(v92 + 32 * v89);
    v95 = v92 + 32 * v93;
    *v94 = CFSTR("Noise Power Attack Time");
    v94[1] = 0x8000000000000004;
    v94[2] = 0x4120000000000000;
    v94[3] = 0x23FC00000;
    v88 = v94 + 4;
    v97 = (char *)*a1;
    v96 = (char *)a1[1];
    if (v96 != *a1)
    {
      do
      {
        v98 = *((_OWORD *)v96 - 1);
        *((_OWORD *)v94 - 2) = *((_OWORD *)v96 - 2);
        *((_OWORD *)v94 - 1) = v98;
        v94 -= 4;
        v96 -= 32;
      }
      while (v96 != v97);
      v96 = (char *)*a1;
    }
    *a1 = v94;
    a1[1] = v88;
    a1[2] = (void *)v95;
    if (v96)
      operator delete(v96);
  }
  else
  {
    *v76 = CFSTR("Noise Power Attack Time");
    v76[1] = 0x8000000000000004;
    v76[2] = 0x4120000000000000;
    v76[3] = 0x23FC00000;
    v88 = v76 + 4;
  }
  a1[1] = v88;
  v99 = (unint64_t)a1[2];
  if ((unint64_t)v88 >= v99)
  {
    v101 = ((char *)v88 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v101 + 1) >> 59)
      goto LABEL_867;
    v102 = v99 - (_QWORD)*a1;
    v103 = v102 >> 4;
    if (v102 >> 4 <= (unint64_t)(v101 + 1))
      v103 = v101 + 1;
    if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFE0)
      v104 = 0x7FFFFFFFFFFFFFFLL;
    else
      v104 = v103;
    if (v104)
      v104 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v104);
    else
      v105 = 0;
    v106 = (_QWORD *)(v104 + 32 * v101);
    v107 = v104 + 32 * v105;
    *v106 = CFSTR("Noise Power Release Time");
    v106[1] = 0x8000000000000004;
    v106[2] = 0x4120000000000000;
    v106[3] = 0x23F000000;
    v100 = v106 + 4;
    v109 = (char *)*a1;
    v108 = (char *)a1[1];
    if (v108 != *a1)
    {
      do
      {
        v110 = *((_OWORD *)v108 - 1);
        *((_OWORD *)v106 - 2) = *((_OWORD *)v108 - 2);
        *((_OWORD *)v106 - 1) = v110;
        v106 -= 4;
        v108 -= 32;
      }
      while (v108 != v109);
      v108 = (char *)*a1;
    }
    *a1 = v106;
    a1[1] = v100;
    a1[2] = (void *)v107;
    if (v108)
      operator delete(v108);
  }
  else
  {
    *v88 = CFSTR("Noise Power Release Time");
    v88[1] = 0x8000000000000004;
    v88[2] = 0x4120000000000000;
    v88[3] = 0x23F000000;
    v100 = v88 + 4;
  }
  a1[1] = v100;
  v111 = (unint64_t)a1[2];
  if ((unint64_t)v100 >= v111)
  {
    v113 = ((char *)v100 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v113 + 1) >> 59)
      goto LABEL_867;
    v114 = v111 - (_QWORD)*a1;
    v115 = v114 >> 4;
    if (v114 >> 4 <= (unint64_t)(v113 + 1))
      v115 = v113 + 1;
    if ((unint64_t)v114 >= 0x7FFFFFFFFFFFFFE0)
      v116 = 0x7FFFFFFFFFFFFFFLL;
    else
      v116 = v115;
    if (v116)
      v116 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v116);
    else
      v117 = 0;
    v118 = (_QWORD *)(v116 + 32 * v113);
    v119 = v116 + 32 * v117;
    *v118 = CFSTR("Environmental Noise Power (dBA)");
    v118[1] = 0x80000000000DLL;
    v118[2] = 0x43020000C0A00000;
    v118[3] = 0x241A00000;
    v112 = v118 + 4;
    v121 = (char *)*a1;
    v120 = (char *)a1[1];
    if (v120 != *a1)
    {
      do
      {
        v122 = *((_OWORD *)v120 - 1);
        *((_OWORD *)v118 - 2) = *((_OWORD *)v120 - 2);
        *((_OWORD *)v118 - 1) = v122;
        v118 -= 4;
        v120 -= 32;
      }
      while (v120 != v121);
      v120 = (char *)*a1;
    }
    *a1 = v118;
    a1[1] = v112;
    a1[2] = (void *)v119;
    if (v120)
      operator delete(v120);
  }
  else
  {
    *v100 = CFSTR("Environmental Noise Power (dBA)");
    v100[1] = 0x80000000000DLL;
    v100[2] = 0x43020000C0A00000;
    v100[3] = 0x241A00000;
    v112 = v100 + 4;
  }
  a1[1] = v112;
  v123 = (unint64_t)a1[2];
  if ((unint64_t)v112 >= v123)
  {
    v125 = ((char *)v112 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v125 + 1) >> 59)
      goto LABEL_867;
    v126 = v123 - (_QWORD)*a1;
    v127 = v126 >> 4;
    if (v126 >> 4 <= (unint64_t)(v125 + 1))
      v127 = v125 + 1;
    if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFE0)
      v128 = 0x7FFFFFFFFFFFFFFLL;
    else
      v128 = v127;
    if (v128)
      v128 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v128);
    else
      v129 = 0;
    v130 = (_QWORD *)(v128 + 32 * v125);
    v131 = v128 + 32 * v129;
    *v130 = CFSTR("Auto Volume Low Noise");
    v130[1] = 0x800000000000000DLL;
    v130[2] = 0x42F0000000000000;
    v130[3] = 0x342480000;
    v124 = v130 + 4;
    v133 = (char *)*a1;
    v132 = (char *)a1[1];
    if (v132 != *a1)
    {
      do
      {
        v134 = *((_OWORD *)v132 - 1);
        *((_OWORD *)v130 - 2) = *((_OWORD *)v132 - 2);
        *((_OWORD *)v130 - 1) = v134;
        v130 -= 4;
        v132 -= 32;
      }
      while (v132 != v133);
      v132 = (char *)*a1;
    }
    *a1 = v130;
    a1[1] = v124;
    a1[2] = (void *)v131;
    if (v132)
      operator delete(v132);
  }
  else
  {
    *v112 = CFSTR("Auto Volume Low Noise");
    v112[1] = 0x800000000000000DLL;
    v112[2] = 0x42F0000000000000;
    v112[3] = 0x342480000;
    v124 = v112 + 4;
  }
  a1[1] = v124;
  v135 = (unint64_t)a1[2];
  if ((unint64_t)v124 >= v135)
  {
    v137 = ((char *)v124 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v137 + 1) >> 59)
      goto LABEL_867;
    v138 = v135 - (_QWORD)*a1;
    v139 = v138 >> 4;
    if (v138 >> 4 <= (unint64_t)(v137 + 1))
      v139 = v137 + 1;
    if ((unint64_t)v138 >= 0x7FFFFFFFFFFFFFE0)
      v140 = 0x7FFFFFFFFFFFFFFLL;
    else
      v140 = v139;
    if (v140)
      v140 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v140);
    else
      v141 = 0;
    v142 = (_QWORD *)(v140 + 32 * v137);
    v143 = v140 + 32 * v141;
    *v142 = CFSTR("Auto Volume High Noise");
    v142[1] = 0x800000000000000DLL;
    v142[2] = 0x42F0000000000000;
    v142[3] = 0x342C80000;
    v136 = v142 + 4;
    v145 = (char *)*a1;
    v144 = (char *)a1[1];
    if (v144 != *a1)
    {
      do
      {
        v146 = *((_OWORD *)v144 - 1);
        *((_OWORD *)v142 - 2) = *((_OWORD *)v144 - 2);
        *((_OWORD *)v142 - 1) = v146;
        v142 -= 4;
        v144 -= 32;
      }
      while (v144 != v145);
      v144 = (char *)*a1;
    }
    *a1 = v142;
    a1[1] = v136;
    a1[2] = (void *)v143;
    if (v144)
      operator delete(v144);
  }
  else
  {
    *v124 = CFSTR("Auto Volume High Noise");
    v124[1] = 0x800000000000000DLL;
    v124[2] = 0x42F0000000000000;
    v124[3] = 0x342C80000;
    v136 = v124 + 4;
  }
  a1[1] = v136;
  v147 = (unint64_t)a1[2];
  if ((unint64_t)v136 >= v147)
  {
    v149 = ((char *)v136 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v149 + 1) >> 59)
      goto LABEL_867;
    v150 = v147 - (_QWORD)*a1;
    v151 = v150 >> 4;
    if (v150 >> 4 <= (unint64_t)(v149 + 1))
      v151 = v149 + 1;
    if ((unint64_t)v150 >= 0x7FFFFFFFFFFFFFE0)
      v152 = 0x7FFFFFFFFFFFFFFLL;
    else
      v152 = v151;
    if (v152)
      v152 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v152);
    else
      v153 = 0;
    v154 = (_QWORD *)(v152 + 32 * v149);
    v155 = v152 + 32 * v153;
    *v154 = CFSTR("Auto Volume Low Slope");
    v154[1] = 0x8000000000000000;
    v154[2] = 0x3F80000000000000;
    v154[3] = 0x33EA8F5C3;
    v148 = v154 + 4;
    v157 = (char *)*a1;
    v156 = (char *)a1[1];
    if (v156 != *a1)
    {
      do
      {
        v158 = *((_OWORD *)v156 - 1);
        *((_OWORD *)v154 - 2) = *((_OWORD *)v156 - 2);
        *((_OWORD *)v154 - 1) = v158;
        v154 -= 4;
        v156 -= 32;
      }
      while (v156 != v157);
      v156 = (char *)*a1;
    }
    *a1 = v154;
    a1[1] = v148;
    a1[2] = (void *)v155;
    if (v156)
      operator delete(v156);
  }
  else
  {
    *v136 = CFSTR("Auto Volume Low Slope");
    v136[1] = 0x8000000000000000;
    v136[2] = 0x3F80000000000000;
    v136[3] = 0x33EA8F5C3;
    v148 = v136 + 4;
  }
  a1[1] = v148;
  v159 = (unint64_t)a1[2];
  if ((unint64_t)v148 >= v159)
  {
    v161 = ((char *)v148 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v161 + 1) >> 59)
      goto LABEL_867;
    v162 = v159 - (_QWORD)*a1;
    v163 = v162 >> 4;
    if (v162 >> 4 <= (unint64_t)(v161 + 1))
      v163 = v161 + 1;
    if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFE0)
      v164 = 0x7FFFFFFFFFFFFFFLL;
    else
      v164 = v163;
    if (v164)
      v164 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v164);
    else
      v165 = 0;
    v166 = (_QWORD *)(v164 + 32 * v161);
    v167 = v164 + 32 * v165;
    *v166 = CFSTR("Auto Volume High Slope");
    v166[1] = 0x8000000000000000;
    v166[2] = 0x3F80000000000000;
    v166[3] = 0x33F4CCCCDLL;
    v160 = v166 + 4;
    v169 = (char *)*a1;
    v168 = (char *)a1[1];
    if (v168 != *a1)
    {
      do
      {
        v170 = *((_OWORD *)v168 - 1);
        *((_OWORD *)v166 - 2) = *((_OWORD *)v168 - 2);
        *((_OWORD *)v166 - 1) = v170;
        v166 -= 4;
        v168 -= 32;
      }
      while (v168 != v169);
      v168 = (char *)*a1;
    }
    *a1 = v166;
    a1[1] = v160;
    a1[2] = (void *)v167;
    if (v168)
      operator delete(v168);
  }
  else
  {
    *v148 = CFSTR("Auto Volume High Slope");
    v148[1] = 0x8000000000000000;
    v148[2] = 0x3F80000000000000;
    v148[3] = 0x33F4CCCCDLL;
    v160 = v148 + 4;
  }
  a1[1] = v160;
  v171 = (unint64_t)a1[2];
  if ((unint64_t)v160 >= v171)
  {
    v173 = ((char *)v160 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v173 + 1) >> 59)
      goto LABEL_867;
    v174 = v171 - (_QWORD)*a1;
    v175 = v174 >> 4;
    if (v174 >> 4 <= (unint64_t)(v173 + 1))
      v175 = v173 + 1;
    if ((unint64_t)v174 >= 0x7FFFFFFFFFFFFFE0)
      v176 = 0x7FFFFFFFFFFFFFFLL;
    else
      v176 = v175;
    if (v176)
      v176 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v176);
    else
      v177 = 0;
    v178 = (_QWORD *)(v176 + 32 * v173);
    v179 = v176 + 32 * v177;
    *v178 = CFSTR("Total Volume Max Gain");
    v178[1] = 0x800000000000000DLL;
    v178[2] = 0x41700000C1200000;
    v178[3] = 0x300000000;
    v172 = v178 + 4;
    v181 = (char *)*a1;
    v180 = (char *)a1[1];
    if (v180 != *a1)
    {
      do
      {
        v182 = *((_OWORD *)v180 - 1);
        *((_OWORD *)v178 - 2) = *((_OWORD *)v180 - 2);
        *((_OWORD *)v178 - 1) = v182;
        v178 -= 4;
        v180 -= 32;
      }
      while (v180 != v181);
      v180 = (char *)*a1;
    }
    *a1 = v178;
    a1[1] = v172;
    a1[2] = (void *)v179;
    if (v180)
      operator delete(v180);
  }
  else
  {
    *v160 = CFSTR("Total Volume Max Gain");
    v160[1] = 0x800000000000000DLL;
    v160[2] = 0x41700000C1200000;
    v160[3] = 0x300000000;
    v172 = v160 + 4;
  }
  a1[1] = v172;
  v183 = (unint64_t)a1[2];
  if ((unint64_t)v172 >= v183)
  {
    v185 = ((char *)v172 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v185 + 1) >> 59)
      goto LABEL_867;
    v186 = v183 - (_QWORD)*a1;
    v187 = v186 >> 4;
    if (v186 >> 4 <= (unint64_t)(v185 + 1))
      v187 = v185 + 1;
    if ((unint64_t)v186 >= 0x7FFFFFFFFFFFFFE0)
      v188 = 0x7FFFFFFFFFFFFFFLL;
    else
      v188 = v187;
    if (v188)
      v188 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v188);
    else
      v189 = 0;
    v190 = (_QWORD *)(v188 + 32 * v185);
    v191 = v188 + 32 * v189;
    *v190 = CFSTR("Pre Auto Volume SNR (dBA)");
    v190[1] = 0x80000000000DLL;
    v190[2] = 0x42480000C2480000;
    v190[3] = 0x300000000;
    v184 = v190 + 4;
    v193 = (char *)*a1;
    v192 = (char *)a1[1];
    if (v192 != *a1)
    {
      do
      {
        v194 = *((_OWORD *)v192 - 1);
        *((_OWORD *)v190 - 2) = *((_OWORD *)v192 - 2);
        *((_OWORD *)v190 - 1) = v194;
        v190 -= 4;
        v192 -= 32;
      }
      while (v192 != v193);
      v192 = (char *)*a1;
    }
    *a1 = v190;
    a1[1] = v184;
    a1[2] = (void *)v191;
    if (v192)
      operator delete(v192);
  }
  else
  {
    *v172 = CFSTR("Pre Auto Volume SNR (dBA)");
    v172[1] = 0x80000000000DLL;
    v172[2] = 0x42480000C2480000;
    v172[3] = 0x300000000;
    v184 = v172 + 4;
  }
  a1[1] = v184;
  v195 = (unint64_t)a1[2];
  if ((unint64_t)v184 >= v195)
  {
    v197 = ((char *)v184 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v197 + 1) >> 59)
      goto LABEL_867;
    v198 = v195 - (_QWORD)*a1;
    v199 = v198 >> 4;
    if (v198 >> 4 <= (unint64_t)(v197 + 1))
      v199 = v197 + 1;
    if ((unint64_t)v198 >= 0x7FFFFFFFFFFFFFE0)
      v200 = 0x7FFFFFFFFFFFFFFLL;
    else
      v200 = v199;
    if (v200)
      v200 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v200);
    else
      v201 = 0;
    v202 = (_QWORD *)(v200 + 32 * v197);
    v203 = v200 + 32 * v201;
    *v202 = CFSTR("Current Auto Volume Gain");
    v202[1] = 0x80000000000DLL;
    v202[2] = 0x41F00000C0A00000;
    v202[3] = 0x300000000;
    v196 = v202 + 4;
    v205 = (char *)*a1;
    v204 = (char *)a1[1];
    if (v204 != *a1)
    {
      do
      {
        v206 = *((_OWORD *)v204 - 1);
        *((_OWORD *)v202 - 2) = *((_OWORD *)v204 - 2);
        *((_OWORD *)v202 - 1) = v206;
        v202 -= 4;
        v204 -= 32;
      }
      while (v204 != v205);
      v204 = (char *)*a1;
    }
    *a1 = v202;
    a1[1] = v196;
    a1[2] = (void *)v203;
    if (v204)
      operator delete(v204);
  }
  else
  {
    *v184 = CFSTR("Current Auto Volume Gain");
    v184[1] = 0x80000000000DLL;
    v184[2] = 0x41F00000C0A00000;
    v184[3] = 0x300000000;
    v196 = v184 + 4;
  }
  a1[1] = v196;
  v207 = (unint64_t)a1[2];
  if ((unint64_t)v196 >= v207)
  {
    v209 = ((char *)v196 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v209 + 1) >> 59)
      goto LABEL_867;
    v210 = v207 - (_QWORD)*a1;
    v211 = v210 >> 4;
    if (v210 >> 4 <= (unint64_t)(v209 + 1))
      v211 = v209 + 1;
    if ((unint64_t)v210 >= 0x7FFFFFFFFFFFFFE0)
      v212 = 0x7FFFFFFFFFFFFFFLL;
    else
      v212 = v211;
    if (v212)
      v212 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v212);
    else
      v213 = 0;
    v214 = (_QWORD *)(v212 + 32 * v209);
    v215 = v212 + 32 * v213;
    *v214 = CFSTR("Bypass Auto EQ");
    v214[1] = 0x8000000000000002;
    v214[2] = 0x3F80000000000000;
    v214[3] = 0x400000000;
    v208 = v214 + 4;
    v217 = (char *)*a1;
    v216 = (char *)a1[1];
    if (v216 != *a1)
    {
      do
      {
        v218 = *((_OWORD *)v216 - 1);
        *((_OWORD *)v214 - 2) = *((_OWORD *)v216 - 2);
        *((_OWORD *)v214 - 1) = v218;
        v214 -= 4;
        v216 -= 32;
      }
      while (v216 != v217);
      v216 = (char *)*a1;
    }
    *a1 = v214;
    a1[1] = v208;
    a1[2] = (void *)v215;
    if (v216)
      operator delete(v216);
  }
  else
  {
    *v196 = CFSTR("Bypass Auto EQ");
    v196[1] = 0x8000000000000002;
    v196[2] = 0x3F80000000000000;
    v196[3] = 0x400000000;
    v208 = v196 + 4;
  }
  a1[1] = v208;
  v219 = (unint64_t)a1[2];
  if ((unint64_t)v208 >= v219)
  {
    v221 = ((char *)v208 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v221 + 1) >> 59)
      goto LABEL_867;
    v222 = v219 - (_QWORD)*a1;
    v223 = v222 >> 4;
    if (v222 >> 4 <= (unint64_t)(v221 + 1))
      v223 = v221 + 1;
    if ((unint64_t)v222 >= 0x7FFFFFFFFFFFFFE0)
      v224 = 0x7FFFFFFFFFFFFFFLL;
    else
      v224 = v223;
    if (v224)
      v224 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v224);
    else
      v225 = 0;
    v226 = (_QWORD *)(v224 + 32 * v221);
    v227 = v224 + 32 * v225;
    *v226 = CFSTR("EQ Bandwidth");
    v226[1] = 0x8000000000000008;
    v226[2] = 0x469C400042C80000;
    v226[3] = 0x445FA0000;
    v220 = v226 + 4;
    v229 = (char *)*a1;
    v228 = (char *)a1[1];
    if (v228 != *a1)
    {
      do
      {
        v230 = *((_OWORD *)v228 - 1);
        *((_OWORD *)v226 - 2) = *((_OWORD *)v228 - 2);
        *((_OWORD *)v226 - 1) = v230;
        v226 -= 4;
        v228 -= 32;
      }
      while (v228 != v229);
      v228 = (char *)*a1;
    }
    *a1 = v226;
    a1[1] = v220;
    a1[2] = (void *)v227;
    if (v228)
      operator delete(v228);
  }
  else
  {
    *v208 = CFSTR("EQ Bandwidth");
    v208[1] = 0x8000000000000008;
    v208[2] = 0x469C400042C80000;
    v208[3] = 0x445FA0000;
    v220 = v208 + 4;
  }
  a1[1] = v220;
  v231 = (unint64_t)a1[2];
  if ((unint64_t)v220 >= v231)
  {
    v233 = ((char *)v220 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v233 + 1) >> 59)
      goto LABEL_867;
    v234 = v231 - (_QWORD)*a1;
    v235 = v234 >> 4;
    if (v234 >> 4 <= (unint64_t)(v233 + 1))
      v235 = v233 + 1;
    if ((unint64_t)v234 >= 0x7FFFFFFFFFFFFFE0)
      v236 = 0x7FFFFFFFFFFFFFFLL;
    else
      v236 = v235;
    if (v236)
      v236 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v236);
    else
      v237 = 0;
    v238 = (_QWORD *)(v236 + 32 * v233);
    v239 = v236 + 32 * v237;
    *v238 = CFSTR("Regularization High SNR");
    v238[1] = 0x800000000000000DLL;
    v238[2] = 0x4248000040A00000;
    v238[3] = 0x441200000;
    v232 = v238 + 4;
    v241 = (char *)*a1;
    v240 = (char *)a1[1];
    if (v240 != *a1)
    {
      do
      {
        v242 = *((_OWORD *)v240 - 1);
        *((_OWORD *)v238 - 2) = *((_OWORD *)v240 - 2);
        *((_OWORD *)v238 - 1) = v242;
        v238 -= 4;
        v240 -= 32;
      }
      while (v240 != v241);
      v240 = (char *)*a1;
    }
    *a1 = v238;
    a1[1] = v232;
    a1[2] = (void *)v239;
    if (v240)
      operator delete(v240);
  }
  else
  {
    *v220 = CFSTR("Regularization High SNR");
    v220[1] = 0x800000000000000DLL;
    v220[2] = 0x4248000040A00000;
    v220[3] = 0x441200000;
    v232 = v220 + 4;
  }
  a1[1] = v232;
  v243 = (unint64_t)a1[2];
  if ((unint64_t)v232 >= v243)
  {
    v245 = ((char *)v232 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v245 + 1) >> 59)
      goto LABEL_867;
    v246 = v243 - (_QWORD)*a1;
    v247 = v246 >> 4;
    if (v246 >> 4 <= (unint64_t)(v245 + 1))
      v247 = v245 + 1;
    if ((unint64_t)v246 >= 0x7FFFFFFFFFFFFFE0)
      v248 = 0x7FFFFFFFFFFFFFFLL;
    else
      v248 = v247;
    if (v248)
      v248 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v248);
    else
      v249 = 0;
    v250 = (_QWORD *)(v248 + 32 * v245);
    v251 = v248 + 32 * v249;
    *v250 = CFSTR("EQ Min Gain (low freq)");
    v250[1] = 0x800000000000000DLL;
    v250[2] = 3248488448;
    v250[3] = 0x4C0A00000;
    v244 = v250 + 4;
    v253 = (char *)*a1;
    v252 = (char *)a1[1];
    if (v252 != *a1)
    {
      do
      {
        v254 = *((_OWORD *)v252 - 1);
        *((_OWORD *)v250 - 2) = *((_OWORD *)v252 - 2);
        *((_OWORD *)v250 - 1) = v254;
        v250 -= 4;
        v252 -= 32;
      }
      while (v252 != v253);
      v252 = (char *)*a1;
    }
    *a1 = v250;
    a1[1] = v244;
    a1[2] = (void *)v251;
    if (v252)
      operator delete(v252);
  }
  else
  {
    *v232 = CFSTR("EQ Min Gain (low freq)");
    v232[1] = 0x800000000000000DLL;
    v232[2] = 3248488448;
    v232[3] = 0x4C0A00000;
    v244 = v232 + 4;
  }
  a1[1] = v244;
  v255 = (unint64_t)a1[2];
  if ((unint64_t)v244 >= v255)
  {
    v257 = ((char *)v244 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v257 + 1) >> 59)
      goto LABEL_867;
    v258 = v255 - (_QWORD)*a1;
    v259 = v258 >> 4;
    if (v258 >> 4 <= (unint64_t)(v257 + 1))
      v259 = v257 + 1;
    if ((unint64_t)v258 >= 0x7FFFFFFFFFFFFFE0)
      v260 = 0x7FFFFFFFFFFFFFFLL;
    else
      v260 = v259;
    if (v260)
      v260 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v260);
    else
      v261 = 0;
    v262 = (_QWORD *)(v260 + 32 * v257);
    v263 = v260 + 32 * v261;
    *v262 = CFSTR("EQ Max Gain (low freq)");
    v262[1] = 0x800000000000000DLL;
    v262[2] = 0x41A0000000000000;
    v262[3] = 0x441200000;
    v256 = v262 + 4;
    v265 = (char *)*a1;
    v264 = (char *)a1[1];
    if (v264 != *a1)
    {
      do
      {
        v266 = *((_OWORD *)v264 - 1);
        *((_OWORD *)v262 - 2) = *((_OWORD *)v264 - 2);
        *((_OWORD *)v262 - 1) = v266;
        v262 -= 4;
        v264 -= 32;
      }
      while (v264 != v265);
      v264 = (char *)*a1;
    }
    *a1 = v262;
    a1[1] = v256;
    a1[2] = (void *)v263;
    if (v264)
      operator delete(v264);
  }
  else
  {
    *v244 = CFSTR("EQ Max Gain (low freq)");
    v244[1] = 0x800000000000000DLL;
    v244[2] = 0x41A0000000000000;
    v244[3] = 0x441200000;
    v256 = v244 + 4;
  }
  a1[1] = v256;
  v267 = (unint64_t)a1[2];
  if ((unint64_t)v256 >= v267)
  {
    v269 = ((char *)v256 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v269 + 1) >> 59)
      goto LABEL_867;
    v270 = v267 - (_QWORD)*a1;
    v271 = v270 >> 4;
    if (v270 >> 4 <= (unint64_t)(v269 + 1))
      v271 = v269 + 1;
    if ((unint64_t)v270 >= 0x7FFFFFFFFFFFFFE0)
      v272 = 0x7FFFFFFFFFFFFFFLL;
    else
      v272 = v271;
    if (v272)
      v272 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v272);
    else
      v273 = 0;
    v274 = (_QWORD *)(v272 + 32 * v269);
    v275 = v272 + 32 * v273;
    *v274 = CFSTR("Pre EQ Signal Power (dBA)");
    v274[1] = 0x80000000000DLL;
    v274[2] = 0x43020000C0A00000;
    v274[3] = 0x441A00000;
    v268 = v274 + 4;
    v277 = (char *)*a1;
    v276 = (char *)a1[1];
    if (v276 != *a1)
    {
      do
      {
        v278 = *((_OWORD *)v276 - 1);
        *((_OWORD *)v274 - 2) = *((_OWORD *)v276 - 2);
        *((_OWORD *)v274 - 1) = v278;
        v274 -= 4;
        v276 -= 32;
      }
      while (v276 != v277);
      v276 = (char *)*a1;
    }
    *a1 = v274;
    a1[1] = v268;
    a1[2] = (void *)v275;
    if (v276)
      operator delete(v276);
  }
  else
  {
    *v256 = CFSTR("Pre EQ Signal Power (dBA)");
    v256[1] = 0x80000000000DLL;
    v256[2] = 0x43020000C0A00000;
    v256[3] = 0x441A00000;
    v268 = v256 + 4;
  }
  a1[1] = v268;
  v279 = (unint64_t)a1[2];
  if ((unint64_t)v268 >= v279)
  {
    v281 = ((char *)v268 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v281 + 1) >> 59)
      goto LABEL_867;
    v282 = v279 - (_QWORD)*a1;
    v283 = v282 >> 4;
    if (v282 >> 4 <= (unint64_t)(v281 + 1))
      v283 = v281 + 1;
    if ((unint64_t)v282 >= 0x7FFFFFFFFFFFFFE0)
      v284 = 0x7FFFFFFFFFFFFFFLL;
    else
      v284 = v283;
    if (v284)
      v284 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v284);
    else
      v285 = 0;
    v286 = (_QWORD *)(v284 + 32 * v281);
    v287 = v284 + 32 * v285;
    *v286 = CFSTR("Num Iterations to Converge EQ");
    v286[1] = 0x400800000000000;
    v286[2] = 0x4348000000000000;
    v286[3] = 0x400000000;
    v280 = v286 + 4;
    v289 = (char *)*a1;
    v288 = (char *)a1[1];
    if (v288 != *a1)
    {
      do
      {
        v290 = *((_OWORD *)v288 - 1);
        *((_OWORD *)v286 - 2) = *((_OWORD *)v288 - 2);
        *((_OWORD *)v286 - 1) = v290;
        v286 -= 4;
        v288 -= 32;
      }
      while (v288 != v289);
      v288 = (char *)*a1;
    }
    *a1 = v286;
    a1[1] = v280;
    a1[2] = (void *)v287;
    if (v288)
      operator delete(v288);
  }
  else
  {
    *v268 = CFSTR("Num Iterations to Converge EQ");
    v268[1] = 0x400800000000000;
    v268[2] = 0x4348000000000000;
    v268[3] = 0x400000000;
    v280 = v268 + 4;
  }
  a1[1] = v280;
  v291 = (unint64_t)a1[2];
  if ((unint64_t)v280 >= v291)
  {
    v293 = ((char *)v280 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v293 + 1) >> 59)
      goto LABEL_867;
    v294 = v291 - (_QWORD)*a1;
    v295 = v294 >> 4;
    if (v294 >> 4 <= (unint64_t)(v293 + 1))
      v295 = v293 + 1;
    if ((unint64_t)v294 >= 0x7FFFFFFFFFFFFFE0)
      v296 = 0x7FFFFFFFFFFFFFFLL;
    else
      v296 = v295;
    if (v296)
      v296 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v296);
    else
      v297 = 0;
    v298 = (_QWORD *)(v296 + 32 * v293);
    v299 = v296 + 32 * v297;
    *v298 = CFSTR("Use Tabulated Speech PSD");
    v298[1] = 0x8400000000000002;
    v298[2] = 0x3F80000000000000;
    v298[3] = -3229614080;
    v292 = v298 + 4;
    v301 = (char *)*a1;
    v300 = (char *)a1[1];
    if (v300 != *a1)
    {
      do
      {
        v302 = *((_OWORD *)v300 - 1);
        *((_OWORD *)v298 - 2) = *((_OWORD *)v300 - 2);
        *((_OWORD *)v298 - 1) = v302;
        v298 -= 4;
        v300 -= 32;
      }
      while (v300 != v301);
      v300 = (char *)*a1;
    }
    *a1 = v298;
    a1[1] = v292;
    a1[2] = (void *)v299;
    if (v300)
      operator delete(v300);
  }
  else
  {
    *v280 = CFSTR("Use Tabulated Speech PSD");
    v280[1] = 0x8400000000000002;
    v280[2] = 0x3F80000000000000;
    v280[3] = -3229614080;
    v292 = v280 + 4;
  }
  a1[1] = v292;
  v303 = (unint64_t)a1[2];
  if ((unint64_t)v292 >= v303)
  {
    v305 = ((char *)v292 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v305 + 1) >> 59)
      goto LABEL_867;
    v306 = v303 - (_QWORD)*a1;
    v307 = v306 >> 4;
    if (v306 >> 4 <= (unint64_t)(v305 + 1))
      v307 = v305 + 1;
    if ((unint64_t)v306 >= 0x7FFFFFFFFFFFFFE0)
      v308 = 0x7FFFFFFFFFFFFFFLL;
    else
      v308 = v307;
    if (v308)
      v308 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v308);
    else
      v309 = 0;
    v310 = (_QWORD *)(v308 + 32 * v305);
    v311 = v308 + 32 * v309;
    *v310 = CFSTR("Enable EQ Display (expert mode)");
    v310[1] = 0x8000000000000002;
    v310[2] = 0x3F80000000000000;
    v310[3] = 0x500000000;
    v304 = v310 + 4;
    v313 = (char *)*a1;
    v312 = (char *)a1[1];
    if (v312 != *a1)
    {
      do
      {
        v314 = *((_OWORD *)v312 - 1);
        *((_OWORD *)v310 - 2) = *((_OWORD *)v312 - 2);
        *((_OWORD *)v310 - 1) = v314;
        v310 -= 4;
        v312 -= 32;
      }
      while (v312 != v313);
      v312 = (char *)*a1;
    }
    *a1 = v310;
    a1[1] = v304;
    a1[2] = (void *)v311;
    if (v312)
      operator delete(v312);
  }
  else
  {
    *v292 = CFSTR("Enable EQ Display (expert mode)");
    v292[1] = 0x8000000000000002;
    v292[2] = 0x3F80000000000000;
    v292[3] = 0x500000000;
    v304 = v292 + 4;
  }
  a1[1] = v304;
  v315 = (unint64_t)a1[2];
  if ((unint64_t)v304 >= v315)
  {
    v317 = ((char *)v304 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v317 + 1) >> 59)
      goto LABEL_867;
    v318 = v315 - (_QWORD)*a1;
    v319 = v318 >> 4;
    if (v318 >> 4 <= (unint64_t)(v317 + 1))
      v319 = v317 + 1;
    if ((unint64_t)v318 >= 0x7FFFFFFFFFFFFFE0)
      v320 = 0x7FFFFFFFFFFFFFFLL;
    else
      v320 = v319;
    if (v320)
      v320 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v320);
    else
      v321 = 0;
    v322 = (_QWORD *)(v320 + 32 * v317);
    v323 = v320 + 32 * v321;
    *v322 = CFSTR("Current User Volume Gain");
    v322[1] = 0x40080000000000DLL;
    v322[2] = 0x41700000C1F00000;
    v322[3] = 0x300000000;
    v316 = v322 + 4;
    v325 = (char *)*a1;
    v324 = (char *)a1[1];
    if (v324 != *a1)
    {
      do
      {
        v326 = *((_OWORD *)v324 - 1);
        *((_OWORD *)v322 - 2) = *((_OWORD *)v324 - 2);
        *((_OWORD *)v322 - 1) = v326;
        v322 -= 4;
        v324 -= 32;
      }
      while (v324 != v325);
      v324 = (char *)*a1;
    }
    *a1 = v322;
    a1[1] = v316;
    a1[2] = (void *)v323;
    if (v324)
      operator delete(v324);
  }
  else
  {
    *v304 = CFSTR("Current User Volume Gain");
    v304[1] = 0x40080000000000DLL;
    v304[2] = 0x41700000C1F00000;
    v304[3] = 0x300000000;
    v316 = v304 + 4;
  }
  a1[1] = v316;
  v327 = (unint64_t)a1[2];
  if ((unint64_t)v316 >= v327)
  {
    v329 = ((char *)v316 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v329 + 1) >> 59)
      goto LABEL_867;
    v330 = v327 - (_QWORD)*a1;
    v331 = v330 >> 4;
    if (v330 >> 4 <= (unint64_t)(v329 + 1))
      v331 = v329 + 1;
    if ((unint64_t)v330 >= 0x7FFFFFFFFFFFFFE0)
      v332 = 0x7FFFFFFFFFFFFFFLL;
    else
      v332 = v331;
    if (v332)
      v332 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v332);
    else
      v333 = 0;
    v334 = (_QWORD *)(v332 + 32 * v329);
    v335 = v332 + 32 * v333;
    *v334 = CFSTR("Current Total Volume Gain");
    v334[1] = 0x80000000000DLL;
    v334[2] = 0x41700000C1F00000;
    v334[3] = 0x300000000;
    v328 = v334 + 4;
    v337 = (char *)*a1;
    v336 = (char *)a1[1];
    if (v336 != *a1)
    {
      do
      {
        v338 = *((_OWORD *)v336 - 1);
        *((_OWORD *)v334 - 2) = *((_OWORD *)v336 - 2);
        *((_OWORD *)v334 - 1) = v338;
        v334 -= 4;
        v336 -= 32;
      }
      while (v336 != v337);
      v336 = (char *)*a1;
    }
    *a1 = v334;
    a1[1] = v328;
    a1[2] = (void *)v335;
    if (v336)
      operator delete(v336);
  }
  else
  {
    *v316 = CFSTR("Current Total Volume Gain");
    v316[1] = 0x80000000000DLL;
    v316[2] = 0x41700000C1F00000;
    v316[3] = 0x300000000;
    v328 = v316 + 4;
  }
  a1[1] = v328;
  v339 = (unint64_t)a1[2];
  if ((unint64_t)v328 >= v339)
  {
    v341 = ((char *)v328 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v341 + 1) >> 59)
      goto LABEL_867;
    v342 = v339 - (_QWORD)*a1;
    v343 = v342 >> 4;
    if (v342 >> 4 <= (unint64_t)(v341 + 1))
      v343 = v341 + 1;
    if ((unint64_t)v342 >= 0x7FFFFFFFFFFFFFE0)
      v344 = 0x7FFFFFFFFFFFFFFLL;
    else
      v344 = v343;
    if (v344)
      v344 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v344);
    else
      v345 = 0;
    v346 = (_QWORD *)(v344 + 32 * v341);
    v347 = v344 + 32 * v345;
    *v346 = CFSTR("EQ Min Gain (high freq)");
    v346[1] = 0x800000000000000DLL;
    v346[2] = 3248488448;
    v346[3] = 0x4C0A00000;
    v340 = v346 + 4;
    v349 = (char *)*a1;
    v348 = (char *)a1[1];
    if (v348 != *a1)
    {
      do
      {
        v350 = *((_OWORD *)v348 - 1);
        *((_OWORD *)v346 - 2) = *((_OWORD *)v348 - 2);
        *((_OWORD *)v346 - 1) = v350;
        v346 -= 4;
        v348 -= 32;
      }
      while (v348 != v349);
      v348 = (char *)*a1;
    }
    *a1 = v346;
    a1[1] = v340;
    a1[2] = (void *)v347;
    if (v348)
      operator delete(v348);
  }
  else
  {
    *v328 = CFSTR("EQ Min Gain (high freq)");
    v328[1] = 0x800000000000000DLL;
    v328[2] = 3248488448;
    v328[3] = 0x4C0A00000;
    v340 = v328 + 4;
  }
  a1[1] = v340;
  v351 = (unint64_t)a1[2];
  if ((unint64_t)v340 >= v351)
  {
    v353 = ((char *)v340 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v353 + 1) >> 59)
      goto LABEL_867;
    v354 = v351 - (_QWORD)*a1;
    v355 = v354 >> 4;
    if (v354 >> 4 <= (unint64_t)(v353 + 1))
      v355 = v353 + 1;
    if ((unint64_t)v354 >= 0x7FFFFFFFFFFFFFE0)
      v356 = 0x7FFFFFFFFFFFFFFLL;
    else
      v356 = v355;
    if (v356)
      v356 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v356);
    else
      v357 = 0;
    v358 = (_QWORD *)(v356 + 32 * v353);
    v359 = v356 + 32 * v357;
    *v358 = CFSTR("EQ Max Gain (high freq)");
    v358[1] = 0x800000000000000DLL;
    v358[2] = 0x41A0000000000000;
    v358[3] = 0x441200000;
    v352 = v358 + 4;
    v361 = (char *)*a1;
    v360 = (char *)a1[1];
    if (v360 != *a1)
    {
      do
      {
        v362 = *((_OWORD *)v360 - 1);
        *((_OWORD *)v358 - 2) = *((_OWORD *)v360 - 2);
        *((_OWORD *)v358 - 1) = v362;
        v358 -= 4;
        v360 -= 32;
      }
      while (v360 != v361);
      v360 = (char *)*a1;
    }
    *a1 = v358;
    a1[1] = v352;
    a1[2] = (void *)v359;
    if (v360)
      operator delete(v360);
  }
  else
  {
    *v340 = CFSTR("EQ Max Gain (high freq)");
    v340[1] = 0x800000000000000DLL;
    v340[2] = 0x41A0000000000000;
    v340[3] = 0x441200000;
    v352 = v340 + 4;
  }
  a1[1] = v352;
  v363 = (unint64_t)a1[2];
  if ((unint64_t)v352 >= v363)
  {
    v365 = ((char *)v352 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v365 + 1) >> 59)
      goto LABEL_867;
    v366 = v363 - (_QWORD)*a1;
    v367 = v366 >> 4;
    if (v366 >> 4 <= (unint64_t)(v365 + 1))
      v367 = v365 + 1;
    if ((unint64_t)v366 >= 0x7FFFFFFFFFFFFFE0)
      v368 = 0x7FFFFFFFFFFFFFFLL;
    else
      v368 = v367;
    if (v368)
      v368 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v368);
    else
      v369 = 0;
    v370 = (_QWORD *)(v368 + 32 * v365);
    v371 = v368 + 32 * v369;
    *v370 = CFSTR("EQ Frequency Boundary");
    v370[1] = 0x8000000000000008;
    v370[2] = 0x469C400042C80000;
    v370[3] = 0x444480000;
    v364 = v370 + 4;
    v373 = (char *)*a1;
    v372 = (char *)a1[1];
    if (v372 != *a1)
    {
      do
      {
        v374 = *((_OWORD *)v372 - 1);
        *((_OWORD *)v370 - 2) = *((_OWORD *)v372 - 2);
        *((_OWORD *)v370 - 1) = v374;
        v370 -= 4;
        v372 -= 32;
      }
      while (v372 != v373);
      v372 = (char *)*a1;
    }
    *a1 = v370;
    a1[1] = v364;
    a1[2] = (void *)v371;
    if (v372)
      operator delete(v372);
  }
  else
  {
    *v352 = CFSTR("EQ Frequency Boundary");
    v352[1] = 0x8000000000000008;
    v352[2] = 0x469C400042C80000;
    v352[3] = 0x444480000;
    v364 = v352 + 4;
  }
  a1[1] = v364;
  v375 = (unint64_t)a1[2];
  if ((unint64_t)v364 >= v375)
  {
    v377 = ((char *)v364 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v377 + 1) >> 59)
      goto LABEL_867;
    v378 = v375 - (_QWORD)*a1;
    v379 = v378 >> 4;
    if (v378 >> 4 <= (unint64_t)(v377 + 1))
      v379 = v377 + 1;
    if ((unint64_t)v378 >= 0x7FFFFFFFFFFFFFE0)
      v380 = 0x7FFFFFFFFFFFFFFLL;
    else
      v380 = v379;
    if (v380)
      v380 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v380);
    else
      v381 = 0;
    v382 = (_QWORD *)(v380 + 32 * v377);
    v383 = v380 + 32 * v381;
    *v382 = CFSTR("EQ Low Noise");
    v382[1] = 0x800000000000000DLL;
    v382[2] = 0x42F0000000000000;
    v382[3] = 0x4425C0000;
    v376 = v382 + 4;
    v385 = (char *)*a1;
    v384 = (char *)a1[1];
    if (v384 != *a1)
    {
      do
      {
        v386 = *((_OWORD *)v384 - 1);
        *((_OWORD *)v382 - 2) = *((_OWORD *)v384 - 2);
        *((_OWORD *)v382 - 1) = v386;
        v382 -= 4;
        v384 -= 32;
      }
      while (v384 != v385);
      v384 = (char *)*a1;
    }
    *a1 = v382;
    a1[1] = v376;
    a1[2] = (void *)v383;
    if (v384)
      operator delete(v384);
  }
  else
  {
    *v364 = CFSTR("EQ Low Noise");
    v364[1] = 0x800000000000000DLL;
    v364[2] = 0x42F0000000000000;
    v364[3] = 0x4425C0000;
    v376 = v364 + 4;
  }
  a1[1] = v376;
  v387 = (unint64_t)a1[2];
  if ((unint64_t)v376 >= v387)
  {
    v389 = ((char *)v376 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v389 + 1) >> 59)
      goto LABEL_867;
    v390 = v387 - (_QWORD)*a1;
    v391 = v390 >> 4;
    if (v390 >> 4 <= (unint64_t)(v389 + 1))
      v391 = v389 + 1;
    if ((unint64_t)v390 >= 0x7FFFFFFFFFFFFFE0)
      v392 = 0x7FFFFFFFFFFFFFFLL;
    else
      v392 = v391;
    if (v392)
      v392 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v392);
    else
      v393 = 0;
    v394 = (_QWORD *)(v392 + 32 * v389);
    v395 = v392 + 32 * v393;
    *v394 = CFSTR("Change in Environment");
    v394[1] = 0x800000000000;
    v394[2] = 0x3F80000000000000;
    v394[3] = 0xFFFFFFFF00000000;
    v388 = v394 + 4;
    v397 = (char *)*a1;
    v396 = (char *)a1[1];
    if (v396 != *a1)
    {
      do
      {
        v398 = *((_OWORD *)v396 - 1);
        *((_OWORD *)v394 - 2) = *((_OWORD *)v396 - 2);
        *((_OWORD *)v394 - 1) = v398;
        v394 -= 4;
        v396 -= 32;
      }
      while (v396 != v397);
      v396 = (char *)*a1;
    }
    *a1 = v394;
    a1[1] = v388;
    a1[2] = (void *)v395;
    if (v396)
      operator delete(v396);
  }
  else
  {
    *v376 = CFSTR("Change in Environment");
    v376[1] = 0x800000000000;
    v376[2] = 0x3F80000000000000;
    v376[3] = 0xFFFFFFFF00000000;
    v388 = v376 + 4;
  }
  a1[1] = v388;
  v399 = (unint64_t)a1[2];
  if ((unint64_t)v388 >= v399)
  {
    v401 = ((char *)v388 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v401 + 1) >> 59)
      goto LABEL_867;
    v402 = v399 - (_QWORD)*a1;
    v403 = v402 >> 4;
    if (v402 >> 4 <= (unint64_t)(v401 + 1))
      v403 = v401 + 1;
    if ((unint64_t)v402 >= 0x7FFFFFFFFFFFFFE0)
      v404 = 0x7FFFFFFFFFFFFFFLL;
    else
      v404 = v403;
    if (v404)
      v404 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v404);
    else
      v405 = 0;
    v406 = (_QWORD *)(v404 + 32 * v401);
    v407 = v404 + 32 * v405;
    *v406 = CFSTR("0.20 kHz");
    v406[1] = 0x40080000000000DLL;
    v406[2] = 0x41A00000C1A00000;
    v406[3] = 0x500000000;
    v400 = v406 + 4;
    v409 = (char *)*a1;
    v408 = (char *)a1[1];
    if (v408 != *a1)
    {
      do
      {
        v410 = *((_OWORD *)v408 - 1);
        *((_OWORD *)v406 - 2) = *((_OWORD *)v408 - 2);
        *((_OWORD *)v406 - 1) = v410;
        v406 -= 4;
        v408 -= 32;
      }
      while (v408 != v409);
      v408 = (char *)*a1;
    }
    *a1 = v406;
    a1[1] = v400;
    a1[2] = (void *)v407;
    if (v408)
      operator delete(v408);
  }
  else
  {
    *v388 = CFSTR("0.20 kHz");
    v388[1] = 0x40080000000000DLL;
    v388[2] = 0x41A00000C1A00000;
    v388[3] = 0x500000000;
    v400 = v388 + 4;
  }
  a1[1] = v400;
  v411 = (unint64_t)a1[2];
  if ((unint64_t)v400 >= v411)
  {
    v413 = ((char *)v400 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v413 + 1) >> 59)
      goto LABEL_867;
    v414 = v411 - (_QWORD)*a1;
    v415 = v414 >> 4;
    if (v414 >> 4 <= (unint64_t)(v413 + 1))
      v415 = v413 + 1;
    if ((unint64_t)v414 >= 0x7FFFFFFFFFFFFFE0)
      v416 = 0x7FFFFFFFFFFFFFFLL;
    else
      v416 = v415;
    if (v416)
      v416 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v416);
    else
      v417 = 0;
    v418 = (_QWORD *)(v416 + 32 * v413);
    v419 = v416 + 32 * v417;
    *v418 = CFSTR("0.40 kHz");
    v418[1] = 0x40080000000000DLL;
    v418[2] = 0x41A00000C1A00000;
    v418[3] = 0x500000000;
    v412 = v418 + 4;
    v421 = (char *)*a1;
    v420 = (char *)a1[1];
    if (v420 != *a1)
    {
      do
      {
        v422 = *((_OWORD *)v420 - 1);
        *((_OWORD *)v418 - 2) = *((_OWORD *)v420 - 2);
        *((_OWORD *)v418 - 1) = v422;
        v418 -= 4;
        v420 -= 32;
      }
      while (v420 != v421);
      v420 = (char *)*a1;
    }
    *a1 = v418;
    a1[1] = v412;
    a1[2] = (void *)v419;
    if (v420)
      operator delete(v420);
  }
  else
  {
    *v400 = CFSTR("0.40 kHz");
    v400[1] = 0x40080000000000DLL;
    v400[2] = 0x41A00000C1A00000;
    v400[3] = 0x500000000;
    v412 = v400 + 4;
  }
  a1[1] = v412;
  v423 = (unint64_t)a1[2];
  if ((unint64_t)v412 >= v423)
  {
    v425 = ((char *)v412 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v425 + 1) >> 59)
      goto LABEL_867;
    v426 = v423 - (_QWORD)*a1;
    v427 = v426 >> 4;
    if (v426 >> 4 <= (unint64_t)(v425 + 1))
      v427 = v425 + 1;
    if ((unint64_t)v426 >= 0x7FFFFFFFFFFFFFE0)
      v428 = 0x7FFFFFFFFFFFFFFLL;
    else
      v428 = v427;
    if (v428)
      v428 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v428);
    else
      v429 = 0;
    v430 = (_QWORD *)(v428 + 32 * v425);
    v431 = v428 + 32 * v429;
    *v430 = CFSTR("0.80 kHz");
    v430[1] = 0x40080000000000DLL;
    v430[2] = 0x41A00000C1A00000;
    v430[3] = 0x500000000;
    v424 = v430 + 4;
    v433 = (char *)*a1;
    v432 = (char *)a1[1];
    if (v432 != *a1)
    {
      do
      {
        v434 = *((_OWORD *)v432 - 1);
        *((_OWORD *)v430 - 2) = *((_OWORD *)v432 - 2);
        *((_OWORD *)v430 - 1) = v434;
        v430 -= 4;
        v432 -= 32;
      }
      while (v432 != v433);
      v432 = (char *)*a1;
    }
    *a1 = v430;
    a1[1] = v424;
    a1[2] = (void *)v431;
    if (v432)
      operator delete(v432);
  }
  else
  {
    *v412 = CFSTR("0.80 kHz");
    v412[1] = 0x40080000000000DLL;
    v412[2] = 0x41A00000C1A00000;
    v412[3] = 0x500000000;
    v424 = v412 + 4;
  }
  a1[1] = v424;
  v435 = (unint64_t)a1[2];
  if ((unint64_t)v424 >= v435)
  {
    v437 = ((char *)v424 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v437 + 1) >> 59)
      goto LABEL_867;
    v438 = v435 - (_QWORD)*a1;
    v439 = v438 >> 4;
    if (v438 >> 4 <= (unint64_t)(v437 + 1))
      v439 = v437 + 1;
    if ((unint64_t)v438 >= 0x7FFFFFFFFFFFFFE0)
      v440 = 0x7FFFFFFFFFFFFFFLL;
    else
      v440 = v439;
    if (v440)
      v440 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v440);
    else
      v441 = 0;
    v442 = (_QWORD *)(v440 + 32 * v437);
    v443 = v440 + 32 * v441;
    *v442 = CFSTR("1.25 kHz");
    v442[1] = 0x40080000000000DLL;
    v442[2] = 0x41A00000C1A00000;
    v442[3] = 0x500000000;
    v436 = v442 + 4;
    v445 = (char *)*a1;
    v444 = (char *)a1[1];
    if (v444 != *a1)
    {
      do
      {
        v446 = *((_OWORD *)v444 - 1);
        *((_OWORD *)v442 - 2) = *((_OWORD *)v444 - 2);
        *((_OWORD *)v442 - 1) = v446;
        v442 -= 4;
        v444 -= 32;
      }
      while (v444 != v445);
      v444 = (char *)*a1;
    }
    *a1 = v442;
    a1[1] = v436;
    a1[2] = (void *)v443;
    if (v444)
      operator delete(v444);
  }
  else
  {
    *v424 = CFSTR("1.25 kHz");
    v424[1] = 0x40080000000000DLL;
    v424[2] = 0x41A00000C1A00000;
    v424[3] = 0x500000000;
    v436 = v424 + 4;
  }
  a1[1] = v436;
  v447 = (unint64_t)a1[2];
  if ((unint64_t)v436 >= v447)
  {
    v449 = ((char *)v436 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v449 + 1) >> 59)
      goto LABEL_867;
    v450 = v447 - (_QWORD)*a1;
    v451 = v450 >> 4;
    if (v450 >> 4 <= (unint64_t)(v449 + 1))
      v451 = v449 + 1;
    if ((unint64_t)v450 >= 0x7FFFFFFFFFFFFFE0)
      v452 = 0x7FFFFFFFFFFFFFFLL;
    else
      v452 = v451;
    if (v452)
      v452 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v452);
    else
      v453 = 0;
    v454 = (_QWORD *)(v452 + 32 * v449);
    v455 = v452 + 32 * v453;
    *v454 = CFSTR("1.60 kHz");
    v454[1] = 0x40080000000000DLL;
    v454[2] = 0x41A00000C1A00000;
    v454[3] = 0x500000000;
    v448 = v454 + 4;
    v457 = (char *)*a1;
    v456 = (char *)a1[1];
    if (v456 != *a1)
    {
      do
      {
        v458 = *((_OWORD *)v456 - 1);
        *((_OWORD *)v454 - 2) = *((_OWORD *)v456 - 2);
        *((_OWORD *)v454 - 1) = v458;
        v454 -= 4;
        v456 -= 32;
      }
      while (v456 != v457);
      v456 = (char *)*a1;
    }
    *a1 = v454;
    a1[1] = v448;
    a1[2] = (void *)v455;
    if (v456)
      operator delete(v456);
  }
  else
  {
    *v436 = CFSTR("1.60 kHz");
    v436[1] = 0x40080000000000DLL;
    v436[2] = 0x41A00000C1A00000;
    v436[3] = 0x500000000;
    v448 = v436 + 4;
  }
  a1[1] = v448;
  v459 = (unint64_t)a1[2];
  if ((unint64_t)v448 >= v459)
  {
    v461 = ((char *)v448 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v461 + 1) >> 59)
      goto LABEL_867;
    v462 = v459 - (_QWORD)*a1;
    v463 = v462 >> 4;
    if (v462 >> 4 <= (unint64_t)(v461 + 1))
      v463 = v461 + 1;
    if ((unint64_t)v462 >= 0x7FFFFFFFFFFFFFE0)
      v464 = 0x7FFFFFFFFFFFFFFLL;
    else
      v464 = v463;
    if (v464)
      v464 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v464);
    else
      v465 = 0;
    v466 = (_QWORD *)(v464 + 32 * v461);
    v467 = v464 + 32 * v465;
    *v466 = CFSTR("2.00 kHz");
    v466[1] = 0x40080000000000DLL;
    v466[2] = 0x41A00000C1A00000;
    v466[3] = 0x500000000;
    v460 = v466 + 4;
    v469 = (char *)*a1;
    v468 = (char *)a1[1];
    if (v468 != *a1)
    {
      do
      {
        v470 = *((_OWORD *)v468 - 1);
        *((_OWORD *)v466 - 2) = *((_OWORD *)v468 - 2);
        *((_OWORD *)v466 - 1) = v470;
        v466 -= 4;
        v468 -= 32;
      }
      while (v468 != v469);
      v468 = (char *)*a1;
    }
    *a1 = v466;
    a1[1] = v460;
    a1[2] = (void *)v467;
    if (v468)
      operator delete(v468);
  }
  else
  {
    *v448 = CFSTR("2.00 kHz");
    v448[1] = 0x40080000000000DLL;
    v448[2] = 0x41A00000C1A00000;
    v448[3] = 0x500000000;
    v460 = v448 + 4;
  }
  a1[1] = v460;
  v471 = (unint64_t)a1[2];
  if ((unint64_t)v460 >= v471)
  {
    v473 = ((char *)v460 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v473 + 1) >> 59)
      goto LABEL_867;
    v474 = v471 - (_QWORD)*a1;
    v475 = v474 >> 4;
    if (v474 >> 4 <= (unint64_t)(v473 + 1))
      v475 = v473 + 1;
    if ((unint64_t)v474 >= 0x7FFFFFFFFFFFFFE0)
      v476 = 0x7FFFFFFFFFFFFFFLL;
    else
      v476 = v475;
    if (v476)
      v476 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v476);
    else
      v477 = 0;
    v478 = (_QWORD *)(v476 + 32 * v473);
    v479 = v476 + 32 * v477;
    *v478 = CFSTR("2.50 kHz");
    v478[1] = 0x40080000000000DLL;
    v478[2] = 0x41A00000C1A00000;
    v478[3] = 0x500000000;
    v472 = v478 + 4;
    v481 = (char *)*a1;
    v480 = (char *)a1[1];
    if (v480 != *a1)
    {
      do
      {
        v482 = *((_OWORD *)v480 - 1);
        *((_OWORD *)v478 - 2) = *((_OWORD *)v480 - 2);
        *((_OWORD *)v478 - 1) = v482;
        v478 -= 4;
        v480 -= 32;
      }
      while (v480 != v481);
      v480 = (char *)*a1;
    }
    *a1 = v478;
    a1[1] = v472;
    a1[2] = (void *)v479;
    if (v480)
      operator delete(v480);
  }
  else
  {
    *v460 = CFSTR("2.50 kHz");
    v460[1] = 0x40080000000000DLL;
    v460[2] = 0x41A00000C1A00000;
    v460[3] = 0x500000000;
    v472 = v460 + 4;
  }
  a1[1] = v472;
  v483 = (unint64_t)a1[2];
  if ((unint64_t)v472 >= v483)
  {
    v485 = ((char *)v472 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v485 + 1) >> 59)
      goto LABEL_867;
    v486 = v483 - (_QWORD)*a1;
    v487 = v486 >> 4;
    if (v486 >> 4 <= (unint64_t)(v485 + 1))
      v487 = v485 + 1;
    if ((unint64_t)v486 >= 0x7FFFFFFFFFFFFFE0)
      v488 = 0x7FFFFFFFFFFFFFFLL;
    else
      v488 = v487;
    if (v488)
      v488 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v488);
    else
      v489 = 0;
    v490 = (_QWORD *)(v488 + 32 * v485);
    v491 = v488 + 32 * v489;
    *v490 = CFSTR("3.15 kHz");
    v490[1] = 0x40080000000000DLL;
    v490[2] = 0x41A00000C1A00000;
    v490[3] = 0x500000000;
    v484 = v490 + 4;
    v493 = (char *)*a1;
    v492 = (char *)a1[1];
    if (v492 != *a1)
    {
      do
      {
        v494 = *((_OWORD *)v492 - 1);
        *((_OWORD *)v490 - 2) = *((_OWORD *)v492 - 2);
        *((_OWORD *)v490 - 1) = v494;
        v490 -= 4;
        v492 -= 32;
      }
      while (v492 != v493);
      v492 = (char *)*a1;
    }
    *a1 = v490;
    a1[1] = v484;
    a1[2] = (void *)v491;
    if (v492)
      operator delete(v492);
  }
  else
  {
    *v472 = CFSTR("3.15 kHz");
    v472[1] = 0x40080000000000DLL;
    v472[2] = 0x41A00000C1A00000;
    v472[3] = 0x500000000;
    v484 = v472 + 4;
  }
  a1[1] = v484;
  v495 = (unint64_t)a1[2];
  if ((unint64_t)v484 >= v495)
  {
    v497 = ((char *)v484 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v497 + 1) >> 59)
      goto LABEL_867;
    v498 = v495 - (_QWORD)*a1;
    v499 = v498 >> 4;
    if (v498 >> 4 <= (unint64_t)(v497 + 1))
      v499 = v497 + 1;
    if ((unint64_t)v498 >= 0x7FFFFFFFFFFFFFE0)
      v500 = 0x7FFFFFFFFFFFFFFLL;
    else
      v500 = v499;
    if (v500)
      v500 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v500);
    else
      v501 = 0;
    v502 = (_QWORD *)(v500 + 32 * v497);
    v503 = v500 + 32 * v501;
    *v502 = CFSTR("4.00 kHz");
    v502[1] = 0x40080000000000DLL;
    v502[2] = 0x41A00000C1A00000;
    v502[3] = 0x500000000;
    v496 = v502 + 4;
    v505 = (char *)*a1;
    v504 = (char *)a1[1];
    if (v504 != *a1)
    {
      do
      {
        v506 = *((_OWORD *)v504 - 1);
        *((_OWORD *)v502 - 2) = *((_OWORD *)v504 - 2);
        *((_OWORD *)v502 - 1) = v506;
        v502 -= 4;
        v504 -= 32;
      }
      while (v504 != v505);
      v504 = (char *)*a1;
    }
    *a1 = v502;
    a1[1] = v496;
    a1[2] = (void *)v503;
    if (v504)
      operator delete(v504);
  }
  else
  {
    *v484 = CFSTR("4.00 kHz");
    v484[1] = 0x40080000000000DLL;
    v484[2] = 0x41A00000C1A00000;
    v484[3] = 0x500000000;
    v496 = v484 + 4;
  }
  a1[1] = v496;
  v507 = (unint64_t)a1[2];
  if ((unint64_t)v496 >= v507)
  {
    v509 = ((char *)v496 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v509 + 1) >> 59)
      goto LABEL_867;
    v510 = v507 - (_QWORD)*a1;
    v511 = v510 >> 4;
    if (v510 >> 4 <= (unint64_t)(v509 + 1))
      v511 = v509 + 1;
    if ((unint64_t)v510 >= 0x7FFFFFFFFFFFFFE0)
      v512 = 0x7FFFFFFFFFFFFFFLL;
    else
      v512 = v511;
    if (v512)
      v512 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v512);
    else
      v513 = 0;
    v514 = (_QWORD *)(v512 + 32 * v509);
    v515 = v512 + 32 * v513;
    *v514 = CFSTR("5.00 kHz");
    v514[1] = 0x40080000000000DLL;
    v514[2] = 0x41A00000C1A00000;
    v514[3] = 0x500000000;
    v508 = v514 + 4;
    v517 = (char *)*a1;
    v516 = (char *)a1[1];
    if (v516 != *a1)
    {
      do
      {
        v518 = *((_OWORD *)v516 - 1);
        *((_OWORD *)v514 - 2) = *((_OWORD *)v516 - 2);
        *((_OWORD *)v514 - 1) = v518;
        v514 -= 4;
        v516 -= 32;
      }
      while (v516 != v517);
      v516 = (char *)*a1;
    }
    *a1 = v514;
    a1[1] = v508;
    a1[2] = (void *)v515;
    if (v516)
      operator delete(v516);
  }
  else
  {
    *v496 = CFSTR("5.00 kHz");
    v496[1] = 0x40080000000000DLL;
    v496[2] = 0x41A00000C1A00000;
    v496[3] = 0x500000000;
    v508 = v496 + 4;
  }
  a1[1] = v508;
  v519 = (unint64_t)a1[2];
  if ((unint64_t)v508 >= v519)
  {
    v521 = ((char *)v508 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v521 + 1) >> 59)
      goto LABEL_867;
    v522 = v519 - (_QWORD)*a1;
    v523 = v522 >> 4;
    if (v522 >> 4 <= (unint64_t)(v521 + 1))
      v523 = v521 + 1;
    if ((unint64_t)v522 >= 0x7FFFFFFFFFFFFFE0)
      v524 = 0x7FFFFFFFFFFFFFFLL;
    else
      v524 = v523;
    if (v524)
      v524 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v524);
    else
      v525 = 0;
    v526 = (_QWORD *)(v524 + 32 * v521);
    v527 = v524 + 32 * v525;
    *v526 = CFSTR("6.30 kHz");
    v526[1] = 0x40080000000000DLL;
    v526[2] = 0x41A00000C1A00000;
    v526[3] = 0x500000000;
    v520 = v526 + 4;
    v529 = (char *)*a1;
    v528 = (char *)a1[1];
    if (v528 != *a1)
    {
      do
      {
        v530 = *((_OWORD *)v528 - 1);
        *((_OWORD *)v526 - 2) = *((_OWORD *)v528 - 2);
        *((_OWORD *)v526 - 1) = v530;
        v526 -= 4;
        v528 -= 32;
      }
      while (v528 != v529);
      v528 = (char *)*a1;
    }
    *a1 = v526;
    a1[1] = v520;
    a1[2] = (void *)v527;
    if (v528)
      operator delete(v528);
  }
  else
  {
    *v508 = CFSTR("6.30 kHz");
    v508[1] = 0x40080000000000DLL;
    v508[2] = 0x41A00000C1A00000;
    v508[3] = 0x500000000;
    v520 = v508 + 4;
  }
  a1[1] = v520;
  v531 = (unint64_t)a1[2];
  if ((unint64_t)v520 >= v531)
  {
    v533 = ((char *)v520 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v533 + 1) >> 59)
      goto LABEL_867;
    v534 = v531 - (_QWORD)*a1;
    v535 = v534 >> 4;
    if (v534 >> 4 <= (unint64_t)(v533 + 1))
      v535 = v533 + 1;
    if ((unint64_t)v534 >= 0x7FFFFFFFFFFFFFE0)
      v536 = 0x7FFFFFFFFFFFFFFLL;
    else
      v536 = v535;
    if (v536)
      v536 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v536);
    else
      v537 = 0;
    v538 = (_QWORD *)(v536 + 32 * v533);
    v539 = v536 + 32 * v537;
    *v538 = CFSTR("8.00 kHz");
    v538[1] = 0x40080000000000DLL;
    v538[2] = 0x41A00000C1A00000;
    v538[3] = 0x500000000;
    v532 = v538 + 4;
    v541 = (char *)*a1;
    v540 = (char *)a1[1];
    if (v540 != *a1)
    {
      do
      {
        v542 = *((_OWORD *)v540 - 1);
        *((_OWORD *)v538 - 2) = *((_OWORD *)v540 - 2);
        *((_OWORD *)v538 - 1) = v542;
        v538 -= 4;
        v540 -= 32;
      }
      while (v540 != v541);
      v540 = (char *)*a1;
    }
    *a1 = v538;
    a1[1] = v532;
    a1[2] = (void *)v539;
    if (v540)
      operator delete(v540);
  }
  else
  {
    *v520 = CFSTR("8.00 kHz");
    v520[1] = 0x40080000000000DLL;
    v520[2] = 0x41A00000C1A00000;
    v520[3] = 0x500000000;
    v532 = v520 + 4;
  }
  a1[1] = v532;
  v543 = (unint64_t)a1[2];
  if ((unint64_t)v532 >= v543)
  {
    v545 = ((char *)v532 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v545 + 1) >> 59)
      goto LABEL_867;
    v546 = v543 - (_QWORD)*a1;
    v547 = v546 >> 4;
    if (v546 >> 4 <= (unint64_t)(v545 + 1))
      v547 = v545 + 1;
    if ((unint64_t)v546 >= 0x7FFFFFFFFFFFFFE0)
      v548 = 0x7FFFFFFFFFFFFFFLL;
    else
      v548 = v547;
    if (v548)
      v548 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v548);
    else
      v549 = 0;
    v550 = (_QWORD *)(v548 + 32 * v545);
    v551 = v548 + 32 * v549;
    *v550 = CFSTR("10.00 kHz");
    v550[1] = 0x40080000000000DLL;
    v550[2] = 0x41A00000C1A00000;
    v550[3] = 0x500000000;
    v544 = v550 + 4;
    v553 = (char *)*a1;
    v552 = (char *)a1[1];
    if (v552 != *a1)
    {
      do
      {
        v554 = *((_OWORD *)v552 - 1);
        *((_OWORD *)v550 - 2) = *((_OWORD *)v552 - 2);
        *((_OWORD *)v550 - 1) = v554;
        v550 -= 4;
        v552 -= 32;
      }
      while (v552 != v553);
      v552 = (char *)*a1;
    }
    *a1 = v550;
    a1[1] = v544;
    a1[2] = (void *)v551;
    if (v552)
      operator delete(v552);
  }
  else
  {
    *v532 = CFSTR("10.00 kHz");
    v532[1] = 0x40080000000000DLL;
    v532[2] = 0x41A00000C1A00000;
    v532[3] = 0x500000000;
    v544 = v532 + 4;
  }
  a1[1] = v544;
  v555 = (unint64_t)a1[2];
  if ((unint64_t)v544 >= v555)
  {
    v557 = ((char *)v544 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v557 + 1) >> 59)
      goto LABEL_867;
    v558 = v555 - (_QWORD)*a1;
    v559 = v558 >> 4;
    if (v558 >> 4 <= (unint64_t)(v557 + 1))
      v559 = v557 + 1;
    if ((unint64_t)v558 >= 0x7FFFFFFFFFFFFFE0)
      v560 = 0x7FFFFFFFFFFFFFFLL;
    else
      v560 = v559;
    if (v560)
      v560 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v560);
    else
      v561 = 0;
    v562 = (_QWORD *)(v560 + 32 * v557);
    v563 = v560 + 32 * v561;
    *v562 = CFSTR("12.50 kHz");
    v562[1] = 0x40080000000000DLL;
    v562[2] = 0x41A00000C1A00000;
    v562[3] = 0x500000000;
    v556 = v562 + 4;
    v565 = (char *)*a1;
    v564 = (char *)a1[1];
    if (v564 != *a1)
    {
      do
      {
        v566 = *((_OWORD *)v564 - 1);
        *((_OWORD *)v562 - 2) = *((_OWORD *)v564 - 2);
        *((_OWORD *)v562 - 1) = v566;
        v562 -= 4;
        v564 -= 32;
      }
      while (v564 != v565);
      v564 = (char *)*a1;
    }
    *a1 = v562;
    a1[1] = v556;
    a1[2] = (void *)v563;
    if (v564)
      operator delete(v564);
  }
  else
  {
    *v544 = CFSTR("12.50 kHz");
    v544[1] = 0x40080000000000DLL;
    v544[2] = 0x41A00000C1A00000;
    v544[3] = 0x500000000;
    v556 = v544 + 4;
  }
  a1[1] = v556;
  v567 = (unint64_t)a1[2];
  if ((unint64_t)v556 >= v567)
  {
    v569 = ((char *)v556 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v569 + 1) >> 59)
      goto LABEL_867;
    v570 = v567 - (_QWORD)*a1;
    v571 = v570 >> 4;
    if (v570 >> 4 <= (unint64_t)(v569 + 1))
      v571 = v569 + 1;
    if ((unint64_t)v570 >= 0x7FFFFFFFFFFFFFE0)
      v572 = 0x7FFFFFFFFFFFFFFLL;
    else
      v572 = v571;
    if (v572)
      v572 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v572);
    else
      v573 = 0;
    v574 = (_QWORD *)(v572 + 32 * v569);
    v575 = v572 + 32 * v573;
    *v574 = CFSTR("16.00 kHz");
    v574[1] = 0x40080000000000DLL;
    v574[2] = 0x41A00000C1A00000;
    v574[3] = 0x500000000;
    v568 = v574 + 4;
    v577 = (char *)*a1;
    v576 = (char *)a1[1];
    if (v576 != *a1)
    {
      do
      {
        v578 = *((_OWORD *)v576 - 1);
        *((_OWORD *)v574 - 2) = *((_OWORD *)v576 - 2);
        *((_OWORD *)v574 - 1) = v578;
        v574 -= 4;
        v576 -= 32;
      }
      while (v576 != v577);
      v576 = (char *)*a1;
    }
    *a1 = v574;
    a1[1] = v568;
    a1[2] = (void *)v575;
    if (v576)
      operator delete(v576);
  }
  else
  {
    *v556 = CFSTR("16.00 kHz");
    v556[1] = 0x40080000000000DLL;
    v556[2] = 0x41A00000C1A00000;
    v556[3] = 0x500000000;
    v568 = v556 + 4;
  }
  a1[1] = v568;
  v579 = (unint64_t)a1[2];
  if ((unint64_t)v568 >= v579)
  {
    v581 = ((char *)v568 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v581 + 1) >> 59)
      goto LABEL_867;
    v582 = v579 - (_QWORD)*a1;
    v583 = v582 >> 4;
    if (v582 >> 4 <= (unint64_t)(v581 + 1))
      v583 = v581 + 1;
    if ((unint64_t)v582 >= 0x7FFFFFFFFFFFFFE0)
      v584 = 0x7FFFFFFFFFFFFFFLL;
    else
      v584 = v583;
    if (v584)
      v584 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v584);
    else
      v585 = 0;
    v586 = (_QWORD *)(v584 + 32 * v581);
    v587 = v584 + 32 * v585;
    *v586 = CFSTR("20.00 kHz");
    v586[1] = 0x40080000000000DLL;
    v586[2] = 0x41A00000C1A00000;
    v586[3] = 0x500000000;
    v580 = v586 + 4;
    v589 = (char *)*a1;
    v588 = (char *)a1[1];
    if (v588 != *a1)
    {
      do
      {
        v590 = *((_OWORD *)v588 - 1);
        *((_OWORD *)v586 - 2) = *((_OWORD *)v588 - 2);
        *((_OWORD *)v586 - 1) = v590;
        v586 -= 4;
        v588 -= 32;
      }
      while (v588 != v589);
      v588 = (char *)*a1;
    }
    *a1 = v586;
    a1[1] = v580;
    a1[2] = (void *)v587;
    if (v588)
      operator delete(v588);
  }
  else
  {
    *v568 = CFSTR("20.00 kHz");
    v568[1] = 0x40080000000000DLL;
    v568[2] = 0x41A00000C1A00000;
    v568[3] = 0x500000000;
    v580 = v568 + 4;
  }
  a1[1] = v580;
  v591 = (unint64_t)a1[2];
  if ((unint64_t)v580 >= v591)
  {
    v593 = ((char *)v580 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v593 + 1) >> 59)
      goto LABEL_867;
    v594 = v591 - (_QWORD)*a1;
    v595 = v594 >> 4;
    if (v594 >> 4 <= (unint64_t)(v593 + 1))
      v595 = v593 + 1;
    if ((unint64_t)v594 >= 0x7FFFFFFFFFFFFFE0)
      v596 = 0x7FFFFFFFFFFFFFFLL;
    else
      v596 = v595;
    if (v596)
      v596 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v596);
    else
      v597 = 0;
    v598 = (_QWORD *)(v596 + 32 * v593);
    v599 = v596 + 32 * v597;
    *v598 = CFSTR("EQ Slew Rate (dB/s)");
    v598[1] = 0x8400000000000000;
    v598[2] = 0x4170000000000000;
    v598[3] = 0x440000000;
    v592 = v598 + 4;
    v601 = (char *)*a1;
    v600 = (char *)a1[1];
    if (v600 != *a1)
    {
      do
      {
        v602 = *((_OWORD *)v600 - 1);
        *((_OWORD *)v598 - 2) = *((_OWORD *)v600 - 2);
        *((_OWORD *)v598 - 1) = v602;
        v598 -= 4;
        v600 -= 32;
      }
      while (v600 != v601);
      v600 = (char *)*a1;
    }
    *a1 = v598;
    a1[1] = v592;
    a1[2] = (void *)v599;
    if (v600)
      operator delete(v600);
  }
  else
  {
    *v580 = CFSTR("EQ Slew Rate (dB/s)");
    v580[1] = 0x8400000000000000;
    v580[2] = 0x4170000000000000;
    v580[3] = 0x440000000;
    v592 = v580 + 4;
  }
  a1[1] = v592;
  v603 = (unint64_t)a1[2];
  if ((unint64_t)v592 >= v603)
  {
    v605 = ((char *)v592 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v605 + 1) >> 59)
      goto LABEL_867;
    v606 = v603 - (_QWORD)*a1;
    v607 = v606 >> 4;
    if (v606 >> 4 <= (unint64_t)(v605 + 1))
      v607 = v605 + 1;
    if ((unint64_t)v606 >= 0x7FFFFFFFFFFFFFE0)
      v608 = 0x7FFFFFFFFFFFFFFLL;
    else
      v608 = v607;
    if (v608)
      v608 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v608);
    else
      v609 = 0;
    v610 = (_QWORD *)(v608 + 32 * v605);
    v611 = v608 + 32 * v609;
    *v610 = CFSTR("Noise Slew Rate (dB/s)");
    v610[1] = 0x8400000000000000;
    v610[2] = 0x4170000000000000;
    v610[3] = 0x240A00000;
    v604 = v610 + 4;
    v613 = (char *)*a1;
    v612 = (char *)a1[1];
    if (v612 != *a1)
    {
      do
      {
        v614 = *((_OWORD *)v612 - 1);
        *((_OWORD *)v610 - 2) = *((_OWORD *)v612 - 2);
        *((_OWORD *)v610 - 1) = v614;
        v610 -= 4;
        v612 -= 32;
      }
      while (v612 != v613);
      v612 = (char *)*a1;
    }
    *a1 = v610;
    a1[1] = v604;
    a1[2] = (void *)v611;
    if (v612)
      operator delete(v612);
  }
  else
  {
    *v592 = CFSTR("Noise Slew Rate (dB/s)");
    v592[1] = 0x8400000000000000;
    v592[2] = 0x4170000000000000;
    v592[3] = 0x240A00000;
    v604 = v592 + 4;
  }
  a1[1] = v604;
  v615 = (unint64_t)a1[2];
  if ((unint64_t)v604 >= v615)
  {
    v617 = ((char *)v604 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v617 + 1) >> 59)
      goto LABEL_867;
    v618 = v615 - (_QWORD)*a1;
    v619 = v618 >> 4;
    if (v618 >> 4 <= (unint64_t)(v617 + 1))
      v619 = v617 + 1;
    if ((unint64_t)v618 >= 0x7FFFFFFFFFFFFFE0)
      v620 = 0x7FFFFFFFFFFFFFFLL;
    else
      v620 = v619;
    if (v620)
      v620 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v620);
    else
      v621 = 0;
    v622 = (_QWORD *)(v620 + 32 * v617);
    v623 = v620 + 32 * v621;
    *v622 = CFSTR("Auto Volume Slew Rate (dB/s)");
    v622[1] = 0x8400000000000000;
    v622[2] = 0x4170000000000000;
    v622[3] = 0x340400000;
    v616 = v622 + 4;
    v625 = (char *)*a1;
    v624 = (char *)a1[1];
    if (v624 != *a1)
    {
      do
      {
        v626 = *((_OWORD *)v624 - 1);
        *((_OWORD *)v622 - 2) = *((_OWORD *)v624 - 2);
        *((_OWORD *)v622 - 1) = v626;
        v622 -= 4;
        v624 -= 32;
      }
      while (v624 != v625);
      v624 = (char *)*a1;
    }
    *a1 = v622;
    a1[1] = v616;
    a1[2] = (void *)v623;
    if (v624)
      operator delete(v624);
  }
  else
  {
    *v604 = CFSTR("Auto Volume Slew Rate (dB/s)");
    v604[1] = 0x8400000000000000;
    v604[2] = 0x4170000000000000;
    v604[3] = 0x340400000;
    v616 = v604 + 4;
  }
  a1[1] = v616;
  v627 = (unint64_t)a1[2];
  if ((unint64_t)v616 >= v627)
  {
    v629 = ((char *)v616 - (_BYTE *)*a1) >> 5;
    if ((unint64_t)(v629 + 1) >> 59)
      goto LABEL_867;
    v630 = v627 - (_QWORD)*a1;
    v631 = v630 >> 4;
    if (v630 >> 4 <= (unint64_t)(v629 + 1))
      v631 = v629 + 1;
    if ((unint64_t)v630 >= 0x7FFFFFFFFFFFFFE0)
      v632 = 0x7FFFFFFFFFFFFFFLL;
    else
      v632 = v631;
    if (v632)
      v632 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v632);
    else
      v633 = 0;
    v634 = (_QWORD *)(v632 + 32 * v629);
    v635 = v632 + 32 * v633;
    *v634 = CFSTR("Near-End Speech Presence");
    v634[1] = 0x400800000000000;
    v634[2] = 0x3F80000000000000;
    v634[3] = 0xFFFFFFFF00000000;
    v628 = v634 + 4;
    v637 = (char *)*a1;
    v636 = (char *)a1[1];
    if (v636 != *a1)
    {
      do
      {
        v638 = *((_OWORD *)v636 - 1);
        *((_OWORD *)v634 - 2) = *((_OWORD *)v636 - 2);
        *((_OWORD *)v634 - 1) = v638;
        v634 -= 4;
        v636 -= 32;
      }
      while (v636 != v637);
      v636 = (char *)*a1;
    }
    *a1 = v634;
    a1[1] = v628;
    a1[2] = (void *)v635;
    if (v636)
      operator delete(v636);
  }
  else
  {
    *v616 = CFSTR("Near-End Speech Presence");
    v616[1] = 0x400800000000000;
    v616[2] = 0x3F80000000000000;
    v616[3] = 0xFFFFFFFF00000000;
    v628 = v616 + 4;
  }
  a1[1] = v628;
  v639 = (unint64_t)a1[2];
  if ((unint64_t)v628 < v639)
  {
    *v628 = CFSTR("Near-End SPP Threshold");
    v628[1] = 0x8400000000000000;
    v628[2] = 0x3F80000000000000;
    v628[3] = -3246391296;
    v640 = v628 + 4;
    goto LABEL_865;
  }
  v641 = ((char *)v628 - (_BYTE *)*a1) >> 5;
  if ((unint64_t)(v641 + 1) >> 59)
LABEL_867:
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  v642 = v639 - (_QWORD)*a1;
  v643 = v642 >> 4;
  if (v642 >> 4 <= (unint64_t)(v641 + 1))
    v643 = v641 + 1;
  if ((unint64_t)v642 >= 0x7FFFFFFFFFFFFFE0)
    v644 = 0x7FFFFFFFFFFFFFFLL;
  else
    v644 = v643;
  if (v644)
    v644 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v644);
  else
    v645 = 0;
  v646 = (_QWORD *)(v644 + 32 * v641);
  v647 = v644 + 32 * v645;
  *v646 = CFSTR("Near-End SPP Threshold");
  v646[1] = 0x8400000000000000;
  v646[2] = 0x3F80000000000000;
  v646[3] = -3246391296;
  v640 = v646 + 4;
  v649 = (char *)*a1;
  v648 = (char *)a1[1];
  if (v648 != *a1)
  {
    do
    {
      v650 = *((_OWORD *)v648 - 1);
      *((_OWORD *)v646 - 2) = *((_OWORD *)v648 - 2);
      *((_OWORD *)v646 - 1) = v650;
      v646 -= 4;
      v648 -= 32;
    }
    while (v648 != v649);
    v648 = (char *)*a1;
  }
  *a1 = v646;
  a1[1] = v640;
  a1[2] = (void *)v647;
  if (v648)
    operator delete(v648);
LABEL_865:
  a1[1] = v640;
  if ((char *)v640 - (_BYTE *)*a1 != 1728)
    __assert_rtn("populateParameterInfoTable", "SpeechEnhancerParameters.h", 99, "paramInfo.size() == kAUSpeechEnhancerNumberOfParameters");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(unint64_t a1)
{
  if (a1 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a1);
}

void BassKoenig::~BassKoenig(BassKoenig *this)
{
  AUDspLib::~AUDspLib(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t BassKoenig::SetParameter(BassKoenig *this, unsigned int a2, unsigned int a3, uint64_t a4, float a5)
{
  if (a2 == 48)
  {
    *((float *)this + 543) = DspLib::dB2Amp(this, a5);
  }
  else if (a2 == 47)
  {
    *((float *)this + 542) = DspLib::dB2Amp(this, a5);
  }
  return AUDspLib::SetParameter(this, a2, a3, a4, a5);
}

uint64_t BassKoenig::ProcessBufferLists(BassKoenig *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  unsigned int v5;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  float *mData;
  _DWORD *v12;
  AudioBufferList *v14;
  const AudioBufferList *v15;

  v5 = a5;
  v14 = a4;
  v15 = a3;
  v8 = (*(uint64_t (**)(BassKoenig *, unsigned int *, uint64_t, uint64_t, const AudioBufferList **, uint64_t, AudioBufferList **))(*(_QWORD *)this + 184))(this, a2, a5, 1, &v15, 1, &v14);
  v9 = v8;
  if (*((_BYTE *)this + 2113))
    v10 = 0;
  else
    v10 = (_DWORD)v8 == 0;
  if (v10)
  {
    mData = (float *)a4->mBuffers[0].mData;
    v12 = (_DWORD *)*((_QWORD *)this + 268);
    if (v12 != *((_DWORD **)this + 269) && *v12 == 2 && !*((_DWORD *)this + 397))
      DspLib::multiply((const float *)a4->mBuffers[0].mData, v5, *(float **)&a4[1].mBuffers[0].mNumberChannels, *((float *)this + 543));
    DspLib::multiply(mData, v5, *((float *)this + 542));
  }
  return v9;
}

uint64_t BassKoenig::SupportedNumChannels(BassKoenig *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&BassKoenig::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  return 2;
}

uint64_t BassKoenig::Version(BassKoenig *this)
{
  return 197376;
}

DspLib::BassKoenig::Algorithm *BassKoenig::newDspLibAlgorithm(BassKoenig *this)
{
  DspLib::BassKoenig::Algorithm *v1;

  v1 = (DspLib::BassKoenig::Algorithm *)operator new();
  DspLib::BassKoenig::Algorithm::Algorithm(v1);
  return v1;
}

void sub_1B6140AC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10E1C40B292FFD0);
  _Unwind_Resume(a1);
}

void AUBSS2::~AUBSS2(AUBSS2 *this)
{
  AUBSS2::~AUBSS2(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)this = &off_1E69C8698;
  v2 = *((_QWORD *)this + 77);
  *((_QWORD *)this + 77) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 56))(v2);
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)this + 664);
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)this + 624);
  v3 = *((_QWORD *)this + 77);
  *((_QWORD *)this + 77) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
  v4 = (void **)((char *)this + 568);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&v4);
  ausdk::AUBase::~AUBase(this);
}

void AUBSS2::CreateExtendedElements(uint64_t **this)
{
  ausdk::AUScope *v2;
  unsigned int i;
  uint64_t *v4;
  unint64_t v5;
  std::string *v6;
  __int128 v7;
  void **v8;
  CFStringRef v9;
  uint64_t Element;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  void **v15;
  CFStringRef v16;
  std::string v17;
  void *__p[2];
  int64_t v19;

  v2 = (ausdk::AUScope *)(this + 69);
  ausdk::AUScope::Initialize((int64x2_t *)(this + 69), (ausdk::AUBase *)this, 4, 8);
  for (i = 0; ; ++i)
  {
    v4 = this[74];
    if (v4)
      LODWORD(v5) = (*(uint64_t (**)(uint64_t *))(*v4 + 24))(v4);
    else
      v5 = (unint64_t)((char *)this[72] - (char *)this[71]) >> 3;
    if (i >= v5)
      break;
    std::to_string(&v17, i);
    v6 = std::string::insert(&v17, 0, "Mic", 3uLL);
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v19 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v17.__r_.__value_.__l.__data_);
    if (v19 >= 0)
      v8 = __p;
    else
      v8 = (void **)__p[0];
    v9 = CFStringCreateWithCString(0, (const char *)v8, 0x8000100u);
    Element = ausdk::AUScope::SafeGetElement(v2, i);
    ausdk::Owned<__CFString const*>::operator=((const void **)(Element + 72), v9);
    v11 = ausdk::AUScope::SafeGetElement(v2, i);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 40))(v11, 2);
    CFRelease(v9);
    if (SHIBYTE(v19) < 0)
      operator delete(__p[0]);
  }
  v12 = this[9];
  if (v12)
  {
    v13 = (*(uint64_t (**)(uint64_t *, _QWORD))(*v12 + 32))(v12, 0);
    if (!v13)
      return;
  }
  else
  {
    v14 = this[6];
    if (this[7] == v14)
      return;
    v13 = *v14;
    if (!*v14)
      return;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Global");
  if (v19 >= 0)
    v15 = __p;
  else
    v15 = (void **)__p[0];
  v16 = CFStringCreateWithCString(0, (const char *)v15, 0x8000100u);
  ausdk::Owned<__CFString const*>::operator=((const void **)(v13 + 72), v16);
  CFRelease(v16);
  if (SHIBYTE(v19) < 0)
    operator delete(__p[0]);
}

void sub_1B6140CF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t AUBSS2::Initialize(int64x2_t *this)
{
  uint64_t Element;
  uint64_t v3;
  unsigned int v4;
  int64x2_t *Scope;
  uint64_t v6;
  __int32 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int (***v11)(_QWORD, uint64_t, _QWORD, _QWORD, float);

  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[5], 0);
  v3 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[8], 0);
  v4 = *(_DWORD *)(Element + 108);
  if (v4 != *(_DWORD *)(v3 + 108))
    return 4294956421;
  this[37].i32[2] = v4;
  Scope = (int64x2_t *)ausdk::AUBase::GetScope((ausdk::AUBase *)this, 4u);
  ausdk::AUScope::SetNumberOfElements(Scope, v4);
  ausdk::AUScope::SetNumberOfElements(this + 2, 1u);
  v6 = this[21].u32[0];
  v7 = this[37].i32[3];
  switch(v7)
  {
    case 2:
      v10 = operator new();
      *(_QWORD *)v10 = off_1E69C89F0;
      *(_BYTE *)(v10 + 8) = 0;
      *(_OWORD *)(v10 + 16) = 0u;
      *(_OWORD *)(v10 + 32) = 0u;
      *(_OWORD *)(v10 + 48) = xmmword_1B66A06D0;
      *(_QWORD *)(v10 + 64) = 0x3FC0000025800000;
      *(_DWORD *)(v10 + 72) = 0;
      *(_QWORD *)(v10 + 80) = 5;
      *(_DWORD *)(v10 + 88) = 841731191;
      *(_QWORD *)(v10 + 104) = 0;
      *(_QWORD *)(v10 + 112) = 0;
      *(_QWORD *)(v10 + 96) = 0;
      *(_BYTE *)(v10 + 120) = 1;
      *(_QWORD *)(v10 + 124) = 1065353216;
      *(_WORD *)(v10 + 132) = 256;
      *(_QWORD *)(v10 + 136) = 0;
      *(_QWORD *)(v10 + 144) = 0;
      *(_BYTE *)(v10 + 152) = 0;
      *(_QWORD *)(v10 + 336) = 0;
      *(_OWORD *)(v10 + 304) = 0u;
      *(_OWORD *)(v10 + 320) = 0u;
      *(_OWORD *)(v10 + 272) = 0u;
      *(_OWORD *)(v10 + 288) = 0u;
      *(_OWORD *)(v10 + 240) = 0u;
      *(_OWORD *)(v10 + 256) = 0u;
      *(_OWORD *)(v10 + 208) = 0u;
      *(_OWORD *)(v10 + 224) = 0u;
      *(_OWORD *)(v10 + 176) = 0u;
      *(_OWORD *)(v10 + 192) = 0u;
      *(_OWORD *)(v10 + 160) = 0u;
      goto LABEL_10;
    case 1:
      if (this[37].i32[2] > 3u)
        return 4294956421;
      v10 = operator new();
      *(_QWORD *)v10 = off_1E69C89A0;
      *(_BYTE *)(v10 + 8) = 0;
      *(_OWORD *)(v10 + 16) = 0u;
      *(_OWORD *)(v10 + 32) = 0u;
      *(_OWORD *)(v10 + 48) = xmmword_1B66A06D0;
      *(_QWORD *)(v10 + 64) = 0x3FC0000025800000;
      *(_DWORD *)(v10 + 72) = 0;
      *(_QWORD *)(v10 + 80) = 5;
      *(_DWORD *)(v10 + 88) = 841731191;
      *(_QWORD *)(v10 + 104) = 0;
      *(_QWORD *)(v10 + 112) = 0;
      *(_QWORD *)(v10 + 96) = 0;
      *(_BYTE *)(v10 + 120) = 1;
      *(_DWORD *)(v10 + 124) = 1065353216;
      *(_BYTE *)(v10 + 128) = 0;
      *(_DWORD *)(v10 + 132) = 0;
      *(_WORD *)(v10 + 136) = 256;
      *(_BYTE *)(v10 + 138) = 1;
      *(_OWORD *)(v10 + 272) = 0u;
      *(_OWORD *)(v10 + 288) = 0u;
      *(_OWORD *)(v10 + 240) = 0u;
      *(_OWORD *)(v10 + 256) = 0u;
      *(_OWORD *)(v10 + 208) = 0u;
      *(_OWORD *)(v10 + 224) = 0u;
      *(_OWORD *)(v10 + 176) = 0u;
      *(_OWORD *)(v10 + 192) = 0u;
      *(_OWORD *)(v10 + 144) = 0u;
      *(_OWORD *)(v10 + 160) = 0u;
LABEL_10:
      v9 = this[38].i64[1];
      this[38].i64[1] = v10;
      if (!v9)
        break;
LABEL_11:
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 56))(v9);
      break;
    case 0:
      v8 = operator new();
      *(_QWORD *)v8 = off_1E69C8950;
      *(_BYTE *)(v8 + 8) = 0;
      *(_OWORD *)(v8 + 16) = 0u;
      *(_OWORD *)(v8 + 32) = 0u;
      *(_OWORD *)(v8 + 48) = xmmword_1B66A06D0;
      *(_QWORD *)(v8 + 64) = 0x3FC0000025800000;
      *(_DWORD *)(v8 + 72) = 0;
      *(_QWORD *)(v8 + 80) = 5;
      *(_DWORD *)(v8 + 88) = 841731191;
      *(_QWORD *)(v8 + 104) = 0;
      *(_QWORD *)(v8 + 112) = 0;
      *(_QWORD *)(v8 + 96) = 0;
      *(_BYTE *)(v8 + 120) = 1;
      *(_QWORD *)(v8 + 124) = 1065353216;
      *(_WORD *)(v8 + 132) = 256;
      *(_BYTE *)(v8 + 134) = 0;
      *(_OWORD *)(v8 + 152) = 0u;
      *(_OWORD *)(v8 + 168) = 0u;
      *(_OWORD *)(v8 + 184) = 0u;
      *(_OWORD *)(v8 + 200) = 0u;
      *(_OWORD *)(v8 + 216) = 0u;
      *(_OWORD *)(v8 + 232) = 0u;
      *(_OWORD *)(v8 + 248) = 0u;
      v9 = this[38].i64[1];
      this[38].i64[1] = v8;
      *(_OWORD *)(v8 + 136) = 0u;
      v8 += 136;
      *(_OWORD *)(v8 + 128) = 0u;
      *(_OWORD *)(v8 + 144) = 0u;
      *(_OWORD *)(v8 + 160) = 0u;
      if (v9)
        goto LABEL_11;
      break;
  }
  v11 = (unsigned int (***)(_QWORD, uint64_t, _QWORD, _QWORD, float))this[38].i64[1];
  if (v11 && (**v11)(v11, v6, (v6 + 1), this[37].u32[2], (float)this[33].u32[3]))
    return 4294956421;
  return (*(uint64_t (**)(int64x2_t *, _QWORD, _QWORD))(this->i64[0] + 72))(this, 0, 0);
}

uint64_t AUBSS2::Cleanup(AUBSS2 *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 77);
  *((_QWORD *)this + 77) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 56))(result);
  return result;
}

uint64_t AUBSS2::Reset(AUBSS2 *this)
{
  if (*((_QWORD *)this + 77))
  {
    AUBSS2::UpdateState((uint64_t)this);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 77) + 40))(*((_QWORD *)this + 77));
  }
  return 0;
}

uint64_t AUBSS2::GetPropertyInfo(AUBSS2 *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;

  if (a3 || a2 != 21 && a2 != 4501 && a2 != 3700)
    return 4294956417;
  result = 0;
  *a6 = 1;
  *a5 = 4;
  return result;
}

uint64_t AUBSS2::GetProperty(AUBSS2 *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  int v7;

  if (a3)
    return 4294956417;
  switch(a2)
  {
    case 4501:
      result = 0;
      v7 = *((_DWORD *)this + 151);
      break;
    case 3700:
      result = 0;
      v7 = *((unsigned __int8 *)this + 376);
      break;
    case 21:
      result = 0;
      v7 = *((_DWORD *)this + 134);
      break;
    default:
      return 4294956417;
  }
  *a5 = v7;
  return result;
}

uint64_t AUBSS2::SetProperty(AUBSS2 *this, int a2, int a3, unsigned int a4, const __CFNumber **a5, unsigned int a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  const __CFNumber *v10;
  _QWORD valuePtr[5];

  if (a3)
    return 4294956417;
  valuePtr[3] = v6;
  valuePtr[4] = v7;
  switch(a2)
  {
    case 4501:
      v10 = *a5;
      valuePtr[0] = 0;
      CFNumberGetValue(v10, kCFNumberSInt64Type, valuePtr);
      if (LODWORD(valuePtr[0]) > 2)
      {
        return 4294956445;
      }
      else
      {
        result = 0;
        *((_DWORD *)this + 151) = valuePtr[0];
      }
      break;
    case 3700:
      result = 4294956445;
      if (a6 >= 4)
      {
        if (*(_BYTE *)a5)
          return 0;
        else
          return 4294956445;
      }
      break;
    case 21:
      result = 0;
      *((_DWORD *)this + 134) = *(_DWORD *)a5;
      break;
    default:
      return 4294956417;
  }
  return result;
}

uint64_t AUBSS2::SetParameter(AUBSS2 *this, unsigned int a2, int a3, unsigned int a4, float a5)
{
  uint64_t v8;
  ausdk::AUElement *Element;
  uint64_t result;
  ausdk::AUElement **v11;

  if (a3 == 4)
  {
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUBSS2 *)((char *)this + 552), a4);
LABEL_6:
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
    result = 0;
    ++*((_DWORD *)this + 132);
    return result;
  }
  if (!a3)
  {
    v8 = *((_QWORD *)this + 9);
    if (v8)
    {
      Element = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
    }
    else
    {
      v11 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v11)
        Element = 0;
      else
        Element = *v11;
    }
    goto LABEL_6;
  }
  return 4294956418;
}

uint64_t AUBSS2::CanScheduleParameters(AUBSS2 *this)
{
  return 0;
}

uint64_t AUBSS2::ProcessBufferLists(AUBSS2 *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  AudioBufferList *v6;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x1E0C80C00];
  v6 = a4;
  v7[0] = a3;
  return (*(uint64_t (**)(AUBSS2 *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, AudioBufferList **))(*(_QWORD *)this + 184))(this, a2, a5, 1, v7, 1, &v6);
}

uint64_t AUBSS2::ProcessMultipleBufferLists(AUBSS2 *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7, double a8)
{
  int v12;
  int v13;
  unint64_t v14;
  AudioDSP::Utility *v15;
  uint64_t v16;
  const AudioBufferList **v17;
  AudioBufferList *v18;
  BOOL v19;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  AudioBufferList **v25;
  unint64_t v26;
  AudioBufferList *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v31;
  unint64_t v32;
  AudioBufferList *v33;
  uint64_t v34;
  unint64_t v35;
  AudioBufferList v36;
  int v37;
  int v38;
  uint64_t v39;
  AudioStreamBasicDescription v40;

  if (*((_BYTE *)this + 376) && *((_DWORD *)this + 84) != a3)
    return 4294956422;
  LOBYTE(v40.mSampleRate) = 0;
  v12 = *((_DWORD *)this + 136);
  LODWORD(a8) = *((_DWORD *)this + 135);
  v13 = *((_DWORD *)this + 150);
  *(double *)&v36.mNumberBuffers = (double)*(unint64_t *)&a8;
  v36.mBuffers[0] = (AudioBuffer)xmmword_1B6626900;
  v37 = 4;
  v38 = v13;
  v39 = 32;
  v14 = a4;
  if (a4)
  {
    v15 = (AudioDSP::Utility *)(2 * v12);
    v16 = a4 - 1;
    v17 = a5;
    while (1)
    {
      v18 = (AudioBufferList *)*v17;
      if (!*v17)
        return 4294956420;
      if (v18->mNumberBuffers != *((_DWORD *)this + 150))
        return 4294956428;
      AudioDSP::Utility::DetectNonFinites(v15, v18, &v36, &v40, (BOOL *)a5);
      v19 = LOBYTE(v40.mSampleRate) == 0;
      v21 = v16-- != 0;
      if (!LOBYTE(v40.mSampleRate))
      {
        ++v17;
        if (v21)
          continue;
      }
      goto LABEL_15;
    }
  }
  v19 = 1;
LABEL_15:
  v23 = a6;
  if (a6)
  {
    v24 = a6;
    v25 = a7;
    while (*v25)
    {
      if ((*v25)->mNumberBuffers != *((_DWORD *)this + 150))
        return 4294956428;
      ++v25;
      if (!--v24)
        goto LABEL_20;
    }
    return 4294956420;
  }
LABEL_20:
  if (*((_DWORD *)this + 134) || !v19 && *((_BYTE *)this + 608) || (v31 = *((_QWORD *)this + 77)) == 0)
  {
    if (a6)
    {
      v26 = 0;
      do
      {
        if (v26 >= v14)
        {
          v27 = a7[v26];
          if (v27->mNumberBuffers)
          {
            v28 = 0;
            v29 = 0;
            do
            {
              bzero(v27->mBuffers[v28].mData, v27->mBuffers[v28].mDataByteSize);
              ++v29;
              v27 = a7[v26];
              ++v28;
            }
            while (v29 < v27->mNumberBuffers);
          }
        }
        else
        {
          CopyBufferList(&a5[v26]->mNumberBuffers, a7[v26]);
        }
        ++v26;
      }
      while (v26 != v23);
    }
    return 0;
  }
  else
  {
    if (*((_DWORD *)this + 133) != *((_DWORD *)this + 132))
    {
      AUBSS2::UpdateState((uint64_t)this);
      *((_DWORD *)this + 133) = *((_DWORD *)this + 132);
      v31 = *((_QWORD *)this + 77);
    }
    v22 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v31 + 8))(v31, *a5, *a7);
    if ((_DWORD)v22)
      CopyBufferList(&(*a5)->mNumberBuffers, *a7);
    if (a6 >= 2)
    {
      v32 = 1;
      do
      {
        if (v32 >= v14)
        {
          v33 = a7[v32];
          if (v33->mNumberBuffers)
          {
            v34 = 0;
            v35 = 0;
            do
            {
              bzero(v33->mBuffers[v34].mData, v33->mBuffers[v34].mDataByteSize);
              ++v35;
              v33 = a7[v32];
              ++v34;
            }
            while (v35 < v33->mNumberBuffers);
          }
        }
        else
        {
          v22 = (*(uint64_t (**)(_QWORD, const AudioBufferList *, AudioBufferList *))(**((_QWORD **)this + 77)
                                                                                              + 16))(*((_QWORD *)this + 77), a5[v32], a7[v32]);
          if ((_DWORD)v22)
            CopyBufferList(&a5[v32]->mNumberBuffers, a7[v32]);
        }
        ++v32;
      }
      while (v32 != v23);
    }
  }
  return v22;
}

uint64_t AUBSS2::Render(AUBSS2 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  ausdk::AUInputElement *Element;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  ausdk::AUIOElement *v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD v31[4];

  v31[3] = *MEMORY[0x1E0C80C00];
  v8 = (AUBSS2 *)((char *)this + 80);
  v9 = *((_QWORD *)this + 15);
  if (v9)
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  else
    v10 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  v11 = 0;
  if ((_DWORD)v10)
  {
    v12 = 0;
    do
    {
      if (ausdk::AUBase::HasInput(this, v12))
      {
        Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, v12);
        result = ausdk::AUInputElement::PullInput(Element, a2, a3, v12, a4);
        if ((_DWORD)result)
          return result;
      }
      else
      {
        v11 = 1;
      }
      v12 = (v12 + 1);
    }
    while ((_DWORD)v10 != (_DWORD)v12);
  }
  v15 = *((_QWORD *)this + 21);
  if (v15)
  {
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
    LODWORD(v16) = v15;
  }
  else
  {
    v16 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
  }
  v31[2] = v31;
  v17 = v16;
  MEMORY[0x1E0C80A78](v15);
  v20 = (char *)v31 - v19;
  if (v18 >= 0x200)
    v21 = 512;
  else
    v21 = v18;
  bzero((char *)v31 - v19, v21);
  if ((_DWORD)v16)
  {
    v23 = 0;
    do
    {
      v24 = (ausdk::AUIOElement *)ausdk::AUScope::SafeGetElement((AUBSS2 *)((char *)this + 128), v23);
      v22 = ausdk::AUIOElement::PrepareBuffer(v24, a4);
      *(_QWORD *)&v20[8 * v23++] = v22;
    }
    while (v17 != v23);
  }
  if ((v11 & 1) != 0)
    return 0;
  v31[1] = v31;
  MEMORY[0x1E0C80A78](v22);
  v27 = (char *)v31 - v26;
  if (v25 >= 0x200)
    v28 = 512;
  else
    v28 = v25;
  bzero((char *)v31 - v26, v28);
  if ((_DWORD)v10)
  {
    v29 = 0;
    do
    {
      v30 = ausdk::AUScope::SafeGetElement(v8, v29);
      *(_QWORD *)&v27[8 * v29++] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v30 + 144));
    }
    while (v10 != v29);
  }
  return (*(uint64_t (**)(AUBSS2 *, unsigned int *, uint64_t, uint64_t, char *, uint64_t, char *))(*(_QWORD *)this + 184))(this, a2, a4, v10, v27, v17, v20);
}

BOOL AUBSS2::BusCountWritable(AUBSS2 *this, int a2)
{
  return (a2 - 1) < 2;
}

uint64_t AUBSS2::SetBusCount(AUBSS2 *this, int a2, unsigned int a3)
{
  unsigned int v3;
  int64x2_t *v4;
  uint64_t v5;

  v3 = a3 - 1;
  if (a2 == 1 && v3 <= 7)
  {
    v4 = (int64x2_t *)((char *)this + 80);
LABEL_7:
    ausdk::AUScope::SetNumberOfElements(v4, a3);
    return 0;
  }
  v5 = 4294956445;
  if (a2 == 2 && v3 <= 7)
  {
    v4 = (int64x2_t *)((char *)this + 128);
    goto LABEL_7;
  }
  return v5;
}

uint64_t AUBSS2::GetParameterInfo(AUBSS2 *this, int a2, unsigned int a3, AudioUnitParameterInfo *a4)
{
  _QWORD *v7;
  const __CFString *v8;
  AudioUnitParameterValue v9;
  AudioUnitParameterUnit v10;
  int v11;
  AudioUnitParameterOptions v12;
  uint64_t v13;
  uint64_t result;
  _QWORD *v15;
  _QWORD *v16;
  const __CFString *v17;
  AudioUnitParameterValue v18;
  AudioUnitParameterUnit v19;
  int v20;
  AudioUnitParameterOptions v21;
  uint64_t v22;
  unsigned int v23;

  v23 = a3;
  a4->flags = 0;
  a4->unitName = 0;
  if (a2 || a3 > 0x11)
  {
    result = 4294956418;
    if (a2 != 4 || a3 > 1)
      return result;
    v15 = (_QWORD *)((char *)this + 664);
    if (std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>(v15, a3))
    {
      v16 = std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v15, a3, &v23);
      v17 = (const __CFString *)v16[3];
      v18 = *((float *)v16 + 8);
      v19 = *((_DWORD *)v16 + 11);
      v20 = *((_DWORD *)v16 + 12);
      v21 = a4->flags | 0x8000000;
      v22 = *(_QWORD *)((char *)v16 + 36);
      a4->cfNameString = v17;
      a4->flags = v21;
      CFStringGetCString(v17, a4->name, 52, 0x8000100u);
      result = 0;
      a4->defaultValue = v18;
      *(_QWORD *)&a4->minValue = v22;
      a4->unit = v19;
      a4->flags |= v20;
      return result;
    }
    return 4294956418;
  }
  if (!std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((_QWORD *)this + 78, a3))return 4294956418;
  v7 = std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)this + 624, a3, &v23);
  v8 = (const __CFString *)v7[3];
  v9 = *((float *)v7 + 8);
  v10 = *((_DWORD *)v7 + 11);
  v11 = *((_DWORD *)v7 + 12);
  v12 = a4->flags | 0x8000000;
  v13 = *(_QWORD *)((char *)v7 + 36);
  a4->cfNameString = v8;
  a4->flags = v12;
  CFStringGetCString(v8, a4->name, 52, 0x8000100u);
  a4->defaultValue = v9;
  *(_QWORD *)&a4->minValue = v13;
  a4->unit = v10;
  a4->flags |= v11;
  if (a3 != 7 || !*((_BYTE *)this + 17))
    return 0;
  result = 0;
  a4->maxValue = (float)*((unsigned int *)this + 150);
  return result;
}

UInt8 *AUBSS2::SaveExtendedScopes(AUBSS2 *this, __CFData *a2)
{
  ausdk::AUScope *Scope;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, 4u);
  return ausdk::AUScope::SaveState(Scope, a2);
}

uint64_t AUBSS2::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
    ++*((_DWORD *)this + 132);
  return result;
}

uint64_t AUBSS2::GetParameterValueStrings(AUBSS2 *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  NSObject *v5;
  CFIndex v8;
  unint64_t v9;
  uint64_t v10;
  const void **v11;
  size_t v12;
  unint64_t i;
  std::string *v14;
  __int128 v15;
  const char *v16;
  CFIndex v17;
  CFTypeRef *v18;
  _BOOL4 v19;
  char *v20;
  CFIndex v21;
  CFArrayRef v22;
  char *v23;
  const __CFArray *v24;
  char *v25;
  float *v26;
  unint64_t v27;
  uint64_t v28;
  size_t v29;
  unint64_t k;
  std::string *v31;
  __int128 v32;
  const char *v33;
  char *v34;
  float *v35;
  unint64_t v36;
  uint64_t v37;
  size_t v38;
  unint64_t j;
  std::string *v40;
  __int128 v41;
  const char *v42;
  CFIndex v43;
  CFTypeRef *v44;
  std::string v45;
  int v46;
  _BYTE buf[24];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v46 = a3;
  if (!a4)
  {
    if (AUBSS2LogScope(void)::once != -1)
      dispatch_once(&AUBSS2LogScope(void)::once, &__block_literal_global_945);
    if (AUBSS2LogScope(void)::scope)
    {
      v5 = *(NSObject **)AUBSS2LogScope(void)::scope;
      if (!*(_QWORD *)AUBSS2LogScope(void)::scope)
        return 0;
    }
    else
    {
      v5 = MEMORY[0x1E0C81028];
    }
    v19 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v19)
      return result;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "AUBSS2.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 514;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEFAULT, "%25s:%-5d ERROR: Failed accessing strings in GetParameterValueStrings.", buf, 0x12u);
    return 0;
  }
  if (a2)
    return 4294956430;
  result = 0;
  if (a3 <= 9)
  {
    if (a3 != 2)
    {
      if (a3 != 7)
        return result;
      if (*((_BYTE *)this + 17))
      {
        v8 = (*((_DWORD *)this + 150) + 1);
        MEMORY[0x1E0C80A78](0);
        v11 = (const void **)((char *)&v45.__r_.__value_.__l.__data_ - v10);
        if (v9 >= 0x200)
          v12 = 512;
        else
          v12 = v9;
        bzero((char *)&v45 - v10, v12);
        *v11 = CFSTR("Multiple Reference MDP");
        if (v8 > 1)
        {
          for (i = 1; i != v8; ++i)
          {
            std::to_string(&v45, i);
            v14 = std::string::insert(&v45, 0, "Mic", 3uLL);
            v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
            *(_QWORD *)&buf[16] = *((_QWORD *)&v14->__r_.__value_.__l + 2);
            *(_OWORD *)buf = v15;
            v14->__r_.__value_.__l.__size_ = 0;
            v14->__r_.__value_.__r.__words[2] = 0;
            v14->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v45.__r_.__value_.__l.__data_);
            if (buf[23] >= 0)
              v16 = buf;
            else
              v16 = *(const char **)buf;
            v11[i] = CFStringCreateWithCString(0, v16, 0x8000100u);
            if ((buf[23] & 0x80000000) != 0)
              operator delete(*(void **)buf);
          }
          *a4 = CFArrayCreate(0, v11, v8, 0);
          v17 = v8 - 1;
          v18 = v11 + 1;
          do
          {
            CFRelease(*v18++);
            --v17;
          }
          while (v17);
          return 0;
        }
        goto LABEL_75;
      }
      v34 = (char *)this + 624;
      if (std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((_QWORD *)this + 78, 7u))
      {
        v35 = (float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v34, 7u, &v46);
        v8 = (float)(v35[10] + 1.0);
        MEMORY[0x1E0C80A78](v35);
        v11 = (const void **)((char *)&v45.__r_.__value_.__l.__data_ - v37);
        if (v36 >= 0x200)
          v38 = 512;
        else
          v38 = v36;
        bzero((char *)&v45 - v37, v38);
        *v11 = CFSTR("Multiple Reference MDP");
        if (v8 > 1)
        {
          for (j = 1; j != v8; ++j)
          {
            std::to_string(&v45, j);
            v40 = std::string::insert(&v45, 0, "Mic", 3uLL);
            v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
            *(_QWORD *)&buf[16] = *((_QWORD *)&v40->__r_.__value_.__l + 2);
            *(_OWORD *)buf = v41;
            v40->__r_.__value_.__l.__size_ = 0;
            v40->__r_.__value_.__r.__words[2] = 0;
            v40->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v45.__r_.__value_.__l.__data_);
            if (buf[23] >= 0)
              v42 = buf;
            else
              v42 = *(const char **)buf;
            v11[j] = CFStringCreateWithCString(0, v42, 0x8000100u);
            if ((buf[23] & 0x80000000) != 0)
              operator delete(*(void **)buf);
          }
          *a4 = CFArrayCreate(0, v11, v8, 0);
          v43 = v8 - 1;
          v44 = v11 + 1;
          do
          {
            CFRelease(*v44++);
            --v43;
          }
          while (v43);
          return 0;
        }
        goto LABEL_75;
      }
      return 4294956418;
    }
    v23 = (char *)this + 624;
    if (!std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((_QWORD *)this + 78, 2u))return 4294956418;
    if (*((float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v23, 2u, &v46)+ 10) != 1.0)__assert_rtn("GetParameterValueStrings", "AUBSS2.cpp", 590, "std::get<3>(param) == 1");
    *(_OWORD *)buf = xmmword_1E69C88D8;
    v22 = CFArrayCreate(0, (const void **)buf, 2, 0);
LABEL_39:
    v24 = v22;
    result = 0;
    *a4 = v24;
    return result;
  }
  if (a3 != 10)
  {
    if (a3 != 16)
      return result;
    v20 = (char *)this + 624;
    if (!std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((_QWORD *)this + 78, 0x10u))return 4294956418;
    v21 = (float)(*((float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v20, 0x10u, &v46)+ 10)+ 1.0);
    *(_OWORD *)buf = xmmword_1E69C88E8;
    *(_QWORD *)&buf[16] = CFSTR("Others");
    v22 = CFArrayCreate(0, (const void **)buf, v21, 0);
    goto LABEL_39;
  }
  v25 = (char *)this + 624;
  if (!std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>((_QWORD *)this + 78, 0xAu))return 4294956418;
  v26 = (float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v25, 0xAu, &v46);
  v8 = (float)(v26[10] + 1.0);
  MEMORY[0x1E0C80A78](v26);
  v11 = (const void **)((char *)&v45.__r_.__value_.__l.__data_ - v28);
  if (v27 >= 0x200)
    v29 = 512;
  else
    v29 = v27;
  bzero((char *)&v45 - v28, v29);
  if ((_DWORD)v8)
  {
    for (k = 0; k != v8; ++k)
    {
      std::to_string(&v45, k);
      v31 = std::string::insert(&v45, 0, "Speed ", 6uLL);
      v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
      *(_QWORD *)&buf[16] = *((_QWORD *)&v31->__r_.__value_.__l + 2);
      *(_OWORD *)buf = v32;
      v31->__r_.__value_.__l.__size_ = 0;
      v31->__r_.__value_.__r.__words[2] = 0;
      v31->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v45.__r_.__value_.__l.__data_);
      if (buf[23] >= 0)
        v33 = buf;
      else
        v33 = *(const char **)buf;
      v11[k] = CFStringCreateWithCString(0, v33, 0x8000100u);
      if ((buf[23] & 0x80000000) != 0)
        operator delete(*(void **)buf);
    }
    *a4 = CFArrayCreate(0, v11, v8, 0);
    do
    {
      CFRelease(*v11++);
      --v8;
    }
    while (v8);
    return 0;
  }
LABEL_75:
  *a4 = CFArrayCreate(0, v11, v8, 0);
  return 0;
}

void sub_1B61420BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 73) < 0)
    operator delete(*(void **)(v1 - 96));
  _Unwind_Resume(exception_object);
}

double AUBSS2::GetLatency(AUBSS2 *this)
{
  return 0.0;
}

double AUBSS2::GetTailTime(AUBSS2 *this)
{
  return 0.0;
}

uint64_t AUBSS2::SupportsTail(AUBSS2 *this)
{
  return 1;
}

BOOL AUBSS2::StreamFormatWritable(AUBSS2 *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUBSS2::SupportedNumChannels(AUBSS2 *this, const AUChannelInfo **a2)
{
  uint64_t v2;
  __int16 *v3;

  v2 = 0;
  v3 = &word_1EF134DEA;
  do
  {
    *(v3 - 1) = v2 + 2;
    *v3 = v2 + 2;
    v3 += 2;
    ++v2;
  }
  while (v2 != 7);
  if (a2)
    *a2 = (const AUChannelInfo *)&AUBSS2::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 7;
}

uint64_t AUBSS2::ValidFormat(AUBSS2 *this, int a2, unsigned int a3, const AudioStreamBasicDescription *a4)
{
  uint64_t result;

  if (a4->mBitsPerChannel == 64 && a4->mFormatID == 1718773105)
    result = (LOBYTE(a4->mFormatFlags) >> 5) & 1;
  else
    result = 0;
  if (a2 == 2 || a2 == 1)
  {
    if (a4->mChannelsPerFrame - 2 < 7)
      return result;
    else
      return 0;
  }
  return result;
}

uint64_t AUBSS2::ChangeStreamFormat(AUBSS2 *this, uint64_t a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  ausdk::AUBase::ChangeStreamFormat(this, a2, a3, a4, a5);
  if (a4->mSampleRate != a5->mSampleRate)
    *((_DWORD *)this + 135) = a5->mSampleRate;
  return 0;
}

char *AUBSS2::GetScopeExtended(AUBSS2 *this, int a2)
{
  char *v2;

  v2 = (char *)this + 552;
  if (a2 != 4)
    v2 = 0;
  if (a2)
    return v2;
  else
    return (char *)this + 32;
}

uint64_t AUBSS2::SetMaxFramesPerSlice(AUBSS2 *this, int a2)
{
  uint64_t result;

  result = ausdk::AUBase::SetMaxFramesPerSlice((uint64_t)this, a2);
  if (*((_DWORD *)this + 136) != a2)
    *((_DWORD *)this + 136) = a2;
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>(_QWORD *a1, unsigned int a2)
{
  unint64_t v2;
  uint8x8_t v3;
  unint64_t v4;
  uint64_t **v5;
  uint64_t *result;
  unint64_t v7;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
      v4 = a2 % v2;
  }
  else
  {
    v4 = ((_DWORD)v2 - 1) & a2;
  }
  v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  for (result = *v5; result; result = (uint64_t *)*result)
  {
    v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2)
        return result;
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2)
          v7 %= v2;
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4)
        return 0;
    }
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x38uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  *((_DWORD *)v10 + 12) = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_1B6142508(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint8x8_t v12;
  uint64_t v13;
  _QWORD *v14;
  size_t v15;
  void *v16;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(_QWORD *)&v4)
  {
    if (prime >= *(_QWORD *)&v4)
      return;
    v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      v11 = std::__next_prime(v11);
    }
    else
    {
      v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2)
        v11 = v13;
    }
    if (prime <= v11)
      prime = v11;
    if (prime >= *(_QWORD *)&v4)
      return;
    if (!prime)
    {
      v16 = *(void **)a1;
      *(_QWORD *)a1 = 0;
      if (v16)
        operator delete(v16);
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v5 = operator new(8 * prime);
  v6 = *(void **)a1;
  *(_QWORD *)a1 = v5;
  if (v6)
    operator delete(v6);
  v7 = 0;
  *(_QWORD *)(a1 + 8) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  v8 = *(_QWORD **)(a1 + 16);
  if (v8)
  {
    v9 = v8[1];
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime)
        v9 %= prime;
    }
    else
    {
      v9 &= prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v9) = a1 + 16;
    v14 = (_QWORD *)*v8;
    if (*v8)
    {
      do
      {
        v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime)
            v15 %= prime;
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v15))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *v8 = *v14;
          *v14 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v15);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v15) = v14;
          v14 = v8;
        }
        v15 = v9;
LABEL_31:
        v8 = v14;
        v14 = (_QWORD *)*v14;
        v9 = v15;
      }
      while (v14);
    }
  }
}

os_log_t ___ZL14AUBSS2LogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "aubss2");
  *v0 = result;
  AUBSS2LogScope(void)::scope = (uint64_t)v0;
  return result;
}

uint64_t ausdk::AUIOElement::PrepareBuffer(ausdk::AUIOElement *this, unsigned int a2)
{
  if (!*((_BYTE *)this + 168))
    ausdk::Throw((ausdk *)0xFFFFD59DLL);
  return ausdk::AUBufferList::PrepareBuffer((ausdk::AUIOElement *)((char *)this + 144), (const AudioStreamBasicDescription *)this + 2, a2);
}

void ausdk::Throw(ausdk *this)
{
  int v1;
  ausdk::AUException *exception;
  _DWORD v3[2];
  uint64_t v4;

  v1 = (int)this;
  v4 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v3[0] = 67109120;
    v3[1] = v1;
    _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)v3, 8u);
  }
  exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
  ausdk::AUException::AUException(exception, v1);
}

void sub_1B614283C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

unsigned int *CopyBufferList(unsigned int *result, AudioBufferList *a2)
{
  unint64_t v2;
  unsigned int *v5;
  unint64_t v6;
  unint64_t v7;
  size_t v8;
  unsigned int *v9;

  v2 = *result;
  if (v2 == a2->mNumberBuffers && v2 != 0)
  {
    v5 = result;
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = v5[v6 / 4 + 3];
      if (v8 <= a2->mBuffers[v6 / 0x10].mDataByteSize)
      {
        v9 = *(unsigned int **)&v5[v6 / 4 + 4];
        result = (unsigned int *)a2->mBuffers[v6 / 0x10].mData;
        if (v9 != result)
        {
          result = (unsigned int *)memcpy(result, v9, v8);
          v2 = *v5;
        }
      }
      ++v7;
      v6 += 16;
    }
    while (v7 < v2);
  }
  return result;
}

uint64_t AUBSS2::UpdateState(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  float Parameter;
  unint64_t v8;
  ausdk::AUElement *Element;
  float v10;
  float v11;

  if (*(_QWORD *)(this + 616))
  {
    v1 = this;
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(v1 + 616);
      v4 = *(_QWORD *)(v1 + 72);
      if (v4)
      {
        v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
      }
      else
      {
        v6 = *(ausdk::AUElement ***)(v1 + 48);
        if (*(ausdk::AUElement ***)(v1 + 56) == v6)
          v5 = 0;
        else
          v5 = *v6;
      }
      Parameter = ausdk::AUElement::GetParameter(v5, v2);
      this = (*(uint64_t (**)(uint64_t, uint64_t, float))(*(_QWORD *)v3 + 24))(v3, v2, Parameter);
      v2 = (v2 + 1);
    }
    while ((_DWORD)v2 != 18);
    if (*(_DWORD *)(v1 + 600))
    {
      v8 = 0;
      do
      {
        Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 552), v8);
        this = ausdk::AUElement::HasParameterID(Element, 0);
        if ((_DWORD)this)
        {
          this = ausdk::AUElement::HasParameterID(Element, 1u);
          if ((_DWORD)this)
          {
            v10 = ausdk::AUElement::GetParameter(Element, 0);
            v11 = ausdk::AUElement::GetParameter(Element, 1u);
            this = (*(uint64_t (**)(_QWORD, unint64_t, float, float))(**(_QWORD **)(v1 + 616) + 32))(*(_QWORD *)(v1 + 616), v8, v10, v11);
          }
        }
        ++v8;
      }
      while (v8 < *(unsigned int *)(v1 + 600));
    }
  }
  return this;
}

uint64_t AU::BSS2::AUXIVARLS<float>::Initialize(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, float a5)
{
  uint64_t result;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  vDSP_Length v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t i;
  float **v25;
  uint64_t v26;
  uint64_t j;
  _QWORD *v28;
  unint64_t v29;
  vDSP_Length v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t k;
  float **v36;
  uint64_t v37;
  uint64_t m;
  _QWORD *v39;
  unint64_t v40;
  vDSP_Length v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t n;
  float **v47;
  uint64_t v48;
  uint64_t ii;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  float v58;
  double v59;
  float32x2_t v60;
  int8x16_t v61;
  int8x16_t v62;
  __int128 v63;
  uint64_t v64;
  void **v65;

  if (a5 < 0.0)
    return 1;
  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 16) = a4;
  v9 = a5 / (float)a2;
  *(float *)(a1 + 32) = a5;
  *(float *)(a1 + 36) = v9;
  v10 = *(float *)(a1 + 68);
  v11 = 0.0;
  if (v10 > 0.0)
  {
    if (v9 <= 0.0)
      __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
    v11 = expf(-1.0 / (float)(v9 * v10));
  }
  *(float *)(a1 + 72) = v11;
  *(float *)(a1 + 36) = v9;
  *(_QWORD *)(a1 + 24) = a3;
  LODWORD(v63) = 0;
  std::vector<float>::resize(a1 + 192, a4, &v63);
  t3l::tDSP_create_vec_tensors<float>(&v63, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(float *)(a1 + 88));
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate((uint64_t **)(a1 + 232));
  *(_OWORD *)(a1 + 232) = v63;
  *(_QWORD *)(a1 + 248) = v64;
  v64 = 0;
  v63 = 0uLL;
  v65 = (void **)&v63;
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v65);
  t3l::tDSP_create_vec_tensors<float>(&v63, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), 1.0 / *(float *)(a1 + 88));
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate((uint64_t **)(a1 + 256));
  *(_OWORD *)(a1 + 256) = v63;
  *(_QWORD *)(a1 + 272) = v64;
  v64 = 0;
  v63 = 0uLL;
  v65 = (void **)&v63;
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v65);
  v12 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v12, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 216), v12);
  v13 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v13, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  v14 = a1 + 280;
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 280), v13);
  v15 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v15, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  v16 = a1 + 224;
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 224), v15);
  v17 = *(_QWORD **)(a1 + 216);
  v18 = v17[1];
  if (v18 != v17[2])
    goto LABEL_37;
  v19 = v17[3];
  LODWORD(v63) = 1065353216;
  if (v18)
  {
    v20 = 0;
    v21 = 1;
    v22 = v18;
    do
    {
      if (v21)
      {
        v23 = 0;
        for (i = 0; i < v21; ++i)
        {
          v25 = (float **)(*(_QWORD *)(*v17 + 8 * v20) + v23);
          vDSP_vclr(*v25, 1, v19);
          vDSP_vclr(v25[1], 1, v19);
          v21 = v17[2];
          v23 += 16;
        }
        v22 = v17[1];
      }
      ++v20;
    }
    while (v22 > v20);
    v26 = 0;
    for (j = 0; j != v18; ++j)
    {
      vDSP_vfill((const float *)&v63, *(float **)(*(_QWORD *)(*v17 + 8 * j) + v26), 1, v19);
      v26 += 16;
    }
  }
  v28 = *(_QWORD **)v14;
  v29 = *(_QWORD *)(*(_QWORD *)v14 + 8);
  if (v29 != *(_QWORD *)(*(_QWORD *)v14 + 16))
    goto LABEL_37;
  v30 = v28[3];
  LODWORD(v63) = 1065353216;
  if (v29)
  {
    v31 = 0;
    v32 = 1;
    v33 = v29;
    do
    {
      if (v32)
      {
        v34 = 0;
        for (k = 0; k < v32; ++k)
        {
          v36 = (float **)(*(_QWORD *)(*v28 + 8 * v31) + v34);
          vDSP_vclr(*v36, 1, v30);
          vDSP_vclr(v36[1], 1, v30);
          v32 = v28[2];
          v34 += 16;
        }
        v33 = v28[1];
      }
      ++v31;
    }
    while (v33 > v31);
    v37 = 0;
    for (m = 0; m != v29; ++m)
    {
      vDSP_vfill((const float *)&v63, *(float **)(*(_QWORD *)(*v28 + 8 * m) + v37), 1, v30);
      v37 += 16;
    }
  }
  v39 = *(_QWORD **)v16;
  v40 = *(_QWORD *)(*(_QWORD *)v16 + 8);
  if (v40 != *(_QWORD *)(*(_QWORD *)v16 + 16))
LABEL_37:
    __assert_rtn("tDSP_zmeye", "Tensor3Lib.h", 513, "N == X.cols");
  v41 = v39[3];
  LODWORD(v63) = 1065353216;
  if (v40)
  {
    v42 = 0;
    v43 = 1;
    v44 = v40;
    do
    {
      if (v43)
      {
        v45 = 0;
        for (n = 0; n < v43; ++n)
        {
          v47 = (float **)(*(_QWORD *)(*v39 + 8 * v42) + v45);
          vDSP_vclr(*v47, 1, v41);
          vDSP_vclr(v47[1], 1, v41);
          v43 = v39[2];
          v45 += 16;
        }
        v44 = v39[1];
      }
      ++v42;
    }
    while (v44 > v42);
    v48 = 0;
    for (ii = 0; ii != v40; ++ii)
    {
      vDSP_vfill((const float *)&v63, *(float **)(*(_QWORD *)(*v39 + 8 * ii) + v48), 1, v41);
      v48 += 16;
    }
  }
  v50 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v50, *(_QWORD *)(a1 + 16), 1, *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 288), v50);
  v51 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v51, *(_QWORD *)(a1 + 16), 1, *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 296), v51);
  v52 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v52, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 304), v52);
  v53 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v53, *(_QWORD *)(a1 + 16), 1, *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 312), v53);
  v54 = *(_QWORD *)(a1 + 16);
  LODWORD(v63) = 1065353216;
  std::vector<float>::resize(a1 + 168, v54, &v63);
  v55 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v55, 1uLL, 1, *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 320), v55);
  v56 = operator new();
  t3l::RTensor3<float>::RTensor3(v56, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 336), v56);
  v57 = operator new();
  t3l::RTensor3<float>::RTensor3(v57, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 328), v57);
  result = 0;
  v58 = *(float *)(a1 + 32);
  v59 = v58 / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
  v60.i32[0] = 0;
  v60.f32[1] = v58 * 0.5;
  v61 = (int8x16_t)vdupq_n_s64(*(_QWORD *)(a1 + 24) - 1);
  *(_BYTE *)(a1 + 8) = 1;
  *(float *)&v59 = v59;
  v62 = (int8x16_t)vcvtq_u64_f64(vcvtq_f64_f32(vrnda_f32(vabs_f32(vdiv_f32(v60, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v59, 0))))));
  *(int8x16_t *)(a1 + 136) = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v61, (uint64x2_t)v62), v62, v61);
  return result;
}

void sub_1B6143050(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10A0C40CB468F57);
  _Unwind_Resume(a1);
}

uint64_t AU::BSS2::AUXIVARLS<float>::Process(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  const DSPSplitComplex *v6;
  float *v7;
  vDSP_Length v8;
  uint64_t v9;
  _QWORD *v10;
  _DWORD ***v11;
  _DWORD **v12;
  uint64_t v13;
  unint64_t v14;
  const DSPSplitComplex *v15;
  uint64_t v16;
  double v17;
  long double v18;
  float v19;
  unint64_t v20;
  unint64_t i;
  int v22;
  unint64_t j;
  unint64_t v24;
  uint64_t v26;
  _QWORD *v27;
  float v28;
  _QWORD *v29;
  const DSPSplitComplex ***v30;
  uint64_t v31;
  uint64_t v32;
  vDSP_Length v33;
  const DSPSplitComplex **v34;
  vDSP_Length __N;
  unint64_t v36;
  uint64_t mm;
  const DSPSplitComplex **v38;
  uint64_t v39;
  const DSPSplitComplex **nn;
  uint64_t v41;
  const DSPSplitComplex **v42;
  const float **v43;
  unint64_t v44;
  unint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t v48;
  vDSP_Length v49;
  unint64_t v51;
  uint64_t v52;
  uint64_t k;
  uint64_t v54;
  uint64_t m;
  const DSPSplitComplex *v56;
  float *v57;
  _QWORD *v58;
  _QWORD *v59;
  _QWORD *v60;
  _QWORD *v61;
  const DSPSplitComplex ***v62;
  uint64_t v63;
  vDSP_Length v64;
  uint64_t v65;
  uint64_t n;
  vDSP_Length v67;
  const DSPSplitComplex **v69;
  const DSPSplitComplex **ii;
  uint64_t jj;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  const DSPSplitComplex *v77;
  float *v78;
  vDSP_Length v79;
  uint64_t v80;
  unint64_t v81;
  vDSP_Length v82;
  float *v83;
  const float **v84;
  uint64_t kk;
  unint64_t v86;
  uint64_t v87;
  float ****v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  const DSPSplitComplex **v92;
  const DSPSplitComplex ***v93;
  float v94;
  float v95;
  float __A;
  float __B;

  if (!*(_BYTE *)(a1 + 8))
    return 1;
  v4 = a1;
  ++*(_QWORD *)(a1 + 160);
  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(_QWORD **)(a1 + 288), *(_QWORD *)(*(_QWORD *)(a1 + 288) + 8), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16));
  if (*(_QWORD *)(v4 + 16))
  {
    v5 = 0;
    do
    {
      v6 = *(const DSPSplitComplex **)(**(_QWORD **)(v4 + 288) + 8 * v5);
      v7 = **(float ***)(**(_QWORD **)(v4 + 336) + 8 * v5);
      v8 = *(_QWORD *)(v4 + 24);
      __B = 2.2204e-16;
      vDSP_zvmags(v6, 1, v7, 1, v8);
      vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
      ++v5;
    }
    while (*(_QWORD *)(v4 + 16) > v5);
  }
  if (*(_BYTE *)(v4 + 120) && AU::BSS2::AboveMinEnergyThreshold<float>(*(_QWORD **)(v4 + 336), *(float *)(v4 + 128)))
  {
    v9 = *(_QWORD *)(v4 + 16);
    v10 = *(_QWORD **)(v4 + 288);
    if (v9)
    {
      v11 = (_DWORD ***)*v10;
      do
      {
        v12 = *v11++;
        **v12 = (*v12)[1];
        *v12[1] = v12[1][1];
        --v9;
      }
      while (v9);
    }
    t3l::tDSP_zmzvmult<float>(*(_QWORD **)(v4 + 216), (uint64_t)v10, *(_QWORD **)(v4 + 296));
    if (*(_QWORD *)(v4 + 16))
    {
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = *(const DSPSplitComplex **)(**(_QWORD **)(v4 + 296) + 8 * v14);
        vDSP_zvmags(v15, 1, v15->realp, 1, *(_QWORD *)(v4 + 24));
        vDSP_sve((const float *)(**(_QWORD **)(**(_QWORD **)(v4 + 296) + 8 * v14) + 4 * *(_QWORD *)(v4 + 136)), 1, (float *)(*(_QWORD *)(v4 + 192) + v13), *(_QWORD *)(v4 + 144) - *(_QWORD *)(v4 + 136));
        v16 = *(_QWORD *)(v4 + 192);
        v17 = (float)(*(float *)(v4 + 48) * 0.5);
        v18 = log2((float)(*(float *)(v16 + 4 * v14) + *(float *)(v4 + 52)));
        v19 = exp2(v18 * v17);
        *(float *)(v16 + 4 * v14) = v19;
        *(float *)(v16 + 4 * v14) = *(float *)(*(_QWORD *)(v4 + 168) + 4 * v14) * v19;
        ++v14;
        v13 += 4;
      }
      while (*(_QWORD *)(v4 + 16) > v14);
    }
    t3l::tDSP_ztvztvhmultupper<float>(*(_QWORD **)(v4 + 288), *(_QWORD **)(v4 + 288), *(_QWORD **)(v4 + 304));
    if (*(float *)(v4 + 56) > 0.0)
      t3l::tDSP_zmsreg<float>(*(_QWORD **)(v4 + 304), (const float *)(v4 + 56));
    v20 = *(_QWORD *)(v4 + 16);
    if (v20)
    {
      for (i = 0; i < v20; ++i)
      {
        AU::BSS2::UpdateVj<float>(*(_QWORD **)(v4 + 304), *(_QWORD **)(*(_QWORD *)(v4 + 232) + 8 * i), *(const float *****)(v4 + 296), 1, *(float *)(*(_QWORD *)(v4 + 192) + 4 * i), *(float *)(v4 + 72), *(float *)(v4 + 60));
        v20 = *(_QWORD *)(v4 + 16);
      }
    }
    v22 = *(unsigned __int8 *)(v4 + 152);
    v87 = a3;
    v91 = v4;
    if (*(_BYTE *)(v4 + 152))
    {
      if (v20)
      {
        for (j = 0; j < v24; ++j)
        {
          t3l::tDSP_zminverselu<float>(*(_QWORD **)(*(_QWORD *)(v4 + 232) + 8 * j), *(_QWORD **)(*(_QWORD *)(v4 + 256) + 8 * j), *(_QWORD **)(v4 + 328), *(uint64_t **)(v4 + 304), *(uint64_t **)(v4 + 296), *(_QWORD *)(v4 + 320));
          v24 = *(_QWORD *)(v4 + 16);
        }
        if (!v22)
        {
LABEL_56:
          t3l::tDSP_ztmov<float>(*(_QWORD **)(v4 + 216), *(_QWORD **)(v4 + 280));
          if (*(_QWORD *)(v4 + 16))
          {
            v45 = 0;
            do
            {
              v46 = *(_QWORD **)(*(_QWORD *)(v4 + 256) + 8 * v45);
              v47 = *(_QWORD **)(v4 + 216);
              v48 = *(_QWORD *)(v4 + 224);
              v49 = v46[3];
              if (v49 != *(_QWORD *)(v48 + 24) || v49 != v47[3])
                __assert_rtn("tDSP_zmzmekmulth", "Tensor3Lib.h", 693, "A.len == B.len && A.len == C.len");
              v51 = v46[2];
              if (v51 <= v45)
                __assert_rtn("tDSP_zmzmekmulth", "Tensor3Lib.h", 694, "BcolInd < A.cols");
              v52 = v46[1];
              if (v52)
              {
                for (k = 0; k != v52; ++k)
                {
                  vDSP_zvmul(*(const DSPSplitComplex **)(*v46 + 8 * k), 1, (const DSPSplitComplex *)(**(_QWORD **)v48 + 16 * v45), 1, (const DSPSplitComplex *)(*(_QWORD *)(*v47 + 8 * v45) + 16 * k), 1, v49, 1);
                  if (v51 >= 2)
                  {
                    v54 = 16;
                    for (m = 1; m != v51; ++m)
                    {
                      v56 = (const DSPSplitComplex *)(*(_QWORD *)(*v47 + 8 * v45) + 16 * k);
                      vDSP_zvma((const DSPSplitComplex *)(*(_QWORD *)(*v46 + 8 * k) + v54), 1, (const DSPSplitComplex *)(*(_QWORD *)(*(_QWORD *)v48 + 8 * m) + 16 * v45), 1, v56, 1, v56, 1, v49);
                      v54 += 16;
                    }
                  }
                  v57 = *(float **)(*(_QWORD *)(*v47 + 8 * v45) + 16 * k + 8);
                  vDSP_vneg(v57, 1, v57, 1, v49);
                }
                v4 = v91;
                v47 = *(_QWORD **)(v91 + 216);
              }
              AU::BSS2::UpdateWScale<float>(v47, v45, *(_QWORD *)(*(_QWORD *)(v4 + 232) + 8 * v45), v47, *(const DSPSplitComplex ****)(v4 + 296), *(const DSPSplitComplex ****)(v4 + 320));
              v58 = *(_QWORD **)(v4 + 280);
              v59 = *(_QWORD **)(v4 + 216);
              v60 = *(_QWORD **)(v4 + 224);
              v62 = *(const DSPSplitComplex ****)(v4 + 296);
              v61 = *(_QWORD **)(v4 + 304);
              v93 = *(const DSPSplitComplex ****)(v4 + 312);
              v88 = *(float *****)(v4 + 320);
              v63 = v59[1];
              v64 = v59[3];
              __B = 1.0;
              if (v63)
              {
                v65 = 0;
                for (n = 0; n != v63; ++n)
                {
                  vDSP_zvsub((const DSPSplitComplex *)(*(_QWORD *)(*v59 + 8 * v45) + v65), 1, (const DSPSplitComplex *)(*(_QWORD *)(*v58 + 8 * v45) + v65), 1, (*v62)[n], 1, v64);
                  v65 += 16;
                }
              }
              v90 = v63;
              v67 = (vDSP_Length)v62[3];
              if (v67 != v60[3] || v67 != (_QWORD)v93[3])
                __assert_rtn("tDSP_zvtzmmult", "Tensor3Lib.h", 726, "a.len == B.len && a.len == c.len");
              v69 = v62[1];
              if (v69 != (const DSPSplitComplex **)v60[2])
                __assert_rtn("tDSP_zvtzmmult", "Tensor3Lib.h", 727, "arows == bcols");
              if (v69 != v93[1])
                __assert_rtn("tDSP_zvtzmmult", "Tensor3Lib.h", 728, "a.rows == c.rows");
              if (v62 == v93)
                __assert_rtn("tDSP_zvtzmmult", "Tensor3Lib.h", 729, "&a != &c");
              if (v69)
              {
                for (ii = 0; ii != v69; ii = (const DSPSplitComplex **)((char *)ii + 1))
                {
                  vDSP_zvmul(**v62, 1, (const DSPSplitComplex *)(*(_QWORD *)*v60 + 16 * (_QWORD)ii), 1, (*v93)[(_QWORD)ii], 1, v67, 1);
                  if (v69 != (const DSPSplitComplex **)1)
                  {
                    for (jj = 1; (const DSPSplitComplex **)jj != v69; ++jj)
                      vDSP_zvma((*v62)[jj], 1, (const DSPSplitComplex *)(*(_QWORD *)(*v60 + 8 * jj) + 16 * (_QWORD)ii), 1, (*v93)[(_QWORD)ii], 1, (*v93)[(_QWORD)ii], 1, v67);
                  }
                }
              }
              vDSP_vsadd((*v93)[v45]->realp, 1, &__B, ***v88, 1, v64);
              vDSP_svdiv(&__B, ***v88, 1, ***v88, 1, v64);
              if (v63)
              {
                v72 = 0;
                v4 = v91;
                do
                {
                  vDSP_zrvmul((*v93)[v72], 1, ***v88, 1, (*v93)[v72], 1, v64);
                  ++v72;
                }
                while (v63 != v72);
                AU::BSS2::vDSP_zmekzvhmultT<float>(v60, v45, v93, v61);
                v73 = 0;
                do
                {
                  v74 = 0;
                  v75 = v90;
                  do
                  {
                    vDSP_zvsub((const DSPSplitComplex *)(*(_QWORD *)(*v60 + 8 * v73) + v74), 1, (const DSPSplitComplex *)(*(_QWORD *)(*v61 + 8 * v73) + v74), 1, (const DSPSplitComplex *)(*(_QWORD *)(*v60 + 8 * v73) + v74), 1, v64);
                    v74 += 16;
                    --v75;
                  }
                  while (v75);
                  ++v73;
                }
                while (v73 != v90);
              }
              else
              {
                AU::BSS2::vDSP_zmekzvhmultT<float>(v60, v45, v93, v61);
                v4 = v91;
              }
              ++v45;
            }
            while (*(_QWORD *)(v4 + 16) > v45);
          }
          goto LABEL_98;
        }
        if (v24)
        {
          v44 = 0;
          do
          {
            AU::BSS2::UpdateWProject<float>(*(_QWORD **)(v4 + 216), v44, *(_QWORD *)(*(_QWORD *)(v4 + 232) + 8 * v44), *(_QWORD **)(v4 + 328), *(_QWORD **)(v4 + 304), *(uint64_t **)(v4 + 296), *(const DSPSplitComplex ****)(v4 + 320), *(float *)(v4 + 64));
            AU::BSS2::UpdateWScale<float>(*(_QWORD **)(v4 + 216), v44, *(_QWORD *)(*(_QWORD *)(v4 + 232) + 8 * v44), *(_QWORD **)(v4 + 216), *(const DSPSplitComplex ****)(v4 + 296), *(const DSPSplitComplex ****)(v4 + 304));
            ++v44;
          }
          while (*(_QWORD *)(v4 + 16) > v44);
        }
      }
      t3l::tDSP_zminverselu<float>(*(_QWORD **)(v4 + 216), *(_QWORD **)(v4 + 224), *(_QWORD **)(v4 + 328), *(uint64_t **)(v4 + 304), *(uint64_t **)(v4 + 296), *(_QWORD *)(v4 + 320));
LABEL_98:
      AU::BSS2::GenerateOutput<float>(*(_QWORD **)(v4 + 216), *(_QWORD **)(v4 + 224), *(_QWORD *)(v4 + 288), *(_QWORD **)(v4 + 296), *(_QWORD *)(v4 + 112));
      if (*(_QWORD *)(v4 + 16))
      {
        v76 = 0;
        do
        {
          v77 = *(const DSPSplitComplex **)(**(_QWORD **)(v4 + 296) + 8 * v76);
          v78 = **(float ***)(**(_QWORD **)(v4 + 328) + 8 * v76);
          v79 = *(_QWORD *)(v4 + 24);
          __B = 2.2204e-16;
          vDSP_zvmags(v77, 1, v78, 1, v79);
          vDSP_vsadd(v78, 1, &__B, v78, 1, v79);
          ++v76;
        }
        while (*(_QWORD *)(v4 + 16) > v76);
      }
      v80 = v87;
      if (*(_BYTE *)(v4 + 133))
        AU::BSS2::FixWNG<float>(*(_QWORD **)(v4 + 296), *(_QWORD **)(v4 + 336), *(_QWORD **)(v4 + 328), *(_QWORD *)(v4 + 304), *(_QWORD *)(v4 + 112), *(float *)(v4 + 124));
      if (*(_BYTE *)(v4 + 132))
        AU::BSS2::MixturePhase<float>(*(_QWORD **)(v4 + 288), *(_QWORD **)(v4 + 336), *(_QWORD **)(v4 + 296), *(_QWORD **)(v4 + 328), **(float *****)(v4 + 304), *(_QWORD *)(*(_QWORD *)(v4 + 304) + 24));
      *(_BYTE *)(v4 + 152) = 0;
      if (*(_QWORD *)(v4 + 16))
      {
        v81 = 0;
        v82 = *(_QWORD *)(v4 + 24);
        v83 = ****(float *****)(v4 + 304);
        do
        {
          v84 = *(const float ***)(**(_QWORD **)(v4 + 296) + 8 * v81);
          vDSP_vadd(*v84, 1, v84[1], 1, v83, 1, v82);
          if (v82)
          {
            for (kk = 0; kk != v82; ++kk)
              ;
          }
          ++v81;
          v86 = *(_QWORD *)(v4 + 16);
        }
        while (v86 > v81);
        v80 = v87;
      }
      else
      {
        v86 = 0;
      }
      t3l::tDSP_copy_ztensor_to_freq_abl<float>(**(_QWORD **)(v4 + 296), v80, *(_QWORD *)(v4 + 40), v86);
      return 0;
    }
    if (v20)
    {
      v26 = 0;
      do
      {
        v27 = *(_QWORD **)(*(_QWORD *)(v4 + 256) + 8 * v26);
        v28 = *(float *)(v4 + 72);
        v30 = *(const DSPSplitComplex ****)(v4 + 296);
        v29 = *(_QWORD **)(v4 + 304);
        v31 = *(_QWORD *)(v4 + 288);
        v32 = *(_QWORD *)(v4 + 320);
        v33 = *(_QWORD *)(v31 + 24);
        v34 = *(const DSPSplitComplex ***)(v31 + 8);
        __A = (float)(1.0 - v28) / *(float *)(*(_QWORD *)(v4 + 192) + 4 * v26);
        __B = v28 * v28;
        v94 = __A * v28;
        v95 = 1.0 / v28;
        if (v34 != (const DSPSplitComplex **)v27[1])
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 776, "a.rows == B.rows");
        if (v34 != (const DSPSplitComplex **)v27[2])
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 777, "a.rows == B.cols");
        if (*(_QWORD *)(v32 + 8) != 1)
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 778, "1 == c.rows");
        if (*(_QWORD *)(v32 + 16) != 1)
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 779, "1 == c.cols");
        if (v30[1] != v34)
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 780, "Ba.rows == a.rows");
        if (v30[2] != (const DSPSplitComplex **)1)
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 781, "Ba.cols == 1");
        if (v33 != v27[3] || (const DSPSplitComplex **)v33 != v30[3] || v33 != *(_QWORD *)(v32 + 24))
          __assert_rtn("tDSP_zvtzmzvmult", "Tensor3Lib.h", 782, "a.len == B.len && a.len == Ba.len && a.len == c.len");
        v92 = v34;
        t3l::tDSP_zmzvmult<float>(v27, v31, v30);
        __N = *(_QWORD *)(v31 + 24);
        if ((const DSPSplitComplex **)__N != v30[3] || __N != *(_QWORD *)(v32 + 24))
          __assert_rtn("tDSP_zvhzvmult", "Tensor3Lib.h", 753, "a.len == b.len && a.len == c.len");
        v36 = *(_QWORD *)(v31 + 8);
        if ((const DSPSplitComplex **)v36 != v30[1])
          __assert_rtn("tDSP_zvhzvmult", "Tensor3Lib.h", 754, "a.rows == b.rows");
        if (*(_QWORD *)(v31 + 16) != 1 || v30[2] != (const DSPSplitComplex **)1)
          __assert_rtn("tDSP_zvhzvmult", "Tensor3Lib.h", 755, "a.cols == b.cols && a.cols == 1");
        v89 = v26;
        vDSP_zvmul(**(const DSPSplitComplex ***)v31, 1, **v30, 1, **(const DSPSplitComplex ***)v32, 1, __N, -1);
        if (v36 >= 2)
        {
          for (mm = 1; mm != v36; ++mm)
            vDSP_zvcma(*(const DSPSplitComplex **)(*(_QWORD *)v31 + 8 * mm), 1, (*v30)[mm], 1, **(const DSPSplitComplex ***)v32, 1, **(const DSPSplitComplex ***)v32, 1, __N);
        }
        vDSP_vsmul(***(const float ****)v32, 1, &v94, ***(float ****)v32, 1, v33);
        vDSP_vsadd(***(const float ****)v32, 1, &__B, ***(float ****)v32, 1, v33);
        vDSP_svdiv(&__A, ***(const float ****)v32, 1, ***(float ****)v32, 1, v33);
        vDSP_vneg(***(const float ****)v32, 1, ***(float ****)v32, 1, v33);
        t3l::tDSP_ztvztvhmultupper<float>(v30, v30, v29);
        v38 = v92;
        if (v92)
        {
          v39 = 0;
          for (nn = 0; nn != v92; nn = (const DSPSplitComplex **)((char *)nn + 1))
          {
            v41 = v39;
            v42 = v38;
            do
            {
              vDSP_zrvmul((const DSPSplitComplex *)(*(_QWORD *)(*v29 + 8 * (_QWORD)nn) + v41), 1, ***(const float ****)v32, 1, (const DSPSplitComplex *)(*(_QWORD *)(*v29 + 8 * (_QWORD)nn) + v41), 1, v33);
              v43 = (const float **)(*(_QWORD *)(*v27 + 8 * (_QWORD)nn) + v41);
              vDSP_vsmul(*v43, 1, &v95, (float *)*v43, 1, v33);
              vDSP_vsmul(v43[1], 1, &v95, (float *)v43[1], 1, v33);
              vDSP_zvadd((const DSPSplitComplex *)(*(_QWORD *)(*v27 + 8 * (_QWORD)nn) + v41), 1, (const DSPSplitComplex *)(*(_QWORD *)(*v29 + 8 * (_QWORD)nn) + v41), 1, (const DSPSplitComplex *)(*(_QWORD *)(*v27 + 8 * (_QWORD)nn) + v41), 1, v33);
              v41 += 16;
              v42 = (const DSPSplitComplex **)((char *)v42 - 1);
            }
            while (v42);
            v38 = (const DSPSplitComplex **)((char *)v38 - 1);
            v39 += 16;
          }
        }
        t3l::tDSP_ztsymmetric<float>(v27);
        v4 = v91;
        v26 = v89 + 1;
      }
      while (*(_QWORD *)(v91 + 16) > (unint64_t)(v89 + 1));
    }
    goto LABEL_56;
  }
  AU::BSS2::GenerateOutput<float>(*(_QWORD **)(v4 + 216), *(_QWORD **)(v4 + 224), *(_QWORD *)(v4 + 288), *(_QWORD **)(v4 + 296), *(_QWORD *)(v4 + 112));
  return 0;
}

uint64_t AU::BSS2::AUXIVARLS<float>::SideChain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  const DSPSplitComplex *v6;
  float *v7;
  vDSP_Length v8;
  unint64_t v9;
  unint64_t v10;
  const DSPSplitComplex *v11;
  float *v12;
  vDSP_Length v13;
  float __B;
  float v16;

  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(_QWORD **)(a1 + 288), *(_QWORD *)(*(_QWORD *)(a1 + 288) + 8), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16));
  AU::BSS2::GenerateOutput<float>(*(_QWORD **)(a1 + 216), *(_QWORD **)(a1 + 224), *(_QWORD *)(a1 + 288), *(_QWORD **)(a1 + 296), *(_QWORD *)(a1 + 112));
  if (*(_BYTE *)(a1 + 133) || *(_BYTE *)(a1 + 132))
  {
    if (*(_QWORD *)(a1 + 16))
    {
      v5 = 0;
      do
      {
        v6 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 288) + 8 * v5);
        v7 = **(float ***)(**(_QWORD **)(a1 + 336) + 8 * v5);
        v8 = *(_QWORD *)(a1 + 24);
        __B = 2.2204e-16;
        vDSP_zvmags(v6, 1, v7, 1, v8);
        vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
        ++v5;
        v9 = *(_QWORD *)(a1 + 16);
      }
      while (v9 > v5);
      if (v9)
      {
        v10 = 0;
        do
        {
          v11 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 296) + 8 * v10);
          v12 = **(float ***)(**(_QWORD **)(a1 + 328) + 8 * v10);
          v13 = *(_QWORD *)(a1 + 24);
          v16 = 2.2204e-16;
          vDSP_zvmags(v11, 1, v12, 1, v13);
          vDSP_vsadd(v12, 1, &v16, v12, 1, v13);
          ++v10;
        }
        while (*(_QWORD *)(a1 + 16) > v10);
      }
    }
  }
  if (*(_BYTE *)(a1 + 133))
    AU::BSS2::FixWNG<float>(*(_QWORD **)(a1 + 296), *(_QWORD **)(a1 + 336), *(_QWORD **)(a1 + 328), *(_QWORD *)(a1 + 320), *(_QWORD *)(a1 + 112), *(float *)(a1 + 124));
  if (*(_BYTE *)(a1 + 132))
    AU::BSS2::MixturePhase<float>(*(_QWORD **)(a1 + 288), *(_QWORD **)(a1 + 336), *(_QWORD **)(a1 + 296), *(_QWORD **)(a1 + 328), **(float *****)(a1 + 320), *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24));
  t3l::tDSP_copy_ztensor_to_freq_abl<float>(**(_QWORD **)(a1 + 296), a3, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16));
  return 0;
}

uint64_t AU::BSS2::AUXIVARLS<float>::UpdateParam(uint64_t a1, int a2, float a3)
{
  uint64_t result;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  unint64_t v14;
  float v15;
  unint64_t v16;
  unint64_t v17;
  float v18;
  unint64_t v19;

  if (!*(_BYTE *)(a1 + 8))
    return 1;
  switch(a2)
  {
    case 0:
      result = 0;
      *(_BYTE *)(a1 + 120) = a3 != 0.0;
      break;
    case 1:
      *(float *)(a1 + 68) = a3;
      v5 = 0.0;
      if (a3 > 0.0)
      {
        v6 = *(float *)(a1 + 36);
        if (v6 <= 0.0)
          __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
        v5 = expf(-1.0 / (float)(v6 * a3));
      }
      result = 0;
      *(float *)(a1 + 72) = v5;
      break;
    case 2:
      result = 0;
      *(_BYTE *)(a1 + 132) = a3 != 0.0;
      break;
    case 3:
      v7 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 52) = v7;
      break;
    case 4:
      v8 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 56) = v8;
      break;
    case 5:
      v9 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 60) = v9;
      break;
    case 6:
      v10 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 64) = v10;
      break;
    case 7:
      result = 0;
      *(_QWORD *)(a1 + 112) = (unint64_t)a3;
      break;
    case 8:
      result = 0;
      *(float *)(a1 + 48) = a3;
      break;
    case 9:
      v11 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 124) = v11;
      break;
    case 10:
      result = 0;
      *(_QWORD *)(a1 + 96) = (unint64_t)a3;
      break;
    case 11:
      v12 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 128) = v12;
      break;
    case 12:
      result = 0;
      *(_QWORD *)(a1 + 80) = vcvtas_u32_f32((float)(*(float *)(a1 + 32) * a3) / (float)*(unint64_t *)(a1 + 40));
      break;
    case 13:
      v13 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 88) = v13;
      break;
    case 14:
      result = 0;
      v14 = *(_QWORD *)(a1 + 24) - 1;
      v15 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      v16 = vcvtas_u32_f32(fabsf(a3 / v15));
      if (v16 < v14)
        v14 = v16;
      *(_QWORD *)(a1 + 136) = v14;
      break;
    case 15:
      result = 0;
      v17 = *(_QWORD *)(a1 + 24) - 1;
      v18 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      v19 = vcvtas_u32_f32(fabsf(a3 / v18));
      if (v19 < v17)
        v17 = v19;
      *(_QWORD *)(a1 + 144) = v17;
      break;
    default:
      return 1;
  }
  return result;
}

uint64_t AU::BSS2::AUXIVARLS<float>::UpdatePrior(uint64_t a1, unint64_t a2, float a3, float a4)
{
  uint64_t v4;
  float v5;
  BOOL v6;
  float v7;

  v4 = *(_QWORD *)(a1 + 168);
  if (a2 > (*(_QWORD *)(a1 + 176) - v4) >> 2)
    __assert_rtn("UpdatePrior", "AUBSS2Algorithm+XIVARLS.h", 366, "index <= priors.size()");
  if (a3 < 0.0)
    a3 = 0.0;
  v5 = a3 + -0.5;
  v6 = a3 <= 1.0;
  v7 = 0.5;
  if (v6)
    v7 = v5;
  *(float *)(v4 + 4 * a2) = expf(v7 * a4);
  return 0;
}

uint64_t AU::BSS2::AUXIVARLS<float>::Reset(uint64_t a1)
{
  unint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  vDSP_Length v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t i;
  float **v11;
  uint64_t v12;
  uint64_t j;
  _QWORD *v14;
  unint64_t v15;
  vDSP_Length v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t k;
  float **v22;
  uint64_t v23;
  uint64_t m;
  float __A;
  float v27;

  if (*(_QWORD *)(a1 + 16))
  {
    v2 = 0;
    do
    {
      t3l::tDSP_ztfilldiag<float>(*(_QWORD **)(*(_QWORD *)(a1 + 232) + 8 * v2), *(float *)(a1 + 88));
      t3l::tDSP_ztfilldiag<float>(*(_QWORD **)(*(_QWORD *)(a1 + 256) + 8 * v2), 1.0 / *(float *)(a1 + 88));
      *(_DWORD *)(*(_QWORD *)(a1 + 168) + 4 * v2++) = 1065353216;
    }
    while (*(_QWORD *)(a1 + 16) > v2);
  }
  v3 = *(_QWORD **)(a1 + 216);
  v4 = v3[1];
  if (v4 != v3[2])
    goto LABEL_25;
  v5 = v3[3];
  __A = 1.0;
  if (v4)
  {
    v6 = 0;
    v7 = 1;
    v8 = v4;
    do
    {
      if (v7)
      {
        v9 = 0;
        for (i = 0; i < v7; ++i)
        {
          v11 = (float **)(*(_QWORD *)(*v3 + 8 * v6) + v9);
          vDSP_vclr(*v11, 1, v5);
          vDSP_vclr(v11[1], 1, v5);
          v7 = v3[2];
          v9 += 16;
        }
        v8 = v3[1];
      }
      ++v6;
    }
    while (v8 > v6);
    v12 = 0;
    for (j = 0; j != v4; ++j)
    {
      vDSP_vfill(&__A, *(float **)(*(_QWORD *)(*v3 + 8 * j) + v12), 1, v5);
      v12 += 16;
    }
  }
  v14 = *(_QWORD **)(a1 + 224);
  v15 = v14[1];
  if (v15 != v14[2])
LABEL_25:
    __assert_rtn("tDSP_zmeye", "Tensor3Lib.h", 513, "N == X.cols");
  v16 = v14[3];
  v27 = 1.0;
  if (v15)
  {
    v17 = 0;
    v18 = 1;
    v19 = v15;
    do
    {
      if (v18)
      {
        v20 = 0;
        for (k = 0; k < v18; ++k)
        {
          v22 = (float **)(*(_QWORD *)(*v14 + 8 * v17) + v20);
          vDSP_vclr(*v22, 1, v16);
          vDSP_vclr(v22[1], 1, v16);
          v18 = v14[2];
          v20 += 16;
        }
        v19 = v14[1];
      }
      ++v17;
    }
    while (v19 > v17);
    v23 = 0;
    for (m = 0; m != v15; ++m)
    {
      vDSP_vfill(&v27, *(float **)(*(_QWORD *)(*v14 + 8 * m) + v23), 1, v16);
      v23 += 16;
    }
  }
  *(_QWORD *)(a1 + 160) = 1;
  *(_QWORD *)(a1 + 104) = 0;
  return 0;
}

void AU::BSS2::AUXIVARLS<float>::~AUXIVARLS(uint64_t a1)
{
  AU::BSS2::AUXIVARLS<float>::~AUXIVARLS(a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AU::BSS2::AUXIVARLS<float>::~AUXIVARLS(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v5;

  *(_QWORD *)a1 = off_1E69C89F0;
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 336), 0);
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 328), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 320), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 312), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 304), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 296), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 288), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 280), 0);
  v5 = (void **)(a1 + 256);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)(a1 + 232);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 224), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 216), 0);
  v2 = *(void **)(a1 + 192);
  if (v2)
  {
    *(_QWORD *)(a1 + 200) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 168);
  if (v3)
  {
    *(_QWORD *)(a1 + 176) = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t *std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void **v5;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v5 = (void **)(v2 + 80);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
    v3 = *(void **)(v2 + 56);
    if (v3)
    {
      *(_QWORD *)(v2 + 64) = v3;
      operator delete(v3);
    }
    v4 = *(void **)(v2 + 32);
    if (v4)
    {
      *(_QWORD *)(v2 + 40) = v4;
      operator delete(v4);
    }
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

uint64_t *std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void **v5;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v5 = (void **)(v2 + 104);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
    v5 = (void **)(v2 + 80);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
    v3 = *(void **)(v2 + 56);
    if (v3)
    {
      *(_QWORD *)(v2 + 64) = v3;
      operator delete(v3);
    }
    v4 = *(void **)(v2 + 32);
    if (v4)
    {
      *(_QWORD *)(v2 + 40) = v4;
      operator delete(v4);
    }
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  uint64_t *v2;
  uint64_t *v4;
  void *v5;

  v1 = *a1;
  v2 = (uint64_t *)**a1;
  if (v2)
  {
    v4 = (uint64_t *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100](--v4, 0);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void t3l::tDSP_ztfilldiag<float>(_QWORD *a1, float a2)
{
  unint64_t v2;
  unint64_t v4;
  unint64_t v5;
  vDSP_Length v6;
  uint64_t v7;
  unint64_t i;
  float **v9;
  uint64_t v10;
  unint64_t v11;
  vDSP_Length v12;
  float v13;
  float __A;

  __A = a2;
  v13 = 0.0;
  v2 = a1[1];
  if (v2)
  {
    v4 = 0;
    v5 = a1[2];
    v6 = a1[3];
    do
    {
      if (v5)
      {
        v7 = 0;
        for (i = 0; i < v5; ++i)
        {
          v9 = (float **)(*(_QWORD *)(*a1 + 8 * v4) + v7);
          vDSP_vclr(*v9, 1, v6);
          vDSP_vclr(v9[1], 1, v6);
          v5 = a1[2];
          v7 += 16;
        }
        v2 = a1[1];
      }
      ++v4;
    }
    while (v2 > v4);
    if (v2)
    {
      v10 = 0;
      v11 = 0;
      v12 = a1[3];
      do
      {
        vDSP_vfill(&__A, *(float **)(*(_QWORD *)(*a1 + 8 * v11) + v10), 1, v12);
        vDSP_vfill(&v13, *(float **)(*(_QWORD *)(*a1 + 8 * v11++) + v10 + 8), 1, v12);
        v10 += 16;
      }
      while (a1[1] > v11);
    }
  }
}

float t3l::tDSP_copy_freq_abl_to_ztensor<float>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  unint64_t i;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  float result;

  if (a3 < a5)
    __assert_rtn("tDSP_copy_freq_abl_to_ztensor", "Tensor3Lib.h", 218, "XInput.rows >= numBuffs");
  if (a5)
  {
    for (i = 0; i < a5; i = (i + 1))
    {
      v6 = *(uint64_t **)(a2 + 8 * i);
      if (a4)
      {
        v7 = 0;
        v8 = *(_QWORD *)(a1 + 16 * i + 16);
        v10 = *v6;
        v9 = (float *)v6[1];
        do
        {
          *(_DWORD *)(v10 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
          v9[v7] = *(float *)(v8 + 4 * a4 + 4 * v7);
          ++v7;
        }
        while (a4 > v7);
      }
      else
      {
        v9 = (float *)v6[1];
      }
      result = *v9;
      *(float *)(*v6 + 4 * a4) = *v9;
      v9[a4] = 0.0;
      *v9 = 0.0;
    }
  }
  return result;
}

void AU::BSS2::GenerateOutput<float>(_QWORD *a1, _QWORD *a2, uint64_t a3, _QWORD *a4, unint64_t a5)
{
  unint64_t v8;
  vDSP_Length v9;
  double v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t i;

  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a3 + 24);
  t3l::tDSP_zmzvmult<float>(a1, a3, a4);
  if (a5)
  {
    v10 = (double)a5 + -1.0;
    if ((double)v8 + -1.0 < v10)
      v10 = (double)v8 + -1.0;
    if (v8)
    {
      v11 = 0;
      v12 = 0;
      v13 = (unint64_t)v10;
      do
      {
        vDSP_zvmul(*(const DSPSplitComplex **)(*a4 + 8 * v12), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a2 + 8 * v13) + v11), 1, *(const DSPSplitComplex **)(*a4 + 8 * v12), 1, v9, 1);
        ++v12;
        v11 += 16;
      }
      while (v8 != v12);
    }
  }
  else if (v8)
  {
    v14 = 0;
    for (i = 0; i != v8; ++i)
    {
      vDSP_zvmul(*(const DSPSplitComplex **)(*a4 + 8 * i), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a2 + 8 * i) + v14), 1, *(const DSPSplitComplex **)(*a4 + 8 * i), 1, v9, 1);
      v14 += 16;
    }
  }
}

void AU::BSS2::FixWNG<float>(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t a4, unint64_t a5, float a6)
{
  vDSP_Length v6;
  unint64_t v10;
  unint64_t v12;
  float *v13;
  double v14;
  unint64_t v15;
  unint64_t v16;
  float *v17;
  float __B;
  int v19;
  float __A;

  __A = a6;
  v6 = a2[3];
  __B = 1.0;
  v19 = v6;
  if (v6 != a1[3])
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 325, "Nf == YOutput.len");
  if (v6 != a3[3])
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 326, "Nf == YMag2.len");
  if (v6 != *(_QWORD *)(a4 + 24))
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 327, "Nf == temp1xNf.len");
  v10 = a1[1];
  if (a2[1] < v10)
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 328, "XMag2.rows >= Nm");
  if (a3[1] < v10)
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 329, "YMag2.rows >= Nm");
  if (!*(_QWORD *)(a4 + 8))
    __assert_rtn("FixWNG", "AUBSS2IVALib.h", 331, "temp1xNf.rows >= 1");
  if (v10)
  {
    v12 = 0;
    v13 = ***(float ****)a4;
    v14 = (double)a5 + -1.0;
    if ((double)v10 + -1.0 < v14)
      v14 = (double)v10 + -1.0;
    v15 = (unint64_t)v14;
    do
    {
      if (a5)
        v16 = v15;
      else
        v16 = v12;
      vDSP_vdiv(**(const float ***)(*a2 + 8 * v16), 1, **(const float ***)(*a3 + 8 * v16), 1, v13, 1, v6);
      vvsqrtf(v13, v13, &v19);
      vDSP_svdiv(&__A, v13, 1, v13, 1, v6);
      vDSP_vmin(v13, 1, &__B, 0, v13, 1, v6);
      vDSP_zrvmul(*(const DSPSplitComplex **)(*a1 + 8 * v12), 1, v13, 1, *(const DSPSplitComplex **)(*a1 + 8 * v12), 1, v6);
      v17 = **(float ***)(*a3 + 8 * v12);
      vDSP_vmul(v17, 1, v13, 1, v17, 1, v6);
      ++v12;
    }
    while (v10 != v12);
  }
}

void AU::BSS2::MixturePhase<float>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, float ***a5, vDSP_Length __N)
{
  uint64_t v6;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  int v15;

  v6 = a1[3];
  v15 = v6;
  if (v6 != a2[3])
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 296, "Nf == XMag2.len");
  if (v6 != a3[3])
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 297, "Nf == YOutput.len");
  if (v6 != a4[3])
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 298, "Nf == YMag2.len");
  if (v6 != __N)
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 299, "Nf == temp1xNf.len");
  v12 = a1[1];
  if (v12 != a2[1])
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 300, "Nm == XMag2.rows");
  if (v12 != a3[1])
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 301, "Nm == YOutput.rows");
  if (v12 != a4[1])
    __assert_rtn("MixturePhase", "AUBSS2IVALib.h", 302, "Nm == YMag2.rows");
  if (v12)
  {
    v13 = 0;
    v14 = **a5;
    do
    {
      vDSP_vdiv(**(const float ***)(*a2 + 8 * v13), 1, **(const float ***)(*a4 + 8 * v13), 1, v14, 1, __N);
      vvsqrtf(v14, v14, &v15);
      vDSP_zrvmul(*(const DSPSplitComplex **)(*a1 + 8 * v13), 1, v14, 1, *(const DSPSplitComplex **)(*a3 + 8 * v13), 1, __N);
      ++v13;
    }
    while (v12 != v13);
  }
}

float t3l::tDSP_copy_ztensor_to_freq_abl<float>(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t i;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float result;

  if (a4)
  {
    for (i = 0; i != a4; ++i)
    {
      v5 = *(_QWORD *)(a2 + 16 * i + 16);
      v6 = *(uint64_t **)(a1 + 8 * i);
      v7 = *v6;
      if (a3)
      {
        v8 = 0;
        v9 = v6[1];
        do
        {
          *(_DWORD *)(v5 + 4 * v8) = *(_DWORD *)(v7 + 4 * v8);
          *(_DWORD *)(v5 + 4 * a3 + 4 * v8) = *(_DWORD *)(v9 + 4 * v8);
          ++v8;
        }
        while (a3 > v8);
      }
      result = *(float *)(v7 + 4 * a3);
      *(float *)(v5 + 4 * a3) = result;
    }
  }
  return result;
}

void t3l::tDSP_zmzvmult<float>(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  vDSP_Length __N;
  unint64_t v7;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  uint64_t j;

  __N = a1[3];
  if (__N != *(_QWORD *)(a2 + 24) || __N != a3[3])
    __assert_rtn("tDSP_zmzvmult", "Tensor3Lib.h", 603, "A.len == b.len && (A.len == c.len)");
  v7 = a1[2];
  if (v7 != *(_QWORD *)(a2 + 8))
    __assert_rtn("tDSP_zmzvmult", "Tensor3Lib.h", 604, "A.cols == b.rows");
  if (*(_QWORD *)(a2 + 16) != 1)
    __assert_rtn("tDSP_zmzvmult", "Tensor3Lib.h", 605, "b.cols == 1");
  if (a3[2] != 1)
    __assert_rtn("tDSP_zmzvmult", "Tensor3Lib.h", 606, "c.cols == 1");
  v9 = a1[1];
  if (v9)
  {
    for (i = 0; i != v9; ++i)
    {
      vDSP_zvmul(*(const DSPSplitComplex **)(*a1 + 8 * i), 1, **(const DSPSplitComplex ***)a2, 1, *(const DSPSplitComplex **)(*a3 + 8 * i), 1, __N, 1);
      if (v7 >= 2)
      {
        v11 = 16;
        for (j = 1; j != v7; ++j)
        {
          vDSP_zvma((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * i) + v11), 1, *(const DSPSplitComplex **)(*(_QWORD *)a2 + 8 * j), 1, *(const DSPSplitComplex **)(*a3 + 8 * i), 1, *(const DSPSplitComplex **)(*a3 + 8 * i), 1, __N);
          v11 += 16;
        }
      }
    }
  }
}

BOOL AU::BSS2::AboveMinEnergyThreshold<float>(_QWORD *a1, float a2)
{
  unint64_t v4;
  vDSP_Length v5;
  float v6;
  float v7;
  float __C;

  if (a1[1])
  {
    v4 = 0;
    v5 = a1[3];
    v6 = 3.4028e38;
    do
    {
      __C = 0.0;
      vDSP_sve(**(const float ***)(*a1 + 8 * v4), 1, &__C, v5);
      v7 = sqrtf((float)(fabsf(__C) / (float)((float)v5 + 2.2204e-16)) + 2.2204e-16);
      if (v7 < v6)
        v6 = v7;
      ++v4;
    }
    while (v4 < a1[1]);
  }
  else
  {
    v6 = 3.4028e38;
  }
  return v6 >= a2;
}

void t3l::tDSP_ztvztvhmultupper<float>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  vDSP_Length v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = a1[1];
  if (v3 != a2[1])
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 832, "a.rows == b.rows");
  if (a1[2] != a2[2])
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 833, "a.cols == b.cols");
  if (a3[1] != v3)
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 834, "C.rows == a.rows");
  if (a3[2] != v3)
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 835, "C.cols == a.rows");
  v7 = a1[3];
  if (v7 != a3[3])
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 836, "a.len == C.len");
  if (a2[3] != v7)
    __assert_rtn("tDSP_ztvztvhmultupper", "Tensor3Lib.h", 837, "b.len == C.len");
  if (v3)
  {
    v8 = 0;
    for (i = 0; i != v3; ++i)
    {
      v10 = v8;
      v11 = i;
      do
      {
        vDSP_zvmul(*(const DSPSplitComplex **)(*a2 + 8 * v11++), 1, *(const DSPSplitComplex **)(*a1 + 8 * i), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a3 + 8 * i) + v10), 1, v7, -1);
        v10 += 16;
      }
      while (v3 != v11);
      v8 += 16;
    }
    v12 = 0;
    v13 = 8;
    do
    {
      vDSP_vclr(*(float **)(*(_QWORD *)(*a3 + 8 * v12++) + v13), 1, v7);
      v13 += 16;
    }
    while (v3 != v12);
  }
}

void t3l::tDSP_zmsreg<float>(_QWORD *a1, const float *__B)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  vDSP_Length v7;
  float *v8;

  v2 = a1[1];
  if (v2 != a1[2])
    __assert_rtn("tDSP_zmsreg", "Tensor3Lib.h", 880, "Nm == A.cols");
  if (*__B < 0.0)
    __assert_rtn("tDSP_zmsreg", "Tensor3Lib.h", 881, "reg >= 0");
  if (v2)
  {
    v5 = 0;
    v6 = 0;
    v7 = a1[3];
    do
    {
      v8 = *(float **)(*(_QWORD *)(*a1 + 8 * v6) + v5);
      vDSP_vsadd(v8, 1, __B, v8, 1, v7);
      ++v6;
      v5 += 16;
    }
    while (v2 != v6);
  }
}

void AU::BSS2::UpdateVj<float>(_QWORD *a1, _QWORD *a2, const float ****a3, char a4, float a5, float a6, float a7)
{
  vDSP_Length v10;
  unint64_t v12;
  uint64_t v13;
  unint64_t i;
  unint64_t v15;
  const float **v16;
  float **v17;
  const float **v18;
  float **v19;
  uint64_t v21;
  float __B;
  float v23;
  float v24;

  v24 = a7;
  if (a5 <= 0.0)
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 231, "rk > 0");
  if (a6 < 0.0)
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 232, "covAlpha >= 0");
  if (a7 < 0.0)
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 233, "weightedCovReg >= 0");
  v10 = a1[3];
  if (v10 != a2[3])
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 234, "Nv == Vj.len");
  if ((const float ***)v10 != a3[3])
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 235, "Nv == temp1x1xNf.len");
  if (!a3[1] || !a3[2])
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 236, "temp1x1xNf.rows >= 1 && temp1x1xNf.cols >= 1");
  v12 = a1[1];
  if (a1[2] != v12)
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 237, "xxt.cols == Nm");
  if (a2[1] != v12)
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 238, "Vj.rows == Nm");
  if (a2[2] != v12)
    __assert_rtn("UpdateVj", "AUBSS2IVALib.h", 239, "Vj.cols == Nm");
  __B = 1.0 / a5;
  v23 = a6 / (float)(1.0 - a6);
  if (v12)
  {
    v13 = 0;
    for (i = 0; i != v12; ++i)
    {
      v21 = v13;
      v15 = i;
      do
      {
        v16 = (const float **)(*(_QWORD *)(*a1 + 8 * i) + v13);
        v17 = (float **)**a3;
        vDSP_vsmul(*v16, 1, &__B, *v17, 1, v10);
        vDSP_vsmul(v16[1], 1, &__B, v17[1], 1, v10);
        v18 = **a3;
        v19 = (float **)(*(_QWORD *)(*a2 + 8 * i) + v13);
        vDSP_vavlin(*v18, 1, &v23, *v19, 1, v10);
        vDSP_vavlin(v18[1], 1, &v23, v19[1], 1, v10);
        ++v15;
        v13 += 16;
      }
      while (v15 < v12);
      v13 = v21 + 16;
    }
  }
  if ((a4 & 1) != 0)
    t3l::tDSP_ztsymmetric<float>(a2);
  if (a7 > 0.0)
    t3l::tDSP_zmsreg<float>(a2, &v24);
}

_QWORD *t3l::tDSP_zmeyef<float>(_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v4;
  uint64_t *v5;
  float v6;
  uint64_t v7;

  v2 = result[1];
  if (v2 != result[2])
    __assert_rtn("tDSP_zmeyef", "Tensor3Lib.h", 527, "X.rows == X.cols");
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = 0;
      v5 = (uint64_t *)(*(_QWORD *)(*result + 8 * i) + 8);
      do
      {
        if (i == v4)
          v6 = 1.0;
        else
          v6 = 0.0;
        *(float *)(*(v5 - 1) + 4 * a2) = v6;
        v7 = *v5;
        v5 += 2;
        *(_DWORD *)(v7 + 4 * a2) = 0;
        ++v4;
      }
      while (v2 != v4);
    }
  }
  return result;
}

void t3l::tDSP_ztsymmetric<float>(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  vDSP_Length v4;
  uint64_t v5;
  uint64_t i;

  v1 = a1[1];
  if (v1 != a1[2])
    __assert_rtn("tDSP_ztsymmetric", "Tensor3Lib.h", 576, "A.rows == A.cols");
  if (v1)
  {
    v3 = 0;
    v4 = a1[3];
    do
    {
      if (v3)
      {
        v5 = 0;
        for (i = 0; i != v3; ++i)
        {
          vDSP_zvconj((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * i) + 16 * v3), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v3) + v5), 1, v4);
          v5 += 16;
        }
      }
      vDSP_vclr(*(float **)(*(_QWORD *)(*a1 + 8 * v3) + 16 * v3 + 8), 1, v4);
      ++v3;
    }
    while (v3 != v1);
  }
}

void t3l::tDSP_zminverselu<float>(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  unint64_t v11;
  vDSP_Length v12;
  uint64_t i;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  vDSP_Length v17;
  uint64_t v18;
  unint64_t j;
  float **v20;
  uint64_t k;
  _QWORD *v22;
  uint64_t *v23;
  const DSPSplitComplex ***v24;
  float __A;

  t3l::tDSP_ztmov<float>(a1, a4);
  v22 = a3;
  v24 = (const DSPSplitComplex ***)a6;
  t3l::tDSP_zmlu<float>(a4, a3, a5, (const DSPSplitComplex ***)a6);
  v11 = a4[1];
  v23 = a4;
  if (a4[2] < v11)
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1117, "lu.cols >= n");
  if (a5[1] < v11)
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1118, "tempNx1xNf.rows >= n");
  if (!*(_QWORD *)(a6 + 8))
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1119, "temp1x1xNf.rows >= 1");
  if (a2[1] < v11)
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1120, "inv.rows >= n");
  if (a2[2] < v11)
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1121, "inv.cols >= n");
  v12 = a4[3];
  if (v12 != a2[3] || v12 != a3[3] || v12 != a5[3] || v12 != *(_QWORD *)(a6 + 24))
    __assert_rtn("tDSP_zminverse_from_lu", "Tensor3Lib.h", 1126, "lu.len == inv.len && lu.len == pivotNx1xNf.len && lu.len == tempNx1xNf.len && lu.len == temp1x1xNf.len && lu.len == inv.len");
  __A = 1.0;
  if (v11)
  {
    for (i = 0; i != v11; ++i)
    {
      v14 = a5[1];
      if (v14)
      {
        v15 = 0;
        v16 = a5[2];
        v17 = a5[3];
        do
        {
          if (v16)
          {
            v18 = 0;
            for (j = 0; j < v16; ++j)
            {
              v20 = (float **)(*(_QWORD *)(*a5 + 8 * v15) + v18);
              vDSP_vclr(*v20, 1, v17);
              vDSP_vclr(v20[1], 1, v17);
              v16 = a5[2];
              v18 += 16;
            }
            v14 = a5[1];
          }
          ++v15;
        }
        while (v14 > v15);
      }
      vDSP_vfill(&__A, **(float ***)(*a5 + 8 * i), 1, v12);
      t3l::tDSP_zmsolvelu<float>(v23, v22, a5, v24);
      for (k = 0; k != v11; ++k)
        vDSP_zvmov(*(const DSPSplitComplex **)(*a5 + 8 * k), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a2 + 8 * k) + 16 * i), 1, v12);
    }
  }
}

void t3l::tDSP_ztmov<float>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v5;
  vDSP_Length v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;

  v2 = a1[1];
  if (v2 != a2[1])
    __assert_rtn("tDSP_ztmov", "Tensor3Lib.h", 355, "rows == lhs.rows");
  v5 = a1[2];
  if (v5 != a2[2])
    __assert_rtn("tDSP_ztmov", "Tensor3Lib.h", 356, "cols == lhs.cols");
  v6 = a1[3];
  if (v6 != a2[3])
    __assert_rtn("tDSP_ztmov", "Tensor3Lib.h", 357, "Nv == lhs.len");
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      if (v5)
      {
        v8 = 0;
        v9 = v5;
        do
        {
          vDSP_zvmov((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * i) + v8), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a2 + 8 * i) + v8), 1, v6);
          v8 += 16;
          --v9;
        }
        while (v9);
      }
    }
  }
}

void AU::BSS2::UpdateWScale<float>(_QWORD *a1, unint64_t a2, uint64_t a3, _QWORD *a4, const DSPSplitComplex ***a5, const DSPSplitComplex ***a6)
{
  uint64_t v6;
  unint64_t v7;
  vDSP_Length __N;
  unint64_t v14;
  const DSPSplitComplex *v15;
  const DSPSplitComplex *v16;
  const DSPSplitComplex *v17;
  uint64_t v18;
  unint64_t i;
  const DSPSplitComplex *v20;
  const DSPSplitComplex *v21;
  uint64_t v22;
  uint64_t v23;
  float *realp;
  uint64_t v25;
  uint64_t v26;
  float __A;
  int v29;
  float v30;

  v6 = a1[3];
  v7 = a1[1];
  __A = 1.0;
  v29 = v6;
  __N = (int)v6;
  if ((int)v6 != *(_QWORD *)(a3 + 24))
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 41, "Nf == Vj.len");
  if ((int)v6 != a4[3])
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 42, "Nf == Wout.len");
  if ((const DSPSplitComplex **)(int)v6 != a5[3])
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 43, "Nf == tempNx1xNf.len");
  if ((const DSPSplitComplex **)(int)v6 != a6[3])
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 44, "Nf == temp1x1xNf.len");
  if (v7 <= a2)
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 46, "j < Nm");
  if (*(_QWORD *)(a3 + 8) != v7)
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 47, "Vj.rows == Nm");
  if (*(_QWORD *)(a3 + 16) != v7)
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 48, "Vj.cols == Nm");
  if (a4[1] != v7)
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 49, "Wout.rows == Nm");
  if (a4[2] != v7)
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 50, "Wout.cols == Nm");
  if (a1[2] != v7)
    __assert_rtn("UpdateWScale", "AUBSS2IVALib.h", 51, "Win.cols == Nm");
  v14 = 0;
  do
  {
    if (v14)
    {
      vDSP_zvconj((const DSPSplitComplex *)(**(_QWORD **)a3 + 16 * v14), 1, **a6, 1, __N);
      v15 = *(const DSPSplitComplex **)(*a1 + 8 * a2);
      v16 = **a6;
      v17 = (*a5)[v14];
    }
    else
    {
      v15 = *(const DSPSplitComplex **)(*a1 + 8 * a2);
      v16 = **(const DSPSplitComplex ***)a3;
      v17 = **a5;
    }
    vDSP_zvmul(v15, 1, v16, 1, v17, 1, __N, -1);
    if (v7 >= 2)
    {
      v18 = 16;
      for (i = 1; i != v7; ++i)
      {
        if (v14 <= i)
        {
          v20 = (const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * a2) + v18);
          v21 = (const DSPSplitComplex *)(*(_QWORD *)(*(_QWORD *)a3 + 8 * v14) + v18);
        }
        else
        {
          vDSP_zvconj((const DSPSplitComplex *)(*(_QWORD *)(*(_QWORD *)a3 + 8 * i) + 16 * v14), 1, **a6, 1, __N);
          v20 = (const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * a2) + v18);
          v21 = **a6;
        }
        vDSP_zvcma(v20, 1, v21, 1, (*a5)[v14], 1, (*a5)[v14], 1, __N);
        v18 += 16;
      }
    }
    ++v14;
  }
  while (v14 != v7);
  vDSP_zvmul(*(const DSPSplitComplex **)(*a1 + 8 * a2), 1, **a5, 1, **a6, 1, __N, 1);
  if (v7 >= 2)
  {
    v22 = 1;
    v23 = 16;
    do
    {
      vDSP_zvma((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * a2) + v23), 1, (*a5)[v22++], 1, **a6, 1, **a6, 1, __N);
      v23 += 16;
    }
    while (v7 != v22);
  }
  realp = (**a6)->realp;
  v30 = 1.0e-16;
  vDSP_vabs(realp, 1, realp, 1, __N);
  vDSP_vsadd(realp, 1, &v30, realp, 1, __N);
  vvsqrtf((**a6)->realp, (**a6)->realp, &v29);
  vDSP_svdiv(&__A, (**a6)->realp, 1, (**a6)->realp, 1, v29);
  v25 = 0;
  if (v7 <= 1)
    v26 = 1;
  else
    v26 = v7;
  do
  {
    vDSP_zrvmul((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * a2) + v25), 1, (**a6)->realp, 1, (const DSPSplitComplex *)(*(_QWORD *)(*a4 + 8 * a2) + v25), 1, v29);
    v25 += 16;
    --v26;
  }
  while (v26);
}

void AU::BSS2::UpdateWProject<float>(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5, uint64_t *a6, const DSPSplitComplex ***a7, float a8)
{
  vDSP_Length v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  vDSP_Length v20;
  uint64_t v21;
  unint64_t i;
  float **v23;
  uint64_t v24;
  uint64_t j;
  _QWORD *v26;
  _QWORD *v27;
  const DSPSplitComplex ***v28;
  float __A;
  float __B;

  __B = a8;
  v16 = a1[2];
  v15 = a1[3];
  __A = 1.0;
  t3l::tDSP_zmzmuppermult<float>(a1, a3, a5);
  if (a8 > 0.0)
    t3l::tDSP_zmsreg<float>(a5, &__B);
  v26 = a5;
  v27 = a4;
  v28 = a7;
  t3l::tDSP_zmlu<float>(a5, a4, a6, a7);
  v17 = a6[1];
  if (v17)
  {
    v18 = 0;
    v19 = a6[2];
    v20 = a6[3];
    do
    {
      if (v19)
      {
        v21 = 0;
        for (i = 0; i < v19; ++i)
        {
          v23 = (float **)(*(_QWORD *)(*a6 + 8 * v18) + v21);
          vDSP_vclr(*v23, 1, v20);
          vDSP_vclr(v23[1], 1, v20);
          v19 = a6[2];
          v21 += 16;
        }
        v17 = a6[1];
      }
      ++v18;
    }
    while (v17 > v18);
  }
  vDSP_vfill(&__A, **(float ***)(*a6 + 8 * a2), 1, v15);
  t3l::tDSP_zmsolvelu<float>(v26, v27, a6, v28);
  if (v16)
  {
    v24 = 0;
    for (j = 0; j != v16; ++j)
    {
      vDSP_zvconj(*(const DSPSplitComplex **)(*a6 + 8 * j), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * a2) + v24), 1, v15);
      v24 += 16;
    }
  }
}

void t3l::tDSP_zmzmuppermult<float>(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  vDSP_Length __N;
  uint64_t v10;
  uint64_t v11;
  unint64_t i;
  uint64_t v13;
  unint64_t j;
  const DSPSplitComplex *v15;
  uint64_t v16;

  v3 = a1[2];
  if (v3 != *(_QWORD *)(a2 + 8) || a3[1] < v3)
    __assert_rtn("tDSP_zmzmuppermult", "Tensor3Lib.h", 629, "A.cols == B.rows && C.rows >= A.cols");
  __N = a1[3];
  if (__N != *(_QWORD *)(a2 + 24) || __N != a3[3])
    __assert_rtn("tDSP_zmzmuppermult", "Tensor3Lib.h", 630, "A.len == B.len && (A.len == C.len)");
  v16 = a1[1];
  if (v16)
  {
    v10 = 0;
    v11 = *(_QWORD *)(a2 + 16);
    do
    {
      if (v11)
      {
        for (i = 0; i != v11; ++i)
        {
          vDSP_zvmul(*(const DSPSplitComplex **)(*a1 + 8 * v10), 1, (const DSPSplitComplex *)(**(_QWORD **)a2 + 16 * i), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a3 + 8 * v10) + 16 * i), 1, __N, 1);
          if (v3 >= 2)
          {
            v13 = 16;
            for (j = 1; j != v3; ++j)
            {
              v15 = (const DSPSplitComplex *)(*(_QWORD *)(*a3 + 8 * v10) + 16 * i);
              if (j <= i)
                vDSP_zvma((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v10) + v13), 1, (const DSPSplitComplex *)(*(_QWORD *)(*(_QWORD *)a2 + 8 * j) + 16 * i), 1, v15, 1, v15, 1, __N);
              else
                vDSP_zvcma((const DSPSplitComplex *)(*(_QWORD *)(*(_QWORD *)a2 + 8 * i) + v13), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v10) + v13), 1, v15, 1, v15, 1, __N);
              v13 += 16;
            }
          }
        }
      }
      ++v10;
    }
    while (v10 != v16);
  }
}

void t3l::tDSP_zmlu<float>(uint64_t *a1, _QWORD *a2, _QWORD *a3, const DSPSplitComplex ***a4)
{
  uint64_t v4;
  vDSP_Length __N;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v12;
  float *v13;
  const DSPSplitComplex *v14;
  float *realp;
  uint64_t v16;
  unint64_t v17;
  float *v18;
  float *v19;
  float *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  float *v41;
  float *v42;
  vDSP_Length v43;
  uint64_t v44;
  const DSPSplitComplex *v45;
  uint64_t v46;
  const DSPSplitComplex *v47;
  _QWORD *v48;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  float *__C;
  float v54;
  float __A;
  float __B;

  v4 = a1[2];
  __N = a1[3];
  v6 = a1[1];
  __A = 1.0;
  __B = 2.2204e-16;
  if (v4 != v6)
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 923, "lu.cols == n");
  v7 = a3;
  if (a3[1] < v6)
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 924, "tempNx1xNf.rows >= n");
  if (!a4[1])
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 925, "temp1x1xNf.rows >= 1");
  if (__N > a2[3] || __N > a3[3] || __N > (unint64_t)a4[3])
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 928, "Nv <= pivotNx1xNf.len && Nv <= tempNx1xNf.len && Nv <= temp1x1xNf.len");
  if (v6 <= 1)
    __assert_rtn("tDSP_zmlu", "Tensor3Lib.h", 929, "n > 1");
  v12 = 0;
  v13 = *(float **)(*(_QWORD *)*a3 + 8);
  v14 = **a4;
  realp = v14->realp;
  __C = v14->imagp;
  do
  {
    vDSP_vclr(**(float ***)(*v7 + 8 * v12), 1, __N);
    v16 = 0;
    v17 = v6;
    do
    {
      vDSP_zvabs((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v12) + v16), 1, *(float **)(*(_QWORD *)*v7 + 8), 1, __N);
      v18 = **(float ***)(*v7 + 8 * v12);
      vDSP_vmax(v18, 1, *(const float **)(*(_QWORD *)*v7 + 8), 1, v18, 1, __N);
      v16 += 16;
      --v17;
    }
    while (v17);
    v19 = **(float ***)(*v7 + 8 * v12);
    vDSP_vsadd(v19, 1, &__B, v19, 1, __N);
    v20 = **(float ***)(*v7 + 8 * v12);
    vDSP_svdiv(&__A, v20, 1, v20, 1, __N);
    ++v12;
  }
  while (v12 != v6);
  v21 = 0;
  v48 = v7;
  v22 = 1;
  v51 = v6;
  v52 = 16;
  do
  {
    vDSP_vclr(realp, 1, __N);
    v54 = (float)(int)v21;
    vDSP_vfill(&v54, __C, 1, __N);
    v23 = v21;
    do
    {
      while (1)
      {
        vDSP_zvabs((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v23) + 16 * v21), 1, v13, 1, __N);
        vDSP_vmul(v13, 1, **(const float ***)(*v7 + 8 * v23), 1, v13, 1, __N);
        if (__N)
          break;
        ++v23;
        v25 = __C;
        if (v23 == v6)
          goto LABEL_32;
      }
      v24 = 0;
      v25 = __C;
      do
      {
        v26 = v13[v24];
        if (v26 > realp[v24])
        {
          realp[v24] = v26;
          __C[v24] = (float)(int)v23;
        }
        ++v24;
      }
      while (__N != v24);
      ++v23;
    }
    while (v23 != v6);
    v27 = 0;
    v28 = *a1;
    v29 = *v7;
    do
    {
      v30 = (unint64_t)__C[v27];
      if (v21 != v30)
      {
        v31 = (uint64_t *)(*(_QWORD *)(v28 + 8 * v21) + 8);
        v32 = (uint64_t *)(*(_QWORD *)(v28 + 8 * v30) + 8);
        v33 = v6;
        do
        {
          v34 = *(v32 - 1);
          v35 = *(v31 - 1);
          v36 = *(_DWORD *)(v34 + 4 * v27);
          *(_DWORD *)(v34 + 4 * v27) = *(_DWORD *)(v35 + 4 * v27);
          *(_DWORD *)(v35 + 4 * v27) = v36;
          v38 = *v32;
          v32 += 2;
          v37 = v38;
          v39 = *v31;
          v31 += 2;
          v40 = *(_DWORD *)(v37 + 4 * v27);
          *(_DWORD *)(v37 + 4 * v27) = *(_DWORD *)(v39 + 4 * v27);
          *(_DWORD *)(v39 + 4 * v27) = v40;
          --v33;
        }
        while (v33);
        *(_DWORD *)(**(_QWORD **)(v29 + 8 * v30) + 4 * v27) = *(_DWORD *)(**(_QWORD **)(v29 + 8 * v21) + 4 * v27);
      }
      ++v27;
    }
    while (v27 != __N);
LABEL_32:
    memcpy(**(void ***)(*a2 + 8 * v21), v25, 4 * __N);
    vDSP_zvabs((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v21) + 16 * v21), 1, v13, 1, __N);
    if (__N)
    {
      v41 = *(float **)(*(_QWORD *)(*a1 + 8 * v21) + 16 * v21);
      v42 = v13;
      v43 = __N;
      do
      {
        if (*v42 <= 0.0)
          *v41 = __B;
        ++v41;
        ++v42;
        --v43;
      }
      while (v43);
    }
    v44 = v22;
    v50 = v21 + 1;
    if (v6 > v21 + 1)
    {
      do
      {
        v45 = (const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v44) + 16 * v21);
        vDSP_zvdiv((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v21) + 16 * v21), 1, v45, 1, v45, 1, __N);
        vDSP_zvneg((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v44) + 16 * v21), 1, **a4, 1, __N);
        v46 = v52;
        do
        {
          v47 = (const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v44) + v46);
          vDSP_zvma(**a4, 1, (const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v21) + v46), 1, v47, 1, v47, 1, __N);
          --v6;
          v46 += 16;
        }
        while (v22 != v6);
        ++v44;
        v6 = v51;
      }
      while (v44 != v51);
    }
    ++v22;
    v52 += 16;
    ++v21;
    v7 = v48;
  }
  while (v50 != v6);
}

void t3l::tDSP_zmsolvelu<float>(_QWORD *a1, _QWORD *a2, uint64_t *a3, const DSPSplitComplex ***a4)
{
  unint64_t v4;
  vDSP_Length __N;
  BOOL v9;
  unint64_t v11;
  unint64_t v12;
  const DSPSplitComplex *v13;
  float *realp;
  float *imagp;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t i;
  unint64_t v33;

  v4 = a1[1];
  if (v4 < a1[2])
    __assert_rtn("tDSP_zmsolvelu", "Tensor3Lib.h", 1041, "n >= lu.cols");
  if (a3[1] < v4)
    __assert_rtn("tDSP_zmsolvelu", "Tensor3Lib.h", 1042, "b.rows >= n");
  if (!a4[1])
    __assert_rtn("tDSP_zmsolvelu", "Tensor3Lib.h", 1043, "temp1x1xNf.rows >= 1");
  __N = a1[3];
  v9 = __N > a2[3] || __N > a3[3];
  if (v9 || __N > (unint64_t)a4[3])
    __assert_rtn("tDSP_zmsolvelu", "Tensor3Lib.h", 1048, "Nv <= pivotNx1xNf.len && Nv <= b.len && Nv <= x.len && Nv <= temp1x1xNf.len");
  if (v4)
  {
    v11 = 0;
    v12 = 0;
    v13 = **a4;
    realp = v13->realp;
    imagp = v13->imagp;
    do
    {
      if (__N)
      {
        v16 = 0;
        v17 = **(_QWORD **)(*a2 + 8 * v11);
        v18 = *a3;
        v19 = *(uint64_t **)(*a3 + 8 * v11);
        v20 = *v19;
        v21 = v19[1];
        do
        {
          v22 = *(uint64_t **)(v18 + 8 * (unint64_t)*(float *)(v17 + 4 * v16));
          v24 = *v22;
          v23 = v22[1];
          realp[v16] = *(float *)(v24 + 4 * v16);
          imagp[v16] = *(float *)(v23 + 4 * v16);
          *(_DWORD *)(v24 + 4 * v16) = *(_DWORD *)(v20 + 4 * v16);
          *(_DWORD *)(v23 + 4 * v16) = *(_DWORD *)(v21 + 4 * v16);
          ++v16;
        }
        while (__N != v16);
      }
      if (v12)
      {
        vDSP_zvneg(**a4, 1, **a4, 1, __N);
        v33 = v12;
        v25 = (unint64_t)((double)v12 + -1.0);
        if (v11 > v25)
        {
          v26 = 16 * v25;
          do
          {
            vDSP_zvma((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v11) + v26), 1, *(const DSPSplitComplex **)(*a3 + 8 * v25++), 1, **a4, 1, **a4, 1, __N);
            v26 += 16;
          }
          while (v11 != v25);
        }
        vDSP_zvneg(**a4, 1, **a4, 1, __N);
        v27 = v11 + 1;
        v12 = v33;
      }
      else
      {
        v27 = v11 + 1;
        v12 = v11 + 1;
      }
      vDSP_zvmov(**a4, 1, *(const DSPSplitComplex **)(*a3 + 8 * v11), 1, __N);
      v11 = v27;
    }
    while (v27 != v4);
  }
  v28 = (int)((double)v4 + -1.0);
  if ((v28 & 0x80000000) == 0)
  {
    v29 = 16 * (int)((double)v4 + -1.0) + 16;
    do
    {
      vDSP_zvneg(*(const DSPSplitComplex **)(*a3 + 8 * v28), 1, **a4, 1, __N);
      v30 = v28 + 1;
      for (i = v29; v30 < v4; i += 16)
        vDSP_zvma((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v28) + i), 1, *(const DSPSplitComplex **)(*a3 + 8 * v30++), 1, **a4, 1, **a4, 1, __N);
      vDSP_zvneg(**a4, 1, **a4, 1, __N);
      vDSP_zvdiv((const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v28) + 16 * v28), 1, **a4, 1, *(const DSPSplitComplex **)(*a3 + 8 * v28), 1, __N);
      v29 -= 16;
      v9 = v28-- <= 0;
    }
    while (!v9);
  }
}

void AU::BSS2::vDSP_zmekzvhmultT<float>(_QWORD *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v9;
  vDSP_Length v10;
  uint64_t v11;
  uint64_t i;

  v4 = a1[1];
  if (v4)
  {
    v9 = 0;
    v10 = a1[3];
    do
    {
      v11 = 0;
      for (i = 0; i != v4; ++i)
      {
        vDSP_zvmul(*(const DSPSplitComplex **)(*a3 + 8 * i), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a1 + 8 * v9) + 16 * a2), 1, (const DSPSplitComplex *)(*(_QWORD *)(*a4 + 8 * v9) + v11), 1, v10, 1);
        v11 += 16;
      }
      ++v9;
    }
    while (v9 != v4);
  }
}

void t3l::tDSP_create_vec_tensors<float>(_QWORD *a1, unint64_t a2, unint64_t a3, unint64_t a4, vDSP_Length a5, float a6)
{
  _QWORD *v7;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  vDSP_Length v17;
  uint64_t v18;
  unint64_t i;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t j;
  _QWORD *v25;
  float __A[3];

  __A[0] = a6;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  if (a2)
  {
    v7 = a1;
    if (a2 >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v9 = 8 * a2;
    v10 = (char *)operator new(8 * a2);
    bzero(v10, 8 * a2);
    *v7 = v10;
    v7[1] = &v10[v9];
    v7[2] = &v10[8 * a2];
    if (v9)
    {
      v11 = 0;
      v25 = v7;
      do
      {
        v12 = operator new();
        t3l::ZTensor3<float>::ZTensor3(v12, a3, a4, a5);
        std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)&v10[8 * v11], v12);
        v10 = (char *)*v7;
        v13 = *(_QWORD **)(*v7 + 8 * v11);
        v14 = v13[1];
        if (v14)
        {
          v15 = 0;
          v16 = v13[2];
          v17 = v13[3];
          do
          {
            if (v16)
            {
              v18 = 0;
              for (i = 0; i < v16; ++i)
              {
                v20 = *(_QWORD *)(*v13 + 8 * v15);
                vDSP_vclr(*(float **)(v20 + v18), 1, v17);
                vDSP_vclr(*(float **)(v20 + v18 + 8), 1, v17);
                v16 = v13[2];
                v18 += 16;
              }
              v14 = v13[1];
            }
            ++v15;
          }
          while (v14 > v15);
        }
        ++v11;
        v7 = v25;
      }
      while (v11 < (uint64_t)(v25[1] - (_QWORD)v10) >> 3);
    }
    v21 = 0;
    if (a4 >= a3)
      v22 = a3;
    else
      v22 = a4;
    do
    {
      if (v22)
      {
        v23 = 0;
        for (j = 0; j != v22; ++j)
        {
          vDSP_vfill(__A, *(float **)(*(_QWORD *)(**(_QWORD **)&v10[8 * v21] + 8 * j) + v23), 1, a5);
          v23 += 16;
        }
      }
      ++v21;
    }
    while (v21 != a2);
  }
}

void sub_1B6146FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate(uint64_t **a1)
{
  uint64_t *v1;
  uint64_t *v3;
  uint64_t *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
        std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100](--v3, 0);
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t t3l::ZTensor3<float>::ZTensor3(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  v7 = (uint64_t *)(a1 + 80);
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = a4;
  v8 = (uint64_t *)(a1 + 104);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  if (a2)
  {
    if (a2 >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v9 = a2;
    v10 = operator new(8 * a2);
    bzero(v10, 8 * a2);
    *(_QWORD *)(a1 + 32) = v10;
    *(_QWORD *)(a1 + 40) = &v10[v9];
    *(_QWORD *)(a1 + 48) = &v10[a2];
  }
  else
  {
    v10 = 0;
  }
  v11 = a2 * a3;
  if (a2 * a3)
  {
    if (v11 >> 60)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v12 = (char *)operator new(16 * v11);
    v13 = 0;
    v14 = &v12[16 * v11];
    do
    {
      v15 = &v12[v13];
      *(_QWORD *)v15 = 0;
      *((_QWORD *)v15 + 1) = 0;
      v13 += 16;
    }
    while (16 * a3 * a2 != v13);
    *(_QWORD *)(a1 + 56) = v12;
    *(_QWORD *)(a1 + 64) = v14;
    *(_QWORD *)(a1 + 72) = v14;
  }
  else
  {
    v12 = 0;
  }
  *(_QWORD *)a1 = v10;
  *v10 = v12;
  if (a2)
  {
    v16 = 0;
    v17 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v17++) = **(_QWORD **)a1 + v16;
      v16 += 16 * a3;
    }
    while (a2 != v17);
  }
  std::vector<std::vector<float>>::resize(v7, a2 * a3);
  std::vector<std::vector<float>>::resize(v8, *(_QWORD *)(a1 + 16) * *(_QWORD *)(a1 + 8));
  v18 = *(_QWORD *)(a1 + 80);
  if (*(_QWORD *)(a1 + 88) != v18)
  {
    v19 = 0;
    v20 = 0;
    do
    {
      std::vector<float>::resize(v18 + v19, *(_QWORD *)(a1 + 24));
      std::vector<float>::resize(*(_QWORD *)(a1 + 104) + v19, *(_QWORD *)(a1 + 24));
      ++v20;
      v18 = *(_QWORD *)(a1 + 80);
      v19 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 88) - v18) >> 3) > v20);
  }
  v21 = *(_QWORD *)(a1 + 8);
  if (v21)
  {
    v22 = 0;
    v23 = 0;
    v24 = *(_QWORD *)(a1 + 16);
    do
    {
      if (v24)
      {
        v25 = 0;
        v26 = v22;
        v27 = v24;
        do
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + v26);
          v29 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v23) + v25);
          *v29 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + v26);
          v29[1] = v28;
          v25 += 16;
          v26 += 24;
          --v27;
        }
        while (v27);
      }
      ++v23;
      v22 += 24 * v24;
    }
    while (v23 != v21);
  }
  return a1;
}

void sub_1B61472A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _QWORD *v2;
  void **v3;
  void *v5;
  void *v6;
  va_list va;

  va_start(va, a2);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  v5 = (void *)v2[7];
  if (v5)
  {
    v2[8] = v5;
    operator delete(v5);
  }
  v6 = *v3;
  if (*v3)
  {
    v2[5] = v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t t3l::RTensor3<float>::RTensor3(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 24) = a3;
  *(_OWORD *)(a1 + 32) = 0u;
  v5 = a1 + 56;
  *(_OWORD *)(a1 + 80) = 0u;
  v6 = (uint64_t *)(a1 + 80);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 96) = 0;
  if (a2)
  {
    if (a2 >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v7 = 8 * a2;
    v8 = (char *)operator new(8 * a2);
    bzero(v8, 8 * a2);
    *(_QWORD *)(a1 + 32) = v8;
    *(_QWORD *)(a1 + 40) = &v8[v7];
    *(_QWORD *)(a1 + 48) = &v8[8 * a2];
  }
  std::vector<void const*>::resize(v5, a2);
  v9 = *(_QWORD **)(a1 + 32);
  *(_QWORD *)a1 = v9;
  *v9 = *(_QWORD *)(a1 + 56);
  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)(a1 + 16);
  if (v10)
  {
    v12 = 0;
    for (i = 0; i != v10; ++i)
    {
      *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = **(_QWORD **)a1 + v12;
      v12 += 8 * v11;
    }
  }
  std::vector<std::vector<float>>::resize(v6, v11 * v10);
  v14 = *(_QWORD *)(a1 + 80);
  if (*(_QWORD *)(a1 + 88) != v14)
  {
    v15 = 0;
    v16 = 0;
    do
    {
      std::vector<float>::resize(v14 + v15, *(_QWORD *)(a1 + 24));
      ++v16;
      v14 = *(_QWORD *)(a1 + 80);
      v15 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 88) - v14) >> 3) > v16);
  }
  v17 = *(_QWORD *)(a1 + 8);
  if (v17)
  {
    v18 = 0;
    v19 = 0;
    v20 = *(_QWORD *)(a1 + 16);
    do
    {
      if (v20)
      {
        v21 = 0;
        v22 = v18;
        do
        {
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v19) + 8 * v21++) = *(_QWORD *)(*(_QWORD *)(a1 + 80) + v22);
          v22 += 24;
        }
        while (v20 != v21);
      }
      ++v19;
      v18 += 24 * v20;
    }
    while (v19 != v17);
  }
  return a1;
}

void sub_1B6147498(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;
  va_list va;

  va_start(va, a2);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  v6 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v2 + 64) = v6;
    operator delete(v6);
  }
  v7 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v2 + 40) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

uint64_t AU::BSS2::AUXIVACramer23<float>::Initialize(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, float a5)
{
  float v8;
  float v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  vDSP_Length v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t i;
  float **v22;
  uint64_t v23;
  uint64_t j;
  _QWORD *v25;
  unint64_t v26;
  vDSP_Length v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t k;
  float **v33;
  uint64_t v34;
  uint64_t m;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t result;
  uint64_t v41;
  uint64_t v42;
  float v43;
  double v44;
  float32x2_t v45;
  int8x16_t v46;
  int8x16_t v47;
  __int128 v48;
  uint64_t v49;
  void **v50;

  if (a5 < 0.0)
    return 1;
  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 16) = a4;
  v8 = a5 / (float)a2;
  *(float *)(a1 + 32) = a5;
  *(float *)(a1 + 36) = v8;
  v9 = *(float *)(a1 + 68);
  v10 = 0.0;
  if (v9 > 0.0)
  {
    if (v8 <= 0.0)
      __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
    v10 = expf(-1.0 / (float)(v8 * v9));
  }
  *(float *)(a1 + 72) = v10;
  *(float *)(a1 + 36) = v8;
  *(_QWORD *)(a1 + 24) = a3;
  LODWORD(v48) = 0;
  std::vector<float>::resize(a1 + 192, a4, &v48);
  t3l::tDSP_create_vec_tensors<float>(&v48, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(float *)(a1 + 88));
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate((uint64_t **)(a1 + 232));
  *(_OWORD *)(a1 + 232) = v48;
  *(_QWORD *)(a1 + 248) = v49;
  v49 = 0;
  v48 = 0uLL;
  v50 = (void **)&v48;
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v50);
  v11 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v11, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 216), v11);
  v12 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v12, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  v13 = a1 + 224;
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 224), v12);
  v14 = *(_QWORD **)(a1 + 216);
  v15 = v14[1];
  if (v15 != v14[2])
    goto LABEL_28;
  v16 = v14[3];
  LODWORD(v48) = 1065353216;
  if (v15)
  {
    v17 = 0;
    v18 = 1;
    v19 = v15;
    do
    {
      if (v18)
      {
        v20 = 0;
        for (i = 0; i < v18; ++i)
        {
          v22 = (float **)(*(_QWORD *)(*v14 + 8 * v17) + v20);
          vDSP_vclr(*v22, 1, v16);
          vDSP_vclr(v22[1], 1, v16);
          v18 = v14[2];
          v20 += 16;
        }
        v19 = v14[1];
      }
      ++v17;
    }
    while (v19 > v17);
    v23 = 0;
    for (j = 0; j != v15; ++j)
    {
      vDSP_vfill((const float *)&v48, *(float **)(*(_QWORD *)(*v14 + 8 * j) + v23), 1, v16);
      v23 += 16;
    }
  }
  v25 = *(_QWORD **)v13;
  v26 = *(_QWORD *)(*(_QWORD *)v13 + 8);
  if (v26 != *(_QWORD *)(*(_QWORD *)v13 + 16))
LABEL_28:
    __assert_rtn("tDSP_zmeye", "Tensor3Lib.h", 513, "N == X.cols");
  v27 = v25[3];
  LODWORD(v48) = 1065353216;
  if (v26)
  {
    v28 = 0;
    v29 = 1;
    v30 = v26;
    do
    {
      if (v29)
      {
        v31 = 0;
        for (k = 0; k < v29; ++k)
        {
          v33 = (float **)(*(_QWORD *)(*v25 + 8 * v28) + v31);
          vDSP_vclr(*v33, 1, v27);
          vDSP_vclr(v33[1], 1, v27);
          v29 = v25[2];
          v31 += 16;
        }
        v30 = v25[1];
      }
      ++v28;
    }
    while (v30 > v28);
    v34 = 0;
    for (m = 0; m != v26; ++m)
    {
      vDSP_vfill((const float *)&v48, *(float **)(*(_QWORD *)(*v25 + 8 * m) + v34), 1, v27);
      v34 += 16;
    }
  }
  v36 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v36, *(_QWORD *)(a1 + 16), 1, *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 256), v36);
  v37 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v37, *(_QWORD *)(a1 + 16), 1, *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 264), v37);
  v38 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v38, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 272), v38);
  v39 = *(_QWORD *)(a1 + 16);
  LODWORD(v48) = 1065353216;
  std::vector<float>::resize(a1 + 168, v39, &v48);
  if (*(_QWORD *)(a1 + 16) > 3uLL)
    return 1;
  *(_BYTE *)(a1 + 128) = 0;
  v41 = operator new();
  t3l::RTensor3<float>::RTensor3(v41, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 296), v41);
  v42 = operator new();
  t3l::RTensor3<float>::RTensor3(v42, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 288), v42);
  result = 0;
  v43 = *(float *)(a1 + 32);
  v44 = v43 / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
  v45.i32[0] = 0;
  v45.f32[1] = v43 * 0.5;
  v46 = (int8x16_t)vdupq_n_s64(*(_QWORD *)(a1 + 24) - 1);
  *(_BYTE *)(a1 + 8) = 1;
  *(float *)&v44 = v44;
  v47 = (int8x16_t)vcvtq_u64_f64(vcvtq_f64_f32(vrnda_f32(vabs_f32(vdiv_f32(v45, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v44, 0))))));
  *(int8x16_t *)(a1 + 144) = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v46, (uint64x2_t)v47), v47, v46);
  return result;
}

void sub_1B6147990(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10A0C40CB468F57);
  _Unwind_Resume(a1);
}

uint64_t AU::BSS2::AUXIVACramer23<float>::Process(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  const DSPSplitComplex *v6;
  float *v7;
  vDSP_Length v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD **v11;
  _QWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  unint64_t v15;
  const DSPSplitComplex *v16;
  uint64_t v17;
  double v18;
  long double v19;
  float v20;
  unint64_t v21;
  unint64_t i;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v27;
  const DSPSplitComplex ***v28;
  const DSPSplitComplex ***v29;
  const DSPSplitComplex ***v30;
  vDSP_Length __N;
  uint64_t k;
  uint64_t m;
  unint64_t v34;
  const DSPSplitComplex ***v35;
  const DSPSplitComplex ***v36;
  const DSPSplitComplex ***v37;
  vDSP_Length v38;
  unint64_t v39;
  const DSPSplitComplex *v40;
  float *v41;
  vDSP_Length v42;
  unint64_t v43;
  vDSP_Length v44;
  float *v45;
  const float **v46;
  uint64_t j;
  float __B;
  float v49;

  if (!*(_BYTE *)(a1 + 8))
    return 1;
  ++*(_QWORD *)(a1 + 160);
  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(_QWORD **)(a1 + 256), *(_QWORD *)(*(_QWORD *)(a1 + 256) + 8), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16));
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      v6 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 256) + 8 * v5);
      v7 = **(float ***)(**(_QWORD **)(a1 + 296) + 8 * v5);
      v8 = *(_QWORD *)(a1 + 24);
      __B = 2.2204e-16;
      vDSP_zvmags(v6, 1, v7, 1, v8);
      vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
      ++v5;
    }
    while (*(_QWORD *)(a1 + 16) > v5);
  }
  if (*(_BYTE *)(a1 + 120) && AU::BSS2::AboveMinEnergyThreshold<float>(*(_QWORD **)(a1 + 296), *(float *)(a1 + 132)))
  {
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_QWORD **)(a1 + 256);
    if (v9)
    {
      v11 = (_QWORD **)*v10;
      do
      {
        v12 = *v11++;
        v13 = (_DWORD *)v12[1];
        *(_DWORD *)*v12 = *(_DWORD *)(*v12 + 4);
        *v13 = v13[1];
        --v9;
      }
      while (v9);
    }
    t3l::tDSP_zmzvmult<float>(*(_QWORD **)(a1 + 216), (uint64_t)v10, *(_QWORD **)(a1 + 264));
    if (*(_QWORD *)(a1 + 16))
    {
      v14 = 0;
      v15 = 0;
      do
      {
        v16 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 264) + 8 * v15);
        vDSP_zvmags(v16, 1, v16->realp, 1, *(_QWORD *)(a1 + 24));
        vDSP_sve((const float *)(**(_QWORD **)(**(_QWORD **)(a1 + 264) + 8 * v15) + 4 * *(_QWORD *)(a1 + 144)), 1, (float *)(*(_QWORD *)(a1 + 192) + v14), *(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144));
        v17 = *(_QWORD *)(a1 + 192);
        v18 = (float)(*(float *)(a1 + 48) * 0.5);
        v19 = log2((float)(*(float *)(v17 + 4 * v15) + *(float *)(a1 + 52)));
        v20 = exp2(v19 * v18);
        *(float *)(v17 + 4 * v15) = v20;
        *(float *)(v17 + 4 * v15) = *(float *)(*(_QWORD *)(a1 + 168) + 4 * v15) * v20;
        ++v15;
        v14 += 4;
      }
      while (*(_QWORD *)(a1 + 16) > v15);
    }
    t3l::tDSP_ztvztvhmultupper<float>(*(_QWORD **)(a1 + 256), *(_QWORD **)(a1 + 256), *(_QWORD **)(a1 + 272));
    if (*(float *)(a1 + 56) > 0.0)
      t3l::tDSP_zmsreg<float>(*(_QWORD **)(a1 + 272), (const float *)(a1 + 56));
    v21 = *(_QWORD *)(a1 + 16);
    if (v21)
    {
      for (i = 0; i < v21; ++i)
      {
        AU::BSS2::UpdateVj<float>(*(_QWORD **)(a1 + 272), *(_QWORD **)(*(_QWORD *)(a1 + 232) + 8 * i), *(const float *****)(a1 + 264), *(_BYTE *)(a1 + 128), *(float *)(*(_QWORD *)(a1 + 192) + 4 * i), *(float *)(a1 + 72), *(float *)(a1 + 60));
        v21 = *(_QWORD *)(a1 + 16);
      }
    }
    v23 = *(_QWORD *)(a1 + 96);
    if (v23)
    {
      v24 = (*(_QWORD *)(a1 + 104) + 1) % (unint64_t)(v23 + 1);
      *(_QWORD *)(a1 + 104) = v24;
      if (*(_QWORD *)(a1 + 160) < *(_QWORD *)(a1 + 80) || v24)
        goto LABEL_39;
    }
    else
    {
      *(_QWORD *)(a1 + 104) = 0;
      if (*(_QWORD *)(a1 + 160) < *(_QWORD *)(a1 + 80))
      {
LABEL_39:
        AU::BSS2::GenerateOutput<float>(*(_QWORD **)(a1 + 216), *(_QWORD **)(a1 + 224), *(_QWORD *)(a1 + 256), *(_QWORD **)(a1 + 264), *(_QWORD *)(a1 + 112));
        if (*(_QWORD *)(a1 + 16))
        {
          v39 = 0;
          do
          {
            v40 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 264) + 8 * v39);
            v41 = **(float ***)(**(_QWORD **)(a1 + 288) + 8 * v39);
            v42 = *(_QWORD *)(a1 + 24);
            v49 = 2.2204e-16;
            vDSP_zvmags(v40, 1, v41, 1, v42);
            vDSP_vsadd(v41, 1, &v49, v41, 1, v42);
            ++v39;
          }
          while (*(_QWORD *)(a1 + 16) > v39);
        }
        if (*(_BYTE *)(a1 + 137))
          AU::BSS2::FixWNG<float>(*(_QWORD **)(a1 + 264), *(_QWORD **)(a1 + 296), *(_QWORD **)(a1 + 288), *(_QWORD *)(a1 + 272), *(_QWORD *)(a1 + 112), *(float *)(a1 + 124));
        if (*(_BYTE *)(a1 + 136))
          AU::BSS2::MixturePhase<float>(*(_QWORD **)(a1 + 256), *(_QWORD **)(a1 + 296), *(_QWORD **)(a1 + 264), *(_QWORD **)(a1 + 288), **(float *****)(a1 + 272), *(_QWORD *)(*(_QWORD *)(a1 + 272) + 24));
        if (*(_QWORD *)(a1 + 16))
        {
          v43 = 0;
          v44 = *(_QWORD *)(a1 + 24);
          v45 = ****(float *****)(a1 + 272);
          do
          {
            v46 = *(const float ***)(**(_QWORD **)(a1 + 264) + 8 * v43);
            vDSP_vadd(*v46, 1, v46[1], 1, v45, 1, v44);
            if (v44)
            {
              for (j = 0; j != v44; ++j)
                ;
            }
            ++v43;
            v25 = *(_QWORD *)(a1 + 16);
          }
          while (v25 > v43);
        }
        else
        {
          v25 = 0;
        }
        goto LABEL_54;
      }
    }
    if (v21 == 2)
    {
      v34 = 0;
      do
      {
        AU::BSS2::UpdateWProject23<float>(*(const DSPSplitComplex ****)(a1 + 216), v34, *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v34), *(const DSPSplitComplex ****)(a1 + 272), *(const DSPSplitComplex ****)(a1 + 264), *(float *)(a1 + 64));
        AU::BSS2::UpdateWScale<float>(*(_QWORD **)(a1 + 216), v34, *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v34), *(_QWORD **)(a1 + 216), *(const DSPSplitComplex ****)(a1 + 264), *(const DSPSplitComplex ****)(a1 + 272));
        ++v34;
      }
      while (*(_QWORD *)(a1 + 16) > v34);
      v35 = *(const DSPSplitComplex ****)(a1 + 216);
      if (v35[1] != (const DSPSplitComplex **)2)
        __assert_rtn("tDSP_inverse2x2", "Tensor3Lib.h", 1183, "MatIn.rows == 2");
      v36 = *(const DSPSplitComplex ****)(a1 + 264);
      v37 = *(const DSPSplitComplex ****)(a1 + 224);
      v38 = (vDSP_Length)v35[3];
      vDSP_zvmul(**v35 + 1, 1, (*v35)[1], 1, **v36, 1, v38, 1);
      vDSP_zvneg(**v36, 1, **v36, 1, v38);
      vDSP_zvma(**v35, 1, (*v35)[1] + 1, 1, **v36, 1, **v36, 1, v38);
      t3l::tDSP_zvreciprocal<float>((**v36)->realp, (**v36)->imagp, (**v36)->realp, (**v36)->imagp, v38);
      vDSP_zvmul(**v35, 1, **v36, 1, (*v37)[1] + 1, 1, v38, 1);
      vDSP_zvmul((*v35)[1] + 1, 1, **v36, 1, **v37, 1, v38, 1);
      vDSP_zvneg(**v36, 1, **v36, 1, v38);
      vDSP_zvmul((*v35)[1], 1, **v36, 1, (*v37)[1], 1, v38, 1);
      vDSP_zvmul(**v35 + 1, 1, **v36, 1, **v37 + 1, 1, v38, 1);
    }
    else
    {
      if (v21 != 3)
        __assert_rtn("UpdateUmixing", "AUBSS2Algorithm+XIVACramer23.h", 205, "0");
      v27 = 0;
      do
      {
        AU::BSS2::UpdateWProject23<float>(*(const DSPSplitComplex ****)(a1 + 216), v27, *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v27), *(const DSPSplitComplex ****)(a1 + 272), *(const DSPSplitComplex ****)(a1 + 264), *(float *)(a1 + 64));
        AU::BSS2::UpdateWScale<float>(*(_QWORD **)(a1 + 216), v27, *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v27), *(_QWORD **)(a1 + 216), *(const DSPSplitComplex ****)(a1 + 264), *(const DSPSplitComplex ****)(a1 + 272));
        ++v27;
      }
      while (*(_QWORD *)(a1 + 16) > v27);
      v28 = *(const DSPSplitComplex ****)(a1 + 216);
      if (v28[1] != (const DSPSplitComplex **)3)
        __assert_rtn("tDSP_inverse3x3", "Tensor3Lib.h", 1244, "MIn.rows == 3");
      v29 = *(const DSPSplitComplex ****)(a1 + 224);
      v30 = *(const DSPSplitComplex ****)(a1 + 264);
      __N = (vDSP_Length)v28[3];
      vDSP_zvmul((*v28)[1] + 2, 1, (*v28)[2] + 1, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma((*v28)[1] + 1, 1, (*v28)[2] + 2, 1, **v30, 1, **v29, 1, __N);
      vDSP_zvmul((*v28)[1], 1, (*v28)[2] + 2, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma((*v28)[1] + 2, 1, (*v28)[2], 1, **v30, 1, (*v29)[1], 1, __N);
      vDSP_zvmul((*v28)[1] + 1, 1, (*v28)[2], 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma((*v28)[1], 1, (*v28)[2] + 1, 1, **v30, 1, (*v29)[2], 1, __N);
      vDSP_zvmul(**v28 + 1, 1, (*v28)[2] + 2, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 2, 1, (*v28)[2] + 1, 1, **v30, 1, **v29 + 1, 1, __N);
      vDSP_zvmul(**v28 + 2, 1, (*v28)[2], 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28, 1, (*v28)[2] + 2, 1, **v30, 1, (*v29)[1] + 1, 1, __N);
      vDSP_zvmul(**v28, 1, (*v28)[2] + 1, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 1, 1, (*v28)[2], 1, **v30, 1, (*v29)[2] + 1, 1, __N);
      vDSP_zvmul(**v28 + 2, 1, (*v28)[1] + 1, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 1, 1, (*v28)[1] + 2, 1, **v30, 1, **v29 + 2, 1, __N);
      vDSP_zvmul(**v28, 1, (*v28)[1] + 2, 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 2, 1, (*v28)[1], 1, **v30, 1, (*v29)[1] + 2, 1, __N);
      vDSP_zvmul(**v28 + 1, 1, (*v28)[1], 1, **v30, 1, __N, 1);
      vDSP_zvneg(**v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28, 1, (*v28)[1] + 1, 1, **v30, 1, (*v29)[2] + 2, 1, __N);
      vDSP_zvmul(**v28, 1, **v29, 1, **v30, 1, __N, 1);
      vDSP_zvma(**v28 + 1, 1, (*v29)[1], 1, **v30, 1, **v30, 1, __N);
      vDSP_zvma(**v28 + 2, 1, (*v29)[2], 1, **v30, 1, **v30, 1, __N);
      t3l::tDSP_zvreciprocal<float>((**v30)->realp, (**v30)->imagp, (**v30)->realp, (**v30)->imagp, __N);
      for (k = 0; k != 3; ++k)
      {
        for (m = 0; m != 3; ++m)
          vDSP_zvmul(&(*v29)[k][m], 1, **v30, 1, &(*v29)[k][m], 1, __N, 1);
      }
    }
    goto LABEL_39;
  }
  AU::BSS2::GenerateOutput<float>(*(_QWORD **)(a1 + 216), *(_QWORD **)(a1 + 224), *(_QWORD *)(a1 + 256), *(_QWORD **)(a1 + 264), *(_QWORD *)(a1 + 112));
  v25 = *(_QWORD *)(a1 + 16);
LABEL_54:
  t3l::tDSP_copy_ztensor_to_freq_abl<float>(**(_QWORD **)(a1 + 264), a3, *(_QWORD *)(a1 + 40), v25);
  return 0;
}

uint64_t AU::BSS2::AUXIVACramer23<float>::SideChain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  const DSPSplitComplex *v6;
  float *v7;
  vDSP_Length v8;
  unint64_t v9;
  unint64_t v10;
  const DSPSplitComplex *v11;
  float *v12;
  vDSP_Length v13;
  float __B;
  float v16;

  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(_QWORD **)(a1 + 256), *(_QWORD *)(*(_QWORD *)(a1 + 256) + 8), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16));
  AU::BSS2::GenerateOutput<float>(*(_QWORD **)(a1 + 216), *(_QWORD **)(a1 + 224), *(_QWORD *)(a1 + 256), *(_QWORD **)(a1 + 264), *(_QWORD *)(a1 + 112));
  if (*(_BYTE *)(a1 + 137) || *(_BYTE *)(a1 + 136))
  {
    if (*(_QWORD *)(a1 + 16))
    {
      v5 = 0;
      do
      {
        v6 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 256) + 8 * v5);
        v7 = **(float ***)(**(_QWORD **)(a1 + 296) + 8 * v5);
        v8 = *(_QWORD *)(a1 + 24);
        __B = 2.2204e-16;
        vDSP_zvmags(v6, 1, v7, 1, v8);
        vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
        ++v5;
        v9 = *(_QWORD *)(a1 + 16);
      }
      while (v9 > v5);
      if (v9)
      {
        v10 = 0;
        do
        {
          v11 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 264) + 8 * v10);
          v12 = **(float ***)(**(_QWORD **)(a1 + 288) + 8 * v10);
          v13 = *(_QWORD *)(a1 + 24);
          v16 = 2.2204e-16;
          vDSP_zvmags(v11, 1, v12, 1, v13);
          vDSP_vsadd(v12, 1, &v16, v12, 1, v13);
          ++v10;
        }
        while (*(_QWORD *)(a1 + 16) > v10);
      }
    }
  }
  if (*(_BYTE *)(a1 + 137))
    AU::BSS2::FixWNG<float>(*(_QWORD **)(a1 + 264), *(_QWORD **)(a1 + 296), *(_QWORD **)(a1 + 288), *(_QWORD *)(a1 + 272), *(_QWORD *)(a1 + 112), *(float *)(a1 + 124));
  if (*(_BYTE *)(a1 + 136))
    AU::BSS2::MixturePhase<float>(*(_QWORD **)(a1 + 256), *(_QWORD **)(a1 + 296), *(_QWORD **)(a1 + 264), *(_QWORD **)(a1 + 288), **(float *****)(a1 + 272), *(_QWORD *)(*(_QWORD *)(a1 + 272) + 24));
  t3l::tDSP_copy_ztensor_to_freq_abl<float>(**(_QWORD **)(a1 + 264), a3, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16));
  return 0;
}

uint64_t AU::BSS2::AUXIVACramer23<float>::UpdateParam(uint64_t a1, int a2, float a3)
{
  uint64_t result;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  unint64_t v14;
  float v15;
  unint64_t v16;
  unint64_t v17;
  float v18;
  unint64_t v19;

  if (!*(_BYTE *)(a1 + 8))
    return 1;
  switch(a2)
  {
    case 0:
      result = 0;
      *(_BYTE *)(a1 + 120) = a3 != 0.0;
      break;
    case 1:
      *(float *)(a1 + 68) = a3;
      v5 = 0.0;
      if (a3 > 0.0)
      {
        v6 = *(float *)(a1 + 36);
        if (v6 <= 0.0)
          __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
        v5 = expf(-1.0 / (float)(v6 * a3));
      }
      result = 0;
      *(float *)(a1 + 72) = v5;
      break;
    case 2:
      result = 0;
      *(_BYTE *)(a1 + 136) = a3 != 0.0;
      break;
    case 3:
      v7 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 52) = v7;
      break;
    case 4:
      v8 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 56) = v8;
      break;
    case 5:
      v9 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 60) = v9;
      break;
    case 6:
      v10 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 64) = v10;
      break;
    case 7:
      result = 0;
      *(_QWORD *)(a1 + 112) = (unint64_t)a3;
      break;
    case 8:
      result = 0;
      *(float *)(a1 + 48) = a3;
      break;
    case 9:
      v11 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 124) = v11;
      break;
    case 10:
      result = 0;
      *(_QWORD *)(a1 + 96) = (unint64_t)a3;
      break;
    case 11:
      v12 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 132) = v12;
      break;
    case 12:
      result = 0;
      *(_QWORD *)(a1 + 80) = vcvtas_u32_f32((float)(*(float *)(a1 + 32) * a3) / (float)*(unint64_t *)(a1 + 40));
      break;
    case 13:
      v13 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 88) = v13;
      break;
    case 14:
      result = 0;
      v14 = *(_QWORD *)(a1 + 24) - 1;
      v15 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      v16 = vcvtas_u32_f32(fabsf(a3 / v15));
      if (v16 < v14)
        v14 = v16;
      *(_QWORD *)(a1 + 144) = v14;
      break;
    case 15:
      result = 0;
      v17 = *(_QWORD *)(a1 + 24) - 1;
      v18 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      v19 = vcvtas_u32_f32(fabsf(a3 / v18));
      if (v19 < v17)
        v17 = v19;
      *(_QWORD *)(a1 + 152) = v17;
      break;
    default:
      return 1;
  }
  return result;
}

uint64_t AU::BSS2::AUXIVACramer23<float>::UpdatePrior(uint64_t a1, unint64_t a2, float a3, float a4)
{
  uint64_t v4;
  float v5;
  BOOL v6;
  float v7;

  v4 = *(_QWORD *)(a1 + 168);
  if (a2 > (*(_QWORD *)(a1 + 176) - v4) >> 2)
    __assert_rtn("UpdatePrior", "AUBSS2Algorithm+XIVACramer23.h", 343, "index <= priors.size()");
  if (a3 < 0.0)
    a3 = 0.0;
  v5 = a3 + -0.5;
  v6 = a3 <= 1.0;
  v7 = 0.5;
  if (v6)
    v7 = v5;
  *(float *)(v4 + 4 * a2) = expf(v7 * a4);
  return 0;
}

uint64_t AU::BSS2::AUXIVACramer23<float>::Reset(uint64_t a1)
{
  unint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  vDSP_Length v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t i;
  float **v11;
  uint64_t v12;
  uint64_t j;
  float __A;

  if (*(_QWORD *)(a1 + 16))
  {
    v2 = 0;
    do
    {
      t3l::tDSP_ztfilldiag<float>(*(_QWORD **)(*(_QWORD *)(a1 + 232) + 8 * v2), *(float *)(a1 + 88));
      *(_DWORD *)(*(_QWORD *)(a1 + 168) + 4 * v2++) = 1065353216;
    }
    while (*(_QWORD *)(a1 + 16) > v2);
  }
  v3 = *(_QWORD **)(a1 + 216);
  v4 = v3[1];
  if (v4 != v3[2])
    __assert_rtn("tDSP_zmeye", "Tensor3Lib.h", 513, "N == X.cols");
  v5 = v3[3];
  __A = 1.0;
  if (v4)
  {
    v6 = 0;
    v7 = 1;
    v8 = v4;
    do
    {
      if (v7)
      {
        v9 = 0;
        for (i = 0; i < v7; ++i)
        {
          v11 = (float **)(*(_QWORD *)(*v3 + 8 * v6) + v9);
          vDSP_vclr(*v11, 1, v5);
          vDSP_vclr(v11[1], 1, v5);
          v7 = v3[2];
          v9 += 16;
        }
        v8 = v3[1];
      }
      ++v6;
    }
    while (v8 > v6);
    v12 = 0;
    for (j = 0; j != v4; ++j)
    {
      vDSP_vfill(&__A, *(float **)(*(_QWORD *)(*v3 + 8 * j) + v12), 1, v5);
      v12 += 16;
    }
  }
  *(_QWORD *)(a1 + 160) = 1;
  *(_QWORD *)(a1 + 104) = 0;
  return 0;
}

void AU::BSS2::AUXIVACramer23<float>::~AUXIVACramer23(uint64_t a1)
{
  AU::BSS2::AUXIVACramer23<float>::~AUXIVACramer23(a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AU::BSS2::AUXIVACramer23<float>::~AUXIVACramer23(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v5;

  *(_QWORD *)a1 = off_1E69C89A0;
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 296), 0);
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 288), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 280), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 272), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 264), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 256), 0);
  v5 = (void **)(a1 + 232);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 224), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 216), 0);
  v2 = *(void **)(a1 + 192);
  if (v2)
  {
    *(_QWORD *)(a1 + 200) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 168);
  if (v3)
  {
    *(_QWORD *)(a1 + 176) = v3;
    operator delete(v3);
  }
  return a1;
}

void AU::BSS2::UpdateWProject23<float>(const DSPSplitComplex ***a1, unint64_t a2, uint64_t a3, const DSPSplitComplex ***a4, const DSPSplitComplex ***a5, float a6)
{
  const DSPSplitComplex **v6;
  vDSP_Length v12;
  uint64_t v13;
  uint64_t v14;
  const DSPSplitComplex **i;
  uint64_t v16;
  const DSPSplitComplex **v17;
  vDSP_Length __N;
  const DSPSplitComplex *v19;
  const DSPSplitComplex *v20;
  const DSPSplitComplex *v21;
  const DSPSplitComplex *v22;
  vDSP_Length v23;
  const DSPSplitComplex **v24;
  uint64_t v25;
  const DSPSplitComplex *v26;
  float __A;
  float __B;

  __B = a6;
  v6 = a1[2];
  if (((unint64_t)v6 & 0xFFFFFFFFFFFFFFFELL) != 2)
    __assert_rtn("UpdateWProject23", "AUBSS2IVALib.h", 111, "Nm == 2 || Nm == 3");
  v12 = (vDSP_Length)a1[3];
  t3l::tDSP_zmzmuppermult<float>(a1, a3, a4);
  __A = 1.0;
  v13 = 1;
  vDSP_zvmov(**a4, 1, **a5, 1, v12);
  v14 = 1;
  do
    vDSP_zvadd(&(*a4)[v13++][v14++], 1, **a5, 1, **a5, 1, v12);
  while (v6 != (const DSPSplitComplex **)v13);
  vDSP_zvabs(**a5, 1, (**a5)->realp, 1, v12);
  vDSP_svdiv(&__A, (**a5)->realp, 1, (**a5)->realp, 1, v12);
  if (v6)
  {
    for (i = 0; i != v6; i = (const DSPSplitComplex **)((char *)i + 1))
    {
      v16 = 0;
      v17 = v6;
      do
      {
        vDSP_zrvmul(&(*a4)[(_QWORD)i][v16], 1, (**a5)->realp, 1, &(*a4)[(_QWORD)i][v16], 1, v12);
        ++v16;
        v17 = (const DSPSplitComplex **)((char *)v17 - 1);
      }
      while (v17);
    }
  }
  if (a6 > 0.0)
    t3l::tDSP_zmsreg<float>(a4, &__B);
  if (v6)
  {
    if (v6 == (const DSPSplitComplex **)2)
    {
      if (a4[1] != (const DSPSplitComplex **)2)
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1381, "MIn.rows == 2");
      if (a4[2] != (const DSPSplitComplex **)2)
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1382, "MIn.cols == MIn.rows");
      if (a1[1] != (const DSPSplitComplex **)2)
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1383, "MOut.rows == MIn.rows");
      if (a1[2] != (const DSPSplitComplex **)2)
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1384, "MOut.cols == MIn.rows");
      v23 = (vDSP_Length)a4[3];
      if ((const DSPSplitComplex **)v23 != a1[3])
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1385, "MIn.len == MOut.len");
      if (a2 >= 2)
        __assert_rtn("tDSP_inversecolt2x2", "Tensor3Lib.h", 1386, "jSource < MIn.rows");
      v24 = *a4;
      if (a2)
      {
        vDSP_zvmov(*v24 + 1, 1, (*a1)[1], 1, (vDSP_Length)a4[3]);
        vDSP_zvneg((*a1)[1], 1, (*a1)[1], 1, v23);
        vDSP_zvmov(**a4, 1, (*a1)[1] + 1, 1, v23);
      }
      else
      {
        vDSP_zvmov(v24[1] + 1, 1, **a1, 1, (vDSP_Length)a4[3]);
        vDSP_zvmov((*a4)[1], 1, **a1 + 1, 1, v23);
        vDSP_zvneg(**a1 + 1, 1, **a1 + 1, 1, v23);
      }
    }
    else if (v6 == (const DSPSplitComplex **)3)
    {
      if (a4[1] != (const DSPSplitComplex **)3)
        __assert_rtn("tDSP_inversecolt3x3", "Tensor3Lib.h", 1412, "MIn.rows == 3");
      if (a4[2] != (const DSPSplitComplex **)3)
        __assert_rtn("tDSP_inversecolt3x3", "Tensor3Lib.h", 1413, "MIn.cols == 3");
      if (a2 >= 3)
        __assert_rtn("tDSP_inversecolt3x3", "Tensor3Lib.h", 1414, "jSource < 3");
      __N = (vDSP_Length)a4[3];
      if ((const DSPSplitComplex **)__N != a1[3])
        __assert_rtn("tDSP_inversecolt3x3", "Tensor3Lib.h", 1415, "MIn.len == MOut.len");
      if (a2 == 2)
      {
        vDSP_zvmul(**a4 + 2, 1, (*a4)[1] + 1, 1, **a5, 1, (vDSP_Length)a4[3], 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma(**a4 + 1, 1, (*a4)[1] + 2, 1, **a5, 1, (*a1)[2], 1, __N);
        vDSP_zvmul(**a4, 1, (*a4)[1] + 2, 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma(**a4 + 2, 1, (*a4)[1], 1, **a5, 1, (*a1)[2] + 1, 1, __N);
        vDSP_zvmul(**a4 + 1, 1, (*a4)[1], 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        v19 = **a4;
        v20 = (*a4)[1] + 1;
        v21 = **a5;
        v22 = (*a1)[2];
      }
      else if (a2 == 1)
      {
        vDSP_zvmul(**a4 + 1, 1, (*a4)[2] + 2, 1, **a5, 1, (vDSP_Length)a4[3], 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma(**a4 + 2, 1, (*a4)[2] + 1, 1, **a5, 1, (*a1)[1], 1, __N);
        vDSP_zvmul(**a4 + 2, 1, (*a4)[2], 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma(**a4, 1, (*a4)[2] + 2, 1, **a5, 1, (*a1)[1] + 1, 1, __N);
        vDSP_zvmul(**a4, 1, (*a4)[2] + 1, 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        v19 = **a4 + 1;
        v20 = (*a4)[2];
        v21 = **a5;
        v22 = (*a1)[1];
      }
      else
      {
        vDSP_zvmul((*a4)[1] + 2, 1, (*a4)[2] + 1, 1, **a5, 1, (vDSP_Length)a4[3], 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma((*a4)[1] + 1, 1, (*a4)[2] + 2, 1, **a5, 1, **a1, 1, __N);
        vDSP_zvmul((*a4)[1], 1, (*a4)[2] + 2, 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        vDSP_zvma((*a4)[1] + 2, 1, (*a4)[2], 1, **a5, 1, **a1 + 1, 1, __N);
        vDSP_zvmul((*a4)[1] + 1, 1, (*a4)[2], 1, **a5, 1, __N, 1);
        vDSP_zvneg(**a5, 1, **a5, 1, __N);
        v19 = (*a4)[1];
        v20 = (*a4)[2] + 1;
        v21 = **a5;
        v22 = **a1;
      }
      vDSP_zvma(v19, 1, v20, 1, v21, 1, v22 + 2, 1, __N);
    }
    v25 = 0;
    do
    {
      v26 = &(*a1)[a2][v25];
      vDSP_zvconj(v26, 1, v26, 1, v12);
      ++v25;
      v6 = (const DSPSplitComplex **)((char *)v6 - 1);
    }
    while (v6);
  }
}

void t3l::tDSP_zvreciprocal<float>(float *a1, float *a2, float *a3, float *a4, vDSP_Length __N)
{
  DSPSplitComplex __A;
  int v6;
  int v7;
  DSPSplitComplex __C;
  DSPSplitComplex __B;

  __B.realp = a1;
  __B.imagp = a2;
  __C.realp = a3;
  __C.imagp = a4;
  v6 = 0;
  v7 = 1065353216;
  __A.realp = (float *)&v7;
  __A.imagp = (float *)&v6;
  vDSP_zvdiv(&__B, 1, &__A, 0, &__C, 1, __N);
}

uint64_t AU::BSS2::AUXIVALU<float>::Initialize(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, float a5)
{
  uint64_t result;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  vDSP_Length v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t i;
  float **v23;
  uint64_t v24;
  uint64_t j;
  _QWORD *v26;
  unint64_t v27;
  vDSP_Length v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t k;
  float **v34;
  uint64_t v35;
  uint64_t m;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float v44;
  double v45;
  float32x2_t v46;
  int8x16_t v47;
  int8x16_t v48;
  __int128 v49;
  uint64_t v50;
  void **v51;

  if (a5 < 0.0)
    return 1;
  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 16) = a4;
  v9 = a5 / (float)a2;
  *(float *)(a1 + 32) = a5;
  *(float *)(a1 + 36) = v9;
  v10 = *(float *)(a1 + 68);
  v11 = 0.0;
  if (v10 > 0.0)
  {
    if (v9 <= 0.0)
      __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
    v11 = expf(-1.0 / (float)(v9 * v10));
  }
  *(float *)(a1 + 72) = v11;
  *(float *)(a1 + 36) = v9;
  *(_QWORD *)(a1 + 24) = a3;
  LODWORD(v49) = 0;
  std::vector<float>::resize(a1 + 200, a4, &v49);
  t3l::tDSP_create_vec_tensors<float>(&v49, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(float *)(a1 + 88));
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__vdeallocate((uint64_t **)(a1 + 240));
  *(_OWORD *)(a1 + 240) = v49;
  *(_QWORD *)(a1 + 256) = v50;
  v50 = 0;
  v49 = 0uLL;
  v51 = (void **)&v49;
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v51);
  v12 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v12, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 224), v12);
  v13 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v13, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  v14 = a1 + 232;
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 232), v13);
  v15 = *(_QWORD **)(a1 + 224);
  v16 = v15[1];
  if (v16 != v15[2])
    goto LABEL_27;
  v17 = v15[3];
  LODWORD(v49) = 1065353216;
  if (v16)
  {
    v18 = 0;
    v19 = 1;
    v20 = v16;
    do
    {
      if (v19)
      {
        v21 = 0;
        for (i = 0; i < v19; ++i)
        {
          v23 = (float **)(*(_QWORD *)(*v15 + 8 * v18) + v21);
          vDSP_vclr(*v23, 1, v17);
          vDSP_vclr(v23[1], 1, v17);
          v19 = v15[2];
          v21 += 16;
        }
        v20 = v15[1];
      }
      ++v18;
    }
    while (v20 > v18);
    v24 = 0;
    for (j = 0; j != v16; ++j)
    {
      vDSP_vfill((const float *)&v49, *(float **)(*(_QWORD *)(*v15 + 8 * j) + v24), 1, v17);
      v24 += 16;
    }
  }
  v26 = *(_QWORD **)v14;
  v27 = *(_QWORD *)(*(_QWORD *)v14 + 8);
  if (v27 != *(_QWORD *)(*(_QWORD *)v14 + 16))
LABEL_27:
    __assert_rtn("tDSP_zmeye", "Tensor3Lib.h", 513, "N == X.cols");
  v28 = v26[3];
  LODWORD(v49) = 1065353216;
  if (v27)
  {
    v29 = 0;
    v30 = 1;
    v31 = v27;
    do
    {
      if (v30)
      {
        v32 = 0;
        for (k = 0; k < v30; ++k)
        {
          v34 = (float **)(*(_QWORD *)(*v26 + 8 * v29) + v32);
          vDSP_vclr(*v34, 1, v28);
          vDSP_vclr(v34[1], 1, v28);
          v30 = v26[2];
          v32 += 16;
        }
        v31 = v26[1];
      }
      ++v29;
    }
    while (v31 > v29);
    v35 = 0;
    for (m = 0; m != v27; ++m)
    {
      vDSP_vfill((const float *)&v49, *(float **)(*(_QWORD *)(*v26 + 8 * m) + v35), 1, v28);
      v35 += 16;
    }
  }
  v37 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v37, *(_QWORD *)(a1 + 16), 1, *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 264), v37);
  v38 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v38, *(_QWORD *)(a1 + 16), 1, *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 272), v38);
  v39 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v39, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 280), v39);
  v40 = *(_QWORD *)(a1 + 16);
  LODWORD(v49) = 1065353216;
  std::vector<float>::resize(a1 + 176, v40, &v49);
  v41 = operator new();
  t3l::ZTensor3<float>::ZTensor3(v41, 1uLL, 1, *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 288), v41);
  v42 = operator new();
  t3l::RTensor3<float>::RTensor3(v42, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 304), v42);
  v43 = operator new();
  t3l::RTensor3<float>::RTensor3(v43, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 296), v43);
  result = 0;
  v44 = *(float *)(a1 + 32);
  v45 = v44 / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
  v46.i32[0] = 0;
  v46.f32[1] = v44 * 0.5;
  v47 = (int8x16_t)vdupq_n_s64(*(_QWORD *)(a1 + 24) - 1);
  *(_BYTE *)(a1 + 8) = 1;
  *(float *)&v45 = v45;
  v48 = (int8x16_t)vcvtq_u64_f64(vcvtq_f64_f32(vrnda_f32(vabs_f32(vdiv_f32(v46, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v45, 0))))));
  *(int8x16_t *)(a1 + 136) = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v47, (uint64x2_t)v48), v48, v47);
  return result;
}

void sub_1B6149C00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x10A0C40CB468F57);
  _Unwind_Resume(a1);
}

uint64_t AU::BSS2::AUXIVALU<float>::Process(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  const DSPSplitComplex *v6;
  float *v7;
  vDSP_Length v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD **v11;
  _QWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  unint64_t v15;
  const DSPSplitComplex *v16;
  uint64_t v17;
  double v18;
  long double v19;
  float v20;
  unint64_t v21;
  unint64_t i;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v27;
  unint64_t v28;
  const DSPSplitComplex *v29;
  float *v30;
  vDSP_Length v31;
  unint64_t v32;
  vDSP_Length v33;
  float *v34;
  const float **v35;
  uint64_t j;
  float __B;
  float v38;

  if (!*(_BYTE *)(a1 + 8))
    return 1;
  ++*(_QWORD *)(a1 + 168);
  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(_QWORD **)(a1 + 264), *(_QWORD *)(*(_QWORD *)(a1 + 264) + 8), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16));
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      v6 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 264) + 8 * v5);
      v7 = **(float ***)(**(_QWORD **)(a1 + 304) + 8 * v5);
      v8 = *(_QWORD *)(a1 + 24);
      __B = 2.2204e-16;
      vDSP_zvmags(v6, 1, v7, 1, v8);
      vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
      ++v5;
    }
    while (*(_QWORD *)(a1 + 16) > v5);
  }
  if (*(_BYTE *)(a1 + 120) && AU::BSS2::AboveMinEnergyThreshold<float>(*(_QWORD **)(a1 + 304), *(float *)(a1 + 128)))
  {
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_QWORD **)(a1 + 264);
    if (v9)
    {
      v11 = (_QWORD **)*v10;
      do
      {
        v12 = *v11++;
        v13 = (_DWORD *)v12[1];
        *(_DWORD *)*v12 = *(_DWORD *)(*v12 + 4);
        *v13 = v13[1];
        --v9;
      }
      while (v9);
    }
    t3l::tDSP_zmzvmult<float>(*(_QWORD **)(a1 + 224), (uint64_t)v10, *(_QWORD **)(a1 + 272));
    if (*(_QWORD *)(a1 + 16))
    {
      v14 = 0;
      v15 = 0;
      do
      {
        v16 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 272) + 8 * v15);
        vDSP_zvmags(v16, 1, v16->realp, 1, *(_QWORD *)(a1 + 24));
        vDSP_sve((const float *)(**(_QWORD **)(**(_QWORD **)(a1 + 272) + 8 * v15) + 4 * *(_QWORD *)(a1 + 136)), 1, (float *)(*(_QWORD *)(a1 + 200) + v14), *(_QWORD *)(a1 + 144) - *(_QWORD *)(a1 + 136));
        v17 = *(_QWORD *)(a1 + 200);
        v18 = (float)(*(float *)(a1 + 48) * 0.5);
        v19 = log2((float)(*(float *)(v17 + 4 * v15) + *(float *)(a1 + 52)));
        v20 = exp2(v19 * v18);
        *(float *)(v17 + 4 * v15) = v20;
        *(float *)(v17 + 4 * v15) = *(float *)(*(_QWORD *)(a1 + 176) + 4 * v15) * v20;
        ++v15;
        v14 += 4;
      }
      while (*(_QWORD *)(a1 + 16) > v15);
    }
    t3l::tDSP_ztvztvhmultupper<float>(*(_QWORD **)(a1 + 264), *(_QWORD **)(a1 + 264), *(_QWORD **)(a1 + 280));
    if (*(float *)(a1 + 56) > 0.0)
      t3l::tDSP_zmsreg<float>(*(_QWORD **)(a1 + 280), (const float *)(a1 + 56));
    v21 = *(_QWORD *)(a1 + 16);
    if (v21)
    {
      for (i = 0; i < v21; ++i)
      {
        AU::BSS2::UpdateVj<float>(*(_QWORD **)(a1 + 280), *(_QWORD **)(*(_QWORD *)(a1 + 240) + 8 * i), *(const float *****)(a1 + 272), 1, *(float *)(*(_QWORD *)(a1 + 200) + 4 * i), *(float *)(a1 + 72), *(float *)(a1 + 60));
        v21 = *(_QWORD *)(a1 + 16);
      }
    }
    v23 = *(_QWORD *)(a1 + 96);
    if (v23)
    {
      v24 = (*(_QWORD *)(a1 + 104) + 1) % (unint64_t)(v23 + 1);
      *(_QWORD *)(a1 + 104) = v24;
      if (*(_QWORD *)(a1 + 168) < *(_QWORD *)(a1 + 80) || v24)
        goto LABEL_29;
    }
    else
    {
      *(_QWORD *)(a1 + 104) = 0;
      if (*(_QWORD *)(a1 + 168) < *(_QWORD *)(a1 + 80))
      {
LABEL_29:
        AU::BSS2::GenerateOutput<float>(*(_QWORD **)(a1 + 224), *(_QWORD **)(a1 + 232), *(_QWORD *)(a1 + 264), *(_QWORD **)(a1 + 272), *(_QWORD *)(a1 + 112));
        if (*(_QWORD *)(a1 + 16))
        {
          v28 = 0;
          do
          {
            v29 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 272) + 8 * v28);
            v30 = **(float ***)(**(_QWORD **)(a1 + 296) + 8 * v28);
            v31 = *(_QWORD *)(a1 + 24);
            v38 = 2.2204e-16;
            vDSP_zvmags(v29, 1, v30, 1, v31);
            vDSP_vsadd(v30, 1, &v38, v30, 1, v31);
            ++v28;
          }
          while (*(_QWORD *)(a1 + 16) > v28);
        }
        if (*(_BYTE *)(a1 + 133))
          AU::BSS2::FixWNG<float>(*(_QWORD **)(a1 + 272), *(_QWORD **)(a1 + 304), *(_QWORD **)(a1 + 296), *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 112), *(float *)(a1 + 124));
        if (*(_BYTE *)(a1 + 132))
          AU::BSS2::MixturePhase<float>(*(_QWORD **)(a1 + 264), *(_QWORD **)(a1 + 304), *(_QWORD **)(a1 + 272), *(_QWORD **)(a1 + 296), **(float *****)(a1 + 280), *(_QWORD *)(*(_QWORD *)(a1 + 280) + 24));
        if (*(_QWORD *)(a1 + 16))
        {
          v32 = 0;
          v33 = *(_QWORD *)(a1 + 24);
          v34 = ****(float *****)(a1 + 280);
          do
          {
            v35 = *(const float ***)(**(_QWORD **)(a1 + 272) + 8 * v32);
            vDSP_vadd(*v35, 1, v35[1], 1, v34, 1, v33);
            if (v33)
            {
              for (j = 0; j != v33; ++j)
                ;
            }
            ++v32;
            v25 = *(_QWORD *)(a1 + 16);
          }
          while (v25 > v32);
        }
        else
        {
          v25 = 0;
        }
        goto LABEL_44;
      }
    }
    if (v21)
    {
      v27 = 0;
      do
      {
        AU::BSS2::UpdateWProject<float>(*(_QWORD **)(a1 + 224), v27, *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8 * v27), *(_QWORD **)(a1 + 296), *(_QWORD **)(a1 + 280), *(uint64_t **)(a1 + 272), *(const DSPSplitComplex ****)(a1 + 288), *(float *)(a1 + 64));
        AU::BSS2::UpdateWScale<float>(*(_QWORD **)(a1 + 224), v27, *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8 * v27), *(_QWORD **)(a1 + 224), *(const DSPSplitComplex ****)(a1 + 272), *(const DSPSplitComplex ****)(a1 + 280));
        ++v27;
      }
      while (*(_QWORD *)(a1 + 16) > v27);
    }
    t3l::tDSP_zminverselu<float>(*(_QWORD **)(a1 + 224), *(_QWORD **)(a1 + 232), *(_QWORD **)(a1 + 296), *(uint64_t **)(a1 + 280), *(uint64_t **)(a1 + 272), *(_QWORD *)(a1 + 288));
    goto LABEL_29;
  }
  AU::BSS2::GenerateOutput<float>(*(_QWORD **)(a1 + 224), *(_QWORD **)(a1 + 232), *(_QWORD *)(a1 + 264), *(_QWORD **)(a1 + 272), *(_QWORD *)(a1 + 112));
  v25 = *(_QWORD *)(a1 + 16);
LABEL_44:
  AU::BSS2::AUXIVALU<float>::Mixing(a1, *(uint64_t **)(a1 + 272), a3, *(_QWORD *)(a1 + 40), v25, *(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160));
  return 0;
}

uint64_t AU::BSS2::AUXIVALU<float>::SideChain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  const DSPSplitComplex *v6;
  float *v7;
  vDSP_Length v8;
  unint64_t v9;
  unint64_t v10;
  const DSPSplitComplex *v11;
  float *v12;
  vDSP_Length v13;
  float __B;
  float v16;

  t3l::tDSP_copy_freq_abl_to_ztensor<float>(a2, **(_QWORD **)(a1 + 264), *(_QWORD *)(*(_QWORD *)(a1 + 264) + 8), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16));
  AU::BSS2::GenerateOutput<float>(*(_QWORD **)(a1 + 224), *(_QWORD **)(a1 + 232), *(_QWORD *)(a1 + 264), *(_QWORD **)(a1 + 272), *(_QWORD *)(a1 + 112));
  if (*(_BYTE *)(a1 + 133) || *(_BYTE *)(a1 + 132))
  {
    if (*(_QWORD *)(a1 + 16))
    {
      v5 = 0;
      do
      {
        v6 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 264) + 8 * v5);
        v7 = **(float ***)(**(_QWORD **)(a1 + 304) + 8 * v5);
        v8 = *(_QWORD *)(a1 + 24);
        __B = 2.2204e-16;
        vDSP_zvmags(v6, 1, v7, 1, v8);
        vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
        ++v5;
        v9 = *(_QWORD *)(a1 + 16);
      }
      while (v9 > v5);
      if (v9)
      {
        v10 = 0;
        do
        {
          v11 = *(const DSPSplitComplex **)(**(_QWORD **)(a1 + 272) + 8 * v10);
          v12 = **(float ***)(**(_QWORD **)(a1 + 296) + 8 * v10);
          v13 = *(_QWORD *)(a1 + 24);
          v16 = 2.2204e-16;
          vDSP_zvmags(v11, 1, v12, 1, v13);
          vDSP_vsadd(v12, 1, &v16, v12, 1, v13);
          ++v10;
        }
        while (*(_QWORD *)(a1 + 16) > v10);
      }
    }
  }
  if (*(_BYTE *)(a1 + 133))
    AU::BSS2::FixWNG<float>(*(_QWORD **)(a1 + 272), *(_QWORD **)(a1 + 304), *(_QWORD **)(a1 + 296), *(_QWORD *)(a1 + 288), *(_QWORD *)(a1 + 112), *(float *)(a1 + 124));
  if (*(_BYTE *)(a1 + 132))
    AU::BSS2::MixturePhase<float>(*(_QWORD **)(a1 + 264), *(_QWORD **)(a1 + 304), *(_QWORD **)(a1 + 272), *(_QWORD **)(a1 + 296), **(float *****)(a1 + 288), *(_QWORD *)(*(_QWORD *)(a1 + 288) + 24));
  AU::BSS2::AUXIVALU<float>::Mixing(a1, *(uint64_t **)(a1 + 272), a3, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160));
  return 0;
}

uint64_t AU::BSS2::AUXIVALU<float>::UpdateParam(uint64_t a1, int a2, float a3)
{
  uint64_t result;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  unint64_t v14;
  float v15;
  unint64_t v16;
  unint64_t v17;
  float v18;
  unint64_t v19;

  if (!*(_BYTE *)(a1 + 8))
    return 1;
  switch(a2)
  {
    case 0:
      result = 0;
      *(_BYTE *)(a1 + 120) = a3 != 0.0;
      break;
    case 1:
      *(float *)(a1 + 68) = a3;
      v5 = 0.0;
      if (a3 > 0.0)
      {
        v6 = *(float *)(a1 + 36);
        if (v6 <= 0.0)
          __assert_rtn("ComputeCoefFromTC", "Tensor3Lib.h", 30, "blockFs > 0");
        v5 = expf(-1.0 / (float)(v6 * a3));
      }
      result = 0;
      *(float *)(a1 + 72) = v5;
      break;
    case 2:
      result = 0;
      *(_BYTE *)(a1 + 132) = a3 != 0.0;
      break;
    case 3:
      v7 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 52) = v7;
      break;
    case 4:
      v8 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 56) = v8;
      break;
    case 5:
      v9 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 60) = v9;
      break;
    case 6:
      v10 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 64) = v10;
      break;
    case 7:
      result = 0;
      *(_QWORD *)(a1 + 112) = (unint64_t)a3;
      break;
    case 8:
      result = 0;
      *(float *)(a1 + 48) = a3;
      break;
    case 9:
      v11 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 124) = v11;
      break;
    case 10:
      result = 0;
      *(_QWORD *)(a1 + 96) = (unint64_t)a3;
      break;
    case 11:
      v12 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 128) = v12;
      break;
    case 12:
      result = 0;
      *(_QWORD *)(a1 + 80) = vcvtas_u32_f32((float)(*(float *)(a1 + 32) * a3) / (float)*(unint64_t *)(a1 + 40));
      break;
    case 13:
      v13 = __exp10f(a3 / 20.0);
      result = 0;
      *(float *)(a1 + 88) = v13;
      break;
    case 14:
      result = 0;
      v14 = *(_QWORD *)(a1 + 24) - 1;
      v15 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      v16 = vcvtas_u32_f32(fabsf(a3 / v15));
      if (v16 < v14)
        v14 = v16;
      *(_QWORD *)(a1 + 136) = v14;
      break;
    case 15:
      result = 0;
      v17 = *(_QWORD *)(a1 + 24) - 1;
      v18 = *(float *)(a1 + 32) / ((double)*(unint64_t *)(a1 + 40) + (double)*(unint64_t *)(a1 + 40));
      v19 = vcvtas_u32_f32(fabsf(a3 / v18));
      if (v19 < v17)
        v17 = v19;
      *(_QWORD *)(a1 + 144) = v17;
      break;
    case 16:
      result = 0;
      *(_QWORD *)(a1 + 152) = (unint64_t)a3;
      break;
    case 17:
      if (*(_QWORD *)(a1 + 160) <= *(_QWORD *)(a1 + 16))
      {
        result = 0;
        *(_QWORD *)(a1 + 160) = (unint64_t)a3;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      return 1;
  }
  return result;
}

uint64_t AU::BSS2::AUXIVALU<float>::UpdatePrior(uint64_t a1, unint64_t a2, float a3, float a4)
{
  uint64_t v4;
  float v5;
  BOOL v6;
  float v7;

  v4 = *(_QWORD *)(a1 + 176);
  if (a2 > (*(_QWORD *)(a1 + 184) - v4) >> 2)
    __assert_rtn("UpdatePrior", "AUBSS2Algorithm+XIVALU.h", 358, "index <= priors.size()");
  if (a3 < 0.0)
    a3 = 0.0;
  v5 = a3 + -0.5;
  v6 = a3 <= 1.0;
  v7 = 0.5;
  if (v6)
    v7 = v5;
  *(float *)(v4 + 4 * a2) = expf(v7 * a4);
  return 0;
}

uint64_t AU::BSS2::AUXIVALU<float>::Reset(uint64_t a1)
{
  unint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  vDSP_Length v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t i;
  float **v11;
  uint64_t v12;
  uint64_t j;
  float __A;

  if (*(_QWORD *)(a1 + 16))
  {
    v2 = 0;
    do
    {
      t3l::tDSP_ztfilldiag<float>(*(_QWORD **)(*(_QWORD *)(a1 + 240) + 8 * v2), *(float *)(a1 + 88));
      *(_DWORD *)(*(_QWORD *)(a1 + 176) + 4 * v2++) = 1065353216;
    }
    while (*(_QWORD *)(a1 + 16) > v2);
  }
  v3 = *(_QWORD **)(a1 + 224);
  v4 = v3[1];
  if (v4 != v3[2])
    __assert_rtn("tDSP_zmeye", "Tensor3Lib.h", 513, "N == X.cols");
  v5 = v3[3];
  __A = 1.0;
  if (v4)
  {
    v6 = 0;
    v7 = 1;
    v8 = v4;
    do
    {
      if (v7)
      {
        v9 = 0;
        for (i = 0; i < v7; ++i)
        {
          v11 = (float **)(*(_QWORD *)(*v3 + 8 * v6) + v9);
          vDSP_vclr(*v11, 1, v5);
          vDSP_vclr(v11[1], 1, v5);
          v7 = v3[2];
          v9 += 16;
        }
        v8 = v3[1];
      }
      ++v6;
    }
    while (v8 > v6);
    v12 = 0;
    for (j = 0; j != v4; ++j)
    {
      vDSP_vfill(&__A, *(float **)(*(_QWORD *)(*v3 + 8 * j) + v12), 1, v5);
      v12 += 16;
    }
  }
  *(_QWORD *)(a1 + 168) = 1;
  *(_QWORD *)(a1 + 104) = 0;
  return 0;
}

void AU::BSS2::AUXIVALU<float>::~AUXIVALU(uint64_t a1)
{
  AU::BSS2::AUXIVALU<float>::~AUXIVALU(a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AU::BSS2::AUXIVALU<float>::~AUXIVALU(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v5;

  *(_QWORD *)a1 = off_1E69C8950;
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 304), 0);
  std::unique_ptr<t3l::RTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 296), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 288), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 280), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 272), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 264), 0);
  v5 = (void **)(a1 + 240);
  std::vector<std::unique_ptr<t3l::ZTensor3<float>>>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 232), 0);
  std::unique_ptr<t3l::ZTensor3<float>>::reset[abi:ne180100]((uint64_t *)(a1 + 224), 0);
  v2 = *(void **)(a1 + 200);
  if (v2)
  {
    *(_QWORD *)(a1 + 208) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 176);
  if (v3)
  {
    *(_QWORD *)(a1 + 184) = v3;
    operator delete(v3);
  }
  return a1;
}

float AU::BSS2::AUXIVALU<float>::Mixing(uint64_t a1, uint64_t *a2, uint64_t a3, vDSP_Length __N, unint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v13;
  float **v14;
  float *v15;
  float result;
  float *v17;
  uint64_t v18;
  unsigned int v19;
  float *v21;
  unint64_t v22;
  unsigned int v23;
  DSPSplitComplex v24;

  if (a6 != 1)
    return t3l::tDSP_copy_ztensor_to_freq_abl<float>(*a2, a3, __N, a5);
  if (*(_QWORD *)(a1 + 16))
  {
    v13 = 0;
    v14 = (float **)(a3 + 16);
    do
    {
      v15 = *v14;
      v14 += 2;
      vDSP_vclr(v15, 1, 2 * __N);
      ++v13;
    }
    while (*(_QWORD *)(a1 + 16) > v13);
  }
  v17 = (float *)(*(_QWORD *)(a3 + 16) + 4 * __N);
  v24.realp = *(float **)(a3 + 16);
  v24.imagp = v17;
  if (a5 != a7)
  {
    v18 = 0;
    v19 = 1;
    do
    {
      vDSP_zvadd(*(const DSPSplitComplex **)(*a2 + 8 * v18), 1, &v24, 1, &v24, 1, __N);
      v18 = v19;
    }
    while (a5 - a7 > v19++);
  }
  v21 = (float *)(*(_QWORD *)(a3 + 32) + 4 * __N);
  v24.realp = *(float **)(a3 + 32);
  v24.imagp = v21;
  v22 = (a5 - a7);
  if (v22 < a5)
  {
    v23 = a5 - a7 + 1;
    do
    {
      vDSP_zvadd(*(const DSPSplitComplex **)(*a2 + 8 * v22), 1, &v24, 1, &v24, 1, __N);
      v22 = v23++;
    }
    while (v22 < a5);
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__assign_unique<std::pair<unsigned int const,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>> const*>(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  unint64_t v3;
  unsigned int *v5;
  uint64_t v7;
  uint64_t i;
  _QWORD *v9;
  BOOL v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  uint8x8_t v14;
  unint64_t v15;
  uint64_t **v16;
  uint64_t *j;
  unint64_t v18;
  float v19;
  float v20;
  uint64_t v21;
  _BOOL8 v22;
  size_t v23;
  unint64_t v24;
  size_t v25;
  uint8x8_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  unint64_t v32;
  uint8x8_t v33;
  uint64_t **v34;
  uint64_t *k;
  unint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  __int128 v39;
  float v40;
  float v41;
  _BOOL8 v42;
  unint64_t v43;
  unint64_t v44;
  size_t v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t v48;

  v5 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    for (i = 0; i != v7; ++i)
      *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    v9 = *(_QWORD **)(a1 + 16);
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    if (v9)
      v10 = a2 == a3;
    else
      v10 = 1;
    if (!v10)
    {
      while (1)
      {
        v12 = *v5;
        *((_DWORD *)v9 + 4) = v12;
        v9[3] = *((_QWORD *)v5 + 1);
        *((_DWORD *)v9 + 8) = v5[4];
        *((_DWORD *)v9 + 9) = v5[5];
        *((_DWORD *)v9 + 10) = v5[6];
        *(_QWORD *)((char *)v9 + 44) = *(_QWORD *)(v5 + 7);
        v11 = (_QWORD *)*v9;
        v9[1] = v12;
        v13 = *(_QWORD *)(a1 + 8);
        if (v13)
        {
          v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
          v14.i16[0] = vaddlv_u8(v14);
          if (v14.u32[0] > 1uLL)
          {
            v15 = v12;
            if (v13 <= v12)
              v15 = v12 % v13;
          }
          else
          {
            v15 = ((_DWORD)v13 - 1) & v12;
          }
          v16 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v15);
          if (v16)
          {
            for (j = *v16; j; j = (uint64_t *)*j)
            {
              v18 = j[1];
              if (v18 == v12)
              {
                if (*((_DWORD *)j + 4) == (_DWORD)v12)
                  goto LABEL_49;
              }
              else
              {
                if (v14.u32[0] > 1uLL)
                {
                  if (v18 >= v13)
                    v18 %= v13;
                }
                else
                {
                  v18 &= v13 - 1;
                }
                if (v18 != v15)
                  break;
              }
            }
          }
        }
        v19 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
        v20 = *(float *)(a1 + 32);
        if (!v13 || (float)(v20 * (float)v13) < v19)
        {
          v21 = 2 * v13;
          v22 = v13 < 3 || (v13 & (v13 - 1)) != 0;
          v23 = v22 | v21;
          v24 = vcvtps_u32_f32(v19 / v20);
          if (v23 <= v24)
            v25 = v24;
          else
            v25 = v23;
          std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__rehash<true>(a1, v25);
          v13 = *(_QWORD *)(a1 + 8);
          v12 = v9[1];
        }
        v26 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
        v26.i16[0] = vaddlv_u8(v26);
        if (v26.u32[0] > 1uLL)
        {
          if (v12 >= v13)
            v12 %= v13;
        }
        else
        {
          v12 &= v13 - 1;
        }
        v27 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
        if (v27)
        {
          *v9 = *v27;
        }
        else
        {
          *v9 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)(a1 + 16) = v9;
          *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = a1 + 16;
          if (!*v9)
            goto LABEL_48;
          v28 = *(_QWORD *)(*v9 + 8);
          if (v26.u32[0] > 1uLL)
          {
            if (v28 >= v13)
              v28 %= v13;
          }
          else
          {
            v28 &= v13 - 1;
          }
          v27 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
        }
        *v27 = v9;
LABEL_48:
        ++*(_QWORD *)(a1 + 24);
LABEL_49:
        v5 += 10;
        if (v11)
        {
          v9 = v11;
          if (v5 != a3)
            continue;
        }
        goto LABEL_51;
      }
    }
    v11 = v9;
LABEL_51:
    if (v11)
    {
      do
      {
        v29 = (_QWORD *)*v11;
        operator delete(v11);
        v11 = v29;
      }
      while (v29);
    }
  }
  if (v5 != a3)
  {
    v30 = (_QWORD *)(a1 + 16);
    v31 = *(_QWORD *)(a1 + 8);
    do
    {
      v32 = *v5;
      if (v31)
      {
        v33 = (uint8x8_t)vcnt_s8((int8x8_t)v31);
        v33.i16[0] = vaddlv_u8(v33);
        if (v33.u32[0] > 1uLL)
        {
          v3 = *v5;
          if (v31 <= v32)
            v3 = v32 % v31;
        }
        else
        {
          v3 = ((_DWORD)v31 - 1) & v32;
        }
        v34 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v3);
        if (v34)
        {
          for (k = *v34; k; k = (uint64_t *)*k)
          {
            v36 = k[1];
            if (v36 == v32)
            {
              if (*((_DWORD *)k + 4) == (_DWORD)v32)
                goto LABEL_93;
            }
            else
            {
              if (v33.u32[0] > 1uLL)
              {
                if (v36 >= v31)
                  v36 %= v31;
              }
              else
              {
                v36 &= v31 - 1;
              }
              if (v36 != v3)
                break;
            }
          }
        }
      }
      v37 = operator new(0x38uLL);
      *v37 = 0;
      v37[1] = v32;
      v38 = *((_QWORD *)v5 + 4);
      v39 = *((_OWORD *)v5 + 1);
      *((_OWORD *)v37 + 1) = *(_OWORD *)v5;
      *((_OWORD *)v37 + 2) = v39;
      v37[6] = v38;
      v40 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
      v41 = *(float *)(a1 + 32);
      if (!v31 || (float)(v41 * (float)v31) < v40)
      {
        v42 = (v31 & (v31 - 1)) != 0;
        if (v31 < 3)
          v42 = 1;
        v43 = v42 | (2 * v31);
        v44 = vcvtps_u32_f32(v40 / v41);
        if (v43 <= v44)
          v45 = v44;
        else
          v45 = v43;
        std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__rehash<true>(a1, v45);
        v31 = *(_QWORD *)(a1 + 8);
        if ((v31 & (v31 - 1)) != 0)
        {
          if (v31 <= v32)
            v3 = v32 % v31;
          else
            v3 = v32;
        }
        else
        {
          v3 = ((_DWORD)v31 - 1) & v32;
        }
      }
      v46 = *(_QWORD *)a1;
      v47 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
      if (v47)
      {
        *v37 = *v47;
      }
      else
      {
        *v37 = *v30;
        *v30 = v37;
        *(_QWORD *)(v46 + 8 * v3) = v30;
        if (!*v37)
          goto LABEL_92;
        v48 = *(_QWORD *)(*v37 + 8);
        if ((v31 & (v31 - 1)) != 0)
        {
          if (v48 >= v31)
            v48 %= v31;
        }
        else
        {
          v48 &= v31 - 1;
        }
        v47 = (_QWORD *)(*(_QWORD *)a1 + 8 * v48);
      }
      *v47 = v37;
LABEL_92:
      ++*(_QWORD *)(a1 + 24);
LABEL_93:
      v5 += 10;
    }
    while (v5 != a3);
  }
}

void sub_1B614AEA4(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  __cxa_begin_catch(a1);
  do
  {
    v2 = (_QWORD *)*v1;
    operator delete(v1);
    v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1B614AEC4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void AUReferenceSignalMixer::~AUReferenceSignalMixer(AUReferenceSignalMixer *this)
{
  AUReferenceSignalMixer::~AUReferenceSignalMixer(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  unsigned __int8 v2;
  NSObject *v3;
  const void *v4;
  void *v5;
  void *v6;
  int v7;
  AUReferenceSignalMixer *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E69C8A40;
  {
    AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
  }
  v3 = AU::ReferenceSignalMixer::getLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    v7 = 134217984;
    v8 = this;
    _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_INFO, "[%p] destroyed", (uint8_t *)&v7, 0xCu);
  }
  v4 = (const void *)*((_QWORD *)this + 84);
  if (v4)
    CFRelease(v4);
  std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table((uint64_t)this + 624);
  if (*((_BYTE *)this + 600))
  {
    v5 = (void *)*((_QWORD *)this + 72);
    if (v5)
    {
      *((_QWORD *)this + 73) = v5;
      operator delete(v5);
    }
  }
  if (*((_BYTE *)this + 560))
  {
    v6 = (void *)*((_QWORD *)this + 67);
    if (v6)
    {
      *((_QWORD *)this + 68) = v6;
      operator delete(v6);
    }
  }
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUReferenceSignalMixer::Initialize(AUReferenceSignalMixer *this)
{
  unsigned __int8 v1;
  NSObject *v2;
  ausdk::AUScope *v3;
  ausdk::AUScope *v4;
  const __CFDictionary *v5;
  int v6;
  AU::ReferenceSignalMixer *v7;
  const __CFDictionary *v8;
  const void *v9;
  CFTypeRef v10;
  CFTypeID v11;
  unint64_t v12;
  AU::ReferenceSignalMixer *v13;
  const __CFDictionary *v14;
  _BOOL8 v15;
  const void *v16;
  AU::ReferenceSignalMixer *v17;
  CFTypeID v18;
  _BOOL4 v19;
  CFTypeID v20;
  AU::ReferenceSignalMixer *v21;
  const __CFArray *begin;
  unint64_t v23;
  int v24;
  BOOL v25;
  BOOL v26;
  unint64_t v27;
  int v28;
  int v29;
  CFTypeID v30;
  _BOOL4 v31;
  uint64_t Element;
  CFTypeID v33;
  AU::ReferenceSignalMixer *v34;
  const __CFArray *v35;
  unint64_t v36;
  int v37;
  _BOOL4 v38;
  BOOL v39;
  const __CFData *v40;
  const UInt8 *BytePtr;
  unint64_t Length;
  unsigned int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  std::vector<char>::pointer v47;
  uint64_t v48;
  BOOL v49;
  int v51;
  unsigned __int8 v52;
  uint64_t v53;
  NSObject *v54;
  const char *v55;
  unsigned __int8 v56;
  uint64_t v57;
  unsigned __int8 v58;
  uint64_t v59;
  int v60;
  CFTypeID v61;
  _BOOL4 v62;
  const __CFDictionary *v63;
  CFTypeID v64;
  const __CFDictionary *v65;
  AU::ReferenceSignalMixer *v66;
  const __CFDictionary *v67;
  CFTypeID v68;
  _BOOL4 v69;
  CFTypeID v70;
  const __CFDictionary *v71;
  AU::ReferenceSignalMixer *v72;
  CFTypeID v73;
  _BOOL4 v74;
  CFTypeID v75;
  AU::ReferenceSignalMixer *v76;
  const __CFArray *v77;
  unint64_t v78;
  int v79;
  BOOL v80;
  BOOL v81;
  unint64_t v82;
  int v83;
  CFTypeID v84;
  _BOOL4 v85;
  uint64_t v86;
  CFTypeID v87;
  AU::ReferenceSignalMixer *v88;
  const __CFArray *v89;
  unint64_t v90;
  int v91;
  BOOL v92;
  BOOL v93;
  AU::ReferenceSignalMixer *v94;
  const __CFData *v95;
  const UInt8 *v96;
  AU::ReferenceSignalMixer *v97;
  unsigned int v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  std::vector<char>::pointer v104;
  uint64_t v105;
  uint64_t *v106;
  char *v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  BOOL v115;
  int v117;
  NSObject *v118;
  NSObject *v119;
  const char *v120;
  NSObject *v121;
  int v122;
  int v123;
  CFTypeID v124;
  _BOOL4 v125;
  CFTypeID v126;
  const __CFDictionary *v127;
  AU::ReferenceSignalMixer *v128;
  CFTypeID v129;
  _BOOL4 v130;
  CFTypeID v131;
  const __CFDictionary *v132;
  AU::ReferenceSignalMixer *v133;
  _BOOL8 v134;
  const void *v135;
  CFTypeRef v136;
  CFTypeID v137;
  char *v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  unint64_t v142;
  _BOOL8 v143;
  uint64_t v144;
  const __CFDictionary *v145;
  unsigned int v146;
  int v147;
  AU::ReferenceSignalMixer *v148;
  AU::ReferenceSignalMixer *v149;
  unsigned int v150;
  _BOOL8 v151;
  AU::ReferenceSignalMixer *v152;
  uint64_t v153;
  _QWORD *v154;
  char v155;
  NSObject *v156;
  NSObject *v157;
  const char *v158;
  NSObject *v159;
  NSObject *v160;
  NSObject *v161;
  NSObject *v162;
  NSObject *v163;
  NSObject *v164;
  AU::ReferenceSignalMixer *v165;
  NSObject *v166;
  CFHashCode v167;
  unsigned __int8 v168;
  NSObject *v169;
  unint64_t v170;
  uint8x8_t v171;
  unint64_t v172;
  uint64_t **v173;
  uint64_t *i;
  unint64_t v175;
  _QWORD *v176;
  CFTypeRef v177;
  float v178;
  _BOOL8 v179;
  unint64_t v180;
  unint64_t v181;
  int8x8_t prime;
  void *v183;
  void *v184;
  uint64_t v185;
  _QWORD **v186;
  unint64_t v187;
  uint8x8_t v188;
  unint64_t v189;
  uint8x8_t v190;
  uint64_t v191;
  unsigned __int8 v192;
  uint64_t v193;
  _QWORD *j;
  unint64_t v195;
  _QWORD *v196;
  unint64_t v197;
  __int128 v198;
  std::__shared_weak_count *v199;
  unint64_t *p_shared_owners;
  unint64_t v201;
  const __CFDictionary *v202;
  _BOOL8 v203;
  const __CFArray *v204;
  CFArrayRef v205;
  CFTypeID v206;
  unint64_t v207;
  const __CFArray *v208;
  CFTypeID Count;
  int v210;
  uint64_t v211;
  std::vector<char>::pointer value_high;
  unint64_t v213;
  const void **v214;
  NSObject *v215;
  int v216;
  unint64_t v217;
  unint64_t v218;
  uint8x8_t v219;
  void **v220;
  char *v221;
  unint64_t v222;
  float v223;
  _BOOL8 v224;
  unint64_t v225;
  unint64_t v226;
  int8x8_t v227;
  void *v228;
  void *v229;
  uint64_t v230;
  _QWORD **v231;
  unint64_t v232;
  uint8x8_t v233;
  unint64_t v234;
  uint8x8_t v235;
  uint64_t v236;
  _QWORD *k;
  unint64_t v238;
  uint64_t v239;
  _QWORD *v240;
  unint64_t v241;
  unint64_t v242;
  unint64_t v243;
  _QWORD *v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  unint64_t v249;
  uint64_t v250;
  _QWORD *v251;
  unint64_t v252;
  _QWORD *v253;
  _QWORD *v254;
  uint64_t v255;
  int64x2_t v256;
  unint64_t v257;
  void *v258;
  AU::ReferenceSignalMixer *v259;
  NSObject *v260;
  NSObject *v261;
  uint64_t v262;
  AU::ReferenceSignalMixer *v263;
  unint64_t v264;
  CFHashCode v265;
  unint64_t v266;
  CFHashCode v267;
  uint8x8_t v268;
  unint64_t v269;
  CFHashCode v270;
  CFTypeRef **v271;
  CFTypeRef *v272;
  unint64_t v273;
  unint64_t v274;
  unint64_t v275;
  uint8x8_t v276;
  uint64_t **v277;
  uint64_t *m;
  unint64_t v279;
  char *v280;
  char *v281;
  unint64_t *v282;
  unint64_t v283;
  float v284;
  float v285;
  _BOOL8 v286;
  unint64_t v287;
  unint64_t v288;
  int8x8_t v289;
  void *v290;
  void *v291;
  uint64_t v292;
  _QWORD *v293;
  unint64_t v294;
  uint8x8_t v295;
  unint64_t v296;
  uint8x8_t v297;
  uint64_t v298;
  _QWORD *v299;
  unint64_t v300;
  uint64_t v301;
  std::vector<char>::pointer *v302;
  std::vector<char>::pointer v303;
  unint64_t v304;
  void *v305;
  NSObject *v306;
  void *v307;
  NSObject *v308;
  NSObject *v309;
  NSObject *v310;
  NSObject *v311;
  NSObject *v312;
  const char *v313;
  uint32_t v314;
  NSObject *v315;
  NSObject *v316;
  const char *v317;
  NSObject *v318;
  NSObject *v319;
  NSObject *v320;
  NSObject *v321;
  NSObject *v322;
  NSObject *v323;
  NSObject *v324;
  NSObject *v325;
  std::__shared_weak_count *v326;
  unint64_t *v327;
  unint64_t v328;
  int v329;
  int v330;
  char *v331;
  char *v332;
  void **v333;
  AU::ReferenceSignalMixer *v334;
  NSObject *v335;
  uint64_t v336;
  const char *v338;
  NSObject *v339;
  uint32_t v340;
  NSObject *Log;
  NSObject *v342;
  std::runtime_error *v343;
  std::runtime_error *v344;
  std::runtime_error *v345;
  std::runtime_error *v346;
  std::runtime_error *v347;
  std::runtime_error *v348;
  std::runtime_error *v349;
  std::runtime_error *v350;
  std::runtime_error *v351;
  std::runtime_error *v352;
  std::runtime_error *v353;
  std::runtime_error *exception;
  std::runtime_error *v355;
  std::runtime_error *v356;
  std::runtime_error *v357;
  std::runtime_error *v358;
  std::runtime_error *v359;
  std::runtime_error *v360;
  int v361;
  uint64_t *v362;
  _QWORD *v363;
  unsigned int v364;
  int v366;
  void *v367[2];
  char v368;
  CFTypeRef cf[2];
  uint64_t v370;
  unsigned __int8 v371;
  CFTypeRef v372[2];
  uint64_t v373;
  CFArrayRef theArray;
  __int128 v375;
  CFTypeRef v376;
  CFTypeRef v377;
  CFTypeRef v378;
  CFTypeRef v379;
  __int128 __p;
  __int128 v381;
  float v382;
  __int128 v383;
  __int128 v384;
  float v385;
  std::vector<char> v386;
  void **v387;
  _BYTE buf[24];
  unint64_t v389;
  char *v390;
  uint64_t v391;

  v391 = *MEMORY[0x1E0C80C00];
  {
    AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
  }
  v2 = AU::ReferenceSignalMixer::getLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_INFO, "[%p] initialize", buf, 0xCu);
  }
  v3 = (AUReferenceSignalMixer *)((char *)this + 80);
  *((_DWORD *)this + 133) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUReferenceSignalMixer *)((char *)this + 80), 0)
                                      + 108);
  v4 = (AUReferenceSignalMixer *)((char *)this + 128);
  *((_DWORD *)this + 142) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUReferenceSignalMixer *)((char *)this + 128), 0)+ 108);
  v5 = (const __CFDictionary *)*((_QWORD *)this + 84);
  if (!v5)
    goto LABEL_755;
  v383 = 0u;
  v384 = 0u;
  v385 = 1.0;
  __p = 0u;
  v381 = 0u;
  v382 = 1.0;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)buf, "Configuration");
  v6 = CFDictionaryContainsKey(v5, *(const void **)buf);
  v7 = *(AU::ReferenceSignalMixer **)buf;
  if (*(_QWORD *)buf)
    CFRelease(*(CFTypeRef *)buf);
  if (v6)
  {
    v8 = (const __CFDictionary *)*((_QWORD *)this + 84);
    if (!v8)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    v9 = applesauce::CF::details::at_key<char const(&)[14]>(v8, "Configuration");
    if (v9)
    {
      v10 = v9;
      CFRetain(v9);
      v11 = CFGetTypeID(v10);
      if (v11 == CFArrayGetTypeID())
      {
        *(_QWORD *)buf = v10;
        buf[8] = 1;
        CFRetain(v10);
        v379 = v10;
        std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
        v12 = 0;
        v364 = 0;
        v366 = 0;
        v363 = (_QWORD *)((char *)this + 640);
        while (1)
        {
          if (CFArrayGetCount((CFArrayRef)v10) <= v12)
          {
            v29 = 0;
LABEL_751:
            v336 = v364;
            goto LABEL_752;
          }
          if (!v379)
          {
            v344 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v344, "Could not construct");
          }
          *(_QWORD *)buf = 0;
          applesauce::CF::at_or<applesauce::CF::DictionaryRef>(&v378, (CFArrayRef)v379, v12, buf);
          v13 = *(AU::ReferenceSignalMixer **)buf;
          if (*(_QWORD *)buf)
            CFRelease(*(CFTypeRef *)buf);
          v14 = (const __CFDictionary *)v378;
          if (!v378)
          {
            Log = AU::ReferenceSignalMixer::getLog(v13);
            if (!os_log_type_enabled(Log, OS_LOG_TYPE_ERROR))
              goto LABEL_748;
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = this;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v366;
            v338 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has invalid value";
            v339 = Log;
            v340 = 18;
LABEL_758:
            _os_log_error_impl(&dword_1B5ED0000, v339, OS_LOG_TYPE_ERROR, v338, buf, v340);
            goto LABEL_748;
          }
          v15 = applesauce::CF::details::has_key<char const(&)[5]>((const __CFDictionary *)v378, "Name");
          if (!v15)
          {
            v308 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v15);
            if (os_log_type_enabled(v308, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              _os_log_error_impl(&dword_1B5ED0000, v308, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has no \"Name\" key", buf, 0x12u);
            }
            v29 = 1;
            v364 = -10875;
            goto LABEL_284;
          }
          applesauce::CF::details::find_at_key_or_optional<applesauce::CF::StringRef,char const(&)[5]>(v14, "Name", buf);
          if (buf[8])
          {
            v16 = *(const void **)buf;
            if (*(_QWORD *)buf)
              CFRetain(*(CFTypeRef *)buf);
            v377 = v16;
          }
          else
          {
            v377 = 0;
          }
          v17 = (AU::ReferenceSignalMixer *)std::__optional_destruct_base<applesauce::CF::StringRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
          if (!v377)
          {
            v309 = AU::ReferenceSignalMixer::getLog(v17);
            if (!os_log_type_enabled(v309, OS_LOG_TYPE_ERROR))
              goto LABEL_689;
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = this;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v366;
            v316 = v309;
            v317 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has invalid \"Name\" value";
            goto LABEL_712;
          }
          CFRetain(CFSTR("InputChannelCounts"));
          v18 = CFGetTypeID(CFSTR("InputChannelCounts"));
          if (v18 == CFStringGetTypeID())
          {
            v19 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, CFSTR("InputChannelCounts"));
            CFRelease(CFSTR("InputChannelCounts"));
            if (v19)
              goto LABEL_28;
          }
          else
          {
            CFRelease(CFSTR("InputChannelCounts"));
            if (applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, 0))
            {
LABEL_28:
              CFRetain(CFSTR("InputChannelCounts"));
              v20 = CFGetTypeID(CFSTR("InputChannelCounts"));
              if (v20 == CFStringGetTypeID())
              {
                *(_QWORD *)buf = CFSTR("InputChannelCounts");
              }
              else
              {
                *(_QWORD *)buf = 0;
                CFRelease(CFSTR("InputChannelCounts"));
              }
              cf[0] = 0;
              applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>((const __CFDictionary **)&v386, v14, (const void **)buf, (const __CFDictionary **)cf);
              if (cf[0])
                CFRelease(cf[0]);
              v21 = *(AU::ReferenceSignalMixer **)buf;
              if (*(_QWORD *)buf)
                CFRelease(*(CFTypeRef *)buf);
              begin = (const __CFArray *)v386.__begin_;
              if (v386.__begin_)
              {
                v23 = 0;
                v24 = 0;
                v25 = 0;
                while (1)
                {
                  v26 = CFArrayGetCount(begin) <= v23;
                  if (v26 || v25)
                  {
                    if (v26)
                      v28 = 6;
                    else
                      v28 = 7;
                    if (v25)
                      v29 = 0;
                    else
                      v29 = v28;
                    goto LABEL_47;
                  }
                  v27 = applesauce::CF::details::at_as<unsigned int>(begin, v23);
                  if ((v27 & 0xFF00000000) == 0)
                    break;
                  v25 = *(_DWORD *)(ausdk::AUScope::SafeGetElement(v3, 0) + 108) == (_DWORD)v27;
                  v23 = ++v24;
                }
                if ((v168 & 1) == 0
                {
                  AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
                }
                v169 = AU::ReferenceSignalMixer::getLog(void)::gLog;
                if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 134218496;
                  *(_QWORD *)&buf[4] = this;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v366;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v24;
                  _os_log_error_impl(&dword_1B5ED0000, v169, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelCounts\"][%u] has invalid value", buf, 0x18u);
                }
                v364 = -10875;
                v29 = 1;
              }
              else
              {
                v310 = AU::ReferenceSignalMixer::getLog(v21);
                if (os_log_type_enabled(v310, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 134218240;
                  *(_QWORD *)&buf[4] = this;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v366;
                  _os_log_error_impl(&dword_1B5ED0000, v310, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelCounts\"] has invalid value", buf, 0x12u);
                }
                v364 = -10875;
                v29 = 1;
              }
LABEL_47:
              if (v386.__begin_)
                CFRelease(v386.__begin_);
              if (v29)
                goto LABEL_281;
              v14 = (const __CFDictionary *)v378;
              if (!v378)
              {
                v355 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v355, "Could not construct");
              }
            }
          }
          CFRetain(CFSTR("InputChannelLayouts"));
          v30 = CFGetTypeID(CFSTR("InputChannelLayouts"));
          if (v30 == CFStringGetTypeID())
          {
            v31 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, CFSTR("InputChannelLayouts"));
            CFRelease(CFSTR("InputChannelLayouts"));
            if (!v31)
              goto LABEL_135;
          }
          else
          {
            CFRelease(CFSTR("InputChannelLayouts"));
            if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, 0))
              goto LABEL_135;
          }
          Element = ausdk::AUScope::SafeGetElement(v3, 0);
          AU::ReferenceSignalMixer::MakeDefaultChannelLayout(&v386, *(_DWORD *)(Element + 108));
          std::optional<CA::ChannelLayout>::value_or[abi:ne180100]<CA::ChannelLayout>((__n128 *)buf, (uint64_t)this + 536, (__n128 *)&v386);
          if (v386.__begin_)
          {
            v386.__end_ = v386.__begin_;
            operator delete(v386.__begin_);
          }
          CFRetain(CFSTR("InputChannelLayouts"));
          v33 = CFGetTypeID(CFSTR("InputChannelLayouts"));
          if (v33 == CFStringGetTypeID())
          {
            v386.__begin_ = (std::vector<char>::pointer)CFSTR("InputChannelLayouts");
          }
          else
          {
            v386.__begin_ = 0;
            CFRelease(CFSTR("InputChannelLayouts"));
          }
          v372[0] = 0;
          applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>((const __CFDictionary **)cf, v14, (const void **)&v386.__begin_, (const __CFDictionary **)v372);
          if (v372[0])
            CFRelease(v372[0]);
          v34 = (AU::ReferenceSignalMixer *)v386.__begin_;
          if (v386.__begin_)
            CFRelease(v386.__begin_);
          v35 = (const __CFArray *)cf[0];
          if (!cf[0])
          {
            v311 = AU::ReferenceSignalMixer::getLog(v34);
            if (os_log_type_enabled(v311, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v386.__begin_) = 134218240;
              *(std::vector<char>::pointer *)((char *)&v386.__begin_ + 4) = (std::vector<char>::pointer)this;
              WORD2(v386.__end_) = 1024;
              *(_DWORD *)((char *)&v386.__end_ + 6) = v366;
              _os_log_error_impl(&dword_1B5ED0000, v311, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelLayouts\"] has invalid value", (uint8_t *)&v386, 0x12u);
            }
            v29 = 1;
            v364 = -10875;
            goto LABEL_131;
          }
          v36 = 0;
          v37 = 0;
          LOBYTE(v38) = 0;
          while (1)
          {
            v39 = CFArrayGetCount(v35) <= v36 || v38;
            if (v39)
            {
              if (v38)
                v29 = 0;
              else
                v29 = 6;
LABEL_130:
              CFRelease(v35);
              goto LABEL_131;
            }
            v386.__begin_ = 0;
            applesauce::CF::at_or<applesauce::CF::DataRef>(v372, v35, v36, &v386);
            if (v386.__begin_)
              CFRelease(v386.__begin_);
            v40 = (const __CFData *)v372[0];
            if (!v372[0])
            {
              if ((v52 & 1) == 0
              {
                AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
              }
              v53 = AU::ReferenceSignalMixer::getLog(void)::gLog;
              if (!os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR))
                goto LABEL_111;
              LODWORD(v386.__begin_) = 134218496;
              *(std::vector<char>::pointer *)((char *)&v386.__begin_ + 4) = (std::vector<char>::pointer)this;
              WORD2(v386.__end_) = 1024;
              *(_DWORD *)((char *)&v386.__end_ + 6) = v366;
              WORD1(v386.__end_cap_.__value_) = 1024;
              HIDWORD(v386.__end_cap_.__value_) = v37;
              v54 = v53;
              v55 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelLayouts\"][%u] has invalid value";
              goto LABEL_113;
            }
            BytePtr = CFDataGetBytePtr((CFDataRef)v372[0]);
            Length = CFDataGetLength(v40);
            if (Length <= 0x1F)
            {
              if ((v56 & 1) == 0
              {
                AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
              }
              v57 = AU::ReferenceSignalMixer::getLog(void)::gLog;
              if (!os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR))
                goto LABEL_111;
              LODWORD(v386.__begin_) = 134218496;
              *(std::vector<char>::pointer *)((char *)&v386.__begin_ + 4) = (std::vector<char>::pointer)this;
              WORD2(v386.__end_) = 1024;
              *(_DWORD *)((char *)&v386.__end_ + 6) = v366;
              WORD1(v386.__end_cap_.__value_) = 1024;
              HIDWORD(v386.__end_cap_.__value_) = v37;
              v54 = v57;
              v55 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelLayouts\"][%u] has insuf"
                    "ficient byte size";
              goto LABEL_113;
            }
            v43 = *((_DWORD *)BytePtr + 2);
            v44 = 20 * (v43 - 1) + 32;
            if (v43 <= 1)
              v44 = 32;
            if (Length == v44)
            {
              if (v43 <= 1)
                v43 = 1;
              std::vector<char>::vector(&v386, 20 * v43 + 12);
              memcpy(v386.__begin_, BytePtr, 20 * *((unsigned int *)BytePtr + 2) + 12);
              v45 = **(_DWORD **)buf;
              if (**(_DWORD **)buf == *(_DWORD *)v386.__begin_)
              {
                if (v45)
                {
                  if (v45 == 0x10000)
                  {
                    v38 = *(_DWORD *)(*(_QWORD *)buf + 4) == *((_DWORD *)v386.__begin_ + 1);
LABEL_97:
                    v386.__end_ = v386.__begin_;
                    operator delete(v386.__begin_);
                    v51 = 1;
                    goto LABEL_98;
                  }
LABEL_96:
                  v38 = 1;
                  goto LABEL_97;
                }
                v46 = *(unsigned int *)(*(_QWORD *)buf + 8);
                if ((_DWORD)v46 == *((_DWORD *)v386.__begin_ + 2))
                {
                  if (!(_DWORD)v46)
                    goto LABEL_96;
                  v47 = v386.__begin_ + 12;
                  v48 = *(_QWORD *)buf + 12;
                  while (*(_DWORD *)v48 == *(_DWORD *)v47)
                  {
                    if (*(_DWORD *)v48 == 100)
                    {
                      v49 = *(_QWORD *)v48 == *(_QWORD *)v47 && *(_QWORD *)(v48 + 8) == *((_QWORD *)v47 + 1);
                      if (!v49 || *(_DWORD *)(v48 + 16) != (unint64_t)*((unsigned int *)v47 + 4))
                        break;
                    }
                    v47 += 20;
                    v48 += 20;
                    v38 = 1;
                    if (!--v46)
                      goto LABEL_97;
                  }
                }
              }
              v38 = 0;
              goto LABEL_97;
            }
            if ((v58 & 1) == 0
            {
              AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
            }
            v59 = AU::ReferenceSignalMixer::getLog(void)::gLog;
            if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v386.__begin_) = 134218496;
              *(std::vector<char>::pointer *)((char *)&v386.__begin_ + 4) = (std::vector<char>::pointer)this;
              WORD2(v386.__end_) = 1024;
              *(_DWORD *)((char *)&v386.__end_ + 6) = v366;
              WORD1(v386.__end_cap_.__value_) = 1024;
              HIDWORD(v386.__end_cap_.__value_) = v37;
              v54 = v59;
              v55 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"InputChannelLayouts\"][%u] has unexpected byte size";
LABEL_113:
              _os_log_error_impl(&dword_1B5ED0000, v54, OS_LOG_TYPE_ERROR, v55, (uint8_t *)&v386, 0x18u);
            }
LABEL_111:
            v38 = 0;
            v51 = 0;
            v364 = -10875;
LABEL_98:
            if (v372[0])
              CFRelease(v372[0]);
            v35 = (const __CFArray *)cf[0];
            if (!v51)
              break;
            v36 = ++v37;
            if (!cf[0])
            {
              v343 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v343, "Could not construct");
            }
          }
          if (v38)
            v60 = 0;
          else
            v60 = 6;
          if (v39)
            v29 = v60;
          else
            v29 = 1;
          if (cf[0])
            goto LABEL_130;
LABEL_131:
          if (*(_QWORD *)buf)
          {
            *(_QWORD *)&buf[8] = *(_QWORD *)buf;
            operator delete(*(void **)buf);
          }
          if (v29)
            goto LABEL_281;
          v14 = (const __CFDictionary *)v378;
          if (!v378)
          {
            v356 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v356, "Could not construct");
          }
LABEL_135:
          CFRetain(CFSTR("MinInputChannelCount"));
          v61 = CFGetTypeID(CFSTR("MinInputChannelCount"));
          if (v61 != CFStringGetTypeID())
          {
            CFRelease(CFSTR("MinInputChannelCount"));
            if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, 0))
              goto LABEL_147;
LABEL_139:
            v63 = (const __CFDictionary *)v378;
            if (!v378)
            {
              v349 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v349, "Could not construct");
            }
            CFRetain(CFSTR("MinInputChannelCount"));
            v64 = CFGetTypeID(CFSTR("MinInputChannelCount"));
            if (v64 == CFStringGetTypeID())
            {
              *(_QWORD *)buf = CFSTR("MinInputChannelCount");
            }
            else
            {
              *(_QWORD *)buf = 0;
              CFRelease(CFSTR("MinInputChannelCount"));
            }
            v65 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(v63, (const void **)buf);
            v66 = *(AU::ReferenceSignalMixer **)buf;
            if (*(_QWORD *)buf)
              CFRelease(*(CFTypeRef *)buf);
            if (((unint64_t)v65 & 0xFF00000000) == 0)
            {
              v315 = AU::ReferenceSignalMixer::getLog(v66);
              if (os_log_type_enabled(v315, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 134218240;
                *(_QWORD *)&buf[4] = this;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v366;
                v316 = v315;
                v317 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"MinInputChannelCount\"] has invalid value";
                goto LABEL_712;
              }
              goto LABEL_689;
            }
            if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v3, 0) + 108) >= v65)
              goto LABEL_147;
            goto LABEL_280;
          }
          v62 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v14, CFSTR("MinInputChannelCount"));
          CFRelease(CFSTR("MinInputChannelCount"));
          if (v62)
            goto LABEL_139;
LABEL_147:
          v67 = (const __CFDictionary *)v378;
          if (!v378)
          {
            v346 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v346, "Could not construct");
          }
          CFRetain(CFSTR("MaxInputChannelCount"));
          v68 = CFGetTypeID(CFSTR("MaxInputChannelCount"));
          if (v68 != CFStringGetTypeID())
          {
            CFRelease(CFSTR("MaxInputChannelCount"));
            if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, 0))
              goto LABEL_159;
LABEL_152:
            CFRetain(CFSTR("MaxInputChannelCount"));
            v70 = CFGetTypeID(CFSTR("MaxInputChannelCount"));
            if (v70 == CFStringGetTypeID())
            {
              *(_QWORD *)buf = CFSTR("MaxInputChannelCount");
            }
            else
            {
              *(_QWORD *)buf = 0;
              CFRelease(CFSTR("MaxInputChannelCount"));
            }
            v71 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(v67, (const void **)buf);
            v72 = *(AU::ReferenceSignalMixer **)buf;
            if (*(_QWORD *)buf)
              CFRelease(*(CFTypeRef *)buf);
            if (((unint64_t)v71 & 0xFF00000000) == 0)
            {
              v318 = AU::ReferenceSignalMixer::getLog(v72);
              if (os_log_type_enabled(v318, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 134218240;
                *(_QWORD *)&buf[4] = this;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v366;
                v316 = v318;
                v317 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"MaxInputChannelCount\"] has invalid value";
                goto LABEL_712;
              }
              goto LABEL_689;
            }
            if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v3, 0) + 108) <= v71)
              goto LABEL_159;
            goto LABEL_280;
          }
          v69 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, CFSTR("MaxInputChannelCount"));
          CFRelease(CFSTR("MaxInputChannelCount"));
          if (v69)
            goto LABEL_152;
LABEL_159:
          CFRetain(CFSTR("OutputChannelCounts"));
          v73 = CFGetTypeID(CFSTR("OutputChannelCounts"));
          if (v73 == CFStringGetTypeID())
          {
            v74 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, CFSTR("OutputChannelCounts"));
            CFRelease(CFSTR("OutputChannelCounts"));
            if (!v74)
              goto LABEL_186;
          }
          else
          {
            CFRelease(CFSTR("OutputChannelCounts"));
            if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, 0))
              goto LABEL_186;
          }
          CFRetain(CFSTR("OutputChannelCounts"));
          v75 = CFGetTypeID(CFSTR("OutputChannelCounts"));
          if (v75 == CFStringGetTypeID())
          {
            *(_QWORD *)buf = CFSTR("OutputChannelCounts");
          }
          else
          {
            *(_QWORD *)buf = 0;
            CFRelease(CFSTR("OutputChannelCounts"));
          }
          cf[0] = 0;
          applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>((const __CFDictionary **)&v386, v67, (const void **)buf, (const __CFDictionary **)cf);
          if (cf[0])
            CFRelease(cf[0]);
          v76 = *(AU::ReferenceSignalMixer **)buf;
          if (*(_QWORD *)buf)
            CFRelease(*(CFTypeRef *)buf);
          v77 = (const __CFArray *)v386.__begin_;
          if (v386.__begin_)
          {
            v78 = 0;
            v79 = 0;
            v80 = 0;
            while (1)
            {
              v81 = CFArrayGetCount(v77) <= v78;
              if (v81 || v80)
              {
                if (v81)
                  v83 = 6;
                else
                  v83 = 13;
                if (v80)
                  v29 = 0;
                else
                  v29 = v83;
                goto LABEL_182;
              }
              v82 = applesauce::CF::details::at_as<unsigned int>(v77, v78);
              if ((v82 & 0xFF00000000) == 0)
                break;
              v80 = *(_DWORD *)(ausdk::AUScope::SafeGetElement(v4, 0) + 108) == (_DWORD)v82;
              v78 = ++v79;
            }
            if ((v192 & 1) == 0
            {
              AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
            }
            v193 = AU::ReferenceSignalMixer::getLog(void)::gLog;
            if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v79;
              v312 = v193;
              v313 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelCounts\"][%u] has invalid value";
              v314 = 24;
              goto LABEL_697;
            }
          }
          else
          {
            v319 = AU::ReferenceSignalMixer::getLog(v76);
            if (os_log_type_enabled(v319, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              v312 = v319;
              v313 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelCounts\"] has invalid value";
              v314 = 18;
LABEL_697:
              _os_log_error_impl(&dword_1B5ED0000, v312, OS_LOG_TYPE_ERROR, v313, buf, v314);
            }
          }
          v364 = -10875;
          v29 = 1;
LABEL_182:
          if (v386.__begin_)
            CFRelease(v386.__begin_);
          if (v29)
            goto LABEL_281;
          v67 = (const __CFDictionary *)v378;
          if (!v378)
          {
            v357 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v357, "Could not construct");
          }
LABEL_186:
          CFRetain(CFSTR("OutputChannelLayouts"));
          v84 = CFGetTypeID(CFSTR("OutputChannelLayouts"));
          if (v84 == CFStringGetTypeID())
          {
            v85 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, CFSTR("OutputChannelLayouts"));
            CFRelease(CFSTR("OutputChannelLayouts"));
            if (!v85)
              goto LABEL_258;
          }
          else
          {
            CFRelease(CFSTR("OutputChannelLayouts"));
            if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, 0))
              goto LABEL_258;
          }
          v86 = ausdk::AUScope::SafeGetElement(v4, 0);
          AU::ReferenceSignalMixer::MakeDefaultChannelLayout(&v386, *(_DWORD *)(v86 + 108));
          std::optional<CA::ChannelLayout>::value_or[abi:ne180100]<CA::ChannelLayout>((__n128 *)buf, (uint64_t)this + 576, (__n128 *)&v386);
          if (v386.__begin_)
          {
            v386.__end_ = v386.__begin_;
            operator delete(v386.__begin_);
          }
          CFRetain(CFSTR("OutputChannelLayouts"));
          v87 = CFGetTypeID(CFSTR("OutputChannelLayouts"));
          if (v87 == CFStringGetTypeID())
          {
            v386.__begin_ = (std::vector<char>::pointer)CFSTR("OutputChannelLayouts");
          }
          else
          {
            v386.__begin_ = 0;
            CFRelease(CFSTR("OutputChannelLayouts"));
          }
          v372[0] = 0;
          applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>((const __CFDictionary **)cf, v67, (const void **)&v386.__begin_, (const __CFDictionary **)v372);
          if (v372[0])
            CFRelease(v372[0]);
          v88 = (AU::ReferenceSignalMixer *)v386.__begin_;
          if (v386.__begin_)
            CFRelease(v386.__begin_);
          v89 = (const __CFArray *)cf[0];
          if (!cf[0])
          {
            v320 = AU::ReferenceSignalMixer::getLog(v88);
            if (os_log_type_enabled(v320, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v386.__begin_) = 134218240;
              *(std::vector<char>::pointer *)((char *)&v386.__begin_ + 4) = (std::vector<char>::pointer)this;
              WORD2(v386.__end_) = 1024;
              *(_DWORD *)((char *)&v386.__end_ + 6) = v366;
              _os_log_error_impl(&dword_1B5ED0000, v320, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelLayouts\"] has invalid value", (uint8_t *)&v386, 0x12u);
            }
            v29 = 1;
            v364 = -10875;
            goto LABEL_255;
          }
          v90 = 0;
          v91 = 0;
          v92 = 0;
          while (2)
          {
            v93 = CFArrayGetCount(v89) <= v90 || v92;
            if (v93)
            {
              v122 = 16;
              goto LABEL_247;
            }
            v386.__begin_ = 0;
            applesauce::CF::at_or<applesauce::CF::DataRef>(v372, v89, v90, &v386);
            v94 = (AU::ReferenceSignalMixer *)v386.__begin_;
            if (v386.__begin_)
              CFRelease(v386.__begin_);
            v95 = (const __CFData *)v372[0];
            if (v372[0])
            {
              v96 = CFDataGetBytePtr((CFDataRef)v372[0]);
              v97 = (AU::ReferenceSignalMixer *)CFDataGetLength(v95);
              if ((unint64_t)v97 <= 0x1F)
              {
                v118 = AU::ReferenceSignalMixer::getLog(v97);
                if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
                  goto LABEL_242;
                LODWORD(v386.__begin_) = 134218496;
                *(std::vector<char>::pointer *)((char *)&v386.__begin_ + 4) = (std::vector<char>::pointer)this;
                WORD2(v386.__end_) = 1024;
                *(_DWORD *)((char *)&v386.__end_ + 6) = v366;
                WORD1(v386.__end_cap_.__value_) = 1024;
                HIDWORD(v386.__end_cap_.__value_) = v91;
                v119 = v118;
                v120 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelLayouts\"][%u] has i"
                       "nsufficient byte size";
              }
              else
              {
                v98 = *((_DWORD *)v96 + 2);
                v99 = 20 * (v98 - 1) + 32;
                if (v98 <= 1)
                  v99 = 32;
                if (v97 == (AU::ReferenceSignalMixer *)v99)
                {
                  if (v98 <= 1)
                    v98 = 1;
                  std::vector<char>::vector(&v386, 20 * v98 + 12);
                  memcpy(v386.__begin_, v96, 20 * *((unsigned int *)v96 + 2) + 12);
                  v100 = **(_DWORD **)buf;
                  if (**(_DWORD **)buf == *(_DWORD *)v386.__begin_)
                  {
                    if (v100)
                    {
                      if (v100 == 0x10000)
                      {
                        v92 = *(_DWORD *)(*(_QWORD *)buf + 4) == *((_DWORD *)v386.__begin_ + 1);
                        goto LABEL_232;
                      }
LABEL_231:
                      v92 = 1;
LABEL_232:
                      v386.__end_ = v386.__begin_;
                      operator delete(v386.__begin_);
LABEL_233:
                      v117 = 1;
LABEL_234:
                      CFRelease(v95);
                      if (v117)
                      {
LABEL_235:
                        v90 = ++v91;
                        continue;
                      }
                      v122 = 1;
LABEL_247:
                      if (v92)
                        v123 = 0;
                      else
                        v123 = 6;
                      goto LABEL_250;
                    }
                    v101 = *(unsigned int *)(*(_QWORD *)buf + 8);
                    if ((_DWORD)v101 == *((_DWORD *)v386.__begin_ + 2))
                    {
                      if (!(_DWORD)v101)
                        goto LABEL_231;
                      v102 = 0;
                      v103 = 20 * v101;
                      v104 = v386.__begin_ + 12;
                      v105 = *(_QWORD *)buf + 12;
                      while (1)
                      {
                        v106 = (uint64_t *)(v105 + v102);
                        v107 = &v104[v102];
                        v108 = *(_DWORD *)(v105 + v102);
                        if (v108 != *(_DWORD *)&v104[v102])
                          break;
                        if (v108 == 100)
                        {
                          v109 = *v106;
                          v110 = v106[1];
                          v111 = *(_QWORD *)v107;
                          v112 = *((_QWORD *)v107 + 1);
                          v113 = *((unsigned int *)v106 + 4);
                          v114 = *((unsigned int *)v107 + 4);
                          v115 = v109 == v111 && v110 == v112;
                          if (!v115 || v113 != v114)
                            break;
                        }
                        v102 += 20;
                        if (v103 == v102)
                        {
                          v92 = 1;
                          goto LABEL_237;
                        }
                      }
                      v92 = 0;
LABEL_237:
                      v386.__end_ = v386.__begin_;
                      operator delete(v386.__begin_);
                      if (v95)
                        goto LABEL_233;
                      goto LABEL_235;
                    }
                  }
                  v92 = 0;
                  goto LABEL_232;
                }
                v121 = AU::ReferenceSignalMixer::getLog(v97);
                if (!os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
                {
LABEL_242:
                  v117 = 0;
                  v92 = 0;
                  v364 = -10875;
                  goto LABEL_234;
                }
                LODWORD(v386.__begin_) = 134218496;
                *(std::vector<char>::pointer *)((char *)&v386.__begin_ + 4) = (std::vector<char>::pointer)this;
                WORD2(v386.__end_) = 1024;
                *(_DWORD *)((char *)&v386.__end_ + 6) = v366;
                WORD1(v386.__end_cap_.__value_) = 1024;
                HIDWORD(v386.__end_cap_.__value_) = v91;
                v119 = v121;
                v120 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelLayouts\"][%u] has u"
                       "nexpected byte size";
              }
              _os_log_error_impl(&dword_1B5ED0000, v119, OS_LOG_TYPE_ERROR, v120, (uint8_t *)&v386, 0x18u);
              goto LABEL_242;
            }
            break;
          }
          v306 = AU::ReferenceSignalMixer::getLog(v94);
          if (os_log_type_enabled(v306, OS_LOG_TYPE_ERROR))
          {
            LODWORD(v386.__begin_) = 134218496;
            *(std::vector<char>::pointer *)((char *)&v386.__begin_ + 4) = (std::vector<char>::pointer)this;
            WORD2(v386.__end_) = 1024;
            *(_DWORD *)((char *)&v386.__end_ + 6) = v366;
            WORD1(v386.__end_cap_.__value_) = 1024;
            HIDWORD(v386.__end_cap_.__value_) = v91;
            _os_log_error_impl(&dword_1B5ED0000, v306, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"OutputChannelLayouts\"][%u] has invalid value", (uint8_t *)&v386, 0x18u);
          }
          v123 = 6;
          v122 = 1;
          v364 = -10875;
LABEL_250:
          if (v93)
            v29 = v123;
          else
            v29 = v122;
          if (v89)
            CFRelease(v89);
LABEL_255:
          if (*(_QWORD *)buf)
          {
            *(_QWORD *)&buf[8] = *(_QWORD *)buf;
            operator delete(*(void **)buf);
          }
          if (v29)
            goto LABEL_281;
LABEL_258:
          CFRetain(CFSTR("MinOutputChannelCount"));
          v124 = CFGetTypeID(CFSTR("MinOutputChannelCount"));
          if (v124 != CFStringGetTypeID())
          {
            CFRelease(CFSTR("MinOutputChannelCount"));
            if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, 0))
              goto LABEL_269;
LABEL_262:
            CFRetain(CFSTR("MinOutputChannelCount"));
            v126 = CFGetTypeID(CFSTR("MinOutputChannelCount"));
            if (v126 == CFStringGetTypeID())
            {
              *(_QWORD *)buf = CFSTR("MinOutputChannelCount");
            }
            else
            {
              *(_QWORD *)buf = 0;
              CFRelease(CFSTR("MinOutputChannelCount"));
            }
            v127 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(v67, (const void **)buf);
            v128 = *(AU::ReferenceSignalMixer **)buf;
            if (*(_QWORD *)buf)
              CFRelease(*(CFTypeRef *)buf);
            if (((unint64_t)v127 & 0xFF00000000) == 0)
            {
              v322 = AU::ReferenceSignalMixer::getLog(v128);
              if (!os_log_type_enabled(v322, OS_LOG_TYPE_ERROR))
                goto LABEL_689;
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              v316 = v322;
              v317 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"MinOutputChannelCount\"] has invalid value";
              goto LABEL_712;
            }
            if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v4, 0) + 108) >= v127)
              goto LABEL_269;
LABEL_280:
            v29 = 6;
            goto LABEL_281;
          }
          v125 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, CFSTR("MinOutputChannelCount"));
          CFRelease(CFSTR("MinOutputChannelCount"));
          if (v125)
            goto LABEL_262;
LABEL_269:
          CFRetain(CFSTR("MaxOutputChannelCount"));
          v129 = CFGetTypeID(CFSTR("MaxOutputChannelCount"));
          if (v129 != CFStringGetTypeID())
          {
            CFRelease(CFSTR("MaxOutputChannelCount"));
            if (!applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, 0))
              goto LABEL_289;
LABEL_273:
            CFRetain(CFSTR("MaxOutputChannelCount"));
            v131 = CFGetTypeID(CFSTR("MaxOutputChannelCount"));
            if (v131 == CFStringGetTypeID())
            {
              *(_QWORD *)buf = CFSTR("MaxOutputChannelCount");
            }
            else
            {
              *(_QWORD *)buf = 0;
              CFRelease(CFSTR("MaxOutputChannelCount"));
            }
            v132 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(v67, (const void **)buf);
            v133 = *(AU::ReferenceSignalMixer **)buf;
            if (*(_QWORD *)buf)
              CFRelease(*(CFTypeRef *)buf);
            if (((unint64_t)v132 & 0xFF00000000) != 0)
            {
              if (*(_DWORD *)(ausdk::AUScope::SafeGetElement(v4, 0) + 108) <= v132)
                goto LABEL_289;
              goto LABEL_280;
            }
            v323 = AU::ReferenceSignalMixer::getLog(v133);
            if (!os_log_type_enabled(v323, OS_LOG_TYPE_ERROR))
              goto LABEL_689;
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = this;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v366;
            v316 = v323;
            v317 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"MaxOutputChannelCount\"] has invalid value";
LABEL_712:
            _os_log_error_impl(&dword_1B5ED0000, v316, OS_LOG_TYPE_ERROR, v317, buf, 0x12u);
            goto LABEL_689;
          }
          v130 = applesauce::CF::details::has_key<applesauce::CF::StringRef>(v67, CFSTR("MaxOutputChannelCount"));
          CFRelease(CFSTR("MaxOutputChannelCount"));
          if (v130)
            goto LABEL_273;
LABEL_289:
          v134 = applesauce::CF::details::has_key<char const(&)[6]>(v67, "Gains");
          if (!v134)
          {
            v321 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v134);
            if (os_log_type_enabled(v321, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              v316 = v321;
              v317 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has no \"Gains\" key";
              goto LABEL_712;
            }
LABEL_689:
            v364 = -10875;
            v29 = 1;
            goto LABEL_281;
          }
          v135 = applesauce::CF::details::at_key<char const(&)[6]>(v67, "Gains");
          if (!v135)
            goto LABEL_338;
          v136 = v135;
          CFRetain(v135);
          v137 = CFGetTypeID(v136);
          if (v137 != CFArrayGetTypeID())
          {
            CFRelease(v136);
LABEL_338:
            buf[0] = 0;
            buf[8] = 0;
            v376 = 0;
            v165 = (AU::ReferenceSignalMixer *)std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
            v166 = AU::ReferenceSignalMixer::getLog(v165);
            if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              _os_log_error_impl(&dword_1B5ED0000, v166, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has invalid \"Gains\" value", buf, 0x12u);
            }
            v29 = 1;
            v364 = -10875;
            goto LABEL_281;
          }
          *(_QWORD *)buf = v136;
          buf[8] = 1;
          CFRetain(v136);
          v376 = v136;
          std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
          v138 = (char *)operator new(0x38uLL);
          *(_OWORD *)(v138 + 8) = 0u;
          *(_QWORD *)v138 = &off_1E69C8DC0;
          *((_QWORD *)v138 + 3) = off_1E69C8CF0;
          v139 = *((unsigned int *)this + 133);
          v140 = *((unsigned int *)this + 142);
          *((_QWORD *)v138 + 4) = 0;
          *(_OWORD *)(v138 + 40) = 0u;
          LODWORD(cf[0]) = 0;
          std::vector<float>::vector(buf, v139, cf);
          std::vector<std::vector<float>>::resize((uint64_t *)v138 + 4, v140, (uint64_t)buf);
          if (*(_QWORD *)buf)
          {
            *(_QWORD *)&buf[8] = *(_QWORD *)buf;
            operator delete(*(void **)buf);
          }
          v141 = 0;
          v142 = 0;
          *(_QWORD *)&v375 = v138 + 24;
          *((_QWORD *)&v375 + 1) = v138;
          while (CFArrayGetCount((CFArrayRef)v136) > v141)
          {
            v136 = v376;
            if (!v376)
            {
              v347 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v347, "Could not construct");
            }
            *(_QWORD *)buf = 0;
            applesauce::CF::at_or<applesauce::CF::DictionaryRef>(&v386, (CFArrayRef)v376, v141, buf);
            if (*(_QWORD *)buf)
              CFRelease(*(CFTypeRef *)buf);
            if (!v386.__begin_)
            {
              v159 = AU::ReferenceSignalMixer::getLog(0);
              if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 134218496;
                *(_QWORD *)&buf[4] = this;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v366;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v142;
                v157 = v159;
                v158 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u] has invalid value";
                goto LABEL_324;
              }
LABEL_318:
              v155 = 0;
              v364 = -10875;
              goto LABEL_319;
            }
            v143 = applesauce::CF::details::has_key<char const(&)[6]>((const __CFDictionary *)v386.__begin_, "Input");
            if (!v143)
            {
              v160 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v143);
              if (!os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
                goto LABEL_318;
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v142;
              v157 = v160;
              v158 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u] has no \"Input\" key";
              goto LABEL_324;
            }
            if (!v386.__begin_)
            {
              v348 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v348, "Could not construct");
            }
            v144 = (uint64_t)applesauce::CF::details::at_key<char const(&)[6]>((const __CFDictionary *)v386.__begin_, "Input");
            if (!v144
              || (v144 = applesauce::CF::convert_as<unsigned int,0>((const __CFNumber *)v144),
                  (v144 & 0xFF00000000) == 0))
            {
              v156 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v144);
              if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 134218496;
                *(_QWORD *)&buf[4] = this;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v366;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v142;
                v157 = v156;
                v158 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u][\"Input\"] has invalid value";
                goto LABEL_324;
              }
              goto LABEL_318;
            }
            v145 = (const __CFDictionary *)v386.__begin_;
            if (!v386.__begin_)
            {
              v350 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v350, "Could not construct");
            }
            v146 = v144;
            applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)buf, "Output");
            v147 = CFDictionaryContainsKey(v145, *(const void **)buf);
            v148 = *(AU::ReferenceSignalMixer **)buf;
            if (*(_QWORD *)buf)
              CFRelease(*(CFTypeRef *)buf);
            if (!v147)
            {
              v161 = AU::ReferenceSignalMixer::getLog(v148);
              if (!os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
                goto LABEL_318;
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v142;
              v157 = v161;
              v158 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u] has no \"Output\" key";
              goto LABEL_324;
            }
            if (!v386.__begin_)
            {
              v351 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v351, "Could not construct");
            }
            *(_QWORD *)buf = &v386;
            v149 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,char const(&)[7]>((const __CFDictionary ***)buf, "Output");
            if (((unint64_t)v149 & 0xFF00000000) == 0)
            {
              v162 = AU::ReferenceSignalMixer::getLog(v149);
              if (!os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
                goto LABEL_318;
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v142;
              v157 = v162;
              v158 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u][\"Output\"] has invalid value";
              goto LABEL_324;
            }
            v150 = v149;
            if (!v386.__begin_)
            {
              v352 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v352, "Could not construct");
            }
            v151 = applesauce::CF::details::has_key<char const(&)[5]>((const __CFDictionary *)v386.__begin_, "Gain");
            if (!v151)
            {
              v163 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v151);
              if (!os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
                goto LABEL_318;
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v142;
              v157 = v163;
              v158 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u] has no \"Gain\" key";
              goto LABEL_324;
            }
            if (!v386.__begin_)
            {
              v353 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v353, "Could not construct");
            }
            v152 = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[5]>((const __CFDictionary *)v386.__begin_, "Gain");
            if (((unint64_t)v152 & 0xFF00000000) == 0)
            {
              v164 = AU::ReferenceSignalMixer::getLog(v152);
              if (!os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
                goto LABEL_318;
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v142;
              v157 = v164;
              v158 = "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Gains\"][%u][\"Gain\"] has invalid value";
LABEL_324:
              _os_log_error_impl(&dword_1B5ED0000, v157, OS_LOG_TYPE_ERROR, v158, buf, 0x18u);
              goto LABEL_318;
            }
            v153 = *(_QWORD *)(v375 + 8);
            if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v375 + 16) - v153) >> 3) <= v150)
              std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
            v154 = (_QWORD *)(v153 + 24 * v150);
            if (v146 >= (unint64_t)((uint64_t)(v154[1] - *v154) >> 2))
              std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
            *(_DWORD *)(*v154 + 4 * v146) = (_DWORD)v152;
            v155 = 1;
LABEL_319:
            if (v386.__begin_)
              CFRelease(v386.__begin_);
            if ((v155 & 1) == 0)
              goto LABEL_720;
            v141 = (v142 + 1);
            v142 = v141;
          }
          if (v377)
            v167 = CFHash(v377);
          else
            v167 = 0xD7C06285B9DE677ALL;
          v170 = *((_QWORD *)&v383 + 1);
          if (*((_QWORD *)&v383 + 1))
          {
            v171 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v383 + 8));
            v171.i16[0] = vaddlv_u8(v171);
            v172 = v171.u32[0];
            if (v171.u32[0] > 1uLL)
            {
              v142 = v167;
              if (v167 >= *((_QWORD *)&v383 + 1))
                v142 = v167 % *((_QWORD *)&v383 + 1);
            }
            else
            {
              v142 = (*((_QWORD *)&v383 + 1) - 1) & v167;
            }
            v173 = *(uint64_t ***)(v383 + 8 * v142);
            if (v173)
            {
              for (i = *v173; i; i = (uint64_t *)*i)
              {
                v175 = i[1];
                if (v175 == v167)
                {
                  if (applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>((CFTypeRef *)i + 2, (const __CFString **)&v377) == kCFCompareEqualTo)goto LABEL_425;
                }
                else
                {
                  if (v172 > 1)
                  {
                    if (v175 >= v170)
                      v175 %= v170;
                  }
                  else
                  {
                    v175 &= v170 - 1;
                  }
                  if (v175 != v142)
                    break;
                }
              }
            }
          }
          v176 = operator new(0x28uLL);
          *(_QWORD *)buf = v176;
          *(_QWORD *)&buf[8] = &v384;
          *v176 = 0;
          v176[1] = v167;
          v177 = v377;
          if (v377)
            CFRetain(v377);
          v176[3] = 0;
          v176[4] = 0;
          v176[2] = v177;
          buf[16] = 1;
          v178 = (float)(unint64_t)(*((_QWORD *)&v384 + 1) + 1);
          if (!v170 || (float)(v385 * (float)v170) < v178)
          {
            v179 = (v170 & (v170 - 1)) != 0;
            if (v170 < 3)
              v179 = 1;
            v180 = v179 | (2 * v170);
            v181 = vcvtps_u32_f32(v178 / v385);
            if (v180 <= v181)
              prime = (int8x8_t)v181;
            else
              prime = (int8x8_t)v180;
            if (*(_QWORD *)&prime == 1)
            {
              prime = (int8x8_t)2;
            }
            else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
            {
              prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
            }
            v170 = *((_QWORD *)&v383 + 1);
            if (*(_QWORD *)&prime <= *((_QWORD *)&v383 + 1))
            {
              if (*(_QWORD *)&prime < *((_QWORD *)&v383 + 1))
              {
                v189 = vcvtps_u32_f32((float)*((unint64_t *)&v384 + 1) / v385);
                if (*((_QWORD *)&v383 + 1) < 3uLL
                  || (v190 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v383 + 8)),
                      v190.i16[0] = vaddlv_u8(v190),
                      v190.u32[0] > 1uLL))
                {
                  v189 = std::__next_prime(v189);
                }
                else
                {
                  v191 = 1 << -(char)__clz(v189 - 1);
                  if (v189 >= 2)
                    v189 = v191;
                }
                if (*(_QWORD *)&prime <= v189)
                  prime = (int8x8_t)v189;
                if (*(_QWORD *)&prime >= v170)
                {
                  v170 = *((_QWORD *)&v383 + 1);
                }
                else
                {
                  if (prime)
                    goto LABEL_378;
                  v307 = (void *)v383;
                  *(_QWORD *)&v383 = 0;
                  if (v307)
                    operator delete(v307);
                  v170 = 0;
                  *((_QWORD *)&v383 + 1) = 0;
                }
              }
            }
            else
            {
LABEL_378:
              if (*(_QWORD *)&prime >> 61)
                std::__throw_bad_array_new_length[abi:ne180100]();
              v183 = operator new(8 * *(_QWORD *)&prime);
              v184 = (void *)v383;
              *(_QWORD *)&v383 = v183;
              if (v184)
                operator delete(v184);
              v185 = 0;
              *((int8x8_t *)&v383 + 1) = prime;
              do
                *(_QWORD *)(v383 + 8 * v185++) = 0;
              while (*(_QWORD *)&prime != v185);
              v186 = (_QWORD **)v384;
              if ((_QWORD)v384)
              {
                v187 = *(_QWORD *)(v384 + 8);
                v188 = (uint8x8_t)vcnt_s8(prime);
                v188.i16[0] = vaddlv_u8(v188);
                if (v188.u32[0] > 1uLL)
                {
                  if (v187 >= *(_QWORD *)&prime)
                    v187 %= *(_QWORD *)&prime;
                }
                else
                {
                  v187 &= *(_QWORD *)&prime - 1;
                }
                *(_QWORD *)(v383 + 8 * v187) = &v384;
                for (j = *v186; j; v187 = v195)
                {
                  v195 = j[1];
                  if (v188.u32[0] > 1uLL)
                  {
                    if (v195 >= *(_QWORD *)&prime)
                      v195 %= *(_QWORD *)&prime;
                  }
                  else
                  {
                    v195 &= *(_QWORD *)&prime - 1;
                  }
                  if (v195 != v187)
                  {
                    if (!*(_QWORD *)(v383 + 8 * v195))
                    {
                      *(_QWORD *)(v383 + 8 * v195) = v186;
                      goto LABEL_406;
                    }
                    *v186 = (_QWORD *)*j;
                    *j = **(_QWORD **)(v383 + 8 * v195);
                    **(_QWORD **)(v383 + 8 * v195) = j;
                    j = v186;
                  }
                  v195 = v187;
LABEL_406:
                  v186 = (_QWORD **)j;
                  j = (_QWORD *)*j;
                }
              }
              v170 = (unint64_t)prime;
            }
            if ((v170 & (v170 - 1)) != 0)
            {
              if (v167 >= v170)
                v142 = v167 % v170;
              else
                v142 = v167;
            }
            else
            {
              v142 = (v170 - 1) & v167;
            }
          }
          v196 = *(_QWORD **)(v383 + 8 * v142);
          i = *(uint64_t **)buf;
          if (v196)
          {
            **(_QWORD **)buf = *v196;
            goto LABEL_423;
          }
          **(_QWORD **)buf = v384;
          *(_QWORD *)&v384 = i;
          *(_QWORD *)(v383 + 8 * v142) = &v384;
          if (*i)
          {
            v197 = *(_QWORD *)(*i + 8);
            if ((v170 & (v170 - 1)) != 0)
            {
              if (v197 >= v170)
                v197 %= v170;
            }
            else
            {
              v197 &= v170 - 1;
            }
            v196 = (_QWORD *)(v383 + 8 * v197);
LABEL_423:
            *v196 = i;
          }
          *(_QWORD *)buf = 0;
          ++*((_QWORD *)&v384 + 1);
          std::unique_ptr<std::__hash_node<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>>>>::reset[abi:ne180100]((uint64_t)buf);
LABEL_425:
          v198 = v375;
          v375 = 0uLL;
          v199 = (std::__shared_weak_count *)i[4];
          *(_OWORD *)(i + 3) = v198;
          if (v199)
          {
            p_shared_owners = (unint64_t *)&v199->__shared_owners_;
            do
              v201 = __ldaxr(p_shared_owners);
            while (__stlxr(v201 - 1, p_shared_owners));
            if (!v201)
            {
              ((void (*)(std::__shared_weak_count *))v199->__on_zero_shared)(v199);
              std::__shared_weak_count::__release_weak(v199);
            }
          }
          v202 = (const __CFDictionary *)v378;
          if (!v378)
          {
            v360 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v360, "Could not construct");
          }
          v203 = applesauce::CF::details::has_key<char const(&)[13]>((const __CFDictionary *)v378, "Orientations");
          if (!v203)
          {
            v325 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)v203);
            if (os_log_type_enabled(v325, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              _os_log_error_impl(&dword_1B5ED0000, v325, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has no \"Orientations\" key", buf, 0x12u);
            }
            v364 = -10875;
LABEL_720:
            v29 = 1;
            goto LABEL_721;
          }
          v204 = (const __CFArray *)applesauce::CF::details::at_key<char const(&)[13]>(v202, "Orientations");
          if (!v204)
            goto LABEL_557;
          v205 = v204;
          CFRetain(v204);
          v206 = CFGetTypeID(v205);
          if (v206 != CFArrayGetTypeID())
          {
            CFRelease(v205);
LABEL_557:
            buf[0] = 0;
            buf[8] = 0;
            theArray = 0;
            v259 = (AU::ReferenceSignalMixer *)std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
            v260 = AU::ReferenceSignalMixer::getLog(v259);
            if (os_log_type_enabled(v260, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v366;
              _os_log_error_impl(&dword_1B5ED0000, v260, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u] has invalid \"Gains\" value", buf, 0x12u);
            }
            v364 = -10875;
            v29 = 1;
            goto LABEL_671;
          }
          *(_QWORD *)buf = v205;
          buf[8] = 1;
          CFRetain(v205);
          theArray = v205;
          std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
          v207 = 0;
          v361 = 0;
          while (CFArrayGetCount(v205) > v207)
          {
            v208 = theArray;
            if (!theArray)
            {
              v358 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v358, "Could not construct");
            }
            Count = CFArrayGetCount(theArray);
            if (Count <= v207 || (Count = (CFTypeID)CFArrayGetValueAtIndex(v208, v207)) == 0)
            {
              LOBYTE(v386.__begin_) = 0;
              LOBYTE(v387) = 0;
LABEL_561:
              v261 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)Count);
              if (os_log_type_enabled(v261, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 134218496;
                *(_QWORD *)&buf[4] = this;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v366;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v361;
                _os_log_error_impl(&dword_1B5ED0000, v261, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Orientations\"][%u] has invalid value", buf, 0x18u);
              }
              goto LABEL_563;
            }
            Count = applesauce::CF::convert_as<std::string,0>((uint64_t)&v386, (const __CFString *)Count);
            v210 = v387;
            if (!(_BYTE)v387)
              goto LABEL_561;
            v211 = 0;
            if (SHIBYTE(v386.__end_cap_.__value_) >= 0)
              value_high = (std::vector<char>::pointer)HIBYTE(v386.__end_cap_.__value_);
            else
              value_high = v386.__end_;
            if (SHIBYTE(v386.__end_cap_.__value_) >= 0)
              v213 = (unint64_t)&v386;
            else
              v213 = (unint64_t)v386.__begin_;
            while (1)
            {
              v214 = (const void **)((char *)&AU::ReferenceSignalMixer::gOrientationStringMap + v211);
              if (*(std::vector<char>::pointer *)((char *)&AU::ReferenceSignalMixer::gOrientationStringMap + v211 + 16) == value_high)
              {
                Count = memcmp(v214[1], (const void *)v213, (size_t)value_high);
                if (!(_DWORD)Count)
                  break;
              }
              v211 += 24;
              if (v211 == 168)
              {
                v215 = AU::ReferenceSignalMixer::getLog((AU::ReferenceSignalMixer *)Count);
                if (os_log_type_enabled(v215, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 134218496;
                  *(_QWORD *)&buf[4] = this;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v366;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v361;
                  _os_log_error_impl(&dword_1B5ED0000, v215, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list \"Configurations\"[%u][\"Orientations\"][%u] has unsupported value", buf, 0x18u);
                }
                v216 = 0;
                v364 = -10875;
                goto LABEL_541;
              }
            }
            v217 = *(unsigned int *)v214;
            v218 = *((_QWORD *)&__p + 1);
            if (*((_QWORD *)&__p + 1))
            {
              v219 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&__p + 8));
              v219.i16[0] = vaddlv_u8(v219);
              if (v219.u32[0] > 1uLL)
              {
                v213 = *(unsigned int *)v214;
                if (*((_QWORD *)&__p + 1) <= v217)
                  v213 = v217 % *((_QWORD *)&__p + 1);
              }
              else
              {
                v213 = (DWORD2(__p) - 1) & v217;
              }
              v220 = *(void ***)(__p + 8 * v213);
              if (v220)
              {
                v221 = (char *)*v220;
                if (*v220)
                {
                  do
                  {
                    v222 = *((_QWORD *)v221 + 1);
                    if (v222 == v217)
                    {
                      if (*((_DWORD *)v221 + 4) == (_DWORD)v217)
                        goto LABEL_524;
                    }
                    else
                    {
                      if (v219.u32[0] > 1uLL)
                      {
                        if (v222 >= *((_QWORD *)&__p + 1))
                          v222 %= *((_QWORD *)&__p + 1);
                      }
                      else
                      {
                        v222 &= *((_QWORD *)&__p + 1) - 1;
                      }
                      if (v222 != v213)
                        break;
                    }
                    v221 = *(char **)v221;
                  }
                  while (v221);
                }
              }
            }
            v221 = (char *)operator new(0x30uLL);
            *(_QWORD *)v221 = 0;
            *((_QWORD *)v221 + 1) = v217;
            *((_DWORD *)v221 + 4) = v217;
            *((_QWORD *)v221 + 4) = 0;
            *((_QWORD *)v221 + 5) = 0;
            *((_QWORD *)v221 + 3) = 0;
            v223 = (float)(unint64_t)(*((_QWORD *)&v381 + 1) + 1);
            if (v218 && (float)(v382 * (float)v218) >= v223)
            {
              v217 = v213;
              goto LABEL_514;
            }
            v224 = (v218 & (v218 - 1)) != 0;
            if (v218 < 3)
              v224 = 1;
            v225 = v224 | (2 * v218);
            v226 = vcvtps_u32_f32(v223 / v382);
            if (v225 <= v226)
              v227 = (int8x8_t)v226;
            else
              v227 = (int8x8_t)v225;
            if (*(_QWORD *)&v227 == 1)
            {
              v227 = (int8x8_t)2;
            }
            else if ((*(_QWORD *)&v227 & (*(_QWORD *)&v227 - 1)) != 0)
            {
              v227 = (int8x8_t)std::__next_prime(*(_QWORD *)&v227);
              v218 = *((_QWORD *)&__p + 1);
            }
            if (*(_QWORD *)&v227 <= v218)
            {
              if (*(_QWORD *)&v227 >= v218)
                goto LABEL_510;
              v234 = vcvtps_u32_f32((float)*((unint64_t *)&v381 + 1) / v382);
              if (v218 < 3
                || (v235 = (uint8x8_t)vcnt_s8((int8x8_t)v218), v235.i16[0] = vaddlv_u8(v235), v235.u32[0] > 1uLL))
              {
                v234 = std::__next_prime(v234);
              }
              else
              {
                v236 = 1 << -(char)__clz(v234 - 1);
                if (v234 >= 2)
                  v234 = v236;
              }
              if (*(_QWORD *)&v227 <= v234)
                v227 = (int8x8_t)v234;
              if (*(_QWORD *)&v227 >= v218)
              {
                v218 = *((_QWORD *)&__p + 1);
                goto LABEL_510;
              }
              if (!*(_QWORD *)&v227)
              {
                v258 = (void *)__p;
                *(_QWORD *)&__p = 0;
                if (v258)
                  operator delete(v258);
                v218 = 0;
                *((_QWORD *)&__p + 1) = 0;
                goto LABEL_510;
              }
            }
            if (*(_QWORD *)&v227 >> 61)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v228 = operator new(8 * *(_QWORD *)&v227);
            v229 = (void *)__p;
            *(_QWORD *)&__p = v228;
            if (v229)
              operator delete(v229);
            v230 = 0;
            *((int8x8_t *)&__p + 1) = v227;
            do
              *(_QWORD *)(__p + 8 * v230++) = 0;
            while (*(_QWORD *)&v227 != v230);
            v231 = (_QWORD **)v381;
            if ((_QWORD)v381)
            {
              v232 = *(_QWORD *)(v381 + 8);
              v233 = (uint8x8_t)vcnt_s8(v227);
              v233.i16[0] = vaddlv_u8(v233);
              if (v233.u32[0] > 1uLL)
              {
                if (v232 >= *(_QWORD *)&v227)
                  v232 %= *(_QWORD *)&v227;
              }
              else
              {
                v232 &= *(_QWORD *)&v227 - 1;
              }
              *(_QWORD *)(__p + 8 * v232) = &v381;
              for (k = *v231; k; v232 = v238)
              {
                v238 = k[1];
                if (v233.u32[0] > 1uLL)
                {
                  if (v238 >= *(_QWORD *)&v227)
                    v238 %= *(_QWORD *)&v227;
                }
                else
                {
                  v238 &= *(_QWORD *)&v227 - 1;
                }
                if (v238 != v232)
                {
                  if (!*(_QWORD *)(__p + 8 * v238))
                  {
                    *(_QWORD *)(__p + 8 * v238) = v231;
                    goto LABEL_506;
                  }
                  *v231 = (_QWORD *)*k;
                  *k = **(_QWORD **)(__p + 8 * v238);
                  **(_QWORD **)(__p + 8 * v238) = k;
                  k = v231;
                }
                v238 = v232;
LABEL_506:
                v231 = (_QWORD **)k;
                k = (_QWORD *)*k;
              }
            }
            v218 = (unint64_t)v227;
LABEL_510:
            if ((v218 & (v218 - 1)) != 0)
            {
              if (v218 <= v217)
                v217 %= v218;
            }
            else
            {
              v217 = ((_DWORD)v218 - 1) & v217;
            }
LABEL_514:
            v239 = __p;
            v240 = *(_QWORD **)(__p + 8 * v217);
            if (v240)
            {
              *(_QWORD *)v221 = *v240;
LABEL_522:
              *v240 = v221;
              goto LABEL_523;
            }
            *(_QWORD *)v221 = v381;
            *(_QWORD *)&v381 = v221;
            *(_QWORD *)(v239 + 8 * v217) = &v381;
            if (*(_QWORD *)v221)
            {
              v241 = *(_QWORD *)(*(_QWORD *)v221 + 8);
              if ((v218 & (v218 - 1)) != 0)
              {
                if (v241 >= v218)
                  v241 %= v218;
              }
              else
              {
                v241 &= v218 - 1;
              }
              v240 = (_QWORD *)(__p + 8 * v241);
              goto LABEL_522;
            }
LABEL_523:
            ++*((_QWORD *)&v381 + 1);
LABEL_524:
            v242 = *((_QWORD *)v221 + 5);
            v243 = *((_QWORD *)v221 + 4);
            if (v243 >= v242)
            {
              v245 = *((_QWORD *)v221 + 3);
              v246 = (uint64_t)(v243 - v245) >> 3;
              if ((unint64_t)(v246 + 1) >> 61)
                std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
              v247 = v242 - v245;
              v248 = v247 >> 2;
              if (v247 >> 2 <= (unint64_t)(v246 + 1))
                v248 = v246 + 1;
              if ((unint64_t)v247 >= 0x7FFFFFFFFFFFFFF8)
                v249 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v249 = v248;
              v390 = v221 + 40;
              if (v249)
                v249 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v249);
              else
                v250 = 0;
              v251 = (_QWORD *)(v249 + 8 * v246);
              v252 = v249 + 8 * v250;
              v389 = v252;
              std::construct_at[abi:ne180100]<applesauce::CF::StringRef,applesauce::CF::StringRef const&,applesauce::CF::StringRef*>(v251, &v377);
              v244 = v251 + 1;
              *(_QWORD *)&buf[16] = v251 + 1;
              v254 = (_QWORD *)*((_QWORD *)v221 + 3);
              v253 = (_QWORD *)*((_QWORD *)v221 + 4);
              if (v253 == v254)
              {
                v256 = vdupq_n_s64((unint64_t)v253);
              }
              else
              {
                do
                {
                  v255 = *--v253;
                  *--v251 = v255;
                  *v253 = 0;
                }
                while (v253 != v254);
                v256 = *(int64x2_t *)(v221 + 24);
                v244 = *(_QWORD **)&buf[16];
                v252 = v389;
              }
              *((_QWORD *)v221 + 3) = v251;
              *((_QWORD *)v221 + 4) = v244;
              *(int64x2_t *)&buf[8] = v256;
              v257 = *((_QWORD *)v221 + 5);
              *((_QWORD *)v221 + 5) = v252;
              v389 = v257;
              *(_QWORD *)buf = v256.i64[0];
              std::__split_buffer<applesauce::CF::StringRef>::~__split_buffer((uint64_t)buf);
              v210 = v387;
            }
            else
            {
              std::construct_at[abi:ne180100]<applesauce::CF::StringRef,applesauce::CF::StringRef const&,applesauce::CF::StringRef*>(*((_QWORD **)v221 + 4), &v377);
              v244 = (_QWORD *)(v243 + 8);
            }
            *((_QWORD *)v221 + 4) = v244;
            v216 = 1;
            if (v210)
            {
LABEL_541:
              if (SHIBYTE(v386.__end_cap_.__value_) < 0)
              {
                operator delete(v386.__begin_);
                if ((v216 & 1) == 0)
                  goto LABEL_564;
                goto LABEL_545;
              }
            }
            if (!v216)
              goto LABEL_564;
LABEL_545:
            v207 = (v361 + 1);
            v205 = theArray;
            ++v361;
            if (!theArray)
            {
              v359 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(v359, "Could not construct");
            }
          }
          v262 = v381;
          if (!(_QWORD)v381)
            goto LABEL_670;
          while (2)
          {
            *(_DWORD *)buf = *(_DWORD *)(v262 + 16);
            *(_QWORD *)&buf[16] = 0;
            v389 = 0;
            *(_QWORD *)&buf[8] = 0;
            v263 = (AU::ReferenceSignalMixer *)std::vector<applesauce::CF::StringRef>::__init_with_size[abi:ne180100]<applesauce::CF::StringRef*,applesauce::CF::StringRef*>(&buf[8], *(CFTypeRef **)(v262 + 24), *(CFTypeRef **)(v262 + 32), (uint64_t)(*(_QWORD *)(v262 + 32) - *(_QWORD *)(v262 + 24)) >> 3);
            v362 = (uint64_t *)v262;
            v264 = *(_QWORD *)&buf[8];
            if (*(_QWORD *)&buf[16] - *(_QWORD *)&buf[8] == 8)
            {
              v265 = std::hash<applesauce::CF::StringRef>::operator()((uint64_t)&v384 + 8, *(CFTypeRef **)&buf[8]);
              v266 = *((_QWORD *)&v383 + 1);
              if (!*((_QWORD *)&v383 + 1))
                goto LABEL_764;
              v267 = v265;
              v268 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v383 + 8));
              v268.i16[0] = vaddlv_u8(v268);
              v269 = v268.u32[0];
              if (v268.u32[0] > 1uLL)
              {
                v270 = v265;
                if (v265 >= *((_QWORD *)&v383 + 1))
                  v270 = v265 % *((_QWORD *)&v383 + 1);
              }
              else
              {
                v270 = (*((_QWORD *)&v383 + 1) - 1) & v265;
              }
              v271 = *(CFTypeRef ***)(v383 + 8 * v270);
              if (!v271 || (v272 = *v271) == 0)
LABEL_764:
                std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
              while (2)
              {
                v273 = (unint64_t)v272[1];
                if (v273 != v267)
                {
                  if (v269 > 1)
                  {
                    if (v273 >= v266)
                      v273 %= v266;
                  }
                  else
                  {
                    v273 &= v266 - 1;
                  }
                  if (v273 != v270)
                    goto LABEL_764;
LABEL_582:
                  v272 = (CFTypeRef *)*v272;
                  if (!v272)
                    goto LABEL_764;
                  continue;
                }
                break;
              }
              if (applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>(v272 + 2, (const __CFString **)v264))
              {
                goto LABEL_582;
              }
              v274 = *(unsigned int *)buf;
              v275 = *((_QWORD *)this + 79);
              if (v275)
              {
                v276 = (uint8x8_t)vcnt_s8((int8x8_t)v275);
                v276.i16[0] = vaddlv_u8(v276);
                if (v276.u32[0] > 1uLL)
                {
                  v264 = *(unsigned int *)buf;
                  if (v275 <= *(unsigned int *)buf)
                    v264 = *(unsigned int *)buf % v275;
                }
                else
                {
                  v264 = (v275 - 1) & *(_DWORD *)buf;
                }
                v277 = *(uint64_t ***)(*((_QWORD *)this + 78) + 8 * v264);
                if (v277)
                {
                  for (m = *v277; m; m = (uint64_t *)*m)
                  {
                    v279 = m[1];
                    if (v279 == *(unsigned int *)buf)
                    {
                      if (*((_DWORD *)m + 4) == *(_DWORD *)buf)
                        goto LABEL_659;
                    }
                    else
                    {
                      if (v276.u32[0] > 1uLL)
                      {
                        if (v279 >= v275)
                          v279 %= v275;
                      }
                      else
                      {
                        v279 &= v275 - 1;
                      }
                      if (v279 != v264)
                        break;
                    }
                  }
                }
              }
              v280 = (char *)operator new(0x28uLL);
              v386.__begin_ = v280;
              v386.__end_ = (char *)this + 640;
              *(_QWORD *)v280 = 0;
              *((_QWORD *)v280 + 1) = v274;
              *((_DWORD *)v280 + 4) = v274;
              *((_QWORD *)v280 + 3) = v272[3];
              v281 = (char *)v272[4];
              *((_QWORD *)v280 + 4) = v281;
              if (v281)
              {
                v282 = (unint64_t *)(v281 + 8);
                do
                  v283 = __ldxr(v282);
                while (__stxr(v283 + 1, v282));
              }
              LOBYTE(v386.__end_cap_.__value_) = 1;
              v284 = (float)(unint64_t)(*((_QWORD *)this + 81) + 1);
              v285 = *((float *)this + 164);
              if (!v275 || (float)(v285 * (float)v275) < v284)
              {
                v286 = (v275 & (v275 - 1)) != 0;
                if (v275 < 3)
                  v286 = 1;
                v287 = v286 | (2 * v275);
                v288 = vcvtps_u32_f32(v284 / v285);
                if (v287 <= v288)
                  v289 = (int8x8_t)v288;
                else
                  v289 = (int8x8_t)v287;
                if (*(_QWORD *)&v289 == 1)
                {
                  v289 = (int8x8_t)2;
                }
                else if ((*(_QWORD *)&v289 & (*(_QWORD *)&v289 - 1)) != 0)
                {
                  v289 = (int8x8_t)std::__next_prime(*(_QWORD *)&v289);
                }
                v275 = *((_QWORD *)this + 79);
                if (*(_QWORD *)&v289 <= v275)
                {
                  if (*(_QWORD *)&v289 < v275)
                  {
                    v296 = vcvtps_u32_f32((float)*((unint64_t *)this + 81) / *((float *)this + 164));
                    if (v275 < 3
                      || (v297 = (uint8x8_t)vcnt_s8((int8x8_t)v275), v297.i16[0] = vaddlv_u8(v297), v297.u32[0] > 1uLL))
                    {
                      v296 = std::__next_prime(v296);
                    }
                    else
                    {
                      v298 = 1 << -(char)__clz(v296 - 1);
                      if (v296 >= 2)
                        v296 = v298;
                    }
                    if (*(_QWORD *)&v289 <= v296)
                      v289 = (int8x8_t)v296;
                    if (*(_QWORD *)&v289 >= v275)
                    {
                      v275 = *((_QWORD *)this + 79);
                    }
                    else
                    {
                      if (v289)
                        goto LABEL_615;
                      v305 = (void *)*((_QWORD *)this + 78);
                      *((_QWORD *)this + 78) = 0;
                      if (v305)
                        operator delete(v305);
                      v275 = 0;
                      *((_QWORD *)this + 79) = 0;
                    }
                  }
                }
                else
                {
LABEL_615:
                  if (*(_QWORD *)&v289 >> 61)
                    std::__throw_bad_array_new_length[abi:ne180100]();
                  v290 = operator new(8 * *(_QWORD *)&v289);
                  v291 = (void *)*((_QWORD *)this + 78);
                  *((_QWORD *)this + 78) = v290;
                  if (v291)
                    operator delete(v291);
                  v292 = 0;
                  *((int8x8_t *)this + 79) = v289;
                  do
                    *(_QWORD *)(*((_QWORD *)this + 78) + 8 * v292++) = 0;
                  while (*(_QWORD *)&v289 != v292);
                  v293 = (_QWORD *)*v363;
                  if (*v363)
                  {
                    v294 = v293[1];
                    v295 = (uint8x8_t)vcnt_s8(v289);
                    v295.i16[0] = vaddlv_u8(v295);
                    if (v295.u32[0] > 1uLL)
                    {
                      if (v294 >= *(_QWORD *)&v289)
                        v294 %= *(_QWORD *)&v289;
                    }
                    else
                    {
                      v294 &= *(_QWORD *)&v289 - 1;
                    }
                    *(_QWORD *)(*((_QWORD *)this + 78) + 8 * v294) = v363;
                    v299 = (_QWORD *)*v293;
                    if (*v293)
                    {
                      do
                      {
                        v300 = v299[1];
                        if (v295.u32[0] > 1uLL)
                        {
                          if (v300 >= *(_QWORD *)&v289)
                            v300 %= *(_QWORD *)&v289;
                        }
                        else
                        {
                          v300 &= *(_QWORD *)&v289 - 1;
                        }
                        if (v300 != v294)
                        {
                          v301 = *((_QWORD *)this + 78);
                          if (!*(_QWORD *)(v301 + 8 * v300))
                          {
                            *(_QWORD *)(v301 + 8 * v300) = v293;
                            goto LABEL_640;
                          }
                          *v293 = *v299;
                          *v299 = **(_QWORD **)(*((_QWORD *)this + 78) + 8 * v300);
                          **(_QWORD **)(*((_QWORD *)this + 78) + 8 * v300) = v299;
                          v299 = v293;
                        }
                        v300 = v294;
LABEL_640:
                        v293 = v299;
                        v299 = (_QWORD *)*v299;
                        v294 = v300;
                      }
                      while (v299);
                    }
                  }
                  v275 = (unint64_t)v289;
                }
                if ((v275 & (v275 - 1)) != 0)
                {
                  if (v275 <= v274)
                    v264 = v274 % v275;
                  else
                    v264 = v274;
                }
                else
                {
                  v264 = ((_DWORD)v275 - 1) & v274;
                }
              }
              v302 = *(std::vector<char>::pointer **)(*((_QWORD *)this + 78) + 8 * v264);
              v303 = v386.__begin_;
              if (v302)
              {
                *(_QWORD *)v386.__begin_ = *v302;
                goto LABEL_657;
              }
              *(_QWORD *)v386.__begin_ = *((_QWORD *)this + 80);
              *((_QWORD *)this + 80) = v303;
              *(_QWORD *)(*((_QWORD *)this + 78) + 8 * v264) = v363;
              if (*(_QWORD *)v303)
              {
                v304 = *(_QWORD *)(*(_QWORD *)v303 + 8);
                if ((v275 & (v275 - 1)) != 0)
                {
                  if (v304 >= v275)
                    v304 %= v275;
                }
                else
                {
                  v304 &= v275 - 1;
                }
                v302 = (std::vector<char>::pointer *)(*((_QWORD *)this + 78) + 8 * v304);
LABEL_657:
                *v302 = v303;
              }
              v386.__begin_ = 0;
              ++*((_QWORD *)this + 81);
              std::unique_ptr<std::__hash_node<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v386);
LABEL_659:
              v386.__begin_ = &buf[8];
              std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&v386);
              v262 = *v362;
              if (*v362)
                continue;
LABEL_670:
              v29 = 0;
            }
            else
            {
              v324 = AU::ReferenceSignalMixer::getLog(v263);
              if (os_log_type_enabled(v324, OS_LOG_TYPE_ERROR))
              {
                AU::ReferenceSignalMixer::OrientationToString((uint64_t)cf, *(int *)buf);
                v329 = v371;
                if (v371)
                {
                  *(_OWORD *)v372 = *(_OWORD *)cf;
                  v373 = v370;
                  cf[1] = 0;
                  v370 = 0;
                  cf[0] = 0;
                }
                else
                {
                  std::string::basic_string[abi:ne180100]<0>(v372, "???");
                }
                v330 = SHIBYTE(v373);
                v331 = (char *)v372[0];
                AU::ReferenceSignalMixer::Join(v367, *(const __CFString ***)&buf[8], *(const __CFString ***)&buf[16]);
                v332 = (char *)v372;
                if (v330 < 0)
                  v332 = v331;
                v333 = v367;
                if (v368 < 0)
                  v333 = (void **)v367[0];
                LODWORD(v386.__begin_) = 134218498;
                *(std::vector<char>::pointer *)((char *)&v386.__begin_ + 4) = (std::vector<char>::pointer)this;
                WORD2(v386.__end_) = 2080;
                *(std::vector<char>::pointer *)((char *)&v386.__end_ + 6) = v332;
                HIWORD(v386.__end_cap_.__value_) = 2080;
                v387 = v333;
                _os_log_error_impl(&dword_1B5ED0000, v324, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list maps orientation \"%s\" to multiple configurations: %s", (uint8_t *)&v386, 0x20u);
                if (v368 < 0)
                  operator delete(v367[0]);
                if (SHIBYTE(v373) < 0)
                  operator delete((void *)v372[0]);
                if (v329 && SHIBYTE(v370) < 0)
                  operator delete((void *)cf[0]);
              }
              v386.__begin_ = &buf[8];
              std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&v386);
LABEL_563:
              v364 = -10875;
LABEL_564:
              v29 = 1;
            }
            break;
          }
LABEL_671:
          if (theArray)
            CFRelease(theArray);
LABEL_721:
          v326 = (std::__shared_weak_count *)*((_QWORD *)&v375 + 1);
          if (*((_QWORD *)&v375 + 1))
          {
            v327 = (unint64_t *)(*((_QWORD *)&v375 + 1) + 8);
            do
              v328 = __ldaxr(v327);
            while (__stlxr(v328 - 1, v327));
            if (!v328)
            {
              ((void (*)(std::__shared_weak_count *))v326->__on_zero_shared)(v326);
              std::__shared_weak_count::__release_weak(v326);
            }
          }
          if (v376)
            CFRelease(v376);
LABEL_281:
          if (v377)
            CFRelease(v377);
          v14 = (const __CFDictionary *)v378;
          if (v378)
LABEL_284:
            CFRelease(v14);
          if (v29 && v29 != 6)
            goto LABEL_751;
          v12 = (v366 + 1);
          v10 = v379;
          ++v366;
          if (!v379)
          {
            v345 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v345, "Could not construct");
          }
        }
      }
      CFRelease(v10);
    }
    buf[0] = 0;
    buf[8] = 0;
    v379 = 0;
    v334 = (AU::ReferenceSignalMixer *)std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
    v335 = AU::ReferenceSignalMixer::getLog(v334);
    if (os_log_type_enabled(v335, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = this;
      v338 = "[%p] AUReferenceSignal's property list has invalid \"Configurations\" value";
      v339 = v335;
      v340 = 12;
      goto LABEL_758;
    }
LABEL_748:
    v336 = 4294956421;
    v29 = 1;
LABEL_752:
    if (v379)
      CFRelease(v379);
  }
  else
  {
    v342 = AU::ReferenceSignalMixer::getLog(v7);
    if (os_log_type_enabled(v342, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = this;
      _os_log_error_impl(&dword_1B5ED0000, v342, OS_LOG_TYPE_ERROR, "[%p] AUReferenceSignal's property list has no \"Configurations\" key", buf, 0xCu);
    }
    v336 = 4294956421;
    v29 = 1;
  }
  std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>>>::~__hash_table((uint64_t)&__p);
  std::__hash_table<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<applesauce::CF::StringRef>,std::equal_to<applesauce::CF::StringRef>,true>,std::__unordered_map_equal<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<applesauce::CF::StringRef>,std::hash<applesauce::CF::StringRef>,true>,std::allocator<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table((uint64_t)&v383);
  if (!v29)
  {
LABEL_755:
    v336 = 0;
    *((_QWORD *)this + 83) = (char *)this + 616;
    ++*((_DWORD *)this + 152);
  }
  return v336;
}

void sub_1B614E604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,const void *a38,__int16 a39,uint64_t a40,const void *a41,const void *a42,const void *a43,const void *a44,__int16 a45)
{
  uint64_t v45;

  a31 = a22;
  std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&a31);
  applesauce::CF::ArrayRef::~ArrayRef(&a38);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)&a39);
  applesauce::CF::ArrayRef::~ArrayRef(&a41);
  applesauce::CF::StringRef::~StringRef(&a42);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a43);
  applesauce::CF::ArrayRef::~ArrayRef(&a44);
  std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>>>::~__hash_table((uint64_t)&a45);
  std::__hash_table<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<applesauce::CF::StringRef>,std::equal_to<applesauce::CF::StringRef>,true>,std::__unordered_map_equal<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<applesauce::CF::StringRef>,std::hash<applesauce::CF::StringRef>,true>,std::allocator<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table(v45 - 224);
  _Unwind_Resume(a1);
}

void AUReferenceSignalMixer::Cleanup(AUReferenceSignalMixer *this)
{
  uint64_t v2;
  uint64_t i;

  if (*((_QWORD *)this + 81))
  {
    std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::__deallocate_node(*((_QWORD **)this + 80));
    *((_QWORD *)this + 80) = 0;
    v2 = *((_QWORD *)this + 79);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*((_QWORD *)this + 78) + 8 * i) = 0;
    }
    *((_QWORD *)this + 81) = 0;
  }
}

uint64_t AUReferenceSignalMixer::GetPropertyInfo(AUReferenceSignalMixer *this, int a2, int a3, int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  char v8;

  if (a2 == 1667655524)
  {
    if (!a3)
    {
      if (!a4)
      {
        result = 0;
        *a5 = 8;
        *a6 = *((_BYTE *)this + 17) ^ 1;
        return result;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  if (a2 == 3700)
  {
    if (!a3)
    {
      if (!a4)
      {
        result = 0;
        v8 = *((_BYTE *)this + 17) ^ 1;
        goto LABEL_16;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  if (a2 != 21)
    return 4294956417;
  if (a3)
    return 4294956430;
  if (a4)
    return 4294956419;
  result = 0;
  v8 = 1;
LABEL_16:
  *a6 = v8;
  *a5 = 4;
  return result;
}

uint64_t AUReferenceSignalMixer::GetProperty(AUReferenceSignalMixer *this, int a2, int a3, int a4, _DWORD *a5)
{
  uint64_t result;
  int v8;
  uint64_t v9;

  if (a2 != 1667655524)
  {
    if (a2 == 3700)
    {
      if (!a3)
      {
        if (!a4)
        {
          result = 0;
          v8 = *((unsigned __int8 *)this + 376);
          goto LABEL_18;
        }
        return 4294956419;
      }
    }
    else
    {
      if (a2 != 21)
        return 4294956417;
      if (!a3)
      {
        if (!a4)
        {
          result = 0;
          v8 = *((unsigned __int8 *)this + 528);
LABEL_18:
          *a5 = v8;
          return result;
        }
        return 4294956419;
      }
    }
    return 4294956430;
  }
  if (a3)
    return 4294956430;
  if (a4)
    return 4294956419;
  v9 = *((_QWORD *)this + 84);
  if (v9)
    CFRetain(*((CFTypeRef *)this + 84));
  result = 0;
  *(_QWORD *)a5 = v9;
  return result;
}

uint64_t AUReferenceSignalMixer::SetProperty(AUReferenceSignalMixer *this, int a2, int a3, int a4, CFTypeRef *a5)
{
  uint64_t result;
  CFTypeRef v7;
  CFTypeID v8;

  if (a2 != 1667655524)
  {
    if (a2 == 3700)
    {
      if (!a3)
      {
        if (!a4)
        {
          result = 0;
          *((_BYTE *)this + 376) = a5 != 0;
          return result;
        }
        return 4294956419;
      }
    }
    else
    {
      if (a2 != 21)
        return 4294956417;
      if (!a3)
      {
        if (!a4)
        {
          result = 0;
          *((_BYTE *)this + 528) = *(_DWORD *)a5 != 0;
          return result;
        }
        return 4294956419;
      }
    }
    return 4294956430;
  }
  if (a3)
    return 4294956430;
  if (a4)
    return 4294956419;
  if (*((_BYTE *)this + 17))
    return 4294956447;
  v7 = *a5;
  if (*a5)
  {
    CFRetain(*a5);
    v8 = CFGetTypeID(v7);
    if (v8 != CFDictionaryGetTypeID())
    {
      CFRelease(v7);
      v7 = 0;
    }
  }
  result = *((_QWORD *)this + 84);
  *((_QWORD *)this + 84) = v7;
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 0;
  }
  return result;
}

uint64_t AUReferenceSignalMixer::GetParameter(AUReferenceSignalMixer *this, unsigned int a2, unsigned int a3, unsigned int a4, float *a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  float Parameter;
  uint64_t result;

  if (a2)
  {
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    Parameter = ausdk::AUElement::GetParameter(Element, a2);
LABEL_3:
    result = 0;
    *a5 = Parameter;
    return result;
  }
  if (a3)
    return 4294956430;
  if (!a4)
  {
    Parameter = AUReferenceSignalMixer::GetParameter((uint64_t)this);
    goto LABEL_3;
  }
  return 4294956419;
}

uint64_t AUReferenceSignalMixer::SetParameter(AUReferenceSignalMixer *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;

  if (a2)
  {
    Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
    ausdk::AUElement::SetParameter(Element, a2, a5, 0);
    return 0;
  }
  if (a3)
    return 4294956430;
  if (!a4)
  {
    AUReferenceSignalMixer::SetParameter((uint64_t)this, a5);
    return 0;
  }
  return 4294956419;
}

uint64_t AUReferenceSignalMixer::CanScheduleParameters(AUReferenceSignalMixer *this)
{
  return 0;
}

uint64_t AUReferenceSignalMixer::ProcessMultipleBufferLists(int8x8_t *this, unsigned int *a2, uint64_t a3, int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7)
{
  __int32 v12;
  float Parameter;
  int8x8_t v14;
  unint64_t v15;
  uint8x8_t v16;
  unint64_t v17;
  int8x8_t **v18;
  int8x8_t *i;
  unint64_t v20;

  if (a4 != 1 || a6 != 1 || (*a5)->mNumberBuffers != this[66].i32[1] || (*a7)->mNumberBuffers != this[71].i32[0])
    return 4294956428;
  if (this[66].i8[0])
  {
    this[83] = (int8x8_t)&this[77];
  }
  else
  {
    v12 = this[76].i32[0];
    if (v12 != this[76].i32[1])
    {
      Parameter = AUReferenceSignalMixer::GetParameter((uint64_t)this);
      v14 = this[79];
      if (v14)
      {
        v15 = Parameter;
        v16 = (uint8x8_t)vcnt_s8(v14);
        v16.i16[0] = vaddlv_u8(v16);
        if (v16.u32[0] > 1uLL)
        {
          v17 = v15;
          if (*(_QWORD *)&v14 <= v15)
            v17 = v15 % *(_QWORD *)&v14;
        }
        else
        {
          v17 = (v14.i32[0] - 1) & v15;
        }
        v18 = *(int8x8_t ***)(*(_QWORD *)&this[78] + 8 * v17);
        if (v18)
        {
          for (i = *v18; i; i = (int8x8_t *)*i)
          {
            v20 = (unint64_t)i[1];
            if (v20 == v15)
            {
              if (i[2].i32[0] == (_DWORD)v15)
              {
                this[83] = i[3];
                break;
              }
            }
            else
            {
              if (v16.u32[0] > 1uLL)
              {
                if (v20 >= *(_QWORD *)&v14)
                  v20 %= *(_QWORD *)&v14;
              }
              else
              {
                v20 &= *(_QWORD *)&v14 - 1;
              }
              if (v20 != v17)
                break;
            }
          }
        }
      }
      this[76].i32[1] = v12;
    }
  }
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)&this[83] + 16))(*(_QWORD *)&this[83], *a5, *a7, a3);
}

uint64_t AUReferenceSignalMixer::GetParameterList(AUReferenceSignalMixer *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;

  if (a2)
    return 4294956430;
  if (a3)
    *a3 = 0;
  result = 0;
  *a4 = 1;
  return result;
}

double AUReferenceSignalMixer::GetParameterInfo(AUReferenceSignalMixer *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  double result;
  AudioUnitParameterOptions v6;

  if (!a3 && !a2)
  {
    buffer->unitName = 0;
    buffer->cfNameString = CFSTR("Orientation");
    buffer->flags = 0x8000000;
    CFStringGetCString(CFSTR("Orientation"), buffer->name, 52, 0x8000100u);
    buffer->unit = kAudioUnitParameterUnit_Indexed;
    result = 8192.0;
    *(_QWORD *)&buffer->minValue = 0x40C0000000000000;
    v6 = buffer->flags | 0xC0002000;
    buffer->defaultValue = 1.0;
    buffer->flags = v6;
  }
  return result;
}

uint64_t AUReferenceSignalMixer::GetParameterValueStrings(AUReferenceSignalMixer *this, int a2, int a3, const __CFArray **a4)
{
  _QWORD v5[2];
  _OWORD v6[3];
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a3)
    return 4294956417;
  if (a2)
    return 4294956430;
  v6[0] = xmmword_1E69C8C80;
  v6[1] = *(_OWORD *)&off_1E69C8C90;
  v6[2] = xmmword_1E69C8CA0;
  v7 = "Face down";
  v5[0] = v6;
  v5[1] = 7;
  if (a4)
    *a4 = applesauce::CF::details::make_CFArrayRef<char const*>((uint64_t)v5);
  return 0;
}

double ausdk::AUBase::GetTailTime(ausdk::AUBase *this)
{
  return 0.0;
}

uint64_t AUReferenceSignalMixer::SupportsTail(AUReferenceSignalMixer *this)
{
  return 1;
}

BOOL AUReferenceSignalMixer::StreamFormatWritable(AUReferenceSignalMixer *this, int a2, int a3)
{
  BOOL v3;

  if (a3)
    v3 = 1;
  else
    v3 = (a2 - 1) >= 2;
  return !v3 && *((_BYTE *)this + 17) == 0;
}

uint64_t AUReferenceSignalMixer::SupportedNumChannels(AUReferenceSignalMixer *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUReferenceSignalMixer::SupportedNumChannels(AUChannelInfo const**)::sChannels;
  return 1;
}

uint64_t AUReferenceSignalMixer::GetAudioChannelLayout(AUReferenceSignalMixer *this, int a2, int a3, AudioChannelLayout *__dst, BOOL *a5)
{
  _BYTE *v6;
  _BYTE *v7;

  *a5 = *((_BYTE *)this + 17) ^ 1;
  if (a2 != 2)
  {
    if (a2 != 1)
      return 0;
    if (!a3)
    {
      if (*((_BYTE *)this + 560))
      {
        v6 = (_BYTE *)*((_QWORD *)this + 68);
        v7 = (_BYTE *)*((_QWORD *)this + 67);
        if (__dst)
        {
          if (v6 != v7)
          {
            memcpy(__dst, v7, v6 - v7);
            v6 = (_BYTE *)*((_QWORD *)this + 68);
            v7 = (_BYTE *)*((_QWORD *)this + 67);
          }
        }
        return ((_DWORD)v6 - (_DWORD)v7);
      }
      return 0;
    }
    return 4294956419;
  }
  if (a3)
    return 4294956419;
  if (*((_BYTE *)this + 600))
  {
    v6 = (_BYTE *)*((_QWORD *)this + 73);
    v7 = (_BYTE *)*((_QWORD *)this + 72);
    if (__dst && v6 != v7)
    {
      memcpy(__dst, v7, v6 - v7);
      v6 = (_BYTE *)*((_QWORD *)this + 73);
      v7 = (_BYTE *)*((_QWORD *)this + 72);
    }
    return ((_DWORD)v6 - (_DWORD)v7);
  }
  return 0;
}

uint64_t AUReferenceSignalMixer::SetAudioChannelLayout(AUReferenceSignalMixer *this, int a2, int a3, const AudioChannelLayout *a4)
{
  uint64_t v4;
  UInt32 mNumberChannelDescriptions;
  int v10;
  __int32 v11;
  int v12;
  __int32 v13;
  uint8x8_t v14;
  char *v15;
  uint8x8_t v16;
  std::vector<char> v18;

  if (*((_BYTE *)this + 17))
    return 4294956447;
  mNumberChannelDescriptions = a4->mNumberChannelDescriptions;
  if (mNumberChannelDescriptions <= 1)
    mNumberChannelDescriptions = 1;
  std::vector<char>::vector(&v18, 20 * mNumberChannelDescriptions + 12);
  memcpy(v18.__begin_, a4, 20 * a4->mNumberChannelDescriptions + 12);
  if (a2 != 2)
  {
    if (a2 != 1)
    {
      v4 = 4294956430;
      goto LABEL_27;
    }
    if (!a3)
    {
      v10 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUReferenceSignalMixer *)((char *)this + 80), 0) + 108);
      if (*(_DWORD *)v18.__begin_ == 0x10000)
      {
        v14 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)v18.__begin_ + 1));
        v14.i16[0] = vaddlv_u8(v14);
        v11 = v14.i32[0];
      }
      else if (*(_DWORD *)v18.__begin_)
      {
        v11 = (unsigned __int16)*(_DWORD *)v18.__begin_;
      }
      else
      {
        v11 = *((_DWORD *)v18.__begin_ + 2);
      }
      if (v10 == v11)
      {
        v15 = (char *)this + 536;
LABEL_25:
        std::optional<CA::ChannelLayout>::operator=[abi:ne180100]<CA::ChannelLayout const,void>((uint64_t)v15, &v18.__begin_);
        v4 = 0;
        goto LABEL_27;
      }
      goto LABEL_26;
    }
LABEL_12:
    v4 = 4294956419;
    goto LABEL_27;
  }
  if (a3)
    goto LABEL_12;
  v12 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUReferenceSignalMixer *)((char *)this + 128), 0) + 108);
  if (*(_DWORD *)v18.__begin_ == 0x10000)
  {
    v16 = (uint8x8_t)vcnt_s8((int8x8_t)*((unsigned int *)v18.__begin_ + 1));
    v16.i16[0] = vaddlv_u8(v16);
    v13 = v16.i32[0];
  }
  else if (*(_DWORD *)v18.__begin_)
  {
    v13 = (unsigned __int16)*(_DWORD *)v18.__begin_;
  }
  else
  {
    v13 = *((_DWORD *)v18.__begin_ + 2);
  }
  if (v12 == v13)
  {
    v15 = (char *)this + 576;
    goto LABEL_25;
  }
LABEL_26:
  v4 = 4294956445;
LABEL_27:
  if (v18.__begin_)
  {
    v18.__end_ = v18.__begin_;
    operator delete(v18.__begin_);
  }
  return v4;
}

void sub_1B614F40C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t AUReferenceSignalMixer::RemoveAudioChannelLayout(AUReferenceSignalMixer *this, int a2, int a3)
{
  uint64_t v3;
  _BYTE *v5;
  void *v6;

  if (!*((_BYTE *)this + 17))
  {
    if (a2 == 2)
    {
      if (a3)
        return 4294956419;
      if (*((_BYTE *)this + 600))
      {
        v5 = (char *)this + 600;
        v6 = (void *)*((_QWORD *)this + 72);
        if (!v6)
        {
          v3 = 4294956430;
          goto LABEL_20;
        }
        *((_QWORD *)this + 73) = v6;
        v3 = 4294956430;
        goto LABEL_15;
      }
    }
    else if (a2 == 1)
    {
      if (!a3)
      {
        if (!*((_BYTE *)this + 560))
          return 0;
        v5 = (char *)this + 560;
        v6 = (void *)*((_QWORD *)this + 67);
        if (!v6)
        {
          v3 = 0;
          goto LABEL_20;
        }
        v3 = 0;
        *((_QWORD *)this + 68) = v6;
LABEL_15:
        operator delete(v6);
LABEL_20:
        *v5 = 0;
        return v3;
      }
      return 4294956419;
    }
    return 4294956430;
  }
  return 4294956447;
}

uint64_t std::optional<CA::ChannelLayout>::operator=[abi:ne180100]<CA::ChannelLayout const,void>(uint64_t a1, char **a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    if ((char **)a1 != a2)
      std::vector<char>::__assign_with_size[abi:ne180100]<char *,char *>((_QWORD *)a1, *a2, a2[1], a2[1] - *a2);
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    std::vector<char>::__init_with_size[abi:ne180100]<char *,char *>((_QWORD *)a1, *a2, (uint64_t)a2[1], a2[1] - *a2);
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

_QWORD *std::vector<char>::__assign_with_size[abi:ne180100]<char *,char *>(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  size_t v11;
  _BYTE *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;

  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v10 = 2 * v8;
    if (2 * v8 <= a4)
      v10 = a4;
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](v7, v11);
    v9 = (char *)v7[1];
    goto LABEL_17;
  }
  v12 = (_BYTE *)result[1];
  v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    v16 = a3 - __src;
    if (v16)
      result = memmove(v9, __src, v16);
    v15 = &v9[v16];
    goto LABEL_20;
  }
  v14 = &__src[v13];
  if (v12 != v9)
  {
    result = memmove((void *)*result, __src, v13);
    v9 = (char *)v7[1];
  }
  if (a3 != v14)
    result = memmove(v9, v14, a3 - v14);
  v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<char const*>(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  char **v4;
  uint64_t v5;
  applesauce::CF::StringRef *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  applesauce::CF::StringRef *v11;
  applesauce::CF::StringRef *v12;
  applesauce::CF::StringRef *v13;
  uint64_t v14;
  int64x2_t v15;
  unint64_t v16;
  applesauce::CF::StringRef *v17;
  applesauce::CF::StringRef *v18;
  _QWORD *v19;
  uint64_t v20;
  CFArrayRef CFArray;
  applesauce::CF::StringRef *v23[2];
  unint64_t v24;
  void *__p;
  int64x2_t v26;
  unint64_t v27;
  unint64_t *v28;

  v2 = *(_QWORD *)(a1 + 8);
  v23[0] = 0;
  v23[1] = 0;
  v24 = 0;
  std::vector<applesauce::CF::StringRef>::reserve(v23, v2);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    v4 = *(char ***)a1;
    v5 = *(_QWORD *)a1 + 8 * v3;
    v6 = v23[1];
    do
    {
      if ((unint64_t)v6 >= v24)
      {
        v7 = (v6 - v23[0]) >> 3;
        if ((unint64_t)(v7 + 1) >> 61)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v8 = (uint64_t)(v24 - (unint64_t)v23[0]) >> 2;
        if (v8 <= v7 + 1)
          v8 = v7 + 1;
        if (v24 - (unint64_t)v23[0] >= 0x7FFFFFFFFFFFFFF8)
          v9 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v9 = v8;
        v28 = &v24;
        if (v9)
          v9 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v9);
        else
          v10 = 0;
        __p = (void *)v9;
        v26.i64[0] = v9 + 8 * v7;
        v26.i64[1] = v26.i64[0];
        v27 = v9 + 8 * v10;
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)v26.i64[0], *v4);
        v11 = (applesauce::CF::StringRef *)v26.i64[0];
        v6 = (applesauce::CF::StringRef *)(v26.i64[1] + 8);
        v26.i64[1] += 8;
        v13 = v23[0];
        v12 = v23[1];
        if (v23[1] == v23[0])
        {
          v15 = vdupq_n_s64((unint64_t)v23[1]);
        }
        else
        {
          do
          {
            v14 = *((_QWORD *)v12 - 1);
            v12 = (applesauce::CF::StringRef *)((char *)v12 - 8);
            *((_QWORD *)v11 - 1) = v14;
            v11 = (applesauce::CF::StringRef *)((char *)v11 - 8);
            *(_QWORD *)v12 = 0;
          }
          while (v12 != v13);
          v15 = *(int64x2_t *)v23;
          v6 = (applesauce::CF::StringRef *)v26.i64[1];
        }
        v23[0] = v11;
        v23[1] = v6;
        v26 = v15;
        v16 = v24;
        v24 = v27;
        v27 = v16;
        __p = (void *)v15.i64[0];
        std::__split_buffer<applesauce::CF::StringRef>::~__split_buffer((uint64_t)&__p);
      }
      else
      {
        applesauce::CF::StringRef::StringRef(v6, *v4);
        v6 = (applesauce::CF::StringRef *)((char *)v6 + 8);
      }
      v23[1] = v6;
      ++v4;
    }
    while (v4 != (char **)v5);
  }
  else
  {
    v6 = v23[1];
  }
  std::vector<void const*>::vector(&__p, (v6 - v23[0]) >> 3);
  v17 = v23[0];
  v18 = v23[1];
  if (v23[0] != v23[1])
  {
    v19 = __p;
    do
    {
      v20 = *(_QWORD *)v17;
      v17 = (applesauce::CF::StringRef *)((char *)v17 + 8);
      *v19++ = v20;
    }
    while (v17 != v18);
  }
  CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)&__p);
  if (__p)
  {
    v26.i64[0] = (uint64_t)__p;
    operator delete(__p);
  }
  __p = v23;
  std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  return CFArray;
}

void sub_1B614F824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13, void *__p, uint64_t a15)
{
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  a13 = &a9;
  std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<applesauce::CF::StringRef>::reserve(_QWORD *result, unint64_t a2)
{
  char **v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  int64x2_t v10;
  char *v11;
  uint64_t v12;
  int64x2_t v13;
  char *v14;
  _QWORD *v15;

  if (a2 > (uint64_t)(result[2] - *result) >> 3)
  {
    if (a2 >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v2 = (char **)result;
    v3 = result[1] - *result;
    v15 = result + 2;
    v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(a2);
    v7 = *v2;
    v6 = v2[1];
    if (v6 == *v2)
    {
      v10 = vdupq_n_s64((unint64_t)v6);
      v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
      do
      {
        v9 = *((_QWORD *)v6 - 1);
        v6 -= 8;
        *((_QWORD *)v8 - 1) = v9;
        v8 -= 8;
        *(_QWORD *)v6 = 0;
      }
      while (v6 != v7);
      v10 = *(int64x2_t *)v2;
    }
    *v2 = v8;
    v2[1] = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    v13 = v10;
    v11 = v2[2];
    v2[2] = &v4[8 * v5];
    v14 = v11;
    v12 = v10.i64[0];
    return (_QWORD *)std::__split_buffer<applesauce::CF::StringRef>::~__split_buffer((uint64_t)&v12);
  }
  return result;
}

void std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  const void **v2;
  const void **v4;
  void *v5;

  v1 = *a1;
  v2 = (const void **)**a1;
  if (v2)
  {
    v4 = (const void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::__destroy_at[abi:ne180100]<applesauce::CF::StringRef,0>(--v4);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__split_buffer<applesauce::CF::StringRef>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::StringRef,0>((const void **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

float AUReferenceSignalMixer::GetParameter(uint64_t a1)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 72);
  if (v2)
  {
    v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v5 = a1 + 48;
    v4 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(v5 + 8) == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  return ausdk::AUElement::GetParameter(v3, 0);
}

void AUReferenceSignalMixer::SetParameter(uint64_t a1, float a2)
{
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  uint64_t v7;
  ausdk::AUElement *v8;
  ausdk::AUElement **v9;

  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
  {
    v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  }
  else
  {
    v6 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v6)
      v5 = 0;
    else
      v5 = *v6;
  }
  if (ausdk::AUElement::GetParameter(v5, 0) != a2)
  {
    v7 = *(_QWORD *)(a1 + 72);
    if (v7)
    {
      v8 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
    }
    else
    {
      v9 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v9)
        v8 = 0;
      else
        v8 = *v9;
    }
    ausdk::AUElement::SetParameter(v8, 0, a2, 0);
    ++*(_DWORD *)(a1 + 608);
  }
}

void std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::__deallocate_node(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = (_QWORD *)*v1;
      std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)(v1 + 3));
      operator delete(v1);
      v1 = v2;
    }
    while (v2);
  }
}

uint64_t AU::ReferenceSignalMixer::getLog(AU::ReferenceSignalMixer *this)
{
  unsigned __int8 v1;
  _QWORD *v2;
  int v4;

  v2 = &unk_1EF134000;
  if ((v1 & 1) == 0)
  {
    v2 = (_QWORD *)&unk_1EF134000;
    if (v4)
    {
      AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
      v2 = (_QWORD *)&unk_1EF134000;
    }
  }
  return v2[451];
}

uint64_t applesauce::CF::at_or<applesauce::CF::DictionaryRef>(_QWORD *a1, CFArrayRef theArray, unint64_t a3, _QWORD *a4)
{
  const void *ValueAtIndex;
  const void *v9;
  CFTypeID v10;
  const void *v12;
  char v13;

  if (CFArrayGetCount(theArray) <= a3)
    goto LABEL_6;
  ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3);
  v9 = ValueAtIndex;
  if (!ValueAtIndex)
    goto LABEL_6;
  CFRetain(ValueAtIndex);
  v10 = CFGetTypeID(v9);
  if (v10 != CFDictionaryGetTypeID())
  {
    CFRelease(v9);
LABEL_6:
    LOBYTE(v12) = 0;
    v13 = 0;
    *a1 = *a4;
    *a4 = 0;
    return std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v12);
  }
  v12 = v9;
  v13 = 1;
  CFRetain(v9);
  *a1 = v9;
  return std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v12);
}

BOOL applesauce::CF::details::has_key<char const(&)[5]>(const __CFDictionary *a1, char *a2)
{
  int v3;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  v3 = CFDictionaryContainsKey(a1, key);
  if (key)
    CFRelease(key);
  return v3 != 0;
}

void sub_1B614FCD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL applesauce::CF::details::has_key<applesauce::CF::StringRef>(CFDictionaryRef theDict, const void *a2)
{
  _BOOL8 result;

  result = 0;
  if (theDict)
  {
    if (a2)
      return CFDictionaryContainsKey(theDict, a2) != 0;
  }
  return result;
}

uint64_t applesauce::CF::at_or<applesauce::CF::ArrayRef,applesauce::CF::StringRef>(const __CFDictionary **a1, const __CFDictionary *a2, const void **a3, const __CFDictionary **a4)
{
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  CFTypeID v8;
  const __CFDictionary *v10;
  char v11;

  v6 = applesauce::CF::details::at_key<applesauce::CF::StringRef>(a2, a3);
  if (!v6)
    goto LABEL_5;
  v7 = v6;
  CFRetain(v6);
  v8 = CFGetTypeID(v7);
  if (v8 != CFArrayGetTypeID())
  {
    CFRelease(v7);
LABEL_5:
    LOBYTE(v10) = 0;
    v11 = 0;
    *a1 = *a4;
    *a4 = 0;
    return std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v10);
  }
  v10 = v7;
  v11 = 1;
  CFRetain(v7);
  *a1 = v7;
  return std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v10);
}

std::vector<char> *AU::ReferenceSignalMixer::MakeDefaultChannelLayout(std::vector<char> *a1, int a2)
{
  std::vector<char> *result;
  _DWORD *begin;
  int v4;
  int v5;
  std::vector<char>::value_type __x;
  std::vector<char>::value_type v7;
  std::vector<char>::value_type v8;

  if (a2 == 2)
  {
    v7 = 0;
    result = std::vector<char>::vector(a1, 0x20uLL, &v7);
    begin = result->__begin_;
    v4 = 6619138;
  }
  else
  {
    if (a2 != 1)
    {
      v5 = a2 | 0x930000;
      v8 = 0;
      result = std::vector<char>::vector(a1, 0x20uLL, &v8);
      begin = result->__begin_;
      *(_DWORD *)result->__begin_ = v5;
      goto LABEL_7;
    }
    __x = 0;
    result = std::vector<char>::vector(a1, 0x20uLL, &__x);
    begin = result->__begin_;
    v4 = 6553601;
  }
  *begin = v4;
LABEL_7:
  begin[1] = 0;
  begin[2] = 0;
  return result;
}

__n128 std::optional<CA::ChannelLayout>::value_or[abi:ne180100]<CA::ChannelLayout>(__n128 *a1, uint64_t a2, __n128 *a3)
{
  __n128 result;

  if (*(_BYTE *)(a2 + 24))
  {
    a1->n128_u64[0] = 0;
    a1->n128_u64[1] = 0;
    a1[1].n128_u64[0] = 0;
    std::vector<char>::__init_with_size[abi:ne180100]<char *,char *>(a1, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  }
  else
  {
    result = *a3;
    *a1 = *a3;
    a1[1].n128_u64[0] = a3[1].n128_u64[0];
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    a3->n128_u64[0] = 0;
  }
  return result;
}

uint64_t applesauce::CF::at_or<applesauce::CF::DataRef>(_QWORD *a1, CFArrayRef theArray, unint64_t a3, _QWORD *a4)
{
  const void *ValueAtIndex;
  const void *v9;
  CFTypeID v10;
  const void *v12;
  char v13;

  if (CFArrayGetCount(theArray) <= a3)
    goto LABEL_6;
  ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3);
  v9 = ValueAtIndex;
  if (!ValueAtIndex)
    goto LABEL_6;
  CFRetain(ValueAtIndex);
  v10 = CFGetTypeID(v9);
  if (v10 != CFDataGetTypeID())
  {
    CFRelease(v9);
LABEL_6:
    LOBYTE(v12) = 0;
    v13 = 0;
    *a1 = *a4;
    *a4 = 0;
    return std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v12);
  }
  v12 = v9;
  v13 = 1;
  CFRetain(v9);
  *a1 = v9;
  return std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v12);
}

const __CFDictionary *applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,applesauce::CF::StringRef>(const __CFDictionary *a1, const void **a2)
{
  const __CFDictionary *result;

  result = applesauce::CF::details::at_key<applesauce::CF::StringRef>(a1, a2);
  if (result)
    return (const __CFDictionary *)applesauce::CF::convert_as<unsigned int,0>(result);
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[6]>(const __CFDictionary *a1, char *a2)
{
  int v3;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  v3 = CFDictionaryContainsKey(a1, key);
  if (key)
    CFRelease(key);
  return v3 != 0;
}

void sub_1B614FFEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[5]>(const __CFDictionary *a1, char *a2)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[5]>(a1, a2);
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[13]>(const __CFDictionary *a1, char *a2)
{
  int v3;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  v3 = CFDictionaryContainsKey(a1, key);
  if (key)
    CFRelease(key);
  return v3 != 0;
}

void sub_1B6150074(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<applesauce::CF::StringRef>::__init_with_size[abi:ne180100]<applesauce::CF::StringRef*,applesauce::CF::StringRef*>(_QWORD *result, CFTypeRef *a2, CFTypeRef *a3, unint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  CFTypeRef v9;

  if (a4)
  {
    if (a4 >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v6 = result;
    result = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(a4);
    v7 = result;
    *v6 = result;
    v6[1] = result;
    v6[2] = &result[v8];
    while (a2 != a3)
    {
      v9 = *a2;
      if (*a2)
        result = CFRetain(*a2);
      *v7++ = v9;
      ++a2;
    }
    v6[1] = v7;
  }
  return result;
}

void sub_1B6150120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

double AU::ReferenceSignalMixer::OrientationToString(uint64_t a1, int a2)
{
  uint64_t v3;
  char *v4;
  size_t v5;
  const void *v6;
  __int128 *p_dst;
  uint64_t v8;
  uint64_t v9;
  double result;
  __int128 __dst;
  unint64_t v12;

  v3 = 0;
  while (1)
  {
    v4 = (char *)&AU::ReferenceSignalMixer::gOrientationStringMap + v3;
    if (*(_DWORD *)((char *)&AU::ReferenceSignalMixer::gOrientationStringMap + v3) == a2)
      break;
    v3 += 24;
    if (v3 == 168)
    {
      *(_BYTE *)a1 = 0;
      *(_BYTE *)(a1 + 24) = 0;
      return result;
    }
  }
  v5 = *((_QWORD *)v4 + 2);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = (const void *)*((_QWORD *)v4 + 1);
  if (v5 >= 0x17)
  {
    v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v8 = v5 | 7;
    v9 = v8 + 1;
    p_dst = (__int128 *)operator new(v8 + 1);
    *((_QWORD *)&__dst + 1) = v5;
    v12 = v9 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
  }
  else
  {
    HIBYTE(v12) = *((_QWORD *)v4 + 2);
    p_dst = &__dst;
    if (!v5)
      goto LABEL_13;
  }
  memmove(p_dst, v6, v5);
LABEL_13:
  *((_BYTE *)p_dst + v5) = 0;
  result = *(double *)&__dst;
  *(_OWORD *)a1 = __dst;
  *(_QWORD *)(a1 + 16) = v12;
  *(_BYTE *)(a1 + 24) = 1;
  return result;
}

void AU::ReferenceSignalMixer::Join(_QWORD *a1, const __CFString **a2, const __CFString **a3)
{
  _QWORD *v3;
  const __CFString **v5;
  std::string *v6;
  __int128 v7;
  void **v8;
  std::string::size_type v9;
  _BYTE *v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  std::runtime_error *exception;
  std::string v16;
  void *__p[2];
  int64_t v18;

  v3 = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 == a3)
  {
    LOBYTE(v11) = 0;
    v10 = (char *)a1 + 23;
  }
  else
  {
    v5 = a2;
    do
    {
      if (!*v5)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      applesauce::CF::convert_to<std::string,0>(*v5, (uint64_t)&v16);
      v6 = std::string::append(&v16, ", ", 2uLL);
      v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v18 = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      if (v18 >= 0)
        v8 = __p;
      else
        v8 = (void **)__p[0];
      if (v18 >= 0)
        v9 = HIBYTE(v18);
      else
        v9 = (std::string::size_type)__p[1];
      std::string::append((std::string *)v3, (const std::string::value_type *)v8, v9);
      if (SHIBYTE(v18) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v16.__r_.__value_.__l.__data_);
      ++v5;
    }
    while (v5 != a3);
    v10 = (char *)v3 + 23;
    v11 = *((char *)v3 + 23);
    if (v11 < 0)
    {
      v12 = (_QWORD *)*v3;
      v13 = v3[1] - 1;
      v3[1] = v13;
      goto LABEL_19;
    }
  }
  v13 = v11 - 1;
  *v10 = v13 & 0x7F;
  v12 = v3;
LABEL_19:
  *((_BYTE *)v12 + v13) = 0;
  if (*((char *)v3 + 23) < 0)
  {
    v14 = v3[1] - 1;
    v3[1] = v14;
    v3 = (_QWORD *)*v3;
  }
  else
  {
    v14 = *((unsigned __int8 *)v3 + 23) - 1;
    *v10 = v14 & 0x7F;
  }
  *((_BYTE *)v3 + v14) = 0;
}

void sub_1B61503AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;

  if (*(char *)(v21 + 23) < 0)
    operator delete(*(void **)v21);
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>>>::~__hash_table(uint64_t a1)
{
  char *v2;
  char *v3;
  void *v4;
  void **v6;

  v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = *(char **)v2;
      v6 = (void **)(v2 + 24);
      std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100](&v6);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<applesauce::CF::StringRef>,std::equal_to<applesauce::CF::StringRef>,true>,std::__unordered_map_equal<applesauce::CF::StringRef,std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<applesauce::CF::StringRef>,std::hash<applesauce::CF::StringRef>,true>,std::allocator<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table(uint64_t a1)
{
  CFTypeRef *v2;
  CFTypeRef *v3;
  void *v4;

  v2 = *(CFTypeRef **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (CFTypeRef *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<applesauce::CF::StringRef const,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,0>(v2 + 2);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::__destroy_at[abi:ne180100]<std::pair<applesauce::CF::StringRef const,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,0>(CFTypeRef *a1)
{
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  if (*a1)
    CFRelease(*a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)v1 + 24);
    operator delete(v1);
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::vector<applesauce::CF::StringRef>>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  void **v3;

  if (a1)
  {
    v3 = __p + 3;
    std::vector<applesauce::CF::StringRef>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  if (__p)
    operator delete(__p);
}

CFTypeID applesauce::CF::convert_as<std::string,0>(uint64_t a1, const __CFString *a2)
{
  CFTypeID TypeID;
  CFTypeID result;
  char v6;
  __int128 v7;
  uint64_t v8;

  TypeID = CFStringGetTypeID();
  result = CFGetTypeID(a2);
  if (TypeID == result)
  {
    result = (CFTypeID)applesauce::CF::details::CFString_get_value<false>((uint64_t)&v7, a2);
    *(_OWORD *)a1 = v7;
    *(_QWORD *)(a1 + 16) = v8;
    v6 = 1;
  }
  else
  {
    v6 = 0;
    *(_BYTE *)a1 = 0;
  }
  *(_BYTE *)(a1 + 24) = v6;
  return result;
}

_QWORD *applesauce::CF::details::CFString_get_value<false>(uint64_t a1, CFStringRef theString)
{
  char *CStringPtr;
  CFIndex Length;
  UInt8 *v7;
  CFIndex maxBufLen;
  CFRange v9;
  CFRange v10;

  CStringPtr = (char *)CFStringGetCStringPtr(theString, 0x8000100u);
  if (CStringPtr)
    return std::string::basic_string[abi:ne180100]<0>((_QWORD *)a1, CStringPtr);
  Length = CFStringGetLength(theString);
  maxBufLen = 0;
  v9.location = 0;
  v9.length = Length;
  CFStringGetBytes(theString, v9, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
  std::string::basic_string[abi:ne180100]((_QWORD *)a1, maxBufLen, 0);
  if (*(char *)(a1 + 23) >= 0)
    v7 = (UInt8 *)a1;
  else
    v7 = *(UInt8 **)a1;
  v10.location = 0;
  v10.length = Length;
  return (_QWORD *)CFStringGetBytes(theString, v10, 0x8000100u, 0, 0, v7, maxBufLen, &maxBufLen);
}

uint64_t std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  const void *v2;

  if (*(_BYTE *)(a1 + 8))
  {
    v2 = *(const void **)a1;
    if (*(_QWORD *)a1)
      CFRelease(v2);
  }
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<applesauce::CF::StringRef,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  CFTypeRef *v1;

  v1 = *(CFTypeRef **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<applesauce::CF::StringRef const,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,0>(v1 + 2);
    operator delete(v1);
  }
}

void std::vector<std::vector<float>>::resize(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD v27[2];
  char *v28;
  char *v29;
  uint64_t *v30;

  v5 = *a1;
  v6 = (_QWORD *)a1[1];
  v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v6 - *a1) >> 3);
  v8 = a2 - v7;
  if (a2 <= v7)
  {
    if (a2 < v7)
    {
      v21 = (_QWORD *)(v5 + 24 * a2);
      if (v6 != v21)
      {
        v22 = (_QWORD *)a1[1];
        do
        {
          v24 = (void *)*(v22 - 3);
          v22 -= 3;
          v23 = v24;
          if (v24)
          {
            *(v6 - 2) = v23;
            operator delete(v23);
          }
          v6 = v22;
        }
        while (v22 != v21);
      }
      a1[1] = (uint64_t)v21;
    }
  }
  else
  {
    v10 = (uint64_t)(a1 + 2);
    v11 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v11 - (uint64_t)v6) >> 3) >= v8)
    {
      v25 = &v6[3 * v8];
      v26 = 24 * a2 - 24 * v7;
      do
      {
        *v6 = 0;
        v6[1] = 0;
        v6[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v6, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
        v6 += 3;
        v26 -= 24;
      }
      while (v26);
      a1[1] = (uint64_t)v25;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v30 = a1 + 2;
      v12 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v5) >> 3);
      v13 = 2 * v12;
      if (2 * v12 <= a2)
        v13 = a2;
      if (v12 >= 0x555555555555555)
        v14 = 0xAAAAAAAAAAAAAAALL;
      else
        v14 = v13;
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::__fs::filesystem::path>>(v10, v14);
      v16 = &v15[24 * v7];
      v27[0] = v15;
      v27[1] = v16;
      v28 = v16;
      v29 = &v15[24 * v17];
      v18 = 3 * a2;
      v19 = &v15[24 * a2];
      v20 = 8 * v18 - 24 * v7;
      do
      {
        *(_QWORD *)v16 = 0;
        *((_QWORD *)v16 + 1) = 0;
        *((_QWORD *)v16 + 2) = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v16, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
        v16 += 24;
        v20 -= 24;
      }
      while (v20);
      v28 = v19;
      std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v27);
      std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v27);
    }
  }
}

void sub_1B6150924(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void AUReferenceSignalMixer::MatrixKernel::~MatrixKernel(AUReferenceSignalMixer::MatrixKernel *this)
{
  void **v1;

  v1 = (void **)((char *)this + 8);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  v2 = (void **)((char *)this + 8);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x1BCC95CEC](this, 0xA1C4030951706);
}

uint64_t AUReferenceSignalMixer::MatrixKernel::Mix(AUReferenceSignalMixer::MatrixKernel *this, const AudioBufferList *a2, AudioBufferList *a3, vDSP_Length __N)
{
  unint64_t v7;
  vDSP_Length v8;
  float *mData;
  unint64_t v10;
  char v11;
  uint64_t v12;
  const float *v13;
  float __A;
  float __B;

  if (a3->mNumberBuffers)
  {
    v7 = 0;
    v8 = __N;
    do
    {
      mData = (float *)a3->mBuffers[v7].mData;
      if (!a2->mNumberBuffers)
        goto LABEL_11;
      v10 = 0;
      v11 = 0;
      v12 = 16;
      do
      {
        v13 = *(const float **)((char *)&a2->mNumberBuffers + v12);
        __B = 0.0;
        __B = *(float *)(*(_QWORD *)(*((_QWORD *)this + 1) + 24 * v7) + 4 * v10);
        if (__B != 0.0)
        {
          if ((v11 & 1) != 0)
          {
            v11 = 1;
            vDSP_vsma(v13, 1, &__B, mData, 1, mData, 1, v8);
          }
          else
          {
            v11 = 1;
            vDSP_vsmul(v13, 1, &__B, mData, 1, v8);
          }
        }
        ++v10;
        v12 += 16;
      }
      while (v10 < a2->mNumberBuffers);
      if ((v11 & 1) == 0)
      {
LABEL_11:
        __A = 0.0;
        vDSP_vfill(&__A, mData, 1, v8);
      }
      ++v7;
    }
    while (v7 < a3->mNumberBuffers);
  }
  return 0;
}

void std::__shared_ptr_emplace<AUReferenceSignalMixer::MatrixKernel>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69C8DC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AUReferenceSignalMixer::MatrixKernel>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69C8DC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void std::__shared_ptr_emplace<AUReferenceSignalMixer::MatrixKernel>::__on_zero_shared(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 32);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

const void *applesauce::CF::details::at_key<char const(&)[14]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B6150BCC(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6150BB0);
}

void sub_1B6150D34(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::__deallocate_node(*(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void AUReferenceSignalMixer::BypassKernel::~BypassKernel(AUReferenceSignalMixer::BypassKernel *this)
{
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AUReferenceSignalMixer::BypassKernel::Mix(AUReferenceSignalMixer::BypassKernel *this, const AudioBufferList *a2, AudioBufferList *a3, unsigned int a4)
{
  unint64_t v6;
  size_t v7;
  uint64_t v8;
  UInt32 v9;

  if (a3->mNumberBuffers)
  {
    v6 = 0;
    v7 = 4 * a4;
    v8 = 16;
    do
    {
      v9 = a2->mNumberBuffers - 1;
      if (v9 >= v6)
        v9 = v6;
      memcpy(*(void **)((char *)&a3->mNumberBuffers + v8), a2->mBuffers[v9].mData, v7);
      ++v6;
      v8 += 16;
    }
    while (v6 < a3->mNumberBuffers);
  }
  return 0;
}

void std::__tree<std::__value_type<unsigned int,ProcessingChainInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,ProcessingChainInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,ProcessingChainInfo>>>::__emplace_unique_impl<std::pair<int,ProcessingChainInfo>>(uint64_t **a1, int *a2)
{
  _DWORD *v4;
  unsigned int v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t **v10;
  uint64_t *v11;
  uint64_t **v12;
  unsigned int v13;

  v4 = operator new(0xB8uLL);
  v5 = *a2;
  v4[7] = *a2;
  v6 = *(_OWORD *)(a2 + 29);
  *((_OWORD *)v4 + 8) = *(_OWORD *)(a2 + 25);
  *((_OWORD *)v4 + 9) = v6;
  *((_OWORD *)v4 + 10) = *(_OWORD *)(a2 + 33);
  v4[44] = a2[37];
  v7 = *(_OWORD *)(a2 + 13);
  *((_OWORD *)v4 + 4) = *(_OWORD *)(a2 + 9);
  *((_OWORD *)v4 + 5) = v7;
  v8 = *(_OWORD *)(a2 + 21);
  *((_OWORD *)v4 + 6) = *(_OWORD *)(a2 + 17);
  *((_OWORD *)v4 + 7) = v8;
  v9 = *(_OWORD *)(a2 + 5);
  *((_OWORD *)v4 + 2) = *(_OWORD *)(a2 + 1);
  *((_OWORD *)v4 + 3) = v9;
  v10 = a1 + 1;
  v11 = a1[1];
  if (v11)
  {
    while (1)
    {
      while (1)
      {
        v12 = (uint64_t **)v11;
        v13 = *((_DWORD *)v11 + 7);
        if (v5 >= v13)
          break;
        v11 = *v12;
        v10 = v12;
        if (!*v12)
          goto LABEL_9;
      }
      if (v13 >= v5)
        break;
      v11 = v12[1];
      if (!v11)
      {
        v10 = v12 + 1;
        goto LABEL_9;
      }
    }
    operator delete(v4);
  }
  else
  {
    v12 = a1 + 1;
LABEL_9:
    std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(a1, (uint64_t)v12, v10, (uint64_t *)v4);
  }
}

float32x4_t *RampGainMono(float32x4_t *result, float32x4_t *a2, int a3, float *a4, float a5, float32x4_t a6)
{
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t *v12;
  float32x4_t v13;
  unsigned int v14;
  float v15;

  a6.f32[0] = *a4;
  if (a3 >= 12)
  {
    v6 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 0);
    v7 = vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_1B66A06E0, a5), v6);
    v6.f32[0] = a5 * 4.0;
    a6 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0);
    v8 = *result;
    v9 = result[1];
    result += 2;
    v10 = vmulq_f32(v7, v8);
    v11 = vaddq_f32(a6, v7);
    a3 -= 8;
    do
    {
      v12 = a2;
      *a2++ = v10;
      v10 = vmulq_f32(v11, v9);
      v11 = vaddq_f32(a6, v11);
      v13 = *result++;
      v9 = v13;
      a3 -= 4;
    }
    while (a3 > 3);
    a6.i32[0] = vaddq_f32(a6, v11).u32[0];
    *a2 = v10;
    a2[1] = vmulq_f32(v11, v9);
    a2 = v12 + 3;
  }
  if (a3 >= 1)
  {
    v14 = a3 + 1;
    do
    {
      v15 = result->f32[0];
      result = (float32x4_t *)((char *)result + 4);
      a2->f32[0] = a6.f32[0] * v15;
      a2 = (float32x4_t *)((char *)a2 + 4);
      a6.f32[0] = a6.f32[0] + a5;
      --v14;
    }
    while (v14 > 1);
  }
  *a4 = a6.f32[0];
  return result;
}

NeuralNet *std::unique_ptr<NeuralNet>::reset[abi:ne180100](NeuralNet **a1, NeuralNet *a2)
{
  NeuralNet *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    NeuralNet::~NeuralNet(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

uint64_t DictionaryBlobReader::ReadScalarFromDictionary<double>(NSObject ***a1, CFDictionaryRef theDict, const __CFString *key, uint64_t *a4)
{
  const __CFNumber *Value;
  NSObject **v8;
  NSObject *v9;
  uint64_t v10;
  NSObject **v11;
  NSObject *v12;
  const char *CStringPtr;
  uint64_t v14;
  int v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberFloat64Type, a4);
    v8 = *a1;
    if (*a1)
    {
      v9 = *v8;
      if (!*v8)
        return 0;
    }
    else
    {
      v9 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      CStringPtr = CFStringGetCStringPtr(key, 0x8000100u);
      v14 = *a4;
      v16 = 136315906;
      v17 = "DictionaryBlobReader.hpp";
      v18 = 1024;
      v19 = 71;
      v20 = 2080;
      v21 = CStringPtr;
      v22 = 2048;
      v23 = v14;
      _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved %s (%g).", (uint8_t *)&v16, 0x26u);
    }
    return 0;
  }
  v10 = 4294900555;
  v11 = *a1;
  if (*a1)
  {
    v12 = *v11;
    if (!*v11)
      return v10;
  }
  else
  {
    v12 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v16 = 136315650;
    v17 = "DictionaryBlobReader.hpp";
    v18 = 1024;
    v19 = 65;
    v20 = 2080;
    v21 = CFStringGetCStringPtr(key, 0x8000100u);
    _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Failed to retrieve %s.", (uint8_t *)&v16, 0x1Cu);
  }
  return v10;
}

uint64_t DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>(uint64_t **a1, CFDictionaryRef theDict, const __CFString *key, _DWORD *a4)
{
  const __CFNumber *Value;
  uint64_t *v8;
  uint64_t v9;
  NSObject **v10;
  NSObject *v11;
  const char *CStringPtr;
  unint64_t v13;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  double v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberIntType, a4);
    v8 = *a1;
    if (*a1)
    {
      v9 = *v8;
      if (!*v8)
        return v9;
    }
    else
    {
      v9 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEBUG))
    {
      CStringPtr = CFStringGetCStringPtr(key, 0x8000100u);
      LODWORD(v13) = *a4;
      v15 = 136315906;
      v16 = "DictionaryBlobReader.hpp";
      v17 = 1024;
      v18 = 71;
      v19 = 2080;
      v20 = CStringPtr;
      v21 = 2048;
      v22 = (double)v13;
      _os_log_impl(&dword_1B5ED0000, (os_log_t)v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved %s (%g).", (uint8_t *)&v15, 0x26u);
    }
    return 0;
  }
  else
  {
    v9 = 4294900555;
    v10 = (NSObject **)*a1;
    if (*a1)
    {
      v11 = *v10;
      if (!*v10)
        return v9;
    }
    else
    {
      v11 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 136315650;
      v16 = "DictionaryBlobReader.hpp";
      v17 = 1024;
      v18 = 65;
      v19 = 2080;
      v20 = CFStringGetCStringPtr(key, 0x8000100u);
      _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Failed to retrieve %s.", (uint8_t *)&v15, 0x1Cu);
    }
  }
  return v9;
}

uint64_t DictionaryBlobReader::ReadScalarFromDictionary<float>(uint64_t **a1, CFDictionaryRef theDict, const __CFString *key, CFNumberType a4, float *a5)
{
  const __CFNumber *Value;
  uint64_t *v10;
  uint64_t v11;
  NSObject **v12;
  NSObject *v13;
  const char *CStringPtr;
  double v15;
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  double v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    CFNumberGetValue(Value, a4, a5);
    v10 = *a1;
    if (*a1)
    {
      v11 = *v10;
      if (!*v10)
        return v11;
    }
    else
    {
      v11 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_DEBUG))
    {
      CStringPtr = CFStringGetCStringPtr(key, 0x8000100u);
      v15 = *a5;
      v17 = 136315906;
      v18 = "DictionaryBlobReader.hpp";
      v19 = 1024;
      v20 = 71;
      v21 = 2080;
      v22 = CStringPtr;
      v23 = 2048;
      v24 = v15;
      _os_log_impl(&dword_1B5ED0000, (os_log_t)v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d Successfully retrieved %s (%g).", (uint8_t *)&v17, 0x26u);
    }
    return 0;
  }
  else
  {
    v11 = 4294900555;
    v12 = (NSObject **)*a1;
    if (*a1)
    {
      v13 = *v12;
      if (!*v12)
        return v11;
    }
    else
    {
      v13 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v17 = 136315650;
      v18 = "DictionaryBlobReader.hpp";
      v19 = 1024;
      v20 = 65;
      v21 = 2080;
      v22 = CFStringGetCStringPtr(key, 0x8000100u);
      _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Failed to retrieve %s.", (uint8_t *)&v17, 0x1Cu);
    }
  }
  return v11;
}

uint64_t NeuralNetRES::NeuralNetRES(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  char **v5;
  char **v6;
  NeuralNet **v7;
  char **v8;
  char **v9;
  char **v10;
  NeuralNet *v11;
  uint64_t *v12;
  NSObject *v13;
  int ScalarFrom;
  NSObject *v15;
  NSObject *isa;
  uint64_t v17;
  NSObject *v18;
  int v19;
  NSObject **v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  int v24;
  NSObject **v25;
  NSObject *v26;
  int v27;
  NSObject *v28;
  float *v29;
  int v30;
  NSObject **v31;
  NSObject *v32;
  double v33;
  float v34;
  float v35;
  NSObject **v36;
  NSObject *v37;
  NSObject *v38;
  int v39;
  NSObject *v40;
  double v41;
  NSObject *v42;
  int v43;
  NSObject *v44;
  double v45;
  NSObject *v46;
  int v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  int v57;
  const char *v58;
  NSObject **v59;
  NSObject **v60;
  NSObject *v61;
  NSObject *v62;
  uint32_t v63;
  _DWORD *exception;
  NSObject *v65;
  char **v66;
  uint64_t *v67;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  _BYTE v73[10];
  __int16 v74;
  int v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)(a1 + 56) = 0u;
  v5 = (char **)(a1 + 56);
  *(_DWORD *)(a1 + 36) = 629145600;
  *(_OWORD *)(a1 + 104) = 0u;
  v6 = (char **)(a1 + 104);
  *(_OWORD *)(a1 + 152) = 0u;
  v7 = (NeuralNet **)(a1 + 152);
  *(_OWORD *)(a1 + 168) = 0u;
  v8 = (char **)(a1 + 168);
  v66 = (char **)(a1 + 80);
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  v9 = (char **)(a1 + 128);
  v10 = (char **)(a1 + 192);
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = a3;
  v11 = (NeuralNet *)operator new();
  NeuralNet::NeuralNet((uint64_t)v11, a2, *(uint64_t **)(a1 + 216));
  std::unique_ptr<NeuralNet>::reset[abi:ne180100](v7, v11);
  v12 = *(uint64_t **)(a1 + 216);
  v67 = v12;
  if (v12)
  {
    v13 = *v12;
    if (!*v12)
      goto LABEL_7;
  }
  else
  {
    v13 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 50;
    _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_INFO, "%25s:%-5d NeuralNetRES: Loading SampleRate from topLevelDict.", buf, 0x12u);
  }
LABEL_7:
  ScalarFrom = DictionaryBlobReader::ReadScalarFromDictionary<double>((NSObject ***)&v67, a2, CFSTR("SampleRate"), (uint64_t *)a1);
  v15 = *(NSObject **)(a1 + 216);
  if (ScalarFrom)
  {
    if (v15)
      v15 = v15->isa;
    v57 = -66741;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_132;
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 52;
    v72 = 1024;
    *(_DWORD *)v73 = -66741;
    v58 = "%25s:%-5d EXCEPTION (%d) [err != noErr is false]: \"Failed to retrieve sample rate.\"";
LABEL_130:
    v62 = v15;
    v63 = 24;
LABEL_131:
    _os_log_impl(&dword_1B5ED0000, v62, OS_LOG_TYPE_ERROR, v58, buf, v63);
    goto LABEL_132;
  }
  if (v15)
  {
    isa = v15->isa;
    if (!v15->isa)
      goto LABEL_20;
  }
  else
  {
    isa = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(isa, OS_LOG_TYPE_INFO))
  {
    v17 = *(_QWORD *)a1;
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 53;
    v72 = 2048;
    *(_QWORD *)v73 = v17;
    _os_log_impl(&dword_1B5ED0000, isa, OS_LOG_TYPE_INFO, "%25s:%-5d Successfully retrieved sample rate (%g Hz).\n", buf, 0x1Cu);
    v15 = *(NSObject **)(a1 + 216);
  }
  if (v15)
  {
    v18 = v15->isa;
    if (!v18)
      goto LABEL_20;
  }
  else
  {
    v18 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 56;
    _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_INFO, "%25s:%-5d NeuralNetRES: Loading BlockSize from topLevelDict.", buf, 0x12u);
  }
LABEL_20:
  v19 = DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>(&v67, a2, CFSTR("BlockSize"), (_DWORD *)(a1 + 8));
  v20 = *(NSObject ***)(a1 + 216);
  if (v19)
  {
    if (v20)
      v15 = *v20;
    else
      v15 = 0;
    v57 = -66741;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_132;
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 58;
    v72 = 1024;
    *(_DWORD *)v73 = -66741;
    v58 = "%25s:%-5d EXCEPTION (%d) [err != noErr is false]: \"Failed to retrieve BlockSize.\"";
    goto LABEL_130;
  }
  if (v20)
  {
    v21 = *v20;
    if (!*v20)
      goto LABEL_33;
  }
  else
  {
    v21 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
  {
    v22 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 59;
    v72 = 1024;
    *(_DWORD *)v73 = v22;
    _os_log_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_INFO, "%25s:%-5d Successfully retrieved BlockSize (%u).\n", buf, 0x18u);
    v20 = *(NSObject ***)(a1 + 216);
  }
  if (v20)
  {
    v23 = *v20;
    if (!*v20)
      goto LABEL_33;
  }
  else
  {
    v23 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 63;
    _os_log_impl(&dword_1B5ED0000, v23, OS_LOG_TYPE_INFO, "%25s:%-5d NeuralNetRES: Loading NumContextFrames from topLevelDict.", buf, 0x12u);
  }
LABEL_33:
  v24 = DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>(&v67, a2, CFSTR("NumContextFrames"), (_DWORD *)(a1 + 12));
  v25 = *(NSObject ***)(a1 + 216);
  if (v24)
  {
    if (v25)
      v15 = *v25;
    else
      v15 = 0;
    v57 = -66741;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_132;
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 65;
    v72 = 1024;
    *(_DWORD *)v73 = -66741;
    v58 = "%25s:%-5d EXCEPTION (%d) [err != noErr is false]: \"Failed to retrieve NumContextFrames.\"";
    goto LABEL_130;
  }
  if (v25)
  {
    v26 = *v25;
    if (!*v25)
      goto LABEL_46;
  }
  else
  {
    v26 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    v27 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 66;
    v72 = 1024;
    *(_DWORD *)v73 = v27;
    _os_log_impl(&dword_1B5ED0000, v26, OS_LOG_TYPE_INFO, "%25s:%-5d Successfully retrieved NumContextFrames (%u).\n", buf, 0x18u);
    v25 = *(NSObject ***)(a1 + 216);
  }
  if (v25)
  {
    v28 = *v25;
    if (!*v25)
      goto LABEL_46;
  }
  else
  {
    v28 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 69;
    _os_log_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_INFO, "%25s:%-5d NeuralNetRES: Loading forgetting factor Lambda_TC from topLevelDict.", buf, 0x12u);
  }
LABEL_46:
  v29 = (float *)(a1 + 16);
  v30 = DictionaryBlobReader::ReadScalarFromDictionary<float>(&v67, a2, CFSTR("Lambda_TC"), kCFNumberFloat32Type, (float *)(a1 + 16));
  v31 = *(NSObject ***)(a1 + 216);
  if (v30)
  {
    if (v31)
      v15 = *v31;
    else
      v15 = 0;
    v57 = -66741;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_132;
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 71;
    v72 = 1024;
    *(_DWORD *)v73 = -66741;
    v58 = "%25s:%-5d EXCEPTION (%d) [err != noErr is false]: \"Failed to retrieve forgetting factor Lambda_TC.\"";
    goto LABEL_130;
  }
  if (v31)
  {
    v32 = *v31;
    if (!*v31)
      goto LABEL_53;
  }
  else
  {
    v32 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
  {
    v33 = *v29;
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 72;
    v72 = 2048;
    *(double *)v73 = v33;
    _os_log_impl(&dword_1B5ED0000, v32, OS_LOG_TYPE_INFO, "%25s:%-5d Successfully retrieved forgetting factor Lambda_TC (%g sec.).\n", buf, 0x1Cu);
  }
LABEL_53:
  v34 = 0.0;
  if (*v29 != 0.0)
  {
    v35 = *(double *)a1;
    v34 = expf((float)((float)-(float)*(unsigned int *)(a1 + 8) / v35) / *v29);
  }
  *(float *)(a1 + 20) = v34;
  *(float *)(a1 + 24) = 1.0 - v34;
  v36 = *(NSObject ***)(a1 + 216);
  if (v36)
  {
    v37 = *v36;
    if (!*v36)
      goto LABEL_67;
  }
  else
  {
    v37 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 77;
    v72 = 2048;
    *(double *)v73 = v34;
    _os_log_impl(&dword_1B5ED0000, v37, OS_LOG_TYPE_INFO, "%25s:%-5d Internally set the forgetting factor as (%g).\n", buf, 0x1Cu);
    v36 = *(NSObject ***)(a1 + 216);
  }
  if (v36)
  {
    v38 = *v36;
    if (!*v36)
      goto LABEL_67;
  }
  else
  {
    v38 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 80;
    _os_log_impl(&dword_1B5ED0000, v38, OS_LOG_TYPE_INFO, "%25s:%-5d NeuralNetRES: Loading ECoutScale from topLevelDict.", buf, 0x12u);
  }
LABEL_67:
  v39 = DictionaryBlobReader::ReadScalarFromDictionary<float>(&v67, a2, CFSTR("ECoutScale"), kCFNumberFloat32Type, (float *)(a1 + 28));
  v15 = *(NSObject **)(a1 + 216);
  if (v39)
  {
    if (v15)
      v15 = v15->isa;
    v57 = -66741;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_132;
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 82;
    v72 = 1024;
    *(_DWORD *)v73 = -66741;
    v58 = "%25s:%-5d EXCEPTION (%d) [err != noErr is false]: \"Failed to retrieve ECoutScale.\"";
    goto LABEL_130;
  }
  if (v15)
  {
    v40 = v15->isa;
    if (!v15->isa)
      goto LABEL_80;
  }
  else
  {
    v40 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
  {
    v41 = *(float *)(a1 + 28);
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 83;
    v72 = 2048;
    *(double *)v73 = v41;
    _os_log_impl(&dword_1B5ED0000, v40, OS_LOG_TYPE_INFO, "%25s:%-5d Successfully retrieved ECoutScale (%g).\n", buf, 0x1Cu);
    v15 = *(NSObject **)(a1 + 216);
  }
  if (v15)
  {
    v42 = v15->isa;
    if (!v42)
      goto LABEL_80;
  }
  else
  {
    v42 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 86;
    _os_log_impl(&dword_1B5ED0000, v42, OS_LOG_TYPE_INFO, "%25s:%-5d NeuralNetRES: Loading ECleeScale from topLevelDict.", buf, 0x12u);
  }
LABEL_80:
  v43 = DictionaryBlobReader::ReadScalarFromDictionary<float>(&v67, a2, CFSTR("ECleeScale"), kCFNumberFloat32Type, (float *)(a1 + 32));
  v15 = *(NSObject **)(a1 + 216);
  if (v43)
  {
    if (v15)
      v15 = v15->isa;
    v57 = -66741;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_132;
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 88;
    v72 = 1024;
    *(_DWORD *)v73 = -66741;
    v58 = "%25s:%-5d EXCEPTION (%d) [err != noErr is false]: \"Failed to retrieve ECleeScale.\"";
    goto LABEL_130;
  }
  if (v15)
  {
    v44 = v15->isa;
    if (!v15->isa)
      goto LABEL_93;
  }
  else
  {
    v44 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
  {
    v45 = *(float *)(a1 + 32);
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 89;
    v72 = 2048;
    *(double *)v73 = v45;
    _os_log_impl(&dword_1B5ED0000, v44, OS_LOG_TYPE_INFO, "%25s:%-5d Successfully retrieved ECleeScale (%g).\n", buf, 0x1Cu);
    v15 = *(NSObject **)(a1 + 216);
  }
  if (v15)
  {
    v46 = v15->isa;
    if (!v46)
      goto LABEL_93;
  }
  else
  {
    v46 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 92;
    _os_log_impl(&dword_1B5ED0000, v46, OS_LOG_TYPE_INFO, "%25s:%-5d NeuralNetRES: Loading FFT2Mel matrix from topLevelDict.", buf, 0x12u);
  }
LABEL_93:
  v47 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 40) = v47;
  if (DictionaryBlobReader::ReadSparseMatrix(&v67, a2, CFSTR("FFT2Mel"), (unsigned int *)(a1 + 44), CFSTR("NumMelBands"), v47, CFSTR("NumFFTBins"), (sparse_m_float **)(a1 + 48)))
  {
    v59 = *(NSObject ***)(a1 + 216);
    if (v59)
      v15 = *v59;
    else
      v15 = 0;
    v57 = -66741;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_132;
    *(_DWORD *)buf = 136315650;
    v69 = "NeuralNetRES.cpp";
    v70 = 1024;
    v71 = 95;
    v72 = 1024;
    *(_DWORD *)v73 = -66741;
    v58 = "%25s:%-5d EXCEPTION (%d) [err != noErr is false]: \"FFT2Mel matrix not loaded.\"";
    goto LABEL_130;
  }
  v48 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)buf = 0;
  std::vector<float>::assign(v5, v48, buf);
  v49 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)buf = 0;
  std::vector<float>::assign(v66, v49, buf);
  v50 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)buf = 0;
  std::vector<float>::assign(v6, v50, buf);
  v51 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)buf = 0;
  std::vector<float>::assign(v9, v51, buf);
  *(_DWORD *)(a1 + 160) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)*v7 + 24))(*(_QWORD *)*v7);
  v52 = (*(uint64_t (**)(_QWORD))(***(_QWORD ***)(a1 + 152) + 32))(**(_QWORD **)(a1 + 152));
  *(_DWORD *)(a1 + 164) = v52;
  v53 = *(_DWORD *)(a1 + 40);
  if (v53 != v52)
  {
    v60 = *(NSObject ***)(a1 + 216);
    if (v60)
      v61 = *v60;
    else
      v61 = 0;
    v65 = v61;
    v57 = -66743;
    if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      v69 = "NeuralNetRES.cpp";
      v70 = 1024;
      v71 = 108;
      v72 = 1024;
      *(_DWORD *)v73 = -66743;
      *(_WORD *)&v73[4] = 1024;
      *(_DWORD *)&v73[6] = v52;
      v74 = 1024;
      v75 = v53;
      v58 = "%25s:%-5d EXCEPTION (%d) [mOutputSize != mNumFFTBins is false]: \"NeuralNet output size (%u) is not matching"
            " the number of FFT bins (%u).\"";
      v62 = v65;
      v63 = 36;
      goto LABEL_131;
    }
LABEL_132:
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E69EE218;
    exception[2] = v57;
  }
  v54 = *(unsigned int *)(a1 + 160);
  *(_DWORD *)buf = 0;
  std::vector<float>::assign(v8, v54, buf);
  v55 = *(unsigned int *)(a1 + 164);
  *(_DWORD *)buf = 0;
  std::vector<float>::assign(v10, v55, buf);
  return a1;
}

void sub_1B61522C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11)
{
  _QWORD *v11;
  void **v12;
  void **v13;
  NeuralNet **v14;
  void **v15;
  void **v16;
  void **v17;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;

  v19 = *v17;
  if (*v17)
  {
    v11[25] = v19;
    operator delete(v19);
  }
  v20 = *v16;
  if (*v16)
  {
    v11[22] = v20;
    operator delete(v20);
  }
  std::unique_ptr<NeuralNet>::reset[abi:ne180100](v14, 0);
  v21 = *v15;
  if (*v15)
  {
    v11[17] = v21;
    operator delete(v21);
  }
  v22 = *v13;
  if (*v13)
  {
    v11[14] = v22;
    operator delete(v22);
  }
  v23 = *a11;
  if (*a11)
  {
    v11[11] = v23;
    operator delete(v23);
  }
  v24 = *v12;
  if (*v12)
  {
    v11[8] = v24;
    operator delete(v24);
  }
  _Unwind_Resume(a1);
}

void NeuralNetRES::Cleanup(NeuralNetRES *this)
{
  (*(void (**)(_QWORD))(***((_QWORD ***)this + 19) + 48))(**((_QWORD **)this + 19));
  bzero(*((void **)this + 7), *((_QWORD *)this + 8) - *((_QWORD *)this + 7));
  bzero(*((void **)this + 10), *((_QWORD *)this + 11) - *((_QWORD *)this + 10));
  bzero(*((void **)this + 13), *((_QWORD *)this + 14) - *((_QWORD *)this + 13));
  bzero(*((void **)this + 16), *((_QWORD *)this + 17) - *((_QWORD *)this + 16));
  bzero(*((void **)this + 21), *((_QWORD *)this + 22) - *((_QWORD *)this + 21));
  bzero(*((void **)this + 24), *((_QWORD *)this + 25) - *((_QWORD *)this + 24));
}

void NeuralNetRES::ProcessBufferList(NeuralNetRES *this, const AudioBufferList *a2, const AudioBufferList *a3, AudioBufferList *a4, float a5, int a6, int a7, float a8)
{
  uint64_t mNumberBuffers;
  float v17;
  float v18;
  unsigned int v19;
  float v20;
  void **p_mData;
  void **v22;
  float *v23;
  uint64_t v24;
  float *v25;
  float *v26;
  float *v27;
  float v28;
  uint64_t v29;
  float v30;
  float *v31;
  float v32;
  vDSP_Length v33;
  const float **v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  float *v39;
  uint64_t v40;
  float *v41;
  float *v42;
  float *v43;
  float v44;
  uint64_t v45;
  float v46;
  float __B;
  int v48;
  float __C;
  DSPSplitComplex v50;
  DSPSplitComplex __A;
  float v52;

  v52 = a5;
  mNumberBuffers = a2->mNumberBuffers;
  v17 = *((float *)this + 7);
  v18 = *((float *)this + 8);
  vDSP_vclr(*((float **)this + 7), 1, *((unsigned int *)this + 10));
  vDSP_vclr(*((float **)this + 13), 1, *((unsigned int *)this + 10));
  if (!(_DWORD)mNumberBuffers)
    goto LABEL_9;
  v19 = 0;
  v20 = v17 * v17;
  p_mData = &a3->mBuffers[0].mData;
  v22 = &a2->mBuffers[0].mData;
  do
  {
    if (!a7
      || (float)((float)(v20
                       * cblas_sdsdot(2 * *((_DWORD *)this + 2), 0.0, (const float *)*v22, 1, (const float *)*v22, 1))
               / (float)*((unsigned int *)this + 10)) >= a8)
    {
      v23 = (float *)*v22;
      v24 = *((unsigned int *)this + 2);
      v25 = (float *)((char *)*v22 + 4 * v24);
      v26 = (float *)*p_mData;
      v27 = (float *)((char *)*p_mData + 4 * v24);
      __A.realp = (float *)((char *)*v22 + 4);
      __A.imagp = v25 + 1;
      v28 = *v23;
      v29 = *((_QWORD *)this + 7);
      *(float *)v29 = *(float *)v29 + (float)(v28 * v28);
      v30 = *v26;
      v50.realp = v26 + 1;
      v31 = (float *)*((_QWORD *)this + 13);
      *v31 = *v31 + (float)(v30 * v30);
      *(float *)(v29 + 4 * v24) = *(float *)(v29 + 4 * v24) + (float)(*v25 * *v25);
      v32 = *v27;
      v50.imagp = v27 + 1;
      ++v19;
      v31[v24] = v31[v24] + (float)(v32 * v32);
      vDSP_zvmgsa(&__A, 1, (const float *)(v29 + 4), 1, (float *)(v29 + 4), 1, (v24 - 1));
      vDSP_zvmgsa(&v50, 1, (const float *)(*((_QWORD *)this + 13) + 4), 1, (float *)(*((_QWORD *)this + 13) + 4), 1, (*((_DWORD *)this + 2) - 1));
    }
    p_mData += 2;
    v22 += 2;
    --mNumberBuffers;
  }
  while (mNumberBuffers);
  v33 = *((unsigned int *)this + 10);
  if (v19)
  {
    *(float *)&__A.realp = v20 / (float)v19;
    *(float *)&v50.realp = (float)(v18 * v18) / (float)v19;
    vDSP_vsmul(*((const float **)this + 7), 1, (const float *)&__A, *((float **)this + 7), 1, v33);
    vDSP_vsmul(*((const float **)this + 13), 1, (const float *)&v50, *((float **)this + 13), 1, *((unsigned int *)this + 10));
LABEL_9:
    LODWORD(v33) = *((_DWORD *)this + 10);
  }
  if (*((float *)this + 5) > 0.0)
  {
    vDSP_vsmsma(*((const float **)this + 10), 1, (const float *)this + 5, *((const float **)this + 7), 1, (const float *)this + 6, *((float **)this + 10), 1, v33);
    vDSP_vsmsma(*((const float **)this + 16), 1, (const float *)this + 5, *((const float **)this + 13), 1, (const float *)this + 6, *((float **)this + 16), 1, *((unsigned int *)this + 10));
    LODWORD(v33) = *((_DWORD *)this + 10);
  }
  __C = 0.0;
  vDSP_meanv(*((const float **)this + 13), 1, &__C, v33);
  if (__C <= *((float *)this + 9))
  {
    LODWORD(__A.realp) = 1065353216;
    vDSP_vfill((const float *)&__A, *((float **)this + 24), 1, *((unsigned int *)this + 10));
    if (a4->mNumberBuffers)
    {
      v35 = 0;
      v36 = 16;
      do
      {
        memcpy(*(void **)((char *)&a4->mNumberBuffers + v36), *(const void **)((char *)&a2->mNumberBuffers + v36), 4 * (2 * *((_DWORD *)this + 2)));
        ++v35;
        v36 += 16;
      }
      while (v35 < a4->mNumberBuffers);
    }
  }
  else
  {
    vDSP_vclr(*((float **)this + 21), 1, *((unsigned int *)this + 40));
    sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 6), *((const float **)this + 7), 1, *((float **)this + 21), 1);
    sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 6), *((const float **)this + 13), 1, (float *)(*((_QWORD *)this + 21) + 4 * *((unsigned int *)this + 11)), 1);
    if (*((float *)this + 5) > 0.0)
    {
      sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 6), *((const float **)this + 10), 1, (float *)(*((_QWORD *)this + 21) + 4 * (2 * *((_DWORD *)this + 11))), 1);
      sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 6), *((const float **)this + 16), 1, (float *)(*((_QWORD *)this + 21) + 4 * (3 * *((_DWORD *)this + 11))), 1);
    }
    vDSP_vthr(*((const float **)this + 21), 1, (const float *)this + 9, *((float **)this + 21), 1, *((unsigned int *)this + 40));
    v48 = *((_DWORD *)this + 40);
    vvlogf(*((float **)this + 21), *((const float **)this + 21), &v48);
    v34 = (const float **)(*(uint64_t (**)(_QWORD, char *))(***((_QWORD ***)this + 19) + 72))(**((_QWORD **)this + 19), (char *)this + 168);
    v46 = 1.0;
    __B = 0.0;
    vDSP_vclip(*v34, 1, &__B, &v46, *((float **)this + 24), 1, *((unsigned int *)this + 10));
    if (a6)
    {
      vDSP_vthr(*((const float **)this + 24), 1, &v52, *((float **)this + 24), 1, *((unsigned int *)this + 10));
    }
    else
    {
      *(float *)&__A.realp = 1.0 - a5;
      vDSP_vsmsa(*((const float **)this + 24), 1, (const float *)&__A, &v52, *((float **)this + 24), 1, *((unsigned int *)this + 10));
    }
    if (a4->mNumberBuffers)
    {
      v37 = 0;
      v38 = 16;
      do
      {
        v39 = *(float **)((char *)&a2->mNumberBuffers + v38);
        v40 = *((unsigned int *)this + 2);
        v41 = &v39[v40];
        v42 = *(float **)((char *)&a4->mNumberBuffers + v38);
        __A.realp = v39 + 1;
        __A.imagp = v41 + 1;
        v43 = &v42[v40];
        v44 = *v39;
        v45 = *((_QWORD *)this + 24);
        *v42 = v44 * *(float *)v45;
        v50.realp = v42 + 1;
        *v43 = *v41 * *(float *)(v45 + 4 * v40);
        v50.imagp = v43 + 1;
        vDSP_zrvmul(&__A, 1, (const float *)(v45 + 4), 1, &v50, 1, (v40 - 1));
        ++v37;
        v38 += 16;
      }
      while (v37 < a4->mNumberBuffers);
    }
  }
}

void std::vector<TimeStampedEvent<unsigned int>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  __int128 v11;

  if (0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) < a2)
  {
    v3 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 24;
    v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(a2);
    v5 = &v4[24 * v3];
    v7 = &v4[24 * v6];
    v9 = (char *)*a1;
    v8 = (char *)a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *(_OWORD *)(v8 - 24);
        *((_QWORD *)v10 - 1) = *((_QWORD *)v8 - 1);
        *(_OWORD *)(v10 - 24) = v11;
        v10 -= 24;
        v8 -= 24;
      }
      while (v8 != v9);
      v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

void std::default_delete<MRRingBuffer<AUEndpointVAD3_Decision>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;

  v1 = *a1;
  if (v1)
    MEMORY[0x1BCC95CC8](v1, 0x1000C8052888210);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t MRRingBuffer<DataTimeStamp>::MRRingBuffer(uint64_t a1, unsigned int a2)
{
  size_t v4;
  void *v5;
  void *v6;

  v4 = 16 * a2;
  v5 = (void *)operator new[]();
  v6 = v5;
  if (a2)
    bzero(v5, v4);
  *(_QWORD *)a1 = v6;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = 0;
  bzero(v6, 16 * (int)a2);
  return a1;
}

void std::default_delete<MRRingBuffer<DataTimeStamp>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;

  v1 = *a1;
  if (v1)
    MEMORY[0x1BCC95CC8](v1, 0x1000C80451B5BE8);
  JUMPOUT(0x1BCC95CECLL);
}

double MRRingBuffer<DataTimeStamp>::GetSample(uint64_t a1, int a2)
{
  int v2;

  if (a2 < 0)
    v2 = *(_DWORD *)(a1 + 8) + ~((*(_DWORD *)(a1 + 8) - a2 + ~*(_DWORD *)(a1 + 12)) % *(_DWORD *)(a1 + 8));
  else
    v2 = (*(_DWORD *)(a1 + 12) + a2) % *(_DWORD *)(a1 + 8);
  return *(double *)(*(_QWORD *)a1 + 16 * v2);
}

void CircularDelay::Reset(CircularDelay *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (void *)*((_QWORD *)this + 2);
  v3 = *((_QWORD *)this + 3) - (_QWORD)v2;
  if (v3 >= 1)
    bzero(v2, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
  *((_QWORD *)this + 5) = 0;
  v4 = *((_QWORD *)this + 1);
  if ((int)v4 < 1)
    v5 = -v4;
  else
    v5 = *(_DWORD *)this - (int)v4;
  *((_QWORD *)this + 6) = v5;
}

uint64_t SpatialMetadata_Create(uint64_t *a1, unsigned int a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t result;

  if (!a2)
    return 1650553447;
  v4 = operator new();
  *(_QWORD *)(v4 + 56) = 0;
  *(_QWORD *)(v4 + 64) = 0;
  *(_QWORD *)(v4 + 48) = 0;
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_QWORD *)(v4 + 32) = 0;
  *(_BYTE *)(v4 + 40) &= ~1u;
  v5 = (char *)operator new(20 * a2);
  *(_QWORD *)(v4 + 48) = v5;
  v6 = &v5[20 * a2];
  *(_QWORD *)(v4 + 64) = v6;
  do
  {
    *v5 = 0;
    *(_QWORD *)(v5 + 12) = 0;
    *(_QWORD *)(v5 + 4) = 0;
    v5 += 20;
  }
  while (v5 != v6);
  result = 0;
  *(_QWORD *)(v4 + 56) = v6;
  *a1 = v4;
  return result;
}

uint64_t SpatialMetadata_Destroy(uint64_t a1)
{
  void *v2;

  if (!a1)
    return 1651664230;
  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  MEMORY[0x1BCC95CEC](a1, 0x1020C40D5999051);
  return 0;
}

uint64_t SpatialMetadata_GetProperty(uint64_t a1, int a2, _anonymous_namespace_::SpatialMetadata *this, _DWORD *a4, _DWORD *a5)
{
  uint64_t v6;
  uint64_t v8;
  _DWORD *v9;
  int v10;
  _DWORD *exception;
  int v13;

  if (!a1)
    return 1651664230;
  v6 = 1650553447;
  if (a4 && a5)
  {
    v6 = 1651536496;
    v8 = a1;
    switch(a2)
    {
      case 0:
        goto LABEL_7;
      case 1:
        if (*a5 < 4u)
          goto LABEL_32;
        v6 = 0;
        *a5 = 4;
        v10 = *(_DWORD *)(v8 + 4);
        goto LABEL_21;
      case 2:
        if (*a5 < 4u)
          goto LABEL_32;
        v6 = 0;
        *a5 = 4;
        v10 = *(_DWORD *)(v8 + 8);
        goto LABEL_21;
      case 3:
        if (*a5 <= 3u)
        {
LABEL_32:
          exception = __cxa_allocate_exception(4uLL);
          *exception = 1651536762;
        }
        v6 = 0;
        *a5 = 4;
        v10 = *(_DWORD *)(v8 + 12);
LABEL_21:
        *a4 = v10;
        return v6;
      case 4:
        v9 = (_DWORD *)(v8 + 16);
        goto LABEL_28;
      case 5:
        v9 = (_DWORD *)(v8 + 20);
        goto LABEL_28;
      case 6:
        v9 = (_DWORD *)(v8 + 24);
        goto LABEL_28;
      case 7:
        v9 = (_DWORD *)(v8 + 28);
        goto LABEL_28;
      case 8:
        v9 = (_DWORD *)(v8 + 32);
        goto LABEL_28;
      case 9:
        v9 = (_DWORD *)(v8 + 36);
        goto LABEL_28;
      case 10:
        goto LABEL_29;
      case 11:
        goto LABEL_29;
      case 12:
        goto LABEL_29;
      case 13:
        goto LABEL_28;
      case 14:
        goto LABEL_28;
      case 15:
LABEL_28:
        goto LABEL_29;
      case 16:
LABEL_7:
        goto LABEL_29;
      case 17:
        v13 = *(_BYTE *)(v8 + 40) & 1;
LABEL_29:
        v6 = 0;
        break;
      default:
        return v6;
    }
  }
  return v6;
}

void sub_1B6152F3C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6152EF4);
}

uint64_t SpatialMetadata_SetProperty(uint64_t a1, int a2, _anonymous_namespace_::SpatialMetadata *this, unsigned int *a4, int a5)
{
  uint64_t result;
  int v8;
  int v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  char v13;
  _BYTE *ClientInfo;
  char v15;
  char v16;
  float v17;
  char v18;
  char v19;
  float v20;
  unsigned int v21;
  float v22;
  uint64_t v23;
  unsigned int v24;
  float v25;
  unsigned int v26;
  char v27;
  float v28;
  float v29;
  uint64_t v30;
  float v31;
  char v32;
  float v33;
  _DWORD *exception;

  if (!a1)
    return 1651664230;
  if (!a4)
    return 1650553447;
  result = 1651536496;
  switch(a2)
  {
    case 0:
      result = 0;
      *(_DWORD *)a1 = v8;
      return result;
    case 1:
      if (a5 != 4)
        goto LABEL_30;
      v26 = *a4;
      result = 0;
      *(_DWORD *)(a1 + 4) = v26;
      return result;
    case 2:
      if (a5 != 4)
        goto LABEL_30;
      v21 = *a4;
      result = 0;
      *(_DWORD *)(a1 + 8) = v21;
      return result;
    case 3:
      if (a5 != 4)
      {
LABEL_30:
        exception = __cxa_allocate_exception(4uLL);
        *exception = 1651536762;
      }
      v24 = *a4;
      result = 0;
      *(_DWORD *)(a1 + 12) = v24;
      return result;
    case 4:
      result = 0;
      *(float *)(a1 + 16) = v17;
      return result;
    case 5:
      result = 0;
      *(float *)(a1 + 20) = v28;
      return result;
    case 6:
      result = 0;
      *(float *)(a1 + 24) = v31;
      return result;
    case 7:
      result = 0;
      *(float *)(a1 + 28) = v25;
      return result;
    case 8:
      result = 0;
      *(float *)(a1 + 32) = v33;
      return result;
    case 9:
      result = 0;
      *(float *)(a1 + 36) = v20;
      return result;
    case 10:
      result = 0;
      v19 = *ClientInfo & 0xFE | v32 & 1;
      goto LABEL_25;
    case 11:
      result = 0;
      v15 = 2 * (v13 & 1);
      v16 = *ClientInfo & 0xFD;
      goto LABEL_10;
    case 12:
      result = 0;
      v15 = 4 * (v18 & 1);
      v16 = *ClientInfo & 0xFB;
LABEL_10:
      v19 = v16 | v15;
LABEL_25:
      *ClientInfo = v19;
      break;
    case 13:
      result = 0;
      *(float *)(v30 + 4) = v29;
      break;
    case 14:
      result = 0;
      *(float *)(v12 + 8) = v11;
      break;
    case 15:
      result = 0;
      *(float *)(v23 + 12) = v22;
      break;
    case 16:
      result = 0;
      *(_DWORD *)(v10 + 16) = v9;
      break;
    case 17:
      result = 0;
      *(_BYTE *)(a1 + 40) = *(_BYTE *)(a1 + 40) & 0xFE | v27 & 1;
      break;
    default:
      return result;
  }
  return result;
}

void sub_1B61532E8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6153290);
}

uint64_t SpatialMetadata_GetDataSize(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  if (!a1)
    return 1651664230;
  if (!a2)
    return 1650553447;
  result = 0;
  *a2 = ((*(_DWORD *)(a1 + 56) - *(_DWORD *)(a1 + 48)) & 0xFFFFFFFC) + 64;
  return result;
}

uint64_t SpatialMetadata_GetData(__int128 *a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v3;
  unint64_t v4;
  unsigned int v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 *v11;
  __int128 v12;
  _DWORD *exception;

  if (!a1)
    return 1651664230;
  v3 = 1650553447;
  if (a2 && a3)
  {
    v4 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)a1 + 7) - *((_QWORD *)a1 + 6)) >> 2);
    v5 = 4 * ((uint64_t)(*((_QWORD *)a1 + 7) - *((_QWORD *)a1 + 6)) >> 2) + 64;
    if (v5 > *a3)
    {
      exception = __cxa_allocate_exception(4uLL);
      *exception = 1650750330;
    }
    *a3 = v5;
    *(_DWORD *)a2 = 1;
    *(_DWORD *)(a2 + 4) = v5;
    *(_DWORD *)(a2 + 8) = 20;
    *(_DWORD *)(a2 + 12) = v4;
    *(_DWORD *)(a2 + 16) = 64;
    v6 = *a1;
    v7 = a1[1];
    *(_OWORD *)(a2 + 48) = *(__int128 *)((char *)a1 + 28);
    *(_OWORD *)(a2 + 36) = v7;
    *(_OWORD *)(a2 + 20) = v6;
    if ((_DWORD)v4)
    {
      v8 = 0;
      v9 = 20 * v4;
      do
      {
        v10 = a2 + 64 + v8;
        v11 = (__int128 *)(*((_QWORD *)a1 + 6) + v8);
        v12 = *v11;
        *(_DWORD *)(v10 + 16) = *((_DWORD *)v11 + 4);
        *(_OWORD *)v10 = v12;
        v8 += 20;
      }
      while (v9 != v8);
    }
    return 0;
  }
  return v3;
}

void sub_1B6153468(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6153424);
}

uint64_t SpatialMetadata_SetData(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 *v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  __int128 v12;
  _DWORD *exception;
  int v16;

  if (!a1)
    return 1651664230;
  if (!a2)
    return 1650553447;
  v3 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48)) >> 2);
  if (4 * ((uint64_t)(*(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48)) >> 2) + 64 > a3 || a2[1] != a3)
  {
    exception = __cxa_allocate_exception(4uLL);
    v16 = 1650750330;
    goto LABEL_12;
  }
  v4 = a2[3];
  if (v3 != v4)
  {
    exception = __cxa_allocate_exception(4uLL);
    v16 = 1650682979;
LABEL_12:
    *exception = v16;
  }
  v5 = a2[4];
  v6 = (__int128 *)((char *)a2 + a2[2]);
  v7 = *v6;
  v8 = v6[1];
  *(_OWORD *)(a1 + 28) = *(__int128 *)((char *)v6 + 28);
  *(_OWORD *)a1 = v7;
  *(_OWORD *)(a1 + 16) = v8;
  if ((_DWORD)v4)
  {
    v9 = 0;
    v10 = (char *)a2 + v5;
    do
    {
      v11 = *(_QWORD *)(a1 + 48) + v9;
      v12 = *(_OWORD *)&v10[v9];
      *(_DWORD *)(v11 + 16) = *(_DWORD *)&v10[v9 + 16];
      *(_OWORD *)v11 = v12;
      v9 += 20;
      --v3;
    }
    while (v3);
  }
  return 0;
}

void sub_1B61535A8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6153544);
}

uint64_t `anonymous namespace'::DataView::operator unsigned int<unsigned int>(unsigned int *a1, int a2)
{
  _DWORD *exception;

  if (a2 != 4)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = 1651536762;
  }
  return *a1;
}

uint64_t `anonymous namespace'::SpatialMetadata::getGlobalInfo(uint64_t this)
{
  _DWORD *exception;

  if ((_DWORD)this)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = 1650814061;
  }
  return this;
}

float `anonymous namespace'::DataView::operator float<float>(uint64_t a1, int a2)
{
  _DWORD *exception;

  if (a2 != 4)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = 1651536762;
  }
  return *(float *)a1;
}

uint64_t `anonymous namespace'::SpatialMetadata::getClientInfo(_anonymous_namespace_::SpatialMetadata *this, uint64_t a2, unsigned int a3)
{
  _DWORD *exception;

  if (0xCCCCCCCCCCCCCCCDLL * ((a2 - (uint64_t)this) >> 2) <= a3)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = 1650814061;
  }
  return (uint64_t)this + 20 * a3;
}

_DWORD *`anonymous namespace'::MutableDataView::operator=<unsigned int>(_DWORD *result, _DWORD *a2, _DWORD *a3)
{
  _DWORD *exception;

  if (*a2 <= 3u)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = 1651536762;
  }
  *a2 = 4;
  *result = *a3;
  return result;
}

void AUBSS1::~AUBSS1(AUBSS1 *this)
{
  AUBSS1::~AUBSS1(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_1E69C8E48;
  AUBSS1::Cleanup(this);
  v3 = (void **)((char *)this + 624);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 600);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)this + 74, 0);
  v2 = *((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void **)((char *)this + 560);
  std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100](&v3);
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUBSS1::Initialize(int64x2_t *this)
{
  uint64_t Element;
  uint64_t v3;
  __int32 v4;
  int v5;
  double v6;
  uint64_t result;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  void *v13;
  unint64_t v14;
  uint64_t *v15;
  int64x2_t *v16;
  uint64_t v17;
  VPTimeFreqConverter *v18;
  VPTimeFreqConverter **v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  VPTimeFreqConverter **v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  VPTimeFreqConverter *v32;
  int64x2_t v33;
  VPTimeFreqConverter *v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int16 v42;
  __int8 v43;
  void *__p[2];
  char v45;
  int64x2_t *v46;
  const unsigned int *v47;
  int v48;
  int v49;
  int v50;
  int v51;
  __int32 v52;
  void *v53;
  int64x2_t v54;
  unint64_t v55;
  int64x2_t *v56;

  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[5], 0);
  v3 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&this[8], 0);
  v4 = *(_DWORD *)(Element + 108);
  v51 = *(_DWORD *)(v3 + 108);
  v52 = v4;
  if (v4 != v51)
    return 4294956428;
  this[34].i32[1] = v4;
  if (v4 != 2)
    return 4294956428;
  v5 = *(_DWORD *)(Element + 88);
  if ((v5 == 1718773105) == (*(_DWORD *)(v3 + 88) != 1718773105))
    return 4294956428;
  this[33].i8[0] = v5 == 1718773105;
  v6 = *(double *)(Element + 80);
  if (v6 != *(double *)(v3 + 80))
    return 4294956428;
  this[46].i32[0] = v6;
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E69C90E8;
  *(_BYTE *)(v8 + 8) = 0;
  *(_QWORD *)&v9 = 0x100000001;
  *((_QWORD *)&v9 + 1) = 0x100000001;
  *(_OWORD *)(v8 + 12) = v9;
  *(_OWORD *)(v8 + 28) = v9;
  *(_DWORD *)(v8 + 44) = 0;
  *(_QWORD *)(v8 + 48) = 1065353216;
  *(_DWORD *)(v8 + 56) = 629145600;
  LOBYTE(v9) = 0;
  BYTE4(v9) = 0;
  BYTE8(v9) = 0;
  BYTE12(v9) = 0;
  *(_OWORD *)(v8 + 60) = v9;
  *(_OWORD *)(v8 + 80) = v9;
  *(_OWORD *)(v8 + 96) = v9;
  *(_OWORD *)(v8 + 112) = v9;
  *(_OWORD *)(v8 + 128) = v9;
  *(_OWORD *)(v8 + 144) = v9;
  *(_OWORD *)(v8 + 160) = v9;
  *(_OWORD *)(v8 + 176) = xmmword_1B66A06F0;
  *(_DWORD *)(v8 + 192) = 1070259713;
  *(_QWORD *)(v8 + 196) = 4000;
  *(_QWORD *)(v8 + 272) = 0;
  *(_OWORD *)(v8 + 240) = v9;
  *(_OWORD *)(v8 + 256) = v9;
  *(_OWORD *)(v8 + 208) = v9;
  *(_OWORD *)(v8 + 224) = v9;
  *(_OWORD *)(v8 + 280) = xmmword_1B66A0700;
  *(_QWORD *)(v8 + 296) = 0x42C8000040000000;
  *(_QWORD *)(v8 + 304) = 60;
  *(_QWORD *)(v8 + 312) = 1061997773;
  *(_QWORD *)(v8 + 320) = 0;
  *(_DWORD *)(v8 + 328) = 1120403456;
  *(_OWORD *)(v8 + 336) = v9;
  *(_OWORD *)(v8 + 352) = v9;
  *(_OWORD *)(v8 + 368) = v9;
  *(_OWORD *)(v8 + 384) = v9;
  *(_OWORD *)(v8 + 400) = v9;
  *(_OWORD *)(v8 + 416) = v9;
  *(_OWORD *)(v8 + 432) = v9;
  *(_OWORD *)(v8 + 448) = v9;
  *(_OWORD *)(v8 + 464) = v9;
  *(_OWORD *)(v8 + 480) = xmmword_1B66A0710;
  *(_QWORD *)(v8 + 496) = 60;
  *(_DWORD *)(v8 + 504) = 4000;
  *(_QWORD *)(v8 + 512) = 0x3E99999A3D4CCCCDLL;
  *(_DWORD *)(v8 + 520) = 0;
  *(_QWORD *)(v8 + 544) = 0;
  *(_OWORD *)(v8 + 528) = v9;
  *(_OWORD *)(v8 + 552) = xmmword_1B66A0720;
  *(_QWORD *)(v8 + 568) = 0x417000003F800000;
  *(_OWORD *)(v8 + 576) = v9;
  *(_OWORD *)(v8 + 592) = v9;
  *(_OWORD *)(v8 + 608) = v9;
  *(_OWORD *)(v8 + 624) = v9;
  *(_QWORD *)(v8 + 640) = 0;
  *(_DWORD *)(v8 + 648) = 1065353216;
  *(_OWORD *)(v8 + 652) = v9;
  *(_OWORD *)(v8 + 668) = v9;
  *(_OWORD *)(v8 + 684) = v9;
  *(_DWORD *)(v8 + 700) = 0;
  *(_OWORD *)(v8 + 704) = xmmword_1B66A0730;
  *(_OWORD *)(v8 + 720) = xmmword_1B66A0740;
  *(_OWORD *)(v8 + 736) = xmmword_1B66A0750;
  *(_QWORD *)(v8 + 752) = 0x40800000C1C80000;
  *(_DWORD *)(v8 + 760) = 1110704128;
  *(_OWORD *)(v8 + 768) = v9;
  *(_OWORD *)(v8 + 784) = v9;
  *(_OWORD *)(v8 + 800) = v9;
  *(_OWORD *)(v8 + 816) = xmmword_1B66A0760;
  *(_DWORD *)(v8 + 832) = 1066611507;
  v10 = this[36].i64[1];
  this[36].i64[1] = v8;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  if (this[23].i8[8])
  {
    v11 = this[21].u32[0];
  }
  else
  {
    v12 = *(double *)(Element + 80);
    if (v12 == 16000.0)
    {
      v11 = 192;
    }
    else if (v12 == 8000.0)
    {
      v11 = 96;
    }
    else if (v12 == 24000.0)
    {
      v11 = 240;
    }
    else
    {
      v11 = 480;
      if (v12 != 48000.0)
      {
        if (v12 == 44100.0)
          v11 = 480;
        else
          v11 = 192;
      }
    }
    v49 = 1;
    v50 = v11;
    __p[0] = &v52;
    v48 = 1;
    v46 = this;
    v47 = (const unsigned int *)&v51;
    std::make_unique[abi:ne180100]<BlockProcessor,int,unsigned int *,int,unsigned int *,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUBSS1 *>((BlockProcessor **)&v53, &v49, (const unsigned int **)__p, &v48, &v47, &v50, (void **)&v46);
    v13 = v53;
    v53 = 0;
    std::unique_ptr<BlockProcessor>::reset[abi:ne180100](this[37].i64, (uint64_t)v13);
    std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)&v53, 0);
  }
  this[34].i32[2] = v11 + 1;
  v14 = this[34].u32[1];
  v15 = &this[37].i64[1];
  std::vector<std::vector<std::vector<float>>>::resize(&this[37].i64[1], v14);
  v16 = this + 39;
  std::vector<std::vector<std::vector<float>>>::resize(this[39].i64, v14);
  if ((_DWORD)v14)
  {
    v17 = 0;
    while (1)
    {
      if (!this[33].i8[0])
      {
        v18 = (VPTimeFreqConverter *)operator new();
        VPTimeFreqConverter::VPTimeFreqConverter(v18, 2, v11);
        __p[0] = v18;
        v19 = (VPTimeFreqConverter **)this[35].i64[1];
        v20 = this[36].u64[0];
        if ((unint64_t)v19 >= v20)
        {
          v21 = this[35].i64[0];
          v22 = ((uint64_t)v19 - v21) >> 3;
          v23 = v22 + 1;
          if ((unint64_t)(v22 + 1) >> 61)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          v24 = v20 - v21;
          if (v24 >> 2 > v23)
            v23 = v24 >> 2;
          if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
            v25 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v25 = v23;
          v56 = this + 36;
          if (v25)
            v25 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v25);
          else
            v26 = 0;
          v27 = (VPTimeFreqConverter **)(v25 + 8 * v22);
          v28 = v25 + 8 * v26;
          v55 = v28;
          __p[0] = 0;
          *v27 = v18;
          v29 = v27 + 1;
          v54.i64[1] = (uint64_t)(v27 + 1);
          v30 = (_QWORD *)this[35].i64[1];
          v31 = (_QWORD *)this[35].i64[0];
          if (v30 == v31)
          {
            v34 = 0;
            v33 = vdupq_n_s64((unint64_t)v30);
          }
          else
          {
            do
            {
              v32 = (VPTimeFreqConverter *)*--v30;
              *v30 = 0;
              *--v27 = v32;
            }
            while (v30 != v31);
            v33 = this[35];
            v29 = (_QWORD *)v54.i64[1];
            v28 = v55;
            v34 = (VPTimeFreqConverter *)__p[0];
          }
          this[35].i64[0] = (uint64_t)v27;
          this[35].i64[1] = (uint64_t)v29;
          v54 = v33;
          v35 = this[36].i64[0];
          this[36].i64[0] = v28;
          v55 = v35;
          v53 = (void *)v33.i64[0];
          std::__split_buffer<std::unique_ptr<VPTimeFreqConverter>>::~__split_buffer((uint64_t)&v53);
          this[35].i64[1] = (uint64_t)v29;
          if (v34)
          {
            VPTimeFreqConverter::~VPTimeFreqConverter(v34);
            MEMORY[0x1BCC95CEC]();
          }
        }
        else
        {
          *v19 = v18;
          this[35].i64[1] = (uint64_t)(v19 + 1);
        }
        if (!*(_BYTE *)(*(_QWORD *)(this[35].i64[0] + 8 * v17) + 184))
          return 4294967246;
      }
      std::vector<std::vector<float>>::resize((uint64_t *)(*v15 + 24 * v17), 2uLL);
      std::vector<std::vector<float>>::resize((uint64_t *)(v16->i64[0] + 24 * v17), 2uLL);
      v36 = 0;
      v37 = 1;
      do
      {
        v38 = v37;
        v39 = 3 * v36;
        v40 = *(_QWORD *)(*v15 + 24 * v17) + 24 * v36;
        LODWORD(v53) = 0;
        std::vector<float>::resize(v40, (v11 + 1), &v53);
        v41 = *(_QWORD *)(v16->i64[0] + 24 * v17) + 8 * v39;
        LODWORD(v53) = 0;
        std::vector<float>::resize(v41, (v11 + 1), &v53);
        v37 = 0;
        v36 = 1;
      }
      while ((v38 & 1) != 0);
      if (++v17 == v14)
        goto LABEL_46;
    }
  }
  else
  {
LABEL_46:
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, float))(*(_QWORD *)this[36].i64[1] + 16))(this[36].i64[1], 2, this[34].u32[2], v11, (float)this[46].u32[0]);
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(int64x2_t *, _QWORD, _QWORD))(this->i64[0] + 72))(this, 0, 0);
      if (!(_DWORD)result)
      {
        AUBSS1::UpdateState((AUBSS1 *)this);
        std::string::basic_string[abi:ne180100]<0>(&v53, "com.apple.coreaudio");
        std::string::basic_string[abi:ne180100]<0>(__p, "bss_bypass");
        v42 = GetPreference<BOOL>((const UInt8 *)&v53, (const UInt8 *)__p);
        if (v45 < 0)
          operator delete(__p[0]);
        if (v54.i8[15] < 0)
          operator delete(v53);
        result = 0;
        v43 = v42;
        if (v42 <= 0x100u)
          v43 = 0;
        this[34].i8[0] = v43;
      }
    }
  }
  return result;
}

void sub_1B6153D94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a15 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(exception_object);
}

void AUBSS1::Cleanup(AUBSS1 *this)
{
  OpaqueAudioComponentInstance *v2;
  NSObject *v3;
  OSStatus v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 83);
  if (v2)
  {
    if (AudioUnitUninitialize(v2))
    {
      if (AUBSS1LogScope(void)::once != -1)
        dispatch_once(&AUBSS1LogScope(void)::once, &__block_literal_global_1420);
      if (AUBSS1LogScope(void)::scope)
      {
        v3 = *(NSObject **)AUBSS1LogScope(void)::scope;
        if (!*(_QWORD *)AUBSS1LogScope(void)::scope)
          return;
      }
      else
      {
        v3 = MEMORY[0x1E0C81028];
      }
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        return;
      v6 = 136315394;
      v7 = "AUBSS1.cpp";
      v8 = 1024;
      v9 = 296;
      v5 = "%25s:%-5d ERROR: Failed to uninitialized internal AU.";
LABEL_20:
      _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_ERROR, v5, (uint8_t *)&v6, 0x12u);
      return;
    }
    v4 = AudioComponentInstanceDispose(*((AudioComponentInstance *)this + 83));
    *((_QWORD *)this + 83) = 0;
    if (!v4)
      return;
    if (AUBSS1LogScope(void)::once != -1)
      dispatch_once(&AUBSS1LogScope(void)::once, &__block_literal_global_1420);
    if (AUBSS1LogScope(void)::scope)
    {
      v3 = *(NSObject **)AUBSS1LogScope(void)::scope;
      if (!*(_QWORD *)AUBSS1LogScope(void)::scope)
        return;
    }
    else
    {
      v3 = MEMORY[0x1E0C81028];
    }
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      return;
    v6 = 136315394;
    v7 = "AUBSS1.cpp";
    v8 = 1024;
    v9 = 304;
    v5 = "%25s:%-5d ERROR: Failed to dispose of internal AU.";
    goto LABEL_20;
  }
}

double AUBSS1::Reset(BlockProcessor **this, AudioUnitScope a2, AudioUnitElement a3)
{
  BlockProcessor *v6;
  double result;
  BlockProcessor *v8;
  OpaqueAudioComponentInstance *v9;

  AUBSS1::UpdateState((AUBSS1 *)this);
  v6 = this[73];
  if (!v6 || !(*(unsigned int (**)(BlockProcessor *))(*(_QWORD *)v6 + 24))(v6))
  {
    v8 = this[74];
    if (v8)
      BlockProcessor::Reset(v8);
    v9 = this[83];
    if (!v9 || !AudioUnitReset(v9, a2, a3))
    {
      result = 0.0;
      *((_OWORD *)this + 44) = 0u;
      *((_OWORD *)this + 45) = 0u;
      *((_OWORD *)this + 42) = 0u;
      *((_OWORD *)this + 43) = 0u;
    }
  }
  return result;
}

uint64_t AUBSS1::GetPropertyInfo(AUBSS1 *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  BOOL v7;

  if (a3)
    return 4294956417;
  if (a2 == 21)
  {
    v7 = 1;
  }
  else
  {
    if (a2 != 3700)
      return 4294956417;
    v7 = 0;
  }
  result = 0;
  *a6 = v7;
  *a5 = 4;
  return result;
}

uint64_t AUBSS1::GetProperty(AUBSS1 *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  int v6;

  if (a3)
    return 4294956417;
  if (a2 == 3700)
  {
    v6 = *((unsigned __int8 *)this + 376);
  }
  else
  {
    if (a2 != 21)
      return 4294956417;
    v6 = *((_DWORD *)this + 135);
  }
  result = 0;
  *a5 = v6;
  return result;
}

uint64_t AUBSS1::SetProperty(AUBSS1 *this, int a2, int a3, unsigned int a4, _BYTE *a5, unsigned int a6)
{
  uint64_t result;

  if (a3)
    return 4294956417;
  if (a2 == 3700)
  {
    if (a6 >= 4)
    {
      result = 0;
      *((_BYTE *)this + 376) = *a5;
    }
    else
    {
      return 4294956445;
    }
  }
  else
  {
    if (a2 != 21)
      return 4294956417;
    result = 0;
    *((_DWORD *)this + 135) = *(_DWORD *)a5;
  }
  return result;
}

uint64_t AUBSS1::SetParameter(AUBSS1 *this, unsigned int a2, int a3, float a4)
{
  uint64_t result;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;

  if (a3)
    return 4294956418;
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  ausdk::AUElement::SetParameter(v9, a2, a4, 0);
  result = 0;
  ++*((_DWORD *)this + 133);
  return result;
}

uint64_t AUBSS1::CanScheduleParameters(AUBSS1 *this)
{
  return 0;
}

uint64_t AUBSS1::ProcessBufferLists(AUBSS1 *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, uint64_t a5)
{
  AudioBufferList *v6;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x1E0C80C00];
  v6 = a4;
  v7[0] = a3;
  return (*(uint64_t (**)(AUBSS1 *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, AudioBufferList **))(*(_QWORD *)this + 184))(this, a2, a5, 1, v7, 1, &v6);
}

uint64_t AUBSS1::ProcessMultipleBufferLists(AUBSS1 *this, unsigned int *a2, unsigned int a3, unsigned int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7)
{
  int v12;
  uint64_t result;
  int v14;
  const AudioBufferList *v15;
  uint64_t v16;
  unint64_t v17;
  AudioBufferList *v18;
  uint64_t v19;
  unint64_t v20;
  BlockProcessor *v21;

  v12 = *((unsigned __int8 *)this + 376);
  if (*((_BYTE *)this + 376) && *((_DWORD *)this + 84) != a3)
    return 4294956422;
  result = 4294956449;
  if (a5)
  {
    if (a7)
    {
      result = 4294956428;
      if (a4 <= 2 && a4 == a6)
      {
        v14 = *((_DWORD *)this + 137);
        v15 = *a5;
        if (v14 == (*a5)->mNumberBuffers && v14 == (*a7)->mNumberBuffers)
        {
          if (*((_DWORD *)this + 135) || *((_BYTE *)this + 544))
          {
            if (v14)
            {
              v16 = 0;
              v17 = 0;
              do
              {
                memcpy((*a7)->mBuffers[v16].mData, v15->mBuffers[v16].mData, (*a7)->mBuffers[v16].mDataByteSize);
                ++v17;
                v15 = *a5;
                ++v16;
              }
              while (v17 < (*a5)->mNumberBuffers);
            }
            if (a4 == 2)
            {
              v18 = a7[1];
              if (v18->mNumberBuffers)
              {
                v19 = 0;
                v20 = 0;
                do
                {
                  memcpy(v18->mBuffers[v19].mData, a5[1]->mBuffers[v19].mData, v18->mBuffers[v19].mDataByteSize);
                  result = 0;
                  ++v20;
                  v18 = a7[1];
                  ++v19;
                }
                while (v20 < v18->mNumberBuffers);
                return result;
              }
            }
            return 0;
          }
          if (*((_DWORD *)this + 134) != *((_DWORD *)this + 133))
          {
            AUBSS1::UpdateState(this);
            *((_DWORD *)this + 134) = *((_DWORD *)this + 133);
            v12 = *((unsigned __int8 *)this + 376);
          }
          if (v12)
          {
            if (*((_BYTE *)this + 528))
              AUBSS1::CopyToInternalBuffers(this, a3, a5);
            else
              AUBSS1::TimeToFreqAndCopyToInternalBuffers(this, a5);
            AUBSS1::ScaleProcessInverseScale(this);
            if (*((_BYTE *)this + 528))
              AUBSS1::CopyFromInternalBuffers(this, a3, a7);
            else
              AUBSS1::FreqToTimeAndCopyFromInternalBuffers((uint64_t)this, a7);
            if (a4 != 2)
              return 0;
            if (*((_DWORD *)this + 137) == a5[1]->mNumberBuffers && a7[1]->mNumberBuffers == 1)
              return AUBSS1::SideChainProcess(this, a3, a5, a7);
            else
              return 4294956428;
          }
          else
          {
            v21 = (BlockProcessor *)*((_QWORD *)this + 74);
            if (v21)
              return BlockProcessor::Process(v21, a3, a5, a7);
            else
              return 4294956429;
          }
        }
      }
    }
  }
  return result;
}

uint64_t AUBSS1::Render(AUBSS1 *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  __int128 v8;
  __int128 v9;
  __int128 v10;
  ausdk::AUInputElement *Element;
  uint64_t result;
  uint64_t v13;
  uint64_t BufferList;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;

  v8 = *(_OWORD *)&a3->mSampleTime;
  v9 = *(_OWORD *)&a3->mRateScalar;
  v10 = *(_OWORD *)&a3->mSMPTETime.mHours;
  *((_OWORD *)this + 44) = *(_OWORD *)&a3->mSMPTETime.mSubframes;
  *((_OWORD *)this + 45) = v10;
  *((_OWORD *)this + 42) = v8;
  *((_OWORD *)this + 43) = v9;
  if (*((_BYTE *)this + 376) && *((_DWORD *)this + 84) != (_DWORD)a4)
    return 4294956422;
  if (!ausdk::AUBase::HasInput(this, 0))
    return 4294956420;
  v17 = 0;
  Element = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 80), 0);
  result = ausdk::AUInputElement::PullInput(Element, &v17, a3, 0, a4);
  if (!(_DWORD)result)
  {
    v13 = ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 80), 0);
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v13 + 144));
    v15 = ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 128), 0);
    v16 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v15 + 144));
    return (*(uint64_t (**)(AUBSS1 *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 176))(this, a2, BufferList, v16, a4);
  }
  return result;
}

uint64_t AUBSS1::BusCountWritable(AUBSS1 *this)
{
  return 1;
}

uint64_t AUBSS1::SetBusCount(AUBSS1 *this, int a2, unsigned int a3)
{
  int64x2_t *v3;
  uint64_t v4;

  if (a2 == 1 && a3 <= 2)
  {
    v3 = (int64x2_t *)((char *)this + 80);
LABEL_7:
    ausdk::AUScope::SetNumberOfElements(v3, a3);
    return 0;
  }
  v4 = 4294956445;
  if (a2 == 2 && a3 <= 2)
  {
    v3 = (int64x2_t *)((char *)this + 128);
    goto LABEL_7;
  }
  return v4;
}

uint64_t AUBSS1::GetParameterList(AUBSS1 *this, int a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int v4;
  uint64_t result;

  if (a2)
  {
    v4 = 0;
    result = 4294956418;
  }
  else
  {
    result = 0;
    if (a3)
    {
      *(_OWORD *)a3 = xmmword_1B6626920;
      *((_OWORD *)a3 + 1) = xmmword_1B66A0770;
    }
    v4 = 8;
  }
  *a4 = v4;
  return result;
}

uint64_t AUBSS1::GetParameterInfo(AUBSS1 *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v6;
  uint64_t v7;
  int v8;
  const __CFString *v9;
  uint64_t v10;

  if (a2)
    return 4294956430;
  buffer->flags = 0;
  buffer->unitName = 0;
  switch(a3)
  {
    case 0:
      v6 = CFSTR("Bypass BSS");
      goto LABEL_7;
    case 1:
      v6 = CFSTR("Run MDNS (Test only)");
LABEL_7:
      buffer->cfNameString = v6;
      buffer->flags = 0x8000000;
      CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Boolean;
      *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
      buffer->defaultValue = 0.0;
      goto LABEL_17;
    case 2:
      buffer->cfNameString = CFSTR("Scaling");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Scaling"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_LinearGain;
      buffer->defaultValue = 1.0;
      v7 = 0x461C400000000000;
      goto LABEL_16;
    case 3:
      v8 = 1073774592;
      v9 = CFSTR("+X Separation");
      goto LABEL_11;
    case 4:
      v8 = 1073774592;
      v9 = CFSTR("-X Separation");
LABEL_11:
      buffer->cfNameString = v9;
      buffer->flags = 0x8000000;
      CFStringGetCString(v9, buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultValue = 0.0;
      v10 = 0x41A0000000000000;
      goto LABEL_14;
    case 5:
      v8 = 1073774592;
      buffer->cfNameString = CFSTR("Update Threshold");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Update Threshold"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultValue = 0.0;
      v10 = 0x4120000000000000;
      goto LABEL_14;
    case 6:
      v8 = 1073774592;
      buffer->cfNameString = CFSTR("Noise SPL Estimate");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Noise SPL Estimate"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Decibels;
      buffer->defaultValue = 40.0;
      v10 = 0x42C8000041A00000;
LABEL_14:
      *(_QWORD *)&buffer->minValue = v10;
      goto LABEL_18;
    case 7:
      buffer->cfNameString = CFSTR("Separation Mode");
      buffer->flags = 0x8000000;
      CFStringGetCString(CFSTR("Separation Mode"), buffer->name, 52, 0x8000100u);
      buffer->unit = kAudioUnitParameterUnit_Indexed;
      buffer->defaultValue = 0.0;
      v7 = 0x3F80000000000000;
LABEL_16:
      *(_QWORD *)&buffer->minValue = v7;
LABEL_17:
      v8 = -1073741824;
LABEL_18:
      result = 0;
      buffer->flags |= v8;
      break;
    default:
      result = 4294956418;
      break;
  }
  return result;
}

uint64_t AUBSS1::RestoreState(OpaqueAudioComponentInstance **this, const void *a2)
{
  uint64_t result;

  result = ausdk::AUBase::RestoreState(this, a2);
  if (!(_DWORD)result)
    ++*((_DWORD *)this + 133);
  return result;
}

uint64_t AUBSS1::GetParameterValueStrings(AUBSS1 *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  NSObject *v5;
  const __CFArray *v7;
  _BOOL4 v8;
  _BYTE v9[18];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    if (a2)
      return 4294956430;
    if (a3 == 7)
    {
      *(_OWORD *)v9 = xmmword_1E69C9088;
      v7 = CFArrayCreate(0, (const void **)v9, 2, 0);
      result = 0;
      *a4 = v7;
      return result;
    }
    return 0;
  }
  if (AUBSS1LogScope(void)::once != -1)
    dispatch_once(&AUBSS1LogScope(void)::once, &__block_literal_global_1420);
  if (AUBSS1LogScope(void)::scope)
  {
    v5 = *(NSObject **)AUBSS1LogScope(void)::scope;
    if (!*(_QWORD *)AUBSS1LogScope(void)::scope)
      return 0;
  }
  else
  {
    v5 = MEMORY[0x1E0C81028];
  }
  v8 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (!v8)
    return result;
  *(_DWORD *)v9 = 136315394;
  *(_QWORD *)&v9[4] = "AUBSS1.cpp";
  *(_WORD *)&v9[12] = 1024;
  *(_DWORD *)&v9[14] = 658;
  _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEFAULT, "%25s:%-5d ERROR: Failed accessing strings in GetParameterValueStrings.", v9, 0x12u);
  return 0;
}

double AUBSS1::GetLatency(AUBSS1 *this)
{
  double result;
  double v3;
  unint64_t v4;
  double v5;
  uint64_t v6;

  if (*((_BYTE *)this + 376))
  {
    result = 0.0;
    if (*((_BYTE *)this + 528))
      return result;
    v3 = *(double *)(ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 128), 0) + 80);
    LODWORD(v4) = *((_DWORD *)this + 84);
    v5 = (double)v4;
  }
  else
  {
    v3 = *(double *)(ausdk::AUScope::SafeGetElement((AUBSS1 *)((char *)this + 128), 0) + 80);
    if (v3 == 16000.0)
    {
      v6 = 0x4078000000000000;
    }
    else if (v3 == 8000.0)
    {
      v6 = 0x4068000000000000;
    }
    else if (v3 == 24000.0)
    {
      v6 = 0x407E000000000000;
    }
    else
    {
      if (v3 != 48000.0)
      {
        v5 = 384.0;
        if (v3 == 44100.0)
          v5 = 960.0;
        return v5 / v3;
      }
      v6 = 0x408E000000000000;
    }
    v5 = *(double *)&v6;
  }
  return v5 / v3;
}

double AUBSS1::GetTailTime(AUBSS1 *this)
{
  return 0.0;
}

uint64_t AUBSS1::SupportsTail(AUBSS1 *this)
{
  return 1;
}

BOOL AUBSS1::StreamFormatWritable(AUBSS1 *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUBSS1::SupportedNumChannels(AUBSS1 *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUBSS1::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 2;
}

uint64_t AUBSS1::ValidFormat(AUBSS1 *this, const AudioStreamBasicDescription *a2, int a3, AudioStreamBasicDescription *a4)
{
  uint64_t v4;
  uint64_t v5;
  UInt32 mChannelsPerFrame;
  BOOL v8;
  BOOL v9;
  uint64_t result;
  __int128 v12;
  _OWORD v13[2];
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  if (((_DWORD)a2 - 1) > 1)
    return 0;
  v16 = v4;
  v17 = v5;
  mChannelsPerFrame = a4->mChannelsPerFrame;
  if ((_DWORD)a2 == 1 && mChannelsPerFrame < 2)
    return 0;
  if ((_DWORD)a2 == 2 && !a3 && mChannelsPerFrame < 2)
    return 0;
  v8 = mChannelsPerFrame > 1 && a3 == 1;
  v9 = v8 && (_DWORD)a2 == 2;
  if (v9 || mChannelsPerFrame > 2)
    return 0;
  result = ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2);
  if ((_DWORD)result)
  {
    if ((a4->mFormatFlags & 0x20) != 0)
      return 1;
    result = mChannelsPerFrame == 1;
  }
  if ((result & 1) == 0 && a4->mFormatID == 1718773105)
  {
    v12 = *(_OWORD *)&a4->mBytesPerPacket;
    v13[0] = *(_OWORD *)&a4->mSampleRate;
    v13[1] = v12;
    v14 = *(_QWORD *)&a4->mBitsPerChannel;
    DWORD2(v13[0]) = 1819304813;
    v15 = 0;
    LODWORD(result) = CAStreamBasicDescription::IdentifyCommonPCMFormat(v13, &v15, 0);
    if (v15 == 4)
      return result;
    else
      return 0;
  }
  return result;
}

os_log_t ___ZL14AUBSS1LogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "aubss1");
  *v0 = result;
  AUBSS1LogScope(void)::scope = (uint64_t)v0;
  return result;
}

void AUBSS1::UpdateState(AUBSS1 *this)
{
  uint64_t v2;
  ausdk::AUElement *v3;
  ausdk::AUElement **v4;
  uint64_t v5;
  ausdk::AUElement *v6;
  ausdk::AUElement **v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  float Parameter;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  float v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  float v22;
  uint64_t v23;
  ausdk::AUElement *v24;
  ausdk::AUElement **v25;
  float v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  float v30;

  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    v3 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  else
  {
    v4 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v4)
      v3 = 0;
    else
      v3 = *v4;
  }
  *((_BYTE *)this + 648) = ausdk::AUElement::GetParameter(v3, 1u) != 0.0;
  v5 = *((_QWORD *)this + 9);
  if (v5)
  {
    v6 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
  }
  else
  {
    v7 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v7)
      v6 = 0;
    else
      v6 = *v7;
  }
  *((_DWORD *)this + 163) = ausdk::AUElement::GetParameter(v6, 0);
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  *((float *)this + 164) = ausdk::AUElement::GetParameter(v9, 2u);
  if (*((_QWORD *)this + 73))
  {
    v11 = *((_QWORD *)this + 9);
    if (v11)
    {
      v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
    }
    else
    {
      v13 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v13)
        v12 = 0;
      else
        v12 = *v13;
    }
    Parameter = ausdk::AUElement::GetParameter(v12, 3u);
    (*(void (**)(_QWORD, _QWORD, float))(**((_QWORD **)this + 73) + 48))(*((_QWORD *)this + 73), 0, Parameter);
    v15 = *((_QWORD *)this + 9);
    if (v15)
    {
      v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
    }
    else
    {
      v17 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v17)
        v16 = 0;
      else
        v16 = *v17;
    }
    v18 = ausdk::AUElement::GetParameter(v16, 4u);
    (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)this + 73) + 48))(*((_QWORD *)this + 73), 1, v18);
    v19 = *((_QWORD *)this + 9);
    if (v19)
    {
      v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
    }
    else
    {
      v21 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v21)
        v20 = 0;
      else
        v20 = *v21;
    }
    v22 = ausdk::AUElement::GetParameter(v20, 5u);
    (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)this + 73) + 48))(*((_QWORD *)this + 73), 2, v22);
    v23 = *((_QWORD *)this + 9);
    if (v23)
    {
      v24 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
    }
    else
    {
      v25 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v25)
        v24 = 0;
      else
        v24 = *v25;
    }
    v26 = ausdk::AUElement::GetParameter(v24, 6u);
    (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)this + 73) + 48))(*((_QWORD *)this + 73), 3, v26);
    v27 = *((_QWORD *)this + 9);
    if (v27)
    {
      v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
    }
    else
    {
      v29 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v29)
        v28 = 0;
      else
        v28 = *v29;
    }
    v30 = ausdk::AUElement::GetParameter(v28, 7u);
    (*(void (**)(_QWORD, uint64_t, float))(**((_QWORD **)this + 73) + 48))(*((_QWORD *)this + 73), 4, v30);
  }
}

float AUBSS1::TimeToFreqAndCopyToInternalBuffers(AUBSS1 *this, const AudioBufferList **a2)
{
  uint64_t v2;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  float **v9;
  float *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  float *v15;
  float result;
  DSPSplitComplex v17;

  v2 = (uint64_t)*a2;
  if ((*a2)->mNumberBuffers)
  {
    v5 = 0;
    v6 = 0;
    v7 = *((_QWORD *)this + 75);
    v8 = 16;
    do
    {
      v9 = *(float ***)(v7 + v5);
      v10 = *v9;
      v11 = v9[3];
      v17.realp = v10;
      v17.imagp = v11;
      VPTimeFreqConverter::Analyze(*(VPTimeFreqConverter **)(*((_QWORD *)this + 70) + 8 * v6), *(const float **)(v2 + v8), &v17);
      v7 = *((_QWORD *)this + 75);
      v12 = *(uint64_t **)(v7 + v5);
      v13 = *v12;
      v14 = (unint64_t)(v12[1] - *v12) >> 2;
      v15 = (float *)v12[3];
      result = *v15;
      LODWORD(v14) = v14 - 1;
      *(float *)(v13 + 4 * v14) = *v15;
      v15[v14] = 0.0;
      *v15 = 0.0;
      ++v6;
      v2 = (uint64_t)*a2;
      v5 += 24;
      v8 += 16;
    }
    while (v6 < (*a2)->mNumberBuffers);
  }
  return result;
}

float AUBSS1::CopyToInternalBuffers(AUBSS1 *this, unsigned int a2, const AudioBufferList **a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;
  unint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  _QWORD *v14;
  float *v15;
  float result;
  unsigned int v17;

  v3 = *((_QWORD *)this + 76);
  v4 = *((_QWORD *)this + 75);
  if (v3 != v4)
  {
    v7 = 0;
    v8 = 0;
    v9 = 4 * a2;
    v10 = 2 * a2;
    v11 = 16;
    v12 = a2;
    do
    {
      if (a2)
      {
        v13 = *(char **)((char *)&(*a3)->mNumberBuffers + v11);
        memmove(**(void ***)(v4 + v7), v13, v9);
        memmove(*(void **)(*(_QWORD *)(*((_QWORD *)this + 75) + v7) + 24), &v13[4 * v12], 4 * v10 - 4 * v12);
        v4 = *((_QWORD *)this + 75);
        v3 = *((_QWORD *)this + 76);
      }
      v14 = *(_QWORD **)(v4 + v7);
      v15 = (float *)v14[3];
      result = *v15;
      v17 = *((_DWORD *)this + 138) - 1;
      *(float *)(*v14 + 4 * v17) = *v15;
      v15[v17] = 0.0;
      *v15 = 0.0;
      ++v8;
      v7 += 24;
      v11 += 16;
    }
    while (v8 < 0xAAAAAAAAAAAAAAABLL * ((v3 - v4) >> 3));
  }
  return result;
}

void AUBSS1::ScaleProcessInverseScale(AUBSS1 *this)
{
  uint64_t v2;
  float v3;
  uint64_t v4;
  unint64_t v5;
  float *v6;
  float *v7;
  uint64_t v8;
  unint64_t v9;
  float *v10;
  float *v11;
  float v12;
  float __B;

  v2 = *((_QWORD *)this + 73);
  if (v2)
  {
    v3 = *((float *)this + 164);
    v12 = 1.0 / v3;
    __B = v3;
    if (v3 != 1.0 && *((_DWORD *)this + 137))
    {
      v4 = 0;
      v5 = 0;
      do
      {
        v6 = **(float ***)(*((_QWORD *)this + 75) + v4);
        vDSP_vsmul(v6, 1, &__B, v6, 1, *((unsigned int *)this + 138));
        v7 = *(float **)(*(_QWORD *)(*((_QWORD *)this + 75) + v4) + 24);
        vDSP_vsmul(v7, 1, &__B, v7, 1, *((unsigned int *)this + 138));
        ++v5;
        v4 += 24;
      }
      while (v5 < *((unsigned int *)this + 137));
      v2 = *((_QWORD *)this + 73);
    }
    (*(void (**)(uint64_t, char *, char *))(*(_QWORD *)v2 + 32))(v2, (char *)this + 600, (char *)this + 624);
    if (*((_DWORD *)this + 163))
      std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)this + 624, *((uint64_t **)this + 75), *((uint64_t **)this + 76), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 76) - *((_QWORD *)this + 75)) >> 3));
    if (__B != 1.0 && *((_DWORD *)this + 137))
    {
      v8 = 0;
      v9 = 0;
      do
      {
        v10 = **(float ***)(*((_QWORD *)this + 78) + v8);
        vDSP_vsmul(v10, 1, &v12, v10, 1, *((unsigned int *)this + 138));
        v11 = *(float **)(*(_QWORD *)(*((_QWORD *)this + 78) + v8) + 24);
        vDSP_vsmul(v11, 1, &v12, v11, 1, *((unsigned int *)this + 138));
        ++v9;
        v8 += 24;
      }
      while (v9 < *((unsigned int *)this + 137));
    }
  }
  else
  {
    std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)this + 624, *((uint64_t **)this + 75), *((uint64_t **)this + 76), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 76) - *((_QWORD *)this + 75)) >> 3));
  }
}

uint64_t AUBSS1::FreqToTimeAndCopyFromInternalBuffers(uint64_t this, AudioBufferList **a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  int v10;
  float *v11;
  DSPSplitComplex v12;

  v2 = (uint64_t)*a2;
  if ((*a2)->mNumberBuffers)
  {
    v4 = this;
    v5 = 0;
    v6 = 0;
    v7 = 16;
    do
    {
      v8 = *(_QWORD *)(*(_QWORD *)(v4 + 624) + v5);
      v9 = *(float **)v8;
      v10 = *(_DWORD *)(*(_QWORD *)v8 + 4 * (((*(_QWORD *)(v8 + 8) - *(_QWORD *)v8) >> 2) - 1));
      v11 = *(float **)(v8 + 24);
      *(_DWORD *)v11 = v10;
      v12.realp = v9;
      v12.imagp = v11;
      this = VPTimeFreqConverter::Synthesize(*(VPTimeFreqConverter **)(*(_QWORD *)(v4 + 560) + 8 * v6++), &v12, *(float **)(v2 + v7));
      v2 = (uint64_t)*a2;
      v7 += 16;
      v5 += 24;
    }
    while (v6 < (*a2)->mNumberBuffers);
  }
  return this;
}

_QWORD *AUBSS1::CopyFromInternalBuffers(_QWORD *this, unsigned int a2, AudioBufferList **a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;

  v3 = this[78];
  if (this[79] != v3)
  {
    v5 = (uint64_t)this;
    v6 = 0;
    v7 = 0;
    v8 = 16;
    v9 = a2;
    do
    {
      v10 = *(_QWORD *)(v3 + v6);
      v11 = *(const void **)v10;
      v12 = *(_QWORD *)(v10 + 8);
      v13 = *(_DWORD **)(v10 + 24);
      *v13 = *(_DWORD *)(*(_QWORD *)v10 + 4 * (*(_DWORD *)(v5 + 552) - 1));
      v14 = *(_QWORD *)((char *)&(*a3)->mNumberBuffers + v8);
      if ((const void *)(v12 - 4) != v11)
      {
        this = memmove(*(void **)((char *)&(*a3)->mNumberBuffers + v8), v11, v12 - 4 - (_QWORD)v11);
        v3 = *(_QWORD *)(v5 + 624);
        v10 = *(_QWORD *)(v3 + v6);
        v13 = *(_DWORD **)(v10 + 24);
      }
      v15 = *(_QWORD *)(v10 + 32) - 4;
      if ((_DWORD *)v15 != v13)
      {
        this = memmove((void *)(v14 + 4 * v9), v13, v15 - (_QWORD)v13);
        v3 = *(_QWORD *)(v5 + 624);
      }
      ++v7;
      v6 += 24;
      v8 += 16;
    }
    while (v7 < 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v5 + 632) - v3) >> 3));
  }
  return this;
}

uint64_t AUBSS1::SideChainProcess(AUBSS1 *this, unsigned int a2, const AudioBufferList **a3, AudioBufferList **a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  _QWORD *v12;
  _DWORD *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  _DWORD *v20;
  char *mData;
  uint64_t *v22;
  uint64_t v23;
  AudioBufferList *v24;

  v6 = *((_QWORD *)this + 76);
  v7 = *((_QWORD *)this + 75);
  if (v6 != v7)
  {
    v8 = 0;
    v9 = 0;
    v10 = 16;
    do
    {
      if (a2)
      {
        v11 = *(char **)((char *)&a3[1]->mNumberBuffers + v10);
        memmove(**(void ***)(v7 + v8), v11, 4 * a2);
        memmove(*(void **)(*(_QWORD *)(*((_QWORD *)this + 75) + v8) + 24), &v11[4 * a2], 8 * a2 - 4 * a2);
        v7 = *((_QWORD *)this + 75);
        v6 = *((_QWORD *)this + 76);
      }
      v12 = *(_QWORD **)(v7 + v8);
      v13 = (_DWORD *)v12[3];
      v14 = *((_DWORD *)this + 138) - 1;
      *(_DWORD *)(*v12 + 4 * v14) = *v13;
      v13[v14] = 0;
      *v13 = 0;
      ++v9;
      v8 += 24;
      v10 += 16;
    }
    while (v9 < 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3));
  }
  v15 = *((_QWORD *)this + 73);
  if (v15)
    v16 = (*(uint64_t (**)(uint64_t, char *, char *))(*(_QWORD *)v15 + 40))(v15, (char *)this + 600, (char *)this + 624);
  else
    v16 = 0;
  v17 = **((_QWORD **)this + 78);
  v18 = *(const void **)v17;
  v19 = *(_QWORD *)(v17 + 8);
  v20 = *(_DWORD **)(v17 + 24);
  *v20 = *(_DWORD *)(*(_QWORD *)v17 + 4 * (*((_DWORD *)this + 138) - 1));
  mData = (char *)a4[1]->mBuffers[0].mData;
  if ((const void *)(v19 - 4) != v18)
  {
    memmove(a4[1]->mBuffers[0].mData, v18, v19 - 4 - (_QWORD)v18);
    v22 = (uint64_t *)*((_QWORD *)this + 78);
    v17 = *v22;
    v20 = *(_DWORD **)(*v22 + 24);
  }
  v23 = *(_QWORD *)(v17 + 32) - 4;
  if ((_DWORD *)v23 != v20)
    memmove(&mData[4 * a2], v20, v23 - (_QWORD)v20);
  v24 = a4[1];
  if (v24->mNumberBuffers == 2)
    bzero(*(void **)&v24[1].mBuffers[0].mNumberChannels, *(&v24[1].mNumberBuffers + 1));
  return v16;
}

uint64_t AUBSS1::BlockProcessClassFunc(AUBSS1 *this, void *a2, const AudioBufferList **a3, AudioBufferList **a4, AudioBufferList **a5)
{
  AUBSS1::TimeToFreqAndCopyToInternalBuffers(this, a3);
  AUBSS1::ScaleProcessInverseScale(this);
  AUBSS1::FreqToTimeAndCopyFromInternalBuffers((uint64_t)this, a4);
  return 0;
}

void std::make_unique[abi:ne180100]<BlockProcessor,int,unsigned int *,int,unsigned int *,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUBSS1 *>(BlockProcessor **a1, int *a2, const unsigned int **a3, int *a4, const unsigned int **a5, int *a6, void **a7)
{
  BlockProcessor *v14;

  v14 = (BlockProcessor *)operator new();
  BlockProcessor::BlockProcessor(v14, *a2, *a3, *a4, *a5, *a6, (int (*)(void *, unsigned int, const AudioBufferList **, AudioBufferList **))AUBSS1::BlockProcessClassFunc, *a7);
  *a1 = v14;
}

void sub_1B61555F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x1080C40622722D2);
  _Unwind_Resume(a1);
}

uint64_t GetPreference<BOOL>(const UInt8 *a1, const UInt8 *a2)
{
  int v4;
  const UInt8 *v5;
  CFIndex v6;
  CFStringRef v7;
  int v8;
  const UInt8 *v9;
  CFIndex v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFNumber *v13;
  _BOOL4 v14;
  int v15;
  const UInt8 *v16;
  int v17;
  const UInt8 *v18;
  char *v19;
  const UInt8 *v20;
  const UInt8 *v21;
  void **v22;
  int v23;
  const UInt8 *v24;
  const UInt8 *v25;
  std::runtime_error *exception;
  std::runtime_error *v28;
  void *__p[2];
  char v30;
  const __CFNumber *v31;
  _BYTE buf[12];
  __int16 v33;
  int v34;
  __int16 v35;
  const UInt8 *v36;
  __int16 v37;
  const UInt8 *v38;
  __int16 v39;
  void **v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v4 = *((char *)a1 + 23);
  if (v4 >= 0)
    v5 = a1;
  else
    v5 = *(const UInt8 **)a1;
  if (v4 >= 0)
    v6 = a1[23];
  else
    v6 = *((_QWORD *)a1 + 1);
  v7 = CFStringCreateWithBytes(0, v5, v6, 0x8000100u, 0);
  __p[0] = (void *)v7;
  if (!v7)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  v8 = *((char *)a2 + 23);
  if (v8 >= 0)
    v9 = a2;
  else
    v9 = *(const UInt8 **)a2;
  if (v8 >= 0)
    v10 = a2[23];
  else
    v10 = *((_QWORD *)a2 + 1);
  v11 = CFStringCreateWithBytes(0, v9, v10, 0x8000100u, 0);
  v12 = v11;
  *(_QWORD *)buf = v11;
  if (!v11)
  {
    v28 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v28, "Could not construct");
  }
  v13 = (const __CFNumber *)CFPreferencesCopyAppValue(v11, v7);
  v31 = v13;
  CFRelease(v12);
  CFRelease(v7);
  if (v13)
  {
    v14 = applesauce::CF::convert_to<BOOL,0>(v13);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v15 = *((char *)a1 + 23);
      v16 = *(const UInt8 **)a1;
      v17 = *((char *)a2 + 23);
      v18 = *(const UInt8 **)a2;
      if (v14)
        v19 = "true";
      else
        v19 = "false";
      std::string::basic_string[abi:ne180100]<0>(__p, v19);
      if (v17 >= 0)
        v20 = a2;
      else
        v20 = v18;
      if (v15 >= 0)
        v21 = a1;
      else
        v21 = v16;
      if (v30 >= 0)
        v22 = __p;
      else
        v22 = (void **)__p[0];
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = "CFPrefHelper.h";
      v33 = 1024;
      v34 = 124;
      v35 = 2080;
      v36 = v21;
      v37 = 2080;
      v38 = v20;
      v39 = 2080;
      v40 = v22;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%25s:%-5d Preference '%s %s' retrieved as %s", buf, 0x30u);
      if (v30 < 0)
        operator delete(__p[0]);
    }
    v23 = 1;
    CFRelease(v13);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)a1 + 23) >= 0)
        v24 = a1;
      else
        v24 = *(const UInt8 **)a1;
      if (*((char *)a2 + 23) >= 0)
        v25 = a2;
      else
        v25 = *(const UInt8 **)a2;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "CFPrefHelper.h";
      v33 = 1024;
      v34 = 133;
      v35 = 2080;
      v36 = v24;
      v37 = 2080;
      v38 = v25;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%25s:%-5d Preference: '%s %s' does not exist.", buf, 0x26u);
    }
    v14 = 0;
    v23 = 0;
  }
  return v14 | (v23 << 8);
}

void sub_1B615592C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int128 buf, __int128 a14)
{
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;

  if (a2)
  {
    __cxa_begin_catch(a1);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      if (*((char *)v15 + 23) >= 0)
        v16 = v15;
      else
        v16 = (uint64_t *)*v15;
      if (*((char *)v14 + 23) >= 0)
        v17 = v14;
      else
        v17 = (uint64_t *)*v14;
      LODWORD(buf) = 136315906;
      *(_QWORD *)((char *)&buf + 4) = "CFPrefHelper.h";
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = 128;
      WORD1(a14) = 2080;
      *(_QWORD *)((char *)&a14 + 4) = v16;
      WORD6(a14) = 2080;
      *(_QWORD *)((char *)&a14 + 14) = v17;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to get Preference: '%s %s'. It exists, but is it the right type?", (uint8_t *)&buf, 0x26u);
    }
    __cxa_end_catch();
    if (!a12)
      JUMPOUT(0x1B6155884);
    JUMPOUT(0x1B61557D8);
  }
  _Unwind_Resume(a1);
}

void sub_1B6155A50(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  if (a2)
  {
    applesauce::CF::StringRef::~StringRef((const void **)va);
    JUMPOUT(0x1B6155A6CLL);
  }
  JUMPOUT(0x1B6155A40);
}

void sub_1B6155A78(uint64_t a1, int a2)
{
  if (a2)
    JUMPOUT(0x1B6155A80);
  JUMPOUT(0x1B6155A40);
}

void sub_1B6155B30()
{
  JUMPOUT(0x1B6155A40);
}

void std::vector<std::vector<std::vector<float>>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  void **v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void **v11;
  void **v12;
  uint64_t v13;
  size_t v14;
  void **v15;
  size_t v16;
  void **v17[5];

  v3 = *a1;
  v4 = (void **)a1[1];
  v5 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *a1) >> 3);
  v6 = a2 - v5;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      v15 = (void **)(v3 + 24 * a2);
      while (v4 != v15)
      {
        v4 -= 3;
        v17[0] = v4;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v17);
      }
      a1[1] = (uint64_t)v15;
    }
  }
  else
  {
    v7 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v7 - (uint64_t)v4) >> 3) >= v6)
    {
      v16 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero((void *)a1[1], v16);
      a1[1] = (uint64_t)v4 + v16;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v17[4] = (void **)(a1 + 2);
      v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v3) >> 3);
      v9 = 2 * v8;
      if (2 * v8 <= a2)
        v9 = a2;
      if (v8 >= 0x555555555555555)
        v10 = 0xAAAAAAAAAAAAAAALL;
      else
        v10 = v9;
      v11 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(v10);
      v12 = &v11[3 * v5];
      v17[0] = v11;
      v17[1] = v12;
      v17[3] = &v11[3 * v13];
      v14 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(v12, v14);
      v17[2] = (void **)((char *)v12 + v14);
      std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer(a1, v17);
      std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer((uint64_t)v17);
    }
  }
}

uint64_t std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void **v4;
  void **v6;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = (void **)(i - 24);
    *(_QWORD *)(a1 + 16) = v4;
    v6 = v4;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void AU::BSS1::Handset<float>::~Handset(uint64_t a1)
{
  AU::BSS1::Handset<float>::~Handset(a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AU::BSS1::Handset<float>::Init(uint64_t a1, int a2, unsigned int a3, unsigned int a4, float a5)
{
  float v9;
  float v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;

  if (a5 < 0.0 || a2 != 2 || a3 < a4)
    return 1;
  *(_DWORD *)(a1 + 60) = a3;
  *(float *)(a1 + 64) = a5;
  *(_DWORD *)(a1 + 68) = a4;
  v9 = a5 / (float)a4;
  *(float *)(a1 + 72) = v9;
  v10 = a5 / ((double)a3 + -1.0 + (double)a3 + -1.0);
  v11 = a3 - 1;
  v12 = vcvtas_u32_f32(fabsf((float)*(unsigned int *)(a1 + 196) / v10));
  if (v12 >= a3 - 1)
    v12 = a3 - 1;
  *(_DWORD *)(a1 + 200) = v12;
  v13 = vcvtas_u32_f32(fabsf((float)*(unsigned int *)(a1 + 304) / v10));
  if (v13 >= v11)
    v13 = a3 - 1;
  *(_DWORD *)(a1 + 308) = v13;
  v14 = vcvtas_u32_f32(fabsf((float)*(unsigned int *)(a1 + 496) / v10));
  if (v14 >= v11)
    v14 = a3 - 1;
  *(_DWORD *)(a1 + 500) = v14;
  v15 = vcvtas_u32_f32(fabsf((float)*(unsigned int *)(a1 + 504) / v10));
  if (v15 < v11)
    v11 = v15;
  *(_DWORD *)(a1 + 508) = v11;
  v16 = 0.0;
  v17 = 0.0;
  if (v9 > 0.0)
  {
    v18 = *(float *)(a1 + 312);
    if (v18 > 0.0)
      v17 = exp(-1.0 / (float)(v9 * v18));
  }
  *(float *)(a1 + 316) = v17;
  if (v9 > 0.0)
  {
    v19 = *(float *)(a1 + 184);
    if (v19 > 0.0)
      v16 = exp(-1.0 / (float)(v9 * v19));
  }
  *(float *)(a1 + 188) = v16;
  v20 = 0.0;
  v21 = 0.0;
  if (v9 > 0.0)
  {
    v22 = *(float *)(a1 + 552);
    if (v22 > 0.0)
      v21 = exp(-1.0 / (float)(v9 * v22));
  }
  *(float *)(a1 + 556) = v21;
  if (v9 > 0.0)
  {
    v23 = *(float *)(a1 + 704);
    if (v23 > 0.0)
      v20 = exp(-1.0 / (float)(v9 * v23));
  }
  *(float *)(a1 + 708) = v20;
  v24 = 0.0;
  v25 = 0.0;
  if (v9 > 0.0)
  {
    v26 = *(float *)(a1 + 712);
    if (v26 > 0.0)
      v25 = exp(-1.0 / (float)(v9 * v26));
  }
  *(float *)(a1 + 716) = v25;
  if (v9 > 0.0)
  {
    v27 = *(float *)(a1 + 816);
    if (v27 > 0.0)
      v24 = exp(-1.0 / (float)(v9 * v27));
  }
  *(float *)(a1 + 820) = v24;
  v28 = 0.0;
  if (v9 > 0.0)
  {
    v29 = *(float *)(a1 + 648);
    if (v29 > 0.0)
      v28 = exp(-1.0 / (float)(v9 * v29));
  }
  *(float *)(a1 + 652) = v28;
  *(_BYTE *)(a1 + 8) = 1;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  return 0;
}

float AU::BSS1::Handset<float>::Reset(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  float v7;
  uint64_t v8;
  char v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  void ***v16;
  uint64_t v17;
  void **v18;
  char *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  void **v25;
  void **v26;
  uint64_t v27;
  size_t v28;
  void **v29;
  size_t v30;
  void **v31;
  unint64_t v32;
  uint64_t i;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  char v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  float v50;
  uint64_t j;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t k;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  char v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  char v73;
  char v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  float result;
  void **v85[5];

  if (!*(_BYTE *)(a1 + 8))
    return result;
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 528, 2uLL, v85);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 768, 2uLL, v85);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 792, 2uLL, v85);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 624, 2uLL, v85);
  v2 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 656, v2, v85);
  v3 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 680, v3, v85);
  v4 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 1065353216;
  std::vector<float>::resize(a1 + 576, v4, v85);
  v5 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 1065353216;
  std::vector<float>::resize(a1 + 208, v5, v85);
  v6 = *(unsigned int *)(a1 + 60);
  v7 = 0.01 / (double)(2 * v6 - 2);
  *(float *)v85 = v7;
  std::vector<float>::resize(a1 + 600, v6, v85);
  std::vector<std::vector<std::vector<float>>>::resize((uint64_t *)(a1 + 80), 2uLL);
  v8 = 0;
  v9 = 1;
  do
  {
    v10 = v9;
    v11 = 3 * v8;
    std::vector<std::vector<float>>::resize((uint64_t *)(*(_QWORD *)(a1 + 80) + 24 * v8), 2uLL);
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v11);
    v13 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v12, v13, v85);
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v11) + 24;
    v15 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v14, v15, v85);
    v9 = 0;
    v8 = 1;
  }
  while ((v10 & 1) != 0);
  v16 = (void ***)(a1 + 456);
  v17 = *(_QWORD *)(a1 + 456);
  v18 = *(void ***)(a1 + 464);
  v19 = (char *)v18 - v17;
  v20 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v18 - v17) >> 3);
  if (v20 <= 1)
  {
    v21 = *(_QWORD *)(a1 + 472);
    if (0xAAAAAAAAAAAAAAABLL * ((v21 - (uint64_t)v18) >> 3) < 2 - v20)
    {
      v85[4] = (void **)(a1 + 472);
      v22 = 0xAAAAAAAAAAAAAAABLL * ((v21 - v17) >> 3);
      v23 = 2 * v22;
      if (2 * v22 <= 2)
        v23 = 2;
      if (v22 >= 0x555555555555555)
        v24 = 0xAAAAAAAAAAAAAAALL;
      else
        v24 = v23;
      v25 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<AUPropertyItem>>(v24);
      v26 = &v25[3 * v20];
      v85[0] = v25;
      v85[1] = v26;
      v85[3] = &v25[3 * v27];
      v28 = 24 * ((24 - (uint64_t)v19) / 0x18uLL) + 24;
      bzero(v26, v28);
      v85[2] = (void **)((char *)v26 + v28);
      std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer((_QWORD *)(a1 + 456), v85);
      std::__split_buffer<std::vector<std::vector<std::vector<float>>>>::~__split_buffer((uint64_t)v85);
      v29 = *(void ***)(a1 + 464);
      goto LABEL_17;
    }
    v30 = 24 * ((24 - (uint64_t)v19) / 0x18uLL) + 24;
    bzero(*(void **)(a1 + 464), v30);
    v29 = (void **)((char *)v18 + v30);
    goto LABEL_16;
  }
  if (v19 != (char *)48)
  {
    v29 = (void **)(v17 + 48);
    while (v18 != v29)
    {
      v18 -= 3;
      v85[0] = v18;
      std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](v85);
    }
LABEL_16:
    *(_QWORD *)(a1 + 464) = v29;
    goto LABEL_17;
  }
  v29 = *(void ***)(a1 + 464);
LABEL_17:
  v31 = *v16;
  if (v29 != *v16)
  {
    v32 = 0;
    do
    {
      std::vector<std::vector<std::vector<float>>>::resize((uint64_t *)&v31[3 * v32], 4uLL);
      for (i = 0; i != 96; i += 24)
      {
        std::vector<std::vector<float>>::resize((uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 24 * v32) + i), 2uLL);
        v34 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 24 * v32) + i);
        v35 = *(unsigned int *)(a1 + 60);
        LODWORD(v85[0]) = 0;
        std::vector<float>::resize(v34, v35, v85);
        v36 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 24 * v32) + i) + 24;
        v37 = *(unsigned int *)(a1 + 60);
        LODWORD(v85[0]) = 0;
        std::vector<float>::resize(v36, v37, v85);
      }
      ++v32;
      v31 = *(void ***)(a1 + 456);
    }
    while (v32 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 464) - (_QWORD)v31) >> 3));
  }
  v38 = 0;
  v39 = 1;
  do
  {
    v40 = v39;
    v41 = 3 * v38;
    std::vector<float>::assign(**(char ****)(*(_QWORD *)(a1 + 456) + 24 * v38), *(unsigned int *)(a1 + 60), (_DWORD *)(a1 + 292));
    std::vector<float>::assign(*(char ***)(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 8 * v41) + 72), *(unsigned int *)(a1 + 60), (_DWORD *)(a1 + 292));
    v39 = 0;
    v38 = 1;
  }
  while ((v40 & 1) != 0);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 360, 2uLL, v85);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 336), 4uLL);
  v42 = *(_QWORD *)(a1 + 336);
  if (*(_QWORD *)(a1 + 344) != v42)
  {
    v43 = 0;
    v44 = 0;
    do
    {
      v45 = *(unsigned int *)(a1 + 60);
      LODWORD(v85[0]) = 0;
      std::vector<float>::resize(v42 + v43, v45, v85);
      ++v44;
      v42 = *(_QWORD *)(a1 + 336);
      v43 += 24;
    }
    while (v44 < 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 344) - v42) >> 3));
  }
  v46 = *(unsigned int *)(a1 + 60);
  LODWORD(v85[0]) = 0;
  std::vector<float>::resize(a1 + 384, v46, v85);
  v47 = *(unsigned int *)(a1 + 60);
  if ((_DWORD)v47)
  {
    v48 = 0;
    v49 = *(_QWORD *)(a1 + 384);
    do
    {
      v50 = *(float *)(a1 + 280) / ((double)v48 * 0.5 * (double)v48 + 1.0);
      *(float *)(v49 + 4 * v48++) = v50;
    }
    while (v47 != v48);
  }
  std::vector<std::vector<std::vector<float>>>::resize((uint64_t *)(a1 + 408), 4uLL);
  for (j = 0; j != 4; ++j)
  {
    std::vector<std::vector<float>>::resize((uint64_t *)(*(_QWORD *)(a1 + 408) + 24 * j), 2uLL);
    v52 = *(_QWORD *)(*(_QWORD *)(a1 + 408) + 24 * j);
    v53 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v52, v53, v85);
    v54 = *(_QWORD *)(*(_QWORD *)(a1 + 408) + 24 * j) + 24;
    v55 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v54, v55, v85);
    v56 = *(unsigned int *)(a1 + 60);
    if ((_DWORD)v56)
    {
      v57 = 0;
      v58 = 4 * v56;
      do
      {
        if (j == 3 || !j)
          *(_DWORD *)(**(_QWORD **)(*(_QWORD *)(a1 + 408) + 24 * j) + v57) = 1065353216;
        v57 += 4;
      }
      while (v58 != v57);
    }
  }
  std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(a1 + 432, *(uint64_t **)(a1 + 408), *(uint64_t **)(a1 + 416), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 416) - *(_QWORD *)(a1 + 408)) >> 3));
  std::vector<std::vector<std::vector<float>>>::resize((uint64_t *)(a1 + 104), 4uLL);
  for (k = 0; k != 96; k += 24)
  {
    std::vector<std::vector<float>>::resize((uint64_t *)(*(_QWORD *)(a1 + 104) + k), 2uLL);
    v60 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + k);
    v61 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v60, v61, v85);
    v62 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + k) + 24;
    v63 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v62, v63, v85);
  }
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 128), 2uLL);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 152), 2uLL);
  v64 = 0;
  v65 = 1;
  do
  {
    v66 = v65;
    v67 = 3 * v64;
    v68 = *(_QWORD *)(a1 + 128) + 24 * v64;
    v69 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v68, v69, v85);
    v70 = *(_QWORD *)(a1 + 152) + 8 * v67;
    v71 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v70, v71, v85);
    v65 = 0;
    v64 = 1;
  }
  while ((v66 & 1) != 0);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 232), 2uLL);
  std::vector<std::vector<float>>::resize((uint64_t *)(a1 + 256), 2uLL);
  v72 = 0;
  v73 = 1;
  do
  {
    v74 = v73;
    v75 = 3 * v72;
    v76 = *(_QWORD *)(a1 + 232) + 24 * v72;
    v77 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v76, v77, v85);
    v78 = *(_QWORD *)(a1 + 232) + 8 * v75;
    v79 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v78, v79, v85);
    v80 = *(_QWORD *)(a1 + 256) + 8 * v75;
    v81 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v80, v81, v85);
    v82 = *(_QWORD *)(a1 + 256) + 8 * v75;
    v83 = *(unsigned int *)(a1 + 60);
    LODWORD(v85[0]) = 0;
    std::vector<float>::resize(v82, v83, v85);
    v73 = 0;
    v72 = 1;
  }
  while ((v74 & 1) != 0);
  result = (float)((float)(*(float *)(a1 + 740) * *(float *)(a1 + 64)) / (float)*(unsigned int *)(a1 + 68)) + 1.0;
  *(float *)(a1 + 732) = result;
  *(_QWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 728) = 0;
  *(_DWORD *)(a1 + 736) = 0;
  return result;
}

uint64_t AU::BSS1::Handset<float>::Update(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t *v4;
  float ***v5;
  float ***v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t result;
  float **v12;
  float **v13;
  uint64_t v14;
  char v15;
  char v16;
  float **v17;
  float *v18;
  _QWORD *v19;
  float *v20;
  float *v21;
  vDSP_Length v22;
  unsigned int *v23;
  const float **v24;
  uint64_t v25;
  unint64_t v26;
  unsigned int v27;
  float v28;
  const float ****v29;
  float v30;
  unsigned int v31;
  float *v32;
  float v33;
  uint64_t v34;
  float ****v35;
  float v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  unsigned int v42;
  char v43;
  float **v44;
  float *v45;
  float *v46;
  float *v47;
  float *v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float **v54;
  float *v55;
  float *v56;
  float **v57;
  float *v58;
  float *v59;
  vDSP_Length v60;
  float **v61;
  float *v62;
  float *v63;
  float **v64;
  float *v65;
  float *v66;
  vDSP_Length v67;
  float **v68;
  float *v69;
  float *v70;
  float **v71;
  float *v72;
  float *v73;
  float **v74;
  float *v75;
  float *v76;
  vDSP_Length v77;
  float **v78;
  float *v79;
  float *v80;
  float **v81;
  float *v82;
  float *v83;
  vDSP_Length v84;
  uint64_t v85;
  uint64_t v86;
  char v87;
  uint64_t v88;
  char v89;
  uint64_t v90;
  char v91;
  char v92;
  float *v93;
  unint64_t v94;
  float v95;
  float v96;
  uint64_t v97;
  char v98;
  char v99;
  float ***v100;
  float **v101;
  float **v102;
  float *v103;
  float *v104;
  float **v105;
  float *v106;
  float *v107;
  float *v108;
  float *v109;
  vDSP_Length v110;
  float **v111;
  float *v112;
  float *v113;
  float **v114;
  float *v115;
  float *v116;
  float **v117;
  float *v118;
  float *v119;
  vDSP_Length v120;
  float *v121;
  float *v122;
  float *v123;
  float ****v124;
  float **v125;
  float *v126;
  float *v127;
  vDSP_Length v128;
  float **v129;
  float *v130;
  float *v131;
  float **v132;
  float *v133;
  float *v134;
  float *v135;
  float *v136;
  vDSP_Length v137;
  float **v138;
  float *v139;
  float *v140;
  float **v141;
  float *v142;
  float *v143;
  float *v144;
  float *v145;
  vDSP_Length v146;
  float *v147;
  float *v148;
  float *v149;
  float **v150;
  float *v151;
  float *v152;
  vDSP_Length v153;
  float **v154;
  float *v155;
  float *v156;
  float **v157;
  float *v158;
  float *v159;
  float *v160;
  float *v161;
  vDSP_Length v162;
  float **v163;
  float *v164;
  float *v165;
  float **v166;
  float *v167;
  float *v168;
  float *v169;
  float *v170;
  vDSP_Length v171;
  float *v172;
  float *v173;
  float *v174;
  float **v175;
  float *v176;
  float *v177;
  vDSP_Length v178;
  float **v179;
  float *v180;
  float *v181;
  float **v182;
  float *v183;
  float *v184;
  float *v185;
  float *v186;
  vDSP_Length v187;
  float **v188;
  float *v189;
  float *v190;
  float **v191;
  float *v192;
  float *v193;
  float *v194;
  float *v195;
  vDSP_Length v196;
  float *v197;
  float *v198;
  float *v199;
  float **v200;
  float *v201;
  float *v202;
  vDSP_Length v203;
  float *v204;
  float *v205;
  uint64_t i;
  float **v207;
  float *v208;
  float *v209;
  float **v210;
  float *v211;
  float *v212;
  vDSP_Length v213;
  float ***v214;
  float **v215;
  float *v216;
  float *v217;
  float **v218;
  float *v219;
  float *v220;
  uint64_t v221;
  uint64_t v222;
  char v223;
  uint64_t v224;
  uint64_t v225;
  char v226;
  uint64_t v227;
  _QWORD *v228;
  uint64_t v229;
  float **v230;
  char v231;
  float *v232;
  float *v233;
  float **v234;
  float *v235;
  float *v236;
  float **v237;
  float *v238;
  float *v239;
  vDSP_Length v240;
  float **v241;
  float *v242;
  float *v243;
  float **v244;
  float *v245;
  float *v246;
  float **v247;
  float *v248;
  float *v249;
  vDSP_Length v250;
  float **v251;
  float *v252;
  float *v253;
  float **v254;
  float *v255;
  float *v256;
  float **v257;
  float *v258;
  float *v259;
  vDSP_Length v260;
  vDSP_Length v261;
  float **v262;
  float *v263;
  float *v264;
  float ***v265;
  float *v266;
  float *v267;
  float **v268;
  float *v269;
  float *v270;
  uint64_t v271;
  float **v272;
  float *v273;
  float *v274;
  float **v275;
  float *v276;
  float *v277;
  float **v278;
  float *v279;
  float *v280;
  vDSP_Length v281;
  float **v282;
  float *v283;
  float *v284;
  float **v285;
  float *v286;
  float *v287;
  float **v288;
  float *v289;
  float *v290;
  vDSP_Length v291;
  float *v292;
  vDSP_Length v293;
  vDSP_Length v294;
  float *v295;
  float *v296;
  vDSP_Length v297;
  uint64_t v298;
  char v299;
  char v300;
  uint64_t v301;
  uint64_t v302;
  char v303;
  char v304;
  uint64_t v305;
  float **v306;
  float *v307;
  float *v308;
  float *v309;
  unint64_t v310;
  float v311;
  float ****v312;
  unint64_t v313;
  uint64_t v314;
  float **v315;
  unint64_t v316;
  uint64_t j;
  vDSP_Length v318;
  float **v319;
  float *v320;
  float *v321;
  float *v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t **v325;
  uint64_t *v326;
  uint64_t v327;
  _QWORD *v328;
  uint64_t v329;
  float v330;
  uint64_t v331;
  uint64_t v332;
  float v333;
  float v334;
  float v335;
  float v336;
  uint64_t v337;
  float v338;
  float v339;
  float v340;
  float v341;
  _QWORD *v342;
  _QWORD *v343;
  _QWORD *v344;
  _QWORD *v345;
  uint64_t v346;
  float v347;
  float v348;
  float v349;
  float v350;
  float v351;
  float v352;
  double v353;
  float v354;
  float *v355;
  uint64_t v356;
  char v357;
  uint64_t v358;
  char v359;
  char v360;
  char v361;
  uint64_t v362;
  char v363;
  char v364;
  float **v365;
  float *v366;
  vDSP_Length v367;
  float *v368;
  float *v369;
  float *v370;
  uint64_t v371;
  uint64_t *v372;
  uint64_t **v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t *v379;
  uint64_t v380;
  float v381;
  float v382;
  _QWORD *v383;
  _QWORD *v384;
  _QWORD *v385;
  uint64_t v386;
  char v387;
  char v388;
  float *v389;
  float **v390;
  double v391;
  double v392;
  BOOL v393;
  double v394;
  float v395;
  float v396;
  float v397;
  vDSP_Length v398;
  float *v399;
  unint64_t v400;
  float v401;
  uint64_t v402;
  _QWORD *v403;
  float v404;
  uint64_t v405;
  unint64_t v406;
  float v407;
  uint64_t *v408;
  uint64_t v409;
  uint64_t v410;
  float ***v411;
  uint64_t *v412;
  uint64_t v413;
  uint64_t v414;
  _QWORD *v415;
  uint64_t v416;
  uint64_t *v417;
  uint64_t v418;
  int v419;
  uint64_t v420;
  float v421;
  float v422;
  float v423;
  _QWORD *v424;
  float v425;
  float v426;
  float v427;
  float v428;
  _QWORD *v429;
  float **v430;
  float ***v431;
  float **v432;
  float **v433;
  float v434;
  float v435;
  float **v436;
  float ***v437;
  float **v438;
  float **v439;
  float v440;
  float v441;
  _QWORD *v442;
  float ***v443;
  float **v444;
  float **v445;
  float v446;
  float v447;
  char **v448;
  unint64_t v449;
  uint64_t v450;
  float v451;
  float v452;
  float v453;
  uint64_t v454;
  uint64_t v455;
  float *v456;
  char v457;
  float *v458;
  char v459;
  float v460;
  float v461;
  unint64_t v462;
  float v463;
  float v464;
  float v465;
  unint64_t v466;
  vDSP_Length v467;
  uint64_t v468;
  uint64_t v469;
  const float *v470;
  float v471;
  float v472;
  uint64_t v473;
  float v474;
  const float ***v475;
  uint64_t v476;
  char v477;
  uint64_t v478;
  char v479;
  const float **v480;
  float **v481;
  float *v482;
  float *v483;
  float **v484;
  float *v485;
  float *v486;
  float *v487;
  float *v488;
  vDSP_Length v489;
  float *v490;
  float *v491;
  float ****v492;
  float ***v493;
  char v494;
  float ****v495;
  uint64_t **v497;
  float *__B;
  DSPSplitComplex __C;
  DSPSplitComplex v501;
  DSPSplitComplex __A;
  uint64_t v503;

  v503 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 8))
    return 4294956429;
  v4 = *a2;
  v3 = a2[1];
  if ((char *)v3 - (char *)*a2 != 48)
    return 4294956421;
  v6 = *(float ****)a3;
  v5 = *(float ****)(a3 + 8);
  if ((float ***)((char *)v5 - *(_QWORD *)a3) != (float ***)48)
    return 4294956421;
  v7 = a1;
  v8 = *(unsigned int *)(a1 + 60);
  while (v4 != v3)
  {
    v10 = (_QWORD *)*v4;
    v9 = (_QWORD *)v4[1];
    if ((_QWORD *)((char *)v9 - *v4) != (_QWORD *)48)
      return 4294956421;
    while (v10 != v9)
    {
      if (v8 != (uint64_t)(v10[1] - *v10) >> 2)
        return 4294956421;
      v10 += 3;
    }
    v4 += 3;
  }
  while (v6 != v5)
  {
    v13 = *v6;
    v12 = v6[1];
    if ((char *)v12 - (char *)*v6 != 48)
      return 4294956421;
    while (v13 != v12)
    {
      if (v8 != v13[1] - *v13)
        return 4294956421;
      v13 += 3;
    }
    v6 += 3;
  }
  v497 = a2;
  v14 = 0;
  __B = (float *)(a1 + 56);
  v15 = 1;
  do
  {
    v16 = v15;
    v17 = (float **)(*a2)[3 * v14];
    v18 = *v17;
    v19 = (_QWORD *)(v7 + 232);
    v20 = *(float **)(*(_QWORD *)(v7 + 232) + 24 * v14);
    v21 = v17[3];
    v23 = (unsigned int *)(v7 + 60);
    v22 = *(unsigned int *)(v7 + 60);
    __A.realp = v18;
    __A.imagp = v21;
    vDSP_zvabs(&__A, 1, v20, 1, v22);
    vDSP_vsadd(*(const float **)(*v19 + 24 * v14), 1, __B, *(float **)(*v19 + 24 * v14), 1, *v23);
    v15 = 0;
    v14 = 1;
    v7 = a1;
    a2 = v497;
  }
  while ((v16 & 1) != 0);
  v24 = *(const float ***)(a1 + 240);
  if (v24 == *(const float ***)(a1 + 232))
  {
    v28 = 3.4028e38;
  }
  else
  {
    v25 = 0;
    v26 = 0;
    v27 = *(_DWORD *)(a1 + 60);
    v28 = 3.4028e38;
    v24 = *(const float ***)(a1 + 232);
    do
    {
      LODWORD(__A.realp) = 0;
      v29 = (const float ****)(v7 + 104);
      vDSP_vsq(v24[v25], 1, ***(float ****)(v7 + 104), 1, v27);
      vDSP_sve(***v29, 1, (float *)&__A, *(unsigned int *)(a1 + 60));
      v27 = *(_DWORD *)(a1 + 60);
      v30 = log10f(*(float *)&__A.realp / (float)v27) * 10.0;
      if (v30 < v28)
        v28 = v30;
      ++v26;
      v7 = a1;
      v24 = *(const float ***)(a1 + 232);
      v25 += 3;
    }
    while (v26 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 240) - (_QWORD)v24) >> 3));
  }
  if ((*(_BYTE *)(v7 + 40) & 1) != 0 && v28 < *(float *)(v7 + 176))
  {
    if ((uint64_t **)a3 != v497)
      std::vector<std::vector<std::vector<float>>>::__assign_with_size[abi:ne180100]<std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(a3, *v497, v497[1], 0xAAAAAAAAAAAAAAABLL * (v497[1] - *v497));
    return 0;
  }
  vDSP_vdiv(v24[3], 1, *v24, 1, *(float **)(v7 + 208), 1, *(unsigned int *)(v7 + 60));
  v31 = *(_DWORD *)(a1 + 200);
  if (v31)
  {
    v32 = *(float **)(a1 + 208);
    v33 = 0.0;
    v34 = *(unsigned int *)(a1 + 200);
    v35 = (float ****)v497;
    do
    {
      v36 = *v32++;
      if (v36 > *(float *)(a1 + 192))
        v33 = v33 + 1.0;
      --v34;
    }
    while (v34);
  }
  else
  {
    v33 = 0.0;
    v35 = (float ****)v497;
  }
  v37 = (float)(*(float *)(a1 + 188) * *(float *)(a1 + 728)) + (1.0 - *(float *)(a1 + 188)) * (float)(v33 / (float)v31);
  *(float *)(a1 + 728) = v37;
  AU::BSS1::Handset<float>::ClearDCAndNyquist(*(unsigned int *)(a1 + 60), *(_QWORD *)(a1 + 432));
  v492 = (float ****)(a1 + 432);
  AU::BSS1::Handset<float>::GenerateOutput(a1, v35, (float ****)(a1 + 80), (float ****)(a1 + 432));
  v38 = 0;
  v39 = a1;
  v495 = (float ****)(a1 + 104);
  v40 = 1;
  do
  {
    v42 = *(_DWORD *)(v39 + 60);
    v41 = v39 + 60;
    v43 = v40;
    v44 = *(float ***)(*(_QWORD *)(v41 + 20) + 24 * v38);
    v45 = *v44;
    v46 = v44[3];
    v47 = **(float ***)(*(_QWORD *)(v41 + 44) + 24);
    __A.realp = v45;
    __A.imagp = v46;
    vDSP_zvabs(&__A, 1, v47, 1, v42);
    vDSP_svesq((const float *)(**(_QWORD **)(*(_QWORD *)(a1 + 104) + 24) + 4 * *(unsigned int *)(a1 + 308)), 1, (float *)(*(_QWORD *)(a1 + 360) + 4 * v38), (*(_DWORD *)v41 + ~*(_DWORD *)(a1 + 308)));
    v40 = 0;
    v38 = 1;
    v39 = a1;
  }
  while ((v43 & 1) != 0);
  v48 = *(float **)(a1 + 360);
  v49 = v48[1];
  v50 = sqrtf(*v48 + *(float *)(a1 + 56));
  *v48 = v50;
  *v48 = v50 + *(float *)(a1 + 284);
  v51 = sqrtf(v49 + *(float *)(a1 + 56));
  v48[1] = v51;
  v48[1] = v51 + *(float *)(a1 + 284);
  v52 = *(float *)(a1 + 328) * *(float *)(a1 + 728);
  if (v52 < 1.0)
    v52 = 1.0;
  v48[*(_DWORD *)(a1 + 520) != 0] = v52 * v48[*(_DWORD *)(a1 + 520) != 0];
  v53 = *(float *)(a1 + 316);
  v54 = (float **)**v497;
  v55 = *v54;
  v56 = v54[3];
  v57 = **(float ****)(a1 + 104);
  v58 = *v57;
  v59 = v57[3];
  v60 = *(unsigned int *)(a1 + 60);
  __A.realp = v55;
  __A.imagp = v56;
  v501.realp = v55;
  v501.imagp = v56;
  __C.realp = v58;
  __C.imagp = v59;
  vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v60, -1);
  v61 = (float **)(*v497)[3];
  v62 = *v61;
  v63 = v61[3];
  v64 = *(float ***)(*(_QWORD *)(a1 + 104) + 72);
  v65 = *v64;
  v66 = v64[3];
  v67 = *(unsigned int *)(a1 + 60);
  __A.realp = v62;
  __A.imagp = v63;
  v501.realp = v62;
  v501.imagp = v63;
  __C.realp = v65;
  __C.imagp = v66;
  vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v67, -1);
  v68 = (float **)(*v497)[3];
  v69 = *v68;
  v70 = v68[3];
  v71 = (float **)**v497;
  v72 = *v71;
  v73 = v71[3];
  v74 = *(float ***)(*(_QWORD *)(a1 + 104) + 24);
  v75 = *v74;
  v76 = v74[3];
  v77 = *(unsigned int *)(a1 + 60);
  __A.realp = v69;
  __A.imagp = v70;
  v501.realp = v72;
  v501.imagp = v73;
  __C.realp = v75;
  __C.imagp = v76;
  vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v77, -1);
  v78 = *(float ***)(*(_QWORD *)(a1 + 104) + 24);
  v79 = *v78;
  v80 = v78[3];
  v81 = *(float ***)(*(_QWORD *)(a1 + 104) + 48);
  v82 = *v81;
  v83 = v81[3];
  v84 = *(unsigned int *)(a1 + 60);
  __A.realp = v79;
  __A.imagp = v80;
  v501.realp = v82;
  v501.imagp = v83;
  vDSP_zvconj(&__A, 1, &v501, 1, v84);
  v85 = a1;
  if (*(_DWORD *)(a1 + 36))
  {
    vDSP_vadd(***(const float ****)(a1 + 104), 1, *(const float **)(a1 + 384), 1, ***(float ****)(a1 + 104), 1, *(unsigned int *)(a1 + 60));
    vDSP_vadd(**(const float ***)(*(_QWORD *)(a1 + 104) + 72), 1, *(const float **)(a1 + 384), 1, **(float ***)(*(_QWORD *)(a1 + 104) + 72), 1, *(unsigned int *)(a1 + 60));
    v85 = a1;
  }
  v86 = 0;
  v493 = (float ***)(v85 + 128);
  v87 = 1;
  do
  {
    v88 = 0;
    v89 = v87;
    LODWORD(__A.realp) = 0;
    *(float *)&__A.realp = (float)(1.0 - v53) / *(float *)(*(_QWORD *)(v85 + 360) + 4 * v86);
    do
    {
      v90 = 0;
      v91 = 1;
      do
      {
        v92 = v91;
        v93 = *(float **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v85 + 456) + 24 * v86) + 24 * v88) + 24 * v90);
        vDSP_vsmul(v93, 1, (const float *)(a1 + 316), v93, 1, *(unsigned int *)(v85 + 60));
        vDSP_vsmul(*(const float **)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 24 * v88) + 24 * v90), 1, (const float *)&__A, **(float ***)(a1 + 128), 1, *(unsigned int *)(v85 + 60));
        vDSP_vadd(*(const float **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v85 + 456) + 24 * v86) + 24 * v88) + 24 * v90), 1, **(const float ***)(a1 + 128), 1, *(float **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v85 + 456) + 24 * v86) + 24 * v88) + 24 * v90), 1, *(unsigned int *)(v85 + 60));
        v91 = 0;
        v90 = 1;
        v85 = a1;
      }
      while ((v92 & 1) != 0);
      ++v88;
    }
    while (v88 != 4);
    v87 = 0;
    v86 = 1;
  }
  while ((v89 & 1) != 0);
  v94 = *(_QWORD *)(a1 + 320);
  v95 = *(float *)(a1 + 64);
  v96 = (float)*(unsigned int *)(a1 + 68);
  if ((float)((float)(*(float *)(a1 + 296) * v95) / v96) < (float)v94)
  {
    v97 = 0;
    v98 = 1;
    do
    {
      v99 = v98;
      v101 = *(float ***)(v85 + 128);
      v100 = (float ***)(v85 + 128);
      v102 = (float **)*v100[38];
      v103 = *v102;
      v104 = v102[3];
      v105 = *(float ***)v100[41][3 * v97];
      v106 = *v105;
      v107 = v105[3];
      v108 = *v101;
      v109 = v101[3];
      v110 = *((unsigned int *)v100 - 17);
      __A.realp = v103;
      __A.imagp = v104;
      v501.realp = v106;
      v501.imagp = v107;
      __C.realp = v108;
      __C.imagp = v109;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v110, 1);
      v111 = (float **)v100[38][3];
      v112 = *v111;
      v113 = v111[3];
      v114 = (float **)*((_QWORD *)v100[41][3 * v97] + 6);
      v115 = *v114;
      v116 = v114[3];
      v117 = *(float ***)(a1 + 152);
      v118 = *v117;
      v119 = v117[3];
      v120 = *((unsigned int *)v100 - 17);
      __A.realp = v112;
      __A.imagp = v113;
      v501.realp = v115;
      v501.imagp = v116;
      __C.realp = v118;
      __C.imagp = v119;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v120, 1);
      v121 = (*v100)[3];
      v122 = **(float ***)(a1 + 152);
      v123 = *(float **)(*(_QWORD *)(a1 + 152) + 24);
      v124 = (float ****)(a1 + 104);
      v125 = **(float ****)(a1 + 104);
      v126 = *v125;
      v127 = v125[3];
      v128 = *((unsigned int *)v100 - 17);
      __A.realp = **v100;
      __A.imagp = v121;
      v501.realp = v122;
      v501.imagp = v123;
      __C.realp = v126;
      __C.imagp = v127;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v128);
      v129 = (float **)*v100[38];
      v130 = *v129;
      v131 = v129[3];
      v132 = (float **)*((_QWORD *)v100[41][3 * v97] + 3);
      v133 = *v132;
      v134 = v132[3];
      v135 = **v100;
      v136 = (*v100)[3];
      v137 = *((unsigned int *)v100 - 17);
      __A.realp = v130;
      __A.imagp = v131;
      v501.realp = v133;
      v501.imagp = v134;
      __C.realp = v135;
      __C.imagp = v136;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v137, 1);
      v138 = (float **)v100[38][3];
      v139 = *v138;
      v140 = v138[3];
      v141 = (float **)*((_QWORD *)v100[41][3 * v97] + 9);
      v142 = *v141;
      v143 = v141[3];
      v144 = **(float ***)(a1 + 152);
      v145 = *(float **)(*(_QWORD *)(a1 + 152) + 24);
      v146 = *((unsigned int *)v100 - 17);
      __A.realp = v139;
      __A.imagp = v140;
      v501.realp = v142;
      v501.imagp = v143;
      __C.realp = v144;
      __C.imagp = v145;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v146, 1);
      v147 = (*v100)[3];
      v148 = **(float ***)(a1 + 152);
      v149 = *(float **)(*(_QWORD *)(a1 + 152) + 24);
      v150 = *(float ***)(*(_QWORD *)(a1 + 104) + 24);
      v151 = *v150;
      v152 = v150[3];
      v153 = *((unsigned int *)v100 - 17);
      __A.realp = **v100;
      __A.imagp = v147;
      v501.realp = v148;
      v501.imagp = v149;
      __C.realp = v151;
      __C.imagp = v152;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v153);
      v154 = (float **)v100[38][6];
      v155 = *v154;
      v156 = v154[3];
      v157 = *(float ***)v100[41][3 * v97];
      v158 = *v157;
      v159 = v157[3];
      v160 = **v100;
      v161 = (*v100)[3];
      v162 = *((unsigned int *)v100 - 17);
      __A.realp = v155;
      __A.imagp = v156;
      v501.realp = v158;
      v501.imagp = v159;
      __C.realp = v160;
      __C.imagp = v161;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v162, 1);
      v163 = (float **)v100[38][9];
      v164 = *v163;
      v165 = v163[3];
      v166 = (float **)*((_QWORD *)v100[41][3 * v97] + 6);
      v167 = *v166;
      v168 = v166[3];
      v169 = **(float ***)(a1 + 152);
      v170 = *(float **)(*(_QWORD *)(a1 + 152) + 24);
      v171 = *((unsigned int *)v100 - 17);
      __A.realp = v164;
      __A.imagp = v165;
      v501.realp = v167;
      v501.imagp = v168;
      __C.realp = v169;
      __C.imagp = v170;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v171, 1);
      v172 = (*v100)[3];
      v173 = **(float ***)(a1 + 152);
      v174 = *(float **)(*(_QWORD *)(a1 + 152) + 24);
      v175 = *(float ***)(*(_QWORD *)(a1 + 104) + 48);
      v176 = *v175;
      v177 = v175[3];
      v178 = *((unsigned int *)v100 - 17);
      __A.realp = **v100;
      __A.imagp = v172;
      v501.realp = v173;
      v501.imagp = v174;
      __C.realp = v176;
      __C.imagp = v177;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v178);
      v179 = (float **)v100[38][6];
      v180 = *v179;
      v181 = v179[3];
      v182 = (float **)*((_QWORD *)v100[41][3 * v97] + 3);
      v183 = *v182;
      v184 = v182[3];
      v185 = **v100;
      v186 = (*v100)[3];
      v187 = *((unsigned int *)v100 - 17);
      __A.realp = v180;
      __A.imagp = v181;
      v501.realp = v183;
      v501.imagp = v184;
      __C.realp = v185;
      __C.imagp = v186;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v187, 1);
      v188 = (float **)v100[38][9];
      v189 = *v188;
      v190 = v188[3];
      v191 = (float **)*((_QWORD *)v100[41][3 * v97] + 9);
      v192 = *v191;
      v193 = v191[3];
      v194 = **(float ***)(a1 + 152);
      v195 = *(float **)(*(_QWORD *)(a1 + 152) + 24);
      v196 = *((unsigned int *)v100 - 17);
      __A.realp = v189;
      __A.imagp = v190;
      v501.realp = v192;
      v501.imagp = v193;
      __C.realp = v194;
      __C.imagp = v195;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v196, 1);
      v197 = (*v100)[3];
      v198 = **(float ***)(a1 + 152);
      v199 = *(float **)(*(_QWORD *)(a1 + 152) + 24);
      v200 = *(float ***)(*(_QWORD *)(a1 + 104) + 72);
      v201 = *v200;
      v202 = v200[3];
      v203 = *((unsigned int *)v100 - 17);
      __A.realp = **v100;
      __A.imagp = v197;
      v501.realp = v198;
      v501.imagp = v199;
      __C.realp = v201;
      __C.imagp = v202;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v203);
      AU::BSS1::Handset<float>::VectorizedDetInverseOf2x2(a1, v495, v493);
      vDSP_vswap(***v124, 1, *(*v124)[9], 1, *((unsigned int *)v100 - 17));
      vDSP_vswap((**v124)[3], 1, (*v124)[9][3], 1, *((unsigned int *)v100 - 17));
      vDSP_vneg(*(*v124)[3], 1, *(*v124)[3], 1, *((unsigned int *)v100 - 17));
      v204 = *(float **)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 24) + 24);
      vDSP_vneg(v204, 1, v204, 1, *((unsigned int *)v100 - 17));
      vDSP_vneg(*(*v124)[6], 1, *(*v124)[6], 1, *((unsigned int *)v100 - 17));
      v205 = *(float **)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48) + 24);
      vDSP_vneg(v205, 1, v205, 1, *((unsigned int *)v100 - 17));
      for (i = 0; i != 96; i += 24)
      {
        v207 = *(float ***)(a1 + 128);
        v208 = *v207;
        v209 = v207[3];
        v210 = *(float ***)(*(_QWORD *)(a1 + 104) + i);
        v211 = *v210;
        v212 = v210[3];
        v213 = *(unsigned int *)(a1 + 60);
        __A.realp = v208;
        __A.imagp = v209;
        v501.realp = v211;
        v501.imagp = v212;
        __C.realp = v211;
        __C.imagp = v212;
        vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v213, 1);
      }
      v85 = a1;
      if (!*(_DWORD *)(a1 + 32) || v97 == *(_DWORD *)(a1 + 520) || *(float *)(a1 + 728) >= *(float *)(a1 + 516))
      {
        v214 = *v495;
        v215 = (*v495)[3 * v97];
        v216 = *v215;
        v217 = v215[1];
        if (v217 != v216)
        {
          memmove(*(*v492)[6 * v97], v216, (char *)v217 - (char *)v216);
          v214 = *v495;
        }
        v218 = v214[3 * (v97 | 2)];
        v219 = *v218;
        v220 = v218[1];
        v221 = (2 * v97) | 1;
        if (v220 != v219)
        {
          memmove(*(*v492)[3 * v221], v219, (char *)v220 - (char *)v219);
          v214 = *v495;
        }
        vDSP_vneg(v214[3 * v97][3], 1, *(float **)(*(_QWORD *)(*(_QWORD *)(a1 + 432) + 48 * v97) + 24), 1, *(unsigned int *)(a1 + 60));
        vDSP_vneg(*(const float **)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 24 * (v97 | 2)) + 24), 1, *(float **)(*(_QWORD *)(*(_QWORD *)(a1 + 432) + 24 * v221) + 24), 1, *(unsigned int *)(a1 + 60));
        v85 = a1;
      }
      v98 = 0;
      v97 = 1;
    }
    while ((v99 & 1) != 0);
    v222 = 0;
    v490 = (float *)(v85 + 48);
    v491 = (float *)(v85 + 288);
    v223 = 1;
    do
    {
      v224 = 0;
      v494 = v223;
      v225 = 2 * v222;
      v226 = 1;
      v227 = (2 * v222) | 1;
      do
      {
        v229 = *(_QWORD *)(v85 + 104);
        v228 = (_QWORD *)(v85 + 104);
        v230 = *(float ***)(v228[41] + 48 * v222);
        v231 = v226;
        v232 = *v230;
        v233 = v230[3];
        v234 = *(float ***)(*(_QWORD *)(v228[44] + 24 * v222) + 48 * v224);
        v235 = *v234;
        v236 = v234[3];
        v237 = *(float ***)(v229 + 48);
        v238 = *v237;
        v239 = v237[3];
        v240 = *((unsigned int *)v228 - 11);
        __A.realp = v232;
        __A.imagp = v233;
        v501.realp = v235;
        v501.imagp = v236;
        __C.realp = v238;
        __C.imagp = v239;
        vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v240, -1);
        v241 = *(float ***)(*(_QWORD *)(a1 + 432) + 24 * v227);
        v242 = *v241;
        v243 = v241[3];
        v244 = *(float ***)(*(_QWORD *)(v228[44] + 24 * v222) + 24 * ((2 * v224) | 1));
        v245 = *v244;
        v246 = v244[3];
        v247 = *(float ***)(*v228 + 72);
        v248 = *v247;
        v249 = v247[3];
        v250 = *((unsigned int *)v228 - 11);
        __A.realp = v242;
        __A.imagp = v243;
        v501.realp = v245;
        v501.imagp = v246;
        __C.realp = v248;
        __C.imagp = v249;
        vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v250, -1);
        v251 = *(float ***)(*v228 + 48);
        v252 = *v251;
        v253 = v251[3];
        v254 = *(float ***)(*v228 + 72);
        v255 = *v254;
        v256 = v254[3];
        v257 = *(float ***)(*v228 + 24 * v224);
        v258 = *v257;
        v259 = v257[3];
        v260 = *((unsigned int *)v228 - 11);
        __A.realp = v252;
        __A.imagp = v253;
        v501.realp = v255;
        v501.imagp = v256;
        __C.realp = v258;
        __C.imagp = v259;
        vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v260);
        v226 = 0;
        v224 = 1;
        v85 = a1;
      }
      while ((v231 & 1) != 0);
      v261 = *(unsigned int *)(a1 + 60);
      v262 = *(float ***)(*(_QWORD *)(a1 + 432) + 48 * v222);
      v263 = *v262;
      v264 = v262[3];
      v265 = *(float ****)(a1 + 104);
      v266 = **v265;
      v267 = (*v265)[3];
      v268 = v265[6];
      v269 = *v268;
      v270 = v268[3];
      __A.realp = v263;
      __A.imagp = v264;
      v501.realp = v266;
      v501.imagp = v267;
      __C.realp = v269;
      __C.imagp = v270;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v261, 1);
      v271 = *(_QWORD *)(a1 + 104);
      v272 = *(float ***)(*(_QWORD *)(a1 + 432) + 24 * v227);
      v273 = *v272;
      v274 = v272[3];
      v275 = *(float ***)(v271 + 24);
      v276 = *v275;
      v277 = v275[3];
      v278 = *(float ***)(v271 + 72);
      v279 = *v278;
      v280 = v278[3];
      v281 = *(unsigned int *)(a1 + 60);
      __A.realp = v273;
      __A.imagp = v274;
      v501.realp = v276;
      v501.imagp = v277;
      __C.realp = v279;
      __C.imagp = v280;
      vDSP_zvmul(&__A, 1, &v501, 1, &__C, 1, v281, 1);
      v282 = *(float ***)(*(_QWORD *)(a1 + 104) + 48);
      v283 = *v282;
      v284 = v282[3];
      v285 = *(float ***)(*(_QWORD *)(a1 + 104) + 72);
      v286 = *v285;
      v287 = v285[3];
      v288 = *(float ***)(a1 + 128);
      v289 = *v288;
      v290 = v288[3];
      v291 = *(unsigned int *)(a1 + 60);
      __A.realp = v283;
      __A.imagp = v284;
      v501.realp = v286;
      v501.imagp = v287;
      __C.realp = v289;
      __C.imagp = v290;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v291);
      v292 = *(float **)(*(_QWORD *)(a1 + 128) + 24);
      v293 = *(unsigned int *)(a1 + 60);
      __A.realp = **(float ***)(a1 + 128);
      __A.imagp = v292;
      vDSP_zvabs(&__A, 1, __A.realp, 1, v293);
      vDSP_vsadd(**(const float ***)(a1 + 128), 1, __B, **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
      v294 = *(unsigned int *)(a1 + 60);
      v295 = **(float ***)(a1 + 128);
      v296 = v295;
      v297 = v294;
      if ((_DWORD)v294)
      {
        do
        {
          *v296 = sqrtf(*v296);
          ++v296;
          --v297;
        }
        while (v297);
      }
      vDSP_vsadd(v295, 1, v491, v295, 1, v294);
      vDSP_svdiv(v490, **(const float ***)(a1 + 128), 1, **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
      v298 = 0;
      v299 = 1;
      do
      {
        v300 = v299;
        v301 = 3 * (v298 | v225);
        vDSP_vmul(**(const float ***)(*(_QWORD *)(a1 + 432) + 24 * (v298 | v225)), 1, **(const float ***)(a1 + 128), 1, **(float ***)(*(_QWORD *)(a1 + 104) + 24 * (v298 | v225)), 1, *(unsigned int *)(a1 + 60));
        vDSP_vmul(*(const float **)(*(_QWORD *)(*(_QWORD *)(a1 + 432) + 8 * v301) + 24), 1, **(const float ***)(a1 + 128), 1, *(float **)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8 * v301) + 24), 1, *(unsigned int *)(a1 + 60));
        v299 = 0;
        v298 = 1;
      }
      while ((v300 & 1) != 0);
      v85 = a1;
      if (!*(_DWORD *)(a1 + 32) || v222 == *(_DWORD *)(a1 + 520) || *(float *)(a1 + 728) >= *(float *)(a1 + 516))
      {
        v302 = 0;
        v303 = 1;
        do
        {
          v304 = v303;
          v305 = v302 | v225;
          v306 = (*v495)[3 * (v302 | v225)];
          v307 = v306[1];
          if (v307 != *v306)
          {
            memmove(*(*v492)[3 * v305], *v306, (char *)v307 - (char *)*v306);
            v306 = (*v495)[3 * v305];
          }
          v308 = v306[3];
          v309 = v306[4];
          if (v309 != v308)
            memmove((*v492)[3 * v305][3], v308, (char *)v309 - (char *)v308);
          v303 = 0;
          v302 = 1;
        }
        while ((v304 & 1) != 0);
      }
      v223 = 0;
      v222 = 1;
    }
    while ((v494 & 1) != 0);
    v94 = *(_QWORD *)(a1 + 320);
    v95 = *(float *)(a1 + 64);
    v96 = (float)*(unsigned int *)(a1 + 68);
  }
  v310 = v94 + 1;
  *(_QWORD *)(v85 + 320) = v310;
  v311 = (float)(*(float *)(v85 + 300) * v95) / v96;
  if (v311 < (float)v310)
    *(_QWORD *)(v85 + 320) = (unint64_t)v311;
  v312 = (float ****)(v85 + 408);
  AU::BSS1::Handset<float>::ScaleMDP(v85, v492, (uint64_t *)(v85 + 408));
  v314 = a1;
  if (*(_DWORD *)(a1 + 20))
  {
    v315 = **v495;
    v316 = v315[1] - *v315;
    LODWORD(__A.realp) = 0;
    std::vector<float>::assign((char **)v315, v316, &__A);
    for (j = 0; j != 96; j += 24)
    {
      v318 = *(unsigned int *)(a1 + 60);
      v319 = *(float ***)(*(_QWORD *)(a1 + 408) + j);
      v320 = *v319;
      v321 = v319[3];
      v322 = *(float **)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + j) + 24);
      __A.realp = v320;
      __A.imagp = v321;
      vDSP_zvabs(&__A, 1, v322, 1, v318);
      vDSP_vadd(***(const float ****)(a1 + 104), 1, *(const float **)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + j) + 24), 1, ***(float ****)(a1 + 104), 1, *(unsigned int *)(a1 + 60));
    }
    v314 = a1;
    v323 = *(unsigned int *)(a1 + 60);
    if ((_DWORD)v323)
    {
      v324 = 0;
      v325 = *(uint64_t ***)(a1 + 104);
      v326 = *v325;
      v327 = **v325;
      v328 = *(_QWORD **)(a1 + 432);
      v329 = 4 * v323;
      do
      {
        v330 = *(float *)(v327 + v324);
        if (v330 < *(float *)(a1 + 480))
          goto LABEL_101;
        v331 = v326[3];
        v332 = v325[3][3];
        v333 = *(float *)(v331 + v324);
        v334 = *(float *)(v332 + v324);
        v335 = v333 >= v334 ? *(float *)(v331 + v324) : *(float *)(v332 + v324);
        v336 = *(float *)(a1 + 484);
        if (v335 < v336
          || ((v337 = v325[9][3], v338 = *(float *)(v337 + v324), v334 >= v338)
            ? (v339 = *(float *)(v332 + v324))
            : (v339 = *(float *)(v337 + v324)),
              v339 < v336
           || (v340 = v333 + v334, v341 = *(float *)(a1 + 488), v340 < v341)
           || (float)(v338 + *(float *)(v325[6][3] + v324)) < v341
           || v330 > *(float *)(a1 + 492)))
        {
LABEL_101:
          v342 = (_QWORD *)*v328;
          *(_DWORD *)(*(_QWORD *)*v328 + v324) = 1065353216;
          v343 = (_QWORD *)v328[3];
          *(_DWORD *)(*v343 + v324) = 0;
          v344 = (_QWORD *)v328[6];
          *(_DWORD *)(*v344 + v324) = 0;
          v345 = (_QWORD *)v328[9];
          *(_DWORD *)(*v345 + v324) = 1065353216;
          *(_DWORD *)(v342[3] + v324) = 0;
          *(_DWORD *)(v343[3] + v324) = 0;
          *(_DWORD *)(v344[3] + v324) = 0;
          *(_DWORD *)(v345[3] + v324) = 0;
        }
        v324 += 4;
      }
      while (v329 != v324);
    }
  }
  if (*(_DWORD *)(v314 + 12))
  {
    LODWORD(v313) = *(_DWORD *)(v314 + 508);
    v346 = *(unsigned int *)(v314 + 500);
    v347 = (double)v313 - (double)v346;
    __A.realp = 0;
    vDSP_svemg((const float *)(**(_QWORD **)(v314 + 336) + 4 * v346), 1, (float *)&__A, (unint64_t)v347);
    vDSP_svemg((const float *)(*(_QWORD *)(*(_QWORD *)(a1 + 336) + 24) + 4 * *(unsigned int *)(a1 + 500)), 1, (float *)&__A.realp + 1, (unint64_t)v347);
    v348 = *(float *)(a1 + 512);
    v349 = log10f((float)(*(float *)&__A.realp / v347) + v348);
    v350 = log10f(v348 + (float)(*((float *)&__A.realp + 1) / v347));
    vDSP_svemg((const float *)(*(_QWORD *)(*(_QWORD *)(a1 + 336) + 48) + 4 * *(unsigned int *)(a1 + 500)), 1, (float *)&__A, (unint64_t)v347);
    vDSP_svemg((const float *)(*(_QWORD *)(*(_QWORD *)(a1 + 336) + 72) + 4 * *(unsigned int *)(a1 + 500)), 1, (float *)&__A.realp + 1, (unint64_t)v347);
    v314 = a1;
    v351 = v350 * -20.0 + v349 * 20.0;
    v352 = *(float *)(a1 + 512);
    v353 = log10f((float)(*(float *)&__A.realp / v347) + v352);
    v354 = log10f(v352 + (float)(*((float *)&__A.realp + 1) / v347)) * -20.0 + v353 * 20.0;
    v355 = *(float **)(a1 + 528);
    if (v354 > v351)
    {
      v356 = 0;
      *v355 = v354;
      v355[1] = v351;
      v357 = 1;
      *(_DWORD *)(a1 + 520) = 1;
      do
      {
        v358 = 0;
        v359 = v357;
        v360 = 1;
        do
        {
          v361 = v360;
          vDSP_vswap(*(float **)(*(_QWORD *)(*(_QWORD *)(a1 + 408) + 24 * v356) + 24 * v358), 1, *(float **)(*(_QWORD *)(*(_QWORD *)(a1 + 408) + 24 * (v356 | 2)) + 24 * v358), 1, *(unsigned int *)(a1 + 60));
          v360 = 0;
          v358 = 1;
        }
        while ((v361 & 1) != 0);
        v357 = 0;
        v356 = 1;
      }
      while ((v359 & 1) != 0);
      AU::BSS1::Handset<float>::ScaleMDP(a1, v312, (uint64_t *)v312);
      v314 = a1;
    }
    else
    {
      *v355 = v351;
      v355[1] = v354;
      *(_DWORD *)(a1 + 520) = 0;
    }
  }
  AU::BSS1::Handset<float>::GenerateOutput(v314, (float ****)v497, (float ****)a3, v312);
  v362 = 0;
  v363 = 1;
  do
  {
    v364 = v363;
    v365 = *(float ***)(*(_QWORD *)a3 + 24 * v362);
    v366 = *v365;
    v367 = *(unsigned int *)(a1 + 60);
    v368 = v365[3];
    v369 = *(float **)(*(_QWORD *)(a1 + 256) + 24 * v362);
    __A.realp = v366;
    __A.imagp = v368;
    vDSP_zvabs(&__A, 1, v369, 1, v367);
    v370 = *(float **)(*(_QWORD *)(a1 + 256) + 24 * v362);
    vDSP_vsadd(v370, 1, __B, v370, 1, *(unsigned int *)(a1 + 60));
    v363 = 0;
    v362 = 1;
  }
  while ((v364 & 1) != 0);
  v371 = a1;
  if (*(_DWORD *)(a1 + 44))
  {
    v372 = (uint64_t *)a3;
    v373 = v497;
    if (*(uint64_t **)a3 != *v497)
    {
      std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(*(_QWORD *)a3, **v497, (*v497)[1], 0xAAAAAAAAAAAAAAABLL * (((*v497)[1] - **v497) >> 3));
      v371 = a1;
      v372 = (uint64_t *)a3;
      v373 = v497;
    }
    v374 = *(unsigned int *)(v371 + 60);
    if (!(_DWORD)v374)
      return 0;
    v375 = 0;
    v376 = *(_QWORD *)(*(_QWORD *)(v371 + 256) + 24);
    v377 = *(_QWORD *)(*(_QWORD *)(v371 + 232) + 24);
    v378 = *v372;
    v379 = *v373;
    v380 = 4 * v374;
    do
    {
      v381 = *(float *)(v376 + v375);
      v382 = *(float *)(v377 + v375);
      if (v381 < v382)
      {
        v383 = *(_QWORD **)(v378 + 24);
        *(float *)(*v383 + v375) = *(float *)(v371 + 832) * *(float *)(*v383 + v375);
        *(float *)(v383[3] + v375) = *(float *)(v371 + 832) * *(float *)(v383[3] + v375);
        v381 = *(float *)(v376 + v375);
        v382 = *(float *)(v377 + v375);
      }
      if (v381 > v382)
      {
        v384 = (_QWORD *)v379[3];
        v385 = *(_QWORD **)(v378 + 24);
        *(_DWORD *)(*v385 + v375) = *(_DWORD *)(*v384 + v375);
        *(_DWORD *)(v385[3] + v375) = *(_DWORD *)(v384[3] + v375);
      }
      result = 0;
      v375 += 4;
    }
    while (v380 != v375);
  }
  else
  {
    if (*(_DWORD *)(a1 + 28))
    {
      v386 = 0;
      v387 = 1;
      do
      {
        v388 = v387;
        LODWORD(__A.realp) = 0;
        vDSP_svesq(*(const float **)(*(_QWORD *)(v371 + 256) + 24 * v386), 1, (float *)&__A, *(unsigned int *)(v371 + 60));
        v387 = 0;
        v371 = a1;
        v389 = *(float **)(a1 + 624);
        v389[v386] = (float)((float)(1.0 - *(float *)(a1 + 652)) * *(float *)&__A.realp)
                   + (float)(*(float *)(a1 + 652) * v389[v386]);
        v386 = 1;
      }
      while ((v388 & 1) != 0);
      v390 = *(float ***)(a1 + 128);
      v391 = (float)(*v389 / (float)(*(float *)(a1 + 56) + v389[1])) + -10.0;
      v392 = v391 / 10.0;
      v393 = v391 < 0.0;
      v394 = 0.0;
      if (!v393)
        v394 = v392;
      if (v394 > 1.0)
        v394 = 1.0;
      v395 = v394;
      v396 = (float)((float)(*(float *)(a1 + 564) - *(float *)(a1 + 568)) * v395) + 1.025;
      *(float *)&__A.realp = v396;
      v397 = *(float *)(a1 + 556);
      vDSP_vdiv(*(const float **)(*(_QWORD *)(a1 + 256) + 24), 1, **(const float ***)(a1 + 256), 1, *v390, 1, *(unsigned int *)(a1 + 60));
      v398 = *(unsigned int *)(a1 + 60);
      v399 = **(float ***)(a1 + 128);
      if ((_DWORD)v398)
      {
        v400 = 0;
        v401 = 1.0 - v397;
        do
        {
          if (v399[v400 / 4] < *(float *)(a1 + 180))
          {
            v402 = *(_QWORD *)(a1 + 600);
            v403 = *(_QWORD **)(a1 + 256);
            v404 = (float)(v401 * *(float *)(*v403 + v400)) + (float)(*(float *)(a1 + 556) * *(float *)(v402 + v400));
            *(float *)(v402 + v400) = v404;
            *(float *)(*(_QWORD *)(a1 + 576) + v400) = (float)(v401 * (float)(v404 / *(float *)(v403[3] + v400)))
                                                     + (float)(*(float *)(a1 + 556)
                                                             * *(float *)(*(_QWORD *)(a1 + 576) + v400));
          }
          v400 += 4;
        }
        while (4 * v398 != v400);
      }
      vDSP_vmax(*(const float **)(a1 + 576), 1, (const float *)(a1 + 560), 0, v399, 1, v398);
      vDSP_vsmul(**(const float ***)(a1 + 128), 1, (const float *)&__A, **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
      v405 = *(unsigned int *)(a1 + 60);
      v371 = a1;
      if ((_DWORD)v405)
      {
        v406 = 0;
        v408 = *(uint64_t **)(a1 + 256);
        v409 = v408[3];
        v410 = **(_QWORD **)(a1 + 128);
        v411 = *(float ****)a3;
        v412 = *(uint64_t **)(*(_QWORD *)a3 + 24);
        v413 = *v412;
        v414 = v412[3];
        v415 = *(_QWORD **)(a1 + 232);
        v416 = v415[3];
        v417 = *v497;
        v418 = *v408;
        v419 = *(_DWORD *)(a1 + 16);
        v420 = 4 * v405;
        do
        {
          v421 = *(float *)(v409 + v406);
          v422 = *(float *)(v410 + v406);
          *(float *)(v413 + v406) = v422 * *(float *)(v413 + v406);
          *(float *)(v414 + v406) = v422 * *(float *)(v414 + v406);
          v423 = v421 * v422;
          if (v423 > *(float *)(v416 + v406))
          {
            v424 = (_QWORD *)v417[3];
            *(_DWORD *)(v413 + v406) = *(_DWORD *)(*v424 + v406);
            *(_DWORD *)(v414 + v406) = *(_DWORD *)(v424[3] + v406);
            v423 = *(float *)(v416 + v406);
          }
          v407 = v395 * 2.0 + 2.0;
          v425 = *(float *)(v418 + v406) * v407;
          if (v423 > v425)
          {
            v426 = v425 / v423;
            *(float *)(v413 + v406) = v426 * *(float *)(v413 + v406);
            *(float *)(v414 + v406) = v426 * *(float *)(v414 + v406);
          }
          if (v419)
          {
            v427 = *(float *)(v418 + v406);
            v428 = *(float *)(*v415 + v406);
            if (v427 <= (float)(*(float *)(a1 + 572) * v428))
            {
              v434 = v428 * *(float *)(a1 + 720);
              if (v427 > v434)
              {
                v435 = v434 / v427;
                v436 = *v411;
                (**v411)[v406 / 4] = v435 * (**v411)[v406 / 4];
                v436[3][v406 / 4] = v435 * v436[3][v406 / 4];
                v437 = *v312;
                v438 = **v312;
                (*v438)[v406 / 4] = v435 * (*v438)[v406 / 4];
                v438[3][v406 / 4] = v435 * v438[3][v406 / 4];
                v439 = v437[3];
                (*v439)[v406 / 4] = v435 * (*v439)[v406 / 4];
                v439[3][v406 / 4] = v435 * v439[3][v406 / 4];
              }
            }
            else
            {
              v429 = (_QWORD *)*v417;
              v430 = *v411;
              (**v411)[v406 / 4] = *(float *)(*(_QWORD *)*v417 + v406);
              v430[3][v406 / 4] = *(float *)(v429[3] + v406);
              v431 = *v312;
              v432 = **v312;
              (*v432)[v406 / 4] = 1.0;
              v432[3][v406 / 4] = 0.0;
              v433 = v431[3];
              (*v433)[v406 / 4] = 0.0;
              v433[3][v406 / 4] = 0.0;
            }
            v440 = *(float *)(v409 + v406);
            v441 = *(float *)(v416 + v406);
            if (v440 <= (float)(*(float *)(a1 + 572) * v441))
            {
              v446 = v441 * *(float *)(a1 + 724);
              if (v440 > v446)
              {
                v447 = v446 / v440;
                *(float *)(v413 + v406) = v447 * *(float *)(v413 + v406);
                *(float *)(v414 + v406) = v447 * *(float *)(v414 + v406);
              }
            }
            else
            {
              v442 = (_QWORD *)v417[3];
              *(_DWORD *)(v413 + v406) = *(_DWORD *)(*v442 + v406);
              *(_DWORD *)(v414 + v406) = *(_DWORD *)(v442[3] + v406);
              v443 = *v312;
              v444 = (*v312)[6];
              (*v444)[v406 / 4] = 0.0;
              v444[3][v406 / 4] = 0.0;
              v445 = v443[9];
              (*v445)[v406 / 4] = 1.0;
              v445[3][v406 / 4] = 0.0;
            }
          }
          v406 += 4;
        }
        while (v420 != v406);
      }
    }
    if (!*(_DWORD *)(v371 + 24))
      return 0;
    v448 = (char **)(v371 + 680);
    v449 = (uint64_t)(*(_QWORD *)(v371 + 688) - *(_QWORD *)(v371 + 680)) >> 2;
    LODWORD(__A.realp) = 0;
    std::vector<float>::assign((char **)(v371 + 680), v449, &__A);
    v450 = a1;
    v451 = *(float *)(a1 + 732) + 1.0;
    *(float *)(a1 + 732) = v451;
    v452 = (float)*(unsigned int *)(a1 + 68);
    v453 = (float)(*(float *)(v450 + 300) * *(float *)(v450 + 64)) / v452;
    if (v451 > v453)
      *(float *)(a1 + 732) = v453;
    v454 = 0;
    v455 = *(_QWORD *)(a1 + 768);
    v456 = *(float **)(a1 + 528);
    v457 = 1;
    v458 = *(float **)(a1 + 792);
    do
    {
      v459 = v457;
      v460 = (float)(*(float *)(a1 + 820) * *(float *)(v455 + 4 * v454)) + (1.0 - *(float *)(a1 + 820)) * v456[v454];
      *(float *)(v455 + 4 * v454) = v460;
      v461 = (float)(*(float *)(a1 + 820) * v458[v454])
           + (1.0 - *(float *)(a1 + 820)) * (float)((float)(v456[v454] * v456[v454]) - (float)(v460 * v460));
      v458[v454] = v461;
      v454 = 1;
      v457 = 0;
    }
    while ((v459 & 1) != 0);
    if (fabsf(v458[*(_DWORD *)(a1 + 520) == 1]) > *(float *)(a1 + 824)
      && (float)(fabsf(*v458) + fabsf(v458[1])) > *(float *)(a1 + 828))
    {
      *(_DWORD *)(a1 + 732) = 0;
    }
    if ((float)((float)(*(float *)(a1 + 732) * v452) / *(float *)(a1 + 64)) < *(float *)(a1 + 740))
    {
      v462 = (uint64_t)(*(_QWORD *)(a1 + 688) - *(_QWORD *)(a1 + 680)) >> 2;
      LODWORD(__A.realp) = 1065353216;
      std::vector<float>::assign(v448, v462, &__A);
      v450 = a1;
      v456 = *(float **)(a1 + 528);
    }
    v463 = *v456;
    v464 = v456[1];
    if (vabds_f32(*v456, v464) < *(float *)(v450 + 744))
      goto LABEL_172;
    v465 = v464 >= v463 ? *v456 : v456[1];
    if (v465 > *(float *)(v450 + 748) || v465 < *(float *)(v450 + 752))
      goto LABEL_172;
    if (v463 < v464)
      v463 = v456[1];
    if (v463 < *(float *)(v450 + 756) || v463 > *(float *)(v450 + 760))
    {
LABEL_172:
      v466 = (uint64_t)(*(_QWORD *)(v450 + 688) - *(_QWORD *)(v450 + 680)) >> 2;
      LODWORD(__A.realp) = 1065353216;
      std::vector<float>::assign(v448, v466, &__A);
      v450 = a1;
    }
    v467 = *(unsigned int *)(v450 + 60);
    if ((_DWORD)v467)
    {
      v468 = 0;
      v469 = *(_QWORD *)(v450 + 680);
      v470 = *(const float **)(v450 + 656);
      do
      {
        v471 = *(float *)(v469 + v468 * 4);
        v472 = v470[v468];
        if (v471 <= v472)
          v473 = 708;
        else
          v473 = 716;
        v474 = (float)(v472 * *(float *)(v450 + v473)) + (1.0 - *(float *)(v450 + v473)) * v471;
        v470[v468++] = v474;
      }
      while (v467 != v468);
    }
    else
    {
      v470 = *(const float **)(v450 + 656);
    }
    v475 = (const float ***)(v450 + 128);
    vDSP_vneg(v470, 1, **(float ***)(v450 + 128), 1, v467);
    vDSP_vsadd(**v475, 1, (const float *)(a1 + 48), (float *)**v475, 1, *(unsigned int *)(a1 + 60));
    v476 = 0;
    v477 = 1;
    v478 = a1;
    do
    {
      v479 = v477;
      v481 = *(float ***)(v478 + 152);
      v480 = (const float **)(v478 + 152);
      vDSP_vmul(v480[63], 1, *(const float **)(*v497)[3 * v476], 1, *v481, 1, *((unsigned int *)v480 - 23));
      vDSP_vmul(v480[63], 1, *(const float **)((*v497)[3 * v476] + 24), 1, *((float **)*v480 + 3), 1, *((unsigned int *)v480 - 23));
      v482 = **(float ***)(*(_QWORD *)a3 + 24 * v476);
      vDSP_vmul(**(const float ***)(a1 + 128), 1, v482, 1, v482, 1, *((unsigned int *)v480 - 23));
      v483 = *(float **)(*(_QWORD *)(*(_QWORD *)a3 + 24 * v476) + 24);
      vDSP_vmul(**(const float ***)(a1 + 128), 1, v483, 1, v483, 1, *((unsigned int *)v480 - 23));
      v484 = *(float ***)(*(_QWORD *)a3 + 24 * v476);
      v485 = *v484;
      v486 = v484[3];
      v487 = *(float **)*v480;
      v488 = (float *)*((_QWORD *)*v480 + 3);
      v489 = *((unsigned int *)v480 - 23);
      __A.realp = v485;
      __A.imagp = v486;
      v501.realp = v487;
      v501.imagp = v488;
      __C.realp = v485;
      __C.imagp = v486;
      vDSP_zvadd(&__A, 1, &v501, 1, &__C, 1, v489);
      v477 = 0;
      result = 0;
      v476 = 1;
      v478 = a1;
    }
    while ((v479 & 1) != 0);
  }
  return result;
}

uint64_t AU::BSS1::Handset<float>::SideChainProcess(uint64_t a1, const float ****a2, const float ****a3)
{
  float **v6;
  float *v7;
  float *v8;
  float **v9;
  float *v10;
  float *v11;
  float **v12;
  float *v13;
  float *v14;
  vDSP_Length v15;
  float **v16;
  float *v17;
  float *v18;
  float **v19;
  float *v20;
  float *v21;
  float **v22;
  float *v23;
  float *v24;
  vDSP_Length v25;
  float **v26;
  float *v27;
  float *v28;
  float **v29;
  float *v30;
  float *v31;
  float **v32;
  float *v33;
  float *v34;
  vDSP_Length v35;
  float **v36;
  float *v37;
  float *v38;
  float **v39;
  float *v40;
  float *v41;
  vDSP_Length v42;
  DSPSplitComplex v44;
  DSPSplitComplex __B;
  DSPSplitComplex __A;

  v6 = **(float ****)(a1 + 408);
  v7 = *v6;
  v8 = v6[3];
  v9 = (float **)**a2;
  v10 = *v9;
  v11 = v9[3];
  v12 = *(float ***)(a1 + 128);
  v13 = *v12;
  v14 = v12[3];
  v15 = *(unsigned int *)(a1 + 60);
  __A.realp = v7;
  __A.imagp = v8;
  __B.realp = v10;
  __B.imagp = v11;
  v44.realp = v13;
  v44.imagp = v14;
  vDSP_zvmul(&__A, 1, &__B, 1, &v44, 1, v15, 1);
  v16 = *(float ***)(*(_QWORD *)(a1 + 408) + 24);
  v17 = *v16;
  v18 = v16[3];
  v19 = (float **)(*a2)[3];
  v20 = *v19;
  v21 = v19[3];
  v22 = *(float ***)(a1 + 152);
  v23 = *v22;
  v24 = v22[3];
  v25 = *(unsigned int *)(a1 + 60);
  __A.realp = v17;
  __A.imagp = v18;
  __B.realp = v20;
  __B.imagp = v21;
  v44.realp = v23;
  v44.imagp = v24;
  vDSP_zvmul(&__A, 1, &__B, 1, &v44, 1, v25, 1);
  v26 = *(float ***)(a1 + 128);
  v27 = *v26;
  v28 = v26[3];
  v29 = *(float ***)(a1 + 152);
  v30 = *v29;
  v31 = v29[3];
  v32 = (float **)**a3;
  v33 = *v32;
  v34 = v32[3];
  v35 = *(unsigned int *)(a1 + 60);
  __A.realp = v27;
  __A.imagp = v28;
  __B.realp = v30;
  __B.imagp = v31;
  v44.realp = v33;
  v44.imagp = v34;
  vDSP_zvadd(&__A, 1, &__B, 1, &v44, 1, v35);
  vDSP_vneg(*(const float **)(a1 + 656), 1, **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
  vDSP_vsadd(**(const float ***)(a1 + 128), 1, (const float *)(a1 + 48), **(float ***)(a1 + 128), 1, *(unsigned int *)(a1 + 60));
  vDSP_vmul(*(const float **)(a1 + 656), 1, ***a2, 1, **(float ***)(a1 + 152), 1, *(unsigned int *)(a1 + 60));
  vDSP_vmul(*(const float **)(a1 + 656), 1, (**a2)[3], 1, *(float **)(*(_QWORD *)(a1 + 152) + 24), 1, *(unsigned int *)(a1 + 60));
  vDSP_vmul(**(const float ***)(a1 + 128), 1, ***a3, 1, (float *)***a3, 1, *(unsigned int *)(a1 + 60));
  vDSP_vmul(**(const float ***)(a1 + 128), 1, (**a3)[3], 1, (float *)(**a3)[3], 1, *(unsigned int *)(a1 + 60));
  v36 = (float **)**a3;
  v37 = *v36;
  v38 = v36[3];
  v39 = *(float ***)(a1 + 152);
  v40 = *v39;
  v41 = v39[3];
  v42 = *(unsigned int *)(a1 + 60);
  __A.realp = v37;
  __A.imagp = v38;
  __B.realp = v40;
  __B.imagp = v41;
  v44.realp = v37;
  v44.imagp = v38;
  vDSP_zvadd(&__A, 1, &__B, 1, &v44, 1, v42);
  return 0;
}

uint64_t AU::BSS1::Handset<float>::UpdateParam(uint64_t a1, unsigned int a2, float a3)
{
  if (!*(_BYTE *)(a1 + 8))
    return 4294956429;
  if (a2 < 3)
    return 0;
  if (a2 == 4)
    goto LABEL_8;
  if (a2 == 3)
  {
    *(float *)(a1 + 736) = a3;
LABEL_8:
    *(_DWORD *)(a1 + 44) = a3;
  }
  return 1;
}

void AU::BSS1::Handset<float>::ScaleMDP(uint64_t a1, float ****a2, uint64_t *a3)
{
  float **v6;
  float *v7;
  float *v8;
  float **v9;
  float *v10;
  float *v11;
  float **v12;
  float *v13;
  float *v14;
  vDSP_Length v15;
  float **v16;
  float *v17;
  float *v18;
  float **v19;
  float *v20;
  float *v21;
  float **v22;
  float *v23;
  float *v24;
  vDSP_Length v25;
  float **v26;
  float *v27;
  float *v28;
  float **v29;
  float *v30;
  float *v31;
  float **v32;
  float *v33;
  float *v34;
  vDSP_Length v35;
  float **v36;
  float *v37;
  float *v38;
  float **v39;
  float *v40;
  float *v41;
  vDSP_Length v42;
  uint64_t i;
  float **v44;
  float *v45;
  float *v46;
  float **v47;
  float *v48;
  float *v49;
  vDSP_Length v50;
  float **v51;
  float *v52;
  float *v53;
  float *v54;
  vDSP_Length v55;
  float **v56;
  float *v57;
  float *v58;
  float *v59;
  vDSP_Length v60;
  float **v61;
  float *v62;
  float *v63;
  float *v64;
  vDSP_Length v65;
  uint64_t v66;
  uint64_t v67;
  DSPSplitComplex v68;
  DSPSplitComplex __B;
  DSPSplitComplex __A;

  AU::BSS1::Handset<float>::VectorizedDetInverseOf2x2(a1, a2, (float ***)(a1 + 128));
  v6 = **a2;
  v7 = *v6;
  v8 = v6[3];
  v9 = (*a2)[9];
  v10 = *v9;
  v11 = v9[3];
  v12 = *(float ***)*a3;
  v13 = *v12;
  v14 = v12[3];
  v15 = *(unsigned int *)(a1 + 60);
  __A.realp = v7;
  __A.imagp = v8;
  __B.realp = v10;
  __B.imagp = v11;
  v68.realp = v13;
  v68.imagp = v14;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v15, 1);
  v16 = (*a2)[9];
  v17 = *v16;
  v18 = v16[3];
  v19 = (*a2)[3];
  v20 = *v19;
  v21 = v19[3];
  v22 = *(float ***)(*a3 + 24);
  v23 = *v22;
  v24 = v22[3];
  v25 = *(unsigned int *)(a1 + 60);
  __A.realp = v17;
  __A.imagp = v18;
  __B.realp = v20;
  __B.imagp = v21;
  v68.realp = v23;
  v68.imagp = v24;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v25, 1);
  v26 = **a2;
  v27 = *v26;
  v28 = v26[3];
  v29 = (*a2)[6];
  v30 = *v29;
  v31 = v29[3];
  v32 = *(float ***)(*a3 + 48);
  v33 = *v32;
  v34 = v32[3];
  v35 = *(unsigned int *)(a1 + 60);
  __A.realp = v27;
  __A.imagp = v28;
  __B.realp = v30;
  __B.imagp = v31;
  v68.realp = v33;
  v68.imagp = v34;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v35, 1);
  v36 = *(float ***)*a3;
  v37 = *v36;
  v38 = v36[3];
  v39 = *(float ***)(*a3 + 72);
  v40 = *v39;
  v41 = v39[3];
  v42 = *(unsigned int *)(a1 + 60);
  __A.realp = v37;
  __A.imagp = v38;
  __B.realp = v40;
  __B.imagp = v41;
  vDSP_zvmov(&__A, 1, &__B, 1, v42);
  for (i = 0; i != 96; i += 24)
  {
    v44 = *(float ***)(a1 + 128);
    v45 = *v44;
    v46 = v44[3];
    v47 = *(float ***)(*a3 + i);
    v48 = *v47;
    v49 = v47[3];
    v50 = *(unsigned int *)(a1 + 60);
    __A.realp = v45;
    __A.imagp = v46;
    __B.realp = v48;
    __B.imagp = v49;
    v68.realp = v48;
    v68.imagp = v49;
    vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v50, 1);
  }
  AU::BSS1::Handset<float>::ClearDCAndNyquist(*(unsigned int *)(a1 + 60), *a3);
  v51 = *(float ***)*a3;
  v52 = *v51;
  v53 = v51[3];
  v54 = **(float ***)(a1 + 336);
  v55 = *(unsigned int *)(a1 + 60);
  __A.realp = v52;
  __A.imagp = v53;
  vDSP_zvabs(&__A, 1, v54, 1, v55);
  v56 = *(float ***)(*a3 + 48);
  v57 = *v56;
  v58 = v56[3];
  v59 = *(float **)(*(_QWORD *)(a1 + 336) + 24);
  v60 = *(unsigned int *)(a1 + 60);
  __A.realp = v57;
  __A.imagp = v58;
  vDSP_zvabs(&__A, 1, v59, 1, v60);
  v61 = *(float ***)(*a3 + 24);
  v62 = *v61;
  v63 = v61[3];
  v64 = *(float **)(*(_QWORD *)(a1 + 336) + 48);
  v65 = *(unsigned int *)(a1 + 60);
  __A.realp = v62;
  __A.imagp = v63;
  vDSP_zvabs(&__A, 1, v64, 1, v65);
  v66 = *(_QWORD *)(a1 + 336);
  v67 = *(_QWORD *)(v66 + 8);
  if (v67 != *(_QWORD *)v66)
    memmove(*(void **)(v66 + 72), *(const void **)v66, v67 - *(_QWORD *)v66);
}

void AU::BSS1::Handset<float>::GenerateOutput(uint64_t a1, float ****a2, float ****a3, float ****a4)
{
  float **v8;
  float *v9;
  float *v10;
  float **v11;
  float *v12;
  float *v13;
  float **v14;
  float *v15;
  float *v16;
  vDSP_Length v17;
  float **v18;
  float *v19;
  float *v20;
  float **v21;
  float *v22;
  float *v23;
  float **v24;
  float *v25;
  float *v26;
  vDSP_Length v27;
  float **v28;
  float *v29;
  float *v30;
  float **v31;
  float *v32;
  float *v33;
  float **v34;
  float *v35;
  float *v36;
  vDSP_Length v37;
  float **v38;
  float *v39;
  float *v40;
  float **v41;
  float *v42;
  float *v43;
  float **v44;
  float *v45;
  float *v46;
  vDSP_Length v47;
  float **v48;
  float *v49;
  float *v50;
  float **v51;
  float *v52;
  float *v53;
  float **v54;
  float *v55;
  float *v56;
  vDSP_Length v57;
  float **v58;
  float *v59;
  float *v60;
  float **v61;
  float *v62;
  float *v63;
  float **v64;
  float *v65;
  float *v66;
  vDSP_Length v67;
  DSPSplitComplex v68;
  DSPSplitComplex __B;
  DSPSplitComplex __A;

  v8 = **a4;
  v9 = *v8;
  v10 = v8[3];
  v11 = **a2;
  v12 = *v11;
  v13 = v11[3];
  v14 = *(float ***)(a1 + 128);
  v15 = *v14;
  v16 = v14[3];
  v17 = *(unsigned int *)(a1 + 60);
  __A.realp = v9;
  __A.imagp = v10;
  __B.realp = v12;
  __B.imagp = v13;
  v68.realp = v15;
  v68.imagp = v16;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v17, 1);
  v18 = (*a4)[3];
  v19 = *v18;
  v20 = v18[3];
  v21 = (*a2)[3];
  v22 = *v21;
  v23 = v21[3];
  v24 = *(float ***)(a1 + 152);
  v25 = *v24;
  v26 = v24[3];
  v27 = *(unsigned int *)(a1 + 60);
  __A.realp = v19;
  __A.imagp = v20;
  __B.realp = v22;
  __B.imagp = v23;
  v68.realp = v25;
  v68.imagp = v26;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v27, 1);
  v28 = *(float ***)(a1 + 128);
  v29 = *v28;
  v30 = v28[3];
  v31 = *(float ***)(a1 + 152);
  v32 = *v31;
  v33 = v31[3];
  v34 = **a3;
  v35 = *v34;
  v36 = v34[3];
  v37 = *(unsigned int *)(a1 + 60);
  __A.realp = v29;
  __A.imagp = v30;
  __B.realp = v32;
  __B.imagp = v33;
  v68.realp = v35;
  v68.imagp = v36;
  vDSP_zvadd(&__A, 1, &__B, 1, &v68, 1, v37);
  v38 = **a2;
  v39 = *v38;
  v40 = v38[3];
  v41 = (*a4)[6];
  v42 = *v41;
  v43 = v41[3];
  v44 = *(float ***)(a1 + 128);
  v45 = *v44;
  v46 = v44[3];
  v47 = *(unsigned int *)(a1 + 60);
  __A.realp = v39;
  __A.imagp = v40;
  __B.realp = v42;
  __B.imagp = v43;
  v68.realp = v45;
  v68.imagp = v46;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v47, 1);
  v48 = (*a2)[3];
  v49 = *v48;
  v50 = v48[3];
  v51 = (*a4)[9];
  v52 = *v51;
  v53 = v51[3];
  v54 = *(float ***)(a1 + 152);
  v55 = *v54;
  v56 = v54[3];
  v57 = *(unsigned int *)(a1 + 60);
  __A.realp = v49;
  __A.imagp = v50;
  __B.realp = v52;
  __B.imagp = v53;
  v68.realp = v55;
  v68.imagp = v56;
  vDSP_zvmul(&__A, 1, &__B, 1, &v68, 1, v57, 1);
  v58 = *(float ***)(a1 + 128);
  v59 = *v58;
  v60 = v58[3];
  v61 = *(float ***)(a1 + 152);
  v62 = *v61;
  v63 = v61[3];
  v64 = (*a3)[3];
  v65 = *v64;
  v66 = v64[3];
  v67 = *(unsigned int *)(a1 + 60);
  __A.realp = v59;
  __A.imagp = v60;
  __B.realp = v62;
  __B.imagp = v63;
  v68.realp = v65;
  v68.imagp = v66;
  vDSP_zvadd(&__A, 1, &__B, 1, &v68, 1, v67);
}

void AU::BSS1::Handset<float>::VectorizedDetInverseOf2x2(uint64_t a1, float ****a2, float ***a3)
{
  float **v6;
  float *v7;
  float *v8;
  float **v9;
  float *v10;
  float *v11;
  float **v12;
  float *v13;
  float *v14;
  vDSP_Length v15;
  float **v16;
  float *v17;
  float *v18;
  float **v19;
  float *v20;
  float *v21;
  float **v22;
  float *v23;
  float *v24;
  vDSP_Length v25;
  float **v26;
  float *v27;
  float *v28;
  float **v29;
  float *v30;
  float *v31;
  vDSP_Length v32;
  float **v33;
  float *v34;
  float *v35;
  float *v36;
  float *v37;
  vDSP_Length v38;
  DSPSplitComplex v39;
  DSPSplitComplex __B;
  DSPSplitComplex __A;

  v6 = **a2;
  v7 = *v6;
  v8 = v6[3];
  v9 = (*a2)[9];
  v10 = *v9;
  v11 = v9[3];
  v12 = *(float ***)(a1 + 128);
  v13 = *v12;
  v14 = v12[3];
  v15 = *(unsigned int *)(a1 + 60);
  __A.realp = v7;
  __A.imagp = v8;
  __B.realp = v10;
  __B.imagp = v11;
  v39.realp = v13;
  v39.imagp = v14;
  vDSP_zvmul(&__A, 1, &__B, 1, &v39, 1, v15, 1);
  v16 = (*a2)[3];
  v17 = *v16;
  v18 = v16[3];
  v19 = (*a2)[6];
  v20 = *v19;
  v21 = v19[3];
  v22 = *(float ***)(a1 + 152);
  v23 = *v22;
  v24 = v22[3];
  v25 = *(unsigned int *)(a1 + 60);
  __A.realp = v17;
  __A.imagp = v18;
  __B.realp = v20;
  __B.imagp = v21;
  v39.realp = v23;
  v39.imagp = v24;
  vDSP_zvmul(&__A, 1, &__B, 1, &v39, 1, v25, 1);
  v26 = *(float ***)(a1 + 128);
  v27 = *v26;
  v28 = v26[3];
  v29 = *(float ***)(a1 + 152);
  v30 = *v29;
  v31 = v29[3];
  v32 = *(unsigned int *)(a1 + 60);
  __A.realp = v27;
  __A.imagp = v28;
  __B.realp = v30;
  __B.imagp = v31;
  v39.realp = v30;
  v39.imagp = v31;
  vDSP_zvsub(&__A, 1, &__B, 1, &v39, 1, v32);
  vDSP_vsadd(**(const float ***)(a1 + 152), 1, (const float *)(a1 + 56), **(float ***)(a1 + 152), 1, *(unsigned int *)(a1 + 60));
  v33 = *(float ***)(a1 + 152);
  v34 = *v33;
  v35 = v33[3];
  v36 = **a3;
  v37 = (*a3)[3];
  v38 = *(unsigned int *)(a1 + 60);
  __A.realp = (float *)(a1 + 48);
  __A.imagp = (float *)(a1 + 52);
  __B.realp = v34;
  __B.imagp = v35;
  v39.realp = v36;
  v39.imagp = v37;
  vDSP_zvdiv(&__B, 1, &__A, 0, &v39, 1, v38);
}

uint64_t AU::BSS1::Handset<float>::ClearDCAndNyquist(uint64_t result, uint64_t a2)
{
  _DWORD **v2;
  _DWORD *v3;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  _DWORD *v9;
  _DWORD *v10;
  _DWORD *v11;
  _DWORD *v12;
  _DWORD *v13;
  int v14;

  v2 = *(_DWORD ***)a2;
  v3 = **(_DWORD ***)a2;
  *v3 = 1065353216;
  v4 = *(_QWORD *)(a2 + 24);
  v5 = *(_DWORD **)v4;
  *v5 = 0;
  v6 = *(_QWORD *)(a2 + 48);
  v7 = *(_DWORD **)v6;
  *v7 = 0;
  v8 = *(_QWORD *)(a2 + 72);
  v9 = *(_DWORD **)v8;
  *v9 = 1065353216;
  v10 = v2[3];
  *v10 = 0;
  v11 = *(_DWORD **)(v4 + 24);
  *v11 = 0;
  v12 = *(_DWORD **)(v6 + 24);
  *v12 = 0;
  v13 = *(_DWORD **)(v8 + 24);
  *v13 = 0;
  v14 = result - 1;
  v3[v14] = 1065353216;
  v5[v14] = 0;
  v7[v14] = 0;
  v9[v14] = 1065353216;
  v10[v14] = 0;
  v11[v14] = 0;
  v12[v14] = 0;
  v13[v14] = 0;
  return result;
}

uint64_t std::__split_buffer<std::vector<std::vector<std::vector<float>>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void **v4;
  void **v6;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = (void **)(i - 24);
    *(_QWORD *)(a1 + 16) = v4;
    v6 = v4;
    std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v6);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t AU::BSS1::Handset<float>::~Handset(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void **v14;

  *(_QWORD *)a1 = &off_1E69C90E8;
  v2 = *(void **)(a1 + 792);
  if (v2)
  {
    *(_QWORD *)(a1 + 800) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 768);
  if (v3)
  {
    *(_QWORD *)(a1 + 776) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 680);
  if (v4)
  {
    *(_QWORD *)(a1 + 688) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 656);
  if (v5)
  {
    *(_QWORD *)(a1 + 664) = v5;
    operator delete(v5);
  }
  v6 = *(void **)(a1 + 624);
  if (v6)
  {
    *(_QWORD *)(a1 + 632) = v6;
    operator delete(v6);
  }
  v7 = *(void **)(a1 + 600);
  if (v7)
  {
    *(_QWORD *)(a1 + 608) = v7;
    operator delete(v7);
  }
  v8 = *(void **)(a1 + 576);
  if (v8)
  {
    *(_QWORD *)(a1 + 584) = v8;
    operator delete(v8);
  }
  v9 = *(void **)(a1 + 528);
  if (v9)
  {
    *(_QWORD *)(a1 + 536) = v9;
    operator delete(v9);
  }
  v14 = (void **)(a1 + 456);
  std::vector<std::vector<std::vector<std::vector<float>>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v14 = (void **)(a1 + 432);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v14 = (void **)(a1 + 408);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v10 = *(void **)(a1 + 384);
  if (v10)
  {
    *(_QWORD *)(a1 + 392) = v10;
    operator delete(v10);
  }
  v11 = *(void **)(a1 + 360);
  if (v11)
  {
    *(_QWORD *)(a1 + 368) = v11;
    operator delete(v11);
  }
  v14 = (void **)(a1 + 336);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v14 = (void **)(a1 + 256);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v14 = (void **)(a1 + 232);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v12 = *(void **)(a1 + 208);
  if (v12)
  {
    *(_QWORD *)(a1 + 216) = v12;
    operator delete(v12);
  }
  v14 = (void **)(a1 + 152);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v14 = (void **)(a1 + 128);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v14 = (void **)(a1 + 104);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v14 = (void **)(a1 + 80);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  return a1;
}

id getIntToNSStringScopeMap(void)
{
  unsigned __int8 v0;
  _QWORD v2[8];
  _QWORD v3[9];

  v3[8] = *MEMORY[0x1E0C80C00];
  {
    v2[0] = &unk_1E6A119C0;
    v2[1] = &unk_1E6A119D8;
    v3[0] = CFSTR("Global");
    v3[1] = CFSTR("Input");
    v2[2] = &unk_1E6A119F0;
    v2[3] = &unk_1E6A11A08;
    v3[2] = CFSTR("Output");
    v3[3] = CFSTR("Group");
    v2[4] = &unk_1E6A11A20;
    v2[5] = &unk_1E6A11A38;
    v3[4] = CFSTR("Part");
    v3[5] = CFSTR("Note");
    v2[6] = &unk_1E6A11A50;
    v2[7] = &unk_1E6A11A68;
    v3[6] = CFSTR("Layer");
    v3[7] = CFSTR("LayerItem");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v3, v2, 8);
    getIntToNSStringScopeMap(void)::intToNSStringMapScope = objc_claimAutoreleasedReturnValue();
  }
  return (id)getIntToNSStringScopeMap(void)::intToNSStringMapScope;
}

void sub_1B61594BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id createNSDescriptionFromDSPGraphBox(DSPGraph::Box *a1)
{
  uint64_t v2;
  void *v3;
  unint64_t i;
  uint64_t v5;
  id v6;
  void *v7;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  unsigned int v12;
  char v13;
  uint64_t *v14;
  uint64_t v15;
  void *v16;
  id v17;
  uint64_t *v18;
  uint64_t *v19;
  BOOL v20;
  id v21;
  void *v22;
  unint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  void *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t **v29;
  uint64_t **v30;
  uint64_t v31;
  uint64_t *v32;
  unsigned int v33;
  char v34;
  uint64_t *v35;
  uint64_t v36;
  void *v37;
  id v38;
  uint64_t *v39;
  uint64_t **v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  unint64_t j;
  void *v46;
  unsigned int *v47;
  unint64_t v48;
  float v49;
  id v50;
  double v51;
  const __CFString *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  id v59;
  void *v60;
  void *v61;
  unint64_t v62;
  unint64_t v63;
  void *v64;
  void *v65;
  void *v66;
  int v67;
  unsigned int v68;
  int v69;
  void *__p;
  _BYTE *v71;
  std::vector<char> v72;
  id v73;
  char v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v59 = (id)objc_claimAutoreleasedReturnValue();
  if ((*(uint64_t (**)(DSPGraph::Box *))(*(_QWORD *)a1 + 216))(a1))
  {
    v2 = (*(uint64_t (**)(DSPGraph::Box *))(*(_QWORD *)a1 + 216))(a1);
    createNSDescriptionFromAudioUnit(*(OpaqueAudioComponentInstance **)(v2 + 848));
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v59, "setObject:forKey:", v3, CFSTR("AUState"));

  }
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  getIntToNSStringScopeMap();
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  v63 = objc_msgSend(v61, "count");
  if (!v63)
    goto LABEL_55;
  for (i = 0; i < v63; i = (i + 1))
  {
    v67 = 4;
    v68 = 0;
    if ((*(unsigned int (**)(DSPGraph::Box *, uint64_t, unint64_t, _QWORD, unsigned int *, int *))(*(_QWORD *)a1 + 304))(a1, 11, i, 0, &v68, &v67))
    {
      continue;
    }
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v65 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v68)
      goto LABEL_53;
    v5 = 0;
    do
    {
      objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
      v6 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      {
        qword_1EF136960 = 0;
        qword_1EF136958 = 0;
        getBoxGenericPropertyMap(void)::gMap = (uint64_t)&qword_1EF136958;
      }
      if (getBoxGenericPropertyMap(void)::onceToken != -1)
        dispatch_once(&getBoxGenericPropertyMap(void)::onceToken, &__block_literal_global_248);
      v9 = getBoxGenericPropertyMap(void)::gMap;
      if ((uint64_t *)getBoxGenericPropertyMap(void)::gMap != &qword_1EF136958)
      {
        do
        {
          v10 = *(unsigned int *)(v9 + 32);
          v11 = *(id *)(v9 + 40);
          v12 = (*(uint64_t (**)(DSPGraph::Box *, uint64_t, unint64_t, uint64_t))(*(_QWORD *)a1 + 296))(a1, v10, i, v5);
          if (v13)
          {
            std::vector<char>::vector(&v72, v12);
            LODWORD(__p) = LODWORD(v72.__end_) - LODWORD(v72.__begin_);
            if (!(*(unsigned int (**)(DSPGraph::Box *, uint64_t, unint64_t, uint64_t, void **))(*(_QWORD *)a1 + 304))(a1, v10, i, v5, &__p))
            {
              getValueTypeFunctionCastMap();
              v69 = (int)__p;
              v14 = std::map<unsigned int,SpatialCaptureParameterInfo>::at((uint64_t *)qword_1EF136958, v10);
              v15 = std::map<ValueType,std::function<objc_object * ()(void *,unsigned int *)>>::at(*((_DWORD *)v14 + 2));
              std::function<objc_object * ()(void *,unsigned int *)>::operator()(*(_QWORD *)(v15 + 24), (uint64_t)v72.__begin_, (uint64_t)&v69);
              v16 = (void *)objc_claimAutoreleasedReturnValue();
              v17 = (id)*std::map<unsigned int,SpatialCaptureParameterInfo>::at((uint64_t *)qword_1EF136958, v10);
              objc_msgSend(v7, "setObject:forKey:", v16, v17);

            }
            if (v72.__begin_)
            {
              v72.__end_ = v72.__begin_;
              operator delete(v72.__begin_);
            }
          }

          v18 = *(uint64_t **)(v9 + 8);
          if (v18)
          {
            do
            {
              v19 = v18;
              v18 = (uint64_t *)*v18;
            }
            while (v18);
          }
          else
          {
            do
            {
              v19 = *(uint64_t **)(v9 + 16);
              v20 = *v19 == v9;
              v9 = (uint64_t)v19;
            }
            while (!v20);
          }
          v9 = (uint64_t)v19;
        }
        while (v19 != &qword_1EF136958);
      }
      objc_msgSend(v6, "setObject:forKey:", v7, CFSTR("Generic"));

      v21 = v6;
      objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      v23 = (*(uint64_t (**)(DSPGraph::Box *))(*(_QWORD *)a1 + 16))(a1);
      getBoxSpecificPropertyMap();
      v24 = (_QWORD *)qword_1EF136980;
      if (!qword_1EF136980)
      {
LABEL_28:
        objc_msgSend(v22, "setObject:forKey:", CFSTR("EitherNoPropertiesElseNeedsToBeAdded"), CFSTR("BoxSpecificPropertiesUnavailable"));
        goto LABEL_29;
      }
      while (1)
      {
        v25 = v24[4];
        if (v23 >= v25)
          break;
LABEL_27:
        v24 = (_QWORD *)*v24;
        if (!v24)
          goto LABEL_28;
      }
      if (v25 < v23)
      {
        ++v24;
        goto LABEL_27;
      }
      getBoxSpecificPropertyMap();
      v27 = (_QWORD *)qword_1EF136980;
      if (!qword_1EF136980)
LABEL_71:
        std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
      while (1)
      {
        while (1)
        {
          v28 = v27[4];
          if (v23 >= v28)
            break;
          v27 = (_QWORD *)*v27;
          if (!v27)
            goto LABEL_71;
        }
        if (v28 >= v23)
          break;
        v27 = (_QWORD *)v27[1];
        if (!v27)
          goto LABEL_71;
      }
      v29 = (uint64_t **)v27[5];
      v30 = (uint64_t **)(v27 + 6);
      if (v29 != v27 + 6)
      {
        do
        {
          v31 = *((unsigned int *)v29 + 8);
          v32 = v29[5];
          v33 = (*(uint64_t (**)(DSPGraph::Box *, uint64_t, unint64_t, uint64_t))(*(_QWORD *)a1 + 296))(a1, v31, i, v5);
          if (v34)
          {
            std::vector<char>::vector(&v72, v33);
            LODWORD(__p) = LODWORD(v72.__end_) - LODWORD(v72.__begin_);
            if (!(*(unsigned int (**)(DSPGraph::Box *, uint64_t, unint64_t, uint64_t, void **))(*(_QWORD *)a1 + 304))(a1, v31, i, v5, &__p))
            {
              getValueTypeFunctionCastMap();
              v69 = (int)__p;
              v35 = std::map<unsigned int,SpatialCaptureParameterInfo>::at(*v30, v31);
              v36 = std::map<ValueType,std::function<objc_object * ()(void *,unsigned int *)>>::at(*((_DWORD *)v35 + 2));
              std::function<objc_object * ()(void *,unsigned int *)>::operator()(*(_QWORD *)(v36 + 24), (uint64_t)v72.__begin_, (uint64_t)&v69);
              v37 = (void *)objc_claimAutoreleasedReturnValue();
              v38 = (id)*std::map<unsigned int,SpatialCaptureParameterInfo>::at(*v30, v31);
              objc_msgSend(v22, "setObject:forKey:", v37, v38);

            }
            if (v72.__begin_)
            {
              v72.__end_ = v72.__begin_;
              operator delete(v72.__begin_);
            }
          }

          v39 = v29[1];
          if (v39)
          {
            do
            {
              v40 = (uint64_t **)v39;
              v39 = (uint64_t *)*v39;
            }
            while (v39);
          }
          else
          {
            do
            {
              v40 = (uint64_t **)v29[2];
              v20 = *v40 == (uint64_t *)v29;
              v29 = v40;
            }
            while (!v20);
          }
          v29 = v40;
        }
        while (v40 != v30);
      }
LABEL_29:
      objc_msgSend(v21, "setObject:forKey:", v22, CFSTR("SubTypeSpecific"));

      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Element: %u"), v5);
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v65, "setObject:forKey:", v21, v26);

      v5 = (v5 + 1);
    }
    while (v5 < v68);
LABEL_53:
    v41 = (void *)MEMORY[0x1E0CB3940];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", i);
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v61, "objectForKey:", v42);
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v41, "stringWithFormat:", CFSTR("Scope : %@"), v43);
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v60, "setObject:forKey:", v65, v44);

  }
LABEL_55:

  objc_msgSend(v59, "setObject:forKey:", v60, CFSTR("BoxProperties"));
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  getIntToNSStringScopeMap();
  v66 = (void *)objc_claimAutoreleasedReturnValue();
  v62 = objc_msgSend(v66, "count");
  if (v62)
  {
    for (j = 0; j < v62; j = (j + 1))
    {
      objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
      v46 = (void *)objc_claimAutoreleasedReturnValue();
      (*(void (**)(void **__return_ptr, DSPGraph::Box *, unint64_t))(*(_QWORD *)a1 + 96))(&__p, a1, j);
      v47 = (unsigned int *)__p;
      if (v71 != __p)
      {
        v48 = 0;
        do
        {
          (*(void (**)(std::vector<char> *__return_ptr, DSPGraph::Box *, unint64_t, _QWORD))(*(_QWORD *)a1 + 104))(&v72, a1, j, v47[v48]);
          if (v74)
          {
            v49 = (*(float (**)(DSPGraph::Box *, _QWORD, unint64_t, _QWORD))(*(_QWORD *)a1 + 88))(a1, *((unsigned int *)__p + v48), j, 0);
            v50 = v73;
            v52 = CFSTR("inf");
            if (v49 == INFINITY || (v52 = CFSTR("-inf"), v49 == -INFINITY))
            {
              objc_msgSend(v46, "setObject:forKey:", v52, v50);
            }
            else
            {
              *(float *)&v51 = v49;
              objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", CFSTR("-inf"), v51);
              v53 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v46, "setObject:forKey:", v53, v50);

            }
          }
          ++v48;
          v47 = (unsigned int *)__p;
        }
        while (v48 < (v71 - (_BYTE *)__p) >> 2);
      }
      v54 = (void *)MEMORY[0x1E0CB3940];
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", j);
      v55 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v66, "objectForKey:", v55);
      v56 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v54, "stringWithFormat:", CFSTR("Scope: %@"), v56);
      v57 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v64, "setObject:forKey:", v46, v57);

      if (__p)
      {
        v71 = __p;
        operator delete(__p);
      }

    }
  }

  objc_msgSend(v59, "setObject:forKey:", v64, CFSTR("BoxParameters"));
  return v59;
}

