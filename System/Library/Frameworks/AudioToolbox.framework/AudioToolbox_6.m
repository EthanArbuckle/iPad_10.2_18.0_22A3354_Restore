void sub_1B6159D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void AULando::~AULando(AULando *this)
{
  AULando::~AULando(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  uint64_t *v2;

  *(_QWORD *)this = &off_1E69C9130;
  v2 = (uint64_t *)*((_QWORD *)this + 68);
  *((_QWORD *)this + 68) = 0;
  if (v2)
    std::default_delete<AULando::Implementation>::operator()[abi:ne180100](v2);
  ausdk::AUBase::~AUBase(this);
}

uint64_t AULando::Initialize(AULando *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  double v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v13;
  float Parameter;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  float v18;
  Crossover2f **v19;
  uint64_t v20;
  double v21;
  double v22;
  Crossover2f *v23;
  void *__p[2];
  char v25;

  v2 = *((_QWORD *)this + 15);
  if (v2)
    LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  else
    v3 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  if ((_DWORD)v3 != 1)
    return 4294956428;
  v4 = *((_QWORD *)this + 21);
  if (v4)
    LODWORD(v5) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  else
    v5 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
  if ((_DWORD)v5 != 1)
    return 4294956428;
  if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 80), 0) + 108) != 2)
    return 4294956428;
  v6 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0) + 108);
  if (v6 != 8 && v6 != 6)
    return 4294956428;
  v7 = *(double *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0) + 80);
  if (*((double *)this + 67) != v7)
  {
    *((double *)this + 67) = v7;
    (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 432))(this, 12, 0, 0);
  }
  (*(void (**)(AULando *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
  v8 = *((unsigned int *)this + 84);
  v9 = *(double *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0) + 80);
  v10 = *((_QWORD *)this + 9);
  if (v10)
  {
    v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
  }
  else
  {
    v13 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v13)
      v11 = 0;
    else
      v11 = *v13;
  }
  Parameter = ausdk::AUElement::GetParameter(v11, 8u);
  v15 = *((_QWORD *)this + 9);
  if (v15)
  {
    v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
  }
  else
  {
    v17 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v17)
      v16 = 0;
    else
      v16 = *v17;
  }
  v18 = ausdk::AUElement::GetParameter(v16, 9u);
  v19 = (Crossover2f **)*((_QWORD *)this + 68);
  v20 = operator new();
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  Crossover2f::Crossover2f(v20, (__int128 *)__p, v9);
  if (v25 < 0)
    operator delete(__p[0]);
  v21 = Parameter;
  v22 = v18;
  v23 = *v19;
  *v19 = (Crossover2f *)v20;
  if (v23)
    std::default_delete<Crossover2f>::operator()[abi:ne180100]((uint64_t)v23);
  AULando::Implementation::updateCrossover(v19, v21, v22);
  IR::HilbertFIR::initialize((IR::HilbertFIR *)(v19 + 1), v9, v8);
  IR::HilbertFIR::initialize((IR::HilbertFIR *)(v19 + 2), v9, v8);
  return 0;
}

void sub_1B615A1B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  MEMORY[0x1BCC95CEC](v15, 0x1032C409EFFA567);
  _Unwind_Resume(a1);
}

uint64_t AULando::Cleanup(AULando *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 68);
  v2 = *(_QWORD *)v1;
  *(_QWORD *)v1 = 0;
  if (v2)
    std::default_delete<Crossover2f>::operator()[abi:ne180100](v2);
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 8) + 24))(*(_QWORD *)(v1 + 8));
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 16) + 24))(*(_QWORD *)(v1 + 16));
}

uint64_t AULando::Reset(AULando *this)
{
  uint64_t v1;
  _OWORD *v2;
  uint64_t v3;
  float v4;
  float v5;

  v1 = *((_QWORD *)this + 68);
  if (*(_QWORD *)v1)
    Crossover2f::Reset(*(ParametricFilters ***)v1);
  v2 = (_OWORD *)(v1 + 8);
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 8) + 32))(*(_QWORD *)(v1 + 8));
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 16) + 32))(*(_QWORD *)(v1 + 16));
  IR::FixedIntegerDelay::reset((IR::FixedIntegerDelay *)(v1 + 24));
  IR::FixedIntegerDelay::reset((IR::FixedIntegerDelay *)(v1 + 80));
  IR::FixedIntegerDelay::reset((IR::FixedIntegerDelay *)(v1 + 136));
  IR::FixedIntegerDelay::reset((IR::FixedIntegerDelay *)(v1 + 192));
  *(_OWORD *)(v1 + 248) = 0u;
  v3 = v1 + 248;
  *(_QWORD *)(v3 + 156) = 0x3F80000000000000;
  v2[16] = 0u;
  v2[17] = 0u;
  v2[18] = 0u;
  v2[19] = 0u;
  v2[20] = 0u;
  v2[21] = 0u;
  v2[22] = 0u;
  v2[23] = 0u;
  *(_DWORD *)(v3 + 144) = 0;
  bzero((void *)(v3 + 800), 8 * *(_DWORD *)(v3 + 796) * *(_DWORD *)(v3 + 792));
  fb::ComplexMat::stabilize((_DWORD *)(v3 + 792), v4);
  bzero((void *)(v3 + 1008), 8 * *(_DWORD *)(v3 + 1004) * *(_DWORD *)(v3 + 1000));
  bzero((void *)(v3 + 1840), 8 * *(_DWORD *)(v3 + 1836) * *(_DWORD *)(v3 + 1832));
  fb::ComplexMat::stabilize((_DWORD *)(v3 + 1832), v5);
  bzero((void *)(v3 + 2048), 8 * *(_DWORD *)(v3 + 2044) * *(_DWORD *)(v3 + 2040));
  return 0;
}

uint64_t AULando::GetPropertyInfo(AULando *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  BOOL v7;

  if (a3)
    return 4294956417;
  if (a2 == 21)
  {
    v7 = 1;
  }
  else
  {
    if (a2 != 3700)
      return 4294956417;
    v7 = 0;
  }
  result = 0;
  *a6 = v7;
  *a5 = 4;
  return result;
}

uint64_t AULando::GetProperty(AULando *this, int a2, int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result;
  unsigned __int8 *v6;

  if (a3)
    return 4294956417;
  if (a2 == 3700)
  {
    v6 = (unsigned __int8 *)this + 376;
  }
  else
  {
    if (a2 != 21)
      return 4294956417;
    v6 = (unsigned __int8 *)this + 528;
  }
  result = 0;
  *a5 = *v6;
  return result;
}

uint64_t AULando::SetProperty(AULando *this, int a2, int a3, unsigned int a4, _DWORD *a5, unsigned int a6)
{
  uint64_t result;
  int v8;

  result = 4294956417;
  if (a2 == 21 && !a3)
  {
    if (a6 >= 4)
    {
      v8 = *a5 != 0;
      if (*((unsigned __int8 *)this + 528) == v8)
      {
        return 0;
      }
      else
      {
        if (*((_BYTE *)this + 17))
          (*(void (**)(AULando *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
        result = 0;
        *((_BYTE *)this + 528) = v8;
      }
    }
    else
    {
      return 4294956445;
    }
  }
  return result;
}

uint64_t AULando::SetParameter(AULando *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  uint64_t v8;
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  uint64_t v12[2];
  unsigned int v13;

  v8 = *((_QWORD *)this + 68);
  v12[0] = (uint64_t)this;
  v12[1] = v8;
  v13 = a2;
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  AULando::SetParameter(unsigned int,unsigned int,unsigned int,float,unsigned int)::OnExit::~OnExit(v12);
  return 0;
}

void sub_1B615A4A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  AULando::SetParameter(unsigned int,unsigned int,unsigned int,float,unsigned int)::OnExit::~OnExit((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t AULando::CanScheduleParameters(AULando *this)
{
  return 0;
}

uint64_t AULando::ProcessBufferLists(AULando *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, AULando::LRLsRs *a5)
{
  UInt32 mNumberBuffers;
  int v10;
  float *v11;
  float *v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  uint64_t v15;
  ausdk::AUElement **v16;
  unsigned int Parameter;
  vDSP_Length v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  float v22;
  uint64_t v23;
  ausdk::AUElement *v24;
  ausdk::AUElement **v25;
  float v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  float v30;
  uint64_t v31;
  ausdk::AUElement *v32;
  ausdk::AUElement **v33;
  float v34;
  uint64_t v35;
  ausdk::AUElement *v36;
  ausdk::AUElement **v37;
  float v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  float v42;
  uint64_t v43;
  ausdk::AUElement *v44;
  ausdk::AUElement **v45;
  float v46;
  uint64_t v47;
  ausdk::AUElement *v48;
  ausdk::AUElement **v49;
  uint64_t v50;
  ausdk::AUElement *v51;
  ausdk::AUElement **v52;
  float *v53;
  float *v54;
  float *v56;
  _BOOL4 v57;
  unsigned int v58;
  float *v59;
  float *v60;
  float *v61;
  float *v62;
  float *v63;
  float *mData;

  if (a3->mNumberBuffers != 2)
    return 4294956428;
  mNumberBuffers = a4->mNumberBuffers;
  if (a4->mNumberBuffers != 8 && mNumberBuffers != 6)
    return 4294956428;
  v10 = *((unsigned __int8 *)this + 528);
  v63 = *(float **)&a3[1].mBuffers[0].mNumberChannels;
  mData = (float *)a3->mBuffers[0].mData;
  v61 = *(float **)&a4[1].mBuffers[0].mNumberChannels;
  v62 = (float *)a4->mBuffers[0].mData;
  v11 = (float *)a4[2].mBuffers[0].mData;
  v59 = *(float **)&a4[3].mBuffers[0].mNumberChannels;
  v60 = *(float **)&a4[2].mNumberBuffers;
  v12 = *(float **)&a4[4].mNumberBuffers;
  v13 = *((_QWORD *)this + 9);
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  }
  else
  {
    v16 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v16)
      v14 = 0;
    else
      v14 = *v16;
  }
  Parameter = ausdk::AUElement::GetParameter(v14, 0);
  if (v10)
    Parameter = 1;
  v58 = Parameter;
  v18 = a5;
  vDSP_vclr(v11, 1, a5);
  v19 = *((_QWORD *)this + 9);
  if (v19)
  {
    v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
  }
  else
  {
    v21 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v21)
      v20 = 0;
    else
      v20 = *v21;
  }
  v22 = ausdk::AUElement::GetParameter(v20, 1u);
  v23 = *((_QWORD *)this + 9);
  if (v23)
  {
    v24 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
  }
  else
  {
    v25 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v25)
      v24 = 0;
    else
      v24 = *v25;
  }
  v26 = ausdk::AUElement::GetParameter(v24, 2u);
  v27 = *((_QWORD *)this + 9);
  if (v27)
  {
    v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
  }
  else
  {
    v29 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v29)
      v28 = 0;
    else
      v28 = *v29;
  }
  v30 = ausdk::AUElement::GetParameter(v28, 3u);
  v31 = *((_QWORD *)this + 9);
  if (v31)
  {
    v32 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v31 + 32))(v31, 0);
  }
  else
  {
    v33 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v33)
      v32 = 0;
    else
      v32 = *v33;
  }
  v34 = ausdk::AUElement::GetParameter(v32, 4u);
  v35 = *((_QWORD *)this + 9);
  if (v35)
  {
    v36 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 32))(v35, 0);
  }
  else
  {
    v37 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v37)
      v36 = 0;
    else
      v36 = *v37;
  }
  v38 = ausdk::AUElement::GetParameter(v36, 5u);
  v39 = *((_QWORD *)this + 9);
  if (v39)
  {
    v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
  }
  else
  {
    v41 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v41)
      v40 = 0;
    else
      v40 = *v41;
  }
  v42 = ausdk::AUElement::GetParameter(v40, 7u);
  v43 = *((_QWORD *)this + 9);
  if (v43)
  {
    v44 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v43 + 32))(v43, 0);
  }
  else
  {
    v45 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v45)
      v44 = 0;
    else
      v44 = *v45;
  }
  v46 = ausdk::AUElement::GetParameter(v44, 6u);
  v47 = *((_QWORD *)this + 9);
  if (v47)
  {
    v48 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v47 + 32))(v47, 0);
  }
  else
  {
    v49 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v49)
      v48 = 0;
    else
      v48 = *v49;
  }
  BYTE4(v56) = ausdk::AUElement::GetParameter(v48, 0xBu) == 1.0;
  BYTE3(v56) = v46 != 0.0;
  BYTE2(v56) = v38 != 0.0;
  BYTE1(v56) = v26 != 0.0;
  LOBYTE(v56) = v22 != 0.0;
  v15 = AULando::Implementation::algo(*((AULando::Implementation **)this + 68), v58, a5, mData, v63, v62, v61, v60, v30, v34, v42, v59, v12, v56, v57, SBYTE1(v57), SBYTE2(v57), SHIBYTE(v57), v58);
  v50 = *((_QWORD *)this + 9);
  if (v50)
  {
    v51 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v50 + 32))(v50, 0);
  }
  else
  {
    v52 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v52)
      v51 = 0;
    else
      v51 = *v52;
  }
  if (ausdk::AUElement::GetParameter(v51, 0xAu) == 1.0)
    vDSP_vneg(v12, 1, v12, 1, v18);
  if (mNumberBuffers == 8)
  {
    v53 = (float *)a4[4].mBuffers[0].mData;
    v54 = *(float **)&a4[5].mBuffers[0].mNumberChannels;
    vDSP_vclr(v53, 1, v18);
    vDSP_vclr(v54, 1, v18);
  }
  return v15;
}

uint64_t AULando::ProcessMultipleBufferLists(AULando *this, unsigned int *a2, unsigned int a3, int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7)
{
  BOOL v7;
  BOOL v8;

  if (a4 == 1 && a5 && (*a5 ? (v7 = a6 == 1) : (v7 = 0), v7 ? (v8 = a7 == 0) : (v8 = 1), !v8 && *a7))
    return (*(uint64_t (**)(AULando *, unsigned int *))(*(_QWORD *)this + 176))(this, a2);
  else
    return 4294956418;
}

uint64_t AULando::Render(AULando *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  uint64_t Element;
  uint64_t v10;
  ausdk::AUInputElement *v11;
  uint64_t result;
  uint64_t BufferList;
  uint64_t v14;
  unsigned int v15;

  v8 = (AULando *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 80), 0);
  v10 = ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0);
  v15 = 0;
  v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  result = ausdk::AUInputElement::PullInput(v11, &v15, a3, 0, a4);
  if (!(_DWORD)result)
  {
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    v14 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    return (*(uint64_t (**)(AULando *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 176))(this, a2, BufferList, v14, a4);
  }
  return result;
}

uint64_t AULando::GetParameterInfo(AULando *this, int a2, AudioUnitParameterUnit a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  uint64_t v6;
  AudioUnitParameterValue v7;
  AudioUnitParameterUnit v8;
  const __CFString *v9;

  if (a2)
    return 4294956418;
  buffer->flags = 0;
  buffer->unitName = 0;
  v6 = 0x4080000000000000;
  v7 = 4.0;
  v8 = kAudioUnitParameterUnit_Indexed;
  v9 = CFSTR("Algorithm");
  switch(a3)
  {
    case kAudioUnitParameterUnit_Generic:
      goto LABEL_17;
    case kAudioUnitParameterUnit_Indexed:
      v6 = 0x3F80000000000000;
      v7 = 0.0;
      v8 = kAudioUnitParameterUnit_Boolean;
      v9 = CFSTR("Phase Shift");
      goto LABEL_17;
    case kAudioUnitParameterUnit_Boolean:
      v6 = 0x3F80000000000000;
      v7 = 1.0;
      v9 = CFSTR("Downmix C");
      goto LABEL_13;
    case kAudioUnitParameterUnit_Percent:
      v8 = kAudioUnitParameterUnit_Generic;
      v6 = 0x3F800000BF800000;
      v9 = CFSTR("Front-Back Bias");
      v7 = -0.36;
      goto LABEL_17;
    case kAudioUnitParameterUnit_Seconds:
      v8 = kAudioUnitParameterUnit_Generic;
      v9 = CFSTR("Steering");
      v7 = 1.92;
      goto LABEL_17;
    case kAudioUnitParameterUnit_SampleFrames:
      v6 = 0x3F80000000000000;
      v7 = 1.0;
      v8 = kAudioUnitParameterUnit_Boolean;
      v9 = CFSTR("Steering Moderator");
      goto LABEL_17;
    case kAudioUnitParameterUnit_Phase:
      v6 = 0x3F80000000000000;
      v7 = 1.0;
      v8 = kAudioUnitParameterUnit_Boolean;
      v9 = CFSTR("Smoothing");
      goto LABEL_17;
    case kAudioUnitParameterUnit_Rate:
      v8 = kAudioUnitParameterUnit_Generic;
      v6 = 0x3F80000000000000;
      v9 = CFSTR("Decay");
      v7 = 0.755;
      goto LABEL_17;
    case kAudioUnitParameterUnit_Hertz:
      v6 = 0x4448000042200000;
      v9 = CFSTR("Low Crossover Frequency");
      v7 = 400.0;
LABEL_13:
      v8 = a3;
      goto LABEL_17;
    case kAudioUnitParameterUnit_Cents:
      v6 = 0x466A600044FA0000;
      v8 = kAudioUnitParameterUnit_Hertz;
      v9 = CFSTR("High Crossover Frequency");
      v7 = 10000.0;
      goto LABEL_17;
    case kAudioUnitParameterUnit_RelativeSemiTones:
      v6 = 0x3F80000000000000;
      v7 = 1.0;
      v8 = kAudioUnitParameterUnit_Boolean;
      v9 = CFSTR("Inverted Rs Polarity");
      goto LABEL_17;
    case kAudioUnitParameterUnit_MIDINoteNumber:
      v6 = 0x3F80000000000000;
      v7 = 0.0;
      v8 = kAudioUnitParameterUnit_Boolean;
      v9 = CFSTR("Soft Bypass");
LABEL_17:
      buffer->cfNameString = v9;
      buffer->flags = 0x8000000;
      CFStringGetCString(v9, buffer->name, 52, 0x8000100u);
      result = 0;
      buffer->unit = v8;
      *(_QWORD *)&buffer->minValue = v6;
      buffer->defaultValue = v7;
      buffer->flags |= 0xC0000000;
      break;
    default:
      result = 4294956418;
      break;
  }
  return result;
}

uint64_t AULando::RestoreState(AULando *this, const void *a2)
{
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  float Parameter;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  float v16;
  uint64_t v17;
  ausdk::AUElement *v18;
  ausdk::AUElement **v19;
  float v20;

  v4 = *((_QWORD *)this + 9);
  if (v4)
  {
    v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  }
  else
  {
    v6 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v6)
      v5 = 0;
    else
      v5 = *v6;
  }
  Parameter = ausdk::AUElement::GetParameter(v5, 8u);
  v8 = *((_QWORD *)this + 9);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  v11 = ausdk::AUElement::GetParameter(v9, 9u);
  v12 = ausdk::AUBase::RestoreState((OpaqueAudioComponentInstance **)this, a2);
  v13 = *((_QWORD *)this + 9);
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  }
  else
  {
    v15 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v15)
      v14 = 0;
    else
      v14 = *v15;
  }
  v16 = ausdk::AUElement::GetParameter(v14, 8u);
  v17 = *((_QWORD *)this + 9);
  if (v17)
  {
    v18 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 32))(v17, 0);
  }
  else
  {
    v19 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v19)
      v18 = 0;
    else
      v18 = *v19;
  }
  v20 = ausdk::AUElement::GetParameter(v18, 9u);
  if (Parameter != v16 || v11 != v20)
    AULando::Implementation::updateCrossover(*((Crossover2f ***)this + 68), v16, v20);
  return v12;
}

uint64_t AULando::GetParameterValueStrings(AULando *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  const __CFArray *v6;

  if (a3 | a2)
    return 4294956418;
  if (!a4)
    return 0;
  v6 = CFArrayCreate(0, (const void **)kAULandoAlgoStrings, 5, 0);
  result = 0;
  *a4 = v6;
  return result;
}

uint64_t AULando::GetPresets(AULando *this, const __CFArray **a2)
{
  __CFArray *Mutable;

  if (a2)
  {
    Mutable = CFArrayCreateMutable(0, 2, 0);
    CFArrayAppendValue(Mutable, &kAULandoPresets);
    CFArrayAppendValue(Mutable, &unk_1EF133248);
    *a2 = Mutable;
  }
  return 0;
}

uint64_t AULando::NewFactoryPresetSet(AULando *this, const AUPreset *a2)
{
  uint64_t presetNumber;

  presetNumber = a2->presetNumber;
  if ((int)presetNumber > 1)
    return 4294956445;
  (*(void (**)(AULando *, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 0, 0, 0, 0, 4.0);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 1, 0, 0, 0, 0.0);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 2, 0, 0, 0, (float)kAULandoPresetDefinitions[12 * (int)presetNumber + 2]);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 3, 0, 0, 0, -0.36);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 4, 0, 0, 0, 1.92);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 5, 0, 0, 0, 1.0);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 6, 0, 0, 0, 1.0);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 7, 0, 0, 0, 0.755);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 8, 0, 0, 0, 400.0);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 9, 0, 0, 0, 10000.0);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 10, 0, 0, 0, 1.0);
  (*(void (**)(AULando *, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, 11, 0, 0, 0, 0.0);
  ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, (const AUPreset *)&kAULandoPresets + presetNumber);
  return 0;
}

double AULando::GetLatency(AULando *this)
{
  double v1;
  double v2;
  BOOL v3;
  double result;

  v1 = *(double *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0) + 80);
  v2 = 35.0 / v1;
  v3 = v1 <= 8000.0;
  result = 0.004375;
  if (!v3)
    return v2;
  return result;
}

double AULando::GetTailTime(AULando *this)
{
  double v1;
  double v2;
  BOOL v3;
  double result;

  v1 = *(double *)(ausdk::AUScope::SafeGetElement((AULando *)((char *)this + 128), 0) + 80);
  v2 = 69.0 / v1;
  v3 = v1 <= 8000.0;
  result = 0.008625;
  if (!v3)
    return v2;
  return result;
}

uint64_t AULando::SupportsTail(AULando *this)
{
  return 1;
}

BOOL AULando::StreamFormatWritable(AULando *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AULando::SupportedNumChannels(AULando *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AULando::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 2;
}

uint64_t AULando::ValidFormat(AULando *this, const AudioStreamBasicDescription *a2, unsigned int a3, AudioStreamBasicDescription *a4)
{
  int v5;
  _BOOL4 v6;
  UInt32 mChannelsPerFrame;
  _BOOL4 v9;

  v5 = (int)a2;
  if (ausdk::ASBD::IsCommonFloat32((ausdk::ASBD *)a4, a2))
    v6 = (a4->mFormatFlags & 0x20) != 0 || a4->mChannelsPerFrame == 1;
  else
    v6 = 0;
  if (v5 == 2)
  {
    if (v6)
    {
      mChannelsPerFrame = a4->mChannelsPerFrame;
      v6 = mChannelsPerFrame == 6 || mChannelsPerFrame == 8;
    }
  }
  else if (v5 == 1 && a4->mChannelsPerFrame != 2)
  {
    v6 = 0;
  }
  v9 = a4->mSampleRate >= 44100.0;
  if (a4->mSampleRate > 48000.0)
    v9 = 0;
  return v9 & v6;
}

void AULando::Implementation::updateCrossover(Crossover2f **this, double a2, double a3)
{
  Crossover2f *v4;

  v4 = *this;
  if (v4)
  {
    Crossover2f::SetLowCrossover(v4, a2, 3);
    Crossover2f::SetHighCrossover(*this, a3, 1);
  }
}

uint64_t AULando::Implementation::algo(AULando::Implementation *this, int a2, AULando::LRLsRs *a3, float *a4, float *a5, float *a6, float *a7, float *a8, float a9, float a10, float a11, float *a12, float *a13, float *a14, BOOL a15, BOOL a16, BOOL a17, BOOL a18, int a19)
{
  uint64_t v27;
  unsigned int v28;
  vDSP_Length v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  const float *v38;
  const float *v39;
  float *v40;
  uint64_t v41;
  float *v42;
  float *v43;
  float *v45;
  AULando::Tools *v46;
  float **v47;
  float *v48;
  float *v49;
  float __B;
  float *v51;
  const float *v52;
  float *v53;
  const float *v54;
  float *v55;
  const float *v56;
  float *v57[4];

  v49 = a6;
  v57[2] = *(float **)MEMORY[0x1E0C80C00];
  v57[0] = a4;
  v57[1] = a5;
  MEMORY[0x1E0C80A78](this);
  v29 = v28;
  v55 = (float *)((char *)&v47 - ((v27 + 15) & 0x7FFFFFFF0));
  v56 = &v55[v28];
  MEMORY[0x1E0C80A78](v30);
  v53 = (float *)((char *)&v47 - v32);
  v54 = (const float *)((char *)&v47 + 4 * v31 - v32);
  MEMORY[0x1E0C80A78](v33);
  v51 = (float *)((char *)&v47 - v35);
  v52 = (const float *)((char *)&v47 + 4 * v34 - v35);
  v37 = Crossover2f::Process(*v36, v57, &v55, &v53, &v51, 2, (vDSP_Length)a3, 1, v47);
  v47 = (float **)&v47;
  v48 = a8;
  v38 = a13;
  v39 = v52;
  switch(a2)
  {
    case 0:
      v40 = v49;
      memcpy(v49, v51, 4 * v29);
      memcpy(a7, v39, 4 * v29);
      vDSP_vclr(v48, 1, v29);
      vDSP_vclr(a12, 1, v29);
      goto LABEL_11;
    case 1:
      v40 = v49;
      AULando::Implementation::algoBypassAlignedLatency(this, (uint64_t)a3, v51, v52, v49, a7, v48, a12, a13);
      goto LABEL_14;
    case 2:
      v40 = v49;
      AULando::LRLsRs::algoExtractLsRsPI(a3, v51, v52, v49, a7, a12, a13, (float *)a14, (_QWORD *)this + 1, v46);
      goto LABEL_8;
    case 3:
      v40 = v49;
      if (BYTE1(a14))
      {
        AULando::LRLsRs::algoUpmixPI(a3, (AULando::LRLsRs *)v51, v52, v49, a7, a12, a13, (float *)a14, (_QWORD *)this + 1, v46);
LABEL_8:
        v42 = v48;
LABEL_12:
        vDSP_vclr(v42, 1, v29);
      }
      else
      {
        LOBYTE(v45) = (_BYTE)a14;
        AULando::LRCLsRs::algoUpmixPI(a3, (AULando::LRCLsRs *)v51, v52, v49, a7, v48, a12, a13, v45, (_QWORD **)this + 1, (AULando::Tools *)v47);
      }
LABEL_14:
      v41 = 0;
LABEL_15:
      MEMORY[0x1E0C80A78](v37);
      v43 = (float *)((char *)&v47 - ((4 * v29 + 15) & 0x7FFFFFFF0));
      vDSP_vadd(v55, 1, v53, 1, v43, 1, v29);
      IR::FixedIntegerDelay::process((AULando::Implementation *)((char *)this + 136), v43, v43, a3);
      vDSP_vadd(v40, 1, v43, 1, v40, 1, v29);
      vDSP_vadd(v56, 1, v54, 1, v43, 1, v29);
      IR::FixedIntegerDelay::process((AULando::Implementation *)((char *)this + 192), v43, v43, a3);
      vDSP_vadd(a7, 1, v43, 1, a7, 1, v29);
      return v41;
    case 4:
      v38 = v48;
      v40 = v49;
      AULando::LRCLsRs::algoUpmixPISteered((AULando::Implementation *)((char *)this + 416), a3, (AULando::LRCLsRs *)v51, v52, v49, a7, v48, a12, a9, a10, a11, a13, (BOOL)a14, SBYTE2(a14), SBYTE3(a14), SBYTE4(a14), (AULando::Implementation *)((char *)this + 8));
      if (!BYTE1(a14))
        goto LABEL_14;
      __B = 0.70711;
      vDSP_vsma(v38, 1, &__B, v40, 1, v40, 1, v29);
      vDSP_vsma(v38, 1, &__B, a7, 1, a7, 1, v29);
LABEL_11:
      v42 = (float *)v38;
      goto LABEL_12;
    default:
      v41 = 4294956418;
      v40 = v49;
      goto LABEL_15;
  }
}

void AULando::Implementation::algoBypassAlignedLatency(AULando::Implementation *this, uint64_t a2, const float *a3, const float *a4, float *a5, float *a6, float *a7, float *a8, float *a9)
{
  vDSP_Length v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v22[2];
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  v15 = a2;
  MEMORY[0x1E0C80A78](this);
  v17 = (char *)&v22[-1] - v16;
  v23[0] = v18;
  v23[1] = (char *)&v22[-1] - v16;
  (*(void (**)(_QWORD, uint64_t, _QWORD *, uint64_t, uint64_t, _QWORD, float))(**(_QWORD **)(v19 + 8) + 40))(*(_QWORD *)(v19 + 8), v20, v23, 2, a2, 0, 1.0);
  v22[0] = a6;
  v22[1] = v17;
  (*(void (**)(_QWORD, const float *, _QWORD *, uint64_t, uint64_t, _QWORD, float))(**((_QWORD **)this + 2)
                                                                                           + 40))(*((_QWORD *)this + 2), a4, v22, 2, a2, 0, 1.0);
  vDSP_vclr(a7, 1, v15);
  vDSP_vclr(a8, 1, v15);
  vDSP_vclr(a9, 1, v15);
}

uint64_t *AULando::SetParameter(unsigned int,unsigned int,unsigned int,float,unsigned int)::OnExit::~OnExit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  ausdk::AUElement *v4;
  ausdk::AUElement **v5;
  uint64_t v6;
  float Parameter;
  uint64_t v8;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  uint64_t v12;
  float v13;

  if ((a1[2] & 0xFFFFFFFE) == 8)
  {
    v2 = *a1;
    v3 = *(_QWORD *)(*a1 + 72);
    if (v3)
    {
      v4 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 32))(v3, 0);
    }
    else
    {
      v6 = v2 + 48;
      v5 = *(ausdk::AUElement ***)(v2 + 48);
      if (*(ausdk::AUElement ***)(v6 + 8) == v5)
        v4 = 0;
      else
        v4 = *v5;
    }
    Parameter = ausdk::AUElement::GetParameter(v4, 8u);
    v8 = *a1;
    v9 = *(_QWORD *)(*a1 + 72);
    if (v9)
    {
      v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
    }
    else
    {
      v12 = v8 + 48;
      v11 = *(ausdk::AUElement ***)(v8 + 48);
      if (*(ausdk::AUElement ***)(v12 + 8) == v11)
        v10 = 0;
      else
        v10 = *v11;
    }
    v13 = ausdk::AUElement::GetParameter(v10, 9u);
    AULando::Implementation::updateCrossover((Crossover2f **)a1[1], Parameter, v13);
  }
  return a1;
}

void std::default_delete<Crossover2f>::operator()[abi:ne180100](uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)(a1 + 24), 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)(a1 + 16), 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)(a1 + 8), 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)a1, 0);
  JUMPOUT(0x1BCC95CECLL);
}

void **std::unique_ptr<ParametricFilters>::reset[abi:ne180100](void ***a1, void **a2)
{
  void **result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    ParametricFilters::~ParametricFilters(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void ParametricFilters::~ParametricFilters(void **this)
{
  void *v2;
  void *v3;
  void *v4;
  void **v5;

  if (*((char *)this + 191) < 0)
    operator delete(this[21]);
  v2 = this[17];
  this[17] = 0;
  if (v2)
    ((void (*)(void))this[18])();
  v3 = this[15];
  this[15] = 0;
  if (v3)
    ((void (*)(void))this[16])();
  v5 = this + 11;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = this + 8;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v4 = this[5];
  if (v4)
  {
    this[6] = v4;
    operator delete(v4);
  }
  v5 = this + 2;
  std::vector<BiquadStage>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void std::vector<BiquadStage>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0)
          operator delete(*(v4 - 3));
        v4 -= 9;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t IR::HilbertFIR::initialize(IR::HilbertFIR *this, double a2, uint64_t a3)
{
  float v5;
  uint64_t result;
  __int128 *v7;
  __int128 v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  v5 = a2;
  result = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, float))(**(_QWORD **)this + 16))(*(_QWORD *)this, a3, 0, 0, 0, 0, 0, v5);
  if (!(_DWORD)result)
  {
    v9[0] = 0;
    if (a2 == 48000.0)
    {
      v7 = &xmmword_1E69C9370;
    }
    else
    {
      if (a2 != 44100.0)
        return result;
      v7 = &xmmword_1E69C9380;
    }
    v8 = *v7;
    return (*(uint64_t (**)(_QWORD, __int128 *, _QWORD *, uint64_t, uint64_t))(**(_QWORD **)this + 208))(*(_QWORD *)this, &v8, v9, 2, 70);
  }
  return result;
}

void std::default_delete<AULando::Implementation>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  AULando::Tools::~Tools((AULando::Tools *)(a1 + 1));
  v2 = *a1;
  *a1 = 0;
  if (v2)
    std::default_delete<Crossover2f>::operator()[abi:ne180100](v2);
  JUMPOUT(0x1BCC95CECLL);
}

void AULando::Tools::~Tools(AULando::Tools *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;

  v2 = (void *)*((_QWORD *)this + 27);
  if (v2)
  {
    *((_QWORD *)this + 28) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 24);
  if (v3)
  {
    *((_QWORD *)this + 25) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 20);
  if (v4)
  {
    *((_QWORD *)this + 21) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 17);
  if (v5)
  {
    *((_QWORD *)this + 18) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 13);
  if (v6)
  {
    *((_QWORD *)this + 14) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 10);
  if (v7)
  {
    *((_QWORD *)this + 11) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 6);
  if (v8)
  {
    *((_QWORD *)this + 7) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 3);
  if (v9)
  {
    *((_QWORD *)this + 4) = v9;
    operator delete(v9);
  }
  v10 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  v11 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
}

IR::HilbertFIR *IR::HilbertFIR::HilbertFIR(IR::HilbertFIR *this)
{
  IR::IRProcessor *v2;
  uint64_t v3;

  *(_QWORD *)this = 0;
  v2 = (IR::IRProcessor *)operator new();
  IR::IRProcessor::IRProcessor(v2, 70, 0.0, 2, 64, 1, 0);
  v3 = *(_QWORD *)this;
  *(_QWORD *)this = v2;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  return this;
}

void sub_1B615BCAC(_Unwind_Exception *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v4;

  MEMORY[0x1BCC95CEC](v2, 0x10E1C40AE0E3EF2);
  v4 = *v1;
  *v1 = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void IR::FixedIntegerDelay::~FixedIntegerDelay(IR::FixedIntegerDelay *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 1);
  if (v3)
  {
    *((_QWORD *)this + 2) = v3;
    operator delete(v3);
  }
}

IR::IRProcessor *IR::IRProcessor::IRProcessor(IR::IRProcessor *this, int a2, float a3, int a4, int a5, char a6, int a7)
{
  const __CFURL *v14;
  const __CFURL *v15;
  std::runtime_error *exception;
  CFURLRef v18;

  *(_QWORD *)this = &off_1E69E7F58;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((IR::IRProcessor *)((char *)this + 20));
  v14 = CFURLCreateWithString(0, &stru_1E69EEE40, 0);
  v18 = v14;
  if (!v14)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  v15 = v14;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)this + 24, &v18, a5, a6, 0.0);
  CFRelease(v15);
  *((_QWORD *)this + 23) = 0;
  *((_BYTE *)this + 176) = 0;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_BYTE *)this + 208) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  IR::IRCoordinates::IRCoordinates((IR::IRProcessor *)((char *)this + 360));
  *((_DWORD *)this + 99) = 0;
  *((_QWORD *)this + 50) = 0x3F800000453B8000;
  *((_BYTE *)this + 408) = 1;
  *((_DWORD *)this + 103) = a7;
  *((_WORD *)this + 208) = 0;
  *((_DWORD *)this + 105) = a4;
  *((_DWORD *)this + 106) = a2;
  *((_DWORD *)this + 107) = 0;
  *((_DWORD *)this + 108) = vcvtps_u32_f32(a3);
  *((_DWORD *)this + 109) = -65536;
  *((_BYTE *)this + 440) = 0;
  return this;
}

void sub_1B615BEAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;

  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

void clsp::AdaptiveDisplacementController::~AdaptiveDisplacementController(clsp::AdaptiveDisplacementController *this)
{
  clsp::AdaptiveDisplacementController::~AdaptiveDisplacementController(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  char *v2;

  *(_QWORD *)this = &off_1E69C93A0;
  v2 = (char *)this + 128;
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 352);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 288);
  std::unique_ptr<clsp::SpeakerModelNonlinear>::reset[abi:ne180100]((uint64_t *)this + 19, 0);
  std::unique_ptr<clsp::SpeakerModelNonlinear>::reset[abi:ne180100]((uint64_t *)this + 18, 0);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)v2);
}

_QWORD *clsp::AdaptiveDisplacementController::dump(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  char v19;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"g_bw = ", 7);
  v4 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\nx_lim = ", 9);
  v5 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"\nQ_d = ", 7);
  v6 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"\npeakAttackTime = ", 18);
  v7 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"\npeakDecayTime = ", 17);
  v8 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"\nflvSmoothingTime = ", 20);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"\nmc_x_lim = ", 12);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"\ninvxlim = ", 11);
  v11 = (_QWORD *)std::ostream::operator<<();
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"\n\nptp:\n", 7);
  clsp::IIRTwoPole<float>::dump(a1 + 80, v12);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"\nflv:\n", 6);
  clsp::IIRTwoPole<float>::dump(a1 + 100, v13);
  v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"\nptpAtkRel:\n", 12);
  clsp::AttackRelease<float,double>::dump(a1 + 160, v14);
  v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"\nflvTime:\n", 10);
  clsp::AttackRelease<float,double>::dump(a1 + 200, v15);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"\nflvSmoother:\n", 14);
  clsp::ExponentialSmoother<float,double>::dump(a1 + 240, v16);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\nlfsn:\n", 7);
  clsp::LFSN::dump(a1 + 256, v17);
  v19 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)&v19, 1);
  return a2;
}

void clsp::AdaptiveDisplacementController::logCoeffs(uint64_t a1, clsp::CLSP_Log **a2)
{
  clsp::CLSP_Log *v4;
  float v5;
  clsp::CLSP_Log *v6;
  float v7;
  clsp::CLSP_Log *v8;
  float v9;
  clsp::CLSP_Log *v10;
  float v11;
  clsp::CLSP_Log *v12;
  float v13;
  clsp::CLSP_Log *v14;
  float v15;
  clsp::CLSP_Log *v16;
  clsp::CLSP_Log *v17;
  clsp::CLSP_Log *v18;
  float *v19;
  clsp::CLSP_Log *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  float *v24;
  clsp::CLSP_Log *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  clsp::CLSP_Log *v30;
  unint64_t *v31;
  unint64_t v32;
  __n128 v33;
  unint64_t v34;
  uint64_t v35;
  clsp::CLSP_Log *v36;
  unint64_t *v37;
  unint64_t v38;
  __n128 v39;
  unint64_t v40;
  uint64_t v41;
  clsp::CLSP_Log *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  clsp::CLSP_Log *v46;
  std::__shared_weak_count *v47;
  unint64_t *p_shared_owners;
  unint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  _QWORD v52[2];
  clsp::CLSP_Log *v53[2];
  clsp::CLSP_Log *v54[2];
  clsp::CLSP_Log *v55[2];
  clsp::CLSP_Log *v56[2];
  clsp::CLSP_Log *v57[2];
  float __src;

  v4 = *a2;
  if (!*a2)
    goto LABEL_10;
  v5 = *(double *)(a1 + 16);
  __src = v5;
  clsp::CLSP_Log::LogCLSPData(v4, &__src, 1);
  v6 = *a2;
  if (!*a2)
    goto LABEL_10;
  v7 = *(double *)(a1 + 24);
  __src = v7;
  clsp::CLSP_Log::LogCLSPData(v6, &__src, 1);
  v8 = *a2;
  if (!*a2)
    goto LABEL_10;
  v9 = *(double *)(a1 + 32);
  __src = v9;
  clsp::CLSP_Log::LogCLSPData(v8, &__src, 1);
  v10 = *a2;
  if (!*a2)
    goto LABEL_10;
  v11 = *(double *)(a1 + 40);
  __src = v11;
  clsp::CLSP_Log::LogCLSPData(v10, &__src, 1);
  v12 = *a2;
  if (!*a2)
    goto LABEL_10;
  v13 = *(double *)(a1 + 48);
  __src = v13;
  clsp::CLSP_Log::LogCLSPData(v12, &__src, 1);
  v14 = *a2;
  if (!*a2)
    goto LABEL_10;
  v15 = *(double *)(a1 + 56);
  __src = v15;
  clsp::CLSP_Log::LogCLSPData(v14, &__src, 1);
  v16 = *a2;
  if (*a2 && (__src = *(float *)(a1 + 68), clsp::CLSP_Log::LogCLSPData(v16, &__src, 1), (v17 = *a2) != 0))
  {
    __src = *(float *)(a1 + 72);
    clsp::CLSP_Log::LogCLSPData(v17, &__src, 1);
    v18 = *a2;
  }
  else
  {
LABEL_10:
    v18 = 0;
  }
  v19 = (float *)(a1 + 80);
  v20 = a2[1];
  v57[0] = v18;
  v57[1] = v20;
  if (v20)
  {
    v21 = (unint64_t *)((char *)v20 + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    clsp::IIRTwoPole<float>::logCoeffs(v19, v57);
    do
      v23 = __ldaxr(v21);
    while (__stlxr(v23 - 1, v21));
    if (!v23)
    {
      (*(void (**)(clsp::CLSP_Log *))(*(_QWORD *)v20 + 16))(v20);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v20);
    }
  }
  else
  {
    clsp::IIRTwoPole<float>::logCoeffs(v19, v57);
  }
  v24 = (float *)(a1 + 100);
  v25 = a2[1];
  v56[0] = *a2;
  v56[1] = v25;
  if (v25)
  {
    v26 = (unint64_t *)((char *)v25 + 8);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
    clsp::IIRTwoPole<float>::logCoeffs(v24, v56);
    do
      v28 = __ldaxr(v26);
    while (__stlxr(v28 - 1, v26));
    if (!v28)
    {
      (*(void (**)(clsp::CLSP_Log *))(*(_QWORD *)v25 + 16))(v25);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v25);
    }
  }
  else
  {
    clsp::IIRTwoPole<float>::logCoeffs(v24, v56);
  }
  v29 = a1 + 160;
  v30 = a2[1];
  v55[0] = *a2;
  v55[1] = v30;
  if (v30)
  {
    v31 = (unint64_t *)((char *)v30 + 8);
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    v33.n128_f32[0] = clsp::AttackRelease<float,double>::logCoeffs(v29, v55);
    do
      v34 = __ldaxr(v31);
    while (__stlxr(v34 - 1, v31));
    if (!v34)
    {
      (*(void (**)(clsp::CLSP_Log *, __n128))(*(_QWORD *)v30 + 16))(v30, v33);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v30);
    }
  }
  else
  {
    clsp::AttackRelease<float,double>::logCoeffs(v29, v55);
  }
  v35 = a1 + 200;
  v36 = a2[1];
  v54[0] = *a2;
  v54[1] = v36;
  if (v36)
  {
    v37 = (unint64_t *)((char *)v36 + 8);
    do
      v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
    v39.n128_f32[0] = clsp::AttackRelease<float,double>::logCoeffs(v35, v54);
    do
      v40 = __ldaxr(v37);
    while (__stlxr(v40 - 1, v37));
    if (!v40)
    {
      (*(void (**)(clsp::CLSP_Log *, __n128))(*(_QWORD *)v36 + 16))(v36, v39);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v36);
    }
  }
  else
  {
    clsp::AttackRelease<float,double>::logCoeffs(v35, v54);
  }
  v41 = a1 + 240;
  v42 = a2[1];
  v53[0] = *a2;
  v53[1] = v42;
  if (v42)
  {
    v43 = (unint64_t *)((char *)v42 + 8);
    do
      v44 = __ldxr(v43);
    while (__stxr(v44 + 1, v43));
    clsp::ExponentialSmoother<float,double>::logCoeffs(v41, v53);
    do
      v45 = __ldaxr(v43);
    while (__stlxr(v45 - 1, v43));
    if (!v45)
    {
      (*(void (**)(clsp::CLSP_Log *))(*(_QWORD *)v42 + 16))(v42);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v42);
    }
  }
  else
  {
    clsp::ExponentialSmoother<float,double>::logCoeffs(v41, v53);
  }
  v46 = *a2;
  v47 = (std::__shared_weak_count *)a2[1];
  v52[0] = v46;
  v52[1] = v47;
  if (v47)
  {
    p_shared_owners = (unint64_t *)&v47->__shared_owners_;
    do
      v49 = __ldxr(p_shared_owners);
    while (__stxr(v49 + 1, p_shared_owners));
  }
  clsp::LFSN::logCoeffs((float *)(a1 + 256), (uint64_t)v52);
  if (v47)
  {
    v50 = (unint64_t *)&v47->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
}

void sub_1B615C4F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t clsp::AdaptiveDisplacementController::setG_bw(uint64_t this, double a2)
{
  *(double *)(this + 16) = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getG_bw(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 2);
}

uint64_t clsp::AdaptiveDisplacementController::setX_lim(uint64_t this, double a2)
{
  *(double *)(this + 24) = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getX_lim(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 3);
}

uint64_t clsp::AdaptiveDisplacementController::setQ_d(uint64_t this, double a2)
{
  *(double *)(this + 32) = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getQ_d(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 4);
}

double *clsp::AdaptiveDisplacementController::setPeakAttackTime(double *this, double a2)
{
  this[5] = a2;
  this[20] = a2;
  this[25] = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getPeakAttackTime(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 5);
}

double *clsp::AdaptiveDisplacementController::setPeakDecayTime(double *this, double a2)
{
  this[6] = a2;
  this[21] = a2;
  this[26] = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getPeakDecayTime(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 6);
}

uint64_t clsp::AdaptiveDisplacementController::setFlvSmoothingTime(uint64_t this, double a2)
{
  *(double *)(this + 56) = a2;
  return this;
}

double clsp::AdaptiveDisplacementController::getFlvSmoothingTime(clsp::AdaptiveDisplacementController *this)
{
  return *((double *)this + 7);
}

uint64_t clsp::AdaptiveDisplacementController::getLFSN(clsp::AdaptiveDisplacementController *this)
{
  return (uint64_t)this + 256;
}

uint64_t clsp::AdaptiveDisplacementController::setDispEnabled(uint64_t this, char a2)
{
  *(_BYTE *)(this + 64) = a2;
  return this;
}

uint64_t clsp::AdaptiveDisplacementController::getDispEnabled(clsp::AdaptiveDisplacementController *this)
{
  return *((unsigned __int8 *)this + 64);
}

uint64_t clsp::AdaptiveDisplacementController::setAttenuationFactor(uint64_t this, float a2)
{
  *(float *)(this + 76) = a2;
  return this;
}

float clsp::AdaptiveDisplacementController::getAttenuationFactor(clsp::AdaptiveDisplacementController *this)
{
  return *((float *)this + 19);
}

float clsp::AdaptiveDisplacementController::calcCoeffs(clsp::AdaptiveDisplacementController *this, double a2, double a3)
{
  double *v4;
  float v7;
  double *v8;
  double v9;
  double v10;
  float v11;
  double *v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  float v19;
  double v20;
  float v21;
  float result;

  v4 = (double *)*((_QWORD *)this + 15);
  if (!v4)
    __assert_rtn("calcCoeffs", "CLSPBlocksAdaptive.cpp", 287, "mr_dispModel");
  v7 = clsp::DisplacementModelSealed::calcCoeffsFLV(v4, (float *)this + 25, a2, a3);
  v8 = (double *)*((_QWORD *)this + 15);
  v9 = (*(double (**)(clsp::AdaptiveDisplacementController *, float))(*(_QWORD *)this + 72))(this, v7);
  v10 = (*(double (**)(clsp::AdaptiveDisplacementController *))(*(_QWORD *)this + 40))(this);
  v11 = clsp::DisplacementModelSealed::calcCoeffsPTP(v8, (float *)this + 20, a2, v9, v10, a3);
  v12 = (double *)*((_QWORD *)this + 15);
  v13 = (*(double (**)(clsp::AdaptiveDisplacementController *, float))(*(_QWORD *)this + 72))(this, v11);
  v14 = (*(double (**)(clsp::AdaptiveDisplacementController *))(*(_QWORD *)this + 40))(this);
  v15 = (*(double (**)(clsp::AdaptiveDisplacementController *))(*(_QWORD *)this + 56))(this);
  clsp::LFSN::calcCoeffs((uint64_t)this + 256, v12, a2, *((double *)this + 10), *((float *)this + 25), *((float *)this + 26), v13, v14, v15, a3);
  clsp::AttackRelease<float,double>::calcCoeffs((uint64_t)this + 160, a2);
  clsp::AttackRelease<float,double>::calcCoeffs((uint64_t)this + 200, a2);
  v16 = *((double *)this + 7);
  *((double *)this + 30) = v16;
  v17 = v16 * a2;
  v18 = 0.0;
  if (v17 >= 0.00001)
    v18 = exp(-4.60517019 / v17);
  v19 = 1.0 - v18;
  *((float *)this + 62) = v19;
  v20 = *((double *)this + 3);
  v21 = v20;
  result = 1.0 / v20;
  *((float *)this + 17) = v21;
  *((float *)this + 18) = result;
  return result;
}

uint64_t clsp::AdaptiveDisplacementController::calcCoeffsSyncDisp(clsp::AdaptiveDisplacementController *this, double a2, double a3, double a4, double a5, double a6, double a7)
{
  double *v7;
  double v13;
  double v14;
  long double v15;
  long double v16;
  long double v17;
  float v18;
  float v19;
  float v20;
  uint64_t v21;

  v7 = (double *)*((_QWORD *)this + 15);
  if (!v7)
    __assert_rtn("calcCoeffsSyncDisp", "CLSPBlocksAdaptive.cpp", 318, "mr_dispModel");
  v13 = 1.0 / a2;
  v14 = -(1.0 / a2 * a3);
  v15 = exp(v14 / (a4 + a4)) * -2.0;
  v16 = v15 * cos(v13 * a3 * sqrt(1.0 / (a4 * -4.0 * a4) + 1.0));
  v17 = exp(v14 / a4);
  v18 = (v17 + v16 + 1.0) * (a7 * 1000.0 * v7[1] / (*v7 * v7[4]));
  v19 = v16;
  *(float *)&v17 = v17;
  *((float *)this + 20) = v19;
  *((_DWORD *)this + 21) = LODWORD(v17);
  *((float *)this + 22) = v18;
  LODWORD(v17) = *((_DWORD *)this + 25);
  v20 = *((float *)this + 26);
  v21 = *((_QWORD *)this + 10);
  *((_DWORD *)this + 78) = 1065353216;
  *((_DWORD *)this + 79) = LODWORD(v17);
  *((float *)this + 80) = v20;
  *((_QWORD *)this + 38) = v21;
  *(float *)&v17 = 1.0 / (1.0 - *(float *)&v17 + v20);
  *((_DWORD *)this + 85) = LODWORD(v17);
  return clsp::LFSNFeedbackCoeffCalc::calcCoeffs((clsp::AdaptiveDisplacementController *)((char *)this + 256), a2, a3, a4, a5, 1.0, a6);
}

void clsp::AdaptiveDisplacementController::processSample(clsp::AdaptiveDisplacementController *this, float a2, float a3)
{
  float v5;
  float v6;
  float v7;
  clsp::CLSP_Log *v8;
  clsp::CLSP_Log *v9;
  float v10;
  float v11;
  float v12;
  float __src;
  float v14;

  if (*((_BYTE *)this + 64))
  {
    v5 = *((float *)this + 19) * *((float *)this + 86);
    if (v5 >= *((float *)this + 70))
      v5 = *((float *)this + 70);
    v6 = (float)(*((float *)this + 64) + (float)(*((float *)this + 65) * v5))
       + (float)(*((float *)this + 66) * (float)(v5 * v5));
    v7 = (float)(*((float *)this + 67) + (float)(*((float *)this + 68) * v5))
       + (float)(*((float *)this + 69) * (float)(v5 * v5));
    *((float *)this + 76) = v6;
    *((float *)this + 77) = v7;
    v8 = *(clsp::CLSP_Log **)(*((_QWORD *)this + 36) + 16);
    if (v8)
    {
      __src = v6;
      clsp::CLSP_Log::LogCLSPData(v8, &__src, 1);
      v9 = *(clsp::CLSP_Log **)(*((_QWORD *)this + 36) + 16);
      if (v9)
      {
        v14 = v7;
        clsp::CLSP_Log::LogCLSPData(v9, &v14, 1);
      }
    }
    v10 = *((float *)this + 81);
    v11 = *((float *)this + 83);
    v12 = (float)((float)((float)((float)(*((float *)this + 79) * v10) + (float)(a3 * *((float *)this + 78)))
                        + (float)(*((float *)this + 82) * *((float *)this + 80)))
                - (float)(v11 * *((float *)this + 76)))
        - (float)(*((float *)this + 84) * *((float *)this + 77));
    *((float *)this + 81) = a3;
    *((float *)this + 82) = v10;
    *((float *)this + 83) = v12;
    *((float *)this + 84) = v11;
  }
}

float clsp::AdaptiveDisplacementController::analyzeDisp(clsp::AdaptiveDisplacementController *this, float a2, float a3)
{
  double *v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  unint64_t v11;
  double *v12;
  uint64_t v13;
  unint64_t v14;
  double v15;
  unint64_t v16;
  float v17;
  double v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  double v29;
  unint64_t v30;
  double v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  unint64_t v36;
  double v37;
  float v38;
  float v39;
  float v40;
  uint64_t v41;
  float v42;
  float v43;
  double *v44;
  uint64_t v45;
  double v46;
  double v47;
  uint64_t v48;
  uint64_t v49;
  double v50;
  unint64_t v51;
  double *v52;
  uint64_t v53;
  unint64_t v54;
  double v55;
  unint64_t v56;
  float v57;
  double v58;
  double v59;
  uint64_t v60;
  uint64_t v61;
  double v62;
  unint64_t v63;
  unint64_t v64;
  int v65;
  float v66;
  double v67;
  uint64_t v68;
  uint64_t v69;
  double v70;
  unint64_t v71;
  double v72;
  double v73;
  double v74;
  uint64_t v75;
  uint64_t v76;
  double v77;
  unint64_t v78;
  float v79;
  double v80;
  double v81;
  float v82;
  float v83;
  float v84;
  uint64_t v85;
  float v86;
  float v87;
  float v88;
  clsp::CLSP_Log **v89;
  clsp::CLSP_Log *v90;
  clsp::CLSP_Log *v91;
  clsp::CLSP_Log *v92;
  clsp::CLSP_Log *v93;
  clsp::CLSP_Log *v94;
  clsp::CLSP_Log *v95;
  clsp::CLSP_Log *v96;
  clsp::CLSP_Log *v97;
  clsp::CLSP_Log *v98;
  float *v99;
  float v101;
  float v102;
  double v103;
  double v104;
  double v105;
  double v107;
  float v108;
  void *__p;
  void *v110;
  uint64_t v111;

  v5 = (double *)*((_QWORD *)this + 18);
  v6 = *(_QWORD *)v5;
  v107 = v5[6];
  v7 = *(double *)(*(_QWORD *)v5 + 16) * v5[5] - **(double **)v5 * v107 - *(double *)(*(_QWORD *)v5 + 8) * v5[7];
  v8 = *(_QWORD *)(*(_QWORD *)v5 + 120);
  v9 = ((*(_QWORD *)(*(_QWORD *)v5 + 128) - v8) >> 3) - 1;
  v10 = *(double *)(v8 + 8 * v9);
  if ((int)v9 >= 1)
  {
    v11 = ((*(_QWORD *)(*(_QWORD *)v5 + 128) - v8) >> 3) - 1 + 1;
    do
      v10 = *(double *)(v8 + 8 * (v11-- - 2)) + v7 * v10;
    while (v11 > 1);
  }
  v12 = *(double **)(v6 + 48);
  v13 = *(_QWORD *)(v6 + 56);
  v14 = (v13 - (uint64_t)v12) >> 3;
  v15 = v12[v14 - 1];
  if ((int)v14 - 1 >= 1)
  {
    v16 = (v14 - 1) + 1;
    do
      v15 = v12[(v16-- - 2)] + v7 * v15;
    while (v16 > 1);
  }
  v17 = *((float *)v5 + 4);
  v18 = v5[3];
  v104 = v5[4];
  v19 = *(double *)(v6 + 32);
  __p = 0;
  v110 = 0;
  v111 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&__p, v12, v13, v14);
  v20 = *(_QWORD *)(v6 + 56) - *(_QWORD *)(v6 + 48);
  v21 = (v20 >> 3) - 1;
  v22 = *((double *)__p + v21) * (double)(unint64_t)v21;
  if ((int)v21 > 1)
  {
    v23 = (unint64_t)v20 >> 3;
    v24 = (v20 >> 3) - 1 + 1;
    v25 = v23 - 2;
    do
      v22 = v7 * v22 + (double)v25-- * *((double *)__p + (v24-- - 2));
    while (v24 > 2);
  }
  v26 = v17 * a2;
  v110 = __p;
  operator delete(__p);
  v27 = *(_QWORD *)(v6 + 72);
  v28 = ((*(_QWORD *)(v6 + 80) - v27) >> 3) - 1;
  v29 = *(double *)(v27 + 8 * v28);
  if ((int)v28 < 2)
  {
    v31 = v104;
  }
  else
  {
    v30 = ((*(_QWORD *)(v6 + 80) - v27) >> 3) - 1 + 1;
    v31 = v104;
    do
      v29 = *(double *)(v27 + 8 * (v30-- - 2)) + v7 * v29;
    while (v30 > 2);
  }
  v32 = v18 * (v7 - v107);
  v33 = *(_QWORD *)(v6 + 96);
  v34 = ((*(_QWORD *)(v6 + 104) - v33) >> 3) - 1;
  v35 = *(double *)(v33 + 8 * v34);
  if ((int)v34 > 1)
  {
    v36 = ((*(_QWORD *)(v6 + 104) - v33) >> 3) - 1 + 1;
    do
      v35 = *(double *)(v33 + 8 * (v36-- - 2)) + v32 * v35;
    while (v36 > 2);
  }
  v37 = (v26 + v31 * v15 * v18 - v10 * v32) / (v19 + v15 * v18 + v22 * v32);
  v5[4] = v37;
  v5[5] = v7 * -(v7 * v29) + v10 * v37 + -(v32 * v35) * v32;
  v5[6] = v7;
  v5[7] = v107;
  v38 = v7;
  v39 = -v38;
  if (v38 >= 0.0)
    v39 = v7;
  v40 = *((float *)this + 48);
  v41 = 180;
  if (v40 < v39)
    v41 = 176;
  v42 = v40 + (float)(*(float *)((char *)this + v41) * (float)(v39 - v40));
  *((float *)this + 48) = v42;
  if (*((float *)this + 17) >= v42)
    v43 = *((float *)this + 17);
  else
    v43 = v42;
  v44 = (double *)*((_QWORD *)this + 19);
  v45 = *(_QWORD *)v44;
  v46 = v44[6];
  v47 = *(double *)(*(_QWORD *)v44 + 16) * v44[5]
      - **(double **)v44 * v46
      - *(double *)(*(_QWORD *)v44 + 8) * v44[7];
  v48 = *(_QWORD *)(*(_QWORD *)v44 + 120);
  v49 = ((*(_QWORD *)(*(_QWORD *)v44 + 128) - v48) >> 3) - 1;
  v50 = *(double *)(v48 + 8 * v49);
  if ((int)v49 >= 1)
  {
    v51 = ((*(_QWORD *)(*(_QWORD *)v44 + 128) - v48) >> 3) - 1 + 1;
    do
      v50 = *(double *)(v48 + 8 * (v51-- - 2)) + v47 * v50;
    while (v51 > 1);
  }
  v52 = *(double **)(v45 + 48);
  v53 = *(_QWORD *)(v45 + 56);
  v54 = (v53 - (uint64_t)v52) >> 3;
  v55 = v52[v54 - 1];
  v108 = v43;
  v101 = v42;
  v102 = v38;
  if ((int)v54 - 1 >= 1)
  {
    v56 = (v54 - 1) + 1;
    do
      v55 = v52[(v56-- - 2)] + v47 * v55;
    while (v56 > 1);
  }
  v57 = *((float *)v44 + 4);
  v58 = v44[3];
  v103 = v44[4];
  v59 = *(double *)(v45 + 32);
  __p = 0;
  v110 = 0;
  v111 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&__p, v52, v53, v54);
  v60 = *(_QWORD *)(v45 + 56) - *(_QWORD *)(v45 + 48);
  v61 = (v60 >> 3) - 1;
  v62 = *((double *)__p + v61) * (double)(unint64_t)v61;
  if ((int)v61 > 1)
  {
    v63 = (unint64_t)v60 >> 3;
    v64 = (v60 >> 3) - 1 + 1;
    v65 = v63 - 2;
    do
      v62 = v47 * v62 + (double)v65-- * *((double *)__p + (v64-- - 2));
    while (v64 > 2);
  }
  v66 = v57 * a3;
  v105 = v46;
  v67 = v47 - v46;
  v110 = __p;
  operator delete(__p);
  v68 = *(_QWORD *)(v45 + 72);
  v69 = ((*(_QWORD *)(v45 + 80) - v68) >> 3) - 1;
  v70 = *(double *)(v68 + 8 * v69);
  if ((int)v69 < 2)
  {
    v72 = v103;
  }
  else
  {
    v71 = ((*(_QWORD *)(v45 + 80) - v68) >> 3) - 1 + 1;
    v72 = v103;
    do
      v70 = *(double *)(v68 + 8 * (v71-- - 2)) + v47 * v70;
    while (v71 > 2);
  }
  v73 = v66;
  v74 = v58 * v67;
  v75 = *(_QWORD *)(v45 + 96);
  v76 = ((*(_QWORD *)(v45 + 104) - v75) >> 3) - 1;
  v77 = *(double *)(v75 + 8 * v76);
  if ((int)v76 < 2)
  {
    v79 = v108;
    v80 = v105;
  }
  else
  {
    v78 = ((*(_QWORD *)(v45 + 104) - v75) >> 3) - 1 + 1;
    v79 = v108;
    v80 = v105;
    do
      v77 = *(double *)(v75 + 8 * (v78-- - 2)) + v74 * v77;
    while (v78 > 2);
  }
  v81 = (v73 + v72 * v55 * v58 - v50 * v74) / (v59 + v55 * v58 + v62 * v74);
  v44[4] = v81;
  v44[5] = v47 * -(v47 * v70) + v50 * v81 + -(v74 * v77) * v74;
  v44[6] = v47;
  v44[7] = v80;
  v82 = v47;
  v83 = -v82;
  if (v82 >= 0.0)
    v83 = v47;
  v84 = *((float *)this + 58);
  v85 = 220;
  if (v84 < v83)
    v85 = 216;
  v86 = v84 + (float)(*(float *)((char *)this + v85) * (float)(v83 - v84));
  *((float *)this + 58) = v86;
  v87 = *((float *)this + 17);
  if (v87 < v86)
    v87 = v86;
  v88 = *((float *)this + 63)
      + (float)(*((float *)this + 62) * (float)((float)(*((float *)this + 18) * v87) - *((float *)this + 63)));
  *((float *)this + 63) = v88;
  *((float *)this + 19) = v79 * v88;
  v89 = (clsp::CLSP_Log **)*((_QWORD *)this + 44);
  v90 = *v89;
  if (*v89)
  {
    *(float *)&__p = a3;
    clsp::CLSP_Log::LogCLSPData(v90, (const float *)&__p, 1);
    v89 = (clsp::CLSP_Log **)*((_QWORD *)this + 44);
  }
  v91 = v89[2];
  if (v91)
  {
    *(float *)&__p = v102;
    clsp::CLSP_Log::LogCLSPData(v91, (const float *)&__p, 1);
    v89 = (clsp::CLSP_Log **)*((_QWORD *)this + 44);
    v92 = v89[2];
    if (v92)
    {
      *(float *)&__p = v101;
      clsp::CLSP_Log::LogCLSPData(v92, (const float *)&__p, 1);
      v89 = (clsp::CLSP_Log **)*((_QWORD *)this + 44);
      v93 = v89[2];
      if (v93)
      {
        *(float *)&__p = v79;
        clsp::CLSP_Log::LogCLSPData(v93, (const float *)&__p, 1);
        v89 = (clsp::CLSP_Log **)*((_QWORD *)this + 44);
        v94 = v89[2];
        if (v94)
        {
          *(float *)&__p = v88;
          clsp::CLSP_Log::LogCLSPData(v94, (const float *)&__p, 1);
          v89 = (clsp::CLSP_Log **)*((_QWORD *)this + 44);
        }
      }
    }
  }
  v95 = *v89;
  if (*v89)
  {
    *(float *)&__p = v47;
    clsp::CLSP_Log::LogCLSPData(v95, (const float *)&__p, 1);
    v96 = (clsp::CLSP_Log *)**((_QWORD **)this + 44);
    if (v96)
    {
      *(float *)&__p = v86;
      clsp::CLSP_Log::LogCLSPData(v96, (const float *)&__p, 1);
      v97 = (clsp::CLSP_Log *)**((_QWORD **)this + 44);
      if (v97)
      {
        LODWORD(__p) = *((_DWORD *)this + 19);
        clsp::CLSP_Log::LogCLSPData(v97, (const float *)&__p, 1);
        v98 = (clsp::CLSP_Log *)**((_QWORD **)this + 44);
        if (v98)
        {
          v99 = (float *)(*(uint64_t (**)(clsp::AdaptiveDisplacementController *))(*(_QWORD *)this + 128))(this);
          *(float *)&__p = log10f(v99[21]* (float)((float)((float)((float)(1.0 - v99[12]) + v99[13])* (float)((float)(v99[14] + v99[15]) + v99[16]))/ (float)((float)(v99[12] + 1.0) + v99[13])))* 20.0;
          clsp::CLSP_Log::LogCLSPData(v98, (const float *)&__p, 1);
        }
      }
    }
  }
  return *((float *)this + 19);
}

float clsp::AdaptiveDisplacementController::getNormAttenFactor(clsp::AdaptiveDisplacementController *this)
{
  return *((float *)this + 19) * *((float *)this + 18);
}

float clsp::AdaptiveDisplacementController::reset(clsp::AdaptiveDisplacementController *this)
{
  float result;

  *(_QWORD *)((char *)this + 332) = 0;
  *(_QWORD *)((char *)this + 324) = 0;
  *(_QWORD *)((char *)this + 92) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 58) = 0;
  *((_DWORD *)this + 63) = 0;
  result = (*(double (**)(clsp::AdaptiveDisplacementController *))(*(_QWORD *)this + 56))(this);
  *((float *)this + 19) = result;
  return result;
}

uint64_t clsp::AdaptiveDisplacementController::zapBadValues(uint64_t this)
{
  float32x2_t v1;
  float64x2_t v2;
  float64x2_t v3;
  float64x2_t v4;
  float v5;
  double v6;
  float32x2_t v8;
  float64x2_t v9;
  float v10;
  double v11;
  float v13;
  double v14;
  float32x4_t v16;
  float32x4_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float v20;
  double v21;

  v1 = *(float32x2_t *)(this + 92);
  v2 = vcvtq_f64_f32(vabs_f32(v1));
  v3 = (float64x2_t)vdupq_n_s64(0x3CD203AF9EE75616uLL);
  v4 = (float64x2_t)vdupq_n_s64(0x430C6BF526340000uLL);
  *(int8x8_t *)(this + 92) = vand_s8((int8x8_t)v1, (int8x8_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_f64(v2, v3), (int8x16_t)vcgtq_f64(v4, v2))));
  v5 = *(float *)(this + 192);
  v6 = fabsf(v5);
  if (v6 >= 1.0e15 || v6 <= 1.0e-15)
    v5 = 0.0;
  *(float *)(this + 192) = v5;
  v8 = *(float32x2_t *)(this + 112);
  v9 = vcvtq_f64_f32(vabs_f32(v8));
  *(int8x8_t *)(this + 112) = vand_s8((int8x8_t)v8, (int8x8_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_f64(v9, v3), (int8x16_t)vcgtq_f64(v4, v9))));
  v10 = *(float *)(this + 232);
  v11 = fabsf(v10);
  if (v11 >= 1.0e15 || v11 <= 1.0e-15)
    v10 = 0.0;
  *(float *)(this + 232) = v10;
  v13 = *(float *)(this + 252);
  v14 = fabsf(v13);
  if (v14 >= 1.0e15 || v14 <= 1.0e-15)
    v13 = 0.0;
  *(float *)(this + 252) = v13;
  v16 = *(float32x4_t *)(this + 324);
  v17 = vabsq_f32(v16);
  v18 = vcvt_hight_f64_f32(v17);
  v19 = vcvtq_f64_f32(*(float32x2_t *)v17.f32);
  *(int8x16_t *)(this + 324) = vandq_s8((int8x16_t)v16, (int8x16_t)vuzp1q_s32((int32x4_t)vandq_s8((int8x16_t)vcgtq_f64(v19, v3), (int8x16_t)vcgtq_f64(v4, v19)), (int32x4_t)vandq_s8((int8x16_t)vcgtq_f64(v18, v3), (int8x16_t)vcgtq_f64(v4, v18))));
  v20 = *(float *)(this + 76);
  v21 = fabsf(v20);
  if (v21 >= 1.0e15 || v21 <= 1.0e-15)
    v20 = 0.0;
  if (v20 < *(float *)(this + 68))
    v20 = *(float *)(this + 68);
  *(float *)(this + 76) = v20;
  return this;
}

float clsp::DisplacementControllerBase::getflvMax(clsp::DisplacementControllerBase *this)
{
  return 0.0;
}

float clsp::DisplacementControllerBase::getAttenuationMax(clsp::DisplacementControllerBase *this)
{
  return 0.0;
}

_QWORD *clsp::AdaptiveDisplacementController::setLogs(uint64_t a1, uint64_t *a2)
{
  std::shared_ptr<clsp::CLSPKernel_Logs>::operator=[abi:ne180100]((_QWORD *)(a1 + 352), *a2, a2[1]);
  return std::shared_ptr<clsp::CLSPKernel_Logs>::operator=[abi:ne180100]((_QWORD *)(a1 + 288), *a2, a2[1]);
}

_QWORD *std::shared_ptr<clsp::CLSPKernel_Logs>::operator=[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (a3)
  {
    v4 = (unint64_t *)(a3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return a1;
}

_QWORD *std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::tuple<unsigned int,float>>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B615D2C0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float clsp::DisplacementModelSealed::calcCoeffsFLV(double *a1, float *a2, double a3, double a4)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  long double v13;
  long double v14;
  long double v15;
  float v16;
  float v17;
  float result;

  v5 = a1[4];
  v7 = a1[1];
  v6 = a1[2];
  v8 = *a1;
  v9 = sqrt(v5 * v6) / (a1[3] + v7 * v7 / *a1);
  v10 = sqrt(v5 / v6);
  v11 = 1.0 / a3;
  v12 = -(1.0 / a3 * v10);
  v13 = exp(v12 / (v9 + v9)) * -2.0;
  v14 = v13 * cos(v11 * v10 * sqrt(1.0 / (v9 * -4.0 * v9) + 1.0));
  v15 = exp(v12 / v9);
  v16 = (v15 + v14 + 1.0) * (a4 * 1000.0 * v7 / (v8 * v5));
  v17 = v14;
  result = v15;
  *a2 = v17;
  a2[1] = result;
  a2[2] = v16;
  return result;
}

float clsp::DisplacementModelSealed::calcCoeffsPTP(double *a1, float *a2, double a3, double a4, double a5, double a6)
{
  double v10;
  double v11;
  double v12;
  double v13;
  long double v14;
  long double v15;
  long double v16;
  float v17;
  float v18;
  float result;

  v10 = a1[4];
  v11 = sqrt(v10 / a1[2]) / sqrt(a5);
  v12 = 1.0 / a3;
  v13 = -(1.0 / a3 * v11);
  v14 = exp(v13 / (a4 + a4)) * -2.0;
  v15 = v14 * cos(v12 * v11 * sqrt(1.0 / (a4 * -4.0 * a4) + 1.0));
  v16 = exp(v13 / a4);
  v17 = (v16 + v15 + 1.0) * (a6 * 1000.0 * a1[1] / (*a1 * v10));
  v18 = v15;
  result = v16;
  *a2 = v18;
  a2[1] = result;
  a2[2] = v17;
  return result;
}

float clsp::LFSN::calcCoeffs(uint64_t a1, double *a2, double a3, double a4, float a5, float a6, double a7, double a8, double a9, double a10)
{
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  float result;

  *(_DWORD *)(a1 + 56) = 1065353216;
  *(float *)(a1 + 60) = a5;
  *(float *)(a1 + 64) = a6;
  *(double *)(a1 + 48) = a4;
  v12 = a5;
  v13 = 1.0;
  *(float *)&v12 = 1.0 / (1.0 - v12 + a6);
  *(_DWORD *)(a1 + 84) = LODWORD(v12);
  v14 = a2[4];
  v15 = a2[1];
  v16 = a2[2];
  v17 = sqrt(v14 / v16);
  v18 = sqrt(v14 * v16) / (a2[3] + v15 * v15 / *a2);
  v19 = a10 * 1000.0 * v15;
  if (v18 >= 1.0)
    v13 = v18;
  clsp::LFSNFeedbackCoeffCalc::calcCoeffs((clsp::LFSNFeedbackCoeffCalc *)a1, a3, v17, a7, a8, a9, v19 * v13 / (*a2 * v14));
  result = v17;
  *(float *)(a1 + 92) = result;
  *(_DWORD *)(a1 + 88) = 1065353216;
  return result;
}

float clsp::AttackRelease<float,double>::calcCoeffs(uint64_t a1, double a2)
{
  double v4;
  double v5;
  double v6;
  float v7;
  double v8;
  float result;

  *(double *)(a1 + 24) = a2;
  v4 = *(double *)(a1 + 8) * a2;
  v5 = 0.0;
  v6 = 0.0;
  if (v4 >= 0.00001)
    v6 = exp(-4.60517019 / v4);
  v7 = 1.0 - v6;
  *(float *)(a1 + 20) = v7;
  v8 = *(double *)a1 * a2;
  if (v8 >= 0.00001)
    v5 = exp(-4.60517019 / v8);
  result = 1.0 - v5;
  *(float *)(a1 + 16) = result;
  return result;
}

void clsp::IIRTwoPole<float>::logCoeffs(float *a1, clsp::CLSP_Log **a2)
{
  clsp::CLSP_Log *v3;
  clsp::CLSP_Log *v5;
  clsp::CLSP_Log *v6;
  float __src;
  float v8;
  float v9;

  v3 = *a2;
  if (*a2)
  {
    __src = *a1;
    clsp::CLSP_Log::LogCLSPData(v3, &__src, 1);
    v5 = *a2;
    if (*a2)
    {
      v8 = a1[1];
      clsp::CLSP_Log::LogCLSPData(v5, &v8, 1);
      v6 = *a2;
      if (*a2)
      {
        v9 = a1[2];
        clsp::CLSP_Log::LogCLSPData(v6, &v9, 1);
      }
    }
  }
}

float clsp::AttackRelease<float,double>::logCoeffs(uint64_t a1, clsp::CLSP_Log **a2)
{
  clsp::CLSP_Log *v3;
  float v5;
  float result;
  clsp::CLSP_Log *v7;
  float v8;
  clsp::CLSP_Log *v9;
  clsp::CLSP_Log *v10;
  clsp::CLSP_Log *v11;
  float v12;
  float __src;

  v3 = *a2;
  if (*a2)
  {
    v5 = *(double *)a1;
    __src = v5;
    clsp::CLSP_Log::LogCLSPData(v3, &__src, 1);
    v7 = *a2;
    if (*a2)
    {
      v8 = *(double *)(a1 + 8);
      __src = v8;
      clsp::CLSP_Log::LogCLSPData(v7, &__src, 1);
      v9 = *a2;
      if (*a2)
      {
        __src = *(float *)(a1 + 16);
        clsp::CLSP_Log::LogCLSPData(v9, &__src, 1);
        v10 = *a2;
        if (*a2)
        {
          __src = *(float *)(a1 + 20);
          clsp::CLSP_Log::LogCLSPData(v10, &__src, 1);
          v11 = *a2;
          if (*a2)
          {
            v12 = *(double *)(a1 + 24);
            __src = v12;
            clsp::CLSP_Log::LogCLSPData(v11, &__src, 1);
          }
        }
      }
    }
  }
  return result;
}

void clsp::ExponentialSmoother<float,double>::logCoeffs(uint64_t a1, clsp::CLSP_Log **a2)
{
  clsp::CLSP_Log *v3;
  float v5;
  clsp::CLSP_Log *v6;
  float __src;
  float v8;

  v3 = *a2;
  if (*a2)
  {
    v5 = *(double *)a1;
    __src = v5;
    clsp::CLSP_Log::LogCLSPData(v3, &__src, 1);
    v6 = *a2;
    if (*a2)
    {
      v8 = *(float *)(a1 + 8);
      clsp::CLSP_Log::LogCLSPData(v6, &v8, 1);
    }
  }
}

void clsp::LFSN::logCoeffs(float *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  clsp::CLSP_Log *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  clsp::CLSP_Log *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  clsp::CLSP_Log *v16;
  float __src;

  v5 = *(clsp::CLSP_Log **)a2;
  v4 = *(std::__shared_weak_count **)(a2 + 8);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  if (v5)
  {
    __src = *a1;
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    __src = a1[1];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    __src = a1[2];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    __src = a1[3];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    __src = a1[4];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    __src = a1[5];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
    __src = a1[6];
    clsp::CLSP_Log::LogCLSPData(v5, &__src, 1);
  }
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v11 = *(clsp::CLSP_Log **)a2;
  v10 = *(std::__shared_weak_count **)(a2 + 8);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (v11)
  {
    __src = a1[12];
    clsp::CLSP_Log::LogCLSPData(v11, &__src, 1);
    __src = a1[13];
    clsp::CLSP_Log::LogCLSPData(v11, &__src, 1);
    __src = a1[14];
    clsp::CLSP_Log::LogCLSPData(v11, &__src, 1);
    __src = a1[15];
    clsp::CLSP_Log::LogCLSPData(v11, &__src, 1);
    __src = a1[16];
    clsp::CLSP_Log::LogCLSPData(v11, &__src, 1);
  }
  if (v10)
  {
    v14 = (unint64_t *)&v10->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v16 = *(clsp::CLSP_Log **)a2;
  if (*(_QWORD *)a2)
  {
    __src = a1[21];
    clsp::CLSP_Log::LogCLSPData(v16, &__src, 1);
  }
}

_QWORD *clsp::IIRTwoPole<float>::dump(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  char v7;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"a1 = ", 5);
  v3 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"\na2 = ", 6);
  v4 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\nb0 = ", 6);
  v5 = (_QWORD *)std::ostream::operator<<();
  v7 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)&v7, 1);
  return a2;
}

_QWORD *clsp::AttackRelease<float,double>::dump(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  char v9;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"attackTime = ", 13);
  v3 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"\nreleaseTime = ", 15);
  v4 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\na1_atk = ", 10);
  v5 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"\na1_rel = ", 10);
  v6 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"\nsampleRate = ", 14);
  v7 = (_QWORD *)std::ostream::operator<<();
  v9 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)&v9, 1);
  return a2;
}

_QWORD *clsp::ExponentialSmoother<float,double>::dump(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"decayTime = ", 12);
  v3 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"\na1 = ", 6);
  std::ostream::operator<<();
  return a2;
}

_QWORD *clsp::LFSN::dump(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  char v18;
  char v19;

  v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"fcc:\n", 5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"ca10 = ", 7);
  v4 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\nca11 = ", 8);
  v5 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"\nca12 = ", 8);
  v6 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"\nca20 = ", 8);
  v7 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"\nca21 = ", 8);
  v8 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"\nca22 = ", 8);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"\nxUpperLimit = ", 15);
  v10 = (_QWORD *)std::ostream::operator<<();
  v18 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)&v18, 1);
  v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"\nlfsn:\n", 7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"a1 = ", 5);
  v12 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"\na2 = ", 6);
  v13 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"\nb0 = ", 6);
  v14 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"\nb1 = ", 6);
  v15 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"\nb2 = ", 6);
  v16 = (_QWORD *)std::ostream::operator<<();
  v19 = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)&v19, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"\ncsigma = ", 10);
  std::ostream::operator<<();
  return a2;
}

uint64_t std::unique_ptr<clsp::SpeakerModelNonlinear>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

_QWORD *std::vector<double>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::tuple<unsigned int,float>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B615DE4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void AUSM::SoundStage::~SoundStage(AUSM::SoundStage *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void **v11;

  v2 = (void *)*((_QWORD *)this + 44);
  if (v2)
  {
    *((_QWORD *)this + 45) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 40);
  if (v3)
  {
    *((_QWORD *)this + 41) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 37);
  if (v4)
  {
    *((_QWORD *)this + 38) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 34);
  if (v5)
  {
    *((_QWORD *)this + 35) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 31);
  if (v6)
  {
    *((_QWORD *)this + 32) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 28);
  if (v7)
  {
    *((_QWORD *)this + 29) = v7;
    operator delete(v7);
  }
  if (*((char *)this + 223) < 0)
    operator delete(*((void **)this + 25));
  v11 = (void **)((char *)this + 168);
  std::vector<AUSM::SoundStage::SoundStageParameters>::__destroy_vector::operator()[abi:ne180100](&v11);
  v11 = (void **)((char *)this + 136);
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&v11);
  v8 = (void *)*((_QWORD *)this + 14);
  if (v8)
  {
    *((_QWORD *)this + 15) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 11);
  if (v9)
  {
    *((_QWORD *)this + 12) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 8);
  if (v10)
  {
    *((_QWORD *)this + 9) = v10;
    operator delete(v10);
  }
  CDelaunayTriangles3D::~CDelaunayTriangles3D((AUSM::SoundStage *)((char *)this + 16));
}

void std::vector<AUSM::SoundStage::SoundStageParameters>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 176;
        std::__destroy_at[abi:ne180100]<AUSM::SoundStage::SoundStageParameters,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  uint64_t *v2;
  uint64_t *v4;
  void *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;

  v1 = *a1;
  v2 = (uint64_t *)**a1;
  if (v2)
  {
    v4 = (uint64_t *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 3;
        if (*(v4 - 1))
        {
          v8 = *(v4 - 3);
          v7 = (uint64_t *)*(v4 - 2);
          v9 = *v7;
          *(_QWORD *)(v9 + 8) = *(_QWORD *)(v8 + 8);
          **(_QWORD **)(v8 + 8) = v9;
          *(v4 - 1) = 0;
          if (v7 != v6)
          {
            do
            {
              v10 = (uint64_t *)v7[1];
              operator delete(v7);
              v7 = v10;
            }
            while (v10 != v6);
          }
        }
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<AUSM::SoundStage::SoundStageParameters,0>(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = *(void **)(a1 + 144);
  if (v2)
  {
    *(_QWORD *)(a1 + 152) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 80);
  if (v3)
  {
    *(_QWORD *)(a1 + 88) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 56);
  if (v4)
  {
    *(_QWORD *)(a1 + 64) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 32);
  if (v5)
  {
    *(_QWORD *)(a1 + 40) = v5;
    operator delete(v5);
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void AUSM::GlobalGeometry::update(float32x2_t *this, unsigned int a2, int a3)
{
  unsigned __int8 v6;
  unsigned __int128 *v7;
  unsigned __int128 v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned __int8 v24;
  unsigned __int128 *v25;
  unsigned __int128 v26;
  float32x4_t v27;
  float32x4_t v28;
  float v29;
  float32x4_t v30;
  float v31;
  float32x4_t v32;
  float v33;
  int32x4_t v34;
  int8x16_t v35;
  float32x2_t v36;
  float32x4_t v37;
  unsigned __int32 v38;
  float32x2_t v39;
  float32x2_t v40;
  unsigned int v41;
  unsigned __int8 v42;
  unsigned __int128 *v43;
  unsigned __int128 v44;
  int32x4_t v45;
  float v46;
  float32x4_t v47;
  float32x4_t v48;
  float v49;
  unsigned __int8 v50;
  unsigned __int128 *v51;
  unsigned __int128 v52;
  unsigned __int128 *v53;
  unsigned __int128 v54;
  int32x4_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int8x16_t v60;
  float32x2_t v61;
  float32x4_t v62;
  unsigned __int32 v63;
  float32x2_t v64;
  float32x2_t v65;
  float32x4_t v66;
  int8x16_t v67;
  float32x2_t v68;
  float32x2_t v69;
  unsigned __int8 v70;
  unsigned int v71;
  int v72;
  unsigned __int8 v73;
  int v74;
  int v75;
  unsigned __int8 v76;
  float v77;
  float v78;

  v6 = atomic_load((unsigned __int8 *)&this[128] + 4);
  if ((v6 & 1) != 0 || a3)
  {
    atomic_store(0, (unsigned __int8 *)&this[128] + 4);
    __dmb(0xBu);
    v7 = (unsigned __int128 *)(*(_QWORD *)&this[56] + 2448);
    do
      v8 = __ldaxp(v7);
    while (__stlxp(v8, v7));
    v9 = *((float *)&v8 + 1);
    v10 = this[69].f32[1];
    if (v10 != *(float *)&v8)
    {
      v11 = 0.0;
      if (*(float *)&v8 >= 0.0)
        v10 = *(float *)&v8;
      else
        v10 = 0.0;
      this[69].f32[1] = v10;
      if (v10 >= 0.001)
      {
        v12 = this[70].f32[0];
        if ((float)(v12 - v10) >= 0.001)
        {
          v13 = log10f(this[70].f32[1]);
          v11 = v13 / log10f(v12 / v10);
        }
      }
      this[71].f32[0] = v11;
    }
    if (this[70].f32[0] != *((float *)&v8 + 1))
    {
      v14 = 0.0;
      if (*((float *)&v8 + 1) < 0.0)
        v9 = 0.0;
      this[70].f32[0] = v9;
      if (v10 >= 0.001 && (float)(v9 - v10) >= 0.001)
      {
        v15 = log10f(this[70].f32[1]);
        v14 = v15 / log10f(v9 / v10);
      }
      this[71].f32[0] = v14;
    }
    v16 = __exp10f(*((float *)&v8 + 2) * -0.05);
    if (this[70].f32[1] != v16)
    {
      if (v16 < 0.000001)
        v16 = 0.000001;
      this[70].f32[1] = v16;
      v17 = this[69].f32[1];
      v18 = 0.0;
      if (v17 >= 0.001)
      {
        v19 = this[70].f32[0];
        if ((float)(v19 - v17) >= 0.001)
        {
          v20 = log10f(v16);
          v18 = v20 / log10f(v19 / v17);
        }
      }
      this[71].f32[0] = v18;
    }
    v21 = atomic_load((unsigned int *)(*(_QWORD *)&this[56] + 2464));
    this[69].i32[0] = v21;
    atomic_store(1u, (unsigned __int8 *)&this[128]);
  }
  if (!*(_BYTE *)(*(_QWORD *)&this[56] + 2544))
  {
    v22 = atomic_load((unsigned int *)&this[52]);
    if (v22 != this[51].i32[1])
    {
      if (this[53].f32[0] == 0.0)
      {
        v23 = atomic_load((unsigned int *)&this[52]);
        atomic_store(v23, (unsigned int *)&this[51]);
      }
      if (AUSM::SoundStage::incrementSoundStageVerticesAndGains(this, a2))
      {
        atomic_store(1u, (unsigned __int8 *)&this[128]);
        ++this[130].i32[1];
      }
    }
  }
  v24 = atomic_load((unsigned __int8 *)&this[128]);
  if ((v24 & 1) != 0 || a3)
  {
    atomic_store(0, (unsigned __int8 *)&this[128]);
    __dmb(0xBu);
    v25 = (unsigned __int128 *)(*(_QWORD *)&this[56] + 2432);
    do
      v26 = __ldaxp(v25);
    while (__stlxp(v26, v25));
    v27 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v26, 1);
    v27.i32[1] = v26;
    v27.i32[2] = vnegq_f32((float32x4_t)v26).i32[2];
    v28 = vmulq_f32(v27, v27);
    v29 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]);
    if (v29 <= 0.0001)
    {
      v32.i64[0] = 0;
      v32.i32[2] = 0;
      v33 = 1.0;
    }
    else
    {
      v30 = vmulq_f32(v27, (float32x4_t)xmmword_1B66A0780);
      v31 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0];
      if ((float)((float)(v31 / v29) + 1.0) >= 0.0001)
      {
        v34 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27), (int8x16_t)v27, 0xCuLL), (float32x4_t)xmmword_1B66A07A0), (float32x4_t)xmmword_1B66282F0, v27);
        v32 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v34, v34), (int8x16_t)v34, 0xCuLL);
        v33 = v31 + v29;
      }
      else
      {
        v32 = (float32x4_t)xmmword_1B66A0790;
        v33 = 0.0;
      }
    }
    v32.f32[3] = v33;
    v35 = (int8x16_t)vmulq_f32(v32, v32);
    v36 = vadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL));
    if (vaddv_f32(v36) == 0.0)
    {
      v37 = (float32x4_t)xmmword_1B6629CC0;
    }
    else
    {
      v38 = vadd_f32(v36, (float32x2_t)vdup_lane_s32((int32x2_t)v36, 1)).u32[0];
      v39 = vrsqrte_f32((float32x2_t)v38);
      v40 = vmul_f32(v39, vrsqrts_f32((float32x2_t)v38, vmul_f32(v39, v39)));
      v37 = vmulq_n_f32(v32, vmul_f32(v40, vrsqrts_f32((float32x2_t)v38, vmul_f32(v40, v40))).f32[0]);
    }
    *(float32x4_t *)this[58].f32 = v37;
    this[60].f32[0] = v29;
    if (!*(_BYTE *)(*(_QWORD *)&this[56] + 2544))
    {
      v41 = atomic_load((unsigned int *)&this[51]);
      if (v41 || this[51].i32[1])
        v29 = (float)(1.0 - this[43].f32[1]) + (float)(this[43].f32[1] * this[60].f32[0]);
      else
        v29 = this[60].f32[0];
    }
    this[60].f32[1] = v29;
    this[61].f32[0] = AUSM::DistanceGain::calculateDistanceGain((AUSM::DistanceGain *)&this[68], v29);
    ++this[129].i32[0];
  }
  v42 = atomic_load((unsigned __int8 *)&this[128] + 2);
  if ((v42 & 1) != 0 || a3)
  {
    atomic_store(0, (unsigned __int8 *)&this[128] + 2);
    __dmb(0xBu);
    v43 = (unsigned __int128 *)(*(_QWORD *)&this[56] + 144);
    do
      v44 = __ldaxp(v43);
    while (__stlxp(v44, v43));
    v45 = vdupq_lane_s32(*(int32x2_t *)&v44, 1);
    v45.i32[1] = v44;
    v45.i32[2] = vnegq_f32((float32x4_t)v44).i32[2];
    *(int32x4_t *)this[62].f32 = v45;
    v46 = COERCE_FLOAT(atomic_load((unsigned int *)(*(_QWORD *)&this[56] + 168)));
    if (v46 >= 0.0)
    {
      v47 = *(float32x4_t *)this[62].f32;
      v48 = vmulq_f32(v47, v47);
      v49 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1))).f32[0]);
      if (v49 > 0.0 && (float)(v46 / v49) < 1.0)
        *(float32x4_t *)this[62].f32 = vmulq_n_f32(v47, v46 / v49);
    }
    ++this[129].i32[1];
  }
  v50 = atomic_load((unsigned __int8 *)&this[128] + 1);
  if ((v50 & 1) != 0 || a3)
  {
    atomic_store(0, (unsigned __int8 *)&this[128] + 1);
    __dmb(0xBu);
    v51 = (unsigned __int128 *)(*(_QWORD *)&this[56] + 112);
    do
      v52 = __ldaxp(v51);
    while (__stlxp(v52, v51));
    v53 = (unsigned __int128 *)(*(_QWORD *)&this[56] + 128);
    do
      v54 = __ldaxp(v53);
    while (__stlxp(v54, v53));
    v55 = (int32x4_t)vnegq_f32((float32x4_t)v54);
    v56 = (int8x16_t)vtrn2q_s32((int32x4_t)v54, vtrn1q_s32((int32x4_t)v54, v55));
    v57 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v55, 8uLL), *(float32x2_t *)&v52, 1), (float32x4_t)vextq_s8(v56, v56, 8uLL), *(float *)&v52);
    v58 = (float32x4_t)vrev64q_s32((int32x4_t)v54);
    v58.i32[0] = v55.i32[1];
    v58.i32[3] = v55.i32[2];
    v59 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)v54, (float32x4_t)v52, 3), v58, (float32x4_t)v52, 2), v57);
    v60 = (int8x16_t)vmulq_f32(v59, v59);
    v61 = vadd_f32(*(float32x2_t *)v60.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL));
    if (vaddv_f32(v61) == 0.0)
    {
      v62 = (float32x4_t)xmmword_1B6629CC0;
    }
    else
    {
      v63 = vadd_f32(v61, (float32x2_t)vdup_lane_s32((int32x2_t)v61, 1)).u32[0];
      v64 = vrsqrte_f32((float32x2_t)v63);
      v65 = vmul_f32(v64, vrsqrts_f32((float32x2_t)v63, vmul_f32(v64, v64)));
      v62 = vmulq_n_f32(v59, vmul_f32(v65, vrsqrts_f32((float32x2_t)v63, vmul_f32(v65, v65))).f32[0]);
    }
    v66 = vmulq_f32(v62, (float32x4_t)xmmword_1B66A07B0);
    v67 = (int8x16_t)vmulq_f32(v62, v62);
    *(float32x2_t *)v67.i8 = vadd_f32(*(float32x2_t *)v67.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v67, v67, 8uLL));
    v67.i32[0] = vadd_f32(*(float32x2_t *)v67.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v67.i8, 1)).u32[0];
    v68 = vrecpe_f32((float32x2_t)v67.u32[0]);
    v69 = vmul_f32(v68, vrecps_f32((float32x2_t)v67.u32[0], v68));
    *(float32x4_t *)this[64].f32 = vmulq_n_f32(v66, vmul_f32(v69, vrecps_f32((float32x2_t)v67.u32[0], v69)).f32[0]);
    ++this[130].i32[0];
  }
  v70 = atomic_load((unsigned __int8 *)&this[128] + 3);
  if ((v70 & 1) != 0 || a3)
  {
    atomic_store(0, (unsigned __int8 *)&this[128] + 3);
    __dmb(0xBu);
    v71 = atomic_load((unsigned int *)(*(_QWORD *)&this[56] + 96));
    if (v71 - 5 <= 0xFFFFFFFB)
    {
      v71 = this[67].u32[0];
      v72 = v71 == 3 ? 4 : 2;
      if (this[67].i8[4])
        v71 = v72;
    }
    if (v71 == 4)
    {
      v71 = 3;
    }
    else
    {
      if (v71 != 2)
      {
        v75 = 0;
        v74 = 0;
        goto LABEL_84;
      }
      v71 = 1;
    }
    v73 = atomic_load((unsigned __int8 *)(*(_QWORD *)&this[56] + 2508));
    v74 = v73 & 1;
    v75 = 1;
LABEL_84:
    if (v71 != this[67].i32[0] || this[67].u8[4] != v75 || this[67].u8[5] != v74)
    {
      this[67].i8[4] = v75;
      this[67].i8[5] = v74;
      this[67].i32[0] = v71;
      ++this[131].i32[0];
    }
  }
  v76 = atomic_load((unsigned __int8 *)&this[128] + 5);
  if ((v76 & 1) != 0 || a3)
  {
    atomic_store(0, (unsigned __int8 *)&this[128] + 5);
    __dmb(0xBu);
    if ((AUSM::SoundStage::incrementSoundStageVerticesAndGains(this + 72, 1u) & 1) != 0)
      this[131].i8[4] = 1;
    else
      atomic_store(1u, (unsigned __int8 *)&this[128] + 5);
    v77 = COERCE_FLOAT(atomic_load((unsigned int *)(*(_QWORD *)&this[56] + 1264)));
    this[66].f32[0] = __exp10f(v77 / 20.0);
    v78 = COERCE_FLOAT(atomic_load((unsigned int *)(*(_QWORD *)&this[56] + 1268)));
    this[66].f32[1] = __exp10f(v78 / 20.0);
    ++this[130].i32[1];
  }
}

void VoiceProcessorV2::SetupUplinkBasicAUChainForHwHasVP(VoiceProcessorV2 *this)
{
  uint64_t v2;
  VoiceProcessorV2 *ChatFlavor;
  uint64_t v4;
  char *v5;
  int v6;

  v5 = (char *)this + 4656;
  v6 = 0;
  std::__fill_n[abi:ne180100]<false,std::__bitset<2ul,71ul>>((uint64_t)&v5);
  *((_QWORD *)this + 582) |= 0x4000000000000000uLL;
  v2 = *((_QWORD *)this + 583);
  *((_QWORD *)this + 583) = v2 | 0x10;
  if (*((_BYTE *)this + 16596) && !*((_BYTE *)this + 2246))
  {
    v4 = v2 | 0x50;
    goto LABEL_9;
  }
  ChatFlavor = (VoiceProcessorV2 *)VoiceProcessorV2::GetChatFlavor(this);
  if ((_DWORD)ChatFlavor == 2 && (*((_BYTE *)this + 16544) & 4) != 0)
  {
    *((_QWORD *)this + 582) |= 0x800000000000000uLL;
    if (*((_BYTE *)this + 2246))
    {
      if (VoiceProcessorV2::IsDeviceSupportingAdvancedChatFlavors(ChatFlavor))
      {
        v4 = *((_QWORD *)this + 583) | 4;
LABEL_9:
        *((_QWORD *)this + 583) = v4;
      }
    }
  }
}

void VoiceProcessorV2::SetupUplinkDNNVADGraph(VoiceProcessorV2 *this)
{
  char *v2;
  char *v3;
  char *v4;
  _QWORD *v5;
  NSObject *v6;
  std::__fs::filesystem::path *v7;
  int *v8;
  std::__fs::filesystem::path *v9;
  _QWORD *v10;
  NSObject *v11;
  std::__fs::filesystem::path *v12;
  int *v13;
  std::__fs::filesystem::path *v14;
  std::__fs::filesystem::path *p_replacement;
  CFIndex size;
  CFStringRef v17;
  const void *v18;
  std::__fs::filesystem::path *v19;
  __int128 v20;
  std::string *v21;
  CFIndex v22;
  CFStringRef v23;
  const void *v24;
  _QWORD *v25;
  NSObject *v26;
  std::__fs::filesystem::path *v27;
  int *v28;
  std::__fs::filesystem::path *v29;
  _QWORD *v30;
  NSObject *v31;
  std::__fs::filesystem::path *v32;
  int *v33;
  std::__fs::filesystem::path *v34;
  const void *v35;
  _QWORD *v36;
  NSObject *v37;
  std::__fs::filesystem::path *v38;
  int *v39;
  std::__fs::filesystem::path *v40;
  _QWORD *v41;
  NSObject *v42;
  std::__fs::filesystem::path *v43;
  int *v44;
  std::__fs::filesystem::path *v45;
  const void *v46;
  _QWORD *v47;
  NSObject *v48;
  int *v49;
  std::runtime_error *v50;
  std::runtime_error *exception;
  std::string v52;
  unsigned __int8 v53;
  std::__fs::filesystem::path __replacement;
  std::__fs::filesystem::path v55;
  std::__fs::filesystem::path __p[17];
  _QWORD v57[21];

  v57[20] = *MEMORY[0x1E0C80C00];
  v2 = (char *)this + 15897;
  if ((_os_feature_enabled_impl() & 1) != 0 || *((_BYTE *)this + 2244) || v2[663])
  {
    *((_QWORD *)this + 582) &= ~0x2000000000000000uLL;
    v3 = (char *)this + 8;
    v4 = (char *)this + 8;
    if (*((char *)this + 31) < 0)
      v4 = *(char **)v3;
    __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v4;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v55.__pn_, &__p[0].__pn_.__r_.__value_.__l.__data_);
    std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v55.__pn_, "Generic");
    VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v55.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    if (std::__fs::filesystem::path::__filename(&v55).__size_)
      std::string::push_back(&v55.__pn_, 47);
    std::string::append[abi:ne180100]<char const*,0>(&v55.__pn_, "nnvad.dspg", "");
    std::__fs::filesystem::__status(&v55, 0);
    if (v53 && v53 != 255)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v10 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
      {
        v11 = (*v10 ? *v10 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          v12 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v12 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 51;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v12;
          _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading DNN VAD graph \"%s\"", (uint8_t *)__p, 0x1Cu);
        }
      }
      v13 = (int *)*((_QWORD *)this + 1570);
      if (v13 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v14 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v14 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        CALegacyLog::log(v13, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 51, "SetupUplinkDNNVADGraph", "loading DNN VAD graph \"%s\"", (const char *)v14);
      }
      std::ifstream::basic_ifstream(__p);
      std::string::__init_with_sentinel[abi:ne180100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(&__replacement.__pn_, *(_QWORD **)((char *)&__p[1].__pn_.__r_.__value_.__r.__words[2]+ *(_QWORD *)(__p[0].__pn_.__r_.__value_.__r.__words[0] - 24)));
      if ((__replacement.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_replacement = &__replacement;
      else
        p_replacement = (std::__fs::filesystem::path *)__replacement.__pn_.__r_.__value_.__r.__words[0];
      if ((__replacement.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]);
      else
        size = __replacement.__pn_.__r_.__value_.__l.__size_;
      v17 = CFStringCreateWithBytes(0, (const UInt8 *)p_replacement, size, 0x8000100u, 0);
      if (!v17)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      v18 = (const void *)*((_QWORD *)this + 2057);
      *((_QWORD *)this + 2057) = v17;
      if (v18)
        CFRelease(v18);
      if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
      __p[0].__pn_.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0DE4F40];
      *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words
                                + *(_QWORD *)(__p[0].__pn_.__r_.__value_.__r.__words[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 24);
      MEMORY[0x1BCC95788](&__p[0].__pn_.__r_.__value_.__r.__words[2]);
      std::istream::~istream();
      MEMORY[0x1BCC95BE4](v57);
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v5 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v6 = (*v5 ? *v5 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          v7 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v7 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 56;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v7;
          _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
        }
      }
      v8 = (int *)*((_QWORD *)this + 1570);
      if (v8 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v9 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v9 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        CALegacyLog::log(v8, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 56, "SetupUplinkDNNVADGraph", "file \"%s\" does not exist", (const char *)v9);
      }
    }
    if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v55.__pn_.__r_.__value_.__l.__data_);
    VoiceProcessorV2::GetDNNVADAUStripFilePath(&v55.__pn_, (uint64_t)this);
    std::__fs::filesystem::path::filename[abi:ne180100](&v55, (uint64_t)__p);
    memset(&__replacement, 0, sizeof(__replacement));
    v19 = std::__fs::filesystem::path::replace_extension(__p, &__replacement);
    if (SHIBYTE(v19->__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v52, v19->__pn_.__r_.__value_.__l.__data_, v19->__pn_.__r_.__value_.__l.__size_);
    }
    else
    {
      v20 = *(_OWORD *)&v19->__pn_.__r_.__value_.__l.__data_;
      v52.__r_.__value_.__r.__words[2] = v19->__pn_.__r_.__value_.__r.__words[2];
      *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v20;
    }
    if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v55.__pn_.__r_.__value_.__l.__data_);
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v21 = &v52;
    else
      v21 = (std::string *)v52.__r_.__value_.__r.__words[0];
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v22 = HIBYTE(v52.__r_.__value_.__r.__words[2]);
    else
      v22 = v52.__r_.__value_.__l.__size_;
    v23 = CFStringCreateWithBytes(0, (const UInt8 *)v21, v22, 0x8000100u, 0);
    if (!v23)
    {
      v50 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v50, "Could not construct");
    }
    v24 = (const void *)*((_QWORD *)this + 2058);
    *((_QWORD *)this + 2058) = v23;
    if (v24)
      CFRelease(v24);
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v52.__r_.__value_.__l.__data_);
    VoiceProcessorV2::GetDNNVADAUStripFilePath(&v55.__pn_, (uint64_t)this);
    std::__fs::filesystem::__status(&v55, 0);
    if (v52.__r_.__value_.__s.__data_[0] && v52.__r_.__value_.__s.__data_[0] != 255)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v30 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
      {
        v31 = (*v30 ? *v30 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
        {
          v32 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v32 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 74;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v32;
          _os_log_impl(&dword_1B5ED0000, v31, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading DNN VAD AU strip \"%s\"", (uint8_t *)__p, 0x1Cu);
        }
      }
      v33 = (int *)*((_QWORD *)this + 1570);
      if (v33 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v34 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v34 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        CALegacyLog::log(v33, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 74, "SetupUplinkDNNVADGraph", "loading DNN VAD AU strip \"%s\"", (const char *)v34);
      }
      if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&__p[0].__pn_, v55.__pn_.__r_.__value_.__l.__data_, v55.__pn_.__r_.__value_.__l.__size_);
      else
        __p[0] = v55;
      applesauce::CF::make_DataRef((const char *)__p, (CFDataRef *)&__replacement);
      if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
      applesauce::CF::make_DictionaryRef((CFDataRef *)&__replacement, (applesauce::CF::DictionaryRef *)__p);
      v35 = (const void *)*((_QWORD *)this + 2059);
      *((_QWORD *)this + 2059) = __p[0].__pn_.__r_.__value_.__r.__words[0];
      __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
      if (v35)
        CFRelease(v35);
      if (__replacement.__pn_.__r_.__value_.__r.__words[0])
        CFRelease(__replacement.__pn_.__r_.__value_.__l.__data_);
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v25 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v26 = (*v25 ? *v25 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          v27 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v27 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 79;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v27;
          _os_log_impl(&dword_1B5ED0000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
        }
      }
      v28 = (int *)*((_QWORD *)this + 1570);
      if (v28 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v29 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v29 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        CALegacyLog::log(v28, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 79, "SetupUplinkDNNVADGraph", "file \"%s\" does not exist", (const char *)v29);
      }
    }
    if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v55.__pn_.__r_.__value_.__l.__data_);
    if (*((char *)this + 31) < 0)
      v3 = *(char **)v3;
    __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v3;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v55.__pn_, &__p[0].__pn_.__r_.__value_.__l.__data_);
    std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v55.__pn_, "Generic");
    VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v55.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    if (std::__fs::filesystem::path::__filename(&v55).__size_)
      std::string::push_back(&v55.__pn_, 47);
    std::string::append[abi:ne180100]<char const*,0>(&v55.__pn_, "nnvad.propstrip", "");
    std::__fs::filesystem::__status(&v55, 0);
    if (__replacement.__pn_.__r_.__value_.__s.__data_[0]
      && __replacement.__pn_.__r_.__value_.__s.__data_[0] != 255)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v41 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
      {
        v42 = (*v41 ? *v41 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
        {
          v43 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v43 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 89;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v43;
          _os_log_impl(&dword_1B5ED0000, v42, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading DNN VAD property strip \"%s\"", (uint8_t *)__p, 0x1Cu);
        }
      }
      v44 = (int *)*((_QWORD *)this + 1570);
      if (v44 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v45 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v45 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        CALegacyLog::log(v44, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 89, "SetupUplinkDNNVADGraph", "loading DNN VAD property strip \"%s\"", (const char *)v45);
      }
      if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&__p[0].__pn_, v55.__pn_.__r_.__value_.__l.__data_, v55.__pn_.__r_.__value_.__l.__size_);
      else
        __p[0] = v55;
      applesauce::CF::make_DataRef((const char *)__p, (CFDataRef *)&__replacement);
      if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
      applesauce::CF::make_DictionaryRef((CFDataRef *)&__replacement, (applesauce::CF::DictionaryRef *)__p);
      v46 = (const void *)*((_QWORD *)this + 2060);
      *((_QWORD *)this + 2060) = __p[0].__pn_.__r_.__value_.__r.__words[0];
      __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v46;
      if (v46)
        CFRelease(v46);
      if (__replacement.__pn_.__r_.__value_.__r.__words[0])
        CFRelease(__replacement.__pn_.__r_.__value_.__l.__data_);
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v36 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v37 = (*v36 ? *v36 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          v38 = &v55;
          if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v38 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 94;
          WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v38;
          _os_log_impl(&dword_1B5ED0000, v37, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
        }
      }
      v39 = (int *)*((_QWORD *)this + 1570);
      if (v39 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v40 = &v55;
        if ((v55.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v40 = (std::__fs::filesystem::path *)v55.__pn_.__r_.__value_.__r.__words[0];
        CALegacyLog::log(v39, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 94, "SetupUplinkDNNVADGraph", "file \"%s\" does not exist", (const char *)v40);
      }
    }
    if (SHIBYTE(v55.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v55.__pn_.__r_.__value_.__l.__data_);
    if (*((_QWORD *)this + 2057) && *((_QWORD *)this + 2058) && *((_QWORD *)this + 2059) && *((_QWORD *)this + 2060))
    {
      *((_QWORD *)this + 582) |= 0x2000000000000000uLL;
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v47 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v48 = (*v47 ? *v47 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
          WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 107;
          _os_log_impl(&dword_1B5ED0000, v48, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Not able to enable DNNVAD", (uint8_t *)__p, 0x12u);
        }
      }
      v49 = (int *)*((_QWORD *)this + 1570);
      if (v49 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v49, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 107, "SetupUplinkDNNVADGraph", "Not able to enable DNNVAD");
      }
    }
  }
}

#error "1B615FC64: call analysis failed (funcsize=144)"

uint64_t std::string::__init_with_sentinel[abi:ne180100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(std::string *a1, _QWORD *a2)
{
  uint64_t result;
  std::string::value_type *v4;
  std::string::value_type v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;

  v7 = 0;
  v8 = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  while (1)
  {
    result = std::istreambuf_iterator<char>::equal[abi:ne180100](&v8, &v7);
    if ((result & 1) != 0)
      break;
    v4 = (std::string::value_type *)v8[3];
    if (v4 == (std::string::value_type *)v8[4])
      v5 = (*(uint64_t (**)(_QWORD *))(*v8 + 72))(v8);
    else
      v5 = *v4;
    std::string::push_back(a1, v5);
    v6 = v8[3];
    if (v6 == v8[4])
      (*(void (**)(_QWORD *))(*v8 + 80))(v8);
    else
      v8[3] = v6 + 1;
  }
  return result;
}

void sub_1B61603C4(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  __cxa_rethrow();
}

void sub_1B61603E0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *std::ifstream::~ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F40];
  v3 = *MEMORY[0x1E0DE4F40];
  *a1 = *MEMORY[0x1E0DE4F40];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x1BCC95788](a1 + 2);
  std::istream::~istream();
  MEMORY[0x1BCC95BE4](a1 + 53);
  return a1;
}

void VoiceProcessorV2::SetupReferenceSignalMixer(VoiceProcessorV2 *this)
{
  char *v2;
  char *v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  _QWORD *v7;
  NSObject *v8;
  int *v9;
  _QWORD *v10;
  NSObject *v11;
  int *v12;
  unsigned int v13;
  char v14;
  char v15;
  unsigned int v16;
  void **v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  _DWORD v21[6];
  _QWORD v22[5];

  v22[4] = *MEMORY[0x1E0C80C00];
  v2 = (char *)this + 15897;
  v3 = (char *)this + 2000;
  std::__optional_destruct_base<vp::utility::Audio_Buffer_Mixer,false>::reset[abi:ne180100]((uint64_t)this + 2000);
  v4 = *((_DWORD *)this + 153);
  if (v4)
  {
    v5 = *((_DWORD *)this + 123);
    if (v5)
    {
      if (**((_DWORD **)this + 292) == 1886613611)
      {
        if (*((_BYTE *)this + 2244) || *((_BYTE *)this + 2245))
        {
          v6 = *((_DWORD *)this + 18);
          if ((v6 - 22) < 8 || (v6 - 34) <= 2)
          {
            vp::utility::Audio_Buffer_Mixer::Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)buf, v4, *((_DWORD *)this + 153), v5);
            std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>((uint64_t)v3, (uint64_t)buf);
            v17 = (void **)v22;
            std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v17);
            v17 = (void **)((char *)v21 + 2);
            std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v17);
            (*(void (**)(VoiceProcessorV2 *, char *, char *))(*(_QWORD *)this + 464))(this, v3, (char *)this + 2072);
          }
        }
        else if ((*((_DWORD *)this + 18) - 26) <= 3)
        {
          vp::utility::Audio_Buffer_Mixer::Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)buf, v4, *((_DWORD *)this + 153), v5);
          v13 = 0;
          v14 = 1;
          do
          {
            v15 = v14;
            vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, v13, 0, 1.0);
            v14 = 0;
            v13 = 1;
          }
          while ((v15 & 1) != 0);
          if (*((_DWORD *)this + 153) >= 2u)
          {
            v16 = 1;
            do
            {
              vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, v16, v16, 1.0);
              ++v16;
            }
            while (v16 < *((_DWORD *)this + 153));
          }
          std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>((uint64_t)v3, (uint64_t)buf);
          vp::utility::Audio_Buffer_Mixer::~Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)buf);
        }
      }
      else if (*((_DWORD *)this + 596) == 1781740087 && v4 >= 6)
      {
        vp::utility::Audio_Buffer_Mixer::Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)buf, v4, *((_DWORD *)this + 153), v5);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 0, 0, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 2u, 0, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 3u, 0, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 5u, 0, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 0, 1u, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 2u, 1u, 1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 3u, 1u, -1.0);
        vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)buf, 5u, 1u, -1.0);
        std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>((uint64_t)v3, (uint64_t)buf);
        v17 = (void **)v22;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v17);
        v17 = (void **)((char *)v21 + 2);
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v17);
      }
    }
    else
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v10 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v11 = (*v10 ? *v10 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v19 = "vpSetupUplinkDSPChain.cpp";
          v20 = 1024;
          v21[0] = 137;
          _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> skip reference mixer setup because reference block size is 0", buf, 0x12u);
        }
      }
      v12 = (int *)*((_QWORD *)this + 1570);
      if (v12 && (*v2 || v2[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v12, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 137, "SetupReferenceSignalMixer", "skip reference mixer setup because reference block size is 0");
      }
    }
  }
  else
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v7 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v8 = (*v7 ? *v7 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v19 = "vpSetupUplinkDSPChain.cpp";
        v20 = 1024;
        v21[0] = 130;
        _os_log_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> skip reference mixer setup because reference channel count is 0", buf, 0x12u);
      }
    }
    v9 = (int *)*((_QWORD *)this + 1570);
    if (v9 && (*v2 || v2[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      CALegacyLog::log(v9, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 130, "SetupReferenceSignalMixer", "skip reference mixer setup because reference channel count is 0");
    }
  }
}

#error "1B6160A80: call analysis failed (funcsize=141)"

void std::__optional_destruct_base<vp::utility::Audio_Buffer_Mixer,false>::reset[abi:ne180100](uint64_t a1)
{
  void **v2;

  if (*(_BYTE *)(a1 + 64))
  {
    v2 = (void **)(a1 + 40);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
    v2 = (void **)(a1 + 16);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
    *(_BYTE *)(a1 + 64) = 0;
  }
}

uint64_t std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t *v6;
  _QWORD *v7;
  _QWORD *v8;

  v4 = *(unsigned __int8 *)(a1 + 64);
  v5 = *(_DWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 8) = v5;
  v6 = (uint64_t *)(a1 + 16);
  v7 = (_QWORD *)(a2 + 16);
  v8 = (_QWORD *)(a2 + 40);
  if (v4)
  {
    std::vector<std::vector<float>>::__vdeallocate(v6);
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    std::vector<std::vector<float>>::__vdeallocate((uint64_t *)(a1 + 40));
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
  }
  else
  {
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
    *v7 = 0;
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
    *v8 = 0;
    *(_QWORD *)(a2 + 48) = 0;
    *(_QWORD *)(a2 + 56) = 0;
    *(_BYTE *)(a1 + 64) = 1;
  }
  return a1;
}

void vp::utility::Audio_Buffer_Mixer::~Audio_Buffer_Mixer(vp::utility::Audio_Buffer_Mixer *this)
{
  void **v2;

  v2 = (void **)((char *)this + 40);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)((char *)this + 16);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void VoiceProcessorV2::SetupReferenceSignalMixer(void)::$_0::operator()(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int i;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  void **v10;

  v2 = a1 + 2000;
  std::__optional_destruct_base<vp::utility::Audio_Buffer_Mixer,false>::reset[abi:ne180100](a1 + 2000);
  vp::utility::Audio_Buffer_Mixer::Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)&v6, *(_DWORD *)(a1 + 612), *(_DWORD *)(a1 + 612), *(_DWORD *)(a1 + 492));
  v3 = v6;
  if (v7 < v6)
    v3 = v7;
  if (v3)
  {
    for (i = 0; i < v5; ++i)
    {
      vp::utility::Audio_Buffer_Mixer::set_gain((vp::utility::Audio_Buffer_Mixer *)&v6, i, i, 1.0);
      v5 = v6;
      if (v7 < v6)
        v5 = v7;
    }
  }
  std::optional<vp::utility::Audio_Buffer_Mixer>::operator=[abi:ne180100]<vp::utility::Audio_Buffer_Mixer,void>(v2, (uint64_t)&v6);
  v10 = (void **)&v9;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v10);
  v10 = (void **)&v8;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v10);
}

void sub_1B6160E38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  vp::utility::Audio_Buffer_Mixer::~Audio_Buffer_Mixer((vp::utility::Audio_Buffer_Mixer *)va);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::UpdateReferenceSignalMixerGains(uint64_t a1, vp::utility::Audio_Buffer_Mixer *this, uint64_t a3)
{
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int i;
  unsigned int v22;
  unsigned int j;
  unsigned int v24;

  if (**(_DWORD **)(a1 + 2336) == 1886613611)
  {
    if (*(_WORD *)(a1 + 2244))
    {
      v5 = *(_DWORD *)(a1 + 72);
      if (v5 <= 0x24)
      {
        if (((1 << v5) & 0x3FC00000) != 0)
        {
          v6 = *(_DWORD *)(a1 + 2304);
          v7 = v6 - 1;
          v8 = *(unsigned __int8 *)(a3 + 4);
          v9 = *(_DWORD *)a3;
          vp::utility::Audio_Buffer_Mixer::reset_gains(this);
          v10 = *(_DWORD *)this;
          v11 = *((_DWORD *)this + 1);
          if (*(_DWORD *)this < 8u || v11 <= 1)
          {
            if (v11 < v10)
              v10 = *((_DWORD *)this + 1);
            if (v10)
            {
              for (i = 0; i < v22; ++i)
              {
                vp::utility::Audio_Buffer_Mixer::set_gain(this, i, i, 1.0);
                v22 = *(_DWORD *)this;
                if (*((_DWORD *)this + 1) < *(_DWORD *)this)
                  v22 = *((_DWORD *)this + 1);
              }
            }
          }
          else
          {
            if (v8)
              v12 = v9;
            else
              v12 = 1;
            if (v7 < 4)
              v12 = v6;
            v13 = v12 - 1;
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 2u, 0, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 3u, 0, 1.0);
            v14 = v13 >= 2;
            if (v13 >= 2)
              v15 = 0;
            else
              v15 = 6;
            if (v13 >= 2)
              v16 = 1;
            else
              v16 = 7;
            if (v14)
              v17 = 6;
            else
              v17 = 0;
            if (v14)
              v18 = 7;
            else
              v18 = 1;
            vp::utility::Audio_Buffer_Mixer::set_gain(this, v15, 0, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, v16, 0, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, v17, 1u, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, v18, 1u, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 4u, 1u, 1.0);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 5u, 1u, 1.0);
          }
          if (v7 <= 3)
          {
            *(_DWORD *)a3 = v6;
            *(_BYTE *)(a3 + 4) = 1;
          }
        }
        else if (((1 << v5) & 0x1C00000100) != 0)
        {
          vp::utility::Audio_Buffer_Mixer::reset_gains(this);
          v19 = *(_DWORD *)this;
          v20 = *((_DWORD *)this + 1);
          if (*(_DWORD *)this < 4u || v20 <= 1)
          {
            if (v20 < v19)
              v19 = *((_DWORD *)this + 1);
            if (v19)
            {
              for (j = 0; j < v24; ++j)
              {
                vp::utility::Audio_Buffer_Mixer::set_gain(this, j, j, 1.0);
                v24 = *(_DWORD *)this;
                if (*((_DWORD *)this + 1) < *(_DWORD *)this)
                  v24 = *((_DWORD *)this + 1);
              }
            }
          }
          else
          {
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 0, 0, 0.5);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 1u, 0, 0.5);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 2u, 1u, 0.5);
            vp::utility::Audio_Buffer_Mixer::set_gain(this, 3u, 1u, 0.5);
          }
        }
      }
    }
  }
}

void VoiceProcessorV2::SetupUplinkEchoProcessingGraph(VoiceProcessorV2 *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  _QWORD *v6;
  std::string *v7;
  std::string::size_type v8;
  char v9;
  _BYTE *v10;
  _QWORD *v11;
  NSObject *v12;
  std::__fs::filesystem::path *v13;
  int *v14;
  std::__fs::filesystem::path *v15;
  _QWORD *v16;
  NSObject *v17;
  std::__fs::filesystem::path *v18;
  int *v19;
  std::__fs::filesystem::path *v20;
  std::string *v21;
  CFIndex size;
  CFStringRef v23;
  const void *v24;
  std::__fs::filesystem::path *v25;
  __int128 v26;
  std::string *v27;
  CFIndex v28;
  CFStringRef v29;
  const void *v30;
  double v31;
  const char *v32;
  char *v33;
  std::string *v34;
  __int128 v35;
  std::string *v36;
  __int128 v37;
  _QWORD *v38;
  std::string *v39;
  std::string::size_type v40;
  char v41;
  _QWORD *v42;
  NSObject *v43;
  std::__fs::filesystem::path *v44;
  int *v45;
  std::__fs::filesystem::path *v46;
  _QWORD *v47;
  NSObject *v48;
  std::__fs::filesystem::path *v49;
  int *v50;
  std::__fs::filesystem::path *v51;
  const void *v52;
  double v53;
  const char *v54;
  char *v55;
  std::string *v56;
  __int128 v57;
  std::string *v58;
  __int128 v59;
  _QWORD *v60;
  std::string *v61;
  std::string::size_type v62;
  char v63;
  _QWORD *v64;
  NSObject *v65;
  std::__fs::filesystem::path *v66;
  int *v67;
  std::__fs::filesystem::path *v68;
  _QWORD *v69;
  NSObject *v70;
  std::__fs::filesystem::path *v71;
  int *v72;
  std::__fs::filesystem::path *v73;
  const void *v74;
  _QWORD *v75;
  CFDictionaryRef CFDictionaryRef;
  const void *v77;
  uint64_t i;
  const void *v79;
  const void *v80;
  std::runtime_error *exception;
  std::runtime_error *v82;
  unsigned __int8 v83;
  unsigned __int8 v84;
  std::__fs::filesystem::path v85;
  std::string __p;
  std::__fs::filesystem::path v87;
  std::string pn;
  std::string v89;
  std::__fs::filesystem::path v90;
  std::string v91;
  std::string v92;
  std::__fs::filesystem::path v93;
  std::__fs::filesystem::path buf[17];
  uint64_t v95;
  _QWORD v96[5];

  v96[2] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 582) &= ~0x8000000uLL;
  v2 = (const void *)*((_QWORD *)this + 2061);
  *((_QWORD *)this + 2061) = 0;
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 2062);
  *((_QWORD *)this + 2062) = 0;
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 2063);
  *((_QWORD *)this + 2063) = 0;
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 2064);
  *((_QWORD *)this + 2064) = 0;
  if (v5)
    CFRelease(v5);
  if (*((_BYTE *)this + 60))
  {
    v6 = (_QWORD *)((char *)this + 8);
    if (*((char *)this + 31) < 0)
      v6 = (_QWORD *)*v6;
    buf[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v6;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v91, &buf[0].__pn_.__r_.__value_.__l.__data_);
    if (!*((_BYTE *)this + 60))
      std::__throw_bad_optional_access[abi:ne180100]();
    std::to_string(&v89, *((_DWORD *)this + 14));
    v7 = std::string::insert(&v89, 0, "AID", 3uLL);
    v8 = v7->__r_.__value_.__r.__words[0];
    v93.__pn_.__r_.__value_.__r.__words[0] = v7->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v93.__pn_.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v7->__r_.__value_.__r.__words[1] + 7);
    v9 = HIBYTE(v7->__r_.__value_.__r.__words[2]);
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    *(std::string::size_type *)((char *)&v90.__pn_.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v93.__pn_.__r_.__value_.__r.__words + 7);
    v90.__pn_.__r_.__value_.__r.__words[0] = v8;
    v90.__pn_.__r_.__value_.__l.__size_ = v93.__pn_.__r_.__value_.__r.__words[0];
    *((_BYTE *)&v90.__pn_.__r_.__value_.__s + 23) = v9;
    v93.__pn_.__r_.__value_.__r.__words[0] = 0;
    *(std::string::size_type *)((char *)v93.__pn_.__r_.__value_.__r.__words + 7) = 0;
    std::__fs::filesystem::operator/[abi:ne180100](&v90, (uint64_t)&v91, (std::__fs::filesystem::path *)&v92);
    VoiceProcessorV2::GetVersionNameForTuning(&v87.__pn_, (uint64_t)this);
    pn = v87.__pn_;
    memset(&v87, 0, sizeof(v87));
    std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&pn, (uint64_t)&v92, buf);
    memset(&__p, 0, sizeof(__p));
    std::string::append[abi:ne180100]<char const*,0>(&__p, "echo_processing.dspg", "");
    std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&__p, (uint64_t)buf, &v85);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(pn.__r_.__value_.__r.__words[2]) < 0)
      operator delete(pn.__r_.__value_.__l.__data_);
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    if (SHIBYTE(v90.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v90.__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v89.__r_.__value_.__l.__data_);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
  }
  else
  {
    std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>(&v85.__pn_, "emptyAcousticID");
  }
  v10 = (char *)this + 15897;
  std::__fs::filesystem::__status(&v85, 0);
  if (v83 && v83 != 255)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v16 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      v17 = (*v16 ? *v16 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        v18 = &v85;
        if ((v85.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v18 = (std::__fs::filesystem::path *)v85.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 408;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v18;
        _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading echo processing graph \"%s\"", (uint8_t *)buf, 0x1Cu);
      }
    }
    v19 = (int *)*((_QWORD *)this + 1570);
    if (v19 && (*v10 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v20 = &v85;
      if ((v85.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v20 = (std::__fs::filesystem::path *)v85.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v19, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 408, "SetupUplinkEchoProcessingGraph", "loading echo processing graph \"%s\"", (const char *)v20);
    }
    std::ifstream::basic_ifstream(buf);
    std::string::__init_with_sentinel[abi:ne180100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(&v92, *(_QWORD **)((char *)&buf[1].__pn_.__r_.__value_.__r.__words[2]+ *(_QWORD *)(buf[0].__pn_.__r_.__value_.__r.__words[0] - 24)));
    if ((v92.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v21 = &v92;
    else
      v21 = (std::string *)v92.__r_.__value_.__r.__words[0];
    if ((v92.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v92.__r_.__value_.__r.__words[2]);
    else
      size = v92.__r_.__value_.__l.__size_;
    v23 = CFStringCreateWithBytes(0, (const UInt8 *)v21, size, 0x8000100u, 0);
    if (!v23)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    v24 = (const void *)*((_QWORD *)this + 2061);
    *((_QWORD *)this + 2061) = v23;
    if (v24)
      CFRelease(v24);
    std::__fs::filesystem::path::filename[abi:ne180100](&v85, (uint64_t)&v90);
    memset(&v89, 0, sizeof(v89));
    v25 = std::__fs::filesystem::path::replace_extension(&v90, (const std::__fs::filesystem::path *)&v89);
    if (SHIBYTE(v25->__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v91, v25->__pn_.__r_.__value_.__l.__data_, v25->__pn_.__r_.__value_.__l.__size_);
    }
    else
    {
      v26 = *(_OWORD *)&v25->__pn_.__r_.__value_.__l.__data_;
      v91.__r_.__value_.__r.__words[2] = v25->__pn_.__r_.__value_.__r.__words[2];
      *(_OWORD *)&v91.__r_.__value_.__l.__data_ = v26;
    }
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v89.__r_.__value_.__l.__data_);
    if (SHIBYTE(v90.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v90.__pn_.__r_.__value_.__l.__data_);
    if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v27 = &v91;
    else
      v27 = (std::string *)v91.__r_.__value_.__r.__words[0];
    if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v28 = HIBYTE(v91.__r_.__value_.__r.__words[2]);
    else
      v28 = v91.__r_.__value_.__l.__size_;
    v29 = CFStringCreateWithBytes(0, (const UInt8 *)v27, v28, 0x8000100u, 0);
    if (!v29)
    {
      v82 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v82, "Could not construct");
    }
    v30 = (const void *)*((_QWORD *)this + 2062);
    *((_QWORD *)this + 2062) = v29;
    if (v30)
      CFRelease(v30);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    buf[0].__pn_.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0DE4F40];
    *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words
                              + *(_QWORD *)(buf[0].__pn_.__r_.__value_.__r.__words[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 24);
    MEMORY[0x1BCC95788](&buf[0].__pn_.__r_.__value_.__r.__words[2]);
    std::istream::~istream();
    MEMORY[0x1BCC95BE4](&v95);
  }
  else
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v11 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v12 = (*v11 ? *v11 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = &v85;
        if ((v85.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v13 = (std::__fs::filesystem::path *)v85.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 419;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v13;
        _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)buf, 0x1Cu);
      }
    }
    v14 = (int *)*((_QWORD *)this + 1570);
    if (v14 && (*v10 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v15 = &v85;
      if ((v85.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v15 = (std::__fs::filesystem::path *)v85.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v14, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 419, "SetupUplinkEchoProcessingGraph", "file \"%s\" does not exist", (const char *)v15);
    }
  }
  if (SHIBYTE(v85.__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v85.__pn_.__r_.__value_.__l.__data_);
  if (*((_BYTE *)this + 60))
  {
    v31 = *((double *)this + 103);
    if (v31 == 16000.0)
      v32 = "16";
    else
      v32 = "24";
    if (v31 == 8000.0)
      v33 = "08";
    else
      v33 = (char *)v32;
    std::string::basic_string[abi:ne180100]<0>(&v91, v33);
    v34 = std::string::insert(&v91, 0, "echo_processing_", 0x10uLL);
    v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
    v92.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v35;
    v34->__r_.__value_.__l.__size_ = 0;
    v34->__r_.__value_.__r.__words[2] = 0;
    v34->__r_.__value_.__r.__words[0] = 0;
    v36 = std::string::append(&v92, "kHz.austrip", 0xBuLL);
    v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__pn_.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
    *(_OWORD *)&buf[0].__pn_.__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0;
    v36->__r_.__value_.__r.__words[2] = 0;
    v36->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
    v38 = (_QWORD *)((char *)this + 8);
    if (*((char *)this + 31) < 0)
      v38 = (_QWORD *)*v38;
    v92.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v90.__pn_, &v92.__r_.__value_.__l.__data_);
    if (!*((_BYTE *)this + 60))
      std::__throw_bad_optional_access[abi:ne180100]();
    std::to_string(&pn, *((_DWORD *)this + 14));
    v39 = std::string::insert(&pn, 0, "AID", 3uLL);
    v40 = v39->__r_.__value_.__r.__words[0];
    v96[0] = v39->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v96 + 7) = *(std::string::size_type *)((char *)&v39->__r_.__value_.__r.__words[1] + 7);
    v41 = HIBYTE(v39->__r_.__value_.__r.__words[2]);
    v39->__r_.__value_.__l.__size_ = 0;
    v39->__r_.__value_.__r.__words[2] = 0;
    v39->__r_.__value_.__r.__words[0] = 0;
    *(std::string::size_type *)((char *)&v89.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)((char *)v96 + 7);
    v89.__r_.__value_.__r.__words[0] = v40;
    v89.__r_.__value_.__l.__size_ = v96[0];
    *((_BYTE *)&v89.__r_.__value_.__s + 23) = v41;
    v96[0] = 0;
    *(_QWORD *)((char *)v96 + 7) = 0;
    std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&v89, (uint64_t)&v90, (std::__fs::filesystem::path *)&v91);
    VoiceProcessorV2::GetVersionNameForTuning(&__p, (uint64_t)this);
    v87.__pn_ = __p;
    memset(&__p, 0, sizeof(__p));
    std::__fs::filesystem::operator/[abi:ne180100](&v87, (uint64_t)&v91, (std::__fs::filesystem::path *)&v92);
    std::__fs::filesystem::path::path[abi:ne180100]<std::string,void>(&v85.__pn_, (char *)buf);
    std::__fs::filesystem::operator/[abi:ne180100](&v85, (uint64_t)&v92, &v93);
    if (SHIBYTE(v85.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v85.__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    if (SHIBYTE(v87.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v87.__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v89.__r_.__value_.__l.__data_);
    if (SHIBYTE(pn.__r_.__value_.__r.__words[2]) < 0)
      operator delete(pn.__r_.__value_.__l.__data_);
    if (SHIBYTE(v90.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v90.__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
  }
  else
  {
    std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>(&v93.__pn_, "emptyAcousticID");
  }
  std::__fs::filesystem::__status(&v93, 0);
  if (v84 && v84 != 255)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v47 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      v48 = (*v47 ? *v47 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
      {
        v49 = &v93;
        if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v49 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 437;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v49;
        _os_log_impl(&dword_1B5ED0000, v48, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading echo processing AU strip \"%s\"", (uint8_t *)buf, 0x1Cu);
      }
    }
    v50 = (int *)*((_QWORD *)this + 1570);
    if (v50 && (*v10 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v51 = &v93;
      if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v51 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v50, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 437, "SetupUplinkEchoProcessingGraph", "loading echo processing AU strip \"%s\"", (const char *)v51);
    }
    if (SHIBYTE(v93.__pn_.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&buf[0].__pn_, v93.__pn_.__r_.__value_.__l.__data_, v93.__pn_.__r_.__value_.__l.__size_);
    else
      buf[0] = v93;
    applesauce::CF::make_DataRef((const char *)buf, (CFDataRef *)&v92);
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
    applesauce::CF::make_DictionaryRef((CFDataRef *)&v92, (applesauce::CF::DictionaryRef *)buf);
    v52 = (const void *)*((_QWORD *)this + 2063);
    *((_QWORD *)this + 2063) = buf[0].__pn_.__r_.__value_.__r.__words[0];
    buf[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v52;
    if (v52)
      CFRelease(v52);
    if (v92.__r_.__value_.__r.__words[0])
      CFRelease(v92.__r_.__value_.__l.__data_);
  }
  else
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v42 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v43 = (*v42 ? *v42 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        v44 = &v93;
        if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v44 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 445;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v44;
        _os_log_impl(&dword_1B5ED0000, v43, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)buf, 0x1Cu);
      }
    }
    v45 = (int *)*((_QWORD *)this + 1570);
    if (v45 && (*v10 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v46 = &v93;
      if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v46 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v45, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 445, "SetupUplinkEchoProcessingGraph", "file \"%s\" does not exist", (const char *)v46);
    }
  }
  if (SHIBYTE(v93.__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v93.__pn_.__r_.__value_.__l.__data_);
  if (*((_BYTE *)this + 60))
  {
    v53 = *((double *)this + 103);
    if (v53 == 16000.0)
      v54 = "16";
    else
      v54 = "24";
    if (v53 == 8000.0)
      v55 = "08";
    else
      v55 = (char *)v54;
    std::string::basic_string[abi:ne180100]<0>(&v91, v55);
    v56 = std::string::insert(&v91, 0, "echo_processing_", 0x10uLL);
    v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v92.__r_.__value_.__r.__words[2] = v56->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0;
    v56->__r_.__value_.__r.__words[2] = 0;
    v56->__r_.__value_.__r.__words[0] = 0;
    v58 = std::string::append(&v92, "kHz.propstrip", 0xDuLL);
    v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    buf[0].__pn_.__r_.__value_.__r.__words[2] = v58->__r_.__value_.__r.__words[2];
    *(_OWORD *)&buf[0].__pn_.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
    v60 = (_QWORD *)((char *)this + 8);
    if (*((char *)this + 31) < 0)
      v60 = (_QWORD *)*v60;
    v92.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
    std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v90.__pn_, &v92.__r_.__value_.__l.__data_);
    if (!*((_BYTE *)this + 60))
      std::__throw_bad_optional_access[abi:ne180100]();
    std::to_string(&pn, *((_DWORD *)this + 14));
    v61 = std::string::insert(&pn, 0, "AID", 3uLL);
    v62 = v61->__r_.__value_.__r.__words[0];
    v96[0] = v61->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v96 + 7) = *(std::string::size_type *)((char *)&v61->__r_.__value_.__r.__words[1] + 7);
    v63 = HIBYTE(v61->__r_.__value_.__r.__words[2]);
    v61->__r_.__value_.__l.__size_ = 0;
    v61->__r_.__value_.__r.__words[2] = 0;
    v61->__r_.__value_.__r.__words[0] = 0;
    *(std::string::size_type *)((char *)&v89.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)((char *)v96 + 7);
    v89.__r_.__value_.__r.__words[0] = v62;
    v89.__r_.__value_.__l.__size_ = v96[0];
    *((_BYTE *)&v89.__r_.__value_.__s + 23) = v63;
    v96[0] = 0;
    *(_QWORD *)((char *)v96 + 7) = 0;
    std::__fs::filesystem::operator/[abi:ne180100]((std::__fs::filesystem::path *)&v89, (uint64_t)&v90, (std::__fs::filesystem::path *)&v91);
    VoiceProcessorV2::GetVersionNameForTuning(&__p, (uint64_t)this);
    v87.__pn_ = __p;
    memset(&__p, 0, sizeof(__p));
    std::__fs::filesystem::operator/[abi:ne180100](&v87, (uint64_t)&v91, (std::__fs::filesystem::path *)&v92);
    std::__fs::filesystem::path::path[abi:ne180100]<std::string,void>(&v85.__pn_, (char *)buf);
    std::__fs::filesystem::operator/[abi:ne180100](&v85, (uint64_t)&v92, &v93);
    if (SHIBYTE(v85.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v85.__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    if (SHIBYTE(v87.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v87.__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v89.__r_.__value_.__l.__data_);
    if (SHIBYTE(pn.__r_.__value_.__r.__words[2]) < 0)
      operator delete(pn.__r_.__value_.__l.__data_);
    if (SHIBYTE(v90.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v90.__pn_.__r_.__value_.__l.__data_);
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
  }
  else
  {
    std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>(&v93.__pn_, "emptyAcousticID");
  }
  std::__fs::filesystem::__status(&v93, 0);
  if (v92.__r_.__value_.__s.__data_[0] && v92.__r_.__value_.__s.__data_[0] != 255)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v69 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      v70 = (*v69 ? *v69 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v70, OS_LOG_TYPE_INFO))
      {
        v71 = &v93;
        if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v71 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 463;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v71;
        _os_log_impl(&dword_1B5ED0000, v70, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading echo processing property strip \"%s\"", (uint8_t *)buf, 0x1Cu);
      }
    }
    v72 = (int *)*((_QWORD *)this + 1570);
    if (v72 && (*v10 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v73 = &v93;
      if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v73 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v72, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 463, "SetupUplinkEchoProcessingGraph", "loading echo processing property strip \"%s\"", (const char *)v73);
    }
    if (SHIBYTE(v93.__pn_.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&buf[0].__pn_, v93.__pn_.__r_.__value_.__l.__data_, v93.__pn_.__r_.__value_.__l.__size_);
    else
      buf[0] = v93;
    applesauce::CF::make_DataRef((const char *)buf, (CFDataRef *)&v91);
    if (SHIBYTE(buf[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf[0].__pn_.__r_.__value_.__l.__data_);
    applesauce::CF::make_DictionaryRef((CFDataRef *)&v91, (applesauce::CF::DictionaryRef *)buf);
    v74 = (const void *)*((_QWORD *)this + 2064);
    *((_QWORD *)this + 2064) = buf[0].__pn_.__r_.__value_.__r.__words[0];
    buf[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
    if (v74)
      CFRelease(v74);
    LODWORD(v89.__r_.__value_.__l.__data_) = 1953850480;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[3],int>((applesauce::CF::TypeRef *)buf, "ID", (int *)&v89);
    v75 = (_QWORD *)((char *)this + 8);
    if (*((char *)this + 31) < 0)
      v75 = (_QWORD *)*v75;
    v90.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v75;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],char const*>((applesauce::CF::TypeRef *)&buf[0].__pn_.__r_.__value_.__r.__words[2], "cfobject", &v90.__pn_.__r_.__value_.__l.__data_);
    v92.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
    v92.__r_.__value_.__l.__size_ = 2;
    CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v92);
    v77 = (const void *)*((_QWORD *)this + 2065);
    *((_QWORD *)this + 2065) = CFDictionaryRef;
    if (v77)
      CFRelease(v77);
    for (i = 0; i != -4; i -= 2)
    {
      v79 = *(std::string::pointer *)((char *)&buf[1].__pn_.__r_.__value_.__l.__data_ + i * 8);
      if (v79)
        CFRelease(v79);
      v80 = (const void *)buf[0].__pn_.__r_.__value_.__r.__words[i + 2];
      if (v80)
        CFRelease(v80);
    }
    if (v91.__r_.__value_.__r.__words[0])
      CFRelease(v91.__r_.__value_.__l.__data_);
  }
  else
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v64 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v65 = (*v64 ? *v64 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        v66 = &v93;
        if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v66 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(buf[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(buf[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 472;
        WORD1(buf[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v66;
        _os_log_impl(&dword_1B5ED0000, v65, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)buf, 0x1Cu);
      }
    }
    v67 = (int *)*((_QWORD *)this + 1570);
    if (v67 && (*v10 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v68 = &v93;
      if ((v93.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v68 = (std::__fs::filesystem::path *)v93.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v67, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 472, "SetupUplinkEchoProcessingGraph", "file \"%s\" does not exist", (const char *)v68);
    }
  }
  if (SHIBYTE(v93.__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v93.__pn_.__r_.__value_.__l.__data_);
  if (*((_QWORD *)this + 2061) && *((_QWORD *)this + 2062) && *((_QWORD *)this + 2063))
  {
    if (*((_QWORD *)this + 2064))
      *((_QWORD *)this + 582) |= 0x8000000uLL;
  }
}

#error "1B6162790: call analysis failed (funcsize=140)"

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[3],int>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B6162EE4(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],char const*>(applesauce::CF::TypeRef *a1, char *a2, char **a3)
{
  applesauce::CF::TypeRef *v5;

  v5 = applesauce::CF::TypeRef::TypeRef(a1, a2);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)((char *)v5 + 8), *a3);
  return a1;
}

void sub_1B6162F54(_Unwind_Exception *a1)
{
  const void **v1;

  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

void VoiceProcessorV2::SetupUplinkAirPodsOffloadGraph(VoiceProcessorV2 *this)
{
  char *v2;
  char *v3;
  char *v4;
  _QWORD *v5;
  NSObject *v6;
  std::__fs::filesystem::path *v7;
  int *v8;
  std::__fs::filesystem::path *v9;
  _QWORD *v10;
  NSObject *v11;
  std::__fs::filesystem::path *v12;
  int *v13;
  std::__fs::filesystem::path *v14;
  std::__fs::filesystem::path *p_replacement;
  CFIndex size;
  CFStringRef v17;
  const void *v18;
  std::__fs::filesystem::path *v19;
  __int128 v20;
  std::string *v21;
  CFIndex v22;
  CFStringRef v23;
  const void *v24;
  _QWORD *v25;
  NSObject *v26;
  std::__fs::filesystem::path *v27;
  int *v28;
  std::__fs::filesystem::path *v29;
  _QWORD *v30;
  NSObject *v31;
  std::__fs::filesystem::path *v32;
  int *v33;
  std::__fs::filesystem::path *v34;
  const void *v35;
  char *v36;
  char *v37;
  _QWORD *v38;
  NSObject *v39;
  std::__fs::filesystem::path *v40;
  int *v41;
  std::__fs::filesystem::path *v42;
  _QWORD *v43;
  NSObject *v44;
  std::__fs::filesystem::path *v45;
  int *v46;
  std::__fs::filesystem::path *v47;
  const void *v48;
  _QWORD *v49;
  NSObject *v50;
  int *v51;
  std::runtime_error *v52;
  std::runtime_error *exception;
  std::string v54;
  unsigned __int8 v55;
  std::__fs::filesystem::path __replacement;
  std::__fs::filesystem::path v57;
  std::__fs::filesystem::path __p[17];
  _QWORD v59[21];

  v59[20] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 583) &= ~0x40uLL;
  v2 = (char *)this + 8;
  v3 = (char *)this + 8;
  if (*((char *)this + 31) < 0)
    v3 = *(char **)v2;
  __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v3;
  std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v57.__pn_, &__p[0].__pn_.__r_.__value_.__l.__data_);
  std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v57.__pn_, "Generic");
  VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
  std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v57.__pn_, (uint64_t)__p);
  if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
  if (std::__fs::filesystem::path::__filename(&v57).__size_)
    std::string::push_back(&v57.__pn_, 47);
  std::string::append[abi:ne180100]<char const*,0>(&v57.__pn_, "uplink_echo_airpods_offload.dspg", "");
  v4 = (char *)this + 15897;
  std::__fs::filesystem::__status(&v57, 0);
  if (v55 && v55 != 255)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v10 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      v11 = (*v10 ? *v10 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        v12 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v12 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 498;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v12;
        _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading offload AirPods DSP graph \"%s\"", (uint8_t *)__p, 0x1Cu);
      }
    }
    v13 = (int *)*((_QWORD *)this + 1570);
    if (v13 && (*v4 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v14 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v14 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v13, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 498, "SetupUplinkAirPodsOffloadGraph", "loading offload AirPods DSP graph \"%s\"", (const char *)v14);
    }
    std::ifstream::basic_ifstream(__p);
    std::string::__init_with_sentinel[abi:ne180100]<std::istreambuf_iterator<char>,std::istreambuf_iterator<char>>(&__replacement.__pn_, *(_QWORD **)((char *)&__p[1].__pn_.__r_.__value_.__r.__words[2]+ *(_QWORD *)(__p[0].__pn_.__r_.__value_.__r.__words[0] - 24)));
    if ((__replacement.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_replacement = &__replacement;
    else
      p_replacement = (std::__fs::filesystem::path *)__replacement.__pn_.__r_.__value_.__r.__words[0];
    if ((__replacement.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]);
    else
      size = __replacement.__pn_.__r_.__value_.__l.__size_;
    v17 = CFStringCreateWithBytes(0, (const UInt8 *)p_replacement, size, 0x8000100u, 0);
    if (!v17)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    v18 = (const void *)*((_QWORD *)this + 2081);
    *((_QWORD *)this + 2081) = v17;
    if (v18)
      CFRelease(v18);
    if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
    __p[0].__pn_.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0DE4F40];
    *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words
                              + *(_QWORD *)(__p[0].__pn_.__r_.__value_.__r.__words[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 24);
    MEMORY[0x1BCC95788](&__p[0].__pn_.__r_.__value_.__r.__words[2]);
    std::istream::~istream();
    MEMORY[0x1BCC95BE4](v59);
  }
  else
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v5 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v6 = (*v5 ? *v5 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v7 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v7 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 503;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v7;
        _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
      }
    }
    v8 = (int *)*((_QWORD *)this + 1570);
    if (v8 && (*v4 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v9 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v9 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v8, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 503, "SetupUplinkAirPodsOffloadGraph", "file \"%s\" does not exist", (const char *)v9);
    }
  }
  if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v57.__pn_.__r_.__value_.__l.__data_);
  VoiceProcessorV2::GetAirPodsOffloadAUStripFilePath(&v57.__pn_, (char *)this);
  std::__fs::filesystem::path::filename[abi:ne180100](&v57, (uint64_t)__p);
  memset(&__replacement, 0, sizeof(__replacement));
  v19 = std::__fs::filesystem::path::replace_extension(__p, &__replacement);
  if (SHIBYTE(v19->__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&v54, v19->__pn_.__r_.__value_.__l.__data_, v19->__pn_.__r_.__value_.__l.__size_);
  }
  else
  {
    v20 = *(_OWORD *)&v19->__pn_.__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v19->__pn_.__r_.__value_.__r.__words[2];
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v20;
  }
  if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
  if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v57.__pn_.__r_.__value_.__l.__data_);
  if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = &v54;
  else
    v21 = (std::string *)v54.__r_.__value_.__r.__words[0];
  if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v22 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
  else
    v22 = v54.__r_.__value_.__l.__size_;
  v23 = CFStringCreateWithBytes(0, (const UInt8 *)v21, v22, 0x8000100u, 0);
  if (!v23)
  {
    v52 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v52, "Could not construct");
  }
  v24 = (const void *)*((_QWORD *)this + 2082);
  *((_QWORD *)this + 2082) = v23;
  if (v24)
    CFRelease(v24);
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v54.__r_.__value_.__l.__data_);
  VoiceProcessorV2::GetAirPodsOffloadAUStripFilePath(&v57.__pn_, (char *)this);
  std::__fs::filesystem::__status(&v57, 0);
  if (v54.__r_.__value_.__s.__data_[0] && v54.__r_.__value_.__s.__data_[0] != 255)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v30 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      v31 = (*v30 ? *v30 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        v32 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v32 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 521;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v32;
        _os_log_impl(&dword_1B5ED0000, v31, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading offload AirPods DSP AU strip \"%s\"", (uint8_t *)__p, 0x1Cu);
      }
    }
    v33 = (int *)*((_QWORD *)this + 1570);
    if (v33 && (*v4 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v34 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v34 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v33, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 521, "SetupUplinkAirPodsOffloadGraph", "loading offload AirPods DSP AU strip \"%s\"", (const char *)v34);
    }
    if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&__p[0].__pn_, v57.__pn_.__r_.__value_.__l.__data_, v57.__pn_.__r_.__value_.__l.__size_);
    else
      __p[0] = v57;
    applesauce::CF::make_DataRef((const char *)__p, (CFDataRef *)&__replacement);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    applesauce::CF::make_DictionaryRef((CFDataRef *)&__replacement, (applesauce::CF::DictionaryRef *)__p);
    v35 = (const void *)*((_QWORD *)this + 2083);
    *((_QWORD *)this + 2083) = __p[0].__pn_.__r_.__value_.__r.__words[0];
    __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
    if (v35)
      CFRelease(v35);
    if (__replacement.__pn_.__r_.__value_.__r.__words[0])
      CFRelease(__replacement.__pn_.__r_.__value_.__l.__data_);
  }
  else
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v25 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v26 = (*v25 ? *v25 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v27 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v27 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 526;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v27;
        _os_log_impl(&dword_1B5ED0000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
      }
    }
    v28 = (int *)*((_QWORD *)this + 1570);
    if (v28 && (*v4 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v29 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v29 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v28, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 526, "SetupUplinkAirPodsOffloadGraph", "file \"%s\" does not exist", (const char *)v29);
    }
  }
  if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v57.__pn_.__r_.__value_.__l.__data_);
  if (*((char *)this + 31) < 0)
    v2 = *(char **)v2;
  __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v2;
  std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(&v57.__pn_, &__p[0].__pn_.__r_.__value_.__l.__data_);
  if (*((_DWORD *)this + 18) == 34)
  {
    VoiceProcessorV2::GetHardwareModelNameForTuning(&__p[0].__pn_, (uint64_t)this, 0);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v57.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v57.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    v36 = "uplink_echo_airpods_offload_espresso.propstrip";
    v37 = "";
    if (std::__fs::filesystem::path::__filename(&v57).__size_)
LABEL_144:
      std::string::push_back(&v57.__pn_, 47);
  }
  else
  {
    std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v57.__pn_, "Generic");
    VoiceProcessorV2::GetVersionNameForTuning(&__p[0].__pn_, (uint64_t)this);
    std::__fs::filesystem::path::append[abi:ne180100]<std::string>(&v57.__pn_, (uint64_t)__p);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    v36 = "uplink_echo_airpods_offload.propstrip";
    v37 = "";
    if (std::__fs::filesystem::path::__filename(&v57).__size_)
      goto LABEL_144;
  }
  std::string::append[abi:ne180100]<char const*,0>(&v57.__pn_, v36, v37);
  std::__fs::filesystem::__status(&v57, 0);
  if (__replacement.__pn_.__r_.__value_.__s.__data_[0]
    && __replacement.__pn_.__r_.__value_.__s.__data_[0] != 255)
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v43 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(4, VPLogScope(void)::scope, 0))
    {
      v44 = (*v43 ? *v43 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
      {
        v45 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v45 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 536;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v45;
        _os_log_impl(&dword_1B5ED0000, v44, OS_LOG_TYPE_INFO, "%25s:%-5d  <vp> loading offload AirPods DSP property strip \"%s\"", (uint8_t *)__p, 0x1Cu);
      }
    }
    v46 = (int *)*((_QWORD *)this + 1570);
    if (v46 && (*v4 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v47 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v47 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v46, 4, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 536, "SetupUplinkAirPodsOffloadGraph", "loading offload AirPods DSP property strip \"%s\"", (const char *)v47);
    }
    if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&__p[0].__pn_, v57.__pn_.__r_.__value_.__l.__data_, v57.__pn_.__r_.__value_.__l.__size_);
    else
      __p[0] = v57;
    applesauce::CF::make_DataRef((const char *)__p, (CFDataRef *)&__replacement);
    if (SHIBYTE(__p[0].__pn_.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__pn_.__r_.__value_.__l.__data_);
    applesauce::CF::make_DictionaryRef((CFDataRef *)&__replacement, (applesauce::CF::DictionaryRef *)__p);
    v48 = (const void *)*((_QWORD *)this + 2084);
    *((_QWORD *)this + 2084) = __p[0].__pn_.__r_.__value_.__r.__words[0];
    __p[0].__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)v48;
    if (v48)
      CFRelease(v48);
    if (__replacement.__pn_.__r_.__value_.__r.__words[0])
      CFRelease(__replacement.__pn_.__r_.__value_.__l.__data_);
  }
  else
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v38 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v39 = (*v38 ? *v38 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        v40 = &v57;
        if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v40 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 541;
        WORD1(__p[0].__pn_.__r_.__value_.__r.__words[2]) = 2080;
        *(std::string::size_type *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v40;
        _os_log_impl(&dword_1B5ED0000, v39, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file \"%s\" does not exist", (uint8_t *)__p, 0x1Cu);
      }
    }
    v41 = (int *)*((_QWORD *)this + 1570);
    if (v41 && (*v4 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v42 = &v57;
      if ((v57.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v42 = (std::__fs::filesystem::path *)v57.__pn_.__r_.__value_.__r.__words[0];
      CALegacyLog::log(v41, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 541, "SetupUplinkAirPodsOffloadGraph", "file \"%s\" does not exist", (const char *)v42);
    }
  }
  if (SHIBYTE(v57.__pn_.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v57.__pn_.__r_.__value_.__l.__data_);
  if (*((_QWORD *)this + 2081) && *((_QWORD *)this + 2082) && *((_QWORD *)this + 2083) && *((_QWORD *)this + 2084))
  {
    *((_QWORD *)this + 583) |= 0x40uLL;
  }
  else
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v49 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v50 = (*v49 ? *v49 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__p[0].__pn_.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)__p[0].__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)"vpSetupUplinkDSPChain.cpp";
        WORD2(__p[0].__pn_.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p[0].__pn_.__r_.__value_.__r.__words[1] + 6) = 554;
        _os_log_impl(&dword_1B5ED0000, v50, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Not able to enable offload AirPods DSP graph", (uint8_t *)__p, 0x12u);
      }
    }
    v51 = (int *)*((_QWORD *)this + 1570);
    if (v51 && (*v4 || v4[1]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      CALegacyLog::log(v51, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDSPChains/vpSetupUplinkDSPChain.cpp", 554, "SetupUplinkAirPodsOffloadGraph", "Not able to enable offload AirPods DSP graph");
    }
  }
}

#error "1B61643B4: call analysis failed (funcsize=144)"

void clsp::DisplacementController::~DisplacementController(clsp::DisplacementController *this)
{
  *(_QWORD *)this = &off_1E69E0F80;
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 320);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 256);
}

{
  *(_QWORD *)this = &off_1E69E0F80;
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 320);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 256);
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *clsp::DisplacementController::dump(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"g_bw = ", 7);
  v4 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\nx_lim = ", 9);
  v5 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"\nQ_d = ", 7);
  v6 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"\npeakAttackTime = ", 18);
  v7 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"\npeakDecayTime = ", 17);
  v8 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"\nflvSmoothingTime = ", 20);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"\nmc_x_lim = ", 12);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"\ninvxlim = ", 11);
  v11 = (_QWORD *)std::ostream::operator<<();
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"\n\nptp:\n", 7);
  clsp::IIRTwoPole<float>::dump(a1 + 80, v12);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"\nflv:\n", 6);
  clsp::IIRTwoPole<float>::dump(a1 + 100, v13);
  v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"\nptpAtkRel:\n", 12);
  clsp::AttackRelease<float,double>::dump(a1 + 128, v14);
  v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"\nflvTime:\n", 10);
  clsp::AttackRelease<float,double>::dump(a1 + 168, v15);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"\nflvSmoother:\n", 14);
  clsp::ExponentialSmoother<float,double>::dump(a1 + 208, v16);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\nlfsn:\n", 7);
  clsp::LFSN::dump(a1 + 224, v17);
  return a2;
}

void clsp::DisplacementController::logCoeffs(uint64_t a1, clsp::CLSP_Log **a2)
{
  clsp::CLSP_Log *v4;
  float v5;
  clsp::CLSP_Log *v6;
  float v7;
  clsp::CLSP_Log *v8;
  float v9;
  clsp::CLSP_Log *v10;
  float v11;
  clsp::CLSP_Log *v12;
  float v13;
  clsp::CLSP_Log *v14;
  float v15;
  clsp::CLSP_Log *v16;
  clsp::CLSP_Log *v17;
  clsp::CLSP_Log *v18;
  float *v19;
  clsp::CLSP_Log *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  float *v24;
  clsp::CLSP_Log *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  clsp::CLSP_Log *v30;
  unint64_t *v31;
  unint64_t v32;
  __n128 v33;
  unint64_t v34;
  uint64_t v35;
  clsp::CLSP_Log *v36;
  unint64_t *v37;
  unint64_t v38;
  __n128 v39;
  unint64_t v40;
  uint64_t v41;
  clsp::CLSP_Log *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  clsp::CLSP_Log *v46;
  std::__shared_weak_count *v47;
  unint64_t *p_shared_owners;
  unint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  _QWORD v52[2];
  clsp::CLSP_Log *v53[2];
  clsp::CLSP_Log *v54[2];
  clsp::CLSP_Log *v55[2];
  clsp::CLSP_Log *v56[2];
  clsp::CLSP_Log *v57[2];
  float __src;

  v4 = *a2;
  if (!*a2)
    goto LABEL_10;
  v5 = *(double *)(a1 + 16);
  __src = v5;
  clsp::CLSP_Log::LogCLSPData(v4, &__src, 1);
  v6 = *a2;
  if (!*a2)
    goto LABEL_10;
  v7 = *(double *)(a1 + 24);
  __src = v7;
  clsp::CLSP_Log::LogCLSPData(v6, &__src, 1);
  v8 = *a2;
  if (!*a2)
    goto LABEL_10;
  v9 = *(double *)(a1 + 32);
  __src = v9;
  clsp::CLSP_Log::LogCLSPData(v8, &__src, 1);
  v10 = *a2;
  if (!*a2)
    goto LABEL_10;
  v11 = *(double *)(a1 + 40);
  __src = v11;
  clsp::CLSP_Log::LogCLSPData(v10, &__src, 1);
  v12 = *a2;
  if (!*a2)
    goto LABEL_10;
  v13 = *(double *)(a1 + 48);
  __src = v13;
  clsp::CLSP_Log::LogCLSPData(v12, &__src, 1);
  v14 = *a2;
  if (!*a2)
    goto LABEL_10;
  v15 = *(double *)(a1 + 56);
  __src = v15;
  clsp::CLSP_Log::LogCLSPData(v14, &__src, 1);
  v16 = *a2;
  if (*a2 && (__src = *(float *)(a1 + 68), clsp::CLSP_Log::LogCLSPData(v16, &__src, 1), (v17 = *a2) != 0))
  {
    __src = *(float *)(a1 + 72);
    clsp::CLSP_Log::LogCLSPData(v17, &__src, 1);
    v18 = *a2;
  }
  else
  {
LABEL_10:
    v18 = 0;
  }
  v19 = (float *)(a1 + 80);
  v20 = a2[1];
  v57[0] = v18;
  v57[1] = v20;
  if (v20)
  {
    v21 = (unint64_t *)((char *)v20 + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    clsp::IIRTwoPole<float>::logCoeffs(v19, v57);
    do
      v23 = __ldaxr(v21);
    while (__stlxr(v23 - 1, v21));
    if (!v23)
    {
      (*(void (**)(clsp::CLSP_Log *))(*(_QWORD *)v20 + 16))(v20);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v20);
    }
  }
  else
  {
    clsp::IIRTwoPole<float>::logCoeffs(v19, v57);
  }
  v24 = (float *)(a1 + 100);
  v25 = a2[1];
  v56[0] = *a2;
  v56[1] = v25;
  if (v25)
  {
    v26 = (unint64_t *)((char *)v25 + 8);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
    clsp::IIRTwoPole<float>::logCoeffs(v24, v56);
    do
      v28 = __ldaxr(v26);
    while (__stlxr(v28 - 1, v26));
    if (!v28)
    {
      (*(void (**)(clsp::CLSP_Log *))(*(_QWORD *)v25 + 16))(v25);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v25);
    }
  }
  else
  {
    clsp::IIRTwoPole<float>::logCoeffs(v24, v56);
  }
  v29 = a1 + 128;
  v30 = a2[1];
  v55[0] = *a2;
  v55[1] = v30;
  if (v30)
  {
    v31 = (unint64_t *)((char *)v30 + 8);
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    v33.n128_f32[0] = clsp::AttackRelease<float,double>::logCoeffs(v29, v55);
    do
      v34 = __ldaxr(v31);
    while (__stlxr(v34 - 1, v31));
    if (!v34)
    {
      (*(void (**)(clsp::CLSP_Log *, __n128))(*(_QWORD *)v30 + 16))(v30, v33);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v30);
    }
  }
  else
  {
    clsp::AttackRelease<float,double>::logCoeffs(v29, v55);
  }
  v35 = a1 + 168;
  v36 = a2[1];
  v54[0] = *a2;
  v54[1] = v36;
  if (v36)
  {
    v37 = (unint64_t *)((char *)v36 + 8);
    do
      v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
    v39.n128_f32[0] = clsp::AttackRelease<float,double>::logCoeffs(v35, v54);
    do
      v40 = __ldaxr(v37);
    while (__stlxr(v40 - 1, v37));
    if (!v40)
    {
      (*(void (**)(clsp::CLSP_Log *, __n128))(*(_QWORD *)v36 + 16))(v36, v39);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v36);
    }
  }
  else
  {
    clsp::AttackRelease<float,double>::logCoeffs(v35, v54);
  }
  v41 = a1 + 208;
  v42 = a2[1];
  v53[0] = *a2;
  v53[1] = v42;
  if (v42)
  {
    v43 = (unint64_t *)((char *)v42 + 8);
    do
      v44 = __ldxr(v43);
    while (__stxr(v44 + 1, v43));
    clsp::ExponentialSmoother<float,double>::logCoeffs(v41, v53);
    do
      v45 = __ldaxr(v43);
    while (__stlxr(v45 - 1, v43));
    if (!v45)
    {
      (*(void (**)(clsp::CLSP_Log *))(*(_QWORD *)v42 + 16))(v42);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v42);
    }
  }
  else
  {
    clsp::ExponentialSmoother<float,double>::logCoeffs(v41, v53);
  }
  v46 = *a2;
  v47 = (std::__shared_weak_count *)a2[1];
  v52[0] = v46;
  v52[1] = v47;
  if (v47)
  {
    p_shared_owners = (unint64_t *)&v47->__shared_owners_;
    do
      v49 = __ldxr(p_shared_owners);
    while (__stxr(v49 + 1, p_shared_owners));
  }
  clsp::LFSN::logCoeffs((float *)(a1 + 224), (uint64_t)v52);
  if (v47)
  {
    v50 = (unint64_t *)&v47->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
}

void sub_1B6165054(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t clsp::DisplacementController::setG_bw(uint64_t this, double a2)
{
  *(double *)(this + 16) = a2;
  return this;
}

double clsp::DisplacementController::getG_bw(clsp::DisplacementController *this)
{
  return *((double *)this + 2);
}

uint64_t clsp::DisplacementController::setX_lim(uint64_t this, double a2)
{
  *(double *)(this + 24) = a2;
  return this;
}

double clsp::DisplacementController::getX_lim(clsp::DisplacementController *this)
{
  return *((double *)this + 3);
}

uint64_t clsp::DisplacementController::setQ_d(uint64_t this, double a2)
{
  *(double *)(this + 32) = a2;
  return this;
}

double clsp::DisplacementController::getQ_d(clsp::DisplacementController *this)
{
  return *((double *)this + 4);
}

double *clsp::DisplacementController::setPeakAttackTime(double *this, double a2)
{
  this[5] = a2;
  this[16] = a2;
  this[21] = a2;
  return this;
}

double clsp::DisplacementController::getPeakAttackTime(clsp::DisplacementController *this)
{
  return *((double *)this + 5);
}

double *clsp::DisplacementController::setPeakDecayTime(double *this, double a2)
{
  this[6] = a2;
  this[17] = a2;
  this[22] = a2;
  return this;
}

double clsp::DisplacementController::getPeakDecayTime(clsp::DisplacementController *this)
{
  return *((double *)this + 6);
}

uint64_t clsp::DisplacementController::setFlvSmoothingTime(uint64_t this, double a2)
{
  *(double *)(this + 56) = a2;
  return this;
}

double clsp::DisplacementController::getFlvSmoothingTime(clsp::DisplacementController *this)
{
  return *((double *)this + 7);
}

uint64_t clsp::DisplacementController::getLFSN(clsp::DisplacementController *this)
{
  return (uint64_t)this + 224;
}

uint64_t clsp::DisplacementController::setDispEnabled(uint64_t this, char a2)
{
  *(_BYTE *)(this + 64) = a2;
  return this;
}

uint64_t clsp::DisplacementController::getDispEnabled(clsp::DisplacementController *this)
{
  return *((unsigned __int8 *)this + 64);
}

uint64_t clsp::DisplacementController::setAttenuationFactor(uint64_t this, float a2)
{
  *(float *)(this + 76) = a2;
  return this;
}

float clsp::DisplacementController::getAttenuationFactor(clsp::DisplacementController *this)
{
  return *((float *)this + 19);
}

float clsp::DisplacementController::calcCoeffs(clsp::DisplacementController *this, double a2, double a3)
{
  float v6;
  double *v7;
  double v8;
  double v9;
  float v10;
  double *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  float v18;
  double v19;
  float v20;
  float result;

  v6 = clsp::DisplacementModelSealed::calcCoeffsFLV(*((double **)this + 15), (float *)this + 25, a2, a3);
  v7 = (double *)*((_QWORD *)this + 15);
  v8 = (*(double (**)(clsp::DisplacementController *, float))(*(_QWORD *)this + 72))(this, v6);
  v9 = (*(double (**)(clsp::DisplacementController *))(*(_QWORD *)this + 40))(this);
  v10 = clsp::DisplacementModelSealed::calcCoeffs(v7, (float *)this + 20, a2, v8, sqrt(v7[4] / v7[2]) / sqrt(v9), a3);
  v11 = (double *)*((_QWORD *)this + 15);
  v12 = (*(double (**)(clsp::DisplacementController *, float))(*(_QWORD *)this + 72))(this, v10);
  v13 = (*(double (**)(clsp::DisplacementController *))(*(_QWORD *)this + 40))(this);
  v14 = (*(double (**)(clsp::DisplacementController *))(*(_QWORD *)this + 56))(this);
  clsp::LFSN::calcCoeffs((uint64_t)this + 224, v11, a2, *((double *)this + 10), *((float *)this + 25), *((float *)this + 26), v12, v13, v14, a3);
  clsp::AttackRelease<float,double>::calcCoeffs((uint64_t)this + 128, a2);
  clsp::AttackRelease<float,double>::calcCoeffs((uint64_t)this + 168, a2);
  v15 = *((double *)this + 7);
  *((double *)this + 26) = v15;
  v16 = v15 * a2;
  v17 = 0.0;
  if (v16 >= 0.00001)
    v17 = exp(-4.60517019 / v16);
  v18 = 1.0 - v17;
  *((float *)this + 54) = v18;
  v19 = *((double *)this + 3);
  v20 = v19;
  result = 1.0 / v19;
  *((float *)this + 17) = v20;
  *((float *)this + 18) = result;
  return result;
}

uint64_t clsp::DisplacementController::calcCoeffsSyncDisp(clsp::DisplacementController *this, double a2, double a3, double a4, double a5, double a6, double a7)
{
  float v13;
  float v14;
  uint64_t v15;
  float v16;

  clsp::DisplacementModelSealed::calcCoeffs(*((double **)this + 15), (float *)this + 20, a2, a4, a3, a7);
  v13 = *((float *)this + 25);
  v14 = *((float *)this + 26);
  v15 = *((_QWORD *)this + 10);
  *((_DWORD *)this + 70) = 1065353216;
  *((float *)this + 71) = v13;
  *((float *)this + 72) = v14;
  *((_QWORD *)this + 34) = v15;
  v16 = 1.0 / (1.0 - v13 + v14);
  *((float *)this + 77) = v16;
  return clsp::LFSNFeedbackCoeffCalc::calcCoeffs((clsp::DisplacementController *)((char *)this + 224), a2, a3, a4, a5, 1.0, a6);
}

void clsp::DisplacementController::processSample(clsp::DisplacementController *this, float a2, float a3)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  clsp::CLSP_Log *v11;
  clsp::CLSP_Log *v12;
  float v13;
  float v14;
  float v15;
  float __src;
  float v17;

  if (*((_BYTE *)this + 64))
  {
    v5 = *((float *)this + 19);
    if (v5 >= *((float *)this + 62))
      v5 = *((float *)this + 62);
    v6 = *((float *)this + 56) + (float)(*((float *)this + 57) * v5);
    v7 = *((float *)this + 58);
    v8 = *((float *)this + 59) + (float)(*((float *)this + 60) * v5);
    v9 = v5 * v5;
    v10 = v8 + (float)(*((float *)this + 61) * v9);
    *((float *)this + 68) = v6 + (float)(v7 * v9);
    *((float *)this + 69) = v10;
    v11 = *(clsp::CLSP_Log **)(*((_QWORD *)this + 32) + 16);
    if (v11)
    {
      __src = v6 + (float)(v7 * v9);
      clsp::CLSP_Log::LogCLSPData(v11, &__src, 1);
      v12 = *(clsp::CLSP_Log **)(*((_QWORD *)this + 32) + 16);
      if (v12)
      {
        v17 = v10;
        clsp::CLSP_Log::LogCLSPData(v12, &v17, 1);
      }
    }
    v13 = *((float *)this + 73);
    v14 = *((float *)this + 75);
    v15 = (float)((float)((float)((float)(*((float *)this + 71) * v13) + (float)(a3 * *((float *)this + 70)))
                        + (float)(*((float *)this + 74) * *((float *)this + 72)))
                - (float)(v14 * *((float *)this + 68)))
        - (float)(*((float *)this + 76) * *((float *)this + 69));
    *((float *)this + 73) = a3;
    *((float *)this + 74) = v13;
    *((float *)this + 75) = v15;
    *((float *)this + 76) = v14;
  }
}

float clsp::DisplacementController::analyzeDisp(clsp::DisplacementController *this, float a2, float a3)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  uint64_t v24;
  float v25;
  float v26;
  float v27;
  float v28;
  clsp::CLSP_Log **v29;
  clsp::CLSP_Log *v30;
  clsp::CLSP_Log *v31;
  clsp::CLSP_Log *v32;
  clsp::CLSP_Log *v33;
  clsp::CLSP_Log *v34;
  clsp::CLSP_Log *v35;
  clsp::CLSP_Log *v36;
  clsp::CLSP_Log *v37;
  clsp::CLSP_Log *v38;
  float *v39;
  float __src;

  v4 = *((float *)this + 21);
  v5 = *((float *)this + 23);
  v6 = (float)(a2 * *((float *)this + 22)) - (float)(v5 * *((float *)this + 20));
  v7 = *((float *)this + 24);
  v8 = *((float *)this + 25);
  v9 = v6 - (float)(v7 * v4);
  *((float *)this + 23) = v9;
  *((float *)this + 24) = v5;
  v10 = -(float)(v6 + (float)((float)-v7 * v4));
  if (v9 >= 0.0)
    v10 = v9;
  v11 = *((float *)this + 40);
  v12 = 148;
  if (v11 < v10)
    v12 = 144;
  v13 = v11 + (float)(*(float *)((char *)this + v12) * (float)(v10 - v11));
  *((float *)this + 40) = v13;
  v14 = *((float *)this + 17);
  v15 = *((float *)this + 18);
  v16 = *((float *)this + 26);
  v17 = *((float *)this + 28);
  v18 = *((float *)this + 29);
  v19 = (float)(a3 * *((float *)this + 27)) - (float)(v17 * v8);
  v20 = v19 - (float)(v18 * v16);
  *((float *)this + 28) = v20;
  *((float *)this + 29) = v17;
  if (v14 >= v13)
    v21 = v14;
  else
    v21 = v13;
  v22 = -(float)(v19 + (float)((float)-v18 * v16));
  if (v20 >= 0.0)
    v22 = v20;
  v23 = *((float *)this + 50);
  v24 = 188;
  if (v23 < v22)
    v24 = 184;
  v25 = *(float *)((char *)this + v24);
  v26 = v22 - v23;
  v27 = v23 + (float)(v25 * v26);
  *((float *)this + 50) = v27;
  if (v14 < v27)
    v14 = v23 + (float)(v25 * v26);
  v28 = *((float *)this + 55) + (float)(*((float *)this + 54) * (float)((float)(v15 * v14) - *((float *)this + 55)));
  *((float *)this + 55) = v28;
  *((float *)this + 19) = v21 * v28;
  v29 = (clsp::CLSP_Log **)*((_QWORD *)this + 40);
  v30 = *v29;
  if (*v29)
  {
    __src = a3;
    clsp::CLSP_Log::LogCLSPData(v30, &__src, 1);
    v29 = (clsp::CLSP_Log **)*((_QWORD *)this + 40);
  }
  v31 = v29[2];
  if (v31)
  {
    __src = v9;
    clsp::CLSP_Log::LogCLSPData(v31, &__src, 1);
    v29 = (clsp::CLSP_Log **)*((_QWORD *)this + 40);
    v32 = v29[2];
    if (v32)
    {
      __src = v13;
      clsp::CLSP_Log::LogCLSPData(v32, &__src, 1);
      v29 = (clsp::CLSP_Log **)*((_QWORD *)this + 40);
      v33 = v29[2];
      if (v33)
      {
        __src = v21;
        clsp::CLSP_Log::LogCLSPData(v33, &__src, 1);
        v29 = (clsp::CLSP_Log **)*((_QWORD *)this + 40);
        v34 = v29[2];
        if (v34)
        {
          __src = v28;
          clsp::CLSP_Log::LogCLSPData(v34, &__src, 1);
          v29 = (clsp::CLSP_Log **)*((_QWORD *)this + 40);
        }
      }
    }
  }
  v35 = *v29;
  if (*v29)
  {
    __src = v20;
    clsp::CLSP_Log::LogCLSPData(v35, &__src, 1);
    v36 = (clsp::CLSP_Log *)**((_QWORD **)this + 40);
    if (v36)
    {
      __src = v27;
      clsp::CLSP_Log::LogCLSPData(v36, &__src, 1);
      v37 = (clsp::CLSP_Log *)**((_QWORD **)this + 40);
      if (v37)
      {
        __src = *((float *)this + 19);
        clsp::CLSP_Log::LogCLSPData(v37, &__src, 1);
        v38 = (clsp::CLSP_Log *)**((_QWORD **)this + 40);
        if (v38)
        {
          v39 = (float *)(*(uint64_t (**)(clsp::DisplacementController *))(*(_QWORD *)this + 128))(this);
          __src = log10f(v39[21]* (float)((float)((float)((float)(1.0 - v39[12]) + v39[13])* (float)((float)(v39[14] + v39[15]) + v39[16]))/ (float)((float)(v39[12] + 1.0) + v39[13])))* 20.0;
          clsp::CLSP_Log::LogCLSPData(v38, &__src, 1);
        }
      }
    }
  }
  return *((float *)this + 19);
}

float clsp::DisplacementController::getNormAttenFactor(clsp::DisplacementController *this)
{
  return *((float *)this + 19) * *((float *)this + 18);
}

float clsp::DisplacementController::reset(clsp::DisplacementController *this)
{
  float result;

  *(_QWORD *)((char *)this + 300) = 0;
  *(_QWORD *)((char *)this + 292) = 0;
  *(_QWORD *)((char *)this + 92) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 50) = 0;
  *((_DWORD *)this + 55) = 0;
  result = (*(double (**)(clsp::DisplacementController *))(*(_QWORD *)this + 56))(this);
  *((float *)this + 19) = result;
  return result;
}

uint64_t clsp::DisplacementController::zapBadValues(uint64_t this)
{
  float32x2_t v1;
  float64x2_t v2;
  float64x2_t v3;
  float64x2_t v4;
  float v5;
  double v6;
  float32x2_t v8;
  float64x2_t v9;
  float v10;
  double v11;
  float v13;
  double v14;
  float32x4_t v16;
  float32x4_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float v20;
  double v21;

  v1 = *(float32x2_t *)(this + 92);
  v2 = vcvtq_f64_f32(vabs_f32(v1));
  v3 = (float64x2_t)vdupq_n_s64(0x3CD203AF9EE75616uLL);
  v4 = (float64x2_t)vdupq_n_s64(0x430C6BF526340000uLL);
  *(int8x8_t *)(this + 92) = vand_s8((int8x8_t)v1, (int8x8_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_f64(v2, v3), (int8x16_t)vcgtq_f64(v4, v2))));
  v5 = *(float *)(this + 160);
  v6 = fabsf(v5);
  if (v6 >= 1.0e15 || v6 <= 1.0e-15)
    v5 = 0.0;
  *(float *)(this + 160) = v5;
  v8 = *(float32x2_t *)(this + 112);
  v9 = vcvtq_f64_f32(vabs_f32(v8));
  *(int8x8_t *)(this + 112) = vand_s8((int8x8_t)v8, (int8x8_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_f64(v9, v3), (int8x16_t)vcgtq_f64(v4, v9))));
  v10 = *(float *)(this + 200);
  v11 = fabsf(v10);
  if (v11 >= 1.0e15 || v11 <= 1.0e-15)
    v10 = 0.0;
  *(float *)(this + 200) = v10;
  v13 = *(float *)(this + 220);
  v14 = fabsf(v13);
  if (v14 >= 1.0e15 || v14 <= 1.0e-15)
    v13 = 0.0;
  *(float *)(this + 220) = v13;
  v16 = *(float32x4_t *)(this + 292);
  v17 = vabsq_f32(v16);
  v18 = vcvt_hight_f64_f32(v17);
  v19 = vcvtq_f64_f32(*(float32x2_t *)v17.f32);
  *(int8x16_t *)(this + 292) = vandq_s8((int8x16_t)v16, (int8x16_t)vuzp1q_s32((int32x4_t)vandq_s8((int8x16_t)vcgtq_f64(v19, v3), (int8x16_t)vcgtq_f64(v4, v19)), (int32x4_t)vandq_s8((int8x16_t)vcgtq_f64(v18, v3), (int8x16_t)vcgtq_f64(v4, v18))));
  v20 = *(float *)(this + 76);
  v21 = fabsf(v20);
  if (v21 >= 1.0e15 || v21 <= 1.0e-15)
    v20 = 0.0;
  if (v20 < *(float *)(this + 68))
    v20 = *(float *)(this + 68);
  *(float *)(this + 76) = v20;
  return this;
}

_QWORD *clsp::DisplacementController::setLogs(uint64_t a1, uint64_t *a2)
{
  std::shared_ptr<clsp::CLSPKernel_Logs>::operator=[abi:ne180100]((_QWORD *)(a1 + 320), *a2, a2[1]);
  return std::shared_ptr<clsp::CLSPKernel_Logs>::operator=[abi:ne180100]((_QWORD *)(a1 + 256), *a2, a2[1]);
}

float clsp::DisplacementModelSealed::calcCoeffs(double *a1, float *a2, double a3, double a4, double a5, double a6)
{
  double v11;
  double v12;
  long double v13;
  long double v14;
  long double v15;
  float v16;
  float v17;
  float result;

  v11 = 1.0 / a3;
  v12 = -(1.0 / a3 * a5);
  v13 = exp(v12 / (a4 + a4)) * -2.0;
  v14 = v13 * cos(v11 * a5 * sqrt(1.0 / (a4 * -4.0 * a4) + 1.0));
  v15 = exp(v12 / a4);
  v16 = (v15 + v14 + 1.0) * (a6 * 1000.0 * a1[1] / (*a1 * a1[4]));
  v17 = v14;
  result = v15;
  *a2 = v17;
  a2[1] = result;
  a2[2] = v16;
  return result;
}

uint64_t clsp::LFSNFeedbackCoeffCalc::calcCoeffs(clsp::LFSNFeedbackCoeffCalc *this, double a2, double a3, double a4, double a5, double a6, double a7)
{
  uint64_t v9;
  double v10;
  double v11;
  double v13;
  float v14;
  double v15;
  double v16;
  long double v17;
  long double v18;
  long double v19;
  float v20;
  uint64_t result;
  int32x4_t v22;
  float v23;
  double v24;
  double v25;
  double v26;
  double v27;
  _QWORD v28[2];
  uint64_t v29;
  int v30;
  _OWORD v31[2];
  uint64_t v32;
  _OWORD v33[2];
  uint64_t v34;
  _OWORD __A[2];
  uint64_t v36;
  uint64_t v37;

  v9 = 0;
  v37 = *MEMORY[0x1E0C80C00];
  if (a7 <= a6)
    a7 = a6;
  v24 = a7 * 1.5;
  v36 = 0;
  memset(__A, 0, sizeof(__A));
  v34 = 0;
  memset(v33, 0, sizeof(v33));
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  v30 = 0;
  v29 = 0;
  memset(v28, 0, 12);
  v26 = 1.0 / sqrt(a5) * a3;
  v27 = (a7 * 1.5 - a6) / 9.0;
  v10 = 1.0 / a2;
  v25 = -(1.0 / a2);
  v11 = a4 + a4;
  v13 = sqrt(1.0 / (a4 * -4.0 * a4) + 1.0);
  do
  {
    v14 = a6 + (double)(int)v9 * v27;
    *((float *)__A + v9) = v14;
    v15 = v26 * sqrt(v14 / a6);
    v16 = v15 * v25;
    v17 = exp(v15 * v25 / v11) * -2.0;
    v18 = cos(v13 * (v10 * v15)) * v17;
    v19 = exp(v16 / a4);
    v20 = v18;
    *((float *)v33 + v9) = v20;
    *(float *)&v19 = v19;
    *((_DWORD *)v31 + v9++) = LODWORD(v19);
  }
  while (v9 != 10);
  clsp::polyfit<10ul,2ul>((const float *)__A, (const float *)v33, (float *)&v29);
  result = clsp::polyfit<10ul,2ul>((const float *)__A, (const float *)v31, (float *)v28);
  *(_DWORD *)this = v30;
  v22.i64[0] = v29;
  v22.i64[1] = *(_QWORD *)((char *)v28 + 4);
  *(int32x4_t *)((char *)this + 4) = vrev64q_s32(v22);
  v23 = v24;
  *((_DWORD *)this + 5) = v28[0];
  *((float *)this + 6) = v23;
  return result;
}

uint64_t clsp::polyfit<10ul,2ul>(const float *__A, const float *a2, float *a3)
{
  uint64_t v6;
  _DWORD *v7;
  uint64_t i;
  uint64_t v9;
  __int128 *p_a;
  uint64_t v11;
  _OWORD *v12;
  int *v13;
  _DWORD *v14;
  uint64_t v15;
  int v16;
  __CLPK_integer __nrhs;
  __CLPK_integer __n;
  __CLPK_integer __lda;
  __CLPK_integer __lwork;
  __CLPK_integer __info;
  __CLPK_integer __ipiv[2];
  int v24;
  __CLPK_real __Aa[4];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  __CLPK_real __work[4];
  __CLPK_real __tau[4];
  __int128 __a;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  _OWORD v43[2];
  int v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;

  v6 = 0;
  v53 = *MEMORY[0x1E0C80C00];
  v52 = 0;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v45 = 0u;
  do
  {
    v7 = (_DWORD *)((char *)&v45 + v6);
    *v7 = 1065353216;
    v7[10] = 1065353216;
    v7[20] = 1065353216;
    v6 += 4;
  }
  while (v6 != 40);
  for (i = 0; i != -80; i -= 40)
    vDSP_vmul(__A, 1, (const float *)((char *)&v50 + i), 1, (float *)((char *)&v47 + i + 8), 1, 0xAuLL);
  v44 = 0;
  memset(v43, 0, sizeof(v43));
  v39 = v49;
  v40 = v50;
  v41 = v51;
  v42 = v52;
  __a = v45;
  v36 = v46;
  v37 = v47;
  v38 = v48;
  __tau[2] = 0.0;
  *(_QWORD *)__tau = 0;
  __work[2] = 0.0;
  *(_QWORD *)__work = 0;
  v9 = 3;
  __lwork = 3;
  __info = 0;
  __n = 3;
  __lda = 10;
  p_a = &__a;
  sgeqrf_(&__lda, &__n, (__CLPK_real *)&__a, &__lda, __tau, __work, &__lwork, &__info);
  v11 = 0;
  v12 = v43;
  do
  {
    v13 = (int *)p_a;
    v14 = v12;
    v15 = v9;
    do
    {
      v16 = *v13;
      v13 += 10;
      *v14 = v16;
      v14 += 3;
      --v15;
    }
    while (v15);
    ++v11;
    --v9;
    ++v12;
    p_a = (__int128 *)((char *)p_a + 44);
  }
  while (v11 != 3);
  v29 = v39;
  v30 = v40;
  v31 = v41;
  v32 = v42;
  *(_OWORD *)__Aa = __a;
  v26 = v36;
  v27 = v37;
  v28 = v38;
  sorgqr_(&__lda, &__n, &__n, __Aa, &__lda, __tau, __work, &__lwork, &__info);
  cblas_sgemv(CblasColMajor, CblasTrans, __lda, __n, 1.0, __Aa, __lda, a2, 1, 0.0, a3, 1);
  v24 = 0;
  *(_QWORD *)__ipiv = 0;
  __nrhs = 1;
  return sgesv_(&__n, &__nrhs, (__CLPK_real *)v43, &__n, __ipiv, a3, &__n, &__info);
}

_QWORD *allocMatrix(int a1, int a2)
{
  size_t v4;
  _QWORD *v5;
  _QWORD *v6;
  size_t v7;
  uint64_t v8;
  _QWORD *i;
  void *v10;
  void *v11;
  std::bad_alloc *exception;
  std::bad_alloc *v14;

  v4 = 8 * a1;
  v5 = malloc_type_malloc(v4, 0x2C8E6D5CuLL);
  v6 = v5;
  if (a1 && !v5)
    goto LABEL_9;
  bzero(v5, v4);
  if (a1 >= 1)
  {
    v7 = 4 * a2;
    v8 = a1;
    for (i = v6; ; ++i)
    {
      v10 = malloc_type_malloc(v7, 0x2C8E6D5CuLL);
      v11 = v10;
      if ((_DWORD)v7)
      {
        if (!v10)
          break;
      }
      bzero(v10, v7);
      *i = v11;
      if (!--v8)
        return v6;
    }
LABEL_9:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v14 = std::bad_alloc::bad_alloc(exception);
  }
  return v6;
}

void freeMatrix(int a1, float ***a2)
{
  void **v2;
  uint64_t v4;

  v2 = (void **)*a2;
  if (*a2)
  {
    if (a1 < 1)
      goto LABEL_8;
    v4 = a1;
    do
    {
      if (*v2)
      {
        free(*v2);
        *v2 = 0;
      }
      ++v2;
      --v4;
    }
    while (v4);
    v2 = (void **)*a2;
    if (*a2)
    {
LABEL_8:
      free(v2);
      *a2 = 0;
    }
  }
}

void ASAFrontEnd::createLifterResponse(ASAFrontEnd *this, float *a2, int32x2_t a3, double a4)
{
  uint64_t v5;
  uint64x2_t v6;
  double v7;
  float32x2_t v8;
  float32x2_t v9;
  uint64_t v10;
  float32x2_t v11;
  uint32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float v22;
  int64x2_t v23;
  uint64x2_t v24;
  float v25;
  float v26;
  int32x2_t v27;
  int64x2_t v28;

  if ((_DWORD)a2)
  {
    v5 = 0;
    v24 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    v6 = (uint64x2_t)xmmword_1B6626830;
    v7 = 3.14159265 / (float)((float)a2 + -1.0);
    *(float *)&v7 = v7;
    v22 = *(float *)&v7;
    v23 = vdupq_n_s64(2uLL);
    *(float *)&a4 = 1.0 / (float)a2;
    *(float *)&v7 = 1.0 - *(float *)&a4;
    v8 = (float32x2_t)vdup_lane_s32(a3, 0);
    v9 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v7, 0);
    v10 = (a2 + 1) & 0x1FFFFFFFELL;
    v11 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
    __asm
    {
      FMOV            V12.2S, #-1.0
      FMOV            V13.2S, #1.0
    }
    do
    {
      v27 = vmovn_s64((int64x2_t)vcgeq_u64(v24, v6));
      v28 = (int64x2_t)v6;
      v18.i32[0] = v5;
      v18.i32[1] = v5 + 1;
      v19 = vmul_n_f32(vcvt_f32_u32(v18), v22);
      v25 = v19.f32[0];
      v26 = sinf(v19.f32[1]);
      v20.f32[0] = sinf(v25);
      v20.f32[1] = v26;
      v21 = vmla_f32(v11, v9, vmla_f32(_D13, vmla_f32(_D12, (float32x2_t)0x4000000040000000, v20), v8));
      if ((v27.i8[0] & 1) != 0)
        *((_DWORD *)this + v5) = v21.i32[0];
      if ((v27.i8[4] & 1) != 0)
        *((_DWORD *)this + v5 + 1) = v21.i32[1];
      v5 += 2;
      v6 = (uint64x2_t)vaddq_s64(v28, v23);
    }
    while (v10 != v5);
  }
}

void VADGenUtils::ComputeProjectionComponent<double>(const double *a1, double *a2, vDSP_Length a3, vDSP_Length a4)
{
  vDSP_Length v4;
  double *v9;
  double *v10;
  vDSP_Length v11;
  double *v12;
  double *v13;
  __CLPK_integer *v14;
  __CLPK_integer *v15;
  __CLPK_doublereal *v16;
  __CLPK_doublereal *v17;
  std::bad_alloc *exception;
  std::bad_alloc *v19;
  __CLPK_integer __lwork;
  __CLPK_integer __lda;
  __CLPK_integer __info;

  v4 = a3 * a3;
  if ((a3 * a3) >> 61)
    goto LABEL_14;
  v9 = (double *)malloc_type_malloc(8 * v4, 0x2C8E6D5CuLL);
  v10 = v9;
  if (a3)
  {
    if (!v9)
      goto LABEL_14;
  }
  bzero(v9, 8 * v4);
  v11 = a4 * a3;
  if ((a4 * a3) >> 61)
    goto LABEL_14;
  v12 = (double *)malloc_type_malloc(8 * v11, 0x2C8E6D5CuLL);
  v13 = v12;
  if (v11)
  {
    if (!v12)
      goto LABEL_14;
  }
  bzero(v12, 8 * v11);
  vDSP_mtransD(a1, 1, v13, 1, a4, a3);
  vDSP_mmulD(a1, 1, v13, 1, v10, 1, a3, a3, a4);
  __lda = a3;
  __info = 0;
  if ((a3 & 0x80000000) != 0)
    goto LABEL_14;
  v14 = (__CLPK_integer *)malloc_type_malloc(4 * a3, 0x2C8E6D5CuLL);
  v15 = v14;
  if (a3)
  {
    if (!v14)
      goto LABEL_14;
  }
  bzero(v14, 4 * a3);
  __lwork = 2 * v4;
  if (((v4 << 33) & 0x8000000000000000) != 0
    || (v16 = (__CLPK_doublereal *)malloc_type_malloc((16 * v4) & 0x7FFFFFFFFLL, 0x2C8E6D5CuLL), v17 = v16, v4 << 33)
    && !v16)
  {
LABEL_14:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v19 = std::bad_alloc::bad_alloc(exception);
  }
  bzero(v16, (16 * v4) & 0x7FFFFFFFFLL);
  dgetrf_(&__lda, &__lda, v10, &__lda, v15, &__info);
  dgetri_(&__lda, v10, &__lda, v15, v17, &__lwork, &__info);
  free(v17);
  free(v15);
  vDSP_mmulD(v13, 1, v10, 1, a2, 1, a4, a3, a3);
  free(v13);
  free(v10);
}

void *ASAFrontEnd::genericComputeMagnitudeSpectrum(ASAFrontEnd *this, const float *__B, float *__C, vDSP_Length __N, unsigned int a5, _QWORD **a6, void **a7, float *a8)
{
  unsigned int v11;
  vDSP_Length v13;
  uint64_t v14;
  float *v15;
  DSPSplitComplex v17;

  v11 = __N;
  v13 = __N;
  vDSP_vmul((const float *)this, 1, __B, 1, __C, 1, __N);
  v14 = v11;
  v15 = &__C[v14];
  bzero(&__C[v14], v14 * 4);
  v17.realp = __C;
  v17.imagp = v15;
  MultiRadixFFT_CplxInPlaceTransform(*a6, (const float **)&v17.realp, 1);
  vDSP_zvabs(&v17, 1, __C, 1, v13);
  return memcpy(a7, __C, 4 * a5);
}

uint64_t Crossover2f::Crossover2f(uint64_t a1, __int128 *a2, double a3)
{
  void ***v5;
  void ***v6;
  void ***v7;
  _OWORD *v8;
  __int128 v9;
  NSObject *v10;
  std::string::size_type v11;
  void **v12;
  NSObject *v13;
  float v14;
  void **v15;
  void **v16;
  void **v17;
  std::string __p;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = (void ***)(a1 + 8);
  *(_OWORD *)(a1 + 16) = 0u;
  v6 = (void ***)(a1 + 16);
  v7 = (void ***)(a1 + 24);
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 32) = 2;
  *(double *)(a1 + 40) = a3;
  v8 = (_OWORD *)(a1 + 48);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 48), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v9 = *a2;
    *(_QWORD *)(a1 + 64) = *((_QWORD *)a2 + 2);
    *v8 = v9;
  }
  if (getScottyLog(void)::onceToken != -1)
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
  v10 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v11 = (std::string::size_type)v8;
    if (*(char *)(a1 + 71) < 0)
      v11 = *(_QWORD *)v8;
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v11;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"Crossover2f";
    _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEFAULT, "[%s|%s] Constructing", (uint8_t *)&__p, 0x16u);
  }
  if (a3 <= 0.0)
  {
    if (getScottyLog(void)::onceToken != -1)
      dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
    v13 = getScottyLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 71) < 0)
        v8 = *(_OWORD **)v8;
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"Crossover2f";
      _os_log_error_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_ERROR, "[%s|%s] Invalid number of channels and/or sample rate", (uint8_t *)&__p, 0x16u);
    }
  }
  else
  {
    v12 = (void **)operator new();
    if (*(char *)(a1 + 71) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a1 + 48), *(_QWORD *)(a1 + 56));
    else
      __p = *(std::string *)v8;
    v14 = a3;
    ParametricFilters::ParametricFilters((uint64_t)v12, 2, 0, 5, (__int128 *)&__p, v14);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    std::unique_ptr<ParametricFilters>::reset[abi:ne180100](v7, v12);
    v15 = (void **)operator new();
    if (*(char *)(a1 + 71) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a1 + 48), *(_QWORD *)(a1 + 56));
    else
      __p = *(std::string *)v8;
    ParametricFilters::ParametricFilters((uint64_t)v15, 2, 0, 5, (__int128 *)&__p, v14);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    std::unique_ptr<ParametricFilters>::reset[abi:ne180100](v6, v15);
    v16 = (void **)operator new();
    if (*(char *)(a1 + 71) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a1 + 48), *(_QWORD *)(a1 + 56));
    else
      __p = *(std::string *)v8;
    ParametricFilters::ParametricFilters((uint64_t)v16, 2, 0, 5, (__int128 *)&__p, v14);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    std::unique_ptr<ParametricFilters>::reset[abi:ne180100](v5, v16);
    v17 = (void **)operator new();
    if (*(char *)(a1 + 71) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a1 + 48), *(_QWORD *)(a1 + 56));
    else
      __p = *(std::string *)v8;
    ParametricFilters::ParametricFilters((uint64_t)v17, 2, 0, 5, (__int128 *)&__p, v14);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)a1, v17);
  }
  return a1;
}

void sub_1B61666D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v14;
  void **v15;
  void ***v16;
  void ***v17;
  void ***v18;
  uint64_t v19;

  MEMORY[0x1BCC95CEC](v19, 0x10B2C40677E12FCLL);
  if (*(char *)(v14 + 71) < 0)
    operator delete(*v15);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100](v18, 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100](v17, 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100](v16, 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)v14, 0);
  _Unwind_Resume(a1);
}

void Crossover2f::CalculateCrossoverCoeffs(int a1, double **a2, double **a3, double a4, double a5)
{
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  char v33;
  char v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  long double v43;
  long double v44;
  double v45;
  unint64_t v46;
  double *v47;
  double *v48;
  double *v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  NSObject *v55;
  double *v56;
  double *v57;
  __int128 v58;
  __int128 v59;
  double v60;
  double v61;
  double v62;
  unint64_t v63;
  double *v64;
  double *v65;
  double *v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  double *v72;
  double *v73;
  __int128 v74;
  __int128 v75;
  NSObject *v76;
  double __x;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  double v93;
  uint8_t buf[4];
  const char *v95;
  uint8_t v96[16];
  _QWORD v97[3];

  v97[1] = *MEMORY[0x1E0C80C00];
  if (a4 <= 0.0)
  {
    if (getScottyLog(void)::onceToken != -1)
      dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
    v10 = getScottyLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v96 = 136315138;
      *(_QWORD *)&v96[4] = "CalculateCrossoverCoeffs";
      _os_log_error_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_ERROR, "%s: Invalid sample rate and/or order", v96, 0xCu);
    }
  }
  else
  {
    a2[1] = *a2;
    a3[1] = *a3;
    switch(a1)
    {
      case 1:
        v9 = 1;
        goto LABEL_11;
      case 2:
        v11 = 0x100000001;
        goto LABEL_13;
      case 3:
        v11 = 0x300000001;
LABEL_13:
        v97[0] = v11;
        _Q0 = xmmword_1B66A07C0;
        goto LABEL_14;
      case 4:
        v9 = 0x200000002;
LABEL_11:
        v97[0] = v9;
        __asm { FMOV            V0.2D, #1.0 }
LABEL_14:
        *(_OWORD *)v96 = _Q0;
        break;
      default:
        if (getScottyLog(void)::onceToken != -1)
          dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
        v76 = getScottyLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v96 = 136315138;
          *(_QWORD *)&v96[4] = "CalculateCrossoverCoeffs";
          _os_log_error_impl(&dword_1B5ED0000, v76, OS_LOG_TYPE_ERROR, "%s: Invalid or unhandled filter order", v96, 0xCu);
        }
        v97[0] = 0;
        break;
    }
    v17 = 0;
    v18 = a5 / (a4 * 0.5) * 3.14159265;
    v19 = v18 * 2.0 + 4.0 + v18 * v18;
    v20 = (v18 + v18) * v18 + -8.0;
    v21 = v18 * -2.0 + 4.0 + v18 * v18;
    v22 = sqrt((v21 + v19 + v20) * (v21 + v19 + v20) * 0.0625);
    v84 = (v22 + v22) / v19;
    v85 = v22 / v19;
    v82 = v21 / v19;
    v83 = v20 / v19;
    v23 = 1.0 / v18 * 2.0 + 1.0;
    v24 = 1.0 / v18 * 4.0;
    v25 = v23 + v24 * (1.0 / v18);
    v26 = 1.0 / v18 * -8.0 * (1.0 / v18) + 2.0;
    v27 = 1.0 / v18 * -2.0 + 1.0;
    v28 = v27 + v24 * (1.0 / v18);
    v29 = sqrt((v28 + v25 - v26) * (v28 + v25 - v26) * 0.00390625);
    v81 = v29 * 4.0 / v25;
    v79 = v26 / v25;
    v80 = v29 * -8.0 / v25;
    __x = v18 * 0.5;
    v78 = v28 / v25;
    v30 = v18 + 2.0;
    v31 = v18 + -2.0;
    v89 = v31 / v30;
    v90 = sqrt((v30 + v31) * (v30 + v31) * 0.25) / v30;
    v32 = sqrt((v23 - v27) * (v23 - v27) * 0.0625);
    v87 = v32 * -2.0 / v23;
    v88 = (v32 + v32) / v23;
    v33 = 1;
    v86 = v27 / v23;
    do
    {
      v34 = v33;
      v35 = 0.0;
      v36 = v87;
      v37 = v88;
      v93 = 0.0;
      v92 = v86;
      v38 = v89;
      v39 = v90;
      v40 = v90;
      v41 = 0.0;
      v42 = 0.0;
      switch(*((_DWORD *)v97 + v17))
      {
        case 0:
          break;
        case 1:
          goto LABEL_19;
        case 2:
          v43 = tan(__x);
          v44 = 1.0 / v43;
          v40 = 1.0 / (1.0 / v43 * 1.41421356 + 1.0 + v44 * v44);
          v39 = v40 + v40;
          v38 = (1.0 - v44 * v44 + 1.0 - v44 * v44) * v40;
          v42 = (1.0 / v43 * -1.41421356 + 1.0 + v44 * v44) * v40;
          v37 = 1.0 / (v43 * 1.41421356 + 1.0 + v43 * v43);
          v36 = v37 * -2.0;
          v92 = (v43 * v43 + -1.0 + v43 * v43 + -1.0) * v37;
          v93 = (v43 * -1.41421356 + 1.0 + v43 * v43) * v37;
          v35 = v37;
          v41 = v40;
          goto LABEL_19;
        case 3:
          v36 = v80;
          v35 = v81;
          v37 = v81;
          v92 = v79;
          v93 = v78;
          v39 = v84;
          v41 = v85;
          v40 = v85;
          v42 = v82;
          v38 = v83;
LABEL_19:
          v91 = v36;
          v45 = *(double *)&v96[8 * v17];
          v47 = a2[1];
          v46 = (unint64_t)a2[2];
          if ((unint64_t)v47 >= v46)
          {
            v49 = *a2;
            v50 = 0xCCCCCCCCCCCCCCCDLL * (v47 - *a2);
            v51 = v50 + 1;
            if (v50 + 1 > 0x666666666666666)
              std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
            v52 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v46 - (_QWORD)v49) >> 3);
            if (2 * v52 > v51)
              v51 = 2 * v52;
            if (v52 >= 0x333333333333333)
              v53 = 0x666666666666666;
            else
              v53 = v51;
            if (v53)
            {
              v53 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<BiquadCoefficients>>(v53);
              v49 = *a2;
              v47 = a2[1];
            }
            else
            {
              v54 = 0;
            }
            v56 = (double *)(v53 + 40 * v50);
            *v56 = v38;
            v56[1] = v42;
            v56[2] = v40;
            v56[3] = v39;
            v56[4] = v41;
            v57 = v56;
            if (v47 != v49)
            {
              do
              {
                v58 = *(_OWORD *)(v47 - 5);
                v59 = *(_OWORD *)(v47 - 3);
                *(v57 - 1) = *(v47 - 1);
                *(_OWORD *)(v57 - 3) = v59;
                *(_OWORD *)(v57 - 5) = v58;
                v57 -= 5;
                v47 -= 5;
              }
              while (v47 != v49);
              v49 = *a2;
            }
            v48 = v56 + 5;
            *a2 = v57;
            a2[1] = v56 + 5;
            a2[2] = (double *)(v53 + 40 * v54);
            if (v49)
              operator delete(v49);
          }
          else
          {
            *v47 = v38;
            v47[1] = v42;
            v47[2] = v40;
            v47[3] = v39;
            v48 = v47 + 5;
            v47[4] = v41;
          }
          v60 = v37 * v45;
          v61 = v91 * v45;
          v62 = v35 * v45;
          a2[1] = v48;
          v64 = a3[1];
          v63 = (unint64_t)a3[2];
          if ((unint64_t)v64 >= v63)
          {
            v66 = *a3;
            v67 = 0xCCCCCCCCCCCCCCCDLL * (v64 - *a3);
            v68 = v67 + 1;
            if (v67 + 1 > 0x666666666666666)
              std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
            v69 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v63 - (_QWORD)v66) >> 3);
            if (2 * v69 > v68)
              v68 = 2 * v69;
            if (v69 >= 0x333333333333333)
              v70 = 0x666666666666666;
            else
              v70 = v68;
            if (v70)
            {
              v70 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<BiquadCoefficients>>(v70);
              v66 = *a3;
              v64 = a3[1];
            }
            else
            {
              v71 = 0;
            }
            v72 = (double *)(v70 + 40 * v67);
            *v72 = v92;
            v72[1] = v93;
            v72[2] = v60;
            v72[3] = v61;
            v72[4] = v62;
            v73 = v72;
            if (v64 != v66)
            {
              do
              {
                v74 = *(_OWORD *)(v64 - 5);
                v75 = *(_OWORD *)(v64 - 3);
                *(v73 - 1) = *(v64 - 1);
                *(_OWORD *)(v73 - 3) = v75;
                *(_OWORD *)(v73 - 5) = v74;
                v73 -= 5;
                v64 -= 5;
              }
              while (v64 != v66);
              v66 = *a3;
            }
            v65 = v72 + 5;
            *a3 = v73;
            a3[1] = v72 + 5;
            a3[2] = (double *)(v70 + 40 * v71);
            if (v66)
              operator delete(v66);
          }
          else
          {
            *v64 = v92;
            v64[1] = v93;
            v64[2] = v60;
            v64[3] = v61;
            v65 = v64 + 5;
            v64[4] = v62;
          }
          a3[1] = v65;
          break;
        default:
          if (getScottyLog(void)::onceToken != -1)
            dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
          v55 = getScottyLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315138;
            v95 = "CalculateCrossoverCoeffs";
            _os_log_error_impl(&dword_1B5ED0000, v55, OS_LOG_TYPE_ERROR, "%s: Invalid or unhandled filter type", buf, 0xCu);
          }
          break;
      }
      v33 = 0;
      v17 = 1;
    }
    while ((v34 & 1) != 0);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<BiquadCoefficients>>(unint64_t a1)
{
  if (a1 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(40 * a1);
}

BOOL Crossover2f::IsLowCrossoverEnabled(Crossover2f *this)
{
  ParametricFilters *v2;

  v2 = (ParametricFilters *)*((_QWORD *)this + 1);
  return v2
      && *(_QWORD *)this
      && ParametricFilters::isEnabled(v2)
      && ParametricFilters::isEnabled(*(ParametricFilters **)this);
}

BOOL Crossover2f::IsHighCrossoverEnabled(Crossover2f *this)
{
  ParametricFilters *v2;

  v2 = (ParametricFilters *)*((_QWORD *)this + 3);
  return v2
      && *((_QWORD *)this + 2)
      && ParametricFilters::isEnabled(v2)
      && ParametricFilters::isEnabled(*((ParametricFilters **)this + 2));
}

void Crossover2f::SetLowCrossover(Crossover2f *this, double a2, int a3)
{
  NSObject *v6;
  _QWORD *v7;
  uint64_t v8;
  double v9;
  ParametricFilters *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *__p[3];
  void **v15;
  uint8_t buf[24];
  double v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (getScottyLog(void)::onceToken != -1)
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
  v6 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (_QWORD *)((char *)this + 48);
    if (*((char *)this + 71) < 0)
      v7 = (_QWORD *)*v7;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v7;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "SetLowCrossover";
    *(_WORD *)&buf[22] = 2048;
    v17 = a2;
    v18 = 1024;
    v19 = a3;
    _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting low crossover, inFC = %f, inOrder = %u", buf, 0x26u);
  }
  memset(buf, 0, sizeof(buf));
  memset(__p, 0, sizeof(__p));
  if (a2 > 0.0 && a3)
  {
    Crossover2f::CalculateCrossoverCoeffs(a3, (double **)buf, (double **)__p, *((double *)this + 5), a2);
    v8 = *((_QWORD *)this + 1);
    if (v8)
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      ParametricFilters::setParametricFilters(v8, __p, &v11);
      v15 = (void **)&v11;
      std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100](&v15);
    }
    v9 = *(double *)this;
    if (*(_QWORD *)this)
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      ParametricFilters::setParametricFilters(*(uint64_t *)&v9, buf, &v11);
      v15 = (void **)&v11;
      std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100](&v15);
    }
  }
  else
  {
    v10 = (ParametricFilters *)*((_QWORD *)this + 1);
    if (v10)
      ParametricFilters::clear(v10);
    if (*(_QWORD *)this)
      ParametricFilters::clear(*(ParametricFilters **)this);
  }
  if (__p[0])
    operator delete(__p[0]);
  if (*(_QWORD *)buf)
    operator delete(*(void **)buf);
}

void sub_1B616715C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  if (__p)
    operator delete(__p);
  if (a17)
    operator delete(a17);
  _Unwind_Resume(a1);
}

void Crossover2f::SetHighCrossover(Crossover2f *this, double a2, int a3)
{
  NSObject *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  ParametricFilters *v10;
  ParametricFilters *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *__p[3];
  void **v16;
  uint8_t buf[24];
  double v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (getScottyLog(void)::onceToken != -1)
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
  v6 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (_QWORD *)((char *)this + 48);
    if (*((char *)this + 71) < 0)
      v7 = (_QWORD *)*v7;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v7;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "SetHighCrossover";
    *(_WORD *)&buf[22] = 2048;
    v18 = a2;
    v19 = 1024;
    v20 = a3;
    _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting high crossover, inFC = %f, inOrder = %u", buf, 0x26u);
  }
  memset(buf, 0, sizeof(buf));
  memset(__p, 0, sizeof(__p));
  if (a2 > 0.0 && a3)
  {
    Crossover2f::CalculateCrossoverCoeffs(a3, (double **)buf, (double **)__p, *((double *)this + 5), a2);
    v8 = *((_QWORD *)this + 3);
    if (v8)
    {
      v12 = 0;
      v13 = 0;
      v14 = 0;
      ParametricFilters::setParametricFilters(v8, __p, &v12);
      v16 = (void **)&v12;
      std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100](&v16);
    }
    v9 = *((_QWORD *)this + 2);
    if (v9)
    {
      v12 = 0;
      v13 = 0;
      v14 = 0;
      ParametricFilters::setParametricFilters(v9, buf, &v12);
      v16 = (void **)&v12;
      std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100](&v16);
    }
  }
  else
  {
    v10 = (ParametricFilters *)*((_QWORD *)this + 2);
    if (v10)
      ParametricFilters::clear(v10);
    v11 = (ParametricFilters *)*((_QWORD *)this + 3);
    if (v11)
      ParametricFilters::clear(v11);
  }
  if (__p[0])
    operator delete(__p[0]);
  if (*(_QWORD *)buf)
    operator delete(*(void **)buf);
}

void sub_1B6167370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  if (__p)
    operator delete(__p);
  if (a17)
    operator delete(a17);
  _Unwind_Resume(a1);
}

uint64_t Crossover2f::Process(uint64_t this, float *const *a2, float **a3, float **a4, float **a5, int a6, vDSP_Length a7, int a8, float *const *a9)
{
  Crossover2f *v15;
  uint64_t v16;
  float *const *v17;
  uint64_t v18;

  if (*(_DWORD *)(this + 32) == a6)
  {
    v15 = (Crossover2f *)this;
    if (Crossover2f::IsLowCrossoverEnabled((Crossover2f *)this))
    {
      v16 = *((_QWORD *)v15 + 1);
      if (v16)
        ParametricFilters::process(v16, a2, a5, a7, 0);
      if (!a8)
      {
        this = Crossover2f::IsHighCrossoverEnabled(v15);
        v17 = a5;
        if ((this & 1) == 0)
          return this;
        goto LABEL_14;
      }
      v17 = a5;
      if (*(_QWORD *)v15)
      {
        ParametricFilters::process(*(_QWORD *)v15, a2, a3, a7, 0);
        v17 = a5;
      }
    }
    else
    {
      v17 = a2;
    }
    this = Crossover2f::IsHighCrossoverEnabled(v15);
    if ((this & 1) == 0)
      return this;
    if (a8)
    {
      v18 = *((_QWORD *)v15 + 3);
      if (v18)
        ParametricFilters::process(v18, v17, a4, a7, 0);
    }
LABEL_14:
    this = *((_QWORD *)v15 + 2);
    if (this)
      return ParametricFilters::process(this, v17, a5, a7, 0);
  }
  return this;
}

ParametricFilters *Crossover2f::Reset(ParametricFilters **this)
{
  NSObject *v2;
  _QWORD *v3;
  ParametricFilters *v4;
  ParametricFilters *v5;
  ParametricFilters *result;
  int v7;
  _QWORD *v8;
  __int16 v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (getScottyLog(void)::onceToken != -1)
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
  v2 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v3 = this + 6;
    if (*((char *)this + 71) < 0)
      v3 = (_QWORD *)*v3;
    v7 = 136315394;
    v8 = v3;
    v9 = 2080;
    v10 = "Reset";
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEFAULT, "[%s|%s] Resetting Crossover2f", (uint8_t *)&v7, 0x16u);
  }
  if (*this)
    ParametricFilters::reset(*this);
  v4 = this[1];
  if (v4)
    ParametricFilters::reset(v4);
  v5 = this[2];
  if (v5)
    ParametricFilters::reset(v5);
  result = this[3];
  if (result)
    return (ParametricFilters *)ParametricFilters::reset(result);
  return result;
}

void AUNeuralNet::~AUNeuralNet(AUNeuralNet *this)
{
  AUNeuralNet::~AUNeuralNet(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  VPTimeFreqConverter *v2;
  NSObject *v3;
  uint64_t v4;
  unint64_t v5;
  VPTimeFreqConverter *v6;
  NSObject *v7;
  NSObject *v8;
  _QWORD *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  _BYTE buf[12];
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E69C94B8;
  v2 = (VPTimeFreqConverter *)*((_QWORD *)this + 144);
  if (v2)
  {
    VPTimeFreqConverter::~VPTimeFreqConverter(v2);
    MEMORY[0x1BCC95CEC]();
    *((_QWORD *)this + 144) = 0;
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v3 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = this;
      _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEFAULT, "[%p] disposed mTimeFreqConverterInputDelayed", buf, 0xCu);
    }
  }
  v4 = *((_QWORD *)this + 145);
  if (*((_QWORD *)this + 146) != v4)
  {
    v5 = 0;
    do
    {
      v6 = *(VPTimeFreqConverter **)(v4 + 8 * v5);
      if (v6)
      {
        VPTimeFreqConverter::~VPTimeFreqConverter(v6);
        MEMORY[0x1BCC95CEC]();
        *(_QWORD *)(*((_QWORD *)this + 145) + 8 * v5) = 0;
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v7 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = this;
          v31 = 1024;
          v32 = v5;
          _os_log_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_DEFAULT, "[%p] disposed mTimeFreqConvertersOutput[%d]", buf, 0x12u);
        }
      }
      ++v5;
      v4 = *((_QWORD *)this + 145);
    }
    while (v5 < (*((_QWORD *)this + 146) - v4) >> 3);
  }
  if (getAUNeuralNetLog(void)::onceToken != -1)
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  v8 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = this;
    _os_log_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_DEFAULT, "[%p] destructed", buf, 0xCu);
  }
  v9 = (_QWORD *)*((_QWORD *)this + 173);
  if (v9)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v9);
    *((_QWORD *)this + 173) = 0;
  }
  *((_QWORD *)this + 174) = 0;
  *((_DWORD *)this + 344) = 0;
  v10 = (void *)*((_QWORD *)this + 165);
  if (v10)
  {
    *((_QWORD *)this + 166) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 160);
  if (v11)
  {
    *((_QWORD *)this + 161) = v11;
    operator delete(v11);
  }
  v12 = *((_QWORD *)this + 158);
  *((_QWORD *)this + 158) = 0;
  if (v12)
    std::default_delete<BlockProcessorLowDelay>::operator()[abi:ne180100](v12);
  std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)this + 157, 0);
  if (*((_BYTE *)this + 1232))
  {
    v13 = (void *)*((_QWORD *)this + 151);
    if (v13)
    {
      *((_QWORD *)this + 152) = v13;
      operator delete(v13);
    }
  }
  v14 = (const void *)*((_QWORD *)this + 150);
  if (v14)
    CFRelease(v14);
  v15 = (const void *)*((_QWORD *)this + 149);
  if (v15)
    CFRelease(v15);
  v16 = (const void *)*((_QWORD *)this + 148);
  if (v16)
    CFRelease(v16);
  v17 = (void *)*((_QWORD *)this + 145);
  if (v17)
  {
    *((_QWORD *)this + 146) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 141);
  if (v18)
  {
    *((_QWORD *)this + 142) = v18;
    operator delete(v18);
  }
  v19 = (void *)*((_QWORD *)this + 138);
  if (v19)
  {
    *((_QWORD *)this + 139) = v19;
    operator delete(v19);
  }
  v20 = (void *)*((_QWORD *)this + 135);
  if (v20)
  {
    *((_QWORD *)this + 136) = v20;
    operator delete(v20);
  }
  *(_QWORD *)buf = (char *)this + 1056;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  v21 = (void *)*((_QWORD *)this + 129);
  if (v21)
  {
    *((_QWORD *)this + 130) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 126);
  if (v22)
  {
    *((_QWORD *)this + 127) = v22;
    operator delete(v22);
  }
  v23 = (void *)*((_QWORD *)this + 123);
  if (v23)
  {
    *((_QWORD *)this + 124) = v23;
    operator delete(v23);
  }
  v24 = (void *)*((_QWORD *)this + 119);
  if (v24)
  {
    *((_QWORD *)this + 120) = v24;
    operator delete(v24);
  }
  v25 = (void *)*((_QWORD *)this + 116);
  if (v25)
  {
    *((_QWORD *)this + 117) = v25;
    operator delete(v25);
  }
  v26 = (void *)*((_QWORD *)this + 113);
  if (v26)
  {
    *((_QWORD *)this + 114) = v26;
    operator delete(v26);
  }
  v27 = (void *)*((_QWORD *)this + 110);
  if (v27)
  {
    *((_QWORD *)this + 111) = v27;
    operator delete(v27);
  }
  v28 = (void *)*((_QWORD *)this + 107);
  if (v28)
  {
    *((_QWORD *)this + 108) = v28;
    operator delete(v28);
  }
  v29 = (void *)*((_QWORD *)this + 104);
  if (v29)
  {
    *((_QWORD *)this + 105) = v29;
    operator delete(v29);
  }
  *(_QWORD *)buf = (char *)this + 800;
  std::vector<AUNeuralNet::NeuralNetWrapper>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 528);
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUNeuralNet::Initialize(AUNeuralNet *this)
{
  NSObject *v2;
  NSObject *v3;
  uint64_t Element;
  __int128 v5;
  AudioFormatFlags v6;
  NSObject *v7;
  uint64_t v8;
  const char *v9;
  uint8_t *v10;
  NSObject *v11;
  uint32_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  int v22;
  AudioFormatID v23;
  AudioFormatFlags v24;
  NSObject *v25;
  UInt32 mChannelsPerFrame;
  UInt32 v27;
  unsigned int v28;
  UInt32 v29;
  _BYTE *v30;
  AudioFormatFlags v31;
  AudioStreamBasicDescription *v32;
  NSObject *v33;
  _QWORD *v34;
  _DWORD *v35;
  __int128 v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  const void *v44;
  const __CFDictionary *v45;
  Float64 v46;
  __CFDictionary *MutableCopy;
  NSObject *v48;
  const __CFString *v49;
  Float64 v50;
  NSObject *v51;
  NSObject *v52;
  const char *v53;
  const void *v54;
  std::chrono::steady_clock::time_point v55;
  std::chrono::steady_clock::time_point v56;
  NSObject *v57;
  NSObject *v58;
  uint64_t v59;
  NSObject *v60;
  NSObject *v61;
  double v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  ausdk::AUElement **v65;
  float v66;
  NSObject *v67;
  NSObject *v68;
  NSObject *v69;
  double v70;
  uint64_t v71;
  ausdk::AUElement *v72;
  _QWORD *v73;
  float v74;
  uint64_t v75;
  NSObject *v76;
  NSObject *v77;
  unint64_t v78;
  NSObject *v79;
  NSObject *v80;
  uint64_t v81;
  NSObject *v82;
  NSObject *v83;
  AudioFormatFlags v84;
  NSObject *v85;
  NSObject *v86;
  AudioFormatFlags v87;
  NSObject *v88;
  NSObject *v89;
  AudioFormatFlags v90;
  NSObject *v91;
  NSObject *v92;
  AudioFormatFlags v93;
  NSObject *v94;
  unsigned int *v95;
  NSObject *v96;
  NSObject *v97;
  AudioFormatFlags v98;
  NSObject *v99;
  const __CFString *Value;
  const __CFString *v101;
  void **v102;
  __int128 v103;
  uint64_t v104;
  NSObject *v105;
  const char *v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  NSObject *v110;
  _QWORD *v111;
  BOOL v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  int v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  Float64 v123;
  NSObject *v124;
  uint64_t v125;
  int v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  AudioFormatFlags v130;
  UInt32 v131;
  UInt32 v132;
  UInt32 v133;
  std::runtime_error *exception;
  NSObject *v135;
  uint64_t v136;
  ausdk::AUElement *v137;
  AudioFormatFlags v138;
  NSObject *v139;
  ausdk::AUElement **v140;
  uint64_t v141;
  uint64_t v142;
  UInt32 v143;
  UInt32 v144;
  int v145;
  const char *v146;
  uint64_t v147;
  uint64_t v148;
  AudioFormatFlags v149;
  UInt32 v150;
  UInt32 v151;
  uint64_t v152;
  uint64_t v153;
  AudioFormatFlags v154;
  uint64_t v155;
  AudioFormatFlags v156;
  NSObject *v157;
  NSObject *v158;
  NSObject *v159;
  int v160;
  uint64_t v161;
  AudioFormatID mFormatID;
  AudioFormatFlags mFormatFlags;
  UInt32 mBitsPerChannel;
  uint64_t v165;
  NSObject *v166;
  AudioFormatFlags v167;
  UInt32 v168;
  uint64_t v169;
  unsigned int *v170;
  unsigned int v171;
  int v172;
  uint64_t v173;
  AudioFormatFlags v174;
  UInt32 v175;
  const char *v176;
  NSObject *v177;
  uint32_t v178;
  uint64_t v179;
  uint64_t v180;
  AudioFormatFlags v181;
  uint64_t v182;
  UInt32 v183;
  UInt32 v184;
  UInt32 v185;
  uint64_t v186;
  UInt32 v187;
  UInt32 v188;
  UInt32 v189;
  NSObject *v190;
  uint32_t v191;
  uint64_t v192;
  NSObject *v193;
  Float64 mSampleRate;
  uint64_t v195;
  AudioFormatFlags v196;
  uint64_t v197;
  ausdk::AUElement *v198;
  ausdk::AUElement **v199;
  uint64_t v200;
  uint64_t v201;
  float v202;
  float v203;
  float v204;
  uint64_t v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  NSObject *v209;
  void **v210;
  NSObject *v211;
  void *v212;
  uint64_t v213;
  ausdk::AUElement *v214;
  ausdk::AUElement **v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  float v219;
  unsigned int CurrentLatencyInSamples;
  uint64_t v221;
  ausdk::AUElement *v222;
  ausdk::AUElement **v223;
  NSObject *v224;
  uint64_t v225;
  _QWORD *v226;
  uint64_t v227;
  ausdk::AUElement *v228;
  ausdk::AUElement **v229;
  float Parameter;
  uint64_t v231;
  ausdk::AUElement *v232;
  ausdk::AUElement **v233;
  NSObject *v234;
  uint64_t v235;
  _QWORD *v236;
  uint64_t v237;
  ausdk::AUElement *v238;
  ausdk::AUElement **v239;
  float v240;
  uint64_t v241;
  AudioFormatFlags v242;
  UInt32 v243;
  _BOOL4 v244;
  const char *v245;
  NSObject *v246;
  uint32_t v247;
  NSObject *v248;
  uint64_t v249;
  uint64_t v250;
  _QWORD *v251;
  AudioFormatFlags v252;
  UInt32 v253;
  UInt32 v254;
  std::runtime_error *v255;
  std::runtime_error *v256;
  std::runtime_error *v257;
  std::runtime_error *v258;
  std::runtime_error *v259;
  std::runtime_error *v260;
  std::runtime_error *v261;
  __int128 v262;
  const void *v263;
  const void *v264;
  const __CFAllocator *allocator;
  _DWORD *v266;
  uint64_t v267;
  AudioFormatFlags *v268;
  int v269;
  const void *v270;
  Float64 v271;
  UInt32 v272;
  AudioStreamBasicDescription v273;
  int v274;
  AudioStreamBasicDescription buf;
  _BYTE v276[12];
  __int16 v277;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v278;
  char v279;
  AudioStreamBasicDescription v280;
  uint64_t v281;

  v281 = *MEMORY[0x1E0C80C00];
  *((_DWORD *)this + 136) = *((_DWORD *)this + 84);
  if (getAUNeuralNetLog(void)::onceToken != -1)
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  v2 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    v31 = *((_DWORD *)this + 136);
    LODWORD(v280.mSampleRate) = 134218240;
    *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
    LOWORD(v280.mFormatFlags) = 1024;
    *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v31;
    _os_log_debug_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "[%p] AU block size %u", (uint8_t *)&v280, 0x12u);
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  }
  v3 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(v280.mSampleRate) = 134217984;
    *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
    _os_log_debug_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEBUG, "[%p] check input format before initialization", (uint8_t *)&v280, 0xCu);
  }
  Element = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
  v5 = *(_OWORD *)(Element + 96);
  *(_OWORD *)&v273.mSampleRate = *(_OWORD *)(Element + 80);
  *(_OWORD *)&v273.mBytesPerPacket = v5;
  *(_QWORD *)&v273.mBitsPerChannel = *(_QWORD *)(Element + 112);
  v6 = HIDWORD(v5);
  *((_DWORD *)this + 164) = HIDWORD(v5);
  if (getAUNeuralNetLog(void)::onceToken != -1)
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  v7 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    v280 = v273;
    CA::StreamDescription::AsString((CA::StreamDescription *)&v280, (uint64_t)&buf, *(int16x8_t *)&v273.mBytesPerPacket);
    v32 = (buf.mFramesPerPacket & 0x80000000) == 0 ? &buf : *(AudioStreamBasicDescription **)&buf.mSampleRate;
    *(_DWORD *)v276 = 134218242;
    *(_QWORD *)&v276[4] = this;
    v277 = 2080;
    v278 = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)v32;
    _os_log_debug_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_DEBUG, "[%p] input format: %s", v276, 0x16u);
    if (SHIBYTE(buf.mFramesPerPacket) < 0)
      operator delete(*(void **)&buf.mSampleRate);
  }
  if (v273.mFormatID != 1819304813)
  {
    if (v273.mFormatID == 1718773105
      && (v273.mFormatFlags & 1) != 0
      && v273.mBitsPerChannel == 64
      && (v273.mFormatFlags & 0x20) != 0)
    {
      goto LABEL_14;
    }
LABEL_21:
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v13 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294956421;
    LODWORD(v280.mSampleRate) = 134217984;
    *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
    v9 = "[%p] input format is not valid";
    goto LABEL_89;
  }
  if ((v273.mFormatFlags & 1) == 0)
    goto LABEL_21;
LABEL_14:
  if (*((_DWORD *)this + 164) >= 0x11u)
  {
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v8 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294956421;
    LODWORD(v280.mSampleRate) = 134218496;
    *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
    LOWORD(v280.mFormatFlags) = 1024;
    *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v6;
    HIWORD(v280.mBytesPerPacket) = 1024;
    v280.mFramesPerPacket = 16;
    v9 = "[%p] input format has %d channels, which is more than the max number of (%d)";
LABEL_19:
    v10 = (uint8_t *)&v280;
    v11 = v8;
    v12 = 24;
    goto LABEL_91;
  }
  v266 = (_DWORD *)((char *)this + 656);
  if (getAUNeuralNetLog(void)::onceToken != -1)
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  v16 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(v280.mSampleRate) = 134217984;
    *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
    _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%p] check output format before initialization", (uint8_t *)&v280, 0xCu);
  }
  v17 = 0;
  v268 = (AudioFormatFlags *)((char *)this + 660);
  while (1)
  {
    v18 = *((_QWORD *)this + 21);
    if (v18)
      LODWORD(v19) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
    else
      v19 = (*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 3;
    if (v17 >= v19)
      break;
    if (v17 != 1)
    {
      if (v17)
        goto LABEL_63;
      v20 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0);
      v21 = *(double *)(v20 + 80);
      v23 = *(_DWORD *)(v20 + 88);
      v22 = *(_DWORD *)(v20 + 92);
      v271 = *(double *)(v20 + 96);
      v24 = *(_DWORD *)(v20 + 108);
      v272 = *(_DWORD *)(v20 + 104);
      v267 = *(_QWORD *)(v20 + 112);
      *v268 = v24;
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v25 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
      {
        v280 = v273;
        CA::StreamDescription::AsString((CA::StreamDescription *)&v280, (uint64_t)v276, *(int16x8_t *)&v273.mBytesPerPacket);
        v30 = v276;
        if (v279 < 0)
          v30 = *(_BYTE **)v276;
        LODWORD(buf.mSampleRate) = 134218498;
        *(_QWORD *)((char *)&buf.mSampleRate + 4) = this;
        LOWORD(buf.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&buf.mFormatFlags + 2) = 0;
        HIWORD(buf.mBytesPerPacket) = 2080;
        *(_QWORD *)&buf.mFramesPerPacket = v30;
        _os_log_debug_impl(&dword_1B5ED0000, v25, OS_LOG_TYPE_DEBUG, "[%p] output format for bus %u: %s", (uint8_t *)&buf, 0x1Cu);
        if (v279 < 0)
          operator delete(*(void **)v276);
      }
      if (v23 == 1819304813)
      {
        if ((v22 & 1) == 0)
          goto LABEL_323;
      }
      else if (v23 != 1718773105 || (v22 & 1) == 0 || (_DWORD)v267 != 64 || (v22 & 0x20) == 0)
      {
LABEL_323:
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v13 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          return 4294956421;
        LODWORD(v280.mSampleRate) = 134217984;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        v9 = "[%p] output format is not valid";
LABEL_89:
        v10 = (uint8_t *)&v280;
        goto LABEL_90;
      }
      if (*v268 >= 0x25)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v8 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          return 4294956421;
        LODWORD(v280.mSampleRate) = 134218496;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v24;
        HIWORD(v280.mBytesPerPacket) = 1024;
        v280.mFramesPerPacket = 36;
        v9 = "[%p] output format has %d channels, which is more than the max number of (%d)";
        goto LABEL_19;
      }
      v280 = v273;
      if ((v273.mFormatFlags & 0x20) != 0)
      {
        mChannelsPerFrame = 1;
      }
      else
      {
        mChannelsPerFrame = v280.mChannelsPerFrame;
        if (!v280.mChannelsPerFrame)
        {
          v27 = (v280.mBitsPerChannel + 7) >> 3;
LABEL_55:
          v28 = 1;
          v280.mBytesPerFrame = v27;
          v280.mChannelsPerFrame = 1;
          v280.mBytesPerPacket = v27;
          v280.mFramesPerPacket = 1;
          v280.mFormatFlags = v273.mFormatFlags | 0x20;
          buf.mSampleRate = v21;
          buf.mFormatID = v23;
          *(Float64 *)&buf.mBytesPerPacket = v271;
          buf.mBytesPerFrame = v272;
          *(_QWORD *)&buf.mBitsPerChannel = v267;
          if ((v22 & 0x20) != 0 || (v28 = v24) != 0)
            v29 = buf.mBytesPerFrame / v28;
          else
            v29 = (v267 + 7) >> 3;
          buf.mChannelsPerFrame = 1;
          buf.mFramesPerPacket = 1;
          buf.mBytesPerFrame = v29;
          buf.mBytesPerPacket = v29;
          buf.mFormatFlags = v22 | 0x20;
          if (v280.mSampleRate != v21
            || v280.mFormatID != v23
            || v27 != v29
            || v280.mBitsPerChannel != (_DWORD)v267
            || !CA::Implementation::EquivalentFormatFlags((CA::Implementation *)&v280, &buf, 0, 0))
          {
            if (getAUNeuralNetLog(void)::onceToken != -1)
              dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
            v13 = getAUNeuralNetLog(void)::gLog;
            if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
              return 4294956421;
            *(_DWORD *)v276 = 134217984;
            *(_QWORD *)&v276[4] = this;
            v9 = "[%p] I/O formats are not compatible.";
            v10 = v276;
LABEL_90:
            v11 = v13;
            v12 = 12;
LABEL_91:
            _os_log_error_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_ERROR, v9, v10, v12);
            return 4294956421;
          }
          goto LABEL_63;
        }
      }
      v27 = v280.mBytesPerFrame / mChannelsPerFrame;
      goto LABEL_55;
    }
    if (*(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 1u) + 108) >= 0x25u)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v8 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        return 4294956421;
      v138 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 1u) + 108);
      LODWORD(v280.mSampleRate) = 134218496;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v138;
      HIWORD(v280.mBytesPerPacket) = 1024;
      v280.mFramesPerPacket = 36;
      v9 = "[%p] output GainVector format has %d channels, which is more than the max number of (%d)";
      goto LABEL_19;
    }
LABEL_63:
    ++v17;
  }
  if (getAUNeuralNetLog(void)::onceToken != -1)
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  v33 = getAUNeuralNetLog(void)::gLog;
  v34 = &unk_1B6624000;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    LODWORD(v280.mSampleRate) = 134217984;
    *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
    _os_log_impl(&dword_1B5ED0000, v33, OS_LOG_TYPE_INFO, "[%p] will try to initialize", (uint8_t *)&v280, 0xCu);
  }
  ausdk::AUBufferList::Allocate((AUNeuralNet *)((char *)this + 1376), &v273, *((_DWORD *)this + 136));
  ausdk::AUBufferList::PrepareBuffer((AUNeuralNet *)((char *)this + 1376), &v273, *((_DWORD *)this + 136));
  v35 = (_DWORD *)ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
  if (v35[22] == 1718773105)
  {
    LOBYTE(v37) = 0;
    v38 = v35[23];
    if ((v38 & 1) != 0 && v35[28] == 64)
      v37 = (v38 >> 5) & 1;
  }
  else
  {
    LOBYTE(v37) = 0;
  }
  *((_BYTE *)this + 664) = v37;
  if (!*((_DWORD *)this + 206))
  {
LABEL_327:
    *((_DWORD *)this + 141) = 0;
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v135 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134218240;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = 0;
      _os_log_impl(&dword_1B5ED0000, v135, OS_LOG_TYPE_INFO, "[%p] Defaulting to NeuralNet model (%u) for processing.", (uint8_t *)&v280, 0x12u);
    }
    if (!*(_BYTE *)(*((_QWORD *)this + 100) + 96))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v139 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        goto LABEL_469;
      LODWORD(v280.mSampleRate) = v34[346];
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v139, OS_LOG_TYPE_INFO, "[%p] No NeuralNets were loaded from plist.", (uint8_t *)&v280, 0xCu);
      goto LABEL_467;
    }
    v136 = *((_QWORD *)this + 9);
    if (v136)
    {
      v137 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v136 + 32))(v136, 0);
    }
    else
    {
      v140 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v140)
        v137 = 0;
      else
        v137 = *v140;
    }
    ausdk::AUElement::SetParameter(v137, 0, 1.0, 0);
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v157 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = v34[346];
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v157, OS_LOG_TYPE_INFO, "[%p] Successfully loaded NeuralNet plist.", (uint8_t *)&v280, 0xCu);
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    }
    v158 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      v200 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 100) + 64) + 24))(*(_QWORD *)(*((_QWORD *)this + 100) + 64));
      LODWORD(v280.mSampleRate) = 134218240;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2048;
      *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v200;
      _os_log_debug_impl(&dword_1B5ED0000, v158, OS_LOG_TYPE_DEBUG, "[%p] mNeuralNet input size: %lu", (uint8_t *)&v280, 0x16u);
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    }
    v159 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      v201 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 100) + 64) + 32))(*(_QWORD *)(*((_QWORD *)this + 100) + 64));
      LODWORD(v280.mSampleRate) = 134218240;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2048;
      *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v201;
      _os_log_debug_impl(&dword_1B5ED0000, v159, OS_LOG_TYPE_DEBUG, "[%p] mNeuralNet output size: %lu", (uint8_t *)&v280, 0x16u);
    }
    v160 = *((_DWORD *)this + 136);
    v161 = *((_QWORD *)this + 100);
    mFormatID = v273.mFormatID;
    if (v160 == *(_DWORD *)(v161 + 20))
    {
      if (v273.mFormatID != 1718773105)
      {
LABEL_399:
        *((_BYTE *)this + 1244) = 0;
        if (*((_QWORD *)this + 157))
          std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)this + 157, 0);
        v165 = *((_QWORD *)this + 158);
        if (v165)
        {
          *((_QWORD *)this + 158) = 0;
          std::default_delete<BlockProcessorLowDelay>::operator()[abi:ne180100](v165);
        }
        goto LABEL_459;
      }
      mFormatFlags = v273.mFormatFlags;
      mBitsPerChannel = v273.mBitsPerChannel;
LABEL_392:
      if ((~mFormatFlags & 0x21) == 0
        && mBitsPerChannel == 64
        && v160 + 1 > (int)((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v161 + 64) + 24))(*(_QWORD *)(v161 + 64))
                          / (unint64_t)*(unsigned int *)(*((_QWORD *)this + 100) + 8)
                          + 1))
      {
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v13 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          return 4294956421;
        LODWORD(v280.mSampleRate) = v34[346];
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        v9 = "[%p] Truncate of freq domain data not allowed (except nyquist)";
        goto LABEL_89;
      }
      goto LABEL_399;
    }
    if (v273.mFormatID == 1718773105)
    {
      mFormatFlags = v273.mFormatFlags;
      if ((~v273.mFormatFlags & 0x21) == 0)
      {
        mBitsPerChannel = v273.mBitsPerChannel;
        if (v273.mBitsPerChannel == 64)
          goto LABEL_392;
      }
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v166 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      v167 = *((_DWORD *)this + 136);
      v168 = *(_DWORD *)(*((_QWORD *)this + 100) + 20);
      LODWORD(v280.mSampleRate) = 134218496;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v167;
      HIWORD(v280.mBytesPerPacket) = 1024;
      v280.mFramesPerPacket = v168;
      _os_log_impl(&dword_1B5ED0000, v166, OS_LOG_TYPE_INFO, "[%p] AU's block size (%d) not matching the NeuralNet's block size (%u). Will use a reblocker", (uint8_t *)&v280, 0x18u);
    }
    v169 = *((_QWORD *)this + 100);
    v171 = *(_DWORD *)(v169 + 20);
    v170 = (unsigned int *)(v169 + 20);
    v172 = *((_DWORD *)this + 312);
    if (*((_DWORD *)this + 136) > v171 && v172 == 2)
    {
      *((_DWORD *)this + 312) = 1;
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v173 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        goto LABEL_451;
      v174 = *((_DWORD *)this + 136);
      v175 = *(_DWORD *)(*((_QWORD *)this + 100) + 20);
      LODWORD(v280.mSampleRate) = 134218496;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v174;
      HIWORD(v280.mBytesPerPacket) = 1024;
      v280.mFramesPerPacket = v175;
      v176 = "[%p] Low Delay block processor not supported for process block size (%d) > NN block size (%d)";
      v177 = v173;
      v178 = 24;
    }
    else
    {
      if (v172 == 2)
      {
        v274 = 1;
        *(_QWORD *)&buf.mSampleRate = (char *)this + 656;
        v269 = 1;
        *(_QWORD *)v276 = (char *)this + 660;
        v271 = *(double *)&this;
        std::make_unique[abi:ne180100]<BlockProcessorLowDelay,int,unsigned int *,int,unsigned int *,unsigned int &,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUNeuralNet *>((uint64_t *)&v280, &v274, (const unsigned int **)&buf, &v269, (const unsigned int **)v276, (int *)this + 136, v170, (uint64_t *)&v271);
        mSampleRate = v280.mSampleRate;
        v195 = *((_QWORD *)this + 158);
        *((_QWORD *)this + 158) = *(_QWORD *)&v280.mSampleRate;
        if (v195)
          std::default_delete<BlockProcessorLowDelay>::operator()[abi:ne180100](v195);
        if (mSampleRate == 0.0)
          goto LABEL_451;
        *((_BYTE *)this + 1244) = 1;
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v180 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
          goto LABEL_451;
        v196 = *(_DWORD *)(*((_QWORD *)this + 158) + 92);
        LODWORD(v280.mSampleRate) = 134218240;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v196;
        v176 = "[%p] Using low delay block processor with delay = %d samples.";
      }
      else
      {
        if (v172 != 1)
          goto LABEL_451;
        v274 = 1;
        *(_QWORD *)&buf.mSampleRate = (char *)this + 656;
        v269 = 1;
        *(_QWORD *)v276 = (char *)this + 660;
        v271 = *(double *)&this;
        std::make_unique[abi:ne180100]<BlockProcessor,int,unsigned int *,int,unsigned int *,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUNeuralNet *>((BlockProcessor **)&v280, &v274, (const unsigned int **)&buf, &v269, (const unsigned int **)v276, (int *)v170, (void **)&v271);
        v179 = *(_QWORD *)&v280.mSampleRate;
        v280.mSampleRate = 0.0;
        std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)this + 157, v179);
        std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)&v280, 0);
        if (!*((_QWORD *)this + 157))
          goto LABEL_451;
        *((_BYTE *)this + 1244) = 1;
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v180 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
          goto LABEL_451;
        v181 = *(_DWORD *)(*((_QWORD *)this + 100) + 20);
        LODWORD(v280.mSampleRate) = 134218240;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v181;
        v176 = "[%p] Using legacy block processor with delay = %d samples.";
      }
      v177 = v180;
      v178 = 18;
    }
    _os_log_impl(&dword_1B5ED0000, v177, OS_LOG_TYPE_INFO, v176, (uint8_t *)&v280, v178);
LABEL_451:
    v197 = *((_QWORD *)this + 9);
    if (v197)
    {
      v198 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v197 + 32))(v197, 0);
    }
    else
    {
      v199 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v199)
        v198 = 0;
      else
        v198 = *v199;
    }
    ausdk::AUElement::SetParameter(v198, 0x11u, (float)*((unsigned int *)this + 312), 0);
LABEL_459:
    v202 = *((float *)this + 155);
    v203 = 0.0;
    if (v202 != 0.0)
    {
      v204 = **((double **)this + 100);
      v203 = expf((float)((float)-(float)*((unsigned int *)this + 136) / v204) / v202);
    }
    *((float *)this + 156) = v203;
    if (mFormatID == 1718773105)
    {
      v205 = *((_QWORD *)this + 100);
      if ((~v273.mFormatFlags & 0x21) == 0 && v273.mBitsPerChannel == 64)
      {
        v206 = (*(int (**)(_QWORD))(**(_QWORD **)(v205 + 64) + 24))(*(_QWORD *)(v205 + 64));
        LODWORD(v280.mSampleRate) = 0;
        std::vector<float>::assign((char **)this + 104, v206, &v280);
        LODWORD(v280.mSampleRate) = 0;
        std::vector<float>::assign((char **)this + 110, v206, &v280);
        goto LABEL_467;
      }
    }
    else
    {
      v205 = *((_QWORD *)this + 100);
    }
    v207 = (*(_DWORD *)(v205 + 20) * *((_DWORD *)this + 164));
    LODWORD(v280.mSampleRate) = 0;
    std::vector<float>::assign((char **)this + 104, v207, &v280);
    v208 = (*(_DWORD *)(*((_QWORD *)this + 100) + 20) * *((_DWORD *)this + 165));
    LODWORD(v280.mSampleRate) = 0;
    std::vector<float>::assign((char **)this + 110, v208, &v280);
LABEL_467:
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
LABEL_469:
    v209 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = v34[346];
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v209, OS_LOG_TYPE_INFO, "[%p] initialize mask related variables", (uint8_t *)&v280, 0xCu);
    }
    AUNeuralNet::InitMaskRelatedVariables(this);
    if (*((_BYTE *)this + 1232))
    {
      v210 = (void **)((char *)this + 1208);
      if (!*((_BYTE *)this + 592))
        goto LABEL_479;
      if (*((_QWORD *)this + 108) - *((_QWORD *)this + 107) != *((_QWORD *)this + 152) - *((_QWORD *)this + 151))
      {
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v216 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          return 4294956421;
        v217 = (uint64_t)(*((_QWORD *)this + 108) - *((_QWORD *)this + 107)) >> 2;
        v218 = (uint64_t)(*((_QWORD *)this + 152) - *((_QWORD *)this + 151)) >> 2;
        LODWORD(v280.mSampleRate) = 134218496;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 2048;
        *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v217;
        HIWORD(v280.mFramesPerPacket) = 2048;
        *(_QWORD *)&v280.mBytesPerFrame = v218;
        v9 = "[%p] cached embedding has mismatch size: %lu != %lu";
        v10 = (uint8_t *)&v280;
        v11 = v216;
        v12 = 32;
        goto LABEL_91;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v211 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        LODWORD(v280.mSampleRate) = v34[346];
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        _os_log_impl(&dword_1B5ED0000, v211, OS_LOG_TYPE_INFO, "[%p] loading cached embedding", (uint8_t *)&v280, 0xCu);
      }
      std::vector<float>::__move_assign((uint64_t)this + 856, (__n128 *)((char *)this + 1208));
      if (*((_BYTE *)this + 1232))
      {
LABEL_479:
        v212 = *v210;
        if (*v210)
        {
          *((_QWORD *)this + 152) = v212;
          operator delete(v212);
        }
        *((_BYTE *)this + 1232) = 0;
      }
    }
    v213 = *((_QWORD *)this + 9);
    if (v213)
    {
      v214 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v213 + 32))(v213, 0);
    }
    else
    {
      v215 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v215)
        v214 = 0;
      else
        v214 = *v215;
    }
    v219 = 0.0;
    if (*(_BYTE *)(*((_QWORD *)this + 100) + 96))
      v219 = 1.0;
    ausdk::AUElement::SetParameter(v214, 0, v219, 0);
    CurrentLatencyInSamples = AUNeuralNet::GetCurrentLatencyInSamples(this);
    *((_DWORD *)this + 245) = CurrentLatencyInSamples;
    v221 = *((_QWORD *)this + 9);
    if (v221)
    {
      v222 = (ausdk::AUElement *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v221 + 32))(*((_QWORD *)this + 9), 0);
      CurrentLatencyInSamples = *((_DWORD *)this + 245);
    }
    else
    {
      v223 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v223)
        v222 = 0;
      else
        v222 = *v223;
    }
    ausdk::AUElement::SetParameter(v222, 0xEu, (float)CurrentLatencyInSamples, 0);
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v224 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      v225 = *((_QWORD *)this + 100);
      v226 = (_QWORD *)(v225 + 32);
      if (*(char *)(v225 + 55) < 0)
        v226 = (_QWORD *)*v226;
      v227 = *((_QWORD *)this + 9);
      if (v227)
      {
        v228 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v227 + 32))(v227, 0);
      }
      else
      {
        v229 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v229)
          v228 = 0;
        else
          v228 = *v229;
      }
      Parameter = ausdk::AUElement::GetParameter(v228, 0xEu);
      LODWORD(v280.mSampleRate) = 134218498;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2080;
      *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v226;
      HIWORD(v280.mFramesPerPacket) = 2048;
      *(double *)&v280.mBytesPerFrame = Parameter;
      _os_log_impl(&dword_1B5ED0000, v224, OS_LOG_TYPE_DEFAULT, "[%p] Latency for model: %s is %f", (uint8_t *)&v280, 0x20u);
    }
    v231 = *((_QWORD *)this + 9);
    if (v231)
    {
      v232 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v231 + 32))(v231, 0);
    }
    else
    {
      v233 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v233)
        v232 = 0;
      else
        v232 = *v233;
    }
    ausdk::AUElement::SetParameter(v232, 0x12u, (float)*(unsigned int *)(*((_QWORD *)this + 100) + 20), 0);
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v234 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      v235 = *((_QWORD *)this + 100);
      v236 = (_QWORD *)(v235 + 32);
      if (*(char *)(v235 + 55) < 0)
        v236 = (_QWORD *)*v236;
      v237 = *((_QWORD *)this + 9);
      if (v237)
      {
        v238 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v237 + 32))(v237, 0);
      }
      else
      {
        v239 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v239)
          v238 = 0;
        else
          v238 = *v239;
      }
      v240 = ausdk::AUElement::GetParameter(v238, 0x12u);
      LODWORD(v280.mSampleRate) = 134218498;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2080;
      *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v236;
      HIWORD(v280.mFramesPerPacket) = 2048;
      *(double *)&v280.mBytesPerFrame = v240;
      _os_log_impl(&dword_1B5ED0000, v234, OS_LOG_TYPE_DEFAULT, "[%p] Block size for model: %s is %f", (uint8_t *)&v280, 0x20u);
    }
    if (!*((_DWORD *)this + 167)
      && *((_BYTE *)this + 672)
      && *(_BYTE *)(*((_QWORD *)this + 100) + 104 * *((unsigned int *)this + 141) + 96))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v249 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
        goto LABEL_532;
      v250 = *((_QWORD *)this + 100) + 104 * *((unsigned int *)this + 141);
      v251 = (_QWORD *)(v250 + 32);
      if (*(char *)(v250 + 55) < 0)
        v251 = (_QWORD *)*v251;
      LODWORD(v280.mSampleRate) = 134218242;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2080;
      *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v251;
      v245 = "[%p] Model with TaskID (%s) will be called";
      v246 = v249;
      v247 = 22;
    }
    else
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v241 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
        goto LABEL_532;
      v242 = *((_DWORD *)this + 167);
      v243 = *((_BYTE *)this + 672) == 0;
      v244 = *(_BYTE *)(*((_QWORD *)this + 100) + 104 * *((unsigned int *)this + 141) + 96) == 0;
      LODWORD(v280.mSampleRate) = 134218752;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v242;
      HIWORD(v280.mBytesPerPacket) = 1024;
      v280.mFramesPerPacket = v243;
      LOWORD(v280.mBytesPerFrame) = 1024;
      *(UInt32 *)((char *)&v280.mBytesPerFrame + 2) = v244;
      v245 = "[%p] Model bypassed: mBypass (%u) || !mSelectedValidModel (%d) || !selectedNeuralNet.model (%d)";
      v246 = v241;
      v247 = 30;
    }
    _os_log_impl(&dword_1B5ED0000, v246, OS_LOG_TYPE_DEFAULT, v245, (uint8_t *)&v280, v247);
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
LABEL_532:
    v248 = getAUNeuralNetLog(void)::gLog;
    v14 = 0;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v280.mSampleRate) = v34[346];
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v248, OS_LOG_TYPE_DEFAULT, "[%p] did initialize", (uint8_t *)&v280, 0xCu);
      return 0;
    }
    return v14;
  }
  v39 = 0;
  v40 = 0;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v263 = (const void *)*MEMORY[0x1E0C9AE40];
  v264 = (const void *)*MEMORY[0x1E0C9AE50];
  *(_QWORD *)&v36 = 134218754;
  v262 = v36;
  while (1)
  {
    v41 = *((_QWORD *)this + 100);
    if (!*(_BYTE *)(v41 + v39 + 96) && *(_QWORD *)(v41 + v39 + 56))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v42 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        LODWORD(v280.mSampleRate) = 134218240;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v40;
        _os_log_impl(&dword_1B5ED0000, v42, OS_LOG_TYPE_INFO, "[%p] Creating NeuralNet model (%d)", (uint8_t *)&v280, 0x12u);
      }
      v43 = *((_QWORD *)this + 100) + v39;
      v44 = *(const void **)(v43 + 56);
      if (v44)
      {
        CFRetain(*(CFTypeRef *)(v43 + 56));
        v270 = v44;
        CFRetain(v44);
        v45 = (const __CFDictionary *)v44;
      }
      else
      {
        v45 = 0;
        v270 = 0;
      }
      v271 = *(double *)&v44;
      if (*((_QWORD *)this + 148) || *((_QWORD *)this + 150) || (v46 = *(double *)&v44, *((_BYTE *)this + 1401)))
      {
        MutableCopy = CFDictionaryCreateMutableCopy(allocator, 0, v45);
        if (*((_QWORD *)this + 148))
        {
          if (getAUNeuralNetLog(void)::onceToken != -1)
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
          v48 = getAUNeuralNetLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
          {
            v49 = (const __CFString *)*((_QWORD *)this + 148);
            if (!v49)
            {
              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(exception, "Could not construct");
            }
            applesauce::CF::convert_to<std::string,0>(v49, (uint64_t)&buf);
            v50 = COERCE_DOUBLE(&buf);
            if ((buf.mFramesPerPacket & 0x80000000) != 0)
              v50 = buf.mSampleRate;
            *(_DWORD *)v276 = 134218242;
            *(_QWORD *)&v276[4] = this;
            v277 = 2080;
            v278 = *(_QWORD *)&v50;
            _os_log_impl(&dword_1B5ED0000, v48, OS_LOG_TYPE_INFO, "[%p] override 'ModelNetPathBaseOverride' to \"%s\"", v276, 0x16u);
            if (SHIBYTE(buf.mFramesPerPacket) < 0)
              operator delete(*(void **)&buf.mSampleRate);
          }
          CFDictionarySetValue(MutableCopy, CFSTR("ModelNetPathBase"), *((const void **)this + 148));
        }
        if (*((_QWORD *)this + 150))
        {
          if (getAUNeuralNetLog(void)::onceToken != -1)
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
          v51 = getAUNeuralNetLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
          {
            LODWORD(buf.mSampleRate) = 134217984;
            *(_QWORD *)((char *)&buf.mSampleRate + 4) = this;
            _os_log_impl(&dword_1B5ED0000, v51, OS_LOG_TYPE_INFO, "[%p] set 'mModelNetBNNSData'", (uint8_t *)&buf, 0xCu);
          }
          CFDictionarySetValue(MutableCopy, CFSTR("bnnsdict"), *((const void **)this + 150));
        }
        if (*((_BYTE *)this + 1401))
        {
          if (getAUNeuralNetLog(void)::onceToken != -1)
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
          v52 = getAUNeuralNetLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
          {
            if (!*((_BYTE *)this + 1401))
              std::__throw_bad_optional_access[abi:ne180100]();
            v53 = "true";
            if (!*((_BYTE *)this + 1400))
              v53 = "false";
            LODWORD(buf.mSampleRate) = 134218242;
            *(_QWORD *)((char *)&buf.mSampleRate + 4) = this;
            LOWORD(buf.mFormatFlags) = 2080;
            *(_QWORD *)((char *)&buf.mFormatFlags + 2) = v53;
            _os_log_impl(&dword_1B5ED0000, v52, OS_LOG_TYPE_INFO, "[%p] set 'mEnableImplementationCache' to %s", (uint8_t *)&buf, 0x16u);
          }
          if (!*((_BYTE *)this + 1401))
            std::__throw_bad_optional_access[abi:ne180100]();
          if (*((_BYTE *)this + 1400))
            v54 = v264;
          else
            v54 = v263;
          CFDictionarySetValue(MutableCopy, CFSTR("CacheImplementation"), v54);
        }
        applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&buf, MutableCopy);
        v46 = buf.mSampleRate;
        v271 = buf.mSampleRate;
        *(_QWORD *)&buf.mSampleRate = v44;
        if (v44)
          CFRelease(v44);
      }
      v55.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
      if (AUNeuralNetLogScope(void)::once != -1)
        dispatch_once(&AUNeuralNetLogScope(void)::once, &__block_literal_global_1862);
      NeuralNet::NeuralNet((uint64_t)&buf, *(CFDictionaryRef *)&v46, (uint64_t *)AUNeuralNetLogScope(void)::scope);
      v56.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v57 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)v276 = 134218240;
        *(_QWORD *)&v276[4] = this;
        v277 = 2048;
        v278 = (v56.__d_.__rep_ - v55.__d_.__rep_) / 1000000;
        _os_log_impl(&dword_1B5ED0000, v57, OS_LOG_TYPE_INFO, "[%p] created NeuralNet instance in %lld milliseconds", v276, 0x16u);
      }
      v280.mSampleRate = buf.mSampleRate;
      *(_OWORD *)&v280.mFormatID = *(_OWORD *)&buf.mFormatID;
      *(_QWORD *)&v280.mBytesPerFrame = *(_QWORD *)&buf.mBytesPerFrame;
      buf.mSampleRate = 0.0;
      *(_QWORD *)&buf.mBytesPerFrame = 0;
      LOBYTE(v280.mBitsPerChannel) = 1;
      NeuralNet::~NeuralNet((NeuralNet *)&buf);
      if (v46 != 0.0)
        CFRelease(*(CFTypeRef *)&v46);
      v34 = (_QWORD *)&unk_1B6624000;
      std::__optional_storage_base<NeuralNet,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<NeuralNet,false>>((NeuralNet *)(*((_QWORD *)this + 100) + v39 + 64), (uint64_t *)&v280);
      if (LOBYTE(v280.mBitsPerChannel))
        NeuralNet::~NeuralNet((NeuralNet *)&v280);
      if (v44)
        CFRelease(v44);
      v41 = *((_QWORD *)this + 100);
      if (!*(_BYTE *)(v41 + v39 + 96))
        return 4294956421;
    }
    if (AUNeuralNetLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetLogScope(void)::once, &__block_literal_global_1862);
    *(_QWORD *)&buf.mSampleRate = AUNeuralNetLogScope(void)::scope;
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v58 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v58, OS_LOG_TYPE_INFO, "[%p] Loading embedding mode from plist.", (uint8_t *)&v280, 0xCu);
    }
    LODWORD(v271) = 0;
    v59 = v41 + v39;
    if (!DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v41 + v39 + 56), CFSTR("EmbeddingMode"), &v271))
    {
      *((_BYTE *)this + 592) = LODWORD(v271) != 0;
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v61 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        if (*((_BYTE *)this + 592))
          v62 = 1.0;
        else
          v62 = 0.0;
        LODWORD(v280.mSampleRate) = 134218240;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 2048;
        *(double *)((char *)&v280.mFormatFlags + 2) = v62;
        _os_log_impl(&dword_1B5ED0000, v61, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved embedding mode (%g).", (uint8_t *)&v280, 0x16u);
      }
      v63 = *((_QWORD *)this + 9);
      if (v63)
      {
        v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v63 + 32))(v63, 0);
      }
      else
      {
        v65 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v65)
          v64 = 0;
        else
          v64 = *v65;
      }
      if (*((_BYTE *)this + 592))
        v66 = 1.0;
      else
        v66 = 0.0;
      ausdk::AUElement::SetParameter(v64, 0xCu, v66, 0);
      goto LABEL_178;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v60 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v60, OS_LOG_TYPE_INFO, "[%p] Failed to retrieve embedding mode", (uint8_t *)&v280, 0xCu);
LABEL_178:
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    }
    v67 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v67, OS_LOG_TYPE_INFO, "[%p] Loading default embedding mode from plist.", (uint8_t *)&v280, 0xCu);
    }
    v274 = 0;
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v59 + 56), CFSTR("DefaultEmbeddingMode"), &v274))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v68 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        if (!*((_BYTE *)this + 592))
          goto LABEL_217;
        goto LABEL_208;
      }
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v68, OS_LOG_TYPE_INFO, "[%p] Failed to retrieve default embedding mode", (uint8_t *)&v280, 0xCu);
    }
    else
    {
      *((_BYTE *)this + 593) = v274 != 0;
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v69 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        if (*((_BYTE *)this + 593))
          v70 = 1.0;
        else
          v70 = 0.0;
        LODWORD(v280.mSampleRate) = 134218240;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 2048;
        *(double *)((char *)&v280.mFormatFlags + 2) = v70;
        _os_log_impl(&dword_1B5ED0000, v69, OS_LOG_TYPE_INFO, "[%p] Successfully default retrieved embedding mode (%g).", (uint8_t *)&v280, 0x16u);
      }
      v71 = *((_QWORD *)this + 9);
      if (v71)
      {
        v72 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v71 + 32))(v71, 0);
      }
      else
      {
        v73 = (_QWORD *)*((_QWORD *)this + 6);
        v72 = *((_QWORD **)this + 7) == v73 ? 0 : (ausdk::AUElement *)*v73;
      }
      v74 = *((_BYTE *)this + 593) ? 1.0 : 0.0;
      ausdk::AUElement::SetParameter(v72, 0xDu, v74, 0);
    }
    v75 = getAUNeuralNetLog(void)::onceToken;
    if (!*((_BYTE *)this + 592))
      goto LABEL_215;
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
LABEL_208:
    v76 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v76, OS_LOG_TYPE_INFO, "[%p] Loading embedding size from plist.", (uint8_t *)&v280, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v59 + 56), CFSTR("EmbeddingSize"), (_DWORD *)(v41 + v39 + 28)))
    {
      v260 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve embedding size. err = %d", (uint64_t)&v280, 4294900555);
      std::runtime_error::runtime_error(v260, (const std::string *)&v280);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v77 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v78) = *(_DWORD *)(v41 + v39 + 28);
      LODWORD(v280.mSampleRate) = 134218240;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2048;
      *(double *)((char *)&v280.mFormatFlags + 2) = (double)v78;
      _os_log_impl(&dword_1B5ED0000, v77, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved embedding size (%g).", (uint8_t *)&v280, 0x16u);
      v75 = getAUNeuralNetLog(void)::onceToken;
LABEL_215:
      if (v75 != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    }
LABEL_217:
    v79 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v79, OS_LOG_TYPE_INFO, "[%p] Loading sample rate from plist.", (uint8_t *)&v280, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<double>((NSObject ***)&buf, *(CFDictionaryRef *)(v59 + 56), CFSTR("SampleRate"), (uint64_t *)(v41 + v39)))
    {
      v255 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve sample rate. err = %d", (uint64_t)&v280, 4294900555);
      std::runtime_error::runtime_error(v255, (const std::string *)&v280);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v80 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      v81 = *(_QWORD *)(v41 + v39);
      LODWORD(v280.mSampleRate) = 134218240;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2048;
      *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v81;
      _os_log_impl(&dword_1B5ED0000, v80, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved sample rate (%g Hz).", (uint8_t *)&v280, 0x16u);
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    }
    v82 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v82, OS_LOG_TYPE_INFO, "[%p] Loading number of input channels from plist.", (uint8_t *)&v280, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v59 + 56), CFSTR("NumberOfInputChannels"), (_DWORD *)(v41 + v39 + 8)))
    {
      v256 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve number of input channels. err = %d", (uint64_t)&v280, 4294900555);
      std::runtime_error::runtime_error(v256, (const std::string *)&v280);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v83 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      v84 = *(_DWORD *)(v41 + v39 + 8);
      LODWORD(v280.mSampleRate) = 134218240;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v84;
      _os_log_impl(&dword_1B5ED0000, v83, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved number of input channels (%u).", (uint8_t *)&v280, 0x12u);
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    }
    v85 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v85, OS_LOG_TYPE_INFO, "[%p] Loading number of output channels from plist.", (uint8_t *)&v280, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v59 + 56), CFSTR("NumberOfOutputChannels"), (_DWORD *)(v41 + v39 + 12)))
    {
      v257 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve number of output channels. err = %d", (uint64_t)&v280, 4294900555);
      std::runtime_error::runtime_error(v257, (const std::string *)&v280);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v86 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      v87 = *(_DWORD *)(v41 + v39 + 12);
      LODWORD(v280.mSampleRate) = 134218240;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v87;
      _os_log_impl(&dword_1B5ED0000, v86, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved number of output channels (%u).", (uint8_t *)&v280, 0x12u);
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    }
    v88 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v88, OS_LOG_TYPE_INFO, "[%p] Loading lookahead size from plist.", (uint8_t *)&v280, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v59 + 56), CFSTR("LookaheadSize"), (_DWORD *)(v41 + v39 + 16)))
    {
      v258 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve lookahead size. err = %d", (uint64_t)&v280, 4294900555);
      std::runtime_error::runtime_error(v258, (const std::string *)&v280);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v89 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      v90 = *(_DWORD *)(v41 + v39 + 16);
      LODWORD(v280.mSampleRate) = 134218240;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v90;
      _os_log_impl(&dword_1B5ED0000, v89, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved lookahead size (%u).", (uint8_t *)&v280, 0x12u);
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    }
    v91 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v91, OS_LOG_TYPE_INFO, "[%p] Loading block size from plist.", (uint8_t *)&v280, 0xCu);
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v59 + 56), CFSTR("BlockSize"), (_DWORD *)(v41 + v39 + 20)))
    {
      v259 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      caulk::make_string((caulk *)"Failed to retrieve block size. err = %d", (uint64_t)&v280, 4294900555);
      std::runtime_error::runtime_error(v259, (const std::string *)&v280);
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v92 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      v93 = *(_DWORD *)(v41 + v39 + 20);
      LODWORD(v280.mSampleRate) = 134218240;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v93;
      _os_log_impl(&dword_1B5ED0000, v92, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved block size (%u).", (uint8_t *)&v280, 0x12u);
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    }
    v94 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v94, OS_LOG_TYPE_INFO, "[%p] Loading batch size from plist.", (uint8_t *)&v280, 0xCu);
    }
    v95 = (unsigned int *)(v41 + v39 + 24);
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, *(CFDictionaryRef *)(v59 + 56), CFSTR("BatchSize"), v95))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v96 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        LODWORD(v280.mSampleRate) = 134217984;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        _os_log_impl(&dword_1B5ED0000, v96, OS_LOG_TYPE_INFO, "[%p] Failed to retrieve batch size, default to 1.", (uint8_t *)&v280, 0xCu);
      }
      *v95 = 1;
    }
    else
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v97 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        v98 = *v95;
        LODWORD(v280.mSampleRate) = 134218240;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v98;
        _os_log_impl(&dword_1B5ED0000, v97, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved batch size (%u).", (uint8_t *)&v280, 0x12u);
      }
      if (!*v95)
      {
        v261 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        caulk::make_string((caulk *)"Failed to retrieve sample rate. err = %d batchsize = %u", (uint64_t)&v280, 4294900553, *v95, v262);
        std::runtime_error::runtime_error(v261, (const std::string *)&v280);
      }
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v99 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(v280.mSampleRate) = 134217984;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      _os_log_impl(&dword_1B5ED0000, v99, OS_LOG_TYPE_INFO, "[%p] Loading task ID.", (uint8_t *)&v280, 0xCu);
    }
    Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v59 + 56), CFSTR("TaskID"));
    v101 = Value;
    if (Value)
    {
      CFRetain(Value);
      *(_QWORD *)v276 = v101;
      applesauce::CF::convert_to<std::string,0>(v101, (uint64_t)&v280);
      v102 = (void **)(v41 + v39 + 32);
      if (*(char *)(v41 + v39 + 55) < 0)
        operator delete(*v102);
      v103 = *(_OWORD *)&v280.mSampleRate;
      *(_QWORD *)(v41 + v39 + 48) = *(_QWORD *)&v280.mBytesPerPacket;
      *(_OWORD *)v102 = v103;
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v104 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        LODWORD(v280.mSampleRate) = 134217984;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        v105 = v104;
        v106 = "[%p] TaskID read from the plist.";
        goto LABEL_288;
      }
    }
    else
    {
      *(_QWORD *)v276 = 0;
      v107 = v41 + v39;
      v108 = (_QWORD *)(v41 + v39 + 32);
      if (*(char *)(v41 + v39 + 55) < 0)
      {
        *(_QWORD *)(v107 + 40) = 3;
        v108 = (_QWORD *)*v108;
      }
      else
      {
        *(_BYTE *)(v107 + 55) = 3;
      }
      *(_DWORD *)v108 = 4271950;
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v109 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        LODWORD(v280.mSampleRate) = 134217984;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        v105 = v109;
        v106 = "[%p] TaskID not available in the plist.";
LABEL_288:
        _os_log_impl(&dword_1B5ED0000, v105, OS_LOG_TYPE_INFO, v106, (uint8_t *)&v280, 0xCu);
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      }
    }
    v110 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      v111 = (_QWORD *)(v41 + v39 + 32);
      if (*(char *)(v41 + v39 + 55) < 0)
        v111 = (_QWORD *)*v111;
      LODWORD(v280.mSampleRate) = 134218242;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2080;
      *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v111;
      _os_log_impl(&dword_1B5ED0000, v110, OS_LOG_TYPE_INFO, "[%p] TaskID set to (%s).", (uint8_t *)&v280, 0x16u);
    }
    if (v101)
      CFRelease(v101);
    v112 = *((_BYTE *)this + 664) == 0;
    v113 = *((_QWORD *)this + 100);
    v114 = v113 + v39;
    v115 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v113 + v39 + 64) + 24))(*(_QWORD *)(v113 + v39 + 64));
    v116 = *(_DWORD *)(v113 + v39 + 8);
    v117 = v113 + v39;
    if (!v112)
    {
      if (v115 > (2 * (v116 + v116 * *(_DWORD *)(v117 + 20)) * *(_DWORD *)(v117 + 24)))
      {
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v141 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          goto LABEL_440;
        v142 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v114 + 64) + 24))(*(_QWORD *)(v114 + 64));
        v143 = *(_DWORD *)(v114 + 8);
        v144 = *(_DWORD *)(v117 + 24);
        v145 = *(_DWORD *)(v117 + 20) + 1;
        LODWORD(v280.mSampleRate) = 134219008;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 2048;
        *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v142;
        HIWORD(v280.mFramesPerPacket) = 1024;
        v280.mBytesPerFrame = v143;
        LOWORD(v280.mChannelsPerFrame) = 1024;
        *(UInt32 *)((char *)&v280.mChannelsPerFrame + 2) = v145;
        HIWORD(v280.mBitsPerChannel) = 1024;
        v280.mReserved = v144;
        v146 = "[%p] NeuralNet input size (%zu) exceeds freq domain format size: input channels (%u) num bins (%u) batch size (%u).";
        goto LABEL_428;
      }
      v118 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v114 + 64) + 32))(*(_QWORD *)(v114 + 64));
      v119 = v40;
      v120 = v113 + v39;
      v121 = *(_DWORD *)(v113 + v39 + 12);
      v122 = *(_DWORD *)(v117 + 24);
      if (v118 <= (2 * (v121 + v121 * *(_DWORD *)(v117 + 20)) * v122))
      {
        v123 = v273.mSampleRate;
        if (v273.mSampleRate == *(double *)(v113 + v39))
        {
          if (*(_DWORD *)(v114 + 8) * v122 == 2 * *v266)
          {
            if (v122 * v121 == 2 * *v268)
            {
              if (getAUNeuralNetLog(void)::onceToken != -1)
                dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
              v124 = getAUNeuralNetLog(void)::gLog;
              if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
                goto LABEL_319;
              goto LABEL_314;
            }
            if (getAUNeuralNetLog(void)::onceToken != -1)
              dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
            v148 = getAUNeuralNetLog(void)::gLog;
            if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
            {
LABEL_440:
              v193 = getAUNeuralNetLog(void)::gLog;
              v14 = 4294956421;
              if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
              {
                LODWORD(v280.mSampleRate) = 134218240;
                *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
                LOWORD(v280.mFormatFlags) = 1024;
                *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = -10875;
                _os_log_error_impl(&dword_1B5ED0000, v193, OS_LOG_TYPE_ERROR, "[%p] Could not create NeuralNet model using the plist, exception (%d)", (uint8_t *)&v280, 0x12u);
              }
              return v14;
            }
            goto LABEL_542;
          }
          if (getAUNeuralNetLog(void)::onceToken != -1)
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
          v148 = getAUNeuralNetLog(void)::gLog;
          if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
            goto LABEL_440;
LABEL_363:
          v149 = *(_DWORD *)(v114 + 8);
          v150 = *(_DWORD *)(v117 + 24);
          v151 = *((_DWORD *)this + 164);
          LODWORD(v280.mSampleRate) = 134218752;
          *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
          LOWORD(v280.mFormatFlags) = 1024;
          *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v149;
          HIWORD(v280.mBytesPerPacket) = 1024;
          v280.mFramesPerPacket = v150;
          LOWORD(v280.mBytesPerFrame) = 1024;
          *(UInt32 *)((char *)&v280.mBytesPerFrame + 2) = v151;
          v146 = "[%p] NeuralNet's number of input channels (%u) times batch size (%u) not matching AU's number of input channels (%u).";
LABEL_543:
          v190 = v148;
          v191 = 30;
LABEL_544:
          _os_log_error_impl(&dword_1B5ED0000, v190, OS_LOG_TYPE_ERROR, v146, (uint8_t *)&v280, v191);
          if (getAUNeuralNetLog(void)::onceToken != -1)
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
          goto LABEL_440;
        }
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v147 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          goto LABEL_440;
LABEL_432:
        v192 = *(_QWORD *)(v113 + v39);
        LODWORD(v280.mSampleRate) = 134218496;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 2048;
        *(Float64 *)((char *)&v280.mFormatFlags + 2) = v123;
        HIWORD(v280.mFramesPerPacket) = 2048;
        *(_QWORD *)&v280.mBytesPerFrame = v192;
        v146 = "[%p] Current input sample rate (%g Hz) not matching NeuralNet sample rate (%g).";
        v190 = v147;
        v191 = 32;
        goto LABEL_544;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v141 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        goto LABEL_440;
      goto LABEL_427;
    }
    if (v115 != *(_DWORD *)(v117 + 20) * v116 * *(_DWORD *)(v117 + 24))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v141 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        goto LABEL_440;
      v182 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v114 + 64) + 24))(*(_QWORD *)(v114 + 64));
      v183 = *(_DWORD *)(v114 + 8);
      v184 = *(_DWORD *)(v117 + 20);
      v185 = *(_DWORD *)(v117 + 24);
      LODWORD(v280.mSampleRate) = 134219008;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2048;
      *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v182;
      HIWORD(v280.mFramesPerPacket) = 1024;
      v280.mBytesPerFrame = v183;
      LOWORD(v280.mChannelsPerFrame) = 1024;
      *(UInt32 *)((char *)&v280.mChannelsPerFrame + 2) = v184;
      HIWORD(v280.mBitsPerChannel) = 1024;
      v280.mReserved = v185;
      v146 = "[%p] NeuralNet input size (%zu) not matching configured number of input channels (%u) times block size (%u)"
             " times batch size (%u).";
      goto LABEL_428;
    }
    v125 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v114 + 64) + 32))(*(_QWORD *)(v114 + 64));
    v119 = v40;
    v120 = v113 + v39;
    v126 = *(_DWORD *)(v117 + 24);
    v127 = v126 * *(_DWORD *)(v113 + v39 + 12);
    if (v125 != v127 * *(_DWORD *)(v117 + 20))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v141 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        goto LABEL_440;
LABEL_427:
      v186 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v114 + 64) + 32))(*(_QWORD *)(v114 + 64));
      v187 = *(_DWORD *)(v120 + 12);
      v188 = *(_DWORD *)(v117 + 20);
      v189 = *(_DWORD *)(v117 + 24);
      LODWORD(v280.mSampleRate) = 134219008;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 2048;
      *(_QWORD *)((char *)&v280.mFormatFlags + 2) = v186;
      HIWORD(v280.mFramesPerPacket) = 1024;
      v280.mBytesPerFrame = v187;
      LOWORD(v280.mChannelsPerFrame) = 1024;
      *(UInt32 *)((char *)&v280.mChannelsPerFrame + 2) = v188;
      HIWORD(v280.mBitsPerChannel) = 1024;
      v280.mReserved = v189;
      v146 = "[%p] NeuralNet output size (%zu) not matching configured number of output channels (%u) times block size (%"
             "u) times batch size (%u).";
LABEL_428:
      v190 = v141;
      v191 = 40;
      goto LABEL_544;
    }
    v123 = v273.mSampleRate;
    if (v273.mSampleRate != *(double *)(v113 + v39))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v147 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        goto LABEL_440;
      goto LABEL_432;
    }
    if (*v266 != *(_DWORD *)(v114 + 8) * v126)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v148 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        goto LABEL_440;
      goto LABEL_363;
    }
    if (*v268 != v127)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v148 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        goto LABEL_440;
LABEL_542:
      v252 = *(_DWORD *)(v113 + v39 + 12);
      v253 = *(_DWORD *)(v113 + v39 + 24);
      v254 = *((_DWORD *)this + 165);
      LODWORD(v280.mSampleRate) = 134218752;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v252;
      HIWORD(v280.mBytesPerPacket) = 1024;
      v280.mFramesPerPacket = v253;
      LOWORD(v280.mBytesPerFrame) = 1024;
      *(UInt32 *)((char *)&v280.mBytesPerFrame + 2) = v254;
      v146 = "[%p] NeuralNet's number of output channels (%u) times batch size (%u) not matching AU's number of output channels (%u).";
      goto LABEL_543;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v124 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
LABEL_319:
      v130 = *(_DWORD *)(v114 + 8);
      v131 = *(_DWORD *)(v120 + 12);
      v132 = *(_DWORD *)(v117 + 20);
      v133 = *(_DWORD *)(v117 + 24);
      LODWORD(v280.mSampleRate) = 134219008;
      *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
      LOWORD(v280.mFormatFlags) = 1024;
      *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v130;
      HIWORD(v280.mBytesPerPacket) = 1024;
      v280.mFramesPerPacket = v131;
      LOWORD(v280.mBytesPerFrame) = 1024;
      *(UInt32 *)((char *)&v280.mBytesPerFrame + 2) = v132;
      HIWORD(v280.mChannelsPerFrame) = 1024;
      v280.mBitsPerChannel = v133;
      _os_log_debug_impl(&dword_1B5ED0000, v124, OS_LOG_TYPE_DEBUG, "[%p] NeuralNet is initialized with %u input channels, %u output channels, block size %u, and batch size %u.", (uint8_t *)&v280, 0x24u);
    }
LABEL_314:
    v128 = v119;
    if (!v39)
      goto LABEL_317;
    v129 = *((_QWORD *)this + 100);
    if (*(_DWORD *)(v129 + 20) != *(_DWORD *)(v129 + v39 + 20))
      break;
    if (*(_DWORD *)(v129 + 16) != *(_DWORD *)(v129 + v39 + 16))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v152 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        v155 = *((_QWORD *)this + 100);
        v156 = *(_DWORD *)(v155 + 16);
        LODWORD(v155) = *(_DWORD *)(v155 + 104 * v128 + 16);
        LODWORD(v280.mSampleRate) = 134218752;
        *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
        LOWORD(v280.mFormatFlags) = 1024;
        *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v156;
        HIWORD(v280.mBytesPerPacket) = 1024;
        v280.mFramesPerPacket = v128;
        LOWORD(v280.mBytesPerFrame) = 1024;
        *(UInt32 *)((char *)&v280.mBytesPerFrame + 2) = v155;
        v9 = "[%p] NeuralNet0 lookaheadSize (%u) and NeuralNet%u lookaheadSize (%u) do not match";
        goto LABEL_376;
      }
      return 4294956421;
    }
LABEL_317:
    v40 = v119 + 1;
    v39 += 104;
    if (v119 + 1 >= (unint64_t)*((unsigned int *)this + 206))
      goto LABEL_327;
  }
  if (getAUNeuralNetLog(void)::onceToken != -1)
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  v152 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    v153 = *((_QWORD *)this + 100);
    v154 = *(_DWORD *)(v153 + 20);
    LODWORD(v153) = *(_DWORD *)(v153 + 104 * v128 + 20);
    LODWORD(v280.mSampleRate) = 134218752;
    *(_QWORD *)((char *)&v280.mSampleRate + 4) = this;
    LOWORD(v280.mFormatFlags) = 1024;
    *(AudioFormatFlags *)((char *)&v280.mFormatFlags + 2) = v154;
    HIWORD(v280.mBytesPerPacket) = 1024;
    v280.mFramesPerPacket = v128;
    LOWORD(v280.mBytesPerFrame) = 1024;
    *(UInt32 *)((char *)&v280.mBytesPerFrame + 2) = v153;
    v9 = "[%p] NeuralNet0 blockSize (%u) and NeuralNet(%u) blockSize (%u) do not match";
LABEL_376:
    v10 = (uint8_t *)&v280;
    v11 = v152;
    v12 = 30;
    goto LABEL_91;
  }
  return 4294956421;
}

void sub_1B616B1B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,const void *a36)
{
  applesauce::CF::DictionaryRef::~DictionaryRef(&a36);
  _Unwind_Resume(a1);
}

void sub_1B616B1C0(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void sub_1B616B220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,__int128 a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,__int128 a30)
{
  uint64_t v30;
  void *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  void *v37;
  void *v38;
  NSObject *v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;

  if (a2)
  {
    if (*(char *)(v34 - 169) < 0)
      operator delete(*(void **)(v33 + 32));
    if (v32)
      __cxa_free_exception(v31);
    v37 = __cxa_begin_catch(a1);
    if (a2 == 3)
    {
      v38 = v37;
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v39 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        v41 = (*(uint64_t (**)(void *))(*(_QWORD *)v38 + 16))(v38);
        *(_DWORD *)(v34 - 192) = a21;
        v42 = v34 - 224;
        *(_QWORD *)(v42 + 36) = v30;
        *(_WORD *)(v34 - 180) = 2080;
        *(_QWORD *)(v42 + 46) = v41;
        _os_log_error_impl(&dword_1B5ED0000, v39, OS_LOG_TYPE_ERROR, "[%p] Could not load metadata using the plist, exception (%s)", (uint8_t *)(v34 - 192), 0x16u);
      }
    }
    else
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v40 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)(v34 - 192) = a30;
        *(_QWORD *)(v33 + 36) = v30;
        _os_log_error_impl(&dword_1B5ED0000, v40, OS_LOG_TYPE_ERROR, "[%p] Could not load metadata using the plist, unknown exception.", (uint8_t *)(v34 - 192), 0xCu);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x1B61677BCLL);
  }
  _Unwind_Resume(a1);
}

void sub_1B616B24C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    JUMPOUT(0x1B616B25CLL);
  _Unwind_Resume(a1);
}

void sub_1B616B260(_Unwind_Exception *a1, int a2)
{
  if (a2)
    JUMPOUT(0x1B616B270);
  _Unwind_Resume(a1);
}

char *AUNeuralNet::Cleanup(AUNeuralNet *this)
{
  NSObject *v2;
  uint64_t i;
  uint64_t v4;
  int v6;
  AUNeuralNet *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (getAUNeuralNetLog(void)::onceToken != -1)
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  v2 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 134217984;
    v7 = this;
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEFAULT, "[%p] cleanup", (uint8_t *)&v6, 0xCu);
  }
  for (i = 0; i != 624; i += 104)
  {
    v4 = *((_QWORD *)this + 100) + i;
    if (*(_BYTE *)(v4 + 96))
      (*(void (**)(_QWORD))(**(_QWORD **)(v4 + 64) + 48))(*(_QWORD *)(v4 + 64));
  }
  return AUNeuralNet::InitMaskRelatedVariables(this);
}

uint64_t AUNeuralNet::Reset(AUNeuralNet *this)
{
  BlockProcessor *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  size_t v6;
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;

  v2 = (BlockProcessor *)*((_QWORD *)this + 157);
  if (v2)
    BlockProcessor::Reset(v2);
  v3 = *((_QWORD *)this + 158);
  if (v3)
  {
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 40) = 0;
    if (*(_QWORD *)(v3 + 24))
    {
      v4 = *(unsigned int *)(v3 + 32);
      if ((_DWORD)v4)
      {
        v5 = 0;
        v6 = (4 * *(_DWORD *)(v3 + 36));
        do
        {
          v7 = *(_DWORD **)(*(_QWORD *)(v3 + 24) + 8 * v5);
          if (*v7)
          {
            v8 = 0;
            v9 = 4;
            do
            {
              bzero(*(void **)&v7[v9], v6);
              ++v8;
              v9 += 4;
            }
            while (v8 < *v7);
            v4 = *(unsigned int *)(v3 + 32);
          }
          ++v5;
        }
        while (v5 < v4);
      }
    }
  }
  for (i = 0; i != 624; i += 104)
  {
    v11 = *((_QWORD *)this + 100) + i;
    if (*(_BYTE *)(v11 + 96))
      (*(void (**)(_QWORD))(**(_QWORD **)(v11 + 64) + 48))(*(_QWORD *)(v11 + 64));
  }
  vDSP_vclr(*((float **)this + 104), 1, (uint64_t)(*((_QWORD *)this + 105) - *((_QWORD *)this + 104)) >> 2);
  if (*((_BYTE *)this + 592))
    vDSP_vclr(*((float **)this + 107), 1, (uint64_t)(*((_QWORD *)this + 108) - *((_QWORD *)this + 107)) >> 2);
  vDSP_vclr(*((float **)this + 110), 1, (uint64_t)(*((_QWORD *)this + 111) - *((_QWORD *)this + 110)) >> 2);
  vDSP_vclr(*((float **)this + 113), 1, (uint64_t)(*((_QWORD *)this + 114) - *((_QWORD *)this + 113)) >> 2);
  vDSP_vclr(*((float **)this + 116), 1, (uint64_t)(*((_QWORD *)this + 117) - *((_QWORD *)this + 116)) >> 2);
  vDSP_vclr(*((float **)this + 119), 1, (uint64_t)(*((_QWORD *)this + 120) - *((_QWORD *)this + 119)) >> 2);
  vDSP_vclr(*((float **)this + 123), 1, (uint64_t)(*((_QWORD *)this + 124) - *((_QWORD *)this + 123)) >> 2);
  vDSP_vclr(*((float **)this + 126), 1, (uint64_t)(*((_QWORD *)this + 127) - *((_QWORD *)this + 126)) >> 2);
  vDSP_vclr(*((float **)this + 129), 1, (uint64_t)(*((_QWORD *)this + 130) - *((_QWORD *)this + 129)) >> 2);
  v12 = *((_QWORD *)this + 132);
  if (*((_QWORD *)this + 133) != v12)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      vDSP_vclr(*(float **)(v12 + v13), 1, (uint64_t)(*(_QWORD *)(v12 + v13 + 8) - *(_QWORD *)(v12 + v13)) >> 2);
      ++v14;
      v12 = *((_QWORD *)this + 132);
      v13 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 133) - v12) >> 3) > v14);
  }
  vDSP_vclr(*((float **)this + 135), 1, (uint64_t)(*((_QWORD *)this + 136) - *((_QWORD *)this + 135)) >> 2);
  vDSP_vclr(*((float **)this + 138), 1, (uint64_t)(*((_QWORD *)this + 139) - *((_QWORD *)this + 138)) >> 2);
  vDSP_vclr(*((float **)this + 141), 1, (uint64_t)(*((_QWORD *)this + 142) - *((_QWORD *)this + 141)) >> 2);
  v15 = *((_DWORD *)this + 158);
  *((_DWORD *)this + 159) = v15;
  *((_DWORD *)this + 160) = v15;
  *((_BYTE *)this + 652) = 1;
  return 0;
}

uint64_t AUNeuralNet::GetPropertyInfo(AUNeuralNet *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  int v8;
  int v9;
  char v10;
  int v11;
  char v12;
  int v13;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 3999)
  {
    if (a2 > 3693)
    {
      switch(a2)
      {
        case 3694:
        case 3698:
        case 3700:
          goto LABEL_27;
        case 3695:
          goto LABEL_28;
        case 3696:
          *a6 = *((_BYTE *)this + 17) ^ 1;
          v9 = *((_DWORD *)this + 84);
          goto LABEL_32;
        case 3697:
          goto LABEL_22;
        case 3699:
          goto LABEL_31;
        default:
          if (a2 != 3799)
            return result;
LABEL_31:
          *a6 = 0;
          v9 = *((_DWORD *)this + 136);
LABEL_32:
          v13 = 4 * v9 + 4;
          break;
      }
      goto LABEL_38;
    }
    if (a2 != 21)
    {
      if (a2 != 3670)
        return result;
      *a6 = 0;
      v11 = *(_DWORD *)(*((_QWORD *)this + 100) + 28);
      goto LABEL_37;
    }
LABEL_27:
    v12 = 1;
LABEL_29:
    *a6 = v12;
    v13 = 4;
LABEL_38:
    result = 0;
    *a5 = v13;
    return result;
  }
  if (a2 > 103695)
  {
    if (a2 <= 103799)
    {
      if (a2 != 103696)
      {
        if (a2 == 103699)
        {
LABEL_21:
          *a6 = 0;
LABEL_35:
          v13 = 8;
          goto LABEL_38;
        }
        v8 = 103799;
LABEL_20:
        if (a2 != v8)
          return result;
        goto LABEL_21;
      }
      v10 = *((_BYTE *)this + 17) ^ 1;
LABEL_34:
      *a6 = v10;
      goto LABEL_35;
    }
    if (a2 != 103800)
    {
      if (a2 != 103801)
      {
        v8 = 1036999;
        goto LABEL_20;
      }
      goto LABEL_27;
    }
LABEL_22:
    v10 = 1;
    goto LABEL_34;
  }
  if (a2 <= 4001)
  {
    if (a2 == 4000)
    {
LABEL_28:
      v12 = *((_BYTE *)this + 17) ^ 1;
      goto LABEL_29;
    }
    goto LABEL_27;
  }
  switch(a2)
  {
    case 4002:
      goto LABEL_27;
    case 36999:
      *a6 = 0;
      v11 = *((_DWORD *)this + 136);
LABEL_37:
      v13 = 4 * v11;
      goto LABEL_38;
    case 40000:
      goto LABEL_22;
  }
  return result;
}

uint64_t AUNeuralNet::GetProperty(AUNeuralNet *this, int a2, int a3, unsigned int a4, CFArrayRef *__dst)
{
  uint64_t result;
  int v9;
  const void *v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  size_t v17;
  int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  CFArrayRef CFArray;
  NSObject *v24;
  int v25;
  const char *v26;
  int v27;
  int v28;
  _BYTE v29[12];
  __int16 v30;
  unsigned int v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 > 39999)
  {
    if (a2 <= 103798)
    {
      if (a2 == 40000)
      {
        v10 = (const void *)*((_QWORD *)this + 148);
        if (!v10)
          goto LABEL_42;
        goto LABEL_41;
      }
      if (a2 == 103670)
      {
        CFArray = applesauce::CF::details::make_CFArrayRef<float>((_QWORD *)this + 107);
        result = 0;
        *__dst = CFArray;
        return result;
      }
      if (a2 != 103699)
        return result;
      if (*((_DWORD *)this + 165) <= a4)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v24 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          return 4294956419;
        goto LABEL_56;
      }
      v11 = *((_DWORD *)this + 136) + 1;
      v12 = v11 * a4;
      v13 = v11 + v11 * a4;
      v14 = *((_QWORD *)this + 113);
    }
    else if (a2 > 103800)
    {
      if (a2 == 103801)
      {
        v9 = *((unsigned __int8 *)this + 1401);
        if (*((_BYTE *)this + 1401))
          v9 = *((unsigned __int8 *)this + 1400);
        result = 0;
        goto LABEL_52;
      }
      if (a2 != 1036999)
        return result;
      if (*((_DWORD *)this + 165) <= a4)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v24 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          return 4294956419;
        goto LABEL_60;
      }
      v18 = *((_DWORD *)this + 136);
      v12 = v18 * a4;
      v13 = v18 * a4 + v18;
      v14 = *((_QWORD *)this + 116);
    }
    else
    {
      if (a2 != 103799)
      {
        v10 = (const void *)*((_QWORD *)this + 150);
        if (!v10)
          goto LABEL_42;
LABEL_41:
        CFRetain(v10);
        goto LABEL_42;
      }
      if (*((_DWORD *)this + 165) <= a4)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v24 = getAUNeuralNetLog(void)::gLog;
        if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          return 4294956419;
        goto LABEL_76;
      }
      v22 = *((_DWORD *)this + 136) + 1;
      v12 = v22 * a4;
      v13 = v22 + v22 * a4;
      v14 = *((_QWORD *)this + 119);
    }
    *(_QWORD *)v29 = 0;
    *__dst = applesauce::CF::details::make_CFArrayRef<float,float *>((int *)(v14 + 4 * v12), (int *)(v14 + 4 * v13));
    applesauce::CF::ArrayRef::~ArrayRef((const void **)v29);
    return 0;
  }
  if (a2 <= 3698)
  {
    if (a2 == 21)
    {
      result = 0;
      v9 = *((_DWORD *)this + 167);
      goto LABEL_52;
    }
    if (a2 == 3670)
    {
      v16 = (const void *)*((_QWORD *)this + 107);
      v17 = *((_QWORD *)this + 108) - (_QWORD)v16;
      goto LABEL_47;
    }
    if (a2 != 3697)
      return result;
    v10 = (const void *)*((_QWORD *)this + 149);
    if (v10)
      goto LABEL_41;
LABEL_42:
    result = 0;
    *__dst = (CFArrayRef)v10;
    return result;
  }
  if (a2 > 3798)
  {
    if (a2 != 3799)
    {
      if (a2 != 36999)
        return result;
      if (*((_DWORD *)this + 165) > a4)
      {
        v15 = *((unsigned int *)this + 136);
        v16 = (const void *)(*((_QWORD *)this + 116) + 4 * (int)(v15 * a4));
        v17 = 4 * v15;
LABEL_47:
        memcpy(__dst, v16, v17);
        return 0;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v24 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        return 4294956419;
LABEL_60:
      v27 = *((_DWORD *)this + 165);
      *(_DWORD *)v29 = 134218496;
      *(_QWORD *)&v29[4] = this;
      v30 = 1024;
      v31 = a4;
      v32 = 1024;
      v33 = v27;
      v26 = "[%p] Tried to select a VP mask indexed at (%u), but only (%u) masks are available";
      goto LABEL_77;
    }
    if (*((_DWORD *)this + 165) > a4)
    {
      v19 = *((_DWORD *)this + 136) + 1;
      v20 = v19 * a4;
      v21 = *((_QWORD *)this + 119);
      goto LABEL_46;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v24 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294956419;
LABEL_76:
    v28 = *((_DWORD *)this + 165);
    *(_DWORD *)v29 = 134218496;
    *(_QWORD *)&v29[4] = this;
    v30 = 1024;
    v31 = a4;
    v32 = 1024;
    v33 = v28;
    v26 = "[%p] Tried to select a postmask indexed at (%u), but only (%u) masks are available";
    goto LABEL_77;
  }
  if (a2 == 3699)
  {
    if (*((_DWORD *)this + 165) > a4)
    {
      v19 = *((_DWORD *)this + 136) + 1;
      v20 = v19 * a4;
      v21 = *((_QWORD *)this + 113);
LABEL_46:
      v16 = (const void *)(v21 + 4 * v20);
      v17 = 4 * v19;
      goto LABEL_47;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v24 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
LABEL_56:
      v25 = *((_DWORD *)this + 165);
      *(_DWORD *)v29 = 134218496;
      *(_QWORD *)&v29[4] = this;
      v30 = 1024;
      v31 = a4;
      v32 = 1024;
      v33 = v25;
      v26 = "[%p] Tried to select a mask indexed at (%u), but only (%u) masks are available";
LABEL_77:
      _os_log_error_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_ERROR, v26, v29, 0x18u);
    }
    return 4294956419;
  }
  if (a2 == 3700)
  {
    result = 0;
    v9 = *((unsigned __int8 *)this + 376);
LABEL_52:
    *(_DWORD *)__dst = v9;
  }
  return result;
}

void sub_1B616BEAC(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void sub_1B616BEBC(uint64_t a1, int a2)
{
  if (!a2)
    JUMPOUT(0x1B616BEB8);
  JUMPOUT(0x1B616BEB0);
}

uint64_t AUNeuralNet::SetProperty(AUNeuralNet *this, int a2, int a3, unsigned int a4, char *__src, size_t __n)
{
  uint64_t v6;
  unsigned int v8;
  const __CFDictionary *v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  _OWORD *v15;
  int v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t i;
  uint64_t v22;
  uint64_t v23;
  void **v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  const __CFArray **v29;
  int64_t v30;
  _QWORD *v31;
  void *v32;
  void *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  uint32_t v40;
  NSObject *v41;
  uint64_t v42;
  NSObject *v43;
  int v44;
  uint64_t v45;
  NSObject *v46;
  ausdk::AUElement **v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  NSObject *v51;
  uint32_t v52;
  float v53;
  NSObject *v54;
  NSObject *v55;
  double v56;
  NSObject *v57;
  double v58;
  NSObject *v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  std::string *v65;
  __int128 v66;
  const char *v67;
  CFStringRef v68;
  NSObject *v69;
  _OWORD *v70;
  int v71;
  NSObject *v72;
  _OWORD *v73;
  const void *Value;
  const void *v75;
  uint64_t v76;
  const void *v77;
  int v78;
  NSObject *v79;
  _OWORD *v80;
  NSObject *v82;
  uint64_t v83;
  std::string::size_type v84;
  int v85;
  uint64_t v86;
  unsigned int __N;
  _OWORD __N_4[4];
  uint64_t v89[4];
  char v90;
  std::string buf;
  char v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  if (a3)
    return 4294956417;
  v8 = __n;
  v6 = 4294956417;
  if (a2 <= 3999)
  {
    switch(a2)
    {
      case 3694:
        if ((_DWORD)__n != 4)
          return 4294956445;
        v6 = 0;
        *((_DWORD *)this + 328) = *(_DWORD *)__src;
        return v6;
      case 3695:
        if (*((_BYTE *)this + 17))
          return 4294956447;
        if ((_DWORD)__n != 4)
          return 4294956445;
        if (*(_DWORD *)__src < 5u)
        {
          v6 = 0;
          *((_DWORD *)this + 318) = *(_DWORD *)__src;
          return v6;
        }
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v17 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          LODWORD(__N_4[0]) = 134217984;
          *(_QWORD *)((char *)__N_4 + 4) = this;
          v18 = "[%p] Bad Property Value for Speech Mask selection";
          goto LABEL_115;
        }
        return 4294956445;
      case 3696:
        if (*((_BYTE *)this + 17))
          return 4294956447;
        v19 = *((unsigned int *)this + 84);
        if (__n != 4 * (v19 + 1))
          return 4294956445;
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 1280, __src, (uint64_t)&__src[4 * v19 + 4], (4 * v19 + 4) >> 2);
        return 0;
      case 3697:
        if (*((_BYTE *)this + 17))
          return 4294956447;
        if (!__src || (_DWORD)__n != 8)
        {
          if (getAUNeuralNetLog(void)::onceToken != -1)
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
          v17 = getAUNeuralNetLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          {
            LODWORD(__N_4[0]) = 134217984;
            *(_QWORD *)((char *)__N_4 + 4) = this;
            v18 = "[%p] The NeuralNetPlist passed to SetProperty is not CFDictionaryRef type or it's null.";
            goto LABEL_115;
          }
          return 4294956445;
        }
        applesauce::CF::DictionaryRef::from_get((applesauce::CF::DictionaryRef *)__N_4, *(CFTypeRef *)__src);
        v20 = *((_QWORD *)this + 149);
        *((_QWORD *)this + 149) = *(_QWORD *)&__N_4[0];
        *(_QWORD *)&__N_4[0] = v20;
        applesauce::CF::DictionaryRef::~DictionaryRef((const void **)__N_4);
        for (i = 0; i != 624; i += 104)
        {
          v22 = *((_QWORD *)this + 100) + i;
          if (*(_BYTE *)(v22 + 96))
          {
            NeuralNet::~NeuralNet((NeuralNet *)(v22 + 64));
            *(_BYTE *)(v22 + 96) = 0;
            v90 = 0;
            LOBYTE(v89[0]) = 0;
            memset(__N_4, 0, sizeof(__N_4));
            v23 = *((_QWORD *)this + 100) + i;
            *(_OWORD *)v23 = 0u;
            *(_OWORD *)(v23 + 16) = 0u;
            v24 = (void **)(v23 + 32);
            if (*(char *)(v23 + 55) < 0)
              operator delete(*v24);
            v25 = __N_4[2];
            *(_QWORD *)(v23 + 48) = *(_QWORD *)&__N_4[3];
            *(_OWORD *)v24 = v25;
            BYTE7(__N_4[3]) = 0;
            LOBYTE(__N_4[2]) = 0;
            v26 = *(_QWORD *)(v23 + 56);
            *(_QWORD *)(v23 + 56) = *((_QWORD *)&__N_4[3] + 1);
            *((_QWORD *)&__N_4[3] + 1) = v26;
            std::__optional_storage_base<NeuralNet,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<NeuralNet,false>>((NeuralNet *)(v23 + 64), v89);
            if (v90)
              NeuralNet::~NeuralNet((NeuralNet *)v89);
            if (*((_QWORD *)&__N_4[3] + 1))
              CFRelease(*((CFTypeRef *)&__N_4[3] + 1));
            if (SBYTE7(__N_4[3]) < 0)
              operator delete(*(void **)&__N_4[2]);
          }
        }
        v27 = *((_QWORD *)this + 9);
        if (v27)
        {
          v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
        }
        else
        {
          v47 = (ausdk::AUElement **)*((_QWORD *)this + 6);
          if (*((ausdk::AUElement ***)this + 7) == v47)
            v28 = 0;
          else
            v28 = *v47;
        }
        ausdk::AUElement::SetParameter(v28, 0, 0.0, 0);
        v63 = 0;
        v64 = 56;
        *((_DWORD *)this + 206) = 0;
        break;
      case 3698:
        goto LABEL_127;
      case 3699:
        return v6;
      case 3700:
        v6 = 4294956445;
        if (__n >= 4)
        {
          if (*__src)
            return 0;
          else
            return 4294956445;
        }
        return v6;
      default:
        if (a2 == 21)
        {
          if (__n < 4)
            return 4294956445;
          v6 = 0;
          *((_DWORD *)this + 167) = *(_DWORD *)__src;
          return v6;
        }
        if (a2 != 3670)
          return v6;
        v12 = (void *)*((_QWORD *)this + 107);
        if (*((_QWORD *)this + 108) - (_QWORD)v12 == __n)
        {
          memcpy(v12, __src, __n);
          return 0;
        }
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v37 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          v38 = *((_QWORD *)this + 108) - *((_QWORD *)this + 107);
          LODWORD(__N_4[0]) = 134218496;
          *(_QWORD *)((char *)__N_4 + 4) = this;
          WORD6(__N_4[0]) = 2048;
          *(_QWORD *)((char *)__N_4 + 14) = v8;
          WORD3(__N_4[1]) = 2048;
          *((_QWORD *)&__N_4[1] + 1) = v38;
          v18 = "[%p] Input size of EmbeddingVector  (%lu) is not equal to the the expected size  (%lu).";
          goto LABEL_110;
        }
        return 4294956445;
    }
    while (1)
    {
      std::to_string(&buf, v63);
      v65 = std::string::insert(&buf, 0, "Model_", 6uLL);
      v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
      *(_QWORD *)&__N_4[1] = *((_QWORD *)&v65->__r_.__value_.__l + 2);
      __N_4[0] = v66;
      v65->__r_.__value_.__l.__size_ = 0;
      v65->__r_.__value_.__r.__words[2] = 0;
      v65->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        operator delete(buf.__r_.__value_.__l.__data_);
      if ((SBYTE7(__N_4[1]) & 0x80u) == 0)
        v67 = (const char *)__N_4;
      else
        v67 = *(const char **)&__N_4[0];
      v68 = CFStringCreateWithCString(0, v67, 0x8000100u);
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v69 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        if ((SBYTE7(__N_4[1]) & 0x80u) == 0)
          v70 = __N_4;
        else
          v70 = *(_OWORD **)&__N_4[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v70;
        _os_log_impl(&dword_1B5ED0000, v69, OS_LOG_TYPE_INFO, "[%p] Searching plist for model named (%s)...", (uint8_t *)&buf, 0x16u);
      }
      v71 = CFDictionaryContainsKey(*((CFDictionaryRef *)this + 149), v68);
      if (v71)
      {
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v72 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        {
          if ((SBYTE7(__N_4[1]) & 0x80u) == 0)
            v73 = __N_4;
          else
            v73 = *(_OWORD **)&__N_4[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v73;
          _os_log_impl(&dword_1B5ED0000, v72, OS_LOG_TYPE_INFO, "[%p] Found model named (%s)...", (uint8_t *)&buf, 0x16u);
        }
        Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 149), v68);
        v75 = Value;
        if (Value)
          CFRetain(Value);
        applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&buf, v75);
        v76 = *((_QWORD *)this + 100);
        v77 = *(const void **)(v76 + v64);
        *(_QWORD *)(v76 + v64) = buf.__r_.__value_.__r.__words[0];
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v77;
        if (v77)
          CFRelease(v77);
        CFRelease(v68);
        v78 = v63 + 1;
      }
      else
      {
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v79 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        {
          if ((SBYTE7(__N_4[1]) & 0x80u) == 0)
            v80 = __N_4;
          else
            v80 = *(_OWORD **)&__N_4[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v80;
          _os_log_impl(&dword_1B5ED0000, v79, OS_LOG_TYPE_INFO, "[%p] Did not find model named (%s)...", (uint8_t *)&buf, 0x16u);
        }
        CFRelease(v68);
        if (v63)
          goto LABEL_212;
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v82 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
          _os_log_impl(&dword_1B5ED0000, v82, OS_LOG_TYPE_INFO, "[%p] Assuming 1 un-named model exists in the plist", (uint8_t *)&buf, 0xCu);
        }
        applesauce::CF::DictionaryRef::from_get((applesauce::CF::DictionaryRef *)&buf, *(CFTypeRef *)__src);
        v83 = *((_QWORD *)this + 100);
        v84 = *(_QWORD *)(v83 + 56);
        *(_QWORD *)(v83 + 56) = buf.__r_.__value_.__r.__words[0];
        buf.__r_.__value_.__r.__words[0] = v84;
        applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&buf.__r_.__value_.__l.__data_);
        v78 = 1;
      }
      *((_DWORD *)this + 206) = v78;
LABEL_212:
      if (SBYTE7(__N_4[1]) < 0)
        operator delete(*(void **)&__N_4[0]);
      if (v71)
      {
        v64 += 104;
        if (v63++ != 5)
          continue;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v61 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        v85 = *((_DWORD *)this + 206);
        LODWORD(__N_4[0]) = 134218240;
        *(_QWORD *)((char *)__N_4 + 4) = this;
        WORD6(__N_4[0]) = 1024;
        *(_DWORD *)((char *)__N_4 + 14) = v85;
        v50 = "[%p] Finished finding models. Found (%u) models";
        goto LABEL_227;
      }
      return 0;
    }
  }
  if (a2 <= 103669)
  {
    if (a2 <= 4001)
    {
      if (a2 == 4000)
      {
        if (!*((_BYTE *)this + 17))
        {
          if ((_DWORD)__n == 4)
          {
            v6 = 0;
            *((_BYTE *)this + 1372) = *(_DWORD *)__src != 0;
            return v6;
          }
          return 4294956445;
        }
      }
      else if (!*((_BYTE *)this + 17))
      {
        if ((_DWORD)__n == 4)
        {
          v6 = 0;
          *((_DWORD *)this + 157) = *(_DWORD *)__src;
          return v6;
        }
        return 4294956445;
      }
      return 4294956447;
    }
    if (a2 == 4002)
    {
      if (!*((_BYTE *)this + 17))
      {
        if ((_DWORD)__n == 4)
        {
          v6 = 0;
          v34 = *(_DWORD *)__src;
          *((_DWORD *)this + 158) = *(_DWORD *)__src;
          *((_DWORD *)this + 159) = v34;
          *((_DWORD *)this + 160) = v34;
          *((_BYTE *)this + 652) = 1;
          return v6;
        }
        return 4294956445;
      }
      return 4294956447;
    }
    if (a2 != 40000)
      return v6;
    if (*((_BYTE *)this + 17))
      return 4294956447;
    if ((_DWORD)__n != 8)
      return 4294956445;
    if (__src)
    {
      applesauce::CF::StringRef::from_get((applesauce::CF::StringRef *)__N_4, *(CFTypeRef *)__src);
      v13 = *((_QWORD *)this + 148);
      *((_QWORD *)this + 148) = *(_QWORD *)&__N_4[0];
      *(_QWORD *)&__N_4[0] = v13;
      applesauce::CF::StringRef::~StringRef((const void **)__N_4);
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v14 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        applesauce::CF::convert_to<std::string,0>(*((const __CFString **)this + 148), (uint64_t)__N_4);
        v15 = (SBYTE7(__N_4[1]) & 0x80u) == 0 ? __N_4 : *(_OWORD **)&__N_4[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)this;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v15;
        _os_log_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_INFO, "[%p] ModelNetPathBase is overriden to %s", (uint8_t *)&buf, 0x16u);
        if (SBYTE7(__N_4[1]) < 0)
          operator delete(*(void **)&__N_4[0]);
      }
      return 0;
    }
    v48 = *((_QWORD *)this + 148);
    *((_QWORD *)this + 148) = 0;
    *(_QWORD *)&__N_4[0] = v48;
    applesauce::CF::StringRef::~StringRef((const void **)__N_4);
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v49 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      return 0;
    LODWORD(__N_4[0]) = 134217984;
    *(_QWORD *)((char *)__N_4 + 4) = this;
    v50 = "[%p] ModelNetPathBaseOverride is set to null and thus removed";
    v51 = v49;
    v52 = 12;
    goto LABEL_228;
  }
  if (a2 > 103799)
  {
    if (a2 != 103800)
    {
      if (a2 != 103801)
        return v6;
      if ((_DWORD)__n != 4)
        return 4294956445;
      v16 = *(_DWORD *)__src;
      if (!*((_BYTE *)this + 1401))
        *((_BYTE *)this + 1401) = 1;
      v6 = 0;
      *((_BYTE *)this + 1400) = v16 != 0;
      return v6;
    }
    if (__src && (_DWORD)__n == 8)
    {
      if (*((_BYTE *)this + 17))
        return 4294956447;
      v35 = *((_QWORD *)this + 100);
      if (*((_QWORD *)this + 101) != v35 && *(_QWORD *)(v35 + 56))
      {
        applesauce::CF::DictionaryRef::from_get((applesauce::CF::DictionaryRef *)__N_4, *(CFTypeRef *)__src);
        v36 = *((_QWORD *)this + 150);
        *((_QWORD *)this + 150) = *(_QWORD *)&__N_4[0];
        *(_QWORD *)&__N_4[0] = v36;
        applesauce::CF::DictionaryRef::~DictionaryRef((const void **)__N_4);
        return 0;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v43 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__N_4[0]) = 134217984;
        *(_QWORD *)((char *)__N_4 + 4) = this;
        _os_log_error_impl(&dword_1B5ED0000, v43, OS_LOG_TYPE_ERROR, "[%p] No model found in plist. Cannot set NeuralNetBNNSData_CF before NeuralNetPlist", (uint8_t *)__N_4, 0xCu);
      }
LABEL_127:
      if (*((_BYTE *)this + 17))
        return 4294956447;
      if (v8 != 4)
        return 4294956445;
      v44 = *(_DWORD *)__src;
      if (*(_DWORD *)__src <= 2u)
      {
        v6 = 0;
        *((_DWORD *)this + 312) = v44;
        return v6;
      }
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v45 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        return 4294956445;
      LODWORD(__N_4[0]) = 134218240;
      *(_QWORD *)((char *)__N_4 + 4) = this;
      WORD6(__N_4[0]) = 1024;
      *(_DWORD *)((char *)__N_4 + 14) = v44;
      v18 = "[%p] Received invalid block processor type value %u";
      v39 = v45;
      v40 = 18;
    }
    else
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v17 = getAUNeuralNetLog(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        return 4294956445;
      LODWORD(__N_4[0]) = 134217984;
      *(_QWORD *)((char *)__N_4 + 4) = this;
      v18 = "[%p] The NeuralNetBNNSData_CF passed to SetProperty is not CFDictionaryRef type or it's null.";
LABEL_115:
      v39 = v17;
      v40 = 12;
    }
LABEL_116:
    _os_log_error_impl(&dword_1B5ED0000, v39, OS_LOG_TYPE_ERROR, v18, (uint8_t *)__N_4, v40);
    return 4294956445;
  }
  if (a2 != 103670)
  {
    if (a2 != 103696)
      return v6;
    if (*((_BYTE *)this + 17))
      return 4294956447;
    if ((_DWORD)__n != 8)
      return 4294956445;
    v11 = *(const __CFDictionary **)__src;
    __N = 0;
    if (AUNeuralNetLogScope(void)::once != -1)
      dispatch_once(&AUNeuralNetLogScope(void)::once, &__block_literal_global_1862);
    buf.__r_.__value_.__r.__words[0] = AUNeuralNetLogScope(void)::scope;
    DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, v11, CFSTR("Size"), &__N);
    if (!__N)
      return 4294956445;
    LODWORD(__N_4[0]) = 1065353216;
    std::vector<float>::assign((char **)this + 160, __N, __N_4);
    if (DictionaryBlobReader::ReadVectorFromDictionary((NSObject ***)&buf, v11, CFSTR("Mask"), (char **)this + 160))
    {
      LODWORD(__N_4[0]) = 1065353216;
      vDSP_vfill((const float *)__N_4, *((float **)this + 160), 1, __N);
      *((float *)this + 326) = 1.0 / (float)__N;
    }
    else
    {
      vDSP_sve(*((const float **)this + 160), 1, (float *)this + 326, (uint64_t)(*((_QWORD *)this + 161) - *((_QWORD *)this + 160)) >> 2);
      v53 = 1.0 / (*((float *)this + 326) + 1.0e-20);
      *((float *)this + 326) = v53;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v54 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
    {
      LODWORD(__N_4[0]) = 134218240;
      *(_QWORD *)((char *)__N_4 + 4) = this;
      WORD6(__N_4[0]) = 1024;
      *(_DWORD *)((char *)__N_4 + 14) = __N;
      _os_log_impl(&dword_1B5ED0000, v54, OS_LOG_TYPE_INFO, "[%p] Weighting for Speech Probability mask has %d elements", (uint8_t *)__N_4, 0x12u);
    }
    if (!DictionaryBlobReader::ReadScalarFromDictionary<float>((uint64_t **)&buf, v11, CFSTR("SmoothingFactor"), kCFNumberFloatType, (float *)this + 339))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v55 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        v56 = *((float *)this + 339);
        LODWORD(__N_4[0]) = 134218240;
        *(_QWORD *)((char *)__N_4 + 4) = this;
        WORD6(__N_4[0]) = 2048;
        *(double *)((char *)__N_4 + 14) = v56;
        _os_log_impl(&dword_1B5ED0000, v55, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved SmoothingFactor (%f).", (uint8_t *)__N_4, 0x16u);
      }
    }
    if (!DictionaryBlobReader::ReadScalarFromDictionary<float>((uint64_t **)&buf, v11, CFSTR("ProbabilityThreshold"), kCFNumberFloatType, (float *)this + 340))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v57 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        v58 = *((float *)this + 340);
        LODWORD(__N_4[0]) = 134218240;
        *(_QWORD *)((char *)__N_4 + 4) = this;
        WORD6(__N_4[0]) = 2048;
        *(double *)((char *)__N_4 + 14) = v58;
        _os_log_impl(&dword_1B5ED0000, v57, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved ProbabilityThreshold (%f).", (uint8_t *)__N_4, 0x16u);
      }
    }
    if (!DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, v11, CFSTR("HangoverOnSetFrames"), (_DWORD *)this + 341))
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v59 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      {
        v60 = *((_DWORD *)this + 341);
        LODWORD(__N_4[0]) = 134218240;
        *(_QWORD *)((char *)__N_4 + 4) = this;
        WORD6(__N_4[0]) = 1024;
        *(_DWORD *)((char *)__N_4 + 14) = v60;
        _os_log_impl(&dword_1B5ED0000, v59, OS_LOG_TYPE_INFO, "[%p] Successfully retrieved HangoverOnSetFrames (%u).", (uint8_t *)__N_4, 0x12u);
      }
    }
    if (DictionaryBlobReader::ReadScalarFromDictionary<unsigned int>((uint64_t **)&buf, v11, CFSTR("HangoverOffSetFrames"), (_DWORD *)this + 342))return 0;
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v61 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
      return 0;
    v62 = *((_DWORD *)this + 342);
    LODWORD(__N_4[0]) = 134218240;
    *(_QWORD *)((char *)__N_4 + 4) = this;
    WORD6(__N_4[0]) = 1024;
    *(_DWORD *)((char *)__N_4 + 14) = v62;
    v50 = "[%p] Successfully retrieved HangoverOffSetFrames (%u).";
LABEL_227:
    v51 = v61;
    v52 = 18;
LABEL_228:
    _os_log_impl(&dword_1B5ED0000, v51, OS_LOG_TYPE_INFO, v50, (uint8_t *)__N_4, v52);
    return 0;
  }
  if ((_DWORD)__n != 8)
  {
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v37 = getAUNeuralNetLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      return 4294956445;
    LODWORD(__N_4[0]) = 134218496;
    *(_QWORD *)((char *)__N_4 + 4) = this;
    WORD6(__N_4[0]) = 2048;
    *(_QWORD *)((char *)__N_4 + 14) = v8;
    WORD3(__N_4[1]) = 2048;
    *((_QWORD *)&__N_4[1] + 1) = 8;
    v18 = "[%p] Input size of EmbeddingVector_CF is not expected size (%lu) != (%lu)";
LABEL_110:
    v39 = v37;
    v40 = 32;
    goto LABEL_116;
  }
  applesauce::CF::ArrayRef::from_get((applesauce::CF::ArrayRef *)__N_4, *(CFTypeRef *)__src);
  v29 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(__N_4);
  applesauce::CF::convert_as<std::vector<float>,0>((uint64_t)&buf, *v29);
  applesauce::CF::ArrayRef::~ArrayRef((const void **)__N_4);
  if (!v92)
    return 4294956445;
  if (*((_BYTE *)this + 17))
  {
    v30 = buf.__r_.__value_.__l.__size_ - buf.__r_.__value_.__r.__words[0];
    if (*((_QWORD *)this + 108) - *((_QWORD *)this + 107) == buf.__r_.__value_.__l.__size_
                                                            - buf.__r_.__value_.__r.__words[0])
    {
      caulk::pooled_semaphore_mutex::_lock((AUNeuralNet *)((char *)this + 1240));
      v31 = (_QWORD *)((char *)this + 856);
      v32 = (void *)*((_QWORD *)this + 107);
      if (v32)
      {
        *((_QWORD *)this + 108) = v32;
        operator delete(v32);
        *v31 = 0;
        *((_QWORD *)this + 108) = 0;
        *((_QWORD *)this + 109) = 0;
      }
      *(_OWORD *)v31 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *((_QWORD *)this + 109) = *((_QWORD *)&buf.__r_.__value_.__l + 2);
      memset(&buf, 0, sizeof(buf));
      caulk::pooled_semaphore_mutex::_unlock((AUNeuralNet *)((char *)this + 1240));
      v33 = 0;
      v6 = 0;
      goto LABEL_142;
    }
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v46 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      v86 = (uint64_t)(*((_QWORD *)this + 108) - *((_QWORD *)this + 107)) >> 2;
      LODWORD(__N_4[0]) = 134219008;
      *(_QWORD *)((char *)__N_4 + 4) = this;
      WORD6(__N_4[0]) = 2048;
      *(_QWORD *)((char *)__N_4 + 14) = 8;
      WORD3(__N_4[1]) = 2048;
      *((_QWORD *)&__N_4[1] + 1) = 8;
      LOWORD(__N_4[2]) = 2048;
      *(_QWORD *)((char *)&__N_4[2] + 2) = v86;
      WORD5(__N_4[2]) = 2048;
      *(_QWORD *)((char *)&__N_4[2] + 12) = v30 >> 2;
      _os_log_error_impl(&dword_1B5ED0000, v46, OS_LOG_TYPE_ERROR, "[%p] Input size of EmbeddingVector (%lu) is not equal to the the expected size  (%lu) or (%lu) is not equal to (%lu).", (uint8_t *)__N_4, 0x34u);
    }
    v42 = 4294956445;
LABEL_141:
    v33 = (void *)buf.__r_.__value_.__r.__words[0];
    v6 = v42;
LABEL_142:
    if (v33)
      operator delete(v33);
    return v6;
  }
  if (getAUNeuralNetLog(void)::onceToken != -1)
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  v41 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    LODWORD(__N_4[0]) = 134217984;
    *(_QWORD *)((char *)__N_4 + 4) = this;
    _os_log_impl(&dword_1B5ED0000, v41, OS_LOG_TYPE_INFO, "[%p] AU not initialized: Cache embedding vector", (uint8_t *)__N_4, 0xCu);
  }
  std::optional<std::vector<float>>::operator=[abi:ne180100]<std::vector<float>,void>((uint64_t)this + 1208, (uint64_t)&buf);
  v42 = 0;
  v6 = 0;
  if (v92)
    goto LABEL_141;
  return v6;
}

void sub_1B616D22C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  _Unwind_Resume(exception_object);
}

uint64_t AUNeuralNet::SetParameter(AUNeuralNet *this, uint64_t a2, int a3, unsigned int a4, float a5)
{
  uint64_t result;
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v12;
  uint64_t v13;

  if (a3)
    return 4294956418;
  v10 = *((_QWORD *)this + 9);
  if (v10)
  {
    v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
  }
  else
  {
    v12 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v12)
      v11 = 0;
    else
      v11 = *v12;
  }
  ausdk::AUElement::SetParameter(v11, a2, a5, 0);
  (*(void (**)(AUNeuralNet *, _QWORD, uint64_t, char *))(*(_QWORD *)this + 256))(this, 0, a2, (char *)this + 696);
  if ((_DWORD)a2 == 20)
  {
    v13 = *((_QWORD *)this + 107);
    if (*(_DWORD *)(*((_QWORD *)this + 100) + 104 * *((unsigned int *)this + 141) + 28) > a4
      && (*((_QWORD *)this + 108) - v13) >> 2 > (unint64_t)a4)
    {
      result = 0;
      *(float *)(v13 + 4 * a4) = a5;
    }
    else
    {
      return 4294956419;
    }
  }
  else if ((_DWORD)a2 == 5 || (*((_DWORD *)this + 198) & 0x8000) == 0)
  {
    result = 0;
    ++*((_QWORD *)this + 85);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t AUNeuralNet::CanScheduleParameters(AUNeuralNet *this)
{
  return 0;
}

uint64_t AUNeuralNet::ProcessMultipleBufferLists(AUNeuralNet *this, unsigned int *a2, int a3, unsigned int a4, const AudioBufferList **a5, unsigned int a6, AudioBufferList **a7)
{
  unsigned int v7;
  uint64_t v10;
  char *v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  float Parameter;
  float v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  float v21;
  float v22;
  uint64_t v23;
  ausdk::AUElement *v24;
  ausdk::AUElement **v25;
  NSObject *v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  unsigned int v30;
  unsigned int v31;
  NSObject *v32;
  uint64_t v33;
  ausdk::AUElement *v34;
  ausdk::AUElement **v35;
  float v36;
  float v37;
  uint64_t v38;
  ausdk::AUElement *v39;
  ausdk::AUElement **v40;
  uint64_t v41;
  ausdk::AUElement *v42;
  ausdk::AUElement **v43;
  unint64_t v44;
  uint64_t v45;
  ausdk::AUElement *v46;
  ausdk::AUElement **v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  ausdk::AUElement **v50;
  uint64_t v51;
  ausdk::AUElement *v52;
  ausdk::AUElement **v53;
  float v54;
  float v55;
  uint64_t v56;
  ausdk::AUElement *v57;
  ausdk::AUElement **v58;
  float v59;
  float v60;
  uint64_t v61;
  ausdk::AUElement *v62;
  ausdk::AUElement **v63;
  float v64;
  float v65;
  uint64_t v66;
  ausdk::AUElement *v67;
  ausdk::AUElement **v68;
  float v69;
  float v70;
  uint64_t v71;
  ausdk::AUElement *v72;
  ausdk::AUElement **v73;
  uint64_t v74;
  ausdk::AUElement *v75;
  ausdk::AUElement **v76;
  int v77;
  unsigned int CurrentLatencyInSamples;
  uint64_t v79;
  ausdk::AUElement *v80;
  ausdk::AUElement **v81;
  const AudioBufferList *v82;
  uint64_t Element;
  int v84;
  int v85;
  NSObject *v87;
  const char *v88;
  NSObject *v89;
  uint64_t v90;
  AudioBufferList *v91;
  uint64_t v92;
  BOOL *v93;
  const AudioBufferList *v94;
  int v95;
  unint64_t BufferList;
  unint64_t v97;
  size_t v98;
  const AudioBufferList *v99;
  uint64_t mNumberBuffers;
  uint64_t v101;
  unsigned int v102;
  char *v103;
  unint64_t v104;
  unint64_t v105;
  float *v106;
  uint64_t v107;
  uint64_t message;
  caulk::concurrent::message *v109;
  uint64_t v110;
  unint64_t v111;
  char v112;
  char v113;
  AudioBufferList *v114;
  _DWORD *v115;
  uint64_t v116;
  int v117;
  int v118;
  _DWORD *v120;
  int v121;
  _BOOL4 v122;
  int v123;
  const AudioBufferList *v124;
  AudioBufferList *v125;
  unsigned int v126;
  uint64_t v127;
  unint64_t v128;
  const void **v129;
  void **v130;
  float *v131;
  uint64_t *v133;
  int v134;
  int v135;
  uint64_t v136;
  unsigned int v137;
  int v138;
  unint64_t v139;
  unsigned int v140;
  unsigned int v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  size_t v145;
  _DWORD *v146;
  unint64_t v147;
  const AudioBufferList *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  int v152;
  int v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  const void **p_mData;
  char *v158;
  uint64_t v159;
  int v160;
  uint64_t v161;
  void *v162;
  _DWORD *v163;
  char *v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  int v168;
  int v169;
  NSObject *v170;
  float v171;
  float v172;
  float v173;
  uint64_t v174;
  ausdk::AUElement *v175;
  ausdk::AUElement **v176;
  BOOL v177;
  uint64_t v178;
  uint64_t v179;
  float v180;
  float v181;
  float v182;
  uint64_t v183;
  ausdk::AUElement *v184;
  ausdk::AUElement **v185;
  unint64_t v186;
  void **v187;
  void *v188;
  uint64_t v189;
  _DWORD *v190;
  int v191;
  uint64_t v192;
  unsigned int v193;
  int v194;
  uint64_t v195;
  uint64_t v196;
  AudioBufferList *v197;
  uint64_t v198;
  BOOL *v199;
  uint64_t v200;
  uint64_t v201;
  caulk::concurrent::message *v202;
  uint64_t v203;
  double v204;
  uint64_t i;
  uint64_t v206;
  AudioBufferList *v207;
  uint64_t v208;
  unint64_t v209;
  uint64_t v210;
  ausdk::AUElement *v211;
  ausdk::AUElement **v212;
  float v213;
  uint64_t v214;
  ausdk::AUElement *v215;
  ausdk::AUElement **v216;
  unint64_t v217;
  float **v218;
  float v219;
  unsigned int v220;
  unint64_t v221;
  float v222;
  const float *v223;
  vDSP_Length v224;
  const float *v225;
  vDSP_Length v226;
  float v227;
  float v228;
  float v229;
  int v230;
  int v231;
  int v232;
  uint64_t v233;
  float v234;
  BOOL v235;
  float v236;
  float v237;
  float v238;
  uint64_t v239;
  ausdk::AUElement *v240;
  ausdk::AUElement **v241;
  float *v242;
  unsigned int v243;
  unsigned int v244;
  unint64_t v245;
  void **v246;
  int v247;
  int v248;
  unsigned int *v249;
  _QWORD *v250;
  unsigned int v251;
  OutputBlockBuffer *v252;
  unsigned int *v253;
  AudioBufferList **v254;
  unsigned int v255;
  AudioBufferList **v256;
  float *__B;
  unsigned int __Ba;
  AudioBufferList *v259;
  int v260;
  int v261;
  _DWORD *v262;
  AudioBufferList **v263;
  _BYTE v265[41];
  int v266;
  uint64_t v267;

  LODWORD(v10) = a3;
  v267 = *MEMORY[0x1E0C80C00];
  v12 = (char *)*((_QWORD *)this + 85);
  if (*((char **)this + 86) == v12)
    goto LABEL_107;
  v13 = *((_QWORD *)this + 9);
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  }
  else
  {
    v15 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v15)
      v14 = 0;
    else
      v14 = *v15;
  }
  Parameter = ausdk::AUElement::GetParameter(v14, 1u);
  v17 = 1.0;
  if (Parameter != 0.0)
    v17 = __exp10f(Parameter / 20.0);
  *((float *)this + 137) = v17;
  v18 = *((_QWORD *)this + 9);
  if (v18)
  {
    v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
  }
  else
  {
    v20 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v20)
      v19 = 0;
    else
      v19 = *v20;
  }
  v21 = ausdk::AUElement::GetParameter(v19, 2u);
  v22 = 1.0;
  if (v21 != 0.0)
    v22 = __exp10f(v21 / 20.0);
  *((float *)this + 138) = v22;
  v23 = *((_QWORD *)this + 9);
  if (v23)
  {
    v24 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
  }
  else
  {
    v25 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v25)
      v24 = 0;
    else
      v24 = *v25;
  }
  v7 = ausdk::AUElement::GetParameter(v24, 5u);
  if (!*(_BYTE *)(*((_QWORD *)this + 100) + 104 * v7 + 96))
  {
    if (getAUNeuralNetLog(void)::onceToken == -1)
      goto LABEL_24;
    goto LABEL_347;
  }
  *((_DWORD *)this + 141) = v7;
  while (1)
  {
    v27 = *((_QWORD *)this + 9);
    if (v27)
    {
      v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
    }
    else
    {
      v29 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v29)
        v28 = 0;
      else
        v28 = *v29;
    }
    v30 = ausdk::AUElement::GetParameter(v28, 6u);
    *((_DWORD *)this + 142) = v30;
    if (v30)
    {
      v31 = v30 - 1;
      if (!*(_BYTE *)(*((_QWORD *)this + 100) + 104 * v31 + 96))
      {
        *((_BYTE *)this + 672) = 0;
        if (getAUNeuralNetLog(void)::onceToken != -1)
          dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
        v32 = getAUNeuralNetLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          v168 = *((_DWORD *)this + 142) - 1;
          v169 = *((_DWORD *)this + 206);
          *(_DWORD *)&v265[21] = 134218496;
          *(_QWORD *)&v265[25] = this;
          *(_WORD *)&v265[33] = 1024;
          *(_DWORD *)&v265[35] = v168;
          *(_WORD *)&v265[39] = 1024;
          v266 = v169;
          _os_log_error_impl(&dword_1B5ED0000, v32, OS_LOG_TYPE_ERROR, "[%p] Tried to select a model indexed at (%u), but only (%u) models are available. A new model will not be selected and AUNeuralNet will run as if bypassed (until a new model is selected).", &v265[21], 0x18u);
        }
        goto LABEL_39;
      }
      *((_DWORD *)this + 141) = v31;
    }
    *((_BYTE *)this + 672) = 1;
LABEL_39:
    v33 = *((_QWORD *)this + 9);
    if (v33)
    {
      v34 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v33 + 32))(v33, 0);
    }
    else
    {
      v35 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v35)
        v34 = 0;
      else
        v34 = *v35;
    }
    v36 = ausdk::AUElement::GetParameter(v34, 7u);
    v37 = 1.0;
    if (v36 != 0.0)
      v37 = __exp10f(v36 / 20.0);
    *((float *)this + 143) = v37;
    v38 = *((_QWORD *)this + 9);
    if (v38)
    {
      v39 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v38 + 32))(v38, 0);
    }
    else
    {
      v40 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v40)
        v39 = 0;
      else
        v39 = *v40;
    }
    *((_BYTE *)this + 592) = ausdk::AUElement::GetParameter(v39, 0xCu) != 0.0;
    v41 = *((_QWORD *)this + 9);
    if (v41)
    {
      v42 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v41 + 32))(v41, 0);
    }
    else
    {
      v43 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v43)
        v42 = 0;
      else
        v42 = *v43;
    }
    *((_BYTE *)this + 593) = ausdk::AUElement::GetParameter(v42, 0xDu) != 0.0;
    if (!*((_BYTE *)this + 592))
    {
      v44 = *(unsigned int *)(*((_QWORD *)this + 100) + 28);
      *(_DWORD *)&v265[21] = 0;
      std::vector<float>::assign((char **)this + 107, v44, &v265[21]);
    }
    v45 = *((_QWORD *)this + 9);
    if (v45)
    {
      v46 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v45 + 32))(v45, 0);
    }
    else
    {
      v47 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v47)
        v46 = 0;
      else
        v46 = *v47;
    }
    *((_BYTE *)this + 600) = ausdk::AUElement::GetParameter(v46, 0x15u) != 0.0;
    v48 = *((_QWORD *)this + 9);
    if (v48)
    {
      v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v48 + 32))(v48, 0);
    }
    else
    {
      v50 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v50)
        v49 = 0;
      else
        v49 = *v50;
    }
    *((_BYTE *)this + 601) = ausdk::AUElement::GetParameter(v49, 0x16u) != 0.0;
    v51 = *((_QWORD *)this + 9);
    if (v51)
    {
      v52 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v51 + 32))(v51, 0);
    }
    else
    {
      v53 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v53)
        v52 = 0;
      else
        v52 = *v53;
    }
    v54 = ausdk::AUElement::GetParameter(v52, 8u);
    v55 = 1.0;
    if (v54 != 0.0)
      v55 = __exp10f(v54 / 20.0);
    *((float *)this + 144) = v55;
    v56 = *((_QWORD *)this + 9);
    if (v56)
    {
      v57 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v56 + 32))(v56, 0);
    }
    else
    {
      v58 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v58)
        v57 = 0;
      else
        v57 = *v58;
    }
    v59 = ausdk::AUElement::GetParameter(v57, 9u);
    v60 = 1.0;
    if (v59 != 0.0)
      v60 = __exp10f(v59 / 20.0);
    *((float *)this + 145) = v60;
    v61 = *((_QWORD *)this + 9);
    if (v61)
    {
      v62 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v61 + 32))(v61, 0);
    }
    else
    {
      v63 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v63)
        v62 = 0;
      else
        v62 = *v63;
    }
    v64 = ausdk::AUElement::GetParameter(v62, 0xAu);
    v65 = 1.0;
    if (v64 != 0.0)
      v65 = __exp10f(v64 / 20.0);
    *((float *)this + 146) = v65;
    v66 = *((_QWORD *)this + 9);
    if (v66)
    {
      v67 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v66 + 32))(v66, 0);
    }
    else
    {
      v68 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v68)
        v67 = 0;
      else
        v67 = *v68;
    }
    v69 = ausdk::AUElement::GetParameter(v67, 0xBu);
    v70 = 1.0;
    if (v69 != 0.0)
      v70 = __exp10f(v69 / 20.0);
    *((float *)this + 147) = v70;
    v71 = *((_QWORD *)this + 9);
    if (v71)
    {
      v72 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v71 + 32))(v71, 0);
    }
    else
    {
      v73 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v73)
        v72 = 0;
      else
        v72 = *v73;
    }
    *((float *)this + 153) = ausdk::AUElement::GetParameter(v72, 0x19u);
    v74 = *((_QWORD *)this + 9);
    if (v74)
    {
      v75 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v74 + 32))(v74, 0);
    }
    else
    {
      v76 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v76)
        v75 = 0;
      else
        v75 = *v76;
    }
    *((float *)this + 154) = ausdk::AUElement::GetParameter(v75, 0x1Au);
    *((_QWORD *)this + 86) = v12;
LABEL_107:
    v77 = *((_DWORD *)this + 245);
    CurrentLatencyInSamples = AUNeuralNet::GetCurrentLatencyInSamples(this);
    *((_DWORD *)this + 245) = CurrentLatencyInSamples;
    if (v77 != CurrentLatencyInSamples)
    {
      v79 = *((_QWORD *)this + 9);
      if (v79)
      {
        v80 = (ausdk::AUElement *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v79 + 32))(*((_QWORD *)this + 9), 0);
        CurrentLatencyInSamples = *((_DWORD *)this + 245);
      }
      else
      {
        v81 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v81)
          v80 = 0;
        else
          v80 = *v81;
      }
      ausdk::AUElement::SetParameter(v80, 0xEu, (float)CurrentLatencyInSamples, 0);
    }
    v82 = *a5;
    if (!*a5)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v89 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)&v265[21] = 134217984;
        *(_QWORD *)&v265[25] = this;
        _os_log_error_impl(&dword_1B5ED0000, v89, OS_LOG_TYPE_ERROR, "[%p] input not connected", &v265[21], 0xCu);
      }
      return 4294956420;
    }
    v12 = (char *)this + 80;
    Element = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
    v84 = *(_DWORD *)(Element + 108);
    if ((*(_DWORD *)(Element + 92) & 0x20) != 0)
      v85 = *(_DWORD *)(Element + 108);
    else
      v85 = 1;
    if ((*(_DWORD *)(Element + 92) & 0x20) != 0)
      v84 = 1;
    if (v82->mNumberBuffers != v85 || v82->mBuffers[0].mNumberChannels != v84)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v87 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)&v265[21] = 134217984;
        *(_QWORD *)&v265[25] = this;
        v88 = "[%p] input format not supported";
        goto LABEL_191;
      }
      return 4294956428;
    }
    v265[0] = 0;
    v91 = (AudioBufferList *)*a5;
    v92 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
    AudioDSP::Utility::DetectNonFinites(0, v91, (const AudioBufferList *)(v92 + 80), (const AudioStreamBasicDescription *)v265, v93);
    v261 = v10;
    if (!v265[0])
      goto LABEL_151;
    v94 = *a5;
    v95 = (_DWORD)this + 1376;
    BufferList = ausdk::AUBufferList::GetBufferList((AUNeuralNet *)((char *)this + 1376));
    if (v94->mNumberBuffers == *(_DWORD *)BufferList)
      break;
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_347:
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
LABEL_24:
    v26 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      v167 = *((_DWORD *)this + 206);
      *(_DWORD *)&v265[21] = 134218496;
      *(_QWORD *)&v265[25] = this;
      *(_WORD *)&v265[33] = 1024;
      *(_DWORD *)&v265[35] = v7;
      *(_WORD *)&v265[39] = 1024;
      v266 = v167;
      _os_log_error_impl(&dword_1B5ED0000, v26, OS_LOG_TYPE_ERROR, "[%p] Tried to select a model indexed at (%u), but only (%u) models are available. A new model will not be selected and the previous selection will be used.", &v265[21], 0x18u);
    }
  }
  if (v94->mNumberBuffers)
  {
    v10 = 0;
    v97 = 0;
    while (1)
    {
      v98 = *(unsigned int *)(BufferList + v10 + 12);
      if ((_DWORD)v98 != *(UInt32 *)((char *)&v94->mBuffers[0].mDataByteSize + v10))
        break;
      memcpy(*(void **)(BufferList + v10 + 16), *(const void **)((char *)&v94->mBuffers[0].mData + v10), v98);
      ++v97;
      v10 += 16;
      if (v97 >= *(unsigned int *)BufferList)
        goto LABEL_139;
    }
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_242:
    v176 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v176)
      v175 = 0;
    else
      v175 = *v176;
    goto LABEL_245;
  }
LABEL_139:
  v99 = (const AudioBufferList *)ausdk::AUBufferList::GetBufferList((AUNeuralNet *)((char *)this + 1376));
  LODWORD(v10) = v261;
  *a5 = v99;
  mNumberBuffers = v99->mNumberBuffers;
  if ((_DWORD)mNumberBuffers)
  {
    v101 = 0;
    v102 = 0;
    do
    {
      v103 = (char *)v99 + 16 * v101;
      v104 = *((unsigned int *)v103 + 3);
      if (v104 >= 4)
      {
        v105 = v104 >> 2;
        v106 = (float *)*((_QWORD *)v103 + 2);
        do
        {
          if (fabsf(*v106) == INFINITY)
          {
            *v106 = 0.0;
            ++v102;
          }
          ++v106;
          --v105;
        }
        while (v105);
      }
      ++v101;
    }
    while (v101 != mNumberBuffers);
  }
  else
  {
    v102 = 0;
  }
  v107 = _os_log_pack_size();
  message = caulk::deferred_logger::create_message(*((caulk::deferred_logger **)this + 66), v107 + 88, 16);
  if (message)
  {
    v109 = (caulk::concurrent::message *)message;
    v110 = _os_log_pack_fill();
    *(_DWORD *)v110 = 134217984;
    *(_QWORD *)(v110 + 4) = v102;
    LODWORD(v10) = v261;
    caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(*((_QWORD *)this + 66) + 16), v109);
  }
LABEL_151:
  v111 = 0;
  *(_OWORD *)&v265[5] = 0uLL;
  v112 = 1;
  do
  {
    v113 = v112;
    if (v111 >= a6)
      v114 = 0;
    else
      v114 = a7[v111];
    v112 = 0;
    *(_QWORD *)&v265[8 * v111 + 5] = v114;
    v111 = 1;
  }
  while ((v113 & 1) != 0);
  v115 = *(_DWORD **)&v265[5];
  if (*(_QWORD *)&v265[5])
  {
    v116 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0);
    v117 = *(_DWORD *)(v116 + 108);
    if ((*(_DWORD *)(v116 + 92) & 0x20) != 0)
      v118 = *(_DWORD *)(v116 + 108);
    else
      v118 = 1;
    if ((*(_DWORD *)(v116 + 92) & 0x20) != 0)
      v117 = 1;
    if (*v115 != v118 || v115[2] != v117)
    {
      if (getAUNeuralNetLog(void)::onceToken != -1)
        dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
      v87 = getAUNeuralNetLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)&v265[21] = 134217984;
        *(_QWORD *)&v265[25] = this;
        v88 = "[%p] processed output format not supported";
        goto LABEL_191;
      }
      return 4294956428;
    }
  }
  v120 = *(_DWORD **)&v265[13];
  if (*(_QWORD *)&v265[13] && **(_DWORD **)&v265[13] != *((_DWORD *)this + 165))
  {
    if (getAUNeuralNetLog(void)::onceToken != -1)
      dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
    v87 = getAUNeuralNetLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)&v265[21] = 134217984;
      *(_QWORD *)&v265[25] = this;
      v88 = "[%p] gain vector format not supported";
LABEL_191:
      _os_log_error_impl(&dword_1B5ED0000, v87, OS_LOG_TYPE_ERROR, v88, &v265[21], 0xCu);
    }
    return 4294956428;
  }
  else
  {
    v121 = *((_DWORD *)this + 167);
    v122 = v121 == 0;
    *((_BYTE *)this + 1245) = 0;
    v262 = v120;
    v263 = a7;
    if (!*((_BYTE *)this + 1244) || v121)
    {
      if (*((_BYTE *)this + 664))
      {
        v124 = *a5;
        v125 = *a7;
        v126 = *((_DWORD *)this + 141);
        v127 = *((_QWORD *)this + 100);
        *((_BYTE *)this + 1245) = v121 == 0;
        if (!v121 && *((_BYTE *)this + 672) && (v154 = v127 + 104 * v126, *(_BYTE *)(v154 + 96)))
        {
          v259 = v125;
          v95 = *((_DWORD *)this + 136);
          v155 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v127 + 64) + 24))(*(_QWORD *)(v127 + 64));
          if (*((_DWORD *)this + 136) == (_DWORD)v10)
          {
            v156 = 0;
            v254 = (AudioBufferList **)(v127 + 104 * v126);
            __B = (float *)((char *)this + 548);
            v250 = (_QWORD *)(v154 + 64);
            v252 = (AUNeuralNet *)((char *)this + 832);
            p_mData = (const void **)&v124->mBuffers[0].mData;
            BufferList = v155 / *(unsigned int *)(*((_QWORD *)this + 100) + 8);
            while (v156 < *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0) + 108))
            {
              v158 = (char *)*p_mData;
              v159 = *((unsigned int *)this + 136);
              v160 = 2 * v156 * BufferList;
              v161 = *((_QWORD *)this + 104);
              v162 = (void *)(v161 + 4 * v160);
              if (v95 == (_DWORD)BufferList)
              {
                if (2 * (_DWORD)v159)
                {
                  memmove((void *)(v161 + 4 * v160), v158, 4 * (2 * v159));
                  LODWORD(v159) = *((_DWORD *)this + 136);
                  v161 = *((_QWORD *)this + 104);
                }
                v163 = (_DWORD *)(v161 + 4 * (v159 + v160));
              }
              else
              {
                v163 = (_DWORD *)(v161 + 4 * ((int)BufferList + 2 * (int)v156 * (int)BufferList));
                v164 = &v158[4 * v159];
                if ((_DWORD)v159 && (memmove(v162, v158, 4 * v159), v165 = *((unsigned int *)this + 136), (_DWORD)v165))
                {
                  memmove(v163, v164, 4 * v165);
                  v166 = *((unsigned int *)this + 136);
                }
                else
                {
                  v166 = 0;
                }
                *((_DWORD *)v162 + v166) = *(_DWORD *)v164;
                v163[v166] = 0;
              }
              *v163 = 0;
              ++v156;
              p_mData += 2;
              a7 = v263;
            }
            *(_DWORD *)&v265[21] = 0;
            vDSP_measqv(*((const float **)this + 104), 1, (float *)&v265[21], (2 * *((_DWORD *)this + 136)));
            v171 = *((float *)this + 156);
            v172 = *((float *)this + 139);
            v173 = (float)((float)(1.0 - v171) * (float)(log10f(*(float *)&v265[21] + 2.2204e-16) * 10.0))
                 + (float)(v171 * v172);
            *((float *)this + 139) = v173;
            v174 = *((_QWORD *)this + 9);
            if (!v174)
              goto LABEL_242;
            v175 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v174 + 32))(v174, 0);
            v173 = *((float *)this + 139);
LABEL_245:
            ausdk::AUElement::SetParameter(v175, 3u, v173, 0);
            v177 = *(float *)&v265[21] < *((float *)this + 138);
            vDSP_vsmul(*((const float **)this + 104), 1, __B, *((float **)this + 104), 1, (uint64_t)(*((_QWORD *)this + 105) - *((_QWORD *)this + 104)) >> 2);
            AUNeuralNet::ApplyEmbedding((uint64_t)this, (uint64_t)v254);
            if (v177)
            {
              *(_DWORD *)&v265[1] = 0;
              vDSP_vfill((const float *)&v265[1], *((float **)this + 110), 1, (uint64_t)(*((_QWORD *)this + 111) - *((_QWORD *)this + 110)) >> 2);
            }
            else
            {
              v178 = (*(uint64_t (**)(_QWORD, OutputBlockBuffer *))(*(_QWORD *)*v250 + 72))(*v250, v252);
              v179 = *(_QWORD *)(v178 + 8);
              if (v179 != *(_QWORD *)v178)
                memmove(*((void **)this + 110), *(const void **)v178, v179 - *(_QWORD *)v178);
              vDSP_vsdiv(*((const float **)this + 110), 1, __B, *((float **)this + 110), 1, (uint64_t)(*((_QWORD *)this + 111) - *((_QWORD *)this + 110)) >> 2);
            }
            vDSP_measqv(*((const float **)this + 110), 1, (float *)&v265[21], (uint64_t)(*((_QWORD *)this + 111) - *((_QWORD *)this + 110)) >> 2);
            v180 = *((float *)this + 156);
            v181 = *((float *)this + 140);
            v182 = (float)((float)(1.0 - v180) * (float)(log10f(*(float *)&v265[21] + 2.2204e-16) * 10.0))
                 + (float)(v180 * v181);
            *((float *)this + 140) = v182;
            v183 = *((_QWORD *)this + 9);
            if (v183)
            {
              v184 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v183 + 32))(v183, 0);
              v182 = *((float *)this + 140);
            }
            else
            {
              v185 = (ausdk::AUElement **)*((_QWORD *)this + 6);
              if (*((ausdk::AUElement ***)this + 7) == v185)
                v184 = 0;
              else
                v184 = *v185;
            }
            ausdk::AUElement::SetParameter(v184, 4u, v182, 0);
            if (*((_DWORD *)this + 165))
            {
              v186 = 0;
              v187 = &v259->mBuffers[0].mData;
              do
              {
                v188 = *v187;
                v189 = *((unsigned int *)this + 136);
                v190 = (char *)*v187 + 4 * v189;
                v191 = v186 * BufferList;
                v192 = *((_QWORD *)this + 110);
                if (v95 == (_DWORD)BufferList)
                {
                  v193 = 2 * v189;
                  v194 = 0;
                  if (v193)
                    memmove(v188, (const void *)(v192 + 8 * v191), 4 * v193);
                }
                else
                {
                  if ((_DWORD)v189
                    && (memmove(v188, (const void *)(v192 + 8 * v191), 4 * v189),
                        v195 = *((unsigned int *)this + 136),
                        (_DWORD)v195))
                  {
                    memmove(v190, (const void *)(v192 + 4 * ((int)BufferList + 2 * v191)), 4 * v195);
                    v196 = *((unsigned int *)this + 136);
                  }
                  else
                  {
                    v196 = 0;
                  }
                  v194 = *(_DWORD *)(v192 + 8 * v191 + 4 * v196);
                }
                LODWORD(v10) = v261;
                *v190 = v194;
                ++v186;
                v187 += 2;
              }
              while (v186 < *((unsigned int *)this + 165));
            }
            goto LABEL_266;
          }
          if (getAUNeuralNetLog(void)::onceToken != -1)
            dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
          v170 = getAUNeuralNetLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
          {
            v248 = *(_DWORD *)(v127 + 104 * v126 + 20);
            *(_DWORD *)&v265[21] = 134218496;
            *(_QWORD *)&v265[25] = this;
            *(_WORD *)&v265[33] = 1024;
            *(_DWORD *)&v265[35] = v248;
            *(_WORD *)&v265[39] = 1024;
            v266 = v10;
            _os_log_error_impl(&dword_1B5ED0000, v170, OS_LOG_TYPE_ERROR, "[%p] NeuralNet expects input block size %u, and we received %d.", &v265[21], 0x18u);
          }
          v90 = 4294956422;
LABEL_267:
          v122 = 1;
        }
        else
        {
          if (*((_DWORD *)this + 165))
          {
            v128 = 0;
            v129 = (const void **)&v124->mBuffers[0].mData;
            v130 = &v125->mBuffers[0].mData;
            do
            {
              v131 = (float *)*v130;
              if (v128 >= *((unsigned int *)this + 164))
              {
                *(_DWORD *)&v265[21] = 0;
                vDSP_vfill((const float *)&v265[21], v131, 1, (2 * v10));
              }
              else if (2 * (_DWORD)v10)
              {
                memmove(*v130, *v129, 4 * (2 * v10));
              }
              ++v128;
              v129 += 2;
              v130 += 2;
            }
            while (v128 < *((unsigned int *)this + 165));
          }
          v90 = 0;
        }
      }
      else
      {
        v90 = AUNeuralNet::ProcessFuncCore(this, v10, a5, a7);
      }
    }
    else
    {
      v123 = *((_DWORD *)this + 312);
      if (v123 != 2)
      {
        if (v123 == 1)
        {
          v90 = BlockProcessor::Process(*((BlockProcessor **)this + 157), v10, a5, a7);
          goto LABEL_267;
        }
LABEL_266:
        v90 = 0;
        goto LABEL_267;
      }
      v133 = (uint64_t *)*((_QWORD *)this + 158);
      *((_BYTE *)v133 + 96) = 0;
      v134 = *((_DWORD *)v133 + 22);
      if (v134 == (_DWORD)v10)
      {
        if ((_DWORD)v10)
        {
          v135 = 0;
          v136 = *((unsigned int *)v133 + 3);
          v253 = (unsigned int *)(v133 + 3);
          v249 = (unsigned int *)(v133 + 6);
          v137 = v10;
          v251 = *((_DWORD *)v133 + 3);
          do
          {
            v138 = *((_DWORD *)v133 + 4);
            v139 = *((unsigned int *)v133 + 2);
            __Ba = v137;
            if (*((_DWORD *)v133 + 3) - v138 >= v137)
              v140 = v137;
            else
              v140 = *((_DWORD *)v133 + 3) - v138;
            v260 = v135;
            if ((_DWORD)v139)
            {
              v141 = v140;
              v142 = 0;
              v143 = (4 * v135);
              v144 = (4 * v138);
              v255 = v141;
              v145 = 4 * v141;
              do
              {
                v146 = *(_DWORD **)(*v133 + 8 * v142);
                if (*v146)
                {
                  v147 = 0;
                  v148 = a5[v142];
                  v149 = 4;
                  do
                  {
                    memcpy((void *)(*(_QWORD *)&v146[v149] + v144), (const void *)(*(_QWORD *)((char *)&v148->mNumberBuffers + v149 * 4) + v143), v145);
                    ++v147;
                    v149 += 4;
                  }
                  while (v147 < *v146);
                  v139 = *((unsigned int *)v133 + 2);
                  a7 = v263;
                }
                ++v142;
              }
              while (v142 < v139);
              v138 = *((_DWORD *)v133 + 4);
              LODWORD(v10) = v261;
              v135 = v260;
              v136 = v251;
              v140 = v255;
            }
            *((_DWORD *)v133 + 4) = v138 + v140;
            if (v138 + v140 == (_DWORD)v136)
            {
              v150 = *v133;
              v151 = v133[6];
              v256 = (AudioBufferList **)v133[3];
              *((_DWORD *)v133 + 16) = 0;
              v90 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v133[9])(v133[10], v136, v150, v151);
              v152 = *((_DWORD *)v133 + 23) - *((_DWORD *)v133 + 10);
              v153 = v152 & ~(v152 >> 31);
              OutputBlockBuffer::Read(v253, v153, 0, a7);
              OutputBlockBuffer::Read(v249, v140 - v153, v153, a7);
              OutputBlockBuffer::Read(v249, v136 - (v140 - v153), 0, v256);
              *((_DWORD *)v133 + 4) = 0;
              *((_DWORD *)v133 + 10) = 0;
              *((_BYTE *)v133 + 96) = 1;
              v135 = v260;
              if ((_DWORD)v90)
                goto LABEL_215;
            }
            else
            {
              OutputBlockBuffer::Read(v253, v140, v135, a7);
            }
            v135 += v140;
            v137 = __Ba - v140;
          }
          while (__Ba != v140);
          v90 = 0;
LABEL_215:
          v133 = (uint64_t *)*((_QWORD *)this + 158);
          v134 = *((_DWORD *)v133 + 22);
        }
        else
        {
          v134 = 0;
          v90 = 0;
        }
      }
      else
      {
        v90 = 4294956428;
      }
      v122 = (v134 + *((_DWORD *)v133 + 4)) >= *((_DWORD *)v133 + 3);
    }
    v265[1] = 0;
    v197 = *a7;
    v198 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0);
    AudioDSP::Utility::DetectNonFinites(0, v197, (const AudioBufferList *)(v198 + 80), (const AudioStreamBasicDescription *)&v265[1], v199);
    if (v265[1])
    {
      v200 = _os_log_pack_size();
      v201 = caulk::deferred_logger::create_message(*((caulk::deferred_logger **)this + 66), v200 + 88, 16);
      if (v201)
      {
        v202 = (caulk::concurrent::message *)v201;
        v203 = _os_log_pack_fill();
        v204 = *((float *)this + 139);
        *(_DWORD *)v203 = 134217984;
        *(double *)(v203 + 4) = v204;
        caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(*((_QWORD *)this + 66) + 16), v202);
      }
      for (i = 0; i != 624; i += 104)
      {
        v206 = *((_QWORD *)this + 100) + i;
        if (*(_BYTE *)(v206 + 96))
          (*(void (**)(_QWORD))(**(_QWORD **)(v206 + 64) + 48))(*(_QWORD *)(v206 + 64));
      }
      v207 = *a7;
      if ((*a7)->mNumberBuffers)
      {
        v208 = 0;
        v209 = 0;
        do
        {
          memcpy(v207->mBuffers[v208].mData, **((const void ***)this + 132), v207->mBuffers[v208].mDataByteSize);
          ++v209;
          v207 = *a7;
          ++v208;
        }
        while (v209 < (*a7)->mNumberBuffers);
      }
      *((_DWORD *)this + 140) = *((_DWORD *)this + 139);
      *((_DWORD *)this + 152) = *((_DWORD *)this + 151);
      LODWORD(v10) = v261;
    }
    v210 = *((_QWORD *)this + 9);
    if (v210)
    {
      v211 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v210 + 32))(v210, 0);
    }
    else
    {
      v212 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v212)
        v211 = 0;
      else
        v211 = *v212;
    }
    v213 = 0.0;
    if (*((_BYTE *)this + 1245))
      v213 = 1.0;
    ausdk::AUElement::SetParameter(v211, 0x10u, v213, 0);
    v214 = *((_QWORD *)this + 9);
    if (v214)
    {
      v215 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v214 + 32))(v214, 0);
    }
    else
    {
      v216 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v216)
        v215 = 0;
      else
        v215 = *v216;
    }
    ausdk::AUElement::SetParameter(v215, 0xFu, (float)v122, 0);
    if (*((_DWORD *)this + 167) || !*((_BYTE *)this + 672) || *((_DWORD *)this + 136) != (_DWORD)v10 || v265[1])
    {
      *(_DWORD *)&v265[21] = 1065353216;
      vDSP_vfill((const float *)&v265[21], *((float **)this + 113), 1, (uint64_t)(*((_QWORD *)this + 114) - *((_QWORD *)this + 113)) >> 2);
      vDSP_vfill((const float *)&v265[21], *((float **)this + 116), 1, (uint64_t)(*((_QWORD *)this + 117) - *((_QWORD *)this + 116)) >> 2);
      vDSP_vfill((const float *)&v265[21], *((float **)this + 119), 1, (uint64_t)(*((_QWORD *)this + 120) - *((_QWORD *)this + 119)) >> 2);
      if (v262 && *v262)
      {
        v217 = 0;
        v218 = (float **)(v262 + 4);
        do
        {
          vDSP_vfill((const float *)&v265[21], *v218, 1, (unint64_t)*((unsigned int *)v218 - 1) >> 2);
          ++v217;
          v218 += 2;
        }
        while (v217 < *v262);
      }
    }
    else
    {
      v219 = AUNeuralNet::ComputeGainMask(this, v10, *a5, *a7);
      v220 = *((_DWORD *)this + 328);
      if (v220 >= *((_DWORD *)this + 165))
        v221 = 0;
      else
        v221 = v220;
      if (*((_DWORD *)this + 318))
      {
        v222 = v219;
        vDSP_vclip((const float *)(*((_QWORD *)this + 113) + 4 * ((*((_DWORD *)this + 136) + 1) * v221)), 1, &AUNeuralNet::ProcessMultipleBufferLists(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**)::kZero, &AUNeuralNet::ProcessMultipleBufferLists(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**)::kOne, *((float **)this + 119), 1, (*((_DWORD *)this + 136) + 1));
        switch(*((_DWORD *)this + 318))
        {
          case 1:
            vDSP_meanv(*((const float **)this + 119), 1, (float *)this + 149, (*((_DWORD *)this + 136) + 1));
            goto LABEL_327;
          case 2:
            v233 = *((_QWORD *)this + 165);
            if (v221 >= (*((_QWORD *)this + 166) - v233) >> 2)
              std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
            v234 = *(float *)(v233 + 4 * v221)
                 / (float)((float)(v222 + 2.2204e-16)
                         + (float)((float)*((unsigned int *)this + 136) * *((float *)this + 327)));
            goto LABEL_319;
          case 3:
            v223 = (const float *)*((_QWORD *)this + 160);
            v224 = (uint64_t)(*((_QWORD *)this + 161) - (_QWORD)v223) >> 2;
            if (v224 == *((_DWORD *)this + 136) + 1)
            {
              vDSP_dotpr(*((const float **)this + 119), 1, v223, 1, (float *)this + 149, v224);
              *((float *)this + 149) = *((float *)this + 326) * *((float *)this + 149);
            }
            else
            {
              *((_DWORD *)this + 149) = 0;
            }
            goto LABEL_327;
          case 4:
            *(_DWORD *)&v265[21] = 0;
            v225 = (const float *)*((_QWORD *)this + 160);
            v226 = (uint64_t)(*((_QWORD *)this + 161) - (_QWORD)v225) >> 2;
            v227 = 0.0;
            if (v226 == *((_DWORD *)this + 136) + 1)
            {
              vDSP_dotpr(*((const float **)this + 119), 1, v225, 1, (float *)&v265[21], v226);
              v227 = *((float *)this + 326) * *(float *)&v265[21];
            }
            v228 = (float)((float)(1.0 - *((float *)this + 339)) * v227)
                 + (float)(*((float *)this + 339) * *((float *)this + 338));
            *((float *)this + 338) = v228;
            v229 = *((float *)this + 340);
            v230 = v228 > v229;
            v231 = *((_DWORD *)this + 341);
            if (*(_QWORD *)((char *)this + 1364))
            {
              if (*((_DWORD *)this + 336) == v230)
              {
                v232 = *((_DWORD *)this + 337);
                if (!v232)
                  goto LABEL_323;
                v231 = v232 - 1;
              }
              else if (v228 <= v229)
              {
                v231 = *((_DWORD *)this + 342);
              }
              *((_DWORD *)this + 337) = v231;
              if (v231)
              {
LABEL_326:
                *((_DWORD *)this + 336) = v230;
                goto LABEL_327;
              }
LABEL_323:
              v235 = v228 <= v229;
              v236 = 0.0;
              if (!v235)
                v236 = 1.0;
              *((float *)this + 149) = v236;
              goto LABEL_326;
            }
            v235 = v228 <= v229;
            v234 = 0.0;
            if (!v235)
              v234 = 1.0;
LABEL_319:
            *((float *)this + 149) = v234;
LABEL_327:
            v237 = *((float *)this + 149);
            v238 = 0.0;
            if (v237 >= 0.0)
            {
              v238 = 1.0;
              if (v237 <= 1.0)
                v238 = *((float *)this + 149);
            }
            *((float *)this + 149) = v238;
            v239 = *((_QWORD *)this + 9);
            if (v239)
            {
              v240 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v239 + 32))(v239, 0);
              v238 = *((float *)this + 149);
            }
            else
            {
              v241 = (ausdk::AUElement **)*((_QWORD *)this + 6);
              if (*((ausdk::AUElement ***)this + 7) == v241)
                v240 = 0;
              else
                v240 = *v241;
            }
            ausdk::AUElement::SetParameter(v240, 0x13u, v238, 0);
            break;
          default:
            goto LABEL_327;
        }
      }
      memcpy(*((void **)this + 119), *((const void **)this + 113), *((_QWORD *)this + 114) - *((_QWORD *)this + 113));
      v242 = (float *)*((_QWORD *)this + 113);
      *(_DWORD *)&v265[21] = (*((_QWORD *)this + 114) - (_QWORD)v242) >> 2;
      vvpowsf(v242, (const float *)this + 153, v242, (const int *)&v265[21]);
      vvpowsf(*((float **)this + 119), (const float *)this + 154, *((const float **)this + 119), (const int *)&v265[21]);
      vDSP_vclip(*((const float **)this + 113), 1, (const float *)this + 144, (const float *)this + 145, *((float **)this + 113), 1, (uint64_t)(*((_QWORD *)this + 114) - *((_QWORD *)this + 113)) >> 2);
      vDSP_vclip(*((const float **)this + 119), 1, (const float *)this + 146, (const float *)this + 147, *((float **)this + 119), 1, (uint64_t)(*((_QWORD *)this + 120) - *((_QWORD *)this + 119)) >> 2);
      if (*((_DWORD *)this + 165))
      {
        v243 = 0;
        do
        {
          memcpy((void *)(*((_QWORD *)this + 116) + 4 * *((_DWORD *)this + 136) * v243), (const void *)(*((_QWORD *)this + 113) + 4 * (v243 + *((_DWORD *)this + 136) * v243)), 4 * *((unsigned int *)this + 136));
          ++v243;
          v244 = *((_DWORD *)this + 165);
        }
        while (v243 < v244);
        if (v244)
        {
          v245 = 0;
          v246 = (void **)(v262 + 4);
          do
          {
            if (v262)
            {
              v247 = *((_DWORD *)this + 136);
              if (v247)
              {
                memmove(*v246, (const void *)(*((_QWORD *)this + 116) + 4 * (v247 * v245)), 4 * (v247 * v245 + v247) - 4 * (v247 * v245));
                v244 = *((_DWORD *)this + 165);
              }
            }
            ++v245;
            v246 += 2;
          }
          while (v245 < v244);
        }
      }
    }
  }
  return v90;
}

uint64_t AUNeuralNet::Render(AUNeuralNet *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  uint64_t Element;
  uint64_t v10;
  ausdk::AUInputElement *v11;
  uint64_t result;
  unsigned int v13;
  uint64_t BufferList;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v8 = (AUNeuralNet *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0);
  v10 = ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0);
  v13 = 0;
  v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  result = ausdk::AUInputElement::PullInput(v11, &v13, a3, 0, a4);
  if (!(_DWORD)result)
  {
    v15[0] = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    return (*(uint64_t (**)(AUNeuralNet *, unsigned int *, uint64_t, uint64_t, _QWORD *, uint64_t, uint64_t *))(*(_QWORD *)this + 184))(this, a2, a4, 1, v15, 1, &BufferList);
  }
  return result;
}

BOOL AUNeuralNet::BusCountWritable(AUNeuralNet *this, int a2)
{
  return a2 == 2 && *((_BYTE *)this + 17) == 0;
}

uint64_t AUNeuralNet::SetBusCount(AUNeuralNet *this, int a2, unsigned int a3)
{
  int64x2_t *v3;
  unsigned int v4;
  uint64_t v5;

  if (a2 == 1 && a3 == 1)
  {
    v3 = (int64x2_t *)((char *)this + 80);
    v4 = 1;
LABEL_7:
    ausdk::AUScope::SetNumberOfElements(v3, v4);
    return 0;
  }
  v5 = 4294956445;
  if (a2 == 2 && a3 - 1 <= 1)
  {
    v3 = (int64x2_t *)((char *)this + 128);
    v4 = a3;
    goto LABEL_7;
  }
  return v5;
}

uint64_t AUNeuralNet::GetParameterList(AUNeuralNet *this, int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;

  if (a2)
    return 4294956430;
  if (a3)
  {
    *(_OWORD *)a3 = xmmword_1B6626920;
    *((_OWORD *)a3 + 1) = xmmword_1B66A0770;
    *((_OWORD *)a3 + 2) = xmmword_1B66A07D0;
    *((_OWORD *)a3 + 3) = xmmword_1B66A07E0;
    *((_OWORD *)a3 + 4) = xmmword_1B66A07F0;
    *((_OWORD *)a3 + 5) = xmmword_1B66A0800;
    *((_QWORD *)a3 + 12) = 0x1900000018;
    a3[26] = 26;
  }
  result = 0;
  *a4 = 27;
  return result;
}

uint64_t AUNeuralNet::GetParameterInfo(AUNeuralNet *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v6;
  UInt32 v7;
  AudioUnitParameterUnit v8;
  AudioUnitParameterValue v9;
  AudioUnitParameterValue v10;
  AudioUnitParameterValue v11;
  int v12;
  AudioUnitParameterOptions flags;

  buffer->flags = 0;
  buffer->unitName = 0;
  if (a2)
    return 4294956430;
  if (a3 > 0x1A)
    return 4294956418;
  v6 = (const __CFString *)*((_QWORD *)&off_1E69C97C8 + a3);
  v7 = dword_1B66314A0[a3];
  v8 = dword_1B663150C[a3];
  v9 = flt_1B6631578[a3];
  v10 = flt_1B66315E4[a3];
  v11 = flt_1B6631650[a3];
  v12 = dword_1B66316BC[a3];
  buffer->cfNameString = v6;
  buffer->flags = 0x8000000;
  CFStringGetCString(v6, buffer->name, 52, 0x8000100u);
  result = 0;
  buffer->clumpID = v7;
  flags = buffer->flags;
  buffer->unit = v8;
  buffer->minValue = v9;
  buffer->maxValue = v10;
  buffer->defaultValue = v11;
  buffer->flags = flags | v12;
  return result;
}

uint64_t AUNeuralNet::GetParameterValueStrings(AUNeuralNet *this, int a2, int a3, const __CFArray **a4)
{
  uint64_t result;
  uint64_t i;
  std::string *v7;
  __int128 v8;
  void **v9;
  CFArrayRef v10;
  const __CFArray *v11;
  std::string v12;
  void *__p[2];
  int64_t v14;
  void *values[2];
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 0;
  if (a2)
    return 4294956430;
  if (a3 == 17)
  {
    *(_OWORD *)values = xmmword_1E69C9730;
    *(_QWORD *)&v16 = CFSTR("LowDelay");
    v10 = CFArrayCreate(0, (const void **)values, 3, 0);
  }
  else if (a3 == 6)
  {
    *(_OWORD *)values = xmmword_1E69C96F8;
    v16 = unk_1E69C9708;
    v17 = xmmword_1E69C9718;
    v18 = 0;
    for (i = 1; i != 7; ++i)
    {
      std::to_string(&v12, i - 1);
      v7 = std::string::insert(&v12, 0, "Model_", 6uLL);
      v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v14 = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v12.__r_.__value_.__l.__data_);
      if (v14 >= 0)
        v9 = __p;
      else
        v9 = (void **)__p[0];
      values[i] = (void *)CFStringCreateWithCString(0, (const char *)v9, 0x8000100u);
      if (SHIBYTE(v14) < 0)
        operator delete(__p[0]);
    }
    v10 = CFArrayCreate(0, (const void **)values, 7, 0);
  }
  else
  {
    values[0] = CFSTR("Parameter Name Unimplemented");
    v10 = CFArrayCreate(0, (const void **)values, 1, 0);
  }
  v11 = v10;
  result = 0;
  *a4 = v11;
  return result;
}

void sub_1B616F1F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double AUNeuralNet::GetLatency(AUNeuralNet *this)
{
  uint64_t v1;
  unsigned int v2;
  _DWORD *v3;

  v1 = *((_QWORD *)this + 100);
  v2 = *(unsigned __int8 *)(v1 + 96);
  if (*(_BYTE *)(v1 + 96))
    v2 = *(_DWORD *)(v1 + 16);
  if (*((_BYTE *)this + 1244))
  {
    if (*((_DWORD *)this + 312) == 2)
      v3 = (_DWORD *)(*((_QWORD *)this + 158) + 92);
    else
      v3 = (_DWORD *)(v1 + 20);
    v2 += *v3;
  }
  return (double)v2 / *(double *)v1;
}

double AUNeuralNet::GetTailTime(AUNeuralNet *this)
{
  return 0.0;
}

uint64_t AUNeuralNet::SupportsTail(AUNeuralNet *this)
{
  return 1;
}

BOOL AUNeuralNet::StreamFormatWritable(AUNeuralNet *this, int a2)
{
  return (a2 - 1) <= 1 && *((_BYTE *)this + 17) == 0;
}

uint64_t AUNeuralNet::SupportedNumChannels(AUNeuralNet *this, const AUChannelInfo **a2)
{
  uint64_t v2;
  __int16 *v3;
  __int16 *v4;
  uint64_t i;

  v2 = 0;
  v3 = &word_1EF134E4A;
  do
  {
    v4 = v3;
    for (i = 1; i != 37; ++i)
    {
      *(v4 - 1) = v2 + 1;
      *v4 = i;
      v4 += 2;
    }
    ++v2;
    v3 += 72;
  }
  while (v2 != 16);
  if (a2)
    *a2 = (const AUChannelInfo *)&AUNeuralNet::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 576;
}

uint64_t AUNeuralNet::ValidFormat(AUNeuralNet *this, int a2, int a3, const AudioStreamBasicDescription *a4)
{
  AudioFormatFlags mFormatFlags;
  AudioFormatID mFormatID;
  AudioFormatFlags v6;
  AudioFormatFlags v7;
  AudioFormatID v8;
  UInt32 mBitsPerChannel;
  UInt32 mChannelsPerFrame;
  UInt32 mBytesPerPacket;
  UInt32 mBytesPerFrame;
  BOOL v14;
  BOOL v17;
  AudioFormatFlags v18;
  int v19;
  _BOOL4 v20;
  _BOOL4 v21;
  int v22;
  int v23;
  int v24;
  BOOL v25;
  int v26;

  if (a2 != 2)
  {
    if (a2 == 1 && !a3)
    {
      mFormatID = a4->mFormatID;
      mFormatFlags = a4->mFormatFlags;
      if (mFormatID == 1718773105)
      {
        v24 = (mFormatFlags >> 5) & 1;
        if (a4->mBitsPerChannel != 64)
          v24 = 0;
        if ((mFormatFlags & 1) != 0)
          v6 = v24;
        else
          v6 = 0;
      }
      else
      {
        v6 = a4->mFormatFlags & 1;
        if (mFormatID != 1819304813)
          v6 = 0;
      }
      v25 = a4->mChannelsPerFrame >= 0x11;
      goto LABEL_60;
    }
    return 0;
  }
  if (a3 == 1)
  {
    mChannelsPerFrame = a4->mChannelsPerFrame;
    mBitsPerChannel = a4->mBitsPerChannel;
    mBytesPerPacket = a4->mBytesPerPacket;
    mBytesPerFrame = a4->mBytesPerFrame;
    v14 = a4->mFormatID == 1819304813 && a4->mFramesPerPacket == 1;
    v17 = !v14 || mBytesPerFrame != mBytesPerPacket || mBitsPerChannel >> 3 > mBytesPerFrame || mChannelsPerFrame == 0;
    if (!v17
      && ((v18 = a4->mFormatFlags, (v18 & 0x20) != 0)
       || (v14 = mBytesPerPacket == mBytesPerPacket / mChannelsPerFrame * mChannelsPerFrame,
           mBytesPerPacket /= mChannelsPerFrame,
           v14)))
    {
      v19 = 8 * mBytesPerPacket;
      v20 = mBytesPerPacket == 4 && (a4->mFormatFlags & 0x1F84) == 0;
      if ((v18 & 1) != 0)
      {
        v21 = (a4->mFormatFlags & 0x1F84) == 0;
      }
      else
      {
        v20 = 0;
        v21 = 1;
      }
      if (v19 == mBitsPerChannel)
      {
        v22 = v21;
      }
      else
      {
        v20 = 0;
        v22 = 1;
      }
      if ((v18 & 2) != 0)
      {
        v20 = 0;
        v23 = 1;
      }
      else
      {
        v23 = v22;
      }
    }
    else
    {
      v20 = 0;
      v23 = 0;
    }
    v14 = mBitsPerChannel == 32;
    v6 = v20 & v23;
    if (!v14)
      v6 = 0;
  }
  else
  {
    if (a3)
      return 0;
    v8 = a4->mFormatID;
    v7 = a4->mFormatFlags;
    if (v8 == 1718773105)
    {
      v26 = (v7 >> 5) & 1;
      if (a4->mBitsPerChannel != 64)
        v26 = 0;
      if ((v7 & 1) != 0)
        v6 = v26;
      else
        v6 = 0;
    }
    else
    {
      v6 = a4->mFormatFlags & 1;
      if (v8 != 1819304813)
        v6 = 0;
    }
    mChannelsPerFrame = a4->mChannelsPerFrame;
  }
  v25 = mChannelsPerFrame >= 0x25;
LABEL_60:
  if (v25)
    return 0;
  else
    return v6;
}

uint64_t AUNeuralNet::GetCurrentLatencyInSamples(AUNeuralNet *this)
{
  uint64_t v2;
  uint64_t result;
  _DWORD *v4;

  if ((!*((_DWORD *)this + 167) || *((_BYTE *)this + 1372)) && (v2 = *((_QWORD *)this + 100), *(_BYTE *)(v2 + 96)))
    result = *(unsigned int *)(v2 + 16);
  else
    result = 0;
  if (*((_BYTE *)this + 1244))
  {
    if (*((_DWORD *)this + 312) == 2)
      v4 = (_DWORD *)(*((_QWORD *)this + 158) + 92);
    else
      v4 = (_DWORD *)(*((_QWORD *)this + 100) + 20);
    return (*v4 + result);
  }
  return result;
}

uint64_t AUNeuralNet::ProcessFuncCore(AUNeuralNet *this, unsigned int a2, const AudioBufferList **a3, AudioBufferList **a4)
{
  ausdk::AUScope *v7;
  int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  vDSP_Stride v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  const float *v22;
  char *v23;
  const float **v24;
  int v25;
  const float *v26;
  uint64_t v27;
  float *v28;
  unsigned int i;
  uint64_t v31;
  unsigned int *v32;
  int v33;
  unint64_t v34;
  uint64_t v35;
  _DWORD *v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  unint64_t v42;
  unsigned int *v43;
  uint64_t v44;
  float v45;
  float v46;
  float v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  ausdk::AUElement **v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  float v54;
  uint64_t v55;
  ausdk::AUElement *v56;
  ausdk::AUElement **v57;
  float v58;
  float v59;
  float v60;
  uint64_t v61;
  ausdk::AUElement *v62;
  ausdk::AUElement **v63;
  float v64;
  uint64_t v65;
  ausdk::AUElement *v66;
  ausdk::AUElement **v67;
  float v68;
  float v69;
  float v70;
  float v71;
  unsigned int v72;
  float v73;
  unsigned int v74;
  uint64_t v75;
  unint64_t v76;
  float *v77;
  unint64_t v78;
  unsigned int v79;
  unsigned int v80;
  float v81;
  unsigned int v82;
  uint64_t v83;
  unint64_t v84;
  float *v85;
  unint64_t v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  unsigned int v98;
  BOOL v99;
  unsigned int v100;
  float v101;
  float v102;
  float v103;
  uint64_t v104;
  ausdk::AUElement *v105;
  ausdk::AUElement **v106;
  uint64_t v107;
  unsigned int v108;
  uint64_t v109;
  unsigned int v110;
  uint64_t v111;
  unsigned int v112;
  _DWORD *v113;
  uint64_t v114;
  unsigned int v115;
  uint64_t v116;
  unsigned int v117;
  vDSP_Stride __IA;
  uint64_t v119;
  uint64_t v120;
  char v121;
  char v122;
  vDSP_Length __N;
  float __D;
  uint64_t v126;
  float __C;
  AUNeuralNet *v128;
  __int16 v129;
  unsigned int v130;
  __int16 v131;
  unsigned int v132;
  uint64_t v133;

  v133 = *MEMORY[0x1E0C80C00];
  v7 = (AUNeuralNet *)((char *)this + 80);
  v8 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0) + 92);
  v9 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0) + 92);
  v121 = v8;
  if ((v8 & 0x20) != 0)
  {
    v10 = 1;
    if ((v9 & 0x20) != 0)
      goto LABEL_3;
LABEL_5:
    v11 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0) + 108);
    goto LABEL_6;
  }
  v10 = *(_DWORD *)(ausdk::AUScope::SafeGetElement(v7, 0) + 108);
  if ((v9 & 0x20) == 0)
    goto LABEL_5;
LABEL_3:
  v11 = 1;
LABEL_6:
  v12 = (uint64_t)*a3;
  v13 = (uint64_t)*a4;
  v14 = *((_DWORD *)this + 141);
  v15 = *((_QWORD *)this + 100);
  v16 = *((_DWORD *)this + 167);
  *((_BYTE *)this + 1245) = v16 == 0;
  v119 = v13;
  v120 = v12;
  if (v16 || !*((_BYTE *)this + 672) || !*(_BYTE *)(v15 + 104 * v14 + 96))
  {
    if (!*((_DWORD *)this + 165))
      return 0;
    v17 = 0;
    v18 = v11;
    v19 = 4 * v10;
    v20 = 4 * v11;
    __IA = v10;
    while (1)
    {
      if ((v9 & 0x20) != 0)
        v21 = *(float **)(v13 + 16 * v17 + 16);
      else
        v21 = (float *)(*(_QWORD *)(v13 + 16) + 4 * v17);
      if (v17 >= *((unsigned int *)this + 164))
      {
        vDSP_vclr(v21, v18, a2);
      }
      else
      {
        if ((v121 & 0x20) != 0)
          v22 = *(const float **)(v120 + 16 * v17 + 16);
        else
          v22 = (const float *)(*(_QWORD *)(v120 + 16) + 4 * v17);
        if (!*((_BYTE *)this + 1372))
          goto LABEL_22;
        v23 = *(char **)(*((_QWORD *)this + 132) + 24 * v17);
        memmove(v23, &v23[4 * *((unsigned int *)this + 136)], 4 * *((unsigned int *)this + 244));
        v24 = (const float **)(*((_QWORD *)this + 132) + 24 * v17);
        if (a2)
        {
          v25 = *((_DWORD *)this + 244);
          v26 = *v24;
          v27 = a2;
          do
          {
            v26[v25++] = *v22;
            v22 = (const float *)((char *)v22 + v19);
            --v27;
          }
          while (v27);
          v22 = v26;
          v13 = v119;
LABEL_22:
          if (v22 == v21)
          {
            v28 = v21;
            for (i = a2; i; --i)
            {
              *v21 = *v28;
              v28 = (float *)((char *)v28 + v19);
              v21 = (float *)((char *)v21 + v20);
            }
            goto LABEL_28;
          }
LABEL_27:
          vDSP_vclr(v21, v18, a2);
          vDSP_vadd(v22, __IA, v21, v18, v21, v18, a2);
          goto LABEL_28;
        }
        v22 = *v24;
        v13 = v119;
        if (*v24 != v21)
          goto LABEL_27;
      }
LABEL_28:
      if (++v17 >= *((unsigned int *)this + 165))
        return 0;
    }
  }
  v31 = v15 + 104 * v14;
  v33 = *(_DWORD *)(v31 + 20);
  v32 = (unsigned int *)(v31 + 20);
  if (v33 == a2)
  {
    v34 = 0;
    v117 = v11;
    __N = v15 + 104 * v14;
    v35 = 4 * v10;
    while (v34 < *(unsigned int *)(ausdk::AUScope::SafeGetElement(v7, 0) + 108))
    {
      if ((v121 & 0x20) != 0)
        v36 = *(_DWORD **)(v120 + 16 * v34 + 16);
      else
        v36 = (_DWORD *)(*(_QWORD *)(v120 + 16) + 4 * v34);
      if (a2)
      {
        v37 = *((_QWORD *)this + 104);
        v38 = *v32 * v34;
        v39 = a2;
        do
        {
          *(_DWORD *)(v37 + 4 * v38++) = *v36;
          v36 = (_DWORD *)((char *)v36 + v35);
          --v39;
        }
        while (v39);
      }
      ++v34;
    }
    v122 = v9;
    if (*((_DWORD *)this + 164))
    {
      v41 = 0;
      v42 = 0;
      if (*((_BYTE *)this + 1244))
        v43 = (unsigned int *)((char *)this + 976);
      else
        v43 = (unsigned int *)(v15 + 104 * v14 + 16);
      v44 = *v43;
      do
      {
        memmove(*(void **)(*((_QWORD *)this + 132) + v41), (const void *)(*(_QWORD *)(*((_QWORD *)this + 132) + v41) + 4 * *v32), 4 * v44);
        memcpy((void *)(*(_QWORD *)(*((_QWORD *)this + 132) + v41) + 4 * v44), (const void *)(*((_QWORD *)this + 104) + 4 * *v32 * v42++), 4 * *v32);
        v41 += 24;
      }
      while (v42 < *((unsigned int *)this + 164));
    }
    __C = 0.0;
    vDSP_measqv(**((const float ***)this + 132), 1, &__C, *((unsigned int *)this + 136));
    v45 = *((float *)this + 156);
    v46 = *((float *)this + 139);
    v47 = (float)((float)(1.0 - v45) * (float)(log10f(__C + 2.2204e-16) * 10.0)) + (float)(v45 * v46);
    *((float *)this + 139) = v47;
    v48 = *((_QWORD *)this + 9);
    if (v48)
    {
      v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v48 + 32))(v48, 0);
      v47 = *((float *)this + 139);
    }
    else
    {
      v50 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v50)
        v49 = 0;
      else
        v49 = *v50;
    }
    ausdk::AUElement::SetParameter(v49, 3u, v47, 0);
    v126 = 0;
    if (*((_DWORD *)this + 164))
    {
      v51 = 0;
      v52 = 0;
      do
      {
        vDSP_measqv(*(const float **)(*((_QWORD *)this + 132) + v51), 1, (float *)&v126, *((unsigned int *)this + 136));
        v53 = *((unsigned int *)this + 164);
        v54 = *((float *)&v126 + 1) + (float)(*(float *)&v126 / (float)v53);
        *((float *)&v126 + 1) = v54;
        ++v52;
        v51 += 24;
      }
      while (v52 < v53);
    }
    else
    {
      v54 = 0.0;
    }
    if (!*((_BYTE *)this + 652))
      v54 = (float)((float)(1.0 - *((float *)this + 156)) * v54)
          + (float)(*((float *)this + 156) * *((float *)this + 151));
    *((float *)this + 151) = v54;
    v55 = *((_QWORD *)this + 9);
    if (v55)
    {
      v56 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v55 + 32))(v55, 0);
      v54 = *((float *)this + 151);
    }
    else
    {
      v57 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v57)
        v56 = 0;
      else
        v56 = *v57;
    }
    ausdk::AUElement::SetParameter(v56, 0x17u, v54, 0);
    __C = 0.0;
    vDSP_measqv(*((const float **)this + 104), 1, &__C, (uint64_t)(*((_QWORD *)this + 105) - *((_QWORD *)this + 104)) >> 2);
    v58 = __C;
    v59 = *((float *)this + 138);
    vDSP_vsmul(*((const float **)this + 104), 1, (const float *)this + 137, *((float **)this + 104), 1, (uint64_t)(*((_QWORD *)this + 105) - *((_QWORD *)this + 104)) >> 2);
    AUNeuralNet::ApplyEmbedding((uint64_t)this, __N);
    if (*((_BYTE *)this + 600))
    {
      AUNeuralNet::ProcessAUNNModel((uint64_t)this, __N);
      HIDWORD(v126) = 0;
      vDSP_measqv(*((const float **)this + 110), 1, (float *)&v126 + 1, (uint64_t)(*((_QWORD *)this + 111) - *((_QWORD *)this + 110)) >> 2);
      if (*((_BYTE *)this + 652))
      {
        v60 = *((float *)&v126 + 1);
        *((_BYTE *)this + 652) = 0;
      }
      else
      {
        v60 = (float)((float)(1.0 - *((float *)this + 156)) * *((float *)&v126 + 1))
            + (float)(*((float *)this + 156) * *((float *)this + 152));
      }
      *((float *)this + 152) = v60;
      v61 = *((_QWORD *)this + 9);
      if (v61)
      {
        v62 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v61 + 32))(v61, 0);
        v60 = *((float *)this + 152);
      }
      else
      {
        v63 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v63)
          v62 = 0;
        else
          v62 = *v63;
      }
      ausdk::AUElement::SetParameter(v62, 0x18u, v60, 0);
      v68 = *((float *)this + 157);
      v69 = 0.0;
      if (v68 != 0.0)
      {
        v70 = **((double **)this + 100);
        v69 = expf(-1.0 / (float)((float)(v68 * v70) / (float)a2));
      }
      v71 = 1.0 - v69;
      if (*((_BYTE *)this + 601))
      {
        *((_DWORD *)this + 160) = 0;
        v72 = *((_DWORD *)this + 159);
        if (!v72)
          *(_QWORD *)((char *)this + 644) = 1065353216;
        if (v72 >= *((_DWORD *)this + 158))
        {
          v88 = *((_DWORD *)this + 164);
          v89 = *((_DWORD *)this + 165);
          if (v88 >= v89)
            v90 = *((_DWORD *)this + 165);
          else
            v90 = *((_DWORD *)this + 164);
          if (v90)
          {
            v91 = 0;
            v92 = 0;
            do
            {
              v93 = *v32;
              if ((_DWORD)v93)
              {
                memmove((void *)(*((_QWORD *)this + 110) + 4 * (v93 * v92)), *(const void **)(*((_QWORD *)this + 132) + v91), 4 * v93);
                v88 = *((_DWORD *)this + 164);
                v89 = *((_DWORD *)this + 165);
              }
              ++v92;
              if (v88 >= v89)
                v94 = v89;
              else
                v94 = v88;
              v91 += 24;
            }
            while (v92 < v94);
          }
        }
        else
        {
          v73 = (float)(v71 * *((float *)this + 162)) + (float)(v69 * *((float *)this + 161));
          *((float *)this + 161) = v73;
          __D = 1.0 - v73;
          v74 = *((_DWORD *)this + 164);
          if (v74 >= *((_DWORD *)this + 165))
            v74 = *((_DWORD *)this + 165);
          if (v74)
          {
            v75 = 0;
            v76 = 0;
            do
            {
              v77 = (float *)(*((_QWORD *)this + 110) + 4 * *v32 * v76);
              vDSP_vsmsma(v77, 1, (const float *)this + 161, *(const float **)(*((_QWORD *)this + 132) + v75), 1, &__D, v77, 1, *v32);
              ++v76;
              LODWORD(v78) = *((_DWORD *)this + 164);
              v79 = *((_DWORD *)this + 165);
              if (v78 >= v79)
                v78 = v79;
              else
                v78 = v78;
              v75 += 24;
            }
            while (v76 < v78);
            v72 = *((_DWORD *)this + 159);
          }
          *((_DWORD *)this + 159) = v72 + 1;
        }
      }
      else
      {
        *((_DWORD *)this + 159) = 0;
        v80 = *((_DWORD *)this + 160);
        if (!v80)
          *(_QWORD *)((char *)this + 644) = 0x3F80000000000000;
        if (v80 < *((_DWORD *)this + 158))
        {
          v81 = (float)(v71 * *((float *)this + 162)) + (float)(v69 * *((float *)this + 161));
          *((float *)this + 161) = v81;
          __D = 1.0 - v81;
          v82 = *((_DWORD *)this + 164);
          if (v82 >= *((_DWORD *)this + 165))
            v82 = *((_DWORD *)this + 165);
          if (v82)
          {
            v83 = 0;
            v84 = 0;
            do
            {
              v85 = (float *)(*((_QWORD *)this + 110) + 4 * *v32 * v84);
              vDSP_vsmsma(v85, 1, (const float *)this + 161, *(const float **)(*((_QWORD *)this + 132) + v83), 1, &__D, v85, 1, *v32);
              ++v84;
              LODWORD(v86) = *((_DWORD *)this + 164);
              v87 = *((_DWORD *)this + 165);
              if (v86 >= v87)
                v86 = v87;
              else
                v86 = v86;
              v83 += 24;
            }
            while (v84 < v86);
            v80 = *((_DWORD *)this + 160);
          }
          *((_DWORD *)this + 160) = v80 + 1;
        }
      }
    }
    else
    {
      if (v58 >= v59)
        AUNeuralNet::ProcessAUNNModel((uint64_t)this, __N);
      else
        vDSP_vclr(*((float **)this + 110), 1, (uint64_t)(*((_QWORD *)this + 111) - *((_QWORD *)this + 110)) >> 2);
      HIDWORD(v126) = 0;
      vDSP_measqv(*((const float **)this + 110), 1, (float *)&v126 + 1, (uint64_t)(*((_QWORD *)this + 111) - *((_QWORD *)this + 110)) >> 2);
      if (*((_BYTE *)this + 652))
      {
        v64 = *((float *)&v126 + 1);
        *((_BYTE *)this + 652) = 0;
      }
      else
      {
        v64 = (float)((float)(1.0 - *((float *)this + 156)) * *((float *)&v126 + 1))
            + (float)(*((float *)this + 156) * *((float *)this + 152));
      }
      *((float *)this + 152) = v64;
      v65 = *((_QWORD *)this + 9);
      if (v65)
      {
        v66 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v65 + 32))(v65, 0);
        v64 = *((float *)this + 152);
      }
      else
      {
        v67 = (ausdk::AUElement **)*((_QWORD *)this + 6);
        if (*((ausdk::AUElement ***)this + 7) == v67)
          v66 = 0;
        else
          v66 = *v67;
      }
      ausdk::AUElement::SetParameter(v66, 0x18u, v64, 0);
    }
    v96 = *v32;
    v97 = *((_DWORD *)this + 136);
    if (*v32 >= v97)
      v98 = *((_DWORD *)this + 136);
    else
      v98 = *v32;
    v99 = v97 >= v96;
    v100 = v97 - v96;
    if (!v99)
      v100 = 0;
    memcpy((void *)(*((_QWORD *)this + 135) + 4 * v100), *((const void **)this + 110), 4 * v98);
    vDSP_measqv(*((const float **)this + 135), 1, &__C, *((unsigned int *)this + 136));
    v101 = *((float *)this + 156);
    v102 = *((float *)this + 140);
    v103 = (float)((float)(1.0 - v101) * (float)(log10f(__C + 2.2204e-16) * 10.0)) + (float)(v101 * v102);
    *((float *)this + 140) = v103;
    v104 = *((_QWORD *)this + 9);
    if (v104)
    {
      v105 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v104 + 32))(v104, 0);
      v103 = *((float *)this + 140);
    }
    else
    {
      v106 = (ausdk::AUElement **)*((_QWORD *)this + 6);
      if (*((ausdk::AUElement ***)this + 7) == v106)
        v105 = 0;
      else
        v105 = *v106;
    }
    ausdk::AUElement::SetParameter(v105, 4u, v103, 0);
    v107 = *v32;
    v108 = *((_DWORD *)this + 136);
    if (v108 > v107)
      memcpy(*((void **)this + 135), (const void *)(*((_QWORD *)this + 135) + 4 * v107), 4 * (v108 - v107));
    v109 = *((unsigned int *)this + 165);
    if ((_DWORD)v109)
    {
      v110 = 0;
      v111 = 0;
      v112 = *v32;
      do
      {
        if ((v122 & 0x20) != 0)
          v113 = *(_DWORD **)(v119 + 16 * v111 + 16);
        else
          v113 = (_DWORD *)(*(_QWORD *)(v119 + 16) + 4 * v111);
        if (a2)
        {
          v114 = *((_QWORD *)this + 110);
          v115 = v110;
          v116 = a2;
          do
          {
            *v113 = *(_DWORD *)(v114 + 4 * v115++);
            v113 += v117;
            --v116;
          }
          while (v116);
        }
        ++v111;
        v110 += v112;
      }
      while (v111 != v109);
    }
    return 0;
  }
  if (getAUNeuralNetLog(void)::onceToken != -1)
    dispatch_once(&getAUNeuralNetLog(void)::onceToken, &__block_literal_global_66);
  v40 = getAUNeuralNetLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUNeuralNetLog(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    v95 = *v32;
    __C = 3.8522e-34;
    v128 = this;
    v129 = 1024;
    v130 = v95;
    v131 = 1024;
    v132 = a2;
    _os_log_error_impl(&dword_1B5ED0000, v40, OS_LOG_TYPE_ERROR, "[%p] NeuralNet expects input block size %u, and we received %d.", (uint8_t *)&__C, 0x18u);
  }
  return 4294956422;
}

float AUNeuralNet::ComputeGainMask(AUNeuralNet *this, unsigned int a2, const AudioBufferList *a3, const AudioBufferList *a4)
{
  const float *mData;
  int v8;
  float *v9;
  float *v10;
  float v11;
  float v12;
  uint64_t v13;
  unint64_t v14;
  void **p_mData;
  char *v16;
  uint64_t v17;
  float *v18;
  float *v19;
  float v20;
  float v21;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  char *v29;
  uint64_t v30;
  float *v31;
  VPTimeFreqConverter *v32;
  float *realp;
  unint64_t v34;
  uint64_t v35;
  float *v36;
  const float *v37;
  float *v38;
  uint64_t v39;
  uint64_t v40;
  float *v41;
  VPTimeFreqConverter *v42;
  float *v43;
  DSPSplitComplex v45;
  DSPSplitComplex v46;
  DSPSplitComplex __B;
  float __C;
  DSPSplitComplex __A;

  __C = 0.0;
  if (*((_BYTE *)this + 664))
  {
    mData = (const float *)a3->mBuffers[0].mData;
    vDSP_svesq(mData, 1, &__C, (2 * *((_DWORD *)this + 136)));
    v8 = *((_DWORD *)this + 136);
    if (2 * v8)
    {
      memmove(*((void **)this + 138), mData, 4 * (2 * v8));
      v8 = *((_DWORD *)this + 136);
    }
    v9 = (float *)*((_QWORD *)this + 138);
    v10 = &v9[v8];
    LODWORD(__B.realp) = 629145600;
    v11 = *v9;
    v12 = *v10;
    __A.realp = v9 + 1;
    __A.imagp = v10 + 1;
    vDSP_zvabs(&__A, 1, v9 + 1, 1, (v8 - 1));
    *v9 = fabsf(v11);
    *v10 = fabsf(v12);
    vDSP_vthr(v9, 1, (const float *)&__B, v9, 1, (v8 + 1));
    if (*((_DWORD *)this + 165))
    {
      v13 = 0;
      v14 = 0;
      p_mData = &a4->mBuffers[0].mData;
      do
      {
        v16 = (char *)*p_mData;
        p_mData += 2;
        vDSP_svesq((const float *)v16, 1, (float *)(*((_QWORD *)this + 165) + v13), (2 * *((_DWORD *)this + 136)));
        v17 = *((unsigned int *)this + 136);
        v18 = (float *)*((_QWORD *)this + 141);
        v19 = (float *)&v16[4 * v17];
        v20 = *(float *)v16;
        v21 = *v19;
        __A.realp = (float *)(v16 + 4);
        __A.imagp = v19 + 1;
        vDSP_zvabs(&__A, 1, v18 + 1, 1, (v17 - 1));
        *v18 = fabsf(v20);
        v18[v17] = fabsf(v21);
        vDSP_vdiv(*((const float **)this + 138), 1, *((const float **)this + 141), 1, (float *)(*((_QWORD *)this + 113) + 4 * ((*((_DWORD *)this + 136) + 1) * v14++)), 1, (*((_DWORD *)this + 136) + 1));
        v13 += 4;
      }
      while (v14 < *((unsigned int *)this + 165));
    }
    return __C;
  }
  v23 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0) + 92);
  v24 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0) + 92);
  if ((v23 & 0x20) != 0)
  {
    v25 = 1;
    if ((v24 & 0x20) != 0)
    {
LABEL_10:
      v26 = 1;
      if (a2)
        goto LABEL_11;
      goto LABEL_16;
    }
  }
  else
  {
    v25 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 80), 0) + 108);
    if ((v24 & 0x20) != 0)
      goto LABEL_10;
  }
  v26 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUNeuralNet *)((char *)this + 128), 0) + 108);
  if (a2)
  {
LABEL_11:
    v27 = 0;
    v28 = a3->mBuffers[0].mData;
    v29 = (char *)*((_QWORD *)this + 126);
    do
    {
      *(_DWORD *)&v29[v27] = *v28;
      v27 += 4;
      v28 += v25;
    }
    while (4 * a2 != v27);
    goto LABEL_17;
  }
LABEL_16:
  v29 = (char *)*((_QWORD *)this + 126);
LABEL_17:
  memcpy((void *)(*((_QWORD *)this + 123) + 4 * *((unsigned int *)this + 244)), v29, 4 * *((unsigned int *)this + 136));
  v30 = *((unsigned int *)this + 136);
  __A.realp = (float *)*((_QWORD *)this + 138);
  __A.imagp = &__A.realp[v30];
  v31 = __A.realp + 1;
  __B.realp = __A.realp + 1;
  __B.imagp = __A.imagp + 1;
  v32 = (VPTimeFreqConverter *)*((_QWORD *)this + 144);
  if (v32)
  {
    VPTimeFreqConverter::Analyze(v32, *((const float **)this + 123), &__A);
    LODWORD(v30) = *((_DWORD *)this + 136);
  }
  vDSP_zvabs(&__B, 1, v31, 1, (v30 - 1));
  realp = __A.realp;
  *__A.realp = fabsf(*__A.realp);
  *__A.imagp = fabsf(*__A.imagp);
  vDSP_vthr(realp, 1, &AUNeuralNet::eps, realp, 1, (*((_DWORD *)this + 136) + 1));
  if (*((_DWORD *)this + 165))
  {
    v34 = 0;
    v35 = 4 * v26;
    do
    {
      if ((v24 & 0x20) != 0)
        v36 = (float *)a4->mBuffers[v34].mData;
      else
        v36 = (float *)((char *)a4->mBuffers[0].mData + 4 * v34);
      v37 = (const float *)*((_QWORD *)this + 129);
      v38 = (float *)v37;
      v39 = a2;
      if (a2)
      {
        do
        {
          *v38++ = *v36;
          v36 = (float *)((char *)v36 + v35);
          --v39;
        }
        while (v39);
      }
      vDSP_svesq(v37, 1, (float *)(*((_QWORD *)this + 165) + 4 * v34), *((unsigned int *)this + 136));
      v40 = *((unsigned int *)this + 136);
      v46.realp = (float *)*((_QWORD *)this + 141);
      v46.imagp = &v46.realp[v40];
      v41 = v46.realp + 1;
      v45.realp = v46.realp + 1;
      v45.imagp = v46.imagp + 1;
      v42 = *(VPTimeFreqConverter **)(*((_QWORD *)this + 145) + 8 * v34);
      if (v42)
      {
        VPTimeFreqConverter::Analyze(v42, *((const float **)this + 129), &v46);
        v41 = v45.realp;
        LODWORD(v40) = *((_DWORD *)this + 136);
      }
      vDSP_zvabs(&v45, 1, v41, 1, (v40 - 1));
      v43 = v46.realp;
      *v46.realp = fabsf(*v46.realp);
      *v46.imagp = fabsf(*v46.imagp);
      vDSP_vdiv(__A.realp, 1, v43, 1, (float *)(*((_QWORD *)this + 113) + 4 * ((*((_DWORD *)this + 136) + 1) * v34++)), 1, (*((_DWORD *)this + 136) + 1));
    }
    while (v34 < *((unsigned int *)this + 165));
  }
  vDSP_svesq(*((const float **)this + 123), 1, &__C, *((unsigned int *)this + 136));
  memmove(*((void **)this + 123), (const void *)(*((_QWORD *)this + 123) + 4 * *((unsigned int *)this + 136)), 4 * *((unsigned int *)this + 244));
  return __C;
}

uint64_t AUNeuralNet::ApplyEmbedding(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t message;
  caulk::concurrent::message *v9;
  _DWORD *v10;
  uint64_t v12;
  char v13;

  v12 = a1 + 1240;
  v4 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(a1 + 1240));
  v13 = v4;
  if (v4)
  {
    if (*(_BYTE *)(a1 + 592))
    {
      v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 64) + 56))(*(_QWORD *)(a2 + 64), a1 + 856);
    }
    else
    {
      if (!*(_BYTE *)(a1 + 593))
        return std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v12);
      v5 = (*(uint64_t (**)(_QWORD, float))(**(_QWORD **)(a2 + 64) + 64))(*(_QWORD *)(a2 + 64), 0.0);
    }
    v6 = v5;
    if (v5)
    {
      v7 = _os_log_pack_size();
      message = caulk::deferred_logger::create_message(*(caulk::deferred_logger **)(a1 + 528), v7 + 88, 16);
      if (message)
      {
        v9 = (caulk::concurrent::message *)message;
        v10 = (_DWORD *)_os_log_pack_fill();
        *v10 = 67109120;
        v10[1] = v6;
        caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(*(_QWORD *)(a1 + 528) + 16), v9);
      }
    }
  }
  return std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v12);
}

void sub_1B6170570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void AUNeuralNet::ProcessAUNNModel(uint64_t a1, uint64_t a2)
{
  const void **v4;
  int v5;
  float v6;
  float v7;
  uint64_t v8;
  unint64_t v9;
  float *v10;
  float __D;

  v4 = (const void **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 64) + 72))(*(_QWORD *)(a2 + 64), a1 + 832);
  v5 = *(_DWORD *)(a1 + 660);
  if (v5 * *(_DWORD *)(a2 + 20))
    memmove(*(void **)(a1 + 880), *v4, 4 * (v5 * *(_DWORD *)(a2 + 20)));
  vDSP_vsdiv(*(const float **)(a1 + 880), 1, (const float *)(a1 + 548), *(float **)(a1 + 880), 1, (uint64_t)(*(_QWORD *)(a1 + 888) - *(_QWORD *)(a1 + 880)) >> 2);
  v6 = *(float *)(a1 + 572);
  __D = 1.0 - v6;
  if (*(_DWORD *)(a1 + 660) == 1 && v6 > __exp10f(-5.0))
  {
    vDSP_vsmsma(**(const float ***)(a1 + 1056), 1, (const float *)(a1 + 572), *(const float **)(a1 + 880), 1, &__D, *(float **)(a1 + 880), 1, (uint64_t)(*(_QWORD *)(a1 + 888) - *(_QWORD *)(a1 + 880)) >> 2);
  }
  else if (*(_DWORD *)(a2 + 24) >= 2u && *(_DWORD *)(a2 + 8) == 1 && *(_DWORD *)(a2 + 12) == 1)
  {
    v7 = *(float *)(a1 + 572);
    if (v7 > __exp10f(-5.0))
    {
      if (*(_DWORD *)(a1 + 656))
      {
        v8 = 0;
        v9 = 0;
        do
        {
          v10 = (float *)(*(_QWORD *)(a1 + 880) + 4 * (*(_DWORD *)(a2 + 20) * v9));
          vDSP_vsmsma(*(const float **)(*(_QWORD *)(a1 + 1056) + v8), 1, (const float *)(a1 + 572), v10, 1, &__D, v10, 1, *(unsigned int *)(a2 + 20));
          ++v9;
          v8 += 24;
        }
        while (v9 < *(unsigned int *)(a1 + 656));
      }
    }
  }
}

os_log_t ___Z17getAUNeuralNetLogv_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreaudio", "AUNeuralNet");
  getAUNeuralNetLog(void)::gLog = (uint64_t)result;
  return result;
}

applesauce::CF::ArrayRef *applesauce::CF::ArrayRef::from_get(applesauce::CF::ArrayRef *this, CFTypeRef cf)
{
  applesauce::CF::ArrayRef *v2;

  v2 = this;
  if (cf)
  {
    CFRetain(cf);
    return applesauce::CF::ArrayRef::ArrayRef(v2, cf);
  }
  else
  {
    *(_QWORD *)this = 0;
  }
  return this;
}

_QWORD *applesauce::CF::ArrayRef::operator->(_QWORD *result)
{
  std::runtime_error *exception;

  if (!*result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_1B61707E4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void applesauce::CF::convert_as<std::vector<float>,0>(uint64_t a1, const __CFArray *a2)
{
  CFTypeID TypeID;
  int Count;
  CFIndex v6;
  uint64_t v7;
  const __CFNumber *ValueAtIndex;
  uint64_t v9;
  int v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  int v20;
  char *v21;
  void *__p;
  char *v23;
  char *v24;

  if (a2 && (TypeID = CFArrayGetTypeID(), TypeID == CFGetTypeID(a2)))
  {
    Count = CFArrayGetCount(a2);
    __p = 0;
    v23 = 0;
    v24 = 0;
    std::vector<float>::reserve(&__p, Count);
    if (Count <= 0)
    {
      v12 = v23;
LABEL_26:
      v21 = v24;
      *(_QWORD *)a1 = __p;
      *(_QWORD *)(a1 + 8) = v12;
      *(_QWORD *)(a1 + 16) = v21;
      *(_BYTE *)(a1 + 24) = 1;
    }
    else
    {
      v6 = 0;
      v7 = Count;
      while (1)
      {
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a2, v6);
        v9 = applesauce::CF::convert_as<float,0>(ValueAtIndex);
        if ((v9 & 0xFF00000000) == 0)
          break;
        v10 = v9;
        v11 = v23;
        if (v23 >= v24)
        {
          v13 = (char *)__p;
          v14 = (v23 - (_BYTE *)__p) >> 2;
          v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 62)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          v16 = v24 - (_BYTE *)__p;
          if ((v24 - (_BYTE *)__p) >> 1 > v15)
            v15 = v16 >> 1;
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL)
            v17 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v17 = v15;
          if (v17)
          {
            v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v24, v17);
            v13 = (char *)__p;
            v11 = v23;
          }
          else
          {
            v18 = 0;
          }
          v19 = &v18[4 * v14];
          *(_DWORD *)v19 = v10;
          v12 = v19 + 4;
          while (v11 != v13)
          {
            v20 = *((_DWORD *)v11 - 1);
            v11 -= 4;
            *((_DWORD *)v19 - 1) = v20;
            v19 -= 4;
          }
          __p = v19;
          v23 = v12;
          v24 = &v18[4 * v17];
          if (v13)
            operator delete(v13);
        }
        else
        {
          *(_DWORD *)v23 = v9;
          v12 = v11 + 4;
        }
        v23 = v12;
        if (++v6 == v7)
          goto LABEL_26;
      }
      *(_BYTE *)a1 = 0;
      *(_BYTE *)(a1 + 24) = 0;
      if (__p)
      {
        v23 = (char *)__p;
        operator delete(__p);
      }
    }
  }
  else
  {
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 24) = 0;
  }
}

uint64_t std::optional<std::vector<float>>::operator=[abi:ne180100]<std::vector<float>,void>(uint64_t a1, uint64_t a2)
{
  void *v4;

  if (*(_BYTE *)(a1 + 24))
  {
    v4 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v4;
      operator delete(v4);
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
    }
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

applesauce::CF::DictionaryRef *applesauce::CF::DictionaryRef::from_get(applesauce::CF::DictionaryRef *this, CFTypeRef cf)
{
  applesauce::CF::DictionaryRef *v2;

  v2 = this;
  if (cf)
  {
    CFRetain(cf);
    return applesauce::CF::DictionaryRef::DictionaryRef(v2, cf);
  }
  else
  {
    *(_QWORD *)this = 0;
  }
  return this;
}

__n128 std::__optional_storage_base<NeuralNet,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<NeuralNet,false>>(NeuralNet *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  __n128 result;
  uint64_t v7;
  uint64_t v8;

  if (*((unsigned __int8 *)this + 32) == *((unsigned __int8 *)a2 + 32))
  {
    if (*((_BYTE *)this + 32))
    {
      v4 = *a2;
      *a2 = 0;
      v5 = *(_QWORD *)this;
      *(_QWORD *)this = v4;
      if (v5)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      result = *(__n128 *)(a2 + 1);
      *(__n128 *)((char *)this + 8) = result;
      v7 = *((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = a2[3];
      a2[3] = v7;
    }
  }
  else if (*((_BYTE *)this + 32))
  {
    NeuralNet::~NeuralNet(this);
    *((_BYTE *)this + 32) = 0;
  }
  else
  {
    v8 = *a2;
    *a2 = 0;
    *(_QWORD *)this = v8;
    result = *(__n128 *)(a2 + 1);
    *(__n128 *)((char *)this + 8) = result;
    *((_QWORD *)this + 3) = a2[3];
    a2[3] = 0;
    *((_BYTE *)this + 32) = 1;
  }
  return result;
}

os_log_t ___ZL19AUNeuralNetLogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "AUNeuralNet");
  *v0 = result;
  AUNeuralNetLogScope(void)::scope = (uint64_t)v0;
  return result;
}

char *AUNeuralNet::InitMaskRelatedVariables(AUNeuralNet *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int v6;
  _DWORD *v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  VPTimeFreqConverter *v16;
  char *v17;
  char *v18;
  unint64_t v19;
  VPTimeFreqConverter *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  int v42;
  void *__p[3];

  v2 = (*((_DWORD *)this + 165) + *((_DWORD *)this + 165) * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 113, v2, __p);
  v3 = (*((_DWORD *)this + 165) * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 116, v3, __p);
  v4 = (*((_DWORD *)this + 165) + *((_DWORD *)this + 165) * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 119, v4, __p);
  v5 = *((_QWORD *)this + 100);
  v6 = *(unsigned __int8 *)(v5 + 96);
  if (*(_BYTE *)(v5 + 96))
    v6 = *(_DWORD *)(v5 + 16);
  if (*((_BYTE *)this + 1244))
  {
    if (*((_DWORD *)this + 312) == 2)
      v7 = (_DWORD *)(*((_QWORD *)this + 158) + 92);
    else
      v7 = (_DWORD *)(v5 + 20);
    v9 = *v7 + v6;
    *((_DWORD *)this + 244) = v9;
    *((_DWORD *)this + 245) = AUNeuralNet::GetCurrentLatencyInSamples(this);
    v10 = *(_DWORD *)(v5 + 20);
    if (*((_DWORD *)this + 136) > v10)
      v10 = *((_DWORD *)this + 136);
    v8 = v10 + v9;
  }
  else
  {
    *((_DWORD *)this + 244) = v6;
    *((_DWORD *)this + 245) = AUNeuralNet::GetCurrentLatencyInSamples(this);
    v8 = *(_DWORD *)(v5 + 16) + *(_DWORD *)(v5 + 20);
  }
  if (!*((_BYTE *)this + 664))
  {
    v11 = *((unsigned int *)this + 164);
    v42 = 0;
    std::vector<float>::vector(__p, v8, &v42);
    std::vector<std::vector<float>>::assign((uint64_t *)this + 132, v11, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v12 = (*((_DWORD *)this + 244) + *((_DWORD *)this + 136));
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 123, v12, __p);
    v13 = *((unsigned int *)this + 136);
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 126, v13, __p);
    v14 = *((unsigned int *)this + 136);
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 129, v14, __p);
    v15 = *((unsigned int *)this + 136);
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 135, v15, __p);
    v16 = (VPTimeFreqConverter *)*((_QWORD *)this + 144);
    if (v16)
    {
      VPTimeFreqConverter::~VPTimeFreqConverter(v16);
      MEMORY[0x1BCC95CEC]();
    }
    VPTimeFreqConverter_Create(2, *((_DWORD *)this + 136), (VPTimeFreqConverter **)this + 144);
    v17 = (char *)*((_QWORD *)this + 146);
    v18 = (char *)*((_QWORD *)this + 145);
    if (v17 == v18)
    {
      v21 = 0;
      v18 = (char *)*((_QWORD *)this + 146);
    }
    else
    {
      v19 = 0;
      do
      {
        v20 = *(VPTimeFreqConverter **)&v18[8 * v19];
        if (v20)
        {
          VPTimeFreqConverter::~VPTimeFreqConverter(v20);
          MEMORY[0x1BCC95CEC]();
          v17 = (char *)*((_QWORD *)this + 146);
          v18 = (char *)*((_QWORD *)this + 145);
        }
        ++v19;
        v21 = (v17 - v18) >> 3;
      }
      while (v21 > v19);
    }
    v22 = *((unsigned int *)this + 165);
    v23 = v22 - v21;
    if (v22 <= v21)
    {
      if (v22 >= v21)
        goto LABEL_39;
      v17 = &v18[8 * v22];
    }
    else
    {
      v24 = *((_QWORD *)this + 147);
      if (v23 > (v24 - (uint64_t)v17) >> 3)
      {
        v25 = v24 - (_QWORD)v18;
        if (v25 >> 2 > v22)
          v22 = v25 >> 2;
        if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
          v26 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v26 = v22;
        v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v26);
        v28 = &v27[8 * v21];
        v30 = &v27[8 * v29];
        bzero(v28, 8 * v23);
        v17 = &v28[8 * v23];
        v31 = (char *)*((_QWORD *)this + 146);
        v32 = (char *)*((_QWORD *)this + 145);
        if (v31 != v32)
        {
          do
          {
            v33 = *((_QWORD *)v31 - 1);
            v31 -= 8;
            *((_QWORD *)v28 - 1) = v33;
            v28 -= 8;
          }
          while (v31 != v32);
          v31 = (char *)*((_QWORD *)this + 145);
        }
        *((_QWORD *)this + 145) = v28;
        *((_QWORD *)this + 146) = v17;
        *((_QWORD *)this + 147) = v30;
        if (v31)
        {
          operator delete(v31);
          v17 = (char *)*((_QWORD *)this + 146);
        }
        goto LABEL_39;
      }
      bzero(v17, 8 * v23);
      v17 += 8 * v23;
    }
    *((_QWORD *)this + 146) = v17;
LABEL_39:
    v34 = (char *)*((_QWORD *)this + 145);
    if (v17 != v34)
    {
      v35 = 0;
      v36 = 0;
      do
      {
        VPTimeFreqConverter_Create(2, *((_DWORD *)this + 136), (VPTimeFreqConverter **)&v34[v35]);
        ++v36;
        v34 = (char *)*((_QWORD *)this + 145);
        v35 += 8;
      }
      while (v36 < (uint64_t)(*((_QWORD *)this + 146) - (_QWORD)v34) >> 3);
    }
  }
  v37 = (2 * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 138, v37, __p);
  v38 = (2 * *((_DWORD *)this + 136));
  LODWORD(__p[0]) = 0;
  std::vector<float>::assign((char **)this + 141, v38, __p);
  if (*((_BYTE *)this + 592))
  {
    v39 = *(unsigned int *)(*((_QWORD *)this + 100) + 28);
    LODWORD(__p[0]) = 0;
    std::vector<float>::assign((char **)this + 107, v39, __p);
  }
  v40 = *((unsigned int *)this + 164);
  LODWORD(__p[0]) = 0;
  return std::vector<float>::assign((char **)this + 165, v40, __p);
}

void sub_1B6170F24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::make_unique[abi:ne180100]<BlockProcessor,int,unsigned int *,int,unsigned int *,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUNeuralNet *>(BlockProcessor **a1, int *a2, const unsigned int **a3, int *a4, const unsigned int **a5, int *a6, void **a7)
{
  BlockProcessor *v14;

  v14 = (BlockProcessor *)operator new();
  BlockProcessor::BlockProcessor(v14, *a2, *a3, *a4, *a5, *a6, (int (*)(void *, unsigned int, const AudioBufferList **, AudioBufferList **))AUNeuralNet::BlockProcessClassFunc, *a7);
  *a1 = v14;
}

void sub_1B6170FD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x1080C40622722D2);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<BlockProcessorLowDelay,int,unsigned int *,int,unsigned int *,unsigned int &,unsigned int &,int (&)(void *,unsigned int,AudioBufferList const**,AudioBufferList**),AUNeuralNet *>(uint64_t *a1, _DWORD *a2, const unsigned int **a3, _DWORD *a4, const unsigned int **a5, int *a6, unsigned int *a7, uint64_t *a8)
{
  uint64_t v16;
  const unsigned int *v17;
  const unsigned int *v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  BOOL v25;

  v16 = operator new();
  v17 = *a3;
  LODWORD(a3) = *a4;
  v18 = *a5;
  v19 = *a6;
  v20 = *a7;
  v21 = *a8;
  *(_DWORD *)(v16 + 8) = *a2;
  *(_DWORD *)(v16 + 12) = v20;
  BlockBuffer::Alloc((BlockBuffer *)v16, v17);
  *(_DWORD *)(v16 + 32) = (_DWORD)a3;
  *(_DWORD *)(v16 + 36) = v20;
  BlockBuffer::Alloc((BlockBuffer *)(v16 + 24), v18);
  *(_DWORD *)(v16 + 56) = (_DWORD)a3;
  *(_DWORD *)(v16 + 60) = v20;
  BlockBuffer::Alloc((BlockBuffer *)(v16 + 48), v18);
  v22 = 0;
  v23 = 0;
  v24 = 0;
  *(_QWORD *)(v16 + 72) = AUNeuralNet::BlockProcessClassFunc;
  *(_QWORD *)(v16 + 80) = v21;
  *(_BYTE *)(v16 + 96) = 0;
  *(_DWORD *)(v16 + 88) = v19;
  *(_DWORD *)(v16 + 92) = 0;
  do
  {
    v24 = (v24 + v19) % v20;
    if (v24 > v22)
    {
      *(_DWORD *)(v16 + 92) = v24;
      v22 = v24;
    }
    if (v24)
      v25 = v23 >= v20;
    else
      v25 = 1;
    ++v23;
  }
  while (!v25);
  *a1 = v16;
}

void sub_1B6171104(_Unwind_Exception *a1)
{
  BlockBuffer *v1;
  BlockBuffer *v2;

  BlockBuffer::~BlockBuffer(v2);
  BlockBuffer::~BlockBuffer(v1);
  MEMORY[0x1BCC95CEC](v1, 0x1080C40367E4524);
  _Unwind_Resume(a1);
}

void std::default_delete<BlockProcessorLowDelay>::operator()[abi:ne180100](uint64_t a1)
{
  BlockBuffer::~BlockBuffer((BlockBuffer *)(a1 + 48));
  BlockBuffer::~BlockBuffer((BlockBuffer *)(a1 + 24));
  BlockBuffer::~BlockBuffer((BlockBuffer *)a1);
  JUMPOUT(0x1BCC95CECLL);
}

void sub_1B6171598(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void std::vector<AUNeuralNet::NeuralNetWrapper>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  const void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*(v4 - 8))
          NeuralNet::~NeuralNet((NeuralNet *)(v4 - 40));
        v6 = (const void *)*((_QWORD *)v4 - 6);
        if (v6)
          CFRelease(v6);
        if (*(v4 - 49) < 0)
          operator delete(*((void **)v4 - 9));
        v4 -= 104;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

BOOL applesauce::CF::details::has_key<__CFString const*>(const __CFDictionary *a1, const void *a2)
{
  return a2 && CFDictionaryContainsKey(a1, a2) != 0;
}

void CLiteMatrix::CLiteMatrix(CLiteMatrix *this, uint64_t a2, uint64_t a3)
{
  int v3;

  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  v3 = 0;
  std::vector<float>::assign((char **)this + 2, 2 * a2 * a3, &v3);
}

void sub_1B61716D4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

VBAP *std::unique_ptr<VBAP>::reset[abi:ne180100](VBAP **a1, VBAP *a2)
{
  VBAP *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    VBAP::~VBAP(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

uint64_t AUSpatialMixerV2DynamicXTCFilter::updateSpeakerLocations(uint64_t this)
{
  float v1;
  uint64_t v2;
  uint64_t v3;
  float v4;
  float v5;
  uint64_t v6;
  float v7;
  uint64_t v8;
  float v9;
  float v11;

  if (*(_QWORD *)(this + 784))
  {
    if (*(_QWORD *)(this + 920) != *(_QWORD *)(this + 912))
      return this;
    v1 = 20.0;
  }
  else
  {
    v1 = *(float *)(this + 44);
  }
  v2 = *(unsigned int *)(this + 20);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = -v1;
    v5 = floorf((float)v2 * 0.5);
    v6 = *(_QWORD *)(this + 864);
    v7 = v1 * 0.5;
    v8 = *(_QWORD *)(this + 888);
    do
    {
      v9 = (float)((float)(v5 - (float)v3) * v4) * 0.5;
      if (v9 >= 0.0 && (v2 & 1) == 0)
        v11 = v7;
      else
        v11 = -0.0;
      *(float *)(v6 + 4 * v3) = v9 + v11;
      *(_DWORD *)(v8 + 4 * v3++) = 0;
    }
    while (v2 != v3);
  }
  return this;
}

void std::make_unique[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  void *v7[3];
  void *__p;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void **v17;

  v6 = operator new();
  v15 = 0;
  v16 = 0;
  v14 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v14, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v11, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
  __p = 0;
  v9 = 0;
  v10 = 0;
  memset(v7, 0, sizeof(v7));
  VBAP::VBAP(v6, (uint64_t *)&v14, (uint64_t *)&v11, 1, (uint64_t)&__p, v7);
  *a1 = v6;
  v17 = v7;
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&v17);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
  if (v11)
  {
    v12 = v11;
    operator delete(v11);
  }
  if (v14)
  {
    v15 = v14;
    operator delete(v14);
  }
}

void sub_1B61718B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v21;

  *(_QWORD *)(v19 - 40) = v18;
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v19 - 40));
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  v21 = *(void **)(v19 - 64);
  if (v21)
  {
    *(_QWORD *)(v19 - 56) = v21;
    operator delete(v21);
  }
  MEMORY[0x1BCC95CEC](v17, 0x10B0C40F5E5D8C6);
  _Unwind_Resume(a1);
}

vDSP_biquad_Setup AUSpatialMixerV2DynamicXTCFilter::setLR8Crossover(AUSpatialMixerV2DynamicXTCFilter *this, float a2)
{
  uint64_t v4;
  _QWORD *v5;
  double v6;
  __double2 v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  uint64_t v16;
  _OWORD *v17;
  double *v18;
  __int128 v19;
  vDSP_biquad_Setup Setup;
  __double2 v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  uint64_t v30;
  _OWORD *v31;
  double *v32;
  __int128 v33;
  vDSP_biquad_Setup result;
  uint64_t v35;
  uint64_t (*v36)(_QWORD);
  uint64_t (*v37)(uint64_t);
  uint64_t v38;
  uint64_t (*v39)(uint64_t);
  double __Coefficients[3];
  _BYTE v41[136];
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  uint64_t v52;

  v4 = 0;
  v52 = *MEMORY[0x1E0C80C00];
  do
  {
    v5 = (_QWORD *)((char *)&v42 + v4);
    *v5 = 0;
    v5[1] = 0;
    v5[3] = 0;
    v5[4] = 0;
    v4 += 40;
    v5[2] = 0x3FF0000000000000;
  }
  while (v4 != 80);
  v6 = a2;
  if (a2 <= 0.0)
  {
    v42 = 0.0;
    v43 = 0.0;
    v44 = 1.0;
    v45 = 0.0;
    v46 = 0.0;
    v47 = 0.0;
    v50 = 0.0;
    v51 = 0.0;
    v15 = 1.0;
    v48 = 0.0;
  }
  else
  {
    v7 = __sincos_stret(fmin(v6, 3.11017673));
    v8 = __exp10(0.0);
    v9 = 0.5 - v7.__cosval * 0.5;
    v10 = 1.0 / (v7.__sinval * 0.923879533 + 1.0);
    v11 = v10 * v8;
    v42 = v7.__cosval * -2.0 * v10;
    v43 = v10 - v7.__sinval * 0.923879533 * v10;
    v45 = (v9 + v9) * v11;
    v46 = v9 * v11;
    v44 = v9 * v11;
    v12 = __exp10(0.0);
    v13 = 1.0 / (v7.__sinval * 0.382683434 + 1.0);
    v14 = v13 * v12;
    v47 = v7.__cosval * -2.0 * v13;
    v48 = v13 - v7.__sinval * 0.382683434 * v13;
    v15 = v9 * (v13 * v12);
    v50 = (v9 + v9) * v14;
    v51 = v15;
  }
  v16 = 0;
  v49 = v15;
  v17 = v41;
  do
  {
    v18 = &v42 + 5 * (v16 & 1);
    v19 = *(_OWORD *)v18;
    *(_OWORD *)((char *)v17 - 24) = *((_OWORD *)v18 + 1);
    *((double *)v17 - 1) = v18[4];
    *v17 = v19;
    v17 = (_OWORD *)((char *)v17 + 40);
    ++v16;
  }
  while (v16 != 4);
  Setup = vDSP_biquad_CreateSetup(__Coefficients, 4uLL);
  if (a2 <= 0.0)
  {
    v42 = 0.0;
    v43 = 0.0;
    v44 = 1.0;
    v45 = 0.0;
    v47 = 0.0;
    v48 = 0.0;
    v50 = 0.0;
    v51 = 0.0;
    v29 = 1.0;
    v46 = 0.0;
  }
  else
  {
    v21 = __sincos_stret(fmin(v6, 3.11017673));
    v22 = __exp10(0.0);
    v23 = v21.__cosval * 0.5 + 0.5;
    v24 = 1.0 / (v21.__sinval * 0.923879533 + 1.0);
    v25 = v24 * v22;
    v42 = v21.__cosval * -2.0 * v24;
    v43 = v24 - v21.__sinval * 0.923879533 * v24;
    v45 = v23 * -2.0 * v25;
    v46 = v23 * v25;
    v44 = v23 * v25;
    v26 = __exp10(0.0);
    v27 = 1.0 / (v21.__sinval * 0.382683434 + 1.0);
    v28 = v27 * v26;
    v47 = v21.__cosval * -2.0 * v27;
    v48 = v27 - v21.__sinval * 0.382683434 * v27;
    v29 = v23 * (v27 * v26);
    v50 = v23 * -2.0 * v28;
    v51 = v29;
  }
  v30 = 0;
  v49 = v29;
  v31 = v41;
  do
  {
    v32 = &v42 + 5 * (v30 & 1);
    v33 = *(_OWORD *)v32;
    *(_OWORD *)((char *)v31 - 24) = *((_OWORD *)v32 + 1);
    *((double *)v31 - 1) = v32[4];
    *v31 = v33;
    v31 = (_OWORD *)((char *)v31 + 40);
    ++v30;
  }
  while (v30 != 4);
  result = vDSP_biquad_CreateSetup(__Coefficients, 4uLL);
  v35 = *((_QWORD *)this + 120);
  *((_QWORD *)this + 120) = Setup;
  v36 = MEMORY[0x1E0C8BFE0];
  v37 = (uint64_t (*)(uint64_t))*((_QWORD *)this + 121);
  *((_QWORD *)this + 121) = MEMORY[0x1E0C8BFE0];
  v38 = *((_QWORD *)this + 118);
  *((_QWORD *)this + 118) = result;
  v39 = (uint64_t (*)(uint64_t))*((_QWORD *)this + 119);
  *((_QWORD *)this + 119) = v36;
  if (v38)
    result = (vDSP_biquad_Setup)v39(v38);
  if (v35)
    return (vDSP_biquad_Setup)v37(v35);
  return result;
}

void sub_1B6171C5C(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void MoorePenrose::~MoorePenrose(MoorePenrose *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  v2 = (void *)*((_QWORD *)this + 65);
  if (v2)
  {
    *((_QWORD *)this + 66) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 60);
  if (v3)
  {
    *((_QWORD *)this + 61) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 55);
  if (v4)
  {
    *((_QWORD *)this + 56) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 52);
  if (v5)
  {
    *((_QWORD *)this + 53) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 49);
  if (v6)
  {
    *((_QWORD *)this + 50) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 46);
  if (v7)
  {
    *((_QWORD *)this + 47) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 43);
  if (v8)
  {
    *((_QWORD *)this + 44) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 40);
  if (v9)
  {
    *((_QWORD *)this + 41) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 37);
  if (v10)
  {
    *((_QWORD *)this + 38) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 32);
  if (v11)
  {
    *((_QWORD *)this + 33) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 27);
  if (v12)
  {
    *((_QWORD *)this + 28) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 22);
  if (v13)
  {
    *((_QWORD *)this + 23) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 17);
  if (v14)
  {
    *((_QWORD *)this + 18) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 12);
  if (v15)
  {
    *((_QWORD *)this + 13) = v15;
    operator delete(v15);
  }
  v16 = (void *)*((_QWORD *)this + 7);
  if (v16)
  {
    *((_QWORD *)this + 8) = v16;
    operator delete(v16);
  }
  v17 = (void *)*((_QWORD *)this + 2);
  if (v17)
  {
    *((_QWORD *)this + 3) = v17;
    operator delete(v17);
  }
}

void std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = (uint64_t)v4 - 24;
      do
      {
        v9 = v6;
        std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](&v9);
        v7 = *(void **)(v6 - 24);
        if (v7)
        {
          *(_QWORD *)(v6 - 16) = v7;
          operator delete(v7);
        }
        v8 = (void *)(v6 - 32);
        v6 -= 56;
      }
      while (v8 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<std::vector<float>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v10;
    v16[4] = result;
    v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::__fs::filesystem::path>>(result, v12);
    v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((_QWORD *)v14 + 1) = 0;
    *((_QWORD *)v14 + 2) = 0;
    *(_QWORD *)v14 = 0;
    *(_OWORD *)v14 = *(_OWORD *)a2;
    *((_QWORD *)v14 + 2) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v16);
    v8 = (_QWORD *)a1[1];
    result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)v7 = *(_OWORD *)a2;
    v7[2] = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1B6171F74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2DynamicXTCFilter::updateFilters(AUSpatialMixerV2DynamicXTCFilter *this)
{
  uint64_t v2;
  unint64_t v3;
  unsigned int v4;
  int v6;
  const UInt8 *v7;
  CFIndex v8;
  CFURLRef v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  __int128 v14;
  NSObject *v15;
  std::string *v16;
  const char *v17;
  NSObject *v18;
  std::string *v19;
  __int128 v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::string *v27;
  std::runtime_error *exception;
  void *v29;
  char v30;
  void *v31;
  void *v32;
  _QWORD *v33;
  std::string v34;
  std::string v35;
  std::string v36;
  __int128 v37;
  CFURLRef v38;
  __int128 buf;
  _QWORD *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 5) >= 2u)
  {
    if (*((float *)this + 1) == 0.0 && *((_QWORD *)this + 103))
      return;
    std::vector<std::vector<float>>::resize((uint64_t *)this + 100, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 106) - *((_QWORD *)this + 105)) >> 3));
    if (*((_QWORD *)this + 106) != *((_QWORD *)this + 105))
    {
      v2 = 0;
      v3 = (*((_DWORD *)this + 5) * *((_DWORD *)this + 13));
      v4 = 1;
      do
      {
        std::vector<float>::resize(*((_QWORD *)this + 100) + 24 * v2, v3);
        v2 = v4;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 106) - *((_QWORD *)this + 105)) >> 3) > v4++);
    }
    AUSpatialMixerV2DynamicXTCFilter::updateSpeakerLocations((uint64_t)this);
    AUSpatialMixerV2DynamicXTCFilter::createDynamicFilters(this);
    v6 = *((char *)this + 1031);
    if (v6 >= 0)
      v7 = (const UInt8 *)this + 1008;
    else
      v7 = (const UInt8 *)*((_QWORD *)this + 126);
    if (v6 >= 0)
      v8 = *((unsigned __int8 *)this + 1031);
    else
      v8 = *((_QWORD *)this + 127);
    v9 = CFURLCreateWithBytes(0, v7, v8, 0, 0);
    v38 = v9;
    if (!v9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    IR::IRDataLoader::instance(v9);
    std::string::basic_string[abi:ne180100]<0>(&v36, "");
    v10 = operator new(8uLL);
    v34.__r_.__value_.__r.__words[2] = 0;
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
    *v10 = 1;
    v35.__r_.__value_.__l.__size_ = (std::string::size_type)(v10 + 1);
    v35.__r_.__value_.__r.__words[2] = (std::string::size_type)(v10 + 1);
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = 0uLL;
    v11 = operator new(8uLL);
    *(_QWORD *)&buf = v11;
    *v11 = 0x43B4000000000000;
    *((_QWORD *)&buf + 1) = v11 + 1;
    v40 = v11 + 1;
    v12 = operator new(8uLL);
    v31 = v12;
    *v12 = 0x100000001;
    v32 = v12 + 1;
    v33 = v12 + 1;
    std::string::basic_string[abi:ne180100]<0>(&v29, "");
    IR::IRData::getPartitionLength(*((IR::IRData **)this + 96));
    IR::IRData::getAudioChannelLayoutTag(*((IR::IRData **)this + 96));
    IR::IRDataLoader::create();
    if (v30 < 0)
      operator delete(v29);
    if (v31)
    {
      v32 = v31;
      operator delete(v31);
    }
    if ((_QWORD)buf)
    {
      *((_QWORD *)&buf + 1) = buf;
      operator delete((void *)buf);
    }
    *(_QWORD *)&buf = &v34;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
    if (v35.__r_.__value_.__r.__words[0])
    {
      v35.__r_.__value_.__l.__size_ = v35.__r_.__value_.__r.__words[0];
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v36.__r_.__value_.__l.__data_);
    if ((_QWORD)v37)
    {
      v13 = *((_QWORD *)&v37 + 1);
      v14 = *(_OWORD *)((char *)this + 824);
      *((_QWORD *)this + 103) = v37;
      *((_QWORD *)this + 104) = v13;
      v37 = v14;
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v15 = getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
        goto LABEL_47;
      std::string::basic_string[abi:ne180100]<0>(&v34, "AUSpatialMixerV2DynamicXTCFilter");
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("::", &v34, &v35);
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("updateFilters", &v35, &v36);
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v16 = &v36;
      else
        v16 = (std::string *)v36.__r_.__value_.__r.__words[0];
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v16;
      v17 = "%s: Filters Updated to IR Data object";
    }
    else
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v15 = getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
        goto LABEL_47;
      std::string::basic_string[abi:ne180100]<0>(&v34, "AUSpatialMixerV2DynamicXTCFilter");
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("::", &v34, &v35);
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("updateFilters", &v35, &v36);
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v27 = &v36;
      else
        v27 = (std::string *)v36.__r_.__value_.__r.__words[0];
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v27;
      v17 = "%s: ERROR: Filters NOT Updated to IR Data object";
    }
    _os_log_debug_impl(&dword_1B5ED0000, v15, OS_LOG_TYPE_DEBUG, v17, (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v36.__r_.__value_.__l.__data_);
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v35.__r_.__value_.__l.__data_);
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v34.__r_.__value_.__l.__data_);
LABEL_47:
    v24 = (std::__shared_weak_count *)*((_QWORD *)&v37 + 1);
    if (*((_QWORD *)&v37 + 1))
    {
      v25 = (unint64_t *)(*((_QWORD *)&v37 + 1) + 8);
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    if (v38)
      CFRelease(v38);
    return;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v18 = getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    std::string::basic_string[abi:ne180100]<0>(&v34, "AUSpatialMixerV2DynamicXTCFilter");
    v19 = std::string::append(&v34, "::", 2uLL);
    v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    v21 = std::string::append(&v35, "updateFilters", 0xDuLL);
    v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v36.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    v23 = &v36;
    if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v23 = (std::string *)v36.__r_.__value_.__r.__words[0];
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v23;
    _os_log_error_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_ERROR, "%s: Filters can not be generated if the number of drivers is < 2", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v36.__r_.__value_.__l.__data_);
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v35.__r_.__value_.__l.__data_);
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v34.__r_.__value_.__l.__data_);
  }
}

void sub_1B61725C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  uint64_t v40;

  if (a40 < 0)
    operator delete(__p);
  if (a34 < 0)
    operator delete(a29);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v40 - 144);
  applesauce::CF::URLRef::~URLRef((const void **)(v40 - 120));
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2DynamicXTCFilter::createDynamicFilters(AUSpatialMixerV2DynamicXTCFilter *this)
{
  int v2;
  int FilterLength;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  long double v7;
  unint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  const DSPSplitComplex *v17;
  uint64_t v18;
  OpaqueFFTSetup **v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  DSPSplitComplex *v25;
  float *v26;
  uint64_t v27;
  char v28;
  float *v29;
  char v30;
  DSPSplitComplex *v31;
  vDSP_Length v32;
  float *v33;
  DSPSplitComplex *v34;
  OpaqueFFTSetup **v35;
  vDSP_Length v36;
  uint64_t v37;
  char v38;
  char v39;
  unsigned int v40;
  unsigned int j;
  unsigned int v42;
  uint64_t v43;
  unint64_t v44;
  unsigned int v45;
  _OWORD *v46;
  uint64_t v47;
  unsigned int v48;
  vDSP_Length v49;
  OpaqueFFTSetup **v50;
  uint64_t v51;
  char v52;
  char v53;
  float *v54;
  DSPSplitComplex *v55;
  int v56;
  float **v57;
  float **v58;
  uint64_t v59;
  float *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  char v67;
  char v68;
  DSPSplitComplex *v69;
  uint64_t v70;
  float **v71;
  _DWORD *v72;
  float *v73;
  float v74;
  float v75;
  CLiteMatrix *v76;
  char *v77;
  AUSpatialMixerV2DynamicXTCFilter *v78;
  uint64_t v79;
  int v80;
  unsigned int v81;
  CLiteMatrix *v82;
  CLiteMatrix *v83;
  float v84;
  float v85;
  float v86;
  float v87;
  char *v88;
  int v89;
  unsigned int v90;
  CLiteMatrix *v91;
  CLiteMatrix *v92;
  float *v93;
  float **v94;
  uint64_t v95;
  float *v96;
  vDSP_Length v97;
  unsigned int v98;
  vDSP_Length v99;
  unint64_t v100;
  const DSPSplitComplex *v101;
  unint64_t v102;
  unsigned int v103;
  float v104;
  float v105;
  float v106;
  float v107;
  unint64_t v108;
  unsigned int v109;
  const DSPSplitComplex *v110;
  int v111;
  uint64_t v112;
  int v113;
  long double v114;
  DSPComplex *v115;
  uint64_t v116;
  uint64_t v117;
  void *v118;
  _QWORD *v119;
  vDSP_Length v120;
  OpaqueFFTSetup **v121;
  uint64_t v122;
  _QWORD *v123;
  vDSP_Length v124;
  vDSP_Length v125;
  uint64_t v126;
  uint64_t v127;
  void *v128;
  uint64_t i;
  void *v130;
  _QWORD v131[2];
  const DSPSplitComplex *v132;
  float *v133;
  const DSPSplitComplex *v134;
  unint64_t v135;
  float v136;
  vDSP_Length v137;
  unsigned int v138;
  float **v139;
  FFTSetup fftsetup;
  float **p_imagp;
  uint64_t v142;
  float *realp;
  _DWORD *v144;
  vDSP_Length v145;
  DSPSplitComplex *v146;
  unint64_t v147;
  const CLiteMatrix *v148;
  vDSP_Length *v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  void *__p[2];
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  uint64_t v162[3];
  void *v163[3];
  _QWORD v164[3];
  _QWORD v165[3];
  _QWORD v166[3];
  _QWORD v167[3];
  _QWORD v168[3];
  _QWORD v169[3];
  OpaqueFFTSetup *v170;
  _QWORD v171[3];
  float v172;
  DSPSplitComplex v173;
  DSPSplitComplex v174;
  DSPSplitComplex v175;
  DSPSplitComplex v176;
  DSPSplitComplex v177;
  DSPSplitComplex v178;
  DSPSplitComplex v179;
  DSPSplitComplex v180;
  DSPSplitComplex v181[5];
  float __C;
  uint64_t v183;

  v183 = *MEMORY[0x1E0C80C00];
  v2 = *((_DWORD *)this + 5);
  std::vector<float>::vector(__p, 0x100uLL);
  std::vector<std::vector<float>>::vector(v171, (2 * v2), (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  FilterLength = IR::IRData::getFilterLength(*((IR::IRData **)this + 96));
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)__p);
  std::vector<float>::vector(&v150, 2uLL);
  std::vector<float>::vector(&v174, 0x100uLL);
  std::vector<std::vector<float>>::vector(&v178, 2uLL, (uint64_t)&v174);
  if (v174.realp)
  {
    v174.imagp = v174.realp;
    operator delete(v174.realp);
  }
  if (*((_DWORD *)this + 5))
  {
    v4 = 0;
    v5 = 0;
    do
    {
      if (!*((_QWORD *)this + 98))
        IR::IRCoordinates::set();
      IR::IRCoordinates::set();
      IR::IRCoordinates::set();
      IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
      if (FilterLength)
      {
        memmove(*(void **)(v171[0] + v4), *(const void **)v178.realp, 4 * FilterLength);
        memmove(*(void **)(v171[0] + 24 * (v5 + *((_DWORD *)this + 5))), *((const void **)v178.realp + 3), 4 * FilterLength);
      }
      ++v5;
      v4 += 24;
    }
    while (v5 < *((unsigned int *)this + 5));
  }
  v174.realp = (float *)&v178;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v174);
  if ((_QWORD)v150)
  {
    *((_QWORD *)&v150 + 1) = v150;
    operator delete((void *)v150);
  }
  LODWORD(v6) = *((_DWORD *)this + 13);
  v7 = log2((double)v6);
  fftsetup = vDSP_create_fftsetup((unint64_t)v7, 0);
  v170 = fftsetup;
  v8 = *((unsigned int *)this + 13);
  v10 = *((_DWORD *)this + 3);
  v9 = *((_DWORD *)this + 4);
  std::vector<float>::vector(__p, 0x100uLL);
  std::vector<std::vector<float>>::vector(v169, 2uLL, (uint64_t)__p);
  v133 = (float *)(v8 >> 1);
  v11 = (v8 >> 1) + 1;
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v12 = *((_DWORD *)this + 5);
  v13 = (2 * v11);
  std::vector<float>::vector(__p, v13);
  std::vector<std::vector<float>>::vector(v168, (2 * v12), (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::vector<float>::vector(__p, (2 * v11));
  std::vector<std::vector<float>>::vector(v167, 2uLL, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v14 = *((unsigned int *)this + 5);
  std::vector<float>::vector(__p, (2 * v11));
  std::vector<std::vector<float>>::vector(v166, v14, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::vector<float>::vector(__p, (2 * v11));
  std::vector<std::vector<float>>::vector(v165, 2uLL, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::vector<float>::vector(__p, v11);
  std::vector<std::vector<float>>::vector(v164, 0xB4uLL, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v15 = std::vector<float>::vector(v163, (2 * v11));
  v131[1] = v131;
  MEMORY[0x1E0C80A78](v15);
  v17 = (const DSPSplitComplex *)&v131[-2 * v16];
  MEMORY[0x1E0C80A78](v18);
  v134 = (const DSPSplitComplex *)&v131[-2 * v20];
  if ((v20 & 0x7FFFFFFF) != 0)
  {
    v21 = v10;
    v22 = v9;
    v23 = 0;
    v24 = 0;
    v25 = (DSPSplitComplex *)v17;
    do
    {
      v26 = *(float **)(v168[0] + v23);
      v25->realp = v26;
      v25->imagp = &v26[v11];
      AUSpatialMixerV2DynamicXTCFilter::getFFT(*(const DSPComplex **)(v171[0] + v23), v25, (DSPSplitComplex *)*((unsigned int *)this + 13), &v170, v19);
      ++v24;
      LODWORD(v20) = *((_DWORD *)this + 5);
      v23 += 24;
      ++v25;
    }
    while (v24 < (2 * v20));
    v9 = v22;
    v10 = v21;
  }
  memset(v162, 0, sizeof(v162));
  v145 = v11;
  if ((_DWORD)v20 == 2 && !AUSpatialMixerV2DynamicXTCFilter::readAUXTCFilter((uint64_t)this, v162))
  {
    LODWORD(v148) = v10;
    LODWORD(v149) = v9;
    v116 = 0;
    v117 = 0;
    v160 = 0u;
    v161 = 0u;
    v158 = 0u;
    v159 = 0u;
    *(_OWORD *)__p = 0u;
    v157 = 0u;
    v154 = 0u;
    v155 = 0u;
    v152 = 0u;
    v153 = 0u;
    v150 = 0u;
    v151 = 0u;
    do
    {
      std::vector<float>::resize((uint64_t)&__p[v117], v13);
      std::vector<float>::resize((uint64_t)&v150 + v117 * 8, v13);
      v118 = __p[v117];
      v119 = (float **)((char *)&v178.realp + v116);
      v120 = (vDSP_Length)v118 + 4 * v145;
      *v119 = v118;
      v119[1] = v120;
      AUSpatialMixerV2DynamicXTCFilter::getFFT(*(const DSPComplex **)(v162[0] + v117 * 8), (DSPSplitComplex *)((char *)&v178 + v116), (DSPSplitComplex *)*((unsigned int *)this + 13), &v170, v121);
      v122 = *(_QWORD *)((char *)&v150 + v117 * 8);
      v123 = (float **)((char *)&v174.realp + v116);
      v124 = v122 + 4 * v145;
      *v123 = v122;
      v123[1] = v124;
      v117 += 3;
      v116 += 16;
    }
    while (v117 != 12);
    v147 = (2 * v11);
    v125 = v145;
    vDSP_zvmul(v17, 1, &v178, 1, &v174, 1, v145, 1);
    vDSP_zvma(v17 + 2, 1, &v180, 1, &v174, 1, &v174, 1, v125);
    vDSP_zvmul(v17 + 1, 1, &v178, 1, &v175, 1, v125, 1);
    v146 = (DSPSplitComplex *)&v17[3];
    vDSP_zvma(v17 + 3, 1, &v180, 1, &v175, 1, &v175, 1, v125);
    vDSP_zvmul(v17, 1, &v179, 1, &v176, 1, v125, 1);
    vDSP_zvma(v17 + 2, 1, v181, 1, &v176, 1, &v176, 1, v125);
    vDSP_zvmul(v17 + 1, 1, &v179, 1, &v177, 1, v125, 1);
    vDSP_zvma(v146, 1, v181, 1, &v177, 1, &v177, 1, v125);
    v126 = 0;
    v13 = v147;
    do
    {
      if ((_DWORD)v13)
        memmove(*(void **)(v168[0] + v126), *(const void **)((char *)&v150 + v126), 4 * v13);
      v126 += 24;
    }
    while (v126 != 96);
    v127 = 0;
    *((_BYTE *)this + 57) = 1;
    do
    {
      v128 = *(void **)((char *)&v154 + v127 * 8 + 8);
      if (v128)
      {
        __p[v127 - 2] = v128;
        operator delete(v128);
      }
      v127 -= 3;
    }
    while (v127 != -12);
    for (i = 0; i != -12; i -= 3)
    {
      v130 = *(void **)((char *)&v160 + i * 8 + 8);
      if (v130)
      {
        v162[i - 2] = (uint64_t)v130;
        operator delete(v130);
      }
    }
    v9 = (int)v149;
    v10 = (int)v148;
  }
  else
  {
    *((_BYTE *)this + 57) = 0;
  }
  AUSpatialMixerV2DynamicXTCFilter::getTargetFIR((uint64_t)this, v169, 0);
  v27 = 0;
  v137 = (v9 - v10 + 1);
  v28 = 1;
  do
  {
    v29 = *(float **)(v167[0] + 24 * v27);
    v30 = v28;
    v31 = &v181[v27 + 3];
    v32 = v145;
    v31->realp = v29;
    v31->imagp = &v29[v32];
    v33 = *(float **)(v165[0] + 24 * v27);
    v34 = &v181[v27 + 1];
    v34->realp = v33;
    v34->imagp = &v33[v32];
    vDSP_vclr(v33, 1, v13);
    AUSpatialMixerV2DynamicXTCFilter::getFFT(*(const DSPComplex **)(v169[0] + 24 * v27), v31, (DSPSplitComplex *)*((unsigned int *)this + 13), &v170, v35);
    v28 = 0;
    v27 = 1;
  }
  while ((v30 & 1) != 0);
  v36 = v13;
  v37 = 0;
  v38 = 1;
  do
  {
    v39 = v38;
    LODWORD(__p[0]) = 1060439283;
    v40 = *((_DWORD *)this + 5);
    if (v40)
    {
      for (j = 0; j < v40; ++j)
      {
        vDSP_zvadd(&v17[j + v40 * (_DWORD)v37], 1, &v181[v37 + 1], 1, &v181[v37 + 1], 1, v145);
        v40 = *((_DWORD *)this + 5);
      }
    }
    vDSP_zvdiv(&v181[v37 + 3], 1, &v181[v37 + 1], 1, &v181[v37 + 1], 1, v145);
    vDSP_vsmul(*(const float **)(v165[0] + 24 * v37), 1, (const float *)__p, *(float **)(v165[0] + 24 * v37), 1, v36);
    v38 = 0;
    v37 = 1;
  }
  while ((v39 & 1) != 0);
  CLiteMatrix::CLiteMatrix((CLiteMatrix *)__p, 2, *((unsigned int *)this + 5));
  CLiteMatrix::CLiteMatrix((CLiteMatrix *)&v150, 2, 1);
  v42 = v137;
  CLiteMatrix::CLiteMatrix((CLiteMatrix *)&v178, *((unsigned int *)this + 5), 1);
  std::vector<float>::vector(&v174, *((_DWORD *)this + 4) - *((_DWORD *)this + 3) + 1);
  v43 = *((_QWORD *)this + 105);
  if (*((_QWORD *)this + 106) != v43)
  {
    v44 = 0;
    v45 = 0;
    v148 = (AUSpatialMixerV2DynamicXTCFilter *)((char *)this + 648);
    v149 = (vDSP_Length *)((char *)this + 608);
    v46 = (_OWORD *)((char *)this + 688);
    v146 = (DSPSplitComplex *)((char *)this + 64);
    v147 = (unint64_t)this + 704;
    p_imagp = &v134->imagp;
    v139 = &v17->imagp;
    v132 = v134 + 1;
    while (1)
    {
      if (v45 >= v42)
      {
        if (v45 <= *((_DWORD *)this + 4))
          v48 = v42;
        else
          v48 = 0;
        v142 = v45 - v48;
        v47 = *(_QWORD *)(v43 + 24 * v142);
      }
      else
      {
        v142 = *((_DWORD *)this + 3) + v45;
        v47 = *(_QWORD *)(v43 + 24 * v142);
        v174.realp[v44] = *(float *)(v47 + 4);
      }
      v49 = v145;
      v136 = *(float *)(v47 + 4);
      AUSpatialMixerV2DynamicXTCFilter::getTargetFIR((uint64_t)this, v169, 1);
      v51 = 0;
      v52 = 1;
      do
      {
        v53 = v52;
        v54 = *(float **)(v167[0] + 24 * v51);
        v55 = &v181[v51 + 3];
        v55->realp = v54;
        v55->imagp = &v54[v49];
        AUSpatialMixerV2DynamicXTCFilter::getFFT(*(const DSPComplex **)(v169[0] + 24 * v51), v55, (DSPSplitComplex *)*((unsigned int *)this + 13), &v170, v50);
        vDSP_zvmul(v55, 1, &v181[v51 + 1], 1, v55, 1, v49, 1);
        v52 = 0;
        v51 = 1;
      }
      while ((v53 & 1) != 0);
      v135 = v44;
      v138 = v45;
      v56 = *((_DWORD *)this + 5);
      if (v56)
      {
        v57 = (float **)v166[0];
        v58 = p_imagp;
        v59 = *((unsigned int *)this + 5);
        do
        {
          v60 = *v57;
          v57 += 3;
          *(v58 - 1) = v60;
          *v58 = &v60[v49];
          v58 += 2;
          --v59;
        }
        while (v59);
      }
      v61 = 0;
      v144 = (_DWORD *)v157;
      v62 = (unint64_t)((uint64_t)(*((_QWORD *)&v157 + 1) - v157) >> 2) >> 1;
      v63 = v151;
      v64 = v63 + 4 * ((*((_QWORD *)&v151 + 1) - v63) >> 3);
      realp = v179.realp;
      v65 = (unint64_t)(v179.imagp - v179.realp) >> 1;
      do
      {
        v66 = 0;
        v67 = 1;
        do
        {
          v68 = v67;
          v69 = &v181[v66 + 3];
          *(float *)(v63 + 4 * v66) = v69->realp[v61];
          *(float *)(v64 + 4 * v66) = v69->imagp[v61];
          v66 = 1;
          v67 = 0;
        }
        while ((v68 & 1) != 0);
        v70 = (2 * v56);
        if ((_DWORD)v70)
        {
          v71 = v139;
          v72 = v144;
          do
          {
            *v72 = LODWORD((*(v71 - 1))[v61]);
            v73 = *v71;
            v71 += 2;
            v72[v62] = LODWORD(v73[v61]);
            ++v72;
            --v70;
          }
          while (v70);
        }
        v74 = __exp10f(-*((float *)this + 10));
        v75 = *((float *)this + 9);
        CLiteMatrix::SetWithConjugateTranposeOfOther((CLiteMatrix *)v149, (const CLiteMatrix *)__p);
        CLiteMatrix::MatrixMultiply(v149, (const CLiteMatrix *)__p, v148, v76);
        v77 = (char *)v147;
        *v46 = *(_OWORD *)v148;
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v77, *((char **)this + 83), *((_QWORD *)this + 84), (uint64_t)(*((_QWORD *)this + 84) - *((_QWORD *)this + 83)) >> 2);
        v78 = (AUSpatialMixerV2DynamicXTCFilter *)*((_QWORD *)this + 88);
        v79 = *((_QWORD *)this + 89);
        v80 = *((_DWORD *)this + 5);
        if (v80 * v80)
        {
          v81 = 0;
          do
          {
            *((float *)v78 + v81) = *((float *)v78 + v81) + v74;
            v81 += v80 + 1;
          }
          while (v81 < v80 * v80);
        }
        if (v80 == 2)
          AUSpatialMixerV2DynamicXTCFilter::analyticalInverseStereo(v78, (DSPSplitComplex *)((char *)v78 + 4 * ((v79 - (uint64_t)v78) >> 3)));
        else
          MoorePenrose::pseudoInverse((MoorePenrose *)v146, (AUSpatialMixerV2DynamicXTCFilter *)((char *)this + 688), (AUSpatialMixerV2DynamicXTCFilter *)((char *)this + 688));
        CLiteMatrix::MatrixMultiply((vDSP_Length *)this + 86, (const CLiteMatrix *)v149, (AUSpatialMixerV2DynamicXTCFilter *)((char *)this + 728), v82);
        CLiteMatrix::MatrixMultiply((vDSP_Length *)this + 91, (const CLiteMatrix *)&v150, (const CLiteMatrix *)&v178, v83);
        v173.realp = v179.realp;
        v173.imagp = &v179.realp[((char *)v179.imagp - (char *)v179.realp) >> 3];
        vDSP_zvabs(&v173, 1, &__C, 1, 2uLL);
        v172 = 0.0;
        vDSP_maxv(&__C, 1, &v172, 2uLL);
        v84 = v75 + 0.5;
        v85 = v172;
        if ((float)(log10f(v172) * 20.0) > (float)(v75 + 0.5))
        {
          v86 = v75 / 20.0;
          do
          {
            v87 = __exp10f(v86);
            v88 = (char *)v147;
            *v46 = *(_OWORD *)v148;
            std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v88, *((char **)this + 83), *((_QWORD *)this + 84), (uint64_t)(*((_QWORD *)this + 84) - *((_QWORD *)this + 83)) >> 2);
            v89 = *((_DWORD *)this + 5);
            v74 = (float)(v74 * v85) / v87;
            if (v89 * v89)
            {
              v90 = 0;
              do
              {
                *((float *)v78 + v90) = v74 + *((float *)v78 + v90);
                v90 += v89 + 1;
              }
              while (v90 < v89 * v89);
            }
            if (v89 == 2)
              AUSpatialMixerV2DynamicXTCFilter::analyticalInverseStereo(*((AUSpatialMixerV2DynamicXTCFilter **)this + 88), (DSPSplitComplex *)(*((_QWORD *)this + 88)+ 4 * ((uint64_t)(*((_QWORD *)this + 89) - *((_QWORD *)this + 88)) >> 3)));
            else
              MoorePenrose::pseudoInverse((MoorePenrose *)v146, (AUSpatialMixerV2DynamicXTCFilter *)((char *)this + 688), (AUSpatialMixerV2DynamicXTCFilter *)((char *)this + 688));
            CLiteMatrix::MatrixMultiply((vDSP_Length *)this + 86, (const CLiteMatrix *)v149, (AUSpatialMixerV2DynamicXTCFilter *)((char *)this + 728), v91);
            CLiteMatrix::MatrixMultiply((vDSP_Length *)this + 91, (const CLiteMatrix *)&v150, (const CLiteMatrix *)&v178, v92);
            vDSP_zvabs(&v173, 1, &__C, 1, 2uLL);
            vDSP_maxv(&__C, 1, &v172, 2uLL);
            v85 = v172;
          }
          while ((float)(log10f(v172) * 20.0) > v84);
        }
        v56 = *((_DWORD *)this + 5);
        if (v56)
        {
          v93 = realp;
          v94 = p_imagp;
          v95 = *((unsigned int *)this + 5);
          do
          {
            (*(v94 - 1))[v61] = *v93;
            v96 = *v94;
            v94 += 2;
            v96[v61] = v93[v65];
            ++v93;
            --v95;
          }
          while (v95);
        }
        ++v61;
      }
      while (v61 != v145);
      if (*((float *)this + 7) > 0.0)
        break;
      v103 = 0;
LABEL_93:
      if (*((_DWORD *)this + 5))
      {
        v108 = 0;
        v109 = v103;
        v110 = v134;
        do
        {
          if (*((float *)this + 7) > 0.0)
          {
            vDSP_vmul(v110->realp, 1, *(const float **)(v164[0] + 24 * v109), 1, v110->realp, 1, v145);
            vDSP_vmul(v110->imagp, 1, *(const float **)(v164[0] + 24 * v109), 1, v110->imagp, 1, v145);
          }
          v111 = *((_DWORD *)this + 13);
          v112 = *(_QWORD *)(*((_QWORD *)this + 100) + 24 * v142);
          if (v111 >= 0)
            v113 = *((_DWORD *)this + 13);
          else
            v113 = v111 + 1;
          *v110->imagp = v110->realp[v113 >> 1];
          v114 = log2((double)v111);
          vDSP_fft_zrip(fftsetup, v110, 1, (unint64_t)v114, -1);
          v115 = (DSPComplex *)(v112 + 4 * (v111 * v108));
          vDSP_ztoc(v110, 1, v115, 2, (uint64_t)v113 >> 1);
          cblas_sscal(v111, 1.0 / (float)v111, (float *)v115, 1);
          ++v108;
          ++v110;
        }
        while (v108 < *((unsigned int *)this + 5));
      }
      v44 = v138 + 1;
      v43 = *((_QWORD *)this + 105);
      v45 = v138 + 1;
      v42 = v137;
      if (0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 106) - v43) >> 3) <= v44)
        goto LABEL_106;
    }
    v97 = v137;
    v98 = v138;
    v99 = v145;
    if (v138 < v137)
    {
      vDSP_zvabs(v134, 1, (float *)v163[0], 1, v145);
      v100 = v135;
      if (*((_DWORD *)this + 5) >= 2u)
      {
        v101 = v132;
        v102 = 1;
        do
        {
          vDSP_zvabs(v101, 1, (float *)v163[0] + v99, 1, v99);
          vDSP_vadd((const float *)v163[0] + v99, 1, (const float *)v163[0], 1, (float *)v163[0], 1, v99);
          ++v102;
          ++v101;
        }
        while (v102 < *((unsigned int *)this + 5));
      }
      LODWORD(v173.realp) = 1068827891;
      vDSP_svdiv((const float *)&v173, (const float *)v163[0], 1, (float *)v163[0], 1, v99);
      AUSpatialMixerV2DynamicXTCFilter::frequencySmooth((AUSpatialMixerV2DynamicXTCFilter *)v163[0], *(float **)(v164[0] + 24 * v100), v133, *((float *)this + 6), *((float *)this + 7));
      v103 = v98;
      goto LABEL_93;
    }
    v172 = 0.0;
    v173.realp = 0;
    v104 = v136;
    v105 = 180.0;
    if (v136 <= 90.0 || v136 > 180.0)
    {
      if (v136 > 180.0 && v136 <= 270.0)
      {
        v106 = v136 + -180.0;
        goto LABEL_91;
      }
      if (v136 <= 270.0 || (v105 = 360.0, v104 = v136, v136 >= 360.0))
      {
        v107 = -v104;
        goto LABEL_92;
      }
    }
    v106 = v105 - v104;
LABEL_91:
    v107 = -v106;
LABEL_92:
    __C = v107;
    vDSP_vsadd(v174.realp, 1, &__C, (float *)v163[0], 1, v137);
    vDSP_vabs((const float *)v163[0], 1, (float *)v163[0], 1, v97);
    vDSP_minvi((const float *)v163[0], 1, &v172, (vDSP_Length *)&v173, v97);
    v103 = v173.realp;
    goto LABEL_93;
  }
LABEL_106:
  vDSP_destroy_fftsetup(fftsetup);
  if (*((float *)this + 12) < 24000.0)
    AUSpatialMixerV2DynamicXTCFilter::applyCrossover(this);
  if (v174.realp)
  {
    v174.imagp = v174.realp;
    operator delete(v174.realp);
  }
  if (v179.realp)
  {
    v179.imagp = v179.realp;
    operator delete(v179.realp);
  }
  if ((_QWORD)v151)
  {
    *((_QWORD *)&v151 + 1) = v151;
    operator delete((void *)v151);
  }
  if ((_QWORD)v157)
  {
    *((_QWORD *)&v157 + 1) = v157;
    operator delete((void *)v157);
  }
  __p[0] = v162;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  if (v163[0])
  {
    v163[1] = v163[0];
    operator delete(v163[0]);
  }
  __p[0] = v164;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  __p[0] = v165;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  __p[0] = v166;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  __p[0] = v167;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  __p[0] = v168;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  __p[0] = v169;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  __p[0] = v171;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
}

void sub_1B61738F4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v3 = *(void **)(v1 + 680);
  if (v3)
  {
    *(_QWORD *)(v1 + 688) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(v1 + 176);
  if (v4)
  {
    *(_QWORD *)(v1 + 184) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(v1 + 272);
  if (v5)
  {
    *(_QWORD *)(v1 + 280) = v5;
    operator delete(v5);
  }
  *(_QWORD *)(v1 + 256) = v1 + 352;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  v6 = *(void **)(v1 + 376);
  if (v6)
  {
    *(_QWORD *)(v1 + 384) = v6;
    operator delete(v6);
  }
  *(_QWORD *)(v1 + 256) = v1 + 400;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(_QWORD *)(v1 + 256) = v1 + 424;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(_QWORD *)(v1 + 256) = v1 + 448;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(_QWORD *)(v1 + 256) = v1 + 472;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(_QWORD *)(v1 + 256) = v1 + 496;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(_QWORD *)(v1 + 256) = v1 + 520;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 256));
  *(_QWORD *)(v1 + 664) = v1 + 552;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v1 + 664));
  _Unwind_Resume(a1);
}

float AUSpatialMixerV2DynamicXTCFilter::getFFT(const DSPComplex *this, DSPSplitComplex *__Z, DSPSplitComplex *a3, OpaqueFFTSetup **a4, OpaqueFFTSetup **a5)
{
  int v6;
  int v8;
  int v9;
  OpaqueFFTSetup *v10;
  long double v11;
  float *imagp;
  float result;

  v6 = (int)a3;
  if ((int)a3 >= 0)
    v8 = (int)a3;
  else
    v8 = (_DWORD)a3 + 1;
  v9 = v8 >> 1;
  vDSP_ctoz(this, 2, __Z, 1, (uint64_t)v8 >> 1);
  v10 = *a4;
  v11 = log2((double)v6);
  vDSP_fft_zrip(v10, __Z, 1, (unint64_t)v11, 1);
  imagp = __Z->imagp;
  result = *imagp;
  __Z->realp[v9] = *imagp;
  imagp[v9] = 0.0;
  *imagp = 0.0;
  return result;
}

uint64_t AUSpatialMixerV2DynamicXTCFilter::readAUXTCFilter(uint64_t a1, uint64_t *a2)
{
  size_t v4;
  void **v5;
  const void *v6;
  const UInt8 *v7;
  CFIndex v8;
  const __CFURL *v9;
  const __CFURL *v10;
  FILE *v11;
  unsigned int v12;
  int v13;
  FILE *v14;
  unint64_t v15;
  NSObject *v16;
  const char *v17;
  uint64_t v18;
  unsigned int v19;
  NSObject *v20;
  _BOOL8 v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  __int128 v25;
  _BYTE *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  NSObject *v30;
  std::string *v31;
  __int128 v32;
  std::string *v33;
  __int128 v34;
  _BYTE *v35;
  NSObject *v36;
  std::string *v38;
  __int128 v39;
  std::string *v40;
  __int128 v41;
  _BYTE *v42;
  std::runtime_error *exception;
  float *v44[5];
  std::string v45;
  std::string v46;
  FILE *v47;
  FILE *v48;
  unsigned int v49;
  unsigned __int16 v50;
  unsigned __int16 v51;
  int v52;
  unsigned __int16 v53;
  FILE *v54;
  unsigned int v55;
  const __CFURL *v56;
  void *v57[2];
  unsigned __int8 v58;
  _BYTE v59[24];
  int v60;
  _BYTE *v61;
  __int16 v62;
  UInt8 *v63;
  UInt8 v64[1024];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (*(char *)(a1 + 1007) >= 0)
    v4 = *(unsigned __int8 *)(a1 + 1007);
  else
    v4 = *(_QWORD *)(a1 + 992);
  v5 = v57;
  std::string::basic_string[abi:ne180100]((uint64_t)v57, v4 + 16);
  if ((v58 & 0x80u) != 0)
    v5 = (void **)v57[0];
  if (v4)
  {
    if (*(char *)(a1 + 1007) >= 0)
      v6 = (const void *)(a1 + 984);
    else
      v6 = *(const void **)(a1 + 984);
    memmove(v5, v6, v4);
  }
  strcpy((char *)v5 + v4, "AUXTC_Tuning.wav");
  if ((v58 & 0x80u) == 0)
    v7 = (const UInt8 *)v57;
  else
    v7 = (const UInt8 *)v57[0];
  if ((v58 & 0x80u) == 0)
    v8 = v58;
  else
    v8 = (CFIndex)v57[1];
  v9 = CFURLCreateWithBytes(0, v7, v8, 0, 0);
  v10 = v9;
  v56 = v9;
  if (!v9)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (!CFURLGetFileSystemRepresentation(v9, 1u, v64, 1024))
  {
    v18 = 0;
LABEL_77:
    CFRelease(v10);
    goto LABEL_78;
  }
  *(_DWORD *)v59 = 0;
  std::vector<float>::vector(&v47, 0x100uLL, v59);
  std::vector<std::vector<float>>::resize(a2, 4uLL, (uint64_t)&v47);
  if (v47)
  {
    v48 = v47;
    operator delete(v47);
  }
  v55 = 0;
  v11 = fopen((const char *)v64, "rb");
  v54 = v11;
  if (!v11 || !fread(&v47, 0x24uLL, 1uLL, v11))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
LABEL_41:
      v14 = v54;
      fclose(v54);
      goto LABEL_42;
    }
    *(_DWORD *)v59 = 136315394;
    *(_QWORD *)&v59[4] = "WaveFileReader";
    *(_WORD *)&v59[12] = 2080;
    *(_QWORD *)&v59[14] = v64;
    v16 = MEMORY[0x1E0C81028];
    v17 = "%s: Invalid wave file path: %s";
LABEL_82:
    _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, v17, v59, 0x16u);
    goto LABEL_41;
  }
  if ((_DWORD)v47 != 1179011410
    || v48 != (FILE *)0x20746D6645564157
    || v49 > 0x28
    || ((1 << v49) & 0x10000050000) == 0
    || (v50 | 2) != 3
    || (v12 = v53, v53 != 16) && v53 != 24 && (v53 != 32 || v50 != 3))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      goto LABEL_41;
    *(_DWORD *)v59 = 136315394;
    *(_QWORD *)&v59[4] = "WaveFileReader";
    *(_WORD *)&v59[12] = 2080;
    *(_QWORD *)&v59[14] = v64;
    v16 = MEMORY[0x1E0C81028];
    v17 = "%s: Invalid format: %s";
    goto LABEL_82;
  }
  v13 = 0;
  v46.__r_.__value_.__s.__data_[0] = 0;
  v14 = v54;
  do
  {
    if (!fread(&v46, 1uLL, 1uLL, v14))
      break;
    HIDWORD(v15) = v46.__r_.__value_.__s.__data_[0];
    LODWORD(v15) = v13;
    v13 = v15 >> 8;
  }
  while (v13 != 1635017060);
  *(_DWORD *)v59 = 0;
  if (fread(v59, 4uLL, 1uLL, v14))
    v55 = 8 * *(_DWORD *)v59 / v12 / v51;
LABEL_42:
  v19 = v55;
  if (!v55)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v30 = getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
      goto LABEL_76;
    std::string::basic_string[abi:ne180100]<0>(&v45, "AUSpatialMixerV2DynamicXTCFilter");
    v31 = std::string::append(&v45, "::", 2uLL);
    v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    v33 = std::string::append(&v46, "readAUXTCFilter", 0xFuLL);
    v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
    *(_QWORD *)&v59[16] = *((_QWORD *)&v33->__r_.__value_.__l + 2);
    *(_OWORD *)v59 = v34;
    v33->__r_.__value_.__l.__size_ = 0;
    v33->__r_.__value_.__r.__words[2] = 0;
    v33->__r_.__value_.__r.__words[0] = 0;
    v35 = v59;
    if (v59[23] < 0)
      v35 = *(_BYTE **)v59;
    v60 = 136315394;
    v61 = v35;
    v62 = 2080;
    v63 = v64;
    _os_log_impl(&dword_1B5ED0000, v30, OS_LOG_TYPE_DEFAULT, "%s: WARNING: AUXTC file not found at %s; will proceed without it",
      (uint8_t *)&v60,
      0x16u);
    goto LABEL_67;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v20 = getAUSMV2Log(void)::gLog;
  v21 = os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT);
  if (v21)
  {
    std::string::basic_string[abi:ne180100]<0>(&v45, "AUSpatialMixerV2DynamicXTCFilter");
    v22 = std::string::append(&v45, "::", 2uLL);
    v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    v24 = std::string::append(&v46, "readAUXTCFilter", 0xFuLL);
    v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    *(_QWORD *)&v59[16] = *((_QWORD *)&v24->__r_.__value_.__l + 2);
    *(_OWORD *)v59 = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    v26 = v59;
    if (v59[23] < 0)
      v26 = *(_BYTE **)v59;
    v60 = 136315394;
    v61 = v26;
    v62 = 2080;
    v63 = v64;
    _os_log_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_DEFAULT, "%s: AUXTC file found: %s", (uint8_t *)&v60, 0x16u);
    if ((v59[23] & 0x80000000) != 0)
      operator delete(*(void **)v59);
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v46.__r_.__value_.__l.__data_);
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (v51 != 4 || v52 != 48000 || v19 >= 0x101)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v36 = getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
      goto LABEL_76;
    std::string::basic_string[abi:ne180100]<0>(&v45, "AUSpatialMixerV2DynamicXTCFilter");
    v38 = std::string::append(&v45, "::", 2uLL);
    v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    v40 = std::string::append(&v46, "readAUXTCFilter", 0xFuLL);
    v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
    *(_QWORD *)&v59[16] = *((_QWORD *)&v40->__r_.__value_.__l + 2);
    *(_OWORD *)v59 = v41;
    v40->__r_.__value_.__l.__size_ = 0;
    v40->__r_.__value_.__r.__words[2] = 0;
    v40->__r_.__value_.__r.__words[0] = 0;
    v42 = v59;
    if (v59[23] < 0)
      v42 = *(_BYTE **)v59;
    v60 = 136315394;
    v61 = v42;
    v62 = 2080;
    v63 = v64;
    _os_log_error_impl(&dword_1B5ED0000, v36, OS_LOG_TYPE_ERROR, "%s: WARNING: AUXTC file found at %s but is invalid; will proceed without it",
      (uint8_t *)&v60,
      0x16u);
LABEL_67:
    if ((v59[23] & 0x80000000) != 0)
      operator delete(*(void **)v59);
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v46.__r_.__value_.__l.__data_);
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v45.__r_.__value_.__l.__data_);
LABEL_76:
    fclose(v14);
    v18 = 4294956425;
    goto LABEL_77;
  }
  MEMORY[0x1E0C80A78](v21);
  v27 = 0;
  v28 = 0;
  memset(v44, 0, 32);
  v29 = *a2;
  do
  {
    *(_DWORD *)v59 = 0;
    std::vector<float>::assign((char **)(v29 + v27), 0x100uLL, v59);
    v29 = *a2;
    v44[v28++] = *(float **)(*a2 + v27);
    v27 += 24;
  }
  while (v28 < v51);
  WaveFileReader::read(&v47, v44, v51, v55);
  v10 = v56;
  fclose(v54);
  v18 = 0;
  if (v10)
    goto LABEL_77;
LABEL_78:
  if ((char)v58 < 0)
    operator delete(v57[0]);
  return v18;
}

void sub_1B6174430(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 + 55) < 0)
    operator delete(*(void **)(v1 + 32));
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  fclose(*(FILE **)(v1 + 96));
  applesauce::CF::URLRef::~URLRef((const void **)(v1 + 112));
  if (*(char *)(v1 + 143) < 0)
    operator delete(*(void **)(v1 + 120));
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2DynamicXTCFilter::getTargetFIR(uint64_t a1, _QWORD *a2, int a3)
{
  unsigned int NumFiltersPerSpatialPoint;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  int v17;
  int64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  int v30;
  int v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  BOOL v36;
  char v37;
  uint64_t v38;
  void *__p[3];
  char v40[36];

  NumFiltersPerSpatialPoint = IR::IRData::getNumFiltersPerSpatialPoint(*(IR::IRData **)(a1 + 768));
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)v40);
  std::vector<float>::vector(__p, (int)NumFiltersPerSpatialPoint);
  IR::IRCoordinates::set();
  IR::IRCoordinates::set();
  IR::IRCoordinates::set();
  IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
  if (a3 && NumFiltersPerSpatialPoint)
  {
    v7 = 0;
    v8 = NumFiltersPerSpatialPoint;
    do
    {
      v9 = *a2 + 24 * v7;
      v11 = *(char **)v9;
      v10 = *(char **)(v9 + 8);
      v12 = (v10 - v11) >> 2;
      v13 = *(unsigned int *)(a1 + 52);
      v14 = v12 - (v13 >> 2);
      v15 = &v11[4 * v14];
      if (v12 != v13 >> 2 && v15 != v10)
      {
        if (v14 == 1)
        {
          v17 = *(_DWORD *)v11;
          v18 = v10 - v15;
          memmove(v11, v15, v10 - v15);
          *(_DWORD *)&v11[v18] = v17;
        }
        else if (v15 + 4 == v10)
        {
          v25 = *((_DWORD *)v10 - 1);
          if (v10 - 4 != v11)
            memmove(v11 + 4, v11, v10 - 4 - v11);
          *(_DWORD *)v11 = v25;
        }
        else if (v14 == (v10 - v15) >> 2)
        {
          if (v14)
          {
            v19 = 0;
            v20 = 4 * v12 - 4 * (v13 >> 2);
            v21 = v20 - 4;
            v22 = &v11[v20];
            do
            {
              v23 = *(_DWORD *)&v11[v19];
              *(_DWORD *)&v11[v19] = *(_DWORD *)&v22[v19];
              *(_DWORD *)&v22[v19] = v23;
              v24 = (uint64_t)&v22[v19 + 4];
              if (v21 == v19)
                break;
              v19 += 4;
            }
            while ((char *)v24 != v10);
          }
        }
        else
        {
          v26 = (v10 - v15) >> 2;
          v27 = v14;
          do
          {
            v28 = v27;
            v27 = v26;
            v26 = v28 % v26;
          }
          while (v26);
          if (v27)
          {
            v29 = &v11[4 * v27];
            do
            {
              v30 = *((_DWORD *)v29 - 1);
              v29 -= 4;
              v31 = v30;
              v32 = &v29[4 * v14];
              v33 = v29;
              do
              {
                v34 = v32;
                *(_DWORD *)v33 = *(_DWORD *)v32;
                v35 = &v32[4 * v14];
                v36 = __OFSUB__(v14, (v10 - v32) >> 2);
                v38 = v14 - ((v10 - v32) >> 2);
                v37 = (v38 < 0) ^ v36;
                v32 = &v11[4 * v38];
                if (v37)
                  v32 = v35;
                v33 = v34;
              }
              while (v32 != v29);
              *(_DWORD *)v34 = v31;
            }
            while (v29 != v11);
          }
        }
      }
      ++v7;
    }
    while (v7 != v8);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1B6174748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void AUSpatialMixerV2DynamicXTCFilter::frequencySmooth(AUSpatialMixerV2DynamicXTCFilter *this, float *a2, float *a3, float a4, float a5)
{
  unsigned int v7;
  vDSP_Length v10;
  uint64_t v11;
  float *v12;
  float *v13;
  int32x2_t v14;
  int32x2_t v15;
  unint64_t v16;
  float32x2_t v17;
  int64x2_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64x2_t v21;
  float v22;
  float32x2_t v23;
  float32x2_t v24;
  uint64_t v25;
  int64x2_t v26;
  int32x2_t v27;
  int32x2_t v28;
  float32x2_t v29;
  float v30;
  __int128 v31;
  int64x2_t v32;
  float __C;
  float __B;
  float v35;
  int v36;
  uint64_t v37;

  v7 = a3;
  v37 = *MEMORY[0x1E0C80C00];
  v36 = (int)a3;
  v10 = a3;
  MEMORY[0x1E0C80A78](this);
  v12 = (float *)((char *)&v31 - v11);
  __B = 1.0;
  vDSP_vdbcon(v13, 1, &__B, v13, 1, v10, 1u);
  v35 = a5 / 100.0;
  if ((float)(a5 / 100.0) != 1.0)
    vDSP_vsmul((const float *)this, 1, &v35, (float *)this, 1, v10);
  if (v7)
  {
    v16 = 0;
    v17 = (float32x2_t)vdup_n_s32(0x473B8000u);
    v18 = vdupq_n_s64(2uLL);
    v31 = xmmword_1B6626830;
    v32 = v18;
    do
    {
      *(float *)v14.i32 = (float)(int)v7 + (float)(int)v7;
      *(float *)v15.i32 = (float)((float)((float)v16 + 0.5) / *(float *)v14.i32) * 48000.0;
      if (*(float *)v15.i32 <= a4)
      {
        v19 = 0;
        if (v7 <= 1)
          v20 = 1;
        else
          v20 = v7;
        v21 = (uint64x2_t)vdupq_n_s64(v20 - 1);
        v22 = (float)((float)(*(float *)v15.i32 / 3.0) / 3.1416)
            * (float)((float)((float)(*(float *)v15.i32 / 3.0) / 3.1416)
                    + (float)((float)(*(float *)v15.i32 / 3.0) / 3.1416));
        v23 = (float32x2_t)vdup_lane_s32(v14, 0);
        v24 = (float32x2_t)vdup_lane_s32(v15, 0);
        v25 = (4 * v20 + 4) & 0x7FFFFFFF8;
        v26 = (int64x2_t)v31;
        v27 = (int32x2_t)0x100000000;
        do
        {
          v28 = vmovn_s64((int64x2_t)vcgeq_u64(v21, (uint64x2_t)v26));
          v29 = vsub_f32(vmul_f32(vdiv_f32(vadd_f32(vcvt_f32_u32((uint32x2_t)v27), (float32x2_t)0x3F0000003F000000), v23), v17), v24);
          if ((v28.i8[0] & 1) != 0)
            v12[v19 / 4] = (float)((float)-v29.f32[0] * v29.f32[0]) / v22;
          if ((v28.i8[4] & 1) != 0)
            v12[v19 / 4 + 1] = vmuls_lane_f32(-v29.f32[1], v29, 1) / v22;
          v26 = vaddq_s64(v26, v18);
          v27 = vadd_s32(v27, (int32x2_t)0x200000002);
          v19 += 8;
        }
        while (v25 != v19);
        vvexpf(v12, v12, &v36);
        __C = 0.0;
        vDSP_sve(v12, 1, &__C, v36);
        vDSP_vsdiv(v12, 1, &__C, v12, 1, v36);
        vDSP_vmul(v12, 1, (const float *)this, 1, v12, 1, v36);
        vDSP_sve(v12, 1, &__C, v36);
        v30 = __exp10f(__C / 20.0);
        v18 = v32;
        a2[v16] = v30;
        v7 = v36;
      }
      else
      {
        a2[v16] = 1.0;
      }
      ++v16;
    }
    while (v16 < v7);
  }
  a2[v7] = a2[v7 - 1];
}

void AUSpatialMixerV2DynamicXTCFilter::applyCrossover(AUSpatialMixerV2DynamicXTCFilter *this)
{
  uint64_t v2;
  uint64_t v3;
  float *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  float *v9;
  double v10;
  __double2 v11;
  __double2 v12;
  unsigned int v13;
  unsigned int v14;
  float sinval;
  unint64_t v16;
  unint64_t v17;
  vDSP_Length v18;
  float *v19;
  _BOOL4 v20;
  vDSP_Length v21;
  const float *v22;
  vDSP_Length v23;
  float *v24;
  NSObject *v25;
  std::string *v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  __int128 v30;
  __int128 *v31;
  uint64_t v32;
  void *v33[2];
  char v34;
  std::string v35;
  __int128 v36;
  int64_t v37;
  float __B;
  __int128 buf;
  unint64_t v40;
  float v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 5) < 2u)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v25 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      v26 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v33, "AUSpatialMixerV2DynamicXTCFilter");
      v27 = std::string::append(v26, "::", 2uLL);
      v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      v35.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      v29 = std::string::append(&v35, "applyCrossover", 0xEuLL);
      v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
      v37 = v29->__r_.__value_.__r.__words[2];
      v36 = v30;
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      v29->__r_.__value_.__r.__words[0] = 0;
      v31 = &v36;
      if (v37 < 0)
        v31 = (__int128 *)v36;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v31;
      _os_log_error_impl(&dword_1B5ED0000, v25, OS_LOG_TYPE_ERROR, "%s: Crossover can not be applied if the number of drivers is < 2", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(v37) < 0)
        operator delete((void *)v36);
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v35.__r_.__value_.__l.__data_);
      if (v34 < 0)
        operator delete(v33[0]);
    }
  }
  else
  {
    __B = __exp10f(*((float *)this + 8) / 20.0);
    MEMORY[0x1E0C80A78](v2);
    v4 = (float *)((char *)&v33[-1] - ((v3 + 15) & 0x7FFFFFFF0));
    v5 = *((unsigned int *)this + 13);
    LODWORD(v35.__r_.__value_.__l.__data_) = 0;
    std::vector<float>::vector(&v36, v5, &v35);
    std::vector<float>::vector(&v35, *((unsigned int *)this + 13));
    LODWORD(buf) = 0;
    std::vector<float>::vector(v33, 0xAuLL, &buf);
    HIDWORD(v32) = 0;
    std::vector<float>::vector(&buf, 0xAuLL, (_DWORD *)&v32 + 1);
    v6 = *((_QWORD *)this + 105);
    if (*((_QWORD *)this + 106) != v6)
    {
      v7 = 0;
      v8 = 0;
      do
      {
        v9 = *(float **)(v6 + 24 * v7);
        v10 = v9[1] * 0.0174532925;
        v11 = __sincos_stret(*v9 * 0.0174532925);
        v12 = __sincos_stret(v10);
        *(float *)&v13 = v11.__cosval * v12.__cosval;
        *(float *)&v14 = v11.__cosval * v12.__sinval;
        v40 = __PAIR64__(v14, v13);
        sinval = v11.__sinval;
        v41 = sinval;
        VBAP::calculateVBAPGains(*((VBAP **)this + 122), (float32x2_t *)&v40, v4);
        LODWORD(v16) = *((_DWORD *)this + 5);
        if ((_DWORD)v16)
        {
          v17 = 0;
          do
          {
            v18 = *((unsigned int *)this + 13);
            v19 = (float *)(*(_QWORD *)(*((_QWORD *)this + 100) + 24 * v7) + 4 * (v18 * v17));
            vDSP_biquad(*((const vDSP_biquad_SetupStruct **)this + 120), (float *)buf, v19, 1, v19, 1, v18);
            v20 = v17;
            if (*((_QWORD *)this + 98))
            {
              if (*((_QWORD *)this + 115) == *((_QWORD *)this + 114))
                v20 = v17 & 1;
              else
                v20 = *(float *)(*((_QWORD *)this + 108) + 4 * v17) >= 0.0;
            }
            v21 = *((unsigned int *)this + 13);
            v22 = (const float *)v36;
            *(float *)(v36 + (v21 & 0xFFFFFFFC)) = v4[v20];
            vDSP_biquad(*((const vDSP_biquad_SetupStruct **)this + 118), (float *)v33[0], v22, 1, (float *)v35.__r_.__value_.__l.__data_, 1, v21);
            v23 = *((unsigned int *)this + 13);
            v24 = (float *)(*(_QWORD *)(*((_QWORD *)this + 100) + 24 * v7) + 4 * (v23 * v17));
            vDSP_vadd((const float *)v35.__r_.__value_.__l.__data_, 1, v24, 1, v24, 1, v23);
            vDSP_vclr((float *)v33[0], 1, 0xAuLL);
            vDSP_vclr((float *)buf, 1, 0xAuLL);
            ++v17;
            v16 = *((unsigned int *)this + 5);
          }
          while (v17 < v16);
        }
        vDSP_vsmul(*(const float **)(*((_QWORD *)this + 100) + 24 * v7), 1, &__B, *(float **)(*((_QWORD *)this + 100) + 24 * v7), 1, (*((_DWORD *)this + 13) * v16));
        v6 = *((_QWORD *)this + 105);
        v7 = ++v8;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 106) - v6) >> 3) > v8);
    }
    if ((_QWORD)buf)
    {
      *((_QWORD *)&buf + 1) = buf;
      operator delete((void *)buf);
    }
    if (v33[0])
    {
      v33[1] = v33[0];
      operator delete(v33[0]);
    }
    if (v35.__r_.__value_.__r.__words[0])
    {
      v35.__r_.__value_.__l.__size_ = v35.__r_.__value_.__r.__words[0];
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if ((_QWORD)v36)
    {
      *((_QWORD *)&v36 + 1) = v36;
      operator delete((void *)v36);
    }
  }
}

void sub_1B6174EA0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 201) < 0)
    operator delete(*(void **)(v1 - 224));
  if (*(char *)(v1 - 225) < 0)
    operator delete(*(void **)(v1 - 248));
  _Unwind_Resume(exception_object);
}

void AUSpatialMixerV2DynamicXTCFilter::analyticalInverseStereo(AUSpatialMixerV2DynamicXTCFilter *this, DSPSplitComplex *a2)
{
  DSPSplitComplex *v2;
  AUSpatialMixerV2DynamicXTCFilter *v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  float32x2_t v19;
  int v20;
  int v21;
  float v22;
  uint64_t v23;
  int v24;
  int v25;
  float32x2_t v26;
  float v27;
  float v28;
  float v29;
  float v30;
  _DWORD v31[8];
  uint64_t v32;

  v2 = a2;
  v3 = this;
  v32 = *MEMORY[0x1E0C80C00];
  v4 = *((float *)this + 1);
  v5 = -*((float *)&a2->realp + 1);
  v6 = -*(float *)&a2->imagp;
  v7 = *((float *)this + 2);
  v8 = *((float *)this + 3);
  v9 = -*((float *)&a2->imagp + 1);
  v29 = *(float *)this;
  v30 = -*(float *)&a2->realp;
  v10 = std::operator*[abi:ne180100]<float>(*(float *)this, v30, v8, v9);
  v12 = v11;
  v13 = v10 - std::operator*[abi:ne180100]<float>(v7, v6, v4, v5);
  v15 = v12 - v14;
  if (v13 == 0.0 && v15 == 0.0)
  {
    v16 = 0.0;
    v17 = 1.0;
  }
  else
  {
    v17 = std::operator/[abi:ne180100]<float>(1.0, 0.0, v13, v15);
  }
  v26 = (float32x2_t)__PAIR64__(LODWORD(v16), LODWORD(v17));
  v27 = v16;
  v28 = v17;
  v31[0] = std::operator*[abi:ne180100]<float>(v17, v16, v8, v9);
  v31[1] = v18;
  v19 = vneg_f32(v26);
  v31[2] = std::operator*[abi:ne180100]<float>(v19.f32[0], v19.f32[1], v7, v6);
  v31[3] = v20;
  v31[4] = std::operator*[abi:ne180100]<float>(v19.f32[0], v19.f32[1], v4, v5);
  v31[5] = v21;
  v22 = std::operator*[abi:ne180100]<float>(v28, v27, v29, v30);
  v23 = 0;
  *(float *)&v31[6] = v22;
  v31[7] = v24;
  do
  {
    v25 = v31[v23 + 1];
    *(_DWORD *)v3 = v31[v23];
    v3 = (AUSpatialMixerV2DynamicXTCFilter *)((char *)v3 + 4);
    LODWORD(v2->realp) = v25;
    v2 = (DSPSplitComplex *)((char *)v2 + 4);
    v23 += 2;
  }
  while (v23 != 8);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[17],float>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B617514C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B6175214(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61752DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61753A4(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2DynamicXTCFilter::updateParamDictionary(uint64_t a1, const void *a2)
{
  const void *v3;
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  int v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const __CFNumber *v10;
  uint64_t v11;
  float32x2_t *v12;
  _QWORD *v13;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  float v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  int v19;
  const __CFDictionary *v20;
  float v21;
  const __CFDictionary *v22;
  const __CFDictionary *v23;
  int v24;
  const __CFDictionary *v25;
  float v26;
  const __CFDictionary *v27;
  uint64_t v28;
  const __CFDictionary *v29;
  float v30;
  const __CFDictionary *v31;
  uint64_t v32;
  const __CFDictionary *v33;
  float v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  const __CFDictionary *v37;
  float v38;
  const __CFDictionary *v39;
  float v40;
  float v41;
  const __CFDictionary *v42;
  const __CFDictionary *v43;
  int v44;
  const __CFDictionary *v45;
  unsigned int v46;
  int v47;
  const __CFDictionary *v48;
  const __CFDictionary *v49;
  _QWORD *v50;
  int v51;
  const UInt8 *v52;
  CFIndex v53;
  _QWORD *v54;
  uint64_t v55;
  const void *v56;
  const void *v57;
  NSObject *v58;
  _QWORD *v59;
  _QWORD *v60;
  _QWORD *v61;
  _QWORD *v62;
  int v63;
  NSObject *v64;
  std::string *p_key;
  std::string *v66;
  __int128 v67;
  std::string *v68;
  __int128 v69;
  std::string *v70;
  std::string *v71;
  __int128 v72;
  std::string *v73;
  __int128 v74;
  std::string *v75;
  std::runtime_error *v76;
  std::runtime_error *v77;
  std::runtime_error *v78;
  std::runtime_error *v79;
  std::runtime_error *v80;
  std::runtime_error *v81;
  std::runtime_error *v82;
  std::runtime_error *v83;
  std::runtime_error *v84;
  std::runtime_error *v85;
  std::runtime_error *v86;
  std::runtime_error *v87;
  std::runtime_error *v88;
  std::runtime_error *v89;
  std::runtime_error *v90;
  std::runtime_error *exception;
  std::runtime_error *v92;
  std::runtime_error *v93;
  std::runtime_error *v94;
  std::runtime_error *v95;
  std::runtime_error *v96;
  std::runtime_error *v97;
  std::runtime_error *v98;
  std::runtime_error *v99;
  std::runtime_error *v100;
  float v101;
  CFURLRef v102;
  CFTypeRef cf;
  void *__p;
  std::string valuePtr;
  std::string v106;
  CFTypeRef CFDictionaryRef;
  __int128 v108;
  _QWORD *v109;
  std::string buf;
  std::string key;
  uint64_t v112;
  uint64_t v113;
  uint64_t v115;
  uint64_t v117;
  uint64_t v119;
  uint64_t v120;
  _BYTE v122[8];
  _QWORD v123[3];

  v123[2] = *MEMORY[0x1E0C80C00];
  v3 = *(const void **)(a1 + 936);
  *(_QWORD *)(a1 + 936) = a2;
  if (a2)
    CFRetain(a2);
  if (v3)
    CFRelease(v3);
  *(_DWORD *)(a1 + 4) = 0;
  v4 = *(const __CFDictionary **)(a1 + 936);
  if (!v4)
    return;
  if (applesauce::CF::details::has_key<char const(&)[25]>(v4, "CounteractRotationShader"))
  {
    v5 = *(const __CFDictionary **)(a1 + 936);
    if (!v5)
      goto LABEL_172;
    v6 = *(unsigned __int8 *)(a1 + 56);
    if (v6 != applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[25]>(v5, "CounteractRotationShader"))
    {
      v7 = *(const __CFDictionary **)(a1 + 936);
      if (!v7)
        goto LABEL_172;
      *(_BYTE *)(a1 + 56) = applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[25]>(v7, "CounteractRotationShader");
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  v8 = *(const __CFDictionary **)(a1 + 936);
  if (!v8)
    goto LABEL_172;
  if (!applesauce::CF::details::has_key<char const(&)[12]>(v8, "SpeakerSpan"))
    goto LABEL_21;
  v9 = *(const __CFDictionary **)(a1 + 936);
  if (!v9)
  {
LABEL_172:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
LABEL_173:
  }
  v10 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[12]>(v9, "SpeakerSpan");
  if (v10)
    LODWORD(v10) = applesauce::CF::convert_as<float,0>(v10);
  if (*(float *)(a1 + 44) != *(float *)&v10)
  {
    *(_DWORD *)(a1 + 44) = (_DWORD)v10;
    if (*(_QWORD *)(a1 + 784))
    {
      v11 = *(_QWORD *)(a1 + 976);
      v101 = *(float *)&v10;
      v12 = (float32x2_t *)operator new(8uLL);
      *v12 = vmul_n_f32((float32x2_t)0x3F000000BF000000, v101);
      key.__r_.__value_.__l.__size_ = (std::string::size_type)&v12[1];
      key.__r_.__value_.__r.__words[2] = (std::string::size_type)&v12[1];
      key.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
      v13 = operator new(8uLL);
      v106.__r_.__value_.__l.__size_ = (std::string::size_type)(v13 + 1);
      v106.__r_.__value_.__r.__words[2] = (std::string::size_type)(v13 + 1);
      *v13 = 0;
      v106.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
      VBAP::changeSpeakerLocations(v11, (uint64_t *)&key, (uint64_t *)&v106);
      operator delete(v13);
      operator delete(v12);
    }
    else
    {
      AUSpatialMixerV2DynamicXTCFilter::updateSpeakerLocations(a1);
      VBAP::changeSpeakerLocations(*(_QWORD *)(a1 + 976), (uint64_t *)(a1 + 864), (uint64_t *)(a1 + 888));
    }
    *(_DWORD *)(a1 + 4) = 1065353216;
  }
LABEL_21:
  v14 = *(const __CFDictionary **)(a1 + 936);
  if (!v14)
    goto LABEL_168;
  if (applesauce::CF::details::has_key<char const(&)[15]>(v14, "Regularization"))
  {
    v15 = *(const __CFDictionary **)(a1 + 936);
    if (!v15)
      goto LABEL_168;
    v16 = *(float *)(a1 + 40);
    if (v16 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[15]>(v15, "Regularization")))
    {
      v17 = *(const __CFDictionary **)(a1 + 936);
      if (v17)
      {
        *(_DWORD *)(a1 + 40) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[15]>(v17, "Regularization");
        *(_DWORD *)(a1 + 4) = 1065353216;
        goto LABEL_27;
      }
LABEL_168:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
      goto LABEL_173;
    }
  }
LABEL_27:
  v18 = *(const __CFDictionary **)(a1 + 936);
  if (!v18)
    goto LABEL_168;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, "Constraint");
  v19 = CFDictionaryContainsKey(v18, key.__r_.__value_.__l.__data_);
  if (key.__r_.__value_.__r.__words[0])
    CFRelease(key.__r_.__value_.__l.__data_);
  if (v19)
  {
    v20 = *(const __CFDictionary **)(a1 + 936);
    if (!v20)
    {
      v82 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v82);
    }
    v21 = *(float *)(a1 + 36);
    if (v21 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[11]>(v20)))
    {
      v22 = *(const __CFDictionary **)(a1 + 936);
      if (!v22)
      {
        v89 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(v89);
      }
      *(_DWORD *)(a1 + 36) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[11]>(v22);
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  v23 = *(const __CFDictionary **)(a1 + 936);
  if (!v23)
  {
    v76 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v76);
  }
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, "PostTimbralFrequency");
  v24 = CFDictionaryContainsKey(v23, key.__r_.__value_.__l.__data_);
  if (key.__r_.__value_.__r.__words[0])
    CFRelease(key.__r_.__value_.__l.__data_);
  if (v24)
  {
    v25 = *(const __CFDictionary **)(a1 + 936);
    if (!v25)
    {
      v83 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v83);
    }
    v26 = *(float *)(a1 + 24);
    if (v26 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>(v25)))
    {
      v27 = *(const __CFDictionary **)(a1 + 936);
      if (!v27)
      {
        v90 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(v90);
      }
      *(_DWORD *)(a1 + 24) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>(v27);
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  v28 = *(_QWORD *)(a1 + 936);
  if (!v28)
  {
    v77 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v77);
  }
  if (applesauce::CF::details::has_key<char const(&)[17]>(v28, "PostTimbralBlend"))
  {
    v29 = *(const __CFDictionary **)(a1 + 936);
    if (!v29)
    {
      v84 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v84);
    }
    v30 = *(float *)(a1 + 28);
    if (v30 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[17]>(v29, "PostTimbralBlend")))
    {
      v31 = *(const __CFDictionary **)(a1 + 936);
      if (!v31)
      {
        v92 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(v92);
      }
      *(_DWORD *)(a1 + 28) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[17]>(v31, "PostTimbralBlend");
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  v32 = *(_QWORD *)(a1 + 936);
  if (!v32)
  {
    v78 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v78);
  }
  if (applesauce::CF::details::has_key<char const(&)[9]>(v32, "PostGain"))
  {
    v33 = *(const __CFDictionary **)(a1 + 936);
    if (!v33)
    {
      v85 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v85);
    }
    v34 = *(float *)(a1 + 32);
    if (v34 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[9]>(v33)))
    {
      v35 = *(const __CFDictionary **)(a1 + 936);
      if (!v35)
      {
        v93 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(v93);
      }
      *(_DWORD *)(a1 + 32) = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[9]>(v35);
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  v36 = *(const __CFDictionary **)(a1 + 936);
  if (!v36)
  {
    v79 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v79);
  }
  if (applesauce::CF::details::has_key<char const(&)[10]>(v36, "Crossover"))
  {
    v37 = *(const __CFDictionary **)(a1 + 936);
    if (!v37)
    {
      v86 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v86);
    }
    v38 = *(float *)(a1 + 48);
    if (v38 != COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[10]>(v37)))
    {
      v39 = *(const __CFDictionary **)(a1 + 936);
      if (!v39)
      {
        v94 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(v94);
      }
      v40 = COERCE_FLOAT(applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[10]>(v39));
      *(float *)(a1 + 48) = v40;
      v41 = (float)((float)(v40 + v40) / *(float *)(a1 + 8)) * 3.14159265;
      AUSpatialMixerV2DynamicXTCFilter::setLR8Crossover((AUSpatialMixerV2DynamicXTCFilter *)a1, v41);
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  v42 = *(const __CFDictionary **)(a1 + 936);
  if (!v42)
  {
    v80 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v80);
  }
  if (applesauce::CF::details::has_key<char const(&)[13]>(v42, "FilterLength"))
  {
    v43 = *(const __CFDictionary **)(a1 + 936);
    if (!v43)
    {
      v87 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v87);
    }
    v44 = *(_DWORD *)(a1 + 52);
    if (v44 != applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,char const(&)[13]>(v43))
    {
      v45 = *(const __CFDictionary **)(a1 + 936);
      if (!v45)
      {
        v95 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(v95);
      }
      v46 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,char const(&)[13]>(v45);
      if (v46 >= 0x100)
        v47 = 256;
      else
        v47 = v46;
      *(_DWORD *)(a1 + 52) = v47;
      *(_DWORD *)(a1 + 4) = 1065353216;
    }
  }
  v48 = *(const __CFDictionary **)(a1 + 936);
  if (!v48)
  {
    v81 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v81);
  }
  if (applesauce::CF::details::has_key<char const(&)[12]>(v48, "SaveXTCFile"))
  {
    v49 = *(const __CFDictionary **)(a1 + 936);
    if (!v49)
    {
      v88 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v88);
    }
    if (applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[12]>(v49, "SaveXTCFile")
      && *(_QWORD *)(a1 + 808) != *(_QWORD *)(a1 + 800))
    {
      v50 = (_QWORD *)(a1 + 1008);
      v51 = *(char *)(a1 + 1031);
      if (v51 >= 0)
        v52 = (const UInt8 *)(a1 + 1008);
      else
        v52 = *(const UInt8 **)(a1 + 1008);
      if (v51 >= 0)
        v53 = *(unsigned __int8 *)(a1 + 1031);
      else
        v53 = *(_QWORD *)(a1 + 1016);
      v102 = CFURLCreateWithBytes(0, v52, v53, 0, 0);
      if (!v102)
      {
        v96 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v96, "Could not construct");
      }
      *(float *)&buf.__r_.__value_.__l.__data_ = (float)*(unsigned int *)(a1 + 52) / 192000.0;
      applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[17],float>((applesauce::CF::TypeRef *)&key, "XTCModelingDelay", (int *)&buf);
      applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float &>((applesauce::CF::TypeRef *)&key.__r_.__value_.__r.__words[2], "XTCSpeakerSpan", (int *)(a1 + 44));
      applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],float &>((applesauce::CF::TypeRef *)&v112, "XTCRegularization", (int *)(a1 + 40));
      applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v113, "XTCConstraint");
      LODWORD(valuePtr.__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 36);
      if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
      {
        v97 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v97, "Could not construct");
      }
      applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v115, "XTCPostTimbralFrequency");
      LODWORD(valuePtr.__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 24);
      if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
      {
        v98 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v98, "Could not construct");
      }
      applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v117, "XTCPostTimbralBlend");
      LODWORD(valuePtr.__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 28);
      if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
      {
        v99 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v99, "Could not construct");
      }
      applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float &>((applesauce::CF::TypeRef *)&v119, "XTCPostGain", (int *)(a1 + 32));
      applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v120, "XTCCrossover");
      LODWORD(valuePtr.__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 48);
      if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
      {
        v100 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v100, "Could not construct");
      }
      applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v122, "CounteractRotationShader");
      if (*(_BYTE *)(a1 + 56))
        v54 = (_QWORD *)MEMORY[0x1E0C9AE50];
      else
        v54 = (_QWORD *)MEMORY[0x1E0C9AE40];
      v123[0] = *v54;
      v106.__r_.__value_.__r.__words[0] = (std::string::size_type)&key;
      v106.__r_.__value_.__l.__size_ = 9;
      v55 = 0;
      CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v106);
      do
      {
        v56 = (const void *)v123[v55];
        if (v56)
          CFRelease(v56);
        v57 = *(const void **)&v122[v55 * 8];
        if (v57)
          CFRelease(v57);
        v55 -= 2;
      }
      while (v55 != -18);
      std::string::basic_string[abi:ne180100]<0>(&key, "Generated Using the AUSM - Virtual Surround Tuning Tool");
      if (*(_BYTE *)(a1 + 57))
        std::string::append(&key, " - Magic Unicorn", 0x10uLL);
      if (*(_QWORD *)(a1 + 784))
        std::string::append(&key, " - Measured Device Reference", 0x1CuLL);
      if (2 * *(_DWORD *)(a1 + 52) != (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 800) + 8) - **(_QWORD **)(a1 + 800)) >> 2)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v58 = getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          std::string::basic_string[abi:ne180100]<0>(&buf, "AUSpatialMixerV2DynamicXTCFilter");
          v71 = std::string::append(&buf, "::", 2uLL);
          v72 = *(_OWORD *)&v71->__r_.__value_.__l.__data_;
          valuePtr.__r_.__value_.__r.__words[2] = v71->__r_.__value_.__r.__words[2];
          *(_OWORD *)&valuePtr.__r_.__value_.__l.__data_ = v72;
          v71->__r_.__value_.__l.__size_ = 0;
          v71->__r_.__value_.__r.__words[2] = 0;
          v71->__r_.__value_.__r.__words[0] = 0;
          v73 = std::string::append(&valuePtr, "writeIRFile", 0xBuLL);
          v74 = *(_OWORD *)&v73->__r_.__value_.__l.__data_;
          v106.__r_.__value_.__r.__words[2] = v73->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v106.__r_.__value_.__l.__data_ = v74;
          v73->__r_.__value_.__l.__size_ = 0;
          v73->__r_.__value_.__r.__words[2] = 0;
          v73->__r_.__value_.__r.__words[0] = 0;
          v75 = &v106;
          if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v75 = (std::string *)v106.__r_.__value_.__r.__words[0];
          LODWORD(v108) = 136315138;
          *(_QWORD *)((char *)&v108 + 4) = v75;
          _os_log_error_impl(&dword_1B5ED0000, v58, OS_LOG_TYPE_ERROR, "%s: Filter matrix size inconsistent with user-defined filter length; IR file may not render",
            (uint8_t *)&v108,
            0xCu);
          if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v106.__r_.__value_.__l.__data_);
          if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0)
            operator delete(valuePtr.__r_.__value_.__l.__data_);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
      v59 = operator new(8uLL);
      v106.__r_.__value_.__r.__words[0] = (std::string::size_type)v59;
      *v59 = 1;
      v106.__r_.__value_.__l.__size_ = (std::string::size_type)(v59 + 1);
      v106.__r_.__value_.__r.__words[2] = (std::string::size_type)(v59 + 1);
      memset(&valuePtr, 0, sizeof(valuePtr));
      v60 = operator new(8uLL);
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
      *v60 = 0x43B4000000000000;
      buf.__r_.__value_.__l.__size_ = (std::string::size_type)(v60 + 1);
      buf.__r_.__value_.__r.__words[2] = (std::string::size_type)(v60 + 1);
      v61 = operator new(8uLL);
      *(_QWORD *)&v108 = v61;
      *v61 = 0x100000001;
      *((_QWORD *)&v108 + 1) = v61 + 1;
      v109 = v61 + 1;
      v62 = operator new(8uLL);
      *v62 = 0;
      __p = v62;
      IR::IRData::getTriangulationData(*(IR::IRData **)(a1 + 768));
      v63 = IR::IRDataLoader::writeIRFile();
      if (cf)
        CFRelease(cf);
      if (__p)
        operator delete(__p);
      if ((_QWORD)v108)
      {
        *((_QWORD *)&v108 + 1) = v108;
        operator delete((void *)v108);
      }
      if (buf.__r_.__value_.__r.__words[0])
      {
        buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&valuePtr;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
      if (v106.__r_.__value_.__r.__words[0])
      {
        v106.__r_.__value_.__l.__size_ = v106.__r_.__value_.__r.__words[0];
        operator delete(v106.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(key.__r_.__value_.__r.__words[2]) < 0)
        operator delete(key.__r_.__value_.__l.__data_);
      if (CFDictionaryRef)
        CFRelease(CFDictionaryRef);
      CFRelease(v102);
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v64 = getAUSMV2Log(void)::gLog;
      if (v63)
      {
        if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
          return;
        std::string::basic_string[abi:ne180100]<0>(&valuePtr, "AUSpatialMixerV2DynamicXTCFilter");
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("::", &valuePtr, &v106);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("updateParamDictionary", &v106, &key);
        if ((key.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_key = &key;
        else
          p_key = (std::string *)key.__r_.__value_.__r.__words[0];
        if (*(char *)(a1 + 1031) < 0)
          v50 = (_QWORD *)*v50;
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_key;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v50;
        _os_log_error_impl(&dword_1B5ED0000, v64, OS_LOG_TYPE_ERROR, "%s: Error: Virtual Surround Tool XTCIR file could not be written to: %s", (uint8_t *)&buf, 0x16u);
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
          return;
        std::string::basic_string[abi:ne180100]<0>(&valuePtr, "AUSpatialMixerV2DynamicXTCFilter");
        v66 = std::string::append(&valuePtr, "::", 2uLL);
        v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
        v106.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v106.__r_.__value_.__l.__data_ = v67;
        v66->__r_.__value_.__l.__size_ = 0;
        v66->__r_.__value_.__r.__words[2] = 0;
        v66->__r_.__value_.__r.__words[0] = 0;
        v68 = std::string::append(&v106, "updateParamDictionary", 0x15uLL);
        v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
        key.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
        *(_OWORD *)&key.__r_.__value_.__l.__data_ = v69;
        v68->__r_.__value_.__l.__size_ = 0;
        v68->__r_.__value_.__r.__words[2] = 0;
        v68->__r_.__value_.__r.__words[0] = 0;
        v70 = &key;
        if ((key.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v70 = (std::string *)key.__r_.__value_.__r.__words[0];
        if (*(char *)(a1 + 1031) < 0)
          v50 = (_QWORD *)*v50;
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v70;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v50;
        _os_log_impl(&dword_1B5ED0000, v64, OS_LOG_TYPE_DEFAULT, "%s: Virtual Surround Tool XTCIR file written to: %s", (uint8_t *)&buf, 0x16u);
      }
      if (SHIBYTE(key.__r_.__value_.__r.__words[2]) < 0)
        operator delete(key.__r_.__value_.__l.__data_);
      if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v106.__r_.__value_.__l.__data_);
      if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0)
        operator delete(valuePtr.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1B61764E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(a1);
}

BOOL applesauce::CF::details::has_key<char const(&)[25]>(const __CFDictionary *a1, char *a2)
{
  int v3;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  v3 = CFDictionaryContainsKey(a1, key);
  if (key)
    CFRelease(key);
  return v3 != 0;
}

void sub_1B6176864(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[25]>(const __CFDictionary *a1, char *a2)
{
  const __CFBoolean *v2;
  int v3;

  v2 = (const __CFBoolean *)applesauce::CF::details::at_key<char const(&)[25]>(a1, a2);
  if (v2)
  {
    LOWORD(v2) = applesauce::CF::convert_as<BOOL,0>(v2);
    v3 = BYTE1(v2);
  }
  else
  {
    v3 = 0;
  }
  return v2 | (v3 << 8);
}

BOOL applesauce::CF::details::has_key<char const(&)[12]>(const __CFDictionary *a1, char *a2)
{
  int v3;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  v3 = CFDictionaryContainsKey(a1, key);
  if (key)
    CFRelease(key);
  return v3 != 0;
}

void sub_1B61768FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL applesauce::CF::details::has_key<char const(&)[15]>(const __CFDictionary *a1, char *a2)
{
  int v3;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  v3 = CFDictionaryContainsKey(a1, key);
  if (key)
    CFRelease(key);
  return v3 != 0;
}

void sub_1B6176964(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[15]>(const __CFDictionary *a1, char *a2)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[15]>(a1, a2);
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  return result;
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[11]>(const __CFDictionary *a1)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[11]>(a1, "Constraint");
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  return result;
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>(const __CFDictionary *a1)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[21]>(a1, "PostTimbralFrequency");
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[17]>(_BOOL8 a1, char *a2)
{
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    a1 = CFDictionaryContainsKey((CFDictionaryRef)a1, key) != 0;
  if (key)
    CFRelease(key);
  return a1;
}

void sub_1B6176A40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[17]>(const __CFDictionary *a1, char *a2)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[17]>(a1, a2);
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[9]>(_BOOL8 a1, char *a2)
{
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    a1 = CFDictionaryContainsKey((CFDictionaryRef)a1, key) != 0;
  if (key)
    CFRelease(key);
  return a1;
}

void sub_1B6176ACC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[9]>(const __CFDictionary *a1)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[9]>(a1, "PostGain");
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[10]>(const __CFDictionary *a1, char *a2)
{
  int v3;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  v3 = CFDictionaryContainsKey(a1, key);
  if (key)
    CFRelease(key);
  return v3 != 0;
}

void sub_1B6176B5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[10]>(const __CFDictionary *a1)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[10]>(a1, "Crossover");
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  return result;
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,char const(&)[13]>(const __CFDictionary *a1)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[13]>(a1, "FilterLength");
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<unsigned int,0>(result);
  return result;
}

uint64_t applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[12]>(const __CFDictionary *a1, char *a2)
{
  const __CFBoolean *v2;
  int v3;

  v2 = (const __CFBoolean *)applesauce::CF::details::at_key<char const(&)[12]>(a1, a2);
  if (v2)
  {
    LOWORD(v2) = applesauce::CF::convert_as<BOOL,0>(v2);
    v3 = BYTE1(v2);
  }
  else
  {
    v3 = 0;
  }
  return v2 | (v3 << 8);
}

const void *applesauce::CF::details::at_key<char const(&)[12]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B6176C50(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6176C34);
}

const void *applesauce::CF::details::at_key<char const(&)[10]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B6176CD8(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6176CBCLL);
}

const void *applesauce::CF::details::at_key<char const(&)[9]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B6176D60(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6176D44);
}

const void *applesauce::CF::details::at_key<char const(&)[17]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B6176DE8(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6176DCCLL);
}

const void *applesauce::CF::details::at_key<char const(&)[21]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B6176E70(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6176E54);
}

const void *applesauce::CF::details::at_key<char const(&)[11]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B6176EF8(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6176EDCLL);
}

const void *applesauce::CF::details::at_key<char const(&)[15]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B6176F80(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B6176F64);
}

void lmsfilt_v5::preemphasisFilter(lmsfilt_v5 *this, const float *a2, float *a3, float *a4, float *a5, unsigned __int8 *a6, const BOOL *a7)
{
  uint64_t v12;
  vDSP_Length v13;
  uint64_t v14;
  uint64_t v15;

  if ((int)a5 >= 1)
  {
    v12 = 0;
    v13 = (int)a2;
    v14 = 4 * (int)a2;
    v15 = a5;
    do
    {
      if (*a6++)
      {
        lmsfilt_v3::preemphasisFilter((lmsfilt_v5 *)((char *)this + v12), a2, a3, (float *)((char *)a4 + v12), a5);
      }
      else
      {
        vDSP_vclr((float *)((char *)a4 + v12), 1, v13);
        *a3 = 0.0;
      }
      ++a3;
      v12 += v14;
      --v15;
    }
    while (v15);
  }
}

float lmsfilt_v5::deemphasisFilterDuo(lmsfilt_v5 *this, float *a2, float *a3, float *a4, float *a5, float *a6, float *a7, float *a8)
{
  uint64_t v8;
  float *v9;
  float *v10;
  float *v11;
  float *v12;
  float v13;
  float v14;
  float result;

  *a4 = *a2 + (float)(*a3 * 0.9);
  *a7 = *a5 + (float)(*a6 * 0.9);
  if ((int)this >= 2)
  {
    v8 = this - 1;
    v9 = a2 + 1;
    v10 = a5 + 1;
    v11 = a4 + 1;
    v12 = a7 + 1;
    do
    {
      v13 = *v9++;
      *v11 = v13 + (float)(*(v11 - 1) * 0.9);
      ++v11;
      v14 = *v10++;
      *v12 = v14 + (float)(*(v12 - 1) * 0.9);
      ++v12;
      --v8;
    }
    while (v8);
  }
  *a3 = a4[(int)this - 1];
  result = a7[(int)this - 1];
  *a6 = result;
  return result;
}

void lmsfilt_v5::initLmsFilter(int a1, int a2, int a3, uint64_t a4, float ***a5, int a6)
{
  int v10;
  int v11;
  float **v12;
  int v13;
  int v14;
  int v15;
  int v16;
  float *v17;
  float *v19;
  float *v20;
  float *v22;
  float *v23;
  float *v25;
  float *v26;
  float *v28;
  float *v29;
  float *v31;
  float **v32;
  int v33;
  int v34;
  int v35;
  float *v36;
  float *v37;
  float *v38;
  float *v39;
  float *v40;
  float *v41;
  uint64_t v42;
  float *v43;
  float *v44;
  std::bad_alloc *exception;
  std::bad_alloc *v46;
  float __A;

  v10 = *(_DWORD *)(a4 + 16);
  __A = 0.0;
  v11 = *(_DWORD *)(a4 + 44);
  v12 = (float **)malloc_type_malloc(0x80uLL, 0x2C8E6D5CuLL);
  if (!v12)
    goto LABEL_42;
  *((_OWORD *)v12 + 6) = 0u;
  *((_OWORD *)v12 + 7) = 0u;
  *((_OWORD *)v12 + 4) = 0u;
  *((_OWORD *)v12 + 5) = 0u;
  *((_OWORD *)v12 + 2) = 0u;
  *((_OWORD *)v12 + 3) = 0u;
  *(_OWORD *)v12 = 0u;
  *((_OWORD *)v12 + 1) = 0u;
  *a5 = v12;
  v13 = v11 * v10;
  *((_DWORD *)v12 + 8) = v11;
  *((_DWORD *)v12 + 9) = v11 * v10;
  v14 = v11 * v10 * a6;
  *((_DWORD *)v12 + 22) = v14;
  *((_DWORD *)v12 + 23) = a6;
  v15 = 4 * v14;
  v16 = 4 * v14;
  v17 = (float *)malloc_type_malloc(4 * v14, 0x2C8E6D5CuLL);
  if (4 * v14 && v17 == 0)
    goto LABEL_42;
  v19 = v17;
  bzero(v17, v15);
  **a5 = v19;
  v20 = (float *)malloc_type_malloc(v15, 0x2C8E6D5CuLL);
  if (v16 && v20 == 0)
    goto LABEL_42;
  v22 = v20;
  bzero(v20, v15);
  (*a5)[1] = v22;
  v23 = (float *)malloc_type_malloc(v15, 0x2C8E6D5CuLL);
  if (v16 && v23 == 0)
    goto LABEL_42;
  v25 = v23;
  bzero(v23, v15);
  (*a5)[2] = v25;
  v26 = (float *)malloc_type_malloc(v15, 0x2C8E6D5CuLL);
  if (v16 && v26 == 0)
    goto LABEL_42;
  v28 = v26;
  bzero(v26, v15);
  (*a5)[3] = v28;
  v29 = (float *)malloc_type_malloc(v15, 0x2C8E6D5CuLL);
  if (v16 && v29 == 0)
    goto LABEL_42;
  v31 = v29;
  bzero(v29, v15);
  (*a5)[6] = v31;
  vDSP_vfill(&__A, **a5, 1, v14);
  vDSP_vfill(&__A, (*a5)[1], 1, v14);
  vDSP_vfill(&__A, (*a5)[2], 1, v14);
  vDSP_vfill(&__A, (*a5)[3], 1, v14);
  vDSP_vfill(&__A, (*a5)[6], 1, v14);
  v32 = *a5;
  *((float *)v32 + 10) = (float)(1.0 - *(float *)(a4 + 92)) + (float)(1.0 - *(float *)(a4 + 92));
  *((_DWORD *)v32 + 11) = 1;
  v32[7] = 0;
  *((_DWORD *)v32 + 16) = 0;
  *((_DWORD *)v32 + 17) = a1;
  *((_DWORD *)v32 + 18) = 0;
  *((_DWORD *)v32 + 19) = v11 - 1;
  v33 = a3 / v10;
  if (a3 / v10 >= v11)
    v33 = v11;
  v34 = (a3 - a2) / v10;
  *((_DWORD *)v32 + 20) = v34;
  *((_DWORD *)v32 + 21) = v33;
  if (v33 - v34 <= 1)
  {
    if (v11 == 4)
      v35 = -1;
    else
      v35 = 0;
    if (v11 > 4)
      v35 = -2;
    *((_DWORD *)v32 + 20) = v33 + v35;
  }
  if (*(_BYTE *)(a4 + 178))
  {
    v36 = (float *)malloc_type_malloc(4 * v13, 0x2C8E6D5CuLL);
    v37 = v36;
    if (!v13 || v36)
    {
      bzero(v36, 4 * v13);
      (*a5)[12] = v37;
      v38 = (float *)malloc_type_malloc(4 * v13, 0x2C8E6D5CuLL);
      v39 = v38;
      if (!v13 || v38)
      {
        bzero(v38, 4 * v13);
        (*a5)[13] = v39;
        v40 = (float *)malloc_type_malloc(4 * v13, 0x2C8E6D5CuLL);
        v41 = v40;
        if (!v13 || v40)
        {
          bzero(v40, 4 * v13);
          (*a5)[14] = v41;
          v42 = *(int *)(a4 + 128);
          v43 = (float *)malloc_type_malloc(4 * v42, 0x2C8E6D5CuLL);
          v44 = v43;
          if (!(_DWORD)v42 || v43)
          {
            bzero(v43, 4 * v42);
            (*a5)[15] = v44;
            return;
          }
        }
      }
    }
LABEL_42:
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v46 = std::bad_alloc::bad_alloc(exception);
  }
}

void lmsfilt_v5::removeLmsFilter(uint64_t *a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      if (*(_QWORD *)v2)
      {
        free(*(void **)v2);
        *(_QWORD *)v2 = 0;
        v2 = *a1;
      }
      v3 = *(void **)(v2 + 8);
      if (v3)
      {
        free(v3);
        *(_QWORD *)(v2 + 8) = 0;
        v2 = *a1;
      }
      v4 = *(void **)(v2 + 16);
      if (v4)
      {
        free(v4);
        *(_QWORD *)(v2 + 16) = 0;
        v2 = *a1;
      }
      v5 = *(void **)(v2 + 24);
      if (v5)
      {
        free(v5);
        *(_QWORD *)(v2 + 24) = 0;
        v2 = *a1;
      }
      v6 = *(void **)(v2 + 48);
      if (v6)
      {
        free(v6);
        *(_QWORD *)(v2 + 48) = 0;
        v2 = *a1;
      }
      v7 = *(void **)(v2 + 96);
      if (v7)
      {
        free(v7);
        *(_QWORD *)(v2 + 96) = 0;
        v2 = *a1;
      }
      v8 = *(void **)(v2 + 104);
      if (v8)
      {
        free(v8);
        *(_QWORD *)(v2 + 104) = 0;
        v2 = *a1;
      }
      v9 = *(void **)(v2 + 112);
      if (v9)
      {
        free(v9);
        *(_QWORD *)(v2 + 112) = 0;
        v2 = *a1;
      }
      v10 = *(void **)(v2 + 120);
      if (!v10 || (free(v10), *(_QWORD *)(v2 + 120) = 0, (v2 = *a1) != 0))
      {
        free((void *)v2);
        *a1 = 0;
      }
    }
  }
}

void lmsfilt_v5::runLmsFilter_v5(DSPSplitComplex *this, DSPSplitComplex *a2, DSPSplitComplex *a3, uint64_t a4, uint64_t a5, uint64_t a6, float *a7, float *a8, float *a9, float *a10, int *a11, unsigned __int8 *a12, float **a13, _DWORD *a14, char a15, uint64_t a16, const BOOL *a17, DSPSplitComplex *a18, const unsigned int *a19, BOOL a20)
{
  int v25;
  vDSP_Length v26;
  float *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  float *imagp;
  float *v34;
  float *v35;
  _DWORD *v36;
  float *v37;
  int *v38;
  int v39[2];
  int v40[2];
  uint64_t v41;
  DSPSplitComplex *v42;
  float *v47;
  DSPSplitComplex v49;

  v25 = HIDWORD(a9);
  v26 = (int)a3;
  vDSP_vclr(a2->realp, 1, (int)a3);
  vDSP_vclr(a2->imagp, 1, v26);
  vDSP_vclr(*a13, 1, v26);
  v38 = (int *)a13;
  vDSP_vclr(a13[1], 1, v26);
  v27 = (float *)a10;
  if ((int)a10 >= 2)
  {
    *(_QWORD *)v40 = a5;
    v41 = a6;
    v42 = a2;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = a4;
    while (1)
    {
      v32 = *a12++;
      imagp = this->imagp;
      v34 = &this->realp[v28];
      v35 = &imagp[v28];
      v47 = v27;
      if (v32)
      {
        v49.realp = &this->realp[v28];
        v49.imagp = &imagp[v28];
        LODWORD(v37) = v25;
        lmsfilt_v3::runLmsFilter_v3(&v49, a3, v31 + v29, *(_QWORD *)v40 + v29, v41 + v30 * 4, &a7[v30], a8, (float *)a9, v37, v38, v40[0], v40[1]);
        vDSP_vadd(v34, 1, v42->realp, 1, v42->realp, 1, v26);
        vDSP_vadd(v35, 1, v42->imagp, 1, v42->imagp, 1, v26);
        v36 = a14;
        if (!a15 || *a14)
          goto LABEL_9;
        vDSP_vadd(v34, 1, *(const float **)v38, 1, *(float **)v38, 1, v26);
        vDSP_vadd(v35, 1, *((const float **)v38 + 1), 1, *((float **)v38 + 1), 1, v26);
      }
      else
      {
        vDSP_vclr(v34, 1, v26);
        vDSP_vclr(v35, 1, v26);
      }
      v36 = a14;
LABEL_9:
      a14 = v36 + 1;
      v30 += SHIDWORD(a10);
      v29 += 4 * (int)a11;
      v28 += v26;
      v27 = (float *)((char *)v47 - 1);
      v25 = HIDWORD(a9);
      if (v47 == (float *)1)
        return;
    }
  }
  LODWORD(v37) = HIDWORD(a9);
  lmsfilt_v3::runLmsFilter_v3(this, a3, a4, a5, a6, a7, a8, (float *)a9, v37, (int *)a13, v39[0], v39[1]);
  memcpy(a2->realp, this->realp, 4 * v26);
  memcpy(a2->imagp, this->imagp, 4 * v26);
}

void lmsfilt_v5::resetLmsFilter(uint64_t *a1, uint64_t a2)
{
  vDSP_Length v3;
  vDSP_Length v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  float __A;

  if (a2)
  {
    v3 = *(unsigned int *)(a2 + 36);
    if ((int)v3 >= 1)
    {
      v5 = *(int *)(a2 + 92);
      v6 = *(_DWORD *)(a2 + 32);
      __A = 0.0;
      vDSP_vfill(&__A, *(float **)a2, 1, (int)v5 * (uint64_t)(int)v3);
      vDSP_vfill(&__A, *(float **)(a2 + 8), 1, (int)v5 * (uint64_t)(int)v3);
      vDSP_vfill(&__A, *(float **)(a2 + 16), 1, (int)v5 * (uint64_t)(int)v3);
      vDSP_vfill(&__A, *(float **)(a2 + 24), 1, (int)v5 * (uint64_t)(int)v3);
      vDSP_vfill(&__A, *(float **)(a2 + 48), 1, (int)v5 * (uint64_t)(int)v3);
      v7 = *a1;
      *(float *)(a2 + 40) = (float)(1.0 - *(float *)(*a1 + 92)) + (float)(1.0 - *(float *)(*a1 + 92));
      *(_DWORD *)(a2 + 44) = 1;
      *(_QWORD *)(a2 + 56) = 0;
      *(_DWORD *)(a2 + 64) = 0;
      *(_DWORD *)(a2 + 72) = 0;
      *(_DWORD *)(a2 + 76) = v6 - 1;
      v8 = *(_DWORD *)(a2 + 84);
      if (v8 > v6)
      {
        *(_DWORD *)(a2 + 84) = v6;
        v8 = v6;
      }
      if (v8 - *(_DWORD *)(a2 + 80) <= 1)
      {
        if (v6 == 4)
          v9 = -1;
        else
          v9 = 0;
        if (v6 > 4)
          v9 = -2;
        *(_DWORD *)(a2 + 80) = v8 + v9;
      }
      if (*(_BYTE *)(v7 + 178))
      {
        vDSP_vfill(&__A, *(float **)(a2 + 96), 1, v3);
        vDSP_vfill(&__A, *(float **)(a2 + 104), 1, v3);
        vDSP_vfill(&__A, *(float **)(a2 + 112), 1, v3);
        vDSP_vfill(&__A, *(float **)(a2 + 120), 1, v5);
      }
    }
  }
}

__CFString *AUToneMeisterParameterImporter::importParameters(DspLib::ToneMeister::Algorithm **this, NSDictionary *a2, _BYTE *a3, BOOL *a4)
{
  NSDictionary *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  __CFString *v13;
  uint64_t i;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  AUToneMeisterParameterImporter *v21;
  void *v22;
  char v23;
  __CFString *v24;
  AUToneMeisterParameterImporter *v25;
  void *v26;
  void *v27;
  DspLib::ToneMeister::Parameters *v28;
  void *v29;
  void *v30;
  float v31;
  float v32;
  void *v33;
  float v34;
  float v35;
  void *v36;
  float v37;
  float v38;
  void *v39;
  float v40;
  float v41;
  double v42;
  const __CFString *v43;
  void *v44;
  float v45;
  float v46;
  void *v47;
  float v48;
  float v49;
  double v50;
  const __CFString *v51;
  void *v52;
  float v53;
  void *v54;
  float v55;
  double v56;
  const __CFString *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  float v61;
  AUToneMeisterParameterImporter *v62;
  void *v63;
  void *v64;
  DspLib::ToneMeister::Parameters *v65;
  int v66;
  __CFString *v67;
  void *v68;
  const __CFString *v69;
  float v70;
  void *v71;
  float v72;
  double v73;
  const __CFString *v74;
  float v75;
  AUToneMeisterParameterImporter *v76;
  void *v77;
  void *v78;
  DspLib::ToneMeister::Parameters *v79;
  __CFString *v80;
  void *v81;
  void *v82;
  float v83;
  void *v84;
  float v85;
  double v86;
  const __CFString *v87;
  uint64_t v88;
  float v89;
  AUToneMeisterParameterImporter *v90;
  void *v91;
  void *v92;
  DspLib::ToneMeister::Parameters *v93;
  void *v94;
  void *v95;
  float v96;
  DspLib *v97;
  float v98;
  float v99;
  DspLib *v100;
  float v101;
  void *v102;
  float v103;
  double v104;
  uint64_t v105;
  void *v106;
  void *v107;
  id v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t j;
  void *v112;
  uint64_t v113;
  uint64_t v114;
  AUToneMeisterParameterImporter *v115;
  void *v116;
  void *v117;
  DspLib::ToneMeister::Parameters *v118;
  int v119;
  void *v120;
  id v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t k;
  uint64_t v125;
  void *v126;
  _BOOL4 v127;
  uint64_t v128;
  const __CFString *v129;
  DspLib::ToneMeister::Parameters *v130;
  unsigned int v131;
  int v132;
  __CFString *v133;
  __CFString *v134;
  DspLib::ToneMeister::Parameters *v135;
  void *v136;
  void *v137;
  void *v138;
  float v139;
  void *v140;
  id v141;
  unsigned int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t m;
  void *v146;
  void *v147;
  void *v148;
  char v149;
  void *v150;
  int v151;
  int v152;
  void *v153;
  void *v154;
  id v155;
  unsigned int v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t n;
  void *v160;
  void *v161;
  void *v162;
  char v163;
  void *v164;
  int v165;
  int v166;
  uint64_t v167;
  void *v168;
  void *v169;
  int v170;
  void *v171;
  void *v172;
  int v173;
  AUToneMeisterParameterImporter *v174;
  void *v175;
  void *v176;
  unsigned int v177;
  unsigned int v178;
  __n128 v179;
  unsigned int v180;
  void *v181;
  void *v182;
  void *v183;
  uint64_t v184;
  unsigned int v185;
  unsigned int v186;
  uint64_t ii;
  void *v188;
  void *v189;
  char v190;
  id *v191;
  id *v192;
  id *v193;
  id v194;
  id v195;
  void *v196;
  int v197;
  int v198;
  int v199;
  void *v200;
  int v201;
  int v202;
  float v203;
  float v204;
  unsigned int v205;
  unsigned int v206;
  void *v207;
  float v208;
  float v209;
  unsigned int v210;
  int HasGain;
  int v212;
  void *v213;
  float v214;
  float v215;
  unsigned int v216;
  void *v217;
  float v218;
  float v219;
  unsigned int v220;
  AUToneMeisterParameterImporter *v221;
  void *v222;
  void *v223;
  uint64_t v224;
  void *v225;
  void *v226;
  float v227;
  float v228;
  unsigned int v229;
  void *v230;
  float v231;
  float v232;
  unsigned int v233;
  void *v234;
  float v235;
  float v236;
  unsigned int v237;
  void *v238;
  float v239;
  float v240;
  unsigned int v241;
  void *v242;
  float v243;
  float v244;
  unsigned int v245;
  float v246;
  float v247;
  unsigned int v248;
  float v249;
  float v250;
  unsigned int v251;
  void *v252;
  float v253;
  float v254;
  unsigned int v255;
  id v256;
  void *v257;
  uint64_t v258;
  void *v259;
  char v260;
  void *v261;
  float v262;
  void *v263;
  float v264;
  void *v265;
  float v266;
  void *v267;
  float v268;
  void *v269;
  float v270;
  void *v271;
  float v272;
  void *v273;
  float v274;
  void *v275;
  float v276;
  AUToneMeisterParameterImporter *v277;
  void *v278;
  void *v279;
  void *v280;
  void *v281;
  void *v282;
  void *v283;
  unsigned int v284;
  float v285;
  float v286;
  unsigned int v287;
  float v288;
  float v289;
  unsigned int v290;
  float v291;
  float v292;
  unsigned int v293;
  float v294;
  float v295;
  unsigned int v296;
  float v297;
  float v298;
  unsigned int v299;
  float v300;
  float v301;
  unsigned int v302;
  void *v303;
  void *v304;
  uint64_t v305;
  void *v307;
  __CFString *v308;
  NSDictionary *v309;
  void *v310;
  id v311;
  void *v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  int v316;
  unsigned int v317;
  void *v318;
  unsigned int v319;
  unsigned int v320;
  AUToneMeisterParameterImporter *v321;
  uint64_t v322;
  uint64_t v323;
  DspLib::ToneMeister::Parameters *v324;
  DspLib::ToneMeister::Parameters *obj;
  id obja;
  uint64_t v328;
  int v329;
  DspLib::ToneMeister::Parameters *v330;
  DspLib::ToneMeister::Parameters *v331;
  unsigned int v332;
  id v333;
  DspLib::ToneMeister::Parameters *v334;
  void *v335;
  void *v336;
  void *v337;
  __int128 v338;
  __int128 v339;
  __int128 v340;
  __int128 v341;
  __int128 v342;
  __int128 v343;
  __int128 v344;
  __int128 v345;
  __int128 v346;
  __int128 v347;
  __int128 v348;
  __int128 v349;
  _BYTE v350[128];
  __int128 v351;
  __int128 v352;
  __int128 v353;
  __int128 v354;
  _QWORD v355[5];
  _BYTE v356[128];
  uint64_t v357;

  v357 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  *a3 = 1;
  v309 = v5;
  -[NSDictionary objectForKeyedSubscript:](v309, "objectForKeyedSubscript:", CFSTR("Filters"));
  v6 = objc_claimAutoreleasedReturnValue();
  *a3 = 1;
  v330 = (DspLib::ToneMeister::Parameters *)v6;
  if (v6)
  {
    -[NSDictionary objectForKeyedSubscript:](v309, "objectForKeyedSubscript:", CFSTR("Global"));
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = v7;
    *a3 = 1;
    if (v7)
    {
      objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("Channels"));
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      if (v9)
      {
        v353 = 0u;
        v354 = 0u;
        v351 = 0u;
        v352 = 0u;
        v10 = v9;
        v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v351, v356, 16);
        if (v11)
        {
          v12 = *(_QWORD *)v352;
          v13 = &stru_1E69EEE40;
          while (2)
          {
            for (i = 0; i != v11; ++i)
            {
              if (*(_QWORD *)v352 != v12)
                objc_enumerationMutation(v10);
              objc_msgSend(*(id *)(*((_QWORD *)&v351 + 1) + 8 * i), "substringFromIndex:", 2);
              v15 = (void *)objc_claimAutoreleasedReturnValue();
              v16 = objc_msgSend(v15, "integerValue");

              v17 = *((unsigned int *)this + 2);
              if (v16 > v17)
              {
                *a3 = 0;
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("attempting to assign a global parameter to channel %ld but AU was created with only %u channels\n"), v16, v17);
                v13 = (__CFString *)objc_claimAutoreleasedReturnValue();
                goto LABEL_18;
              }
            }
            v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v351, v356, 16);
            if (v11)
              continue;
            break;
          }
        }
        else
        {
          v13 = &stru_1E69EEE40;
        }
LABEL_18:

      }
      else
      {
        *a3 = 0;
        objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("could not find key :%@"), CFSTR("Channels"));
        v13 = (__CFString *)objc_claimAutoreleasedReturnValue();
      }
    }
    else
    {
      v13 = &stru_1E69EEE40;
    }

    if (*a3)
    {
      v344 = 0u;
      v345 = 0u;
      v342 = 0u;
      v343 = 0u;
      obj = v330;
      v18 = -[DspLib::ToneMeister::Parameters countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v342, &v351, 16);
      v19 = 0;
      if (!v18)
        goto LABEL_149;
      v328 = *(_QWORD *)v343;
      while (1)
      {
        v334 = 0;
        v322 = (v19 + v18);
        v324 = (DspLib::ToneMeister::Parameters *)v18;
        do
        {
          v332 = v19;
          if (*(_QWORD *)v343 != v328)
            objc_enumerationMutation(obj);
          v20 = *(void **)(*((_QWORD *)&v342 + 1) + 8 * (_QWORD)v334);
          objc_msgSend(v20, "objectForKeyedSubscript:", CFSTR("Type"));
          v21 = (AUToneMeisterParameterImporter *)objc_claimAutoreleasedReturnValue();
          *a3 = 1;
          AUToneMeisterParameterImporter::filterTypeStrings(v21);
          v22 = (void *)objc_claimAutoreleasedReturnValue();
          v23 = objc_msgSend(v22, "containsObject:", v21);

          v24 = &stru_1E69EEE40;
          if ((v23 & 1) == 0)
          {
            *a3 = 0;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown filter type: %@\n"), v21);
            v24 = (__CFString *)objc_claimAutoreleasedReturnValue();
          }

          if (!*a3)
          {
            v19 = v332;
            v13 = v24;
            goto LABEL_149;
          }
          v25 = v20;
          AUToneMeisterParameterImporter::filterTypeStrings(v25);
          v26 = (void *)objc_claimAutoreleasedReturnValue();
          -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v25, "objectForKeyedSubscript:", CFSTR("Type"));
          v27 = (void *)objc_claimAutoreleasedReturnValue();
          v28 = (DspLib::ToneMeister::Parameters *)objc_msgSend(v26, "indexOfObject:", v27);

          *a3 = 1;
          v13 = &stru_1E69EEE40;
          if (DspLib::ToneMeister::Parameters::filterTypeHasFrequency(v28))
          {
            if (v28 == (DspLib::ToneMeister::Parameters *)2)
            {
              -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v25, "objectForKeyedSubscript:", CFSTR("Frequency"));
              v29 = (void *)objc_claimAutoreleasedReturnValue();
              *a3 = 1;
              if (objc_msgSend(v29, "count") == 2)
              {
                objc_msgSend(v29, "objectAtIndex:", 0);
                v44 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v44, "floatValue");
                v46 = v45;

                objc_msgSend(v29, "objectAtIndex:", 1);
                v47 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v47, "floatValue");
                v49 = v48;

                if (v46 >= 20.0)
                {
                  v51 = CFSTR("Frequency 0 of %f greater than maximum (%f)\n");
                  v50 = 20000.0;
                  if (v46 <= 20000.0)
                  {
                    if (v49 >= -30.0)
                    {
                      v46 = v49;
                      v51 = CFSTR("Frequency 1 of %f greater than maximum (%f)\n");
                      v50 = 20000.0;
                      if (v49 <= 20000.0)
                        goto LABEL_64;
                    }
                    else
                    {
                      v50 = -30.0;
                      v46 = v49;
                      v51 = CFSTR("Frequency 1 of %f less than minimum (%f)\n");
                    }
                  }
                }
                else
                {
                  v50 = 20.0;
                  v51 = CFSTR("Frequency 0 of %f less than minimum (%f)\n");
                }
                *a3 = 0;
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", v51, v46, *(_QWORD *)&v50);
                v59 = objc_claimAutoreleasedReturnValue();
              }
              else
              {
                *a3 = 0;
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Frequency array has %lu elements but should have 2\n"), objc_msgSend(v29, "count"));
                v59 = objc_claimAutoreleasedReturnValue();
              }
              v13 = (__CFString *)v59;
            }
            else if (v28)
            {
              -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v25, "objectForKeyedSubscript:", CFSTR("Frequency"));
              v52 = (void *)objc_claimAutoreleasedReturnValue();
              v29 = v52;
              *a3 = 1;
              if (v52)
              {
                objc_msgSend(v52, "floatValue");
                if (v53 >= 20.0)
                {
                  objc_msgSend(v29, "floatValue");
                  if (v61 <= 20000.0)
                    goto LABEL_64;
                  *a3 = 0;
                  v54 = (void *)MEMORY[0x1E0CB3940];
                  objc_msgSend(v29, "floatValue");
                  v57 = CFSTR("Frequency of %f greater than maximum (%f)\n");
                  v56 = 20000.0;
                }
                else
                {
                  *a3 = 0;
                  v54 = (void *)MEMORY[0x1E0CB3940];
                  objc_msgSend(v29, "floatValue");
                  v56 = 20.0;
                  v57 = CFSTR("Frequency of %f less than minimum (%f)\n");
                }
                objc_msgSend(v54, "stringWithFormat:", v57, v55, *(_QWORD *)&v56);
                v60 = objc_claimAutoreleasedReturnValue();
              }
              else
              {
                *a3 = 0;
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("missing key: %@\n"), CFSTR("Frequency"));
                v60 = objc_claimAutoreleasedReturnValue();
              }
              v13 = (__CFString *)v60;
            }
            else
            {
              -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v25, "objectForKeyedSubscript:", CFSTR("Frequency"));
              v29 = (void *)objc_claimAutoreleasedReturnValue();
              *a3 = 1;
              if (objc_msgSend(v29, "count") != 4)
              {
                *a3 = 0;
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Frequency array has %lu elements, should have 4\n"), objc_msgSend(v29, "count"));
                v58 = objc_claimAutoreleasedReturnValue();
                goto LABEL_63;
              }
              objc_msgSend(v29, "objectAtIndex:", 0);
              v30 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v30, "floatValue");
              v32 = v31;

              objc_msgSend(v29, "objectAtIndex:", 1);
              v33 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v33, "floatValue");
              v35 = v34;

              objc_msgSend(v29, "objectAtIndex:", 2);
              v36 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v36, "floatValue");
              v38 = v37;

              objc_msgSend(v29, "objectAtIndex:", 3);
              v39 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v39, "floatValue");
              v41 = v40;

              if (v32 < 20.0)
              {
                v42 = 20.0;
                v43 = CFSTR("Frequency 0 of %f less than minimum (%f)\n");
                goto LABEL_62;
              }
              v43 = CFSTR("Frequency 0 of %f greater than maximum (%f)\n");
              v42 = 20000.0;
              if (v32 > 20000.0)
                goto LABEL_62;
              if (v35 < -30.0)
              {
                v32 = v35;
                v43 = CFSTR("Frequency 1 of %f less than minimum (%f)\n");
                goto LABEL_61;
              }
              v32 = v35;
              v43 = CFSTR("Frequency 1 of %f greater than maximum (%f)\n");
              v42 = 20000.0;
              if (v35 > 20000.0)
                goto LABEL_62;
              if (v38 < -30.0)
              {
                v32 = v38;
                v43 = CFSTR("Frequency 2 of %f less than minimum (%f)\n");
LABEL_61:
                v42 = -30.0;
                goto LABEL_62;
              }
              v32 = v38;
              v43 = CFSTR("Frequency 2 of %f greater than maximum (%f)\n");
              v42 = 20000.0;
              if (v38 > 20000.0)
                goto LABEL_62;
              if (v41 < -180.0)
              {
                v32 = v41;
                v43 = CFSTR("Frequency 3 of %f less than minimum (%f)\n");
                v42 = -180.0;
                goto LABEL_62;
              }
              v32 = v41;
              v43 = CFSTR("Frequency 3 of %f greater than maximum (%f)\n");
              v42 = 20000.0;
              if (v41 > 20000.0)
              {
LABEL_62:
                *a3 = 0;
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", v43, v32, *(_QWORD *)&v42);
                v58 = objc_claimAutoreleasedReturnValue();
LABEL_63:
                v13 = (__CFString *)v58;
              }
            }
LABEL_64:

            if (*a3)
            {

              v13 = &stru_1E69EEE40;
            }
          }

          if (!*a3)
            goto LABEL_145;
          v62 = v25;
          AUToneMeisterParameterImporter::filterTypeStrings(v62);
          v63 = (void *)objc_claimAutoreleasedReturnValue();
          -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v62, "objectForKeyedSubscript:", CFSTR("Type"));
          v64 = (void *)objc_claimAutoreleasedReturnValue();
          v65 = (DspLib::ToneMeister::Parameters *)objc_msgSend(v63, "indexOfObject:", v64);

          v66 = DspLib::ToneMeister::Parameters::categoryOfFilterType(v65);
          *a3 = 1;
          v67 = &stru_1E69EEE40;
          if (DspLib::ToneMeister::Parameters::filterTypeHasGain(v65))
          {
            if (v66 == 4)
            {
              -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v62, "objectForKeyedSubscript:", CFSTR("GainRange"));
              v68 = (void *)objc_claimAutoreleasedReturnValue();
              if (v68)
                goto LABEL_72;
              v69 = CFSTR("GainRange");
            }
            else
            {
              -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v62, "objectForKeyedSubscript:", CFSTR("Gain"));
              v68 = (void *)objc_claimAutoreleasedReturnValue();
              if (v68)
              {
LABEL_72:
                objc_msgSend(v68, "floatValue");
                if (v70 < -30.0)
                {
                  *a3 = 0;
                  v71 = (void *)MEMORY[0x1E0CB3940];
                  objc_msgSend(v68, "floatValue");
                  v73 = -30.0;
                  v74 = CFSTR("Gain of %f less than minimum (%f)\n");
                  goto LABEL_76;
                }
                objc_msgSend(v68, "floatValue");
                if (v75 > 30.0)
                {
                  *a3 = 0;
                  v71 = (void *)MEMORY[0x1E0CB3940];
                  objc_msgSend(v68, "floatValue");
                  v73 = 30.0;
                  v74 = CFSTR("Gain of %f greater than maximum (%f)\n");
LABEL_76:
                  objc_msgSend(v71, "stringWithFormat:", v74, v72, *(_QWORD *)&v73);
                  v67 = (__CFString *)objc_claimAutoreleasedReturnValue();
                }

                goto LABEL_80;
              }
              v69 = CFSTR("Gain");
            }
            *a3 = 0;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("missing key: %@\n"), v69);
            v67 = (__CFString *)objc_claimAutoreleasedReturnValue();
          }
LABEL_80:

          if (!*a3)
          {
            v19 = v332;
            v13 = v67;
            goto LABEL_149;
          }
          v76 = v62;
          AUToneMeisterParameterImporter::filterTypeStrings(v76);
          v77 = (void *)objc_claimAutoreleasedReturnValue();
          -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v76, "objectForKeyedSubscript:", CFSTR("Type"));
          v78 = (void *)objc_claimAutoreleasedReturnValue();
          v79 = (DspLib::ToneMeister::Parameters *)objc_msgSend(v77, "indexOfObject:", v78);

          *a3 = 1;
          v80 = &stru_1E69EEE40;
          if (DspLib::ToneMeister::Parameters::filterTypeHasOrder(v79))
          {
            -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v76, "objectForKeyedSubscript:", CFSTR("Order"));
            v81 = (void *)objc_claimAutoreleasedReturnValue();
            v82 = v81;
            if (v81)
            {
              objc_msgSend(v81, "floatValue");
              if (v83 < -30.0)
              {
                *a3 = 0;
                v84 = (void *)MEMORY[0x1E0CB3940];
                objc_msgSend(v82, "floatValue");
                v86 = -30.0;
                v87 = CFSTR("Order of %f less than minimum (%f)\n");
                goto LABEL_88;
              }
              objc_msgSend(v82, "floatValue");
              if (v89 > 20000.0)
              {
                *a3 = 0;
                v84 = (void *)MEMORY[0x1E0CB3940];
                objc_msgSend(v82, "floatValue");
                v87 = CFSTR("Order of %f greater than maximum (%f)\n");
                v86 = 20000.0;
LABEL_88:
                objc_msgSend(v84, "stringWithFormat:", v87, v85, *(_QWORD *)&v86);
                v88 = objc_claimAutoreleasedReturnValue();
LABEL_89:
                v80 = (__CFString *)v88;
              }

              goto LABEL_91;
            }
            *a3 = 0;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("missing key: %@\n"), CFSTR("Order"));
            v88 = objc_claimAutoreleasedReturnValue();
            goto LABEL_89;
          }
LABEL_91:

          if (!*a3)
            goto LABEL_146;
          v90 = v76;
          AUToneMeisterParameterImporter::filterTypeStrings(v90);
          v91 = (void *)objc_claimAutoreleasedReturnValue();
          -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v90, "objectForKeyedSubscript:", CFSTR("Type"));
          v92 = (void *)objc_claimAutoreleasedReturnValue();
          v93 = (DspLib::ToneMeister::Parameters *)objc_msgSend(v91, "indexOfObject:", v92);

          *a3 = 1;
          v13 = &stru_1E69EEE40;
          if (DspLib::ToneMeister::Parameters::filterTypeHasQuality(v93))
          {
            -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v90, "objectForKeyedSubscript:", CFSTR("Quality"));
            v94 = (void *)objc_claimAutoreleasedReturnValue();
            v95 = v94;
            if (v94)
            {
              objc_msgSend(v94, "floatValue");
              if (v96 >= -30.0
                || (v97 = (DspLib *)objc_msgSend(v95, "floatValue"), DspLib::isEqual(v97, v98, -30.0, 1.0e-20)))
              {
                objc_msgSend(v95, "floatValue");
                if (v99 > 20000.0)
                {
                  v100 = (DspLib *)objc_msgSend(v95, "floatValue");
                  if (!DspLib::isEqual(v100, v101, 20000.0, 1.0e-20))
                  {
                    v102 = (void *)MEMORY[0x1E0CB3940];
                    objc_msgSend(v95, "floatValue");
                    v104 = 20000.0;
                    goto LABEL_101;
                  }
                }
LABEL_103:

                goto LABEL_104;
              }
              v102 = (void *)MEMORY[0x1E0CB3940];
              objc_msgSend(v95, "floatValue");
              v104 = -30.0;
LABEL_101:
              objc_msgSend(v102, "stringWithFormat:", CFSTR("Quality of %f clamped to %f."), v103, *(_QWORD *)&v104);
              v105 = objc_claimAutoreleasedReturnValue();
            }
            else
            {
              *a3 = 0;
              objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("missing key: %@\n"), CFSTR("Quality"));
              v105 = objc_claimAutoreleasedReturnValue();
            }
            v13 = (__CFString *)v105;
            goto LABEL_103;
          }
LABEL_104:

          if (!*a3)
            goto LABEL_145;
          -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v90, "objectForKeyedSubscript:", CFSTR("Channels"));
          v106 = (void *)objc_claimAutoreleasedReturnValue();
          v107 = v106;
          *a3 = 1;
          if (v106)
          {
            v348 = 0u;
            v349 = 0u;
            v346 = 0u;
            v347 = 0u;
            v108 = v106;
            v109 = objc_msgSend(v108, "countByEnumeratingWithState:objects:count:", &v346, v356, 16);
            if (v109)
            {
              v110 = *(_QWORD *)v347;
              while (2)
              {
                for (j = 0; j != v109; ++j)
                {
                  if (*(_QWORD *)v347 != v110)
                    objc_enumerationMutation(v108);
                  objc_msgSend(*(id *)(*((_QWORD *)&v346 + 1) + 8 * j), "substringFromIndex:", 2);
                  v112 = (void *)objc_claimAutoreleasedReturnValue();
                  v113 = objc_msgSend(v112, "integerValue");

                  if (!v113)
                  {
                    *a3 = 0;
                    v80 = CFSTR("channel number = 0, but channel enumeration starts with channel 1");
                    goto LABEL_120;
                  }
                  v114 = *((unsigned int *)this + 2);
                  if (v113 > v114)
                  {
                    *a3 = 0;
                    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("attempting to assing a filter to channel: %ld, but only %d channels are available"), v113, v114);
                    v80 = (__CFString *)objc_claimAutoreleasedReturnValue();
                    goto LABEL_120;
                  }
                }
                v109 = objc_msgSend(v108, "countByEnumeratingWithState:objects:count:", &v346, v356, 16);
                v80 = &stru_1E69EEE40;
                if (v109)
                  continue;
                break;
              }
            }
            else
            {
              v80 = &stru_1E69EEE40;
            }
LABEL_120:

          }
          else
          {
            *a3 = 0;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("missing key %@"), CFSTR("Channels"));
            v80 = (__CFString *)objc_claimAutoreleasedReturnValue();
          }

          if (!*a3)
          {
LABEL_146:
            v19 = v332;
            v13 = v80;
            goto LABEL_149;
          }
          v115 = v90;
          AUToneMeisterParameterImporter::filterTypeStrings(v115);
          v116 = (void *)objc_claimAutoreleasedReturnValue();
          -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v115, "objectForKeyedSubscript:", CFSTR("Type"));
          v117 = (void *)objc_claimAutoreleasedReturnValue();
          v118 = (DspLib::ToneMeister::Parameters *)objc_msgSend(v116, "indexOfObject:", v117);

          v119 = DspLib::ToneMeister::Parameters::categoryOfFilterType(v118);
          *a3 = 1;
          v13 = &stru_1E69EEE40;
          if (v119 == 4)
          {
            v355[0] = CFSTR("attackTime");
            v355[1] = CFSTR("releaseTime");
            v355[2] = CFSTR("enableAttackRelease");
            v355[3] = CFSTR("Threshold");
            v355[4] = CFSTR("Ratio");
            objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v355, 5);
            v120 = (void *)objc_claimAutoreleasedReturnValue();
            v348 = 0u;
            v349 = 0u;
            v346 = 0u;
            v347 = 0u;
            v121 = v120;
            v122 = objc_msgSend(v121, "countByEnumeratingWithState:objects:count:", &v346, v356, 16);
            if (v122)
            {
              v123 = *(_QWORD *)v347;
              while (2)
              {
                for (k = 0; k != v122; ++k)
                {
                  if (*(_QWORD *)v347 != v123)
                    objc_enumerationMutation(v121);
                  v125 = *(_QWORD *)(*((_QWORD *)&v346 + 1) + 8 * k);
                  -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v115, "objectForKeyedSubscript:", v125);
                  v126 = (void *)objc_claimAutoreleasedReturnValue();
                  v127 = v126 == 0;

                  if (v127)
                  {
                    *a3 = 0;
                    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Error dynamic EQ: missing key '%@' "), v125);
                    v13 = (__CFString *)objc_claimAutoreleasedReturnValue();
                    goto LABEL_133;
                  }
                }
                v122 = objc_msgSend(v121, "countByEnumeratingWithState:objects:count:", &v346, v356, 16);
                if (v122)
                  continue;
                break;
              }
              v13 = &stru_1E69EEE40;
            }
LABEL_133:

          }
          if (!*a3)
          {
LABEL_145:
            v19 = v332;
            goto LABEL_149;
          }
          LODWORD(v19) = v332 + 1;
          v334 = (DspLib::ToneMeister::Parameters *)((char *)v334 + 1);
        }
        while (v334 != v324);
        v18 = -[DspLib::ToneMeister::Parameters countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v342, &v351, 16);
        v19 = v322;
        if (!v18)
        {
LABEL_149:
          v128 = v19;

          if (*a3)
          {
            v308 = &stru_1E69EEE40;
          }
          else
          {
            v129 = CFSTR("nil message");
            if (v13)
              v129 = v13;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Error for filter %d: %@"), v128, v129);
            v308 = (__CFString *)objc_claimAutoreleasedReturnValue();
          }

          goto LABEL_155;
        }
      }
    }
    v308 = v13;
  }
  else
  {
    *a3 = 0;
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Missing key: %@\n"), CFSTR("Filters"));
    v308 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
LABEL_155:

  if (!*a3)
  {
    v133 = v308;
    v134 = v133;
    goto LABEL_274;
  }
  v130 = 0;
  v131 = 1023;
  do
  {
    if (DspLib::ToneMeister::Algorithm::filterIsEnabled(*this, v130))
      v131 &= ~(1 << DspLib::ToneMeister::Algorithm::filterGroup(*this, v130));
    v130 = (DspLib::ToneMeister::Parameters *)((char *)v130 + 1);
  }
  while (v130 != (DspLib::ToneMeister::Parameters *)50);
  v132 = 0;
  while (((v131 >> v132) & 1) == 0)
  {
    if (++v132 == 10)
      goto LABEL_186;
  }
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:");
  v310 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v310)
  {
LABEL_186:
    v153 = 0;
    *a3 = 0;
    v134 = CFSTR("Error: No group available for filter import. Please free up one group.");
    goto LABEL_273;
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v312 = (void *)objc_claimAutoreleasedReturnValue();
  v135 = 0;
  do
  {
    if (!DspLib::ToneMeister::Algorithm::filterIsEnabled(*this, v135))
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", v135);
      v136 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v312, "addObject:", v136);

    }
    v135 = (DspLib::ToneMeister::Parameters *)((char *)v135 + 1);
  }
  while (v135 != (DspLib::ToneMeister::Parameters *)50);
  if (!objc_msgSend(v312, "count"))
  {
    *a3 = 0;
    v134 = CFSTR("Error: Not a single filter is available for import. Please free up filters.");
    goto LABEL_272;
  }
  -[NSDictionary objectForKeyedSubscript:](v309, "objectForKeyedSubscript:", CFSTR("Global"));
  v307 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v307, "objectForKeyedSubscript:", CFSTR("InputGain"));
  v137 = (void *)objc_claimAutoreleasedReturnValue();
  v138 = v137;
  if (v137)
  {
    objc_msgSend(v137, "floatValue");
    if (v139 != (*(float (**)(DspLib::ToneMeister::Algorithm *, uint64_t))(*(_QWORD *)*this + 112))(*this, 4))
    {
      objc_msgSend(v138, "floatValue");
      (*(void (**)(DspLib::ToneMeister::Algorithm *, uint64_t))(*(_QWORD *)*this + 128))(*this, 4);
    }
  }

  objc_msgSend(v307, "objectForKeyedSubscript:", CFSTR("Channels"));
  v140 = (void *)objc_claimAutoreleasedReturnValue();
  v335 = v140;
  if (v140)
  {
    v353 = 0u;
    v354 = 0u;
    v351 = 0u;
    v352 = 0u;
    v141 = v140;
    v142 = 0;
    v143 = objc_msgSend(v141, "countByEnumeratingWithState:objects:count:", &v351, v356, 16);
    if (v143)
    {
      v144 = *(_QWORD *)v352;
      do
      {
        for (m = 0; m != v143; ++m)
        {
          if (*(_QWORD *)v352 != v144)
            objc_enumerationMutation(v141);
          v146 = *(void **)(*((_QWORD *)&v351 + 1) + 8 * m);
          objc_msgSend(v141, "objectForKeyedSubscript:", v146);
          v147 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v146, "substringFromIndex:", 2);
          v148 = (void *)objc_claimAutoreleasedReturnValue();
          v149 = objc_msgSend(v148, "integerValue");

          objc_msgSend(v147, "objectForKeyedSubscript:", CFSTR("Mute"));
          v150 = (void *)objc_claimAutoreleasedReturnValue();
          v151 = objc_msgSend(v150, "BOOLValue");

          if (v151)
            v152 = 1 << (v149 - 1);
          else
            v152 = 0;

          v142 |= v152;
        }
        v143 = objc_msgSend(v141, "countByEnumeratingWithState:objects:count:", &v351, v356, 16);
      }
      while (v143);
    }

  }
  else
  {
    v142 = 0;
  }
  (*(void (**)(DspLib::ToneMeister::Algorithm *, uint64_t, float))(*(_QWORD *)*this + 128))(*this, 12, (float)v142);

  objc_msgSend(v307, "objectForKeyedSubscript:", CFSTR("Channels"));
  v154 = (void *)objc_claimAutoreleasedReturnValue();
  v336 = v154;
  if (v154)
  {
    v353 = 0u;
    v354 = 0u;
    v351 = 0u;
    v352 = 0u;
    v155 = v154;
    v156 = 0;
    v157 = objc_msgSend(v155, "countByEnumeratingWithState:objects:count:", &v351, v356, 16);
    if (v157)
    {
      v158 = *(_QWORD *)v352;
      do
      {
        for (n = 0; n != v157; ++n)
        {
          if (*(_QWORD *)v352 != v158)
            objc_enumerationMutation(v155);
          v160 = *(void **)(*((_QWORD *)&v351 + 1) + 8 * n);
          objc_msgSend(v155, "objectForKeyedSubscript:", v160);
          v161 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v160, "substringFromIndex:", 2);
          v162 = (void *)objc_claimAutoreleasedReturnValue();
          v163 = objc_msgSend(v162, "integerValue");

          objc_msgSend(v161, "objectForKeyedSubscript:", CFSTR("PhaseFlip"));
          v164 = (void *)objc_claimAutoreleasedReturnValue();
          v165 = objc_msgSend(v164, "BOOLValue");

          if (v165)
            v166 = 1 << (v163 - 1);
          else
            v166 = 0;

          v156 |= v166;
        }
        v157 = objc_msgSend(v155, "countByEnumeratingWithState:objects:count:", &v351, v356, 16);
      }
      while (v157);
    }

  }
  else
  {
    v156 = 0;
  }
  (*(void (**)(DspLib::ToneMeister::Algorithm *, uint64_t, float))(*(_QWORD *)*this + 128))(*this, 10, (float)v156);

  -[NSDictionary objectForKeyedSubscript:](v309, "objectForKeyedSubscript:", CFSTR("Filters"));
  v340 = 0u;
  v341 = 0u;
  v338 = 0u;
  v339 = 0u;
  v311 = (id)objc_claimAutoreleasedReturnValue();
  v167 = objc_msgSend(v311, "countByEnumeratingWithState:objects:count:", &v338, v350, 16);
  if (!v167)
  {
    v314 = 0;
    goto LABEL_269;
  }
  v317 = 0;
  v313 = *(_QWORD *)v339;
  v314 = 0;
  do
  {
    v323 = 0;
    v315 = v167;
    do
    {
      if (*(_QWORD *)v339 != v313)
        objc_enumerationMutation(v311);
      v168 = *(void **)(*((_QWORD *)&v338 + 1) + 8 * v323);
      objc_msgSend(v168, "objectForKeyedSubscript:", CFSTR("Active"));
      v169 = (void *)objc_claimAutoreleasedReturnValue();
      v170 = objc_msgSend(v169, "BOOLValue");

      if (!v170)
      {
        v314 = (v314 + 1);
        goto LABEL_265;
      }
      objc_msgSend(v312, "objectAtIndexedSubscript:", v317);
      v171 = (void *)objc_claimAutoreleasedReturnValue();
      v320 = objc_msgSend(v171, "integerValue");

      objc_msgSend(v168, "objectForKeyedSubscript:", CFSTR("Active"));
      v172 = (void *)objc_claimAutoreleasedReturnValue();
      v173 = objc_msgSend(v172, "BOOLValue");

      AUToneMeisterParameterImporter::filterTypeStrings(v174);
      v175 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v168, "objectForKeyedSubscript:", CFSTR("Type"));
      v176 = (void *)objc_claimAutoreleasedReturnValue();
      v319 = objc_msgSend(v175, "indexOfObject:", v176);

      v316 = DspLib::ToneMeister::Parameters::categoryOfFilterType((DspLib::ToneMeister::Parameters *)v319);
      objc_msgSend(v168, "objectForKeyedSubscript:", CFSTR("automation"));
      v318 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(v175) = objc_msgSend(v310, "intValue");
      v177 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 9);
      (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v177, (float)(int)v175);
      v178 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 0);
      if (v173)
        v179.n128_f32[0] = 3.0;
      else
        v179.n128_f32[0] = 1.0;
      (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, __n128))(*(_QWORD *)*this + 128))(*this, v178, v179);
      v180 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 1);
      (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v180, (float)v319);
      v321 = v168;
      AUToneMeisterParameterImporter::filterTypeStrings(v321);
      v181 = (void *)objc_claimAutoreleasedReturnValue();
      -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v321, "objectForKeyedSubscript:", CFSTR("Type"));
      v182 = (void *)objc_claimAutoreleasedReturnValue();
      v331 = (DspLib::ToneMeister::Parameters *)objc_msgSend(v181, "indexOfObject:", v182);

      v329 = DspLib::ToneMeister::Parameters::categoryOfFilterType(v331);
      -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v321, "objectForKeyedSubscript:", CFSTR("Channels"));
      v183 = (void *)objc_claimAutoreleasedReturnValue();
      v353 = 0u;
      v354 = 0u;
      v351 = 0u;
      v352 = 0u;
      v333 = v183;
      v184 = objc_msgSend(v333, "countByEnumeratingWithState:objects:count:", &v351, v356, 16);
      if (v184)
      {
        v185 = 0;
        v186 = 0;
        obja = *(id *)v352;
        do
        {
          for (ii = 0; ii != v184; ++ii)
          {
            if (*(id *)v352 != obja)
              objc_enumerationMutation(v333);
            v188 = *(void **)(*((_QWORD *)&v351 + 1) + 8 * ii);
            objc_msgSend(v333, "objectForKeyedSubscript:", v188);
            v337 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v188, "substringFromIndex:", 2);
            v189 = (void *)objc_claimAutoreleasedReturnValue();
            v190 = objc_msgSend(v189, "integerValue");

            v191 = (id *)&kDspLibToneMeisterPlistKey_LowPass;
            if (v329 != 5)
              v191 = (id *)&kDspLibToneMeisterPlistKey_Filter;
            v192 = (id *)&kDspLibToneMeisterPlistKey_PhaseCompensate;
            if (v329 == 5)
              v192 = (id *)&kDspLibToneMeisterPlistKey_HighPass;
            if (v329 == 4)
            {
              v191 = (id *)&kDspLibToneMeisterPlistKey_Filter;
              v192 = (id *)&kDspLibToneMeisterPlistKey_SideChain;
            }
            if (v331 == (DspLib::ToneMeister::Parameters *)10)
            {
              v191 = (id *)&kDspLibToneMeisterPlistKey_ChannelA;
              v193 = (id *)&kDspLibToneMeisterPlistKey_ChannelB;
            }
            else
            {
              v193 = v192;
            }
            v194 = *v191;
            v195 = *v193;
            objc_msgSend(v337, "objectForKeyedSubscript:", v194);
            v196 = (void *)objc_claimAutoreleasedReturnValue();
            v197 = objc_msgSend(v196, "BOOLValue");

            v198 = 1 << (v190 - 1);
            if (v197)
              v199 = 1 << (v190 - 1);
            else
              v199 = 0;
            objc_msgSend(v337, "objectForKeyedSubscript:", v195);
            v200 = (void *)objc_claimAutoreleasedReturnValue();
            v201 = objc_msgSend(v200, "BOOLValue");

            if (v201)
              v202 = v198;
            else
              v202 = 0;

            v185 |= v199;
            v186 |= v202;
          }
          v184 = objc_msgSend(v333, "countByEnumeratingWithState:objects:count:", &v351, v356, 16);
        }
        while (v184);
        v203 = (float)v185;
        v204 = (float)v186;
      }
      else
      {
        v203 = 0.0;
        v204 = 0.0;
      }

      v205 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 7);
      (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v205, v203);
      v206 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 8);
      (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v206, v204);

      if (DspLib::ToneMeister::Parameters::filterTypeHasQuality((DspLib::ToneMeister::Parameters *)v319))
      {
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v321, "objectForKeyedSubscript:", CFSTR("Quality"));
        v207 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v207, "floatValue");
        v209 = v208;
        v210 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 4);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v210, v209);

      }
      HasGain = DspLib::ToneMeister::Parameters::filterTypeHasGain((DspLib::ToneMeister::Parameters *)v319);
      if (v316 == 4)
        v212 = HasGain;
      else
        v212 = 1;
      if (v212 == 1)
      {
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v321, "objectForKeyedSubscript:", CFSTR("Gain"));
        v213 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v213, "floatValue");
        v215 = v214;
        v216 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 2);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v216, v215);

      }
      if (DspLib::ToneMeister::Parameters::filterTypeHasOrder((DspLib::ToneMeister::Parameters *)v319))
      {
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v321, "objectForKeyedSubscript:", CFSTR("Order"));
        v217 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v217, "floatValue");
        v219 = v218;
        v220 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 5);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v220, v219);

      }
      if (DspLib::ToneMeister::Parameters::filterTypeHasFrequency((DspLib::ToneMeister::Parameters *)v319))
      {
        v221 = v321;
        AUToneMeisterParameterImporter::filterTypeStrings(v221);
        v222 = (void *)objc_claimAutoreleasedReturnValue();
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v221, "objectForKeyedSubscript:", CFSTR("Type"));
        v223 = (void *)objc_claimAutoreleasedReturnValue();
        v224 = objc_msgSend(v222, "indexOfObject:", v223);

        if (v224 == 2)
        {
          -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v221, "objectForKeyedSubscript:", CFSTR("Frequency"));
          v225 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v225, "objectAtIndexedSubscript:", 0);
          v242 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v242, "floatValue");
          v244 = v243;
          v245 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 3);
          (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v245, v244);

          objc_msgSend(v225, "objectAtIndexedSubscript:", 1);
          v238 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v238, "floatValue");
          v247 = v246;
          v248 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 4);
          (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v248, v247);
LABEL_250:

        }
        else
        {
          if (!v224)
          {
            -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v221, "objectForKeyedSubscript:", CFSTR("Frequency"));
            v225 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v225, "objectAtIndexedSubscript:", 0);
            v226 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v226, "floatValue");
            v228 = v227;
            v229 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 3);
            (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v229, v228);

            objc_msgSend(v225, "objectAtIndexedSubscript:", 1);
            v230 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v230, "floatValue");
            v232 = v231;
            v233 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 4);
            (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v233, v232);

            objc_msgSend(v225, "objectAtIndexedSubscript:", 2);
            v234 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v234, "floatValue");
            v236 = v235;
            v237 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 5);
            (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v237, v236);

            objc_msgSend(v225, "objectAtIndexedSubscript:", 3);
            v238 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v238, "floatValue");
            v240 = v239;
            v241 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 6);
            (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v241, v240);
            goto LABEL_250;
          }
          -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v221, "objectForKeyedSubscript:", CFSTR("Frequency"));
          v225 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v225, "floatValue");
          v250 = v249;
          v251 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 3);
          (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v251, v250);
        }

      }
      if (v319 == 10)
      {
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v321, "objectForKeyedSubscript:", CFSTR("Phase"));
        v252 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v252, "floatValue");
        v254 = v253;
        v255 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 6);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v255, v254);

      }
      if (objc_msgSend(v318, "count"))
      {
        v256 = v318;
        objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("state"));
        v257 = (void *)objc_claimAutoreleasedReturnValue();
        v258 = 0;
        while (1)
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", _ZGRN6DspLib11ToneMeister10ParametersL26kAutomatedFilterStateNamesE__2038[v258], 4);
          v259 = (void *)objc_claimAutoreleasedReturnValue();
          v260 = objc_msgSend(v257, "isEqualToString:", v259);

          if ((v260 & 1) != 0)
            break;
          if (++v258 == 3)
            goto LABEL_261;
        }
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, (float)v258, 1u, v320);
        objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("setPointBGain"));
        v261 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v261, "floatValue");
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v262, 4u, v320);

        objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("setPointBFrequency"));
        v263 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v263, "floatValue");
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v264, 5u, v320);

        objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("systemVolumeSetPointA"));
        v265 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v265, "floatValue");
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v266, 2u, v320);

        objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("systemVolumeSetPointB"));
        v267 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v267, "floatValue");
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v268, 3u, v320);

        objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("systemVolumeSetPointM"));
        v269 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v269, "floatValue");
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v270, 7u, v320);

        objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("systemVolumeSetPointM_enable"));
        v271 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v271, "floatValue");
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v272, 6u, v320);

        objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("systemVolumeSetPointM_gain"));
        v273 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v273, "floatValue");
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v274, 8u, v320);

        objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("systemVolumeSetPointM_frequency"));
        v275 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v275, "floatValue");
        AUToneMeisterParameterImporter::setValueForAutomationParameter((AUToneMeisterParameterImporter *)this, v276, 9u, v320);

LABEL_261:
      }
      if (v316 == 4)
      {
        v277 = v321;
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v277, "objectForKeyedSubscript:", CFSTR("attackTime"));
        v278 = (void *)objc_claimAutoreleasedReturnValue();
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v277, "objectForKeyedSubscript:", CFSTR("releaseTime"));
        v279 = (void *)objc_claimAutoreleasedReturnValue();
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v277, "objectForKeyedSubscript:", CFSTR("enableAttackRelease"));
        v280 = (void *)objc_claimAutoreleasedReturnValue();
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v277, "objectForKeyedSubscript:", CFSTR("Threshold"));
        v281 = (void *)objc_claimAutoreleasedReturnValue();
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v277, "objectForKeyedSubscript:", CFSTR("Ratio"));
        v282 = (void *)objc_claimAutoreleasedReturnValue();
        -[AUToneMeisterParameterImporter objectForKeyedSubscript:](v277, "objectForKeyedSubscript:", CFSTR("GainRange"));
        v283 = (void *)objc_claimAutoreleasedReturnValue();
        v284 = DspLib::ToneMeister::Algorithm::dynamicFilterIndex(*this, v320);
        objc_msgSend(v278, "floatValue");
        v286 = v285;
        v287 = DspLib::ToneMeister::Parameters::dynamicFilterParameter((DspLib::ToneMeister::Parameters *)v284, 0);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v287, v286);
        objc_msgSend(v279, "floatValue");
        v289 = v288;
        v290 = DspLib::ToneMeister::Parameters::dynamicFilterParameter((DspLib::ToneMeister::Parameters *)v284, 1);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v290, v289);
        objc_msgSend(v280, "floatValue");
        v292 = v291;
        v293 = DspLib::ToneMeister::Parameters::dynamicFilterParameter((DspLib::ToneMeister::Parameters *)v284, 2);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v293, v292);
        objc_msgSend(v281, "floatValue");
        v295 = v294;
        v296 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 6);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v296, v295);
        objc_msgSend(v282, "floatValue");
        v298 = v297;
        v299 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 5);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v299, v298);
        objc_msgSend(v283, "floatValue");
        v301 = v300;
        v302 = DspLib::ToneMeister::Parameters::toneMeisterParameter((DspLib::ToneMeister::Parameters *)v320, 2);
        (*(void (**)(DspLib::ToneMeister::Algorithm *, _QWORD, float))(*(_QWORD *)*this + 128))(*this, v302, v301);

      }
      ++v317;
LABEL_265:
      ++v323;
    }
    while (v323 != v315);
    v167 = objc_msgSend(v311, "countByEnumeratingWithState:objects:count:", &v338, v350, 16);
  }
  while (v167);
LABEL_269:

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Successfully imported %lu filters and assigned them to group %d. "), objc_msgSend(v311, "count"), objc_msgSend(v310, "intValue"));
  v303 = (void *)objc_claimAutoreleasedReturnValue();

  if ((_DWORD)v314)
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%d filters were not imported.\n"), v314);
    v304 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v303, "stringByAppendingString:", v304);
    v305 = objc_claimAutoreleasedReturnValue();

    v303 = (void *)v305;
  }
  v308 = v303;

  v134 = v308;
LABEL_272:

  v153 = v310;
LABEL_273:

  v133 = v308;
LABEL_274:

  return v134;
}

void sub_1B6179C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,void *a32)
{
  void *v32;

  _Unwind_Resume(a1);
}

id AUToneMeisterParameterImporter::filterTypeStrings(AUToneMeisterParameterImporter *this)
{
  void *v1;
  uint64_t i;
  void *v3;

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  for (i = 0; i != 22; ++i)
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", _ZGRN6DspLib11ToneMeister10ParametersL16kFilterTypeNamesE__2042[i]);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v1, "addObject:", v3);

  }
  return v1;
}

void sub_1B617A32C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t AUToneMeisterParameterImporter::setValueForAutomationParameter(AUToneMeisterParameterImporter *this, float a2, unsigned int a3, unsigned int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  DspLib::ToneMeister::Parameters *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  unsigned int v15;
  unsigned int v16;
  DspLib::ToneMeister::Parameters *v17;

  v17 = 0;
  v8 = a4;
  v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 136))(*(_QWORD *)this);
  if (DspLib::ToneMeister::Parameters::findAutomationForFilter(v8, v9, (unint64_t *)&v17, v10))
  {
    v11 = v17;
  }
  else
  {
    v11 = 0;
    while (1)
    {
      v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 136))(*(_QWORD *)this);
      if (!vcvtas_u32_f32(*(float *)(v12 + 4 * DspLib::ToneMeister::Parameters::automationParameterForSlot(v11, 1))))
        break;
      v11 = (DspLib::ToneMeister::Parameters *)((char *)v11 + 1);
      if (v11 == (DspLib::ToneMeister::Parameters *)10)
      {
        v11 = 0;
        while (1)
        {
          v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 136))(*(_QWORD *)this);
          result = DspLib::ToneMeister::Parameters::automationParameterForSlot(v11, 1);
          if (vcvtas_u32_f32(*(float *)(v13 + 4 * result)) == 1)
            break;
          v11 = (DspLib::ToneMeister::Parameters *)((char *)v11 + 1);
          if (v11 == (DspLib::ToneMeister::Parameters *)10)
            return result;
        }
        break;
      }
    }
    v15 = DspLib::ToneMeister::Parameters::automationParameterForSlot(v11, 0);
    (*(void (**)(_QWORD, _QWORD, float))(**(_QWORD **)this + 128))(*(_QWORD *)this, v15, (float)a4);
  }
  v16 = DspLib::ToneMeister::Parameters::automationParameterForSlot(v11, a3);
  return (*(uint64_t (**)(_QWORD, _QWORD, float))(**(_QWORD **)this + 128))(*(_QWORD *)this, v16, a2);
}

uint64_t VoiceProcessorV2::SaveFilesWriteSignal(uint64_t this, unsigned int a2, uint64_t a3, const AudioBufferList *a4, AudioTimeStamp *a5)
{
  uint64_t v9;
  unint64_t v10;
  double v11;
  UInt32 mNumberBuffers;
  unint64_t v13;
  UInt32 *v14;
  const AudioBufferList **v15;
  UInt32 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int realp;
  int v22;
  unint64_t v23;
  BOOL v24;
  _BOOL4 v25;
  uint64_t v26;
  const char *v27;
  int *v28;
  int v29;
  float v30;
  AudioTimeStamp *v31;
  DSPSplitComplex v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  if (!*(_DWORD *)(this + 12576))
    return this;
  v9 = this;
  v10 = a2;
  this = VoiceProcessorV2::QuerySaveFileAtIndexthroughFileSavingKey((VoiceProcessorV2 *)this, a2);
  if (!(_DWORD)this)
    return this;
  this = VoiceProcessorV2::SignalIsInFrequencyDomain((VoiceProcessorV2 *)v9, v10);
  if ((_DWORD)this)
  {
    v35 = 0;
    v33 = 0u;
    v34 = 0u;
    this = VoiceProcessorV2::GetSignalSaveFileFormatForIndex((uint64_t)&v33, (VoiceProcessorV2 *)v9, v10, 0.0, v11);
    mNumberBuffers = HIDWORD(v34);
    if (HIDWORD(v34) != (uint64_t)(*(_QWORD *)(*(_QWORD *)(v9 + 13952) + 24 * v10 + 8)
                                 - *(_QWORD *)(*(_QWORD *)(v9 + 13952) + 24 * v10)) >> 3)
      return this;
    v13 = v9 + 8 * v10;
    v14 = *(UInt32 **)(v13 + 13976);
    if (!v14 || *(_DWORD *)(v9 + 508) < a3)
      return this;
    v31 = a5;
    v15 = (const AudioBufferList **)(v13 + 13976);
    v16 = *v14;
    if (a4->mNumberBuffers < HIDWORD(v34))
      mNumberBuffers = a4->mNumberBuffers;
    if (v16 < mNumberBuffers)
      mNumberBuffers = v16;
    if (mNumberBuffers)
    {
      v17 = 0;
      v18 = 8 * mNumberBuffers;
      v19 = 16;
      do
      {
        v32.realp = *(float **)((char *)&a4->mNumberBuffers + v19);
        v32.imagp = &v32.realp[a3];
        this = VPTimeFreqConverter::Synthesize(*(VPTimeFreqConverter **)(*(_QWORD *)(*(_QWORD *)(v9 + 13952) + 24 * v10) + v17), &v32, *(float **)((char *)&(*v15)->mNumberBuffers + v19));
        v17 += 8;
        v19 += 16;
      }
      while (v18 != v17);
    }
    v20 = v9 + 8 * v10;
    if (!*(_QWORD *)(v20 + 12880))
      return this;
    this = vp::Audio_Capture::write_async((vp::Audio_Capture *)(v20 + 12880), *v15, v31, a3, &v32);
    realp = (int)v32.realp;
    v22 = BYTE4(v32.realp);
  }
  else
  {
    v23 = v9 + 8 * v10;
    if (!*(_QWORD *)(v23 + 12880))
      return this;
    this = vp::Audio_Capture::write_async((vp::Audio_Capture *)(v23 + 12880), a4, a5, a3, &v33);
    realp = v33;
    v22 = BYTE4(v33);
  }
  v24 = v22 == 0;
  v25 = v22 != 0;
  if (!v24)
    realp = 0;
  if (!v25)
  {
    v26 = 0;
    v27 = "badsavefile";
    v28 = kVPSaveFileIndexToCodeArray_v2;
    while (1)
    {
      v29 = *v28;
      v28 += 4;
      if (v29 == a2)
        break;
      if (++v26 == 134)
        goto LABEL_27;
    }
    v27 = *(const char **)&kVPSaveFileIndexToCodeArray_v2[4 * v26 + 2];
LABEL_27:
    if (a2 > 3)
      v30 = 21.003;
    else
      v30 = flt_1B66A2A10[v10];
    return VoiceProcessorV2::LogIOError(v9, v30, (float)*(unsigned int *)(v9 + 12448), (float)*(unsigned int *)(v9 + 12452), 0.0, "err-%d writing %s", realp, v27);
  }
  return this;
}

BOOL VoiceProcessorV2::QuerySaveFileAtIndexthroughFileSavingKey(VoiceProcessorV2 *this, unint64_t a2)
{
  char v2;
  unsigned int v3;
  BOOL v6;
  unsigned int v7;
  unsigned int v9;

  v2 = a2 - 68;
  if (a2 - 68 <= 0x2D)
  {
    if (((1 << v2) & 0x181801F) != 0)
    {
LABEL_12:
      v6 = *((_DWORD *)this + 3144) == 0;
      return !v6;
    }
    if (((1 << v2) & 0x380000000000) != 0)
    {
LABEL_4:
      v3 = *((_DWORD *)this + 3144);
      return v3 > 0x10 || (v3 & 0xFFFFFFFC) == 4;
    }
  }
  if (a2 > 0x3D)
    goto LABEL_4;
  if (((1 << a2) & 0x201E020000000003) != 0)
    goto LABEL_12;
  if (((1 << a2) & 0x40000000010) == 0)
  {
    if (a2 != 47)
      goto LABEL_4;
    v9 = *((_DWORD *)this + 3144);
    if (v9 <= 0xD && v9 - 3 > 4)
      return 0;
    v6 = *((_QWORD *)this + 249) == 0;
    return !v6;
  }
  v7 = *((_DWORD *)this + 3144);
  return v7 > 0xA || v7 - 2 < 6;
}

BOOL VoiceProcessorV2::SignalIsInFrequencyDomain(VoiceProcessorV2 *this, unint64_t a2)
{
  _BOOL8 result;

  result = 1;
  if (a2 - 93 > 0x28 || ((1 << (a2 - 93)) & 0x1FC0001FDBDLL) == 0)
  {
    if (a2 <= 0x27)
    {
      if (((1 << a2) & 0x700FFC0C00) != 0)
        return result;
      if (a2 == 39 && !*((_BYTE *)this + 2083))
        return *((_BYTE *)this + 2085) == 0;
    }
    return 0;
  }
  return result;
}

uint64_t VoiceProcessorV2::GetSignalSaveFileFormatForIndex(uint64_t this, VoiceProcessorV2 *a2, uint64_t a3, double a4, double a5)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  __int128 v8;
  double v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  int v28;
  int v29;

  v5 = this;
  switch(a3)
  {
    case 0:
      v6 = (char *)a2 + 584;
      v7 = *((_QWORD *)a2 + 77);
      goto LABEL_3;
    case 1:
      v18 = *((_OWORD *)a2 + 40);
      *(_OWORD *)this = *((_OWORD *)a2 + 39);
      *(_OWORD *)(this + 16) = v18;
      v12 = *((_QWORD *)a2 + 82);
      goto LABEL_39;
    case 2:
      v19 = *((_OWORD *)a2 + 45);
      *(_OWORD *)this = *((_OWORD *)a2 + 44);
      *(_OWORD *)(this + 16) = v19;
      v12 = *((_QWORD *)a2 + 92);
      goto LABEL_39;
    case 3:
      v6 = (char *)a2 + 744;
      v7 = *((_QWORD *)a2 + 97);
      goto LABEL_3;
    case 4:
      v20 = *((_OWORD *)a2 + 50);
      *(_OWORD *)this = *((_OWORD *)a2 + 49);
      *(_OWORD *)(this + 16) = v20;
      v12 = *((_QWORD *)a2 + 102);
      goto LABEL_39;
    case 5:
    case 74:
      v6 = (char *)a2 + 824;
      v7 = *((_QWORD *)a2 + 107);
      goto LABEL_3;
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 75:
    case 76:
    case 77:
    case 78:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 114:
    case 124:
      v9 = *((double *)a2 + 103);
      goto LABEL_5;
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 79:
    case 80:
    case 81:
    case 82:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 110:
    case 122:
    case 127:
    case 128:
    case 129:
    case 130:
    case 133:
      v6 = (char *)a2 + 904;
      v7 = *((_QWORD *)a2 + 117);
      goto LABEL_3;
    case 47:
    case 48:
      v16 = *((_OWORD *)a2 + 60);
      *(_OWORD *)this = *((_OWORD *)a2 + 59);
      *(_OWORD *)(this + 16) = v16;
      v12 = *((_QWORD *)a2 + 122);
      goto LABEL_39;
    case 49:
      v6 = (char *)a2 + 984;
      v7 = *((_QWORD *)a2 + 127);
      goto LABEL_3;
    case 50:
    case 57:
    case 60:
    case 65:
    case 68:
    case 84:
    case 115:
    case 117:
    case 119:
    case 125:
      v6 = (char *)a2 + 328;
      v7 = *((_QWORD *)a2 + 45);
LABEL_3:
      *(_QWORD *)(this + 32) = v7;
      v8 = *((_OWORD *)v6 + 1);
      *(_OWORD *)this = *(_OWORD *)v6;
      *(_OWORD *)(this + 16) = v8;
      return this;
    case 51:
      v21 = *((_OWORD *)a2 + 14);
      *(_OWORD *)this = *((_OWORD *)a2 + 13);
      *(_OWORD *)(this + 16) = v21;
      v12 = *((_QWORD *)a2 + 30);
      goto LABEL_39;
    case 53:
      v13 = *((_QWORD *)a2 + 41);
      if (*((_BYTE *)a2 + 2244))
        v14 = *((_DWORD *)a2 + 89);
      else
        v14 = 1;
      this = VoiceProcessorV2::GetDynamicsDSPChannelCount(a2);
      goto LABEL_22;
    case 54:
    case 85:
    case 86:
    case 87:
    case 88:
    case 116:
    case 123:
      v11 = *((_OWORD *)a2 + 19);
      *(_OWORD *)this = *((_OWORD *)a2 + 18);
      *(_OWORD *)(this + 16) = v11;
      v12 = *((_QWORD *)a2 + 40);
      goto LABEL_39;
    case 55:
    case 89:
    case 118:
    case 120:
    case 121:
      v13 = *((_QWORD *)a2 + 41);
      if (*((_BYTE *)a2 + 2244))
        v14 = *((_DWORD *)a2 + 89);
      else
        v14 = 1;
      this = VoiceProcessorV2::GetFarEndVoiceMixChannelCount(a2);
LABEL_22:
      if (v14 <= this)
        v15 = this;
      else
        v15 = v14;
      *(_QWORD *)v5 = v13;
      goto LABEL_26;
    case 56:
    case 64:
      v17 = *((_QWORD *)a2 + 41);
      this = VoiceProcessorV2::GetDynamicsDSPChannelCount(a2);
      *(_QWORD *)v5 = v17;
      *(_OWORD *)(v5 + 8) = xmmword_1B6626900;
      *(_DWORD *)(v5 + 24) = 4;
      *(_DWORD *)(v5 + 28) = this;
      goto LABEL_27;
    case 58:
    case 59:
    case 66:
    case 67:
    case 126:
      v15 = *((_DWORD *)a2 + 1073);
      if (v15 <= 1)
        v15 = 1;
      *(_QWORD *)this = *((_QWORD *)a2 + 41);
LABEL_26:
      *(_OWORD *)(v5 + 8) = xmmword_1B6626900;
      *(_DWORD *)(v5 + 24) = 4;
      *(_DWORD *)(v5 + 28) = v15;
LABEL_27:
      *(_QWORD *)(v5 + 32) = 32;
      return this;
    case 61:
    case 62:
    case 63:
    case 111:
    case 112:
    case 113:
      v9 = *((double *)a2 + 41);
      goto LABEL_5;
    case 69:
      v22 = *((_OWORD *)a2 + 94);
      *(_OWORD *)this = *((_OWORD *)a2 + 93);
      *(_OWORD *)(this + 16) = v22;
      v12 = *((_QWORD *)a2 + 190);
LABEL_39:
      *(_QWORD *)(this + 32) = v12;
      return this;
    case 83:
      v23 = *((_DWORD *)a2 + 85);
      v24 = *((_DWORD *)a2 + 89);
      v25 = *((_QWORD *)a2 + 45);
      if (v24 >= 2)
        v26 = 2;
      else
        v26 = *((_DWORD *)a2 + 89);
      if ((v23 & 0x20) != 0)
      {
        v24 = 1;
      }
      else if (!v24)
      {
        v27 = (v25 + 7) >> 3;
        goto LABEL_51;
      }
      v27 = *((_DWORD *)a2 + 88) / v24;
LABEL_51:
      if ((v23 & 0x20) != 0)
        v28 = 1;
      else
        v28 = v26;
      v29 = v27 * v28;
      *(_QWORD *)this = *((_QWORD *)a2 + 41);
      *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 84);
      *(_DWORD *)(this + 12) = v23;
      *(_DWORD *)(this + 16) = v29;
      *(_DWORD *)(this + 20) = 1;
      *(_DWORD *)(this + 24) = v29;
      *(_DWORD *)(this + 28) = v26;
      *(_QWORD *)(this + 32) = v25;
      return this;
    case 90:
      LODWORD(a5) = *((_DWORD *)a2 + 127);
      v9 = (*((double *)a2 + 103) + *((double *)a2 + 103)) / (double)*(unint64_t *)&a5;
LABEL_5:
      *(double *)this = v9;
      *(_OWORD *)(this + 8) = xmmword_1B6626900;
      v10 = xmmword_1B6626910;
      goto LABEL_6;
    case 105:
    case 106:
    case 107:
    case 108:
      *(_QWORD *)this = *((_QWORD *)a2 + 103);
      *(_OWORD *)(this + 8) = xmmword_1B6626900;
      v10 = xmmword_1B66A0810;
      goto LABEL_6;
    case 109:
      *(_QWORD *)this = *((_QWORD *)a2 + 103);
      *(_OWORD *)(this + 8) = xmmword_1B6626900;
      v10 = xmmword_1B66A0830;
      goto LABEL_6;
    case 131:
    case 132:
      *(_QWORD *)this = *((_QWORD *)a2 + 103);
      *(_OWORD *)(this + 8) = xmmword_1B6626900;
      v10 = xmmword_1B66A0820;
LABEL_6:
      *(_OWORD *)(this + 24) = v10;
      return this;
    default:
      *(_QWORD *)(this + 32) = 0;
      *(_OWORD *)this = 0u;
      *(_OWORD *)(this + 16) = 0u;
      return this;
  }
}

CFMutableDictionaryRef VoiceProcessorV2::SaveFilesPrepare(VoiceProcessorV2 *this)
{
  char *v2;
  unsigned __int8 *v3;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  gid_t v7;
  int *v8;
  const std::__fs::filesystem::path *v9;
  unint64_t v10;
  _QWORD *v11;
  NSObject *v12;
  gid_t v13;
  int *v14;
  _QWORD *v15;
  NSObject *v16;
  gid_t v17;
  int *v18;
  const __CFString *v19;
  const __CFString *v20;
  const char *v21;
  size_t v22;
  _QWORD *v23;
  NSObject *v24;
  int *v25;
  int **v26;
  uint64_t v27;
  const char *p_buf;
  uint64_t v29;
  const char *v30;
  _QWORD *v31;
  NSObject *v32;
  int *v33;
  uint64_t v34;
  const __CFAllocator *v35;
  CFMutableDictionaryRef result;
  int *v37;
  uint8_t v38[4];
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  char *v43;
  stat buf;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v2 = (char *)this + 15116;
  *((_QWORD *)this + 1605) = CATimeUtilities::GetCurrentGregorianDate(this);
  *((_QWORD *)this + 1606) = v4;
  *((_DWORD *)this + 3144) = 0;
  *(_OWORD *)((char *)this + 12856) = 0u;
  *(_DWORD *)((char *)this + 12871) = 0;
  if (queryBuildType(void)::once != -1)
    dispatch_once(&queryBuildType(void)::once, &__block_literal_global_67);
  if (!gIsInternal && !gIsCarrier)
  {
LABEL_56:
    if (!*((_DWORD *)this + 3144))
      goto LABEL_85;
    goto LABEL_57;
  }
  if (v2[1060])
  {
    *((_DWORD *)this + 3144) = *((_DWORD *)this + 3145);
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v5 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
    {
      v6 = (*v5 ? *v5 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        v7 = *((_DWORD *)this + 3144);
        buf.st_dev = 136315650;
        *(_QWORD *)&buf.st_mode = "vpDebug_FileSaving.cpp";
        WORD2(buf.st_ino) = 1024;
        *(_DWORD *)((char *)&buf.st_ino + 6) = 605;
        HIWORD(buf.st_uid) = 1024;
        buf.st_gid = v7;
        _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> Simulator override file saving level: %d", (uint8_t *)&buf, 0x18u);
      }
    }
    v8 = (int *)*((_QWORD *)this + 1570);
    if (v8 && (v2[781] || v2[782]))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      CALegacyLog::log(v8, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 605, "SaveFilesPrepare", "Simulator override file saving level: %d", *((_DWORD *)this + 3144));
    }
  }
  else
  {
    std::__fs::filesystem::path::path[abi:ne180100]<char [16],void>((std::string *)&buf, "/usr/local/lib/");
    v10 = vp::utility::CASuperBowl((vp::utility *)&buf, v9);
    if (SHIBYTE(buf.st_gid) < 0)
      operator delete(*(void **)&buf.st_dev);
    if ((v10 & 0xFF00000000) != 0)
    {
      *((_DWORD *)this + 3144) = v10;
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v11 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v12 = (*v11 ? *v11 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          v13 = *((_DWORD *)this + 3144);
          buf.st_dev = 136315650;
          *(_QWORD *)&buf.st_mode = "vpDebug_FileSaving.cpp";
          WORD2(buf.st_ino) = 1024;
          *(_DWORD *)((char *)&buf.st_ino + 6) = 599;
          HIWORD(buf.st_uid) = 1024;
          buf.st_gid = v13;
          _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> magic file exists, enabling file saving level %d", (uint8_t *)&buf, 0x18u);
        }
      }
      v14 = (int *)*((_QWORD *)this + 1570);
      if (v14 && (v2[781] || v2[782]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v14, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 599, "SaveFilesPrepare", "magic file exists, enabling file saving level %d", *((_DWORD *)this + 3144));
      }
    }
  }
  if (!*((_DWORD *)this + 3144))
  {
    if (PlatformUtilities_iOS::IsTelephonyCaptureAllowed())
    {
      *((_DWORD *)this + 3144) = 1;
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v15 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v16 = (*v15 ? *v15 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          v17 = *((_DWORD *)this + 3144);
          buf.st_dev = 136315650;
          *(_QWORD *)&buf.st_mode = "vpDebug_FileSaving.cpp";
          WORD2(buf.st_ino) = 1024;
          *(_DWORD *)((char *)&buf.st_ino + 6) = 615;
          HIWORD(buf.st_uid) = 1024;
          buf.st_gid = v17;
          _os_log_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> master default exists, enabling file saving level %d", (uint8_t *)&buf, 0x18u);
        }
      }
      v18 = (int *)*((_QWORD *)this + 1570);
      if (v18 && (v2[781] || v2[782]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v18, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 615, "SaveFilesPrepare", "master default exists, enabling file saving level %d", *((_DWORD *)this + 3144));
      }
    }
    goto LABEL_56;
  }
LABEL_57:
  CFRetain(CFSTR("com.apple.coreaudio"));
  v19 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("vp_save_files_dir"), CFSTR("com.apple.coreaudio"));
  v20 = v19;
  if (v19)
  {
    CFStringGetCString(v19, (char *)this + 12584, 256, 0x600u);
    CFRelease(v20);
  }
  else
  {
    v21 = (char *)this + 16184;
    if (v2[1091] < 0)
      v21 = *(const char **)v21;
    v22 = strlen(v21);
    strlcpy((char *)this + 12584, v21, v22 + 1);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v23 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
  {
    v24 = (*v23 ? *v23 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      buf.st_dev = 136315650;
      *(_QWORD *)&buf.st_mode = "vpDebug_FileSaving.cpp";
      WORD2(buf.st_ino) = 1024;
      *(_DWORD *)((char *)&buf.st_ino + 6) = 495;
      HIWORD(buf.st_uid) = 2080;
      *(_QWORD *)&buf.st_gid = (char *)this + 12584;
      _os_log_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> audio recordings available in %s", (uint8_t *)&buf, 0x1Cu);
    }
  }
  v25 = (int *)*((_QWORD *)this + 1570);
  if (v25 && (v2[781] || v2[782]))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v25, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 495, "SetSaveFilesDirectory", "audio recordings available in %s", (const char *)this + 12584);
  }
  v26 = (int **)((char *)this + 12560);
  if (stat((const char *)this + 12584, &buf) == -1 && mkpath_np((const char *)this + 12584, 0x1FFu))
  {
    *((_DWORD *)this + 3144) = 0;
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v31 = (_QWORD *)VPLogScope(void)::scope;
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
    {
      v32 = (*v31 ? *v31 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v38 = 136315650;
        v39 = "vpDebug_FileSaving.cpp";
        v40 = 1024;
        v41 = 506;
        v42 = 2080;
        v43 = (char *)this + 12584;
        _os_log_impl(&dword_1B5ED0000, v32, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> file saving turned OFF! recording directory %s cannot be created", v38, 0x1Cu);
      }
    }
    v33 = *v26;
    if (*v26 && (v2[781] || v2[782]))
    {
      if (VPLogScope(void)::once != -1)
      {
        v37 = *v26;
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v33 = v37;
      }
      CALegacyLog::log(v33, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 506, "SetSaveFilesDirectory", "file saving turned OFF! recording directory %s cannot be created", (const char *)this + 12584);
    }
  }
  VPGetSaveFileNameForIndex((std::string *)&buf, (char *)this + 12584, 91, 1, (uint64_t)this + 12840);
  v27 = operator new();
  if ((buf.st_gid & 0x80000000) == 0)
    p_buf = (const char *)&buf;
  else
    p_buf = *(const char **)&buf.st_dev;
  *(_QWORD *)(v27 + 8) = 0;
  *(_DWORD *)v27 = 1;
  if (p_buf)
    *(_QWORD *)(v27 + 8) = fopen(p_buf, "a");
  CADeprecated::CAAutoDelete<CALegacyLog>::set((_QWORD *)this + 1570, v27);
  std::string::operator=((std::string *)((char *)this + 12536), (const std::string *)&buf);
  if (SHIBYTE(buf.st_gid) < 0)
    operator delete(*(void **)&buf.st_dev);
LABEL_85:
  v38[0] = 0;
  VoiceProcessorV2::ReadDefaultsOverride(CFSTR("vp_save_timestamps"), 0, (BOOL *)v38, 0, v3);
  if (v38[0])
  {
    if (*((_DWORD *)this + 3144))
    {
      VPGetSaveFileNameForIndex((std::string *)&buf, (char *)this + 12584, 92, 1, (uint64_t)this + 12840);
      v29 = operator new();
      if ((buf.st_gid & 0x80000000) == 0)
        v30 = (const char *)&buf;
      else
        v30 = *(const char **)&buf.st_dev;
      *(_QWORD *)(v29 + 8) = 0;
      *(_DWORD *)v29 = 1;
      if (v30)
        *(_QWORD *)(v29 + 8) = fopen(v30, "a");
      CADeprecated::CAAutoDelete<CALegacyLog>::set((_QWORD *)this + 1571, v29);
      if (SHIBYTE(buf.st_gid) < 0)
        operator delete(*(void **)&buf.st_dev);
    }
    else
    {
      v34 = operator new();
      *(_QWORD *)(v34 + 8) = 0;
      *(_DWORD *)v34 = 1;
      CADeprecated::CAAutoDelete<CALegacyLog>::set((_QWORD *)this + 1571, v34);
    }
  }
  bzero((char *)this + 13976, 0x430uLL);
  v35 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *((_QWORD *)this + 1884) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  *((_DWORD *)this + 3764) = 0;
  result = CFDictionaryCreateMutable(v35, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)this + 1883) = result;
  *((_DWORD *)this + 3774) = 0;
  *((_QWORD *)this + 1886) = 0;
  *((_QWORD *)this + 1888) = 0;
  *((_DWORD *)this + 3778) = 0;
  *v2 = 0;
  *((_QWORD *)this + 1890) = 0;
  *((_DWORD *)this + 3782) = 0;
  v2[16] = 0;
  return result;
}

void sub_1B617B51C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  MEMORY[0x1BCC95CEC](v20, 0x1020C40D5A9D86FLL);
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

std::string *VPGetSaveFileNameForIndex(std::string *a1, char *a2, uint64_t a3, int a4, uint64_t a5)
{
  char *v8;
  uint64_t v10;
  const char *v11;
  int *v12;
  int v13;
  size_t v14;
  const char *v15;
  size_t v16;
  char *v18;
  char __str[16];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v18 = a2;
  v21 = 0u;
  v22 = 0u;
  *(_OWORD *)__str = 0u;
  v20 = 0u;
  snprintf(__str, 0x40uLL, "%d%02d%02d.%02d%02d%02d", *(_DWORD *)a5, *(char *)(a5 + 4), *(char *)(a5 + 5), *(char *)(a5 + 6), *(char *)(a5 + 7), (int)*(double *)(a5 + 8));
  std::__fs::filesystem::path::path[abi:ne180100]<char const*,void>(a1, &v18);
  std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(a1, "vp.");
  v8 = (char *)&v18 + 7;
  while (*++v8)
    ;
  std::string::append[abi:ne180100]<char const*,0>(a1, __str, v8);
  std::string::append(a1, ".xxx.", 5uLL);
  v10 = 0;
  v11 = "badsavefile";
  v12 = kVPSaveFileIndexToCodeArray_v2;
  while (1)
  {
    v13 = *v12;
    v12 += 4;
    if (v13 == a3)
      break;
    if (++v10 == 134)
      goto LABEL_8;
  }
  v11 = *(const char **)&kVPSaveFileIndexToCodeArray_v2[4 * v10 + 2];
LABEL_8:
  v14 = strlen(v11);
  std::string::append(a1, v11, v14);
  std::string::append(a1, ".", 1uLL);
  v15 = VPGetSaveFileNameForIndex(char const*,unsigned long long,vpSaveFileType,CATimeUtilities::GregorianDate const&)::kFileNameExtention[a4];
  v16 = strlen(v15);
  return std::string::append(a1, v15, v16);
}

void sub_1B617B6F8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

_QWORD *CADeprecated::CAAutoDelete<CALegacyLog>::set(_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  FILE *v5;

  v2 = *result;
  if (*result != a2)
  {
    v4 = result;
    if (v2)
    {
      v5 = *(FILE **)(v2 + 8);
      if (v5)
      {
        fclose(v5);
        *(_QWORD *)(v2 + 8) = 0;
      }
      result = (_QWORD *)MEMORY[0x1BCC95CEC](v2, 0x1020C40D5A9D86FLL);
    }
    *v4 = a2;
  }
  return result;
}

void VoiceProcessorV2::SaveFilesInitialize(VoiceProcessorV2 *this)
{
  char *v2;
  char *v3;
  char *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  size_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unint64_t i;
  double v22;
  size_t v23;
  void *v24;
  BOOL v25;
  void *v26;
  void *v27;
  void *v28;
  std::bad_alloc *exception;
  std::bad_alloc *v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v2 = (char *)*((_QWORD *)this + 1745);
  v3 = (char *)*((_QWORD *)this + 1744);
  if (v2 != v3)
  {
    do
    {
      v2 -= 24;
      *(_QWORD *)&v31 = v2;
      std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v31);
    }
    while (v2 != v3);
    v2 = (char *)*((_QWORD *)this + 1744);
  }
  *((_QWORD *)this + 1745) = v3;
  v4 = (char *)(v3 - v2);
  v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - v2) >> 3);
  if (v5 > 0x85)
  {
    if (v4 != (char *)3216)
    {
      v19 = v2 + 3216;
      while (v3 != v19)
      {
        v3 -= 24;
        *(_QWORD *)&v31 = v3;
        std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v31);
      }
      *((_QWORD *)this + 1745) = v19;
    }
    goto LABEL_27;
  }
  v6 = *((_QWORD *)this + 1746);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)v3) >> 3) >= 134 - v5)
  {
    bzero(v3, 24 * ((3192 - (uint64_t)v4) / 0x18uLL) + 24);
    *((_QWORD *)this + 1745) = &v3[24 * ((3192 - (uint64_t)v4) / 0x18uLL) + 24];
    goto LABEL_27;
  }
  v7 = 0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)v2) >> 3);
  v8 = 0x5555555555555556 * ((v6 - (uint64_t)v2) >> 3);
  if (v8 <= 0x86)
    v8 = 134;
  if (v7 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v8;
  if (v9 > 0xAAAAAAAAAAAAAAALL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v10 = 3 * v9;
  v11 = (char *)operator new(24 * v9);
  v12 = &v11[8 * ((v3 - v2) >> 3)];
  v13 = &v11[8 * v10];
  v14 = 24 * ((3192 - (uint64_t)v4) / 0x18uLL) + 24;
  bzero(v12, v14);
  v15 = &v12[v14];
  if (v3 == v2)
  {
    *((_QWORD *)this + 1744) = v12;
    *((_QWORD *)this + 1745) = v15;
    *((_QWORD *)this + 1746) = v13;
    if (!v3)
      goto LABEL_27;
  }
  else
  {
    do
    {
      v16 = v12;
      *((_QWORD *)v12 - 1) = 0;
      v17 = *(_OWORD *)(v3 - 24);
      v3 -= 24;
      *(_OWORD *)(v12 - 24) = v17;
      v12 -= 24;
      *((_QWORD *)v16 - 1) = *((_QWORD *)v3 + 2);
      *(_QWORD *)v3 = 0;
      *((_QWORD *)v3 + 1) = 0;
      *((_QWORD *)v3 + 2) = 0;
    }
    while (v3 != v2);
    v18 = (char *)*((_QWORD *)this + 1744);
    v3 = (char *)*((_QWORD *)this + 1745);
    *((_QWORD *)this + 1744) = v12;
    *((_QWORD *)this + 1745) = v15;
    *((_QWORD *)this + 1746) = v13;
    if (v3 != v18)
    {
      do
      {
        v3 -= 24;
        *(_QWORD *)&v31 = v3;
        std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v31);
      }
      while (v3 != v18);
      v3 = v18;
    }
    if (!v3)
      goto LABEL_27;
  }
  operator delete(v3);
LABEL_27:
  v20 = 0;
  for (i = 0; i != 134; ++i)
  {
    if (VoiceProcessorV2::SignalIsInFrequencyDomain(this, i))
    {
      v33 = 0;
      v31 = 0u;
      v32 = 0u;
      VoiceProcessorV2::GetSignalSaveFileFormatForIndex((uint64_t)&v31, this, i, 0.0, v22);
      std::vector<std::unique_ptr<VPTimeFreqConverter>>::resize((__int128 *)(*((_QWORD *)this + 1744) + v20), HIDWORD(v32));
    }
    v20 += 24;
  }
  if (*((_DWORD *)this + 3144))
  {
    if (*((_BYTE *)this + 476))
    {
      VoiceProcessorV2::CreateSignalSaveFiles(this, 1);
      if (*((_DWORD *)this + 3144))
      {
        if (*((_QWORD *)this + 1886))
          goto LABEL_49;
        v23 = 4 * *((unsigned int *)this + 3770) * (unint64_t)*((unsigned int *)this + 3771);
        v24 = malloc_type_malloc(v23, 0x2C8E6D5CuLL);
        if (v24)
          v25 = 1;
        else
          v25 = v23 == 0;
        if (!v25)
        {
LABEL_46:
          exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
          v30 = std::bad_alloc::bad_alloc(exception);
        }
        v26 = v24;
        bzero(v24, v23);
        *((_QWORD *)this + 1886) = v26;
        if (*((_DWORD *)this + 3144))
        {
LABEL_49:
          if (!*((_QWORD *)this + 1888))
          {
            v27 = malloc_type_malloc(0x30D40uLL, 0x2C8E6D5CuLL);
            if (!v27)
              goto LABEL_46;
            v28 = v27;
            bzero(v27, 0x30D40uLL);
            *((_QWORD *)this + 1888) = v28;
          }
        }
      }
    }
  }
}

void VoiceProcessorV2::CreateSignalSaveFiles(VoiceProcessorV2 *this, int a2)
{
  char *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  char *v9;
  unint64_t i;
  int v12;
  char IsDLPSignalFile;
  double v14;
  double v15;
  AudioBufferList *p_buf;
  size_t v17;
  uint64_t v18;
  int *v19;
  int v20;
  const char *v21;
  size_t v22;
  const std::string::value_type *v23;
  uint64_t *v24;
  unsigned int v25;
  int v26;
  _QWORD *v27;
  NSObject *v28;
  std::string *v29;
  int *v30;
  std::string *v31;
  _QWORD *v32;
  NSObject *v33;
  std::string *v34;
  int *v35;
  _QWORD *v36;
  NSObject *v37;
  std::string *v38;
  int *v39;
  uint64_t v40;
  unint64_t v41;
  VPTimeFreqConverter *v42;
  int v43;
  AudioStreamBasicDescription v44;
  std::string v45;
  std::string v46;
  AudioTimeStamp buf;
  AudioBufferList v48;
  _OWORD __str[4];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v4 = (char *)this + 12844;
  if (a2 == 1)
  {
    if (!*((_BYTE *)this + 12872))
      goto LABEL_15;
    v5 = *((_DWORD *)this + 3215) + 1;
    *((_DWORD *)this + 3215) = v5;
    *((_BYTE *)this + 12872) = 0;
    v6 = *((_DWORD *)this + 3214);
    if (v6 >= v5)
    {
      if (v5 < v6)
        *((_DWORD *)this + 3215) = v6;
      goto LABEL_15;
    }
  }
  else if (a2 == 3)
  {
    if (!*((_BYTE *)this + 12874))
      goto LABEL_15;
    v5 = *((_DWORD *)this + 3217) + 1;
    *((_DWORD *)this + 3217) = v5;
    *((_BYTE *)this + 12874) = 0;
    v8 = *((_DWORD *)this + 3214);
    if (v8 >= v5)
    {
      if (v5 < v8)
        *((_DWORD *)this + 3217) = v8;
      goto LABEL_15;
    }
  }
  else
  {
    if (a2 != 2 || !*((_BYTE *)this + 12873))
      goto LABEL_15;
    v5 = *((_DWORD *)this + 3216) + 1;
    *((_DWORD *)this + 3216) = v5;
    *((_BYTE *)this + 12873) = 0;
    v7 = *((_DWORD *)this + 3214);
    if (v7 >= v5)
    {
      if (v5 < v7)
        *((_DWORD *)this + 3216) = v7;
      goto LABEL_15;
    }
  }
  *((_DWORD *)this + 3214) = v5;
LABEL_15:
  memset(__str, 0, sizeof(__str));
  snprintf((char *)__str, 0x40uLL, "%d%02d%02d.%02d%02d%02d.%03u", *((_DWORD *)this + 3210), *v4, *((char *)this + 12845), *((char *)this + 12846), *((char *)this + 12847), (int)*((double *)this + 1606), *((_DWORD *)this + 3214));
  memset(&v46, 0, sizeof(v46));
  std::__fs::filesystem::path::path[abi:ne180100]<char [12],void>(&v45, (char *)this + 12584);
  std::__fs::filesystem::path::append[abi:ne180100]<char [8]>(&v45, "vp.");
  v9 = (char *)&v48.mBuffers[0].mData + 7;
  while (*++v9)
    ;
  std::string::append[abi:ne180100]<char const*,0>(&v45, (char *)__str, v9);
  std::string::append(&v45, ".", 1uLL);
  for (i = 0; i != 134; ++i)
  {
    if (i - 91 < 2 || (i & 0xFE) == 0x48 || i == 41 || i == 52 || (i & 0xFE) == 0x46)
      continue;
    if (a2 == 1)
    {
      if (i == 69 || (VoiceProcessorV2::SaveFileAtIndexIsDLPSignalFile((VoiceProcessorV2 *)i) & 1) != 0)
        continue;
      goto LABEL_37;
    }
    if (a2 != 2)
    {
      if (a2 == 3 && i != 69)
        continue;
      goto LABEL_37;
    }
    if (i == 69)
      continue;
    v12 = *((_DWORD *)this + 1127);
    if (v12 == 1)
    {
      IsDLPSignalFile = VoiceProcessorV2::SaveFileAtIndexIsDLPSignalFile((VoiceProcessorV2 *)i);
      if (i)
        goto LABEL_36;
    }
    else if (!v12)
    {
      IsDLPSignalFile = VoiceProcessorV2::SaveFileAtIndexIsDLPSignalFile((VoiceProcessorV2 *)i);
LABEL_36:
      if ((IsDLPSignalFile & 1) == 0)
        continue;
    }
LABEL_37:
    if (*((_DWORD *)this + 3144) && VoiceProcessorV2::QuerySaveFileAtIndexthroughFileSavingKey(this, i))
    {
      VoiceProcessorV2::GetSignalSaveFileFormatForIndex((uint64_t)&buf, this, i, v14, v15);
      *(_OWORD *)&v44.mSampleRate = *(_OWORD *)&buf.mSampleTime;
      *(_OWORD *)&v44.mBytesPerPacket = *(_OWORD *)&buf.mRateScalar;
      *(_QWORD *)&v44.mBitsPerChannel = *(_QWORD *)&buf.mSMPTETime.mSubframes;
      std::string::operator=(&v46, &v45);
      if (a2 == 1)
      {
        p_buf = &v48;
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&v48, **((_DWORD **)this + 295));
      }
      else
      {
        p_buf = (AudioBufferList *)&buf;
        CAX4CCStringNoQuote::CAX4CCStringNoQuote((CAX4CCStringNoQuote *)&buf, **((_DWORD **)this + 292));
      }
      v17 = strlen((const char *)p_buf);
      std::string::append(&v46, (const std::string::value_type *)p_buf, v17);
      std::string::append(&v46, ".", 1uLL);
      v18 = 0;
      v19 = kVPSaveFileIndexToCodeArray_v2;
      while (1)
      {
        v20 = *v19;
        v19 += 4;
        if (i == v20)
          break;
        if (++v18 == 134)
        {
          v21 = "badsavefile";
          goto LABEL_47;
        }
      }
      v21 = *(const char **)&kVPSaveFileIndexToCodeArray_v2[4 * v18 + 2];
LABEL_47:
      v22 = strlen(v21);
      std::string::append(&v46, v21, v22);
      if (i == 69)
        v23 = ".caf";
      else
        v23 = ".wav";
      std::string::append(&v46, v23, 4uLL);
      vp::Audio_File::Audio_File(&buf);
      v24 = (uint64_t *)((char *)this + 8 * i + 12880);
      vp::Audio_Capture::operator=(v24, (uint64_t *)&buf);
      vp::Audio_Capture::~Audio_Capture((vp::Audio_Capture *)&buf);
      if (v44.mChannelsPerFrame)
      {
        v25 = *((_DWORD *)this + 3144) - 8;
        if (v25 > 0xB)
          v26 = 0;
        else
          v26 = dword_1B6631728[v25];
        vp::Audio_Capture::create((const std::__fs::filesystem::path *)&v46, (uint64_t)&v44, v26, (uint64_t *)&buf);
        vp::Audio_Capture::operator=(v24, (uint64_t *)&buf);
        vp::Audio_Capture::~Audio_Capture((vp::Audio_Capture *)&buf);
        if (*v24)
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v32 = (_QWORD *)VPLogScope(void)::scope;
          if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
          {
            v33 = (*v32 ? *v32 : MEMORY[0x1E0C81028]);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            {
              v34 = &v46;
              if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                v34 = (std::string *)v46.__r_.__value_.__r.__words[0];
              LODWORD(buf.mSampleTime) = 136315650;
              *(_QWORD *)((char *)&buf.mSampleTime + 4) = "vpDebug_FileSaving.cpp";
              WORD2(buf.mHostTime) = 1024;
              *(_DWORD *)((char *)&buf.mHostTime + 6) = 1301;
              WORD1(buf.mRateScalar) = 2080;
              *(_QWORD *)((char *)&buf.mRateScalar + 4) = v34;
              _os_log_impl(&dword_1B5ED0000, v33, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> created \"%s\" audio capture", (uint8_t *)&buf, 0x1Cu);
            }
          }
          v35 = (int *)*((_QWORD *)this + 1570);
          if (v35 && (v4[3053] || v4[3054]))
          {
            if (VPLogScope(void)::once != -1)
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            CALegacyLog::log(v35, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 1301, "CreateSignalSaveFiles", "created \"%s\" audio capture");
          }
        }
        else
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v36 = (_QWORD *)VPLogScope(void)::scope;
          if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
          {
            v37 = (*v36 ? *v36 : MEMORY[0x1E0C81028]);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              v38 = &v46;
              if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                v38 = (std::string *)v46.__r_.__value_.__r.__words[0];
              LODWORD(buf.mSampleTime) = 136315650;
              *(_QWORD *)((char *)&buf.mSampleTime + 4) = "vpDebug_FileSaving.cpp";
              WORD2(buf.mHostTime) = 1024;
              *(_DWORD *)((char *)&buf.mHostTime + 6) = 1305;
              WORD1(buf.mRateScalar) = 2080;
              *(_QWORD *)((char *)&buf.mRateScalar + 4) = v38;
              _os_log_impl(&dword_1B5ED0000, v37, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> failed to create \"%s\" audio capture", (uint8_t *)&buf, 0x1Cu);
            }
          }
          v39 = (int *)*((_QWORD *)this + 1570);
          if (v39 && (v4[3053] || v4[3054]))
          {
            if (VPLogScope(void)::once != -1)
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            CALegacyLog::log(v39, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 1305, "CreateSignalSaveFiles", "failed to create \"%s\" audio capture");
          }
        }
        if (VoiceProcessorV2::SignalIsInFrequencyDomain(this, i))
        {
          if (v44.mChannelsPerFrame == (uint64_t)(*(_QWORD *)(*((_QWORD *)this + 1744) + 24 * i + 8)
                                                - *(_QWORD *)(*((_QWORD *)this + 1744) + 24 * i)) >> 3
            && v44.mChannelsPerFrame)
          {
            v40 = 0;
            v41 = 0;
            do
            {
              v42 = (VPTimeFreqConverter *)operator new();
              VPTimeFreqConverter::VPTimeFreqConverter(v42, 1, *((_DWORD *)this + 127));
              std::unique_ptr<VPTimeFreqConverter>::reset[abi:ne180100]((VPTimeFreqConverter **)(*(_QWORD *)(*((_QWORD *)this + 1744) + 24 * i) + v40), v42);
              ++v41;
              v40 += 8;
            }
            while (v41 < v44.mChannelsPerFrame);
          }
          myAllocABLDynamic(&v44, *((_DWORD *)this + 127), (AudioBufferList **)this + i + 1747);
        }
        if (i == 90)
        {
          v43 = 0x40000000;
          *(_QWORD *)&v48.mNumberBuffers = 1;
          *(_QWORD *)&v48.mBuffers[0].mNumberChannels = 0x400000001;
          v48.mBuffers[0].mData = &v43;
          memset(&buf, 0, 56);
          buf.mFlags = 1;
          if (v4[3053] || v4[3054])
            VoiceProcessorV2::SaveFilesWriteSignal((uint64_t)this, 0x5Au, 1, &v48, &buf);
        }
      }
      else
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v27 = (_QWORD *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
        {
          v28 = (*v27 ? *v27 : MEMORY[0x1E0C81028]);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            v29 = &v46;
            if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v29 = (std::string *)v46.__r_.__value_.__r.__words[0];
            LODWORD(buf.mSampleTime) = 136315906;
            *(_QWORD *)((char *)&buf.mSampleTime + 4) = "vpDebug_FileSaving.cpp";
            WORD2(buf.mHostTime) = 1024;
            *(_DWORD *)((char *)&buf.mHostTime + 6) = 1269;
            WORD1(buf.mRateScalar) = 2080;
            *(_QWORD *)((char *)&buf.mRateScalar + 4) = v29;
            WORD2(buf.mWordClockTime) = 1024;
            *(_DWORD *)((char *)&buf.mWordClockTime + 6) = v44.mChannelsPerFrame;
            _os_log_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> Skipping file capture for %s due to unsupported format, theFileFormat.mChannelsPerFrame=%u", (uint8_t *)&buf, 0x22u);
          }
        }
        v30 = (int *)*((_QWORD *)this + 1570);
        if (v30 && (v4[3053] || v4[3054]))
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v31 = &v46;
          if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v31 = (std::string *)v46.__r_.__value_.__r.__words[0];
          CALegacyLog::log(v30, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 1269, "CreateSignalSaveFiles", "Skipping file capture for %s due to unsupported format, theFileFormat.mChannelsPerFrame=%u", (const char *)v31, v44.mChannelsPerFrame);
        }
      }
    }
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v45.__r_.__value_.__l.__data_);
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v46.__r_.__value_.__l.__data_);
}

void sub_1B617C434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a34 < 0)
    operator delete(__p);
  if (a40 < 0)
    operator delete(a35);
  _Unwind_Resume(exception_object);
}

uint64_t VoiceProcessorV2::SaveFileAtIndexIsDLPSignalFile(VoiceProcessorV2 *this)
{
  char *v1;
  uint64_t result;

  v1 = (char *)this - 50;
  result = 1;
  switch((unint64_t)v1)
  {
    case 0uLL:
    case 1uLL:
    case 3uLL:
    case 4uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x24uLL:
    case 0x25uLL:
    case 0x26uLL:
    case 0x27uLL:
    case 0x3DuLL:
    case 0x3EuLL:
    case 0x3FuLL:
    case 0x41uLL:
    case 0x42uLL:
    case 0x43uLL:
    case 0x44uLL:
    case 0x45uLL:
    case 0x46uLL:
    case 0x47uLL:
    case 0x49uLL:
    case 0x4BuLL:
    case 0x4CuLL:
      return result;
    default:
      result = 0;
      break;
  }
  return result;
}

void VoiceProcessorV2::SaveFilesInitializeDLP(VoiceProcessorV2 *this)
{
  void *v2;
  void *v3;
  std::bad_alloc *exception;
  std::bad_alloc *v5;

  if (*((_DWORD *)this + 3144))
  {
    if (*((_BYTE *)this + 477))
    {
      VoiceProcessorV2::CreateSignalSaveFiles(this, 2);
      if (*((_DWORD *)this + 3144))
      {
        if (!*((_QWORD *)this + 1890))
        {
          v2 = malloc_type_malloc(0x30D40uLL, 0x2C8E6D5CuLL);
          if (!v2)
          {
            exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
            v5 = std::bad_alloc::bad_alloc(exception);
          }
          v3 = v2;
          bzero(v2, 0x30D40uLL);
          *((_QWORD *)this + 1890) = v3;
        }
      }
    }
  }
}

void VoiceProcessorV2::SaveFilesCleanup(VoiceProcessorV2 *this)
{
  int v2;
  _BYTE *v3;
  _QWORD *v4;
  NSObject *v5;
  std::string *p_p;
  int *v7;
  std::string *v8;
  std::string *v9;
  const void *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t i;
  double *v15;
  int v16;
  size_t v17;
  const void *v18;
  size_t v19;
  size_t v20;
  size_t v21;
  _QWORD *v22;
  NSObject *v23;
  std::string *v24;
  int *v25;
  std::string *v26;
  std::string *v27;
  _QWORD *v28;
  NSObject *v29;
  std::string *v30;
  int *v31;
  std::string *v32;
  std::string *v33;
  FILE *v34;
  unint64_t v35;
  _QWORD *v36;
  NSObject *v37;
  std::string *v38;
  int *v39;
  std::string *v40;
  _QWORD *v41;
  NSObject *v42;
  std::string *v43;
  int *v44;
  std::string *v45;
  std::string *v46;
  FILE *v47;
  uint64_t v48;
  uint64_t v49;
  size_t v50;
  _QWORD *v51;
  NSObject *v52;
  std::string *v53;
  int *v54;
  std::string *v55;
  _QWORD *v56;
  NSObject *v57;
  std::string *v58;
  int *v59;
  std::string *v60;
  std::string *v61;
  FILE *v62;
  uint64_t v63;
  uint64_t v64;
  size_t v65;
  _QWORD *v66;
  NSObject *v67;
  std::string *v68;
  int *v69;
  std::string *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  const void *v75;
  const void *v76;
  void *v77;
  void *v78;
  void *v79;
  std::string __p;
  _BYTE buf[12];
  __int16 v82;
  int v83;
  __int16 v84;
  std::string *v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v2 = *((_DWORD *)this + 3144);
  if (v2)
  {
    v3 = (char *)this + 15116;
    if (*((_QWORD *)this + 1884))
    {
      VPGetSaveFileNameForIndex(&__p, (char *)this + 12584, 71, 3, (uint64_t)this + 12840);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v4 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v5 = (*v4 ? *v4 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "vpDebug_FileSaving.cpp";
          v82 = 1024;
          v83 = 782;
          v84 = 2080;
          v85 = p_p;
          _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing properties plist file: %s ...", buf, 0x1Cu);
        }
      }
      v7 = (int *)*((_QWORD *)this + 1570);
      if (v7 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v8 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
        CALegacyLog::log(v7, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 782, "SaveFilesCleanup", "writing properties plist file: %s ...", (const char *)v8);
      }
      *(_QWORD *)buf = *((_QWORD *)this + 1884);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v9 = &__p;
      else
        v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
      WritePropertyListToFile((CFPropertyListRef *)buf, (const char *)v9);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      CFRelease(*((CFTypeRef *)this + 1884));
      *((_QWORD *)this + 1884) = 0;
      v2 = *((_DWORD *)this + 3144);
    }
    v10 = (const void *)*((_QWORD *)this + 1883);
    if (v10)
    {
      if (v2)
      {
        v11 = (_QWORD *)((char *)this + 15064);
        v12 = *((unsigned int *)this + 3764);
        if ((_DWORD)v12)
        {
          v13 = 0;
          for (i = 0; i < v12; ++i)
          {
            if (*v11)
            {
              v15 = (double *)(*((_QWORD *)this + 1881) + v13);
              v16 = *(_DWORD *)v15;
              snprintf(buf, 0x100uLL, "%f, %f, %llu", v15[1], v15[2], *((_QWORD *)v15 + 3));
              switch(v16)
              {
                case 0:
                  VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&__p, 48);
                  v17 = strlen(buf);
                  WriteItemToDictionary((__CFDictionary **)this + 1883, (const void **)&__p.__r_.__value_.__l.__data_, 0, v17 + 1, buf);
                  v18 = (const void *)__p.__r_.__value_.__r.__words[0];
                  if (__p.__r_.__value_.__r.__words[0])
                    goto LABEL_41;
                  break;
                case 1:
                  VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&__p, 49);
                  v19 = strlen(buf);
                  WriteItemToDictionary((__CFDictionary **)this + 1883, (const void **)&__p.__r_.__value_.__l.__data_, 0, v19 + 1, buf);
                  v18 = (const void *)__p.__r_.__value_.__r.__words[0];
                  if (__p.__r_.__value_.__r.__words[0])
                    goto LABEL_41;
                  break;
                case 2:
                  VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&__p, 50);
                  v20 = strlen(buf);
                  WriteItemToDictionary((__CFDictionary **)this + 1883, (const void **)&__p.__r_.__value_.__l.__data_, 0, v20 + 1, buf);
                  v18 = (const void *)__p.__r_.__value_.__r.__words[0];
                  if (__p.__r_.__value_.__r.__words[0])
                    goto LABEL_41;
                  break;
                case 3:
                  VPGetPropsPListStringForKey((applesauce::CF::StringRef *)&__p, 52);
                  v21 = strlen(buf);
                  WriteItemToDictionary((__CFDictionary **)this + 1883, (const void **)&__p.__r_.__value_.__l.__data_, 0, v21 + 1, buf);
                  v18 = (const void *)__p.__r_.__value_.__r.__words[0];
                  if (__p.__r_.__value_.__r.__words[0])
LABEL_41:
                    CFRelease(v18);
                  break;
                default:
                  break;
              }
              v12 = *((unsigned int *)this + 3764);
            }
            v13 += 32;
          }
        }
        VPGetSaveFileNameForIndex(&__p, (char *)this + 12584, 70, 3, (uint64_t)this + 12840);
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v22 = (_QWORD *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
        {
          v23 = (*v22 ? *v22 : MEMORY[0x1E0C81028]);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            v24 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "vpDebug_FileSaving.cpp";
            v82 = 1024;
            v83 = 798;
            v84 = 2080;
            v85 = v24;
            _os_log_impl(&dword_1B5ED0000, v23, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing time stamps plist file: %s ...", buf, 0x1Cu);
          }
        }
        v25 = (int *)*((_QWORD *)this + 1570);
        if (v25 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v26 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
          CALegacyLog::log(v25, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 798, "SaveFilesCleanup", "writing time stamps plist file: %s ...", (const char *)v26);
        }
        *(_QWORD *)buf = *v11;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v27 = &__p;
        else
          v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
        WritePropertyListToFile((CFPropertyListRef *)buf, (const char *)v27);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        v10 = (const void *)*v11;
      }
      CFRelease(v10);
      *((_QWORD *)this + 1883) = 0;
      v2 = *((_DWORD *)this + 3144);
    }
    if (v2)
    {
      if (!*((_QWORD *)this + 1886))
        goto LABEL_249;
      VPGetSaveFileNameForIndex(&__p, (char *)this + 12584, 72, 1, (uint64_t)this + 12840);
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v28 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v29 = (*v28 ? *v28 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          v30 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "vpDebug_FileSaving.cpp";
          v82 = 1024;
          v83 = 809;
          v84 = 2080;
          v85 = v30;
          _os_log_impl(&dword_1B5ED0000, v29, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing error log file: %s  ... ", buf, 0x1Cu);
        }
      }
      v31 = (int *)*((_QWORD *)this + 1570);
      if (v31 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v32 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
        CALegacyLog::log(v31, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 809, "SaveFilesCleanup", "writing error log file: %s  ... ", (const char *)v32);
      }
      v33 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      v34 = fopen((const char *)v33, "wt");
      if (v34)
      {
        if (*((_DWORD *)this + 3774))
        {
          v35 = 0;
          do
          {
            if ((v35 & 3) == 0)
              fputc(10, v34);
            fprintf(v34, "%.4f\t", *(float *)(*((_QWORD *)this + 1886) + 4 * v35++));
          }
          while (v35 < *((unsigned int *)this + 3774));
        }
        else
        {
          fwrite("no errors occurred on the I/O thread.\n", 0x26uLL, 1uLL, v34);
        }
        fputc(10, v34);
        fflush(v34);
        fclose(v34);
      }
      else
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v36 = (_QWORD *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
        {
          v37 = (*v36 ? *v36 : MEMORY[0x1E0C81028]);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          {
            v38 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v38 = (std::string *)__p.__r_.__value_.__r.__words[0];
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "vpDebug_FileSaving.cpp";
            v82 = 1024;
            v83 = 821;
            v84 = 2080;
            v85 = v38;
            _os_log_impl(&dword_1B5ED0000, v37, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> couldn't open file to write: %s  ... ", buf, 0x1Cu);
          }
        }
        v39 = (int *)*((_QWORD *)this + 1570);
        if (v39 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v40 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v40 = (std::string *)__p.__r_.__value_.__r.__words[0];
          CALegacyLog::log(v39, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 821, "SaveFilesCleanup", "couldn't open file to write: %s  ... ", (const char *)v40);
        }
      }
      free(*((void **)this + 1886));
      *((_QWORD *)this + 1886) = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (*((_DWORD *)this + 3144))
      {
LABEL_249:
        if (!*((_QWORD *)this + 1888))
          goto LABEL_250;
        VPGetSaveFileNameForIndex(&__p, (char *)this + 12584, 41, 3, (uint64_t)this + 12840);
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v41 = (_QWORD *)VPLogScope(void)::scope;
        if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
        {
          v42 = (*v41 ? *v41 : MEMORY[0x1E0C81028]);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
          {
            v43 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v43 = (std::string *)__p.__r_.__value_.__r.__words[0];
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "vpDebug_FileSaving.cpp";
            v82 = 1024;
            v83 = 872;
            v84 = 2080;
            v85 = v43;
            _os_log_impl(&dword_1B5ED0000, v42, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing gating control data file: %s ... ", buf, 0x1Cu);
          }
        }
        v44 = (int *)*((_QWORD *)this + 1570);
        if (v44 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v45 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v45 = (std::string *)__p.__r_.__value_.__r.__words[0];
          CALegacyLog::log(v44, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 872, "SaveFilesCleanup", "writing gating control data file: %s ... ", (const char *)v45);
        }
        v46 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__p
            : (std::string *)__p.__r_.__value_.__r.__words[0];
        v47 = fopen((const char *)v46, "wt");
        if (v47)
        {
          v48 = *((_QWORD *)this + 1888);
          if (v48)
          {
            if (*v3)
            {
              v49 = *((unsigned int *)this + 3778);
              if ((_DWORD)v49 != 200000)
                fwrite((const void *)(v48 + v49), 1uLL, (200000 - v49), v47);
            }
            v50 = *((unsigned int *)this + 3778);
            if ((_DWORD)v50)
              fwrite(*((const void **)this + 1888), 1uLL, v50, v47);
          }
          fputc(10, v47);
          fflush(v47);
          fclose(v47);
        }
        else
        {
          if (VPLogScope(void)::once != -1)
            dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
          v51 = (_QWORD *)VPLogScope(void)::scope;
          if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
          {
            v52 = (*v51 ? *v51 : MEMORY[0x1E0C81028]);
            if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
            {
              v53 = &__p;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                v53 = (std::string *)__p.__r_.__value_.__r.__words[0];
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = "vpDebug_FileSaving.cpp";
              v82 = 1024;
              v83 = 892;
              v84 = 2080;
              v85 = v53;
              _os_log_impl(&dword_1B5ED0000, v52, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> couldn't open file to write: %s  ... ", buf, 0x1Cu);
            }
          }
          v54 = (int *)*((_QWORD *)this + 1570);
          if (v54 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
          {
            if (VPLogScope(void)::once != -1)
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            v55 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v55 = (std::string *)__p.__r_.__value_.__r.__words[0];
            CALegacyLog::log(v54, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 892, "SaveFilesCleanup", "couldn't open file to write: %s  ... ", (const char *)v55);
          }
        }
        free(*((void **)this + 1888));
        *((_QWORD *)this + 1888) = 0;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (*((_DWORD *)this + 3144))
        {
LABEL_250:
          if (*((_QWORD *)this + 1890))
          {
            VPGetSaveFileNameForIndex(&__p, (char *)this + 12584, 52, 3, (uint64_t)this + 12840);
            if (VPLogScope(void)::once != -1)
              dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
            v56 = (_QWORD *)VPLogScope(void)::scope;
            if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
            {
              v57 = (*v56 ? *v56 : MEMORY[0x1E0C81028]);
              if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
              {
                v58 = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  v58 = (std::string *)__p.__r_.__value_.__r.__words[0];
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)&buf[4] = "vpDebug_FileSaving.cpp";
                v82 = 1024;
                v83 = 903;
                v84 = 2080;
                v85 = v58;
                _os_log_impl(&dword_1B5ED0000, v57, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp> writing dlp control data file: %s ... ", buf, 0x1Cu);
              }
            }
            v59 = (int *)*((_QWORD *)this + 1570);
            if (v59 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
            {
              if (VPLogScope(void)::once != -1)
                dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
              v60 = &__p;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                v60 = (std::string *)__p.__r_.__value_.__r.__words[0];
              CALegacyLog::log(v59, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 903, "SaveFilesCleanup", "writing dlp control data file: %s ... ", (const char *)v60);
            }
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v61 = &__p;
            else
              v61 = (std::string *)__p.__r_.__value_.__r.__words[0];
            v62 = fopen((const char *)v61, "wt");
            if (v62)
            {
              v63 = *((_QWORD *)this + 1890);
              if (v63)
              {
                if (*((_BYTE *)this + 15132))
                {
                  v64 = *((unsigned int *)this + 3782);
                  if ((_DWORD)v64 != 200000)
                    fwrite((const void *)(v63 + v64), 1uLL, (200000 - v64), v62);
                }
                v65 = *((unsigned int *)this + 3782);
                if ((_DWORD)v65)
                  fwrite(*((const void **)this + 1890), 1uLL, v65, v62);
              }
              fputc(10, v62);
              fflush(v62);
              fclose(v62);
            }
            else
            {
              if (VPLogScope(void)::once != -1)
                dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
              v66 = (_QWORD *)VPLogScope(void)::scope;
              if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
              {
                v67 = (*v66 ? *v66 : MEMORY[0x1E0C81028]);
                if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                {
                  v68 = &__p;
                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    v68 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = "vpDebug_FileSaving.cpp";
                  v82 = 1024;
                  v83 = 923;
                  v84 = 2080;
                  v85 = v68;
                  _os_log_impl(&dword_1B5ED0000, v67, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> couldn't open file to write: %s  ... ", buf, 0x1Cu);
                }
              }
              v69 = (int *)*((_QWORD *)this + 1570);
              if (v69 && (*((_BYTE *)this + 15897) || *((_BYTE *)this + 15898)))
              {
                if (VPLogScope(void)::once != -1)
                  dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
                v70 = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  v70 = (std::string *)__p.__r_.__value_.__r.__words[0];
                CALegacyLog::log(v69, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_FileSaving.cpp", 923, "SaveFilesCleanup", "couldn't open file to write: %s  ... ", (const char *)v70);
              }
            }
            free(*((void **)this + 1890));
            *((_QWORD *)this + 1890) = 0;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
      }
    }
  }
  v71 = *((_QWORD *)this + 1745);
  v72 = *((_QWORD *)this + 1744);
  while (v71 != v72)
  {
    v71 -= 24;
    *(_QWORD *)buf = v71;
    std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  }
  v73 = 0;
  *((_QWORD *)this + 1745) = v72;
  v74 = (char *)this + 13976;
  do
  {
    if (*(_QWORD *)&v74[v73])
    {
      myFreeABLDynamic((AudioBufferList **)&v74[v73]);
      *(_QWORD *)&v74[v73] = 0;
    }
    v73 += 8;
  }
  while (v73 != 1072);
  v75 = (const void *)*((_QWORD *)this + 1884);
  if (v75)
  {
    CFRelease(v75);
    *((_QWORD *)this + 1884) = 0;
  }
  v76 = (const void *)*((_QWORD *)this + 1883);
  if (v76)
  {
    CFRelease(v76);
    *((_QWORD *)this + 1883) = 0;
  }
  v77 = (void *)*((_QWORD *)this + 1886);
  if (v77)
  {
    free(v77);
    *((_QWORD *)this + 1886) = 0;
  }
  v78 = (void *)*((_QWORD *)this + 1888);
  if (v78)
  {
    free(v78);
    *((_QWORD *)this + 1888) = 0;
  }
  v79 = (void *)*((_QWORD *)this + 1890);
  if (v79)
  {
    free(v79);
    *((_QWORD *)this + 1890) = 0;
  }
}

void sub_1B617D638(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<VoiceProcessorV2::RereadSaveFilesDefaults(void)::$_0 &&>>(uint64_t **a1)
{
  uint64_t v1;
  VoiceProcessorV2 *v2;
  unsigned __int8 *v3;
  int v4;
  int v5;

  v1 = **a1;
  v2 = *(VoiceProcessorV2 **)v1;
  v3 = (unsigned __int8 *)(*(_QWORD *)v1 + 15897);
  VoiceProcessorV2::SaveFilesPrepare(*(VoiceProcessorV2 **)v1);
  VoiceProcessorV2::SaveFilesInitialize(v2);
  VoiceProcessorV2::SaveFilesInitializeDLP(v2);
  if (*((_DWORD *)v2 + 3144) && *((_BYTE *)v2 + 478))
    VoiceProcessorV2::CreateSignalSaveFiles(v2, 3);
  v4 = **(unsigned __int8 **)(v1 + 8);
  v3[1] = v4;
  v5 = *v3;
  if (!(v5 | v4))
  {
LABEL_7:
    if (!v4)
      goto LABEL_9;
    goto LABEL_8;
  }
  VoiceProcessorV2::PListWriteInitializeHwInputParameters(v2);
  v5 = *v3;
  if (!*v3)
  {
    v4 = v3[1];
    goto LABEL_7;
  }
LABEL_8:
  VoiceProcessorV2::PListWriteInitializeDLPParameters(v2);
  v5 = *v3;
LABEL_9:
  if (v5 || v3[1])
  {
    VoiceProcessorV2::PListWriteInitializeOutputParameters(v2);
    if (*v3 || v3[1])
    {
      VoiceProcessorV2::PListWriteInitializeSpkrTelParameters(v2);
      if (*v3 || v3[1])
        VoiceProcessorV2::PListWriteSetModeParameters(v2);
    }
  }
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<VoiceProcessorV2::RereadSaveFilesDefaults(void)::$_1 &&>>(uint64_t **a1, double a2, double a3)
{
  uint64_t v3;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v4;
  _BYTE *v5;

  v3 = **a1;
  v4 = *(_QWORD *)v3;
  v5 = (_BYTE *)(*(_QWORD *)v3 + 12488);
  if (*(_BYTE *)(*(_QWORD *)v3 + 1688)
    && (*(_BYTE *)(*(_QWORD *)v3 + 15897) || *(_BYTE *)(*(_QWORD *)v3 + 15898)))
  {
    LODWORD(a3) = *(_DWORD *)(v4 + 492);
    VoiceProcessorV2::WriteTSOverload(*(_QWORD *)v3, *(double *)(v4 + 1696) - (double)*(unint64_t *)&a3, *(double *)(v4 + 1696) - (double)*(unint64_t *)&a3, 0);
  }
  if (*(_BYTE *)(v4 + 1689) && (v5[3409] || v5[3410]))
  {
    LODWORD(a3) = *(_DWORD *)(v4 + 496);
    VoiceProcessorV2::WriteTSOverload(v4, *(double *)(v4 + 1704) - (double)*(unint64_t *)&a3, *(double *)(v4 + 1704) - (double)*(unint64_t *)&a3, 1);
  }
  if (*v5 && (v5[3409] || v5[3410]))
  {
    LODWORD(a3) = *(_DWORD *)(v4 + 484);
    VoiceProcessorV2::WriteTSOverload(v4, *(double *)(v4 + 12480) - (double)*(unint64_t *)&a3, *(double *)(v4 + 12480) - (double)*(unint64_t *)&a3, 2);
  }
  if (v5[16] && (v5[3409] || v5[3410]))
  {
    LODWORD(a3) = *(_DWORD *)(v4 + 1528);
    VoiceProcessorV2::WriteTSOverload(v4, *(double *)(v4 + 12496) - (double)*(unint64_t *)&a3, *(double *)(v4 + 12496) - (double)*(unint64_t *)&a3, 3);
  }
  VoiceProcessorV2::SaveFilesCleanup((VoiceProcessorV2 *)v4);
  v5[3410] = **(_BYTE **)(v3 + 8);
}

std::chrono::duration<long long, std::ratio<1, 1000000>>::rep VoiceProcessorV2::WriteTSOverload(std::chrono::duration<long long, std::ratio<1, 1000000>>::rep this, double a2, double a3, int a4)
{
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v4;
  uint64_t v8;

  if (*(_DWORD *)(this + 12576))
  {
    v4 = this;
    if (!(*(_DWORD *)(this + 15056) >> 13))
    {
      this = std::chrono::system_clock::now().__d_.__rep_;
      v8 = *(_QWORD *)(v4 + 15048) + 32 * *(unsigned int *)(v4 + 15056);
      *(_DWORD *)v8 = a4;
      *(double *)(v8 + 8) = a2;
      *(double *)(v8 + 16) = a3;
      *(_QWORD *)(v8 + 24) = this / 1000000;
      ++*(_DWORD *)(v4 + 15056);
    }
  }
  return this;
}

uint64_t VoiceProcessorV2::WriteControlDataToFile(uint64_t this, char *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v7;
  _BYTE *v8;
  void **v9;
  _DWORD *v10;
  char *v11;
  uint64_t v12;
  unsigned int v13;
  size_t v14;
  size_t v15;

  if (*(_DWORD *)(this + 12576))
  {
    v7 = this;
    this = VoiceProcessorV2::QuerySaveFileAtIndexthroughFileSavingKey((VoiceProcessorV2 *)this, a4);
    if ((_DWORD)this)
    {
      v8 = (_BYTE *)(v7 + 15116);
      if (a4 == 52)
      {
        v9 = (void **)(v7 + 15120);
        v10 = (_DWORD *)(v7 + 15128);
        v8 = (_BYTE *)(v7 + 15132);
      }
      else
      {
        if (a4 != 41)
          return this;
        v9 = (void **)(v7 + 15104);
        v10 = (_DWORD *)(v7 + 15112);
      }
      v11 = (char *)*v9;
      if (*v9)
      {
        v12 = *v10;
        if (v12 < 0x30D41)
        {
          v13 = 200000 - v12;
          if (200000 - (int)v12 >= a3)
            v14 = a3;
          else
            v14 = v13;
          if (a3 >= v13)
            v15 = a3 - v13;
          else
            v15 = 0;
          if ((_DWORD)v14)
          {
            this = (uint64_t)memcpy(&v11[v12], a2, v14);
            *v10 += v14;
          }
          if (v13 < a3)
          {
            this = (uint64_t)memcpy(v11, &a2[v14], v15);
            *v10 = v15;
            *v8 = 1;
          }
        }
      }
    }
  }
  return this;
}

uint64_t VoiceProcessorV2::EchoGateV3ReadWriteControlDataCallback(uint64_t this, char *a2, void *a3, int a4)
{
  if (!a4)
    return VoiceProcessorV2::WriteControlDataToFile(this, a2, a3, 0x29u);
  return this;
}

void WaveFileReader::read(FILE **this, float *const *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4;
  unsigned int v7;
  vDSP_Length v8;
  uint64_t v9;
  __int16 *v10;
  size_t v11;
  size_t v12;
  uint64_t v13;
  float *v14;
  int v15;
  size_t v16;
  uint64_t v17;
  void *v18;
  size_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  float *v23;
  size_t v24;
  void *v25;
  _BYTE v26[4];
  float __B;
  uint64_t v28;

  LODWORD(v4) = a3;
  v28 = *MEMORY[0x1E0C80C00];
  if (this[5] && (v7 = *((_DWORD *)this + 12)) != 0)
  {
    if (*((unsigned __int16 *)this + 11) == a3)
    {
      if (v7 >= a4)
        v8 = a4;
      else
        v8 = v7;
      MEMORY[0x1E0C80A78](this);
      v10 = (__int16 *)&v26[-v9];
      v12 = fread(&v26[-v9], v11, (v8 * v4), this[5]);
      if (*((_WORD *)this + 10) == 3)
        goto LABEL_23;
      MEMORY[0x1E0C80A78](v12);
      v14 = (float *)&v26[-((v13 + 15) & 0x7FFFFFFF0)];
      v15 = *((unsigned __int16 *)this + 17);
      switch(v15)
      {
        case 16:
          vDSP_vflt16(v10, 1, v14, 1, (v8 * v4));
          goto LABEL_22;
        case 24:
          vDSP_vflt24((const vDSP_int24 *)v10, 1, v14, 1, (v8 * v4));
          goto LABEL_22;
        case 32:
          vDSP_vflt32((const int *)v10, 1, v14, 1, (v8 * v4));
LABEL_22:
          __B = (float)(1 << (*((_WORD *)this + 17) - 1));
          vDSP_vsdiv(v14, 1, &__B, (float *)v10, 1, (v8 * v4));
LABEL_23:
          if ((_DWORD)v4)
          {
            v22 = v4;
            do
            {
              v23 = *a2++;
              vDSP_mmov((const float *)v10, v23, 1uLL, v8, v4, 1uLL);
              v10 += 2;
              --v22;
            }
            while (v22);
          }
          return;
      }
      if ((_DWORD)v4)
      {
        v24 = 4 * v8;
        v4 = v4;
        do
        {
          v25 = *a2++;
          bzero(v25, v24);
          --v4;
        }
        while (v4);
      }
    }
    else if (a3)
    {
      v19 = 4 * a4;
      v20 = a3;
      do
      {
        v21 = *a2++;
        bzero(v21, v19);
        --v20;
      }
      while (v20);
    }
  }
  else if (a3)
  {
    v16 = 4 * a4;
    v17 = a3;
    do
    {
      v18 = *a2++;
      bzero(v18, v16);
      --v17;
    }
    while (v17);
  }
}

uint64_t VoiceProcessorV2::LogIOError(uint64_t this, float a2, float a3, float a4, float a5, const char *a6, ...)
{
  uint64_t v6;
  uint64_t v7;
  char __str[256];
  uint64_t v9;
  va_list va;

  va_start(va, a6);
  v9 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)(this + 12576))
    return vsnprintf(__str, 0x100uLL, a6, va);
  v6 = *(_QWORD *)(this + 15088);
  if (v6)
  {
    v7 = *(unsigned int *)(this + 15096);
    if (v7 < (*(_DWORD *)(this + 15080) - 1) * *(_DWORD *)(this + 15084))
    {
      *(float *)(v6 + 4 * v7) = a2;
      *(float *)(v6 + 4 * (v7 + 1)) = a3;
      *(float *)(v6 + 4 * (v7 + 2)) = a4;
      *(_DWORD *)(this + 15096) = v7 + 4;
      *(float *)(v6 + 4 * (v7 + 3)) = a5;
    }
  }
  return this;
}

char *std::vector<std::pair<unsigned int,float>>::__init_with_size[abi:ne180100]<std::pair<unsigned int,float>*,std::pair<unsigned int,float>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::pair<unsigned int,float>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B617DE14(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void CAX4CCString::CAX4CCString(CAX4CCString *this, unsigned int a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v4 = bswap32(a2);
  *(_DWORD *)((char *)this + 1) = v4;
  v5 = MEMORY[0x1E0C80978];
  if ((v4 & 0x80) != 0)
  {
    if (!__maskrune((char)v4, 0x40000uLL))
      goto LABEL_17;
  }
  else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v4 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  v6 = *((char *)this + 2);
  if ((v6 & 0x80000000) != 0)
  {
    if (!__maskrune(v6, 0x40000uLL))
      goto LABEL_17;
  }
  else if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  v7 = *((char *)this + 3);
  if ((v7 & 0x80000000) != 0)
  {
    if (!__maskrune(v7, 0x40000uLL))
      goto LABEL_17;
LABEL_13:
    v8 = *((char *)this + 4);
    if ((v8 & 0x80000000) != 0)
    {
      if (!__maskrune(v8, 0x40000uLL))
        goto LABEL_17;
    }
    else if ((*(_DWORD *)(v5 + 4 * v8 + 60) & 0x40000) == 0)
    {
      goto LABEL_17;
    }
    *(_WORD *)((char *)this + 5) = 39;
    *(_BYTE *)this = 39;
    return;
  }
  if ((*(_DWORD *)(v5 + 4 * v7 + 60) & 0x40000) != 0)
    goto LABEL_13;
LABEL_17:
  if (a2 + 199999 > 0x61A7E)
    snprintf((char *)this, 0x10uLL, "0x%x");
  else
    snprintf((char *)this, 0x10uLL, "%d");
}

char *std::vector<std::pair<unsigned int,float>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void VoiceProcessorV2::LogNonTransientErrors(VoiceProcessorV2 *this, int a2)
{
  char *v3;
  const char *v4;
  uint64_t *i;
  _QWORD *v6;
  NSObject *v7;
  const char *v8;
  int *v9;
  const char *v10;
  const char *v11;
  uint64_t *k;
  _QWORD *v13;
  NSObject *v14;
  const char *v15;
  int *v16;
  const char *v17;
  __int128 *v18;
  __int128 *j;
  uint64_t *v20;
  const std::string *v21;
  __int128 *v22;
  __int128 *m;
  uint64_t *v24;
  const std::string *v25;
  __int128 *v26;
  _BYTE buf[28];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = (char *)this + 15897;
  if (a2)
  {
    v4 = (const char *)*((_QWORD *)this + 1997);
    for (i = (uint64_t *)*((_QWORD *)this + 1998); v4 != (const char *)i; v4 += 24)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v6 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v7 = (*v6 ? *v6 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          v8 = v4;
          if (v4[23] < 0)
            v8 = *(const char **)v4;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 97;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v8;
          _os_log_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> %s\n", buf, 0x1Cu);
        }
      }
      v9 = (int *)*((_QWORD *)this + 1570);
      if (v9 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v10 = v4;
        if (v4[23] < 0)
          v10 = *(const char **)v4;
        CALegacyLog::log(v9, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 97, "LogNonTransientErrors", "%s\n", v10);
      }
    }
    v18 = (__int128 *)*((_QWORD *)this + 2003);
    for (j = (__int128 *)*((_QWORD *)this + 2004); v18 != j; v18 = (__int128 *)&v21[1])
    {
      *(_OWORD *)&buf[8] = 0uLL;
      v26 = v18;
      *(_QWORD *)buf = &buf[8];
      v20 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)buf, (void **)v18, &v26);
      v21 = (const std::string *)((char *)v18 + 24);
      std::string::operator=((std::string *)(v20 + 7), v21);
      AudioStatisticsHelperSendMessage(*((uint64_t **)this + 270), *((_DWORD *)this + 542), (const UInt8 **)buf, 6);
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(_QWORD **)&buf[8]);
    }
  }
  else
  {
    v11 = (const char *)*((_QWORD *)this + 2000);
    for (k = (uint64_t *)*((_QWORD *)this + 2001); v11 != (const char *)k; v11 += 24)
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v13 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(1, VPLogScope(void)::scope, 0))
      {
        v14 = (*v13 ? *v13 : MEMORY[0x1E0C81028]);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          v15 = v11;
          if (v11[23] < 0)
            v15 = *(const char **)v11;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 112;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v15;
          _os_log_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d  >vp> %s\n", buf, 0x1Cu);
        }
      }
      v16 = (int *)*((_QWORD *)this + 1570);
      if (v16 && (*v3 || v3[1]))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v17 = v11;
        if (v11[23] < 0)
          v17 = *(const char **)v11;
        CALegacyLog::log(v16, 1, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 112, "LogNonTransientErrors", "%s\n", v17);
      }
    }
    v22 = (__int128 *)*((_QWORD *)this + 2006);
    for (m = (__int128 *)*((_QWORD *)this + 2007); v22 != m; v22 = (__int128 *)&v25[1])
    {
      *(_QWORD *)&buf[8] = 0;
      *(_QWORD *)&buf[16] = 0;
      v26 = v22;
      *(_QWORD *)buf = &buf[8];
      v24 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)buf, (void **)v22, &v26);
      v25 = (const std::string *)((char *)v22 + 24);
      std::string::operator=((std::string *)(v24 + 7), v25);
      AudioStatisticsHelperSendMessage(*((uint64_t **)this + 270), *((_DWORD *)this + 542), (const UInt8 **)buf, 6);
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(_QWORD **)&buf[8]);
    }
  }
}

void sub_1B617E3F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, void **a2, __int128 **a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  std::string *v8;
  __int128 *v9;
  __int128 v10;
  _QWORD v12[2];
  char v13;
  uint64_t v14;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__find_equal<std::string>((uint64_t)a1, &v14, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    v6 = (uint64_t *)operator new(0x50uLL);
    v12[0] = v6;
    v12[1] = a1 + 1;
    v13 = 0;
    v8 = (std::string *)(v6 + 4);
    v9 = *a3;
    if (*((char *)*a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)v9, *((_QWORD *)v9 + 1));
    }
    else
    {
      v10 = *v9;
      v6[6] = *((_QWORD *)v9 + 2);
      *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v10;
    }
    v6[7] = 0;
    v6[8] = 0;
    v6[9] = 0;
    v13 = 1;
    std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(a1, v14, v7, v6);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
  }
  return v6;
}

void sub_1B617E4DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void VoiceProcessorV2::LogVPParams(VoiceProcessorV2 *this)
{
  _QWORD *v2;
  NSObject *v3;
  int *v4;
  _QWORD *v5;
  NSObject *v6;
  _QWORD *v7;
  int *v8;
  const char *v9;
  _QWORD *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  NSObject *v18;
  int *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  NSObject *v24;
  int *v25;
  uint64_t v26;
  int v27;
  _QWORD *v28;
  NSObject *v29;
  int v30;
  int *v31;
  NSObject *v32;
  int *v33;
  _QWORD *v34;
  NSObject *v35;
  int *v36;
  uint64_t v37;
  _QWORD *v38;
  NSObject *v39;
  int *v40;
  uint64_t v41;
  _QWORD *v42;
  NSObject *v43;
  int v44;
  int *v45;
  _QWORD *v46;
  NSObject *v47;
  int v48;
  int *v49;
  _QWORD *v50;
  NSObject *v51;
  const char *v52;
  int v53;
  const char *v54;
  int *v55;
  const char *v56;
  const char *v57;
  _QWORD *v58;
  NSObject *v59;
  int16x8_t v60;
  void **v61;
  int *v62;
  uint64_t v63;
  int16x8_t v64;
  const char *v65;
  unint64_t v66;
  unsigned int v67;
  uint64_t v68;
  _QWORD *v69;
  NSObject *v70;
  double v71;
  int *v72;
  unint64_t v73;
  unsigned int v74;
  uint64_t v75;
  _QWORD *v76;
  NSObject *v77;
  double v78;
  int *v79;
  _QWORD *v80;
  NSObject *v81;
  int *v82;
  uint64_t v83;
  _QWORD *v84;
  NSObject *v85;
  int v86;
  int v87;
  int *v88;
  _QWORD *v89;
  NSObject *v90;
  uint64_t v91;
  int v92;
  int *v93;
  _QWORD *v94;
  NSObject *v95;
  uint64_t v96;
  int v97;
  int *v98;
  _QWORD *v99;
  NSObject *v100;
  int v101;
  int *v102;
  int v103;
  _QWORD *v104;
  NSObject *v105;
  int v106;
  int *v107;
  _QWORD *v108;
  NSObject *v109;
  double v110;
  int *v111;
  _QWORD *v112;
  NSObject *v113;
  double v114;
  int *v115;
  _QWORD *v116;
  NSObject *v117;
  double v118;
  int *v119;
  _QWORD *v120;
  NSObject *v121;
  double v122;
  int *v123;
  _QWORD *v124;
  NSObject *v125;
  double v126;
  int *v127;
  _QWORD *v128;
  NSObject *v129;
  double v130;
  int *v131;
  _QWORD *v132;
  NSObject *v133;
  double v134;
  int *v135;
  _QWORD *v136;
  NSObject *v137;
  int *v138;
  uint64_t v139;
  _QWORD *v140;
  NSObject *v141;
  int *v142;
  uint64_t v143;
  _QWORD *v144;
  NSObject *v145;
  int *v146;
  uint64_t v147;
  _QWORD *v148;
  NSObject *v149;
  int v150;
  int *v151;
  _QWORD *v152;
  NSObject *v153;
  int *v154;
  char *v155;
  void *__p[2];
  char v157;
  _BYTE buf[40];
  _BYTE v159[12];
  __int16 v160;
  int v161;
  __int16 v162;
  void **v163;
  uint64_t v164;

  v164 = *MEMORY[0x1E0C80C00];
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v155 = (char *)this + 15897;
  v2 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v3 = (*v2 ? *v2 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 127;
      _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> ____________logparams:begin___________", buf, 0x12u);
    }
  }
  v4 = (int *)*((_QWORD *)this + 1570);
  if (v4 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v4, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 127, "LogVPParams", "____________logparams:begin___________");
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v5 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v6 = (*v5 ? *v5 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = (_QWORD *)((char *)this + 32);
      if (*((char *)this + 55) < 0)
        v7 = (_QWORD *)*v7;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 128;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = v7;
      _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     PRODUCT: %s", buf, 0x1Cu);
    }
  }
  v8 = (int *)*((_QWORD *)this + 1570);
  if (v8 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v9 = (char *)this + 32;
    if (*((char *)this + 55) < 0)
      v9 = *(const char **)v9;
    CALegacyLog::log(v8, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 128, "LogVPParams", "    PRODUCT: %s", v9);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v10 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v11 = (*v10 ? *v10 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = (uint64_t)(*((_QWORD *)this + 293) - *((_QWORD *)this + 292)) >> 2;
      v13 = (uint64_t)(*((_QWORD *)this + 296) - *((_QWORD *)this + 295)) >> 2;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 130;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v12;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = v13;
      _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Num Ref Ports = %lu, Num Mic Ports = %lu ", buf, 0x26u);
    }
  }
  v14 = (int *)*((_QWORD *)this + 1570);
  if (v14 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v14, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 130, "LogVPParams", "    Num Ref Ports = %lu, Num Mic Ports = %lu ", (uint64_t)(*((_QWORD *)this + 293) - *((_QWORD *)this + 292)) >> 2, (uint64_t)(*((_QWORD *)this + 296) - *((_QWORD *)this + 295)) >> 2);
  }
  if (*((_QWORD *)this + 293) != *((_QWORD *)this + 292))
  {
    v15 = 0;
    v16 = MEMORY[0x1E0C81028];
    do
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v17 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v18 = (*v17 ? *v17 : v16);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          CAX4CCString::CAX4CCString((CAX4CCString *)v159, *(_DWORD *)(*((_QWORD *)this + 292) + 4 * v15));
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 134;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v15;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = v159;
          _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>       : Ref Port #%lu=%s", buf, 0x26u);
        }
      }
      v19 = (int *)*((_QWORD *)this + 1570);
      if (v19 && (*v155 || *((_BYTE *)this + 15898)))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v20 = VPLogScope(void)::scope;
        CAX4CCString::CAX4CCString((CAX4CCString *)buf, *(_DWORD *)(*((_QWORD *)this + 292) + 4 * v15));
        CALegacyLog::log(v19, 3, v20, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 134, "LogVPParams", "      : Ref Port #%lu=%s", v15, buf);
      }
      ++v15;
    }
    while (v15 < (uint64_t)(*((_QWORD *)this + 293) - *((_QWORD *)this + 292)) >> 2);
  }
  if (*((_QWORD *)this + 296) != *((_QWORD *)this + 295))
  {
    v21 = 0;
    v22 = MEMORY[0x1E0C81028];
    do
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v23 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
      {
        v24 = (*v23 ? *v23 : v22);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          CAX4CCString::CAX4CCString((CAX4CCString *)v159, *(_DWORD *)(*((_QWORD *)this + 295) + 4 * v21));
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 138;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v21;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = v159;
          _os_log_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>       : Mic Port #%lu=%s", buf, 0x26u);
        }
      }
      v25 = (int *)*((_QWORD *)this + 1570);
      if (v25 && (*v155 || *((_BYTE *)this + 15898)))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        v26 = VPLogScope(void)::scope;
        CAX4CCString::CAX4CCString((CAX4CCString *)buf, *(_DWORD *)(*((_QWORD *)this + 295) + 4 * v21));
        CALegacyLog::log(v25, 3, v26, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 138, "LogVPParams", "      : Mic Port #%lu=%s", v21, buf);
      }
      ++v21;
    }
    while (v21 < (uint64_t)(*((_QWORD *)this + 296) - *((_QWORD *)this + 295)) >> 2);
  }
  v27 = *((unsigned __int8 *)this + 60);
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v28 = (_QWORD *)VPLogScope(void)::scope;
  if (v27)
  {
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      v29 = (*v28 ? *v28 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        if (!*((_BYTE *)this + 60))
          std::__throw_bad_optional_access[abi:ne180100]();
        v30 = *((_DWORD *)this + 14);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 189;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v30;
        _os_log_impl(&dword_1B5ED0000, v29, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Acoustic ID: %d", buf, 0x18u);
      }
    }
    v31 = (int *)*((_QWORD *)this + 1570);
    if (v31 && (*v155 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      if (!*((_BYTE *)this + 60))
        std::__throw_bad_optional_access[abi:ne180100]();
      CALegacyLog::log(v31, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 189, "LogVPParams", "    Acoustic ID: %d", *((_DWORD *)this + 14));
    }
  }
  else
  {
    if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
    {
      v32 = (*v28 ? *v28 : MEMORY[0x1E0C81028]);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 193;
        _os_log_impl(&dword_1B5ED0000, v32, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     This product does not have a valid Acoustic ID", buf, 0x12u);
      }
    }
    v33 = (int *)*((_QWORD *)this + 1570);
    if (v33 && (*v155 || *((_BYTE *)this + 15898)))
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      CALegacyLog::log(v33, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 193, "LogVPParams", "    This product does not have a valid Acoustic ID");
    }
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v34 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v35 = (*v34 ? *v34 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (const AudioStreamBasicDescription *)((char *)this + 584));
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 196;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = *(_QWORD *)v159;
      _os_log_impl(&dword_1B5ED0000, v35, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Format REF: %s", buf, 0x1Cu);
      if (*(_QWORD *)v159)
        free(*(void **)v159);
    }
  }
  v36 = (int *)*((_QWORD *)this + 1570);
  if (v36 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v37 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (const AudioStreamBasicDescription *)((char *)this + 584));
    CALegacyLog::log(v36, 3, v37, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 196, "LogVPParams", "    HW Format REF: %s", *(const char **)buf);
    if (*(_QWORD *)buf)
      free(*(void **)buf);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v38 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v39 = (*v38 ? *v38 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (const AudioStreamBasicDescription *)((char *)this + 624));
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 197;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = *(_QWORD *)v159;
      _os_log_impl(&dword_1B5ED0000, v39, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Format MIC: %s", buf, 0x1Cu);
      if (*(_QWORD *)v159)
        free(*(void **)v159);
    }
  }
  v40 = (int *)*((_QWORD *)this + 1570);
  if (v40 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v41 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (const AudioStreamBasicDescription *)((char *)this + 624));
    CALegacyLog::log(v40, 3, v41, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 197, "LogVPParams", "    HW Format MIC: %s", *(const char **)buf);
    if (*(_QWORD *)buf)
      free(*(void **)buf);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v42 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v43 = (*v42 ? *v42 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      v44 = *((_DWORD *)this + 123);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 198;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v44;
      _os_log_impl(&dword_1B5ED0000, v43, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Block Size REF: %d", buf, 0x18u);
    }
  }
  v45 = (int *)*((_QWORD *)this + 1570);
  if (v45 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v45, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 198, "LogVPParams", "    HW Block Size REF: %d", *((_DWORD *)this + 123));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v46 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v47 = (*v46 ? *v46 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      v48 = *((_DWORD *)this + 124);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 199;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v48;
      _os_log_impl(&dword_1B5ED0000, v47, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Block Size MIC: %d", buf, 0x18u);
    }
  }
  v49 = (int *)*((_QWORD *)this + 1570);
  if (v49 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v49, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 199, "LogVPParams", "    HW Block Size MIC: %d", *((_DWORD *)this + 124));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v50 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v51 = (*v50 ? *v50 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      v52 = "internal";
      v53 = *((_DWORD *)this + 286);
      v54 = "enabled";
      if (!*((_DWORD *)this + 1127))
        v52 = "external";
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 201;
      *(_DWORD *)buf = 136315906;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = v52;
      if (!v53)
        v54 = "n/a";
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = v54;
      _os_log_impl(&dword_1B5ED0000, v51, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     REF Signal: %s, Hw tap stream: %s", buf, 0x26u);
    }
  }
  v55 = (int *)*((_QWORD *)this + 1570);
  if (v55 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v56 = "internal";
    if (!*((_DWORD *)this + 1127))
      v56 = "external";
    if (*((_DWORD *)this + 286))
      v57 = "enabled";
    else
      v57 = "n/a";
    CALegacyLog::log(v55, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 201, "LogVPParams", "    REF Signal: %s, Hw tap stream: %s", v56, v57);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v58 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v59 = (*v58 ? *v58 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      v60 = *((int16x8_t *)this + 35);
      *(_OWORD *)buf = *((_OWORD *)this + 34);
      *(int16x8_t *)&buf[16] = v60;
      *(_QWORD *)&buf[32] = *((_QWORD *)this + 72);
      CA::StreamDescription::AsString((CA::StreamDescription *)buf, (uint64_t)__p, v60);
      v61 = v157 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)v159 = 136315650;
      *(_QWORD *)&v159[4] = "vpDebug_Logging.cpp";
      v160 = 1024;
      v161 = 202;
      v162 = 2080;
      v163 = v61;
      _os_log_impl(&dword_1B5ED0000, v59, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW Format EXT REF: %s", v159, 0x1Cu);
      if (v157 < 0)
        operator delete(__p[0]);
    }
  }
  v62 = (int *)*((_QWORD *)this + 1570);
  if (v62 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v63 = VPLogScope(void)::scope;
    v64 = *((int16x8_t *)this + 35);
    *(_OWORD *)buf = *((_OWORD *)this + 34);
    *(int16x8_t *)&buf[16] = v64;
    *(_QWORD *)&buf[32] = *((_QWORD *)this + 72);
    CA::StreamDescription::AsString((CA::StreamDescription *)buf, (uint64_t)v159, v64);
    if (SBYTE3(v163) >= 0)
      v65 = v159;
    else
      v65 = *(const char **)v159;
    CALegacyLog::log(v62, 3, v63, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 202, "LogVPParams", "    HW Format EXT REF: %s", v65);
    if (SBYTE3(v163) < 0)
      operator delete(*(void **)v159);
  }
  if (*((_QWORD *)this + 263) != *((_QWORD *)this + 262))
  {
    v66 = 0;
    v67 = 1;
    v68 = MEMORY[0x1E0C81028];
    do
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v69 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v70 = (*v69 ? *v69 : v68);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
        {
          v71 = *(float *)(*((_QWORD *)this + 262) + 4 * v66);
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 209;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v67 - 1;
          *(_WORD *)&buf[24] = 2048;
          *(double *)&buf[26] = v71;
          _os_log_impl(&dword_1B5ED0000, v70, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp>     HW Trim Gain MIC(ch-%d): %f dB", buf, 0x22u);
        }
      }
      v72 = (int *)*((_QWORD *)this + 1570);
      if (v72 && (*v155 || *((_BYTE *)this + 15898)))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v72, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 209, "LogVPParams", "    HW Trim Gain MIC(ch-%d): %f dB", v67 - 1, *(float *)(*((_QWORD *)this + 262) + 4 * v66));
      }
      v66 = v67++;
    }
    while (v66 < (uint64_t)(*((_QWORD *)this + 263) - *((_QWORD *)this + 262)) >> 2);
  }
  if (*((_QWORD *)this + 267) != *((_QWORD *)this + 266))
  {
    v73 = 0;
    v74 = 1;
    v75 = MEMORY[0x1E0C81028];
    do
    {
      if (VPLogScope(void)::once != -1)
        dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
      v76 = (_QWORD *)VPLogScope(void)::scope;
      if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(5, VPLogScope(void)::scope, 0))
      {
        v77 = (*v76 ? *v76 : v75);
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
        {
          v78 = *(float *)(*((_QWORD *)this + 266) + 4 * v73);
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 213;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v74 - 1;
          *(_WORD *)&buf[24] = 2048;
          *(double *)&buf[26] = v78;
          _os_log_impl(&dword_1B5ED0000, v77, OS_LOG_TYPE_DEBUG, "%25s:%-5d  <vp>     HW Trim Gain REF(ch-%d): %f dB", buf, 0x22u);
        }
      }
      v79 = (int *)*((_QWORD *)this + 1570);
      if (v79 && (*v155 || *((_BYTE *)this + 15898)))
      {
        if (VPLogScope(void)::once != -1)
          dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
        CALegacyLog::log(v79, 5, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 213, "LogVPParams", "    HW Trim Gain REF(ch-%d): %f dB", v74 - 1, *(float *)(*((_QWORD *)this + 266) + 4 * v73));
      }
      v73 = v74++;
    }
    while (v73 < (uint64_t)(*((_QWORD *)this + 267) - *((_QWORD *)this + 266)) >> 2);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v80 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v81 = (*v80 ? *v80 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (const AudioStreamBasicDescription *)((char *)this + 984));
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 215;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = *(_QWORD *)v159;
      _os_log_impl(&dword_1B5ED0000, v81, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     VP Output Format: %s", buf, 0x1Cu);
      if (*(_QWORD *)v159)
        free(*(void **)v159);
    }
  }
  v82 = (int *)*((_QWORD *)this + 1570);
  if (v82 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v83 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (const AudioStreamBasicDescription *)((char *)this + 984));
    CALegacyLog::log(v82, 3, v83, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 215, "LogVPParams", "    VP Output Format: %s", *(const char **)buf);
    if (*(_QWORD *)buf)
      free(*(void **)buf);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v84 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v85 = (*v84 ? *v84 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
    {
      v86 = *((_DWORD *)this + 100);
      v87 = *((_DWORD *)this + 101);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 217;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v86;
      *(_WORD *)&buf[24] = 1024;
      *(_DWORD *)&buf[26] = v87;
      _os_log_impl(&dword_1B5ED0000, v85, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     REF Channel BitMap: %x, OUT Channel BitMap: %x", buf, 0x1Eu);
    }
  }
  v88 = (int *)*((_QWORD *)this + 1570);
  if (v88 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v88, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 217, "LogVPParams", "    REF Channel BitMap: %x, OUT Channel BitMap: %x", *((_DWORD *)this + 100), *((_DWORD *)this + 101));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v89 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v90 = (*v89 ? *v89 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
    {
      v91 = *((_QWORD *)this + 54);
      v92 = *((_DWORD *)this + 106);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 219;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = v91;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v92;
      _os_log_impl(&dword_1B5ED0000, v90, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     HW MIC Channels: %s, BitMap: %x", buf, 0x22u);
    }
  }
  v93 = (int *)*((_QWORD *)this + 1570);
  if (v93 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v93, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 219, "LogVPParams", "    HW MIC Channels: %s, BitMap: %x", *((const char **)this + 54), *((_DWORD *)this + 106));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v94 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v95 = (*v94 ? *v94 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
    {
      v96 = *((_QWORD *)this + 57);
      v97 = *((_DWORD *)this + 112);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 221;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = v96;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v97;
      _os_log_impl(&dword_1B5ED0000, v95, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     EP MIC Channels: %s, BitMap: %x", buf, 0x22u);
    }
  }
  v98 = (int *)*((_QWORD *)this + 1570);
  if (v98 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v98, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 221, "LogVPParams", "    EP MIC Channels: %s, BitMap: %x", *((const char **)this + 57), *((_DWORD *)this + 112));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v99 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v100 = (*v99 ? *v99 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
    {
      v101 = 0;
      while (((*((_DWORD *)this + 116) >> v101) & 1) == 0)
      {
        if (++v101 == 32)
        {
          v101 = 33;
          break;
        }
      }
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 223;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v101;
      _os_log_impl(&dword_1B5ED0000, v100, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Primary epmic index: %d", buf, 0x18u);
    }
  }
  v102 = (int *)*((_QWORD *)this + 1570);
  if (v102 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v103 = 0;
    while (((*((_DWORD *)this + 116) >> v103) & 1) == 0)
    {
      if (++v103 == 32)
      {
        v103 = 33;
        break;
      }
    }
    CALegacyLog::log(v102, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 223, "LogVPParams", "    Primary epmic index: %d", v103);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v104 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v105 = (*v104 ? *v104 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
    {
      v106 = *((_DWORD *)this + 1112);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 225;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v106;
      _os_log_impl(&dword_1B5ED0000, v105, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     SRC Quality: 0x%x (0:min, 0x20:low, 0x40:med, 0x60:hig, 0x7f:max)", buf, 0x18u);
    }
  }
  v107 = (int *)*((_QWORD *)this + 1570);
  if (v107 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v107, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 225, "LogVPParams", "    SRC Quality: 0x%x (0:min, 0x20:low, 0x40:med, 0x60:hig, 0x7f:max)", *((_DWORD *)this + 1112));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v108 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v109 = (*v108 ? *v108 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
    {
      v110 = *((float *)this + 1111);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 226;
      *(_WORD *)&buf[18] = 2048;
      *(double *)&buf[20] = v110;
      _os_log_impl(&dword_1B5ED0000, v109, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Hw real-world correction: %f samples", buf, 0x1Cu);
    }
  }
  v111 = (int *)*((_QWORD *)this + 1570);
  if (v111 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v111, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 226, "LogVPParams", "    Hw real-world correction: %f samples", *((float *)this + 1111));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v112 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v113 = (*v112 ? *v112 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
    {
      v114 = *((float *)this + 1092);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 227;
      *(_WORD *)&buf[18] = 2048;
      *(double *)&buf[20] = v114;
      _os_log_impl(&dword_1B5ED0000, v113, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Ref-Mic Delay: %f msec", buf, 0x1Cu);
    }
  }
  v115 = (int *)*((_QWORD *)this + 1570);
  if (v115 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v115, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 227, "LogVPParams", "    Ref-Mic Delay: %f msec", *((float *)this + 1092));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v116 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v117 = (*v116 ? *v116 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
    {
      v118 = *((float *)this + 1090);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 228;
      *(_WORD *)&buf[18] = 2048;
      *(double *)&buf[20] = v118;
      _os_log_impl(&dword_1B5ED0000, v117, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Pre-echo-processing Digital Input Gain: %f dB", buf, 0x1Cu);
    }
  }
  v119 = (int *)*((_QWORD *)this + 1570);
  if (v119 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v119, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 228, "LogVPParams", "    Pre-echo-processing Digital Input Gain: %f dB", *((float *)this + 1090));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v120 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v121 = (*v120 ? *v120 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
    {
      v122 = *((float *)this + 1091);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 229;
      *(_WORD *)&buf[18] = 2048;
      *(double *)&buf[20] = v122;
      _os_log_impl(&dword_1B5ED0000, v121, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Post-echo-processing Digital Input Gain: %f dB", buf, 0x1Cu);
    }
  }
  v123 = (int *)*((_QWORD *)this + 1570);
  if (v123 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v123, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 229, "LogVPParams", "    Post-echo-processing Digital Input Gain: %f dB", *((float *)this + 1091));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v124 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v125 = (*v124 ? *v124 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
    {
      v126 = *((float *)this + 1113);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 233;
      *(_WORD *)&buf[18] = 2048;
      *(double *)&buf[20] = v126;
      _os_log_impl(&dword_1B5ED0000, v125, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Downlink Mix Gain: %f dB", buf, 0x1Cu);
    }
  }
  v127 = (int *)*((_QWORD *)this + 1570);
  if (v127 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v127, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 233, "LogVPParams", "    Downlink Mix Gain: %f dB", *((float *)this + 1113));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v128 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v129 = (*v128 ? *v128 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
    {
      v130 = *((float *)this + 1129);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 234;
      *(_WORD *)&buf[18] = 2048;
      *(double *)&buf[20] = v130;
      _os_log_impl(&dword_1B5ED0000, v129, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Downlink Final Gain Chn 0: %f dB", buf, 0x1Cu);
    }
  }
  v131 = (int *)*((_QWORD *)this + 1570);
  if (v131 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v131, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 234, "LogVPParams", "    Downlink Final Gain Chn 0: %f dB", *((float *)this + 1129));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v132 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v133 = (*v132 ? *v132 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
    {
      v134 = *((float *)this + 1130);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 235;
      *(_WORD *)&buf[18] = 2048;
      *(double *)&buf[20] = v134;
      _os_log_impl(&dword_1B5ED0000, v133, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     Downlink Final Gain Chn 1: %f dB", buf, 0x1Cu);
    }
  }
  v135 = (int *)*((_QWORD *)this + 1570);
  if (v135 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v135, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 235, "LogVPParams", "    Downlink Final Gain Chn 1: %f dB", *((float *)this + 1130));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v136 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v137 = (*v136 ? *v136 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (VoiceProcessorV2 *)((char *)this + 208));
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 236;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = *(_QWORD *)v159;
      _os_log_impl(&dword_1B5ED0000, v137, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     DL Format FEV: %s", buf, 0x1Cu);
      if (*(_QWORD *)v159)
        free(*(void **)v159);
    }
  }
  v138 = (int *)*((_QWORD *)this + 1570);
  if (v138 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v139 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (VoiceProcessorV2 *)((char *)this + 208));
    CALegacyLog::log(v138, 3, v139, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 236, "LogVPParams", "    DL Format FEV: %s", *(const char **)buf);
    if (*(_QWORD *)buf)
      free(*(void **)buf);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v140 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v141 = (*v140 ? *v140 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (VoiceProcessorV2 *)((char *)this + 288));
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 237;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = *(_QWORD *)v159;
      _os_log_impl(&dword_1B5ED0000, v141, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     DL Format FEV Process: %s", buf, 0x1Cu);
      if (*(_QWORD *)v159)
        free(*(void **)v159);
    }
  }
  v142 = (int *)*((_QWORD *)this + 1570);
  if (v142 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v143 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (VoiceProcessorV2 *)((char *)this + 288));
    CALegacyLog::log(v142, 3, v143, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 237, "LogVPParams", "    DL Format FEV Process: %s", *(const char **)buf);
    if (*(_QWORD *)buf)
      free(*(void **)buf);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v144 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v145 = (*v144 ? *v144 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
    {
      CAFormatter::CAFormatter((CAFormatter *)v159, (VoiceProcessorV2 *)((char *)this + 328));
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 238;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = *(_QWORD *)v159;
      _os_log_impl(&dword_1B5ED0000, v145, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     DL Format MIX: %s", buf, 0x1Cu);
      if (*(_QWORD *)v159)
        free(*(void **)v159);
    }
  }
  v146 = (int *)*((_QWORD *)this + 1570);
  if (v146 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    v147 = VPLogScope(void)::scope;
    CAFormatter::CAFormatter((CAFormatter *)buf, (VoiceProcessorV2 *)((char *)this + 328));
    CALegacyLog::log(v146, 3, v147, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 238, "LogVPParams", "    DL Format MIX: %s", *(const char **)buf);
    if (*(_QWORD *)buf)
      free(*(void **)buf);
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v148 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v149 = (*v148 ? *v148 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
    {
      v150 = *((_DWORD *)this + 121);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 239;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v150;
      _os_log_impl(&dword_1B5ED0000, v149, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp>     DL Block Size MIX: %d", buf, 0x18u);
    }
  }
  v151 = (int *)*((_QWORD *)this + 1570);
  if (v151 && (*v155 || *((_BYTE *)this + 15898)))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v151, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 239, "LogVPParams", "    DL Block Size MIX: %d", *((_DWORD *)this + 121));
  }
  if (VPLogScope(void)::once != -1)
    dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
  v152 = (_QWORD *)VPLogScope(void)::scope;
  if (VPLogScope(void)::scope && CALegacyLog::LogEnabled(3, VPLogScope(void)::scope, 0))
  {
    v153 = (*v152 ? *v152 : MEMORY[0x1E0C81028]);
    if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "vpDebug_Logging.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 241;
      _os_log_impl(&dword_1B5ED0000, v153, OS_LOG_TYPE_DEFAULT, "%25s:%-5d  <vp> ____________logparams:end___________", buf, 0x12u);
    }
  }
  v154 = (int *)*((_QWORD *)this + 1570);
  if (v154 && (*v155 || v155[1]))
  {
    if (VPLogScope(void)::once != -1)
      dispatch_once(&VPLogScope(void)::once, &__block_literal_global_19930);
    CALegacyLog::log(v154, 3, VPLogScope(void)::scope, "/Library/Caches/com.apple.xbs/Sources/AudioDSP_darwinOS/Source/AudioDSP/VoiceProcessor/VoiceProcessor_v2/vpDebugFeatures/vpDebug_Logging.cpp", 241, "LogVPParams", "____________logparams:end___________");
  }
}

void sub_1B61814DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a17)
    free(a17);
  _Unwind_Resume(exception_object);
}

void AUSpatialMixerV2::~AUSpatialMixerV2(AUSpatialMixerV2 *this)
{
  AUSpatialMixerV2::~AUSpatialMixerV2(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  NSObject *v3;
  NSObject *v4;
  _QWORD *v5;
  IR::IRProcessor *v6;
  uint64_t v7;
  const void *v8;
  const void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  _QWORD block[5];
  _BYTE buf[12];
  __int16 v32;
  const char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E69CA230;
  *((_QWORD *)this + 66) = &unk_1E69CA4A8;
  atomic_store(1u, (unsigned __int8 *)this + 2864);
  __dmb(0xBu);
  v2 = (void *)*((_QWORD *)this + 356);
  applesauce::dispatch::v1::queue::get(v2);
  v3 = objc_claimAutoreleasedReturnValue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN16AUSpatialMixerV2D2Ev_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_sync(v3, block);

  std::__lock_first<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,std::shared_mutex>(0, (uint64_t)this + 3304, (uint64_t)this + 3320, (std::__shared_mutex_base *)((char *)this + 3352));
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v4 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v5 = (_QWORD *)*v5;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v5;
    v32 = 2080;
    v33 = "~AUSpatialMixerV2";
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "[%s|%s] Instance is being destructed.", buf, 0x16u);
  }

  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3304);
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3320);
  std::__shared_mutex_base::unlock((std::__shared_mutex_base *)((char *)this + 3352));
  *(_QWORD *)buf = (char *)this + 15120;
  std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  *(_QWORD *)buf = (char *)this + 15096;
  std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  v6 = (AUSpatialMixerV2 *)((char *)this + 14624);
  v7 = -7296;
  do
  {
    if (*((_BYTE *)v6 + 448))
      IR::IRProcessor::~IRProcessor(v6);
    v6 = (IR::IRProcessor *)((char *)v6 - 456);
    v7 += 456;
  }
  while (v7);
  IR::IRDataAttributes::~IRDataAttributes((AUSpatialMixerV2 *)((char *)this + 7632));
  IR::IRDataAttributes::~IRDataAttributes((AUSpatialMixerV2 *)((char *)this + 7480));
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)this + 932, 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)this + 931, 0);
  MEMORY[0x1BCC9511C]((char *)this + 7408);
  std::unique_ptr<AUSpatialMixerV2DynamicXTCFilter>::reset[abi:ne180100]((uint64_t *)this + 925, 0);
  AUSM::SoundStage::~SoundStage((AUSpatialMixerV2 *)((char *)this + 6912));
  AUSM::SoundStage::~SoundStage((AUSpatialMixerV2 *)((char *)this + 6336));
  std::unique_ptr<AUSM::RoomCongruence::Processor>::reset[abi:ne180100]((uint64_t *)this + 791, 0);
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)this + 6280);
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)this + 6240);
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)this + 6200);
  if (*((char *)this + 6191) < 0)
    operator delete(*((void **)this + 771));
  AUSM::GlobalProperties::~GlobalProperties((AUSpatialMixerV2 *)((char *)this + 3584));
  *(_QWORD *)buf = (char *)this + 3560;
  std::vector<std::unique_ptr<AUSM::AUFXWrapper>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 3520);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 3464));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 3416));
  std::mutex::~mutex((std::mutex *)((char *)this + 3352));
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*((_QWORD **)this + 409));
  v8 = (const void *)*((_QWORD *)this + 407);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 406);
  if (v9)
    CFRelease(v9);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 3224);
  std::unique_ptr<TorqueEngine>::reset[abi:ne180100]((void ***)this + 401, 0);
  v10 = (void *)*((_QWORD *)this + 387);
  if (v10)
  {
    *((_QWORD *)this + 388) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 384);
  if (v11)
  {
    *((_QWORD *)this + 385) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 381);
  if (v12)
  {
    *((_QWORD *)this + 382) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 377);
  if (v13)
  {
    *((_QWORD *)this + 378) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 374);
  if (v14)
  {
    *((_QWORD *)this + 375) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 371);
  if (v15)
  {
    *((_QWORD *)this + 372) = v15;
    operator delete(v15);
  }
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)this + 370, 0);
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)this + 369, 0);
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)this + 368, 0);
  v16 = *((_QWORD *)this + 363);
  *((_QWORD *)this + 363) = 0;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  v17 = (void *)*((_QWORD *)this + 360);
  if (v17)
  {
    *((_QWORD *)this + 361) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 357);
  *((_QWORD *)this + 357) = 0;

  v19 = (void *)*((_QWORD *)this + 356);
  *((_QWORD *)this + 356) = 0;

  v20 = (void *)*((_QWORD *)this + 353);
  if (v20)
  {
    *((_QWORD *)this + 354) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 346);
  if (v21)
  {
    *((_QWORD *)this + 347) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 339);
  if (v22)
  {
    *((_QWORD *)this + 340) = v22;
    operator delete(v22);
  }
  v23 = (void *)*((_QWORD *)this + 333);
  if (v23)
  {
    *((_QWORD *)this + 334) = v23;
    operator delete(v23);
  }
  v24 = (void *)*((_QWORD *)this + 327);
  if (v24)
  {
    *((_QWORD *)this + 328) = v24;
    operator delete(v24);
  }
  *(_QWORD *)buf = (char *)this + 2584;
  std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  IR::SharedIRBuses::~SharedIRBuses((AUSpatialMixerV2 *)((char *)this + 2328));
  v25 = (void *)*((_QWORD *)this + 284);
  if (v25)
  {
    *((_QWORD *)this + 285) = v25;
    operator delete(v25);
  }
  v26 = *((_QWORD *)this + 281);
  *((_QWORD *)this + 281) = 0;
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
  v27 = (void *)*((_QWORD *)this + 275);
  if (v27)
  {
    *((_QWORD *)this + 276) = v27;
    operator delete(v27);
  }
  v28 = 1152;
  do
  {
    v29 = *(void **)((char *)this + v28 + 952);
    if (v29)
    {
      *(_QWORD *)((char *)this + v28 + 960) = v29;
      operator delete(v29);
    }
    v28 -= 72;
  }
  while (v28);
  AUScopeDynamic::~AUScopeDynamic((AUSpatialMixerV2 *)((char *)this + 776));
  std::unique_ptr<AUSM::Metadata>::reset[abi:ne180100]((uint64_t *)this + 96, 0);
  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)this + 11);
  if (*((_BYTE *)this + 696))
    IR::IRDataAttributes::~IRDataAttributes((AUSpatialMixerV2 *)((char *)this + 544));
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUSpatialMixerV2::Initialize(AUSpatialMixerV2 *this)
{
  unsigned __int8 v2;
  char *v3;
  NSObject *v4;
  NSObject *v5;
  os_signpost_id_t v6;
  _QWORD *v7;
  void *v8;
  NSObject *v9;
  int AppBooleanValue;
  void *v11;
  dev_t v12;
  NSObject *v13;
  unsigned int v14;
  NSObject *v15;
  NSObject *v16;
  _QWORD *v18;
  uint64_t v19;
  unsigned __int8 v20;
  int64x2_t *v21;
  NSObject *v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  std::vector<char> *v26;
  uint64_t v27;
  _DWORD *begin;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  __darwin_ino64_t st_ino;
  _QWORD *v35;
  _QWORD *v36;
  __int128 v37;
  int64x2_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  _QWORD *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  NSObject *v60;
  NSObject *v61;
  APAC::Metadata *v62;
  unsigned __int8 v63;
  std::__shared_weak_count *v64;
  __int128 *v65;
  timespec v66;
  __int128 v67;
  std::__shared_weak_count *size;
  unint64_t *p_shared_owners;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  __int128 v74;
  unint64_t *v75;
  unint64_t v76;
  std::__shared_weak_count *v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  AUSpatialMixerV2OrientationObserver *v81;
  unsigned int v82;
  NSObject *v83;
  unsigned int v84;
  _BOOL4 v85;
  uint64_t v86;
  std::__shared_weak_count *v87;
  std::__shared_weak_count *v88;
  unint64_t *v89;
  unint64_t v90;
  unint64_t *p_shared_weak_owners;
  unint64_t v92;
  unint64_t v93;
  Float64 mSampleRate;
  int v95;
  const std::string::value_type *v96;
  std::string::size_type v97;
  std::string *v98;
  const UInt8 *v99;
  unsigned int v100;
  void **v101;
  const UInt8 *v102;
  CFIndex v103;
  CFStringRef v104;
  const void *v105;
  uint64_t v106;
  std::__shared_weak_count *v107;
  unint64_t *v108;
  unint64_t v109;
  unint64_t *v110;
  unint64_t v111;
  void *v112;
  NSObject *v113;
  unsigned __int8 v114;
  NSObject *v115;
  __int128 v116;
  std::__shared_weak_count *v117;
  unint64_t *v118;
  unint64_t v119;
  std::__shared_weak_count *v120;
  unint64_t *v121;
  unint64_t v122;
  unsigned int v123;
  unsigned __int8 v124;
  int AppIntegerValue;
  int v126;
  char v128;
  int v129;
  NSObject *v130;
  NSObject *v131;
  NSObject *v132;
  void *v133;
  NSObject *v134;
  dispatch_time_t v135;
  NSObject *v136;
  void *v137;
  NSObject *v138;
  void *v139;
  NSObject *v140;
  float v141;
  uint64_t v142;
  float v143;
  float v144;
  float v145;
  unsigned int v146;
  uint64_t v147;
  uint64_t v148;
  unsigned int v149;
  uint64_t Element;
  uint64_t v151;
  uint64_t v152;
  unsigned int v153;
  unsigned int v154;
  AUSpatialMixerV2InputElement *v155;
  unsigned int UncompensatedLatencyFrames;
  unsigned int v157;
  AUSpatialMixerV2InputElement *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unsigned int v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  _DWORD *v166;
  unint64_t v167;
  _DWORD *v168;
  unint64_t v169;
  int8x16_t v170;
  unsigned __int8 v171;
  int v172;
  IIRFilterFloat32 *v173;
  uint64_t v174;
  int8x16_t v175;
  unsigned __int8 v176;
  char v177;
  Float64 v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  unint64_t v183;
  uint64_t v184;
  _QWORD *v185;
  Float64 *v186;
  unint64_t v187;
  _QWORD *v188;
  _QWORD *v189;
  _QWORD *v190;
  uint64_t v191;
  int64x2_t v192;
  Float64 v193;
  uint64_t v194;
  char v195;
  Float64 v196;
  uint64_t v197;
  uint64_t v198;
  unint64_t v199;
  uint64_t v200;
  unint64_t v201;
  uint64_t v202;
  Float64 *v203;
  unint64_t v204;
  _QWORD *v205;
  _QWORD *v206;
  _QWORD *v207;
  uint64_t v208;
  int64x2_t v209;
  Float64 v210;
  uint64_t v211;
  uint64_t v212;
  __int128 v213;
  uint64_t v214;
  AUSM::AUFXWrapper **v215;
  AUSM::AUFXWrapper **v216;
  OpaqueAudioComponentInstance **v217;
  AUSM::AUFXWrapper *v218;
  OpaqueAudioComponentInstance *v219;
  dev_t v220;
  OSStatus v221;
  NSObject *v222;
  NSObject *v223;
  NSObject *v224;
  AUSM::AUFXWrapper *v225;
  OpaqueAudioComponentInstance *v226;
  OSStatus v227;
  NSObject *v228;
  NSObject *v229;
  char *v230;
  void **v231;
  std::string::size_type v232;
  std::string *v233;
  __int128 v234;
  std::string *v235;
  __int128 v236;
  Float64 v237;
  std::string::size_type mFramesPerPacket_high;
  std::string *v239;
  __int128 v240;
  std::string *v241;
  char *v242;
  _QWORD *v243;
  OpaqueAudioComponentInstance *v244;
  dev_t v245;
  NSObject *v246;
  dev_t v247;
  NSObject *v248;
  std::string *v249;
  _QWORD *v250;
  std::string *v251;
  _QWORD *v252;
  char *v253;
  _QWORD *v254;
  _QWORD *v255;
  char *v256;
  _QWORD *v257;
  _QWORD *v258;
  AUSM::AUFXWrapper **v259;
  AUSM::AUFXWrapper **v260;
  AUSM::AUFXWrapper **v261;
  AUSM::AUFXWrapper **v262;
  _QWORD *v263;
  AUSM::AUFXWrapper *v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  unint64_t v268;
  uint64_t v269;
  AUSM::AUFXWrapper **v270;
  unint64_t v271;
  AUSM::AUFXWrapper *v272;
  _QWORD *v273;
  _QWORD *v274;
  AUSM::AUFXWrapper *v275;
  int64x2_t v276;
  uint64_t v277;
  const void *v278;
  float *v279;
  Float64 v280;
  int v281;
  void **v282;
  _OWORD *v283;
  int v284;
  void **v285;
  Float64 v286;
  uint64_t v287;
  uint64_t v288;
  const __CFURL *v289;
  uint64_t v290;
  int v291;
  int v292;
  int v293;
  _BOOL4 v294;
  _BOOL4 v295;
  _BOOL4 v296;
  uint64_t v297;
  uint64x2_t v298;
  uint64_t v299;
  float32x2_t v300;
  int32x2_t v301;
  float32x2_t v302;
  float v303;
  uint64_t v304;
  uint64x2_t v305;
  int32x4_t v306;
  uint64x2_t v312;
  uint64_t v314;
  int8x16_t v315;
  float32x4_t v316;
  int8x16_t v317;
  float32x4_t v318;
  int8x16_t v319;
  int8x16_t v320;
  float32x4_t v321;
  float32x4_t v322;
  int8x16_t v323;
  int8x16_t v324;
  int32x4_t v325;
  int8x16_t v326;
  float32x4_t v327;
  float v328;
  float32x4_t v329;
  float v330;
  float32x4_t v331;
  float32x4_t v332;
  float32x4_t v333;
  float32x4_t v334;
  float32x4_t v335;
  float32x4_t v336;
  int16x4_t v337;
  int32x4_t v338;
  uint64_t v339;
  vDSP_DFT_SetupStruct *v340;
  vDSP_Length v341;
  vDSP_DFT_SetupStruct *v342;
  uint64_t v343;
  uint64_t v344;
  unint64_t v345;
  float v346;
  uint64x2_t v347;
  int32x2_t v348;
  float v349;
  float v350;
  NSObject *v351;
  int v352;
  int v353;
  CFDictionaryRef CFDictionaryRef;
  uint64_t v355;
  const void *v356;
  const void *v357;
  NSObject *v358;
  NSObject *v359;
  os_signpost_id_t v360;
  _QWORD *v361;
  _QWORD *v362;
  unsigned int v363;
  const char *v364;
  _QWORD *v365;
  _QWORD *v366;
  _QWORD *v367;
  _QWORD *v368;
  NSObject *v369;
  os_signpost_id_t v370;
  AUSM::Messenger *v371;
  std::runtime_error *v372;
  std::runtime_error *exception;
  uint64_t v374;
  float32x4_t v375;
  float32x4_t v376;
  int64x2_t v377;
  float32x4_t v378;
  float32x4_t v379;
  float32x4_t v380;
  uint64x2_t v381;
  int8x16_t v382;
  int32x4_t v383;
  int8x16_t v384;
  int32x4_t v385;
  int8x16_t v386;
  int64x2_t v387;
  int64x2_t v388;
  char *v389;
  uint64x2_t v390;
  int32x4_t v391;
  float v392;
  int64x2_t v393;
  int8x16_t v394;
  char **v395;
  float v396;
  float32x4_t v397;
  int8x16_t v398;
  unsigned __int8 v399;
  float v400;
  float32x4_t v401;
  float32x4_t v402;
  int64x2_t *v403;
  int64x2_t v404;
  float32x4_t v405;
  CFURLRef v406;
  Float64 v407;
  Float64 v408;
  CFTypeRef v409;
  _QWORD handler[5];
  Boolean v411;
  Boolean v412;
  Boolean v413;
  uint64_t v414[2];
  CFTypeRef v415;
  Boolean keyExistsAndHasValidFormat;
  void *__p[2];
  unsigned __int8 v418;
  CFTypeRef cf;
  void *inData[3];
  AudioStreamBasicDescription __x;
  int64x2_t v422;
  _QWORD v423[2];
  std::string v424;
  _QWORD v425[7];
  _QWORD v426[7];
  AudioStreamBasicDescription v427;
  stat buf;
  uint64_t v429;

  v429 = *MEMORY[0x1E0C80C00];
  v3 = (char *)&xmmword_1EF135FF8 + 8;
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v369 = (id)getAUSMV2Log(void)::gLog;
    v370 = os_signpost_id_generate(v369);

    AUSpatialMixerV2::Initialize(void)::spid = v370;
    v3 = (_BYTE *)(&xmmword_1EF135FF8 + 8);
  }
  if (*((_QWORD *)v3 + 229) != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v4 = (id)getAUSMV2Log(void)::gLog;
  v5 = v4;
  v6 = AUSpatialMixerV2::Initialize(void)::spid;
  if ((unint64_t)(AUSpatialMixerV2::Initialize(void)::spid - 1) <= 0xFFFFFFFFFFFFFFFDLL
    && os_signpost_enabled(v4))
  {
    v7 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v7 = (_QWORD *)*v7;
    buf.st_dev = 136315138;
    *(_QWORD *)&buf.st_mode = v7;
    _os_signpost_emit_with_name_impl(&dword_1B5ED0000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v6, "AUSM_INIT_EVENT", "%s", (uint8_t *)&buf, 0xCu);
  }

  v374 = mach_absolute_time();
  atomic_store(1u, (unsigned __int8 *)this + 2864);
  __dmb(0xBu);
  v8 = (void *)*((_QWORD *)this + 356);
  applesauce::dispatch::v1::queue::get(v8);
  v9 = objc_claimAutoreleasedReturnValue();
  dispatch_sync(v9, &__block_literal_global_2581);

  keyExistsAndHasValidFormat = 0;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("ausm_all_features"), CFSTR("com.apple.coreaudio"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat && AppBooleanValue)
  {
    v425[0] = CFSTR("SourceExtent");
    v425[1] = kOptionalFeatureSourceDiffuse;
    v426[0] = MEMORY[0x1E0C9AAB0];
    v426[1] = MEMORY[0x1E0C9AAB0];
    v425[2] = CFSTR("SourceDivergence");
    v425[3] = CFSTR("SourceDirectivity");
    v426[2] = MEMORY[0x1E0C9AAB0];
    v426[3] = MEMORY[0x1E0C9AAB0];
    v425[4] = CFSTR("NearFieldHOA");
    v425[5] = CFSTR("NearFieldHRTF");
    v426[4] = MEMORY[0x1E0C9AAB0];
    v426[5] = MEMORY[0x1E0C9AAB0];
    v425[6] = CFSTR("EnableAPACRoomPresets");
    v426[6] = MEMORY[0x1E0C9AAB0];
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v426, v425, 7);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_QWORD *)&__x.mSampleRate = v11;
    v12 = (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, AudioStreamBasicDescription *, uint64_t))(*(_QWORD *)this + 96))(this, 3279, 0, 0, &__x, 8);
    if (v12)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v13 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v361 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v361 = (_QWORD *)*v361;
        buf.st_dev = 136315650;
        *(_QWORD *)&buf.st_mode = v361;
        WORD2(buf.st_ino) = 2080;
        *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"Initialize";
        HIWORD(buf.st_gid) = 1024;
        buf.st_rdev = v12;
        _os_log_error_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_ERROR, "[%s|%s] Could not enable all features (user defaults), err = %d", (uint8_t *)&buf, 0x1Cu);
      }

    }
  }
  v403 = (int64x2_t *)((char *)this + 3560);
  atomic_store(1u, (unsigned __int8 *)this + 7441);
  __dmb(0xBu);
  v14 = *((_DWORD *)this + 84);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v15 = (id)getAUSMV2Log(void)::gLog;
  v16 = v15;
  if (v14 > 0x10000)
  {
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v185 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v185 = (_QWORD *)*v185;
      buf.st_dev = 136315650;
      *(_QWORD *)&buf.st_mode = v185;
      WORD2(buf.st_ino) = 2080;
      *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"Initialize";
      HIWORD(buf.st_gid) = 1024;
      buf.st_rdev = v14;
      _os_log_error_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_ERROR, "[%s|%s] Too large max frames per slice: %u", (uint8_t *)&buf, 0x1Cu);
    }

    return 4294956421;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    v18 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v18 = (_QWORD *)*v18;
    buf.st_dev = 136315650;
    *(_QWORD *)&buf.st_mode = v18;
    WORD2(buf.st_ino) = 2080;
    *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"Initialize";
    HIWORD(buf.st_gid) = 1024;
    buf.st_rdev = v14;
    _os_log_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEFAULT, "[%s|%s] Initializing with max frames per slice = %u", (uint8_t *)&buf, 0x1Cu);
  }

  v19 = *((_QWORD *)this + 96);
  v20 = atomic_load((unsigned __int8 *)(v19 + 96));
  if ((v20 & 1) != 0)
  {
    v21 = (int64x2_t *)(v19 + 32);
    if (*(_QWORD *)(v19 + 40) != *(_QWORD *)(v19 + 32) || *(_QWORD *)(v19 + 64) != *(_QWORD *)(v19 + 56))
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v22 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v366 = (_QWORD *)(v19 + 104);
        if (*(char *)(v19 + 127) < 0)
          v366 = (_QWORD *)*v366;
        buf.st_dev = 136315394;
        *(_QWORD *)&buf.st_mode = v366;
        WORD2(buf.st_ino) = 2080;
        *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"initialize";
        _os_log_error_impl(&dword_1B5ED0000, v22, OS_LOG_TYPE_ERROR, "[%s|%s] Cleanup was not done appropriately (1)", (uint8_t *)&buf, 0x16u);
      }

      std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)(v19 + 32));
      *(_QWORD *)(v19 + 64) = *(_QWORD *)(v19 + 56);
    }
    if (*(_DWORD *)(*(_QWORD *)(v19 + 16) + 32))
    {
      v23 = 0;
      do
      {
        v24 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(*(_QWORD *)v19 + 80), v23) + 108);
        v26 = *(std::vector<char> **)(v19 + 40);
        v25 = *(_QWORD *)(v19 + 48);
        if ((unint64_t)v26 >= v25)
        {
          v29 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v26 - v21->i64[0]) >> 3);
          v30 = v29 + 1;
          if (v29 + 1 > 0xAAAAAAAAAAAAAAALL)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - v21->i64[0]) >> 3);
          if (2 * v31 > v30)
            v30 = 2 * v31;
          if (v31 >= 0x555555555555555)
            v32 = 0xAAAAAAAAAAAAAAALL;
          else
            v32 = v30;
          buf.st_atimespec.tv_sec = v19 + 48;
          if (v32)
          {
            if (v32 > 0xAAAAAAAAAAAAAAALL)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v33 = (char *)operator new(24 * v32);
          }
          else
          {
            v33 = 0;
          }
          *(_QWORD *)&buf.st_dev = v33;
          buf.st_ino = (__darwin_ino64_t)&v33[24 * v29];
          *(_QWORD *)&buf.st_uid = buf.st_ino;
          *(_QWORD *)&buf.st_rdev = &v33[24 * v32];
          LOBYTE(__x.mSampleRate) = 0;
          *(_DWORD *)std::vector<char>::vector((std::vector<char> *)buf.st_ino, (16 * v24) | 8, (const std::vector<char>::value_type *)&__x)->__begin_ = v24;
          st_ino = buf.st_ino;
          v27 = *(_QWORD *)&buf.st_uid + 24;
          *(_QWORD *)&buf.st_uid += 24;
          v36 = *(_QWORD **)(v19 + 32);
          v35 = *(_QWORD **)(v19 + 40);
          if (v35 == v36)
          {
            v38 = vdupq_n_s64((unint64_t)v35);
          }
          else
          {
            do
            {
              *(_QWORD *)(st_ino - 24) = 0;
              *(_QWORD *)(st_ino - 16) = 0;
              st_ino -= 24;
              *(_QWORD *)(st_ino + 16) = 0;
              v37 = *(_OWORD *)(v35 - 3);
              v35 -= 3;
              *(_OWORD *)st_ino = v37;
              *(_QWORD *)(st_ino + 16) = v35[2];
              *v35 = 0;
              v35[1] = 0;
              v35[2] = 0;
            }
            while (v35 != v36);
            v38 = *v21;
            v27 = *(_QWORD *)&buf.st_uid;
          }
          *(_QWORD *)(v19 + 32) = st_ino;
          *(_QWORD *)(v19 + 40) = v27;
          *(int64x2_t *)&buf.st_ino = v38;
          v39 = *(_QWORD *)(v19 + 48);
          *(_QWORD *)(v19 + 48) = *(_QWORD *)&buf.st_rdev;
          *(_QWORD *)&buf.st_rdev = v39;
          *(_QWORD *)&buf.st_dev = v38.i64[0];
          std::__split_buffer<std::vector<unsigned int>>::~__split_buffer((uint64_t)&buf);
        }
        else
        {
          LOBYTE(buf.st_dev) = 0;
          std::vector<char>::vector(v26, (16 * v24) | 8, (const std::vector<char>::value_type *)&buf);
          begin = v26->__begin_;
          v27 = (uint64_t)&v26[1];
          *begin = v24;
          *(_QWORD *)(v19 + 40) = v27;
        }
        *(_QWORD *)(v19 + 40) = v27;
        v40 = *(_QWORD *)(v27 - 24);
        v42 = *(_QWORD **)(v19 + 64);
        v41 = *(_QWORD *)(v19 + 72);
        if ((unint64_t)v42 >= v41)
        {
          v44 = *(_QWORD *)(v19 + 56);
          v45 = ((uint64_t)v42 - v44) >> 3;
          if ((unint64_t)(v45 + 1) >> 61)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          v46 = v41 - v44;
          v47 = v46 >> 2;
          if (v46 >> 2 <= (unint64_t)(v45 + 1))
            v47 = v45 + 1;
          if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8)
            v48 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v48 = v47;
          if (v48)
            v48 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v48);
          else
            v49 = 0;
          v50 = (_QWORD *)(v48 + 8 * v45);
          *v50 = v40;
          v43 = v50 + 1;
          v52 = *(char **)(v19 + 56);
          v51 = *(char **)(v19 + 64);
          if (v51 != v52)
          {
            do
            {
              v53 = *((_QWORD *)v51 - 1);
              v51 -= 8;
              *--v50 = v53;
            }
            while (v51 != v52);
            v51 = *(char **)(v19 + 56);
          }
          *(_QWORD *)(v19 + 56) = v50;
          *(_QWORD *)(v19 + 64) = v43;
          *(_QWORD *)(v19 + 72) = v48 + 8 * v49;
          if (v51)
            operator delete(v51);
        }
        else
        {
          *v42 = v40;
          v43 = v42 + 1;
        }
        *(_QWORD *)(v19 + 64) = v43;
        ++v23;
      }
      while (v23 < *(_DWORD *)(*(_QWORD *)(v19 + 16) + 32));
    }
    if (*(_QWORD *)(v19 + 88))
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v54 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        v368 = (_QWORD *)(v19 + 104);
        if (*(char *)(v19 + 127) < 0)
          v368 = (_QWORD *)*v368;
        buf.st_dev = 136315394;
        *(_QWORD *)&buf.st_mode = v368;
        WORD2(buf.st_ino) = 2080;
        *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"initialize";
        _os_log_error_impl(&dword_1B5ED0000, v54, OS_LOG_TYPE_ERROR, "[%s|%s] Cleanup was not done appropriately (2)", (uint8_t *)&buf, 0x16u);
      }

    }
    v55 = operator new();
    *(_DWORD *)v55 = 0;
    *(_OWORD *)(v55 + 8) = 0u;
    *(_OWORD *)(v55 + 24) = 0u;
    *(_OWORD *)(v55 + 40) = 0u;
    *(_QWORD *)(v55 + 56) = 0;
    LOBYTE(buf.st_dev) = 0;
    std::vector<char>::vector((std::vector<char> *)(v55 + 64), 8uLL, (const std::vector<char>::value_type *)&buf);
    **(_DWORD **)(v55 + 64) = 0;
    *(_DWORD *)(v55 + 88) = 0;
    v56 = *(_QWORD **)(v19 + 88);
    *(_QWORD *)(v19 + 88) = v55;
    if (v56)
      std::default_delete<AUSM::InputABLBuffer>::operator()[abi:ne180100](v56);
    v57 = *(unsigned int *)(v19 + 80);
    *(_DWORD *)v55 = v57;
    *(_QWORD *)&buf.st_dev = 0x40E5888000000000;
    *(_OWORD *)&buf.st_ino = xmmword_1B66A0840;
    buf.st_rdev = 4;
    *(&buf.st_rdev + 1) = v57;
    buf.st_atimespec.tv_sec = 32;
    v58 = ExtendedAudioBufferList_CreateWithFormat();
    std::unique_ptr<ExtendedAudioBufferList,std::integral_constant<void (*)(ExtendedAudioBufferList*),&(ExtendedAudioBufferList_Destroy)>>::reset[abi:ne180100]((uint64_t *)(v55 + 32), v58);
    v59 = *(_QWORD *)(v55 + 32);
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v60 = (id)getAUSMV2Log(void)::gLog;
    v61 = v60;
    if (v59)
    {
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(__x.mSampleRate) = 0;
        _os_log_debug_impl(&dword_1B5ED0000, v61, OS_LOG_TYPE_DEBUG, "Buffers: EABL created", (uint8_t *)&__x, 2u);
      }
    }
    else if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__x.mSampleRate) = 0;
      _os_log_error_impl(&dword_1B5ED0000, v61, OS_LOG_TYPE_ERROR, "Buffers: EABL could not be created", (uint8_t *)&__x, 2u);
    }

    *(_QWORD *)&buf.st_dev = 0;
    std::vector<float *>::assign((char **)(v55 + 8), v57, &buf);
    v62 = (APAC::Metadata *)operator new();
    APAC::Metadata::Metadata(v62);
    std::unique_ptr<APAC::Metadata>::reset[abi:ne180100]((uint64_t *)(v19 + 24), (uint64_t)v62);
  }
  if ((v63 & 1) == 0)
  {
    if ((_DWORD)v371)
    {
      AUSM::Messenger::Messenger(v371);
    }
  }
  *(_QWORD *)&__x.mSampleRate = &unk_1EF1358F0;
  LOBYTE(__x.mFormatID) = 1;
  caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)&unk_1EF1358F0);
  *(_OWORD *)&v424.__r_.__value_.__l.__data_ = 0uLL;
  v64 = (std::__shared_weak_count *)*((_QWORD *)&AUSM::Messenger::instance(void)::msgr + 1);
  if (!*((_QWORD *)&AUSM::Messenger::instance(void)::msgr + 1)
    || (v64 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)&AUSM::Messenger::instance(void)::msgr + 1)),
        (v424.__r_.__value_.__l.__size_ = (std::string::size_type)v64) == 0)
    || (v424.__r_.__value_.__r.__words[0] = AUSM::Messenger::instance(void)::msgr) == 0)
  {
    v65 = (__int128 *)caulk::concurrent::messenger::shared_high_priority((caulk::concurrent::messenger *)v64);
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)&buf, v65);
    v66 = (timespec)v65[2];
    *(_OWORD *)((char *)&buf.st_atimespec.tv_nsec + 5) = *(__int128 *)((char *)v65 + 45);
    buf.st_atimespec = v66;
    std::optional<std::string>::operator=[abi:ne180100]<char const(&)[47],void>((std::string *)&buf, "ausm_messenger_for_buffer_disposal");
    std::allocate_shared[abi:ne180100]<caulk::concurrent::messenger,std::allocator<caulk::concurrent::messenger>,caulk::concurrent::messenger::thread_strategy &,caulk::thread::attributes &,void>((uint64_t *)&v427, 1, (uint64_t)&buf);
    v67 = *(_OWORD *)&v427.mSampleRate;
    *(_QWORD *)&v427.mFormatID = 0;
    v427.mSampleRate = 0.0;
    size = (std::__shared_weak_count *)v424.__r_.__value_.__l.__size_;
    *(_OWORD *)&v424.__r_.__value_.__l.__data_ = v67;
    if (size)
    {
      p_shared_owners = (unint64_t *)&size->__shared_owners_;
      do
        v70 = __ldaxr(p_shared_owners);
      while (__stlxr(v70 - 1, p_shared_owners));
      if (!v70)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }
    v71 = *(std::__shared_weak_count **)&v427.mFormatID;
    if (*(_QWORD *)&v427.mFormatID)
    {
      v72 = (unint64_t *)(*(_QWORD *)&v427.mFormatID + 8);
      do
        v73 = __ldaxr(v72);
      while (__stlxr(v73 - 1, v72));
      if (!v73)
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
      }
    }
    v74 = *(_OWORD *)&v424.__r_.__value_.__l.__data_;
    if (v424.__r_.__value_.__l.__size_)
    {
      v75 = (unint64_t *)(v424.__r_.__value_.__l.__size_ + 16);
      do
        v76 = __ldxr(v75);
      while (__stxr(v76 + 1, v75));
    }
    v77 = (std::__shared_weak_count *)*((_QWORD *)&AUSM::Messenger::instance(void)::msgr + 1);
    AUSM::Messenger::instance(void)::msgr = v74;
    if (v77)
      std::__shared_weak_count::__release_weak(v77);
    if (LOBYTE(buf.st_rdev) && SHIBYTE(buf.st_gid) < 0)
      operator delete(*(void **)&buf.st_dev);
  }
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&__x);
  std::shared_ptr<vp::xml::_xmlNode const>::operator=[abi:ne180100]((uint64_t)this + 3520, (__int128 *)&v424);
  v78 = (std::__shared_weak_count *)v424.__r_.__value_.__l.__size_;
  if (v424.__r_.__value_.__l.__size_)
  {
    v79 = (unint64_t *)(v424.__r_.__value_.__l.__size_ + 8);
    do
      v80 = __ldaxr(v79);
    while (__stlxr(v80 - 1, v79));
    if (!v80)
    {
      ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
      std::__shared_weak_count::__release_weak(v78);
    }
  }
  v81 = (AUSpatialMixerV2OrientationObserver *)*((_QWORD *)this + 403);
  if (v81)
  {
    AUSpatialMixerV2OrientationObserver::unregister(v81);
    std::shared_ptr<caulk::details::lifetime_guard_base<vp::vx::Telephony_Utility_Manager>::control_block>::reset[abi:ne180100]((_QWORD *)this + 403);
  }
  v82 = atomic_load((unsigned int *)this + 1276);
  if (v82 - 1 < 2 || !v82 && (v114 = atomic_load((unsigned __int8 *)this + 3668), (v114 & 1) == 0))
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v83 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
    {
      v362 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v362 = (_QWORD *)*v362;
      v363 = atomic_load((unsigned int *)this + 1276);
      buf.st_dev = 136315650;
      *(_QWORD *)&buf.st_mode = v362;
      WORD2(buf.st_ino) = 2080;
      *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"Initialize";
      if (v363 == 2)
        v364 = "device";
      else
        v364 = "UI";
      HIWORD(buf.st_gid) = 2080;
      *(_QWORD *)&buf.st_rdev = v364;
      _os_log_debug_impl(&dword_1B5ED0000, v83, OS_LOG_TYPE_DEBUG, "[%s|%s] Creating %s orientation observer", (uint8_t *)&buf, 0x20u);
    }

    v84 = atomic_load((unsigned int *)this + 1276);
    v85 = v84 != 2;
    v86 = *((_QWORD *)this + 1);
    v87 = (std::__shared_weak_count *)operator new(0xA8uLL);
    v88 = v87;
    v87->__shared_owners_ = 0;
    v89 = (unint64_t *)&v87->__shared_owners_;
    v87->__shared_weak_owners_ = 0;
    v87->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69CA5B0;
    v87[1].__shared_owners_ = 0;
    v87[1].__vftable = 0;
    LODWORD(v87[1].__shared_weak_owners_) = v85;
    *(_OWORD *)&v87[2].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v87[3].__shared_owners_ = 0u;
    LOBYTE(v87[4].__vftable) = 0;
    v87[4].__shared_owners_ = 850045863;
    *(_OWORD *)&v87[4].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v87[5].__shared_owners_ = 0u;
    v87[6].std::__shared_count = 0u;
    v87[6].__shared_weak_owners_ = 0;
    *(_QWORD *)&__x.mSampleRate = &v87[1];
    *(_QWORD *)&__x.mFormatID = v87;
    do
      v90 = __ldxr(v89);
    while (__stxr(v90 + 1, v89));
    p_shared_weak_owners = (unint64_t *)&v87->__shared_weak_owners_;
    do
      v92 = __ldxr(p_shared_weak_owners);
    while (__stxr(v92 + 1, p_shared_weak_owners));
    v87[1].__vftable = (std::__shared_weak_count_vtbl *)&v87[1];
    v87[1].__shared_owners_ = (uint64_t)v87;
    do
      v93 = __ldaxr(v89);
    while (__stlxr(v93 - 1, v89));
    if (!v93)
    {
      ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
      std::__shared_weak_count::__release_weak(v88);
    }
    mSampleRate = __x.mSampleRate;
    std::string::basic_string[abi:ne180100]<0>(&buf, "AUSpatialMixerV2_");
    v95 = *((char *)this + 3615);
    if (v95 >= 0)
      v96 = (char *)this + 3592;
    else
      v96 = (const std::string::value_type *)*((_QWORD *)this + 449);
    if (v95 >= 0)
      v97 = *((unsigned __int8 *)this + 3615);
    else
      v97 = *((_QWORD *)this + 450);
    v98 = std::string::append((std::string *)&buf, v96, v97);
    v99 = (const UInt8 *)v98->__r_.__value_.__r.__words[0];
    *(_QWORD *)&v427.mSampleRate = v98->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)&v427.mSampleRate + 7) = *(std::string::size_type *)((char *)&v98->__r_.__value_.__r.__words[1]
                                                                           + 7);
    v100 = HIBYTE(v98->__r_.__value_.__r.__words[2]);
    v98->__r_.__value_.__l.__size_ = 0;
    v98->__r_.__value_.__r.__words[2] = 0;
    v98->__r_.__value_.__r.__words[0] = 0;
    v101 = (void **)(*(_QWORD *)&mSampleRate + 40);
    if (*(char *)(*(_QWORD *)&mSampleRate + 63) < 0)
      operator delete(*v101);
    *(Float64 *)(*(_QWORD *)&mSampleRate + 48) = v427.mSampleRate;
    *(_QWORD *)(*(_QWORD *)&mSampleRate + 40) = v99;
    *(Float64 *)(*(_QWORD *)&mSampleRate + 55) = *(Float64 *)((char *)&v427.mSampleRate + 7);
    *(_BYTE *)(*(_QWORD *)&mSampleRate + 63) = v100;
    if (SHIBYTE(buf.st_gid) < 0)
    {
      operator delete(*(void **)&buf.st_dev);
      v100 = *(unsigned __int8 *)(*(_QWORD *)&mSampleRate + 63);
      v99 = *(const UInt8 **)(*(_QWORD *)&mSampleRate + 40);
    }
    if ((v100 & 0x80u) == 0)
      v102 = (const UInt8 *)(*(_QWORD *)&mSampleRate + 40);
    else
      v102 = v99;
    if ((v100 & 0x80u) == 0)
      v103 = v100;
    else
      v103 = *(_QWORD *)(*(_QWORD *)&mSampleRate + 48);
    v104 = CFStringCreateWithBytes(0, v102, v103, 0x8000100u, 0);
    if (!v104)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    v105 = *(const void **)(*(_QWORD *)&mSampleRate + 64);
    *(_QWORD *)(*(_QWORD *)&mSampleRate + 64) = v104;
    if (v105)
      CFRelease(v105);
    *(_QWORD *)(*(_QWORD *)&mSampleRate + 24) = v86;
    *(_DWORD *)(*(_QWORD *)&mSampleRate + 32) = 3101;
    atomic_store(1u, (unsigned __int8 *)(*(_QWORD *)&mSampleRate + 72));
    v106 = **(_QWORD **)&mSampleRate;
    v107 = *(std::__shared_weak_count **)(*(_QWORD *)&mSampleRate + 8);
    if (v107)
    {
      v108 = (unint64_t *)&v107->__shared_weak_owners_;
      do
        v109 = __ldxr(v108);
      while (__stxr(v109 + 1, v108));
    }
    *(_QWORD *)&buf.st_dev = MEMORY[0x1E0C809B0];
    buf.st_ino = 3321888768;
    *(_QWORD *)&buf.st_uid = ___ZN35AUSpatialMixerV2OrientationObserver16registerObserverEP28OpaqueAudioComponentInstancejRKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE_block_invoke;
    *(_QWORD *)&buf.st_rdev = &__block_descriptor_56_ea8_40c60_ZTSNSt3__18weak_ptrI35AUSpatialMixerV2OrientationObserverEE_e8_v12__0i8l;
    *(Float64 *)&buf.st_atimespec.tv_sec = mSampleRate;
    buf.st_atimespec.tv_nsec = v106;
    buf.st_mtimespec.tv_sec = (__darwin_time_t)v107;
    if (v107)
    {
      v110 = (unint64_t *)&v107->__shared_weak_owners_;
      do
        v111 = __ldxr(v110);
      while (__stxr(v111 + 1, v110));
    }
    v112 = _Block_copy(&buf);
    if (*(_DWORD *)(*(_QWORD *)&mSampleRate + 16) == 1)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v113 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(*(_QWORD *)&mSampleRate + 63) < 0)
          v101 = (void **)*v101;
        LODWORD(v427.mSampleRate) = 136315138;
        *(_QWORD *)((char *)&v427.mSampleRate + 4) = v101;
        _os_log_impl(&dword_1B5ED0000, v113, OS_LOG_TYPE_DEFAULT, "Registering UI orientation observer %s", (uint8_t *)&v427, 0xCu);
      }

      CARegisterUIOrientation();
    }
    else
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v115 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(*(_QWORD *)&mSampleRate + 63) < 0)
          v101 = (void **)*v101;
        LODWORD(v427.mSampleRate) = 136315138;
        *(_QWORD *)((char *)&v427.mSampleRate + 4) = v101;
        _os_log_impl(&dword_1B5ED0000, v115, OS_LOG_TYPE_DEFAULT, "Registering device orientation observer %s", (uint8_t *)&v427, 0xCu);
      }

      CARegisterDeviceOrientation();
    }

    if (buf.st_mtimespec.tv_sec)
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)buf.st_mtimespec.tv_sec);
    if (v107)
      std::__shared_weak_count::__release_weak(v107);
    v116 = *(_OWORD *)&__x.mSampleRate;
    __x.mSampleRate = 0.0;
    *(_QWORD *)&__x.mFormatID = 0;
    v117 = (std::__shared_weak_count *)*((_QWORD *)this + 404);
    *(_OWORD *)((char *)this + 3224) = v116;
    if (v117)
    {
      v118 = (unint64_t *)&v117->__shared_owners_;
      do
        v119 = __ldaxr(v118);
      while (__stlxr(v119 - 1, v118));
      if (!v119)
      {
        ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
        std::__shared_weak_count::__release_weak(v117);
      }
    }
    v120 = *(std::__shared_weak_count **)&__x.mFormatID;
    if (*(_QWORD *)&__x.mFormatID)
    {
      v121 = (unint64_t *)(*(_QWORD *)&__x.mFormatID + 8);
      do
        v122 = __ldaxr(v121);
      while (__stlxr(v122 - 1, v121));
      if (!v122)
      {
        ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
        std::__shared_weak_count::__release_weak(v120);
      }
    }
  }
  AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v415, (uint64_t)this + 5640);
  if (v415)
  {
    v123 = (unsigned __int16)applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const*&>((const __CFDictionary *)v415, (const void *)kOptionalFeatureSourceDiffuse);
    if (v123 <= 0x100)
      LOBYTE(v123) = 0;
    v124 = v123 != 0;
  }
  else
  {
    v124 = 0;
  }
  atomic_store(v124, (unsigned __int8 *)this + 2816);
  v414[0] = (uint64_t)this + 3304;
  v414[1] = (uint64_t)this + 3320;
  v389 = (char *)this + 3304;
  std::lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>((uint64_t)this + 3304, (uint64_t)this + 3320);
  v413 = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("ausm_verbose"), CFSTR("com.apple.coreaudio"), &v413);
  if (v413)
    v126 = AppIntegerValue;
  else
    v126 = 0;
  *((_DWORD *)this + 1524) = v126;
  v412 = 0;
  if (CFPreferencesGetAppIntegerValue(CFSTR("ausm_trace_render"), CFSTR("com.apple.coreaudio"), &v412))
    _ZF = v412 == 0;
  else
    _ZF = 1;
  v128 = !_ZF;
  *((_BYTE *)this + 7440) = v128;
  v411 = 0;
  v129 = CFPreferencesGetAppBooleanValue(CFSTR("ausm_enable_debug_features"), CFSTR("com.apple.coreaudio"), &v411);
  if (v411 && v129)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v130 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v130, OS_LOG_TYPE_DEBUG))
    {
      v365 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v365 = (_QWORD *)*v365;
      buf.st_dev = 136315650;
      *(_QWORD *)&buf.st_mode = v365;
      WORD2(buf.st_ino) = 2080;
      *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"Initialize";
      HIWORD(buf.st_gid) = 2112;
      *(_QWORD *)&buf.st_rdev = CFSTR("ausm_enable_debug_features");
      _os_log_debug_impl(&dword_1B5ED0000, v130, OS_LOG_TYPE_DEBUG, "[%s|%s] Using defaults write %@", (uint8_t *)&buf, 0x20u);
    }

    v131 = *((_QWORD *)this + 356);
    applesauce::dispatch::v1::queue::get(v131);
    objc_claimAutoreleasedReturnValue();
    v132 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v131);

    v133 = (void *)*((_QWORD *)this + 357);
    *((_QWORD *)this + 357) = v132;

    v134 = *((_QWORD *)this + 357);
    if (v134)
    {
      applesauce::dispatch::v1::queue::get(*((id *)this + 357));
      objc_claimAutoreleasedReturnValue();
      v135 = dispatch_time(0, 50000000);
      dispatch_source_set_timer(v134, v135, 0x2FAF080uLL, 0x17D7840uLL);

      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v136 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
      {
        v367 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v367 = (_QWORD *)*v367;
        buf.st_dev = 136315394;
        *(_QWORD *)&buf.st_mode = v367;
        WORD2(buf.st_ino) = 2080;
        *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"Initialize";
        _os_log_debug_impl(&dword_1B5ED0000, v136, OS_LOG_TYPE_DEBUG, "[%s|%s] Creating a timer to check defaults writes while running", (uint8_t *)&buf, 0x16u);
      }

      v137 = (void *)*((_QWORD *)this + 357);
      applesauce::dispatch::v1::queue::get(v137);
      v138 = objc_claimAutoreleasedReturnValue();
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3221225472;
      handler[2] = ___ZN16AUSpatialMixerV210InitializeEv_block_invoke_100;
      handler[3] = &__block_descriptor_40_e5_v8__0l;
      handler[4] = this;
      dispatch_source_set_event_handler(v138, handler);

      v139 = (void *)*((_QWORD *)this + 357);
      applesauce::dispatch::v1::queue::get(v139);
      v140 = objc_claimAutoreleasedReturnValue();
      dispatch_resume(v140);

      AUSpatialMixerV2::DebugSoloInputElement(this);
    }
  }
  (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)this + 592))(this, 3111);
  (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)this + 592))(this, 3113);
  v141 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 80);
  v142 = *((_QWORD *)this + 848);
  if (!*(_BYTE *)(v142 + 2544))
  {
    v143 = COERCE_FLOAT(atomic_load((unsigned int *)(v142 + 2424)));
    v144 = 5.0;
    if (v143 <= 5.0)
      v144 = v143;
    if (v143 >= 0.001)
      v145 = v144;
    else
      v145 = 0.001;
    *((float *)this + 1689) = v145;
    v146 = atomic_load((unsigned int *)(*((_QWORD *)this + 848) + 2420));
    atomic_store(v146, (unsigned int *)this + 1688);
    AUSM::SoundStage::initialize((AUSpatialMixerV2 *)((char *)this + 6336), v141);
  }
  AUSM::SoundStage::initialize((AUSpatialMixerV2 *)((char *)this + 6912), v141);
  *((_BYTE *)this + 6792) = AUSM::GlobalProperties::isEnabledFeature(*((AUSM::GlobalProperties **)this + 848), CFSTR("SourceDivergence"));
  *((_BYTE *)this + 6793) = AUSM::GlobalProperties::isEnabledFeature(*((AUSM::GlobalProperties **)this + 848), CFSTR("SourceDirectivity"));
  AUSM::GlobalGeometry::update((float32x2_t *)this + 792, 0, 1);
  v147 = *((_QWORD *)this + 15);
  if (v147)
  {
    LODWORD(v148) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v147 + 24))(v147);
    if (!(_DWORD)v148)
      goto LABEL_219;
  }
  else
  {
    v148 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (!(_DWORD)v148)
      goto LABEL_219;
  }
  v149 = 0;
  do
  {
    Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v149);
    (*(void (**)(uint64_t))(*(_QWORD *)Element + 112))(Element);
    ++v149;
  }
  while ((_DWORD)v148 != v149);
LABEL_219:
  *(_QWORD *)&buf.st_dev = (char *)this + 3352;
  LOBYTE(buf.st_ino) = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
  v151 = *((_QWORD *)this + 15);
  if (v151)
  {
    LODWORD(v152) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v151 + 24))(v151);
    if ((_DWORD)v152)
      goto LABEL_221;
LABEL_227:
    v154 = 0;
    goto LABEL_228;
  }
  v152 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  if (!(_DWORD)v152)
    goto LABEL_227;
LABEL_221:
  v153 = 0;
  v154 = 0;
  do
  {
    v155 = (AUSpatialMixerV2InputElement *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v153);
    UncompensatedLatencyFrames = AUSpatialMixerV2InputElement::GetUncompensatedLatencyFrames(v155);
    if (UncompensatedLatencyFrames > v154)
      v154 = UncompensatedLatencyFrames;
    ++v153;
  }
  while ((_DWORD)v152 != v153);
LABEL_228:
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&buf);
  atomic_store(v154, (unsigned int *)this + 3772);
  if ((_DWORD)v148)
  {
    v157 = 0;
    do
    {
      v158 = (AUSpatialMixerV2InputElement *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v157);
      AUSpatialMixerV2InputElement::UpdateAlignmentDelayLines(v158);
      ++v157;
    }
    while ((_DWORD)v148 != v157);
  }
  v159 = *((_QWORD *)this + 51);
  v160 = *((_QWORD *)this + 52);
  while (v159 != v160)
  {
    if (*(_DWORD *)v159 == 3116)
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(v159 + 8))(*(_QWORD *)(v159 + 16), *((_QWORD *)this + 1), 3116, 0, 0);
    v159 += 24;
  }
  AUSpatialMixerV2::ReloadFactoryPresetIfNecessary(this);
  atomic_store(1u, (unsigned __int8 *)this + 7442);
  v161 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
  (*(void (**)(uint64_t))(*(_QWORD *)v161 + 112))(v161);
  v162 = atomic_load((unsigned int *)this + 918);
  if (v162 == 2)
    AUSpatialMixerV2::UpdateCounteractRotationShader(this);
  v163 = *((unsigned int *)this + 84);
  v164 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 108);
  AUSpatialMixerV2::ReconfigureSharedBuffers(this, 1, 1);
  *((_DWORD *)this + 761) = v164;
  std::vector<float>::resize((uint64_t)this + 2968, (v164 * v163));
  v165 = (16 * v164) | 8;
  LOBYTE(buf.st_dev) = 0;
  v166 = (_DWORD *)*((_QWORD *)this + 374);
  v167 = *((_QWORD *)this + 375) - (_QWORD)v166;
  if (v165 <= v167)
  {
    if (v165 < v167)
      *((_QWORD *)this + 375) = (char *)v166 + v165;
  }
  else
  {
    std::vector<char>::__append((std::vector<char> *)((char *)this + 2992), v165 - v167, (std::vector<char>::const_reference)&buf);
    v166 = (_DWORD *)*((_QWORD *)this + 374);
  }
  *v166 = v164;
  *(_QWORD *)&buf.st_dev = 0;
  std::vector<float *>::assign((char **)this + 377, v164, &buf);
  *((_DWORD *)this + 781) = v164;
  std::vector<float>::resize((uint64_t)this + 3048, (v164 * v163));
  LOBYTE(buf.st_dev) = 0;
  v168 = (_DWORD *)*((_QWORD *)this + 384);
  v169 = *((_QWORD *)this + 385) - (_QWORD)v168;
  if (v165 <= v169)
  {
    if (v165 < v169)
      *((_QWORD *)this + 385) = (char *)v168 + v165;
  }
  else
  {
    std::vector<char>::__append((std::vector<char> *)this + 128, v165 - v169, (std::vector<char>::const_reference)&buf);
    v168 = (_DWORD *)*((_QWORD *)this + 384);
  }
  *v168 = v164;
  *(_QWORD *)&buf.st_dev = 0;
  std::vector<float *>::assign((char **)this + 387, v164, &buf);
  buf.st_dev = 0;
  std::vector<float>::assign((char **)this + 275, v163, &buf);
  *((_BYTE *)this + 2224) = *(float *)&buf.st_dev == 0.0;
  *((_QWORD *)this + 279) = *((_QWORD *)this + 275);
  *((_DWORD *)this + 560) = -1;
  atomic_store(0, (unsigned int *)this + 561);
  buf.st_dev = 0;
  std::vector<float>::assign((char **)this + 284, v163, &buf);
  *((_BYTE *)this + 2296) = *(float *)&buf.st_dev == 0.0;
  *((_QWORD *)this + 288) = *((_QWORD *)this + 284);
  *((_DWORD *)this + 578) = -1;
  atomic_store(0, (unsigned int *)this + 579);
  buf.st_dev = 0;
  std::vector<float>::assign((char **)this + 327, v163, &buf);
  *((_BYTE *)this + 2640) = *(float *)&buf.st_dev == 0.0;
  *((_QWORD *)this + 331) = *((_QWORD *)this + 327);
  *((_DWORD *)this + 664) = -1;
  atomic_store(0, (unsigned int *)this + 665);
  buf.st_dev = 0;
  std::vector<float>::assign((char **)this + 333, v163, &buf);
  *((_BYTE *)this + 2688) = *(float *)&buf.st_dev == 0.0;
  *((_QWORD *)this + 337) = *((_QWORD *)this + 333);
  *((_DWORD *)this + 676) = -1;
  atomic_store(0, (unsigned int *)this + 677);
  buf.st_dev = 0;
  std::vector<float>::assign((char **)this + 339, v163, &buf);
  *((_BYTE *)this + 2736) = *(float *)&buf.st_dev == 0.0;
  *((_QWORD *)this + 343) = *((_QWORD *)this + 339);
  *((_DWORD *)this + 688) = -1;
  atomic_store(0, (unsigned int *)this + 689);
  v171 = atomic_load((unsigned __int8 *)this + 2816);
  if ((v171 & 1) != 0)
  {
    buf.st_dev = 0;
    std::vector<float>::assign((char **)this + 346, v163, &buf);
    *((_BYTE *)this + 2792) = *(float *)&buf.st_dev == 0.0;
    *((_QWORD *)this + 350) = *((_QWORD *)this + 346);
    *((_DWORD *)this + 702) = -1;
    atomic_store(0, (unsigned int *)this + 703);
  }
  v170.i64[0] = *((_QWORD *)this + 394);
  v394 = v170;
  v170.i32[0] = *((_DWORD *)this + 790);
  v398 = v170;
  v172 = *((_DWORD *)this + 791);
  *(_QWORD *)&buf.st_dev = 0x40E5888000000000;
  *(_OWORD *)&buf.st_ino = xmmword_1B6626900;
  *(_OWORD *)&buf.st_rdev = xmmword_1B66A0830;
  *(_OWORD *)&__x.mSampleRate = *(_OWORD *)&buf.st_dev;
  *(_OWORD *)&__x.mBytesPerPacket = *(_OWORD *)&buf.st_uid;
  *(_QWORD *)&__x.mBitsPerChannel = 32;
  v173 = NewIIRFilter((const AudioStreamBasicDescription *)&buf, &__x, (const CAStreamBasicDescription *)1);
  v174 = *((_QWORD *)this + 363);
  *((_QWORD *)this + 363) = v173;
  if (v174)
    (*(void (**)(uint64_t))(*(_QWORD *)v174 + 8))(v174);
  *((_BYTE *)this + 2936) = 1;
  *((_QWORD *)this + 364) = v394.i64[0];
  v175 = vextq_s8(vextq_s8(v398, v398, 4uLL), v394, 0xCuLL);
  v175.i32[3] = v175.i32[0];
  *(int8x16_t *)((char *)this + 2920) = v175;
  AUSpatialMixerV2::SetReverbFilter(this, *(float *)v394.i32, *(float *)&v394.i32[1], *(float *)v398.i32, v172, v141);
  AUSpatialMixerV2::DisposeInputConverters(this);
  *(_QWORD *)&buf.st_dev = 0x40E5888000000000;
  *(_OWORD *)&buf.st_ino = xmmword_1B66A0850;
  *(_OWORD *)&buf.st_rdev = xmmword_1B66A0860;
  __x.mSampleRate = 44100.0;
  *(_OWORD *)&__x.mFormatID = xmmword_1B66A0870;
  *(_OWORD *)&__x.mBytesPerFrame = xmmword_1B66A0880;
  v427.mSampleRate = 44100.0;
  *(_OWORD *)&v427.mFormatID = xmmword_1B6626900;
  *(_OWORD *)&v427.mBytesPerFrame = xmmword_1B6626910;
  AudioConverterNew((const AudioStreamBasicDescription *)&buf, &v427, (AudioConverterRef *)this + 391);
  AudioConverterNew(&__x, &v427, (AudioConverterRef *)this + 392);
  AUSpatialMixerV2::InitializeOutputConverter((AudioConverterRef *)this);
  atomic_store(0, (unsigned __int8 *)this + 2864);
  __dmb(0xBu);
  v176 = atomic_load((unsigned __int8 *)this + 4928);
  if ((v176 & 1) != 0)
  {
    v422 = 0uLL;
    v423[0] = 0;
    v177 = atomic_load((unsigned int *)this + 1233);
    if ((v177 & 2) != 0)
    {
      v178 = COERCE_DOUBLE(operator new());
      std::string::basic_string[abi:ne180100]<0>(&buf, "AULoudnessNormalizerAUSM");
      AUSM::AUFXWrapper::AUFXWrapper(*(uint64_t *)&v178, 0x6C646E6Du, (__int128 *)&buf.st_dev);
      __x.mSampleRate = v178;
      if (SHIBYTE(buf.st_gid) < 0)
        operator delete(*(void **)&buf.st_dev);
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&buf, (uint64_t)this + 5008);
      AUSpatialMixerV2::LoadDynamicProcessorPreset(this, 1818521197, (CFURLRef *)&buf);
      if (*(_QWORD *)&buf.st_dev)
        CFRelease(*(CFTypeRef *)&buf.st_dev);
      v179 = v422.i64[1];
      if (v422.i64[1] >= v423[0])
      {
        v180 = (v422.i64[1] - v422.i64[0]) >> 3;
        v181 = v180 + 1;
        if ((unint64_t)(v180 + 1) >> 61)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v182 = v423[0] - v422.i64[0];
        if ((v423[0] - v422.i64[0]) >> 2 > v181)
          v181 = v182 >> 2;
        if ((unint64_t)v182 >= 0x7FFFFFFFFFFFFFF8)
          v183 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v183 = v181;
        buf.st_atimespec.tv_sec = (__darwin_time_t)v423;
        if (v183)
          v183 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v183);
        else
          v184 = 0;
        v186 = (Float64 *)(v183 + 8 * v180);
        v187 = v183 + 8 * v184;
        *(_QWORD *)&buf.st_rdev = v187;
        __x.mSampleRate = 0.0;
        *v186 = v178;
        v188 = v186 + 1;
        *(_QWORD *)&buf.st_uid = v186 + 1;
        v189 = (_QWORD *)v422.i64[1];
        v190 = (_QWORD *)v422.i64[0];
        if (v422.i64[1] == v422.i64[0])
        {
          v193 = 0.0;
          v192 = vdupq_n_s64(v422.u64[1]);
        }
        else
        {
          do
          {
            v191 = *--v189;
            *v189 = 0;
            *((_QWORD *)v186-- - 1) = v191;
          }
          while (v189 != v190);
          v192 = v422;
          v188 = *(_QWORD **)&buf.st_uid;
          v187 = *(_QWORD *)&buf.st_rdev;
          v193 = __x.mSampleRate;
        }
        v422.i64[0] = (uint64_t)v186;
        v422.i64[1] = (uint64_t)v188;
        *(int64x2_t *)&buf.st_ino = v192;
        v194 = v423[0];
        v423[0] = v187;
        *(_QWORD *)&buf.st_rdev = v194;
        *(_QWORD *)&buf.st_dev = v192.i64[0];
        std::__split_buffer<std::unique_ptr<AUSM::AUFXWrapper>>::~__split_buffer((uint64_t)&buf);
        v422.i64[1] = (uint64_t)v188;
        if (v193 != 0.0)
        {
          AUSM::AUFXWrapper::~AUFXWrapper(*(AUSM::AUFXWrapper **)&v193);
          MEMORY[0x1BCC95CEC]();
        }
      }
      else
      {
        *(Float64 *)v422.i64[1] = v178;
        v422.i64[1] = v179 + 8;
      }
    }
    v195 = atomic_load((unsigned int *)this + 1233);
    if ((v195 & 1) != 0)
    {
      v196 = COERCE_DOUBLE(operator new());
      std::string::basic_string[abi:ne180100]<0>(&buf, "AUControlFreakAUSM");
      AUSM::AUFXWrapper::AUFXWrapper(*(uint64_t *)&v196, 0x6366726Bu, (__int128 *)&buf.st_dev);
      __x.mSampleRate = v196;
      if (SHIBYTE(buf.st_gid) < 0)
        operator delete(*(void **)&buf.st_dev);
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&buf, (uint64_t)this + 4936);
      AUSpatialMixerV2::LoadDynamicProcessorPreset(this, 1667658347, (CFURLRef *)&buf);
      if (*(_QWORD *)&buf.st_dev)
        CFRelease(*(CFTypeRef *)&buf.st_dev);
      v197 = v422.i64[1];
      if (v422.i64[1] >= v423[0])
      {
        v198 = (v422.i64[1] - v422.i64[0]) >> 3;
        v199 = v198 + 1;
        if ((unint64_t)(v198 + 1) >> 61)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v200 = v423[0] - v422.i64[0];
        if ((v423[0] - v422.i64[0]) >> 2 > v199)
          v199 = v200 >> 2;
        if ((unint64_t)v200 >= 0x7FFFFFFFFFFFFFF8)
          v201 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v201 = v199;
        buf.st_atimespec.tv_sec = (__darwin_time_t)v423;
        if (v201)
          v201 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v201);
        else
          v202 = 0;
        v203 = (Float64 *)(v201 + 8 * v198);
        v204 = v201 + 8 * v202;
        *(_QWORD *)&buf.st_rdev = v204;
        __x.mSampleRate = 0.0;
        *v203 = v196;
        v205 = v203 + 1;
        *(_QWORD *)&buf.st_uid = v203 + 1;
        v206 = (_QWORD *)v422.i64[1];
        v207 = (_QWORD *)v422.i64[0];
        if (v422.i64[1] == v422.i64[0])
        {
          v210 = 0.0;
          v209 = vdupq_n_s64(v422.u64[1]);
        }
        else
        {
          do
          {
            v208 = *--v206;
            *v206 = 0;
            *((_QWORD *)v203-- - 1) = v208;
          }
          while (v206 != v207);
          v209 = v422;
          v205 = *(_QWORD **)&buf.st_uid;
          v204 = *(_QWORD *)&buf.st_rdev;
          v210 = __x.mSampleRate;
        }
        v422.i64[0] = (uint64_t)v203;
        v422.i64[1] = (uint64_t)v205;
        *(int64x2_t *)&buf.st_ino = v209;
        v211 = v423[0];
        v423[0] = v204;
        *(_QWORD *)&buf.st_rdev = v211;
        *(_QWORD *)&buf.st_dev = v209.i64[0];
        std::__split_buffer<std::unique_ptr<AUSM::AUFXWrapper>>::~__split_buffer((uint64_t)&buf);
        v422.i64[1] = (uint64_t)v205;
        if (v210 != 0.0)
        {
          AUSM::AUFXWrapper::~AUFXWrapper(*(AUSM::AUFXWrapper **)&v210);
          MEMORY[0x1BCC95CEC]();
        }
      }
      else
      {
        *(Float64 *)v422.i64[1] = v196;
        v422.i64[1] = v197 + 8;
      }
    }
    v212 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
    v213 = *(_OWORD *)(v212 + 96);
    *(_OWORD *)&__x.mSampleRate = *(_OWORD *)(v212 + 80);
    *(_OWORD *)&__x.mBytesPerPacket = v213;
    *(_QWORD *)&__x.mBitsPerChannel = *(_QWORD *)(v212 + 112);
    v214 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
    ausdk::AUChannelLayout::AUChannelLayout((ausdk::AUChannelLayout *)inData, (const ausdk::AUChannelLayout *)(v214 + 120));
    v216 = (AUSM::AUFXWrapper **)v422.i64[1];
    v215 = (AUSM::AUFXWrapper **)v422.i64[0];
    if (v422.i64[0] != v422.i64[1])
    {
      v395 = (char **)((char *)this + 3592);
      do
      {
        v217 = (OpaqueAudioComponentInstance **)*v215;
        *(_OWORD *)(v217 + 7) = 0u;
        *(_OWORD *)(v217 + 5) = 0u;
        *(_OWORD *)(v217 + 3) = 0u;
        *(_OWORD *)(v217 + 1) = 0u;
        v218 = *v215;
        v219 = *(OpaqueAudioComponentInstance **)*v215;
        v220 = -66744;
        if (!v219)
          goto LABEL_315;
        v221 = AudioUnitSetProperty(v219, 8u, 1u, 0, &__x, 0x28u);
        if (v221)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v222 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
          {
            *(_OWORD *)&buf.st_dev = *(_OWORD *)&__x.mSampleRate;
            *(_OWORD *)&buf.st_uid = *(_OWORD *)&__x.mBytesPerPacket;
            buf.st_atimespec.tv_sec = *(_QWORD *)&__x.mBitsPerChannel;
            CA::StreamDescription::AsString((CA::StreamDescription *)&buf, (uint64_t)&v424, *(int16x8_t *)&__x.mBytesPerPacket);
            v251 = (std::string *)v424.__r_.__value_.__r.__words[0];
            if ((v424.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v251 = &v424;
            v252 = (_QWORD *)((char *)v218 + 72);
            if (*((char *)v218 + 95) < 0)
              v252 = (_QWORD *)*v252;
            LODWORD(v427.mSampleRate) = 136315906;
            *(_QWORD *)((char *)&v427.mSampleRate + 4) = "setInputAndOutputStreamFormat";
            LOWORD(v427.mFormatFlags) = 1024;
            *(AudioFormatFlags *)((char *)&v427.mFormatFlags + 2) = v221;
            HIWORD(v427.mBytesPerPacket) = 2080;
            *(_QWORD *)&v427.mFramesPerPacket = v251;
            LOWORD(v427.mChannelsPerFrame) = 2080;
            *(_QWORD *)((char *)&v427.mChannelsPerFrame + 2) = v252;
            _os_log_error_impl(&dword_1B5ED0000, v222, OS_LOG_TYPE_ERROR, "%s: error %d setting input stream format %s for %s", (uint8_t *)&v427, 0x26u);
            if (SHIBYTE(v424.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v424.__r_.__value_.__l.__data_);
          }

        }
        v220 = -66744;
        if (!*(_QWORD *)v218 || (v220 = AudioUnitSetProperty(*(AudioUnit *)v218, 8u, 2u, 0, &__x, 0x28u)) != 0)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v223 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v223, OS_LOG_TYPE_ERROR))
          {
            *(_OWORD *)&buf.st_dev = *(_OWORD *)&__x.mSampleRate;
            *(_OWORD *)&buf.st_uid = *(_OWORD *)&__x.mBytesPerPacket;
            buf.st_atimespec.tv_sec = *(_QWORD *)&__x.mBitsPerChannel;
            CA::StreamDescription::AsString((CA::StreamDescription *)&buf, (uint64_t)&v424, *(int16x8_t *)&__x.mBytesPerPacket);
            v249 = (std::string *)v424.__r_.__value_.__r.__words[0];
            if ((v424.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v249 = &v424;
            v250 = (_QWORD *)((char *)v218 + 72);
            if (*((char *)v218 + 95) < 0)
              v250 = (_QWORD *)*v250;
            LODWORD(v427.mSampleRate) = 136315906;
            *(_QWORD *)((char *)&v427.mSampleRate + 4) = "setInputAndOutputStreamFormat";
            LOWORD(v427.mFormatFlags) = 1024;
            *(AudioFormatFlags *)((char *)&v427.mFormatFlags + 2) = v221;
            HIWORD(v427.mBytesPerPacket) = 2080;
            *(_QWORD *)&v427.mFramesPerPacket = v249;
            LOWORD(v427.mChannelsPerFrame) = 2080;
            *(_QWORD *)((char *)&v427.mChannelsPerFrame + 2) = v250;
            _os_log_error_impl(&dword_1B5ED0000, v223, OS_LOG_TYPE_ERROR, "%s: error %d setting output stream format %s for %s", (uint8_t *)&v427, 0x26u);
            if (SHIBYTE(v424.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v424.__r_.__value_.__l.__data_);
          }

        }
        if (v221)
          v220 = v221;
        if (!v220)
        {
          v225 = *v215;
          v226 = *(OpaqueAudioComponentInstance **)*v215;
          if (v226)
          {
            v227 = AudioUnitSetProperty(v226, 0x13u, 1u, 0, inData[0], 20 * *((_DWORD *)inData[0] + 2) + 12);
            if (v227)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v228 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v228, OS_LOG_TYPE_ERROR))
              {
                v258 = (_QWORD *)((char *)v225 + 72);
                if (*((char *)v225 + 95) < 0)
                  v258 = (_QWORD *)*v258;
                buf.st_dev = 136315650;
                *(_QWORD *)&buf.st_mode = "setInputAndOutputAudioChannelLayout";
                WORD2(buf.st_ino) = 1024;
                *(_DWORD *)((char *)&buf.st_ino + 6) = v227;
                HIWORD(buf.st_uid) = 2080;
                *(_QWORD *)&buf.st_gid = v258;
                _os_log_error_impl(&dword_1B5ED0000, v228, OS_LOG_TYPE_ERROR, "%s: error %d setting input audio channel layout for %s", (uint8_t *)&buf, 0x1Cu);
              }

            }
            if (!*(_QWORD *)v225
              || AudioUnitSetProperty(*(AudioUnit *)v225, 0x13u, 2u, 0, inData[0], 20 * *((_DWORD *)inData[0] + 2) + 12))
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v229 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v229, OS_LOG_TYPE_ERROR))
              {
                v255 = (_QWORD *)((char *)v225 + 72);
                if (*((char *)v225 + 95) < 0)
                  v255 = (_QWORD *)*v255;
                buf.st_dev = 136315650;
                *(_QWORD *)&buf.st_mode = "setInputAndOutputAudioChannelLayout";
                WORD2(buf.st_ino) = 1024;
                *(_DWORD *)((char *)&buf.st_ino + 6) = v227;
                HIWORD(buf.st_uid) = 2080;
                *(_QWORD *)&buf.st_gid = v255;
                _os_log_error_impl(&dword_1B5ED0000, v229, OS_LOG_TYPE_ERROR, "%s: error %d setting input audio channel layout for %s", (uint8_t *)&buf, 0x1Cu);
              }

            }
          }
          v230 = (char *)*v215 + 96;
          if (*((char *)*v215 + 119) < 0)
            v230 = *(char **)v230;
          std::string::basic_string[abi:ne180100]<0>(__p, v230);
          std::string::basic_string[abi:ne180100]<0>(&v424, "/aufx-");
          if ((v418 & 0x80u) == 0)
            v231 = __p;
          else
            v231 = (void **)__p[0];
          if ((v418 & 0x80u) == 0)
            v232 = v418;
          else
            v232 = (std::string::size_type)__p[1];
          v233 = std::string::append(&v424, (const std::string::value_type *)v231, v232);
          v234 = *(_OWORD *)&v233->__r_.__value_.__l.__data_;
          *(_QWORD *)&buf.st_uid = *((_QWORD *)&v233->__r_.__value_.__l + 2);
          *(_OWORD *)&buf.st_dev = v234;
          v233->__r_.__value_.__l.__size_ = 0;
          v233->__r_.__value_.__r.__words[2] = 0;
          v233->__r_.__value_.__r.__words[0] = 0;
          v235 = std::string::append((std::string *)&buf, "-appl-headphone.aupreset", 0x18uLL);
          v236 = *(_OWORD *)&v235->__r_.__value_.__l.__data_;
          *(_QWORD *)&v427.mBytesPerPacket = *((_QWORD *)&v235->__r_.__value_.__l + 2);
          *(_OWORD *)&v427.mSampleRate = v236;
          v235->__r_.__value_.__l.__size_ = 0;
          v235->__r_.__value_.__r.__words[2] = 0;
          v235->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(buf.st_gid) < 0)
            operator delete(*(void **)&buf.st_dev);
          if (SHIBYTE(v424.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v424.__r_.__value_.__l.__data_);
          std::string::basic_string[abi:ne180100]<0>(&buf, "/Library/Audio/Tunings/Generic/AU");
          if ((v427.mFramesPerPacket & 0x80000000) == 0)
            v237 = COERCE_DOUBLE(&v427);
          else
            v237 = v427.mSampleRate;
          if ((v427.mFramesPerPacket & 0x80000000) == 0)
            mFramesPerPacket_high = HIBYTE(v427.mFramesPerPacket);
          else
            mFramesPerPacket_high = *(_QWORD *)&v427.mFormatID;
          v239 = std::string::append((std::string *)&buf, *(const std::string::value_type **)&v237, mFramesPerPacket_high);
          v240 = *(_OWORD *)&v239->__r_.__value_.__l.__data_;
          v424.__r_.__value_.__r.__words[2] = v239->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v424.__r_.__value_.__l.__data_ = v240;
          v239->__r_.__value_.__l.__size_ = 0;
          v239->__r_.__value_.__r.__words[2] = 0;
          v239->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(buf.st_gid) < 0)
            operator delete(*(void **)&buf.st_dev);
          if ((v424.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v241 = &v424;
          else
            v241 = (std::string *)v424.__r_.__value_.__r.__words[0];
          if (stat((const char *)v241, &buf))
          {
            cf = 0;
          }
          else
          {
            if (SHIBYTE(v424.__r_.__value_.__r.__words[2]) < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)&buf, v424.__r_.__value_.__l.__data_, v424.__r_.__value_.__l.__size_);
            }
            else
            {
              *(_OWORD *)&buf.st_dev = *(_OWORD *)&v424.__r_.__value_.__l.__data_;
              *(_QWORD *)&buf.st_uid = *((_QWORD *)&v424.__r_.__value_.__l + 2);
            }
            AUSM::loadAUPreset(&cf, (const char *)&buf);
            if (SHIBYTE(buf.st_gid) < 0)
              operator delete(*(void **)&buf.st_dev);
          }
          if (SHIBYTE(v424.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v424.__r_.__value_.__l.__data_);
          if (SHIBYTE(v427.mFramesPerPacket) < 0)
            operator delete(*(void **)&v427.mSampleRate);
          if ((char)v418 < 0)
            operator delete(__p[0]);
          if (cf)
          {
            *(_QWORD *)&v427.mSampleRate = cf;
            v244 = *(OpaqueAudioComponentInstance **)*v215;
            v245 = -66744;
            if (!v244 || (v245 = AudioUnitSetProperty(v244, 0, 0, 0, &v427, 8u)) != 0)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v246 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v246, OS_LOG_TYPE_ERROR))
              {
                v256 = (char *)this + 3592;
                if (*((char *)this + 3615) < 0)
                  v256 = *v395;
                v257 = (_QWORD *)((char *)*v215 + 72);
                if (*((char *)*v215 + 95) < 0)
                  v257 = (_QWORD *)*v257;
                buf.st_dev = 136315906;
                *(_QWORD *)&buf.st_mode = v256;
                WORD2(buf.st_ino) = 2080;
                *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"InitializeDynamicsProcessing";
                HIWORD(buf.st_gid) = 1024;
                buf.st_rdev = v245;
                *((_WORD *)&buf.st_rdev + 2) = 2080;
                *(_QWORD *)((char *)&buf.st_rdev + 6) = v257;
                _os_log_error_impl(&dword_1B5ED0000, v246, OS_LOG_TYPE_ERROR, "[%s|%s] error %d setting preset on %s", (uint8_t *)&buf, 0x26u);
              }

            }
          }
          v247 = AUSM::AUFXWrapper::initialize(*v215, *((_DWORD *)this + 84));
          if (v247)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v248 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v248, OS_LOG_TYPE_ERROR))
            {
              v253 = (char *)this + 3592;
              if (*((char *)this + 3615) < 0)
                v253 = *v395;
              v254 = (_QWORD *)((char *)*v215 + 72);
              if (*((char *)*v215 + 95) < 0)
                v254 = (_QWORD *)*v254;
              buf.st_dev = 136315906;
              *(_QWORD *)&buf.st_mode = v253;
              WORD2(buf.st_ino) = 2080;
              *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"InitializeDynamicsProcessing";
              HIWORD(buf.st_gid) = 1024;
              buf.st_rdev = v247;
              *((_WORD *)&buf.st_rdev + 2) = 2080;
              *(_QWORD *)((char *)&buf.st_rdev + 6) = v254;
              _os_log_error_impl(&dword_1B5ED0000, v248, OS_LOG_TYPE_ERROR, "[%s|%s] error %d initalizing %s; processing disabled",
                (uint8_t *)&buf,
                0x26u);
            }

          }
          if (cf)
            CFRelease(cf);
        }
        else
        {
LABEL_315:
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v224 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v224, OS_LOG_TYPE_ERROR))
          {
            v242 = (char *)this + 3592;
            if (*((char *)this + 3615) < 0)
              v242 = *v395;
            v243 = (_QWORD *)((char *)*v215 + 72);
            if (*((char *)*v215 + 95) < 0)
              v243 = (_QWORD *)*v243;
            buf.st_dev = 136315906;
            *(_QWORD *)&buf.st_mode = v242;
            WORD2(buf.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"InitializeDynamicsProcessing";
            HIWORD(buf.st_gid) = 1024;
            buf.st_rdev = v220;
            *((_WORD *)&buf.st_rdev + 2) = 2080;
            *(_QWORD *)((char *)&buf.st_rdev + 6) = v243;
            _os_log_error_impl(&dword_1B5ED0000, v224, OS_LOG_TYPE_ERROR, "[%s|%s] error %d setting stream formats on %s; disabling processing",
              (uint8_t *)&buf,
              0x26u);
          }

          AUSM::AUFXWrapper::uninitialize((OpaqueAudioComponentInstance **)*v215);
        }
        ++v215;
      }
      while (v215 != v216);
      if (v422.i64[0] != v422.i64[1])
      {
        caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)v389);
        v259 = (AUSM::AUFXWrapper **)*((_QWORD *)this + 446);
        v260 = (AUSM::AUFXWrapper **)*((_QWORD *)this + 445);
        while (v259 != v260)
          std::unique_ptr<AUSM::AUFXWrapper>::reset[abi:ne180100](--v259);
        *((_QWORD *)this + 446) = v260;
        v262 = (AUSM::AUFXWrapper **)v422.i64[1];
        v261 = (AUSM::AUFXWrapper **)v422.i64[0];
        if (v422.i64[0] != v422.i64[1])
        {
          v263 = (_QWORD *)((char *)this + 3576);
          do
          {
            if ((unint64_t)v260 >= *v263)
            {
              v265 = ((uint64_t)v260 - v403->i64[0]) >> 3;
              if ((unint64_t)(v265 + 1) >> 61)
                std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
              v266 = *v263 - v403->i64[0];
              v267 = v266 >> 2;
              if (v266 >> 2 <= (unint64_t)(v265 + 1))
                v267 = v265 + 1;
              if ((unint64_t)v266 >= 0x7FFFFFFFFFFFFFF8)
                v268 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v268 = v267;
              buf.st_atimespec.tv_sec = (__darwin_time_t)this + 3576;
              if (v268)
                v268 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v268);
              else
                v269 = 0;
              v270 = (AUSM::AUFXWrapper **)(v268 + 8 * v265);
              v271 = v268 + 8 * v269;
              *(_QWORD *)&buf.st_rdev = v271;
              v272 = *v261;
              *v261 = 0;
              *v270 = v272;
              v260 = v270 + 1;
              *(_QWORD *)&buf.st_uid = v270 + 1;
              v273 = (_QWORD *)*((_QWORD *)this + 446);
              v274 = (_QWORD *)*((_QWORD *)this + 445);
              if (v273 == v274)
              {
                v276 = vdupq_n_s64((unint64_t)v273);
              }
              else
              {
                do
                {
                  v275 = (AUSM::AUFXWrapper *)*--v273;
                  *v273 = 0;
                  *--v270 = v275;
                }
                while (v273 != v274);
                v276 = *v403;
                v260 = *(AUSM::AUFXWrapper ***)&buf.st_uid;
                v271 = *(_QWORD *)&buf.st_rdev;
              }
              *((_QWORD *)this + 445) = v270;
              *((_QWORD *)this + 446) = v260;
              *(int64x2_t *)&buf.st_ino = v276;
              v277 = *((_QWORD *)this + 447);
              *((_QWORD *)this + 447) = v271;
              *(_QWORD *)&buf.st_rdev = v277;
              *(_QWORD *)&buf.st_dev = v276.i64[0];
              std::__split_buffer<std::unique_ptr<AUSM::AUFXWrapper>>::~__split_buffer((uint64_t)&buf);
            }
            else
            {
              v264 = *v261;
              *v261 = 0;
              *v260++ = v264;
            }
            *((_QWORD *)this + 446) = v260;
            ++v261;
          }
          while (v261 != v262);
        }
        caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)v389);
      }
    }
    if (inData[0])
    {
      inData[1] = inData[0];
      operator delete(inData[0]);
    }
    *(_QWORD *)&buf.st_dev = &v422;
    std::vector<std::unique_ptr<AUSM::AUFXWrapper>>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
  }
  AUSpatialMixerV2::UpdateDiffuseProcessors(this);
  if (*((_QWORD *)this + 791))
  {
    AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&buf, (uint64_t)this + 5568);
    v278 = *(const void **)&buf.st_dev;
    if (*(_QWORD *)&buf.st_dev)
    {
      v279 = (float *)*((_QWORD *)this + 791);
      CFRetain(*(CFTypeRef *)&buf.st_dev);
      v409 = v278;
      AUSM::RoomCongruence::Processor::setTuningParameters(v279, &v409);
      CFRelease(v278);
    }
    AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&__x, (uint64_t)this + 5208);
    v280 = __x.mSampleRate;
    if (*(_QWORD *)&__x.mSampleRate)
    {
      (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)this + 592))(this, 3239);
      CFRelease(*(CFTypeRef *)&v280);
    }
    if (v278)
      CFRelease(v278);
  }
  v281 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 108);
  v282 = (void **)operator new();
  v283 = (_OWORD *)((char *)this + 3592);
  if (*((char *)this + 3615) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)&buf, *((const std::string::value_type **)this + 449), *((_QWORD *)this + 450));
  }
  else
  {
    *(_OWORD *)&buf.st_dev = *v283;
    *(_QWORD *)&buf.st_uid = *((_QWORD *)this + 451);
  }
  ParametricFilters::ParametricFilters((uint64_t)v282, v281, 1, 5, (__int128 *)&buf.st_dev, v141);
  if (SHIBYTE(buf.st_gid) < 0)
    operator delete(*(void **)&buf.st_dev);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)this + 931, v282);
  v284 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 108);
  v285 = (void **)operator new();
  if (*((char *)this + 3615) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)&buf, *((const std::string::value_type **)this + 449), *((_QWORD *)this + 450));
  }
  else
  {
    *(_OWORD *)&buf.st_dev = *v283;
    *(_QWORD *)&buf.st_uid = *((_QWORD *)this + 451);
  }
  ParametricFilters::ParametricFilters((uint64_t)v285, v284, 1, 5, (__int128 *)&buf.st_dev, v141);
  if (SHIBYTE(buf.st_gid) < 0)
    operator delete(*(void **)&buf.st_dev);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)this + 932, v285);
  AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v427, (uint64_t)this + 5352);
  v286 = v427.mSampleRate;
  if (*(_QWORD *)&v427.mSampleRate)
  {
    v287 = *((_QWORD *)this + 931);
    CFRetain(*(CFTypeRef *)&v427.mSampleRate);
    v408 = v286;
    memset(&buf, 0, 24);
    ParametricFilters::setParametricFilters(v287, (CFDictionaryRef *)&v408, (uint64_t)&buf);
    CFRelease(*(CFTypeRef *)&v286);
    v288 = *((_QWORD *)this + 932);
    CFRetain(*(CFTypeRef *)&v286);
    v407 = v286;
    memset(&buf, 0, 24);
    ParametricFilters::setParametricFilters(v288, (CFDictionaryRef *)&v407, (uint64_t)&buf);
    CFRelease(*(CFTypeRef *)&v286);
  }
  AUSpatialMixerV2::UpdateReverbRoomType(this);
  AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v424, (uint64_t)this + 3904);
  v289 = (const __CFURL *)v424.__r_.__value_.__r.__words[0];
  if (v424.__r_.__value_.__r.__words[0])
  {
    CFRetain(v424.__r_.__value_.__l.__data_);
    v406 = v289;
    AUSpatialMixerV2::InitializeDynamicXTC((uint64_t)this, &v406);
    CFRelease(v289);
    (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)this + 592))(this, 3107);
    AUSpatialMixerV2::RefreshXTCTuningParameters(this);
  }
  v290 = *((_QWORD *)this + 401);
  if (!v290)
    goto LABEL_520;
  *(float *)v290 = v141;
  *(_DWORD *)(v290 + 4268) = 4;
  v291 = *(_DWORD *)(v290 + 52);
  if (*(_DWORD *)(v290 + 48) == 2)
  {
    v292 = *(_DWORD *)(v290 + 56);
    if (v291 == 2 && v292 == 128)
    {
      v293 = *(_DWORD *)(v290 + 60);
      if (v293 == 256)
        goto LABEL_487;
    }
    else
    {
      if (v292 != 128)
      {
        v294 = 1;
        goto LABEL_475;
      }
      v293 = *(_DWORD *)(v290 + 60);
    }
    v294 = v293 != 256;
    v292 = 128;
LABEL_475:
    v295 = v292 != 128;
    goto LABEL_476;
  }
  v294 = 1;
  v295 = 1;
LABEL_476:
  v296 = v291 != 2 || *(_DWORD *)(v290 + 56) != 128;
  *(_OWORD *)(v290 + 48) = xmmword_1B66A0890;
  *(_QWORD *)(v290 + 96) = 256;
  if (v294)
    OverlapperAudioBuffer<float>::resize(v290 + 104, 2u, 384);
  if (v295)
    OverlapperAudioBuffer<float>::resize(v290 + 1144, *(_DWORD *)(v290 + 48), 2 * *(_DWORD *)(v290 + 56));
  if (v296)
    OverlapperAudioBuffer<float>::resize(v290 + 2184, *(_DWORD *)(v290 + 52), 2 * *(_DWORD *)(v290 + 56));
  if (v291 != 2)
    OverlapperAudioBuffer<float>::resize(v290 + 3224, *(_DWORD *)(v290 + 52), 0x8000);
LABEL_487:
  if (*(_QWORD *)(v290 + 4280) != 256)
  {
    AlignedBuffer<float>::resize(v290 + 4272);
    v297 = 0;
    v298 = (uint64x2_t)xmmword_1B6626830;
    v299 = *(_QWORD *)(v290 + 4272);
    v300 = (float32x2_t)vdup_n_s32(0x3C490FDBu);
    v387 = vdupq_n_s64(2uLL);
    v390 = (uint64x2_t)vdupq_n_s64(0x100uLL);
    do
    {
      v399 = vmovn_s64((int64x2_t)vcgtq_u64(v390, v298)).u8[0];
      v404 = (int64x2_t)v298;
      v301.i32[0] = v297;
      v301.i32[1] = v297 + 1;
      v302 = vmul_f32(vadd_f32(vcvt_f32_s32(v301), (float32x2_t)0x3F0000003F000000), v300);
      v392 = v302.f32[0];
      v396 = sinf(v302.f32[1]);
      v303 = sinf(v392);
      if ((v399 & 1) != 0)
        *(float *)(v299 + 4 * v297) = v303;
      if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x100uLL), *(uint64x2_t *)&v404)).i32[1] & 1) != 0)
        *(float *)(v299 + 4 * v297 + 4) = v396;
      v297 += 2;
      v298 = (uint64x2_t)vaddq_s64(v404, v387);
    }
    while (v297 != 256);
  }
  if (*(_QWORD *)(v290 + 4296) != 256)
  {
    AlignedBuffer<float>::resize(v290 + 4288);
    v304 = 0;
    v305 = (uint64x2_t)xmmword_1B6627110;
    v306 = (int32x4_t)xmmword_1B6626920;
    v380 = (float32x4_t)vdupq_n_s32(0x3B800000u);
    v381 = (uint64x2_t)vdupq_n_s64(0x100uLL);
    v378 = (float32x4_t)vdupq_n_s32(0x3FC90FDBu);
    v379 = (float32x4_t)vdupq_n_s32(0x3FA2CD2Fu);
    __asm { FMOV            V1.4S, #4.0 }
    v376 = _Q1;
    v377 = vdupq_n_s64(4uLL);
    __asm { FMOV            V1.4S, #1.0 }
    v397 = _Q1;
    v312 = (uint64x2_t)xmmword_1B6626830;
    __asm { FMOV            V1.4S, #3.0 }
    v375 = _Q1;
    v314 = *(_QWORD *)(v290 + 4288);
    do
    {
      v391 = v306;
      v393 = (int64x2_t)v305;
      v388 = (int64x2_t)v312;
      v315 = (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v381, v312), (int32x4_t)vcgtq_u64(v381, v305));
      v316 = vmulq_f32(vmulq_f32(vcvtq_f32_s32(v306), v376), v380);
      v317 = (int8x16_t)vcgtq_f32(v397, v316);
      v318.i64[0] = 0x4000000040000000;
      v318.i64[1] = 0x4000000040000000;
      v319 = (int8x16_t)vcgtq_f32(v318, v316);
      v320 = (int8x16_t)vcgtq_f32(v375, v316);
      v321 = vsubq_f32(v318, v316);
      v322.i64[0] = 0xC0000000C0000000;
      v322.i64[1] = 0xC0000000C0000000;
      v323 = vandq_s8(v315, v317);
      v324 = vbicq_s8(v315, v317);
      v325 = (int32x4_t)vandq_s8(v324, v319);
      v326 = vbicq_s8(v324, v319);
      v385 = (int32x4_t)vandq_s8(v326, v320);
      v386 = v323;
      v383 = (int32x4_t)vbicq_s8(v326, v320);
      v384 = (int8x16_t)v325;
      v382 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vorn_s8((int8x8_t)vmovn_s32(v383), vorr_s8((int8x8_t)vmovn_s32(v385), (int8x8_t)vmovn_s32(v325)))), 0x1FuLL));
      v405 = vmulq_f32(vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)v383, (int8x16_t)vaddq_f32(v321, v318), vbslq_s8((int8x16_t)v385, (int8x16_t)vaddq_f32(v316, v322), vbslq_s8((int8x16_t)v325, (int8x16_t)v321, (int8x16_t)v316))), v379), v378);
      v400 = cosf(v405.f32[1]);
      v327.f32[0] = cosf(v405.f32[0]);
      v327.f32[1] = v400;
      v401 = v327;
      v328 = cosf(v405.f32[2]);
      v329 = v401;
      v329.f32[2] = v328;
      v402 = v329;
      v330 = cosf(v405.f32[3]);
      v331 = v402;
      v331.f32[3] = v330;
      v332.i64[0] = 0x3F0000003F000000;
      v332.i64[1] = 0x3F0000003F000000;
      v333.i64[0] = 0xBF000000BF000000;
      v333.i64[1] = 0xBF000000BF000000;
      v334 = vmlaq_f32(v332, v333, v331);
      v335 = vmulq_f32(v334, v334);
      v336 = vsqrtq_f32((float32x4_t)vbslq_s8(v382, (int8x16_t)v335, (int8x16_t)vsubq_f32(v397, v335)));
      v337 = vmovn_s32((int32x4_t)vorrq_s8(vorrq_s8((int8x16_t)v383, vorrq_s8(v386, v384)), (int8x16_t)v385));
      if ((v337.i8[0] & 1) != 0)
        *(_DWORD *)(v314 + v304) = v336.i32[0];
      if ((v337.i8[2] & 1) != 0)
        *(_DWORD *)(v314 + v304 + 4) = v336.i32[1];
      if ((v337.i8[4] & 1) != 0)
        *(_DWORD *)(v314 + v304 + 8) = v336.i32[2];
      if ((v337.i8[6] & 1) != 0)
        *(_DWORD *)(v314 + v304 + 12) = v336.i32[3];
      v305 = (uint64x2_t)vaddq_s64(v393, v377);
      v312 = (uint64x2_t)vaddq_s64(v388, v377);
      v338.i64[0] = 0x400000004;
      v338.i64[1] = 0x400000004;
      v306 = vaddq_s32(v391, v338);
      v304 += 16;
    }
    while (v304 != 1024);
  }
  OverlapperAudioBuffer<float>::resize(v290 + 4304, 2u, *(_DWORD *)(v290 + 4268) << 8);
  OverlapperAudioBuffer<float>::resize(v290 + 5344, 2u, *(_DWORD *)(v290 + 4268) << 8);
  OverlapperAudioBuffer<DSPComplex>::resize((int *)(v290 + 6384), *(_DWORD *)(v290 + 4268) << 8);
  OverlapperAudioBuffer<DSPComplex>::resize((int *)(v290 + 7424), *(_DWORD *)(v290 + 4268) << 8);
  v339 = *(int *)(v290 + 4268);
  v340 = *(vDSP_DFT_SetupStruct **)(v290 + 8496);
  if (v340)
    vDSP_DFT_DestroySetup(v340);
  v341 = v339 << 8;
  *(_QWORD *)(v290 + 8496) = vDSP_DFT_zrop_CreateSetup(0, v341, vDSP_DFT_FORWARD);
  v342 = *(vDSP_DFT_SetupStruct **)(v290 + 8504);
  if (v342)
    vDSP_DFT_DestroySetup(v342);
  *(_QWORD *)(v290 + 8504) = vDSP_DFT_zrop_CreateSetup(0, v341, vDSP_DFT_INVERSE);
  *(_DWORD *)(v290 + 4264) = 1;
  TorqueEngine::resizeBuffers((void **)v290, 1024);
  v343 = *(unsigned int *)(v290 + 15796);
  if (*(int *)(v290 + 15792) >= 1)
  {
    v344 = *(_QWORD *)(v290 + 15808);
    if (!(_DWORD)v343)
      goto LABEL_519;
LABEL_513:
    v345 = 0;
    v346 = (float)(*(float *)v290 * 0.5) / (float)(int)v343;
    v347 = (uint64x2_t)vdupq_n_s64(v343 - 1);
    do
    {
      v348 = vmovn_s64((int64x2_t)vcgeq_u64(v347, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v345), (int8x16_t)xmmword_1B6626830)));
      if ((v348.i8[0] & 1) != 0)
        *(float *)(v344 + 4 * v345) = v346 * (float)v345;
      if ((v348.i8[4] & 1) != 0)
        *(float *)(v344 + 4 * v345 + 4) = v346 * (float)(v345 + 1);
      v345 += 2;
    }
    while (((v343 + 1) & 0x1FFFFFFFELL) != v345);
    goto LABEL_519;
  }
  v344 = 0;
  if ((_DWORD)v343)
    goto LABEL_513;
LABEL_519:
  TorqueEngine::updateCrossoverResponse((TorqueEngine *)v290);
  TorqueEngine::updateHighShelfResponses((TorqueEngine *)v290);
LABEL_520:
  *((_DWORD *)this + 804) = -1;
  atomic_store(1u, (unsigned __int8 *)this + 3241);
  v349 = (double)(uint64_t)(mach_absolute_time() - v374) * 0.0000000416666667;
  v350 = v349 * 1000.0;
  *(float *)__p = v349 * 1000.0;
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v351 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v351, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)this + 3615) < 0)
      v283 = *(_OWORD **)v283;
    buf.st_dev = 136315650;
    *(_QWORD *)&buf.st_mode = v283;
    WORD2(buf.st_ino) = 2080;
    *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)"Initialize";
    HIWORD(buf.st_gid) = 2048;
    *(double *)&buf.st_rdev = v350;
    _os_log_impl(&dword_1B5ED0000, v351, OS_LOG_TYPE_DEFAULT, "[%s|%s] Initialized in %.2fms", (uint8_t *)&buf, 0x20u);
  }

  v352 = **(_DWORD **)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), 0) + 120);
  LODWORD(cf) = v352;
  v353 = **(_DWORD **)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 120);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],float &>((applesauce::CF::TypeRef *)&buf, "ausm_init_time_ms", (int *)__p);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[20],unsigned int &>((applesauce::CF::TypeRef *)&buf.st_uid, "ausm_input_bus0_acl", (int *)&cf);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&buf.st_atimespec, "ausm_output_acl");
  LODWORD(inData[0]) = v353;
  buf.st_atimespec.tv_nsec = (uint64_t)CFNumberCreate(0, kCFNumberIntType, inData);
  if (!buf.st_atimespec.tv_nsec)
  {
    v372 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v372, "Could not construct");
  }
  *(_QWORD *)&__x.mSampleRate = &buf;
  *(_QWORD *)&__x.mFormatID = 3;
  CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&__x);
  v355 = 0;
  v422.i64[0] = (uint64_t)CFDictionaryRef;
  do
  {
    v356 = *(const void **)((char *)&buf.st_atimespec.tv_nsec + v355);
    if (v356)
      CFRelease(v356);
    v357 = *(const void **)((char *)&buf.st_atimespec.tv_sec + v355);
    if (v357)
      CFRelease(v357);
    v355 -= 16;
  }
  while (v355 != -48);
  if (AudioStatisticsLibraryLoader(void)::once != -1)
    dispatch_once(&AudioStatisticsLibraryLoader(void)::once, &__block_literal_global_265);
  if (AudioStatisticsLibraryLoader(void)::libSym)
    AudioStatisticsLibraryLoader(void)::libSym(CFDictionaryRef, 268435457, 5);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v358 = (id)getAUSMV2Log(void)::gLog;
  v359 = v358;
  v360 = AUSpatialMixerV2::Initialize(void)::spid;
  if ((unint64_t)(AUSpatialMixerV2::Initialize(void)::spid - 1) <= 0xFFFFFFFFFFFFFFFDLL
    && os_signpost_enabled(v358))
  {
    buf.st_dev = 67109376;
    *(_DWORD *)&buf.st_mode = v352;
    LOWORD(buf.st_ino) = 1024;
    *(_DWORD *)((char *)&buf.st_ino + 2) = v353;
    _os_signpost_emit_with_name_impl(&dword_1B5ED0000, v359, OS_SIGNPOST_INTERVAL_END, v360, "AUSM_INIT_EVENT", "%u|%u", (uint8_t *)&buf, 0xEu);
  }

  if (CFDictionaryRef)
    CFRelease(CFDictionaryRef);
  if (v289)
    CFRelease(v289);
  if (v286 != 0.0)
    CFRelease(*(CFTypeRef *)&v286);
  std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100](v414);
  if (v415)
    CFRelease(v415);
  return 0;
}

void sub_1B6184A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::Cleanup(AUSpatialMixerV2 *this)
{
  _BYTE *v2;
  NSObject *v3;
  _QWORD *v4;
  void *v5;
  CATimeUtilities *v6;
  NSObject *v7;
  _QWORD *v8;
  const char *v9;
  _QWORD *v10;
  unint64_t CurrentGregorianDate;
  _QWORD *v12;
  double v13;
  char *v14;
  char *v15;
  void *p_p;
  void *v17;
  NSObject *v18;
  char *v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  _QWORD *v23;
  AUSpatialMixerV2OrientationObserver *v24;
  IR::IRDataLoader *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  _DWORD *v30;
  unint64_t v31;
  _DWORD *v32;
  unint64_t v33;
  _DWORD *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  AUSM::AUFXWrapper **v50;
  AUSM::AUFXWrapper **v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t Element;
  uint64_t v56;
  uint64_t *v57;
  _QWORD *v58;
  std::__shared_weak_count *v59;
  unint64_t *p_shared_owners;
  unint64_t v61;
  uint64_t v62;
  __int128 v68;
  void *v70;
  char v71;
  _QWORD v72[5];
  void *__p;
  char v74;
  char v75;
  _BYTE buf[24];
  void *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v2 = (char *)this + 6127;
  atomic_store(0, (unsigned __int8 *)this + 7441);
  atomic_store(0, (unsigned __int8 *)this + 7442);
  atomic_store(1u, (unsigned __int8 *)this + 2864);
  __dmb(0xBu);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v3 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v4 = (_QWORD *)*v4;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v4;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "Cleanup";
    _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEFAULT, "[%s|%s] Cleaning up", buf, 0x16u);
  }

  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99EA0]), "initWithSuiteName:", CFSTR("com.apple.coreaudio"));
  if ((objc_msgSend(v5, "BOOLForKey:", CFSTR("ausm_capture_all")) & 1) != 0
    || (objc_msgSend(v5, "BOOLForKey:", CFSTR("ausm_capture_config")) & 1) != 0)
  {
    if ((char)*v2 < 0)
    {
      if (*((_QWORD *)this + 764))
        goto LABEL_11;
    }
    else if (*v2)
    {
LABEL_11:
      *(_QWORD *)buf = 0;
      v6 = (CATimeUtilities *)(*(uint64_t (**)(AUSpatialMixerV2 *, _BYTE *))(*(_QWORD *)this + 272))(this, buf);
      if (!(_DWORD)v6)
      {
        v7 = *(NSObject **)buf;
        CurrentGregorianDate = CATimeUtilities::GetCurrentGregorianDate(v6);
        v12 = (_QWORD *)((char *)this + 6104);
        caulk::make_string((caulk *)"%d%02d%02d.%02d%02d%02d", (uint64_t)&__p, CurrentGregorianDate, ((int)(CurrentGregorianDate >> 8) >> 24), ((int)(CurrentGregorianDate >> 16) >> 24), ((int)(CurrentGregorianDate >> 24) >> 24), (SHIDWORD(CurrentGregorianDate) >> 24), (int)v13);
        if ((char)*v2 < 0)
          v12 = (_QWORD *)*v12;
        v14 = (char *)this + 3592;
        v15 = (char *)this + 3592;
        if (*((char *)this + 3615) < 0)
          v15 = *(char **)v14;
        p_p = &__p;
        if (v75 < 0)
          p_p = __p;
        objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s/ausm_%s_preset_%s_%u.aupreset"), v12, v15, p_p, *((unsigned int *)this + 825));
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v18 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          v19 = (char *)this + 3592;
          if (*((char *)this + 3615) < 0)
            v19 = *(char **)v14;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v19;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "CaptureConfigIfNecessary";
          *(_WORD *)&buf[22] = 2112;
          v77 = v17;
          _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEFAULT, "[%s|%s] Captured preset will be saved to file %@", buf, 0x20u);
        }

        if ((-[NSObject writeToFile:atomically:](v7, "writeToFile:atomically:", v17, 1) & 1) != 0)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v20 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            if (*((char *)this + 3615) < 0)
              v14 = *(char **)v14;
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v14;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "CaptureConfigIfNecessary";
            *(_WORD *)&buf[22] = 2112;
            v77 = v17;
            _os_log_debug_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_DEBUG, "[%s|%s] Preset exported to %@", buf, 0x20u);
          }
        }
        else
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v20 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            if (*((char *)this + 3615) < 0)
              v14 = *(char **)v14;
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v14;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "CaptureConfigIfNecessary";
            *(_WORD *)&buf[22] = 2112;
            v77 = v17;
            _os_log_error_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_ERROR, "[%s|%s] ERROR: could not export the preset to %@", buf, 0x20u);
          }
        }

        ++*((_DWORD *)this + 825);
        if (v75 < 0)
          operator delete(__p);
        goto LABEL_50;
      }
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v7 = (id)getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
LABEL_50:

        goto LABEL_51;
      }
      v8 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v8 = (_QWORD *)*v8;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v8;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "CaptureConfigIfNecessary";
      v9 = "[%s|%s] ERROR: Could not capture preset";
LABEL_25:
      _os_log_error_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_ERROR, v9, buf, 0x16u);
      goto LABEL_50;
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v7 = (id)getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      goto LABEL_50;
    v10 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v10 = (_QWORD *)*v10;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v10;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "CaptureConfigIfNecessary";
    v9 = "[%s|%s] ERROR: no capture dir path available";
    goto LABEL_25;
  }
LABEL_51:

  v21 = *((_QWORD *)this + 357);
  v22 = *((_QWORD *)this + 356);
  applesauce::dispatch::v1::queue::get(v22);
  objc_claimAutoreleasedReturnValue();
  if (v21)
  {
    v72[0] = MEMORY[0x1E0C809B0];
    v72[1] = 3221225472;
    v72[2] = ___ZN16AUSpatialMixerV27CleanupEv_block_invoke;
    v72[3] = &__block_descriptor_40_e5_v8__0l;
    v72[4] = this;
    v23 = v72;
  }
  else
  {
    v23 = &__block_literal_global_106;
  }
  dispatch_sync(v22, v23);

  v24 = (AUSpatialMixerV2OrientationObserver *)*((_QWORD *)this + 403);
  if (v24)
  {
    AUSpatialMixerV2OrientationObserver::unregister(v24);
    std::shared_ptr<caulk::details::lifetime_guard_base<vp::vx::Telephony_Utility_Manager>::control_block>::reset[abi:ne180100]((_QWORD *)this + 403);
  }
  v25 = (IR::IRDataLoader *)AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener((AUSpatialMixerV2 *)((char *)this + 7408));
  IR::IRDataLoader::instance(v25);
  std::operator+<char>();
  IR::IRDataLoader::removePersonalizedHRTFListenerCallback();
  if (v71 < 0)
    operator delete(v70);
  *(_QWORD *)buf = (char *)this + 3304;
  *(_QWORD *)&buf[8] = (char *)this + 3320;
  *(_QWORD *)&buf[16] = (char *)this + 3336;
  std::__lock_first<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(0, (uint64_t)this + 3304, (uint64_t)this + 3320, (uint64_t)this + 3336);
  ElementVector::freeOld(*((ElementVector ***)this + 100));
  AUSpatialMixerV2::DisposeInputConverters(this);
  AUSpatialMixerV2::DisposeOutputConverter(this);
  v26 = 0;
  v27 = *((_QWORD *)this + 370);
  do
  {
    v28 = v27 + v26;
    *(_QWORD *)(v28 + 8) = *(_QWORD *)(v27 + v26);
    *(_BYTE *)(v28 + 24) = 1;
    v26 += 32;
  }
  while (v26 != 128);
  v29 = (_QWORD *)(v27 + 128);
  do
  {
    v29[1] = *v29;
    v29 += 3;
  }
  while (v29 != (_QWORD *)(v27 + 200));
  *(_QWORD *)(v27 + 208) = *(_QWORD *)(v27 + 200);
  *(_QWORD *)(v27 + 816) = *(_QWORD *)(v27 + 808);
  std::vector<DspLib::PeakPowerGuard::AdmittanceFilterCoeffSet::FIRfilter>::__clear[abi:ne180100]((uint64_t *)(v27 + 224));
  *(_QWORD *)(v27 + 256) = *(_QWORD *)(v27 + 248);
  LOBYTE(__p) = 0;
  v30 = *(_DWORD **)(v27 + 272);
  v31 = *(_QWORD *)(v27 + 280) - (_QWORD)v30;
  if (v31 > 7)
  {
    if (v31 != 8)
      *(_QWORD *)(v27 + 280) = v30 + 2;
  }
  else
  {
    std::vector<char>::__append((std::vector<char> *)(v27 + 272), 8 - v31, (std::vector<char>::const_reference)&__p);
    v30 = *(_DWORD **)(v27 + 272);
  }
  *v30 = 0;
  *(_QWORD *)(v27 + 304) = *(_QWORD *)(v27 + 296);
  *(_QWORD *)(v27 + 336) = *(_QWORD *)(v27 + 328);
  *(_QWORD *)(v27 + 360) = *(_QWORD *)(v27 + 352);
  *(_QWORD *)(v27 + 496) = *(_QWORD *)(v27 + 488);
  *(_QWORD *)(v27 + 520) = *(_QWORD *)(v27 + 512);
  *(_QWORD *)(v27 + 560) = *(_QWORD *)(v27 + 552);
  *(_QWORD *)(v27 + 592) = *(_QWORD *)(v27 + 584);
  *(_QWORD *)(v27 + 616) = *(_QWORD *)(v27 + 608);
  *(_QWORD *)(v27 + 656) = *(_QWORD *)(v27 + 648);
  *(_QWORD *)(v27 + 688) = *(_QWORD *)(v27 + 680);
  *(_QWORD *)(v27 + 712) = *(_QWORD *)(v27 + 704);
  *(_QWORD *)(v27 + 752) = *(_QWORD *)(v27 + 744);
  *(_QWORD *)(v27 + 400) = *(_QWORD *)(v27 + 392);
  *(_QWORD *)(v27 + 424) = *(_QWORD *)(v27 + 416);
  *(_QWORD *)(v27 + 464) = *(_QWORD *)(v27 + 456);
  *(_DWORD *)(v27 + 324) = 0;
  IR::ComplexDataCircBuffer::cleanup((IR::ComplexDataCircBuffer *)(v27 + 776));
  IR::ComplexDataCircBuffer::cleanup((IR::ComplexDataCircBuffer *)(v27 + 784));
  IR::ComplexDataCircBuffer::cleanup((IR::ComplexDataCircBuffer *)(v27 + 792));
  IR::ComplexDataCircBuffer::cleanup((IR::ComplexDataCircBuffer *)(v27 + 800));
  *((_QWORD *)this + 372) = *((_QWORD *)this + 371);
  LOBYTE(__p) = 0;
  v32 = (_DWORD *)*((_QWORD *)this + 374);
  v33 = *((_QWORD *)this + 375) - (_QWORD)v32;
  if (v33 > 7)
  {
    if (v33 != 8)
      *((_QWORD *)this + 375) = v32 + 2;
  }
  else
  {
    std::vector<char>::__append((std::vector<char> *)((char *)this + 2992), 8 - v33, (std::vector<char>::const_reference)&__p);
    v32 = (_DWORD *)*((_QWORD *)this + 374);
  }
  *v32 = 0;
  *((_QWORD *)this + 378) = *((_QWORD *)this + 377);
  *((_DWORD *)this + 761) = 0;
  *((_QWORD *)this + 382) = *((_QWORD *)this + 381);
  LOBYTE(__p) = 0;
  v34 = (_DWORD *)*((_QWORD *)this + 384);
  v35 = *((_QWORD *)this + 385) - (_QWORD)v34;
  if (v35 > 7)
  {
    if (v35 != 8)
      *((_QWORD *)this + 385) = v34 + 2;
  }
  else
  {
    std::vector<char>::__append((std::vector<char> *)this + 128, 8 - v35, (std::vector<char>::const_reference)&__p);
    v34 = (_DWORD *)*((_QWORD *)this + 384);
  }
  *v34 = 0;
  *((_QWORD *)this + 388) = *((_QWORD *)this + 387);
  *((_DWORD *)this + 781) = 0;
  v36 = *((_QWORD *)this + 275);
  *((_QWORD *)this + 276) = v36;
  *((_BYTE *)this + 2224) = 1;
  *((_QWORD *)this + 279) = v36;
  *((_DWORD *)this + 560) = -1;
  atomic_store(0, (unsigned int *)this + 561);
  v37 = *((_QWORD *)this + 284);
  *((_QWORD *)this + 285) = v37;
  *((_BYTE *)this + 2296) = 1;
  *((_QWORD *)this + 288) = v37;
  *((_DWORD *)this + 578) = -1;
  atomic_store(0, (unsigned int *)this + 579);
  v38 = *((_QWORD *)this + 327);
  *((_QWORD *)this + 328) = v38;
  *((_BYTE *)this + 2640) = 1;
  *((_QWORD *)this + 331) = v38;
  *((_DWORD *)this + 664) = -1;
  atomic_store(0, (unsigned int *)this + 665);
  v39 = *((_QWORD *)this + 333);
  *((_QWORD *)this + 334) = v39;
  *((_BYTE *)this + 2688) = 1;
  *((_QWORD *)this + 337) = v39;
  *((_DWORD *)this + 676) = -1;
  atomic_store(0, (unsigned int *)this + 677);
  v40 = *((_QWORD *)this + 339);
  *((_QWORD *)this + 340) = v40;
  *((_BYTE *)this + 2736) = 1;
  *((_QWORD *)this + 343) = v40;
  *((_DWORD *)this + 688) = -1;
  atomic_store(0, (unsigned int *)this + 689);
  LOBYTE(v40) = atomic_load((unsigned __int8 *)this + 2816);
  if ((v40 & 1) != 0)
  {
    v41 = *((_QWORD *)this + 346);
    *((_QWORD *)this + 347) = v41;
    *((_BYTE *)this + 2792) = 1;
    *((_QWORD *)this + 350) = v41;
    *((_DWORD *)this + 702) = -1;
    atomic_store(0, (unsigned int *)this + 703);
  }
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 2256);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 281) + 24))(*((_QWORD *)this + 281));
  atomic_store(0, (unsigned __int8 *)this + 2320);
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 2256);
  __p = (char *)this + 2476;
  v74 = 1;
  caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2 *)((char *)this + 2476));
  *((_DWORD *)this + 638) = 0;
  *((_DWORD *)this + 640) = 0;
  atomic_store(0, (unsigned __int8 *)this + 2556);
  atomic_store(0, (unsigned __int8 *)this + 2472);
  atomic_store(0, (unsigned __int8 *)this + 2473);
  atomic_store(0, (unsigned __int8 *)this + 2474);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 310);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 313);
  v42 = *((_QWORD *)this + 292);
  v43 = *((_QWORD *)this + 291);
  while (v42 != v43)
    v42 = std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v42 - 16);
  *((_QWORD *)this + 292) = v43;
  v44 = *((_QWORD *)this + 298);
  v45 = *((_QWORD *)this + 297);
  while (v44 != v45)
    v44 = std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v44 - 16);
  *((_QWORD *)this + 298) = v45;
  v46 = *((_QWORD *)this + 304);
  v47 = *((_QWORD *)this + 303);
  while (v46 != v47)
    v46 = std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v46 - 16);
  *((_QWORD *)this + 304) = v47;
  *((_QWORD *)this + 295) = *((_QWORD *)this + 294);
  *((_QWORD *)this + 301) = *((_QWORD *)this + 300);
  *((_QWORD *)this + 307) = *((_QWORD *)this + 306);
  v48 = *((_QWORD *)this + 317);
  v49 = *((_QWORD *)this + 316);
  while (v48 != v49)
    v48 = std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v48 - 16);
  *((_QWORD *)this + 317) = v49;
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&__p);
  atomic_store(0, (unsigned __int8 *)this + 2760);
  atomic_store(0, (unsigned __int8 *)this + 2761);
  v50 = (AUSM::AUFXWrapper **)*((_QWORD *)this + 446);
  v51 = (AUSM::AUFXWrapper **)*((_QWORD *)this + 445);
  while (v50 != v51)
    std::unique_ptr<AUSM::AUFXWrapper>::reset[abi:ne180100](--v50);
  *((_QWORD *)this + 446) = v51;
  AUSpatialMixerV2::AlignmentDelay::reset((AUSpatialMixerV2 *)((char *)this + 15096));
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)this + 931, 0);
  std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)this + 932, 0);
  v52 = *((_QWORD *)this + 15);
  if (v52)
  {
    LODWORD(v53) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v52 + 24))(v52);
    if (!(_DWORD)v53)
      goto LABEL_97;
  }
  else
  {
    v53 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (!(_DWORD)v53)
      goto LABEL_97;
  }
  v54 = 0;
  do
  {
    Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v54);
    (*(void (**)(uint64_t))(*(_QWORD *)Element + 128))(Element);
    ++v54;
  }
  while ((_DWORD)v53 != v54);
LABEL_97:
  v56 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
  (*(void (**)(uint64_t))(*(_QWORD *)v56 + 128))(v56);
  atomic_store(0, (unsigned int *)this + 3772);
  v57 = (uint64_t *)*((_QWORD *)this + 96);
  std::vector<std::vector<float>>::__clear[abi:ne180100](v57 + 4);
  v57[8] = v57[7];
  v58 = (_QWORD *)v57[11];
  v57[11] = 0;
  if (v58)
    std::default_delete<AUSM::InputABLBuffer>::operator()[abi:ne180100](v58);
  std::unique_ptr<APAC::Metadata>::reset[abi:ne180100](v57 + 3, 0);
  v59 = (std::__shared_weak_count *)*((_QWORD *)this + 441);
  *((_OWORD *)this + 220) = 0u;
  if (v59)
  {
    p_shared_owners = (unint64_t *)&v59->__shared_owners_;
    do
      v61 = __ldaxr(p_shared_owners);
    while (__stlxr(v61 - 1, p_shared_owners));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)this + 368, 0);
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)this + 369, 0);
  *((_DWORD *)this + 3773) = -1;
  atomic_store(0, (unsigned __int8 *)this + 2865);
  v62 = *((_QWORD *)this + 401);
  if (v62)
  {
    TorqueEngine::resizeBuffers((void **)v62, 0);
    *(_DWORD *)(v62 + 16832) = -1082130432;
    __asm { FMOV            V0.2S, #-1.0 }
    *(_QWORD *)(v62 + 16848) = _D0;
  }
  v68 = *(_OWORD *)&buf[8];
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(*(uint64_t *)buf);
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v68);
  return caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(*((uint64_t *)&v68 + 1));
}

void sub_1B6185B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  void *v32;
  void *v33;
  void *v34;

  if (a32 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::Reset(AUSpatialMixerV2 *this, int a2, unsigned int a3)
{
  NSObject *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t Element;
  OpaqueAudioComponentInstance ***v19;
  OpaqueAudioComponentInstance ***i;
  OpaqueAudioComponentInstance **v21;
  OpaqueAudioComponentInstance *v22;
  OSStatus v23;
  NSObject *v24;
  _QWORD *v25;
  ParametricFilters *v26;
  uint64_t v27;
  IR::FixedIntegerDelay *v28;
  IR::FixedIntegerDelay *v29;
  IR::FixedIntegerDelay *v30;
  IR::FixedIntegerDelay *v31;
  uint64_t v32;
  const char *v34;
  uint64_t v35[2];
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  _BYTE v39[14];
  __int16 v40;
  unsigned int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v6 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (char *)this + 3592;
    if (*((char *)this + 3615) < 0)
      v7 = *(const char **)v7;
    *(_DWORD *)buf = 136315906;
    v37 = v7;
    v38 = 2080;
    *(_QWORD *)v39 = "Reset";
    *(_WORD *)&v39[8] = 1024;
    *(_DWORD *)&v39[10] = a2;
    v40 = 1024;
    v41 = a3;
    _os_log_impl(&dword_1B5ED0000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] scope = %u, element = %u", buf, 0x22u);
  }

  v35[0] = (uint64_t)this + 3304;
  v35[1] = (uint64_t)this + 3320;
  std::lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>((uint64_t)this + 3304, (uint64_t)this + 3320);
  if (!a2)
  {
    v10 = atomic_load((unsigned __int8 *)this + 7441);
    if ((v10 & 1) != 0)
    {
      v11 = *((_QWORD *)this + 15);
      if (v11)
      {
        LODWORD(v12) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
        if (!(_DWORD)v12)
          goto LABEL_26;
LABEL_24:
        v17 = 0;
        do
        {
          Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v17);
          (*(void (**)(uint64_t))(*(_QWORD *)Element + 120))(Element);
          *(_OWORD *)(Element + 592) = 0u;
          *(_OWORD *)(Element + 608) = 0u;
          *(_OWORD *)(Element + 560) = 0u;
          *(_OWORD *)(Element + 576) = 0u;
          *(_OWORD *)(Element + 528) = 0u;
          *(_OWORD *)(Element + 544) = 0u;
          *(_OWORD *)(Element + 496) = 0u;
          *(_OWORD *)(Element + 512) = 0u;
          *(_OWORD *)(Element + 464) = 0u;
          *(_OWORD *)(Element + 480) = 0u;
          *(_OWORD *)(Element + 432) = 0u;
          *(_OWORD *)(Element + 448) = 0u;
          *(_OWORD *)(Element + 416) = 0u;
          *(_QWORD *)(Element + 656) = 0x3FF0000000000000;
          ++v17;
          *(_BYTE *)(Element + 672) = 1;
        }
        while ((_DWORD)v12 != v17);
        goto LABEL_26;
      }
      v12 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
      if ((_DWORD)v12)
        goto LABEL_24;
    }
LABEL_26:
    IR::SharedIRBuses::reset((AUSpatialMixerV2 *)((char *)this + 2328));
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 2256);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 281) + 32))(*((_QWORD *)this + 281));
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 2256);
    caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2 *)((char *)this + 2192));
    FeedbackDelayNetwork<float>::Reset((_OWORD *)this + 57);
    caulk::pooled_semaphore_mutex::_unlock((AUSpatialMixerV2 *)((char *)this + 2192));
    v19 = (OpaqueAudioComponentInstance ***)*((_QWORD *)this + 445);
    for (i = (OpaqueAudioComponentInstance ***)*((_QWORD *)this + 446); v19 != i; ++v19)
    {
      v21 = *v19;
      v22 = **v19;
      if (v22)
      {
        v23 = AudioUnitReset(v22, 0, 0);
        if (v23)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v24 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            v25 = v21 + 9;
            if (*((char *)v21 + 95) < 0)
              v25 = (_QWORD *)*v25;
            *(_DWORD *)buf = 136315650;
            v37 = "reset";
            v38 = 1024;
            *(_DWORD *)v39 = v23;
            *(_WORD *)&v39[4] = 2080;
            *(_QWORD *)&v39[6] = v25;
            _os_log_error_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_ERROR, "%s: error %d resetting %s", buf, 0x1Cu);
          }

        }
        *(_OWORD *)(v21 + 7) = 0u;
        *(_OWORD *)(v21 + 5) = 0u;
        *(_OWORD *)(v21 + 3) = 0u;
        *(_OWORD *)(v21 + 1) = 0u;
      }
    }
    *((_DWORD *)this + 1861) = -1;
    goto LABEL_40;
  }
  if (a2 != 1)
  {
LABEL_40:
    v26 = (ParametricFilters *)*((_QWORD *)this + 932);
    if (v26)
      ParametricFilters::reset(v26);
    AUSpatialMixerV2::ResetReverbFilters((uint64_t)this);
    v27 = *((_QWORD *)this + 363);
    if (v27)
      (*(void (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
    caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2 *)((char *)this + 15148));
    v28 = (IR::FixedIntegerDelay *)*((_QWORD *)this + 1887);
    v29 = (IR::FixedIntegerDelay *)*((_QWORD *)this + 1888);
    while (v28 != v29)
    {
      IR::FixedIntegerDelay::reset(v28);
      v28 = (IR::FixedIntegerDelay *)((char *)v28 + 56);
    }
    v30 = (IR::FixedIntegerDelay *)*((_QWORD *)this + 1890);
    v31 = (IR::FixedIntegerDelay *)*((_QWORD *)this + 1891);
    while (v30 != v31)
    {
      IR::FixedIntegerDelay::reset(v30);
      v30 = (IR::FixedIntegerDelay *)((char *)v30 + 56);
    }
    caulk::pooled_semaphore_mutex::_unlock((AUSpatialMixerV2 *)((char *)this + 15148));
    v32 = *((_QWORD *)this + 401);
    if (v32)
      Overlapper<float>::clear(v32 + 40);
    v16 = 0;
    *((_DWORD *)this + 804) = -1;
    goto LABEL_53;
  }
  v8 = *((_QWORD *)this + 15);
  if (v8)
    LODWORD(v9) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  else
    v9 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  if (v9 > a3)
  {
    v13 = atomic_load((unsigned __int8 *)this + 7441);
    if ((v13 & 1) != 0)
    {
      v14 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a3);
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 120))(v14);
    }
    goto LABEL_40;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v15 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    v34 = (char *)this + 3592;
    if (*((char *)this + 3615) < 0)
      v34 = *(const char **)v34;
    *(_DWORD *)buf = 136315650;
    v37 = v34;
    v38 = 2080;
    *(_QWORD *)v39 = "Reset";
    *(_WORD *)&v39[8] = 1024;
    *(_DWORD *)&v39[10] = a3;
    _os_log_error_impl(&dword_1B5ED0000, v15, OS_LOG_TYPE_ERROR, "[%s|%s] Invalid input scope element %u", buf, 0x1Cu);
  }

  v16 = 4294956419;
LABEL_53:
  std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100](v35);
  return v16;
}

void sub_1B61860E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::GetPropertyInfo(AUSpatialMixerV2 *this, signed int a2, unsigned int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  signed int v11;
  AUSM::Properties *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t PropertyInfo;
  uint64_t Element;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int *begin;
  int v39;
  std::vector<unsigned int>::pointer v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  unsigned int *v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t *v48;
  unsigned int *v50;
  unsigned int *v51;
  unsigned int *v52;
  unsigned int *v53;
  unsigned int *v54;
  unsigned int *v55;
  unsigned int *v56;
  unsigned int *v57;
  unsigned int *v58;
  unsigned int *v59;
  unsigned int *v60;
  unsigned int *v61;
  unsigned int *v62;
  unsigned int *v63;
  unsigned int *v64;
  unsigned int *v65;
  unsigned int *v66;
  unsigned int *v67;
  std::vector<unsigned int> v68;
  unsigned int v69;
  __int16 v70;
  int v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  if (a2 == 5679)
    v11 = 3112;
  else
    v11 = a2;
  if (a3 == 2)
  {
    if (a4)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v13 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v25 = (unsigned int *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v25 = *(unsigned int **)v25;
        LODWORD(v68.__begin_) = 136315906;
        *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v25;
        WORD2(v68.__end_) = 2080;
        *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
        HIWORD(v68.__end_cap_.__value_) = 1024;
        v69 = a4;
        v70 = 1024;
        v71 = v11;
        _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid output scope element = %u (property = %u)", (uint8_t *)&v68, 0x22u);
      }
      goto LABEL_33;
    }
    v12 = (AUSM::Properties *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 224);
    goto LABEL_17;
  }
  if (a3 != 1)
  {
    if (a3)
      return 4294956417;
    v12 = (AUSpatialMixerV2 *)((char *)this + 3584);
LABEL_17:
    PropertyInfo = AUSM::Properties::getPropertyInfo(v12, v11, a5, a6);
    goto LABEL_21;
  }
  v14 = *((_QWORD *)this + 15);
  if (v14)
    LODWORD(v15) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  else
    v15 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  if (v15 <= a4)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v13 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v26 = (unsigned int *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v26 = *(unsigned int **)v26;
      LODWORD(v68.__begin_) = 136315906;
      *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v26;
      WORD2(v68.__end_) = 2080;
      *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
      HIWORD(v68.__end_cap_.__value_) = 1024;
      v69 = a4;
      v70 = 1024;
      v71 = v11;
      _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid input scope element = %u (property = %u)", (uint8_t *)&v68, 0x22u);
    }
    goto LABEL_33;
  }
  v68.__begin_ = (std::vector<unsigned int>::pointer)((char *)this + 3352);
  LOBYTE(v68.__end_) = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
  Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
  PropertyInfo = AUSM::Properties::getPropertyInfo((AUSM::Properties *)(Element + 1056), v11, a5, a6);
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v68);
LABEL_21:
  if ((_DWORD)PropertyInfo != -10879)
    return PropertyInfo;
  PropertyInfo = 4294956417;
  if (v11 > 3293)
  {
    if (v11 > 5000)
    {
      switch(v11)
      {
        case 5001:
        case 5010:
          if (!a3)
            goto LABEL_97;
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            break;
          v44 = (unsigned int *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v44 = *(unsigned int **)v44;
          goto LABEL_208;
        case 5002:
          if (a3 >= 2)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v18 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            {
              v62 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v62 = *(unsigned int **)v62;
              LODWORD(v68.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v62;
              WORD2(v68.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
              HIWORD(v68.__end_cap_.__value_) = 1024;
              v69 = a3;
              v70 = 1024;
              v71 = 5002;
              _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", (uint8_t *)&v68, 0x22u);
            }
            break;
          }
          if (a3 != 1)
            goto LABEL_199;
          v31 = *((_QWORD *)this + 15);
          if (v31)
            LODWORD(v32) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v31 + 24))(v31);
          else
            v32 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
          if (v32 > a4)
            goto LABEL_199;
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v13 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            v67 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v67 = *(unsigned int **)v67;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v67;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a4;
            v70 = 1024;
            v71 = 5002;
            _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&v68, 0x22u);
          }
          goto LABEL_33;
        case 5003:
        case 5007:
        case 5008:
        case 5009:
          return PropertyInfo;
        case 5004:
        case 5005:
        case 5006:
          if (!a3)
            goto LABEL_199;
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            break;
          v44 = (unsigned int *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v44 = *(unsigned int **)v44;
          goto LABEL_208;
        case 5011:
          if (!a3)
            goto LABEL_97;
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v51 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v51 = *(unsigned int **)v51;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v51;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a3;
            v70 = 1024;
            v71 = 5011;
            _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&v68, 0x22u);
          }
          break;
        default:
          if (v11 == 5677)
          {
            PropertyInfo = 0;
            *a5 = 0;
            goto LABEL_125;
          }
          if (v11 != 5683)
            return PropertyInfo;
          if (!a3)
          {
LABEL_97:
            PropertyInfo = 0;
            v23 = 8;
            goto LABEL_124;
          }
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v55 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v55 = *(unsigned int **)v55;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v55;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a3;
            v70 = 1024;
            v71 = 5683;
            _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&v68, 0x22u);
          }
          break;
      }
LABEL_142:

      return 4294956430;
    }
    if (v11 == 3294)
    {
      if (a3)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v18 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          v52 = (unsigned int *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v52 = *(unsigned int **)v52;
          LODWORD(v68.__begin_) = 136315906;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v52;
          WORD2(v68.__end_) = 2080;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
          HIWORD(v68.__end_cap_.__value_) = 1024;
          v69 = a3;
          v70 = 1024;
          v71 = 3294;
          _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&v68, 0x22u);
        }
        goto LABEL_142;
      }
LABEL_103:
      PropertyInfo = 0;
      v24 = 16;
      goto LABEL_200;
    }
    if (v11 == 3295)
    {
LABEL_47:
      if (a3)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v18 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          v44 = (unsigned int *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v44 = *(unsigned int **)v44;
LABEL_208:
          LODWORD(v68.__begin_) = 136315906;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v44;
          WORD2(v68.__end_) = 2080;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
          HIWORD(v68.__end_cap_.__value_) = 1024;
          v69 = a3;
          v70 = 1024;
          v71 = v11;
          _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&v68, 0x22u);
        }
        goto LABEL_142;
      }
      goto LABEL_103;
    }
    return PropertyInfo;
  }
  if (v11 <= 3267)
  {
    switch(v11)
    {
      case 3215:
        if (a3 >= 2)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v58 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v58 = *(unsigned int **)v58;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v58;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a3;
            v70 = 1024;
            v71 = 3215;
            _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", (uint8_t *)&v68, 0x22u);
          }
          goto LABEL_142;
        }
        if (a3 == 1)
        {
          v27 = *((_QWORD *)this + 15);
          if (v27)
            LODWORD(v28) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
          else
            v28 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
          if (v28 <= a4)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v13 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            {
              v65 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v65 = *(unsigned int **)v65;
              LODWORD(v68.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v65;
              WORD2(v68.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
              HIWORD(v68.__end_cap_.__value_) = 1024;
              v69 = a4;
              v70 = 1024;
              v71 = 3215;
              _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&v68, 0x22u);
            }
            break;
          }
          v45 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
          v46 = *(uint64_t **)(v45 + 248);
          if (*(uint64_t **)(v45 + 256) == v46)
            goto LABEL_188;
          AUSpatialMixerV2ChannelProcessor::getDecorrFilterLengthsOnReverbSend(&v68, *v46);
        }
        else
        {
          v33 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), 0);
          v34 = *(_QWORD *)(v33 + 248);
          if (a4 >= (unint64_t)((*(_QWORD *)(v33 + 256) - v34) >> 3))
            goto LABEL_188;
          AUSpatialMixerV2ChannelProcessor::getDecorrFilterLengthsOnReverbSend(&v68, *(_QWORD *)(v34 + 8 * a4));
        }
        goto LABEL_186;
      case 3216:
        if (a3 >= 2)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v59 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v59 = *(unsigned int **)v59;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v59;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a3;
            v70 = 1024;
            v71 = 3216;
            _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", (uint8_t *)&v68, 0x22u);
          }
          goto LABEL_142;
        }
        if (a3 != 1)
        {
          v35 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), 0);
          v36 = *(_QWORD *)(v35 + 248);
          if (a4 < (unint64_t)((*(_QWORD *)(v35 + 256) - v36) >> 3))
          {
            AUSpatialMixerV2ChannelProcessor::getDecorrFilterCoeffsOnReverbSend((AUSpatialMixerV2ChannelProcessor *)&v68, *(_QWORD *)(v36 + 8 * a4));
            goto LABEL_186;
          }
LABEL_188:
          *a5 = 0;
          *a6 = 1;
          return 0;
        }
        v29 = *((_QWORD *)this + 15);
        if (v29)
          LODWORD(v30) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
        else
          v30 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
        if (v30 > a4)
        {
          v47 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
          v48 = *(uint64_t **)(v47 + 248);
          if (*(uint64_t **)(v47 + 256) != v48)
          {
            AUSpatialMixerV2ChannelProcessor::getDecorrFilterCoeffsOnReverbSend((AUSpatialMixerV2ChannelProcessor *)&v68, *v48);
LABEL_186:
            begin = v68.__begin_;
            *a5 = (LODWORD(v68.__end_) - LODWORD(v68.__begin_)) & 0xFFFFFFFC;
            *a6 = 1;
            if (!begin)
              return 0;
            v68.__end_ = begin;
LABEL_195:
            operator delete(begin);
            return 0;
          }
          goto LABEL_188;
        }
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v13 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          v66 = (unsigned int *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v66 = *(unsigned int **)v66;
          LODWORD(v68.__begin_) = 136315906;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v66;
          WORD2(v68.__end_) = 2080;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
          HIWORD(v68.__end_cap_.__value_) = 1024;
          v69 = a4;
          v70 = 1024;
          v71 = 3216;
          _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&v68, 0x22u);
        }
        break;
      case 3217:
      case 3218:
      case 3219:
      case 3220:
      case 3221:
      case 3223:
      case 3224:
        return PropertyInfo;
      case 3222:
        if (!a3)
        {
          PropertyInfo = 0;
          v24 = 24;
          goto LABEL_200;
        }
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v18 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          v50 = (unsigned int *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v50 = *(unsigned int **)v50;
          LODWORD(v68.__begin_) = 136315906;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v50;
          WORD2(v68.__end_) = 2080;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
          HIWORD(v68.__end_cap_.__value_) = 1024;
          v69 = a3;
          v70 = 1024;
          v71 = 3222;
          _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&v68, 0x22u);
        }
        goto LABEL_142;
      case 3225:
        if (a3 != 1)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v60 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v60 = *(unsigned int **)v60;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v60;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a3;
            v70 = 1024;
            v71 = 3225;
            _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for input scope property = %u", (uint8_t *)&v68, 0x22u);
          }
          goto LABEL_142;
        }
        v19 = *((_QWORD *)this + 15);
        if (v19)
          LODWORD(v20) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
        else
          v20 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
        if (v20 > a4)
          goto LABEL_199;
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v13 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          v63 = (unsigned int *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v63 = *(unsigned int **)v63;
          LODWORD(v68.__begin_) = 136315906;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v63;
          WORD2(v68.__end_) = 2080;
          *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
          HIWORD(v68.__end_cap_.__value_) = 1024;
          v69 = a4;
          v70 = 1024;
          v71 = 3225;
          _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&v68, 0x22u);
        }
        break;
      case 3226:
        if (a3 != 1)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v61 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v61 = *(unsigned int **)v61;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v61;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a3;
            v70 = 1024;
            v71 = 3226;
            _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for input scope property = %u", (uint8_t *)&v68, 0x22u);
          }
          goto LABEL_142;
        }
        v21 = *((_QWORD *)this + 15);
        if (v21)
          LODWORD(v22) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
        else
          v22 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
        if (v22 <= a4)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v13 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            v64 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v64 = *(unsigned int **)v64;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v64;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a4;
            v70 = 1024;
            v71 = 3226;
            _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&v68, 0x22u);
          }
          break;
        }
        v37 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
        AUSM::InputGeometry::getExclusionZones((AUSM::InputGeometry *)&v68, v37 + 1680);
        begin = v68.__begin_;
        if (v68.__begin_ == v68.__end_)
        {
          v39 = 0;
        }
        else
        {
          v39 = 0;
          v40 = v68.__begin_;
          do
          {
            v42 = *v40;
            v40 += 7;
            v41 = v42;
            v43 = v39 + 7;
            if (!v42)
              v39 += 5;
            if (v41 == 1)
              v39 = v43;
          }
          while (v40 != v68.__end_);
        }
        *a5 = 4 * v39;
        *a6 = 1;
        if (!begin)
          return 0;
        goto LABEL_195;
      default:
        if (v11 == 3107)
        {
          if (!a3)
            goto LABEL_199;
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v57 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v57 = *(unsigned int **)v57;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v57;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a3;
            v70 = 1024;
            v71 = 3107;
            _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&v68, 0x22u);
          }
          goto LABEL_142;
        }
        if (v11 != 3116)
          return PropertyInfo;
        if (a3)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v18 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v56 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v56 = *(unsigned int **)v56;
            LODWORD(v68.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v56;
            WORD2(v68.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
            HIWORD(v68.__end_cap_.__value_) = 1024;
            v69 = a3;
            v70 = 1024;
            v71 = 3116;
            _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&v68, 0x22u);
          }
          goto LABEL_142;
        }
        goto LABEL_123;
    }
LABEL_33:

    return 4294956419;
  }
  if (v11 == 3268)
  {
    if (a3)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v18 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        v53 = (unsigned int *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v53 = *(unsigned int **)v53;
        LODWORD(v68.__begin_) = 136315906;
        *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v53;
        WORD2(v68.__end_) = 2080;
        *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
        HIWORD(v68.__end_cap_.__value_) = 1024;
        v69 = a3;
        v70 = 1024;
        v71 = 3268;
        _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&v68, 0x22u);
      }
      goto LABEL_142;
    }
LABEL_199:
    PropertyInfo = 0;
    v24 = 8;
LABEL_200:
    *a5 = v24;
    *a6 = 1;
    return PropertyInfo;
  }
  if (v11 != 3270)
  {
    if (v11 != 3293)
      return PropertyInfo;
    goto LABEL_47;
  }
  if (a3)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v18 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      v54 = (unsigned int *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v54 = *(unsigned int **)v54;
      LODWORD(v68.__begin_) = 136315906;
      *(std::vector<unsigned int>::pointer *)((char *)&v68.__begin_ + 4) = v54;
      WORD2(v68.__end_) = 2080;
      *(std::vector<unsigned int>::pointer *)((char *)&v68.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetPropertyInfo";
      HIWORD(v68.__end_cap_.__value_) = 1024;
      v69 = a3;
      v70 = 1024;
      v71 = 3270;
      _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&v68, 0x22u);
    }
    goto LABEL_142;
  }
LABEL_123:
  PropertyInfo = 0;
  v23 = 4;
LABEL_124:
  *a5 = v23;
LABEL_125:
  *a6 = 0;
  return PropertyInfo;
}

void sub_1B618778C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::GetProperty(AUSpatialMixerV2 *this, signed int a2, unsigned int a3, unsigned int a4, ausdk **a5)
{
  signed int v9;
  AUSM::Properties *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t Property;
  uint64_t Element;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  NSObject *v22;
  unsigned int *v23;
  unsigned int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  int v32;
  int v33;
  std::vector<unsigned int>::pointer v34;
  std::vector<unsigned int>::pointer v35;
  std::vector<unsigned int>::pointer v36;
  void *v37;
  std::vector<unsigned int>::pointer v38;
  unsigned __int128 *v39;
  unsigned __int128 v40;
  unsigned __int128 *v41;
  unsigned __int128 v42;
  int32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  unsigned __int128 *v47;
  unsigned __int128 v48;
  float v49;
  float32x4_t v50;
  float v51;
  uint64_t v52;
  uint64_t v53;
  _DWORD *v54;
  const __CFDictionary **v55;
  const __CFDictionary **v56;
  const __CFDictionary **v57;
  const __CFDictionary **v58;
  const __CFDictionary **v59;
  const __CFDictionary **v60;
  const void **v61;
  const __CFDictionary **v62;
  const __CFDictionary **v63;
  const __CFDictionary **v64;
  const __CFDictionary **v65;
  const __CFDictionary **v66;
  const __CFDictionary **v67;
  const __CFDictionary **v68;
  const __CFDictionary **v69;
  unsigned __int16 v70;
  char v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  const __CFDictionary **v75;
  uint64_t v76;
  _BOOL4 v77;
  unsigned int v78;
  uint64_t v79;
  uint64_t v80;
  unsigned __int8 v81;
  int v82;
  std::vector<unsigned int>::pointer v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  unsigned int *value;
  uint64_t v98;
  CFTypeRef v99;
  float32x4_t v100;
  unint64_t v101;
  CFDictionaryRef CFDictionaryRef;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unsigned int *v108;
  uint64_t v109;
  std::vector<unsigned int>::pointer v110;
  std::vector<unsigned int> *p_buf;
  void *v112;
  unsigned int v113;
  uint64_t v114;
  void *v115;
  void *v116;
  unsigned __int8 v117;
  void *v118;
  unsigned __int8 v119;
  void *v120;
  void *v121;
  unsigned __int8 v122;
  void *v123;
  void *v124;
  unsigned __int8 v125;
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  uint64_t v130;
  void *v131;
  uint64_t v132;
  uint64_t v133;
  char *v134;
  char *v135;
  void *v136;
  char *v137;
  char *v138;
  BOOL v139;
  uint64_t v140;
  uint64_t *v141;
  uint64_t v142;
  uint64_t *v143;
  uint64_t v144;
  double v145;
  std::vector<unsigned int>::pointer begin;
  std::vector<unsigned int>::pointer end;
  std::vector<unsigned int>::pointer v148;
  void *v149;
  uint64_t v150;
  uint64_t v151;
  _BOOL4 v152;
  uint64_t v153;
  CFDictionaryRef v154;
  const void *v155;
  uint64_t i;
  const void *v157;
  const void *v158;
  const void *v159;
  unsigned int *v161;
  unsigned int *v162;
  unsigned int *v163;
  unsigned int *v164;
  unsigned int *v165;
  unsigned int *v166;
  unsigned int *v167;
  unsigned int *v168;
  unsigned int *v169;
  unsigned int *v170;
  unsigned int *v171;
  unsigned int *v172;
  unsigned int *v173;
  unsigned int *v174;
  unsigned int *v175;
  unsigned int *v176;
  unsigned int *v177;
  unsigned int *v178;
  unsigned int *v179;
  unsigned int *v180;
  void *v181;
  void *v182;
  CFArrayRef v183;
  CFDictionaryRef v184;
  unsigned __int128 v185;
  unint64_t v186;
  const void *v187;
  char v188;
  int v189;
  float v190;
  int v191;
  float v192;
  int v193;
  float v194;
  int v195;
  float v196;
  int v197;
  float v198;
  int v199;
  float v200;
  int v201;
  CFTypeRef v202;
  CFTypeRef cf;
  _QWORD v204[9];
  uint64_t v205;
  uint64_t v206;
  void *v207;
  void *v208;
  void *v209;
  void *v210;
  void *v211;
  CFTypeRef v212;
  void *v213;
  std::vector<unsigned int> buf;
  __int128 v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  _QWORD v220[2];
  uint64_t v221;
  _QWORD v222[2];
  _BYTE v223[8];
  _QWORD v224[5];

  v224[2] = *MEMORY[0x1E0C80C00];
  if (a2 == 5679)
    v9 = 3112;
  else
    v9 = a2;
  if (a3 != 2)
  {
    if (a3 != 1)
    {
      if (a3)
        return 4294956417;
      v10 = (AUSpatialMixerV2 *)((char *)this + 3584);
      goto LABEL_25;
    }
    v11 = *((_QWORD *)this + 15);
    if (v11)
      LODWORD(v12) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
    else
      v12 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (v12 > a4)
    {
      buf.__begin_ = (std::vector<unsigned int>::pointer)((char *)this + 3352);
      LOBYTE(buf.__end_) = 1;
      std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
      Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
      Property = AUSM::Properties::getProperty((AUSM::Properties *)(Element + 1056), v9, a5);
      std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&buf);
      goto LABEL_26;
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v13 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v24 = (unsigned int *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v24 = *(unsigned int **)v24;
      LODWORD(buf.__begin_) = 136315906;
      *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v24;
      WORD2(buf.__end_) = 2080;
      *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
      HIWORD(buf.__end_cap_.__value_) = 1024;
      LODWORD(v215) = a4;
      WORD2(v215) = 1024;
      *(_DWORD *)((char *)&v215 + 6) = v9;
      _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid input scope element = %u (property = %u)", (uint8_t *)&buf, 0x22u);
    }
LABEL_22:

    return 4294956419;
  }
  if (a4)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v13 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v23 = (unsigned int *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v23 = *(unsigned int **)v23;
      LODWORD(buf.__begin_) = 136315906;
      *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v23;
      WORD2(buf.__end_) = 2080;
      *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
      HIWORD(buf.__end_cap_.__value_) = 1024;
      LODWORD(v215) = a4;
      WORD2(v215) = 1024;
      *(_DWORD *)((char *)&v215 + 6) = v9;
      _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid output scope element = %u (property = %u)", (uint8_t *)&buf, 0x22u);
    }
    goto LABEL_22;
  }
  v10 = (AUSM::Properties *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 224);
LABEL_25:
  Property = AUSM::Properties::getProperty(v10, v9, a5);
LABEL_26:
  if ((_DWORD)Property == -10879)
  {
    Property = 4294956417;
    if (v9 > 5000)
    {
      switch(v9)
      {
        case 5001:
          if (a3)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v162 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v162 = *(unsigned int **)v162;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v162;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 5001;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
            }
            goto LABEL_126;
          }
          AUSpatialMixerV2::GetFileNamesDictionary(this);
          Property = 0;
          *a5 = (ausdk *)objc_claimAutoreleasedReturnValue();
          return Property;
        case 5002:
          if (a3 >= 2)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v171 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v171 = *(unsigned int **)v171;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v171;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 5002;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", (uint8_t *)&buf, 0x22u);
            }
            goto LABEL_126;
          }
          if (a3 == 1)
          {
            v25 = *((_QWORD *)this + 15);
            if (v25)
              LODWORD(v26) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25);
            else
              v26 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
            if (v26 <= a4)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v13 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
              {
                v178 = (unsigned int *)((char *)this + 3592);
                if (*((char *)this + 3615) < 0)
                  v178 = *(unsigned int **)v178;
                LODWORD(buf.__begin_) = 136315906;
                *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v178;
                WORD2(buf.__end_) = 2080;
                *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
                HIWORD(buf.__end_cap_.__value_) = 1024;
                LODWORD(v215) = a4;
                WORD2(v215) = 1024;
                *(_DWORD *)((char *)&v215 + 6) = 5002;
                _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&buf, 0x22u);
              }
              goto LABEL_22;
            }
          }
          objc_msgSend(MEMORY[0x1E0C99DE8], "array");
          v131 = (void *)objc_claimAutoreleasedReturnValue();
          if (a3)
          {
            v132 = *((_QWORD *)this + 15);
            if (v132)
              LODWORD(v133) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v132 + 24))(v132);
            else
              v133 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
            if (v133 <= a4)
            {

              return 4294956419;
            }
            v144 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
            *(_QWORD *)&v145 = AUSpatialMixerV2InputElement::GetChannelParameters((AUSpatialMixerV2InputElement *)&buf, v144).n128_u64[0];
            begin = buf.__begin_;
            end = buf.__end_;
            if (buf.__begin_ != buf.__end_)
            {
              v148 = buf.__begin_;
              do
              {
                objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v148, 32, v145);
                v149 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v131, "addObject:", v149);

                v148 += 8;
              }
              while (v148 != end);
            }
            if (begin)
              operator delete(begin);
          }
          else
          {
            v134 = (char *)*((_QWORD *)this + 408);
            v135 = (char *)this + 3272;
            if (v134 != v135)
            {
              do
              {
                objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v134 + 32, 32);
                v136 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v131, "addObject:", v136);

                v137 = (char *)*((_QWORD *)v134 + 1);
                if (v137)
                {
                  do
                  {
                    v138 = v137;
                    v137 = *(char **)v137;
                  }
                  while (v137);
                }
                else
                {
                  do
                  {
                    v138 = (char *)*((_QWORD *)v134 + 2);
                    v139 = *(_QWORD *)v138 == (_QWORD)v134;
                    v134 = v138;
                  }
                  while (!v139);
                }
                v134 = v138;
              }
              while (v138 != v135);
            }
          }
          Property = 0;
          *a5 = (ausdk *)v131;
          return Property;
        case 5003:
        case 5007:
        case 5008:
        case 5009:
          return Property;
        case 5004:
        case 5005:
        case 5006:
          if (*((_BYTE *)this + 6128))
            return 0;
          if (a3)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v161 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v161 = *(unsigned int **)v161;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v161;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = v9;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
            }
            goto LABEL_126;
          }
          objc_msgSend(MEMORY[0x1E0C99DE8], "array");
          v31 = (void *)objc_claimAutoreleasedReturnValue();
          if (v9 == 5006)
            v32 = 1;
          else
            v32 = 3;
          if (v9 == 5005)
            v33 = 2;
          else
            v33 = v32;
          AUSM::SoundStage::getSoundStageParameters((AUSM::SoundStage *)&buf, (uint64_t)this + 6336, v33);
          v34 = buf.__begin_;
          v35 = buf.__end_;
          if (buf.__begin_ != buf.__end_)
          {
            v36 = buf.__begin_;
            do
            {
              objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v36, 32);
              v37 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v31, "addObject:", v37);

              v36 += 8;
            }
            while (v36 != v35);
          }
          *a5 = (ausdk *)v31;
          if (v34)
          {
            v38 = v34;
LABEL_266:
            operator delete(v38);
          }
          return 0;
        case 5010:
          if (a3)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v163 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v163 = *(unsigned int **)v163;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v163;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 5010;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
            }
            goto LABEL_126;
          }
          buf.__begin_ = 0;
          buf.__end_ = 0;
          v39 = (unsigned __int128 *)((char *)this + 3696);
          do
            v40 = __ldaxp(v39);
          while (__stlxp(v40, v39));
          v41 = (unsigned __int128 *)((char *)this + 3712);
          do
            v42 = __ldaxp(v41);
          while (__stlxp(v42, v41));
          v43 = (int32x4_t)vnegq_f32((float32x4_t)v42);
          v44 = (int8x16_t)vtrn2q_s32((int32x4_t)v42, vtrn1q_s32((int32x4_t)v42, v43));
          v45 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v43, 8uLL), *(float32x2_t *)&v40, 1), (float32x4_t)vextq_s8(v44, v44, 8uLL), *(float *)&v40);
          v46 = (float32x4_t)vrev64q_s32((int32x4_t)v42);
          v46.i32[0] = v43.i32[1];
          v46.i32[3] = v43.i32[2];
          *(float32x4_t *)&buf.__begin_ = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)v42, (float32x4_t)v40, 3), v46, (float32x4_t)v40, 2), v45);
          DWORD2(v185) = 0;
          *(_QWORD *)&v185 = 0;
          v47 = (unsigned __int128 *)((char *)this + 3728);
          do
            v48 = __ldaxp(v47);
          while (__stlxp(v48, v47));
          v185 = v48;
          v49 = COERCE_FLOAT(atomic_load((unsigned int *)this + 938));
          if (v49 >= 0.0)
          {
            v50 = vmulq_f32((float32x4_t)v185, (float32x4_t)v185);
            v51 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).f32[0]);
            if (v51 > 0.0 && (float)(v49 / v51) < 1.0)
              v185 = (unsigned __int128)vmulq_n_f32((float32x4_t)v185, v49 / v51);
          }
          v187 = (char *)this + 3352;
          v188 = 1;
          std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
          v52 = *((_QWORD *)this + 15);
          if (v52)
            LODWORD(v53) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v52 + 24))(v52);
          else
            v53 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
          v112 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", v53);
          if ((_DWORD)v53)
          {
            v113 = 0;
            do
            {
              v114 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v113);
              AUSpatialMixerV2InputElement::GetGeometry((AUSpatialMixerV2InputElement *)&v202, v114);
              v115 = (void *)v202;
              v202 = 0;
              objc_msgSend(v112, "addObject:", v115);

              ++v113;
            }
            while ((_DWORD)v53 != v113);
          }
          v202 = 0;
          ausdk::AUBase::SaveState(this, (ausdk **)&v202);
          v204[0] = CFSTR("PresetLoaded");
          v116 = (void *)MEMORY[0x1E0CB37E8];
          v117 = atomic_load((unsigned __int8 *)this + 3240);
          objc_msgSend(v116, "numberWithBool:", v117 & 1);
          v205 = objc_claimAutoreleasedReturnValue();
          v204[1] = CFSTR("Initialized");
          v182 = (void *)v205;
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", *((unsigned __int8 *)this + 17));
          v206 = objc_claimAutoreleasedReturnValue();
          v204[2] = CFSTR("Reinitialized");
          v118 = (void *)MEMORY[0x1E0CB37E8];
          v119 = atomic_load((unsigned __int8 *)this + 3241);
          v181 = (void *)v206;
          objc_msgSend(v118, "numberWithBool:", v119 & 1);
          v120 = (void *)objc_claimAutoreleasedReturnValue();
          v207 = v120;
          v204[3] = CFSTR("ChannelLayoutChanged");
          v121 = (void *)MEMORY[0x1E0CB37E8];
          v122 = atomic_load((unsigned __int8 *)this + 3242);
          objc_msgSend(v121, "numberWithBool:", v122 & 1);
          v123 = (void *)objc_claimAutoreleasedReturnValue();
          v208 = v123;
          v204[4] = CFSTR("PositionParametersChanged");
          v124 = (void *)MEMORY[0x1E0CB37E8];
          v125 = atomic_load((unsigned __int8 *)this + 3243);
          objc_msgSend(v124, "numberWithBool:", v125 & 1);
          v126 = (void *)objc_claimAutoreleasedReturnValue();
          v209 = v126;
          v204[5] = CFSTR("HeadOrientationQuaternion");
          objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &buf, 16);
          v127 = (void *)objc_claimAutoreleasedReturnValue();
          v210 = v127;
          v204[6] = CFSTR("ListenerPosition");
          objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v185, 12);
          v128 = (void *)objc_claimAutoreleasedReturnValue();
          v129 = (void *)v202;
          v211 = v128;
          v212 = v202;
          v204[7] = CFSTR("AllParameters");
          v204[8] = CFSTR("Geometry");
          v213 = v112;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v205, v204, 9);
          v130 = objc_claimAutoreleasedReturnValue();

          atomic_store(0, (unsigned __int8 *)this + 3240);
          atomic_store(0, (unsigned __int8 *)this + 3241);
          atomic_store(0, (unsigned __int8 *)this + 3242);
          atomic_store(0, (unsigned __int8 *)this + 3243);
          *a5 = (ausdk *)v130;

          goto LABEL_231;
        case 5011:
          if (!a3)
          {
            ausdk::AUBase::SaveState(this, a5);
            return 0;
          }
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v16 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            v164 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v164 = *(unsigned int **)v164;
            LODWORD(buf.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v164;
            WORD2(buf.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
            HIWORD(buf.__end_cap_.__value_) = 1024;
            LODWORD(v215) = a3;
            WORD2(v215) = 1024;
            *(_DWORD *)((char *)&v215 + 6) = 5011;
            _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
          }
          goto LABEL_126;
        default:
          if (v9 == 5677)
          {
            v21 = (void *)*((_QWORD *)this + 356);
            applesauce::dispatch::v1::queue::get(v21);
            v22 = objc_claimAutoreleasedReturnValue();
            dispatch_sync(v22, &__block_literal_global_182);

            return 0;
          }
          if (v9 != 5683)
            return Property;
          if (a3)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v170 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v170 = *(unsigned int **)v170;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v170;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 5683;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
            }
            goto LABEL_126;
          }
          v187 = (char *)this + 3352;
          v188 = 1;
          std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
          v84 = 0;
          v185 = 0uLL;
          v186 = 0;
          while (1)
          {
            v85 = *((_QWORD *)this + 15);
            if (v85)
              LODWORD(v86) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v85 + 24))(v85);
            else
              v86 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
            if (v84 >= v86)
              break;
            v87 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v84);
            AUSpatialMixerV2InputElement::GetGeometry((AUSpatialMixerV2InputElement *)&v202, v87);
            v88 = (_QWORD *)*((_QWORD *)&v185 + 1);
            if (*((_QWORD *)&v185 + 1) >= v186)
            {
              v89 = v185;
              v90 = (uint64_t)(*((_QWORD *)&v185 + 1) - v185) >> 3;
              v91 = v90 + 1;
              if ((unint64_t)(v90 + 1) >> 61)
                std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
              v92 = v186 - v185;
              if ((uint64_t)(v186 - v185) >> 2 > v91)
                v91 = v92 >> 2;
              if ((unint64_t)v92 >= 0x7FFFFFFFFFFFFFF8)
                v93 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v93 = v91;
              *((_QWORD *)&v215 + 1) = &v186;
              if (v93)
              {
                v93 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v93);
                v88 = (_QWORD *)*((_QWORD *)&v185 + 1);
                v89 = v185;
              }
              else
              {
                v94 = 0;
              }
              v95 = v93 + 8 * v90;
              v96 = v93 + 8 * v94;
              *(_QWORD *)&v215 = v96;
              *(_QWORD *)v95 = v202;
              value = (unsigned int *)(v95 + 8);
              v202 = 0;
              buf.__end_cap_.__value_ = (unsigned int *)(v95 + 8);
              if (v88 == (_QWORD *)v89)
              {
                v99 = 0;
              }
              else
              {
                do
                {
                  v98 = *--v88;
                  *(_QWORD *)(v95 - 8) = v98;
                  v95 -= 8;
                  *v88 = 0;
                }
                while (v88 != (_QWORD *)v89);
                value = buf.__end_cap_.__value_;
                v96 = v215;
                v99 = v202;
              }
              v100 = (float32x4_t)v185;
              *(_QWORD *)&v185 = v95;
              *(float32x4_t *)&buf.__end_ = v100;
              v101 = v186;
              v186 = v96;
              *(_QWORD *)&v215 = v101;
              buf.__begin_ = (std::vector<unsigned int>::pointer)v100.i64[0];
              std::__split_buffer<applesauce::CF::ArrayRef>::~__split_buffer((uint64_t)&buf);
              *((_QWORD *)&v185 + 1) = value;
              if (v99)
                CFRelease(v99);
            }
            else
            {
              **((_QWORD **)&v185 + 1) = v202;
              *((_QWORD *)&v185 + 1) = v88 + 1;
            }
            ++v84;
          }
          v183 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::ArrayRef>((uint64_t **)&v185);
          applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],applesauce::CF::ArrayRef>((applesauce::CF::TypeRef *)&v202, "InputArray", (const void **)&v183);
          buf.__begin_ = (std::vector<unsigned int>::pointer)&v202;
          buf.__end_ = (std::vector<unsigned int>::pointer)1;
          CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&buf);
          v184 = CFDictionaryRef;
          if (cf)
            CFRelease(cf);
          if (v202)
            CFRelease(v202);
          applesauce::CF::ArrayRef::~ArrayRef((const void **)&v183);
          v184 = 0;
          *a5 = CFDictionaryRef;
          applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v184);
          buf.__begin_ = (std::vector<unsigned int>::pointer)&v185;
          std::vector<applesauce::CF::ArrayRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
LABEL_231:
          p_buf = (std::vector<unsigned int> *)&v187;
          break;
      }
LABEL_232:
      std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)p_buf);
      return 0;
    }
    if (v9 > 3214)
    {
      switch(v9)
      {
        case 3215:
          if (a3 >= 2)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v174 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v174 = *(unsigned int **)v174;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v174;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 3215;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", (uint8_t *)&buf, 0x22u);
            }
            break;
          }
          if (a3 == 1)
          {
            v27 = *((_QWORD *)this + 15);
            if (v27)
              LODWORD(v28) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
            else
              v28 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
            if (v28 <= a4)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v13 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
              {
                v179 = (unsigned int *)((char *)this + 3592);
                if (*((char *)this + 3615) < 0)
                  v179 = *(unsigned int **)v179;
                LODWORD(buf.__begin_) = 136315906;
                *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v179;
                WORD2(buf.__end_) = 2080;
                *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
                HIWORD(buf.__end_cap_.__value_) = 1024;
                LODWORD(v215) = a4;
                WORD2(v215) = 1024;
                *(_DWORD *)((char *)&v215 + 6) = 3215;
                _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&buf, 0x22u);
              }
              goto LABEL_22;
            }
            v140 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
            v141 = *(uint64_t **)(v140 + 248);
            if (*(uint64_t **)(v140 + 256) == v141)
              return 0;
            AUSpatialMixerV2ChannelProcessor::getDecorrFilterLengthsOnReverbSend(&buf, *v141);
          }
          else
          {
            v103 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), 0);
            v104 = *(_QWORD *)(v103 + 248);
            if (a4 >= (unint64_t)((*(_QWORD *)(v103 + 256) - v104) >> 3))
              return 0;
            AUSpatialMixerV2ChannelProcessor::getDecorrFilterLengthsOnReverbSend(&buf, *(_QWORD *)(v104 + 8 * a4));
          }
          goto LABEL_263;
        case 3216:
          if (a3 >= 2)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v175 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v175 = *(unsigned int **)v175;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v175;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 3216;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", (uint8_t *)&buf, 0x22u);
            }
            break;
          }
          if (a3 == 1)
          {
            v29 = *((_QWORD *)this + 15);
            if (v29)
              LODWORD(v30) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
            else
              v30 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
            if (v30 <= a4)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v13 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
              {
                v180 = (unsigned int *)((char *)this + 3592);
                if (*((char *)this + 3615) < 0)
                  v180 = *(unsigned int **)v180;
                LODWORD(buf.__begin_) = 136315906;
                *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v180;
                WORD2(buf.__end_) = 2080;
                *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
                HIWORD(buf.__end_cap_.__value_) = 1024;
                LODWORD(v215) = a4;
                WORD2(v215) = 1024;
                *(_DWORD *)((char *)&v215 + 6) = 3216;
                _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&buf, 0x22u);
              }
              goto LABEL_22;
            }
            v142 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
            v143 = *(uint64_t **)(v142 + 248);
            if (*(uint64_t **)(v142 + 256) == v143)
              return 0;
            AUSpatialMixerV2ChannelProcessor::getDecorrFilterCoeffsOnReverbSend((AUSpatialMixerV2ChannelProcessor *)&buf, *v143);
          }
          else
          {
            v105 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), 0);
            v106 = *(_QWORD *)(v105 + 248);
            if (a4 >= (unint64_t)((*(_QWORD *)(v105 + 256) - v106) >> 3))
              return 0;
            AUSpatialMixerV2ChannelProcessor::getDecorrFilterCoeffsOnReverbSend((AUSpatialMixerV2ChannelProcessor *)&buf, *(_QWORD *)(v106 + 8 * a4));
          }
LABEL_263:
          v108 = buf.__begin_;
          memcpy(a5, buf.__begin_, (char *)buf.__end_ - (char *)buf.__begin_);
          if (!v108)
            return 0;
          buf.__end_ = v108;
          goto LABEL_265;
        case 3217:
        case 3218:
        case 3219:
        case 3220:
        case 3221:
        case 3223:
        case 3224:
          return Property;
        case 3222:
          if (!a3)
          {
            v54 = (_DWORD *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), 0);
            AUSpatialMixerV2InputElement::GetParametricProcessorParams((AUSpatialMixerV2InputElement *)&buf, v54);
            v55 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&buf);
            *(float *)a5 = applesauce::CF::details::find_at_key<float,char const(&)[5]>(*v55);
            v56 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&buf);
            *((float *)a5 + 1) = applesauce::CF::details::find_at_key<float,char const(&)[16]>(*v56);
            v57 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&buf);
            *((float *)a5 + 2) = applesauce::CF::details::find_at_key<float,char const(&)[19]>(*v57);
            v58 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&buf);
            *((float *)a5 + 3) = applesauce::CF::details::find_at_key<float,char const(&)[13]>(*v58, "AnalysisType");
            v59 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&buf);
            *((float *)a5 + 4) = applesauce::CF::details::find_at_key<float,char const(&)[10]>(*v59);
            v60 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&buf);
            *((float *)a5 + 5) = applesauce::CF::details::find_at_key<float,char const(&)[8]>(*v60);
            applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&buf.__begin_);
            return 0;
          }
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v16 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            v165 = (unsigned int *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v165 = *(unsigned int **)v165;
            LODWORD(buf.__begin_) = 136315906;
            *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v165;
            WORD2(buf.__end_) = 2080;
            *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
            HIWORD(buf.__end_cap_.__value_) = 1024;
            LODWORD(v215) = a3;
            WORD2(v215) = 1024;
            *(_DWORD *)((char *)&v215 + 6) = 3222;
            _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
          }
          break;
        case 3225:
          if (a3 != 1)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v173 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v173 = *(unsigned int **)v173;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v173;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 3225;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for input scope property = %u", (uint8_t *)&buf, 0x22u);
            }
            break;
          }
          v19 = *((_QWORD *)this + 15);
          if (v19)
            LODWORD(v20) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
          else
            v20 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
          if (v20 <= a4)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v13 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            {
              v177 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v177 = *(unsigned int **)v177;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v177;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a4;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 3225;
              _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&buf, 0x22u);
            }
            goto LABEL_22;
          }
          v109 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
          AUSM::InputGeometry::getExclusionZones((AUSM::InputGeometry *)&buf, v109 + 1680);
          v110 = buf.__begin_;
          AUSM::ExclusionZone::exclusionZonesToDictionary((CFDictionaryRef *)&buf, buf.__begin_, buf.__end_);
          *a5 = (ausdk *)CFRetain(buf.__begin_);
          applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&buf.__begin_);
          if (!v110)
            return 0;
          v38 = v110;
          goto LABEL_266;
        case 3226:
          if (a3 != 1)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v172 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v172 = *(unsigned int **)v172;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v172;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 3226;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for input scope property = %u", (uint8_t *)&buf, 0x22u);
            }
            break;
          }
          v17 = *((_QWORD *)this + 15);
          if (v17)
            LODWORD(v18) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
          else
            v18 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
          if (v18 <= a4)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v13 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            {
              v176 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v176 = *(unsigned int **)v176;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v176;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a4;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 3226;
              _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", (uint8_t *)&buf, 0x22u);
            }
            goto LABEL_22;
          }
          v107 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
          AUSM::InputGeometry::getExclusionZones((AUSM::InputGeometry *)&buf, v107 + 1680);
          v108 = buf.__begin_;
          AUSM::ExclusionZone::arrayFromZones(buf.__begin_, buf.__end_, (uint64_t)a5);
          if (!v108)
            return 0;
LABEL_265:
          v38 = v108;
          goto LABEL_266;
        default:
          if (v9 == 3268)
          {
            if (!a3)
            {
              AUSM::SoundStage::getSoundStageParametersDictionary((AUSM::SoundStage *)&buf, (uint64_t)this + 6912);
              v83 = buf.__begin_;
              buf.__begin_ = 0;
              *a5 = (ausdk *)v83;
              applesauce::CF::ArrayRef::~ArrayRef((const void **)&buf.__begin_);
              return 0;
            }
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v168 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v168 = *(unsigned int **)v168;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v168;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 3268;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
            }
          }
          else
          {
            if (v9 != 3270)
              return Property;
            if (!a3)
            {
              std::recursive_mutex::lock((std::recursive_mutex *)this + 11);
              *(_DWORD *)a5 = *((unsigned __int8 *)this + 696);
              std::recursive_mutex::unlock((std::recursive_mutex *)this + 11);
              return 0;
            }
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v16 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              v169 = (unsigned int *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v169 = *(unsigned int **)v169;
              LODWORD(buf.__begin_) = 136315906;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v169;
              WORD2(buf.__end_) = 2080;
              *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
              HIWORD(buf.__end_cap_.__value_) = 1024;
              LODWORD(v215) = a3;
              WORD2(v215) = 1024;
              *(_DWORD *)((char *)&v215 + 6) = 3270;
              _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
            }
          }
          break;
      }
LABEL_126:

      return 4294956430;
    }
    if (v9 == 3107)
    {
      if (a3)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v16 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          v166 = (unsigned int *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v166 = *(unsigned int **)v166;
          LODWORD(buf.__begin_) = 136315906;
          *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v166;
          WORD2(buf.__end_) = 2080;
          *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
          HIWORD(buf.__end_cap_.__value_) = 1024;
          LODWORD(v215) = a3;
          WORD2(v215) = 1024;
          *(_DWORD *)((char *)&v215 + 6) = 3107;
          _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
        }
        goto LABEL_126;
      }
      v61 = (const void **)((char *)this + 3248);
      if (*((_QWORD *)this + 406))
      {
        v62 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->((_QWORD *)this + 406);
        LODWORD(v184) = 1101004800;
        LODWORD(v202) = applesauce::CF::at_or<float,char const(&)[12]>(*v62, (uint64_t)&v184);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float>((applesauce::CF::TypeRef *)&buf, (int *)&v202);
        v63 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->((_QWORD *)this + 406);
        v201 = 1086324736;
        LODWORD(v183) = applesauce::CF::at_or<float,char const(&)[15]>(*v63, (uint64_t)&v201);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float>((applesauce::CF::TypeRef *)&buf.__end_cap_, (int *)&v183);
        v64 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->((_QWORD *)this + 406);
        v199 = -1061158912;
        v200 = applesauce::CF::at_or<float,char const(&)[11]>(*v64, "Constraint", (uint64_t)&v199);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float>((applesauce::CF::TypeRef *)((char *)&v215 + 8), (int *)&v200);
        v65 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->((_QWORD *)this + 406);
        v197 = 1186693120;
        v198 = applesauce::CF::at_or<float,char const(&)[21]>(*v65, (uint64_t)&v197);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[21],float>((applesauce::CF::TypeRef *)&v216, (int *)&v198);
        v66 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->((_QWORD *)this + 406);
        v195 = 1120403456;
        v196 = applesauce::CF::at_or<float,char const(&)[17]>(*v66, "PostTimbralBlend", (uint64_t)&v195);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[17],float>((applesauce::CF::TypeRef *)&v217, "PostTimbralBlend", (int *)&v196);
        v67 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->((_QWORD *)this + 406);
        v193 = 1175232512;
        v194 = applesauce::CF::at_or<float,char const(&)[10]>(*v67, (uint64_t)&v193);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[10],float>((applesauce::CF::TypeRef *)&v218, (int *)&v194);
        v68 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->((_QWORD *)this + 406);
        v191 = 0;
        v192 = applesauce::CF::at_or<float,char const(&)[9]>(*v68, (uint64_t)&v191);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],float>((applesauce::CF::TypeRef *)&v219, (int *)&v192);
        v69 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->((_QWORD *)this + 406);
        v70 = applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[25]>(*v69, "CounteractRotationShader");
        applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v220, "CounteractRotationShader");
        v71 = v70;
        if (v70 <= 0x100u)
          v71 = 0;
        v72 = *MEMORY[0x1E0C9AE50];
        v73 = *MEMORY[0x1E0C9AE40];
        if (v71)
          v74 = *MEMORY[0x1E0C9AE50];
        else
          v74 = *MEMORY[0x1E0C9AE40];
        v220[1] = v74;
        v75 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->((_QWORD *)this + 406);
        v189 = 1132462080;
        v190 = applesauce::CF::at_or<float,char const(&)[13]>(*v75, "FilterLength", (uint64_t)&v189);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],float>((applesauce::CF::TypeRef *)&v221, (int *)&v190);
        v76 = *((_QWORD *)this + 925);
        if (v76)
          v77 = *(unsigned __int8 *)(v76 + 57) != 0;
        else
          v77 = 0;
        applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v222, "MagicUnicorn");
        if (v77)
          v150 = v72;
        else
          v150 = v73;
        v222[1] = v150;
        v151 = *((_QWORD *)this + 925);
        if (v151)
          v152 = *(_QWORD *)(v151 + 784) != 0;
        else
          v152 = 0;
        applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v223, "ReferenceData");
        if (v152)
          v153 = v72;
        else
          v153 = v73;
        v224[0] = v153;
        *(_QWORD *)&v185 = &buf;
        *((_QWORD *)&v185 + 1) = 11;
        v154 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v185);
        v155 = *v61;
        *v61 = v154;
        v187 = v155;
        applesauce::CF::DictionaryRef::~DictionaryRef(&v187);
        for (i = 0; i != -22; i -= 2)
        {
          v157 = (const void *)v224[i];
          if (v157)
            CFRelease(v157);
          v158 = *(const void **)&v223[i * 8];
          if (v158)
            CFRelease(v158);
        }
      }
      else
      {
        AUSpatialMixerV2::RefreshXTCTuningParameters(this);
      }
      v159 = *v61;
      *a5 = (ausdk *)*v61;
      if (v159)
        CFRetain(v159);
      return 0;
    }
    if (v9 == 3116)
    {
      if (a3)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v16 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          v167 = (unsigned int *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v167 = *(unsigned int **)v167;
          LODWORD(buf.__begin_) = 136315906;
          *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = v167;
          WORD2(buf.__end_) = 2080;
          *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)"GetProperty";
          HIWORD(buf.__end_cap_.__value_) = 1024;
          LODWORD(v215) = a3;
          WORD2(v215) = 1024;
          *(_DWORD *)((char *)&v215 + 6) = 3116;
          _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", (uint8_t *)&buf, 0x22u);
        }
        goto LABEL_126;
      }
      buf.__begin_ = (std::vector<unsigned int>::pointer)((char *)this + 3352);
      LOBYTE(buf.__end_) = 1;
      std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
      v78 = 0;
      while (1)
      {
        v79 = *((_QWORD *)this + 15);
        if (v79)
          LODWORD(v80) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v79 + 24))(v79);
        else
          v80 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
        if (v78 >= v80)
          break;
        v81 = atomic_load((unsigned __int8 *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v78++)+ 1976));
        if ((v81 & 1) != 0)
        {
          v82 = 1;
          goto LABEL_225;
        }
      }
      v82 = 0;
LABEL_225:
      *(_DWORD *)a5 = v82;
      p_buf = &buf;
      goto LABEL_232;
    }
  }
  return Property;
}

void sub_1B6189908(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::SetProperty(AUSpatialMixerV2 *this, unsigned int a2, unsigned int a3, uint64_t a4, int *a5, uint64_t a6)
{
  unsigned __int8 *v12;
  AudioUnitScope v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  _BOOL4 v20;
  unsigned int v21;
  AudioUnitScope v22;
  unsigned __int8 v23;
  uint64_t v24;
  _BOOL4 v25;
  AUSM::Properties *v26;
  unsigned int v27;
  NSObject *v28;
  AUSM::TuningManager *v29;
  uint64_t v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  int v33;
  uint64_t Element;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int IsSupportedPersonalizedHRTF;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  _BOOL4 v44;
  AUSpatialMixerV2 *v45;
  NSObject *v46;
  _QWORD *v47;
  uint64_t m;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  char *v53;
  uint64_t v54;
  NSObject *v55;
  int v56;
  uint64_t v57;
  unsigned __int8 v58;
  unsigned __int8 v59;
  int v60;
  OpaqueAudioComponentInstance ***v61;
  OpaqueAudioComponentInstance ***v62;
  OpaqueAudioComponentInstance *v63;
  OSStatus v64;
  NSObject *v65;
  OpaqueAudioComponentInstance *v66;
  OSStatus v67;
  NSObject *v68;
  char *v69;
  _QWORD *v70;
  char *v71;
  _QWORD *v72;
  OpaqueAudioComponentInstance ***v73;
  OpaqueAudioComponentInstance ***v74;
  OpaqueAudioComponentInstance *v75;
  OSStatus v76;
  NSObject *v77;
  char *v78;
  _QWORD *v79;
  _QWORD *v80;
  _QWORD *v81;
  _QWORD *v82;
  AUSpatialMixerV2 *v83;
  uint64_t v84;
  uint64_t v85;
  AUSpatialMixerV2 *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t *kk;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  NSObject *v94;
  char *v95;
  int v96;
  __CFDictionary *Mutable;
  int v98;
  unsigned __int8 v99;
  NSObject *v100;
  _QWORD *v101;
  int v102;
  NSObject *v103;
  _QWORD *v104;
  int v105;
  unsigned __int8 v106;
  uint64_t v107;
  unsigned __int8 v108;
  unsigned __int8 v109;
  int v110;
  NSObject *v111;
  AUSpatialMixerV2 *v112;
  uint64_t v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  uint64_t v117;
  AUSpatialMixerV2 *v118;
  uint64_t v119;
  uint64_t v120;
  AUSpatialMixerV2 *v121;
  uint64_t v122;
  uint64_t v123;
  id v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t k;
  void *v128;
  float v129;
  const __CFString **v130;
  char v131;
  char v132;
  int v133;
  uint64_t i;
  const void *v135;
  const void *v136;
  unsigned __int8 v137;
  int v138;
  int v139;
  NSObject *v140;
  _BOOL4 v141;
  _QWORD *v142;
  const char *v143;
  NSObject *v144;
  uint32_t v145;
  NSObject *v146;
  _QWORD *v147;
  const void **v148;
  std::string *v149;
  const __CFArray **v150;
  NSObject *v151;
  _QWORD *v152;
  char *v153;
  std::string::size_type size;
  char **v155;
  unint64_t v156;
  const __CFDictionary **v160;
  const __CFNumber *v161;
  unsigned int v162;
  char *v163;
  float v164;
  float v165;
  char **v166;
  unsigned int v167;
  BOOL v168;
  char **v169;
  int v170;
  int v171;
  float v172;
  float v173;
  float v174;
  float v175;
  const __CFDictionary **v176;
  const __CFNumber *v177;
  const __CFDictionary **v178;
  const __CFNumber *v179;
  const __CFDictionary **v180;
  const __CFNumber *v181;
  const __CFDictionary **v182;
  const __CFNumber *v183;
  const __CFDictionary **v184;
  const __CFNumber *v185;
  const __CFDictionary **v186;
  const __CFNumber *v187;
  char *v188;
  float v189;
  NSObject *v190;
  char *v191;
  _BOOL4 v192;
  NSObject *v193;
  _BOOL4 v194;
  _QWORD *v195;
  id v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  AUSpatialMixerV2 *v200;
  unsigned __int8 v201;
  unsigned __int8 v202;
  uint64_t *ii;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  BOOL v208;
  NSObject *v209;
  char *v210;
  uint64_t v211;
  void *v212;
  __int128 v213;
  objc_object *v214;
  int v215;
  NSObject *v216;
  char *v217;
  uint64_t v218;
  char *v219;
  uint64_t v220;
  NSObject *v221;
  _QWORD *v222;
  __CFDictionary *MutableCopy;
  const void *v224;
  CFTypeRef v225;
  const __CFDictionary **v226;
  const void *v227;
  unsigned int v228;
  int v229;
  id v230;
  unsigned int j;
  void *v232;
  char *v233;
  __int128 v234;
  NSObject *v235;
  uint64_t jj;
  NSObject *v237;
  _QWORD *v238;
  NSObject *v239;
  _QWORD *v240;
  uint64_t v241;
  NSObject *v242;
  _QWORD *v243;
  __CFDictionary *v244;
  const void *v245;
  const void *v246;
  int v247;
  std::string *v248;
  uint64_t v249;
  NSObject *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  NSObject *v254;
  _QWORD *v255;
  uint64_t v256;
  NSObject *v257;
  _QWORD *v258;
  unsigned int v259;
  uint64_t v260;
  NSObject *v261;
  _QWORD *v262;
  uint64_t v263;
  NSObject *v264;
  _QWORD *v265;
  unsigned int v266;
  uint64_t v267;
  __int128 v268;
  int v269;
  int *v270;
  int v271;
  int v272;
  int v273;
  NSObject *v274;
  char v275;
  uint64_t v276;
  id *v277;
  char v278;
  objc_object *v279;
  BOOL v280;
  uint64_t v281;
  uint64_t n;
  _QWORD *v283;
  _QWORD *v284;
  _QWORD *v285;
  _QWORD *v286;
  _QWORD *v287;
  _QWORD *v288;
  _QWORD *v289;
  const __CFString **v290;
  const __CFString **v291;
  _QWORD *v292;
  NSObject *v293;
  _QWORD *v294;
  uint64_t v295;
  NSObject *v296;
  NSObject *v297;
  _QWORD *v298;
  _QWORD *v299;
  _QWORD *v300;
  _QWORD *v301;
  _QWORD *v302;
  _QWORD *v303;
  _QWORD *v304;
  id v305;
  int v306;
  AUSpatialMixerV2InputElement *v307;
  unsigned __int8 v308;
  unsigned int v309;
  __int128 v310;
  unint64_t v311;
  void *v312;
  uint64_t v313;
  unsigned int v314;
  int v316;
  _QWORD *v317;
  _QWORD *v319;
  _QWORD *v320;
  _QWORD *v321;
  _QWORD *v322;
  _QWORD *v323;
  _QWORD *v324;
  _QWORD *v325;
  _QWORD *v326;
  _QWORD *v327;
  _QWORD *v328;
  _QWORD *v329;
  _QWORD *v330;
  _QWORD *v331;
  _QWORD *v332;
  _QWORD *v333;
  _QWORD *v334;
  __int128 v335;
  char **v336;
  unsigned int inElement;
  char *inElementa;
  char **v340;
  CFDictionaryRef CFDictionaryRef;
  int v342;
  const void *v343;
  CFArrayRef theArray;
  void *v345;
  void *v346;
  uint64_t v347;
  void *__p;
  void *v349;
  uint64_t v350;
  _BYTE buf[46];
  uint64_t v352;
  uint64_t v353;
  _BYTE v354[16];
  std::string v355;
  std::string v356;
  uint64_t v357;

  v357 = *MEMORY[0x1E0C80C00];
  if (!a5)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v16 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      v47 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v47 = (_QWORD *)*v47;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v47;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SetProperty";
      _os_log_debug_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEBUG, "[%s|%s] inData == nullptr", buf, 0x16u);
    }

    return 4294967246;
  }
  v12 = (unsigned __int8 *)this + 6128;
  v13 = a3 - 2000;
  if (a3 - 2000 < 3)
  {
LABEL_15:
    v17 = 0;
    if (a2 == 5679)
      v18 = 3112;
    else
      v18 = a2;
    v19 = v13 == 1;
    v20 = v18 == 3241;
    if (v20 && v19)
      v21 = 0;
    else
      v21 = a4;
    if (v20 && v19)
      v22 = 0;
    else
      v22 = v13;
    if ((_DWORD)v18 == 5000)
    {
      v23 = atomic_load(v12 + 1315);
      v17 = v23 & 1;
    }
    inElement = v21;
    if (v22 == 2)
    {
      if (v21)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v28 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          v80 = (_QWORD *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v80 = (_QWORD *)*v80;
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v80;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "SetProperty";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v21;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v18;
          _os_log_error_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_ERROR, "[%s|%s] (scope=%u, element=%u): invalid element (property = %u)", buf, 0x28u);
        }
LABEL_641:

        return 4294956419;
      }
      Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
      v24 = AUSM::Properties::setProperty((AUSM::Properties *)(Element + 224), v18, (CFTypeRef *)a5, a6, v17);
      goto LABEL_44;
    }
    if (v22 != 1)
    {
      if (v22)
        return 4294956417;
      v24 = AUSM::GlobalProperties::setProperty((AUSpatialMixerV2 *)((char *)this + 3584), v18, (CFTypeRef *)a5, a6, v17);
LABEL_44:
      v15 = v24;
      v35 = v21;
LABEL_45:
      if ((_DWORD)v15 != -10879)
        return v15;
      v36 = *((_QWORD *)this + 15);
      if (v36)
      {
        LODWORD(v37) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v36 + 24))(v36);
        v35 = inElement;
      }
      else
      {
        v37 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
      }
      v38 = 4294956417;
      if ((int)v18 <= 3269)
      {
        if ((int)v18 > 3115)
        {
          switch((int)v18)
          {
            case 3215:
              if (v22 >= 2)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v14 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  v301 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v301 = (_QWORD *)*v301;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v301;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v22;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3215;
                  _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", buf, 0x22u);
                }
                goto LABEL_9;
              }
              v118 = this;
              if (v22 != 1
                || ((v119 = *((_QWORD *)this + 15)) == 0
                  ? (AUSpatialMixerV2 *)(v120 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3)
                  : (LODWORD(v120) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v119 + 24))(v119),
                     v35 = inElement,
                     v118 = this),
                    v35 < v120))
              {
                memset(&v356, 0, sizeof(v356));
                std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&v356, a5, (uint64_t)&a5[a6 >> 2], a6 >> 2);
                caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
                if (v22 == 1)
                {
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v254 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v254, OS_LOG_TYPE_DEFAULT))
                  {
                    v255 = (_QWORD *)((char *)this + 3592);
                    if (*((char *)this + 3615) < 0)
                      v255 = (_QWORD *)*v255;
                    *(_DWORD *)buf = 136315906;
                    *(_QWORD *)&buf[4] = v255;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "SetProperty";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = inElement;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = (v356.__r_.__value_.__l.__size_ - v356.__r_.__value_.__r.__words[0]) >> 2;
                    _os_log_impl(&dword_1B5ED0000, v254, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting reverb send decorr filter lengths on Input Element %u to %u:", buf, 0x22u);
                  }

                  v256 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), inElement);
                  AUSpatialMixerV2InputElement::SetDecorrFilterLengthsOnReverbSend(v256, (uint64_t *)&v356, 0xFFFFFFFF);
                }
                else
                {
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v257 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
                  {
                    v258 = (_QWORD *)((char *)this + 3592);
                    if (*((char *)this + 3615) < 0)
                      v258 = (_QWORD *)*v258;
                    *(_DWORD *)buf = 136315906;
                    *(_QWORD *)&buf[4] = v258;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "SetProperty";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = inElement;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = (v356.__r_.__value_.__l.__size_ - v356.__r_.__value_.__r.__words[0]) >> 2;
                    _os_log_impl(&dword_1B5ED0000, v257, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting reverb send decorr filter lengths on Channel %u to %u:", buf, 0x22u);
                  }

                  if ((_DWORD)v37)
                  {
                    v259 = 0;
                    do
                    {
                      v260 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v259);
                      AUSpatialMixerV2InputElement::SetDecorrFilterLengthsOnReverbSend(v260, (uint64_t *)&v356, inElement);
                      ++v259;
                    }
                    while ((_DWORD)v37 != v259);
                  }
                }
                caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3320);
                goto LABEL_636;
              }
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v28 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
              {
                v328 = (_QWORD *)((char *)v118 + 3592);
                if (*((char *)v118 + 3615) < 0)
                  v328 = (_QWORD *)*v328;
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v328;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SetProperty";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = inElement;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = 3215;
                _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", buf, 0x22u);
              }
              goto LABEL_641;
            case 3216:
              if (v22 >= 2)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v14 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  v302 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v302 = (_QWORD *)*v302;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v302;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v22;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3216;
                  _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", buf, 0x22u);
                }
                goto LABEL_9;
              }
              v121 = this;
              if (v22 == 1)
              {
                v122 = *((_QWORD *)this + 15);
                if (v122)
                {
                  LODWORD(v123) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v122 + 24))(v122);
                  v35 = inElement;
                  v121 = this;
                }
                else
                {
                  v123 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
                }
                if (v35 >= v123)
                {
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v28 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                  {
                    v329 = (_QWORD *)((char *)v121 + 3592);
                    if (*((char *)v121 + 3615) < 0)
                      v329 = (_QWORD *)*v329;
                    *(_DWORD *)buf = 136315906;
                    *(_QWORD *)&buf[4] = v329;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "SetProperty";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = inElement;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = 3216;
                    _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", buf, 0x22u);
                  }
                  goto LABEL_641;
                }
              }
              memset(&v356, 0, sizeof(v356));
              std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v356, a5, (uint64_t)&a5[a6 >> 2], a6 >> 2);
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
              if (v22 == 1)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v261 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v261, OS_LOG_TYPE_DEFAULT))
                {
                  v262 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v262 = (_QWORD *)*v262;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v262;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = inElement;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = (v356.__r_.__value_.__l.__size_ - v356.__r_.__value_.__r.__words[0]) >> 2;
                  _os_log_impl(&dword_1B5ED0000, v261, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting reverb send decorr filter coeffs on Input Element %u to %u:", buf, 0x22u);
                }

                v263 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), inElement);
                __p = 0;
                v349 = 0;
                v350 = 0;
                std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v356.__r_.__value_.__l.__data_, v356.__r_.__value_.__l.__size_, (uint64_t)(v356.__r_.__value_.__l.__size_ - v356.__r_.__value_.__r.__words[0]) >> 2);
                AUSpatialMixerV2InputElement::SetDecorrFilterCoeffsOnReverbSend(v263, (uint64_t *)&__p, 0xFFFFFFFF);
                if (__p)
                {
                  v349 = __p;
                  operator delete(__p);
                }
              }
              else
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v264 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v264, OS_LOG_TYPE_DEFAULT))
                {
                  v265 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v265 = (_QWORD *)*v265;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v265;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = inElement;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = (v356.__r_.__value_.__l.__size_ - v356.__r_.__value_.__r.__words[0]) >> 2;
                  _os_log_impl(&dword_1B5ED0000, v264, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting reverb send decorr filter coeffs on Channel %u to %u:", buf, 0x22u);
                }

                if ((_DWORD)v37)
                {
                  v266 = 0;
                  do
                  {
                    v267 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v266);
                    v345 = 0;
                    v346 = 0;
                    v347 = 0;
                    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v345, v356.__r_.__value_.__l.__data_, v356.__r_.__value_.__l.__size_, (uint64_t)(v356.__r_.__value_.__l.__size_ - v356.__r_.__value_.__r.__words[0]) >> 2);
                    AUSpatialMixerV2InputElement::SetDecorrFilterCoeffsOnReverbSend(v267, (uint64_t *)&v345, inElement);
                    if (v345)
                    {
                      v346 = v345;
                      operator delete(v345);
                    }
                    ++v266;
                  }
                  while ((_DWORD)v37 != v266);
                }
              }
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3320);
LABEL_636:
              if (v356.__r_.__value_.__r.__words[0])
              {
                v356.__r_.__value_.__l.__size_ = v356.__r_.__value_.__r.__words[0];
                operator delete(v356.__r_.__value_.__l.__data_);
              }
              return 0;
            case 3217:
            case 3218:
            case 3219:
            case 3220:
            case 3221:
            case 3223:
            case 3224:
              goto LABEL_305;
            case 3222:
              if (v22)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v14 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  v292 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v292 = (_QWORD *)*v292;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v292;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v22;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3222;
                  _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
                }
                goto LABEL_9;
              }
              if ((_DWORD)a6 != 24)
                return 4294956445;
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
              applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[5],float const&>((applesauce::CF::TypeRef *)buf, a5);
              applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[16],float const&>((applesauce::CF::TypeRef *)&buf[16], a5 + 1);
              applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[19],float const&>((applesauce::CF::TypeRef *)&buf[32], a5 + 2);
              applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],float const&>((applesauce::CF::TypeRef *)&v352, a5 + 3);
              LODWORD(v355.__r_.__value_.__l.__data_) = *((float *)a5 + 4);
              applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[10],unsigned int>((applesauce::CF::TypeRef *)&v353, (int *)&v355);
              LODWORD(theArray) = *((float *)a5 + 5);
              applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[8],unsigned int>((applesauce::CF::TypeRef *)v354, (int *)&theArray);
              v356.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
              v356.__r_.__value_.__l.__size_ = 6;
              CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v356);
              AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::store((uint64_t)this + 5112, (const void **)&CFDictionaryRef);
              applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&CFDictionaryRef);
              for (i = 0; i != -96; i -= 16)
              {
                v135 = *(const void **)&v354[i + 8];
                if (v135)
                  CFRelease(v135);
                v136 = *(const void **)&v354[i];
                if (v136)
                  CFRelease(v136);
              }
              (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)this + 592))(this, 3222);
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3320);
              return 0;
            case 3225:
              if (v22 != 1)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v14 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  v303 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v303 = (_QWORD *)*v303;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v303;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v22;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3225;
                  _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for input scope property = %u", buf, 0x22u);
                }
                goto LABEL_9;
              }
              v83 = this;
              v84 = *((_QWORD *)this + 15);
              if (v84)
              {
                LODWORD(v85) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v84 + 24))(v84);
                v35 = inElement;
                v83 = this;
              }
              else
              {
                v85 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
              }
              if (v35 >= v85)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v28 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                {
                  v320 = (_QWORD *)((char *)v83 + 3592);
                  if (*((char *)v83 + 3615) < 0)
                    v320 = (_QWORD *)*v320;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v320;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = inElement;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3225;
                  _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", buf, 0x22u);
                }
                goto LABEL_641;
              }
              if ((_DWORD)a6 != 8)
                return 4294956445;
              applesauce::CF::DictionaryRef::from_get_noexcept((applesauce::CF::DictionaryRef *)buf, *(CFTypeRef *)a5);
              AUSM::ExclusionZone::exclusionZonesFromDictionary((AUSM::ExclusionZone *)&v356, (const __CFDictionary **)buf);
              applesauce::CF::DictionaryRef::~DictionaryRef((const void **)buf);
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)v83 + 3320);
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v239 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
              {
                v240 = (_QWORD *)((char *)v83 + 3592);
                if (*((char *)v83 + 3615) < 0)
                  v240 = (_QWORD *)*v240;
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v240;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SetProperty";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = -1227133513
                                    * ((v356.__r_.__value_.__l.__size_ - v356.__r_.__value_.__r.__words[0]) >> 2);
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v35;
                _os_log_impl(&dword_1B5ED0000, v239, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting %u exclusion zones on Input Element %u", buf, 0x22u);
              }

              v35 = inElement;
              v241 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), inElement);
              v38 = AUSpatialMixerV2InputElement::SetExclusionZones(v241, (uint64_t)&v356);
              if ((_DWORD)v38)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v242 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v242, OS_LOG_TYPE_ERROR))
                {
                  v331 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v331 = (_QWORD *)*v331;
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = v331;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v38;
                  _os_log_error_impl(&dword_1B5ED0000, v242, OS_LOG_TYPE_ERROR, "[%s|%s] SetExclusionZones from dictionary failed with error %d", buf, 0x1Cu);
                }

                v35 = inElement;
              }
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)v83 + 3320);
              goto LABEL_724;
            case 3226:
              if (v22 != 1)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v14 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  v304 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v304 = (_QWORD *)*v304;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v304;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v22;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3226;
                  _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for input scope property = %u", buf, 0x22u);
                }
                goto LABEL_9;
              }
              v86 = this;
              v87 = *((_QWORD *)this + 15);
              if (v87)
              {
                LODWORD(v88) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v87 + 24))(v87);
                v35 = inElement;
                v86 = this;
              }
              else
              {
                v88 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
              }
              if (v35 >= v88)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v28 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                {
                  v321 = (_QWORD *)((char *)v86 + 3592);
                  if (*((char *)v86 + 3615) < 0)
                    v321 = (_QWORD *)*v321;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v321;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = inElement;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3226;
                  _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", buf, 0x22u);
                }
                goto LABEL_641;
              }
              if ((a6 & 3) != 0)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v237 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v237, OS_LOG_TYPE_ERROR))
                {
                  v325 = (_QWORD *)((char *)v86 + 3592);
                  if (*((char *)v86 + 3615) < 0)
                    v325 = (_QWORD *)*v325;
                  *(_DWORD *)buf = 136315394;
                  *(_QWORD *)&buf[4] = v325;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  _os_log_error_impl(&dword_1B5ED0000, v237, OS_LOG_TYPE_ERROR, "[%s|%s] probably corrupted binary blob for exclusion zones", buf, 0x16u);
                }
                goto LABEL_583;
              }
              AUSM::ExclusionZone::exclusionZonesFromArray((AUSM::ExclusionZone *)&v356, (const float *)a5, a6 >> 2);
              v268 = *(_OWORD *)&v356.__r_.__value_.__l.__data_;
              if (v356.__r_.__value_.__r.__words[0] == v356.__r_.__value_.__l.__size_)
              {
                v269 = 0;
              }
              else
              {
                v269 = 0;
                v270 = (int *)v356.__r_.__value_.__r.__words[0];
                do
                {
                  v272 = *v270;
                  v270 += 7;
                  v271 = v272;
                  v273 = v269 + 7;
                  if (!v272)
                    v269 += 5;
                  if (v271 == 1)
                    v269 = v273;
                }
                while (v270 != (int *)v356.__r_.__value_.__l.__size_);
              }
              if (a6 >> 2 == v269)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v293 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v293, OS_LOG_TYPE_DEFAULT))
                {
                  v294 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v294 = (_QWORD *)*v294;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v294;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = -1227133513 * ((*((_QWORD *)&v268 + 1) - (_QWORD)v268) >> 2);
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = inElement;
                  _os_log_impl(&dword_1B5ED0000, v293, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting %u exclusion zones on Input Element %u", buf, 0x22u);
                }

                caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
                v35 = inElement;
                v295 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), inElement);
                v38 = AUSpatialMixerV2InputElement::SetExclusionZones(v295, (uint64_t)&v356);
                if ((_DWORD)v38)
                {
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v296 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v296, OS_LOG_TYPE_ERROR))
                  {
                    v334 = (_QWORD *)((char *)this + 3592);
                    if (*((char *)this + 3615) < 0)
                      v334 = (_QWORD *)*v334;
                    *(_DWORD *)buf = 136315650;
                    *(_QWORD *)&buf[4] = v334;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "SetProperty";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = v38;
                    _os_log_error_impl(&dword_1B5ED0000, v296, OS_LOG_TYPE_ERROR, "[%s|%s] SetExclusionZones from array failed with error %d", buf, 0x1Cu);
                  }

                  v35 = inElement;
                }
                caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3320);
              }
              else
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v297 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v297, OS_LOG_TYPE_ERROR))
                {
                  v333 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v333 = (_QWORD *)*v333;
                  *(_DWORD *)buf = 136315394;
                  *(_QWORD *)&buf[4] = v333;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  _os_log_error_impl(&dword_1B5ED0000, v297, OS_LOG_TYPE_ERROR, "[%s|%s] failed to fully parse zone data", buf, 0x16u);
                }

                v38 = 4294956445;
                v35 = inElement;
              }
LABEL_724:
              if (v356.__r_.__value_.__r.__words[0])
              {
                v356.__r_.__value_.__l.__size_ = v356.__r_.__value_.__r.__words[0];
                operator delete(v356.__r_.__value_.__l.__data_);
              }
              goto LABEL_305;
            default:
              if ((_DWORD)v18 == 3116)
              {
                if (!v22)
                  return 4294956431;
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v14 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  v299 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v299 = (_QWORD *)*v299;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v299;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v22;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3116;
                  _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
                }
                goto LABEL_9;
              }
              if ((_DWORD)v18 != 3268)
                goto LABEL_305;
              if (v22)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v14 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  v298 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v298 = (_QWORD *)*v298;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v298;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v22;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3268;
                  _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
                }
                goto LABEL_9;
              }
              if ((_DWORD)a6 != 8)
                return 4294956445;
              applesauce::CF::ArrayRef::from_get_noexcept((applesauce::CF::ArrayRef *)&theArray, *(CFTypeRef *)a5);
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v146 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
              {
                v147 = (_QWORD *)((char *)this + 3592);
                if (*((char *)this + 3615) < 0)
                  v147 = (_QWORD *)*v147;
                v148 = (const void **)applesauce::CF::ArrayRef::operator->(&theArray);
                applesauce::CF::ArrayRef_proxy::pretty_print((applesauce::CF::ArrayRef_proxy *)&v356, *v148);
                if ((v356.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v149 = &v356;
                else
                  v149 = (std::string *)v356.__r_.__value_.__r.__words[0];
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)&buf[4] = v147;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SetProperty";
                *(_WORD *)&buf[22] = 2080;
                *(_QWORD *)&buf[24] = v149;
                _os_log_impl(&dword_1B5ED0000, v146, OS_LOG_TYPE_DEFAULT, "[%s|%s] TuningWarperParameters = %s", buf, 0x20u);
                if (SHIBYTE(v356.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v356.__r_.__value_.__l.__data_);
              }

              if (theArray)
              {
                v150 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&theArray);
                if (applesauce::CF::ArrayRef_proxy::get_size(*v150))
                {
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v151 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
                  {
                    v152 = (_QWORD *)((char *)this + 3592);
                    if (*((char *)this + 3615) < 0)
                      v152 = (_QWORD *)*v152;
                    *(_DWORD *)buf = 136315394;
                    *(_QWORD *)&buf[4] = v152;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "SetProperty";
                    _os_log_impl(&dword_1B5ED0000, v151, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting tuning warping parameters", buf, 0x16u);
                  }

                  applesauce::CF::ArrayRef_iterator<applesauce::CF::DictionaryRef>::ArrayRef_iterator(buf, theArray);
                  applesauce::CF::ArrayRef_iterator<applesauce::CF::DictionaryRef>::ArrayRef_iterator(&v356, theArray);
                  v153 = (char *)this;
                  size = v356.__r_.__value_.__r.__words[2];
                  v155 = (char **)((char *)this + 3272);
                  v356.__r_.__value_.__l.__size_ = v356.__r_.__value_.__r.__words[2];
                  v156 = *(_QWORD *)&buf[8];
                  while (*(_QWORD *)buf && v156 != *(_QWORD *)&buf[16]
                       || v356.__r_.__value_.__r.__words[0] && size != v356.__r_.__value_.__r.__words[2])
                  {
                    if (*(_QWORD *)buf == v356.__r_.__value_.__r.__words[0] && v156 == size)
                      break;
                    applesauce::CF::details::at_to<applesauce::CF::DictionaryRef>(*(const __CFArray **)buf, v156, (applesauce::CF::DictionaryRef *)&v343);
                    v160 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&v343);
                    v161 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,__CFString const*&>(*v160);
                    if (((unint64_t)v161 & 0xFF00000000) != 0)
                    {
                      v162 = v161;
                      v342 = (int)v161;
                      v163 = *v155;
                      v164 = 1.0;
                      v165 = 0.0;
                      if (!*v155)
                        goto LABEL_411;
                      v166 = (char **)((char *)this + 3272);
                      do
                      {
                        v167 = *((_DWORD *)v163 + 7);
                        v168 = v167 >= v161;
                        if (v167 >= v161)
                          v169 = (char **)v163;
                        else
                          v169 = (char **)(v163 + 8);
                        if (v168)
                          v166 = (char **)v163;
                        v163 = *v169;
                      }
                      while (*v169);
                      if (v166 != v155 && *((_DWORD *)v166 + 7) <= v161)
                      {
                        v165 = *((float *)v166 + 8);
                        v172 = *((float *)v166 + 9);
                        v164 = *((float *)v166 + 10);
                        v173 = *((float *)v166 + 11);
                        v174 = *((float *)v166 + 12);
                        v175 = *((float *)v166 + 13);
                        v170 = *((_DWORD *)v166 + 14);
                        v171 = *((_DWORD *)v166 + 15);
                      }
                      else
                      {
LABEL_411:
                        v170 = 1;
                        v171 = (int)v161;
                        v172 = 0.0;
                        v173 = 1.0;
                        v174 = 0.0;
                        v175 = 0.0;
                      }
                      v176 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&v343);
                      v177 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*&>(*v176, (const void *)kPresetKeyAzimuth);
                      if (((unint64_t)v177 & 0xFF00000000) != 0)
                        v165 = *(float *)&v177;
                      v178 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&v343);
                      v179 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*&>(*v178, (const void *)kPresetKeyElevation);
                      if (((unint64_t)v179 & 0xFF00000000) != 0)
                        v172 = *(float *)&v179;
                      v180 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&v343);
                      v181 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*&>(*v180, (const void *)kPresetKeyDistance);
                      if (((unint64_t)v181 & 0xFF00000000) != 0)
                        v164 = *(float *)&v181;
                      v182 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&v343);
                      v183 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*&>(*v182, (const void *)kPresetKeyGain);
                      if (((unint64_t)v183 & 0xFF00000000) != 0)
                        v173 = *(float *)&v183;
                      v184 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&v343);
                      v185 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*&>(*v184, (const void *)kPresetKeyDRRAdjustment);
                      if (((unint64_t)v185 & 0xFF00000000) != 0)
                        v174 = *(float *)&v185;
                      v186 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&v343);
                      v187 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*&>(*v186, (const void *)kPresetKeyDelay);
                      v188 = std::__tree<std::__value_type<unsigned int,AUSMChannelParameters>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,AUSMChannelParameters>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,AUSMChannelParameters>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t **)this + 408, v162, &v342);
                      v189 = *(float *)&v187;
                      if (((unint64_t)v187 & 0xFF00000000) == 0)
                        v189 = v175;
                      *((float *)v188 + 8) = v165;
                      *((float *)v188 + 9) = v172;
                      *((float *)v188 + 10) = v164;
                      *((float *)v188 + 11) = v173;
                      *((float *)v188 + 12) = v174;
                      *((float *)v188 + 13) = v189;
                      *((_DWORD *)v188 + 14) = v170;
                      *((_DWORD *)v188 + 15) = v171;
                    }
                    else
                    {
                      if (getAUSMV2Log(void)::onceToken != -1)
                        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                      v190 = (id)getAUSMV2Log(void)::gLog;
                      if (os_log_type_enabled(v190, OS_LOG_TYPE_DEFAULT))
                      {
                        v191 = (char *)this + 3592;
                        if (v153[3615] < 0)
                          v191 = (char *)*((_QWORD *)this + 449);
                        LODWORD(v355.__r_.__value_.__l.__data_) = 136315394;
                        *(std::string::size_type *)((char *)v355.__r_.__value_.__r.__words + 4) = (std::string::size_type)v191;
                        WORD2(v355.__r_.__value_.__r.__words[1]) = 2080;
                        *(std::string::size_type *)((char *)&v355.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"SetProperty";
                        _os_log_impl(&dword_1B5ED0000, v190, OS_LOG_TYPE_DEFAULT, "[%s|%s] Invalid channel label in the preset, some channel parameters are probably ignored.", (uint8_t *)&v355, 0x16u);
                      }

                      v153 = (char *)this;
                    }
                    applesauce::CF::DictionaryRef::~DictionaryRef(&v343);
                    v156 = ++*(_QWORD *)&buf[8];
                    size = v356.__r_.__value_.__l.__size_;
                  }
                  AUSpatialMixerV2::UpdateTuningWarper((AUSpatialMixerV2 *)v153);
                }
              }
              applesauce::CF::ArrayRef::~ArrayRef((const void **)&theArray);
              break;
          }
          return 0;
        }
        if ((int)v18 > 13)
        {
          if ((_DWORD)v18 == 14)
          {
            v73 = (OpaqueAudioComponentInstance ***)*((_QWORD *)this + 445);
            v74 = (OpaqueAudioComponentInstance ***)*((_QWORD *)this + 446);
            if (v73 != v74)
            {
              do
              {
                v75 = **v73;
                v76 = -66744;
                if (!v75 || (v76 = AudioUnitSetProperty(v75, 0xEu, v22, v35, a5, a6), v35 = inElement, v76))
                {
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v77 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
                  {
                    v78 = (char *)this + 3592;
                    if (*((char *)this + 3615) < 0)
                      v78 = (char *)*((_QWORD *)this + 449);
                    v79 = *v73 + 9;
                    if (*((char *)*v73 + 95) < 0)
                      v79 = (_QWORD *)*v79;
                    *(_DWORD *)buf = 136315906;
                    *(_QWORD *)&buf[4] = v78;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "SetProperty";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = v76;
                    *(_WORD *)&buf[28] = 2080;
                    *(_QWORD *)&buf[30] = v79;
                    _os_log_error_impl(&dword_1B5ED0000, v77, OS_LOG_TYPE_ERROR, "[%s|%s] error %d setting kAudioUnitProperty_MaximumFramesPerSlice on %s", buf, 0x26u);
                  }

                  v35 = inElement;
                }
                ++v73;
              }
              while (v73 != v74);
              v38 = 4294956417;
            }
            goto LABEL_305;
          }
          if ((_DWORD)v18 != 19)
          {
            if ((_DWORD)v18 == 3107)
            {
              if (v22 >= 2)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v14 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  v288 = (_QWORD *)((char *)this + 3592);
                  if (*((char *)this + 3615) < 0)
                    v288 = (_QWORD *)*v288;
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v288;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "SetProperty";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v22;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = 3107;
                  _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", buf, 0x22u);
                }
                goto LABEL_9;
              }
              v112 = this;
              if (v22 != 1
                || ((v113 = *((_QWORD *)this + 15)) == 0
                  ? (AUSpatialMixerV2 *)(v114 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3)
                  : (LODWORD(v114) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v113 + 24))(v113),
                     v35 = inElement,
                     v112 = this),
                    v35 < v114))
              {
                if ((_DWORD)a6 == 8)
                {
                  applesauce::CF::DictionaryRef::from_get_noexcept((applesauce::CF::DictionaryRef *)buf, *(CFTypeRef *)a5);
                  v249 = *((_QWORD *)v112 + 406);
                  *((_QWORD *)v112 + 406) = *(_QWORD *)buf;
                  *(_QWORD *)buf = v249;
                  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)buf);
                  (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)v112 + 592))(v112, 3107);
                  return 0;
                }
                return 4294956445;
              }
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v28 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
              {
                v324 = (_QWORD *)((char *)v112 + 3592);
                if (*((char *)v112 + 3615) < 0)
                  v324 = (_QWORD *)*v324;
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v324;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SetProperty";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = inElement;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = 3107;
                _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", buf, 0x22u);
              }
              goto LABEL_641;
            }
            goto LABEL_305;
          }
          goto LABEL_155;
        }
        if ((_DWORD)v18 == 2 || (_DWORD)v18 == 8)
        {
LABEL_155:
          if (v22 == 2)
          {
            v61 = (OpaqueAudioComponentInstance ***)*((_QWORD *)this + 445);
            v62 = (OpaqueAudioComponentInstance ***)*((_QWORD *)this + 446);
            if (v61 != v62)
            {
              v336 = (char **)((char *)this + 3592);
              do
              {
                v63 = **v61;
                v64 = -66744;
                if (!v63 || (v64 = AudioUnitSetProperty(v63, v18, 1u, inElement, a5, a6)) != 0)
                {
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v65 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                  {
                    v69 = (char *)this + 3592;
                    if (*((char *)this + 3615) < 0)
                      v69 = *v336;
                    v70 = *v61 + 9;
                    if (*((char *)*v61 + 95) < 0)
                      v70 = (_QWORD *)*v70;
                    *(_DWORD *)buf = 136316162;
                    *(_QWORD *)&buf[4] = v69;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "SetProperty";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = v64;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v18;
                    *(_WORD *)&buf[34] = 2080;
                    *(_QWORD *)&buf[36] = v70;
                    _os_log_error_impl(&dword_1B5ED0000, v65, OS_LOG_TYPE_ERROR, "[%s|%s] error %d setting input scope property %u on %s", buf, 0x2Cu);
                  }

                }
                v66 = **v61;
                v67 = -66744;
                if (!v66 || (v67 = AudioUnitSetProperty(v66, v18, 2u, inElement, a5, a6)) != 0)
                {
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v68 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
                  {
                    v71 = (char *)this + 3592;
                    if (*((char *)this + 3615) < 0)
                      v71 = *v336;
                    v72 = *v61 + 9;
                    if (*((char *)*v61 + 95) < 0)
                      v72 = (_QWORD *)*v72;
                    *(_DWORD *)buf = 136316162;
                    *(_QWORD *)&buf[4] = v71;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "SetProperty";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = v67;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v18;
                    *(_WORD *)&buf[34] = 2080;
                    *(_QWORD *)&buf[36] = v72;
                    _os_log_error_impl(&dword_1B5ED0000, v68, OS_LOG_TYPE_ERROR, "[%s|%s] error %d setting output scope property %u on %s", buf, 0x2Cu);
                  }

                }
                ++v61;
              }
              while (v61 != v62);
              v38 = 4294956417;
              v35 = inElement;
            }
          }
        }
LABEL_305:
        if ((_DWORD)v18 == 5000)
          return v38;
        v15 = v38;
        if ((_DWORD)v38 != -10879)
          return v15;
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v111 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
        {
          v238 = (_QWORD *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v238 = (_QWORD *)*v238;
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v238;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "SetProperty";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = v22;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v35;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v18;
          _os_log_error_impl(&dword_1B5ED0000, v111, OS_LOG_TYPE_ERROR, "[%s|%s] (scope=%u, element=%u): invalid property ID %u", buf, 0x28u);
        }

        return 4294956417;
      }
      if ((int)v18 <= 5000)
      {
        if ((int)v18 > 3293)
        {
          if ((_DWORD)v18 == 3294)
          {
            if (v22)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v14 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
              {
                v287 = (_QWORD *)((char *)this + 3592);
                if (*((char *)this + 3615) < 0)
                  v287 = (_QWORD *)*v287;
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v287;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SetProperty";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v22;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = 3294;
                _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
              }
              goto LABEL_9;
            }
            if ((_DWORD)a6 == 16)
            {
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
              *(_OWORD *)&v356.__r_.__value_.__l.__data_ = *(_OWORD *)a5;
              *(_QWORD *)buf = &v356;
              *(_QWORD *)&buf[8] = 4;
              v355.__r_.__value_.__r.__words[0] = (std::string::size_type)applesauce::CF::details::make_CFArrayRef<unsigned int>((uint64_t)buf);
              *(_QWORD *)buf = v355.__r_.__value_.__r.__words[0];
              (*(void (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, _BYTE *, uint64_t))(*(_QWORD *)this + 96))(this, 3291, 0, inElement, buf, 8);
              applesauce::CF::ArrayRef::~ArrayRef((const void **)&v355.__r_.__value_.__l.__data_);
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3320);
              return 0;
            }
          }
          else
          {
            if ((_DWORD)v18 != 3295)
              goto LABEL_305;
            if (v22)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v14 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
              {
                v285 = (_QWORD *)((char *)this + 3592);
                if (*((char *)this + 3615) < 0)
                  v285 = (_QWORD *)*v285;
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v285;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SetProperty";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v22;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = 3295;
                _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
              }
              goto LABEL_9;
            }
            if ((_DWORD)a6 == 16)
            {
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
              *(_OWORD *)&v356.__r_.__value_.__l.__data_ = *(_OWORD *)a5;
              *(_QWORD *)buf = &v356;
              *(_QWORD *)&buf[8] = 4;
              v355.__r_.__value_.__r.__words[0] = (std::string::size_type)applesauce::CF::details::make_CFArrayRef<float>((uint64_t)buf);
              *(_QWORD *)buf = v355.__r_.__value_.__r.__words[0];
              (*(void (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, _BYTE *, uint64_t))(*(_QWORD *)this + 96))(this, 3292, 0, inElement, buf, 8);
              applesauce::CF::ArrayRef::~ArrayRef((const void **)&v355.__r_.__value_.__l.__data_);
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3320);
              return 0;
            }
          }
        }
        else
        {
          if ((_DWORD)v18 == 3270)
          {
            if (!v22)
              return 4294956431;
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v14 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              v286 = (_QWORD *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v286 = (_QWORD *)*v286;
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v286;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "SetProperty";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = v22;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 3270;
              _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
            }
            goto LABEL_9;
          }
          if ((_DWORD)v18 != 3293)
            goto LABEL_305;
          if (v22)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v14 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              v284 = (_QWORD *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v284 = (_QWORD *)*v284;
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v284;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "SetProperty";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = v22;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 3293;
              _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
            }
            goto LABEL_9;
          }
          if ((_DWORD)a6 == 16)
          {
            caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
            *(_OWORD *)&v356.__r_.__value_.__l.__data_ = *(_OWORD *)a5;
            *(_QWORD *)buf = &v356;
            *(_QWORD *)&buf[8] = 4;
            v355.__r_.__value_.__r.__words[0] = (std::string::size_type)applesauce::CF::details::make_CFArrayRef<float>((uint64_t)buf);
            *(_QWORD *)buf = v355.__r_.__value_.__r.__words[0];
            (*(void (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, _BYTE *, uint64_t))(*(_QWORD *)this
                                                                                                  + 96))(this, 3290, 0, inElement, buf, 8);
            applesauce::CF::ArrayRef::~ArrayRef((const void **)&v355.__r_.__value_.__l.__data_);
            caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3320);
            return 0;
          }
        }
        return 4294956445;
      }
      v15 = 4294956431;
      switch((int)v18)
      {
        case 5001:
        case 5011:
          return v15;
        case 5002:
          if (v22 >= 2)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v14 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              v300 = (_QWORD *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v300 = (_QWORD *)*v300;
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v300;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "SetProperty";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = v22;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 5002;
              _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for property = %u", buf, 0x22u);
            }
            goto LABEL_9;
          }
          v115 = (char *)this;
          if (v22 != 1)
          {
            if ((_DWORD)a6 == 8)
            {
              v230 = *(id *)a5;
              for (j = 0; objc_msgSend(v230, "count") > (unint64_t)j; ++j)
              {
                *(_OWORD *)buf = xmmword_1B6629CB0;
                *(_QWORD *)&buf[16] = 0;
                *(_QWORD *)&buf[24] = 0xFFFFFFFF00000001;
                objc_msgSend(v230, "objectAtIndexedSubscript:", j);
                v232 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v232, "getBytes:length:", buf, 32);

                v233 = std::__tree<std::__value_type<unsigned int,AUSMChannelParameters>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,AUSMChannelParameters>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,AUSMChannelParameters>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t **)this + 408, *(unsigned int *)&buf[28], &buf[28]);
                v115 = (char *)this;
                v234 = *(_OWORD *)&buf[16];
                *((_OWORD *)v233 + 2) = *(_OWORD *)buf;
                *((_OWORD *)v233 + 3) = v234;
              }
              AUSpatialMixerV2::UpdateTuningWarper((AUSpatialMixerV2 *)v115);

              return 0;
            }
            goto LABEL_580;
          }
          v116 = *((_QWORD *)this + 15);
          if (v116)
          {
            LODWORD(v117) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v116 + 24))(v116);
            v35 = inElement;
            v115 = (char *)this;
          }
          else
          {
            v117 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
          }
          if (v35 < v117)
          {
            if ((_DWORD)a6 == 8)
            {
              v251 = (uint64_t)(v115 + 3320);
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)(v115 + 3320));
              v252 = *((_QWORD *)this + 15);
              if (v252)
                LODWORD(v253) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v252 + 24))(v252);
              else
                v253 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
              if (inElement >= v253)
              {
                v15 = 4294956419;
                v316 = 1;
              }
              else
              {
                v305 = *(id *)a5;
                v306 = objc_msgSend(v305, "count");
                v307 = (AUSpatialMixerV2InputElement *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), inElement);
                if (*((_DWORD *)v307 + 27) == v306)
                {
                  v308 = atomic_load((unsigned __int8 *)this + 3747);
                  if ((v308 & 1) != 0)
                  {
                    AUSpatialMixerV2InputElement::GetChannelParameters((AUSpatialMixerV2InputElement *)&v356, (uint64_t)v307);
                    v309 = 0;
                    v310 = *(_OWORD *)&v356.__r_.__value_.__l.__data_;
                    v311 = (uint64_t)(v356.__r_.__value_.__l.__size_ - v356.__r_.__value_.__r.__words[0]) >> 5;
                    while (objc_msgSend(v305, "count") > (unint64_t)v309)
                    {
                      *(_OWORD *)buf = xmmword_1B6629CB0;
                      *(_QWORD *)&buf[16] = 0;
                      *(_QWORD *)&buf[24] = 0xFFFFFFFF00000001;
                      objc_msgSend(v305, "objectAtIndexedSubscript:", v309);
                      v312 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_msgSend(v312, "getBytes:length:", buf, 32);

                      if (*((_QWORD *)&v310 + 1) != (_QWORD)v310)
                      {
                        v313 = 0;
                        v314 = 1;
                        while (*(_DWORD *)(v310 + 32 * v313 + 28) != *(_DWORD *)&buf[28])
                        {
                          v313 = v314;
                          if (v311 <= v314++)
                            goto LABEL_759;
                        }
                        AUSpatialMixerV2InputElement::SetEnableForChannel(v307, *(_DWORD *)&buf[24] != 0, v309);
                      }
LABEL_759:
                      ++v309;
                    }
                    if ((_QWORD)v310)
                      operator delete((void *)v310);
                  }
                  v316 = 0;
                }
                else
                {
                  v316 = 1;
                }

                v15 = 4294956445;
              }
              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v251);
              if (v316)
                return v15;
              return 0;
            }
LABEL_580:
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v237 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v237, OS_LOG_TYPE_ERROR))
            {
              v323 = v115 + 3592;
              if (v115[3615] < 0)
                v323 = (_QWORD *)*v323;
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v323;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "SetProperty";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = a6;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 5002;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 8;
              _os_log_error_impl(&dword_1B5ED0000, v237, OS_LOG_TYPE_ERROR, "[%s|%s] invalid data size = %u for property = %u, expected %u", buf, 0x28u);
            }
            goto LABEL_583;
          }
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v28 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            v327 = v115 + 3592;
            if (v115[3615] < 0)
              v327 = (_QWORD *)*v327;
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v327;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "SetProperty";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = inElement;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 5002;
            _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid element = %u for input scope property = %u", buf, 0x22u);
          }
          goto LABEL_641;
        case 5003:
        case 5007:
        case 5008:
        case 5009:
        case 5010:
          goto LABEL_305;
        case 5004:
        case 5005:
        case 5006:
          if (*v12)
            return 0;
          if (v22)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v14 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              v283 = (_QWORD *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v283 = (_QWORD *)*v283;
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v283;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "SetProperty";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = v22;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v18;
              _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
            }
            goto LABEL_9;
          }
          if ((_DWORD)a6 != 8)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v237 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v237, OS_LOG_TYPE_ERROR))
            {
              v322 = (_QWORD *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v322 = (_QWORD *)*v322;
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v322;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "SetProperty";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = a6;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v18;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 8;
              _os_log_error_impl(&dword_1B5ED0000, v237, OS_LOG_TYPE_ERROR, "[%s|%s] invalid data size = %u for property = %u, expected %u", buf, 0x28u);
            }
LABEL_583:

            return 4294956445;
          }
          caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
          v124 = *(id *)a5;
          v125 = objc_msgSend(v124, "count");
          if (!v125)
            goto LABEL_702;
          std::vector<AUSMChannelParameters>::vector(buf, v125);
          v126 = 0;
          for (k = 0; k != v125; ++k)
          {
            objc_msgSend(v124, "objectAtIndexedSubscript:", k);
            v128 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v128, "getBytes:length:", *(_QWORD *)buf + v126, 32);

            v126 += 32;
          }
          memset(&v356, 0, sizeof(v356));
          v129 = 0.0;
          switch((_DWORD)v18)
          {
            case 0x138C:
              applesauce::CF::StringRef::from_get((applesauce::CF::StringRef *)&theArray, CFSTR("AUSMSoundStageLargeParameters"));
              v290 = (const __CFString **)applesauce::CF::StringRef::operator->(&theArray);
              applesauce::CF::convert_to<std::string,0>(*v290, (uint64_t)&v355);
              v356 = v355;
              *((_BYTE *)&v355.__r_.__value_.__s + 23) = 0;
              v355.__r_.__value_.__s.__data_[0] = 0;
              applesauce::CF::StringRef::~StringRef((const void **)&theArray);
              break;
            case 0x138D:
              applesauce::CF::StringRef::from_get((applesauce::CF::StringRef *)&theArray, CFSTR("AUSMSoundStageMediumParameters"));
              v291 = (const __CFString **)applesauce::CF::StringRef::operator->(&theArray);
              applesauce::CF::convert_to<std::string,0>(*v291, (uint64_t)&v355);
              v356 = v355;
              *((_BYTE *)&v355.__r_.__value_.__s + 23) = 0;
              v355.__r_.__value_.__s.__data_[0] = 0;
              applesauce::CF::StringRef::~StringRef((const void **)&theArray);
              v132 = 0;
              v133 = 2;
              v131 = 1;
              goto LABEL_696;
            case 0x138E:
              applesauce::CF::StringRef::from_get((applesauce::CF::StringRef *)&theArray, CFSTR("AUSMSoundStageSmallParameters"));
              v130 = (const __CFString **)applesauce::CF::StringRef::operator->(&theArray);
              applesauce::CF::convert_to<std::string,0>(*v130, (uint64_t)&v355);
              v356 = v355;
              *((_BYTE *)&v355.__r_.__value_.__s + 23) = 0;
              v355.__r_.__value_.__s.__data_[0] = 0;
              applesauce::CF::StringRef::~StringRef((const void **)&theArray);
              v131 = 1;
              v129 = 1.0;
              v132 = 1;
              v133 = 1;
LABEL_696:
              if (AUSM::SoundStage::setSoundStageParameters((uint64_t)this + 6336, v133, buf, &v356, v131, v132, 1, 1.0, v129))
              {
                v12[400] = 1;
                atomic_store(1u, v12 + 1237);
              }
              if (SHIBYTE(v356.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v356.__r_.__value_.__l.__data_);
              if (*(_QWORD *)buf)
              {
                *(_QWORD *)&buf[8] = *(_QWORD *)buf;
                operator delete(*(void **)buf);
              }
LABEL_702:

              caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 3320);
              return 0;
          }
          v131 = 0;
          v132 = 0;
          v133 = 3;
          goto LABEL_696;
        default:
          if ((_DWORD)v18 == 5677)
            return v15;
          if ((_DWORD)v18 != 5683)
            goto LABEL_305;
          if (!v22)
            return v15;
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v14 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            v289 = (_QWORD *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v289 = (_QWORD *)*v289;
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v289;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "SetProperty";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = v22;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 5683;
            _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
          }
          goto LABEL_9;
      }
    }
    v25 = 1;
    if ((_DWORD)v18 != 3000)
    {
      if ((_DWORD)v18 == 3242)
      {
        LODWORD(v356.__r_.__value_.__l.__data_) = 0;
        *(_QWORD *)buf = (char *)this + 3352;
        buf[8] = 1;
        std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
        v26 = (AUSM::Properties *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), inElement)
                                 + 1056);
        v27 = 3242;
        goto LABEL_69;
      }
      if ((_DWORD)v18 != 3005)
      {
LABEL_72:
        v356.__r_.__value_.__r.__words[0] = (std::string::size_type)this + 3352;
        v356.__r_.__value_.__s.__data_[8] = 1;
        std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
        v35 = inElement;
        IsSupportedPersonalizedHRTF = AUSpatialMixerV2::IsSupportedPersonalizedHRTF(this);
        v40 = *((_QWORD *)this + 15);
        if (v40)
          LODWORD(v41) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v40 + 24))(v40);
        else
          v41 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
        if (inElement >= v41)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v46 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            v82 = (_QWORD *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v82 = (_QWORD *)*v82;
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v82;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "SetProperty";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = inElement;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v18;
            _os_log_error_impl(&dword_1B5ED0000, v46, OS_LOG_TYPE_ERROR, "[%s|%s] (scope=%u, element=%u): invalid element (property = %u)", buf, 0x28u);
          }

          std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v356);
          return 4294956419;
        }
        v42 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), inElement);
        v15 = AUSM::Properties::setProperty((AUSM::Properties *)(v42 + 1056), v18, (CFTypeRef *)a5, a6, v17);
        v43 = AUSpatialMixerV2::IsSupportedPersonalizedHRTF(this);
        std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v356);
        if ((_DWORD)v15)
          v44 = 0;
        else
          v44 = v25;
        if (v44)
        {
          if ((_DWORD)v18 == 3000 || (_DWORD)v18 == 3005)
          {
            v45 = this;
            if (IsSupportedPersonalizedHRTF != v43)
            {
              (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)this + 592))(this, 3113);
              v35 = inElement;
              v45 = this;
            }
          }
          else
          {
            v45 = this;
            if ((_DWORD)v18 != 3242)
              return 0;
          }
          AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)v45, v35, 0, 0);
          return 0;
        }
        goto LABEL_45;
      }
    }
    LODWORD(v356.__r_.__value_.__l.__data_) = 0;
    *(_QWORD *)buf = (char *)this + 3352;
    buf[8] = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
    v26 = (AUSM::Properties *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), inElement) + 1056);
    v27 = v18;
LABEL_69:
    if (!AUSM::Properties::getProperty(v26, v27, &v356))
      v25 = *a5 != LODWORD(v356.__r_.__value_.__l.__data_);
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
    goto LABEL_72;
  }
  if (a3 > 1)
  {
    v13 = a3;
    goto LABEL_15;
  }
  if (a2 == 3231 && a3)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v14 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v81 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v81 = (_QWORD *)*v81;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v81;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SetProperty";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 3231;
      _os_log_debug_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid scope = %u for global scope property = %u", buf, 0x22u);
    }
LABEL_9:

    return 4294956430;
  }
  LODWORD(theArray) = a2;
  inElementa = (char *)this + 6128;
  if (!*((_BYTE *)this + 6192))
  {
LABEL_296:
    v13 = a3;
    goto LABEL_15;
  }
  v29 = (AUSpatialMixerV2 *)((char *)this + 6160);
  v30 = *(_QWORD *)(*((_QWORD *)this + 770) + 768);
  if (v30)
  {
    v31 = atomic_load((unsigned __int8 *)(v30 + 97));
    if ((v31 & 1) != 0)
    {
      v33 = 1;
    }
    else
    {
      v32 = atomic_load((unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v29 + 768) + 96));
      v33 = v32 & 1;
    }
  }
  else
  {
    v33 = 0;
  }
  if (!(_DWORD)a4 && a3 == 1 && v33 && (_DWORD)theArray != 5000)
  {
    if (std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::find<vp::vx::io::Object_ID<vp::vx::io::Node>>((_QWORD *)this + 780, (unsigned int *)&theArray))
    {
      v15 = 0;
      for (m = 1; ; m = (m + 1))
      {
        v49 = *(_QWORD *)(*(_QWORD *)v29 + 120);
        if (v49)
          LODWORD(v50) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v49 + 24))(v49);
        else
          v50 = (*(_QWORD *)(*(_QWORD *)v29 + 104) - *(_QWORD *)(*(_QWORD *)v29 + 96)) >> 3;
        if (m >= v50)
          break;
        v51 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, int *, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, theArray, 1, m, a5, a6);
        if ((_DWORD)v51)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v52 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            v53 = (char *)this + 6168;
            if (inElementa[63] < 0)
              v53 = (char *)*((_QWORD *)this + 771);
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v53;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "ValidateProperty";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = v51;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = (_DWORD)theArray;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = m;
            _os_log_error_impl(&dword_1B5ED0000, v52, OS_LOG_TYPE_ERROR, "[%s|%s] Error %d setting property %u to element %u", buf, 0x28u);
          }

          v15 = v51;
        }
      }
      return v15;
    }
    return 0;
  }
  if (a3)
    v54 = 2001;
  else
    v54 = 2000;
  if ((int)theArray > 3266)
  {
    if ((_DWORD)theArray == 3267)
    {
      if (!a3)
      {
        v98 = *a5;
        v99 = atomic_load((unsigned __int8 *)(*(_QWORD *)v29 + 3670));
        if (v98 != (v99 & 1))
        {
          if (*((_DWORD *)this + 1580) != v98)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v100 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
            {
              v101 = (_QWORD *)((char *)this + 6168);
              if ((char)v12[63] < 0)
                v101 = (_QWORD *)*v101;
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = v101;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "ValidateProperty";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = v98;
              _os_log_impl(&dword_1B5ED0000, v100, OS_LOG_TYPE_DEFAULT, "[%s|%s] Storing post-processing reverb = %u", buf, 0x1Cu);
            }

            *((_DWORD *)this + 1580) = v98;
          }
          v102 = atomic_load((unsigned int *)(*(_QWORD *)v29 + 6004));
          if (v102 != 1)
          {
            v15 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, int *, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, theArray, v54, a4, a5, a6);
            AUSM::TuningManager::SetPostProceReverbBlend(v29, v102, 0xFFFFFFFFLL);
            return v15;
          }
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v103 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
          {
            v104 = (_QWORD *)((char *)this + 6168);
            if ((char)v12[63] < 0)
              v104 = (_QWORD *)*v104;
            v105 = (int)theArray;
            v106 = atomic_load((unsigned __int8 *)(*(_QWORD *)v29 + 3670));
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v104;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "ValidateProperty";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = v105;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 1;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v106 & 1;
            _os_log_impl(&dword_1B5ED0000, v103, OS_LOG_TYPE_DEFAULT, "[%s|%s] Property %u ignored with global sound stage = %u. Post-processing reverb = %u (not changed).", buf, 0x28u);
          }

          return 0;
        }
      }
      goto LABEL_296;
    }
    if ((_DWORD)theArray != 3279)
    {
      if ((_DWORD)theArray == 5000)
      {
        v57 = *(_QWORD *)(*(_QWORD *)v29 + 768);
        if (v57)
        {
          v58 = atomic_load((unsigned __int8 *)(v57 + 97));
          if ((v58 & 1) != 0)
          {
            v60 = 1;
          }
          else
          {
            v59 = atomic_load((unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v29 + 768) + 96));
            v60 = v59 & 1;
          }
          if (a3 && v60)
          {
            v192 = a4 == 0;
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v193 = (id)getAUSMV2Log(void)::gLog;
            v194 = os_log_type_enabled(v193, OS_LOG_TYPE_DEFAULT);
            if (v192)
            {
              if (v194)
              {
                v195 = (_QWORD *)((char *)this + 6168);
                if ((char)v12[63] < 0)
                  v195 = (_QWORD *)*v195;
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = v195;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "ValidateProperty";
                _os_log_impl(&dword_1B5ED0000, v193, OS_LOG_TYPE_DEFAULT, "[%s|%s] InputProperties for Element#0 in the property dictionary are being selectively applied to all APAC buses.", buf, 0x16u);
              }

              objc_msgSend(&unk_1E6A11B28, "stringValue");
              *(_QWORD *)buf = objc_claimAutoreleasedReturnValue();
              objc_msgSend(&unk_1E6A11B40, "stringValue");
              *(_QWORD *)&buf[8] = objc_claimAutoreleasedReturnValue();
              v196 = *(id *)a5;
              v197 = *(_QWORD *)(*(_QWORD *)v29 + 120);
              if (v197)
                LODWORD(v198) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v197 + 24))(v197);
              else
                v198 = (*(_QWORD *)(*(_QWORD *)v29 + 104) - *(_QWORD *)(*(_QWORD *)v29 + 96)) >> 3;
              v275 = 0;
              v276 = 1;
              v277 = (id *)buf;
              do
              {
                v278 = v275;
                objc_msgSend(v196, "objectForKey:", *v277);
                v279 = (objc_object *)objc_claimAutoreleasedReturnValue();
                if (v279)
                  v280 = v198 >= 2;
                else
                  v280 = 0;
                if (v280)
                {
                  v281 = 1;
                  do
                  {
                    AUSM::TuningManager::SetPropertyFromNSObject(v29, 1, v281, objc_msgSend(*v277, "intValue"), v279);
                    v281 = (v281 + 1);
                  }
                  while ((_DWORD)v198 != (_DWORD)v281);
                }

                v277 = (id *)&buf[8 * v276];
                v275 = 1;
                v276 = 2;
              }
              while ((v278 & 1) == 0);

              for (n = 8; n != -8; n -= 8)
            }
            else
            {
              if (v194)
              {
                v243 = (_QWORD *)((char *)this + 6168);
                if ((char)v12[63] < 0)
                  v243 = (_QWORD *)*v243;
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v243;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "ValidateProperty";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 1;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = a4;
                _os_log_impl(&dword_1B5ED0000, v193, OS_LOG_TYPE_DEFAULT, "[%s|%s] Properties with scope = %u and element = %u in the property dictionary are ignored with APAC.", buf, 0x22u);
              }

            }
            return 0;
          }
        }
        v355.__r_.__value_.__r.__words[0] = objc_msgSend(*(id *)a5, "mutableCopy");
        v199 = *(_QWORD *)(*(_QWORD *)v29 + 768);
        v200 = this;
        if (v199)
        {
          v201 = atomic_load((unsigned __int8 *)(v199 + 97));
          if ((v201 & 1) != 0
            || (v202 = atomic_load((unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v29 + 768) + 96)), (v202 & 1) != 0))
          {
            for (ii = (uint64_t *)*((_QWORD *)this + 777); ii; ii = (uint64_t *)*ii)
            {
              if (*((_BYTE *)ii + 20))
              {
                objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *((unsigned int *)ii + 4));
                v204 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v204, "stringValue");
                v205 = (void *)objc_claimAutoreleasedReturnValue();

                v206 = (void *)v355.__r_.__value_.__r.__words[0];
                objc_msgSend(v355.__r_.__value_.__l.__data_, "objectForKey:", v205);
                v207 = (void *)objc_claimAutoreleasedReturnValue();
                v208 = v207 == 0;

                if (!v208)
                {
                  objc_msgSend(v206, "removeObjectForKey:", v205);
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v209 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v209, OS_LOG_TYPE_DEFAULT))
                  {
                    v210 = (char *)this + 6168;
                    if (inElementa[63] < 0)
                      v210 = (char *)*((_QWORD *)this + 771);
                    *(_DWORD *)buf = 136315650;
                    *(_QWORD *)&buf[4] = v210;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "ValidateProperty";
                    *(_WORD *)&buf[22] = 2112;
                    *(_QWORD *)&buf[24] = v205;
                    _os_log_impl(&dword_1B5ED0000, v209, OS_LOG_TYPE_DEFAULT, "[%s|%s] Global property %@ in the property dictionary is a reserved APAC property, hence ignored.", buf, 0x20u);
                  }

                }
                v200 = this;
              }
            }
          }
        }
        if (!a3)
        {
          objc_msgSend(&unk_1E6A11B58, "stringValue");
          v356.__r_.__value_.__r.__words[0] = objc_claimAutoreleasedReturnValue();
          objc_msgSend(&unk_1E6A11B70, "stringValue");
          v356.__r_.__value_.__l.__size_ = objc_claimAutoreleasedReturnValue();
          objc_msgSend(&unk_1E6A11B88, "stringValue");
          v211 = 0;
          v356.__r_.__value_.__r.__words[2] = objc_claimAutoreleasedReturnValue();
          v340 = (char **)((char *)v200 + 6168);
          v212 = (void *)v355.__r_.__value_.__r.__words[0];
          *(_QWORD *)&v213 = 136315650;
          v335 = v213;
          do
          {
            objc_msgSend(v212, "objectForKey:", v356.__r_.__value_.__r.__words[v211], v335);
            v214 = (objc_object *)objc_claimAutoreleasedReturnValue();
            if (v214)
            {
              v215 = AUSM::TuningManager::SetPropertyFromNSObject(v29, 0, 0, objc_msgSend(*(id *)((char *)&v356.__r_.__value_.__l.__data_ + v211 * 8), "intValue"), v214);
              if (v215)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v216 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
                {
                  v217 = (char *)v200 + 6168;
                  if (inElementa[63] < 0)
                    v217 = *v340;
                  v218 = *(uint64_t *)((char *)&v356.__r_.__value_.__l.__data_ + v211 * 8);
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v217;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "ValidateProperty";
                  *(_WORD *)&buf[22] = 2112;
                  *(_QWORD *)&buf[24] = v218;
                  *(_WORD *)&buf[32] = 1024;
                  *(_DWORD *)&buf[34] = v215;
                  _os_log_impl(&dword_1B5ED0000, v216, OS_LOG_TYPE_DEFAULT, "[%s|%s] Could not set global property %@ from the property dictionary. Error %u", buf, 0x26u);
                }
              }
              else
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v216 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v216, OS_LOG_TYPE_DEBUG))
                {
                  v219 = (char *)v200 + 6168;
                  if (inElementa[63] < 0)
                    v219 = *v340;
                  v220 = *(uint64_t *)((char *)&v356.__r_.__value_.__l.__data_ + v211 * 8);
                  *(_DWORD *)buf = v335;
                  *(_QWORD *)&buf[4] = v219;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "ValidateProperty";
                  *(_WORD *)&buf[22] = 2112;
                  *(_QWORD *)&buf[24] = v220;
                  _os_log_debug_impl(&dword_1B5ED0000, v216, OS_LOG_TYPE_DEBUG, "[%s|%s] Global property %@ in the property dictionary is applied separately.", buf, 0x20u);
                }
              }

              v212 = (void *)v355.__r_.__value_.__r.__words[0];
              objc_msgSend(v355.__r_.__value_.__l.__data_, "removeObjectForKey:", v356.__r_.__value_.__r.__words[v211]);
            }

            ++v211;
          }
          while (v211 != 3);
          for (jj = 16; jj != -8; jj -= 8)

        }
        v15 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, std::string *, uint64_t))(**(_QWORD **)v29
                                                                                                  + 96))(*(_QWORD *)v29, theArray, v54, a4, &v355, a6);

        return v15;
      }
      goto LABEL_296;
    }
    v107 = *(_QWORD *)(*(_QWORD *)v29 + 768);
    if (v107)
    {
      v108 = atomic_load((unsigned __int8 *)(v107 + 97));
      if ((v108 & 1) != 0)
      {
        v110 = 1;
      }
      else
      {
        v109 = atomic_load((unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v29 + 768) + 96));
        v110 = v109 & 1;
      }
      if (!a3 && v110)
      {
        AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v356, *(_QWORD *)v29 + 5640);
        if (!v356.__r_.__value_.__r.__words[0])
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v250 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v250, OS_LOG_TYPE_ERROR))
          {
            v330 = (_QWORD *)((char *)this + 6168);
            if ((char)v12[63] < 0)
              v330 = (_QWORD *)*v330;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v330;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "ValidateProperty";
            _os_log_error_impl(&dword_1B5ED0000, v250, OS_LOG_TYPE_ERROR, "[%s|%s] ImmersiveRendererData did not set optional feature dictionary.", buf, 0x16u);
          }

          applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v356.__r_.__value_.__l.__data_);
          goto LABEL_296;
        }
        applesauce::CF::DictionaryRef::from_get((applesauce::CF::DictionaryRef *)&v355, *(CFTypeRef *)a5);
        if (v355.__r_.__value_.__r.__words[0])
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v221 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v221, OS_LOG_TYPE_DEFAULT))
          {
            v222 = (_QWORD *)((char *)this + 6168);
            if ((char)v12[63] < 0)
              v222 = (_QWORD *)*v222;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v222;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "ValidateProperty";
            _os_log_impl(&dword_1B5ED0000, v221, OS_LOG_TYPE_DEFAULT, "[%s|%s] optional feature dictionary is being modified to ensure APAC features remain enabled.", buf, 0x16u);
          }

          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)v355.__r_.__value_.__l.__data_);
          *(_QWORD *)buf = MutableCopy;
          v224 = (const void *)*MEMORY[0x1E0C9AE50];
          CFDictionarySetValue(MutableCopy, CFSTR("SourceExtent"), (const void *)*MEMORY[0x1E0C9AE50]);
          CFDictionarySetValue(MutableCopy, CFSTR("SourceDiffuse"), v224);
          CFDictionarySetValue(MutableCopy, CFSTR("SourceDivergence"), v224);
          CFDictionarySetValue(MutableCopy, CFSTR("SourceDirectivity"), v224);
          CFDictionarySetValue(MutableCopy, CFSTR("NearFieldHOA"), v224);
          CFDictionarySetValue(MutableCopy, CFSTR("NearFieldHRTF"), v224);
          CFDictionarySetValue(MutableCopy, (const void *)kOptionalFeatureEnableAPACRoomPresets, v224);
          (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD, _BYTE *, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, 3279, 2000, 0, buf, 8);
          CFRelease(*(CFTypeRef *)buf);
        }
        else
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v274 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v274, OS_LOG_TYPE_ERROR))
          {
            v332 = (_QWORD *)((char *)this + 6168);
            if ((char)v12[63] < 0)
              v332 = (_QWORD *)*v332;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v332;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "ValidateProperty";
            _os_log_error_impl(&dword_1B5ED0000, v274, OS_LOG_TYPE_ERROR, "[%s|%s] invalid optional feature dictionary.", buf, 0x16u);
          }

        }
        applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v355.__r_.__value_.__l.__data_);
        v248 = &v356;
LABEL_656:
        applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v248->__r_.__value_.__l.__data_);
        return 0;
      }
    }
    v225 = *(CFTypeRef *)a5;
    if (*(_QWORD *)a5)
    {
      CFRetain(*(CFTypeRef *)a5);
      applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v356, v225);
      if (v356.__r_.__value_.__r.__words[0])
      {
        *(_QWORD *)buf = v356.__r_.__value_.__r.__words[0];
        if (!(*(unsigned int (**)(_QWORD, uint64_t, uint64_t, _QWORD, _BYTE *, uint64_t))(**(_QWORD **)v29
                                                                                                 + 96))(*(_QWORD *)v29, 3279, 2000, 0, buf, 8))
        {
          v226 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(&v356);
          v228 = (unsigned __int16)applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const*&>(*v226, (const void *)kOptionalFeatureEnableAPACRoomPresets);
          if (v228 <= 0x100)
            LOBYTE(v228) = 0;
          if ((_BYTE)v228)
            v229 = 23;
          else
            v229 = 12;
          LODWORD(v355.__r_.__value_.__l.__data_) = v229;
          AUSM::Properties::setMaxValue((AUSM::Properties *)(*(_QWORD *)v29 + 3584), (uint64_t)&v355, v227);
        }
LABEL_510:
        if (v356.__r_.__value_.__r.__words[0])
          CFRelease(v356.__r_.__value_.__l.__data_);
        return 0;
      }
    }
    else
    {
      v356.__r_.__value_.__r.__words[0] = 0;
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v235 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v235, OS_LOG_TYPE_ERROR))
    {
      v319 = (_QWORD *)((char *)this + 6168);
      if ((char)v12[63] < 0)
        v319 = (_QWORD *)*v319;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v319;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "ValidateProperty";
      _os_log_error_impl(&dword_1B5ED0000, v235, OS_LOG_TYPE_ERROR, "[%s|%s] invalid optional feature dictionary.", buf, 0x16u);
    }

    goto LABEL_510;
  }
  if ((_DWORD)theArray == 3231)
  {
    v15 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, int *, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, 3231, v54, a4, a5, a6);
    if ((_DWORD)v15)
      return v15;
    LODWORD(v355.__r_.__value_.__l.__data_) = 1;
    (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD, std::string *, uint64_t))(**((_QWORD **)this + 770) + 96))(*((_QWORD *)this + 770), 3251, 2000, 0, &v355, 4);
    for (kk = (uint64_t *)*((_QWORD *)this + 782); kk; kk = (uint64_t *)*kk)
    {
      LODWORD(v356.__r_.__value_.__l.__data_) = 0;
      if (!(*(unsigned int (**)(_QWORD, _QWORD, uint64_t, _QWORD, std::string *))(**(_QWORD **)v29 + 88))(*(_QWORD *)v29, *((unsigned int *)kk + 4), 1, 0, &v356))
      {
        v90 = *(_QWORD *)(*(_QWORD *)v29 + 120);
        if (v90)
          LODWORD(v91) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v90 + 24))(v90);
        else
          v91 = (*(_QWORD *)(*(_QWORD *)v29 + 104) - *(_QWORD *)(*(_QWORD *)v29 + 96)) >> 3;
        if (v91 >= 2)
        {
          v92 = 1;
          do
          {
            v93 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, std::string *, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, *((unsigned int *)kk + 4), 1, v92, &v356, 4);
            if (v93)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v94 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
              {
                v95 = (char *)this + 6168;
                if ((char)v12[63] < 0)
                  v95 = (char *)*((_QWORD *)this + 771);
                v96 = *((_DWORD *)kk + 4);
                *(_DWORD *)buf = 136316418;
                *(_QWORD *)&buf[4] = v95;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "ValidateProperty";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v93;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v96;
                *(_WORD *)&buf[34] = 1024;
                *(_DWORD *)&buf[36] = v356.__r_.__value_.__l.__data_;
                *(_WORD *)&buf[40] = 1024;
                *(_DWORD *)&buf[42] = v92;
                _os_log_impl(&dword_1B5ED0000, v94, OS_LOG_TYPE_DEFAULT, "[%s|%s] Error %u in setting property %u = %u for element %u", buf, 0x2Eu);
              }

            }
            v92 = (v92 + 1);
          }
          while ((_DWORD)v91 != (_DWORD)v92);
        }
      }
    }
    AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(buf, *(_QWORD *)v29 + 5640);
    if (*(_QWORD *)buf)
      Mutable = CFDictionaryCreateMutableCopy(0, 0, *(CFDictionaryRef *)buf);
    else
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v244 = Mutable;
    v356.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
    v245 = (const void *)*MEMORY[0x1E0C9AE50];
    CFDictionarySetValue(Mutable, CFSTR("SourceExtent"), (const void *)*MEMORY[0x1E0C9AE50]);
    CFDictionarySetValue(v244, CFSTR("SourceDiffuse"), v245);
    CFDictionarySetValue(v244, CFSTR("SourceDivergence"), v245);
    CFDictionarySetValue(v244, CFSTR("SourceDirectivity"), v245);
    CFDictionarySetValue(v244, CFSTR("NearFieldHOA"), v245);
    CFDictionarySetValue(v244, CFSTR("NearFieldHRTF"), v245);
    CFDictionarySetValue(v244, (const void *)kOptionalFeatureEnableAPACRoomPresets, v245);
    if (!(*(unsigned int (**)(_QWORD, uint64_t, uint64_t, _QWORD, std::string *, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, 3279, 2000, 0, &v356, 8))
    {
      LODWORD(v343) = 23;
      AUSM::Properties::setMaxValue((AUSM::Properties *)(*(_QWORD *)v29 + 3584), (uint64_t)&v343, v246);
    }
    CFRelease(v356.__r_.__value_.__l.__data_);
    if (_os_feature_enabled_impl())
    {
      LODWORD(v343) = 1;
      (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD, const void **, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, 3289, 2000, 0, &v343, 4);
    }
    v247 = atomic_load((unsigned int *)(*(_QWORD *)v29 + 6004));
    AUSM::TuningManager::SetPostProceReverbBlend(v29, v247, 0xFFFFFFFFLL);
    v248 = (std::string *)buf;
    goto LABEL_656;
  }
  if ((_DWORD)theArray == 3240)
  {
    if (a3)
      goto LABEL_296;
    v15 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, int *, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, 3240, v54, a4, a5, a6);
    if ((_DWORD)v15)
      return v15;
    v137 = atomic_load((unsigned __int8 *)(*(_QWORD *)v29 + 3670));
    v138 = atomic_load((unsigned int *)(*(_QWORD *)v29 + 6004));
    if (v138 != 1 || (v137 & 1) != 0)
    {
LABEL_767:
      AUSM::TuningManager::SetPostProceReverbBlend(v29, v138, 0xFFFFFFFFLL);
      return 0;
    }
    LODWORD(v356.__r_.__value_.__l.__data_) = 1;
    v139 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD, std::string *, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, 3267, 2000, 0, &v356, 4);
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v140 = (id)getAUSMV2Log(void)::gLog;
    v141 = os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT);
    if (v139)
    {
      if (v141)
      {
        v142 = (_QWORD *)((char *)this + 6168);
        if ((char)v12[63] < 0)
          v142 = (_QWORD *)*v142;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v142;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "ValidateProperty";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = v139;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1;
        v143 = "[%s|%s] Error %u while trying to enable post-processing reverb for global sound stage = %u";
        v144 = v140;
        v145 = 34;
LABEL_765:
        _os_log_impl(&dword_1B5ED0000, v144, OS_LOG_TYPE_DEFAULT, v143, buf, v145);
      }
    }
    else if (v141)
    {
      v317 = (_QWORD *)((char *)this + 6168);
      if ((char)v12[63] < 0)
        v317 = (_QWORD *)*v317;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v317;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "ValidateProperty";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1;
      v143 = "[%s|%s] Post-processing reverb is enabled for global sound stage = %u";
      v144 = v140;
      v145 = 28;
      goto LABEL_765;
    }

    goto LABEL_767;
  }
  if ((_DWORD)theArray != 3242)
    goto LABEL_296;
  if ((_DWORD)a6 == 4 && !*((_BYTE *)this + 6193) && *a5 != 4)
  {
    *((_BYTE *)this + 6193) = 1;
    LODWORD(v356.__r_.__value_.__l.__data_) = 1125515264;
    if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t, _QWORD, std::string *, uint64_t))(**(_QWORD **)v29
                                                                                                  + 96))(*(_QWORD *)v29, 3108, 2000, 0, &v356, 4))
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v55 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      {
        v326 = (_QWORD *)((char *)this + 6168);
        if ((char)v12[63] < 0)
          v326 = (_QWORD *)*v326;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v326;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "ValidateProperty";
        _os_log_debug_impl(&dword_1B5ED0000, v55, OS_LOG_TYPE_DEBUG, "[%s|%s] Could not set BCM LFE low pass frequency", buf, 0x16u);
      }

    }
  }
  v15 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, int *, uint64_t))(**(_QWORD **)v29 + 96))(*(_QWORD *)v29, 3242, v54, a4, a5, a6);
  if (!(_DWORD)v15)
  {
    v56 = atomic_load((unsigned int *)(*(_QWORD *)v29 + 6004));
    AUSM::TuningManager::SetPostProceReverbBlend(v29, v56, a4);
    return 0;
  }
  return v15;
}

void sub_1B618E7A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31)
{
  uint64_t v31;
  void *v32;

  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v31);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::RemovePropertyValue(AUSpatialMixerV2 *this, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t Element;
  uint64_t v13;
  NSObject *v14;
  _QWORD *v15;
  _QWORD *v16;
  char *v17;
  char v18;
  uint8_t buf[4];
  _QWORD *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unsigned int v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a3 == 2)
  {
    if (!a4)
    {
      Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
      return AUSM::Properties::setProperty((AUSM::Properties *)(Element + 224), a2, 0, 0, 0);
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v8 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v15 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v15 = (_QWORD *)*v15;
      *(_DWORD *)buf = 136316162;
      v20 = v15;
      v21 = 2080;
      v22 = "RemovePropertyValue";
      v23 = 1024;
      v24 = 2;
      v25 = 1024;
      v26 = a4;
      v27 = 1024;
      v28 = a2;
      _os_log_error_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_ERROR, "[%s|%s] (scope=%u, element=%u): invalid element (property = %u)", buf, 0x28u);
    }

    return 4294956419;
  }
  if (a3 != 1)
  {
    if (a3)
      return 4294956445;
    if ((_DWORD)a2 != 3231)
      return AUSM::GlobalProperties::setProperty((AUSpatialMixerV2 *)((char *)this + 3584), a2, 0, 0, 0);
    return 4294956433;
  }
  v17 = (char *)this + 3352;
  v18 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
  v9 = *((_QWORD *)this + 15);
  if (v9)
    LODWORD(v10) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  else
    v10 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  if (v10 <= a4)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v14 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v16 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v16 = (_QWORD *)*v16;
      *(_DWORD *)buf = 136316162;
      v20 = v16;
      v21 = 2080;
      v22 = "RemovePropertyValue";
      v23 = 1024;
      v24 = 1;
      v25 = 1024;
      v26 = a4;
      v27 = 1024;
      v28 = a2;
      _os_log_error_impl(&dword_1B5ED0000, v14, OS_LOG_TYPE_ERROR, "[%s|%s] (scope=%u, element=%u): invalid element (property = %u)", buf, 0x28u);
    }

    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v17);
    return 4294956419;
  }
  v13 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
  v7 = AUSM::Properties::setProperty((AUSM::Properties *)(v13 + 1056), a2, 0, 0, 0);
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v17);
  return v7;
}

void sub_1B618EF8C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t AUSpatialMixerV2::SetParameter(AUSpatialMixerV2 *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5)
{
  float v5;
  unsigned __int8 *v9;
  unsigned int v10;
  unint64_t v12;
  unsigned int v13;
  float v14;
  float v15;
  int v16;
  int v17;
  NSObject *v18;
  float v19;
  float v20;
  BOOL v21;
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  uint64_t result;
  ausdk::AUScope *v25;
  ausdk::AUElement *v26;
  unsigned int v27;
  float *v28;
  float v29;
  float v30;
  uint64_t v31;
  ausdk::AUElement *v32;
  ausdk::AUElement *v33;
  unsigned __int8 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 v38;
  unsigned __int8 *v39;
  uint64_t v40;
  ausdk::AUElement *v41;
  unsigned __int8 v42;
  ausdk::AUElement **v43;
  ausdk::AUElement **v44;
  NSObject *v45;
  unsigned __int8 v46;
  _QWORD *v47;
  float Parameter;
  uint64_t v49;
  ausdk::AUElement *v50;
  ausdk::AUElement **v51;
  uint64_t v52;
  ausdk::AUElement *v53;
  ausdk::AUElement **v54;
  float v55;
  uint64_t v56;
  ausdk::AUElement *v57;
  ausdk::AUElement **v58;
  uint64_t v59;
  ausdk::AUElement *v60;
  ausdk::AUElement **v61;
  float v62;
  AUSM *v63;
  AUSM *v64;
  unsigned __int128 v65;
  unsigned __int128 *v66;
  unsigned __int128 v67;
  unsigned __int128 *v68;
  unsigned __int128 v69;
  int32x4_t v70;
  int8x16_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  float32x2_t v76;
  float32x4_t v77;
  unsigned __int32 v78;
  float32x2_t v79;
  float32x2_t v80;
  float32x4_t v81;
  int8x16_t v82;
  float32x2_t v83;
  float32x2_t v84;
  float v85;
  uint64_t v86;
  float v87;
  unsigned __int128 *v88;
  NSObject *v89;
  _QWORD *v90;
  _QWORD *v91;
  _QWORD *v92;
  float v93;
  float v94;
  unsigned int v95;
  uint8_t buf[4];
  _QWORD *v97;
  __int16 v98;
  const char *v99;
  __int16 v100;
  int v101;
  __int16 v102;
  unsigned int v103;
  uint64_t v104;

  v5 = a5;
  v104 = *MEMORY[0x1E0C80C00];
  v9 = (unsigned __int8 *)this + 6191;
  v10 = a3 - 2000;
  if (a3 - 2000 >= 3)
  {
    if (a3 <= 1)
    {
      v95 = a4;
      if (*((_BYTE *)this + 6192))
      {
        if (a2 == 35 && a3 == 1)
        {
          v12 = *((_QWORD *)this + 788);
          if (v12 <= a4)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v18 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              v47 = (_QWORD *)((char *)this + 6168);
              if ((char)*v9 < 0)
                v47 = (_QWORD *)*v47;
              *(_DWORD *)buf = 136315906;
              v97 = v47;
              v98 = 2080;
              v99 = "ValidateParameter";
              v100 = 1024;
              v101 = v12;
              v102 = 1024;
              v103 = a4;
              _os_log_error_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_ERROR, "[%s|%s] Buffer size = %u is not large enough to store parameter values for input = %u", buf, 0x22u);
            }

            return 4294956419;
          }
          if (*((float *)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)this + 6280, a4, &v95)+ 5) != a5)*((float *)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)this + 6280, a4, &v95)+ 5) = v5;
          v13 = atomic_load((unsigned int *)(*((_QWORD *)this + 770) + 6004));
          if (v13 == 1)
            return 0;
        }
      }
    }
    v10 = a3;
  }
  switch(a2)
  {
    case 2u:
    case 0x22u:
      v14 = 10000.0;
      goto LABEL_54;
    case 3u:
      v14 = 20.0;
      if (v5 <= 20.0)
        v14 = v5;
      *(float *)&v17 = -120.0;
      goto LABEL_38;
    case 4u:
      v14 = 10.0;
      if (v5 <= 10.0)
        v14 = v5;
      v15 = 0.1;
      goto LABEL_50;
    case 6u:
    case 7u:
    case 0x11u:
      v14 = 10.0;
      goto LABEL_54;
    case 8u:
    case 0x23u:
      *(float *)&v16 = 100.0;
      goto LABEL_53;
    case 9u:
      v14 = 40.0;
      if (v5 <= 40.0)
        v14 = v5;
      *(float *)&v17 = -40.0;
      goto LABEL_38;
    case 0xAu:
    case 0xBu:
      v14 = 0.0;
      if (v5 <= 0.0)
        v14 = v5;
      *(float *)&v17 = -100.0;
LABEL_38:
      v15 = *(float *)&v17;
      goto LABEL_50;
    case 0xEu:
      v19 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 80);
      v20 = v19 * 0.5;
      v21 = v19 < 20000.0;
      v14 = 10000.0;
      if (v21)
        v14 = v20;
      if (v14 >= v5)
        v14 = v5;
      v15 = 10.0;
      goto LABEL_50;
    case 0xFu:
      v14 = 4.0;
      if (v5 <= 4.0)
        v14 = v5;
      v15 = 0.05;
      goto LABEL_50;
    case 0x10u:
      v14 = 18.0;
      if (v5 <= 18.0)
        v14 = v5;
      v15 = -18.0;
      goto LABEL_50;
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Eu:
    case 0x21u:
      v14 = 1.0;
      goto LABEL_54;
    case 0x1Du:
      *(float *)&v16 = 180.0;
      goto LABEL_53;
    case 0x1Fu:
    case 0x20u:
    case 0x27u:
      if (v5 < 0.5)
        v5 = 0.0;
      else
        v5 = 1.0;
      break;
    case 0x24u:
    case 0x25u:
    case 0x26u:
      v14 = 10000.0;
      if (v5 <= 10000.0)
        v14 = v5;
      v15 = -10000.0;
LABEL_50:
      v21 = v5 < v15;
      goto LABEL_57;
    case 0x28u:
      *(float *)&v16 = 90.0;
LABEL_53:
      v14 = *(float *)&v16;
LABEL_54:
      if (v5 <= v14)
        v14 = v5;
      v21 = v5 < 0.0;
      v15 = 0.0;
LABEL_57:
      if (v21)
        v5 = v15;
      else
        v5 = v14;
      break;
    default:
      break;
  }
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, v10);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  if (ausdk::AUElement::GetParameter(Element, a2) == v5)
    return 0;
  v25 = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, v10);
  v26 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v25, a4);
  ausdk::AUElement::SetParameter(v26, a2, v5, 0);
  if (!v10)
  {
    if (!a4)
    {
      result = 0;
      switch(a2)
      {
        case 9u:
          return result;
        case 0xEu:
          result = 0;
          *((float *)this + 788) = v5;
          goto LABEL_104;
        case 0xFu:
          result = 0;
          *((float *)this + 789) = v5;
          goto LABEL_104;
        case 0x10u:
          result = 0;
          *((float *)this + 790) = v5;
          goto LABEL_104;
        case 0x11u:
          result = 0;
          *((_DWORD *)this + 791) = v5;
          goto LABEL_104;
        case 0x12u:
          result = 0;
          *((_BYTE *)this + 3168) = v5 != 0.0;
LABEL_104:
          ++*((_DWORD *)this + 793);
          return result;
        case 0x13u:
        case 0x14u:
        case 0x15u:
          v31 = *((_QWORD *)this + 9);
          if (v31)
          {
            v32 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v31 + 32))(v31, 0);
          }
          else
          {
            v43 = (ausdk::AUElement **)*((_QWORD *)this + 6);
            if (*((ausdk::AUElement ***)this + 7) == v43)
              v32 = 0;
            else
              v32 = *v43;
          }
          Parameter = ausdk::AUElement::GetParameter(v32, 0x13u);
          v49 = *((_QWORD *)this + 9);
          if (v49)
          {
            v50 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v49 + 32))(v49, 0);
          }
          else
          {
            v51 = (ausdk::AUElement **)*((_QWORD *)this + 6);
            if (*((ausdk::AUElement ***)this + 7) == v51)
              v50 = 0;
            else
              v50 = *v51;
          }
          v55 = ausdk::AUElement::GetParameter(v50, 0x14u);
          v56 = *((_QWORD *)this + 9);
          if (v56)
          {
            v57 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v56 + 32))(v56, 0);
          }
          else
          {
            v58 = (ausdk::AUElement **)*((_QWORD *)this + 6);
            if (*((ausdk::AUElement ***)this + 7) == v58)
              v57 = 0;
            else
              v57 = *v58;
          }
          v62 = ausdk::AUElement::GetParameter(v57, 0x15u);
          *(double *)&v65 = AUSM::eulerToAUCoordQuaternion(v63, Parameter, v55, v62);
          v66 = (unsigned __int128 *)((char *)this + 3696);
          do
            __ldaxp(v66);
          while (__stlxp(v65, v66));
          atomic_store(1u, v9 + 1170);
          do
            v67 = __ldaxp(v66);
          while (__stlxp(v67, v66));
          v68 = (unsigned __int128 *)((char *)this + 3712);
          do
            v69 = __ldaxp(v68);
          while (__stlxp(v69, v68));
          v70 = (int32x4_t)vnegq_f32((float32x4_t)v69);
          v71 = (int8x16_t)vtrn2q_s32((int32x4_t)v69, vtrn1q_s32((int32x4_t)v69, v70));
          v72 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v69, (int8x16_t)v70, 8uLL), *(float32x2_t *)&v67, 1), (float32x4_t)vextq_s8(v71, v71, 8uLL), *(float *)&v67);
          v73 = (float32x4_t)vrev64q_s32((int32x4_t)v69);
          v73.i32[0] = v70.i32[1];
          v73.i32[3] = v70.i32[2];
          v74 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)v69, (float32x4_t)v67, 3), v73, (float32x4_t)v67, 2), v72);
          v75 = (int8x16_t)vmulq_f32(v74, v74);
          v76 = vadd_f32(*(float32x2_t *)v75.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL));
          if (vaddv_f32(v76) == 0.0)
          {
            v77 = (float32x4_t)xmmword_1B6629CC0;
          }
          else
          {
            v78 = vadd_f32(v76, (float32x2_t)vdup_lane_s32((int32x2_t)v76, 1)).u32[0];
            v79 = vrsqrte_f32((float32x2_t)v78);
            v80 = vmul_f32(v79, vrsqrts_f32((float32x2_t)v78, vmul_f32(v79, v79)));
            v77 = vmulq_n_f32(v74, vmul_f32(v80, vrsqrts_f32((float32x2_t)v78, vmul_f32(v80, v80))).f32[0]);
          }
          v81 = vmulq_f32(v77, (float32x4_t)xmmword_1B66A07B0);
          v82 = (int8x16_t)vmulq_f32(v77, v77);
          *(float32x2_t *)v82.i8 = vadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v82, v82, 8uLL));
          v82.i32[0] = vadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v82.i8, 1)).u32[0];
          v83 = vrecpe_f32((float32x2_t)v82.u32[0]);
          v84 = vmul_f32(v83, vrecps_f32((float32x2_t)v82.u32[0], v83));
          v85 = AUSM::auCoordQuaternionToYawPitch(v64, vmulq_n_f32(v81, vmul_f32(v84, vrecps_f32((float32x2_t)v82.u32[0], v84)).f32[0]));
          v86 = *((_QWORD *)this + 401);
          if (v86)
          {
            result = 0;
            *(float *)(v86 + 8) = v85;
            return result;
          }
          *((float *)this + 799) = v85;
          MidSideRotation::calculateCoefficients((__float2 *)((char *)this + 3180));
          break;
        case 0x24u:
        case 0x25u:
        case 0x26u:
          v40 = *((_QWORD *)this + 9);
          if (v40)
          {
            v41 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v40 + 32))(v40, 0);
          }
          else
          {
            v44 = (ausdk::AUElement **)*((_QWORD *)this + 6);
            if (*((ausdk::AUElement ***)this + 7) == v44)
              v41 = 0;
            else
              v41 = *v44;
          }
          v94 = ausdk::AUElement::GetParameter(v41, 0x24u);
          v52 = *((_QWORD *)this + 9);
          if (v52)
          {
            v53 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v52 + 32))(v52, 0);
          }
          else
          {
            v54 = (ausdk::AUElement **)*((_QWORD *)this + 6);
            if (*((ausdk::AUElement ***)this + 7) == v54)
              v53 = 0;
            else
              v53 = *v54;
          }
          v93 = ausdk::AUElement::GetParameter(v53, 0x25u);
          v59 = *((_QWORD *)this + 9);
          if (v59)
          {
            v60 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v59 + 32))(v59, 0);
          }
          else
          {
            v61 = (ausdk::AUElement **)*((_QWORD *)this + 6);
            if (*((ausdk::AUElement ***)this + 7) == v61)
              v60 = 0;
            else
              v60 = *v61;
          }
          v87 = ausdk::AUElement::GetParameter(v60, 0x26u);
          v88 = (unsigned __int128 *)((char *)this + 3728);
          do
            __ldaxp(v88);
          while (__stlxp(__PAIR128__(LODWORD(v87), __PAIR64__(LODWORD(v93), LODWORD(v94))), v88));
          result = 0;
          v39 = v9 + 1171;
          goto LABEL_148;
        default:
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v45 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            v90 = (_QWORD *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v90 = (_QWORD *)*v90;
            *(_DWORD *)buf = 136315650;
            v97 = v90;
            v98 = 2080;
            v99 = "SetParameter";
            v100 = 1024;
            v101 = a2;
            _os_log_debug_impl(&dword_1B5ED0000, v45, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid parameter id %d (global scope)", buf, 0x1Cu);
          }
LABEL_159:

          return 4294956418;
      }
      return 0;
    }
    return 4294956419;
  }
  if (v10 == 2)
  {
    result = 0;
    if (a2 == 3 && !a4)
    {
      v28 = (float *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
      v29 = ausdk::AUElement::GetParameter((ausdk::AUElement *)v28, 3u);
      v30 = __exp10f(v29 * 0.05);
      result = 0;
      v28[48] = v30;
    }
    return result;
  }
  if (v10 != 1)
    return 0;
  if (a2 == 29)
  {
    v27 = 30;
    goto LABEL_78;
  }
  if (a2 == 30)
  {
    v27 = 29;
LABEL_78:
    v33 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
    ausdk::AUElement::SetParameter(v33, v27, -1.0, 0);
  }
  v34 = atomic_load(v9 + 1250);
  if ((v34 & 1) == 0)
    return 0;
  v35 = *((_QWORD *)this + 15);
  if (v35)
    LODWORD(v36) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v35 + 24))(v35);
  else
    v36 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  if (v36 <= a4)
    return 0;
  v37 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a4);
  result = 0;
  switch(a2)
  {
    case 0u:
    case 1u:
    case 2u:
      atomic_store(1u, (unsigned __int8 *)this + 3243);
      goto LABEL_85;
    case 3u:
    case 6u:
    case 7u:
      v46 = atomic_load(v9 + 1250);
      if ((v46 & 1) == 0)
        return 0;
      result = 0;
      v39 = (unsigned __int8 *)(v37 + 1923);
      break;
    case 4u:
      result = 0;
      if (*((_BYTE *)this + 540) && *((_DWORD *)this + 134) == 1 && v5 != 1.0)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v89 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
        {
          v92 = (_QWORD *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v92 = (_QWORD *)*v92;
          *(_DWORD *)buf = 136315394;
          v97 = v92;
          v98 = 2080;
          v99 = "SetParameter";
          _os_log_error_impl(&dword_1B5ED0000, v89, OS_LOG_TYPE_ERROR, "[%s|%s] the PlaybackRate parameter value can only be 1.0 with ProcessMultiple as the render method", buf, 0x16u);
        }

        return 4294900553;
      }
      return result;
    case 5u:
    case 0xAu:
    case 0xBu:
    case 0x23u:
      v42 = atomic_load(v9 + 1250);
      if ((v42 & 1) == 0)
        return 0;
      result = 0;
      v39 = (unsigned __int8 *)(v37 + 696);
      break;
    case 8u:
      return result;
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x22u:
    case 0x27u:
    case 0x28u:
LABEL_85:
      v38 = atomic_load(v9 + 1250);
      if ((v38 & 1) == 0)
        return 0;
      result = 0;
      v39 = (unsigned __int8 *)(v37 + 1921);
      break;
    default:
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v45 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
      {
        v91 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v91 = (_QWORD *)*v91;
        *(_DWORD *)buf = 136315650;
        v97 = v91;
        v98 = 2080;
        v99 = "SetParameter";
        v100 = 1024;
        v101 = a2;
        _os_log_debug_impl(&dword_1B5ED0000, v45, OS_LOG_TYPE_DEBUG, "[%s|%s] invalid parameter id %d (input scope)", buf, 0x1Cu);
      }
      goto LABEL_159;
  }
LABEL_148:
  atomic_store(1u, v39);
  return result;
}

uint64_t AUSpatialMixerV2::CanScheduleParameters(AUSpatialMixerV2 *this)
{
  return 1;
}

uint64_t AUSpatialMixerV2::ScheduleParameter(AUSpatialMixerV2 *this, const AudioUnitParameterEvent *a2, unsigned int a3)
{
  unsigned int v6;
  NSObject *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  const AudioUnitParameterEvent *v11;
  const AudioUnitParameterEvent *v12;
  unsigned int v13;
  AudioUnitParameterID *v14;
  int v15;
  NSObject *v16;
  _OWORD *v18;
  unint64_t v19;
  AudioUnitParameterEvent::$30DB46DA13B14C3192C3DF0E34A08043 v20;
  _OWORD *v21;
  AUParameterEventType *p_eventType;
  AUParameterEventType eventType;
  const AudioUnitParameterEvent *v24;
  AudioUnitParameterID *p_parameter;
  AudioUnitParameterID parameter;
  uint64_t v27;
  NSObject *v28;
  const AudioUnitParameterEvent *v29;
  AudioUnitParameterID *v30;
  AudioUnitParameterID v31;
  const AudioUnitParameterEvent *v32;
  AudioUnitParameterID *v33;
  AudioUnitParameterID v34;
  const AudioUnitParameterEvent *v35;
  AudioUnitParameterID *v36;
  AudioUnitParameterID v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  _OWORD *v45;
  AudioUnitParameterEvent::$30DB46DA13B14C3192C3DF0E34A08043 eventValues;
  char *v47;
  char *v48;
  _OWORD *v49;
  __int128 v50;
  char *v51;
  AudioUnitParameterID v52;
  AudioUnitScope v53;
  AudioUnitElement element;
  char *v55;
  AUParameterEventType v56;
  char *v57;
  AudioUnitParameterID v58;
  AudioUnitScope v59;
  int v60;
  char *v61;
  AudioUnitParameterID v62;
  AudioUnitScope v63;
  int v64;
  char *v65;
  AudioUnitParameterID v66;
  AudioUnitScope scope;
  int v68;
  char *v69;
  AudioUnitParameterID v70;
  AudioUnitScope v71;
  int v72;
  char **v74;
  uint64_t v75;
  char *v76;
  char v77;
  uint8_t v78[4];
  char *v79;
  __int16 v80;
  const char *v81;
  __int16 v82;
  int v83;
  __int16 v84;
  AudioUnitParameterID v85;
  __int16 v86;
  AudioUnitScope v87;
  __int16 v88;
  AudioUnitElement v89;
  uint8_t buf[4];
  char *v91;
  __int16 v92;
  const char *v93;
  __int16 v94;
  AUParameterEventType v95;
  __int16 v96;
  AudioUnitParameterID v97;
  __int16 v98;
  AudioUnitScope v99;
  __int16 v100;
  int v101;
  int v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  v6 = atomic_load((unsigned int *)this + 1192);
  if (v6 != 2)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v7 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = (char *)this + 3592;
      if (*((char *)this + 3615) < 0)
        v8 = *(char **)v8;
      *(_DWORD *)buf = 136315394;
      v91 = v8;
      v92 = 2080;
      v93 = "ScheduleParameter";
      _os_log_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_INFO, "[%s|%s] Warning: scheduling parameters while the parameter smoothing is not set to scheduled parameters.", buf, 0x16u);
    }

  }
  v76 = (char *)this + 3544;
  v77 = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3544);
  if (a3)
  {
    v9 = 0;
    v10 = 0;
    v74 = (char **)((char *)this + 3592);
    v75 = a3;
    while (1)
    {
      v11 = &a2[v9];
      v12 = v11;
      v13 = atomic_load((unsigned int *)this + 1192);
      if (v13 != 2)
      {
LABEL_25:
        eventType = v11->eventType;
        p_eventType = &v11->eventType;
        switch(eventType)
        {
          case 1u:
            v24 = &a2[v9];
            parameter = v24->parameter;
            p_parameter = &v24->parameter;
            v27 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, parameter, v12->scope, *(p_parameter - 1), p_parameter[2], *((float *)p_parameter + 3));
            if ((_DWORD)v27)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v28 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
              {
                v65 = (char *)this + 3592;
                if (*((char *)this + 3615) < 0)
                  v65 = *v74;
                v66 = *p_parameter;
                scope = v12->scope;
                v68 = *(p_parameter - 1);
                *(_DWORD *)buf = 136316418;
                v91 = v65;
                v92 = 2080;
                v93 = "ScheduleParameter";
                v94 = 1024;
                v95 = v9;
                v96 = 1024;
                v97 = v66;
                v98 = 1024;
                v99 = scope;
                v100 = 1024;
                v101 = v68;
                _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] Error scheduling unsupported parameter (immediate) #%u: param = %u, scope = %u, element = %u", buf, 0x2Eu);
              }
              goto LABEL_45;
            }
            break;
          case 2u:
            v35 = &a2[v9];
            v37 = v35->parameter;
            v36 = &v35->parameter;
            v27 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, v37, v12->scope, *(v36 - 1), v36[3] + v36[2], *((float *)v36 + 5));
            if ((_DWORD)v27)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v28 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
              {
                v69 = (char *)this + 3592;
                if (*((char *)this + 3615) < 0)
                  v69 = *v74;
                v70 = *v36;
                v71 = v12->scope;
                v72 = *(v36 - 1);
                *(_DWORD *)buf = 136316418;
                v91 = v69;
                v92 = 2080;
                v93 = "ScheduleParameter";
                v94 = 1024;
                v95 = v9;
                v96 = 1024;
                v97 = v70;
                v98 = 1024;
                v99 = v71;
                v100 = 1024;
                v101 = v72;
                _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] Error scheduling unsupported parameter (ramped) #%u: param = %u, scope = %u, element = %u", buf, 0x2Eu);
              }
              goto LABEL_45;
            }
            break;
          case 3u:
            v29 = &a2[v9];
            v31 = v29->parameter;
            v30 = &v29->parameter;
            v27 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, v31, v12->scope, *(v30 - 1), v30[3] + v30[2], *((float *)v30 + 5));
            if ((_DWORD)v27)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v28 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
              {
                v57 = (char *)this + 3592;
                if (*((char *)this + 3615) < 0)
                  v57 = *v74;
                v58 = *v30;
                v59 = v12->scope;
                v60 = *(v30 - 1);
                *(_DWORD *)buf = 136316418;
                v91 = v57;
                v92 = 2080;
                v93 = "ScheduleParameter";
                v94 = 1024;
                v95 = v9;
                v96 = 1024;
                v97 = v58;
                v98 = 1024;
                v99 = v59;
                v100 = 1024;
                v101 = v60;
                _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] Error scheduling unsupported parameter (control value) #%u: param = %u, scope = %u, element = %u", buf, 0x2Eu);
              }
              goto LABEL_45;
            }
            break;
          case 4u:
            v32 = &a2[v9];
            v34 = v32->parameter;
            v33 = &v32->parameter;
            v27 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)this + 152))(this, v34, v12->scope, *(v33 - 1), v33[3] + v33[2], *((float *)v33 + 5));
            if ((_DWORD)v27)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v28 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
              {
                v61 = (char *)this + 3592;
                if (*((char *)this + 3615) < 0)
                  v61 = *v74;
                v62 = *v33;
                v63 = v12->scope;
                v64 = *(v33 - 1);
                *(_DWORD *)buf = 136316418;
                v91 = v61;
                v92 = 2080;
                v93 = "ScheduleParameter";
                v94 = 1024;
                v95 = v9;
                v96 = 1024;
                v97 = v62;
                v98 = 1024;
                v99 = v63;
                v100 = 1024;
                v101 = v64;
                _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] Error scheduling unsupported parameter (ramped with start value unknown) #%u: param = %u, scope = %u, element = %u", buf, 0x2Eu);
              }
LABEL_45:

              v10 = v27;
            }
            break;
          default:
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v38 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
            {
              v55 = (char *)this + 3592;
              if (*((char *)this + 3615) < 0)
                v55 = *v74;
              v56 = *p_eventType;
              *(_DWORD *)buf = 136315650;
              v91 = v55;
              v92 = 2080;
              v93 = "ScheduleParameter";
              v94 = 1024;
              v95 = v56;
              _os_log_error_impl(&dword_1B5ED0000, v38, OS_LOG_TYPE_ERROR, "[%s|%s] Unknown event type: %u", buf, 0x1Cu);
            }

            v10 = 4294900553;
            break;
        }
        goto LABEL_65;
      }
      v14 = &v11->parameter;
      v15 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, uint8_t *))(*(_QWORD *)this + 256))(this, v11->scope, v11->parameter, buf);
      if (v15)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v16 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          v51 = (char *)this + 3592;
          if (*((char *)this + 3615) < 0)
            v51 = *v74;
          v52 = *v14;
          v53 = v11->scope;
          element = a2[v9].element;
          *(_DWORD *)v78 = 136316418;
          v79 = v51;
          v80 = 2080;
          v81 = "ParameterCanRamp";
          v82 = 1024;
          v83 = v15;
          v84 = 1024;
          v85 = v52;
          v86 = 1024;
          v87 = v53;
          v88 = 1024;
          v89 = element;
          _os_log_error_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_ERROR, "[%s|%s] Error %d while fetching the parameter info canRamp: param = %u, scope = %u, element = %u", v78, 0x2Eu);
        }

      }
      else if ((v102 & 0x2000000) != 0)
      {
        goto LABEL_23;
      }
      if (v11->scope != 1)
        goto LABEL_25;
      if (*v14 > 0x22 || ((1 << *v14) & 0x67E00000FLL) == 0)
        goto LABEL_25;
LABEL_23:
      v18 = (_OWORD *)*((_QWORD *)this + 49);
      v19 = *((_QWORD *)this + 50);
      if ((unint64_t)v18 >= v19)
      {
        v39 = *((_QWORD *)this + 48);
        v40 = ((uint64_t)v18 - v39) >> 5;
        v41 = v40 + 1;
        if ((unint64_t)(v40 + 1) >> 59)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v42 = v19 - v39;
        if (v42 >> 4 > v41)
          v41 = v42 >> 4;
        if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFE0)
          v43 = 0x7FFFFFFFFFFFFFFLL;
        else
          v43 = v41;
        if (v43)
          v43 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v43);
        else
          v44 = 0;
        v45 = (_OWORD *)(v43 + 32 * v40);
        eventValues = v12->eventValues;
        *v45 = *(_OWORD *)&v12->scope;
        v45[1] = eventValues;
        v48 = (char *)*((_QWORD *)this + 48);
        v47 = (char *)*((_QWORD *)this + 49);
        v49 = v45;
        if (v47 != v48)
        {
          do
          {
            v50 = *((_OWORD *)v47 - 1);
            *(v49 - 2) = *((_OWORD *)v47 - 2);
            *(v49 - 1) = v50;
            v49 -= 2;
            v47 -= 32;
          }
          while (v47 != v48);
          v47 = (char *)*((_QWORD *)this + 48);
        }
        v21 = v45 + 2;
        *((_QWORD *)this + 48) = v49;
        *((_QWORD *)this + 49) = v45 + 2;
        *((_QWORD *)this + 50) = v43 + 32 * v44;
        if (v47)
          operator delete(v47);
      }
      else
      {
        v20 = v11->eventValues;
        *v18 = *(_OWORD *)&v11->scope;
        v18[1] = v20;
        v21 = v18 + 2;
      }
      *((_QWORD *)this + 49) = v21;
LABEL_65:
      if (++v9 == v75)
        goto LABEL_86;
    }
  }
  v10 = 0;
LABEL_86:
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v76);
  return v10;
}

void sub_1B61904F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::ProcessMultipleBufferLists(AUSpatialMixerV2 *this, unsigned int *a2, uint64_t a3, uint64_t a4, AudioBufferList **a5, uint64_t a6, AudioBufferList **a7)
{
  unsigned __int8 v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v18;
  _QWORD *v19;
  unsigned int v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  double v25;
  uint64_t Element;
  AudioBufferList *v27;
  int v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  unsigned __int8 v32;
  int v33;
  int v34;
  _QWORD *v35;
  const char *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  char *v42;
  char v43;
  AudioBufferList *v44;
  uint8_t buf[4];
  _QWORD *v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  __int16 v51;
  double v52;
  __int16 v53;
  double v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v42 = (char *)this + 3304;
  v43 = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 3304);
  if ((v43 & 1) == 0)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v15 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v37 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v37 = (_QWORD *)*v37;
      *(_DWORD *)buf = 136315394;
      v46 = v37;
      v47 = 2080;
      v48 = "ProcessMultipleBufferLists";
      _os_log_error_impl(&dword_1B5ED0000, v15, OS_LOG_TYPE_ERROR, "[%s|%s] Trying to render while initialization or clean-up is in process", buf, 0x16u);
    }
    goto LABEL_11;
  }
  if (!*((_BYTE *)this + 17) || (v14 = atomic_load((unsigned __int8 *)this + 7441), (v14 & 1) == 0))
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v15 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v38 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v38 = (_QWORD *)*v38;
      *(_DWORD *)buf = 136315394;
      v46 = v38;
      v47 = 2080;
      v48 = "ProcessMultipleBufferLists";
      _os_log_error_impl(&dword_1B5ED0000, v15, OS_LOG_TYPE_ERROR, "[%s|%s] Trying to render while uninitialized", buf, 0x16u);
    }
LABEL_11:

    v16 = 4294956429;
    goto LABEL_12;
  }
  if (*((_BYTE *)this + 540) && !*((_DWORD *)this + 134))
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v18 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v19 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v19 = (_QWORD *)*v19;
      *(_DWORD *)buf = 136315394;
      v46 = v19;
      v47 = 2080;
      v48 = "ProcessMultipleBufferLists";
      _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEFAULT, "[%s|%s] Switching from Render to ProcessMultiple without reinitializing", buf, 0x16u);
    }

  }
  *((_DWORD *)this + 134) = 1;
  *((_BYTE *)this + 540) = 1;
  v20 = 0;
  v21 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 80);
  while (1)
  {
    v22 = *((_QWORD *)this + 15);
    if (v22)
      LODWORD(v23) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
    else
      v23 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (v23 >= a4)
      v24 = a4;
    else
      v24 = v23;
    if (v20 >= v24)
    {
      Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
      v27 = (AudioBufferList *)AUSM::ABLBuffer::setupBufferList((AUSpatialMixerV2 *)((char *)this + 2968), *(_DWORD *)(Element + 108), 0, a3, 4);
      v44 = v27;
      v28 = AUSpatialMixerV2::ProcessMultipleBufferListsSlicingPrivate(this, a2, a3, a4, a5, a6, &v44, (const AudioBufferList **)this + 34);
      if (v28)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v29 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          v40 = (_QWORD *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v40 = (_QWORD *)*v40;
          *(_DWORD *)buf = 136315650;
          v46 = v40;
          v47 = 2080;
          v48 = "ProcessMultipleBufferLists";
          v49 = 1024;
          v50 = v28;
          _os_log_debug_impl(&dword_1B5ED0000, v29, OS_LOG_TYPE_DEBUG, "[%s|%s] ProcessMultipleBufferListsSlicingPrivate ERROR: result = %d", buf, 0x1Cu);
        }

      }
      ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
      v16 = AudioConverterConvertComplexBuffer(*((AudioConverterRef *)this + 393), a3, v27, *a7);
      if ((_DWORD)v16)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v30 = (id)getAUSMV2Log(void)::gLog;
        if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          goto LABEL_41;
        v41 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v41 = (_QWORD *)*v41;
        *(_DWORD *)buf = 136315650;
        v46 = v41;
        v47 = 2080;
        v48 = "ProcessMultipleBufferLists";
        v49 = 1024;
        v50 = v16;
        v36 = "[%s|%s] ConvertOutputData ERROR: result = %d";
      }
      else
      {
        if (!*((_QWORD *)this + 411))
          goto LABEL_12;
        v32 = atomic_load((unsigned __int8 *)this + 3668);
        v33 = (v32 & 1) != 0
            ? MEMORY[0x1E0CFF680](*((_QWORD *)this + 411), a3, *a7)
            : MEMORY[0x1E0CFF688](*((_QWORD *)this + 411), a3, *a7);
        v34 = v33;
        if (!v33)
          goto LABEL_12;
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v30 = (id)getAUSMV2Log(void)::gLog;
        if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
LABEL_41:

          goto LABEL_12;
        }
        v35 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v35 = (_QWORD *)*v35;
        *(_DWORD *)buf = 136315650;
        v46 = v35;
        v47 = 2080;
        v48 = "ProcessMultipleBufferLists";
        v49 = 1024;
        v50 = v34;
        v36 = "[%s|%s] ERROR: writing data to output file, %d";
      }
      _os_log_debug_impl(&dword_1B5ED0000, v30, OS_LOG_TYPE_DEBUG, v36, buf, 0x1Cu);
      goto LABEL_41;
    }
    v25 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v20) + 80);
    if (vabdd_f64(v21, v25) > 0.01)
      break;
    ++v20;
  }
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::unlock((uint64_t)&v42);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v31 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    v39 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v39 = (_QWORD *)*v39;
    *(_DWORD *)buf = 136316162;
    v46 = v39;
    v47 = 2080;
    v48 = "ProcessMultipleBufferLists";
    v49 = 1024;
    v50 = v20;
    v51 = 2048;
    v52 = v25;
    v53 = 2048;
    v54 = v21;
    _os_log_error_impl(&dword_1B5ED0000, v31, OS_LOG_TYPE_ERROR, "[%s|%s] Cannot render with ProcessMultiple since the samplerate of the input element %u is %f whereas the output samplerate is %f", buf, 0x30u);
  }

  v16 = 4294967246;
LABEL_12:
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v42);
  return v16;
}

void sub_1B6190C18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::Render(AUSpatialMixerV2 *this, unsigned int *a2, const AudioBufferList **a3, uint64_t a4)
{
  unsigned __int8 v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v12;
  _QWORD *v13;
  uint64_t Element;
  AudioBufferList *BufferList;
  const AudioBufferList *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  NSObject *v21;
  unsigned __int8 v22;
  int v23;
  int v24;
  _QWORD *v25;
  const char *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  char *v31;
  char v32;
  uint8_t buf[4];
  _QWORD *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  AudioBufferList *v39[2];

  v39[1] = *(AudioBufferList **)MEMORY[0x1E0C80C00];
  v31 = (char *)this + 3304;
  v32 = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 3304);
  if ((v32 & 1) == 0)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v9 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v27 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v27 = (_QWORD *)*v27;
      *(_DWORD *)buf = 136315394;
      v34 = v27;
      v35 = 2080;
      v36 = "Render";
      _os_log_error_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_ERROR, "[%s|%s] Trying to render while initialization or clean-up is in process", buf, 0x16u);
    }
    goto LABEL_11;
  }
  if (!*((_BYTE *)this + 17) || (v8 = atomic_load((unsigned __int8 *)this + 7441), (v8 & 1) == 0))
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v9 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v28 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v28 = (_QWORD *)*v28;
      *(_DWORD *)buf = 136315394;
      v34 = v28;
      v35 = 2080;
      v36 = "Render";
      _os_log_error_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_ERROR, "[%s|%s] Trying to render while uninitialized", buf, 0x16u);
    }
LABEL_11:

    v10 = 4294956429;
    goto LABEL_12;
  }
  if (*((_BYTE *)this + 540) && *((_DWORD *)this + 134) == 1)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v12 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v13 = (_QWORD *)*v13;
      *(_DWORD *)buf = 136315394;
      v34 = v13;
      v35 = 2080;
      v36 = "Render";
      _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEFAULT, "[%s|%s] Switching from ProcessMultiple to Render without reinitializing", buf, 0x16u);
    }

  }
  *((_DWORD *)this + 134) = 0;
  *((_BYTE *)this + 540) = 1;
  Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
  BufferList = (AudioBufferList *)ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
  v16 = (const AudioBufferList *)AUSM::ABLBuffer::setupBufferList((AUSpatialMixerV2 *)((char *)this + 2968), *(_DWORD *)(Element + 108), 0, a4, 4);
  v39[0] = (AudioBufferList *)v16;
  v17 = *((_QWORD *)this + 15);
  if (v17)
    v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  else
    v18 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  v19 = AUSpatialMixerV2::ProcessMultipleBufferListsSlicingPrivate(this, a2, a4, v18, 0, 1, v39, a3);
  if (v19)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v20 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v29 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v29 = (_QWORD *)*v29;
      *(_DWORD *)buf = 136315650;
      v34 = v29;
      v35 = 2080;
      v36 = "Render";
      v37 = 1024;
      v38 = v19;
      _os_log_error_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_ERROR, "[%s|%s] PMBLSP return an error %d", buf, 0x1Cu);
    }

  }
  v10 = AudioConverterConvertComplexBuffer(*((AudioConverterRef *)this + 393), a4, v16, BufferList);
  if ((_DWORD)v10)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v21 = (id)getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      goto LABEL_34;
    v30 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v30 = (_QWORD *)*v30;
    *(_DWORD *)buf = 136315650;
    v34 = v30;
    v35 = 2080;
    v36 = "Render";
    v37 = 1024;
    v38 = v10;
    v26 = "[%s|%s] ConvertOutputData ERROR: result = %d";
LABEL_58:
    _os_log_debug_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_DEBUG, v26, buf, 0x1Cu);
LABEL_34:

    goto LABEL_12;
  }
  if (*((_QWORD *)this + 411))
  {
    v22 = atomic_load((unsigned __int8 *)this + 3668);
    v23 = (v22 & 1) != 0
        ? MEMORY[0x1E0CFF680](*((_QWORD *)this + 411), a4, BufferList)
        : MEMORY[0x1E0CFF688](*((_QWORD *)this + 411), a4, BufferList);
    v24 = v23;
    if (v23)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v21 = (id)getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        goto LABEL_34;
      v25 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v25 = (_QWORD *)*v25;
      *(_DWORD *)buf = 136315650;
      v34 = v25;
      v35 = 2080;
      v36 = "Render";
      v37 = 1024;
      v38 = v24;
      v26 = "[%s|%s] ERROR: writing data to output file, %d";
      goto LABEL_58;
    }
  }
LABEL_12:
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v31);
  return v10;
}

void sub_1B61911EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL AUSpatialMixerV2::BusCountWritable(AUSpatialMixerV2 *this, int a2)
{
  return a2 == 1;
}

uint64_t AUSpatialMixerV2::SetBusCount(AUSpatialMixerV2 *this, unsigned int a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v8;
  NSObject *v10;
  _BOOL4 v11;
  _QWORD *v12;
  _QWORD *v13;
  unsigned __int8 v14;
  unsigned int v15;
  uint64_t Element;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  unsigned __int8 v21;
  AUSpatialMixerV2InputElement *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD v25[2];
  _BYTE buf[12];
  __int16 v27;
  const char *v28;
  __int16 v29;
  unsigned int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a2 == 1)
  {
    v5 = *((_QWORD *)this + 15);
    if (v5)
      LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    else
      v6 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v10 = (id)getAUSMV2Log(void)::gLog;
    v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v6 == a3)
    {
      if (v11)
      {
        v12 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v12 = (_QWORD *)*v12;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v12;
        v27 = 2080;
        v28 = "SetBusCount";
        v29 = 1024;
        v30 = a3;
        _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting input bus count = %u (not changed)", buf, 0x1Cu);
      }

    }
    else
    {
      if (v11)
      {
        v13 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v13 = (_QWORD *)*v13;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v13;
        v27 = 2080;
        v28 = "SetBusCount";
        v29 = 1024;
        v30 = a3;
        _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting input bus count = %u", buf, 0x1Cu);
      }

      v14 = atomic_load((unsigned __int8 *)this + 7441);
      if ((v14 & 1) == 0 && v6 > a3)
      {
        v15 = a3;
        do
        {
          Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v15);
          *(_DWORD *)(Element + 172) = 0;
          v17 = *(_QWORD **)(Element + 152);
          if (v17)
          {
            ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v17);
            *(_QWORD *)(Element + 152) = 0;
          }
          *(_QWORD *)(Element + 160) = 0;
          *(_DWORD *)(Element + 144) = 0;
          ++v15;
        }
        while ((_DWORD)v6 != v15);
      }
      v25[0] = (char *)this + 3352;
      v25[1] = (char *)this + 3304;
      while (1)
      {
        *(_QWORD *)buf = (char *)this + 3352;
        buf[8] = 1;
        std::__shared_mutex_base::lock((std::__shared_mutex_base *)((char *)this + 3352));
        if ((caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 3304) & 1) != 0)
        {
          *(_QWORD *)buf = 0;
          buf[8] = 0;
          std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)buf);
          goto LABEL_33;
        }
        std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)buf);
        sched_yield();
        *(_QWORD *)buf = (char *)this + 3304;
        buf[8] = 1;
        caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3304);
        if (std::__shared_mutex_base::try_lock((std::__shared_mutex_base *)((char *)this + 3352)))
          break;
        std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)buf);
        sched_yield();
      }
      *(_QWORD *)buf = 0;
      buf[8] = 0;
      std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)buf);
LABEL_33:
      ausdk::AUScope::SetNumberOfElements((int64x2_t *)this + 5, a3);
      v18 = *((_QWORD *)this + 15);
      if (v18)
        LODWORD(v19) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
      else
        v19 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
      if ((_DWORD)v19 != *((_DWORD *)this + 638))
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v20 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          v24 = (_QWORD *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v24 = (_QWORD *)*v24;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v24;
          v27 = 2080;
          v28 = "SetBusCount";
          v29 = 1024;
          v30 = v19;
          _os_log_debug_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_DEBUG, "[%s|%s] Setting late reverb bus count = %u", buf, 0x1Cu);
        }

        IR::SharedIRBuses::setNumInputChannels((uint64_t)this + 2328, 3 * v19);
      }
      if (v19 > v6)
      {
        v21 = atomic_load((unsigned __int8 *)this + 7441);
        if ((v21 & 1) != 0)
        {
          do
          {
            v22 = (AUSpatialMixerV2InputElement *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v6);
            (*(void (**)(AUSpatialMixerV2InputElement *))(*(_QWORD *)v22 + 112))(v22);
            AUSpatialMixerV2InputElement::UpdateAlignmentDelayLines(v22);
            LODWORD(v6) = v6 + 1;
          }
          while ((_DWORD)v19 != (_DWORD)v6);
        }
      }
      AUSM::TuningManager::ResizeBuffers((AUSpatialMixerV2 *)((char *)this + 6160), v19);
      std::scoped_lock<std::shared_mutex,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100]((uint64_t)v25);
      AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, 0, 0);
    }
    return 0;
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v8 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v23 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v23 = (_QWORD *)*v23;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v23;
      v27 = 2080;
      v28 = "SetBusCount";
      v29 = 1024;
      v30 = a2;
      _os_log_error_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_ERROR, "[%s|%s] cannot change bus count for scope = %u", buf, 0x1Cu);
    }

    return 4294956430;
  }
}

void sub_1B61916F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::scoped_lock<std::shared_mutex,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::SetConnection(const void **this, const AudioUnitConnection *a2)
{
  uint64_t Element;

  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(this + 10), a2->destInputNumber);
  (*(void (**)(uint64_t))(*(_QWORD *)Element + 120))(Element);
  return ausdk::AUBase::SetConnection(this, a2);
}

uint64_t AUSpatialMixerV2::SetInputCallback(AUSpatialMixerV2 *this, uint64_t a2, uint64_t a3, int (*a4)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a5)
{
  ausdk::AUScope *v10;
  uint64_t Element;
  ausdk::AUInputElement *v12;

  v10 = (AUSpatialMixerV2 *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a3);
  (*(void (**)(uint64_t))(*(_QWORD *)Element + 120))(Element);
  v12 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v10, a3);
  ausdk::AUInputElement::SetInputCallback(v12, a4, a5);
  (*(void (**)(AUSpatialMixerV2 *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 432))(this, a2, 1, a3);
  return 0;
}

uint64_t AUSpatialMixerV2::GetParameterInfo(AUSpatialMixerV2 *this, int a2, int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  const __CFString *v7;
  uint64_t v8;
  const __CFString *v9;
  uint64_t *v10;
  const __CFString *v11;
  float v12;
  uint64_t Element;
  double v14;
  double v15;
  BOOL v16;
  double v17;
  AudioUnitParameterValue v18;
  AudioUnitParameterOptions v19;
  AudioUnitParameterValue v20;
  uint64_t v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  AudioUnitParameterOptions v26;
  const __CFString *v27;
  const __CFString *v28;
  AudioUnitParameterValue v29;
  const __CFString *v30;
  const __CFString *v31;
  AudioUnitParameterOptions v32;
  const __CFString *v33;
  const __CFString *v34;
  const __CFString *v35;
  const __CFString *v36;
  const __CFString *v37;
  const __CFString *v38;

  buffer->flags = -1073741824;
  switch(a2)
  {
    case 2:
      if (a3 == 3)
      {
LABEL_7:
        v9 = (const __CFString *)kGainParameterName;
        buffer->cfNameString = (CFStringRef)kGainParameterName;
        buffer->flags = -939524096;
        CFStringGetCString(v9, buffer->name, 52, 0x8000100u);
        result = 0;
        buffer->unit = kAudioUnitParameterUnit_Decibels;
        v8 = 0x41A00000C2F00000;
LABEL_58:
        *(_QWORD *)&buffer->minValue = v8;
        v26 = buffer->flags | 0x2000000;
LABEL_59:
        buffer->defaultValue = 0.0;
        buffer->flags = v26;
      }
      else
      {
        return 4294956418;
      }
      break;
    case 1:
      result = 4294956418;
      switch(a3)
      {
        case 0:
          v23 = (const __CFString *)kAzimuthParameterName;
          goto LABEL_47;
        case 1:
          v24 = (const __CFString *)kElevationParameterName;
          goto LABEL_45;
        case 2:
          v27 = (const __CFString *)kDistanceParameterName;
          buffer->cfNameString = (CFStringRef)kDistanceParameterName;
          buffer->flags = -939524096;
          CFStringGetCString(v27, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Meters;
          v8 = 0x461C400000000000;
          goto LABEL_58;
        case 3:
          goto LABEL_7;
        case 4:
          v28 = (const __CFString *)kPlaybackRateParameterName;
          buffer->cfNameString = (CFStringRef)kPlaybackRateParameterName;
          buffer->flags = -939524096;
          CFStringGetCString(v28, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Generic;
          *(_QWORD *)&buffer->minValue = 0x412000003DCCCCCDLL;
          v20 = 1.0;
          goto LABEL_39;
        case 5:
          v22 = (const __CFString *)kEnableParameterName;
LABEL_36:
          buffer->cfNameString = v22;
          buffer->flags = -939524096;
          CFStringGetCString(v22, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Boolean;
          *(_QWORD *)&buffer->minValue = 0x3F80000000000000;
          v29 = 1.0;
          goto LABEL_66;
        case 6:
          v30 = (const __CFString *)kMinGainParameterName;
          buffer->cfNameString = (CFStringRef)kMinGainParameterName;
          buffer->flags = -939524096;
          CFStringGetCString(v30, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_LinearGain;
          v8 = 0x4120000000000000;
          goto LABEL_58;
        case 7:
          v31 = (const __CFString *)kMaxGainParameterName;
          buffer->cfNameString = (CFStringRef)kMaxGainParameterName;
          buffer->flags = -939524096;
          CFStringGetCString(v31, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_LinearGain;
          *(_QWORD *)&buffer->minValue = 0x4120000000000000;
          v20 = 10.0;
LABEL_39:
          v32 = buffer->flags | 0x2000000;
          goto LABEL_61;
        case 8:
        case 35:
          v10 = &kReverbBlendParameterName;
          if (a3 != 8)
            v10 = &kPostProcReverbBlendParameterName;
          v11 = (const __CFString *)*v10;
          buffer->cfNameString = (CFStringRef)*v10;
          buffer->flags = -939524096;
          if (a3 == 8)
            v12 = 30.0;
          else
            v12 = 50.0;
          CFStringGetCString(v11, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Percent;
          *(_QWORD *)&buffer->minValue = 0x42C8000000000000;
          buffer->defaultValue = v12;
          buffer->flags |= 0x2000000u;
          return result;
        case 10:
          v33 = (const __CFString *)kOcclusionAttenuationParameterName;
          goto LABEL_42;
        case 11:
          v33 = (const __CFString *)kObstructionAttenuationParameterName;
LABEL_42:
          buffer->cfNameString = v33;
          buffer->flags = -939524096;
          CFStringGetCString(v33, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Decibels;
          v8 = 3267887104;
          goto LABEL_58;
        case 22:
          v23 = (const __CFString *)kSourceYawName;
          goto LABEL_47;
        case 23:
          v24 = (const __CFString *)kSourcePitchName;
LABEL_45:
          buffer->cfNameString = v24;
          buffer->flags = -939524096;
          CFStringGetCString(v24, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Degrees;
          v8 = 0x42B40000C2B40000;
          goto LABEL_58;
        case 24:
          v23 = (const __CFString *)kSourceRollName;
LABEL_47:
          buffer->cfNameString = v23;
          buffer->flags = -939524096;
          CFStringGetCString(v23, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Degrees;
          v8 = 0x43340000C3340000;
          goto LABEL_58;
        case 25:
          v34 = (const __CFString *)kSourceWidthParamName;
          goto LABEL_57;
        case 26:
          v34 = (const __CFString *)kSourceHeightParamName;
          goto LABEL_57;
        case 27:
          v34 = (const __CFString *)kSourceDepthParamName;
          goto LABEL_57;
        case 28:
          v34 = (const __CFString *)kSourceDivergenceParamName;
          goto LABEL_57;
        case 29:
          v35 = (const __CFString *)kSourceDivergenceAzimuthRangeParamName;
          buffer->cfNameString = (CFStringRef)kSourceDivergenceAzimuthRangeParamName;
          buffer->flags = -939524096;
          CFStringGetCString(v35, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Ratio;
          v8 = 0x4334000000000000;
          goto LABEL_58;
        case 30:
          v34 = (const __CFString *)kSourceDivergencePositionRangeParamName;
          goto LABEL_57;
        case 31:
          v36 = (const __CFString *)kHeadLockedParamName;
          goto LABEL_63;
        case 32:
          v36 = (const __CFString *)kSpeakerSnapParamName;
          goto LABEL_63;
        case 33:
          v34 = (const __CFString *)kDiffuseParamName;
LABEL_57:
          buffer->cfNameString = v34;
          buffer->flags = -939524096;
          CFStringGetCString(v34, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Ratio;
          v8 = 0x3F80000000000000;
          goto LABEL_58;
        case 34:
          v37 = (const __CFString *)kSceneScaleParamName;
          buffer->cfNameString = (CFStringRef)kSceneScaleParamName;
          buffer->flags = -939524096;
          CFStringGetCString(v37, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Meters;
          *(_QWORD *)&buffer->minValue = 0x461C400000000000;
          v20 = 1.0;
          v32 = buffer->flags | 0x800000;
LABEL_61:
          buffer->defaultValue = v20;
          buffer->flags = v32;
          return result;
        case 39:
          v36 = (const __CFString *)kInternalizedParamName;
LABEL_63:
          buffer->cfNameString = v36;
          buffer->flags = -939524096;
          CFStringGetCString(v36, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Boolean;
          v21 = 0x3F80000000000000;
LABEL_64:
          *(_QWORD *)&buffer->minValue = v21;
          buffer->defaultValue = 0.0;
          return result;
        case 40:
          v38 = (const __CFString *)kStereoPanningRefAngleParamName;
          buffer->cfNameString = (CFStringRef)kStereoPanningRefAngleParamName;
          buffer->flags = -939524096;
          CFStringGetCString(v38, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Degrees;
          *(_QWORD *)&buffer->minValue = 0x42B4000000000000;
          v29 = 45.0;
LABEL_66:
          buffer->defaultValue = v29;
          return result;
        default:
          return result;
      }
    case 0:
      result = 4294956418;
      switch(a3)
      {
        case 9:
          v7 = (const __CFString *)kReverbGainParameterName;
          buffer->cfNameString = (CFStringRef)kReverbGainParameterName;
          buffer->flags = -939524096;
          CFStringGetCString(v7, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Decibels;
          v8 = 0x42200000C2200000;
          goto LABEL_58;
        case 14:
          buffer->cfNameString = CFSTR("filter frequency");
          buffer->flags = -939524096;
          CFStringGetCString(CFSTR("filter frequency"), buffer->name, 52, 0x8000100u);
          *(_QWORD *)&buffer->unit = 0x4120000000000008;
          Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
          result = 0;
          v14 = *(double *)(Element + 80);
          v15 = v14 * 0.5;
          v16 = v14 < 20000.0;
          v17 = 10000.0;
          if (v16)
            v17 = v15;
          v18 = v17;
          buffer->maxValue = v18;
          v19 = buffer->flags | 0x2400000;
          buffer->defaultValue = 800.0;
          buffer->flags = v19;
          return result;
        case 15:
          buffer->cfNameString = CFSTR("filter bandwidth");
          buffer->flags = -939524096;
          CFStringGetCString(CFSTR("filter bandwidth"), buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Octaves;
          *(_QWORD *)&buffer->minValue = 0x408000003D4CCCCDLL;
          v20 = 3.0;
          goto LABEL_39;
        case 16:
          buffer->cfNameString = CFSTR("filter gain");
          buffer->flags = -939524096;
          CFStringGetCString(CFSTR("filter gain"), buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Decibels;
          v8 = 0x41900000C1900000;
          goto LABEL_58;
        case 17:
          buffer->cfNameString = CFSTR("filter type");
          buffer->flags = -939524096;
          CFStringGetCString(CFSTR("filter type"), buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Indexed;
          v21 = 0x4120000000000000;
          goto LABEL_64;
        case 18:
          v22 = CFSTR("filter enable");
          goto LABEL_36;
        case 19:
          v23 = (const __CFString *)kHeadOrientationYawName;
          goto LABEL_47;
        case 20:
          v24 = (const __CFString *)kHeadOrientationPitchName;
          goto LABEL_45;
        case 21:
          v23 = (const __CFString *)kHeadOrientationRollName;
          goto LABEL_47;
        case 36:
          v25 = (const __CFString *)kListenerPositionXName;
          goto LABEL_30;
        case 37:
          v25 = (const __CFString *)kListenerPositionYName;
          goto LABEL_30;
        case 38:
          v25 = (const __CFString *)kListenerPositionZName;
LABEL_30:
          buffer->cfNameString = v25;
          buffer->flags = -939524096;
          CFStringGetCString(v25, buffer->name, 52, 0x8000100u);
          result = 0;
          buffer->unit = kAudioUnitParameterUnit_Meters;
          *(_QWORD *)&buffer->minValue = 0x461C4000C61C4000;
          v26 = buffer->flags | 0x2800000;
          goto LABEL_59;
        default:
          return result;
      }
    default:
      return 0;
  }
  return result;
}

uint64_t AUSpatialMixerV2::SaveState(AUSpatialMixerV2 *this, ausdk **a2)
{
  NSObject *v3;
  _QWORD *v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Element;
  __int128 v9;
  std::string::size_type v10;
  AUSpatialMixerV2 *v11;
  _QWORD *v12;
  unsigned int v13;
  _QWORD **v14;
  _QWORD *v15;
  _QWORD **v16;
  unsigned int v17;
  _QWORD *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  CFDictionaryRef CFDictionaryRef;
  CFDictionaryRef v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  CFDictionaryRef *v35;
  unint64_t v36;
  _QWORD *v37;
  const __CFDictionary *v38;
  const void *v39;
  __int128 v40;
  const __CFURL *v41;
  uint64_t i;
  const void *v43;
  const void *v44;
  AUSpatialMixerV2 *v45;
  AUSpatialMixerV2 *v46;
  BOOL v47;
  CFArrayRef v48;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  unint64_t v61;
  NSObject *v62;
  char *v63;
  uint64_t v64;
  unsigned int v65;
  unsigned int v66;
  const void *v67;
  CFTypeRef v68;
  const void *v69;
  const void *v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const void *v74;
  CFDictionaryRef v75;
  CFDictionaryRef v76;
  CFURLRef v77;
  CFURLRef v78;
  int64_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  const __CFURL *v84;
  const __CFURL *v85;
  const __CFURL *v86;
  uint64_t v87;
  CFTypeRef v88;
  __int128 v89;
  const __CFURL *v90;
  uint64_t j;
  const void *v92;
  const void *v93;
  CFArrayRef v94;
  __CFDictionary *v95;
  CFNumberRef v96;
  CFNumberRef v97;
  char *v98;
  CFTypeID v99;
  CFArrayRef v100;
  unsigned int v101;
  uint64_t v102;
  uint64_t v103;
  unsigned int *v104;
  unsigned int *v105;
  const AudioChannelLayout *v106;
  unsigned int v107;
  _QWORD *v108;
  _QWORD *v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  CFURLRef *v115;
  unint64_t v116;
  CFURLRef *v117;
  const __CFURL *v118;
  CFURLRef v119;
  __int128 v120;
  unint64_t v121;
  CFArrayRef v122;
  unsigned int *v123;
  unsigned int *v124;
  const AudioChannelLayout *v125;
  unsigned int v126;
  CFArrayRef v127;
  const void *v128;
  CFURLRef v129;
  const __CFString *v130;
  uint64_t v131;
  const UInt8 *v132;
  CFIndex v133;
  const UInt8 *v134;
  CFIndex v135;
  const UInt8 *v136;
  CFIndex v137;
  CFStringRef v138;
  _BOOL4 v139;
  const __CFArray *v140;
  __CFDictionary *ValueAtIndex;
  std::string *p_buf;
  CFIndex size;
  const __CFURL *v144;
  std::runtime_error *v146;
  std::runtime_error *exception;
  std::runtime_error *v148;
  std::runtime_error *v149;
  __CFDictionary *v150;
  const __CFAllocator *allocator;
  unsigned int v152;
  _BYTE *v153;
  const __CFArray *v155;
  CFMutableDictionaryRef value;
  __int128 v157;
  unint64_t v158;
  _QWORD **v159;
  _QWORD *v160[2];
  char *v161;
  char v162;
  CFURLRef anURL[2];
  const __CFURL *v164;
  CFTypeRef v165;
  CFTypeRef cf;
  CFTypeRef v167;
  CFTypeRef v168;
  CFTypeRef v169;
  CFTypeRef v170;
  _QWORD valuePtr[2];
  CFTypeRef v172;
  CFTypeRef v173;
  std::string buf;
  unint64_t v175;
  _QWORD v176[2];
  _QWORD v177[2];
  _QWORD v178[2];
  _QWORD v179[2];
  _QWORD v180[2];
  _BYTE v181[24];
  const __CFURL *v182;
  const __CFURL **v183;
  uint64_t v184;

  v184 = *MEMORY[0x1E0C80C00];
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v3 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v4 = (_QWORD *)*v4;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v4;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"SaveState";
    _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEFAULT, "[%s|%s] ", (uint8_t *)&buf, 0x16u);
  }

  v161 = (char *)this + 3352;
  v162 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
  ausdk::AUBase::SaveState(this, a2);
  v5 = 0;
  v153 = (char *)this + 6128;
  v160[0] = 0;
  v160[1] = 0;
  v159 = v160;
  while (1)
  {
    v6 = *((_QWORD *)this + 15);
    if (v6)
      LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
    else
      v7 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (v5 >= v7)
      break;
    Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v5);
    AUSpatialMixerV2InputElement::GetChannelParameters((AUSpatialMixerV2InputElement *)&buf, Element);
    v9 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    v10 = buf.__r_.__value_.__r.__words[0];
    if (buf.__r_.__value_.__r.__words[0] != buf.__r_.__value_.__l.__size_)
    {
      do
      {
        std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t *)&v159, *(_DWORD *)(v10 + 28), *(_DWORD *)(v10 + 28));
        v10 += 32;
      }
      while (v10 != *((_QWORD *)&v9 + 1));
    }
    if ((_QWORD)v9)
      operator delete((void *)v9);
    ++v5;
  }
  v157 = 0uLL;
  v158 = 0;
  v11 = (AUSpatialMixerV2 *)*((_QWORD *)this + 408);
  if (v11 != (AUSpatialMixerV2 *)((char *)this + 3272))
  {
    do
    {
      v12 = v160[0];
      if (v160[0])
      {
        v13 = *((_DWORD *)v11 + 15);
        v14 = v160;
        do
        {
          v15 = v12;
          v16 = v14;
          v17 = *((_DWORD *)v12 + 7);
          v18 = v12 + 1;
          if (v17 >= v13)
          {
            v18 = v15;
            v14 = (_QWORD **)v15;
          }
          v12 = (_QWORD *)*v18;
        }
        while (v12);
        if (v14 != v160)
        {
          if (v17 < v13)
            v15 = v16;
          if (v13 >= *((_DWORD *)v15 + 7))
          {
            v19 = (const void *)kPresetKeyChannelLabel;
            if (kPresetKeyChannelLabel)
              CFRetain((CFTypeRef)kPresetKeyChannelLabel);
            applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v172, v19);
            applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,unsigned int &>(&buf, v172, (int *)v11 + 15);
            v20 = (const void *)kPresetKeyAzimuth;
            if (kPresetKeyAzimuth)
              CFRetain((CFTypeRef)kPresetKeyAzimuth);
            applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v170, v20);
            applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(&buf.__r_.__value_.__r.__words[2], v170, (int *)v11 + 8);
            v21 = (const void *)kPresetKeyElevation;
            if (kPresetKeyElevation)
              CFRetain((CFTypeRef)kPresetKeyElevation);
            applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v173, v21);
            applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v176, v173, (int *)v11 + 9);
            v22 = (const void *)kPresetKeyDistance;
            if (kPresetKeyDistance)
              CFRetain((CFTypeRef)kPresetKeyDistance);
            applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v169, v22);
            applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v177, v169, (int *)v11 + 10);
            v23 = (const void *)kPresetKeyGain;
            if (kPresetKeyGain)
              CFRetain((CFTypeRef)kPresetKeyGain);
            applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v168, v23);
            applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v178, v168, (int *)v11 + 11);
            v24 = (const void *)kPresetKeyDRRAdjustment;
            if (kPresetKeyDRRAdjustment)
              CFRetain((CFTypeRef)kPresetKeyDRRAdjustment);
            applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v167, v24);
            applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v179, v167, (int *)v11 + 12);
            v25 = (const void *)kPresetKeyDelay;
            if (kPresetKeyDelay)
              CFRetain((CFTypeRef)kPresetKeyDelay);
            applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v25);
            applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v180, cf, (int *)v11 + 13);
            anURL[0] = (CFURLRef)&buf;
            anURL[1] = (CFURLRef)7;
            CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)anURL);
            v27 = CFDictionaryRef;
            valuePtr[0] = CFDictionaryRef;
            v28 = (_QWORD *)*((_QWORD *)&v157 + 1);
            if (*((_QWORD *)&v157 + 1) >= v158)
            {
              v29 = (_QWORD *)v157;
              v30 = (uint64_t)(*((_QWORD *)&v157 + 1) - v157) >> 3;
              v31 = v30 + 1;
              if ((unint64_t)(v30 + 1) >> 61)
                std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
              v32 = v158 - v157;
              if ((uint64_t)(v158 - v157) >> 2 > v31)
                v31 = v32 >> 2;
              if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8)
                v33 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v33 = v31;
              v183 = (const __CFURL **)&v158;
              if (v33)
              {
                v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v33);
                v28 = (_QWORD *)*((_QWORD *)&v157 + 1);
                v29 = (_QWORD *)v157;
              }
              else
              {
                v34 = 0;
              }
              v35 = (CFDictionaryRef *)(v33 + 8 * v30);
              v36 = v33 + 8 * v34;
              v182 = (const __CFURL *)v36;
              *v35 = v27;
              v37 = v35 + 1;
              valuePtr[0] = 0;
              *(_QWORD *)&v181[16] = v35 + 1;
              if (v28 == v29)
              {
                v39 = 0;
              }
              else
              {
                do
                {
                  v38 = (const __CFDictionary *)*--v28;
                  *--v35 = v38;
                  *v28 = 0;
                }
                while (v28 != v29);
                v37 = *(_QWORD **)&v181[16];
                v36 = (unint64_t)v182;
                v39 = (const void *)valuePtr[0];
              }
              v40 = v157;
              *(_QWORD *)&v157 = v35;
              *(_OWORD *)&v181[8] = v40;
              v41 = (const __CFURL *)v158;
              v158 = v36;
              v182 = v41;
              *(_QWORD *)v181 = v40;
              std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer((uint64_t)v181);
              *((_QWORD *)&v157 + 1) = v37;
              if (v39)
                CFRelease(v39);
            }
            else
            {
              **((_QWORD **)&v157 + 1) = CFDictionaryRef;
              valuePtr[0] = 0;
              *((_QWORD *)&v157 + 1) = v28 + 1;
            }
            for (i = 0; i != -14; i -= 2)
            {
              v43 = (const void *)v180[i + 1];
              if (v43)
                CFRelease(v43);
              v44 = (const void *)v180[i];
              if (v44)
                CFRelease(v44);
            }
            if (cf)
              CFRelease(cf);
            if (v167)
              CFRelease(v167);
            if (v168)
              CFRelease(v168);
            if (v169)
              CFRelease(v169);
            if (v173)
              CFRelease(v173);
            if (v170)
              CFRelease(v170);
            if (v172)
              CFRelease(v172);
          }
        }
      }
      v45 = (AUSpatialMixerV2 *)*((_QWORD *)v11 + 1);
      if (v45)
      {
        do
        {
          v46 = v45;
          v45 = *(AUSpatialMixerV2 **)v45;
        }
        while (v45);
      }
      else
      {
        do
        {
          v46 = (AUSpatialMixerV2 *)*((_QWORD *)v11 + 2);
          v47 = *(_QWORD *)v46 == (_QWORD)v11;
          v11 = v46;
        }
        while (!v47);
      }
      v11 = v46;
    }
    while (v46 != (AUSpatialMixerV2 *)((char *)this + 3272));
  }
  v48 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)&v157);
  value = 0;
  v155 = v48;
  if (!*v153 && *((_BYTE *)this + 6528))
  {
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 6336);
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v50 = Mutable;
    v51 = *((_QWORD *)this + 814);
    v52 = *((_QWORD *)this + 813);
    if (v51 != v52)
    {
      v53 = 0;
      v54 = 0;
      v150 = Mutable;
      do
      {
        anURL[0] = 0;
        anURL[1] = 0;
        v164 = 0;
        if (v51 == v52)
        {
LABEL_92:
          v57 = *(_DWORD *)(v52 + 176 * v53 + 24);
        }
        else
        {
          v55 = 0;
          v56 = 0;
          while (*(_DWORD *)(v52 + 176 * v55 + 24) != 4)
          {
            v55 = ++v56;
            if (0x2E8BA2E8BA2E8BA3 * ((v51 - v52) >> 4) <= (unint64_t)v56)
              goto LABEL_92;
          }
          v57 = *(_DWORD *)(v52 + 176 * v53 + 24);
          if (v57 == v56)
            goto LABEL_168;
        }
        v58 = v51 - v52;
        if (v51 == v52)
        {
LABEL_97:
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v62 = getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
          {
            v63 = (char *)this + 6536;
            if (*((char *)this + 6559) < 0)
              v63 = (char *)*((_QWORD *)this + 817);
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v63;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"getSoundStageDictionaryVec";
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
            LODWORD(v175) = v57;
            _os_log_error_impl(&dword_1B5ED0000, v62, OS_LOG_TYPE_ERROR, "[%s|%s] Failed to find valid index for SoundStage with enum = %d", (uint8_t *)&buf, 0x1Cu);
          }
        }
        else
        {
          v59 = 0;
          v60 = 0;
          v61 = 0x2E8BA2E8BA2E8BA3 * (v58 >> 4);
          while (*(_DWORD *)(v52 + 176 * v59 + 24) != v57)
          {
            v59 = ++v60;
            if (v61 <= v60)
              goto LABEL_97;
          }
          v152 = v54;
          if (*(_QWORD *)(v52 + 176 * v60 + 40) != *(_QWORD *)(v52 + 176 * v60 + 32))
          {
            v64 = 0;
            v65 = 0;
            v66 = v60;
            do
            {
              v67 = (const void *)kPresetKeyChannelLabel;
              if (kPresetKeyChannelLabel)
              {
                CFRetain((CFTypeRef)kPresetKeyChannelLabel);
                applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v170, v67);
                v52 = *((_QWORD *)this + 813);
                v68 = v170;
              }
              else
              {
                v68 = 0;
                v170 = 0;
              }
              applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,unsigned int &>(&buf, v68, (int *)(*(_QWORD *)(v52 + 176 * v66 + 32) + 32 * v64 + 28));
              v69 = (const void *)kPresetKeyAzimuth;
              if (kPresetKeyAzimuth)
                CFRetain((CFTypeRef)kPresetKeyAzimuth);
              applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v173, v69);
              applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(&buf.__r_.__value_.__r.__words[2], v173, (int *)(*(_QWORD *)(*((_QWORD *)this + 813) + 176 * v66 + 32) + 32 * v64));
              v70 = (const void *)kPresetKeyElevation;
              if (kPresetKeyElevation)
                CFRetain((CFTypeRef)kPresetKeyElevation);
              applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v169, v70);
              applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v176, v169, (int *)(*(_QWORD *)(*((_QWORD *)this + 813) + 176 * v66 + 32) + 32 * v64 + 4));
              v71 = (const void *)kPresetKeyDistance;
              if (kPresetKeyDistance)
                CFRetain((CFTypeRef)kPresetKeyDistance);
              applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v168, v71);
              applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v177, v168, (int *)(*(_QWORD *)(*((_QWORD *)this + 813) + 176 * v66 + 32) + 32 * v64 + 8));
              v72 = (const void *)kPresetKeyGain;
              if (kPresetKeyGain)
                CFRetain((CFTypeRef)kPresetKeyGain);
              applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v167, v72);
              applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v178, v167, (int *)(*(_QWORD *)(*((_QWORD *)this + 813) + 176 * v66 + 32) + 32 * v64 + 12));
              v73 = (const void *)kPresetKeyDRRAdjustment;
              if (kPresetKeyDRRAdjustment)
                CFRetain((CFTypeRef)kPresetKeyDRRAdjustment);
              applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v73);
              applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v179, cf, (int *)(*(_QWORD *)(*((_QWORD *)this + 813) + 176 * v66 + 32) + 32 * v64 + 16));
              v74 = (const void *)kPresetKeyDelay;
              if (kPresetKeyDelay)
                CFRetain((CFTypeRef)kPresetKeyDelay);
              applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v165, v74);
              applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(v180, v165, (int *)(*(_QWORD *)(*((_QWORD *)this + 813) + 176 * v66 + 32) + 32 * v64 + 20));
              valuePtr[0] = &buf;
              valuePtr[1] = 7;
              v75 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)valuePtr);
              v76 = v75;
              v172 = v75;
              v77 = anURL[1];
              if (anURL[1] >= v164)
              {
                v78 = anURL[0];
                v79 = (anURL[1] - anURL[0]) >> 3;
                v80 = v79 + 1;
                if ((unint64_t)(v79 + 1) >> 61)
                  std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
                v81 = v164 - anURL[0];
                if ((v164 - anURL[0]) >> 2 > v80)
                  v80 = v81 >> 2;
                if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF8)
                  v82 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v82 = v80;
                v183 = &v164;
                if (v82)
                {
                  v82 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v82);
                  v78 = anURL[0];
                  v77 = anURL[1];
                }
                else
                {
                  v83 = 0;
                }
                v84 = (const __CFURL *)(v82 + 8 * v79);
                v85 = (const __CFURL *)(v82 + 8 * v83);
                v182 = v85;
                *(_QWORD *)v84 = v76;
                v86 = (const __CFURL *)((char *)v84 + 8);
                v172 = 0;
                *(_QWORD *)&v181[16] = (char *)v84 + 8;
                if (v77 == v78)
                {
                  v88 = 0;
                }
                else
                {
                  do
                  {
                    v87 = *((_QWORD *)v77 - 1);
                    v77 = (CFURLRef)((char *)v77 - 8);
                    *((_QWORD *)v84 - 1) = v87;
                    v84 = (const __CFURL *)((char *)v84 - 8);
                    *(_QWORD *)v77 = 0;
                  }
                  while (v77 != v78);
                  v86 = *(const __CFURL **)&v181[16];
                  v85 = v182;
                  v88 = v172;
                }
                v89 = *(_OWORD *)anURL;
                anURL[0] = v84;
                anURL[1] = v86;
                *(_OWORD *)&v181[8] = v89;
                v90 = v164;
                v164 = v85;
                v182 = v90;
                *(_QWORD *)v181 = v89;
                std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer((uint64_t)v181);
                anURL[1] = v86;
                if (v88)
                  CFRelease(v88);
              }
              else
              {
                *(_QWORD *)anURL[1] = v75;
                v172 = 0;
                anURL[1] = (CFURLRef)((char *)v77 + 8);
              }
              for (j = 0; j != -14; j -= 2)
              {
                v92 = (const void *)v180[j + 1];
                if (v92)
                  CFRelease(v92);
                v93 = (const void *)v180[j];
                if (v93)
                  CFRelease(v93);
              }
              if (v165)
                CFRelease(v165);
              if (cf)
                CFRelease(cf);
              if (v167)
                CFRelease(v167);
              if (v168)
                CFRelease(v168);
              if (v169)
                CFRelease(v169);
              if (v173)
                CFRelease(v173);
              if (v170)
                CFRelease(v170);
              v52 = *((_QWORD *)this + 813);
              v64 = ++v65;
            }
            while (v65 < (unint64_t)((uint64_t)(*(_QWORD *)(v52 + 176 * v66 + 40)
                                                     - *(_QWORD *)(v52 + 176 * v66 + 32)) >> 5));
          }
          v94 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)anURL);
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v94;
          v50 = v150;
          v95 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          LODWORD(valuePtr[0]) = *(_DWORD *)(*((_QWORD *)this + 813) + 176 * v53 + 136);
          v96 = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
          *(_QWORD *)v181 = v96;
          if (!v96)
          {
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Could not construct");
          }
          CFDictionaryAddValue(v95, CFSTR("Gain"), v96);
          CFRelease(v96);
          LODWORD(valuePtr[0]) = *(_DWORD *)(*((_QWORD *)this + 813) + 176 * v53 + 140);
          v97 = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
          *(_QWORD *)v181 = v97;
          if (!v97)
          {
            v146 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v146, "Could not construct");
          }
          CFDictionaryAddValue(v95, CFSTR("DistanceCompression"), v97);
          CFRelease(v97);
          CFDictionaryAddValue(v95, CFSTR("WarpingParameters"), v94);
          v98 = (char *)(*((_QWORD *)this + 813) + 176 * v53);
          if (v98[23] < 0)
            v98 = *(char **)v98;
          v54 = v152;
          applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)v181, v98);
          CFDictionaryAddValue(v150, *(const void **)v181, v95);
          CFRelease(v95);
          if (*(_QWORD *)v181)
            CFRelease(*(CFTypeRef *)v181);
          if (v94)
            CFRelease(v94);
        }
LABEL_168:
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)anURL;
        std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
        v51 = *((_QWORD *)this + 814);
        v52 = *((_QWORD *)this + 813);
        v53 = ++v54;
      }
      while (0x2E8BA2E8BA2E8BA3 * ((v51 - v52) >> 4) > (unint64_t)v54);
    }
    if (v50)
    {
      v48 = v155;
      v99 = CFGetTypeID(v50);
      if (v99 != CFDictionaryGetTypeID())
      {
        CFRelease(v50);
        v50 = 0;
      }
    }
    else
    {
      v48 = v155;
    }
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)this + 6336);
    value = v50;
  }
  AUSM::Properties::createPropertyDictionaryForSaveState((AUSpatialMixerV2 *)((char *)this + 3584), (__CFDictionary **)v181);
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v181;
  buf.__r_.__value_.__l.__size_ = 1;
  v100 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t)&buf);
  valuePtr[0] = v100;
  if (*(_QWORD *)v181)
    CFRelease(*(CFTypeRef *)v181);
  v101 = 0;
  memset(v181, 0, sizeof(v181));
  while (1)
  {
    v102 = *((_QWORD *)this + 15);
    if (v102)
      LODWORD(v103) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v102 + 24))(v102);
    else
      v103 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (v101 >= v103)
      break;
    v104 = (unsigned int *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v101);
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)(v104 + 180));
    ausdk::AUChannelLayout::AUChannelLayout((ausdk::AUChannelLayout *)&buf, (const ausdk::AUChannelLayout *)(v104 + 30));
    v105 = (unsigned int *)buf.__r_.__value_.__r.__words[0];
    if (!ausdk::AUChannelLayout::NumberChannels((ausdk::AUChannelLayout *)buf.__r_.__value_.__l.__data_, v106)|| (v107 = *v105, (*v105 | 0x10000) == 0x10000))
    {
      v107 = -65536;
    }
    atomic_store(v107, v104 + 318);
    AUSM::Properties::createPropertyDictionaryForSaveState((AUSM::Properties *)(v104 + 264), anURL);
    v48 = v155;
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)(v104 + 180));
    v108 = *(_QWORD **)&v181[8];
    if (*(_QWORD *)&v181[8] >= *(_QWORD *)&v181[16])
    {
      v109 = *(_QWORD **)v181;
      v110 = (uint64_t)(*(_QWORD *)&v181[8] - *(_QWORD *)v181) >> 3;
      v111 = v110 + 1;
      if ((unint64_t)(v110 + 1) >> 61)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v112 = *(_QWORD *)&v181[16] - *(_QWORD *)v181;
      if ((uint64_t)(*(_QWORD *)&v181[16] - *(_QWORD *)v181) >> 2 > v111)
        v111 = v112 >> 2;
      if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFF8)
        v113 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v113 = v111;
      v176[0] = &v181[16];
      if (v113)
      {
        v113 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v113);
        v108 = *(_QWORD **)&v181[8];
        v109 = *(_QWORD **)v181;
      }
      else
      {
        v114 = 0;
      }
      v115 = (CFURLRef *)(v113 + 8 * v110);
      v116 = v113 + 8 * v114;
      v175 = v116;
      *v115 = anURL[0];
      v117 = v115 + 1;
      anURL[0] = 0;
      buf.__r_.__value_.__r.__words[2] = (std::string::size_type)(v115 + 1);
      if (v108 == v109)
      {
        v119 = 0;
      }
      else
      {
        do
        {
          v118 = (const __CFURL *)*--v108;
          *--v115 = v118;
          *v108 = 0;
        }
        while (v108 != v109);
        v117 = (CFURLRef *)buf.__r_.__value_.__r.__words[2];
        v116 = v175;
        v119 = anURL[0];
      }
      v120 = *(_OWORD *)v181;
      *(_QWORD *)v181 = v115;
      *(_QWORD *)&v181[8] = v117;
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = v120;
      v121 = *(_QWORD *)&v181[16];
      *(_QWORD *)&v181[16] = v116;
      v175 = v121;
      buf.__r_.__value_.__r.__words[0] = v120;
      std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer((uint64_t)&buf);
      *(_QWORD *)&v181[8] = v117;
      if (v119)
        CFRelease(v119);
    }
    else
    {
      **(_QWORD **)&v181[8] = anURL[0];
      *(_QWORD *)&v181[8] = v108 + 1;
    }
    ++v101;
  }
  v122 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)v181);
  v172 = v122;
  v123 = (unsigned int *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
  ausdk::AUChannelLayout::AUChannelLayout((ausdk::AUChannelLayout *)&buf, (const ausdk::AUChannelLayout *)(v123 + 30));
  v124 = (unsigned int *)buf.__r_.__value_.__r.__words[0];
  if (!ausdk::AUChannelLayout::NumberChannels((ausdk::AUChannelLayout *)buf.__r_.__value_.__l.__data_, v125)|| (v126 = *v124, (*v124 | 0x10000) == 0x10000))
  {
    v126 = -65536;
  }
  atomic_store(v126, v123 + 74);
  AUSM::Properties::createPropertyDictionaryForSaveState((AUSM::Properties *)(v123 + 56), (__CFDictionary **)&v173);
  if (buf.__r_.__value_.__r.__words[0])
  {
    buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  anURL[0] = (CFURLRef)&v173;
  anURL[1] = (CFURLRef)1;
  v127 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t)anURL);
  v170 = v127;
  if (v173)
    CFRelease(v173);
  CFDictionaryAddValue(*a2, (const void *)AUSM::kFactoryPresetChannelOverridesKey, v48);
  CFDictionaryAddValue(*a2, CFSTR("InputProperties"), v122);
  CFDictionaryAddValue(*a2, CFSTR("OutputProperties"), v127);
  CFDictionaryAddValue(*a2, (const void *)AUSM::kFactoryPresetGlobalPropertiesKey, v100);
  if (!*v153 && value && *((_BYTE *)this + 6528))
    CFDictionaryAddValue(*a2, CFSTR("SoundStages"), value);
  AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&buf, (uint64_t)this + 3904);
  v128 = (const void *)buf.__r_.__value_.__r.__words[0];
  if (!buf.__r_.__value_.__r.__words[0])
    goto LABEL_236;
  if (*((_QWORD *)this + 925))
  {
    AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(anURL, (uint64_t)this + 3904);
    v129 = anURL[0];
    v130 = CFURLGetString(anURL[0]);
    v131 = *((_QWORD *)this + 925);
    v132 = (const UInt8 *)(v131 + 1008);
    v133 = *(unsigned __int8 *)(v131 + 1031);
    v134 = *(const UInt8 **)(v131 + 1008);
    v135 = *(_QWORD *)(v131 + 1016);
    if ((v133 & 0x80u) == 0)
      v136 = v132;
    else
      v136 = v134;
    if ((v133 & 0x80u) == 0)
      v137 = v133;
    else
      v137 = v135;
    v138 = CFStringCreateWithBytes(0, v136, v137, 0x8000100u, 0);
    v173 = v138;
    if (!v138)
    {
      v148 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v148, "Could not construct");
    }
    v139 = CFStringCompare(v130, v138, 0) == kCFCompareEqualTo;
    CFRelease(v138);
    if (v129)
      CFRelease(v129);
  }
  else
  {
    v139 = 0;
  }
  CFRelease(v128);
  if (!v139)
    goto LABEL_236;
  v140 = (const __CFArray *)CFDictionaryGetValue(*a2, (const void *)AUSM::kFactoryPresetGlobalPropertiesKey);
  ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(v140, 0);
  std::to_string(&buf, 3203);
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_buf = &buf;
  else
    p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  else
    size = buf.__r_.__value_.__l.__size_;
  v144 = (const __CFURL *)CFStringCreateWithBytes(0, (const UInt8 *)p_buf, size, 0x8000100u, 0);
  anURL[0] = v144;
  if (!v144)
  {
    v149 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v149, "Could not construct");
  }
  CFDictionaryRemoveValue(ValueAtIndex, v144);
  CFRelease(v144);
  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_236:
    if (!v127)
      goto LABEL_238;
    goto LABEL_237;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
  if (v127)
LABEL_237:
    CFRelease(v127);
LABEL_238:
  if (v122)
    CFRelease(v122);
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v181;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
  if (v100)
    CFRelease(v100);
  if (value)
    CFRelease(value);
  if (v155)
    CFRelease(v155);
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v157;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(v160[0]);
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v161);
  return 0;
}

void sub_1B619327C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::RestoreState(AUSpatialMixerV2 *this, const void *a2)
{
  unsigned __int8 v3;
  NSObject *v4;
  _BOOL4 v5;
  AUSpatialMixerV2 *v6;
  _QWORD *v7;
  const char *v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unsigned int i;
  uint64_t v14;
  uint64_t v15;
  uint64_t Element;
  float *v17;
  float Parameter;
  const __CFArray *Value;
  int v20;
  int v21;
  const __CFArray *v22;
  int v23;
  int v24;
  const void *v25;
  const void *v26;
  CFTypeID v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  const __CFArray *v31;
  const void *v32;
  const void *v33;
  CFTypeID v34;
  _DWORD *v35;
  const void **v36;
  char *v37;
  int v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  const void *v44;
  const void *v45;
  int v46;
  float v47;
  CFTypeID v48;
  NSObject *v49;
  CFTypeID v50;
  const void *v51;
  const void *v52;
  CFTypeID v53;
  NSObject *v54;
  CFTypeID v55;
  CFIndex v56;
  CFIndex v57;
  CFIndex v58;
  unint64_t k;
  const __CFNumber *v60;
  int v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  const __CFNumber *v70;
  float v71;
  const __CFNumber *v72;
  float v73;
  char *v74;
  char *v75;
  char *v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  __int128 v84;
  void *v85;
  int v86;
  const void *v87;
  char v88;
  NSObject *v89;
  std::string::size_type v90;
  const void *v91;
  std::string::size_type v92;
  std::string::size_type v93;
  uint64_t v94;
  const __CFDictionary *v95;
  void *v96;
  const void **v97;
  NSObject *v98;
  NSObject *v99;
  unsigned __int8 v100;
  NSObject *v101;
  _QWORD *v102;
  CFIndex Count;
  CFIndex v105;
  CFIndex v106;
  unint64_t j;
  const __CFNumber *v108;
  uint64_t v109;
  int v110;
  int v111;
  int v112;
  NSObject *v113;
  std::string::size_type v114;
  _QWORD *v115;
  _QWORD *v116;
  _QWORD *v117;
  std::runtime_error *v118;
  std::runtime_error *v119;
  std::runtime_error *v120;
  std::runtime_error *v121;
  std::runtime_error *v122;
  std::runtime_error *v123;
  std::runtime_error *v124;
  std::runtime_error *v125;
  std::runtime_error *v126;
  std::runtime_error *v127;
  std::runtime_error *exception;
  std::runtime_error *v129;
  std::string::size_type *v130;
  uint64_t v131;
  char *v132;
  unsigned __int8 *v133;
  char v134;
  float v135;
  unsigned int v136;
  CFTypeRef cf;
  _DWORD *v138;
  const __CFDictionary *theDict;
  BOOL v140;
  const void **v141;
  const __CFArray *v143;
  const void *v144;
  const void *ValueAtIndex;
  CFTypeRef v146;
  void *__p;
  char *v148;
  unint64_t v149;
  std::string buf;
  _QWORD v151[5];

  v151[3] = *MEMORY[0x1E0C80C00];
  v133 = (unsigned __int8 *)this + 6128;
  v3 = atomic_load((unsigned __int8 *)this + 7443);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v4 = (id)getAUSMV2Log(void)::gLog;
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if ((v3 & 1) != 0)
  {
    v6 = this;
    if (!v5)
      goto LABEL_13;
    v9 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v9 = (_QWORD *)*v9;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"RestoreState";
    v8 = "[%s|%s] repeated call, suppressing logs for properties that do not change";
  }
  else
  {
    v6 = this;
    if (!v5)
      goto LABEL_13;
    v7 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v7 = (_QWORD *)*v7;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"RestoreState";
    v8 = "[%s|%s] started";
  }
  _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&buf, 0x16u);
LABEL_13:

  v10 = *(_QWORD *)(*((_QWORD *)v6 + 770) + 768);
  if (v10
    && ((v11 = atomic_load((unsigned __int8 *)(v10 + 97)), (v11 & 1) != 0)
     || (v12 = atomic_load((unsigned __int8 *)(*(_QWORD *)(*((_QWORD *)v6 + 770) + 768) + 96)), (v12 & 1) != 0))
    || (v136 = ausdk::AUBase::RestoreState((OpaqueAudioComponentInstance **)v6, a2)) == 0)
  {
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v6 + 3352;
    buf.__r_.__value_.__s.__data_[8] = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)v6 + 3352));
    for (i = 0; ; ++i)
    {
      v14 = *((_QWORD *)v6 + 15);
      if (v14)
        LODWORD(v15) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
      else
        v15 = (*((_QWORD *)v6 + 13) - *((_QWORD *)v6 + 12)) >> 3;
      if (i >= v15)
        break;
      Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)v6 + 80), i);
      atomic_store(1u, (unsigned __int8 *)(Element + 1921));
      atomic_store(1u, (unsigned __int8 *)(Element + 696));
    }
    v17 = (float *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)v6 + 128), 0);
    Parameter = ausdk::AUElement::GetParameter((ausdk::AUElement *)v17, 3u);
    v17[48] = __exp10f(Parameter * 0.05);
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&buf);
    v136 = 0;
  }
  Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a2, (const void *)AUSM::kFactoryPresetGlobalPropertiesKey);
  ValueAtIndex = CFArrayGetValueAtIndex(Value, 0);
  if (ValueAtIndex)
  {
    v20 = (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, const void **, uint64_t))(*(_QWORD *)v6 + 96))(v6, 5000, 0, 0, &ValueAtIndex, 8);
    v21 = v136;
    if (v20)
      v21 = v20;
    v136 = v21;
  }
  v22 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("OutputProperties"));
  v144 = CFArrayGetValueAtIndex(v22, 0);
  if (v144)
  {
    v23 = (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, uint64_t, _QWORD, const void **, uint64_t))(*(_QWORD *)v6 + 96))(v6, 5000, 2, 0, &v144, 8);
    v24 = v136;
    if (v23)
      v24 = v23;
    v136 = v24;
  }
  v25 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("InputProperties"));
  cf = v25;
  v26 = v25;
  if (!v25)
    goto LABEL_41;
  CFRetain(v25);
  v27 = CFGetTypeID(v26);
  if (v27 != CFArrayGetTypeID())
  {
    CFRelease(cf);
LABEL_41:
    cf = 0;
    goto LABEL_42;
  }
  if (CFArrayGetCount((CFArrayRef)cf))
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v28 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      v115 = (_QWORD *)((char *)v6 + 3592);
      if (*((char *)v6 + 3615) < 0)
        v115 = (_QWORD *)*v115;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v115;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"RestoreState";
      _os_log_debug_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "[%s|%s] Setting input properties", (uint8_t *)&buf, 0x16u);
    }

    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v6 + 3352;
    buf.__r_.__value_.__s.__data_[8] = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)v6 + 3352));
    v29 = *((_QWORD *)v6 + 15);
    if (v29)
      LODWORD(v30) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
    else
      v30 = (*((_QWORD *)v6 + 13) - *((_QWORD *)v6 + 12)) >> 3;
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&buf);
    Count = CFArrayGetCount((CFArrayRef)cf);
    v105 = CFArrayGetCount((CFArrayRef)cf);
    if (Count)
    {
      v106 = v105;
      for (j = 0; j != Count; ++j)
      {
        if (v106 == j)
          break;
        applesauce::CF::details::at_to<applesauce::CF::DictionaryRef>((const __CFArray *)cf, j, (applesauce::CF::DictionaryRef *)&__p);
        if (!__p)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Could not construct");
        }
        v108 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[14]>((const __CFDictionary *)__p, "ElementNumber");
        if (v108)
        {
          v109 = applesauce::CF::convert_as<unsigned int,0>(v108);
          if ((v109 & 0xFF00000000) != 0)
          {
            v110 = v109;
            if (v30 <= v109)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v113 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
              {
                v114 = (std::string::size_type)v6 + 3592;
                if (*((char *)v6 + 3615) < 0)
                  v114 = *((_QWORD *)v6 + 449);
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v114;
                WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"RestoreState";
                HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
                LODWORD(v151[0]) = v30;
                WORD2(v151[0]) = 1024;
                *(_DWORD *)((char *)v151 + 6) = v110;
                _os_log_impl(&dword_1B5ED0000, v113, OS_LOG_TYPE_DEFAULT, "[%s|%s] bus count == %d, dropping properties for InputElement %d", (uint8_t *)&buf, 0x22u);
              }

            }
            else
            {
              v111 = (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, uint64_t, uint64_t, void **, uint64_t))(*(_QWORD *)v6 + 96))(v6, 5000, 1, v109, &__p, 8);
              v112 = v136;
              if (v111)
                v112 = v111;
              v136 = v112;
            }
          }
        }
        if (__p)
          CFRelease(__p);
      }
    }
  }
LABEL_42:
  v31 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a2, (const void *)AUSM::kFactoryPresetChannelOverridesKey);
  v143 = v31;
  if (v31 && CFArrayGetCount(v31) >= 1)
    (*(void (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, const __CFArray **, uint64_t))(*(_QWORD *)v6 + 96))(v6, 3268, 0, 0, &v143, 8);
  if (!*v133)
  {
    v32 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("SoundStages"));
    v33 = v32;
    if (v32)
    {
      CFRetain(v32);
      v34 = CFGetTypeID(v33);
      if (v34 != CFDictionaryGetTypeID())
      {
        CFRelease(v33);
        v33 = 0;
      }
      v35 = operator new(0xCuLL);
      *(_QWORD *)v35 = 0x200000003;
      v35[2] = 1;
      v36 = (const void **)operator new(0x18uLL);
      *(_OWORD *)v36 = xmmword_1E69CA588;
      v36[2] = CFSTR("AUSMSoundStageSmallParameters");
      LOWORD(buf.__r_.__value_.__l.__data_) = 256;
      buf.__r_.__value_.__s.__data_[2] = 1;
      v37 = (char *)operator new(8uLL);
      v38 = 0;
      v39 = 0;
      *(_QWORD *)v37 = 0;
      v132 = v37;
      v40 = (uint64_t *)v37;
      do
      {
        v41 = 1 << v38;
        if (buf.__r_.__value_.__s.__data_[v39])
          v42 = *v40 | v41;
        else
          v42 = *v40 & ~v41;
        *v40 = v42;
        ++v39;
        v40 += v38 == 63;
        if (v38 == 63)
          v38 = 0;
        else
          ++v38;
      }
      while (v39 != 3);
      v141 = v36;
      v138 = v35;
      theDict = (const __CFDictionary *)v33;
      v43 = 0;
      v134 = 0;
      v131 = (uint64_t)v6 + 6336;
      v130 = (std::string::size_type *)((char *)v6 + 6536);
      while (1)
      {
        if (!theDict)
        {
          v126 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v126, "Could not construct");
        }
        v44 = applesauce::CF::details::at_key<__CFString const* const&>(theDict, v141[v43]);
        if (!v44)
          goto LABEL_135;
        v45 = v44;
        v46 = v138[v43];
        if (v46 == 1)
          v47 = 1.0;
        else
          v47 = 0.0;
        v48 = CFGetTypeID(v44);
        if (v48 == CFDictionaryGetTypeID())
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v49 = getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
          {
            v92 = (std::string::size_type)v130;
            if ((char)v133[431] < 0)
              v92 = *v130;
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v92;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"setSoundStageDictionary";
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
            LODWORD(v151[0]) = v43;
            _os_log_debug_impl(&dword_1B5ED0000, v49, OS_LOG_TYPE_DEBUG, "[%s|%s] Parsing SoundStage preset #%d dictionary", (uint8_t *)&buf, 0x1Cu);
          }
          CFRetain(v45);
          v50 = CFGetTypeID(v45);
          if (v50 != CFDictionaryGetTypeID())
          {
            CFRelease(v45);
            v127 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v127, "Could not construct");
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 1065353216;
          v135 = applesauce::CF::at_or<float,char const(&)[5]>((const __CFDictionary *)v45, "Gain", (uint64_t)&buf);
          if (applesauce::CF::details::has_key<char const(&)[20]>((const __CFDictionary *)v45, "DistanceCompression"))
            v47 = applesauce::CF::details::find_at_key<float,char const(&)[20]>((const __CFDictionary *)v45, "DistanceCompression");
          v51 = CFDictionaryGetValue((CFDictionaryRef)v45, CFSTR("WarpingParameters"));
          v52 = v51;
          if (v51)
          {
            CFRetain(v51);
            v53 = CFGetTypeID(v52);
            if (v53 != CFArrayGetTypeID())
            {
              CFRelease(v52);
              v52 = 0;
            }
          }
          CFRelease(v45);
          __p = 0;
          v148 = 0;
          v149 = 0;
          v140 = v52 == 0;
          if (!v52)
            goto LABEL_128;
        }
        else
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v54 = getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
          {
            v93 = (std::string::size_type)v130;
            if ((char)v133[431] < 0)
              v93 = *v130;
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v93;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"setSoundStageDictionary";
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
            LODWORD(v151[0]) = v43;
            _os_log_debug_impl(&dword_1B5ED0000, v54, OS_LOG_TYPE_DEBUG, "[%s|%s] SoundStage preset #%d is not dictionary; treating as array",
              (uint8_t *)&buf,
              0x1Cu);
          }
          CFRetain(v45);
          v55 = CFGetTypeID(v45);
          if (v55 != CFArrayGetTypeID())
          {
            CFRelease(v45);
            v52 = 0;
            __p = 0;
            v148 = 0;
            v140 = 1;
            v149 = 0;
            goto LABEL_128;
          }
          __p = 0;
          v148 = 0;
          v149 = 0;
          v140 = v45 == 0;
          v135 = 1.0;
          v52 = v45;
        }
        if (CFArrayGetCount((CFArrayRef)v52))
        {
          v56 = CFArrayGetCount((CFArrayRef)v52);
          v57 = CFArrayGetCount((CFArrayRef)v52);
          if (v56)
          {
            v58 = v57;
            for (k = 0; k != v56; ++k)
            {
              if (k == v58)
                break;
              applesauce::CF::details::at_to<applesauce::CF::DictionaryRef>((const __CFArray *)v52, k, (applesauce::CF::DictionaryRef *)&buf);
              if (!buf.__r_.__value_.__r.__words[0])
              {
                v119 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v119, "Could not construct");
              }
              v60 = (const __CFNumber *)applesauce::CF::details::at_key<__CFString const*&>((CFDictionaryRef)buf.__r_.__value_.__l.__data_, (const void *)kPresetKeyChannelLabel);
              if (!v60)
              {
                v125 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v125, "Could not find item");
              }
              v61 = applesauce::CF::convert_to<unsigned int,0>(v60);
              if (!buf.__r_.__value_.__r.__words[0])
              {
                v120 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v120, "Could not construct");
              }
              v62 = applesauce::CF::details::find_at_key<float,__CFString const*&>((const __CFDictionary *)buf.__r_.__value_.__l.__data_, (const void *)kPresetKeyAzimuth);
              if (!buf.__r_.__value_.__r.__words[0])
              {
                v122 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v122, "Could not construct");
              }
              v63 = v62;
              v64 = applesauce::CF::details::find_at_key<float,__CFString const*&>((const __CFDictionary *)buf.__r_.__value_.__l.__data_, (const void *)kPresetKeyElevation);
              if (!buf.__r_.__value_.__r.__words[0])
              {
                v121 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v121, "Could not construct");
              }
              v65 = v64;
              v66 = applesauce::CF::details::find_at_key<float,__CFString const*&>((const __CFDictionary *)buf.__r_.__value_.__l.__data_, (const void *)kPresetKeyDistance);
              if (!buf.__r_.__value_.__r.__words[0])
              {
                v123 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v123, "Could not construct");
              }
              v67 = v66;
              v68 = applesauce::CF::details::find_at_key<float,__CFString const*&>((const __CFDictionary *)buf.__r_.__value_.__l.__data_, (const void *)kPresetKeyGain);
              if (!buf.__r_.__value_.__r.__words[0])
              {
                v118 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v118, "Could not construct");
              }
              v69 = v68;
              v70 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*&>((const __CFDictionary *)buf.__r_.__value_.__l.__data_, (const void *)kPresetKeyDRRAdjustment);
              if (((unint64_t)v70 & 0xFF00000000) != 0)
                v71 = *(float *)&v70;
              else
                v71 = 0.0;
              if (!buf.__r_.__value_.__r.__words[0])
              {
                v124 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v124, "Could not construct");
              }
              v72 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*&>((const __CFDictionary *)buf.__r_.__value_.__l.__data_, (const void *)kPresetKeyDelay);
              v73 = ((unint64_t)v72 & 0xFF00000000) != 0 ? *(float *)&v72 : 0.0;
              v74 = v148;
              if ((unint64_t)v148 >= v149)
              {
                v76 = (char *)__p;
                v77 = (v148 - (_BYTE *)__p) >> 5;
                v78 = v77 + 1;
                if ((unint64_t)(v77 + 1) >> 59)
                  std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
                v79 = v149 - (_QWORD)__p;
                if ((uint64_t)(v149 - (_QWORD)__p) >> 4 > v78)
                  v78 = v79 >> 4;
                if ((unint64_t)v79 >= 0x7FFFFFFFFFFFFFE0)
                  v80 = 0x7FFFFFFFFFFFFFFLL;
                else
                  v80 = v78;
                if (v80)
                  v80 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v80);
                else
                  v81 = 0;
                v82 = v80 + 32 * v77;
                *(float *)v82 = v63;
                *(float *)(v82 + 4) = v65;
                *(float *)(v82 + 8) = v67;
                *(float *)(v82 + 12) = v69;
                *(float *)(v82 + 16) = v71;
                *(float *)(v82 + 20) = v73;
                *(_DWORD *)(v82 + 24) = 1;
                *(_DWORD *)(v82 + 28) = v61;
                if (v74 == v76)
                {
                  v85 = (void *)(v80 + 32 * v77);
                }
                else
                {
                  v83 = v80 + 32 * v77;
                  do
                  {
                    v84 = *((_OWORD *)v74 - 1);
                    v85 = (void *)(v83 - 32);
                    *(_OWORD *)(v83 - 32) = *((_OWORD *)v74 - 2);
                    *(_OWORD *)(v83 - 16) = v84;
                    v74 -= 32;
                    v83 -= 32;
                  }
                  while (v74 != v76);
                }
                v75 = (char *)(v82 + 32);
                __p = v85;
                v148 = (char *)(v82 + 32);
                v149 = v80 + 32 * v81;
                if (v76)
                  operator delete(v76);
              }
              else
              {
                *(float *)v148 = v63;
                *((float *)v74 + 1) = v65;
                *((float *)v74 + 2) = v67;
                *((float *)v74 + 3) = v69;
                *((float *)v74 + 4) = v71;
                *((float *)v74 + 5) = v73;
                v75 = v74 + 32;
                *((_DWORD *)v74 + 6) = 1;
                *((_DWORD *)v74 + 7) = v61;
              }
              v148 = v75;
              if (buf.__r_.__value_.__r.__words[0])
                CFRelease(buf.__r_.__value_.__l.__data_);
              v6 = this;
            }
          }
          v86 = v138[v43];
          v87 = v141[v43];
          if (v87)
            CFRetain(v141[v43]);
          applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v146, v87);
          if (!v146)
          {
            v129 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(v129, "Could not construct");
          }
          applesauce::CF::convert_to<std::string,0>((const __CFString *)v146, (uint64_t)&buf);
          v88 = AUSM::SoundStage::setSoundStageParameters(v131, v86, &__p, &buf, (*(_QWORD *)&v132[(v43 >> 3) & 0x1FFFFFFFFFFFFFF8] >> v43) & 1, v46 == 1, 1, v135, v47);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            operator delete(buf.__r_.__value_.__l.__data_);
          if (v146)
            CFRelease(v146);
          v134 |= v88;
          goto LABEL_131;
        }
LABEL_128:
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v89 = getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
        {
          v90 = (std::string::size_type)v130;
          if ((char)v133[431] < 0)
            v90 = *v130;
          v91 = v141[v43];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v90;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"setSoundStageDictionary";
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2112;
          v151[0] = v91;
          _os_log_error_impl(&dword_1B5ED0000, v89, OS_LOG_TYPE_ERROR, "[%s|%s] Failed to extract SoundStage preset: %@", (uint8_t *)&buf, 0x20u);
        }
LABEL_131:
        if (__p)
          operator delete(__p);
        if (!v140)
          CFRelease(v52);
LABEL_135:
        if (++v43 == 3)
        {
          v94 = getAUSMV2Log(void)::onceToken;
          if ((v134 & 1) != 0)
          {
            v96 = v138;
            v95 = theDict;
            v97 = v141;
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v98 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
            {
              v116 = (_QWORD *)((char *)v6 + 3592);
              if (*((char *)v6 + 3615) < 0)
                v116 = (_QWORD *)*v116;
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v116;
              WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"RestoreState";
              _os_log_debug_impl(&dword_1B5ED0000, v98, OS_LOG_TYPE_DEBUG, "[%s|%s] Set SoundStage Parameters", (uint8_t *)&buf, 0x16u);
            }

            v133[400] = 1;
          }
          else
          {
            v133[400] = 0;
            v96 = v138;
            v95 = theDict;
            v97 = v141;
            if (v94 != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v99 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
            {
              v117 = (_QWORD *)((char *)v6 + 3592);
              if (*((char *)v6 + 3615) < 0)
                v117 = (_QWORD *)*v117;
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v117;
              WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"RestoreState";
              _os_log_debug_impl(&dword_1B5ED0000, v99, OS_LOG_TYPE_DEBUG, "[%s|%s] Found SoundStages in Dictionary, but failed to set parameters on SoundStageManager", (uint8_t *)&buf, 0x16u);
            }

          }
          operator delete(v132);
          operator delete(v97);
          operator delete(v96);
          CFRelease(v95);
          break;
        }
      }
    }
  }
  v100 = atomic_load(v133 + 1315);
  if ((v100 & 1) == 0)
    atomic_store(1u, v133 + 1315);
  atomic_store(1u, (unsigned __int8 *)v6 + 3240);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v101 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
  {
    v102 = (_QWORD *)((char *)v6 + 3592);
    if (*((char *)v6 + 3615) < 0)
      v102 = (_QWORD *)*v102;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v102;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"RestoreState";
    _os_log_impl(&dword_1B5ED0000, v101, OS_LOG_TYPE_DEFAULT, "[%s|%s] finished", (uint8_t *)&buf, 0x16u);
  }

  if (cf)
    CFRelease(cf);
  return v136;
}

void sub_1B6194B40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef cf, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,CFTypeRef a27,CFTypeRef a28,uint64_t a29,uint64_t a30,CFTypeRef a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t AUSpatialMixerV2::GetPresets(AUSpatialMixerV2 *this, const __CFArray **a2)
{
  int v3;
  CFIndex v4;
  __CFArray *Mutable;
  __CFArray *v6;
  uint64_t i;

  if (a2)
  {
    IR::IRDataLoader::instance(this);
    v3 = IR::IRDataLoader::fileExists();
    if (v3)
      v4 = 3;
    else
      v4 = 2;
    Mutable = CFArrayCreateMutable(0, v4, 0);
    v6 = Mutable;
    if (v3)
      CFArrayAppendValue(Mutable, AUSM::kFactoryPresets);
    for (i = 0; i != 2; CFArrayAppendValue(v6, &AUSM::kFactoryPresets[i]))
      ++i;
    *a2 = v6;
  }
  return 0;
}

uint64_t AUSpatialMixerV2::NewFactoryPresetSet(AUSpatialMixerV2 *this, const AUPreset *a2)
{
  NSObject *v4;
  _QWORD *v5;
  SInt32 presetNumber;
  uint64_t v7;
  NSObject *v8;
  const void *v9;
  _QWORD *v11;
  int v12;
  uint8_t buf[4];
  _QWORD *v14;
  __int16 v15;
  _BYTE v16[10];
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v4 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v5 = (_QWORD *)*v5;
    presetNumber = a2->presetNumber;
    *(_DWORD *)buf = 136315650;
    v14 = v5;
    v15 = 2080;
    *(_QWORD *)v16 = "NewFactoryPresetSet";
    *(_WORD *)&v16[8] = 1024;
    v17 = presetNumber;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "[%s|%s] setting factory preset #%u", buf, 0x1Cu);
  }

  v12 = 0;
  v7 = (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, int *))(*(_QWORD *)this + 88))(this, 3116, 0, 0, &v12);
  if ((_DWORD)v7)
  {
    v12 = 0;
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v8 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v11 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v11 = (_QWORD *)*v11;
      *(_DWORD *)buf = 136315650;
      v14 = v11;
      v15 = 2080;
      *(_QWORD *)v16 = "NewFactoryPresetSet";
      *(_WORD *)&v16[8] = 1024;
      v17 = v7;
      _os_log_error_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_ERROR, "[%s|%s] Could not get personalized HRTF status. Error: %u. Assuming generic HRTF is being used.", buf, 0x1Cu);
    }

  }
  AUSM::FactoryPreset::load((AUSM::FactoryPreset *)buf, (int *)this + 1848, a2->presetNumber, v12 != 0);
  v9 = *(const void **)&v16[2];
  if (*(_QWORD *)&v16[2])
  {
    v7 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD))(*(_QWORD *)this + 288))(this, *(_QWORD *)&v16[2]);
    ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, (const AUPreset *)buf);
    CFRelease(v9);
  }
  return v7;
}

void sub_1B61950C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

double AUSpatialMixerV2::GetLatency(AUSpatialMixerV2 *this)
{
  double v2;
  double result;
  unsigned int v4;

  v2 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 80);
  result = 0.0;
  if (v2 > 0.0)
  {
    v4 = atomic_load((unsigned int *)this + 3772);
    return (double)v4 / v2;
  }
  return result;
}

uint64_t AUSpatialMixerV2::SupportsTail(AUSpatialMixerV2 *this)
{
  return 0;
}

uint64_t AUSpatialMixerV2::StreamFormatWritable(AUSpatialMixerV2 *this)
{
  return 1;
}

uint64_t AUSpatialMixerV2::SupportedNumChannels(AUSpatialMixerV2 *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)*((_QWORD *)this + 360);
  return (*((_QWORD *)this + 361) - *((_QWORD *)this + 360)) >> 2;
}

uint64_t AUSpatialMixerV2::ValidFormat(AUSpatialMixerV2 *this, int a2, uint64_t a3, const AudioStreamBasicDescription *a4, uint64_t a5)
{
  UInt32 mChannelsPerFrame;
  __int128 v6;
  uint64_t v8;
  __int128 v9;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  mChannelsPerFrame = a4->mChannelsPerFrame;
  if (a2 == 1)
  {
    if (mChannelsPerFrame && mChannelsPerFrame <= *((_DWORD *)this + 717))
    {
      v6 = *(_OWORD *)&a4->mBytesPerPacket;
      v11 = *(_OWORD *)&a4->mSampleRate;
      v12 = v6;
      v13 = *(_QWORD *)&a4->mBitsPerChannel;
      return (*(uint64_t (**)(AUSpatialMixerV2 *, __int128 *, uint64_t, const AudioStreamBasicDescription *, uint64_t))(*(_QWORD *)this + 576))(this, &v11, a3, a4, a5);
    }
    return 0;
  }
  v8 = 0;
  if ((a2 & 0xFFFFFFFD) == 0 && mChannelsPerFrame >= 2)
  {
    if (mChannelsPerFrame <= *((_DWORD *)this + 718))
    {
      v9 = *(_OWORD *)&a4->mBytesPerPacket;
      v11 = *(_OWORD *)&a4->mSampleRate;
      v12 = v9;
      v13 = *(_QWORD *)&a4->mBitsPerChannel;
      return (*(uint64_t (**)(AUSpatialMixerV2 *, __int128 *, _QWORD, const AudioStreamBasicDescription *, uint64_t))(*(_QWORD *)this + 584))(this, &v11, 0, a4, a5);
    }
    return 0;
  }
  return v8;
}

uint64_t AUSpatialMixerV2::ChangeStreamFormat(AUSpatialMixerV2 *this, int a2, uint64_t a3, const AudioStreamBasicDescription *a4, const AudioStreamBasicDescription *a5)
{
  _BOOL4 IsSupportedPersonalizedHRTF;
  unsigned __int8 v10;
  int RequiredSharedInputBufferSize;
  uint64_t v12;
  char *v13;
  unsigned __int8 v14;
  char *v16;
  char v17;
  char *v18;
  char v19;

  if (a2 == 2)
  {
    v13 = (char *)this + 3320;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
    v14 = atomic_load((unsigned __int8 *)this + 7441);
    if ((v14 & 1) != 0)
    {
      (*(void (**)(AUSpatialMixerV2 *))(*(_QWORD *)this + 64))(this);
      ausdk::AUBase::ChangeStreamFormat(this, 2, a3, a4, a5);
      v12 = (*(uint64_t (**)(AUSpatialMixerV2 *))(*(_QWORD *)this + 56))(this);
    }
    else
    {
      ausdk::AUBase::ChangeStreamFormat(this, 2, a3, a4, a5);
      v12 = 0;
    }
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)v13);
  }
  else
  {
    if (a2 == 1)
    {
      v18 = (char *)this + 3352;
      v19 = 1;
      std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
      IsSupportedPersonalizedHRTF = AUSpatialMixerV2::IsSupportedPersonalizedHRTF(this);
      ausdk::AUBase::ChangeStreamFormat(this, 1, a3, a4, a5);
      if (a5->mChannelsPerFrame != a4->mChannelsPerFrame)
      {
        v10 = atomic_load((unsigned __int8 *)this + 7441);
        if ((v10 & 1) != 0)
        {
          RequiredSharedInputBufferSize = AUSpatialMixerV2::GetRequiredSharedInputBufferSize(this);
          v16 = (char *)this + 3336;
          v17 = 1;
          caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3336);
          if (RequiredSharedInputBufferSize != (uint64_t)(*(_QWORD *)(*((_QWORD *)this + 370) + 232)
                                                        - *(_QWORD *)(*((_QWORD *)this + 370) + 224)) >> 5)
          {
            std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::unlock((uint64_t)&v16);
            AUSpatialMixerV2::ReconfigureSharedBuffers(this, 0, 1);
          }
          std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v16);
        }
      }
      if (IsSupportedPersonalizedHRTF != AUSpatialMixerV2::IsSupportedPersonalizedHRTF(this))
        (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)this + 592))(this, 3113);
      std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v18);
    }
    return 0;
  }
  return v12;
}

void sub_1B61953C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2::CreateElement(AUSpatialMixerV2 *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t *a4@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  std::string *v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  size_t v15;
  std::string *v16;
  const void *v17;
  uint64_t **v18;
  uint64_t *v19;
  uint64_t **v20;
  uint64_t **v21;
  unsigned int v22;
  _DWORD *v23;
  uint64_t v24;
  std::string *v25;
  uint64_t *v26;
  uint64_t **v27;
  unsigned int v28;
  _DWORD *v29;
  uint64_t v30;
  _DWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v39;
  _DWORD *v40;
  _DWORD *v41;
  uint64_t v42;
  _DWORD *v43;
  _DWORD *v44;
  char *v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  _OWORD *v54;
  char *v55;
  __int128 v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t i;
  uint64_t v61;
  float v62;
  __float2 v63;
  __float2 v64;
  __int128 v65;
  NSObject *v66;
  void **v67;
  uint64_t v68;
  size_t v69;
  std::string *v70;
  const void *v71;
  std::string *v72;
  std::string::size_type size;
  std::string *v74;
  std::string::size_type v75;
  char v76;
  AUSM::MatrixMix *v77;
  char *v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  char *v82;
  std::__shared_weak_count *v83;
  unint64_t *v84;
  unint64_t v85;
  NSObject *v86;
  std::string *v87;
  __int128 v88;
  std::string *v89;
  __int128 v90;
  std::string *v91;
  int v92;
  std::bad_alloc *exception;
  std::bad_alloc *v94;
  unsigned int __val;
  std::string v97;
  std::string v98;
  uint8_t buf[4];
  std::string *v100;
  __int16 v101;
  int v102;
  std::string v103;
  uint64_t v104;

  v104 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  if (a2 != 2)
  {
    if (a2 != 1)
    {
      ausdk::AUBase::CreateElement(this, a2, (uint64_t *)&v103);
      *a4 = v103.__r_.__value_.__r.__words[0];
      return;
    }
    v7 = operator new();
    ausdk::AUIOElement::AUIOElement((ausdk::AUIOElement *)v7, this);
    *(_QWORD *)(v7 + 80) = 0x40E5888000000000;
    *(_OWORD *)(v7 + 88) = xmmword_1B6626900;
    *(_OWORD *)(v7 + 104) = xmmword_1B6626910;
    *(_OWORD *)(v7 + 172) = 0u;
    *(_OWORD *)(v7 + 188) = 0u;
    *(_DWORD *)(v7 + 204) = 0;
    *(_QWORD *)(v7 + 208) = &unk_1E69D1D78;
    *(_QWORD *)v7 = &off_1E69D1CD0;
    *(_QWORD *)(v7 + 216) = this;
    *(_OWORD *)(v7 + 224) = 0u;
    *(_OWORD *)(v7 + 240) = 0u;
    *(_OWORD *)(v7 + 256) = 0u;
    *(_OWORD *)(v7 + 272) = 0u;
    *(_OWORD *)(v7 + 288) = 0u;
    *(_OWORD *)(v7 + 304) = 0u;
    *(_OWORD *)(v7 + 320) = 0u;
    *(_OWORD *)(v7 + 336) = 0u;
    *(_BYTE *)(v7 + 352) = 0;
    *(_QWORD *)(v7 + 360) = 0;
    *(_QWORD *)(v7 + 368) = 0;
    *(_WORD *)(v7 + 384) = 0;
    *(_QWORD *)(v7 + 376) = 0;
    std::vector<AudioChannelLayout>::vector((_QWORD *)(v7 + 392), 1uLL);
    v8 = *(_QWORD *)(v7 + 392);
    *(_QWORD *)v8 = 0;
    *(_DWORD *)(v8 + 8) = 0;
    *(_QWORD *)(v7 + 640) = 0;
    *(_WORD *)(v7 + 632) = 1;
    *(_BYTE *)(v7 + 635) = 0;
    *(_BYTE *)(v7 + 664) = 0;
    *(_OWORD *)(v7 + 592) = 0u;
    *(_OWORD *)(v7 + 608) = 0u;
    *(_OWORD *)(v7 + 560) = 0u;
    *(_OWORD *)(v7 + 576) = 0u;
    *(_OWORD *)(v7 + 528) = 0u;
    *(_OWORD *)(v7 + 544) = 0u;
    *(_OWORD *)(v7 + 496) = 0u;
    *(_OWORD *)(v7 + 512) = 0u;
    *(_OWORD *)(v7 + 464) = 0u;
    *(_OWORD *)(v7 + 480) = 0u;
    *(_OWORD *)(v7 + 432) = 0u;
    *(_OWORD *)(v7 + 448) = 0u;
    *(_OWORD *)(v7 + 416) = 0u;
    *(_QWORD *)(v7 + 656) = 0x3FF0000000000000;
    *(_BYTE *)(v7 + 672) = 1;
    *(_WORD *)(v7 + 680) = 0;
    *(_DWORD *)(v7 + 684) = a3;
    *(_QWORD *)(v7 + 688) = 0;
    *(_BYTE *)(v7 + 696) = 0;
    *(_QWORD *)(v7 + 704) = 0;
    *(_DWORD *)(v7 + 712) = 0;
    caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(v7 + 716));
    *(_QWORD *)(v7 + 720) = 0;
    *(_DWORD *)(v7 + 728) = 0;
    caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(v7 + 732));
    IR::IRDataAttributes::IRDataAttributes(v7 + 736, 0, 0, 0, 0.0);
    IR::IRDataAttributes::IRDataAttributes(v7 + 888, 0, 0, 0, 0.0);
    v9 = *(_QWORD *)(v7 + 216);
    *(_WORD *)(v7 + 1040) = 0;
    *(_DWORD *)(v7 + 1044) = -65536;
    AUSM::Properties::Properties(v7 + 1056, v7 + 208, 1, a3, (__int128 *)(v9 + 3592));
    *(_QWORD *)(v7 + 1056) = &off_1E69D1D98;
    *(_QWORD *)(v7 + 1128) = 0x500000000;
    *(_DWORD *)(v7 + 1136) = 0;
    *(_OWORD *)(v7 + 1152) = xmmword_1B66A08A0;
    *(_QWORD *)(v7 + 1168) = 2;
    *(_BYTE *)(v7 + 1176) = 0;
    *(_QWORD *)(v7 + 1184) = 0;
    *(_QWORD *)(v7 + 1192) = 850045863;
    *(_DWORD *)(v7 + 1260) = 0;
    *(_BYTE *)(v7 + 1264) = 0;
    *(_OWORD *)(v7 + 1200) = 0u;
    *(_OWORD *)(v7 + 1216) = 0u;
    *(_OWORD *)(v7 + 1232) = 0u;
    *(_OWORD *)(v7 + 1242) = 0u;
    *(_OWORD *)(v7 + 1268) = xmmword_1B66A08B0;
    *(_QWORD *)(v7 + 1288) = v9 + 3584;
    std::string::basic_string[abi:ne180100]<0>(&v103, "spatialization algorithm");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xBB8u, v7 + 1128, (__int128 *)&v103, 1, 1, 1, 0x100000000, 0x100000009);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "rendering flags");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xBBBu, v7 + 1132, (__int128 *)&v103, 1, 0, 1);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "source mode");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xBBDu, v7 + 1136, (__int128 *)&v103, 1, 1, 1, 0x100000000, 0x100000003);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "distance parameters");
    AUSM::Properties::addPropertyMapEntry<AUSM::DistanceParameters>(v7 + 1056, v7 + 1152, (uint64_t)&v103, 1);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "attenuation curve");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xBC5u, v7 + 1168, (__int128 *)&v103, 1, 0, 1, 0x100000000, 0x100000005);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "point source in-head mode");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xC1Fu, v7 + 1172, (__int128 *)&v103, 1, 0, 1, 0x100000000, 0x100000001);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "enable propagation delay");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xC25u, v7 + 1176, (__int128 *)&v103, 1, 0, 1);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "custom source directivity IR");
    AUSM::Properties::addCFURLAndCStringPropertyMapEntry(v7 + 1056, 0xC84u, 0xC85u, v7 + 1184, (const void **)&v103.__r_.__value_.__l.__data_, 1);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "enable reverb send decorrelation filters");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xC8Eu, v7 + 1256, (__int128 *)&v103, 1, 0, 1);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "enable upmixing for LRC channels");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xCA4u, v7 + 1264, (__int128 *)&v103, 1, 0, 1);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "enable exclusion zones");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xC98u, v7 + 1257, (__int128 *)&v103, 1, 0, 1);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "exclusion zone preset");
    __val = a3;
    v10 = operator new();
    *(_QWORD *)v10 = off_1E69E0820;
    *(_QWORD *)(v10 + 8) = 1;
    *(_BYTE *)(v10 + 16) = 1;
    v11 = (std::string *)(v10 + 24);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v11, v103.__r_.__value_.__l.__data_, v103.__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)&v103.__r_.__value_.__l.__data_;
      *(_QWORD *)(v10 + 40) = *((_QWORD *)&v103.__r_.__value_.__l + 2);
    }
    *(_QWORD *)v10 = off_1E69D1B78;
    *(_QWORD *)(v10 + 48) = v7 + 1260;
    v18 = (uint64_t **)(v7 + 1104);
    v19 = *(uint64_t **)(v7 + 1104);
    v20 = (uint64_t **)(v7 + 1104);
    v21 = (uint64_t **)(v7 + 1104);
    if (v19)
    {
      while (1)
      {
        while (1)
        {
          v21 = (uint64_t **)v19;
          v22 = *((_DWORD *)v19 + 8);
          if (v22 < 0xC9C)
            break;
          v19 = *v21;
          v20 = v21;
          if (!*v21)
            goto LABEL_51;
        }
        if (v22 == 3227)
          break;
        v19 = v21[1];
        if (!v19)
        {
          v20 = v21 + 1;
          goto LABEL_51;
        }
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    }
    else
    {
LABEL_51:
      v23 = operator new(0x30uLL);
      v23[8] = 3227;
      *((_QWORD *)v23 + 5) = v10;
      std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at((uint64_t **)(v7 + 1096), (uint64_t)v21, v20, (uint64_t *)v23);
    }
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "default audio channel layout tag");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xC94u, v7 + 1272, (__int128 *)&v103, 1, 0, 1);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "source orientation reference");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xCB7u, v7 + 1280, (__int128 *)&v103, 1, 0, 1, 0x100000000, 0x100000001);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "directivity preset number");
    AUSM::Properties::addPropertyMapEntry<unsigned int>(v7 + 1056, 0xCC5u, v7 + 1276, (__int128 *)&v103, 1, 1, 1, 0x100000000, 0x100000009);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v103, "binaural compatibility mode");
    v24 = operator new();
    *(_QWORD *)v24 = off_1E69E0820;
    *(_QWORD *)(v24 + 8) = 0x200000001;
    *(_BYTE *)(v24 + 16) = 1;
    v25 = (std::string *)(v24 + 24);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v25, v103.__r_.__value_.__l.__data_, v103.__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)&v25->__r_.__value_.__l.__data_ = *(_OWORD *)&v103.__r_.__value_.__l.__data_;
      *(_QWORD *)(v24 + 40) = *((_QWORD *)&v103.__r_.__value_.__l + 2);
    }
    *(_QWORD *)(v24 + 48) = v7 + 1268;
    *(_QWORD *)v24 = off_1E69D1BF0;
    *(_OWORD *)(v24 + 56) = xmmword_1B66A08C0;
    v26 = *v18;
    v27 = (uint64_t **)(v7 + 1104);
    if (*v18)
    {
      while (1)
      {
        while (1)
        {
          v27 = (uint64_t **)v26;
          v28 = *((_DWORD *)v26 + 8);
          if (v28 < 0xCAB)
            break;
          v26 = *v27;
          v18 = v27;
          if (!*v27)
            goto LABEL_71;
        }
        if (v28 == 3242)
          break;
        v26 = v27[1];
        if (!v26)
        {
          v18 = v27 + 1;
          goto LABEL_71;
        }
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
    }
    else
    {
LABEL_71:
      v29 = operator new(0x30uLL);
      v29[8] = 3242;
      *((_QWORD *)v29 + 5) = v24;
      std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at((uint64_t **)(v7 + 1096), (uint64_t)v27, v18, (uint64_t *)v29);
    }
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    *(_BYTE *)(v7 + 1312) = 0;
    *(_OWORD *)(v7 + 1296) = 0u;
    *(_QWORD *)(v7 + 1316) = 0xBF800000467A0000;
    *(_DWORD *)(v7 + 1324) = 1195081728;
    *(_QWORD *)(v7 + 1328) = 0x8000000800;
    *(_WORD *)(v7 + 1336) = 257;
    *(_OWORD *)(v7 + 1344) = xmmword_1B66A08D0;
    *(_BYTE *)(v7 + 1360) = 1;
    *(_OWORD *)(v7 + 1364) = xmmword_1B66A08E0;
    *(_QWORD *)(v7 + 1380) = 3;
    *(_DWORD *)(v7 + 1388) = 3;
    *(_OWORD *)(v7 + 1392) = xmmword_1B66A08F0;
    *(_OWORD *)(v7 + 1408) = xmmword_1B66A0900;
    *(_DWORD *)(v7 + 1424) = 30;
    *(_QWORD *)(v7 + 1428) = 0x3E4CCCCD3F800000;
    *(_DWORD *)(v7 + 1436) = 1056964608;
    *(_QWORD *)(v7 + 1440) = 0x100000001;
    *(_DWORD *)(v7 + 1448) = 0;
    *(_QWORD *)(v7 + 1464) = 0;
    *(_QWORD *)(v7 + 1456) = 0;
    *(_OWORD *)(v7 + 1472) = xmmword_1B66A0910;
    *(_QWORD *)(v7 + 1488) = 0xA00000003;
    *(_DWORD *)(v7 + 1496) = 2;
    *(_BYTE *)(v7 + 1500) = 1;
    *(_DWORD *)(v7 + 1504) = 1;
    *(_OWORD *)(v7 + 1508) = xmmword_1B66A0920;
    *(_BYTE *)(v7 + 1524) = 0;
    *(_QWORD *)(v7 + 1528) = 0x100000000;
    std::vector<AudioChannelLayout>::vector((_QWORD *)(v7 + 1536), 1uLL);
    v30 = *(_QWORD *)(v7 + 1536);
    *(_QWORD *)v30 = 0;
    *(_DWORD *)(v30 + 8) = 0;
    *(_OWORD *)(v7 + 1560) = 0u;
    *(_OWORD *)(v7 + 1576) = 0u;
    v31 = operator new(0xCuLL);
    *(_QWORD *)(v7 + 1568) = v31;
    *(_QWORD *)(v7 + 1584) = v31 + 3;
    *(_QWORD *)v31 = 0x100000000;
    v31[2] = 2;
    *(_QWORD *)(v7 + 1576) = v31 + 3;
    *(_BYTE *)(v7 + 1592) = 0;
    *(_QWORD *)(v7 + 1600) = 0;
    *(_DWORD *)(v7 + 1608) = 0;
    caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(v7 + 1612));
    *(_QWORD *)(v7 + 1664) = 0;
    *(_OWORD *)(v7 + 1648) = 0u;
    *(_QWORD *)(v7 + 1616) = 0;
    *(_DWORD *)(v7 + 1640) = 0;
    *(_OWORD *)(v7 + 1624) = 0u;
    *(_QWORD *)(v7 + 1680) = v7;
    *(_QWORD *)(v7 + 1688) = v7 + 1056;
    *(_QWORD *)(v7 + 1696) = (char *)this + 6336;
    v32 = (_QWORD *)operator new();
    *v32 = 0;
    v32[1] = 0;
    v32[2] = 0;
    *(_QWORD *)(v7 + 1704) = v32;
    v33 = (_QWORD *)operator new();
    *v33 = 0;
    v33[1] = 0;
    v33[2] = 0;
    *(_QWORD *)(v7 + 1712) = v33;
    caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(v7 + 1720));
    *(_BYTE *)(v7 + 1724) = 0;
    *(_OWORD *)(v7 + 1728) = 0u;
    *(_DWORD *)(v7 + 1744) = 4;
    __asm { FMOV            V1.2S, #1.0 }
    *(_QWORD *)(v7 + 1748) = _D1;
    *(_WORD *)(v7 + 1756) = 256;
    *(_OWORD *)(v7 + 1760) = xmmword_1B6629CC0;
    *(_BYTE *)(v7 + 1776) = 0;
    *(_OWORD *)(v7 + 1792) = xmmword_1B6629CC0;
    *(_BYTE *)(v7 + 1808) = 0;
    *(_OWORD *)(v7 + 1824) = xmmword_1B6629CC0;
    *(_DWORD *)(v7 + 1840) = 0;
    *(_BYTE *)(v7 + 1844) = 0;
    *(_DWORD *)(v7 + 1848) = 1056964608;
    *(_BYTE *)(v7 + 1852) = 1;
    *(_QWORD *)(v7 + 1856) = 0x23E99999ALL;
    *(_OWORD *)(v7 + 1864) = xmmword_1B66A0930;
    *(_DWORD *)(v7 + 1876) = -1082130432;
    v39 = (_QWORD *)(v7 + 1888);
    *(_OWORD *)(v7 + 1888) = 0u;
    *(_OWORD *)(v7 + 1904) = 0u;
    *(_QWORD *)(v7 + 1880) = 0xFC00C0000CLL;
    v40 = malloc_type_malloc(0x13BCuLL, 0x2C8E6D5CuLL);
    v41 = v40;
    if (!v40)
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      v94 = std::bad_alloc::bad_alloc(exception);
    }
    bzero(v40, 0x13BCuLL);
    v41[2] = 252;
    v42 = 0x3FFFFFFFFFFFFB14;
    do
    {
      v43 = &v41[v42];
      v43[1263] = -1;
      *((_OWORD *)v43 + 316) = 0uLL;
      v42 += 5;
    }
    while (v42 * 4);
    v44 = (_DWORD *)*v39;
    *v39 = v41;
    if (v44)
    {
      MEMORY[0x1BCC95CEC](v44, 0x1000C40E0EAB150);
      v41 = (_DWORD *)*v39;
    }
    AudioFormatGetProperty(0x636D706Cu, 4u, (const void *)(v7 + 1880), (UInt32 *)(v7 + 1884), v41);
    v45 = *(char **)(v7 + 1904);
    v46 = *(char **)(v7 + 1896);
    v47 = v45 - v46;
    if ((unint64_t)(v45 - v46) > 0xBF)
    {
      if (v47 == 192)
        goto LABEL_100;
      v57 = v46 + 192;
    }
    else
    {
      v48 = v47 >> 4;
      v49 = 12 - (v47 >> 4);
      v50 = *(_QWORD *)(v7 + 1912);
      if (v49 > (v50 - (uint64_t)v45) >> 4)
      {
        v51 = v50 - (_QWORD)v46;
        v52 = (v50 - (uint64_t)v46) >> 3;
        if (v52 <= 0xC)
          v52 = 12;
        if (v51 >= 0x7FFFFFFFFFFFFFF0)
          v53 = 0xFFFFFFFFFFFFFFFLL;
        else
          v53 = v52;
        if (v53 >> 60)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v54 = operator new(16 * v53);
        v55 = (char *)&v54[v48];
        do
          v54[v48++] = 0uLL;
        while (v48 != 12);
        if (v45 != v46)
        {
          do
          {
            v56 = *((_OWORD *)v45 - 1);
            v45 -= 16;
            *((_OWORD *)v55 - 1) = v56;
            v55 -= 16;
          }
          while (v45 != v46);
          v45 = *(char **)(v7 + 1896);
        }
        *(_QWORD *)(v7 + 1896) = v55;
        *(_QWORD *)(v7 + 1904) = v54 + 12;
        *(_QWORD *)(v7 + 1912) = &v54[v53];
        if (v45)
          operator delete(v45);
        goto LABEL_100;
      }
      v57 = &v45[16 * v49];
      v58 = 192 - 16 * v48;
      do
      {
        *(_OWORD *)v45 = 0uLL;
        v45 += 16;
        v58 -= 16;
      }
      while (v58);
    }
    *(_QWORD *)(v7 + 1904) = v57;
LABEL_100:
    v59 = 0;
    for (i = 0; i != 240; i += 20)
    {
      v61 = *(_QWORD *)(v7 + 1888) + i;
      v62 = *(float *)(v61 + 24) * 0.017453;
      v63 = __sincosf_stret(*(float *)(v61 + 20) * 0.017453);
      v64 = __sincosf_stret(v62);
      *(float32x2_t *)&v65 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v63.__sinval), LODWORD(v63.__cosval)), v64.__cosval);
      *((float *)&v65 + 2) = -v64.__sinval;
      *(_OWORD *)(*(_QWORD *)(v7 + 1896) + v59) = v65;
      v59 += 16;
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v66 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      std::string::basic_string[abi:ne180100]<0>(&v98, "SnapCoordinates");
      v87 = std::string::append(&v98, "::", 2uLL);
      v88 = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
      v97.__r_.__value_.__r.__words[2] = v87->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v97.__r_.__value_.__l.__data_ = v88;
      v87->__r_.__value_.__l.__size_ = 0;
      v87->__r_.__value_.__r.__words[2] = 0;
      v87->__r_.__value_.__r.__words[0] = 0;
      v89 = std::string::append(&v97, "SnapCoordinates", 0xFuLL);
      v90 = *(_OWORD *)&v89->__r_.__value_.__l.__data_;
      v103.__r_.__value_.__r.__words[2] = v89->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v103.__r_.__value_.__l.__data_ = v90;
      v89->__r_.__value_.__l.__size_ = 0;
      v89->__r_.__value_.__r.__words[2] = 0;
      v89->__r_.__value_.__r.__words[0] = 0;
      v91 = &v103;
      if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v91 = (std::string *)v103.__r_.__value_.__r.__words[0];
      v92 = *(_DWORD *)(v7 + 1880);
      *(_DWORD *)buf = 136315394;
      v100 = v91;
      v101 = 1024;
      v102 = v92;
      _os_log_debug_impl(&dword_1B5ED0000, v66, OS_LOG_TYPE_DEBUG, "%s: Snap Coordinates initialized with ACL tag %u", buf, 0x12u);
      if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v103.__r_.__value_.__l.__data_);
      if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v97.__r_.__value_.__l.__data_);
      if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v98.__r_.__value_.__l.__data_);
    }
    *(_DWORD *)(v7 + 1920) = 16843008;
    *(_OWORD *)(v7 + 1924) = xmmword_1B66A0940;
    v67 = (void **)(v7 + 1952);
    *(_QWORD *)(v7 + 1952) = 0;
    *(_QWORD *)(v7 + 1968) = 0;
    *(_QWORD *)(v7 + 1960) = 0;
    *(_BYTE *)(v7 + 1976) = 0;
    v68 = *(_QWORD *)(v7 + 1288);
    if (*(char *)(v68 + 31) >= 0)
      v69 = *(unsigned __int8 *)(v68 + 31);
    else
      v69 = *(_QWORD *)(v68 + 16);
    std::string::basic_string[abi:ne180100]((uint64_t)&v103, v69 + 15);
    if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v70 = &v103;
    else
      v70 = (std::string *)v103.__r_.__value_.__r.__words[0];
    if (v69)
    {
      if (*(char *)(v68 + 31) >= 0)
        v71 = (const void *)(v68 + 8);
      else
        v71 = *(const void **)(v68 + 8);
      memmove(v70, v71, v69);
    }
    strcpy((char *)v70 + v69, "|InputElement #");
    std::to_string(&v97, __val);
    if ((v97.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v72 = &v97;
    else
      v72 = (std::string *)v97.__r_.__value_.__r.__words[0];
    if ((v97.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v97.__r_.__value_.__r.__words[2]);
    else
      size = v97.__r_.__value_.__l.__size_;
    v74 = std::string::append(&v103, (const std::string::value_type *)v72, size);
    v75 = v74->__r_.__value_.__r.__words[0];
    v98.__r_.__value_.__r.__words[0] = v74->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v98.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v74->__r_.__value_.__r.__words[1] + 7);
    v76 = HIBYTE(v74->__r_.__value_.__r.__words[2]);
    v74->__r_.__value_.__l.__size_ = 0;
    v74->__r_.__value_.__r.__words[2] = 0;
    v74->__r_.__value_.__r.__words[0] = 0;
    if (*(char *)(v7 + 1975) < 0)
      operator delete(*v67);
    *(_QWORD *)(v7 + 1952) = v75;
    *(_QWORD *)(v7 + 1960) = v98.__r_.__value_.__r.__words[0];
    *(_QWORD *)(v7 + 1967) = *(std::string::size_type *)((char *)v98.__r_.__value_.__r.__words + 7);
    *(_BYTE *)(v7 + 1975) = v76;
    if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v97.__r_.__value_.__l.__data_);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 40))(v7, 41);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 1u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 2u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 3u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 6u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 7u, 10.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 4u, 1.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 5u, 1.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 8u, 30.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0xAu, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0xBu, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x16u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x17u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x18u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x19u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x1Au, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x1Bu, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x1Cu, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x1Du, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x1Eu, -1.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x1Fu, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x20u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x21u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x22u, 1.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x23u, 50.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x27u, 0.0, 0);
    ausdk::AUElement::SetParameter((ausdk::AUElement *)v7, 0x28u, 45.0, 0);
    *(_WORD *)(v7 + 632) = 0;
    v77 = (AUSM::MatrixMix *)operator new();
    if (*(char *)(v7 + 1975) < 0)
    {
      std::string::__init_copy_ctor_external(&v103, (const std::string::value_type *)*v67, *(_QWORD *)(v7 + 1960));
    }
    else
    {
      *(_OWORD *)&v103.__r_.__value_.__l.__data_ = *(_OWORD *)v67;
      v103.__r_.__value_.__r.__words[2] = *(_QWORD *)(v7 + 1968);
    }
    AUSM::MatrixMix::MatrixMix((uint64_t)v77, (const void **)&v103.__r_.__value_.__l.__data_);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    std::unique_ptr<AUSM::MatrixMix>::reset[abi:ne180100]((AUSM::MatrixMix **)(v7 + 1296), v77);
    v78 = (char *)operator new(0x48uLL);
    *((_QWORD *)v78 + 1) = 0;
    *((_QWORD *)v78 + 2) = 0;
    *(_QWORD *)v78 = &off_1E69D1E38;
    *(_OWORD *)(v78 + 40) = 0u;
    *(_OWORD *)(v78 + 49) = 0u;
    *(_OWORD *)(v78 + 24) = 0u;
    v78[65] = 1;
    v103.__r_.__value_.__r.__words[0] = (std::string::size_type)(v78 + 24);
    v103.__r_.__value_.__l.__size_ = (std::string::size_type)v78;
    std::shared_ptr<vp::xml::_xmlNode const>::operator=[abi:ne180100](v7 + 272, (__int128 *)&v103);
    v79 = (std::__shared_weak_count *)v103.__r_.__value_.__l.__size_;
    if (v103.__r_.__value_.__l.__size_)
    {
      v80 = (unint64_t *)(v103.__r_.__value_.__l.__size_ + 8);
      do
        v81 = __ldaxr(v80);
      while (__stlxr(v81 - 1, v80));
      if (!v81)
      {
        ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
        std::__shared_weak_count::__release_weak(v79);
      }
    }
    v82 = (char *)operator new(0x48uLL);
    *((_QWORD *)v82 + 1) = 0;
    *((_QWORD *)v82 + 2) = 0;
    *(_QWORD *)v82 = &off_1E69D1E38;
    *(_OWORD *)(v82 + 40) = 0u;
    *(_OWORD *)(v82 + 49) = 0u;
    *(_OWORD *)(v82 + 24) = 0u;
    v82[65] = 1;
    v103.__r_.__value_.__r.__words[0] = (std::string::size_type)(v82 + 24);
    v103.__r_.__value_.__l.__size_ = (std::string::size_type)v82;
    std::shared_ptr<vp::xml::_xmlNode const>::operator=[abi:ne180100](v7 + 288, (__int128 *)&v103);
    v83 = (std::__shared_weak_count *)v103.__r_.__value_.__l.__size_;
    if (v103.__r_.__value_.__l.__size_)
    {
      v84 = (unint64_t *)(v103.__r_.__value_.__l.__size_ + 8);
      do
        v85 = __ldaxr(v84);
      while (__stlxr(v85 - 1, v84));
      if (!v85)
      {
        ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
        std::__shared_weak_count::__release_weak(v83);
      }
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v86 = getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(v7 + 1975) < 0)
        v67 = (void **)*v67;
      LODWORD(v103.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)v103.__r_.__value_.__r.__words + 4) = (std::string::size_type)v67;
      WORD2(v103.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v103.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"AUSpatialMixerV2InputElement";
      _os_log_debug_impl(&dword_1B5ED0000, v86, OS_LOG_TYPE_DEBUG, "[%s|%s] Constructed", (uint8_t *)&v103, 0x16u);
    }
    *a4 = v7;
    return;
  }
  v12 = operator new();
  ausdk::AUOutputElement::AUOutputElement((ausdk::AUOutputElement *)v12, this);
  *(_QWORD *)(v12 + 176) = &unk_1E69C7EB0;
  *(_QWORD *)v12 = off_1E69C7E08;
  *(_QWORD *)(v12 + 184) = this;
  *(_DWORD *)(v12 + 192) = 1065353216;
  *(_WORD *)(v12 + 196) = 0;
  *(_QWORD *)(v12 + 200) = 0;
  v13 = (void **)(v12 + 200);
  *(_QWORD *)(v12 + 208) = 0;
  *(_QWORD *)(v12 + 216) = 0;
  AUSM::Properties::Properties(v12 + 224, v12 + 176, 2, 0, (__int128 *)((char *)this + 3592));
  *(_QWORD *)(v12 + 224) = &off_1E69E0728;
  *(_DWORD *)(v12 + 296) = -65536;
  *(_QWORD *)(v12 + 304) = (char *)this + 3584;
  std::string::basic_string[abi:ne180100]<0>(&v103, "default audio channel layout tag");
  AUSM::Properties::addPropertyMapEntry<unsigned int>(v12 + 224, 0xC94u, v12 + 296, (__int128 *)&v103, 1, 0, 1);
  if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v103.__r_.__value_.__l.__data_);
  v14 = *(_QWORD *)(v12 + 304);
  if (*(char *)(v14 + 31) >= 0)
    v15 = *(unsigned __int8 *)(v14 + 31);
  else
    v15 = *(_QWORD *)(v14 + 16);
  v16 = &v103;
  std::string::basic_string[abi:ne180100]((uint64_t)&v103, v15 + 14);
  if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v16 = (std::string *)v103.__r_.__value_.__r.__words[0];
  if (v15)
  {
    if (*(char *)(v14 + 31) >= 0)
      v17 = (const void *)(v14 + 8);
    else
      v17 = *(const void **)(v14 + 8);
    memmove(v16, v17, v15);
  }
  strcpy((char *)v16 + v15, "|OutputElement");
  if (*(char *)(v12 + 223) < 0)
    operator delete(*v13);
  *(_OWORD *)v13 = *(_OWORD *)&v103.__r_.__value_.__l.__data_;
  *(_QWORD *)(v12 + 216) = *((_QWORD *)&v103.__r_.__value_.__l + 2);
  CAAudioChannelLayout::CAAudioChannelLayout((CAAudioChannelLayout *)&v103, 6619138);
  (*(void (**)(uint64_t, std::string::size_type))(*(_QWORD *)v12 + 88))(v12, v103.__r_.__value_.__r.__words[0] + 16);
  CAAudioChannelLayout::~CAAudioChannelLayout((unsigned int **)&v103);
  ausdk::AUElement::SetParameter((ausdk::AUElement *)v12, 3u, 0.0, 0);
  *a4 = v12;
}

void sub_1B61969EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFTypeRef *a11, void *a12, void **a13, IR::IRDataAttributes *a14, IR::IRDataAttributes *a15, void **a16, void **a17, std::mutex *a18, CFTypeRef *a19, AUSM::MatrixMix **a20,uint64_t a21,uint64_t a22,uint64_t a23,_QWORD *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  void **v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t *v43;
  uint64_t v44;
  _QWORD *v45;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  void *v52;
  const void *v53;
  void *v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  void *v60;
  void *v61;
  _QWORD *v62;
  void *v63;

  MEMORY[0x1BCC95CEC](v44, 0x10B2C404DE30388);
  if (*(char *)(v41 + 1975) < 0)
    operator delete(*v40);
  v47 = *(void **)(v41 + 1896);
  if (v47)
  {
    *(_QWORD *)(v41 + 1904) = v47;
    operator delete(v47);
  }
  v48 = *v42;
  *v42 = 0;
  if (v48)
    MEMORY[0x1BCC95CEC](v48, 0x1000C40E0EAB150);
  v49 = *(_QWORD *)(v41 + 1712);
  *(_QWORD *)(v41 + 1712) = 0;
  if (v49)
    std::default_delete<std::vector<AUSM::ExclusionZone>>::operator()[abi:ne180100](v49);
  v50 = *(_QWORD *)(v41 + 1704);
  *(_QWORD *)(v41 + 1704) = 0;
  if (v50)
    std::default_delete<std::vector<AUSM::ExclusionZone>>::operator()[abi:ne180100](v50);
  __p = (void *)(v41 + 1648);
  std::vector<std::unique_ptr<IR::FixedIntegerDelay>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  __p = a12;
  std::vector<std::unique_ptr<IR::FixedIntegerDelay>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  v51 = *(void **)(v41 + 1568);
  if (v51)
  {
    *(_QWORD *)(v41 + 1576) = v51;
    operator delete(v51);
  }
  std::unique_ptr<ScottyLite>::reset[abi:ne180100](v43, 0);
  v52 = *a13;
  if (*a13)
  {
    *(_QWORD *)(v41 + 1544) = v52;
    operator delete(v52);
  }
  v53 = *(const void **)(v41 + 1464);
  if (v53)
    CFRelease(v53);
  if (*a11)
    CFRelease(*a11);
  std::unique_ptr<ParametricProcessor>::reset[abi:ne180100]((ParametricProcessor **)(v41 + 1304), 0);
  std::unique_ptr<AUSM::MatrixMix>::reset[abi:ne180100](a20, 0);
  *v45 = &off_1E69D1D98;
  std::mutex::~mutex(a18);
  if (*a19)
    CFRelease(*a19);
  *(_QWORD *)(v41 + 1056) = &off_1E69E0768;
  std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(*(_QWORD **)(v41 + 1104));
  if (*(char *)(v41 + 1087) < 0)
    operator delete(*(void **)(v41 + 1064));
  IR::IRDataAttributes::~IRDataAttributes(a14);
  IR::IRDataAttributes::~IRDataAttributes(a15);
  v54 = *a16;
  if (*a16)
  {
    *(_QWORD *)(v41 + 400) = v54;
    operator delete(v54);
  }
  v55 = *(_QWORD *)(v41 + 376);
  *(_QWORD *)(v41 + 376) = 0;
  if (v55)
    std::default_delete<std::vector<float>>::operator()[abi:ne180100](v55);
  v56 = (uint64_t *)(v41 + 360);
  v57 = *(_QWORD *)(v41 + 368);
  *(_QWORD *)(v41 + 368) = 0;
  if (v57)
    std::default_delete<std::vector<float>>::operator()[abi:ne180100](v57);
  v58 = *v56;
  *v56 = 0;
  if (v58)
    std::default_delete<HOA::RotationMatrix>::operator()[abi:ne180100](v58);
  v59 = *(void **)(v41 + 328);
  if (v59)
  {
    *(_QWORD *)(v41 + 336) = v59;
    operator delete(v59);
  }
  v60 = *(void **)(v41 + 304);
  if (v60)
  {
    *(_QWORD *)(v41 + 312) = v60;
    operator delete(v60);
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](a22);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](a23);
  __p = (void *)(v41 + 248);
  std::vector<std::unique_ptr<AUSpatialMixerV2ChannelProcessor>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  v61 = *a17;
  if (*a17)
  {
    *(_QWORD *)(v41 + 232) = v61;
    operator delete(v61);
  }
  *(_QWORD *)v41 = off_1E69ED7C0;
  v62 = *(_QWORD **)(v41 + 152);
  if (v62)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v62);
    *(_QWORD *)(v41 + 152) = 0;
  }
  *(_QWORD *)(v41 + 160) = 0;
  *(_DWORD *)(v41 + 144) = 0;
  v63 = *(void **)(v41 + 120);
  if (v63)
  {
    *(_QWORD *)(v41 + 128) = v63;
    operator delete(v63);
  }
  ausdk::AUElement::~AUElement((const void **)v41);
  MEMORY[0x1BCC95CEC](v41, 0x10F3C408666F8D7);
  *a24 = 0;
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::GetAudioChannelLayout(AUSpatialMixerV2 *this, unsigned int a2, unsigned int a3, AudioChannelLayout *a4, BOOL *a5)
{
  ausdk::AUScope *Scope;
  uint64_t IOElement;

  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a2);
  IOElement = ausdk::AUScope::GetIOElement(Scope, a3);
  return (*(uint64_t (**)(uint64_t, AudioChannelLayout *, BOOL *))(*(_QWORD *)IOElement + 96))(IOElement, a4, a5);
}

uint64_t AUSpatialMixerV2::SetAudioChannelLayout(AUSpatialMixerV2 *this, int a2, unsigned int a3, AudioChannelLayout *a4)
{
  NSObject *v8;
  NSObject *v9;
  _QWORD *v10;
  std::string *p_p;
  AudioChannelLayoutTag mChannelLayoutTag;
  _BOOL4 v13;
  AUSpatialMixerV2OutputElement *Element;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  _QWORD *v19;
  std::string *v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  _QWORD *v25;
  _QWORD *v26;
  NSObject *v27;
  _QWORD *v28;
  NSObject *v29;
  _QWORD *v30;
  NSObject *v31;
  _QWORD *v32;
  char *v33;
  char v34;
  std::string __p;
  uint8_t buf[4];
  _QWORD *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  _QWORD v41[3];

  v41[2] = *MEMORY[0x1E0C80C00];
  if (a2 != 1)
  {
    if (a2 != 2)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v27 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        v28 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v28 = (_QWORD *)*v28;
        *(_DWORD *)buf = 136315650;
        v37 = v28;
        v38 = 2080;
        v39 = "SetAudioChannelLayout";
        v40 = 1024;
        LODWORD(v41[0]) = a2;
        _os_log_error_impl(&dword_1B5ED0000, v27, OS_LOG_TYPE_ERROR, "[%s|%s] invalid scope %u", buf, 0x1Cu);
      }

      ausdk::Throw((ausdk *)0xFFFFD58ELL);
    }
    if (a3)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v29 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        v30 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v30 = (_QWORD *)*v30;
        *(_DWORD *)buf = 136315650;
        v37 = v30;
        v38 = 2080;
        v39 = "SetAudioChannelLayout";
        v40 = 1024;
        LODWORD(v41[0]) = a3;
        _os_log_error_impl(&dword_1B5ED0000, v29, OS_LOG_TYPE_ERROR, "[%s|%s] [OutputElement] Invalid element %u", buf, 0x1Cu);
      }

      ausdk::Throw((ausdk *)0xFFFFD583);
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v8 = (id)getAUSMV2Log(void)::gLog;
    v9 = v8;
    if (a4)
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v10 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v10 = (_QWORD *)*v10;
        PrintAudioChannelLayout(&__p, (int *)a4);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)buf = 136315650;
        v37 = v10;
        v38 = 2080;
        v39 = "SetAudioChannelLayout";
        v40 = 2080;
        v41[0] = p_p;
        _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEFAULT, "[%s|%s] [OutputElement] Setting audio channel layout %s", buf, 0x20u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }

      mChannelLayoutTag = a4->mChannelLayoutTag;
      v13 = (a4->mChannelLayoutTag & 0xFFFEFFFF) == 0;
      Element = (AUSpatialMixerV2OutputElement *)ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
      if (v13)
        v15 = AUSpatialMixerV2OutputElement::SetFullLayout(Element, a4, 0);
      else
        v15 = AUSpatialMixerV2OutputElement::SetFullLayoutFromTag(Element, mChannelLayoutTag, 0);
      v22 = v15;
      if (!(_DWORD)v15)
        atomic_store(1u, (unsigned __int8 *)this + 3242);
      return v22;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v25 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v25 = (_QWORD *)*v25;
      *(_DWORD *)buf = 136315394;
      v37 = v25;
      v38 = 2080;
      v39 = "SetAudioChannelLayout";
      _os_log_error_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_ERROR, "[%s|%s] [OutputElement] Error setting audio channel layout: null layout pointer", buf, 0x16u);
    }

    return 4294956445;
  }
  v33 = (char *)this + 3352;
  v34 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
  v16 = *((_QWORD *)this + 15);
  if (v16)
    LODWORD(v17) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  else
    v17 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  if (v17 <= a3)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v31 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v32 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v32 = (_QWORD *)*v32;
      *(_DWORD *)buf = 136315650;
      v37 = v32;
      v38 = 2080;
      v39 = "SetAudioChannelLayout";
      v40 = 1024;
      LODWORD(v41[0]) = a3;
      _os_log_error_impl(&dword_1B5ED0000, v31, OS_LOG_TYPE_ERROR, "[%s|%s] [InputElement #%u] Invalid element", buf, 0x1Cu);
    }

    ausdk::Throw((ausdk *)0xFFFFD583);
  }
  if (!a4)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v23 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v26 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v26 = (_QWORD *)*v26;
      *(_DWORD *)buf = 136315650;
      v37 = v26;
      v38 = 2080;
      v39 = "SetAudioChannelLayout";
      v40 = 1024;
      LODWORD(v41[0]) = a3;
      _os_log_error_impl(&dword_1B5ED0000, v23, OS_LOG_TYPE_ERROR, "[%s|%s] [InputElement #%u] Error setting audio channel layout: null layout pointer", buf, 0x1Cu);
    }

    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v33);
    return 4294956445;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v18 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    v19 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v19 = (_QWORD *)*v19;
    PrintAudioChannelLayout(&__p, (int *)a4);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v20 = &__p;
    else
      v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315906;
    v37 = v19;
    v38 = 2080;
    v39 = "SetAudioChannelLayout";
    v40 = 1024;
    LODWORD(v41[0]) = a3;
    WORD2(v41[0]) = 2080;
    *(_QWORD *)((char *)v41 + 6) = v20;
    _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEFAULT, "[%s|%s] [InputElement #%u] Setting audio channel layout %s", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }

  v21 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), a3);
  v22 = (*(uint64_t (**)(uint64_t, AudioChannelLayout *))(*(_QWORD *)v21 + 88))(v21, a4);
  if (!(_DWORD)v22)
    atomic_store(1u, (unsigned __int8 *)this + 3242);
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v33);
  return v22;
}

void sub_1B6197630(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);

  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL AUSpatialMixerV2::ValidInputFormat(uint64_t a1, _DWORD *a2)
{
  int v2;
  int v4;
  int v5;
  unsigned int v6;
  int v7;

  v2 = a2[2];
  if (v2 != 1885564203 && v2 != 1819304813)
    return 0;
  if (a2[5] != 1)
    return 0;
  v4 = a2[4];
  if (v4 != a2[6])
    return 0;
  v5 = a2[3];
  if ((v5 & 2) != 0)
    return 0;
  v6 = a2[8];
  if ((v5 & 1) != 0)
  {
    if (v6 == 32)
      goto LABEL_12;
    return 0;
  }
  if (v6 != 16 && v6 != 8)
    return 0;
LABEL_12:
  if ((v5 & 0x20) != 0)
    v7 = 1;
  else
    v7 = a2[7];
  return v4 == (v6 >> 3) * v7;
}

BOOL AUSpatialMixerV2::ValidOutputFormat(uint64_t a1, _DWORD *a2)
{
  int v3;
  _BOOL8 result;
  unsigned int v5;
  int v6;
  unsigned int v7;
  BOOL v8;
  int v9;

  if (a2[2] != 1819304813 || a2[5] != 1)
    return 0;
  v3 = a2[4];
  if (v3 != a2[6])
    return 0;
  result = 0;
  v5 = a2[3];
  v6 = (v5 >> 5) & 1;
  v7 = a2[8];
  if (v7 == 16)
    v6 = 1;
  if ((v5 & 2) == 0 && v6)
  {
    v8 = v7 == 32;
    if ((v5 & 1) == 0)
    {
      if (v7 == 32)
      {
LABEL_16:
        if ((v5 & 0x20) != 0)
          v9 = 1;
        else
          v9 = a2[7];
        return v3 == v9 * (v7 >> 3);
      }
      v8 = v7 == 16;
    }
    if (!v8)
      return 0;
    goto LABEL_16;
  }
  return result;
}

uint64_t AUSpatialMixerV2::PropertyChanged(AUSpatialMixerV2 *this, uint64_t a2)
{
  AUSpatialMixerV2 *v3;
  char v4;
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  char *v8;
  char *v9;
  char *v10;
  IR::IRDataLoader *v11;
  CFTypeRef v12;
  int v13;
  _BOOL4 v14;
  NSObject *v15;
  _QWORD *v16;
  unsigned int v17;
  unsigned __int8 v18;
  int v19;
  char *v20;
  char *v21;
  char *v22;
  IR::IRDataLoader *v23;
  CFTypeRef v24;
  int v25;
  _BOOL4 v26;
  NSObject *v27;
  _QWORD *v28;
  IR::IRDataLoader *v29;
  const void *v30;
  int AudioChannelLayoutTag;
  _BOOL4 IsSupportedHOA;
  NSObject *v33;
  _QWORD *v34;
  IR::IRDataLoader *v35;
  const void *v36;
  int v37;
  _BOOL4 v38;
  NSObject *v39;
  _QWORD *v40;
  int v41;
  int DynamicProcessorPreset;
  unsigned __int8 *v43;
  unsigned __int8 v44;
  const void *v45;
  BOOL v46;
  unsigned int v47;
  unsigned int v49;
  unsigned int *v50;
  unsigned int v51;
  int v52;
  int v53;
  unsigned __int8 v54;
  unsigned __int8 v55;
  unsigned __int128 *v56;
  unsigned __int8 v57;
  _BOOL8 IsSupportedPersonalizedHRTF;
  unsigned __int8 v59;
  void *v60;
  unsigned __int128 *v61;
  unsigned __int128 v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  unsigned int v65;
  unsigned __int8 v66;
  unsigned __int8 v67;
  unsigned __int8 v68;
  float v69;
  float v70;
  float v71;
  unsigned __int8 v72;
  unsigned int i;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  unsigned int v77;
  CFTypeRef v78;
  unsigned int v79;
  unsigned int v80;
  CFTypeRef v81;
  unsigned __int8 v82;
  ParametricFilters *v83;
  unsigned __int128 *v84;
  unsigned __int128 v85;
  float32x4_t v86;
  unsigned __int128 *v87;
  uint64_t v88;
  uint64_t v89;
  unsigned __int128 v90;
  __float2 *v91;
  float v92;
  float v93;
  float v94;
  unsigned __int8 v95;
  uint64_t v96;
  CFDictionaryRef *v97;
  unsigned __int8 v98;
  unsigned __int8 v99;
  unsigned __int8 v100;
  unsigned __int8 v101;
  char v102;
  unsigned __int8 v103;
  int v104;
  unsigned __int8 v105;
  float *v106;
  unsigned __int128 *v107;
  unsigned __int128 v108;
  NSObject *v109;
  _QWORD *v110;
  unsigned __int8 v111;
  IR::IRDataLoader *v113;
  unsigned __int128 *v114;
  unsigned __int128 v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  uint64_t v121;
  ausdk::AUElement *v122;
  unsigned __int8 v123;
  unsigned int v124;
  unsigned __int8 v125;
  unsigned __int8 v126;
  unsigned int v127;
  unsigned __int8 v128;
  unsigned __int8 v129;
  void (*v130)(uint64_t, _QWORD *);
  void *v131;
  uint64_t v132;
  unsigned __int8 v133;
  uint64_t v134;
  uint64_t v135;
  unsigned int v136;
  ausdk::AUElement **v138;
  ausdk::AUElement **v139;
  NSObject *v140;
  _QWORD *v141;
  IR::IRDataLoader *v142;
  unsigned __int128 *v143;
  uint64_t v144;
  ausdk::AUElement *v145;
  ausdk::AUElement **v146;
  uint64_t v147;
  ausdk::AUElement *v148;
  ausdk::AUElement **v149;
  uint64_t v150;
  ausdk::AUElement *v151;
  ausdk::AUElement **v152;
  uint64_t v153;
  ausdk::AUElement *v154;
  ausdk::AUElement **v155;
  unsigned __int128 v156;
  NSObject *v157;
  _QWORD *v158;
  unsigned __int128 v159;
  unsigned __int128 *v160;
  unsigned __int128 v161;
  float32x4_t v162;
  int32x4_t v163;
  int8x16_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  int8x16_t v168;
  float32x2_t v169;
  float32x4_t v170;
  unsigned __int32 v171;
  float32x2_t v172;
  float32x2_t v173;
  float32x4_t v174;
  int8x16_t v175;
  float32x2_t v176;
  float32x2_t v177;
  float v178;
  uint64_t v179;
  _QWORD *v180;
  uint64_t v181;
  ParametricFilters *v182;
  const void *v184;
  const void *v185;
  const void *v186;
  const void *v187;
  const void *v188;
  const void *v189;
  const void *v190;
  const void *v191;
  const void *v192[2];
  const void *v193[2];
  const void *v194;
  const void *v195[2];
  const void *v196;
  const void *v197[2];
  const void *v198;
  CFTypeRef v199;
  const void *v200;
  _QWORD v201[7];
  char v202;
  void *__p;
  char v204;
  void *v205;
  char v206;
  const void *v207;
  const void *v208;
  const void *v209;
  _QWORD v210[3];
  _QWORD *v211;
  uint8_t buf[24];
  double v213;
  __int16 v214;
  double v215;
  __int16 v216;
  double v217;
  __int16 v218;
  double v219;
  __int16 v220;
  double v221;
  __int16 v222;
  double v223;
  __int16 v224;
  double v225;
  CFTypeRef v226;
  CFTypeRef v227;
  char v228;
  char v229;
  uint64_t v230;

  v3 = this;
  v4 = 0;
  v230 = *MEMORY[0x1E0C80C00];
  v5 = (unsigned __int8 *)this + 5080;
  if ((int)a2 > 3199)
  {
    v6 = 0;
    switch((int)a2)
    {
      case 3200:
      case 3201:
        if (atomic_load((unsigned int *)this + 1273))
        {
          v49 = atomic_load((unsigned int *)this + 1274);
          if (v49 == 1)
          {
            v50 = (unsigned int *)((char *)this + 6072);
            v51 = 1;
          }
          else
          {
            v50 = (unsigned int *)((char *)this + 6072);
            v51 = 2;
          }
          atomic_store(v51, v50);
        }
        else
        {
          atomic_store(0, (unsigned int *)this + 1518);
        }
        v133 = atomic_load((unsigned __int8 *)this + 7442);
        if ((v133 & 1) == 0)
          goto LABEL_319;
        v6 = AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements(this, a2);
        v134 = *((_QWORD *)v3 + 51);
        v135 = *((_QWORD *)v3 + 52);
        while (v134 != v135)
        {
          if (*(_DWORD *)v134 == 3116)
            (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(v134 + 8))(*(_QWORD *)(v134 + 16), *((_QWORD *)v3 + 1), 3116, 0, 0);
          v134 += 24;
        }
        AUSpatialMixerV2::ReloadFactoryPresetIfNecessary(v3);
        v136 = atomic_load((unsigned int *)v3 + 918);
        if (v136 == 1)
          AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)v3, -1, 1, 1);
        return v6;
      case 3202:
      case 3203:
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(buf, (uint64_t)this + 3904);
        v44 = atomic_load(v5 + 2361);
        if ((v44 & 1) == 0
          || (v45 = *(const void **)buf) != 0
          && (AUSpatialMixerV2::RefreshXTCTuningParameters(v3),
              applesauce::CF::URLRef::URLRef((applesauce::CF::URLRef *)&v200, v45),
              v46 = AUSpatialMixerV2::InitializeDynamicXTC((uint64_t)v3, (CFURLRef *)&v200),
              applesauce::CF::URLRef::~URLRef(&v200),
              v46)
          || (v47 = atomic_load((unsigned int *)v3 + 918), v47 != 2))
        {
          v4 = 0;
          v6 = 0;
        }
        else
        {
          AUSpatialMixerV2::UpdateCounteractRotationShader(v3);
          v6 = AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements(v3, a2);
          v4 = 1;
          AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)v3, -1, 1, 0);
        }
        if (*(_QWORD *)buf)
          CFRelease(*(CFTypeRef *)buf);
        goto LABEL_320;
      case 3204:
      case 3205:
      case 3210:
      case 3211:
      case 3212:
      case 3213:
      case 3214:
      case 3215:
      case 3216:
      case 3217:
      case 3218:
      case 3219:
      case 3220:
      case 3221:
      case 3222:
      case 3224:
      case 3225:
      case 3226:
      case 3227:
      case 3228:
      case 3229:
      case 3230:
      case 3232:
      case 3236:
      case 3242:
      case 3244:
      case 3250:
      case 3251:
      case 3253:
      case 3255:
      case 3256:
      case 3257:
      case 3258:
      case 3268:
      case 3269:
      case 3270:
      case 3271:
      case 3272:
      case 3273:
      case 3274:
      case 3275:
      case 3276:
      case 3277:
      case 3278:
        goto LABEL_320;
      case 3206:
      case 3207:
      case 3259:
      case 3260:
        v7 = a2 & 0xFFFFFFFE;
        if ((a2 & 0xFFFFFFFE) == 0xC86)
          v8 = (char *)this + 4264;
        else
          v8 = (char *)this + 4336;
        if (v7 == 3206)
          v9 = (char *)this + 4120;
        else
          v9 = (char *)this + 4192;
        if (v7 == 3206)
          v10 = (char *)this + 3976;
        else
          v10 = (char *)this + 4048;
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v199, (uint64_t)v10);
        v198 = 0;
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v8, &v198);
        v12 = v199;
        if (v199
          && (IR::IRDataLoader::instance(v11),
              CFRetain(v12),
              v197[1] = v12,
              v13 = IR::IRDataLoader::getAudioChannelLayoutTag(),
              v14 = ChannelLayoutTagIsSupportedHOA(v13),
              CFRelease(v12),
              v14))
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v15 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            v16 = (_QWORD *)((char *)v3 + 3592);
            if (*((char *)v3 + 3615) < 0)
              v16 = (_QWORD *)*v16;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "PropertyChanged";
            _os_log_impl(&dword_1B5ED0000, v15, OS_LOG_TYPE_DEFAULT, "[%s|%s] Early reflections IR is HOA: updating late reverb to use same IR file", buf, 0x16u);
          }

          CFRetain(v12);
          v197[0] = v12;
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v9, v197);
          CFRelease(v12);
        }
        else
        {
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v196, (uint64_t)v9);
          v30 = v196;
          if (v196)
          {
            IR::IRDataLoader::instance(v29);
            CFRetain(v30);
            v195[1] = v30;
            AudioChannelLayoutTag = IR::IRDataLoader::getAudioChannelLayoutTag();
            IsSupportedHOA = ChannelLayoutTagIsSupportedHOA(AudioChannelLayoutTag);
            CFRelease(v30);
            if (IsSupportedHOA)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v33 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
              {
                v34 = (_QWORD *)((char *)v3 + 3592);
                if (*((char *)v3 + 3615) < 0)
                  v34 = (_QWORD *)*v34;
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = v34;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "PropertyChanged";
                _os_log_impl(&dword_1B5ED0000, v33, OS_LOG_TYPE_DEFAULT, "[%s|%s] Clearing late reverb HOA IR", buf, 0x16u);
              }

              v195[0] = 0;
              AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v9, v195);
              applesauce::CF::URLRef::~URLRef(v195);
            }
            CFRelease(v30);
          }
        }
        if (v7 == 3206
          || (std::recursive_mutex::lock((std::recursive_mutex *)v3 + 11),
              v52 = *((unsigned __int8 *)v3 + 696),
              std::recursive_mutex::unlock((std::recursive_mutex *)v3 + 11),
              !v52))
        {
          AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)v3, -1, 1, 0);
        }
        if (v12)
          CFRelease(v12);
        goto LABEL_319;
      case 3208:
      case 3209:
      case 3261:
      case 3262:
        v19 = a2 & 0xFFFFFFFE;
        if ((a2 & 0xFFFFFFFE) == 0xC88)
          v20 = (char *)this + 4264;
        else
          v20 = (char *)this + 4336;
        if (v19 == 3208)
          v21 = (char *)this + 3976;
        else
          v21 = (char *)this + 4048;
        if (v19 == 3208)
          v22 = (char *)this + 4120;
        else
          v22 = (char *)this + 4192;
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v199, (uint64_t)v22);
        v194 = 0;
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v20, &v194);
        v24 = v199;
        if (v199
          && (IR::IRDataLoader::instance(v23),
              CFRetain(v24),
              v193[1] = v24,
              v25 = IR::IRDataLoader::getAudioChannelLayoutTag(),
              v26 = ChannelLayoutTagIsSupportedHOA(v25),
              CFRelease(v24),
              v26))
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v27 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            v28 = (_QWORD *)((char *)v3 + 3592);
            if (*((char *)v3 + 3615) < 0)
              v28 = (_QWORD *)*v28;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v28;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "PropertyChanged";
            _os_log_impl(&dword_1B5ED0000, v27, OS_LOG_TYPE_DEFAULT, "[%s|%s] Late IR is HOA: updating early reflections to use same IR file", buf, 0x16u);
          }

          CFRetain(v24);
          v193[0] = v24;
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v21, v193);
          CFRelease(v24);
        }
        else
        {
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v196, (uint64_t)v21);
          v36 = v196;
          if (v196)
          {
            IR::IRDataLoader::instance(v35);
            CFRetain(v36);
            v192[1] = v36;
            v37 = IR::IRDataLoader::getAudioChannelLayoutTag();
            v38 = ChannelLayoutTagIsSupportedHOA(v37);
            CFRelease(v36);
            if (v38)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v39 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                v40 = (_QWORD *)((char *)v3 + 3592);
                if (*((char *)v3 + 3615) < 0)
                  v40 = (_QWORD *)*v40;
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = v40;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "PropertyChanged";
                _os_log_impl(&dword_1B5ED0000, v39, OS_LOG_TYPE_DEFAULT, "[%s|%s] Clearing early reflections HOA IR", buf, 0x16u);
              }

              v192[0] = 0;
              AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v21, v192);
              applesauce::CF::URLRef::~URLRef(v192);
            }
            CFRelease(v36);
          }
        }
        if (v19 == 3208
          || (std::recursive_mutex::lock((std::recursive_mutex *)v3 + 11),
              v53 = *((unsigned __int8 *)v3 + 696),
              std::recursive_mutex::unlock((std::recursive_mutex *)v3 + 11),
              !v53))
        {
          AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)v3, -1, 1, 0);
        }
        if (v24)
          CFRelease(v24);
        goto LABEL_319;
      case 3223:
      case 3265:
        v6 = 0;
        v43 = (unsigned __int8 *)this + 7365;
        goto LABEL_269;
      case 3231:
        v68 = atomic_load((unsigned __int8 *)this + 7441);
        if ((v68 & 1) != 0)
          return 4294956447;
        caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3304);
        AUSM::TuningManager::ResetReservedGlobalAPACPropertyList((AUSpatialMixerV2 *)((char *)v3 + 6160));
        v6 = AUSM::Metadata::ingestImmersiveRendererData(*((_QWORD *)v3 + 96));
        caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)v3 + 3304);
LABEL_126:
        v4 = 0;
        goto LABEL_320;
      case 3233:
        goto LABEL_100;
      case 3234:
        v66 = atomic_load((unsigned __int8 *)this + 5088);
        if ((v66 & 1) == 0 || (v67 = atomic_load((unsigned __int8 *)this + 5089), (v67 & 1) != 0))
          AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener((AUSpatialMixerV2 *)((char *)this + 7408));
        else
          AudioDSP::Core::HeadTracker::RegisterUserChoiceListener((AUSpatialMixerV2 *)((char *)this + 7408));
        goto LABEL_319;
      case 3235:
        atomic_store(1u, (unsigned __int8 *)this + 7361);
        v84 = (unsigned __int128 *)((char *)this + 3696);
        do
          v85 = __ldaxp(v84);
        while (__stlxp(v85, v84));
        v86 = (float32x4_t)v85;
        v87 = (unsigned __int128 *)((char *)this + 3712);
        do
        {
          v90 = __ldaxp(v87);
          v88 = *((_QWORD *)&v90 + 1);
          v89 = v90;
        }
        while (__stlxp(v90, v87));
        goto LABEL_293;
      case 3237:
        v61 = (unsigned __int128 *)((char *)this + 3728);
        do
          v62 = __ldaxp(v61);
        while (__stlxp(v62, v61));
        v63 = *((_QWORD *)this + 9);
        if (v63)
        {
          v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v63 + 32))(v63, 0);
        }
        else
        {
          v138 = (ausdk::AUElement **)*((_QWORD *)v3 + 6);
          if (*((ausdk::AUElement ***)v3 + 7) == v138)
            v64 = 0;
          else
            v64 = *v138;
        }
        ausdk::AUElement::SetParameter(v64, 0x24u, *(float *)&v62, 0);
        v144 = *((_QWORD *)v3 + 9);
        if (v144)
        {
          v145 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v144 + 32))(v144, 0);
        }
        else
        {
          v146 = (ausdk::AUElement **)*((_QWORD *)v3 + 6);
          if (*((ausdk::AUElement ***)v3 + 7) == v146)
            v145 = 0;
          else
            v145 = *v146;
        }
        ausdk::AUElement::SetParameter(v145, 0x25u, *((float *)&v62 + 1), 0);
        v147 = *((_QWORD *)v3 + 9);
        if (v147)
        {
          v148 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v147 + 32))(v147, 0);
        }
        else
        {
          v149 = (ausdk::AUElement **)*((_QWORD *)v3 + 6);
          if (*((ausdk::AUElement ***)v3 + 7) == v149)
            v148 = 0;
          else
            v148 = *v149;
        }
        ausdk::AUElement::SetParameter(v148, 0x26u, *((float *)&v62 + 2), 0);
        goto LABEL_268;
      case 3238:
LABEL_268:
        v6 = 0;
        v43 = v5 + 2282;
        goto LABEL_269;
      case 3239:
        if (*((_QWORD *)this + 791))
        {
          v95 = atomic_load((unsigned __int8 *)this + 7441);
          if ((v95 & 1) != 0)
          {
            v96 = *((_QWORD *)this + 791);
            AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v209, (uint64_t)this + 5208);
            AUSM::RoomCongruence::Processor::process((uint64_t)buf, v96, &v209);
            applesauce::CF::DictionaryRef::~DictionaryRef(&v209);
            if (v229)
            {
              if (v228)
              {
                std::recursive_mutex::lock((std::recursive_mutex *)v3 + 11);
                if (!v229)
                  std::__throw_bad_optional_access[abi:ne180100]();
                std::__optional_storage_base<IR::IRDataAttributes,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<IR::IRDataAttributes,false> const&>((AUSpatialMixerV2 *)((char *)v3 + 544), (uint64_t)buf);
                std::recursive_mutex::unlock((std::recursive_mutex *)v3 + 11);
                if (!v229)
                  std::__throw_bad_optional_access[abi:ne180100]();
                AUSM::Properties::setProperty((AUSpatialMixerV2 *)((char *)v3 + 3584), 3248, &v226, 8, 0);
                if (!v229)
                  std::__throw_bad_optional_access[abi:ne180100]();
                if (v227)
                {
                  applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v208, v227);
                  AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::store((uint64_t)v3 + 5424, &v208);
                  applesauce::CF::DictionaryRef::~DictionaryRef(&v208);
                }
              }
              else
              {
                std::recursive_mutex::lock((std::recursive_mutex *)v3 + 11);
                if (*((_BYTE *)v3 + 696))
                {
                  IR::IRDataAttributes::~IRDataAttributes((AUSpatialMixerV2 *)((char *)v3 + 544));
                  *((_BYTE *)v3 + 696) = 0;
                }
                std::recursive_mutex::unlock((std::recursive_mutex *)v3 + 11);
                AUSM::Properties::setProperty((AUSpatialMixerV2 *)((char *)v3 + 3584), 3248, 0, 8, 0);
                AUSM::Properties::setProperty((AUSpatialMixerV2 *)((char *)v3 + 3584), 3249, 0, 8, 0);
              }
              AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)v3, -1, 0, 0);
              if (v229)
                AUSM::RoomCongruence::ProcessingResult::~ProcessingResult((AUSM::RoomCongruence::ProcessingResult *)buf);
            }
          }
        }
        goto LABEL_319;
      case 3240:
        if (*((_BYTE *)this + 6128))
          goto LABEL_319;
        v4 = 0;
        v6 = 0;
        v65 = atomic_load((unsigned int *)this + 1501);
        atomic_store(v65, (unsigned int *)this + 1688);
        goto LABEL_320;
      case 3241:
        if (*((_BYTE *)this + 6128))
          goto LABEL_319;
        v4 = 0;
        v6 = 0;
        v69 = COERCE_FLOAT(atomic_load((unsigned int *)this + 1502));
        v70 = 5.0;
        if (v69 <= 5.0)
          v70 = v69;
        if (v69 >= 0.001)
          v71 = v70;
        else
          v71 = 0.001;
        *((float *)this + 1689) = v71;
        goto LABEL_320;
      case 3243:
        atomic_load((unsigned __int8 *)this + 5089);
        AudioDSP::Core::HeadTracker::SetCanAccessHALAPIs((AUSpatialMixerV2 *)((char *)this + 7408));
        goto LABEL_319;
      case 3245:
        v57 = atomic_load((unsigned __int8 *)this + 7441);
        if ((v57 & 1) == 0)
          goto LABEL_319;
        IsSupportedPersonalizedHRTF = AUSpatialMixerV2::IsSupportedPersonalizedHRTF(this);
        if (IsSupportedPersonalizedHRTF)
        {
          v59 = atomic_load(v5 + 20);
          IR::IRDataLoader::instance((IR::IRDataLoader *)IsSupportedPersonalizedHRTF);
          if ((v59 & 1) == 0)
          {
            std::operator+<char>();
            IR::IRDataLoader::removePersonalizedHRTFListenerCallback();
            if ((v202 & 0x80000000) == 0)
              goto LABEL_319;
            v60 = (void *)v201[5];
            goto LABEL_318;
          }
          std::operator+<char>();
          v210[0] = &off_1E69CA710;
          v210[1] = v3;
          v211 = v210;
          IR::IRDataLoader::addPersonalizedHRTFListenerCallback();
          v180 = v211;
          if (v211 == v210)
          {
            v181 = 4;
            v180 = v210;
          }
          else
          {
            if (!v211)
            {
LABEL_316:
              if ((v204 & 0x80000000) == 0)
                goto LABEL_319;
              v60 = __p;
              goto LABEL_318;
            }
            v181 = 5;
          }
          (*(void (**)(void))(*v180 + 8 * v181))();
          goto LABEL_316;
        }
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v140 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
        {
          v141 = (_QWORD *)((char *)v3 + 3592);
          if (*((char *)v3 + 3615) < 0)
            v141 = (_QWORD *)*v141;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v141;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "PropertyChanged";
          _os_log_impl(&dword_1B5ED0000, v140, OS_LOG_TYPE_DEFAULT, "[%s|%s] Does not support personalized HRTF.", buf, 0x16u);
        }

        IR::IRDataLoader::instance(v142);
        std::operator+<char>();
        IR::IRDataLoader::removePersonalizedHRTFListenerCallback();
        if (v206 < 0)
        {
          v60 = v205;
LABEL_318:
          operator delete(v60);
          goto LABEL_319;
        }
        break;
      case 3246:
      case 3247:
        v189 = 0;
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)this + 3976, &v189);
        v188 = 0;
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v3 + 4120, &v188);
        goto LABEL_90;
      case 3248:
        v82 = atomic_load((unsigned __int8 *)this + 7441);
        if ((v82 & 1) != 0)
        {
          caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
          AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v199, (uint64_t)v3 + 5352);
          v83 = (ParametricFilters *)*((_QWORD *)v3 + 931);
          if (v83)
          {
            if (v199)
            {
              applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v187, v199);
              memset(buf, 0, sizeof(buf));
              ParametricFilters::setParametricFilters((uint64_t)v83, (CFDictionaryRef *)&v187, (uint64_t)buf);
              applesauce::CF::DictionaryRef::~DictionaryRef(&v187);
            }
            else
            {
              ParametricFilters::clear(v83);
            }
          }
          v182 = (ParametricFilters *)*((_QWORD *)v3 + 932);
          if (v182)
          {
            if (v199)
            {
              applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v186, v199);
              memset(buf, 0, sizeof(buf));
              ParametricFilters::setParametricFilters((uint64_t)v182, (CFDictionaryRef *)&v186, (uint64_t)buf);
              applesauce::CF::DictionaryRef::~DictionaryRef(&v186);
            }
            else
            {
              ParametricFilters::clear(v182);
            }
          }
          applesauce::CF::DictionaryRef::~DictionaryRef(&v199);
          caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock((uint64_t)v3 + 3320);
        }
        goto LABEL_319;
      case 3249:
        AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v199, (uint64_t)this + 5424);
        v72 = atomic_load(v5 + 2361);
        if ((v72 & 1) != 0)
        {
          *(_QWORD *)buf = (char *)v3 + 3352;
          buf[8] = 1;
          std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)v3 + 3352));
          for (i = 0; ; ++i)
          {
            v74 = *((_QWORD *)v3 + 15);
            if (v74)
              LODWORD(v75) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v74 + 24))(v74);
            else
              v75 = (*((_QWORD *)v3 + 13) - *((_QWORD *)v3 + 12)) >> 3;
            if (i >= v75)
              break;
            v76 = atomic_load((unsigned int *)v3 + 1868);
            if ((v76 & 0x80000000) == 0)
            {
              v77 = atomic_load((unsigned int *)v3 + 1868);
              v78 = v199;
              if (v199)
                CFRetain(v199);
              v185 = v78;
              IR::SharedIRBuses::setParametricFiltersCoeffs((uint64_t)v3 + 2328, i + v77, &v185);
              if (v78)
                CFRelease(v78);
            }
            v79 = atomic_load((unsigned int *)v3 + 1869);
            if ((v79 & 0x80000000) == 0)
            {
              v80 = atomic_load((unsigned int *)v3 + 1869);
              v81 = v199;
              if (v199)
                CFRetain(v199);
              v184 = v81;
              IR::SharedIRBuses::setParametricFiltersCoeffs((uint64_t)v3 + 2328, i + v80, &v184);
              if (v81)
                CFRelease(v81);
            }
          }
          std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
        }
        goto LABEL_238;
      case 3252:
        v98 = atomic_load((unsigned __int8 *)this + 7441);
        if ((v98 & 1) != 0)
        {
          *(_QWORD *)buf = (char *)this + 3352;
          buf[8] = 1;
          std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
          v99 = atomic_load((unsigned __int8 *)v3 + 2760);
          if ((v99 & 1) != 0 || (v100 = atomic_load((unsigned __int8 *)v3 + 2761), (v100 & 1) != 0))
          {
            v101 = atomic_load((unsigned __int8 *)v3 + 2760);
            v102 = v101 & 1;
            v103 = atomic_load((unsigned __int8 *)v3 + 2761);
            AUSpatialMixerV2::UpdateAutoModeReverb(v3, v102, v103 & 1, -1);
          }
          std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
        }
        goto LABEL_319;
      case 3254:
        if (!*((_QWORD *)this + 791))
          goto LABEL_319;
        v105 = atomic_load((unsigned __int8 *)this + 7441);
        if ((v105 & 1) == 0)
          goto LABEL_319;
        v106 = (float *)*((_QWORD *)this + 791);
        AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v207, (uint64_t)this + 5568);
        AUSM::RoomCongruence::Processor::setTuningParameters(v106, &v207);
        applesauce::CF::DictionaryRef::~DictionaryRef(&v207);
        AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(buf, (uint64_t)v3 + 5208);
        v6 = *(_QWORD *)buf;
        applesauce::CF::DictionaryRef::~DictionaryRef((const void **)buf);
        if (!v6)
          goto LABEL_126;
        (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)v3 + 592))(v3, 3239);
        goto LABEL_319;
      case 3263:
      case 3264:
        v191 = 0;
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)this + 4048, &v191);
        v190 = 0;
        AUSM::AppleSauceCFWithMutex<__CFURL const*>::store((uint64_t)v3 + 4192, &v190);
        std::recursive_mutex::lock((std::recursive_mutex *)v3 + 11);
        if (!*((_BYTE *)v3 + 696))
          AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)v3, -1, 0, 0);
        std::recursive_mutex::unlock((std::recursive_mutex *)v3 + 11);
        goto LABEL_319;
      case 3266:
        std::recursive_mutex::lock((std::recursive_mutex *)this + 11);
        v104 = *((unsigned __int8 *)v3 + 696);
        std::recursive_mutex::unlock((std::recursive_mutex *)v3 + 11);
        if (!v104)
          goto LABEL_184;
        goto LABEL_319;
      case 3267:
        goto LABEL_73;
      case 3279:
        AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v199, (uint64_t)this + 5640);
        v97 = (CFDictionaryRef *)applesauce::CF::DictionaryRef::operator->(&v199);
        applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,__CFString const*&>(buf, *v97, (const void *)kOptionalFeatureConvolutionOptimizationParameters);
        if (buf[8])
        {
          applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v196, *(CFTypeRef *)buf);
          (*(void (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, const void **, uint64_t))(*(_QWORD *)v3 + 96))(v3, 3252, 0, 0, &v196, 8);
          applesauce::CF::DictionaryRef::~DictionaryRef(&v196);
        }
        std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
LABEL_238:
        applesauce::CF::DictionaryRef::~DictionaryRef(&v199);
        goto LABEL_319;
      case 3280:
        v91 = (__float2 *)((char *)this + 3180);
        v92 = COERCE_FLOAT(atomic_load((unsigned int *)v3 + 1513));
        v93 = 1.0;
        if (v92 <= 1.0)
          v93 = v92;
        v94 = 0.0;
        if (v92 >= 0.0)
          v94 = v93;
        *((float *)v3 + 800) = v94;
        MidSideRotation::calculateCoefficients(v91);
        goto LABEL_319;
      default:
        if ((_DWORD)a2 == 5681)
        {
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(buf, (uint64_t)this + 4936);
          DynamicProcessorPreset = AUSpatialMixerV2::LoadDynamicProcessorPreset(v3, 1667658347, (CFURLRef *)buf);
        }
        else
        {
          v6 = 0;
          if ((_DWORD)a2 != 5682)
            goto LABEL_320;
          AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(buf, (uint64_t)this + 5008);
          DynamicProcessorPreset = AUSpatialMixerV2::LoadDynamicProcessorPreset(v3, 1818521197, (CFURLRef *)buf);
        }
        LODWORD(v6) = DynamicProcessorPreset;
        applesauce::CF::URLRef::~URLRef((const void **)buf);
        v4 = 0;
        if (*((_BYTE *)v3 + 17))
          v6 = v6;
        else
          v6 = 0;
        goto LABEL_320;
    }
    goto LABEL_319;
  }
  if ((int)a2 <= 3012)
  {
    if ((_DWORD)a2 == 10)
    {
LABEL_184:
      AUSpatialMixerV2::UpdateReverbRoomType(v3);
    }
    else
    {
      if ((_DWORD)a2 != 1005)
      {
        v6 = 0;
        if ((_DWORD)a2 != 3010)
          goto LABEL_320;
LABEL_109:
        v6 = 0;
        v43 = (unsigned __int8 *)this + 7364;
LABEL_269:
        atomic_store(1u, v43);
        return v6;
      }
LABEL_73:
      v41 = 1;
LABEL_91:
      AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, v41, 0);
    }
LABEL_319:
    v4 = 0;
    v6 = 0;
LABEL_320:
    if ((v4 & 1) == 0 && !(_DWORD)v6)
      return AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements(v3, a2);
    return v6;
  }
  v6 = 0;
  switch((int)a2)
  {
    case 3100:
      v17 = atomic_load((unsigned int *)this + 918);
      if (v17 == 2)
      {
        v18 = atomic_load((unsigned __int8 *)this + 7441);
        if ((v18 & 1) != 0)
          AUSpatialMixerV2::UpdateCounteractRotationShader(this);
      }
      (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)v3 + 592))(v3, 3113);
LABEL_90:
      this = v3;
      v41 = 0;
      goto LABEL_91;
    case 3101:
      atomic_store(1u, (unsigned __int8 *)this + 7363);
      v123 = atomic_load((unsigned __int8 *)this + 7441);
      if ((v123 & 1) != 0)
      {
        v124 = atomic_load((unsigned int *)this + 918);
        if (v124 == 2)
        {
          v125 = atomic_load((unsigned __int8 *)this + 2760);
          if ((v125 & 1) != 0)
          {
            *(_QWORD *)buf = (char *)this + 3352;
            buf[8] = 1;
            std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
            AUSpatialMixerV2::UpdateAutoModeReverb(v3, 1, 0, -1);
            std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
          }
        }
      }
      goto LABEL_299;
    case 3102:
      atomic_store(1u, (unsigned __int8 *)this + 7361);
      v114 = (unsigned __int128 *)((char *)this + 3696);
      do
        v115 = __ldaxp(v114);
      while (__stlxp(v115, v114));
      v116 = AUSM::auCoordQuaternionToEuler(this, (float32x4_t)v115);
      v118 = v117;
      v120 = v119;
      v121 = *((_QWORD *)v3 + 9);
      if (v121)
      {
        v122 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v121 + 32))(v121, 0);
      }
      else
      {
        v139 = (ausdk::AUElement **)*((_QWORD *)v3 + 6);
        if (*((ausdk::AUElement ***)v3 + 7) == v139)
          v122 = 0;
        else
          v122 = *v139;
      }
      ausdk::AUElement::SetParameter(v122, 0x13u, v116, 0);
      v150 = *((_QWORD *)v3 + 9);
      if (v150)
      {
        v151 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v150 + 32))(v150, 0);
      }
      else
      {
        v152 = (ausdk::AUElement **)*((_QWORD *)v3 + 6);
        if (*((ausdk::AUElement ***)v3 + 7) == v152)
          v151 = 0;
        else
          v151 = *v152;
      }
      ausdk::AUElement::SetParameter(v151, 0x14u, v118, 0);
      v153 = *((_QWORD *)v3 + 9);
      if (v153)
      {
        v154 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v153 + 32))(v153, 0);
      }
      else
      {
        v155 = (ausdk::AUElement **)*((_QWORD *)v3 + 6);
        if (*((ausdk::AUElement ***)v3 + 7) == v155)
          v154 = 0;
        else
          v154 = *v155;
      }
      ausdk::AUElement::SetParameter(v154, 0x15u, v120, 0);
      if ((*((_BYTE *)v3 + 6096) & 4) != 0)
      {
        do
          v156 = __ldaxp(v114);
        while (__stlxp(v156, v114));
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v157 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT))
        {
          v158 = (_QWORD *)((char *)v3 + 3592);
          if (*((char *)v3 + 3615) < 0)
            v158 = (_QWORD *)*v158;
          *(_DWORD *)buf = 136317186;
          *(_QWORD *)&buf[4] = v158;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "PropertyChanged";
          *(_WORD *)&buf[22] = 2048;
          v213 = v116;
          v214 = 2048;
          v215 = v118;
          v216 = 2048;
          v217 = v120;
          v218 = 2048;
          v219 = *(float *)&v156;
          v220 = 2048;
          v221 = *((float *)&v156 + 1);
          v222 = 2048;
          v223 = *((float *)&v156 + 2);
          v224 = 2048;
          v225 = *((float *)&v156 + 3);
          _os_log_impl(&dword_1B5ED0000, v157, OS_LOG_TYPE_DEFAULT, "[%s|%s] AUSMHeadOrientation: Y: %.2f, P: %.2f, R: %.2f, Quat: (%.4f, %.4f, %.4f, %.4f)", buf, 0x5Cu);
        }

      }
      do
        v159 = __ldaxp(v114);
      while (__stlxp(v159, v114));
      v86 = (float32x4_t)v159;
      v160 = (unsigned __int128 *)((char *)v3 + 3712);
      do
      {
        v161 = __ldaxp(v160);
        v88 = *((_QWORD *)&v161 + 1);
        v89 = v161;
      }
      while (__stlxp(v161, v160));
LABEL_293:
      v162.i64[0] = v89;
      v162.i64[1] = v88;
      v163 = (int32x4_t)vnegq_f32(v162);
      v164 = (int8x16_t)vtrn2q_s32((int32x4_t)v162, vtrn1q_s32((int32x4_t)v162, v163));
      v165 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v162, (int8x16_t)v163, 8uLL), *(float32x2_t *)v86.f32, 1), (float32x4_t)vextq_s8(v164, v164, 8uLL), v86.f32[0]);
      v166 = (float32x4_t)vrev64q_s32((int32x4_t)v162);
      v166.i32[0] = v163.i32[1];
      v166.i32[3] = v163.i32[2];
      v167 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v162, v86, 3), v166, v86, 2), v165);
      v168 = (int8x16_t)vmulq_f32(v167, v167);
      v169 = vadd_f32(*(float32x2_t *)v168.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v168, v168, 8uLL));
      if (vaddv_f32(v169) == 0.0)
      {
        v170 = (float32x4_t)xmmword_1B6629CC0;
      }
      else
      {
        v171 = vadd_f32(v169, (float32x2_t)vdup_lane_s32((int32x2_t)v169, 1)).u32[0];
        v172 = vrsqrte_f32((float32x2_t)v171);
        v173 = vmul_f32(v172, vrsqrts_f32((float32x2_t)v171, vmul_f32(v172, v172)));
        v170 = vmulq_n_f32(v167, vmul_f32(v173, vrsqrts_f32((float32x2_t)v171, vmul_f32(v173, v173))).f32[0]);
      }
      v174 = vmulq_f32(v170, (float32x4_t)xmmword_1B66A07B0);
      v175 = (int8x16_t)vmulq_f32(v170, v170);
      *(float32x2_t *)v175.i8 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v175, v175, 8uLL));
      v175.i32[0] = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v175.i8, 1)).u32[0];
      v176 = vrecpe_f32((float32x2_t)v175.u32[0]);
      v177 = vmul_f32(v176, vrecps_f32((float32x2_t)v175.u32[0], v176));
      v178 = AUSM::auCoordQuaternionToYawPitch(this, vmulq_n_f32(v174, vmul_f32(v177, vrecps_f32((float32x2_t)v175.u32[0], v177)).f32[0]));
      v179 = *((_QWORD *)v3 + 401);
      if (v179)
      {
        v6 = 0;
        *(float *)(v179 + 8) = v178;
        return v6;
      }
      *((float *)v3 + 799) = v178;
      MidSideRotation::calculateCoefficients((__float2 *)((char *)v3 + 3180));
      goto LABEL_299;
    case 3103:
    case 3104:
    case 3105:
    case 3106:
    case 3108:
    case 3109:
    case 3110:
    case 3112:
      goto LABEL_320;
    case 3107:
      v128 = atomic_load((unsigned __int8 *)this + 7441);
      if ((v128 & 1) == 0)
        goto LABEL_319;
      v129 = atomic_load((unsigned __int8 *)this + 3668);
      if ((v129 & 1) != 0)
        v130 = (void (*)(uint64_t, _QWORD *))MEMORY[0x1E0C82F90];
      else
        v130 = (void (*)(uint64_t, _QWORD *))MEMORY[0x1E0C82C00];
      v131 = (void *)*((_QWORD *)this + 356);
      applesauce::dispatch::v1::queue::get(v131);
      v132 = objc_claimAutoreleasedReturnValue();
      v201[0] = MEMORY[0x1E0C809B0];
      v201[1] = 3221225472;
      v201[2] = ___ZN16AUSpatialMixerV215PropertyChangedEj_block_invoke;
      v201[3] = &__block_descriptor_40_e5_v8__0l;
      v201[4] = v3;
      v130(v132, v201);

      goto LABEL_299;
    case 3111:
LABEL_100:
      v54 = atomic_load((unsigned __int8 *)this + 7441);
      if ((v54 & 1) == 0)
        goto LABEL_319;
      v55 = atomic_load(v5);
      if ((v55 & 1) == 0)
      {
        AudioDSP::Core::HeadTracker::DisconnectRM((AUSpatialMixerV2 *)((char *)this + 7408));
        v56 = (unsigned __int128 *)((char *)v3 + 3712);
        do
          __ldaxp(v56);
        while (__stlxp(__PAIR128__(0x3F80000000000000, 0), v56));
LABEL_255:
        v6 = 0;
        v43 = v5 + 2281;
        goto LABEL_269;
      }
      AudioDSP::Core::HeadTracker::Initialize();
      if (!atomic_load((unsigned int *)v3 + 1271))
      {
        AudioDSP::Core::HeadTracker::DisconnectRM((AUSpatialMixerV2 *)((char *)v3 + 7408));
        v143 = (unsigned __int128 *)((char *)v3 + 3712);
        do
          __ldaxp(v143);
        while (__stlxp(__PAIR128__(0x3F80000000000000, 0), v143));
        goto LABEL_255;
      }
      atomic_load((unsigned int *)v3 + 1271);
      AudioDSP::Core::HeadTracker::ConnectRM();
LABEL_299:
      v6 = 0;
      break;
    case 3113:
      v126 = atomic_load((unsigned __int8 *)this + 7441);
      if ((v126 & 1) == 0)
        goto LABEL_319;
      v127 = atomic_load((unsigned int *)this + 1273);
      atomic_store(v127 == 2, (unsigned __int8 *)this + 5100);
      (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)this + 592))(this, 3245);
      goto LABEL_214;
    case 3114:
      v111 = atomic_load((unsigned __int8 *)this + 7441);
      if ((v111 & 1) == 0)
        goto LABEL_319;
      if (!atomic_load((unsigned int *)this + 1273))
        goto LABEL_319;
      v113 = (IR::IRDataLoader *)IR::IRDataLoader::instance(this);
      if ((IR::IRDataLoader::hasFailedToFetchPersonalizedHRTF(v113) & 1) != 0)
        goto LABEL_319;
LABEL_214:
      (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)v3 + 592))(v3, 3200);
      goto LABEL_319;
    case 3115:
      if ((*((_BYTE *)this + 6096) & 8) != 0)
      {
        v107 = (unsigned __int128 *)((char *)this + 6016);
        do
          v108 = __ldaxp(v107);
        while (__stlxp(v108, v107));
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v109 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
        {
          v110 = (_QWORD *)((char *)v3 + 3592);
          if (*((char *)v3 + 3615) < 0)
            v110 = (_QWORD *)*v110;
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v110;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "PropertyChanged";
          *(_WORD *)&buf[22] = 2048;
          v213 = *(float *)&v108;
          v214 = 2048;
          v215 = *((float *)&v108 + 1);
          v216 = 2048;
          v217 = *((float *)&v108 + 2);
          _os_log_impl(&dword_1B5ED0000, v109, OS_LOG_TYPE_DEFAULT, "[%s|%s] AUSM_PRESENTATION_POS: X (left-right): %.4f, Y (back-front): %.4f, Z (down-up): %.4f", buf, 0x34u);
        }

      }
      v6 = 0;
      v43 = v5 + 2280;
      goto LABEL_269;
    default:
      v6 = 0;
      if ((_DWORD)a2 == 3013)
        goto LABEL_109;
      goto LABEL_320;
  }
  return v6;
}

void sub_1B619907C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (LOBYTE(STACK[0x218]))
    AUSM::RoomCongruence::ProcessingResult::~ProcessingResult((AUSM::RoomCongruence::ProcessingResult *)&a53);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::PropertyObserverIsInitialized(AUSpatialMixerV2 *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)this + 7441);
  return v1 & 1;
}

uint64_t AUSpatialMixerV2::AcceptAnyChannelLayoutBeforeInitialization(AUSpatialMixerV2 *this)
{
  return 0;
}

uint64_t `non-virtual thunk to'AUSpatialMixerV2::PropertyChanged(AUSpatialMixerV2 *this, uint64_t a2)
{
  return AUSpatialMixerV2::PropertyChanged((AUSpatialMixerV2 *)((char *)this - 528), a2);
}

uint64_t `non-virtual thunk to'AUSpatialMixerV2::PropertyObserverIsInitialized(AUSpatialMixerV2 *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)this + 6913);
  return v1 & 1;
}

float AUSM::auCoordQuaternionToYawPitch(AUSM *this, float32x4_t a2)
{
  int8x16_t v2;
  float32x2_t v3;
  float v4;
  float v5;
  unsigned __int32 v7;
  float32x2_t v8;
  float32x2_t v9;

  v2 = (int8x16_t)vmulq_f32(a2, a2);
  v3 = vadd_f32(*(float32x2_t *)v2.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  v4 = vaddv_f32(v3);
  v5 = 0.0;
  if (sqrtf(v4) >= 0.0001)
  {
    if (v4 == 0.0)
    {
      _Q1 = (float32x4_t)xmmword_1B6629CC0;
    }
    else
    {
      v7 = vadd_f32(v3, (float32x2_t)vdup_lane_s32((int32x2_t)v3, 1)).u32[0];
      v8 = vrsqrte_f32((float32x2_t)v7);
      v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)v7, vmul_f32(v8, v8)));
      _Q1 = vmulq_n_f32(a2, vmul_f32(v9, vrsqrts_f32((float32x2_t)v7, vmul_f32(v9, v9))).f32[0]);
    }
    _S2 = _Q1.i32[2];
    _S3 = _Q1.i32[1];
    __asm
    {
      FMLA            S0, S2, V1.S[3]
      FMLA            S2, S3, V1.S[1]
    }
    return atan2f(_S0 + _S0, (float)(_S2 * -2.0) + 1.0) * 57.296;
  }
  return v5;
}

float AUSM::auCoordQuaternionToEuler(AUSM *this, float32x4_t a2)
{
  int8x16_t v2;
  float32x2_t v3;
  float v4;
  float v5;
  float32x4_t v6;
  unsigned __int32 v7;
  float32x2_t v8;
  float32x2_t v9;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  __float2 v24;
  __float2 v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x4_t v30;
  int32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float v36;
  int8x16_t v39;
  float v40;
  __int32 v41;

  v2 = (int8x16_t)vmulq_f32(a2, a2);
  v3 = vadd_f32(*(float32x2_t *)v2.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  v4 = vaddv_f32(v3);
  if (sqrtf(v4) < 0.0001)
    return 0.0;
  if (v4 == 0.0)
  {
    v6 = (float32x4_t)xmmword_1B6629CC0;
  }
  else
  {
    v7 = vadd_f32(v3, (float32x2_t)vdup_lane_s32((int32x2_t)v3, 1)).u32[0];
    v8 = vrsqrte_f32((float32x2_t)v7);
    v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)v7, vmul_f32(v8, v8)));
    v6 = vmulq_n_f32(a2, vmul_f32(v9, vrsqrts_f32((float32x2_t)v7, vmul_f32(v9, v9))).f32[0]);
  }
  _S9 = v6.i32[2];
  _S10 = v6.i32[1];
  _Q2 = v6;
  v41 = v6.i32[3];
  __asm
  {
    FMLA            S0, S9, V2.S[3]
    FMLA            S1, S10, V2.S[1]
  }
  v5 = atan2f(_S0 + _S0, (float)(_S1 * -2.0) + 1.0) * 57.296;
  _V1.S[3] = v41;
  __asm { FMLA            S0, S10, V1.S[3] }
  *(float *)v21.i32 = _S0 + _S0;
  v39 = v21;
  if (fabsf(*(float *)v21.i32) >= nexttowardf(1.0, 0.0))
  {
    v22.i32[0] = 1119092736;
    v23.i64[0] = 0x8000000080000000;
    v23.i64[1] = 0x8000000080000000;
    v22.i32[0] = vbslq_s8(v23, v22, v39).u32[0];
  }
  else
  {
    *(float *)v22.i32 = asinf(*(float *)v39.i32) * 57.296;
  }
  v40 = *(float *)v22.i32;
  v24 = __sincosf_stret((float)(v5 * 0.017453) * 0.5);
  v25 = __sincosf_stret((float)(v40 * 0.017453) * 0.5);
  v26.f32[0] = -(float)((float)(v24.__sinval * v25.__sinval) - (float)((float)(v24.__cosval * v25.__cosval) * 0.0));
  v26.f32[1] = (float)(v24.__sinval * (float)(v25.__cosval * 0.0)) + (float)(v25.__sinval * v24.__cosval);
  v26.f32[2] = (float)(v24.__cosval * (float)(v25.__sinval * -0.0)) + (float)(v25.__cosval * v24.__sinval);
  v26.f32[3] = (float)(v24.__cosval * v25.__cosval) + (float)((float)(v24.__sinval * v25.__sinval) * 0.0);
  v27 = (int8x16_t)vmulq_f32(v26, v26);
  *(float32x2_t *)v27.i8 = vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
  v27.i32[0] = vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1)).u32[0];
  v28 = vrecpe_f32((float32x2_t)v27.u32[0]);
  v29 = vmul_f32(v28, vrecps_f32((float32x2_t)v27.u32[0], v28));
  v30 = vmulq_n_f32(vmulq_f32(v26, (float32x4_t)xmmword_1B66A07B0), vmul_f32(v29, vrecps_f32((float32x2_t)v27.u32[0], v29)).f32[0]);
  v31 = (int32x4_t)vnegq_f32(a2);
  v32 = (int8x16_t)vtrn2q_s32((int32x4_t)a2, vtrn1q_s32((int32x4_t)a2, v31));
  v33 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)a2, (int8x16_t)v31, 8uLL), *(float32x2_t *)v30.f32, 1), (float32x4_t)vextq_s8(v32, v32, 8uLL), v30.f32[0]);
  v34 = (float32x4_t)vrev64q_s32((int32x4_t)a2);
  v34.i32[0] = v31.i32[1];
  v34.i32[3] = v31.i32[2];
  v35 = vaddq_f32(v33, vmlaq_laneq_f32(vmulq_laneq_f32(a2, v30, 3), v34, v30, 2));
  v36 = atan2f(v35.f32[0], v35.f32[3]);
  remainderf((float)(v36 + v36) * 57.296, 360.0);
  return v5;
}

void AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(_QWORD *a1, uint64_t a2)
{
  std::mutex *v4;
  const void *v5;

  v4 = (std::mutex *)(a2 + 8);
  std::mutex::lock((std::mutex *)(a2 + 8));
  v5 = *(const void **)a2;
  if (v5)
    CFRetain(v5);
  *a1 = v5;
  std::mutex::unlock(v4);
}

void std::__optional_storage_base<IR::IRDataAttributes,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<IR::IRDataAttributes,false> const&>(IR::IRDataAttributes *a1, uint64_t a2)
{
  uint64_t v2;

  if (*((unsigned __int8 *)a1 + 152) == *(unsigned __int8 *)(a2 + 152))
  {
    if (*((_BYTE *)a1 + 152))
      IR::IRDataAttributes::operator=((uint64_t)a1, a2);
  }
  else if (*((_BYTE *)a1 + 152))
  {
    IR::IRDataAttributes::~IRDataAttributes(a1);
    *(_BYTE *)(v2 + 152) = 0;
  }
  else
  {
    *(_BYTE *)(IR::IRDataAttributes::IRDataAttributes((uint64_t)a1, a2) + 152) = 1;
  }
}

void AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::store(uint64_t a1, const void **a2)
{
  std::mutex *v4;
  const void *v5;
  const void *v6;

  v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  v5 = *(const void **)a1;
  v6 = *a2;
  *(_QWORD *)a1 = *a2;
  if (v6)
    CFRetain(v6);
  if (v5)
    CFRelease(v5);
  std::mutex::unlock(v4);
}

uint64_t AUSpatialMixerV2::UpdateReverbIfNecessary(uint64_t this, int a2, int a3, int a4)
{
  unsigned __int8 v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *Element;
  _BOOL4 MustProcessInternalReverb;
  _BOOL4 MustProcessPostProcReverb;
  unsigned int v15;
  unsigned int v16;
  _BOOL4 v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 v21;
  NSObject *v22;
  ParametricFilters *v23;
  unsigned int v24;
  uint64_t v25;
  unsigned __int8 v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  IR::FixedIntegerDelay *v31;
  IR::FixedIntegerDelay *v32;
  int v33;
  int v34;
  unsigned int *v35;
  unsigned int *v36;
  int v37;
  unsigned __int8 v38;
  NSObject *v39;
  double v40;
  unint64_t v41;
  int v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  void *v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  int v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t *v65;
  IR::IRDataLoader *LoadedSpatializerIRDataAttributes;
  IR::IRDataLoader *v67;
  int ModelingDelay;
  uint64_t *v69;
  int v70;
  NSObject *v71;
  _QWORD *v72;
  int v73;
  const char *v74;
  unint64_t v75;
  unsigned int v76;
  unsigned __int8 *v77;
  unsigned __int8 v78;
  unsigned __int8 v79;
  NSObject *v80;
  unsigned __int8 v81;
  unsigned __int8 v82;
  NSObject *v83;
  uint64_t v84;
  uint64_t v85;
  float v86;
  NSObject *v87;
  uint64_t v88;
  _QWORD *v89;
  _QWORD *v90;
  _QWORD *v91;
  _QWORD *v92;
  _QWORD *v93;
  _QWORD *v94;
  unsigned __int8 *v95;
  int v99;
  uint64_t v100;
  char v101;
  uint64_t v102;
  char v103;
  _BYTE v104[24];
  int v105;
  __int16 v106;
  _QWORD __p[4];
  CFTypeRef v108;
  CFTypeRef v109;
  CFTypeRef cf;
  char v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  v4 = atomic_load((unsigned __int8 *)(this + 7441));
  if ((v4 & 1) == 0)
    return this;
  v5 = this;
  v95 = (unsigned __int8 *)(this + 15144);
  v100 = this + 3352;
  v101 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(this + 3352));
  v6 = 0;
  v99 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  while (1)
  {
    v10 = *(_QWORD *)(v5 + 120);
    if (v10)
      LODWORD(v11) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    else
      v11 = (*(_QWORD *)(v5 + 104) - *(_QWORD *)(v5 + 96)) >> 3;
    if (v6 >= v11)
      break;
    Element = (unsigned int *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 80), v6);
    MustProcessInternalReverb = AUSpatialMixerV2InputElement::MustProcessInternalReverb((AUSpatialMixerV2InputElement *)Element);
    MustProcessPostProcReverb = AUSpatialMixerV2InputElement::MustProcessPostProcReverb((AUSpatialMixerV2InputElement *)Element);
    v15 = atomic_load(Element + 282);
    if (v15 - 7 <= 2
      && AUSpatialMixerV2InputElement::MustProcessInternalReverb((AUSpatialMixerV2InputElement *)Element))
    {
      v99 = 1;
    }
    else
    {
      v16 = atomic_load(Element + 282);
      v17 = v16 == 6 && AUSpatialMixerV2InputElement::MustProcessInternalReverb((AUSpatialMixerV2InputElement *)Element);
      v7 |= v17;
    }
    v9 |= MustProcessInternalReverb;
    v8 |= MustProcessPostProcReverb;
    ++v6;
  }
  v18 = a2;
  if (a2 == -1)
  {
    v20 = *(_QWORD *)(v5 + 120);
    if (v20)
    {
      LODWORD(v19) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
      v18 = 0;
    }
    else
    {
      v18 = 0;
      v19 = (*(_QWORD *)(v5 + 104) - *(_QWORD *)(v5 + 96)) >> 3;
    }
  }
  else
  {
    LODWORD(v19) = a2 + 1;
  }
  v21 = atomic_load((unsigned __int8 *)(v5 + 2760));
  if (!(((v21 & 1) == 0) | v99 & 1))
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v22 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      v89 = (_QWORD *)(v5 + 3592);
      if (*(char *)(v5 + 3615) < 0)
        v89 = (_QWORD *)*v89;
      *(_DWORD *)v104 = 136315394;
      *(_QWORD *)&v104[4] = v89;
      *(_WORD *)&v104[12] = 2080;
      *(_QWORD *)&v104[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1B5ED0000, v22, OS_LOG_TYPE_DEBUG, "[%s|%s] Resetting auto mode reverb", v104, 0x16u);
    }

    v23 = *(ParametricFilters **)(v5 + 7456);
    if (v23)
      ParametricFilters::reset(v23);
    if (v18 != (_DWORD)v19)
    {
      v24 = v18;
      do
      {
        v25 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 80), v24);
        AUSpatialMixerV2InputElement::ResetReverbProcessors(v25, 1);
        ++v24;
      }
      while ((_DWORD)v19 != v24);
    }
    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 2608));
    IR::SharedIRBuses::reset((IR::SharedIRBuses *)(v5 + 2328));
    caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v5 + 2608));
  }
  v26 = atomic_load((unsigned __int8 *)(v5 + 2761));
  if (!(((v26 & 1) == 0) | v8 & 1))
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v27 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      v90 = (_QWORD *)(v5 + 3592);
      if (*(char *)(v5 + 3615) < 0)
        v90 = (_QWORD *)*v90;
      *(_DWORD *)v104 = 136315394;
      *(_QWORD *)&v104[4] = v90;
      *(_WORD *)&v104[12] = 2080;
      *(_QWORD *)&v104[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1B5ED0000, v27, OS_LOG_TYPE_DEBUG, "[%s|%s] Resetting post-processing reverb", v104, 0x16u);
    }

    AUSpatialMixerV2::ResetReverbFilters(v5);
    for (; (_DWORD)v19 != v18; ++v18)
    {
      v28 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 80), v18);
      AUSpatialMixerV2InputElement::ResetReverbProcessors(v28, 0);
    }
    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 2608));
    IR::SharedIRBuses::reset((IR::SharedIRBuses *)(v5 + 2328));
    caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v5 + 2608));
  }
  if (((v99 | v8) & 1) == 0)
  {
    if (a4)
      AUSpatialMixerV2::ReconfigureSharedBuffers((AUSpatialMixerV2 *)v5, 0, 0);
    v31 = *(IR::FixedIntegerDelay **)(v5 + 2584);
    v32 = *(IR::FixedIntegerDelay **)(v5 + 2592);
    while (v31 != v32)
    {
      IR::FixedIntegerDelay::reset(v31);
      v31 = (IR::FixedIntegerDelay *)((char *)v31 + 56);
    }
    v33 = 0;
    v34 = 0;
    goto LABEL_71;
  }
  v29 = *(_QWORD *)(v5 + 120);
  if (v29)
    LODWORD(v30) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
  else
    v30 = (*(_QWORD *)(v5 + 104) - *(_QWORD *)(v5 + 96)) >> 3;
  if ((v99 & v8 & 1) == 0)
  {
    v35 = (unsigned int *)(v5 + 7464);
    if ((v99 & 1) != 0)
    {
      atomic_store(v30, v35);
      atomic_store(0, (unsigned int *)(v5 + 7468));
      v36 = (unsigned int *)(v5 + 7472);
    }
    else
    {
      if ((v8 & 1) != 0)
      {
        atomic_store(v30, v35);
        atomic_store(0xFFFFFFFF, (unsigned int *)(v5 + 7468));
        atomic_store(0, (unsigned int *)(v5 + 7472));
LABEL_55:
        atomic_store(0xFFFFFFFF, (unsigned int *)(v5 + 7476));
        goto LABEL_56;
      }
      atomic_store(0, v35);
      atomic_store(0xFFFFFFFF, (unsigned int *)(v5 + 7468));
      v36 = (unsigned int *)(v5 + 7472);
    }
    atomic_store(0xFFFFFFFF, v36);
    goto LABEL_55;
  }
  atomic_store(3 * v30, (unsigned int *)(v5 + 7464));
  atomic_store(0, (unsigned int *)(v5 + 7468));
  atomic_store(v30, (unsigned int *)(v5 + 7472));
  atomic_store(2 * v30, (unsigned int *)(v5 + 7476));
LABEL_56:
  v37 = atomic_load((unsigned int *)(v5 + 7464));
  v38 = atomic_load((unsigned __int8 *)(v5 + 2556));
  if ((v38 & 1) != 0)
  {
    IR::SharedIRBuses::setNumInputChannels(v5 + 2328, v37);
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v39 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
    {
      v93 = (_QWORD *)(v5 + 3592);
      if (*(char *)(v5 + 3615) < 0)
        v93 = (_QWORD *)*v93;
      *(_DWORD *)v104 = 136315394;
      *(_QWORD *)&v104[4] = v93;
      *(_WORD *)&v104[12] = 2080;
      *(_QWORD *)&v104[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1B5ED0000, v39, OS_LOG_TYPE_DEBUG, "[%s|%s] Initializing auto mode reverb", v104, 0x16u);
    }

    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 2608));
    v40 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 128), 0) + 80);
    v41 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 128), 0) + 108);
    v42 = *(_DWORD *)(v5 + 336);
    v102 = v5 + 2476;
    v103 = 1;
    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 2476));
    v43 = v40;
    atomic_store(0, (unsigned __int8 *)(v5 + 2472));
    atomic_store(0, (unsigned __int8 *)(v5 + 2473));
    atomic_store(0, (unsigned __int8 *)(v5 + 2474));
    *(float *)(v5 + 2564) = v43;
    *(_DWORD *)(v5 + 2552) = v37;
    *(_DWORD *)(v5 + 2568) = v42;
    *(_DWORD *)(v5 + 2580) = 1 << -(char)__clz(vcvtas_u32_f32(v43 * 0.0053333) - 1);
    if (v42)
    {
      *(_DWORD *)(v5 + 2560) = v41;
      v44 = *(_QWORD *)(v5 + 2488);
      v45 = *(_QWORD *)(v5 + 2480);
      std::vector<std::vector<float>>::resize((uint64_t *)(v5 + 2480), v41);
      std::vector<std::vector<float>>::resize((uint64_t *)(v5 + 2504), v41);
      v46 = -1431655765 * ((v44 - v45) >> 3);
      if (v41 > v46)
      {
        v47 = 24 * (int)v46;
        do
        {
          v48 = v41;
          std::vector<float>::vector(v104, *(unsigned int *)(v5 + 2568));
          v49 = *(_QWORD *)(v5 + 2480) + v47;
          v50 = *(void **)v49;
          if (*(_QWORD *)v49)
          {
            *(_QWORD *)(v49 + 8) = v50;
            operator delete(v50);
            *(_QWORD *)v49 = 0;
            *(_QWORD *)(v49 + 8) = 0;
            *(_QWORD *)(v49 + 16) = 0;
          }
          *(_OWORD *)v49 = *(_OWORD *)v104;
          *(_QWORD *)(v49 + 16) = *(_QWORD *)&v104[16];
          std::vector<float>::vector(v104, *(unsigned int *)(v5 + 2568));
          v51 = *(_QWORD *)(v5 + 2504) + v47;
          v52 = *(void **)v51;
          if (*(_QWORD *)v51)
          {
            *(_QWORD *)(v51 + 8) = v52;
            operator delete(v52);
            *(_QWORD *)v51 = 0;
            *(_QWORD *)(v51 + 8) = 0;
            *(_QWORD *)(v51 + 16) = 0;
          }
          *(_OWORD *)v51 = *(_OWORD *)v104;
          *(_QWORD *)(v51 + 16) = *(_QWORD *)&v104[16];
          ++v46;
          v47 += 24;
          v41 = v48;
        }
        while (v48 > v46);
      }
    }
    v53 = *(unsigned int *)(v5 + 2552);
    *(_QWORD *)v104 = 0;
    *(_QWORD *)&v104[8] = 0;
    std::vector<std::shared_ptr<IR::SharedIRBuses::IRBus>>::resize((char **)(v5 + 2328), v53, v104);
    v54 = *(unsigned int *)(v5 + 2552);
    *(_QWORD *)v104 = 0;
    *(_QWORD *)&v104[8] = 0;
    std::vector<std::shared_ptr<IR::SharedIRBuses::IRBus>>::resize((char **)(v5 + 2376), v54, v104);
    v55 = *(unsigned int *)(v5 + 2552);
    *(_QWORD *)v104 = 0;
    *(_QWORD *)&v104[8] = 0;
    std::vector<std::shared_ptr<IR::SharedIRBuses::IRBus>>::resize((char **)(v5 + 2424), v55, v104);
    v56 = *(unsigned int *)(v5 + 2552);
    *(_DWORD *)v104 = 0;
    std::vector<float>::resize(v5 + 2352, v56, v104);
    v57 = *(unsigned int *)(v5 + 2552);
    *(_DWORD *)v104 = 0;
    std::vector<float>::resize(v5 + 2400, v57, v104);
    v58 = *(unsigned int *)(v5 + 2552);
    *(_DWORD *)v104 = 0;
    std::vector<float>::resize(v5 + 2448, v58, v104);
    *(_QWORD *)v104 = 0;
    *(_QWORD *)&v104[8] = 0;
    std::vector<std::shared_ptr<IR::SharedIRBuses::IRBus>>::resize((char **)(v5 + 2528), 4uLL, v104);
    *(_BYTE *)(v5 + 2557) = 1;
    atomic_store(1u, (unsigned __int8 *)(v5 + 2556));
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v102);
    caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v5 + 2608));
  }
  v33 = v99;
  AUSpatialMixerV2::UpdateAutoModeReverb((AUSpatialMixerV2 *)v5, v99 & 1, v8 & 1, a2);
  v34 = v8;
LABEL_71:
  atomic_store(v99 & 1, (unsigned __int8 *)(v5 + 2760));
  atomic_store(v8 & 1, (unsigned __int8 *)(v5 + 2761));
  if (a3)
  {
    v59 = atomic_load((unsigned __int8 *)(v5 + 2760));
    v60 = atomic_load((unsigned __int8 *)(v5 + 2761));
    v61 = atomic_load((unsigned int *)(v5 + 3672));
    if (v61 == 1)
    {
      if ((v59 & v60 & 1) != 0)
      {
        v62 = AUSpatialMixerV2::UpdateAlignmentDelayLines(BOOL,BOOL)::$_0::operator()(v5, 0);
        v63 = AUSpatialMixerV2::UpdateAlignmentDelayLines(BOOL,BOOL)::$_0::operator()(v5, 1);
        if (v63 < v62)
          v62 = v63;
      }
      else if (((v60 | v59) & 1) != 0)
      {
        v62 = AUSpatialMixerV2::UpdateAlignmentDelayLines(BOOL,BOOL)::$_0::operator()(v5, (v60 & 1) == 0);
      }
      else
      {
        v62 = 0;
      }
      v64 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 80), 0);
      v102 = v64 + 704;
      v103 = 1;
      caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(v64 + 704);
      v65 = *(uint64_t **)(v64 + 248);
      if (*(uint64_t **)(v64 + 256) == v65
        || (LoadedSpatializerIRDataAttributes = (IR::IRDataLoader *)AUSpatialMixerV2ChannelProcessor::getLoadedSpatializerIRDataAttributes((AUSpatialMixerV2ChannelProcessor *)v104, *v65), !v111))
      {
        ModelingDelay = 0;
      }
      else
      {
        v67 = (IR::IRDataLoader *)IR::IRDataLoader::instance(LoadedSpatializerIRDataAttributes);
        if (!v111)
          std::__throw_bad_optional_access[abi:ne180100]();
        ModelingDelay = IR::IRDataLoader::getModelingDelay(v67, (const IR::IRDataAttributes *)v104);
        if (v111)
        {
          if (cf)
            CFRelease(cf);
          if (v109)
            CFRelease(v109);
          if (v108)
            CFRelease(v108);
          if (*(_QWORD *)v104)
            CFRelease(*(CFTypeRef *)v104);
        }
      }
      std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v102);
      v69 = (uint64_t *)(v5 + 15096);
      AUSpatialMixerV2::AlignmentDelay::reset((AUSpatialMixerV2::AlignmentDelay *)(v5 + 15096));
      if (v62 != ModelingDelay)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v70 = v62 - ModelingDelay;
        v71 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
        {
          v72 = (_QWORD *)(v5 + 3592);
          if (*(char *)(v5 + 3615) < 0)
            v72 = (_QWORD *)*v72;
          if (v70 >= 0)
            v73 = v70;
          else
            v73 = -v70;
          *(_DWORD *)v104 = 136315906;
          *(_QWORD *)&v104[4] = v72;
          *(_QWORD *)&v104[14] = "UpdateAlignmentDelayLines";
          *(_WORD *)&v104[22] = 1024;
          v74 = "direct path";
          *(_WORD *)&v104[12] = 2080;
          if (v70 <= 0)
            v74 = "reverb path";
          v105 = v73;
          v106 = 2080;
          __p[0] = v74;
          _os_log_impl(&dword_1B5ED0000, v71, OS_LOG_TYPE_DEFAULT, "[%s|%s] Applying alignement delay of %u samples to the %s", v104, 0x26u);
        }

        if (v70 <= 0)
          v69 = (uint64_t *)(v5 + 15120);
        v102 = v5 + 15148;
        v103 = 1;
        caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 15148));
        v75 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 128), 0) + 108);
        if (v70 >= 0)
          v76 = v70;
        else
          v76 = -v70;
        IR::FixedIntegerDelay::FixedIntegerDelay((IR::FixedIntegerDelay *)v104, v76, 1);
        std::vector<IR::FixedIntegerDelay>::resize(v69, v75, (IR::FixedIntegerDelay *)v104);
        if (*(_QWORD *)((char *)__p + 2))
        {
          *(_QWORD *)((char *)&__p[1] + 2) = *(_QWORD *)((char *)__p + 2);
          operator delete(*(void **)((char *)__p + 2));
        }
        if (*(_QWORD *)&v104[8])
        {
          *(_QWORD *)&v104[16] = *(_QWORD *)&v104[8];
          operator delete(*(void **)&v104[8]);
        }
        v77 = v95;
        atomic_store(v70 > 0, v95);
        v78 = atomic_load(v77);
        atomic_store((v78 & 1) == 0, v77 + 1);
        std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v102);
      }
    }
  }
  v79 = atomic_load((unsigned __int8 *)(v5 + 904));
  if (!(((v79 & 1) == 0) | v9 & 1))
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v80 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
    {
      v91 = (_QWORD *)(v5 + 3592);
      if (*(char *)(v5 + 3615) < 0)
        v91 = (_QWORD *)*v91;
      *(_DWORD *)v104 = 136315394;
      *(_QWORD *)&v104[4] = v91;
      *(_WORD *)&v104[12] = 2080;
      *(_QWORD *)&v104[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1B5ED0000, v80, OS_LOG_TYPE_DEBUG, "[%s|%s] Resetting FDN", v104, 0x16u);
    }

    caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v5 + 2192));
    FeedbackDelayNetwork<float>::Reset((_OWORD *)(v5 + 912));
    caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v5 + 2192));
  }
  atomic_store(v9 & 1, (unsigned __int8 *)(v5 + 904));
  v81 = atomic_load((unsigned __int8 *)(v5 + 2320));
  if (((v81 & 1) == 0) | v7 & 1)
  {
    v82 = atomic_load((unsigned __int8 *)(v5 + 2320));
    if ((((v82 & 1) == 0) & v7) == 1)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v83 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
      {
        v94 = (_QWORD *)(v5 + 3592);
        if (*(char *)(v5 + 3615) < 0)
          v94 = (_QWORD *)*v94;
        *(_DWORD *)v104 = 136315394;
        *(_QWORD *)&v104[4] = v94;
        *(_WORD *)&v104[12] = 2080;
        *(_QWORD *)&v104[14] = "UpdateReverbIfNecessary";
        _os_log_debug_impl(&dword_1B5ED0000, v83, OS_LOG_TYPE_DEBUG, "[%s|%s] Updating HRTFHQ reverb", v104, 0x16u);
      }

      *(_QWORD *)v104 = v5 + 2256;
      *(_QWORD *)&v104[8] = v5 + 3320;
      std::lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(v5 + 2256, v5 + 3320);
      atomic_load((unsigned int *)(v5 + 3656));
      v84 = operator new();
      IR::IRProcessor::IRProcessor(v84);
      v85 = *(_QWORD *)(v5 + 2248);
      *(_QWORD *)(v5 + 2248) = v84;
      if (v85)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v85 + 8))(v85);
        v84 = *(_QWORD *)(v5 + 2248);
      }
      v86 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v5 + 128), 0) + 80);
      (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)v84 + 16))(v84, *(unsigned int *)(v5 + 336), 128, 0, 0, 0, 0, v86);
      atomic_store((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 2248) + 128))(*(_QWORD *)(v5 + 2248)), (unsigned int *)(v5 + 2316));
      std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100]((uint64_t *)v104);
    }
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v87 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
    {
      v92 = (_QWORD *)(v5 + 3592);
      if (*(char *)(v5 + 3615) < 0)
        v92 = (_QWORD *)*v92;
      *(_DWORD *)v104 = 136315394;
      *(_QWORD *)&v104[4] = v92;
      *(_WORD *)&v104[12] = 2080;
      *(_QWORD *)&v104[14] = "UpdateReverbIfNecessary";
      _os_log_debug_impl(&dword_1B5ED0000, v87, OS_LOG_TYPE_DEBUG, "[%s|%s] Resetting HRTFHQ reverb", v104, 0x16u);
    }

    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(v5 + 2256);
    (*(void (**)(_QWORD))(**(_QWORD **)(v5 + 2248) + 32))(*(_QWORD *)(v5 + 2248));
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v5 + 2256);
  }
  atomic_store(v7 & 1, (unsigned __int8 *)(v5 + 2320));
  if (((v33 | v7 | v9 | v34) & 1) == 0)
  {
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(v5 + 3320);
    v88 = *(_QWORD *)(v5 + 2904);
    if (v88)
      (*(void (**)(uint64_t))(*(_QWORD *)v88 + 24))(v88);
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v5 + 3320);
  }
  return std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v100);
}

void sub_1B619A80C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, caulk::pooled_semaphore_mutex *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void AUSM::RoomCongruence::ProcessingResult::~ProcessingResult(AUSM::RoomCongruence::ProcessingResult *this)
{
  const void *v2;
  const void *v3;

  v2 = (const void *)*((_QWORD *)this + 21);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 20);
  if (v3)
    CFRelease(v3);
  if (*((_BYTE *)this + 152))
    IR::IRDataAttributes::~IRDataAttributes(this);
}

BOOL AUSpatialMixerV2::IsSupportedPersonalizedHRTF(AUSpatialMixerV2 *this)
{
  unsigned int v1;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  ausdk::AUScope *v6;
  BOOL v7;
  uint64_t Element;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  char *v13;
  char v14;

  v1 = atomic_load((unsigned int *)this + 918);
  if (v1 == 1)
  {
    v13 = (char *)this + 3352;
    v14 = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
    v3 = *((_QWORD *)this + 15);
    if (v3)
    {
      LODWORD(v4) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
      if ((_DWORD)v4)
        goto LABEL_4;
    }
    else
    {
      v4 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
      if ((_DWORD)v4)
      {
LABEL_4:
        v5 = 0;
        v6 = (AUSpatialMixerV2 *)((char *)this + 80);
        v7 = 1;
        do
        {
          Element = ausdk::AUScope::SafeGetElement(v6, v5);
          v9 = atomic_load((unsigned int *)(Element + 1128));
          if (v9 == 7)
          {
            v10 = atomic_load((unsigned int *)(*(_QWORD *)(Element + 1688) + 80));
            if (v10 != 1 && (v10 || *(_DWORD *)(*(_QWORD *)(Element + 1680) + 108) <= 1u))
            {
              v11 = atomic_load((unsigned int *)(*(_QWORD *)(Element + 1688) + 72));
              if (v11 != 5)
                break;
            }
          }
          v7 = ++v5 < v4;
        }
        while ((_DWORD)v4 != v5);
        goto LABEL_15;
      }
    }
    v7 = 0;
LABEL_15:
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v13);
    return v7;
  }
  return 0;
}

void sub_1B619AB08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN16AUSpatialMixerV215PropertyChangedEj_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  unsigned __int8 v3;
  const void *v4;
  const void *v5;
  uint64_t v6;
  const void *v7;
  NSObject *v8;
  NSObject *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint8_t buf[4];
  _QWORD *v14;
  __int16 v15;
  const char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v2 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v10 = (_QWORD *)(v1 + 3592);
    if (*(char *)(v1 + 3615) < 0)
      v10 = (_QWORD *)*v10;
    *(_DWORD *)buf = 136315394;
    v14 = v10;
    v15 = 2080;
    v16 = "PropertyChanged_block_invoke";
    _os_log_debug_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "[%s|%s] dispatched update for dynamic XTC filter generation #:", buf, 0x16u);
  }

  v3 = atomic_load((unsigned __int8 *)(v1 + 2864));
  if ((v3 & 1) != 0)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v9 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      v11 = (_QWORD *)(v1 + 3592);
      if (*(char *)(v1 + 3615) < 0)
        v11 = (_QWORD *)*v11;
      *(_DWORD *)buf = 136315394;
      v14 = v11;
      v15 = 2080;
      v16 = "PropertyChanged_block_invoke";
      _os_log_debug_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "[%s|%s] update dropped", buf, 0x16u);
    }

  }
  else if (*(_QWORD *)(v1 + 7400))
  {
    v4 = *(const void **)(v1 + 3256);
    v5 = *(const void **)(v1 + 3248);
    *(_QWORD *)(v1 + 3256) = v5;
    if (v5)
      CFRetain(v5);
    if (v4)
      CFRelease(v4);
    v6 = *(_QWORD *)(v1 + 7400);
    v7 = *(const void **)(v1 + 3248);
    if (v7)
      CFRetain(*(CFTypeRef *)(v1 + 3248));
    AUSpatialMixerV2DynamicXTCFilter::updateParamDictionary(v6, v7);
    if (v7)
      CFRelease(v7);
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v8 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v12 = (_QWORD *)(v1 + 3592);
      if (*(char *)(v1 + 3615) < 0)
        v12 = (_QWORD *)*v12;
      *(_DWORD *)buf = 136315394;
      v14 = v12;
      v15 = 2080;
      v16 = "PropertyChanged_block_invoke";
      _os_log_debug_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_DEBUG, "[%s|%s] updating dynamic XTC filters", buf, 0x16u);
    }

    AUSpatialMixerV2DynamicXTCFilter::updateFilters(*(AUSpatialMixerV2DynamicXTCFilter **)(v1 + 7400));
    AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements((AUSpatialMixerV2 *)v1, 3202);
  }
}

void sub_1B619ADDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t AUSpatialMixerV2::UpdateReverbRoomType(AUSpatialMixerV2 *this)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  unsigned __int8 v5;
  char v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  double v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  _QWORD v18[2];
  uint64_t v19;
  char *v20;

  v2 = atomic_load((unsigned __int8 *)this + 7441);
  if ((v2 & 1) != 0)
  {
    v3 = atomic_load((unsigned __int8 *)this + 2760);
    if ((v3 & 1) != 0 || (v4 = atomic_load((unsigned __int8 *)this + 2761), (v4 & 1) != 0))
    {
      v5 = atomic_load((unsigned __int8 *)this + 2760);
      v6 = v5 & 1;
      v7 = atomic_load((unsigned __int8 *)this + 2761);
      AUSpatialMixerV2::UpdateAutoModeReverb(this, v6, v7 & 1, -1);
    }
    v8 = atomic_load((unsigned __int8 *)this + 2320);
    if ((v8 & 1) != 0)
    {
      v19 = (uint64_t)this + 2256;
      v20 = (char *)this + 3320;
      std::lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>((uint64_t)this + 2256, (uint64_t)this + 3320);
      atomic_load((unsigned int *)this + 914);
      v9 = operator new();
      IR::IRProcessor::IRProcessor(v9);
      v10 = *((_QWORD *)this + 281);
      *((_QWORD *)this + 281) = v9;
      if (v10)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
        v9 = *((_QWORD *)this + 281);
      }
      v11 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 80);
      (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)v9 + 16))(v9, *((unsigned int *)this + 84), 128, 0, 0, 0, 0, v11);
      atomic_store((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 281) + 128))(*((_QWORD *)this + 281)), (unsigned int *)this + 579);
      std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100](&v19);
    }
  }
  AUSpatialMixerV2::UpdateReverbIfNecessary((uint64_t)this, -1, *((_BYTE *)this + 17) == 0, 0);
  v18[0] = (char *)this + 2192;
  v18[1] = (char *)this + 3320;
  while (1)
  {
    v19 = (uint64_t)this + 2192;
    LOBYTE(v20) = 1;
    caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2 *)((char *)this + 2192));
    if ((caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 3320) & 1) != 0)
    {
      v19 = 0;
      LOBYTE(v20) = 0;
      std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v19);
      goto LABEL_15;
    }
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v19);
    sched_yield();
    v19 = (uint64_t)this + 3320;
    LOBYTE(v20) = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
    if ((caulk::pooled_semaphore_mutex::try_lock((AUSpatialMixerV2 *)((char *)this + 2192)) & 1) != 0)
      break;
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v19);
    sched_yield();
  }
  v19 = 0;
  LOBYTE(v20) = 0;
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v19);
LABEL_15:
  v12 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 80);
  v13 = atomic_load((unsigned int *)this + 914);
  atomic_store(1u, (unsigned __int8 *)this + 2176);
  v14 = atomic_load((unsigned int *)this + 914);
  v15 = 33 * v13;
  switch(v14)
  {
    case 0u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.002, 0.014, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 0.3, 0.08);
      v16 = 0x3FD3333333333333;
      goto LABEL_33;
    case 1u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.005, 0.045, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 0.85, 0.3);
      v16 = 0x3FEB333333333333;
      goto LABEL_33;
    case 2u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.01, 0.07, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 1.0, 0.6);
      goto LABEL_27;
    case 3u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.01, 0.07, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 2.1, 1.1);
      goto LABEL_30;
    case 4u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.018, 0.1, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 2.9, 2.0);
      goto LABEL_32;
    case 5u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.005, 0.045, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 7.0, 2.5);
      v16 = 0x401C000000000000;
      goto LABEL_33;
    case 6u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.01, 0.028, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 1.2, 0.37);
      v16 = 0x3FF3333333333333;
      goto LABEL_33;
    case 7u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.01, 0.028, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 2.0, 0.67);
      v16 = 0x4000000000000000;
      goto LABEL_33;
    case 8u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.03, 0.2, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 9.0, 3.0);
      v16 = 0x4022000000000000;
      goto LABEL_33;
    case 9u:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.0065, 0.08, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 1.0, 0.6);
LABEL_27:
      v16 = 0x3FF0000000000000;
      goto LABEL_33;
    case 0xAu:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.006, 0.04, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 2.1, 1.1);
      goto LABEL_30;
    case 0xBu:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.008, 0.055, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 2.1, 1.1);
LABEL_30:
      v16 = 0x4000CCCCCCCCCCCDLL;
      goto LABEL_33;
    case 0xCu:
      FeedbackDelayNetwork<float>::SetDelayTime((uint64_t)this + 912, v15, 0.006, 0.04, v12);
      FeedbackDelayNetwork<float>::SetDecayTime((uint64_t)this + 912, 2.9, 2.0);
LABEL_32:
      v16 = 0x4007333333333333;
LABEL_33:
      *((_QWORD *)this + 273) = v16;
      break;
    default:
      atomic_store(0, (unsigned __int8 *)this + 2176);
      break;
  }
  FeedbackDelayNetwork<float>::Reset((_OWORD *)this + 57);
  atomic_store((v12 * (*((double *)this + 273) + *((double *)this + 273))), (unsigned int *)this + 561);
  return std::scoped_lock<caulk::pooled_semaphore_mutex,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100]((uint64_t)v18);
}

void sub_1B619B3A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  MEMORY[0x1BCC95CEC](v3, 0x10E1C40AE0E3EF2);
  std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2::UpdateCounteractRotationShader(AUSpatialMixerV2 *this)
{
  unsigned __int8 v2;
  float v3;
  IR::IRDataLoader *v4;
  CFTypeRef v5;
  unsigned __int8 *v6;
  uint64_t v7;
  IR::IRDataLoader *v8;
  IR::IRDataLoader *v9;
  int BooleanFromDictionary;
  unsigned __int8 v11;
  unsigned __int8 v12;
  NSObject *v13;
  _QWORD *v14;
  const char *v15;
  CFTypeRef v16;
  CFTypeRef cf;
  CFTypeRef v18;
  float v19;
  BOOL v20;
  CFTypeRef v21;
  CFTypeRef v22;
  CFTypeRef v23;
  _BYTE buf[12];
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  IR::getPresetDataAttributes();
  v2 = atomic_load((unsigned __int8 *)this + 3744);
  v20 = (v2 & 1) == 0;
  v3 = *(double *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 80);
  v19 = v3;
  AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&cf, (uint64_t)this + 3904);
  v4 = (IR::IRDataLoader *)cf;
  if (cf)
  {
    v5 = v18;
    v18 = cf;
    v4 = (IR::IRDataLoader *)CFRetain(cf);
    if (v5)
      CFRelease(v5);
  }
  v6 = (unsigned __int8 *)this + 6092;
  if (!v18
    || (v7 = IR::IRDataLoader::instance(v4), v8 = (IR::IRDataLoader *)MEMORY[0x1BCC94C18](v7, &v18), !(_DWORD)v8))
  {
    v12 = atomic_load(v6);
    if ((v12 & 1) != 0)
      goto LABEL_26;
    BooleanFromDictionary = 1;
    goto LABEL_16;
  }
  v9 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v8);
  IR::IRDataLoader::getUserData(v9, (const IR::IRDataAttributes *)&v18);
  if (v16)
    CFRetain(v16);
  std::string::basic_string[abi:ne180100]<0>(buf, "CounteractRotationShader");
  BooleanFromDictionary = IR::IRData::getBooleanFromDictionary();
  if (SHIBYTE(v27) < 0)
    operator delete(*(void **)buf);
  if (v16)
  {
    CFRelease(v16);
    CFRelease(v16);
  }
  v11 = atomic_load(v6);
  if (BooleanFromDictionary != (v11 & 1))
  {
LABEL_16:
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v13 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v14 = (_QWORD *)*v14;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v14;
      v25 = 2080;
      v26 = "UpdateCounteractRotationShader";
      if (BooleanFromDictionary)
        v15 = "true";
      else
        v15 = "false";
      v27 = 2080;
      v28 = v15;
      _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting CounteractRotationShader = %s", buf, 0x20u);
    }

    atomic_store(BooleanFromDictionary, v6);
    atomic_store(1u, (unsigned __int8 *)this + 7363);
  }
LABEL_26:
  if (cf)
    CFRelease(cf);
  if (v23)
    CFRelease(v23);
  if (v22)
    CFRelease(v22);
  if (v21)
    CFRelease(v21);
  if (v18)
    CFRelease(v18);
}

void sub_1B619B690(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void AUSpatialMixerV2::UpdateAutoModeReverb(AUSpatialMixerV2 *this, char a2, char a3, int a4)
{
  unsigned __int8 v4;
  unsigned __int8 v6;
  NSObject *v7;
  _QWORD *v8;
  unsigned __int8 v12;
  _QWORD *v13;
  _QWORD *v14;
  unsigned int v15;
  unint64_t v16;
  char **v17;
  unsigned __int8 v18;
  void (*v19)(uint64_t, _QWORD *);
  uint64_t v20;
  unsigned int v21;
  _QWORD v22[5];
  int v23;
  char v24;
  char v25;
  char *v26;
  char v27;
  _BYTE buf[24];
  void *__p;
  void *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v4 = atomic_load((unsigned __int8 *)this + 7441);
  if ((v4 & 1) != 0)
  {
    v6 = atomic_load((unsigned __int8 *)this + 2556);
    if ((v6 & 1) == 0)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v7 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v8 = (_QWORD *)*v8;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v8;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "UpdateAutoModeReverb";
        _os_log_debug_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_DEBUG, "[%s|%s] auto mode reverb not initialized", buf, 0x16u);
      }
      goto LABEL_27;
    }
    v12 = atomic_load((unsigned __int8 *)this + 3744);
    if ((v12 & 1) != 0
      && ((v15 = atomic_load((unsigned int *)this + 918), v15 == 1)
       || (v21 = atomic_load((unsigned int *)this + 918), v21 == 2)
       && AUSM::GlobalProperties::hasXTCIR((AUSpatialMixerV2 *)((char *)this + 3584))))
    {
      v16 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0) + 108);
      if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)this + 324) - *((_QWORD *)this + 323)) >> 3) != v16)
      {
        v26 = (char *)this + 2608;
        v27 = 1;
        caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2 *)((char *)this + 2608));
        IR::FixedIntegerDelay::FixedIntegerDelay((IR::FixedIntegerDelay *)buf, 0x80u, 1);
        std::vector<IR::FixedIntegerDelay>::resize((uint64_t *)this + 323, v16, (IR::FixedIntegerDelay *)buf);
        if (__p)
        {
          v30 = __p;
          operator delete(__p);
        }
        if (*(_QWORD *)&buf[8])
        {
          *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
          operator delete(*(void **)&buf[8]);
        }
        v17 = &v26;
        goto LABEL_22;
      }
    }
    else if (*((_QWORD *)this + 324) != *((_QWORD *)this + 323))
    {
      *(_QWORD *)buf = (char *)this + 2608;
      buf[8] = 1;
      caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2 *)((char *)this + 2608));
      v13 = (_QWORD *)*((_QWORD *)this + 324);
      v14 = (_QWORD *)*((_QWORD *)this + 323);
      while (v13 != v14)
      {
        v13 -= 7;
        std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(v13);
      }
      *((_QWORD *)this + 324) = v14;
      v17 = (char **)buf;
LABEL_22:
      std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)v17);
    }
    v18 = atomic_load((unsigned __int8 *)this + 3668);
    if ((v18 & 1) != 0)
      v19 = (void (*)(uint64_t, _QWORD *))MEMORY[0x1E0C82F90];
    else
      v19 = (void (*)(uint64_t, _QWORD *))MEMORY[0x1E0C82C00];
    v7 = *((_QWORD *)this + 356);
    applesauce::dispatch::v1::queue::get(v7);
    v20 = objc_claimAutoreleasedReturnValue();
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3221225472;
    v22[2] = ___ZN16AUSpatialMixerV220UpdateAutoModeReverbEbbi_block_invoke;
    v22[3] = &__block_descriptor_46_e5_v8__0l;
    v22[4] = this;
    v23 = a4;
    v24 = a2;
    v25 = a3;
    v19(v20, v22);
LABEL_27:

  }
}

void sub_1B619B9E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  IR::FixedIntegerDelay::~FixedIntegerDelay((IR::FixedIntegerDelay *)va1);
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements(AUSpatialMixerV2 *this, uint64_t a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  unsigned int i;
  uint64_t v7;
  uint64_t v8;
  uint64_t Element;
  unsigned int v10;
  char *v12;
  char v13;

  v2 = atomic_load((unsigned __int8 *)this + 7441);
  if ((v2 & 1) == 0)
    return 0;
  v12 = (char *)this + 3352;
  v13 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
  v3 = 0;
  for (i = 0; ; ++i)
  {
    v7 = *((_QWORD *)this + 15);
    if (v7)
      LODWORD(v8) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
    else
      v8 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (i >= v8)
      break;
    Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), i);
    v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)Element + 136))(Element, a2);
    if (v10)
      v3 = v10;
    else
      v3 = v3;
  }
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v12);
  return v3;
}

void sub_1B619BAE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2::ReloadFactoryPresetIfNecessary(AUSpatialMixerV2 *this)
{
  unsigned int v2;
  NSObject *v3;
  NSObject *v4;
  int *v5;
  int v6;
  NSObject *v7;
  CFDictionaryRef *v8;
  CFDictionaryRef *v9;
  void *v10;
  id v11;
  const __CFArray **v12;
  const __CFArray **v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t i;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  int v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  void *v31;
  const void *v32;
  CFTypeRef v33;
  char v34;
  id v35;
  char v36;
  int v37;
  __int128 v38;
  uint8_t buf[4];
  _QWORD *v40;
  __int16 v41;
  _BYTE v42[10];
  unsigned int v43;
  __int16 v44;
  int v45;
  void *v46;
  _BYTE v47[128];
  _QWORD v48[4];

  v48[1] = *MEMORY[0x1E0C80C00];
  if (!ausdk::AUBase::DispatchGetProperty(this, 36, 0, 0, &v38))
  {
    v2 = v38;
    CFRelease(*((CFTypeRef *)&v38 + 1));
    if (v2 == -1 || !*((_DWORD *)this + 1848))
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v4 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        v23 = (_QWORD *)((char *)this + 3592);
        if (*((char *)this + 3615) < 0)
          v23 = (_QWORD *)*v23;
        *(_DWORD *)buf = 136315394;
        v40 = v23;
        v41 = 2080;
        *(_QWORD *)v42 = "ReloadFactoryPresetIfNecessary";
        _os_log_debug_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "[%s|%s] No headphone factory preset was set.", buf, 0x16u);
      }

    }
    else
    {
      v37 = 0;
      if ((*(unsigned int (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, int *))(*(_QWORD *)this + 88))(this, 3116, 0, 0, &v37))
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v3 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        {
          v24 = (_QWORD *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v24 = (_QWORD *)*v24;
          *(_DWORD *)buf = 136315394;
          v40 = v24;
          v41 = 2080;
          *(_QWORD *)v42 = "ReloadFactoryPresetIfNecessary";
          _os_log_error_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_ERROR, "[%s|%s] Could not get personalized HRTF status.", buf, 0x16u);
        }

      }
      else
      {
        v5 = (int *)((char *)this + 7392);
        if (v37)
          v6 = 2;
        else
          v6 = 1;
        if (*v5 == v6)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v7 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
          {
            v25 = (_QWORD *)((char *)this + 3592);
            if (*((char *)this + 3615) < 0)
              v25 = (_QWORD *)*v25;
            v26 = *v5;
            *(_DWORD *)buf = 136315906;
            v40 = v25;
            v41 = 2080;
            *(_QWORD *)v42 = "ReloadFactoryPresetIfNecessary";
            *(_WORD *)&v42[8] = 1024;
            v43 = v2;
            v44 = 1024;
            v45 = v26;
            _os_log_debug_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_DEBUG, "[%s|%s] FactoryPreset %u of subtype = %u is already loaded.", buf, 0x22u);
          }

        }
        else
        {
          AUSM::FactoryPreset::load((AUSM::FactoryPreset *)buf, (int *)this + 1848, v2, v37 != 0);
          if (*(_QWORD *)&v42[2])
          {
            v8 = (CFDictionaryRef *)applesauce::CF::DictionaryRef::operator->(&v42[2]);
            applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*&>(&v35, *v8, (const void *)AUSM::kFactoryPresetChannelOverridesKey);
            v9 = (CFDictionaryRef *)applesauce::CF::DictionaryRef::operator->(&v42[2]);
            applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*&>(&v33, *v9, (const void *)AUSM::kFactoryPresetGlobalPropertiesKey);
            v10 = (void *)objc_opt_new();
            if (v36)
            {
              v11 = v35;
              applesauce::dispatch::v1::queue::get(v35);
              objc_claimAutoreleasedReturnValue();
              objc_msgSend(v10, "setObject:forKeyedSubscript:", v11, AUSM::kFactoryPresetChannelOverridesKey);

            }
            if (v34)
            {
              applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&v32, v33);
              v12 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&v32);
              if (applesauce::CF::ArrayRef_proxy::get_size(*v12))
              {
                v13 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&v32);
                applesauce::CF::details::at_to<applesauce::CF::DictionaryRef>(*v13, 0, (applesauce::CF::DictionaryRef *)&v31);
                v14 = (void *)objc_msgSend(v31, "mutableCopy");
                objc_msgSend(&unk_1E6A11A80, "stringValue");
                v15 = (void *)objc_claimAutoreleasedReturnValue();
                v48[0] = v15;
                objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v48, 1);
                v16 = (void *)objc_claimAutoreleasedReturnValue();

                v29 = 0u;
                v30 = 0u;
                v27 = 0u;
                v28 = 0u;
                objc_msgSend(v14, "allKeys", 0);
                v17 = (void *)objc_claimAutoreleasedReturnValue();
                v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v27, v47, 16);
                if (v18)
                {
                  v19 = *(_QWORD *)v28;
                  do
                  {
                    for (i = 0; i != v18; ++i)
                    {
                      if (*(_QWORD *)v28 != v19)
                        objc_enumerationMutation(v17);
                      v21 = *(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * i);
                      if ((objc_msgSend(v16, "containsObject:", v21) & 1) == 0)
                        objc_msgSend(v14, "removeObjectForKey:", v21);
                    }
                    v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v27, v47, 16);
                  }
                  while (v18);
                }

                v46 = v14;
                objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v46, 1);
                v22 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v10, "setObject:forKeyedSubscript:", v22, AUSM::kFactoryPresetGlobalPropertiesKey);

                applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v31);
              }
              applesauce::CF::ArrayRef::~ArrayRef(&v32);
            }
            (*(void (**)(AUSpatialMixerV2 *, void *))(*(_QWORD *)this + 288))(this, v10);
            ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)this, (const AUPreset *)buf);

            std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v33);
            std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v35);
            if (*(_QWORD *)&v42[2])
              CFRelease(*(CFTypeRef *)&v42[2]);
          }
        }
      }
    }
  }
}

void sub_1B619C058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18, const void *a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  void *v27;
  void *v28;
  void *v29;
  void *v30;

  applesauce::CF::DictionaryRef::~DictionaryRef(&a18);
  applesauce::CF::ArrayRef::~ArrayRef(&a19);

  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a20);
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a22);
  std::pair<AUPreset,applesauce::CF::DictionaryRef>::~pair((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(_QWORD *a1, uint64_t a2)
{
  std::mutex *v4;
  const void *v5;

  v4 = (std::mutex *)(a2 + 8);
  std::mutex::lock((std::mutex *)(a2 + 8));
  v5 = *(const void **)a2;
  if (v5)
    CFRetain(v5);
  *a1 = v5;
  std::mutex::unlock(v4);
}

void AUSpatialMixerV2::RefreshXTCTuningParameters(AUSpatialMixerV2 *this)
{
  IR::IRDataLoader *v2;
  CFTypeRef v3;
  unsigned __int8 v4;
  IR::IRDataLoader *v5;
  uint64_t v6;
  IR::IRDataLoader *v7;
  IR::IRDataLoader *v8;
  CFTypeRef *v9;
  IR::IRDataLoader *v10;
  void *v11;
  uint64_t v12;
  int v13;
  _BOOL4 v14;
  const __CFDictionary *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFDictionaryRef v20;
  const void *v21;
  uint64_t j;
  const void *v23;
  const void *v24;
  const __CFDictionary *v25;
  float v26;
  const __CFDictionary *v27;
  const __CFDictionary *v28;
  float v29;
  const __CFDictionary *v30;
  float v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  float v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  float v37;
  const __CFDictionary *v38;
  const __CFDictionary *v39;
  float v40;
  const __CFDictionary *v41;
  const __CFDictionary *v42;
  float v43;
  const __CFDictionary *v44;
  CFTypeRef v45;
  int BooleanFromDictionary;
  const __CFDictionary *v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  CFDictionaryRef CFDictionaryRef;
  const void *v55;
  uint64_t i;
  const void *v57;
  const void *v58;
  std::runtime_error *exception;
  std::runtime_error *v60;
  std::runtime_error *v61;
  std::runtime_error *v62;
  std::runtime_error *v63;
  std::runtime_error *v64;
  std::runtime_error *v65;
  std::runtime_error *v66;
  std::runtime_error *v67;
  std::runtime_error *v68;
  std::runtime_error *v69;
  std::runtime_error *v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  const void *v76[2];
  CFTypeRef v77;
  CFTypeRef v78;
  CFTypeRef cf;
  int FilterLength;
  CFTypeRef v81;
  float valuePtr;
  CFTypeRef v83[2];
  _BYTE v84[16];
  uint64_t v85;
  uint64_t v87;
  CFTypeRef v89;
  uint64_t v91;
  CFNumberRef v92;
  uint64_t v93;
  uint64_t v95;
  uint64_t v96;
  CFTypeRef v97[2];
  uint64_t v98;
  uint64_t v99;
  _BYTE v100[8];
  uint64_t v101;
  CFTypeRef *v102;
  uint64_t v103;
  float v104;
  float v105;
  float v106;
  uint64_t v107;

  v107 = *MEMORY[0x1E0C80C00];
  v81 = 0;
  FilterLength = 0;
  AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&cf, (uint64_t)this + 3904);
  v3 = cf;
  if (cf)
  {
    CFRetain(cf);
    v78 = v3;
    v4 = atomic_load((unsigned __int8 *)this + 3744);
    IR::IRDataAttributes::IRDataAttributes((uint64_t)v83, v3, 128, (v4 & 1) == 0, 48000.0);
    CFRelease(v3);
    v6 = IR::IRDataLoader::instance(v5);
    v7 = (IR::IRDataLoader *)MEMORY[0x1BCC94C18](v6, v83);
    if ((_DWORD)v7)
    {
      v8 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v7);
      IR::IRDataLoader::getUserData(v8, (const IR::IRDataAttributes *)v83);
      v9 = (CFTypeRef *)v81;
      v81 = v102;
      v102 = v9;
      if (v9)
        CFRelease(v9);
      v10 = (IR::IRDataLoader *)IR::IRDataLoader::instance((IR::IRDataLoader *)v9);
      FilterLength = IR::IRDataLoader::getFilterLength(v10, (const IR::IRDataAttributes *)v83);
    }
    if (v97[0])
      CFRelease(v97[0]);
    if (v92)
      CFRelease(v92);
    if (v89)
      CFRelease(v89);
    if (v83[0])
      CFRelease(v83[0]);
  }
  else if (*((_BYTE *)this + 6068))
  {
    IR::IRDataLoader::instance(v2);
    IR::IRDataLoader::getUserData();
    v11 = (void *)v81;
    v81 = v83[0];
    v83[0] = v11;
    if (v11)
      CFRelease(v11);
    IR::IRDataLoader::instance((IR::IRDataLoader *)v11);
    FilterLength = IR::IRDataLoader::getFilterLength();
  }
  v12 = *((_QWORD *)this + 925);
  if (v12)
  {
    v13 = *(unsigned __int8 *)(v12 + 57);
    v14 = *(_QWORD *)(v12 + 784) != 0;
  }
  else
  {
    v14 = 0;
    v13 = 0;
  }
  if (v81)
  {
    v83[0] = &v81;
    v76[0] = CFSTR("XTCSpeakerSpan");
    v15 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v15 & 0xFF00000000) != 0)
    {
      LODWORD(v102) = (_DWORD)v15;
    }
    else
    {
      v25 = (const __CFDictionary *)*((_QWORD *)this + 406);
      if (v25)
      {
        LODWORD(v83[0]) = 1101004800;
        v26 = applesauce::CF::at_or<float,char const(&)[12]>(v25, (uint64_t)v83);
      }
      else
      {
        v26 = 20.0;
      }
      *(float *)&v102 = v26;
    }
    if (!v81)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = CFSTR("XTCRegularization");
    v27 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v27 & 0xFF00000000) != 0)
    {
      HIDWORD(v102) = (_DWORD)v27;
    }
    else
    {
      v28 = (const __CFDictionary *)*((_QWORD *)this + 406);
      if (v28)
      {
        LODWORD(v83[0]) = 1086324736;
        v29 = applesauce::CF::at_or<float,char const(&)[15]>(v28, (uint64_t)v83);
      }
      else
      {
        v29 = 6.0;
      }
      *((float *)&v102 + 1) = v29;
    }
    if (!v81)
    {
      v60 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v60, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = CFSTR("XTCConstraint");
    v30 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v30 & 0xFF00000000) != 0)
    {
      LODWORD(v103) = (_DWORD)v30;
      v31 = *(float *)&v30;
    }
    else
    {
      v32 = (const __CFDictionary *)*((_QWORD *)this + 406);
      if (v32)
      {
        LODWORD(v83[0]) = 1107296256;
        v31 = applesauce::CF::at_or<float,char const(&)[11]>(v32, "Constraint", (uint64_t)v83);
      }
      else
      {
        v31 = 32.0;
      }
      *(float *)&v103 = v31;
    }
    if (!v81)
    {
      v61 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v61, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = CFSTR("XTCPostTimbralFrequency");
    v33 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v33 & 0xFF00000000) != 0)
    {
      HIDWORD(v103) = (_DWORD)v33;
      v34 = *(float *)&v33;
    }
    else
    {
      v35 = (const __CFDictionary *)*((_QWORD *)this + 406);
      if (v35)
      {
        LODWORD(v83[0]) = 1186693120;
        v34 = applesauce::CF::at_or<float,char const(&)[21]>(v35, (uint64_t)v83);
      }
      else
      {
        v34 = 24000.0;
      }
      *((float *)&v103 + 1) = v34;
    }
    if (!v81)
    {
      v62 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v62, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = CFSTR("XTCPostTimbralBlend");
    v36 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v36 & 0xFF00000000) != 0)
    {
      v104 = *(float *)&v36;
      v37 = *(float *)&v36;
    }
    else
    {
      v38 = (const __CFDictionary *)*((_QWORD *)this + 406);
      if (v38)
      {
        LODWORD(v83[0]) = 1120403456;
        v37 = applesauce::CF::at_or<float,char const(&)[17]>(v38, "PostTimbralBlend", (uint64_t)v83);
      }
      else
      {
        v37 = 100.0;
      }
      v104 = v37;
    }
    if (!v81)
    {
      v63 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v63, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = CFSTR("XTCCrossover");
    v39 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v39 & 0xFF00000000) != 0)
    {
      v105 = *(float *)&v39;
      v40 = *(float *)&v39;
    }
    else
    {
      v41 = (const __CFDictionary *)*((_QWORD *)this + 406);
      if (v41)
      {
        LODWORD(v83[0]) = 1175232512;
        v40 = applesauce::CF::at_or<float,char const(&)[10]>(v41, (uint64_t)v83);
      }
      else
      {
        v40 = *(float *)"";
      }
      v105 = v40;
    }
    if (!v81)
    {
      v64 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v64, "Could not construct");
    }
    v83[0] = &v81;
    v76[0] = CFSTR("XTCPostGain");
    v42 = applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*>((const __CFDictionary ***)v83, v76);
    if (((unint64_t)v42 & 0xFF00000000) != 0)
    {
      v106 = *(float *)&v42;
      v43 = *(float *)&v42;
    }
    else
    {
      v44 = (const __CFDictionary *)*((_QWORD *)this + 406);
      if (v44)
      {
        LODWORD(v83[0]) = 0;
        v43 = applesauce::CF::at_or<float,char const(&)[9]>(v44, (uint64_t)v83);
      }
      else
      {
        v43 = 0.0;
      }
      v106 = v43;
    }
    if (!v81)
    {
      v65 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v65, "Could not construct");
    }
    if (applesauce::CF::details::has_key<__CFString const*>((const __CFDictionary *)v81, CFSTR("CounteractRotationShader")))
    {
      v45 = v81;
      if (v81)
        CFRetain(v81);
      v77 = v45;
      std::string::basic_string[abi:ne180100]<0>(v83, "CounteractRotationShader");
      BooleanFromDictionary = IR::IRData::getBooleanFromDictionary();
      if ((v84[7] & 0x80000000) != 0)
        operator delete((void *)v83[0]);
      if (v77)
        CFRelease(v77);
    }
    else
    {
      v47 = (const __CFDictionary *)*((_QWORD *)this + 406);
      if (v47)
      {
        v48 = (unsigned __int16)applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[25]>(v47, "CounteractRotationShader");
        if (v48 <= 0x100)
          LOBYTE(v48) = 0;
        BooleanFromDictionary = v48 != 0;
      }
      else
      {
        BooleanFromDictionary = 0;
      }
    }
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float &>((applesauce::CF::TypeRef *)v83, "SpeakerSpan", (int *)&v102);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float &>((applesauce::CF::TypeRef *)v84, "Regularization", (int *)&v102 + 1);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v85, "Constraint");
    valuePtr = v31;
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      v66 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v66, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v87, "PostTimbralFrequency");
    valuePtr = v34;
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      v67 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v67, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v89, "PostTimbralBlend");
    valuePtr = v37;
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      v68 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v68, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v91, "Crossover");
    valuePtr = v40;
    v92 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    if (!v92)
    {
      v69 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v69, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v93, "PostGain");
    valuePtr = v43;
    if (!CFNumberCreate(0, kCFNumberFloatType, &valuePtr))
    {
      v70 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v70, "Could not construct");
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v95, "CounteractRotationShader");
    v49 = *MEMORY[0x1E0C9AE50];
    v50 = *MEMORY[0x1E0C9AE40];
    if (BooleanFromDictionary)
      v51 = *MEMORY[0x1E0C9AE50];
    else
      v51 = *MEMORY[0x1E0C9AE40];
    v96 = v51;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],int &>((applesauce::CF::TypeRef *)v97, &FilterLength);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v98, "MagicUnicorn");
    if (v13)
      v52 = v49;
    else
      v52 = v50;
    v99 = v52;
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v100, "ReferenceData");
    if (v14)
      v53 = v49;
    else
      v53 = v50;
    v101 = v53;
    v76[0] = v83;
    v76[1] = (const void *)11;
    CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v76);
    v55 = (const void *)*((_QWORD *)this + 406);
    *((_QWORD *)this + 406) = CFDictionaryRef;
    if (v55)
      CFRelease(v55);
    for (i = 0; i != -176; i -= 16)
    {
      v57 = *(const void **)((char *)&v101 + i);
      if (v57)
        CFRelease(v57);
      v58 = *(const void **)&v100[i];
      if (v58)
        CFRelease(v58);
    }
  }
  else
  {
    LODWORD(v76[0]) = 1101004800;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float>((applesauce::CF::TypeRef *)v83, (int *)v76);
    valuePtr = 6.0;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float>((applesauce::CF::TypeRef *)v84, (int *)&valuePtr);
    v75 = 1107296256;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float>((applesauce::CF::TypeRef *)&v85, &v75);
    v74 = 1186693120;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[21],float>((applesauce::CF::TypeRef *)&v87, &v74);
    v73 = 1120403456;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[17],float>((applesauce::CF::TypeRef *)&v89, "PostTimbralBlend", &v73);
    v72 = 1175232512;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[10],float>((applesauce::CF::TypeRef *)&v91, &v72);
    v71 = 0;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],float>((applesauce::CF::TypeRef *)&v93, &v71);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v95, "CounteractRotationShader");
    v16 = *MEMORY[0x1E0C9AE40];
    v96 = *MEMORY[0x1E0C9AE40];
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],int &>((applesauce::CF::TypeRef *)v97, &FilterLength);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v98, "MagicUnicorn");
    v17 = *MEMORY[0x1E0C9AE50];
    if (v13)
      v18 = *MEMORY[0x1E0C9AE50];
    else
      v18 = v16;
    v99 = v18;
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v100, "ReferenceData");
    if (v14)
      v19 = v17;
    else
      v19 = v16;
    v101 = v19;
    v102 = v83;
    v103 = 11;
    v20 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v102);
    v21 = (const void *)*((_QWORD *)this + 406);
    *((_QWORD *)this + 406) = v20;
    if (v21)
      CFRelease(v21);
    for (j = 0; j != -176; j -= 16)
    {
      v23 = *(const void **)((char *)&v101 + j);
      if (v23)
        CFRelease(v23);
      v24 = *(const void **)&v100[j];
      if (v24)
        CFRelease(v24);
    }
  }
  if (cf)
    CFRelease(cf);
  if (v81)
    CFRelease(v81);
}

void sub_1B619CD04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,CFTypeRef cf)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

BOOL AUSpatialMixerV2::InitializeDynamicXTC(uint64_t a1, CFURLRef *a2)
{
  const __CFString *v4;
  int v5;
  CFURLRef v6;
  const void *v7;
  const void *v8;
  unsigned __int8 v9;
  void *v10;
  void (*v11)(void *, _QWORD *);
  CFTypeRef v12;
  CFTypeRef v13;
  CFTypeRef v14;
  CFTypeRef v15;
  CFURLRef v16;
  unsigned __int8 v17;
  void (*v18)(uint64_t, _QWORD *);
  void *v19;
  uint64_t v20;
  _QWORD v22[5];
  CFTypeRef v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  char v27;
  CFTypeRef v28;
  __int128 v29;
  CFTypeRef v30;
  _OWORD v31[2];
  CFTypeRef v32;
  uint64_t v33;
  int v34;
  CFTypeRef v35;
  CFURLRef v36;
  CFTypeRef cf;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  char v41;
  CFTypeRef v42;
  __int128 v43;
  CFTypeRef v44;
  _OWORD v45[2];
  CFTypeRef v46;
  uint64_t v47;
  int v48;
  _QWORD v49[5];
  CFRange result;
  CFRange v51;

  v4 = CFURLGetString(*a2);
  v51.length = CFStringGetLength(v4);
  v51.location = 0;
  v5 = CFStringFindWithOptions(v4, CFSTR("Tuning_Mode_HRTFXTC_Reference_Data"), v51, 1uLL, &result);
  if (v5)
  {
    v6 = *a2;
    if (*a2)
      CFRetain(*a2);
    v36 = v6;
    IR::IRDataAttributes::IRDataAttributes((uint64_t)&cf, v6, 128, 1, 48000.0);
    if (v6)
      CFRelease(v6);
    v7 = *(const void **)(a1 + 3256);
    if (v7)
    {
      v8 = *(const void **)(a1 + 3248);
      *(_QWORD *)(a1 + 3248) = v7;
      CFRetain(v7);
      if (v8)
        CFRelease(v8);
    }
    v9 = atomic_load((unsigned __int8 *)(a1 + 3668));
    v10 = *(void **)(a1 + 2848);
    applesauce::dispatch::v1::queue::get(v10);
    objc_claimAutoreleasedReturnValue();
    if ((v9 & 1) != 0)
      v11 = (void (*)(void *, _QWORD *))MEMORY[0x1E0C82F90];
    else
      v11 = (void (*)(void *, _QWORD *))MEMORY[0x1E0C82C00];
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3321888768;
    v22[2] = ___ZN16AUSpatialMixerV220InitializeDynamicXTCEN10applesauce2CF6URLRefE_block_invoke_126;
    v22[3] = &__block_descriptor_200_ea8_40c27_ZTSN2IR16IRDataAttributesE192c28_ZTSN10applesauce2CF6URLRefE_e5_v8__0l;
    v22[4] = a1;
    v12 = cf;
    if (cf)
      CFRetain(cf);
    v23 = v12;
    v24 = v38;
    v25 = v39;
    v26 = v40;
    v27 = v41;
    v13 = v42;
    if (v42)
      CFRetain(v42);
    v28 = v13;
    v29 = v43;
    v14 = v44;
    if (v44)
      CFRetain(v44);
    v30 = v14;
    v31[0] = v45[0];
    *(_OWORD *)((char *)v31 + 9) = *(_OWORD *)((char *)v45 + 9);
    v15 = v46;
    if (v46)
      CFRetain(v46);
    v32 = v15;
    v33 = v47;
    v34 = v48;
    v16 = *a2;
    if (v16)
      CFRetain(v16);
    v35 = v16;
    v11(v10, v22);

    if (v35)
      CFRelease(v35);
    if (v32)
      CFRelease(v32);
    if (v30)
      CFRelease(v30);
    if (v28)
      CFRelease(v28);
    if (v23)
      CFRelease(v23);
    if (v46)
      CFRelease(v46);
    if (v44)
      CFRelease(v44);
    if (v42)
      CFRelease(v42);
    if (cf)
      CFRelease(cf);
  }
  else
  {
    v17 = atomic_load((unsigned __int8 *)(a1 + 3668));
    if ((v17 & 1) != 0)
      v18 = (void (*)(uint64_t, _QWORD *))MEMORY[0x1E0C82F90];
    else
      v18 = (void (*)(uint64_t, _QWORD *))MEMORY[0x1E0C82C00];
    v19 = *(void **)(a1 + 2848);
    applesauce::dispatch::v1::queue::get(v19);
    v20 = objc_claimAutoreleasedReturnValue();
    v49[0] = MEMORY[0x1E0C809B0];
    v49[1] = 3221225472;
    v49[2] = ___ZN16AUSpatialMixerV220InitializeDynamicXTCEN10applesauce2CF6URLRefE_block_invoke;
    v49[3] = &__block_descriptor_40_e5_v8__0l;
    v49[4] = a1;
    v18(v20, v49);

  }
  return v5 != 0;
}

void sub_1B619D310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,const void *a34)
{
  applesauce::CF::URLRef::~URLRef(&a34);
  _Unwind_Resume(a1);
}

void AUSM::AppleSauceCFWithMutex<__CFURL const*>::store(uint64_t a1, const void **a2)
{
  std::mutex *v4;
  const void *v5;
  const void *v6;

  v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  v5 = *(const void **)a1;
  v6 = *a2;
  *(_QWORD *)a1 = *a2;
  if (v6)
    CFRetain(v6);
  if (v5)
    CFRelease(v5);
  std::mutex::unlock(v4);
}

uint64_t caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  int v6;

  result = (uint64_t)pthread_self();
  v3 = result;
  v4 = atomic_load((unint64_t *)a1);
  if (result)
  {
    if (v4)
      v5 = result == v4;
    else
      v5 = 0;
    if (!v5)
      goto LABEL_9;
  }
  else if (v4)
  {
LABEL_9:
    result = caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(a1 + 12));
    atomic_store(v3, (unint64_t *)a1);
    v6 = 1;
    goto LABEL_10;
  }
  v6 = *(_DWORD *)(a1 + 8) + 1;
LABEL_10:
  *(_DWORD *)(a1 + 8) = v6;
  return result;
}

uint64_t caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  BOOL v4;
  int v5;
  int v6;

  result = (uint64_t)pthread_self();
  v3 = atomic_load((unint64_t *)a1);
  if (result)
  {
    if (v3)
      v4 = result == v3;
    else
      v4 = 0;
    if (!v4)
      goto LABEL_11;
  }
  else if (v3)
  {
LABEL_11:
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  v5 = *(_DWORD *)(a1 + 8);
  if (v5 <= 0)
  {
    _os_assert_log();
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v6 = v5 - 1;
    *(_DWORD *)(a1 + 8) = v6;
    if (!v6)
    {
LABEL_12:
      atomic_store(0, (unint64_t *)a1);
      return caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(a1 + 12));
    }
  }
  return result;
}

uint64_t AUSpatialMixerV2::LoadDynamicProcessorPreset(AUSpatialMixerV2 *this, int a2, CFURLRef *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  CFStringRef v8;
  const __CFString *v9;
  std::vector<char>::size_type MaximumSizeOfFileSystemRepresentation;
  int FileSystemRepresentation;
  uint64_t v12;
  NSObject *v13;
  CFTypeRef v15;
  int v16;
  int v17;
  NSObject *v18;
  _QWORD *v19;
  const char *v20;
  NSObject *v21;
  _QWORD *v22;
  const char *v23;
  const char *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  std::runtime_error *exception;
  std::string v29;
  CFTypeRef cf;
  std::string __p;
  CFStringRef string;
  CFTypeRef inData;
  _BYTE v34[32];
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!*a3)
    return 0;
  v5 = (uint64_t *)*((_QWORD *)this + 445);
  v6 = (uint64_t *)*((_QWORD *)this + 446);
  if (v5 != v6)
  {
    while (*(_DWORD *)(*v5 + 120) != a2)
    {
      if (++v5 == v6)
        goto LABEL_17;
    }
  }
  if (v5 == v6)
  {
LABEL_17:
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v13 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v22 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v22 = (_QWORD *)*v22;
      v23 = "????";
      if (a2 == 1818521197)
        v23 = "ldnm";
      *(_DWORD *)v34 = 136315906;
      *(_QWORD *)&v34[4] = v22;
      *(_QWORD *)&v34[14] = "FindDynamicProcessor";
      *(_WORD *)&v34[12] = 2080;
      if (a2 == 1667658347)
        v24 = "cfrk";
      else
        v24 = v23;
      *(_WORD *)&v34[22] = 2080;
      *(_QWORD *)&v34[24] = v24;
      v35 = 1024;
      v36 = a2;
      _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] can't find dynamics processor %s (%u).", v34, 0x26u);
    }

    return 4294967246;
  }
  v7 = *v5;
  if (!*v5)
    return 4294967246;
  v8 = CFURLCopyFileSystemPath(*a3, kCFURLPOSIXPathStyle);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&string, v8);
  v9 = string;
  if (!string)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(string);
  std::vector<char>::vector((std::vector<char> *)v34, MaximumSizeOfFileSystemRepresentation);
  FileSystemRepresentation = CFStringGetFileSystemRepresentation(v9, *(char **)v34, *(_QWORD *)&v34[8] - *(_QWORD *)v34);
  if (FileSystemRepresentation)
    std::string::basic_string[abi:ne180100]<0>(&__p, *(char **)v34);
  if (*(_QWORD *)v34)
  {
    *(_QWORD *)&v34[8] = *(_QWORD *)v34;
    operator delete(*(void **)v34);
  }
  if (FileSystemRepresentation)
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v29, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      goto LABEL_25;
    }
  }
  else
  {
    memset(&__p, 0, sizeof(__p));
  }
  v29 = __p;
LABEL_25:
  AUSM::loadAUPreset(&cf, (const char *)&v29);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v29.__r_.__value_.__l.__data_);
  v15 = cf;
  if (!cf)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v21 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v25 = (_QWORD *)(v7 + 72);
      if (*(char *)(v7 + 95) < 0)
        v25 = (_QWORD *)*v25;
      *(_DWORD *)v34 = 136315394;
      *(_QWORD *)&v34[4] = "loadPreset";
      *(_WORD *)&v34[12] = 2080;
      *(_QWORD *)&v34[14] = v25;
      _os_log_error_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_ERROR, "%s: null dictionary ref for %s", v34, 0x16u);
    }

    v12 = 4294967246;
    goto LABEL_54;
  }
  CFRetain(cf);
  v16 = *((_DWORD *)this + 84);
  v17 = *(unsigned __int8 *)(v7 + 124);
  if (*(_BYTE *)(v7 + 124))
  {
    v12 = AUSM::AUFXWrapper::uninitialize((OpaqueAudioComponentInstance **)v7);
    if ((_DWORD)v12)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v18 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        v27 = (_QWORD *)(v7 + 72);
        if (*(char *)(v7 + 95) < 0)
          v27 = (_QWORD *)*v27;
        *(_DWORD *)v34 = 136315650;
        *(_QWORD *)&v34[4] = "loadPreset";
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = v12;
        *(_WORD *)&v34[18] = 2080;
        *(_QWORD *)&v34[20] = v27;
        _os_log_error_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_ERROR, "%s: error %d uninitalizing %s", v34, 0x1Cu);
      }
      goto LABEL_52;
    }
  }
  inData = v15;
  if (!*(_QWORD *)v7)
  {
    v12 = 4294900552;
    goto LABEL_49;
  }
  v12 = AudioUnitSetProperty(*(AudioUnit *)v7, 0, 0, 0, &inData, 8u);
  if ((_DWORD)v12)
  {
LABEL_49:
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v18 = (id)getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      goto LABEL_52;
    v26 = (_QWORD *)(v7 + 72);
    if (*(char *)(v7 + 95) < 0)
      v26 = (_QWORD *)*v26;
    *(_DWORD *)v34 = 136315650;
    *(_QWORD *)&v34[4] = "loadPreset";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = v12;
    *(_WORD *)&v34[18] = 2080;
    *(_QWORD *)&v34[20] = v26;
    v20 = "%s: error %d setting preset on %s";
    goto LABEL_75;
  }
  if (!v17 || (v12 = AUSM::AUFXWrapper::initialize((AUSM::AUFXWrapper *)v7, v16), !(_DWORD)v12))
  {
    v12 = 0;
    goto LABEL_53;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v18 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    v19 = (_QWORD *)(v7 + 72);
    if (*(char *)(v7 + 95) < 0)
      v19 = (_QWORD *)*v19;
    *(_DWORD *)v34 = 136315650;
    *(_QWORD *)&v34[4] = "loadPreset";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = v12;
    *(_WORD *)&v34[18] = 2080;
    *(_QWORD *)&v34[20] = v19;
    v20 = "%s: error %d initalizing %s; processing disabled";
LABEL_75:
    _os_log_error_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_ERROR, v20, v34, 0x1Cu);
  }
LABEL_52:

LABEL_53:
  CFRelease(v15);
LABEL_54:
  if (cf)
    CFRelease(cf);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (string)
    CFRelease(string);
  return v12;
}

void sub_1B619DA64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,const void *a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  if (a24 < 0)
    operator delete(__p);
  applesauce::CF::StringRef::~StringRef(&a25);
  _Unwind_Resume(a1);
}

_QWORD *applesauce::CF::DictionaryRef::operator->(_QWORD *result)
{
  std::runtime_error *exception;

  if (!*result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_1B619DB54(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,__CFString const*&>(_BYTE *a1, CFDictionaryRef theDict, const void *a3)
{
  const void *v4;
  const void *v5;
  CFTypeID v6;
  char v7;

  v4 = applesauce::CF::details::at_key<__CFString const*&>(theDict, a3);
  if (!v4)
    goto LABEL_5;
  v5 = v4;
  CFRetain(v4);
  v6 = CFGetTypeID(v5);
  if (v6 != CFDictionaryGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    v7 = 0;
    *a1 = 0;
    goto LABEL_6;
  }
  *(_QWORD *)a1 = v5;
  v7 = 1;
LABEL_6:
  a1[8] = v7;
}

const void *applesauce::CF::details::at_key<__CFString const*&>(CFDictionaryRef theDict, const void *a2)
{
  const void *result;

  result = 0;
  if (theDict)
  {
    if (a2)
      return CFDictionaryGetValue(theDict, a2);
  }
  return result;
}

uint64_t AUSM::AUFXWrapper::uninitialize(OpaqueAudioComponentInstance **this)
{
  OpaqueAudioComponentInstance *v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD *v6;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (!v2)
    return 4294900552;
  v3 = AudioUnitUninitialize(v2);
  *((_BYTE *)this + 124) = 0;
  if ((_DWORD)v3)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v4 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = this + 9;
      if (*((char *)this + 95) < 0)
        v6 = (_QWORD *)*v6;
      v7 = 136315650;
      v8 = "uninitialize";
      v9 = 1024;
      v10 = v3;
      v11 = 2080;
      v12 = v6;
      _os_log_error_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_ERROR, "%s: error %d uninitializing %s", (uint8_t *)&v7, 0x1Cu);
    }

  }
  return v3;
}

uint64_t AUSM::AUFXWrapper::initialize(AUSM::AUFXWrapper *this, int a2)
{
  uint64_t Property;
  OpaqueAudioComponentInstance *v4;
  uint64_t v6;
  NSObject *v7;
  char v9;
  unint64_t v10;
  unsigned int v11;
  _DWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  NSObject *v16;
  _QWORD *v17;
  _QWORD *v18;
  unsigned int v19;
  int v20;
  NSObject *v21;
  _QWORD *v22;
  _QWORD *v23;
  UInt32 ioDataSize;
  int inData;
  _BYTE __x[12];
  __int16 v27;
  int v28;
  __int16 v29;
  _QWORD *v30;
  int outData;
  const char *v32;
  __int16 v33;
  _BYTE v34[10];
  _DWORD v35[4];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  Property = 4294900552;
  v4 = *(OpaqueAudioComponentInstance **)this;
  if (v4)
  {
    inData = a2;
    v6 = AudioUnitSetProperty(v4, 0xEu, 0, 0, &inData, 4u);
    if ((_DWORD)v6)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v7 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v17 = (_QWORD *)((char *)this + 72);
        if (*((char *)this + 95) < 0)
          v17 = (_QWORD *)*v17;
        outData = 136315906;
        v32 = "initialize";
        v33 = 1024;
        *(_DWORD *)v34 = v6;
        *(_WORD *)&v34[4] = 1024;
        *(_DWORD *)&v34[6] = inData;
        LOWORD(v35[0]) = 2080;
        *(_QWORD *)((char *)v35 + 2) = v17;
        _os_log_error_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_ERROR, "%s: error %d setting the maximum frames per slice = %u for %s", (uint8_t *)&outData, 0x22u);
      }
LABEL_11:

      *((_BYTE *)this + 124) = 0;
      return v6;
    }
    v6 = AudioUnitInitialize(*(AudioUnit *)this);
    if ((_DWORD)v6)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v7 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v18 = (_QWORD *)((char *)this + 72);
        if (*((char *)this + 95) < 0)
          v18 = (_QWORD *)*v18;
        outData = 136315394;
        v32 = "initialize";
        v33 = 2080;
        *(_QWORD *)v34 = v18;
        _os_log_error_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_ERROR, "%s: error initializing %s", (uint8_t *)&outData, 0x16u);
      }
      goto LABEL_11;
    }
    if (*((_DWORD *)this + 32) != 2)
    {
LABEL_39:
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v21 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        v22 = (_QWORD *)((char *)this + 72);
        if (*((char *)this + 95) < 0)
          v22 = (_QWORD *)*v22;
        outData = 136315394;
        v32 = "initialize";
        v33 = 2080;
        *(_QWORD *)v34 = v22;
        _os_log_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_INFO, "%s: initialized %s", (uint8_t *)&outData, 0x16u);
      }

      v6 = 0;
      *((_BYTE *)this + 124) = 1;
      return v6;
    }
    ioDataSize = 40;
    if (!*(_QWORD *)this
      || (Property = AudioUnitGetProperty(*(AudioUnit *)this, 8u, 1u, 0, &outData, &ioDataSize), (_DWORD)Property)
      || ioDataSize != 40)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v16 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v23 = (_QWORD *)((char *)this + 72);
        if (*((char *)this + 95) < 0)
          v23 = (_QWORD *)*v23;
        *(_DWORD *)__x = 136315650;
        *(_QWORD *)&__x[4] = "initialize";
        v27 = 1024;
        v28 = Property;
        v29 = 2080;
        v30 = v23;
        _os_log_error_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_ERROR, "%s: error %d getting input stream format of %s", __x, 0x1Cu);
      }

      *((_BYTE *)this + 124) = 0;
      return Property;
    }
    v9 = v33;
    v11 = v35[0];
    v10 = v35[1];
    *((_DWORD *)this + 53) = v35[1];
    std::vector<float>::resize((uint64_t)this + 136, (v10 * a2));
    v12 = (_DWORD *)*((_QWORD *)this + 20);
    v13 = *((_QWORD *)this + 21);
    v14 = (16 * v10) | 8;
    __x[0] = 0;
    v15 = v13 - (_QWORD)v12;
    if (v14 <= v15)
    {
      if (v14 < v15)
        *((_QWORD *)this + 21) = (char *)v12 + v14;
    }
    else
    {
      std::vector<char>::__append((std::vector<char> *)((char *)this + 160), v14 - v15, __x);
      v12 = (_DWORD *)*((_QWORD *)this + 20);
    }
    *v12 = v10;
    *(_QWORD *)__x = 0;
    std::vector<float *>::assign((char **)this + 23, v10, __x);
    if (!v11)
      goto LABEL_35;
    if ((v9 & 0x20) != 0)
    {
      v19 = 1;
    }
    else
    {
      v19 = v10;
      if (!(_DWORD)v10)
      {
LABEL_35:
        v20 = 0;
LABEL_38:
        AUSM::ABLBuffer::setupBufferList((AUSM::AUFXWrapper *)((char *)this + 136), v10, (v9 & 0x20) == 0, a2, v20);
        goto LABEL_39;
      }
    }
    v20 = v11 / v19;
    goto LABEL_38;
  }
  return Property;
}

char *std::vector<float *>::assign(char **a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  char *result;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v6 = (uint64_t)a1[2];
  result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 3)
  {
    v13 = (a1[1] - result) >> 3;
    if (v13 >= a2)
      v14 = a2;
    else
      v14 = (a1[1] - result) >> 3;
    for (; v14; --v14)
    {
      *(_QWORD *)result = *a3;
      result += 8;
    }
    if (a2 <= v13)
    {
      a1[1] = &(*a1)[8 * a2];
    }
    else
    {
      v15 = a1[1];
      v16 = &v15[8 * (a2 - v13)];
      v17 = 8 * a2 - 8 * v13;
      do
      {
        *(_QWORD *)v15 = *a3;
        v15 += 8;
        v17 -= 8;
      }
      while (v17);
      a1[1] = v16;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    v8 = v6 >> 2;
    if (v6 >> 2 <= a2)
      v8 = a2;
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8)
      v9 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v9 = v8;
    result = std::vector<std::tuple<unsigned int,float>>::__vallocate[abi:ne180100](a1, v9);
    v10 = a1[1];
    v11 = &v10[8 * a2];
    v12 = 8 * a2;
    do
    {
      *(_QWORD *)v10 = *a3;
      v10 += 8;
      v12 -= 8;
    }
    while (v12);
    a1[1] = v11;
  }
  return result;
}

unsigned int *AUSM::ABLBuffer::setupBufferList(AUSM::ABLBuffer *this, unsigned int a2, int a3, int a4, int a5)
{
  int v7;
  unsigned int *result;
  unsigned int v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int64_t v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;

  *((_DWORD *)this + 18) = a5;
  v7 = a5 * a4;
  if (a3)
  {
    result = (unsigned int *)*((_QWORD *)this + 3);
    *result = 1;
    *((_QWORD *)result + 2) = *(_QWORD *)this;
    result[2] = a2;
    result[3] = v7;
  }
  else
  {
    if (*((_DWORD *)this + 19) >= a2)
      v9 = a2;
    else
      v9 = *((_DWORD *)this + 19);
    result = (unsigned int *)*((_QWORD *)this + 3);
    *result = v9;
    if (v9)
    {
      v10 = 0;
      v11 = 0;
      v12 = *(_QWORD *)this;
      v13 = 16 * v9;
      do
      {
        v14 = (int *)&result[v11 / 4];
        *((_QWORD *)v14 + 2) = v12 + v10;
        v14[2] = 1;
        v14[3] = v7;
        v11 += 16;
        v10 += v7;
      }
      while (v13 != v11);
    }
  }
  v15 = *((_QWORD *)this + 7) - *((_QWORD *)this + 6);
  if (v15 >= 1)
  {
    bzero(*((void **)this + 6), v15);
    result = (unsigned int *)*((_QWORD *)this + 3);
  }
  if (a5 == 4 && result[2] == 1)
  {
    v16 = *result;
    v17 = *((_QWORD *)this + 6);
    if (*result >= ((unint64_t)(*((_QWORD *)this + 7) - v17) >> 3))
      v16 = (unint64_t)(*((_QWORD *)this + 7) - v17) >> 3;
    if (v16)
    {
      v18 = 0;
      v19 = 4;
      do
      {
        *(_QWORD *)(v17 + 8 * v18++) = *(_QWORD *)&result[v19];
        result = (unsigned int *)*((_QWORD *)this + 3);
        LODWORD(v20) = *result;
        v17 = *((_QWORD *)this + 6);
        v21 = (unint64_t)(*((_QWORD *)this + 7) - v17) >> 3;
        if (*result >= v21)
          v20 = v21;
        else
          v20 = v20;
        v19 += 4;
      }
      while (v18 < v20);
    }
  }
  return result;
}

void ___ZN16AUSpatialMixerV220InitializeDynamicXTCEN10applesauce2CF6URLRefE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v2;
  NSObject *v3;
  _QWORD *v4;
  int v5;
  _QWORD *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = atomic_load((unsigned __int8 *)(v1 + 2864));
  if ((v2 & 1) != 0)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v3 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      v4 = (_QWORD *)(v1 + 3592);
      if (*(char *)(v1 + 3615) < 0)
        v4 = (_QWORD *)*v4;
      v5 = 136315394;
      v6 = v4;
      v7 = 2080;
      v8 = "InitializeDynamicXTC_block_invoke";
      _os_log_debug_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEBUG, "[%s|%s] update dropped", (uint8_t *)&v5, 0x16u);
    }

  }
  else
  {
    std::unique_ptr<AUSpatialMixerV2DynamicXTCFilter>::reset[abi:ne180100]((uint64_t *)(v1 + 7400), 0);
  }
}

void ___ZN16AUSpatialMixerV220InitializeDynamicXTCEN10applesauce2CF6URLRefE_block_invoke_126(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  unsigned int v5;
  uint64_t v6;
  IR::IRData **v7;
  IR::IRData **v8;
  IR::IRDataLoader *v9;
  uint64_t (*v10)(_QWORD);
  std::__shared_weak_count *size;
  unint64_t *v12;
  unint64_t v13;
  char *v14;
  char *v15;
  std::string *v16;
  __int128 v17;
  NSObject *v18;
  _QWORD *v19;
  uint64_t v20;
  NSObject *v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  __int128 v25;
  _BYTE *v26;
  uint64_t v27;
  NSObject *v28;
  std::string *v29;
  __int128 v30;
  std::string *v31;
  __int128 v32;
  _BYTE *v33;
  void *v34;
  NSObject *v35;
  size_t v36;
  _BYTE *v37;
  const void *v38;
  const UInt8 *v39;
  CFIndex v40;
  CFURLRef v41;
  size_t v42;
  _BYTE *v43;
  const void *v44;
  IR::IRDataLoader *v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  _BOOL4 v49;
  const void *v50;
  const void *Value;
  const void *v52;
  CFTypeRef v53;
  void *v54;
  unint64_t v55;
  void *v56;
  _QWORD *v57;
  void *v58;
  void *v59;
  void *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  uint64_t v74;
  unsigned int v75;
  int v76;
  int v77;
  _DWORD *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  float *v83;
  float *v84;
  uint64_t v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float32x2_t *v90;
  __int128 v91;
  _QWORD *v92;
  __int128 v93;
  VBAP *v94;
  AUSpatialMixerV2DynamicXTCFilter **v95;
  uint64_t v96;
  const void *v97;
  NSObject *v98;
  int v99;
  const UInt8 *v100;
  CFIndex v101;
  CFURLRef v102;
  unsigned int v103;
  _QWORD *v104;
  uint64_t v105;
  _QWORD *v106;
  _QWORD *v107;
  std::string *v108;
  __int128 v109;
  std::string *v110;
  __int128 v111;
  _BYTE *v112;
  std::runtime_error *exception;
  std::runtime_error *v114;
  std::runtime_error *v115;
  __int128 v116;
  float v117;
  __int128 v118;
  float **v119;
  VBAP **v120;
  void **v121;
  void **v122;
  CFURLRef v123;
  float **v124;
  uint64_t v125;
  void **v126;
  const void *v128[2];
  CFTypeRef v129;
  std::string __p;
  char v131;
  CFTypeRef v132;
  std::string v133;
  CFTypeRef cf;
  std::string v135;
  CFTypeRef v136;
  _BYTE buf[32];
  uint64_t v138;
  CFTypeRef v139;
  CFTypeRef v140;
  CFTypeRef v141;
  uint8_t v142[24];
  uint64_t v143;

  v143 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v2 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v106 = (_QWORD *)(v1 + 3592);
    if (*(char *)(v1 + 3615) < 0)
      v106 = (_QWORD *)*v106;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v106;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "InitializeDynamicXTC_block_invoke";
    _os_log_debug_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "[%s|%s] dispatched update for dynamic XTC filter generation:", buf, 0x16u);
  }

  v3 = atomic_load((unsigned __int8 *)(v1 + 2864));
  if ((v3 & 1) == 0)
  {
    v4 = atomic_load((unsigned __int8 *)(v1 + 3744));
    v5 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 128), 0) + 108);
    v6 = operator new();
    v125 = v1;
    *(_BYTE *)v6 = 1;
    *(_QWORD *)(v6 + 4) = 0x473B80003F800000;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)(v6 + 20) = v5;
    *(_OWORD *)(v6 + 24) = xmmword_1B66A0950;
    *(_QWORD *)(v6 + 40) = 0x41A0000040C00000;
    v7 = (IR::IRData **)(v6 + 768);
    v8 = (IR::IRData **)(v6 + 784);
    *(_QWORD *)(v6 + 48) = 0x100460CA000;
    *(_WORD *)(v6 + 56) = 0;
    v124 = (float **)(v6 + 888);
    v121 = (void **)(v6 + 912);
    bzero((void *)(v6 + 64), 0x378uLL);
    v10 = MEMORY[0x1E0C8BFE0];
    *(_QWORD *)(v6 + 952) = MEMORY[0x1E0C8BFE0];
    *(_QWORD *)(v6 + 960) = 0;
    *(_QWORD *)(v6 + 968) = v10;
    v120 = (VBAP **)(v6 + 976);
    v126 = (void **)(v6 + 984);
    v122 = (void **)(v6 + 1008);
    *(_OWORD *)(v6 + 976) = 0u;
    *(_OWORD *)(v6 + 992) = 0u;
    *(_OWORD *)(v6 + 1008) = 0u;
    *(_QWORD *)(v6 + 1024) = 0;
    if (v5 < 2)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v20 = v1;
      v21 = getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        std::string::basic_string[abi:ne180100]<0>(&v135, "AUSpatialMixerV2DynamicXTCFilter");
        v22 = std::string::append(&v135, "::", 2uLL);
        v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v23;
        v22->__r_.__value_.__l.__size_ = 0;
        v22->__r_.__value_.__r.__words[2] = 0;
        v22->__r_.__value_.__r.__words[0] = 0;
        v24 = std::string::append(&__p, "AUSpatialMixerV2DynamicXTCFilter", 0x20uLL);
        v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
        *(_QWORD *)&buf[16] = *((_QWORD *)&v24->__r_.__value_.__l + 2);
        *(_OWORD *)buf = v25;
        v24->__r_.__value_.__l.__size_ = 0;
        v24->__r_.__value_.__r.__words[2] = 0;
        v24->__r_.__value_.__r.__words[0] = 0;
        v26 = buf;
        if (buf[23] < 0)
          v26 = *(_BYTE **)buf;
        *(_DWORD *)v142 = 136315138;
        *(_QWORD *)&v142[4] = v26;
        _os_log_error_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_ERROR, "%s: Filters can not be generated if the number of drivers is < 2", v142, 0xCu);
        if ((buf[23] & 0x80000000) != 0)
          operator delete(*(void **)buf);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v135.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v135.__r_.__value_.__l.__data_);
      }
LABEL_171:
      v95 = (AUSpatialMixerV2DynamicXTCFilter **)(v20 + 7400);
      std::unique_ptr<AUSpatialMixerV2DynamicXTCFilter>::reset[abi:ne180100]((uint64_t *)(v20 + 7400), v6);
      v96 = *(_QWORD *)(v20 + 7400);
      v97 = *(const void **)(v20 + 3248);
      if (v97)
        CFRetain(*(CFTypeRef *)(v20 + 3248));
      v128[1] = v97;
      AUSpatialMixerV2DynamicXTCFilter::updateParamDictionary(v96, v97);
      if (v97)
        CFRelease(v97);
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v98 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
      {
        v107 = (_QWORD *)(v20 + 3592);
        if (*(char *)(v20 + 3615) < 0)
          v107 = (_QWORD *)*v107;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v107;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "InitializeDynamicXTC_block_invoke";
        _os_log_debug_impl(&dword_1B5ED0000, v98, OS_LOG_TYPE_DEBUG, "[%s|%s] updating dynamic XTC filters:", buf, 0x16u);
      }

      AUSpatialMixerV2DynamicXTCFilter::updateFilters(*v95);
      v99 = *((char *)*v95 + 1031);
      if (v99 >= 0)
        v100 = (const UInt8 *)*v95 + 1008;
      else
        v100 = (const UInt8 *)*((_QWORD *)*v95 + 126);
      if (v99 >= 0)
        v101 = *((unsigned __int8 *)*v95 + 1031);
      else
        v101 = *((_QWORD *)*v95 + 127);
      v102 = CFURLCreateWithBytes(0, v100, v101, 0, 0);
      v128[0] = v102;
      if (!v102)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::store(v20 + 3904, v128);
      CFRelease(v102);
      v103 = atomic_load((unsigned int *)(v20 + 3672));
      if (v103 == 2)
      {
        AUSpatialMixerV2::UpdateCounteractRotationShader((AUSpatialMixerV2 *)v20);
        AUSpatialMixerV2::PropagateGlobalPropertyChangeToInputElements((AUSpatialMixerV2 *)v20, 3202);
        AUSpatialMixerV2::UpdateReverbIfNecessary(v20, -1, 0, 0);
      }
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v18 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v104 = (_QWORD *)(v20 + 3592);
        if (*(char *)(v20 + 3615) < 0)
          v104 = (_QWORD *)*v104;
        v105 = *(_QWORD *)(a1 + 192);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v104;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "InitializeDynamicXTC_block_invoke";
        *(_WORD *)&buf[22] = 2112;
        *(_QWORD *)&buf[24] = v105;
        _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEFAULT, "[%s|%s] Replacing custom XTC IR using CFURL %@", buf, 0x20u);
      }
      goto LABEL_193;
    }
    *(_BYTE *)v6 = (v4 & 1) == 0;
    v119 = (float **)(v6 + 864);
    IR::IRDataLoader::instance(v9);
    std::string::basic_string[abi:ne180100]<0>(buf, "");
    cf = 0;
    memset(&__p, 0, sizeof(__p));
    IR::IRDataLoader::load();
    std::shared_ptr<vp::xml::_xmlNode const>::operator=[abi:ne180100]((uint64_t)v7, (__int128 *)&v135);
    size = (std::__shared_weak_count *)v135.__r_.__value_.__l.__size_;
    if (v135.__r_.__value_.__l.__size_)
    {
      v12 = (unint64_t *)(v135.__r_.__value_.__l.__size_ + 8);
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }
    if ((buf[23] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    v14 = getenv("TMPDIR");
    if (v14)
    {
      v15 = getenv("TMPDIR");
      std::string::basic_string[abi:ne180100]<0>(&v133, v15);
      v16 = std::string::insert(&v133, 0, "file:///", 8uLL);
      v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      *(_QWORD *)&buf[16] = *((_QWORD *)&v16->__r_.__value_.__l + 2);
      *(_OWORD *)buf = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(buf, "");
    }
    if (*(char *)(v6 + 1007) < 0)
      operator delete(*v126);
    *(_OWORD *)v126 = *(_OWORD *)buf;
    *(_QWORD *)(v6 + 1000) = *(_QWORD *)&buf[16];
    buf[23] = 0;
    buf[0] = 0;
    if (v14 && SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v133.__r_.__value_.__l.__data_);
    if (*(char *)(v6 + 1007) < 0)
      v27 = *(_QWORD *)(v6 + 992);
    else
      v27 = *(unsigned __int8 *)(v6 + 1007);
    if (v27)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v28 = getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_DEFAULT))
        goto LABEL_59;
      std::string::basic_string[abi:ne180100]<0>(&v135, "AUSpatialMixerV2DynamicXTCFilter");
      v29 = std::string::append(&v135, "::", 2uLL);
      v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v30;
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      v29->__r_.__value_.__r.__words[0] = 0;
      v31 = std::string::append(&__p, "AUSpatialMixerV2DynamicXTCFilter", 0x20uLL);
      v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
      *(_QWORD *)&buf[16] = *((_QWORD *)&v31->__r_.__value_.__l + 2);
      *(_OWORD *)buf = v32;
      v31->__r_.__value_.__l.__size_ = 0;
      v31->__r_.__value_.__r.__words[2] = 0;
      v31->__r_.__value_.__r.__words[0] = 0;
      v33 = buf;
      if (buf[23] < 0)
        v33 = *(_BYTE **)buf;
      v34 = (void *)(v6 + 984);
      if (*(char *)(v6 + 1007) < 0)
        v34 = *v126;
      *(_DWORD *)v142 = 136315394;
      *(_QWORD *)&v142[4] = v33;
      *(_WORD *)&v142[12] = 2080;
      *(_QWORD *)&v142[14] = v34;
      _os_log_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEFAULT, "%s: Temp directory string: %s", v142, 0x16u);
    }
    else
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v35 = getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled((os_log_t)getAUSMV2Log(void)::gLog, OS_LOG_TYPE_ERROR))
        goto LABEL_59;
      std::string::basic_string[abi:ne180100]<0>(&v135, "AUSpatialMixerV2DynamicXTCFilter");
      v108 = std::string::append(&v135, "::", 2uLL);
      v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v108->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0;
      v108->__r_.__value_.__r.__words[2] = 0;
      v108->__r_.__value_.__r.__words[0] = 0;
      v110 = std::string::append(&__p, "AUSpatialMixerV2DynamicXTCFilter", 0x20uLL);
      v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      *(_QWORD *)&buf[16] = *((_QWORD *)&v110->__r_.__value_.__l + 2);
      *(_OWORD *)buf = v111;
      v110->__r_.__value_.__l.__size_ = 0;
      v110->__r_.__value_.__r.__words[2] = 0;
      v110->__r_.__value_.__r.__words[0] = 0;
      v112 = buf;
      if (buf[23] < 0)
        v112 = *(_BYTE **)buf;
      *(_DWORD *)v142 = 136315138;
      *(_QWORD *)&v142[4] = v112;
      _os_log_error_impl(&dword_1B5ED0000, v35, OS_LOG_TYPE_ERROR, "%s: Temp directory string is empty", v142, 0xCu);
    }
    if ((buf[23] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v135.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v135.__r_.__value_.__l.__data_);
LABEL_59:
    if (*(char *)(v6 + 1007) >= 0)
      v36 = *(unsigned __int8 *)(v6 + 1007);
    else
      v36 = *(_QWORD *)(v6 + 992);
    std::string::basic_string[abi:ne180100]((uint64_t)buf, v36 + 41);
    if (buf[23] >= 0)
      v37 = buf;
    else
      v37 = *(_BYTE **)buf;
    if (v36)
    {
      if (*(char *)(v6 + 1007) >= 0)
        v38 = (const void *)(v6 + 984);
      else
        v38 = *(const void **)(v6 + 984);
      memmove(v37, v38, v36);
    }
    strcpy(&v37[v36], "AUSM_Virtual_Surround_Device_Reference.ir");
    if (buf[23] >= 0)
      v39 = buf;
    else
      v39 = *(const UInt8 **)buf;
    if (buf[23] >= 0)
      v40 = buf[23];
    else
      v40 = *(_QWORD *)&buf[8];
    v41 = CFURLCreateWithBytes(0, v39, v40, 0, 0);
    if (!v41)
    {
      v114 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v114, "Could not construct");
    }
    if ((buf[23] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    v123 = v41;
    if (*(char *)(v6 + 1007) >= 0)
      v42 = *(unsigned __int8 *)(v6 + 1007);
    else
      v42 = *(_QWORD *)(v6 + 992);
    std::string::basic_string[abi:ne180100]((uint64_t)buf, v42 + 31);
    if (buf[23] >= 0)
      v43 = buf;
    else
      v43 = *(_BYTE **)buf;
    if (v42)
    {
      if (*(char *)(v6 + 1007) >= 0)
        v44 = (const void *)(v6 + 984);
      else
        v44 = *(const void **)(v6 + 984);
      memmove(v43, v44, v42);
    }
    strcpy(&v43[v42], "AUSM_Virtual_Surround_Tuning.ir");
    if (*(char *)(v6 + 1031) < 0)
      operator delete(*v122);
    *(_OWORD *)v122 = *(_OWORD *)buf;
    *(_QWORD *)(v6 + 1024) = *(_QWORD *)&buf[16];
    if (CFURLResourceIsReachable(v41, 0))
    {
      CFRetain(v41);
      IR::IRDataAttributes::IRDataAttributes((uint64_t)buf, v41, 128, 1, *(float *)(v6 + 8));
      CFRelease(v41);
      IR::IRDataLoader::instance(v45);
      std::string::basic_string[abi:ne180100]<0>(&__p, "");
      v132 = 0;
      memset(&v135, 0, sizeof(v135));
      IR::IRDataLoader::load();
      std::shared_ptr<vp::xml::_xmlNode const>::operator=[abi:ne180100]((uint64_t)v8, (__int128 *)v142);
      v46 = *(std::__shared_weak_count **)&v142[8];
      if (*(_QWORD *)&v142[8])
      {
        v47 = (unint64_t *)(*(_QWORD *)&v142[8] + 8);
        do
          v48 = __ldaxr(v47);
        while (__stlxr(v48 - 1, v47));
        if (!v48)
        {
          ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
          std::__shared_weak_count::__release_weak(v46);
        }
      }
      if (v135.__r_.__value_.__r.__words[0])
      {
        v135.__r_.__value_.__l.__size_ = v135.__r_.__value_.__r.__words[0];
        operator delete(v135.__r_.__value_.__l.__data_);
      }
      if (v132)
        CFRelease(v132);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (*v8)
      {
        IR::IRData::getUserData(*v8);
        if (v135.__r_.__value_.__r.__words[0])
        {
          v49 = applesauce::CF::details::has_key<__CFString const*>((const __CFDictionary *)v135.__r_.__value_.__l.__data_, CFSTR("SpeakerPositions"));
          v50 = (const void *)v135.__r_.__value_.__r.__words[0];
          if (v49)
          {
            Value = CFDictionaryGetValue((CFDictionaryRef)v135.__r_.__value_.__l.__data_, CFSTR("SpeakerPositions"));
            v52 = Value;
            if (Value)
              CFRetain(Value);
            *(_QWORD *)v142 = v52;
            applesauce::CF::TypeRef::operator applesauce::CF::ArrayRef((const void **)v142, (applesauce::CF::ArrayRef *)&v136);
            v53 = v136;
            if (v136)
            {
              CFRetain(v136);
              applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&v129, v53);
              if (!v129)
              {
                v115 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                std::runtime_error::runtime_error(v115, "Could not construct");
              }
              applesauce::CF::convert_as<std::vector<float>,0>((uint64_t)&__p, (const __CFArray *)v129);
              if (v129)
                CFRelease(v129);
              if (v131)
              {
                v54 = *v121;
                if (*v121)
                {
                  *(_QWORD *)(v6 + 920) = v54;
                  operator delete(v54);
                  *v121 = 0;
                  *(_QWORD *)(v6 + 920) = 0;
                  *(_QWORD *)(v6 + 928) = 0;
                }
                *(std::string *)(v6 + 912) = __p;
                v55 = (3 * *(_DWORD *)(v6 + 20));
                LODWORD(v129) = 0;
                std::vector<float>::resize((uint64_t)v121, v55, &v129);
              }
              if (v136)
                CFRelease(v136);
            }
            if (*(_QWORD *)v142)
              CFRelease(*(CFTypeRef *)v142);
            v50 = (const void *)v135.__r_.__value_.__r.__words[0];
          }
          if (v50)
            CFRelease(v50);
        }
      }
      if (v141)
        CFRelease(v141);
      if (v140)
        CFRelease(v140);
      if (v139)
        CFRelease(v139);
      if (*(_QWORD *)buf)
        CFRelease(*(CFTypeRef *)buf);
    }
    MoorePenrose::setMandN((MoorePenrose *)(v6 + 64), *(unsigned int *)(v6 + 20), *(unsigned int *)(v6 + 20));
    CLiteMatrix::CLiteMatrix((CLiteMatrix *)buf, *(unsigned int *)(v6 + 20), 2);
    *(_OWORD *)(v6 + 608) = *(_OWORD *)buf;
    v56 = *(void **)(v6 + 624);
    if (v56)
    {
      *(_QWORD *)(v6 + 632) = v56;
      operator delete(v56);
      *(_QWORD *)(v6 + 624) = 0;
      *(_QWORD *)(v6 + 632) = 0;
      *(_QWORD *)(v6 + 640) = 0;
    }
    *(_OWORD *)(v6 + 624) = *(_OWORD *)&buf[16];
    *(_QWORD *)(v6 + 640) = v138;
    CLiteMatrix::CLiteMatrix((CLiteMatrix *)buf, *(unsigned int *)(v6 + 20), *(unsigned int *)(v6 + 20));
    v57 = (_QWORD *)(v6 + 664);
    *(_OWORD *)(v6 + 648) = *(_OWORD *)buf;
    v58 = *(void **)(v6 + 664);
    if (v58)
    {
      *(_QWORD *)(v6 + 672) = v58;
      operator delete(v58);
      *v57 = 0;
      *(_QWORD *)(v6 + 672) = 0;
      *(_QWORD *)(v6 + 680) = 0;
    }
    *(_OWORD *)v57 = *(_OWORD *)&buf[16];
    *(_QWORD *)(v6 + 680) = v138;
    CLiteMatrix::CLiteMatrix((CLiteMatrix *)buf, *(unsigned int *)(v6 + 20), *(unsigned int *)(v6 + 20));
    *(_OWORD *)(v6 + 688) = *(_OWORD *)buf;
    v59 = *(void **)(v6 + 704);
    if (v59)
    {
      *(_QWORD *)(v6 + 712) = v59;
      operator delete(v59);
      *(_QWORD *)(v6 + 704) = 0;
      *(_QWORD *)(v6 + 712) = 0;
      *(_QWORD *)(v6 + 720) = 0;
    }
    *(_OWORD *)(v6 + 704) = *(_OWORD *)&buf[16];
    *(_QWORD *)(v6 + 720) = v138;
    CLiteMatrix::CLiteMatrix((CLiteMatrix *)buf, *(unsigned int *)(v6 + 20), 2);
    *(_OWORD *)(v6 + 728) = *(_OWORD *)buf;
    v61 = (_QWORD *)(v6 + 744);
    v60 = *(void **)(v6 + 744);
    if (v60)
    {
      *(_QWORD *)(v6 + 752) = v60;
      operator delete(v60);
      *v61 = 0;
      *(_QWORD *)(v6 + 752) = 0;
      *(_QWORD *)(v6 + 760) = 0;
    }
    *(_OWORD *)v61 = *(_OWORD *)&buf[16];
    *(_QWORD *)(v6 + 760) = v138;
    v62 = *(_QWORD *)(v6 + 848);
    v63 = *(_QWORD *)(v6 + 840);
    std::vector<float>::vector(buf, (*(_DWORD *)(v6 + 20) * *(_DWORD *)(v6 + 52)));
    std::vector<std::vector<float>>::resize((uint64_t *)(v6 + 800), 0xAAAAAAAAAAAAAAABLL * ((v62 - v63) >> 3), (uint64_t)buf);
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)&buf[8] = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
    IR::IRData::getCoordinateTree(*v7);
    v65 = *(_QWORD *)&buf[8];
    v64 = *(_QWORD *)&buf[16];
    if (*(_QWORD *)&buf[16] != *(_QWORD *)&buf[8])
    {
      v66 = 0;
      v67 = 0;
      v68 = 0;
      v69 = v138;
      while (*(float *)(v65 + 4 * v66) == 0.0)
      {
        *(_DWORD *)(v6 + 12) = v67;
        v70 = *(_QWORD *)(v69 + 56 * v66 + 8);
        v71 = *(_QWORD *)(v69 + 56 * v66 + 16);
        if (v71 != v70)
        {
          v72 = 0;
          v73 = 0;
          while (*(float *)(v70 + 4 * v72) <= 90.0)
          {
            v72 = ++v73;
            if ((v71 - v70) >> 2 <= (unint64_t)v73)
              goto LABEL_152;
          }
          *(_DWORD *)(v6 + 16) = v67 + v73 - 1;
          goto LABEL_152;
        }
LABEL_158:
        v66 = ++v68;
        if (v68 >= (unint64_t)((v64 - v65) >> 2))
          goto LABEL_159;
      }
      v70 = *(_QWORD *)(v69 + 56 * v66 + 8);
      v71 = *(_QWORD *)(v69 + 56 * v66 + 16);
LABEL_152:
      if (v71 != v70)
      {
        v74 = 0;
        v75 = 0;
        do
        {
          v76 = *(_DWORD *)(*(_QWORD *)&buf[8] + 4 * v66);
          v77 = *(_DWORD *)(v70 + 4 * v74);
          v78 = operator new(8uLL);
          __p.__r_.__value_.__l.__size_ = (std::string::size_type)(v78 + 2);
          __p.__r_.__value_.__r.__words[2] = (std::string::size_type)(v78 + 2);
          *v78 = v76;
          v78[1] = v77;
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v78;
          std::vector<std::vector<float>>::push_back[abi:ne180100]((uint64_t *)(v6 + 840), (uint64_t)&__p);
          if (__p.__r_.__value_.__r.__words[0])
            operator delete(__p.__r_.__value_.__l.__data_);
          v69 = v138;
          v79 = v138 + 56 * v66;
          v70 = *(_QWORD *)(v79 + 8);
          v74 = ++v75;
        }
        while (v75 < (unint64_t)((*(_QWORD *)(v79 + 16) - v70) >> 2));
        v67 += v75;
        v65 = *(_QWORD *)&buf[8];
        v64 = *(_QWORD *)&buf[16];
      }
      goto LABEL_158;
    }
LABEL_159:
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v138;
    std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
    if (*(_QWORD *)&buf[8])
    {
      *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    std::vector<float>::resize((uint64_t)v119, *(unsigned int *)(v6 + 20));
    v20 = v125;
    std::vector<float>::resize((uint64_t)v124, *(unsigned int *)(v6 + 20));
    if (!*(_QWORD *)(v6 + 784) || (v80 = *(_QWORD *)(v6 + 912), *(_QWORD *)(v6 + 920) == v80))
    {
      AUSpatialMixerV2DynamicXTCFilter::updateSpeakerLocations(v6);
      std::make_unique[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &>((uint64_t *)buf, (uint64_t)v119, (uint64_t)v124);
      std::unique_ptr<VBAP>::reset[abi:ne180100](v120, *(VBAP **)buf);
    }
    else
    {
      v81 = *(unsigned int *)(v6 + 20);
      if ((_DWORD)v81)
      {
        v82 = 0;
        v83 = *v119;
        v84 = *v124;
        v85 = 3 * v81;
        do
        {
          v86 = atan2f(*(float *)(v80 + 4 * (v82 + 1)), *(float *)(v80 + 4 * v82))
              / 3.14159265
              * 180.0;
          *v83++ = v86;
          v87 = *(float *)(v80 + 4 * (v82 + 2));
          v88 = hypotf(*(float *)(v80 + 4 * v82), *(float *)(v80 + 4 * (v82 + 1)));
          v89 = atan2f(v87, v88) / 3.14159265 * 180.0;
          *v84++ = v89;
          v82 += 3;
        }
        while (v85 != v82);
      }
      LODWORD(v117) = *(_QWORD *)(v6 + 44);
      v90 = (float32x2_t *)operator new(8uLL);
      *v90 = vmul_n_f32((float32x2_t)0x3F000000BF000000, v117);
      *(_QWORD *)&v91 = v90;
      *((_QWORD *)&v91 + 1) = v90 + 1;
      v118 = v91;
      v92 = operator new(8uLL);
      *v92 = 0;
      *(_QWORD *)&v93 = v92;
      *((_QWORD *)&v93 + 1) = v92 + 1;
      v116 = v93;
      v94 = (VBAP *)operator new();
      *(_OWORD *)buf = v118;
      *(_QWORD *)&buf[16] = v90 + 1;
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v116;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)(v92 + 1);
      memset(&v135, 0, sizeof(v135));
      memset(v142, 0, sizeof(v142));
      VBAP::VBAP((uint64_t)v94, (uint64_t *)buf, (uint64_t *)&__p, 1, (uint64_t)&v135, (void **)v142);
      v136 = v142;
      std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v136);
      if (v135.__r_.__value_.__r.__words[0])
      {
        v135.__r_.__value_.__l.__size_ = v135.__r_.__value_.__r.__words[0];
        operator delete(v135.__r_.__value_.__l.__data_);
      }
      operator delete(v92);
      operator delete(v90);
      std::unique_ptr<VBAP>::reset[abi:ne180100](v120, v94);
      v20 = v125;
    }
    AUSpatialMixerV2DynamicXTCFilter::setLR8Crossover((AUSpatialMixerV2DynamicXTCFilter *)v6, (float)((float)(*(float *)(v6 + 48) + *(float *)(v6 + 48)) / *(float *)(v6 + 8)) * 3.1416);
    CFRelease(v123);
    goto LABEL_171;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v18 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    v19 = (_QWORD *)(v1 + 3592);
    if (*(char *)(v1 + 3615) < 0)
      v19 = (_QWORD *)*v19;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v19;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "InitializeDynamicXTC_block_invoke";
    _os_log_debug_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEBUG, "[%s|%s] update dropped", buf, 0x16u);
  }
LABEL_193:

}

void sub_1B619F83C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, MoorePenrose *a14, uint64_t a15, void **a16, VBAP **a17, const void *a18, void **a19, void **a20,CFTypeRef a21,void **a22,uint64_t a23,void **a24,uint64_t a25,uint64_t a26,uint64_t a27,CFTypeRef cf,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,CFTypeRef a34,uint64_t a35,uint64_t a36,uint64_t a37,CFTypeRef a38,CFTypeRef a39,uint64_t a40,uint64_t a41,CFTypeRef a42,CFTypeRef a43,void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,CFTypeRef a51,uint64_t a52,uint64_t a53,CFTypeRef a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,CFTypeRef a59)
{
  uint64_t v59;
  uint64_t v60;
  const void *v62;
  uint64_t v63;
  uint64_t v64;
  const void *v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;

  if (cf)
    CFRelease(cf);
  if (a42)
    CFRelease(a42);
  v62 = *(const void **)(v60 - 160);
  if (v62)
    CFRelease(v62);
  if (a39)
    CFRelease(a39);
  if (a59)
    CFRelease(a59);
  if (a54)
    CFRelease(a54);
  if (a51)
    CFRelease(a51);
  if (a43)
    CFRelease(a43);
  CFRelease(a21);
  if (*(char *)(v59 + 1031) < 0)
    operator delete(*a20);
  if (*(char *)(v59 + 1007) < 0)
    operator delete(*a24);
  std::unique_ptr<VBAP>::reset[abi:ne180100](a17, 0);
  v63 = *(_QWORD *)(v59 + 960);
  *(_QWORD *)(v59 + 960) = 0;
  if (v63)
    (*(void (**)(void))(v59 + 968))();
  v64 = *(_QWORD *)(v59 + 944);
  *(_QWORD *)(v59 + 944) = 0;
  if (v64)
    (*(void (**)(void))(v59 + 952))();
  v65 = *(const void **)(v59 + 936);
  if (v65)
    CFRelease(v65);
  v66 = *a19;
  if (*a19)
  {
    *(_QWORD *)(v59 + 920) = v66;
    operator delete(v66);
  }
  v67 = *a22;
  if (*a22)
  {
    *(_QWORD *)(v59 + 896) = v67;
    operator delete(v67);
  }
  v68 = *a16;
  if (*a16)
  {
    *(_QWORD *)(v59 + 872) = v68;
    operator delete(v68);
  }
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a39);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v59 + 824);
  a39 = a18;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a39);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](a15);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](a13);
  v69 = *(void **)(v59 + 744);
  if (v69)
  {
    *(_QWORD *)(v59 + 752) = v69;
    operator delete(v69);
  }
  v70 = *(void **)(v59 + 704);
  if (v70)
  {
    *(_QWORD *)(v59 + 712) = v70;
    operator delete(v70);
  }
  v71 = *(void **)(v59 + 664);
  if (v71)
  {
    *(_QWORD *)(v59 + 672) = v71;
    operator delete(v71);
  }
  v72 = *(void **)(v59 + 624);
  if (v72)
  {
    *(_QWORD *)(v59 + 632) = v72;
    operator delete(v72);
  }
  MoorePenrose::~MoorePenrose(a14);
  MEMORY[0x1BCC95CEC](v59, 0x10F2C40D46768E9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_40c27_ZTSN2IR16IRDataAttributesE192c28_ZTSN10applesauce2CF6URLRefE(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const void *v5;

  result = IR::IRDataAttributes::IRDataAttributes(a1 + 40, a2 + 40);
  v5 = *(const void **)(a2 + 192);
  if (v5)
    result = (uint64_t)CFRetain(v5);
  *(_QWORD *)(a1 + 192) = v5;
  return result;
}

void __destroy_helper_block_ea8_40c27_ZTSN2IR16IRDataAttributesE192c28_ZTSN10applesauce2CF6URLRefE(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 192);
  if (v2)
    CFRelease(v2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)(a1 + 40));
}

uint64_t *std::unique_ptr<AUSpatialMixerV2DynamicXTCFilter>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void **v13;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    if (*(char *)(v2 + 1031) < 0)
      operator delete(*(void **)(v2 + 1008));
    if (*(char *)(v2 + 1007) < 0)
      operator delete(*(void **)(v2 + 984));
    std::unique_ptr<VBAP>::reset[abi:ne180100]((VBAP **)(v2 + 976), 0);
    v3 = *(_QWORD *)(v2 + 960);
    *(_QWORD *)(v2 + 960) = 0;
    if (v3)
      (*(void (**)(void))(v2 + 968))();
    v4 = *(_QWORD *)(v2 + 944);
    *(_QWORD *)(v2 + 944) = 0;
    if (v4)
      (*(void (**)(void))(v2 + 952))();
    v5 = *(const void **)(v2 + 936);
    if (v5)
      CFRelease(v5);
    v6 = *(void **)(v2 + 912);
    if (v6)
    {
      *(_QWORD *)(v2 + 920) = v6;
      operator delete(v6);
    }
    v7 = *(void **)(v2 + 888);
    if (v7)
    {
      *(_QWORD *)(v2 + 896) = v7;
      operator delete(v7);
    }
    v8 = *(void **)(v2 + 864);
    if (v8)
    {
      *(_QWORD *)(v2 + 872) = v8;
      operator delete(v8);
    }
    v13 = (void **)(v2 + 840);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v13);
    std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v2 + 824);
    v13 = (void **)(v2 + 800);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v13);
    std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v2 + 784);
    std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v2 + 768);
    v9 = *(void **)(v2 + 744);
    if (v9)
    {
      *(_QWORD *)(v2 + 752) = v9;
      operator delete(v9);
    }
    v10 = *(void **)(v2 + 704);
    if (v10)
    {
      *(_QWORD *)(v2 + 712) = v10;
      operator delete(v10);
    }
    v11 = *(void **)(v2 + 664);
    if (v11)
    {
      *(_QWORD *)(v2 + 672) = v11;
      operator delete(v11);
    }
    v12 = *(void **)(v2 + 624);
    if (v12)
    {
      *(_QWORD *)(v2 + 632) = v12;
      operator delete(v12);
    }
    MoorePenrose::~MoorePenrose((MoorePenrose *)(v2 + 64));
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

float applesauce::CF::at_or<float,char const(&)[12]>(const __CFDictionary *a1, uint64_t a2)
{
  const __CFNumber *v3;
  uint64_t v4;
  float result;

  v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[12]>(a1, "SpeakerSpan");
  if (!v3)
    return *(float *)a2;
  v4 = applesauce::CF::convert_as<float,0>(v3);
  result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0)
    return *(float *)a2;
  return result;
}

float applesauce::CF::at_or<float,char const(&)[15]>(const __CFDictionary *a1, uint64_t a2)
{
  const __CFNumber *v3;
  uint64_t v4;
  float result;

  v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[15]>(a1, "Regularization");
  if (!v3)
    return *(float *)a2;
  v4 = applesauce::CF::convert_as<float,0>(v3);
  result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0)
    return *(float *)a2;
  return result;
}

float applesauce::CF::at_or<float,char const(&)[11]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  const __CFNumber *v4;
  uint64_t v5;
  float result;

  v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[11]>(a1, a2);
  if (!v4)
    return *(float *)a3;
  v5 = applesauce::CF::convert_as<float,0>(v4);
  result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0)
    return *(float *)a3;
  return result;
}

float applesauce::CF::at_or<float,char const(&)[21]>(const __CFDictionary *a1, uint64_t a2)
{
  const __CFNumber *v3;
  uint64_t v4;
  float result;

  v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[21]>(a1, "PostTimbralFrequency");
  if (!v3)
    return *(float *)a2;
  v4 = applesauce::CF::convert_as<float,0>(v3);
  result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0)
    return *(float *)a2;
  return result;
}

float applesauce::CF::at_or<float,char const(&)[17]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  const __CFNumber *v4;
  uint64_t v5;
  float result;

  v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[17]>(a1, a2);
  if (!v4)
    return *(float *)a3;
  v5 = applesauce::CF::convert_as<float,0>(v4);
  result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0)
    return *(float *)a3;
  return result;
}

float applesauce::CF::at_or<float,char const(&)[10]>(const __CFDictionary *a1, uint64_t a2)
{
  const __CFNumber *v3;
  uint64_t v4;
  float result;

  v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[10]>(a1, "Crossover");
  if (!v3)
    return *(float *)a2;
  v4 = applesauce::CF::convert_as<float,0>(v3);
  result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0)
    return *(float *)a2;
  return result;
}

float applesauce::CF::at_or<float,char const(&)[9]>(const __CFDictionary *a1, uint64_t a2)
{
  const __CFNumber *v3;
  uint64_t v4;
  float result;

  v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[9]>(a1, "PostGain");
  if (!v3)
    return *(float *)a2;
  v4 = applesauce::CF::convert_as<float,0>(v3);
  result = *(float *)&v4;
  if ((v4 & 0xFF00000000) == 0)
    return *(float *)a2;
  return result;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],int &>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "FilterLength");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61A017C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "SpeakerSpan");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61A024C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "Regularization");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61A031C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "Constraint");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61A03EC(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[21],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "PostTimbralFrequency");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61A04BC(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[10],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "Crossover");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61A058C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "PostGain");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61A065C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*&>(_BYTE *a1, CFDictionaryRef theDict, const void *a3)
{
  const void *v4;
  const void *v5;
  CFTypeID v6;
  char v7;

  v4 = applesauce::CF::details::at_key<__CFString const*&>(theDict, a3);
  if (!v4)
    goto LABEL_5;
  v5 = v4;
  CFRetain(v4);
  v6 = CFGetTypeID(v5);
  if (v6 != CFArrayGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    v7 = 0;
    *a1 = 0;
    goto LABEL_6;
  }
  *(_QWORD *)a1 = v5;
  v7 = 1;
LABEL_6:
  a1[8] = v7;
}

const __CFArray *applesauce::CF::ArrayRef_proxy::get_size(const __CFArray *this)
{
  if (this)
    return (const __CFArray *)CFArrayGetCount(this);
  return this;
}

uint64_t std::pair<AUPreset,applesauce::CF::DictionaryRef>::~pair(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);
  return a1;
}

BOOL AUSM::GlobalProperties::hasXTCIR(AUSM::GlobalProperties *this)
{
  _BOOL8 v1;
  CFTypeRef cf;

  if (*((_BYTE *)this + 2484))
    return 1;
  AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&cf, (uint64_t)this + 320);
  v1 = cf != 0;
  if (cf)
    CFRelease(cf);
  return v1;
}

void std::vector<IR::FixedIntegerDelay>::resize(uint64_t *a1, unint64_t a2, IR::FixedIntegerDelay *a3)
{
  uint64_t v5;
  IR::FixedIntegerDelay *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  IR::FixedIntegerDelay *v15;
  uint64_t v16;
  uint64_t v17;
  IR::FixedIntegerDelay *v18;
  unint64_t v19;
  IR::FixedIntegerDelay *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD v23[2];
  IR::FixedIntegerDelay *v24;
  char *v25;
  uint64_t *v26;

  v5 = *a1;
  v6 = (IR::FixedIntegerDelay *)a1[1];
  v7 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v6 - *a1) >> 3);
  v8 = a2 - v7;
  if (a2 <= v7)
  {
    if (a2 < v7)
    {
      v20 = (IR::FixedIntegerDelay *)(v5 + 56 * a2);
      while (v6 != v20)
      {
        v6 = (IR::FixedIntegerDelay *)((char *)v6 - 56);
        std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(v6);
      }
      a1[1] = (uint64_t)v20;
    }
  }
  else
  {
    v10 = a1[2];
    if (0x6DB6DB6DB6DB6DB7 * ((v10 - (uint64_t)v6) >> 3) >= v8)
    {
      v21 = (_QWORD *)((char *)v6 + 56 * v8);
      v22 = 56 * a2 - 8 * (((uint64_t)v6 - *a1) >> 3);
      do
      {
        IR::FixedIntegerDelay::FixedIntegerDelay(v6, a3);
        v6 = (IR::FixedIntegerDelay *)((char *)v6 + 56);
        v22 -= 56;
      }
      while (v22);
      a1[1] = (uint64_t)v21;
    }
    else
    {
      if (a2 > 0x492492492492492)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v26 = a1 + 2;
      v11 = 0x6DB6DB6DB6DB6DB7 * ((v10 - v5) >> 3);
      v12 = 2 * v11;
      if (2 * v11 <= a2)
        v12 = a2;
      if (v11 >= 0x249249249249249)
        v13 = 0x492492492492492;
      else
        v13 = v12;
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::FixedIntegerDelay>>(v13);
      v15 = (IR::FixedIntegerDelay *)&v14[56 * v7];
      v23[0] = v14;
      v23[1] = v15;
      v24 = v15;
      v25 = &v14[56 * v16];
      v17 = 56 * a2;
      v18 = (IR::FixedIntegerDelay *)&v14[56 * a2];
      v19 = v17 - 56 * v7;
      do
      {
        IR::FixedIntegerDelay::FixedIntegerDelay(v15, a3);
        v15 = (IR::FixedIntegerDelay *)((char *)v15 + 56);
        v19 -= 56;
      }
      while (v19);
      v24 = v18;
      std::vector<IR::FixedIntegerDelay>::__swap_out_circular_buffer(a1, v23);
      std::__split_buffer<IR::FixedIntegerDelay>::~__split_buffer((uint64_t)v23);
    }
  }
}

void sub_1B61A0994(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

void ___ZN16AUSpatialMixerV220UpdateAutoModeReverbEbbi_block_invoke(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v2;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  _QWORD *v7;
  int v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  NSObject *v12;
  int v13;
  unsigned __int8 v14;
  char v15;
  char v16;
  int v17;
  unsigned int v18;
  IR::IRDataLoader *v19;
  IR::IRDataLoader *v20;
  int OriginalAudioChannelLayoutTag;
  IR::IRDataLoader *v22;
  IR::IRDataLoader *v23;
  int v24;
  _BOOL4 IsSupportedHOA;
  const void *v26;
  unsigned __int8 v27;
  _QWORD *v28;
  NSObject *v29;
  _QWORD *v30;
  int v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  std::__shared_weak_count *v36;
  unint64_t *p_shared_owners;
  CFTypeRef v38;
  int v39;
  unint64_t v40;
  NSObject *v41;
  uint64_t v42;
  NSObject *v43;
  _QWORD *v44;
  int v45;
  unsigned int v46;
  int v47;
  const void *v48;
  uint64_t v49[2];
  uint64_t v50;
  char v51;
  CFTypeRef cf[2];
  uint8_t v53[4];
  _QWORD *v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  _BYTE buf[12];
  _BYTE v62[10];
  __int16 v63;
  int v64;
  CFTypeRef v65;
  __int128 v66;
  CFTypeRef v67;
  int v68;
  int v69;
  int v70;
  int v71;
  BOOL v72;
  CFTypeRef v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = atomic_load((unsigned __int8 *)(v1 + 2864));
  if ((v2 & 1) != 0)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v12 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      v28 = (_QWORD *)(v1 + 3592);
      if (*(char *)(v1 + 3615) < 0)
        v28 = (_QWORD *)*v28;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v28;
      *(_WORD *)v62 = 2080;
      *(_QWORD *)&v62[2] = "UpdateAutoModeReverb_block_invoke";
      _os_log_debug_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_DEBUG, "[%s|%s] update dropped", buf, 0x16u);
    }

    return;
  }
  v4 = *(_DWORD *)(a1 + 40);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v5 = (id)getAUSMV2Log(void)::gLog;
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
  if (v4 < 0)
  {
    if (!v6)
      goto LABEL_14;
    v32 = (_QWORD *)(v1 + 3592);
    if (*(char *)(v1 + 3615) < 0)
      v32 = (_QWORD *)*v32;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v32;
    *(_WORD *)v62 = 2080;
    *(_QWORD *)&v62[2] = "UpdateAutoModeReverb_block_invoke";
    v9 = "[%s|%s] dispatching update for all InputElements";
    v10 = v5;
    v11 = 22;
  }
  else
  {
    if (!v6)
      goto LABEL_14;
    v7 = (_QWORD *)(v1 + 3592);
    if (*(char *)(v1 + 3615) < 0)
      v7 = (_QWORD *)*v7;
    v8 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = v7;
    *(_WORD *)v62 = 2080;
    *(_QWORD *)&v62[2] = "UpdateAutoModeReverb_block_invoke";
    v63 = 1024;
    v64 = v8;
    v9 = "[%s|%s] dispatching update for InputElement #%d:";
    v10 = v5;
    v11 = 28;
  }
  _os_log_debug_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEBUG, v9, buf, v11);
LABEL_14:

  v13 = *(unsigned __int8 *)(a1 + 45);
  v47 = *(_DWORD *)(a1 + 40);
  v14 = atomic_load((unsigned __int8 *)(v1 + 2864));
  if ((v14 & 1) != 0)
    return;
  if (*(_BYTE *)(a1 + 44) && AUSpatialMixerV2::UpdateAutoModeReverbBus(v1, 1, v47))
  {
    v15 = 0;
    v16 = *(_BYTE *)(v1 + 7496);
    v17 = *(_DWORD *)(v1 + 7492);
    if (!v13)
    {
LABEL_22:
      if ((v15 & 1) != 0)
      {
LABEL_88:
        AUSpatialMixerV2::ReconfigureSharedBuffers((AUSpatialMixerV2 *)v1, 0, 0);
        return;
      }
      goto LABEL_23;
    }
  }
  else
  {
    v16 = 0;
    v17 = 0;
    v15 = 1;
    if (!v13)
      goto LABEL_22;
  }
  if (!AUSpatialMixerV2::UpdateAutoModeReverbBus(v1, 0, v47))
    goto LABEL_22;
  v16 = *(_BYTE *)(v1 + 7648);
  v17 = *(_DWORD *)(v1 + 7644);
LABEL_23:
  v18 = atomic_load((unsigned int *)(v1 + 7476));
  v46 = v18;
  if ((v18 & 0x80000000) != 0 || !*(_QWORD *)(v1 + 7480) || !*(_QWORD *)(v1 + 7632))
    goto LABEL_88;
  cf[1] = 0;
  v19 = (IR::IRDataLoader *)IR::IRDataAttributes::IRDataAttributes((uint64_t)buf, 0, 0, 0, 0.0);
  v20 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v19);
  OriginalAudioChannelLayoutTag = IR::IRDataLoader::getOriginalAudioChannelLayoutTag(v20, (const IR::IRDataAttributes *)(v1 + 7480));
  if (ChannelLayoutTagIsSupportedHOA(OriginalAudioChannelLayoutTag))
  {
    v22 = (IR::IRDataLoader *)IR::IRDataAttributes::operator=((uint64_t)buf, v1 + 7480);
    v23 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v22);
    v24 = IR::IRDataLoader::getOriginalAudioChannelLayoutTag(v23, (const IR::IRDataAttributes *)(v1 + 7632));
    IsSupportedHOA = ChannelLayoutTagIsSupportedHOA(v24);
    v26 = *(const void **)(v1 + 7632);
    if (IsSupportedHOA)
    {
      applesauce::CF::URLRef::operator=(&v65, v26);
      v66 = *(_OWORD *)(v1 + 7656);
      applesauce::CF::URLRef::operator=(&v67, *(CFTypeRef *)(v1 + 7720));
      v70 = *(_DWORD *)(v1 + 7736);
      v27 = atomic_load((unsigned __int8 *)(v1 + 5089));
      v72 = (v27 & 1) == 0;
      v71 = 1500;
    }
    else
    {
      applesauce::CF::URLRef::operator=(&v67, v26);
      v68 = *(_DWORD *)(v1 + 7672);
      v70 = 0;
    }
    v31 = v47;
    v69 = 0;
    v62[4] = v16;
    *(_DWORD *)v62 = v17;
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v29 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      v30 = (_QWORD *)(v1 + 3592);
      if (*(char *)(v1 + 3615) < 0)
        v30 = (_QWORD *)*v30;
      *(_DWORD *)v53 = 136315394;
      v54 = v30;
      v55 = 2080;
      v56 = "UpdateAutoModeReverbBlock";
      _os_log_impl(&dword_1B5ED0000, v29, OS_LOG_TYPE_DEFAULT, "[%s|%s] Scene reverb IR is non-HOA, any additional late reverb will run in parallel.", v53, 0x16u);
    }

    v31 = v47;
  }
  AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(cf, v1 + 5424);
  v50 = v1 + 3352;
  v51 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v1 + 3352));
  v33 = *(_QWORD *)(v1 + 120);
  if (v33)
    LODWORD(v34) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v33 + 24))(v33);
  else
    v34 = (*(_QWORD *)(v1 + 104) - *(_QWORD *)(v1 + 96)) >> 3;
  v45 = v34;
  if ((int)v34 <= v31)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v43 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      v44 = (_QWORD *)(v1 + 3592);
      if (*(char *)(v1 + 3615) < 0)
        v44 = (_QWORD *)*v44;
      *(_DWORD *)v53 = 136315906;
      v54 = v44;
      v55 = 2080;
      v56 = "UpdateAutoModeReverbBlock";
      v57 = 1024;
      v58 = v31;
      v59 = 1024;
      v60 = v34;
      _os_log_error_impl(&dword_1B5ED0000, v43, OS_LOG_TYPE_ERROR, "[%s|%s] update called for input #%d, number of inputs = %u", v53, 0x22u);
    }

  }
  else
  {
    if (v31 == -1)
      v35 = v34;
    else
      v35 = v31 + 1;
    if (v31 == -1)
      v31 = 0;
    for (; v31 != v35; LODWORD(v34) = v45)
    {
      v36 = (std::__shared_weak_count *)operator new(0xB0uLL);
      v36->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v36->__shared_owners_;
      v36->__shared_weak_owners_ = 0;
      v36->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69CA638;
      v49[0] = IR::IRDataAttributes::IRDataAttributes((uint64_t)&v36[1], (uint64_t)buf);
      v49[1] = (uint64_t)v36;
      v38 = cf[0];
      if (cf[0])
        CFRetain(cf[0]);
      v48 = v38;
      v39 = IR::SharedIRBuses::reconfigure(v1 + 2328, v31 + v46, v49, &v48);
      if (v38)
        CFRelease(v38);
      do
        v40 = __ldaxr(p_shared_owners);
      while (__stlxr(v40 - 1, p_shared_owners));
      if (v40)
      {
        if (v39)
          goto LABEL_64;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
        if (v39)
        {
LABEL_64:
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v41 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            v42 = v1 + 3592;
            if (*(char *)(v1 + 3615) < 0)
              v42 = *(_QWORD *)(v1 + 3592);
            *(_DWORD *)v53 = 136315906;
            v54 = (_QWORD *)v42;
            v55 = 2080;
            v56 = "UpdateAutoModeReverbBlock";
            v57 = 1024;
            v58 = v31;
            v59 = 1024;
            v60 = v39;
            _os_log_error_impl(&dword_1B5ED0000, v41, OS_LOG_TYPE_ERROR, "[%s|%s] Could not reconfigure auto mode combined late reverb for input #%u: error %d", v53, 0x22u);
          }

        }
      }
      ++v31;
    }
  }
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v50);
  if (cf[0])
    CFRelease(cf[0]);
  if (v73)
    CFRelease(v73);
  if (v67)
    CFRelease(v67);
  if (v65)
    CFRelease(v65);
  if (*(_QWORD *)buf)
    CFRelease(*(CFTypeRef *)buf);
  if ((int)v34 > v47)
    goto LABEL_88;
}

void sub_1B61A110C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,char a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t AUSpatialMixerV2::UpdateAutoModeReverbBus(uint64_t a1, int a2, int a3)
{
  IR::IRDataLoader *v6;
  IR::IRDataLoader *v7;
  uint64_t UserData;
  const __CFDictionary *v9;
  float v10;
  IR::IRDataLoader *v11;
  IR::IRDataLoader *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  unsigned int *v17;
  uint64_t v18;
  float v19;
  unsigned int *v20;
  int v21;
  const __CFDictionary *v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  const __CFNumber *v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  NSObject *v36;
  _QWORD *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t Element;
  uint64_t v43;
  unsigned __int8 v44;
  uint64_t *v45;
  uint64_t *v46;
  uint64_t v47;
  unsigned __int8 v48;
  unsigned int v49;
  NSObject *v50;
  _QWORD *v51;
  unsigned int v52;
  void *v53;
  IR::IRDataLoader *v54;
  uint64_t v55;
  unsigned int v56;
  CFTypeRef v57;
  CFTypeRef v58;
  CFTypeRef v59;
  NSObject *v60;
  CFTypeRef v61;
  _QWORD *v62;
  const char *v63;
  _QWORD *v64;
  CFTypeRef v65;
  unsigned int v66;
  unsigned __int8 v67;
  uint64_t v68;
  const char *v70;
  std::__shared_weak_count *v71;
  unint64_t *p_shared_owners;
  CFTypeRef v73;
  int v74;
  unint64_t v75;
  NSObject *v76;
  uint64_t v77;
  CFTypeRef v78;
  _QWORD *v79;
  unsigned int v80;
  int v81;
  int v82;
  const char *v83;
  unsigned int FilterLength;
  uint64_t v85;
  const void *v86;
  uint64_t v87[2];
  uint64_t v88;
  char v89;
  CFTypeRef v90;
  CFTypeRef v91;
  float v92;
  int v93;
  uint64_t v94;
  unsigned int v95;
  int v96;
  int v97;
  CFTypeRef v98;
  CFTypeRef v99;
  CFTypeRef v100;
  float v101;
  float v102;
  int v103;
  CFTypeRef v104;
  int v105;
  unsigned int v106;
  int v107;
  uint64_t v108;
  CFTypeRef v109;
  CFTypeRef cf;
  uint64_t v111;
  int v112;
  BOOL v113;
  CFTypeRef v114;
  float v115;
  float v116;
  int v117;
  float v118;
  CFTypeRef v119;
  CFTypeRef v120;
  _BYTE buf[12];
  __int16 v122;
  const char *v123;
  __int16 v124;
  _BYTE v125[10];
  unsigned int v126;
  __int16 v127;
  int v128;
  CFTypeRef v129;
  CFTypeRef v130;
  CFTypeRef v131;
  uint64_t v132;

  v132 = *MEMORY[0x1E0C80C00];
  v119 = 0;
  AUSpatialMixerV2::GetAutoModeReverbAttributes((uint64_t)&v91, a1, a2);
  v85 = a1;
  if (v91)
  {
    v7 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v6);
    UserData = IR::IRDataLoader::getUserData(v7, (const IR::IRDataAttributes *)&v91);
    v9 = *(const __CFDictionary **)buf;
    v119 = *(CFTypeRef *)buf;
    if (v97 == 3
      || (!*(_QWORD *)buf
       || (UserData = (uint64_t)applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[15]>(*(const __CFDictionary **)buf, "EarlyLateSplit"), (UserData & 0xFF00000000) == 0)? (v10 = v118): (v10 = *(float *)&UserData, v118 = *(float *)&UserData), v10 <= 0.0))
    {
      v12 = (IR::IRDataLoader *)IR::IRDataLoader::instance((IR::IRDataLoader *)UserData);
      FilterLength = IR::IRDataLoader::getFilterLength(v12, (const IR::IRDataAttributes *)&v91);
    }
    else
    {
      FilterLength = llroundf(v10 * v92);
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v13 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v62 = (_QWORD *)(a1 + 3592);
      if (*(char *)(a1 + 3615) < 0)
        v62 = (_QWORD *)*v62;
      v63 = "post-processing";
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v62;
      v123 = "UpdateAutoModeReverbBus";
      v122 = 2080;
      if (a2 == 1)
        v63 = "scene";
      v124 = 2080;
      *(_QWORD *)v125 = v63;
      *(_WORD *)&v125[8] = 1024;
      v126 = FilterLength;
      _os_log_debug_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEBUG, "[%s|%s] Early length for %s reverb = %u", buf, 0x26u);
    }

  }
  else
  {
    v11 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v6);
    IR::IRDataLoader::getUserData(v11, (const IR::IRDataAttributes *)&v104);
    FilterLength = 0;
    v9 = *(const __CFDictionary **)buf;
    v119 = *(CFTypeRef *)buf;
  }
  if (a2 == 1)
    v14 = 6084;
  else
    v14 = 6088;
  if (a2 == 1)
    v15 = 6076;
  else
    v15 = 6080;
  if (v9)
  {
    *(_QWORD *)buf = CFSTR("DiffuseFieldPowerRMS");
    LODWORD(v88) = 1065353216;
    v16 = applesauce::CF::at_or<float,__CFString const*>(v9, (const void **)buf, (uint64_t)&v88);
    v17 = (unsigned int *)(v85 + v14);
    v18 = v85;
    atomic_store(LODWORD(v16), v17);
    *(_QWORD *)buf = CFSTR("CriticalDistance");
    LODWORD(v88) = 1065353216;
    v19 = applesauce::CF::at_or<float,__CFString const*>(v9, (const void **)buf, (uint64_t)&v88);
  }
  else
  {
    v20 = (unsigned int *)(v85 + v14);
    v18 = v85;
    atomic_store(0x3F800000u, v20);
    v19 = 1.0;
  }
  atomic_store(LODWORD(v19), (unsigned int *)(v18 + v15));
  if (FilterLength >= 0x64)
    v21 = 100;
  else
    v21 = FilterLength;
  v82 = v21;
  AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v90, v18 + 5496);
  v22 = (const __CFDictionary *)v90;
  if (v90)
  {
    v23 = 0.0;
    if (applesauce::CF::details::has_key<char const(&)[20]>((const __CFDictionary *)v90, "AbsoluteThresholdDb"))
    {
      v24 = applesauce::CF::details::find_at_key<float,char const(&)[20]>(v22, "AbsoluteThresholdDb");
      v23 = __exp10f(v24 / 20.0);
      v18 = v85;
    }
    v25 = 0.0;
    v26 = 0.0;
    if (applesauce::CF::details::has_key<char const(&)[20]>(v22, "RelativeThresholdDb"))
    {
      v27 = applesauce::CF::details::find_at_key<float,char const(&)[20]>(v22, "RelativeThresholdDb");
      v26 = __exp10f(v27 / 20.0);
      v18 = v85;
    }
    v28 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[19]>(v22, "MaximumFrequencyHz");
    if (v28)
    {
      v29 = applesauce::CF::convert_as<float,0>(v28);
      if ((v29 & 0xFF00000000) != 0)
        v25 = *(float *)&v29;
      else
        v25 = 0.0;
    }
    v30 = vcvtps_u32_f32((float)((float)(v25 + v25) / v92) * 128.0);
    if (v30 >= 0x80)
      v31 = 128;
    else
      v31 = v30;
  }
  else
  {
    v31 = 0;
    v23 = 0.0;
    v26 = 0.0;
  }
  v88 = v18 + 3352;
  v89 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v18 + 3352));
  v32 = *(_QWORD *)(v18 + 120);
  if (v32)
    LODWORD(v33) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v32 + 24))(v32);
  else
    v33 = (*(_QWORD *)(v18 + 104) - *(_QWORD *)(v18 + 96)) >> 3;
  if ((int)v33 <= a3)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v39 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      v64 = (_QWORD *)(v18 + 3592);
      if (*(char *)(v18 + 3615) < 0)
        v64 = (_QWORD *)*v64;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v64;
      v122 = 2080;
      v123 = "UpdateAutoModeReverbBus";
      v124 = 1024;
      *(_DWORD *)v125 = a3;
      *(_WORD *)&v125[4] = 1024;
      *(_DWORD *)&v125[6] = v33;
      _os_log_error_impl(&dword_1B5ED0000, v39, OS_LOG_TYPE_ERROR, "[%s|%s] update called for input #%d, number of inputs = %u", buf, 0x22u);
    }

    goto LABEL_64;
  }
  v81 = v31;
  if (a3 == -1)
    v34 = 0;
  else
    v34 = a3;
  if (a3 == -1)
    v35 = v33;
  else
    v35 = a3 + 1;
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v36 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    v37 = (_QWORD *)(v85 + 3592);
    if (*(char *)(v85 + 3615) < 0)
      v37 = (_QWORD *)*v37;
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = v37;
    v122 = 2080;
    v123 = "UpdateAutoModeReverbBus";
    v124 = 1024;
    *(_DWORD *)v125 = a3;
    _os_log_impl(&dword_1B5ED0000, v36, OS_LOG_TYPE_DEFAULT, "[%s|%s] updating early room for input %d", buf, 0x1Cu);
  }

  v93 = 128;
  v94 = 0;
  v95 = FilterLength;
  v96 = v82;
  v101 = v23;
  v102 = v26;
  v103 = v81;
  if (v34 != v35)
  {
    v41 = v34;
    do
    {
      Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v85 + 80), v41);
      caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(Element + 720);
      if (a2 == 1)
        v43 = Element + 736;
      else
        v43 = Element + 888;
      if (!IR::IRDataAttributes::operator==((uint64_t)&v91, v43)
        || (v44 = atomic_load((unsigned __int8 *)(Element + 681)), (v44 & 1) != 0))
      {
        IR::IRDataAttributes::operator=(v43, (uint64_t)&v91);
        v46 = *(uint64_t **)(Element + 248);
        v45 = *(uint64_t **)(Element + 256);
        while (v46 != v45)
        {
          v47 = *v46;
          v48 = atomic_load((unsigned __int8 *)(*(_QWORD *)(Element + 1288) + 160));
          AUSpatialMixerV2ChannelProcessor::setEarlyReflectionsIRDataAttributes(v47, v43, (v48 & 1) == 0, a2, 1);
          ++v46;
        }
      }
      caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(Element + 720);
      ++v41;
    }
    while (v41 != v35);
  }
  if (a2)
  {
    if (a2 != 1)
    {
LABEL_64:
      v40 = 0;
      goto LABEL_129;
    }
    v38 = 7468;
  }
  else
  {
    v38 = 7472;
  }
  v49 = atomic_load((unsigned int *)(v85 + v38));
  if ((v49 & 0x80000000) != 0)
    goto LABEL_64;
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v50 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
  {
    v51 = (_QWORD *)(v85 + 3592);
    if (*(char *)(v85 + 3615) < 0)
      v51 = (_QWORD *)*v51;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v51;
    v122 = 2080;
    v123 = "UpdateAutoModeReverbBus";
    _os_log_impl(&dword_1B5ED0000, v50, OS_LOG_TYPE_DEFAULT, "[%s|%s] updating late reverb", buf, 0x16u);
  }

  v105 = 128;
  v106 = FilterLength - v82;
  v108 = 0;
  v107 = v82;
  v115 = v23;
  v116 = v26;
  v117 = v81;
  v52 = atomic_load((unsigned int *)(v85 + 3672));
  switch(v52)
  {
    case 1u:
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v120, v85 + 3832);
      if (v120)
      {
        v57 = cf;
        cf = v120;
        CFRetain(v120);
        if (v57)
          CFRelease(v57);
      }
      else
      {
        IR::getPresetDataAttributes();
        v65 = cf;
        cf = *(CFTypeRef *)buf;
        *(_QWORD *)buf = v65;
        if (v131)
          CFRelease(v131);
        if (v130)
          CFRelease(v130);
        if (v129)
          CFRelease(v129);
        if (*(_QWORD *)buf)
          CFRelease(*(CFTypeRef *)buf);
      }
      LODWORD(v111) = 0;
      v66 = atomic_load((unsigned int *)(v85 + 6072));
      HIDWORD(v111) = v66;
      if (v120)
        CFRelease(v120);
      break;
    case 2u:
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v120, v85 + 3904);
      v58 = v120;
      if (!v120)
      {
        if (*(_BYTE *)(v85 + 6068))
        {
          IR::getPresetDataAttributes();
          v78 = cf;
          cf = *(CFTypeRef *)buf;
          *(_QWORD *)buf = v78;
          if (v131)
            CFRelease(v131);
          if (v130)
            CFRelease(v130);
          if (v129)
            CFRelease(v129);
          if (*(_QWORD *)buf)
            CFRelease(*(CFTypeRef *)buf);
          v56 = 0;
          goto LABEL_90;
        }
        v53 = (void *)cf;
        cf = 0;
        if (v53)
          CFRelease(v53);
LABEL_89:
        v54 = (IR::IRDataLoader *)IR::IRDataLoader::instance((IR::IRDataLoader *)v53);
        v55 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v85 + 128), 0);
        v56 = IR::IRDataLoader::registerCustomLayoutIfNecessary(v54, *(const AudioChannelLayout **)(v55 + 120));
LABEL_90:
        v111 = v56;
        break;
      }
      v59 = cf;
      cf = v120;
      CFRetain(v120);
      if (v59)
        CFRelease(v59);
      v111 = 0;
      CFRelease(v58);
      break;
    case 3u:
      v53 = (void *)cf;
      cf = 0;
      if (v53)
        CFRelease(v53);
      goto LABEL_89;
    default:
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v60 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        v79 = (_QWORD *)(v85 + 3592);
        if (*(char *)(v85 + 3615) < 0)
          v79 = (_QWORD *)*v79;
        v80 = atomic_load((unsigned int *)(v85 + 3672));
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v79;
        v122 = 2080;
        v123 = "ConfigureAutoModeReverbHOADecoder";
        v124 = 1024;
        *(_DWORD *)v125 = v80;
        _os_log_error_impl(&dword_1B5ED0000, v60, OS_LOG_TYPE_ERROR, "[%s|%s] Unknown output type %d", buf, 0x1Cu);
      }

      v61 = cf;
      cf = 0;
      if (v61)
        CFRelease(v61);
      v111 = 0;
      break;
  }
  v67 = atomic_load((unsigned __int8 *)(v85 + 5089));
  v113 = (v67 & 1) == 0;
  v112 = 1500;
  if (a2 == 1)
    v68 = v85 + 7480;
  else
    v68 = v85 + 7632;
  IR::IRDataAttributes::operator=(v68, (uint64_t)&v104);
  AUSM::AppleSauceCFWithMutex<__CFDictionary const*>::load(&v120, v85 + 5424);
  if (v34 != v35)
  {
    v70 = "post-processing";
    if (a2 == 1)
      v70 = "scene";
    v83 = v70;
    do
    {
      v71 = (std::__shared_weak_count *)operator new(0xB0uLL);
      v71->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v71->__shared_owners_;
      v71->__shared_weak_owners_ = 0;
      v71->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69CA638;
      v73 = 0;
      v87[0] = IR::IRDataAttributes::IRDataAttributes((uint64_t)&v71[1], (uint64_t)&v104);
      v87[1] = (uint64_t)v71;
      if (!a2)
      {
        v73 = v120;
        if (v120)
          CFRetain(v120);
      }
      v86 = v73;
      v74 = IR::SharedIRBuses::reconfigure(v85 + 2328, v34 + v49, v87, &v86);
      if (a2)
      {
        if (!v73)
          goto LABEL_161;
      }
      else if (!v73)
      {
        goto LABEL_161;
      }
      CFRelease(v73);
      do
LABEL_161:
        v75 = __ldaxr(p_shared_owners);
      while (__stlxr(v75 - 1, p_shared_owners));
      if (v75)
      {
        if (v74)
          goto LABEL_166;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
        if (v74)
        {
LABEL_166:
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v76 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
          {
            v77 = v85 + 3592;
            if (*(char *)(v85 + 3615) < 0)
              v77 = *(_QWORD *)(v85 + 3592);
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v77;
            v122 = 2080;
            v123 = "UpdateAutoModeReverbBus";
            v124 = 2080;
            *(_QWORD *)v125 = v83;
            *(_WORD *)&v125[8] = 1024;
            v126 = v34;
            v127 = 1024;
            v128 = v74;
            _os_log_error_impl(&dword_1B5ED0000, v76, OS_LOG_TYPE_ERROR, "[%s|%s] Could not reconfigure auto mode %s late reverb for input #%u: error %d", buf, 0x2Cu);
          }

        }
      }
      ++v34;
    }
    while (v34 != v35);
  }
  if (v120)
    CFRelease(v120);
  v40 = 1;
LABEL_129:
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v88);
  if (v90)
    CFRelease(v90);
  if (v114)
    CFRelease(v114);
  if (cf)
    CFRelease(cf);
  if (v109)
    CFRelease(v109);
  if (v104)
    CFRelease(v104);
  if (v100)
    CFRelease(v100);
  if (v99)
    CFRelease(v99);
  if (v98)
    CFRelease(v98);
  if (v91)
    CFRelease(v91);
  if (v119)
    CFRelease(v119);
  return v40;
}

void sub_1B61A1E8C(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t IR::IRDataAttributes::operator=(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  __int128 v13;
  const void *v14;
  const void *v15;
  uint64_t v16;

  v4 = *(const void **)a1;
  v5 = *(const void **)a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  if (v5)
    CFRetain(v5);
  if (v4)
    CFRelease(v4);
  v6 = *(_OWORD *)(a2 + 8);
  v7 = *(_OWORD *)(a2 + 24);
  v8 = *(_OWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v8;
  *(_OWORD *)(a1 + 24) = v7;
  *(_OWORD *)(a1 + 8) = v6;
  v9 = *(const void **)(a1 + 64);
  v10 = *(const void **)(a2 + 64);
  *(_QWORD *)(a1 + 64) = v10;
  if (v10)
    CFRetain(v10);
  if (v9)
    CFRelease(v9);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  v11 = *(const void **)(a1 + 88);
  v12 = *(const void **)(a2 + 88);
  *(_QWORD *)(a1 + 88) = v12;
  if (v12)
    CFRetain(v12);
  if (v11)
    CFRelease(v11);
  v13 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 105) = *(_OWORD *)(a2 + 105);
  *(_OWORD *)(a1 + 96) = v13;
  v14 = *(const void **)(a1 + 128);
  v15 = *(const void **)(a2 + 128);
  *(_QWORD *)(a1 + 128) = v15;
  if (v15)
    CFRetain(v15);
  if (v14)
    CFRelease(v14);
  v16 = *(_QWORD *)(a2 + 136);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 136) = v16;
  return a1;
}

const void **applesauce::CF::URLRef::operator=(const void **a1, CFTypeRef cf)
{
  const void *v3;

  v3 = *a1;
  *a1 = cf;
  if (cf)
    CFRetain(cf);
  if (v3)
    CFRelease(v3);
  return a1;
}

uint64_t AUSpatialMixerV2::ReconfigureSharedBuffers(AUSpatialMixerV2 *this, int a2, char a3)
{
  AUSpatialMixerV2 *v4;
  unint64_t v5;
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  AUSpatialMixerV2 *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  ausdk::AUScope *v15;
  uint64_t Element;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint32x2_t v21;
  uint64_t v22;
  uint32x2_t v23;
  uint64_t v24;
  uint32x2_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  IR::ComplexDataCircBuffer *v30;
  IR::ComplexDataCircBuffer *v31;
  IR::ComplexDataCircBuffer *v32;
  IR::ComplexDataCircBuffer *v33;
  NSObject *v34;
  _QWORD *v35;
  const char *v36;
  uint64_t *v37;
  uint64_t v38;
  void *v39;
  AUSpatialMixerV2 *v40;
  uint64_t v41;
  unsigned int RequiredSharedInputBufferSize;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  char *v62;
  void *v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  void *v68;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  unint64_t v72;
  unsigned int *v73;
  unint64_t v74;
  uint64_t v75;
  unsigned int v76;
  uint64_t v77;
  unsigned int v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t *v83;
  unsigned int v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  char v88;
  unsigned int v89[2];
  uint64_t *v90;
  unsigned int v92[4];
  __int128 v93;
  __int128 v94;
  unint64_t v95;
  __int128 v96;
  uint64_t *v97;
  int v98;
  uint32x2_t v99;
  unsigned int v100;
  int v101;
  uint32x2_t v102;
  unsigned int v103;
  _BYTE v104[12];
  unsigned int v105;
  char *v106;
  char v107;
  uint8_t buf[24];
  const char *v109;
  __int16 v110;
  unsigned int v111;
  __int16 v112;
  unsigned int v113;
  __int16 v114;
  unsigned int v115;
  __int16 v116;
  unsigned int v117;
  __int16 v118;
  int v119;
  __int16 v120;
  unsigned int v121;
  __int16 v122;
  unsigned int v123;
  __int16 v124;
  int v125;
  __int16 v126;
  int v127;
  __int16 v128;
  unsigned int v129;
  __int16 v130;
  unsigned int v131;
  __int16 v132;
  int v133;
  uint64_t v134;

  v4 = this;
  v134 = *MEMORY[0x1E0C80C00];
  v5 = *((unsigned int *)this + 84);
  v106 = (char *)this + 3352;
  v107 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 3352));
  v6 = atomic_load((unsigned __int8 *)v4 + 3746);
  v90 = (uint64_t *)v4;
  if ((v6 & 1) == 0)
    goto LABEL_23;
  v7 = *((_QWORD *)v4 + 15);
  if (v7)
  {
    LODWORD(v8) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
    if ((_DWORD)v8)
      goto LABEL_4;
LABEL_23:
    v14 = 0;
    v86 = 0;
    v87 = 0;
    v85 = 0;
    v13 = 0;
    v12 = 0;
    *(_QWORD *)v89 = 0;
    v9 = 0;
    v92[0] = 0;
    goto LABEL_34;
  }
  v8 = (*((_QWORD *)v4 + 13) - *((_QWORD *)v4 + 12)) >> 3;
  if (!(_DWORD)v8)
    goto LABEL_23;
LABEL_4:
  v88 = a3;
  v9 = 0;
  v10 = v4;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  *(_OWORD *)v92 = 0u;
  v93 = 0u;
  v15 = (AUSpatialMixerV2 *)((char *)v10 + 80);
  v94 = 0u;
  v96 = 0u;
  do
  {
    Element = ausdk::AUScope::SafeGetElement(v15, v11);
    v17 = Element + 720;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(Element + 720);
    v18 = *(uint64_t **)(Element + 248);
    if (v18 == *(uint64_t **)(Element + 256))
    {
      memset(buf, 0, sizeof(buf));
      LODWORD(v109) = 0;
    }
    else
    {
      v19 = *v18;
      *(_QWORD *)v104 = *v18 + 776;
      v104[8] = 1;
      caulk::pooled_semaphore_mutex::_lock(*(caulk::pooled_semaphore_mutex **)v104);
      v20 = *(_QWORD *)(v19 + 480);
      if (v20)
      {
        (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v20 + 288))(buf);
      }
      else
      {
        memset(buf, 0, sizeof(buf));
        LODWORD(v109) = 0;
      }
      std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)v104);
    }
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v17);
    v21 = *(uint32x2_t *)&buf[4];
    if (*(_DWORD *)&buf[16] > v9)
      v9 = *(_DWORD *)&buf[16];
    v22 = ausdk::AUScope::SafeGetElement(v15, v11);
    AUSpatialMixerV2InputElement::GetHeadTrackedEarlyReflectionsFilterParams((int *)v104, v22, 1);
    v23 = *(uint32x2_t *)&v104[4];
    if (v105 > v12)
      v12 = v105;
    v24 = ausdk::AUScope::SafeGetElement(v15, v11);
    AUSpatialMixerV2InputElement::GetHeadTrackedEarlyReflectionsFilterParams(&v101, v24, 0);
    v25 = v102;
    if (v103 > v14)
      v14 = v103;
    v26 = ausdk::AUScope::SafeGetElement(v15, v11);
    AUSpatialMixerV2InputElement::GetHeadTrackedEarlyReflectionsFilterParams(&v98, v26, 2);
    *((_QWORD *)&v27 + 1) = *(_QWORD *)&v92[2];
    *(uint32x2_t *)&v27 = vmax_u32(v21, *(uint32x2_t *)v92);
    *(_OWORD *)v92 = v27;
    *((_QWORD *)&v27 + 1) = *((_QWORD *)&v93 + 1);
    *(uint32x2_t *)&v27 = vmax_u32(v23, *(uint32x2_t *)&v93);
    v93 = v27;
    *((_QWORD *)&v28 + 1) = *((_QWORD *)&v94 + 1);
    *((_QWORD *)&v29 + 1) = *((_QWORD *)&v96 + 1);
    *(uint32x2_t *)&v28 = vmax_u32(v25, *(uint32x2_t *)&v94);
    v94 = v28;
    *(uint32x2_t *)&v29 = vmax_u32(v99, *(uint32x2_t *)&v96);
    v96 = v29;
    if (v100 > v13)
      v13 = v100;
    ++v11;
  }
  while ((_DWORD)v8 != v11);
  if (v92[0])
  {
    v89[1] = v92[1] + vcvtps_u32_f32((float)v5 / (float)v92[0]) - 1;
  }
  else
  {
    v89[1] = v92[1];
    v92[0] = 0;
  }
  v4 = (AUSpatialMixerV2 *)v90;
  a3 = v88;
  if ((_DWORD)v93)
  {
    v89[0] = v93;
    HIDWORD(v87) = DWORD1(v93) + vcvtps_u32_f32((float)v5 / (float)v93) - 1;
  }
  else
  {
    HIDWORD(v87) = DWORD1(v93);
    v89[0] = 0;
  }
  if ((_DWORD)v28)
  {
    LODWORD(v87) = v28;
    HIDWORD(v86) = DWORD1(v28) + vcvtps_u32_f32((float)v5 / (float)v28) - 1;
  }
  else
  {
    HIDWORD(v86) = DWORD1(v28);
    LODWORD(v87) = 0;
  }
  if ((_DWORD)v29)
  {
    LODWORD(v86) = v29;
    v85 = DWORD1(v29) + vcvtps_u32_f32((float)v5 / (float)v29) - 1;
  }
  else
  {
    v85 = DWORD1(v29);
    LODWORD(v86) = 0;
  }
LABEL_34:
  *(_QWORD *)v104 = (char *)v4 + 3336;
  v104[8] = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)v4 + 3336);
  if ((a3 & 1) == 0)
  {
    v30 = (IR::ComplexDataCircBuffer *)(*((_QWORD *)v4 + 370) + 776);
    if (v92[0] == IR::ComplexDataCircBuffer::getFFTPartitionLength(v30)
      && v89[1] == IR::ComplexDataCircBuffer::getNumFFTBuffers(v30)
      && v9 == IR::ComplexDataCircBuffer::getNumOutputChannels(v30))
    {
      v31 = (IR::ComplexDataCircBuffer *)(*((_QWORD *)v4 + 370) + 784);
      if (v89[0] == IR::ComplexDataCircBuffer::getFFTPartitionLength(v31)
        && HIDWORD(v87) == IR::ComplexDataCircBuffer::getNumFFTBuffers(v31)
        && v12 == IR::ComplexDataCircBuffer::getNumOutputChannels(v31))
      {
        v32 = (IR::ComplexDataCircBuffer *)(*((_QWORD *)v4 + 370) + 792);
        if ((_DWORD)v87 == IR::ComplexDataCircBuffer::getFFTPartitionLength(v32)
          && HIDWORD(v86) == IR::ComplexDataCircBuffer::getNumFFTBuffers(v32)
          && v14 == IR::ComplexDataCircBuffer::getNumOutputChannels(v32))
        {
          v33 = (IR::ComplexDataCircBuffer *)(*((_QWORD *)v4 + 370) + 800);
          if ((_DWORD)v86 == IR::ComplexDataCircBuffer::getFFTPartitionLength(v33)
            && v85 == IR::ComplexDataCircBuffer::getNumFFTBuffers(v33)
            && v13 == IR::ComplexDataCircBuffer::getNumOutputChannels(v33))
          {
            goto LABEL_116;
          }
        }
      }
    }
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v34 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    v35 = (_QWORD *)((char *)v4 + 3592);
    if (*((char *)v4 + 3615) < 0)
      v35 = (_QWORD *)*v35;
    v36 = "false";
    *(_DWORD *)buf = 136318722;
    *(_QWORD *)&buf[4] = v35;
    *(_QWORD *)&buf[14] = "ReconfigureSharedBuffers";
    *(_WORD *)&buf[12] = 2080;
    if (a2)
      v36 = "true";
    *(_WORD *)&buf[22] = 2080;
    v109 = v36;
    v110 = 1024;
    v111 = v9;
    v112 = 1024;
    v113 = v89[1];
    v114 = 1024;
    v115 = v92[0];
    v116 = 1024;
    v117 = v12;
    v118 = 1024;
    v119 = HIDWORD(v87);
    v120 = 1024;
    v121 = v89[0];
    v122 = 1024;
    v123 = v14;
    v124 = 1024;
    v125 = HIDWORD(v86);
    v126 = 1024;
    v127 = v87;
    v128 = 1024;
    v129 = v13;
    v130 = 1024;
    v131 = v85;
    v132 = 1024;
    v133 = v86;
    _os_log_impl(&dword_1B5ED0000, v34, OS_LOG_TYPE_DEFAULT, "[%s|%s] Reinitializing shared buffers. immediateUpdate = %s, fftParams {.numOutputs, .numFFTSubFilters, .partitionLength}: hrtfParams = {%u, %u, %u}, sceneBusParams = {%u, %u, %u}, postProcBusParams = {%u, %u, %u}, combinedBusParams = {%u, %u, %u}", buf, 0x68u);
  }

  v37 = (uint64_t *)((char *)v4 + 2960);
  if (a2)
    v38 = 2960;
  else
    v38 = 2952;
  v83 = (uint64_t *)((char *)v4 + 2952);
  if (!a2)
    v37 = (uint64_t *)((char *)v4 + 2952);
  v97 = v37;
  v39 = (void *)operator new();
  bzero(v39, 0x340uLL);
  AUSM::SharedBuffers::SharedBuffers((AUSM::SharedBuffers *)v39);
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](v97, (uint64_t)v39);
  v40 = v4;
  v41 = *(_QWORD *)((char *)v4 + v38);
  RequiredSharedInputBufferSize = AUSpatialMixerV2::GetRequiredSharedInputBufferSize(v40);
  v95 = *(unsigned int *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v90 + 16), 0) + 108);
  v84 = RequiredSharedInputBufferSize;
  v43 = RequiredSharedInputBufferSize;
  v45 = *(_QWORD *)(v41 + 224);
  v44 = *(_QWORD *)(v41 + 232);
  v46 = (v44 - v45) >> 5;
  if (v43 > v46)
  {
    v47 = *(_QWORD *)(v41 + 240);
    if (v43 - v46 > (v47 - v44) >> 5)
    {
      v48 = v47 - v45;
      v49 = (v47 - v45) >> 4;
      if (v49 <= v43)
        v49 = v43;
      if (v48 >= 0x7FFFFFFFFFFFFFE0)
        v50 = 0x7FFFFFFFFFFFFFFLL;
      else
        v50 = v49;
      if (v50 >> 59)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v51 = (char *)operator new(32 * v50);
      v52 = &v51[32 * v46];
      v53 = &v51[32 * v43];
      v54 = v52;
      do
      {
        *(_QWORD *)v54 = 0;
        *((_QWORD *)v54 + 1) = 0;
        *((_QWORD *)v54 + 2) = 0;
        v54[24] = 1;
        v54 += 32;
      }
      while (v54 != v53);
      v55 = &v51[32 * v50];
      v57 = *(char **)(v41 + 224);
      v56 = *(char **)(v41 + 232);
      if (v56 == v57)
      {
        *(_QWORD *)(v41 + 224) = v52;
        *(_QWORD *)(v41 + 232) = v53;
        *(_QWORD *)(v41 + 240) = v55;
        if (!v56)
          goto LABEL_80;
      }
      else
      {
        do
        {
          *((_QWORD *)v52 - 4) = 0;
          *((_QWORD *)v52 - 3) = 0;
          v52 -= 32;
          *((_QWORD *)v52 + 2) = 0;
          v58 = *((_QWORD *)v56 - 4);
          v56 -= 32;
          v52[24] = 1;
          *(_QWORD *)v52 = v58;
          *(_QWORD *)v56 = 0;
          v59 = *((_QWORD *)v52 + 1);
          *((_QWORD *)v52 + 1) = *((_QWORD *)v56 + 1);
          *((_QWORD *)v56 + 1) = v59;
          v60 = *((_QWORD *)v52 + 2);
          *((_QWORD *)v52 + 2) = *((_QWORD *)v56 + 2);
          *((_QWORD *)v56 + 2) = v60;
          v52[24] = v56[24];
        }
        while (v56 != v57);
        v61 = *(char **)(v41 + 224);
        v56 = *(char **)(v41 + 232);
        *(_QWORD *)(v41 + 224) = v52;
        *(_QWORD *)(v41 + 232) = v53;
        *(_QWORD *)(v41 + 240) = v55;
        if (v56 != v61)
        {
          v62 = v56;
          do
          {
            v64 = (void *)*((_QWORD *)v62 - 4);
            v62 -= 32;
            v63 = v64;
            if (v64)
            {
              *((_QWORD *)v56 - 3) = v63;
              operator delete(v63);
            }
            v56 = v62;
          }
          while (v62 != v61);
          v56 = v61;
        }
        if (!v56)
          goto LABEL_80;
      }
      operator delete(v56);
LABEL_80:
      v65 = *(_QWORD *)(v41 + 232);
      goto LABEL_92;
    }
    v65 = v44 + 32 * (v43 - v46);
    do
    {
      *(_QWORD *)v44 = 0;
      *(_QWORD *)(v44 + 8) = 0;
      *(_QWORD *)(v44 + 16) = 0;
      *(_BYTE *)(v44 + 24) = 1;
      v44 += 32;
    }
    while (v44 != v65);
    goto LABEL_90;
  }
  if (v43 < v46)
  {
    v65 = v45 + 32 * v43;
    if (v44 != v65)
    {
      v66 = *(_QWORD *)(v41 + 232);
      do
      {
        v68 = *(void **)(v66 - 32);
        v66 -= 32;
        v67 = v68;
        if (v68)
        {
          *(_QWORD *)(v44 - 24) = v67;
          operator delete(v67);
        }
        v44 = v66;
      }
      while (v66 != v65);
    }
LABEL_90:
    *(_QWORD *)(v41 + 232) = v65;
    goto LABEL_92;
  }
  v65 = *(_QWORD *)(v41 + 232);
LABEL_92:
  for (i = *(_QWORD *)(v41 + 224); i != v65; i += 32)
    std::vector<float>::resize(i, v5);
  for (j = 0; j != 128; j += 32)
    std::vector<float>::resize(v41 + j, v5);
  for (k = 0; k != 72; k += 24)
    std::vector<float>::resize(v41 + 128 + k, v5);
  *(_DWORD *)(v41 + 324) = v84;
  std::vector<float>::resize(v41 + 248, v5 * v84);
  v72 = (16 * v43) | 8;
  buf[0] = 0;
  v73 = *(unsigned int **)(v41 + 272);
  v74 = *(_QWORD *)(v41 + 280) - (_QWORD)v73;
  if (v72 <= v74)
  {
    if (v72 < v74)
      *(_QWORD *)(v41 + 280) = (char *)v73 + v72;
  }
  else
  {
    std::vector<char>::__append((std::vector<char> *)(v41 + 272), v72 - v74, (std::vector<char>::const_reference)buf);
    v73 = *(unsigned int **)(v41 + 272);
  }
  *v73 = v84;
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 296), v43, buf);
  std::vector<float>::resize(v41 + 808, (v5 * v95));
  std::vector<void const*>::resize(v41 + 200, v95);
  v75 = 8 * v95;
  if ((_DWORD)v95)
  {
    v76 = 0;
    v77 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(v41 + 200) + v77) = *(_QWORD *)(v41 + 808) + 4 * v76;
      v77 += 8;
      v76 += v5;
    }
    while (v75 != v77);
  }
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 328), v95, buf);
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 352), v95, buf);
  *(_DWORD *)(v41 + 380) = v95;
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 488), v95, buf);
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 512), v95, buf);
  *(_DWORD *)(v41 + 540) = v95;
  *(_DWORD *)buf = 0;
  std::vector<float>::assign((char **)(v41 + 552), (v5 * v95), buf);
  if ((_DWORD)v95)
  {
    v78 = 0;
    v79 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(v41 + 488) + v79) = *(_QWORD *)(v41 + 552) + 4 * v78;
      v79 += 8;
      v78 += v5;
    }
    while (v75 != v79);
  }
  *(_DWORD *)(v41 + 576) = v5;
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 584), 2uLL, buf);
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 608), 2uLL, buf);
  *(_DWORD *)(v41 + 636) = 2;
  *(_DWORD *)buf = 0;
  std::vector<float>::assign((char **)(v41 + 648), (2 * v5), buf);
  **(_QWORD **)(v41 + 584) = *(_QWORD *)(v41 + 648);
  *(_QWORD *)(*(_QWORD *)(v41 + 584) + 8) = *(_QWORD *)(v41 + 648) + 4 * v5;
  *(_DWORD *)(v41 + 672) = v5;
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 680), 2uLL, buf);
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 704), 2uLL, buf);
  *(_DWORD *)(v41 + 732) = 2;
  *(_DWORD *)buf = 0;
  std::vector<float>::assign((char **)(v41 + 744), (2 * v5), buf);
  **(_QWORD **)(v41 + 680) = *(_QWORD *)(v41 + 744);
  *(_QWORD *)(*(_QWORD *)(v41 + 680) + 8) = *(_QWORD *)(v41 + 744) + 4 * v5;
  *(_DWORD *)(v41 + 768) = v5;
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 392), 2uLL, buf);
  *(_QWORD *)buf = 0;
  std::vector<float *>::assign((char **)(v41 + 416), 2uLL, buf);
  *(_DWORD *)(v41 + 444) = 2;
  *(_DWORD *)buf = 0;
  std::vector<float>::assign((char **)(v41 + 456), (2 * v5), buf);
  **(_QWORD **)(v41 + 392) = *(_QWORD *)(v41 + 456);
  *(_QWORD *)(*(_QWORD *)(v41 + 392) + 8) = *(_QWORD *)(v41 + 456) + 4 * v5;
  *(_DWORD *)(v41 + 480) = v5;
  IR::ComplexDataCircBuffer::initialize((IR::ComplexDataCircBuffer *)(*v97 + 776));
  IR::ComplexDataCircBuffer::initialize((IR::ComplexDataCircBuffer *)(*v97 + 784));
  IR::ComplexDataCircBuffer::initialize((IR::ComplexDataCircBuffer *)(*v97 + 792));
  IR::ComplexDataCircBuffer::initialize((IR::ComplexDataCircBuffer *)(*v97 + 800));
  if (a2)
  {
    v80 = v90;
    if (*v83)
      std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](v83, 0);
    v81 = v90[368];
    if (v81)
    {
      std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](v90 + 368, 0);
      LOBYTE(v81) = 0;
    }
  }
  else
  {
    __dmb(0xBu);
    LOBYTE(v81) = 1;
    v80 = v90;
  }
  atomic_store(v81, (unsigned __int8 *)v80 + 2865);
LABEL_116:
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)v104);
  return std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v106);
}

void sub_1B61A2D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&a37);
  _Unwind_Resume(a1);
}

AUSM::SharedBuffers *AUSM::SharedBuffers::SharedBuffers(AUSM::SharedBuffers *this)
{
  uint64_t i;
  char *v3;
  std::vector<char>::value_type __x[9];

  for (i = 0; i != 128; i += 32)
  {
    v3 = (char *)this + i;
    *(_QWORD *)v3 = 0;
    *((_QWORD *)v3 + 1) = 0;
    *((_QWORD *)v3 + 2) = 0;
    v3[24] = 1;
  }
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  __x[0] = 0;
  std::vector<char>::vector((std::vector<char> *)((char *)this + 272), 8uLL, __x);
  **((_DWORD **)this + 34) = 0;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((_BYTE *)this + 376) = 1;
  *(_QWORD *)((char *)this + 380) = 0;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *((_BYTE *)this + 440) = 1;
  *(_QWORD *)((char *)this + 444) = 0;
  *((_QWORD *)this + 58) = 0;
  *((_QWORD *)this + 59) = 0;
  *((_QWORD *)this + 57) = 0;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *((_BYTE *)this + 536) = 1;
  *(_QWORD *)((char *)this + 540) = 0;
  *((_QWORD *)this + 71) = 0;
  *((_QWORD *)this + 69) = 0;
  *((_QWORD *)this + 70) = 0;
  *(_OWORD *)((char *)this + 584) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *((_BYTE *)this + 632) = 1;
  *(_QWORD *)((char *)this + 636) = 0;
  *((_QWORD *)this + 83) = 0;
  *((_QWORD *)this + 81) = 0;
  *((_QWORD *)this + 82) = 0;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  *(_OWORD *)((char *)this + 712) = 0u;
  *((_BYTE *)this + 728) = 1;
  *(_QWORD *)((char *)this + 732) = 0;
  *((_QWORD *)this + 94) = 0;
  *((_QWORD *)this + 93) = 0;
  *((_QWORD *)this + 95) = 0;
  IR::ComplexDataCircBuffer::ComplexDataCircBuffer((AUSM::SharedBuffers *)((char *)this + 776));
  IR::ComplexDataCircBuffer::ComplexDataCircBuffer((AUSM::SharedBuffers *)((char *)this + 784));
  IR::ComplexDataCircBuffer::ComplexDataCircBuffer((AUSM::SharedBuffers *)((char *)this + 792));
  IR::ComplexDataCircBuffer::ComplexDataCircBuffer((AUSM::SharedBuffers *)((char *)this + 800));
  *((_QWORD *)this + 103) = 0;
  *(_OWORD *)((char *)this + 808) = 0u;
  return this;
}

void sub_1B61A2F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, AUSM::ABLBuffer *a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  IR::ComplexDataCircBuffer *v13;
  uint64_t v14;
  AUSM::OutputBuffers *v15;
  AUSM::OutputBuffers *v16;
  AUSM::OutputBuffers *v17;
  AUSM::OutputBuffers *v18;
  IR::ComplexDataCircBuffer *v19;
  IR::ComplexDataCircBuffer *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  void *v25;

  IR::ComplexDataCircBuffer::~ComplexDataCircBuffer(v13);
  IR::ComplexDataCircBuffer::~ComplexDataCircBuffer(v20);
  IR::ComplexDataCircBuffer::~ComplexDataCircBuffer(v19);
  AUSM::OutputBuffers::~OutputBuffers(v18);
  AUSM::OutputBuffers::~OutputBuffers(v17);
  AUSM::OutputBuffers::~OutputBuffers(v16);
  AUSM::OutputBuffers::~OutputBuffers(v15);
  vp::vx::io::Direction_Pair<std::vector<std::tuple<unsigned int,vp::services::Audio_Issue_Detector_Node_ID>>>::~Direction_Pair(v14);
  AUSM::ABLBuffer::~ABLBuffer(a10);
  std::vector<DspLib::PeakPowerGuard::AdmittanceFilterCoeffSet::FIRfilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  v21 = *(void **)(v12 + 200);
  if (v21)
  {
    *(_QWORD *)(v12 + 208) = v21;
    operator delete(v21);
  }
  v22 = 0;
  while (1)
  {
    v23 = *(void **)(v12 + v22 + 176);
    if (v23)
    {
      *(_QWORD *)(v12 + v22 + 184) = v23;
      operator delete(v23);
    }
    v22 -= 24;
    if (v22 == -72)
    {
      v24 = 0;
      while (1)
      {
        v25 = *(void **)(v12 + v24 + 96);
        if (v25)
        {
          *(_QWORD *)(v12 + v24 + 104) = v25;
          operator delete(v25);
        }
        v24 -= 32;
        if (v24 == -128)
          _Unwind_Resume(a1);
      }
    }
  }
}

void sub_1B61A3028()
{
  uint64_t v0;
  void **v1;
  void *v2;

  v2 = *v1;
  if (*v1)
  {
    *(_QWORD *)(v0 + 256) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1B61A2FBCLL);
}

uint64_t *std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  void *v25;
  void **v26;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = *(void **)(v2 + 808);
    if (v3)
    {
      *(_QWORD *)(v2 + 816) = v3;
      operator delete(v3);
    }
    IR::ComplexDataCircBuffer::~ComplexDataCircBuffer((IR::ComplexDataCircBuffer *)(v2 + 800));
    IR::ComplexDataCircBuffer::~ComplexDataCircBuffer((IR::ComplexDataCircBuffer *)(v2 + 792));
    IR::ComplexDataCircBuffer::~ComplexDataCircBuffer((IR::ComplexDataCircBuffer *)(v2 + 784));
    IR::ComplexDataCircBuffer::~ComplexDataCircBuffer((IR::ComplexDataCircBuffer *)(v2 + 776));
    v4 = *(void **)(v2 + 744);
    if (v4)
    {
      *(_QWORD *)(v2 + 752) = v4;
      operator delete(v4);
    }
    v5 = *(void **)(v2 + 704);
    if (v5)
    {
      *(_QWORD *)(v2 + 712) = v5;
      operator delete(v5);
    }
    v6 = *(void **)(v2 + 680);
    if (v6)
    {
      *(_QWORD *)(v2 + 688) = v6;
      operator delete(v6);
    }
    v7 = *(void **)(v2 + 648);
    if (v7)
    {
      *(_QWORD *)(v2 + 656) = v7;
      operator delete(v7);
    }
    v8 = *(void **)(v2 + 608);
    if (v8)
    {
      *(_QWORD *)(v2 + 616) = v8;
      operator delete(v8);
    }
    v9 = *(void **)(v2 + 584);
    if (v9)
    {
      *(_QWORD *)(v2 + 592) = v9;
      operator delete(v9);
    }
    v10 = *(void **)(v2 + 552);
    if (v10)
    {
      *(_QWORD *)(v2 + 560) = v10;
      operator delete(v10);
    }
    v11 = *(void **)(v2 + 512);
    if (v11)
    {
      *(_QWORD *)(v2 + 520) = v11;
      operator delete(v11);
    }
    v12 = *(void **)(v2 + 488);
    if (v12)
    {
      *(_QWORD *)(v2 + 496) = v12;
      operator delete(v12);
    }
    v13 = *(void **)(v2 + 456);
    if (v13)
    {
      *(_QWORD *)(v2 + 464) = v13;
      operator delete(v13);
    }
    v14 = *(void **)(v2 + 416);
    if (v14)
    {
      *(_QWORD *)(v2 + 424) = v14;
      operator delete(v14);
    }
    v15 = *(void **)(v2 + 392);
    if (v15)
    {
      *(_QWORD *)(v2 + 400) = v15;
      operator delete(v15);
    }
    v16 = *(void **)(v2 + 352);
    if (v16)
    {
      *(_QWORD *)(v2 + 360) = v16;
      operator delete(v16);
    }
    v17 = *(void **)(v2 + 328);
    if (v17)
    {
      *(_QWORD *)(v2 + 336) = v17;
      operator delete(v17);
    }
    v18 = *(void **)(v2 + 296);
    if (v18)
    {
      *(_QWORD *)(v2 + 304) = v18;
      operator delete(v18);
    }
    v19 = *(void **)(v2 + 272);
    if (v19)
    {
      *(_QWORD *)(v2 + 280) = v19;
      operator delete(v19);
    }
    v20 = *(void **)(v2 + 248);
    if (v20)
    {
      *(_QWORD *)(v2 + 256) = v20;
      operator delete(v20);
    }
    v26 = (void **)(v2 + 224);
    std::vector<DspLib::PeakPowerGuard::AdmittanceFilterCoeffSet::FIRfilter>::__destroy_vector::operator()[abi:ne180100](&v26);
    v21 = *(void **)(v2 + 200);
    if (v21)
    {
      *(_QWORD *)(v2 + 208) = v21;
      operator delete(v21);
    }
    v22 = 0;
    while (1)
    {
      v23 = *(void **)(v2 + v22 + 176);
      if (v23)
      {
        *(_QWORD *)(v2 + v22 + 184) = v23;
        operator delete(v23);
      }
      v22 -= 24;
      if (v22 == -72)
      {
        v24 = 0;
        while (1)
        {
          v25 = *(void **)(v2 + v24 + 96);
          if (v25)
          {
            *(_QWORD *)(v2 + v24 + 104) = v25;
            operator delete(v25);
          }
          v24 -= 32;
          if (v24 == -128)
            JUMPOUT(0x1BCC95CECLL);
        }
      }
    }
  }
  return result;
}

uint64_t AUSpatialMixerV2::GetRequiredSharedInputBufferSize(AUSpatialMixerV2 *this)
{
  unsigned int v2;
  ausdk::AUScope *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;

  v2 = 0;
  v3 = (AUSpatialMixerV2 *)((char *)this + 80);
  v4 = 2;
  while (1)
  {
    v5 = *((_QWORD *)this + 15);
    if (v5)
      LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    else
      v6 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
    if (v2 >= v6)
      break;
    v7 = *(_DWORD *)(ausdk::AUScope::SafeGetElement(v3, v2) + 108);
    if (v4 <= v7)
      v4 = v7;
    else
      v4 = v4;
    ++v2;
  }
  return v4;
}

uint64_t std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(*(_QWORD *)a1);
  return a1;
}

void AUSM::OutputBuffers::~OutputBuffers(AUSM::OutputBuffers *this)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)*((_QWORD *)this + 8);
  if (v2)
  {
    *((_QWORD *)this + 9) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  v4 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v4;
    operator delete(v4);
  }
}

void AUSM::ABLBuffer::~ABLBuffer(AUSM::ABLBuffer *this)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  v4 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v4;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<IR::IRDataAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69CA638;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<IR::IRDataAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69CA638;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void std::__shared_ptr_emplace<IR::IRDataAttributes>::__on_zero_shared(uint64_t a1)
{
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)(a1 + 24));
}

void AUSpatialMixerV2::GetAutoModeReverbAttributes(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  BOOL v7;
  double *Element;
  float v9;
  unsigned int v10;
  CFTypeRef v11;
  CFTypeRef v12;
  CFTypeRef v13;
  CFTypeRef v14;
  CFTypeRef v15;
  CFTypeRef v16;
  CFTypeRef v17;
  CFTypeRef v18;
  int v19;
  CFTypeRef v20;
  uint64_t v21;
  CFTypeRef v22;
  CFTypeRef v23;
  CFTypeRef v24;
  CFTypeRef v25;
  uint64_t v26;
  CFTypeRef v27;
  CFTypeRef v28;
  CFTypeRef v29;
  IR::IRDataLoader *v30;
  double *v31;
  double *v32;
  IR::IRDataLoader *v33;
  double *v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  CFTypeRef cf;
  double *v38;
  CFTypeRef v39;
  CFTypeRef cf2;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  char v44;
  CFTypeRef v45;
  __int128 v46;
  CFTypeRef v47;
  _OWORD v48[2];
  CFTypeRef v49;
  uint64_t v50;
  int v51;
  CFTypeRef cf1;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  char v56;
  CFTypeRef v57;
  __int128 v58;
  CFTypeRef v59;
  _OWORD v60[2];
  CFTypeRef v61;
  uint64_t v62;
  int v63;
  CFTypeRef v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  char v68;
  CFTypeRef v69;
  __int128 v70;
  CFTypeRef v71;
  _OWORD v72[2];
  CFTypeRef v73;
  uint64_t v74;
  int v75;

  v6 = 3660;
  if (a3 == 1)
    v6 = 3656;
  atomic_load((unsigned int *)(a2 + v6));
  IR::getPresetDataAttributes();
  if (a3 == 1)
  {
    v7 = 0;
  }
  else
  {
    std::recursive_mutex::lock((std::recursive_mutex *)(a2 + 704));
    v7 = *(_BYTE *)(a2 + 696) != 0;
    if (*(_BYTE *)(a2 + 696))
      IR::IRDataAttributes::operator=((uint64_t)&v64, a2 + 544);
    std::recursive_mutex::unlock((std::recursive_mutex *)(a2 + 704));
  }
  Element = (double *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a2 + 128), 0);
  v9 = Element[10];
  *(float *)&v65 = v9;
  v10 = atomic_load((unsigned int *)(a2 + 3680));
  DWORD1(v67) = v10;
  v11 = v64;
  if (v64)
    Element = (double *)CFRetain(v64);
  cf1 = v11;
  v53 = v65;
  v54 = v66;
  v55 = v67;
  v56 = v68;
  v12 = v69;
  if (v69)
    Element = (double *)CFRetain(v69);
  v57 = v12;
  v58 = v70;
  v13 = v71;
  if (v71)
    Element = (double *)CFRetain(v71);
  v59 = v13;
  v60[0] = v72[0];
  *(_OWORD *)((char *)v60 + 9) = *(_OWORD *)((char *)v72 + 9);
  v14 = v73;
  if (v73)
    Element = (double *)CFRetain(v73);
  v15 = v64;
  v61 = v14;
  v62 = v74;
  v63 = v75;
  if (v64)
    Element = (double *)CFRetain(v64);
  cf2 = v15;
  v41 = v65;
  v42 = v66;
  v43 = v67;
  v44 = v68;
  v16 = v69;
  if (v69)
    Element = (double *)CFRetain(v69);
  v45 = v16;
  v46 = v70;
  v17 = v71;
  if (v71)
    Element = (double *)CFRetain(v71);
  v47 = v17;
  v48[0] = v72[0];
  *(_OWORD *)((char *)v48 + 9) = *(_OWORD *)((char *)v72 + 9);
  v18 = v73;
  if (v73)
    Element = (double *)CFRetain(v73);
  v49 = v18;
  v50 = v74;
  v51 = v75;
  if (v7)
  {
    v19 = 1028443341;
    goto LABEL_51;
  }
  if (a3 == 1)
  {
    AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&cf, a2 + 4264);
    v20 = cf;
    if (!cf)
    {
      v21 = a2 + 3976;
LABEL_36:
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v39, v21);
      v24 = v39;
      if (v39)
      {
        v25 = cf1;
        cf1 = v39;
        CFRetain(v39);
        if (v25)
          CFRelease(v25);
        v19 = 0;
        CFRelease(v24);
      }
      else
      {
        v19 = 1028443341;
      }
      if (a3 == 1)
        v26 = a2 + 4120;
      else
        v26 = a2 + 4192;
      AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&v39, v26);
      v27 = v39;
      if (v39)
      {
        v28 = cf2;
        cf2 = v39;
        CFRetain(v39);
        if (v28)
          CFRelease(v28);
        if (!v24)
        {
          v29 = cf1;
          cf1 = 0;
          v19 = 0;
          if (v29)
            CFRelease(v29);
        }
        CFRelease(v27);
      }
      else if (v24)
      {
        Element = (double *)cf2;
        cf2 = 0;
        v19 = 0;
        if (Element)
          CFRelease(Element);
      }
      goto LABEL_51;
    }
  }
  else
  {
    AUSM::AppleSauceCFWithMutex<__CFURL const*>::load(&cf, a2 + 4336);
    v20 = cf;
    if (!cf)
    {
      v21 = a2 + 4048;
      goto LABEL_36;
    }
  }
  v22 = cf1;
  cf1 = v20;
  CFRetain(v20);
  if (v22)
    CFRelease(v22);
  v23 = cf2;
  cf2 = v20;
  CFRetain(v20);
  if (v23)
    CFRelease(v23);
  v19 = 0;
  CFRelease(v20);
LABEL_51:
  if (!cf1)
    goto LABEL_72;
  v30 = (IR::IRDataLoader *)IR::IRDataLoader::instance((IR::IRDataLoader *)Element);
  IR::IRDataLoader::getIRDataTypes(v30, (const IR::IRDataAttributes *)&cf1);
  v31 = (double *)cf;
  Element = v38;
  if (v38 != cf)
  {
    v32 = (double *)cf;
    while (*(_DWORD *)v32 != 3)
    {
      v32 = (double *)((char *)v32 + 4);
      if (v32 == v38)
      {
        v32 = v38;
        break;
      }
    }
    if (v32 != v38)
      LODWORD(v55) = 3;
    while (*(_DWORD *)v31 != 2)
    {
      v31 = (double *)((char *)v31 + 4);
      if (v31 == v38)
      {
        v31 = v38;
        break;
      }
    }
    if (v31 == v38)
      goto LABEL_69;
    if ((_DWORD)v55 != 3)
      LODWORD(v55) = 2;
    if (cf1 && cf2)
    {
      if (!CFEqual(cf1, cf2))
      {
LABEL_69:
        Element = (double *)cf;
        goto LABEL_70;
      }
    }
    else if ((unint64_t)cf1 | (unint64_t)cf2)
    {
      goto LABEL_69;
    }
    LODWORD(v43) = 2;
    goto LABEL_69;
  }
LABEL_70:
  if (Element)
  {
    v38 = Element;
    operator delete(Element);
  }
LABEL_72:
  if ((_DWORD)v43 != 2)
  {
    v33 = (IR::IRDataLoader *)IR::IRDataLoader::instance((IR::IRDataLoader *)Element);
    IR::IRDataLoader::getIRDataTypes(v33, (const IR::IRDataAttributes *)&cf2);
    if (v38 != cf)
    {
      v34 = (double *)cf;
      while (*(_DWORD *)v34 != 2)
      {
        v34 = (double *)((char *)v34 + 4);
        if (v34 == v38)
        {
          v34 = v38;
          break;
        }
      }
      if (v34 != v38)
        LODWORD(v43) = 2;
    }
    if (cf)
    {
      v38 = (double *)cf;
      operator delete((void *)cf);
    }
  }
  v35 = atomic_load((unsigned __int8 *)(a2 + 5090));
  BYTE9(v53) = v35 & 1;
  v36 = atomic_load((unsigned __int8 *)(a2 + 5090));
  BYTE9(v41) = v36 & 1;
  IR::IRDataAttributes::IRDataAttributes(a1, (uint64_t)&cf1);
  IR::IRDataAttributes::IRDataAttributes(a1 + 152, (uint64_t)&cf2);
  *(_DWORD *)(a1 + 304) = v19;
  if (v49)
    CFRelease(v49);
  if (v47)
    CFRelease(v47);
  if (v45)
    CFRelease(v45);
  if (cf2)
    CFRelease(cf2);
  if (v61)
    CFRelease(v61);
  if (v59)
    CFRelease(v59);
  if (v57)
    CFRelease(v57);
  if (cf1)
    CFRelease(cf1);
  if (v73)
    CFRelease(v73);
  if (v71)
    CFRelease(v71);
  if (v69)
    CFRelease(v69);
  if (v64)
    CFRelease(v64);
}

void sub_1B61A396C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v33;

  applesauce::CF::URLRef::~URLRef(&a10);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)&a14);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)&a33);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)(v33 - 248));
  _Unwind_Resume(a1);
}

float applesauce::CF::at_or<float,__CFString const*>(const __CFDictionary *a1, const void **a2, uint64_t a3)
{
  const __CFDictionary *v4;
  uint64_t v5;
  float result;

  v4 = applesauce::CF::details::at_key<__CFString const*>(a1, a2);
  if (!v4)
    return *(float *)a3;
  v5 = applesauce::CF::convert_as<float,0>(v4);
  result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0)
    return *(float *)a3;
  return result;
}

BOOL applesauce::CF::details::has_key<char const(&)[20]>(const __CFDictionary *a1, char *a2)
{
  int v3;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  v3 = CFDictionaryContainsKey(a1, key);
  if (key)
    CFRelease(key);
  return v3 != 0;
}

void sub_1B61A3AB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  _Unwind_Resume(a1);
}

float applesauce::CF::details::find_at_key<float,char const(&)[20]>(const __CFDictionary *a1, char *a2)
{
  const __CFNumber *v2;
  std::runtime_error *exception;

  v2 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[20]>(a1, a2);
  if (!v2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  return applesauce::CF::convert_to<float,0>(v2);
}

void sub_1B61A3B10(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const void *applesauce::CF::details::at_key<char const(&)[19]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B61A3B84(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B61A3B68);
}

IR::FixedIntegerDelay *IR::FixedIntegerDelay::FixedIntegerDelay(IR::FixedIntegerDelay *this, const IR::FixedIntegerDelay *a2)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)this + 1, *((const void **)a2 + 1), *((_QWORD *)a2 + 2), (uint64_t)(*((_QWORD *)a2 + 2) - *((_QWORD *)a2 + 1)) >> 2);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)this + 4, *((const void **)a2 + 4), *((_QWORD *)a2 + 5), (uint64_t)(*((_QWORD *)a2 + 5) - *((_QWORD *)a2 + 4)) >> 2);
  return this;
}

void sub_1B61A3C20(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IR::FixedIntegerDelay>>(unint64_t a1)
{
  if (a1 >= 0x492492492492493)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(56 * a1);
}

uint64_t *std::vector<IR::FixedIntegerDelay>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    v5 = 0;
    do
    {
      v6 = v4 + v5;
      v7 = v2 + v5;
      *(_DWORD *)(v6 - 56) = *(_DWORD *)(v2 + v5 - 56);
      *(_QWORD *)(v6 - 40) = 0;
      *(_QWORD *)(v6 - 32) = 0;
      *(_QWORD *)(v6 - 48) = 0;
      *(_OWORD *)(v6 - 48) = *(_OWORD *)(v2 + v5 - 48);
      *(_QWORD *)(v6 - 32) = *(_QWORD *)(v2 + v5 - 32);
      *(_QWORD *)(v7 - 48) = 0;
      *(_QWORD *)(v7 - 40) = 0;
      *(_QWORD *)(v7 - 32) = 0;
      *(_QWORD *)(v6 - 24) = 0;
      *(_QWORD *)(v6 - 16) = 0;
      *(_QWORD *)(v6 - 8) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(_QWORD *)(v6 - 8) = *(_QWORD *)(v2 + v5 - 8);
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v5 -= 56;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  v8 = *result;
  *result = v4;
  a2[1] = v8;
  v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<IR::FixedIntegerDelay>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 56;
    std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>((_QWORD *)(i - 56));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  char v6;

  while (1)
  {
    v5 = a1;
    v6 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a1);
    if ((caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock(a2) & 1) != 0)
      break;
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v5);
    sched_yield();
    v5 = a2;
    v6 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a2);
    if ((caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock(a1) & 1) != 0)
      break;
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v5);
    sched_yield();
  }
  v5 = 0;
  v6 = 0;
  return std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v5);
}

void sub_1B61A3E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t IR::IRProcessor::IRProcessor(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E69E7F58;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(a1 + 20));
  IR::getPresetDataAttributes();
  *(_OWORD *)(a1 + 216) = 0u;
  *(_BYTE *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_BYTE *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)(a1 + 360));
  *(_DWORD *)(a1 + 396) = 0;
  *(_QWORD *)(a1 + 400) = 0x3F800000453B8000;
  *(_BYTE *)(a1 + 408) = 1;
  *(_DWORD *)(a1 + 412) = 1;
  *(_WORD *)(a1 + 416) = 1;
  *(_DWORD *)(a1 + 420) = 0;
  *(_QWORD *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 436) = -65536;
  *(_BYTE *)(a1 + 440) = 0;
  return a1;
}

void sub_1B61A3F18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _QWORD *v2;
  IR::IRDataAttributes *v3;
  uint64_t v4;
  void *v6;
  void *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  v6 = (void *)v2[42];
  if (v6)
  {
    v2[43] = v6;
    operator delete(v6);
  }
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  v7 = (void *)v2[33];
  if (v7)
  {
    v2[34] = v7;
    operator delete(v7);
  }
  std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<IR::DelayLine>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  v8 = v2[25];
  v2[25] = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v4);
  IR::IRDataAttributes::~IRDataAttributes(v3);
  _Unwind_Resume(a1);
}

uint64_t *std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = a1[1];
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(*a1);
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v2);
  return a1;
}

void FeedbackDelayNetwork<float>::SetDelayTime(uint64_t a1, unsigned int a2, float a3, float a4, double a5)
{
  long double v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  uint64_t v15;
  float v16;
  uint64_t v17;
  uint64_t j;
  int v19;
  uint64_t Prime;

  v10 = pow((float)(a4 / a3), 0.0666666667);
  v11 = a3;
  LODWORD(v12) = vcvtmd_u64_f64(a5 * v11 + 0.5);
  FeedbackDelayNetwork<float>::DelayLine::SetDelaySamples(a1 + 112, v12, a5);
  LODWORD(v13) = vcvtmd_u64_f64(a5 * a4 + 0.5);
  FeedbackDelayNetwork<float>::DelayLine::SetDelaySamples(a1 + 1192, v13, a5);
  srandom(a2);
  for (i = 0; i != 1008; i += 72)
  {
    v11 = v10 * v11;
    v15 = random();
    v16 = v11 * pow(v10, ((double)v15 / 2147483650.0 + -0.5) * 0.8);
    LODWORD(v17) = vcvtmd_u64_f64(a5 * v16 + 0.5);
    FeedbackDelayNetwork<float>::DelayLine::SetDelaySamples(a1 + 184 + i, v17, a5);
  }
  for (j = 0; j != 1080; j += 72)
  {
    v19 = *(_DWORD *)(a1 + j + 236);
    if (v19 == *(_DWORD *)(a1 + j + 164))
    {
      Prime = NextPrime((v19 + 1));
      FeedbackDelayNetwork<float>::DelayLine::SetDelaySamples(a1 + j + 184, Prime, a5);
    }
  }
}

float FeedbackDelayNetwork<float>::SetDecayTime(uint64_t a1, float a2, float a3)
{
  uint64_t v4;
  double v5;
  double v6;
  float v7;
  uint64_t v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float result;

  v4 = 0;
  if (a3 > a2)
    a3 = a2;
  v5 = a2;
  *(double *)(a1 + 8) = a2;
  *(double *)(a1 + 16) = a3;
  v6 = 1.0 - (float)(a2 / a3) * (float)(a2 / a3);
  v7 = 0.0;
  do
  {
    v8 = a1 + v4;
    v9 = *(double *)(a1 + v4 + 168) * -3.0 / v5;
    v10 = fmax(__exp10(v9), 0.0001);
    v11 = v6 * (v9 * 0.575646273);
    if (v11 > 0.99)
      v11 = 0.99;
    v12 = v10 * (1.0 - v11);
    v13 = v12 * 0.25;
    *(float *)&v12 = v12;
    *(_DWORD *)(v8 + 176) = LODWORD(v12);
    *(float *)&v12 = v11;
    v14 = v13;
    *(_DWORD *)(v8 + 136) = LODWORD(v12);
    *(float *)(v8 + 140) = v14;
    v7 = v7 + v14;
    v4 += 72;
  }
  while (v4 != 1152);
  *(float *)(a1 + 28) = 1.0 / v7;
  v15 = *(double *)(a1 + 16) / *(double *)(a1 + 8);
  v16 = (1.0 - v15) / (v15 + 1.0);
  v17 = 1.0 / (1.0 - v16);
  *(float *)(a1 + 36) = (float)(1.0 / v7) * *(float *)(a1 + 24);
  *(float *)(a1 + 40) = v17;
  result = -(float)(v16 * v17);
  *(float *)(a1 + 44) = result;
  return result;
}

double FeedbackDelayNetwork<float>::Reset(_OWORD *a1)
{
  uint64_t i;
  char *v3;
  uint64_t v4;
  double result;

  for (i = 0; i != 1152; i += 72)
  {
    v3 = (char *)a1 + i;
    v4 = *(unsigned int *)((char *)a1 + i + 148);
    if ((_DWORD)v4)
      bzero(*((void **)v3 + 14), 4 * v4);
    *(_QWORD *)(v3 + 156) = *((_DWORD *)v3 + 38) & -*((_DWORD *)v3 + 41);
    *((_DWORD *)v3 + 36) = 0;
  }
  result = 0.0;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  return result;
}

uint64_t std::scoped_lock<caulk::pooled_semaphore_mutex,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100](uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  caulk::pooled_semaphore_mutex::_unlock(*(caulk::pooled_semaphore_mutex **)a1);
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v2);
  return a1;
}

double FeedbackDelayNetwork<float>::DelayLine::SetDelaySamples(uint64_t a1, uint64_t a2, double a3)
{
  int Prime;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  char *v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  double result;

  Prime = NextPrime(a2);
  *(_DWORD *)(a1 + 52) = Prime;
  v6 = (1 << -(char)__clz(Prime - 1));
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v6 - 1;
  std::vector<float>::resize(a1, v6);
  v8 = *(char **)a1;
  v9 = *(char **)(a1 + 8);
  v10 = (uint64_t)&v9[-*(_QWORD *)a1] >> 2;
  if (v10 >= (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 2)
    goto LABEL_11;
  if (v9 == v8)
  {
    v15 = 0;
    v13 = 4 * v10;
    goto LABEL_8;
  }
  v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(a1 + 16, (uint64_t)&v9[-*(_QWORD *)a1] >> 2);
  v12 = *(char **)a1;
  v8 = *(char **)(a1 + 8);
  v13 = (uint64_t)&v11[4 * v10];
  v15 = &v11[4 * v14];
  if (v8 == *(char **)a1)
  {
LABEL_8:
    v16 = v13;
    goto LABEL_9;
  }
  v16 = v13;
  do
  {
    v17 = *((_DWORD *)v8 - 1);
    v8 -= 4;
    *(_DWORD *)(v16 - 4) = v17;
    v16 -= 4;
  }
  while (v8 != v12);
  v8 = v12;
LABEL_9:
  *(_QWORD *)a1 = v16;
  *(_QWORD *)(a1 + 8) = v13;
  *(_QWORD *)(a1 + 16) = v15;
  if (v8)
    operator delete(v8);
LABEL_11:
  v18 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v18)
    bzero(*(void **)a1, 4 * v18);
  LODWORD(v7) = *(_DWORD *)(a1 + 52);
  result = (double)v7 / a3;
  *(double *)(a1 + 56) = result;
  return result;
}

void sub_1B61A4414(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B61A43E0);
}

uint64_t caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock(uint64_t a1)
{
  pthread_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t result;

  v2 = pthread_self();
  v3 = (unint64_t)v2;
  v4 = atomic_load((unint64_t *)a1);
  if (v2)
  {
    if (v4)
      v5 = v2 == (pthread_t)v4;
    else
      v5 = 0;
    if (!v5)
      goto LABEL_9;
LABEL_7:
    ++*(_DWORD *)(a1 + 8);
    return 1;
  }
  if (!v4)
    goto LABEL_7;
LABEL_9:
  result = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(a1 + 12));
  if ((_DWORD)result)
  {
    atomic_store(v3, (unint64_t *)a1);
    result = 1;
    *(_DWORD *)(a1 + 8) = 1;
  }
  return result;
}

void std::__function::__func<AUSpatialMixerV2::PropertyChanged(unsigned int)::$_0,std::allocator<AUSpatialMixerV2::PropertyChanged(unsigned int)::$_0>,void ()(BOOL,BOOL)>::~__func()
{
  JUMPOUT(0x1BCC95CECLL);
}

_QWORD *std::__function::__func<AUSpatialMixerV2::PropertyChanged(unsigned int)::$_0,std::allocator<AUSpatialMixerV2::PropertyChanged(unsigned int)::$_0>,void ()(BOOL,BOOL)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E69CA710;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AUSpatialMixerV2::PropertyChanged(unsigned int)::$_0,std::allocator<AUSpatialMixerV2::PropertyChanged(unsigned int)::$_0>,void ()(BOOL,BOOL)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E69CA710;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<AUSpatialMixerV2::PropertyChanged(unsigned int)::$_0,std::allocator<AUSpatialMixerV2::PropertyChanged(unsigned int)::$_0>,void ()(BOOL,BOOL)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 8) + 592))(*(_QWORD *)(a1 + 8), 3200);
}

ParametricFilters *AUSpatialMixerV2::ResetReverbFilters(uint64_t a1)
{
  ParametricFilters *v2;
  ParametricFilters *result;

  v2 = *(ParametricFilters **)(a1 + 7448);
  if (v2)
    ParametricFilters::reset(v2);
  result = *(ParametricFilters **)(a1 + 7456);
  if (result)
    return (ParametricFilters *)ParametricFilters::reset(result);
  return result;
}

uint64_t AUSpatialMixerV2::UpdateAlignmentDelayLines(BOOL,BOOL)::$_0::operator()(uint64_t a1, int a2)
{
  IR::IRDataLoader *v2;
  IR::IRDataLoader *v3;
  uint64_t ModelingDelay;
  IR::IRDataLoader *v5;
  IR::IRDataLoader *v6;
  unsigned int v7;
  CFTypeRef cf1[8];
  CFTypeRef v10;
  CFTypeRef v11;
  CFTypeRef v12;
  CFTypeRef cf2[8];
  CFTypeRef v14;
  CFTypeRef v15;
  CFTypeRef cf;

  AUSpatialMixerV2::GetAutoModeReverbAttributes((uint64_t)cf1, a1, a2);
  v3 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v2);
  ModelingDelay = IR::IRDataLoader::getModelingDelay(v3, (const IR::IRDataAttributes *)cf1);
  v5 = (IR::IRDataLoader *)cf1[0];
  if (cf1[0] && cf2[0])
  {
    v5 = (IR::IRDataLoader *)CFEqual(cf1[0], cf2[0]);
    if ((_DWORD)v5)
      goto LABEL_9;
  }
  else if (!((uint64_t)cf1[0] | (uint64_t)cf2[0]))
  {
    goto LABEL_9;
  }
  v6 = (IR::IRDataLoader *)IR::IRDataLoader::instance(v5);
  v7 = IR::IRDataLoader::getModelingDelay(v6, (const IR::IRDataAttributes *)cf2);
  if (v7 >= ModelingDelay)
    ModelingDelay = ModelingDelay;
  else
    ModelingDelay = v7;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (v15)
    CFRelease(v15);
  if (v14)
    CFRelease(v14);
  if (cf2[0])
    CFRelease(cf2[0]);
  if (v12)
    CFRelease(v12);
  if (v11)
    CFRelease(v11);
  if (v10)
    CFRelease(v10);
  if (cf1[0])
    CFRelease(cf1[0]);
  return ModelingDelay;
}

void sub_1B61A4658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  IR::IRDataAttributes *v10;

  IR::IRDataAttributes::~IRDataAttributes(v10);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)&a10);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::AlignmentDelay::reset(AUSpatialMixerV2::AlignmentDelay *this)
{
  _QWORD *i;
  _QWORD *v3;
  _QWORD *j;
  _QWORD *v5;
  char *v7;
  char v8;

  v7 = (char *)this + 52;
  v8 = 1;
  caulk::pooled_semaphore_mutex::_lock((AUSpatialMixerV2::AlignmentDelay *)((char *)this + 52));
  atomic_store(0, (unsigned __int8 *)this + 48);
  atomic_store(0, (unsigned __int8 *)this + 49);
  v3 = *(_QWORD **)this;
  for (i = (_QWORD *)*((_QWORD *)this + 1); i != v3; std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(i))
    i -= 7;
  *((_QWORD *)this + 1) = v3;
  v5 = (_QWORD *)*((_QWORD *)this + 3);
  for (j = (_QWORD *)*((_QWORD *)this + 4); j != v5; std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(j))
    j -= 7;
  *((_QWORD *)this + 4) = v5;
  return std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v7);
}

uint64_t std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::unlock(uint64_t a1)
{
  uint64_t result;

  if (*(_BYTE *)(a1 + 8))
  {
    result = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(*(_QWORD *)a1);
    *(_BYTE *)(a1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    return std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>();
  }
  return result;
}

uint64_t *std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t *result, unsigned int a2, int a3)
{
  uint64_t **v4;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unsigned int v8;
  uint64_t *v9;

  v4 = (uint64_t **)result;
  v6 = (uint64_t **)(result + 1);
  v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = (uint64_t **)(result + 1);
LABEL_9:
    v9 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v9 + 7) = a3;
    return std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  CFArrayRef CFArray;
  void *__p[3];

  std::vector<void const*>::vector(__p, a1[1] - *a1);
  v2 = *a1;
  v3 = a1[1];
  if (*a1 != v3)
  {
    v4 = __p[0];
    do
    {
      v5 = *v2++;
      *v4++ = v5;
    }
    while (v2 != v3);
  }
  CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return CFArray;
}

void sub_1B61A4860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,unsigned int &>(_QWORD *a1, CFTypeRef cf, int *a3)
{
  CFNumberRef v6;
  std::runtime_error *exception;
  int valuePtr;

  if (cf)
    CFRetain(cf);
  *a1 = cf;
  valuePtr = *a3;
  v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  a1[1] = v6;
  if (!v6)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61A4918(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

_QWORD *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(_QWORD *a1, CFTypeRef cf, int *a3)
{
  CFNumberRef v6;
  std::runtime_error *exception;
  int valuePtr;

  if (cf)
    CFRetain(cf);
  *a1 = cf;
  valuePtr = *a3;
  v6 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  a1[1] = v6;
  if (!v6)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61A49F4(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::DictionaryRef,0>((const void **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  CFArrayRef CFArray;
  void *__p[3];

  std::vector<void const*>::vector(__p, *(_QWORD *)(a1 + 8));
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(uint64_t **)a1;
    v4 = __p[0];
    v5 = 8 * v2;
    do
    {
      v6 = *v3++;
      *v4++ = v6;
      v5 -= 8;
    }
    while (v5);
  }
  CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return CFArray;
}

void sub_1B61A4AF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  const void **v2;
  const void **v4;
  void *v5;

  v1 = *a1;
  v2 = (const void **)**a1;
  if (v2)
  {
    v4 = (const void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::__destroy_at[abi:ne180100]<applesauce::CF::DictionaryRef,0>(--v4);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::scoped_lock<std::shared_mutex,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~scoped_lock[abi:ne180100](uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  std::__shared_mutex_base::unlock(*(std::__shared_mutex_base **)a1);
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v2);
  return a1;
}

uint64_t AUSpatialMixerV2::ProcessMultipleBufferListsSlicingPrivate(AUSpatialMixerV2 *this, unsigned int *a2, signed int a3, uint64_t a4, AudioBufferList **a5, uint64_t a6, AudioBufferList **a7, const AudioBufferList **a8)
{
  int v10;
  unsigned __int8 v11;
  const AudioBufferList **v12;
  uint64_t v13;
  unsigned int v14;
  char *v16;
  char *v17;
  __int128 v18;
  __int128 v19;
  int v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  unsigned __int8 *v24;
  uint64_t v25;
  AudioBufferList *v26;
  size_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  size_t v33;
  uint64_t v34;
  uint64_t v35;
  AudioBufferList *v36;
  uint64_t v37;
  AudioBufferList *v38;
  size_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int *v51;
  float *v52;
  unint64_t v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  NSObject *v60;
  uint64_t v61;
  float KnownValueForParameter;
  uint64_t v63;
  unint64_t v64;
  float v65;
  unint64_t v66;
  float v67;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  float v71;
  float v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  NSObject *v77;
  _QWORD *v78;
  float v79;
  unint64_t v80;
  unsigned int v81;
  unint64_t v82;
  _QWORD *v84;
  unsigned int v85;
  _QWORD *v86;
  unsigned int v87;
  NSObject *v88;
  AudioBufferList **v89;
  uint64_t v90;
  unsigned __int8 v91;
  NSObject *v92;
  uint64_t v93;
  NSObject *v94;
  uint64_t MetadataFrame;
  NSObject *v96;
  AudioBufferList **v97;
  const char *v98;
  NSObject *v99;
  uint32_t v100;
  unsigned __int8 v101;
  AUSpatialMixerV2InputElement *Element;
  AudioBufferList *v103;
  void *v104;
  int64_t v105;
  AudioBufferList *v106;
  unsigned int mNumberBuffers;
  uint64_t v108;
  unint64_t v109;
  unint64_t v110;
  void **p_mData;
  void *v112;
  unint64_t v113;
  AudioBufferList *v114;
  AudioBufferList **v115;
  NSObject *v116;
  AudioBufferList **v117;
  const char *v118;
  const AudioBufferList *v119;
  UInt32 v120;
  AudioBufferList *v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  uint64_t v127;
  const AudioBufferList *v128;
  uint64_t v129;
  uint64_t v130;
  AudioBuffer *mBuffers;
  __int128 v132;
  int v133;
  NSObject *v134;
  AudioBufferList **v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  int v140;
  int v141;
  int v142;
  int v143;
  int v144;
  double *v145;
  UInt32 v146;
  AudioBufferList *v147;
  NSObject *v148;
  AudioBufferList **v149;
  int v150;
  AudioBufferList *v151;
  UInt32 v152;
  int v153;
  uint64_t v154;
  NSObject *v155;
  uint64_t v156;
  int v157;
  int v158;
  int v159;
  uint64_t v160;
  int v161;
  int v162;
  NSObject *v163;
  uint64_t v164;
  NSObject *v165;
  const char *v166;
  uint32_t v167;
  unsigned __int8 *v168;
  uint64_t v169;
  void *v170;
  AudioBufferList **v171;
  AudioBufferList *v172;
  APAC::Metadata *v173;
  NSObject *v174;
  APAC::Metadata *v175;
  uint64_t v176;
  __n128 v177;
  uint64_t v178;
  int v179;
  APAC *v180;
  NSObject *v181;
  uint64_t v182;
  const std::locale::facet *v183;
  unsigned __int8 v184;
  uint64_t v185;
  _QWORD *v186;
  _BYTE *v187;
  int v188;
  NSObject *v189;
  _QWORD *v190;
  std::string *v191;
  AudioBufferList *v192;
  AudioBufferList *v193;
  NSObject *v194;
  AudioBufferList *v195;
  int v196;
  int v197;
  char *v199;
  AudioBufferList *v200;
  int v201;
  unsigned int mNumberBuffers_low;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  unint64_t v206;
  NSObject *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  unsigned int v212;
  unsigned __int16 *v213;
  unsigned int v214;
  uint64_t v215;
  uint64_t v216;
  unsigned int v217;
  BOOL v218;
  uint64_t *v219;
  NSObject *v220;
  uint64_t v221;
  NSObject *v222;
  uint64_t v223;
  int v224;
  int v225;
  AudioBufferList *v226;
  int v227;
  AudioBufferList *v228;
  uint64_t v229;
  int mData;
  unsigned int v236;
  unsigned int v237;
  NSObject *v239;
  NSObject *v240;
  AudioBufferList *v241;
  int v242;
  AudioBufferList *v243;
  int v244;
  NSObject *v245;
  AudioBufferList *v246;
  uint64_t v247;
  uint64_t v248;
  unsigned __int8 v249;
  const char *v250;
  AudioBufferList *v251;
  int v252;
  int v253;
  AudioBufferList *v254;
  AudioBufferList **v255;
  const char *v256;
  NSObject *v257;
  unint64_t v258;
  uint64_t v259;
  unint64_t v260;
  uint64_t v261;
  NSObject *v262;
  _QWORD *v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  unint64_t v270;
  unint64_t v271;
  unint64_t v272;
  signed int *v273;
  signed int v274;
  unint64_t v275;
  BOOL v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  unint64_t v282;
  unint64_t v283;
  int *v284;
  unint64_t *v285;
  int v286;
  unint64_t v287;
  unint64_t v288;
  int v289;
  uint64_t v290;
  unint64_t v291;
  uint64_t v292;
  unsigned int *v293;
  unint64_t v294;
  uint64_t v295;
  float v296;
  unsigned int *v297;
  int v298;
  NSObject *v299;
  int v300;
  _QWORD *v301;
  NSObject *v302;
  const char *v303;
  _QWORD *v304;
  AUSM::AUFXWrapper **v305;
  AUSM::AUFXWrapper **v306;
  uint64_t v307;
  AudioBufferList **v308;
  int v309;
  NSObject *v310;
  signed int TargetTimeCue;
  __int128 v312;
  int v313;
  uint64_t v314;
  unint64_t v315;
  unsigned int *v316;
  uint64_t v317;
  float v318;
  int v319;
  NSObject *v320;
  int v321;
  _QWORD *v322;
  NSObject *v323;
  const char *v324;
  _QWORD *v325;
  int v326;
  UInt32 v327;
  NSObject *v328;
  int v329;
  unsigned __int8 v330;
  AUSM::AUFXWrapper **v331;
  AUSM::AUFXWrapper **v332;
  uint64_t v333;
  int v334;
  uint64_t v335;
  uint64_t v336;
  _DWORD *v337;
  unsigned __int8 *v338;
  const AudioBufferList *v339;
  uint64_t v340;
  uint64_t v341;
  void **v342;
  uint64_t v343;
  AudioBufferList *v344;
  uint64_t v345;
  uint64_t v346;
  void **v347;
  signed int v348;
  _QWORD *v349;
  AudioBufferList *v350;
  uint64_t v351;
  float v352;
  float v353;
  uint64_t v354;
  uint64_t v355;
  double v356;
  float *v357;
  unsigned int mNumberChannels;
  unsigned int v359;
  float *v361;
  float v362;
  BOOL v365;
  char v366;
  _DWORD *v367;
  _QWORD *v369;
  _QWORD *v370;
  AudioBufferList **v371;
  _QWORD v372[2];
  AudioBufferList *v373;
  uint64_t v374;
  _QWORD *v375;
  _BYTE *v376;
  uint64_t v377;
  uint64_t v378;
  __int128 v379;
  __int128 v380;
  uint64_t *v381;
  __int128 v382;
  unint64_t v383;
  AudioBufferList *v384;
  __int128 v385;
  __int128 v386;
  __int128 v387;
  __int128 v388;
  uint64_t v389;
  _DWORD *v390;
  AudioBufferList **v391;
  signed int v392;
  uint64_t v393;
  uint64_t v394;
  __int128 v395;
  unsigned int *v396;
  uint64_t v397;
  unsigned __int8 *v398;
  const AudioBufferList **v399;
  AudioBufferList **v400;
  AudioBufferList *v401;
  std::string v402;
  std::string v403;
  int v404;
  _QWORD *p_mNumberBuffers;
  __int16 v406;
  const char *v407;
  __int16 v408;
  std::string *v409;
  _BYTE v410[66];
  __int16 v411;
  int v412;
  __int16 v413;
  int v414;
  __int16 v415;
  void *v416;
  char v417;
  _QWORD v418[23];

  v399 = a8;
  v391 = a7;
  v393 = a6;
  v394 = a4;
  v392 = a3;
  v396 = a2;
  v418[20] = *MEMORY[0x1E0C80C00];
  v389 = *((_QWORD *)this + 67);
  v390 = (_DWORD *)((char *)this + 536);
  v400 = (AudioBufferList **)*((_QWORD *)this + 96);
  v10 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(*v400)[3].mBuffers, 0) + 88);
  if (v10 != 1885564203)
  {
    v11 = atomic_load((unsigned __int8 *)v400 + 96);
    if ((v11 & 1) == 0)
    {
      v12 = (const AudioBufferList **)a5;
      goto LABEL_4;
    }
  }
  if (AUSM::Metadata::mTraceLevel >= 1)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v88 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v88, OS_LOG_TYPE_INFO))
    {
      v89 = v400 + 13;
      if (*((char *)v400 + 127) < 0)
        v89 = (AudioBufferList **)*v89;
      v90 = (uint64_t)*v399;
      *(_DWORD *)v410 = 136315906;
      *(_QWORD *)&v410[4] = v89;
      *(_WORD *)&v410[12] = 2080;
      *(_QWORD *)&v410[14] = "ingestEABL";
      *(_WORD *)&v410[22] = 1024;
      *(_DWORD *)&v410[24] = v392;
      *(_WORD *)&v410[28] = 2048;
      *(_QWORD *)&v410[30] = v90;
      _os_log_impl(&dword_1B5ED0000, v88, OS_LOG_TYPE_INFO, "[%s|%s] EABL ingestion: inPullSizeThisTime = %u, timestamp = %f", v410, 0x26u);
    }

  }
  v91 = atomic_load((unsigned __int8 *)v400 + 96);
  if ((v91 & 1) != 0)
  {
    v401 = 0;
    if (*((_BYTE *)this + 540) && *((_DWORD *)this + 134))
    {
      if (!a5)
      {
LABEL_143:
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v93 = 4294900553;
        v96 = (id)getAUSMV2Log(void)::gLog;
        if (!os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
          goto LABEL_494;
        v97 = v400 + 13;
        if (*((char *)v400 + 127) < 0)
          v97 = (AudioBufferList **)*v97;
        *(_DWORD *)v410 = 136315394;
        *(_QWORD *)&v410[4] = v97;
        *(_WORD *)&v410[12] = 2080;
        *(_QWORD *)&v410[14] = "ingestEABL";
        v98 = "[%s|%s] EABL ingestion: Invalid buffer list or invalid number of buffers lists";
        v99 = v96;
        v100 = 22;
        goto LABEL_149;
      }
    }
    else if (!a5)
    {
      *((_DWORD *)this + 134) = 1;
      *((_BYTE *)this + 540) = 1;
      Element = (AUSpatialMixerV2InputElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(*v400)[3].mBuffers, 0);
      v103 = v400[11];
      LODWORD(v103[3].mBuffers[0].mData) = *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(*v400)[3].mBuffers, 0)+ 104);
      if (!*(_QWORD *)&v103[1].mBuffers[0].mNumberChannels)
        __assert_rtn("setupBufferList", "AUSpatialMixerV2Buffers.h", 376, "mEABL.get()");
      ExtendedAudioBufferList_PrepareWithNumberOfBuffers();
      v104 = *(void **)&v103->mBuffers[0].mNumberChannels;
      v105 = (char *)v103->mBuffers[0].mData - (char *)v104;
      if (v105 >= 1)
        bzero(v104, v105);
      v106 = *(AudioBufferList **)&v103[1].mBuffers[0].mNumberChannels;
      if (v106 && v106[2].mBuffers[0].mNumberChannels == 1 && LODWORD(v103[3].mBuffers[0].mData) == 4)
      {
        mNumberBuffers = v106[2].mNumberBuffers;
        v108 = *(_QWORD *)&v103->mBuffers[0].mNumberChannels;
        v109 = ((unint64_t)v103->mBuffers[0].mData - v108) >> 3;
        if (mNumberBuffers < v109)
          LODWORD(v109) = v106[2].mNumberBuffers;
        if ((_DWORD)v109)
        {
          v110 = 0;
          p_mData = &v106[2].mBuffers[0].mData;
          do
          {
            v112 = *p_mData;
            p_mData += 2;
            *(_QWORD *)(v108 + 8 * v110++) = v112;
            v108 = *(_QWORD *)&v103->mBuffers[0].mNumberChannels;
            v113 = ((unint64_t)v103->mBuffers[0].mData - v108) >> 3;
            if (mNumberBuffers >= v113)
              v113 = v113;
            else
              v113 = mNumberBuffers;
          }
          while (v110 < v113);
          v106 = *(AudioBufferList **)&v103[1].mBuffers[0].mNumberChannels;
        }
      }
      v114 = v106 + 2;
      v93 = AUSpatialMixerV2InputElement::PullSharedInput(Element, v106 + 2, v396, (const AudioTimeStamp *)v399, 0, v392);
      if ((_DWORD)v93)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v96 = (id)getAUSMV2Log(void)::gLog;
        if (!os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
          goto LABEL_494;
        v115 = v400 + 13;
        if (*((char *)v400 + 127) < 0)
          v115 = (AudioBufferList **)*v115;
        *(_DWORD *)v410 = 136315650;
        *(_QWORD *)&v410[4] = v115;
        *(_WORD *)&v410[12] = 2080;
        *(_QWORD *)&v410[14] = "ingestEABL";
        *(_WORD *)&v410[22] = 1024;
        *(_DWORD *)&v410[24] = v93;
        v98 = "[%s|%s] EABL ingestion: err #%d while pulling the input";
        v99 = v96;
        v100 = 28;
LABEL_149:
        _os_log_error_impl(&dword_1B5ED0000, v99, OS_LOG_TYPE_ERROR, v98, v410, v100);
LABEL_494:

        goto LABEL_608;
      }
      v401 = v114;
      v394 = 1;
      a5 = &v401;
    }
    if (!*a5 || (_DWORD)v394 != 1)
      goto LABEL_143;
    if (v10 == 1885564203)
      MetadataFrame = AudioBufferList_GetMetadataFrame(*a5);
    else
      MetadataFrame = 0;
    if (AUSM::Metadata::mTraceLevel >= 1)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v116 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v116, OS_LOG_TYPE_INFO))
      {
        v117 = v400 + 13;
        if (*((char *)v400 + 127) < 0)
          v117 = (AudioBufferList **)*v117;
        v118 = "present";
        *(_DWORD *)v410 = 136315650;
        *(_QWORD *)&v410[4] = v117;
        *(_WORD *)&v410[12] = 2080;
        *(_QWORD *)&v410[14] = "ingestEABL";
        if (!MetadataFrame)
          v118 = "nullptr";
        *(_WORD *)&v410[22] = 2080;
        *(_QWORD *)&v410[24] = v118;
        _os_log_impl(&dword_1B5ED0000, v116, OS_LOG_TYPE_INFO, "[%s|%s] EABL ingestion: mdFrame: %s", v410, 0x20u);
      }

    }
    v12 = (const AudioBufferList **)v400[7];
    v119 = *v12;
    v120 = (*v12)->mNumberBuffers;
    if (v120 == (*a5)->mNumberBuffers)
    {
      v121 = v400[7];
      if (v120)
      {
        v122 = 0;
        v123 = 8;
        do
        {
          *(_OWORD *)((char *)&v119->mNumberBuffers + v123) = *(_OWORD *)((char *)&(*a5)->mNumberBuffers + v123);
          ++v122;
          v119 = *v12;
          v123 += 16;
        }
        while (v122 < (*v12)->mNumberBuffers);
        v121 = v400[7];
      }
      v124 = (char *)v400[8] - (char *)v121;
      v394 = v124 >> 3;
      if ((v124 >> 3) < 2)
        goto LABEL_198;
      v125 = 0;
      v126 = (v124 >> 3);
      v127 = 1;
      while (1)
      {
        v128 = v12[v127];
        v129 = v128->mNumberBuffers;
        if (!(_DWORD)v129)
          goto LABEL_197;
        v130 = (16 * v125) | 8;
        mBuffers = v128->mBuffers;
        do
        {
          if (v125 >= (*a5)->mNumberBuffers)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v96 = (id)getAUSMV2Log(void)::gLog;
            if (!os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
              goto LABEL_493;
            v371 = v400 + 13;
            if (*((char *)v400 + 127) < 0)
              v371 = (AudioBufferList **)*v371;
            *(_DWORD *)v410 = 136315394;
            *(_QWORD *)&v410[4] = v371;
            *(_WORD *)&v410[12] = 2080;
            *(_QWORD *)&v410[14] = "ingestEABL";
            v256 = "[%s|%s] EABL ingestion: Mismatch between the configured number of channels and the actual number of c"
                   "hannels given on the call";
LABEL_618:
            _os_log_error_impl(&dword_1B5ED0000, v96, OS_LOG_TYPE_ERROR, v256, v410, 0x16u);
LABEL_493:
            v93 = 4294956428;
            goto LABEL_494;
          }
          *mBuffers++ = *(AudioBuffer *)((char *)&(*a5)->mNumberBuffers + v130);
          ++v125;
          v130 += 16;
          --v129;
        }
        while (v129);
        v125 = v125;
LABEL_197:
        if (++v127 >= v126)
        {
LABEL_198:
          if (!MetadataFrame)
            goto LABEL_4;
          *(_QWORD *)&v385 = AudioMetadataFrame_GetHeader();
          if (!(_QWORD)v385)
            goto LABEL_4;
          LODWORD(v397) = *(_DWORD *)(v385 + 40);
          v133 = AUSM::Metadata::mTraceLevel;
          if (AUSM::Metadata::mTraceLevel >= 1)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v134 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v134, OS_LOG_TYPE_INFO))
            {
              v135 = v400 + 13;
              if (*((char *)v400 + 127) < 0)
                v135 = (AudioBufferList **)*v135;
              v136 = *(_QWORD *)v385;
              v137 = *(_QWORD *)(v385 + 8);
              v138 = *(_DWORD *)(v385 + 16);
              v139 = *(_DWORD *)(v385 + 20);
              v140 = *(unsigned __int8 *)(v385 + 24);
              v141 = *(unsigned __int8 *)(v385 + 25);
              v142 = *(_DWORD *)(v385 + 28);
              v143 = *(_DWORD *)(v385 + 32);
              v144 = *(_DWORD *)(v385 + 40);
              *(_DWORD *)v410 = 136317698;
              *(_QWORD *)&v410[4] = v135;
              *(_WORD *)&v410[12] = 2080;
              *(_QWORD *)&v410[14] = "ingestEABL";
              *(_WORD *)&v410[22] = 2048;
              *(_QWORD *)&v410[24] = v136;
              *(_WORD *)&v410[32] = 2048;
              *(_QWORD *)&v410[34] = v137;
              *(_WORD *)&v410[42] = 1024;
              *(_DWORD *)&v410[44] = v138;
              *(_WORD *)&v410[48] = 1024;
              *(_DWORD *)&v410[50] = v139;
              *(_WORD *)&v410[54] = 1024;
              *(_DWORD *)&v410[56] = v140;
              *(_WORD *)&v410[60] = 1024;
              *(_DWORD *)&v410[62] = v141;
              v411 = 1024;
              v412 = v142;
              v413 = 1024;
              v414 = v143;
              v415 = 1024;
              LODWORD(v416) = v144;
              _os_log_impl(&dword_1B5ED0000, v134, OS_LOG_TYPE_INFO, "[%s|%s] EABL ingestion: mdFrameHeader: frameStartTime = %f, frameDuration = %f, trimmedSamplesFromBeginning = %u, trimmedSamplesFromEnd = %u, type = %u, reserved1 = %u, intermediateCountToFull = %u, headerSize = %u, eventCount = %u", v410, 0x54u);
            }

            v133 = AUSM::Metadata::mTraceLevel;
          }
          v145 = (double *)v385;
          v146 = *(_DWORD *)(v385 + 16);
          v147 = v400[2];
          if (*(&v147[1].mNumberBuffers + 1) > v146)
            v146 = *(&v147[1].mNumberBuffers + 1);
          *(&v147[1].mNumberBuffers + 1) = v146;
          v147[1].mNumberBuffers = v146 + llround(*v145) + llround(v145[7]);
          if (v133 >= 1)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v148 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v148, OS_LOG_TYPE_INFO))
            {
              v149 = v400 + 13;
              if (*((char *)v400 + 127) < 0)
                v149 = (AudioBufferList **)*v149;
              v150 = llround(*(double *)v385);
              v151 = v400[2];
              v152 = v151[1].mNumberBuffers;
              LODWORD(v151) = *(&v151[1].mNumberBuffers + 1);
              v153 = llround(*(double *)(v385 + 56));
              *(_DWORD *)v410 = 136316418;
              *(_QWORD *)&v410[4] = v149;
              *(_WORD *)&v410[12] = 2080;
              *(_QWORD *)&v410[14] = "ingestEABL";
              *(_WORD *)&v410[22] = 1024;
              *(_DWORD *)&v410[24] = v152;
              *(_WORD *)&v410[28] = 1024;
              *(_DWORD *)&v410[30] = v150;
              *(_WORD *)&v410[34] = 1024;
              *(_DWORD *)&v410[36] = (_DWORD)v151;
              *(_WORD *)&v410[40] = 1024;
              *(_DWORD *)&v410[42] = v153;
              _os_log_impl(&dword_1B5ED0000, v148, OS_LOG_TYPE_INFO, "[%s|%s] EABL ingestion: mFirstAudioBufferSampleTime (%d) = mdFrameHeader->frameStartTime (%d) + mPImpl->mSaveTrimmedSamplesFromBeginning (%d) + mdEvent->eventStartTime (%d)", v410, 0x2Eu);
            }

          }
          if (!(_DWORD)v397)
            goto LABEL_4;
          v398 = (unsigned __int8 *)(v385 + 44);
          *(_QWORD *)&v388 = v400 + 13;
          v381 = (uint64_t *)(v400 + 3);
          *(_QWORD *)&v395 = &v410[32];
          v372[1] = &v410[36];
          v154 = *MEMORY[0x1E0DE4F58];
          v377 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 24);
          v378 = v154;
          v375 = v418;
          v376 = &v410[16];
          *(_QWORD *)&v132 = 136316930;
          v382 = v132;
          *(_QWORD *)&v132 = 136315650;
          v386 = v132;
          *(_QWORD *)&v132 = 136315394;
          v380 = v132;
          *(_QWORD *)&v132 = 136315906;
          v379 = v132;
          v374 = MEMORY[0x1E0DE4FB8] + 16;
          while (2)
          {
            if (AUSM::Metadata::mTraceLevel >= 1)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v155 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v155, OS_LOG_TYPE_INFO))
              {
                v156 = v388;
                if (*((char *)v400 + 127) < 0)
                  v156 = *(_QWORD *)v388;
                v157 = *v398;
                v158 = *((_DWORD *)v398 + 1);
                v159 = *((_DWORD *)v398 + 2);
                v160 = *(_QWORD *)(v398 + 12);
                v161 = *((_DWORD *)v398 + 5);
                v162 = *((_DWORD *)v398 + 6);
                *(_DWORD *)v410 = v382;
                *(_QWORD *)&v410[4] = v156;
                *(_WORD *)&v410[12] = 2080;
                *(_QWORD *)&v410[14] = "ingestEABL";
                *(_WORD *)&v410[22] = 1024;
                *(_DWORD *)&v410[24] = v157;
                *(_WORD *)&v410[28] = 1024;
                *(_DWORD *)&v410[30] = v158;
                *(_WORD *)&v410[34] = 1024;
                *(_DWORD *)&v410[36] = v159;
                *(_WORD *)&v410[40] = 2048;
                *(_QWORD *)&v410[42] = v160;
                *(_WORD *)&v410[50] = 1024;
                *(_DWORD *)&v410[52] = v161;
                *(_WORD *)&v410[56] = 1024;
                *(_DWORD *)&v410[58] = v162;
                _os_log_impl(&dword_1B5ED0000, v155, OS_LOG_TYPE_INFO, "[%s|%s] EABL ingestion: mdEvent: eventType = %u, channelIndex = %u, eventSize = %u, eventStartTime = %f, audioFrameCount = %u, version = %u", v410, 0x3Eu);
              }

            }
            if (*v398 != 1)
            {
              if (*v398)
                goto LABEL_246;
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v163 = (id)getAUSMV2Log(void)::gLog;
              if (!os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
                goto LABEL_245;
              v164 = v388;
              if (*((char *)v400 + 127) < 0)
                v164 = *(_QWORD *)v388;
              *(_DWORD *)v410 = v380;
              *(_QWORD *)&v410[4] = v164;
              *(_WORD *)&v410[12] = 2080;
              *(_QWORD *)&v410[14] = "processAudioFormatExtendedEvent";
              v165 = v163;
              v166 = "[%s|%s] AudioFormatExtended metadata ingestion is not functional";
              v167 = 22;
LABEL_401:
              _os_log_error_impl(&dword_1B5ED0000, v165, OS_LOG_TYPE_ERROR, v166, v410, v167);
              goto LABEL_245;
            }
            v168 = v398;
            v169 = *((unsigned int *)v398 + 7);
            v170 = (void *)*((_QWORD *)v398 + 4);
            v171 = v400;
            v172 = v400[2];
            *(_QWORD *)&v172[3].mNumberBuffers = v385;
            *(_QWORD *)&v172[3].mBuffers[0].mNumberChannels = v168;
            v173 = (APAC::Metadata *)v171[3];
            if (!v173)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v174 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
              {
                v248 = v388;
                if (*((char *)v400 + 127) < 0)
                  v248 = *(_QWORD *)v388;
                v249 = atomic_load((unsigned __int8 *)v400 + 96);
                _ZF = (v249 & 1) == 0;
                v250 = "configured";
                if (_ZF)
                  v250 = "not configured";
                *(_DWORD *)v410 = v386;
                *(_QWORD *)&v410[4] = v248;
                *(_WORD *)&v410[12] = 2080;
                *(_QWORD *)&v410[14] = "processAppleProprietaryEvent";
                *(_WORD *)&v410[22] = 2080;
                *(_QWORD *)&v410[24] = v250;
                _os_log_debug_impl(&dword_1B5ED0000, v174, OS_LOG_TYPE_DEBUG, "[%s|%s] APAC flat metadata structure was not ready, late memory allocation in a RT context, to be fixed. ImmersiveRendererData: %s", v410, 0x20u);
              }

              v175 = (APAC::Metadata *)operator new();
              APAC::Metadata::Metadata(v175);
              std::unique_ptr<APAC::Metadata>::reset[abi:ne180100](v381, (uint64_t)v175);
              v173 = (APAC::Metadata *)*v381;
              v171 = v400;
            }
            v176 = APAC::MetadataBitStreamParser::parse((APAC::MetadataBitStreamParser *)v171[1], v170, v169, v173);
            if (v176)
            {
              v178 = v176;
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v163 = (id)getAUSMV2Log(void)::gLog;
              if (!os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
                goto LABEL_245;
              v247 = v388;
              if (*((char *)v400 + 127) < 0)
                v247 = *(_QWORD *)v388;
              *(_DWORD *)v410 = v386;
              *(_QWORD *)&v410[4] = v247;
              *(_WORD *)&v410[12] = 2080;
              *(_QWORD *)&v410[14] = "processAppleProprietaryEvent";
              *(_WORD *)&v410[22] = 2080;
              *(_QWORD *)&v410[24] = v178;
              v165 = v163;
              v166 = "[%s|%s] Metadata parsing error: %s";
              v167 = 32;
              goto LABEL_401;
            }
            v179 = AUSM::Metadata::mTraceLevel;
            if (AUSM::Metadata::mTraceLevel <= 1)
              goto LABEL_290;
            v180 = (APAC *)*v381;
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v181 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v181, OS_LOG_TYPE_INFO))
            {
              v182 = v388;
              if (*((char *)v400 + 127) < 0)
                v182 = *(_QWORD *)v388;
              *(_DWORD *)v410 = v380;
              *(_QWORD *)&v410[4] = v182;
              *(_WORD *)&v410[12] = 2080;
              *(_QWORD *)&v410[14] = "dumpAPE";
              _os_log_impl(&dword_1B5ED0000, v181, OS_LOG_TYPE_INFO, "[%s|%s] APAC Metadata JSON:", v410, 0x16u);
            }

            APAC::MetadataJSON(v180, (const APAC::Metadata *)4);
            std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)v410, &v403);
            memset(&v402, 0, sizeof(v402));
            while (2)
            {
              std::ios_base::getloc((const std::ios_base *)&v410[*(_QWORD *)(*(_QWORD *)v410 - 24)]);
              v183 = std::locale::use_facet((const std::locale *)&v404, MEMORY[0x1E0DE4A90]);
              v184 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v183->__vftable[2].~facet_0)(v183, 10);
              std::locale::~locale((std::locale *)&v404);
              MEMORY[0x1BCC95794](&v404, v410, 1);
              if (!(_BYTE)v404)
                goto LABEL_273;
              if (SHIBYTE(v402.__r_.__value_.__r.__words[2]) < 0)
              {
                *v402.__r_.__value_.__l.__data_ = 0;
                v402.__r_.__value_.__l.__size_ = 0;
              }
              else
              {
                v402.__r_.__value_.__s.__data_[0] = 0;
                *((_BYTE *)&v402.__r_.__value_.__s + 23) = 0;
              }
              v185 = 0;
              while (2)
              {
                v186 = *(_QWORD **)&v410[*(_QWORD *)(*(_QWORD *)v410 - 24) + 40];
                v187 = (_BYTE *)v186[3];
                if (v187 != (_BYTE *)v186[4])
                {
                  v186[3] = v187 + 1;
                  LOBYTE(v186) = *v187;
LABEL_264:
                  if (v184 == v186)
                  {
                    v188 = 0;
                    goto LABEL_272;
                  }
                  std::string::push_back(&v402, (std::string::value_type)v186);
                  ++v185;
                  if (SHIBYTE(v402.__r_.__value_.__r.__words[2]) < 0
                    && v402.__r_.__value_.__l.__size_ == 0x7FFFFFFFFFFFFFF7)
                  {
                    v188 = 4;
                    goto LABEL_272;
                  }
                  continue;
                }
                break;
              }
              LODWORD(v186) = (*(uint64_t (**)(_QWORD *))(*v186 + 80))(v186);
              if ((_DWORD)v186 != -1)
                goto LABEL_264;
              if (v185)
                v188 = 2;
              else
                v188 = 6;
LABEL_272:
              std::ios_base::clear((std::ios_base *)&v410[*(_QWORD *)(*(_QWORD *)v410 - 24)], *(_DWORD *)&v410[*(_QWORD *)(*(_QWORD *)v410 - 24) + 32] | v188);
LABEL_273:
              if ((*(_BYTE *)(v395 + *(_QWORD *)(*(_QWORD *)v410 - 24)) & 5) == 0)
              {
                if (getAUSMV2Log(void)::onceToken != -1)
                  dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                v189 = (id)getAUSMV2Log(void)::gLog;
                if (os_log_type_enabled(v189, OS_LOG_TYPE_INFO))
                {
                  v190 = (_QWORD *)v388;
                  if (*((char *)v400 + 127) < 0)
                    v190 = *(_QWORD **)v388;
                  v191 = &v402;
                  if ((v402.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    v191 = (std::string *)v402.__r_.__value_.__r.__words[0];
                  v404 = v386;
                  p_mNumberBuffers = v190;
                  v406 = 2080;
                  v407 = "dumpAPE";
                  v408 = 2080;
                  v409 = v191;
                  _os_log_impl(&dword_1B5ED0000, v189, OS_LOG_TYPE_INFO, "[%s|%s] %s", (uint8_t *)&v404, 0x20u);
                }

                continue;
              }
              break;
            }
            if (SHIBYTE(v402.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v402.__r_.__value_.__l.__data_);
            *(_QWORD *)v410 = v378;
            *(_QWORD *)&v410[*(_QWORD *)(v378 - 24)] = v377;
            *(_QWORD *)&v410[16] = v374;
            if (v417 < 0)
              operator delete(v416);
            std::streambuf::~streambuf();
            std::istream::~istream();
            MEMORY[0x1BCC95BE4](v375);
            if (SHIBYTE(v403.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v403.__r_.__value_.__l.__data_);
            v179 = AUSM::Metadata::mTraceLevel;
LABEL_290:
            v192 = v400[2];
            v193 = v400[3];
            if (v179 >= 1)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v194 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v194, OS_LOG_TYPE_INFO))
              {
                v195 = v192 + 2;
                if (SHIBYTE(v192[2].mBuffers[0].mData) < 0)
                  v195 = *(AudioBufferList **)&v195->mNumberBuffers;
                *(_DWORD *)v410 = v380;
                *(_QWORD *)&v410[4] = v195;
                *(_WORD *)&v410[12] = 2080;
                *(_QWORD *)&v410[14] = "onAPACMetadataAvailable";
                _os_log_impl(&dword_1B5ED0000, v194, OS_LOG_TYPE_INFO, "[%s|%s] Applying", v410, 0x16u);
              }

            }
            v196 = *((unsigned __int8 *)&v193->mNumberBuffers + 4);
            BYTE4(v192[3].mBuffers[0].mData) = v196;
            v197 = *((unsigned __int8 *)&v193->mNumberBuffers + 5);
            BYTE5(v192[3].mBuffers[0].mData) = v197;
            if (v196 == 1 && v197 == 2)
            {
              if (*((_BYTE *)&v193->mNumberBuffers + 6))
                AUSM::Metadata::PImpl::ParseSceneComponentStaticData((uint64_t)v192, (unsigned __int8 *)v193[1161].mBuffers, v177);
              *(_QWORD *)&v387 = BYTE4(v193[8612].mBuffers[0].mData);
              if ((_QWORD)v387)
              {
                v229 = 0;
                v384 = v192 + 2;
                _X25 = v193 + 8613;
                do
                {
                  LODWORD(v192[3].mBuffers[0].mData) = v229;
                  __asm { PRFM            #0, [X25,#0x4C30] }
                  if (LOBYTE(_X25->mNumberBuffers) == 1)
                  {
                    AUSM::Metadata::PImpl::ParseDynamicObjectMetadata((uint64_t)v192, (unsigned __int8 *)&_X25[2].mBuffers[0].mData + 4, v177);
                    mData = (int)v192[3].mBuffers[0].mData;
                  }
                  else
                  {
                    mData = v229;
                  }
                  _X9 = _X25[1128].mBuffers;
                  v236 = mData + 1;
                  v237 = llround(**(double **)&v192[3].mNumberBuffers)
                       - v192[1].mNumberBuffers
                       + llround(*(double *)(*(_QWORD *)&v192[3].mBuffers[0].mNumberChannels + 12));
                  __asm { PRFM            #0, [X9] }
                  if (AUSM::Metadata::PImpl::setParameter((AUSM::Metadata::PImpl *)v192, 0x16u, mData + 1, v237, -*(float *)&_X25[315].mBuffers[0].mData, 0))
                  {
                    if (getAUSMV2Log(void)::onceToken != -1)
                      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                    v239 = (id)getAUSMV2Log(void)::gLog;
                    if (os_log_type_enabled(v239, OS_LOG_TYPE_DEBUG))
                    {
                      v241 = v384;
                      if (SHIBYTE(v192[2].mBuffers[0].mData) < 0)
                        v241 = *(AudioBufferList **)&v384->mNumberBuffers;
                      v242 = (int)v192[3].mBuffers[0].mData;
                      *(_DWORD *)v410 = v379;
                      *(_QWORD *)&v410[4] = v241;
                      *(_WORD *)&v410[12] = 2080;
                      *(_QWORD *)&v410[14] = "ParseProprietaryDynamicMetadata";
                      *(_WORD *)&v410[22] = 1024;
                      *(_DWORD *)&v410[24] = v242;
                      *(_WORD *)&v410[28] = 1024;
                      *(_DWORD *)&v410[30] = v236;
                      _os_log_debug_impl(&dword_1B5ED0000, v239, OS_LOG_TYPE_DEBUG, "[%s|%s] Could not set source yaw on sc #%u, input element #%u", v410, 0x22u);
                    }

                  }
                  if (AUSM::Metadata::PImpl::setParameter((AUSM::Metadata::PImpl *)v192, 0x17u, v236, v237, *((float *)&_X25[315].mBuffers[0].mData + 1), 0))
                  {
                    if (getAUSMV2Log(void)::onceToken != -1)
                      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                    v240 = (id)getAUSMV2Log(void)::gLog;
                    if (os_log_type_enabled(v240, OS_LOG_TYPE_DEBUG))
                    {
                      v243 = v384;
                      if (SHIBYTE(v192[2].mBuffers[0].mData) < 0)
                        v243 = *(AudioBufferList **)&v384->mNumberBuffers;
                      v244 = (int)v192[3].mBuffers[0].mData;
                      *(_DWORD *)v410 = v379;
                      *(_QWORD *)&v410[4] = v243;
                      *(_WORD *)&v410[12] = 2080;
                      *(_QWORD *)&v410[14] = "ParseProprietaryDynamicMetadata";
                      *(_WORD *)&v410[22] = 1024;
                      *(_DWORD *)&v410[24] = v244;
                      *(_WORD *)&v410[28] = 1024;
                      *(_DWORD *)&v410[30] = v236;
                      _os_log_debug_impl(&dword_1B5ED0000, v240, OS_LOG_TYPE_DEBUG, "[%s|%s] Could not set source pitch on sc #%u, input element #%u", v410, 0x22u);
                    }

                  }
                  ++v229;
                  _X25 = (AudioBufferList *)((char *)_X25 + 9752);
                }
                while ((_QWORD)v387 != v229);
              }
            }
            else if (v196 == 1 && v197 == 3)
            {
              v199 = (char *)&v193[60461].mBuffers[0].mData + 1;
              if (BYTE1(v193[60461].mBuffers[0].mData))
              {
                v200 = v193 + 60661;
                v201 = *((unsigned __int8 *)&v193->mNumberBuffers + 6);
                v384 = v193 + 60661;
                if (v201)
                {
                  if (LOBYTE(v193[60462].mBuffers[0].mNumberChannels))
                    AUSM::Metadata::PImpl::ParseGlobalConfig((uint64_t)v192, (uint64_t)v193[60462].mBuffers);
                  mNumberBuffers_low = LOWORD(v193[60462].mNumberBuffers);
                  v200 = v384;
                  if (-1431655765
                     * ((*(_QWORD *)&v200->mBuffers[0].mNumberChannels - *(_QWORD *)&v200->mNumberBuffers) >> 4) < mNumberBuffers_low)
                    mNumberBuffers_low = -1431655765
                                       * ((*(_QWORD *)&v384->mBuffers[0].mNumberChannels
                                         - *(_QWORD *)&v384->mNumberBuffers) >> 4);
                  if (mNumberBuffers_low)
                  {
                    v203 = 0;
                    v204 = 48 * mNumberBuffers_low;
                    do
                    {
                      AUSM::Metadata::PImpl::ParseGroupConfig((uint64_t)v192, (unsigned __int16 *)(*(_QWORD *)&v384->mNumberBuffers + v203));
                      v203 += 48;
                    }
                    while (v204 != v203);
                  }
                }
                v205 = *(unsigned __int16 *)(v199 + 7);
                LODWORD(v206) = *(unsigned __int16 *)(v199 + 7);
                if (0xB81DC085AE2E9061
                   * ((uint64_t)(*(_QWORD *)&v200[1].mBuffers[0].mNumberChannels - *(_QWORD *)&v200[1].mNumberBuffers) >> 3) != v205)
                {
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v207 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v207, OS_LOG_TYPE_ERROR))
                  {
                    v254 = v192 + 2;
                    if (SHIBYTE(v192[2].mBuffers[0].mData) < 0)
                      v254 = *(AudioBufferList **)&v254->mNumberBuffers;
                    *(_DWORD *)v410 = v380;
                    *(_QWORD *)&v410[4] = v254;
                    *(_WORD *)&v410[12] = 2080;
                    *(_QWORD *)&v410[14] = "ParseRendererMetadata";
                    _os_log_error_impl(&dword_1B5ED0000, v207, OS_LOG_TYPE_ERROR, "[%s|%s] Inconsistent sizes in RendererMetadata", v410, 0x16u);
                  }

                  v206 = 0xB81DC085AE2E9061
                       * ((uint64_t)(*(_QWORD *)&v384[1].mBuffers[0].mNumberChannels - *(_QWORD *)&v384[1].mNumberBuffers) >> 3);
                }
                if (v206 >= v205)
                  v206 = v205;
                else
                  v206 = v206;
                v383 = v206;
                if ((_DWORD)v206)
                {
                  v208 = 0;
                  *(_QWORD *)&v387 = (char *)v192 + 104;
                  v373 = v192 + 2;
                  v209 = 16;
                  do
                  {
                    v210 = *(_QWORD *)&v384[1].mNumberBuffers;
                    if (*(_BYTE *)(v210 + 40200 * v208))
                    {
                      v211 = v210 + 40200 * v208;
                      v214 = *(unsigned __int16 *)(v211 + 2);
                      v213 = (unsigned __int16 *)(v211 + 2);
                      v212 = v214;
                      v215 = *(_QWORD *)v387;
                      if (!*(_QWORD *)v387)
                        goto LABEL_335;
                      v216 = v387;
                      do
                      {
                        v217 = *(_DWORD *)(v215 + 32);
                        v218 = v217 >= v212;
                        if (v217 >= v212)
                          v219 = (uint64_t *)v215;
                        else
                          v219 = (uint64_t *)(v215 + 8);
                        if (v218)
                          v216 = v215;
                        v215 = *v219;
                      }
                      while (*v219);
                      if (v216 != (_QWORD)v387 && *(_DWORD *)(v216 + 32) <= v212)
                      {
                        *(_DWORD *)v410 = v212;
                        *(_QWORD *)&v410[8] = v216 + 40;
                        LODWORD(v221) = *(unsigned __int8 *)(v210 + 40200 * v208 + 4);
                        if (v221 >= 0x21)
                        {
                          if (getAUSMV2Log(void)::onceToken != -1)
                            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                          v222 = (id)getAUSMV2Log(void)::gLog;
                          if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
                          {
                            v228 = v373;
                            if (SHIBYTE(v192[2].mBuffers[0].mData) < 0)
                              v228 = *(AudioBufferList **)&v373->mNumberBuffers;
                            v404 = v380;
                            p_mNumberBuffers = &v228->mNumberBuffers;
                            v406 = 2080;
                            v407 = "ParseGroupData";
                            _os_log_error_impl(&dword_1B5ED0000, v222, OS_LOG_TYPE_ERROR, "[%s|%s] Too many blocks", (uint8_t *)&v404, 0x16u);
                          }

                        }
                        if (v221 >= 0x20)
                          v221 = 32;
                        else
                          v221 = v221;
                        if ((_DWORD)v221)
                        {
                          v223 = v210 + v209;
                          do
                          {
                            v224 = *(unsigned __int16 *)(v223 - 8);
                            *(_DWORD *)&v410[16] = v224;
                            if (*(_BYTE *)(v223 - 6))
                              v225 = *(unsigned __int16 *)(v223 - 4);
                            else
                              v225 = *(_DWORD *)(*(_QWORD *)&v192[3].mBuffers[0].mNumberChannels + 20) - v224;
                            *(_DWORD *)&v410[20] = v225;
                            AUSM::Metadata::PImpl::ParseRendererData((AUSM::Metadata::PImpl *)v192, v223, (uint64_t)v410, v177);
                            v223 += 1256;
                            --v221;
                          }
                          while (v221);
                        }
                      }
                      else
                      {
LABEL_335:
                        if (getAUSMV2Log(void)::onceToken != -1)
                          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                        v220 = (id)getAUSMV2Log(void)::gLog;
                        if (os_log_type_enabled(v220, OS_LOG_TYPE_ERROR))
                        {
                          v226 = v373;
                          if (SHIBYTE(v192[2].mBuffers[0].mData) < 0)
                            v226 = *(AudioBufferList **)&v373->mNumberBuffers;
                          v227 = *v213;
                          *(_DWORD *)v410 = v386;
                          *(_QWORD *)&v410[4] = v226;
                          *(_WORD *)&v410[12] = 2080;
                          *(_QWORD *)&v410[14] = "ParseGroupData";
                          *(_WORD *)&v410[22] = 1024;
                          *(_DWORD *)&v410[24] = v227;
                          _os_log_error_impl(&dword_1B5ED0000, v220, OS_LOG_TYPE_ERROR, "[%s|%s] GD: Group %u not found", v410, 0x1Cu);
                        }

                      }
                    }
                    ++v208;
                    v209 += 40200;
                  }
                  while (v208 != v383);
                }
              }
            }
            else
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v245 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v245, OS_LOG_TYPE_ERROR))
              {
                v251 = v192 + 2;
                if (SHIBYTE(v192[2].mBuffers[0].mData) < 0)
                  v251 = *(AudioBufferList **)&v251->mNumberBuffers;
                v252 = BYTE4(v192[3].mBuffers[0].mData);
                v253 = BYTE5(v192[3].mBuffers[0].mData);
                *(_DWORD *)v410 = v379;
                *(_QWORD *)&v410[4] = v251;
                *(_WORD *)&v410[12] = 2080;
                *(_QWORD *)&v410[14] = "onAPACMetadataAvailable";
                *(_WORD *)&v410[22] = 1024;
                *(_DWORD *)&v410[24] = v252;
                *(_WORD *)&v410[28] = 1024;
                *(_DWORD *)&v410[30] = v253;
                _os_log_error_impl(&dword_1B5ED0000, v245, OS_LOG_TYPE_ERROR, "[%s|%s] Unknown metadata version %u.%u", v410, 0x22u);
              }

            }
            if (AUSM::Metadata::mTraceLevel >= 1)
            {
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v163 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v163, OS_LOG_TYPE_INFO))
              {
                v246 = v192 + 2;
                if (SHIBYTE(v192[2].mBuffers[0].mData) < 0)
                  v246 = *(AudioBufferList **)&v246->mNumberBuffers;
                *(_DWORD *)v410 = v380;
                *(_QWORD *)&v410[4] = v246;
                *(_WORD *)&v410[12] = 2080;
                *(_QWORD *)&v410[14] = "onAPACMetadataAvailable";
                _os_log_impl(&dword_1B5ED0000, v163, OS_LOG_TYPE_INFO, "[%s|%s] Applied", v410, 0x16u);
              }
LABEL_245:

            }
LABEL_246:
            v398 += *((unsigned int *)v398 + 2);
            LODWORD(v397) = v397 - 1;
            if ((_DWORD)v397)
              continue;
            break;
          }
LABEL_4:
          v403.__r_.__value_.__r.__words[0] = (std::string::size_type)this + 3544;
          v13 = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 3544);
          *(_QWORD *)&v386 = (char *)this + 4928;
          v403.__r_.__value_.__s.__data_[8] = v13;
          v14 = atomic_load((unsigned int *)this + 1192);
          _ZF = v14 != 2 || v13 == 0;
          if (!_ZF)
          {
            v16 = (char *)*((_QWORD *)this + 48);
            v17 = (char *)*((_QWORD *)this + 49);
            if (v16 != v17)
            {
              v18 = *((_OWORD *)v399 + 1);
              *(_OWORD *)v410 = *(_OWORD *)v399;
              *(_OWORD *)&v410[16] = v18;
              v19 = *((_OWORD *)v399 + 3);
              *(_OWORD *)&v410[32] = *((_OWORD *)v399 + 2);
              *(_OWORD *)&v410[48] = v19;
              if (v391 && v12)
              {
                v20 = v394;
                v398 = (unsigned __int8 *)v394;
                MEMORY[0x1E0C80A78](v13);
                v399 = (const AudioBufferList **)((char *)v372 - v21);
                bzero((char *)v372 - v21, v22);
                if (v20)
                {
                  v24 = 0;
                  do
                  {
                    if (v12[(_QWORD)v24])
                    {
                      MEMORY[0x1E0C80A78](v23);
                      v26 = (AudioBufferList *)((char *)v372 - ((v25 + 23) & 0x1FFFFFFFF0));
                      bzero(v26, v27);
                      v28 = v12[(_QWORD)v24]->mNumberBuffers;
                      v26->mNumberBuffers = v28;
                      if ((_DWORD)v28)
                      {
                        v29 = 0;
                        v30 = 16 * v28;
                        do
                        {
                          v26->mBuffers[v29 / 0x10] = v12[(_QWORD)v24]->mBuffers[v29 / 0x10];
                          v29 += 16;
                        }
                        while (v30 != v29);
                      }
                    }
                    else
                    {
                      v26 = 0;
                    }
                    v399[(_QWORD)v24++] = v26;
                  }
                  while (v24 != v398);
                }
                v31 = v393;
                v397 = v393;
                MEMORY[0x1E0C80A78](v23);
                v400 = (AudioBufferList **)((char *)v372 - v32);
                bzero((char *)v372 - v32, v33);
                if (v31)
                {
                  v35 = 0;
                  do
                  {
                    v36 = v391[v35];
                    if (v36)
                    {
                      MEMORY[0x1E0C80A78](v34);
                      v38 = (AudioBufferList *)((char *)v372 - ((v37 + 23) & 0x1FFFFFFFF0));
                      bzero(v38, v39);
                      v40 = v36->mNumberBuffers;
                      v38->mNumberBuffers = v40;
                      if ((_DWORD)v40)
                      {
                        v41 = 0;
                        v42 = 16 * v40;
                        do
                        {
                          v38->mBuffers[v41 / 0x10] = v36->mBuffers[v41 / 0x10];
                          v41 += 16;
                        }
                        while (v42 != v41);
                      }
                    }
                    else
                    {
                      v38 = 0;
                    }
                    v400[v35++] = v38;
                  }
                  while (v35 != v397);
                }
                v43 = 0;
                v44 = v16;
                do
                {
                  switch(*((_DWORD *)v44 + 3))
                  {
                    case 1:
                      v43 += 3;
                      break;
                    case 2:
                      v43 += 4;
                      break;
                    case 3:
                      v43 += 2;
                      break;
                    case 4:
                      v45 = v43 + 2;
                      if (*((_DWORD *)v44 + 2) <= 2u)
                      {
                        v46 = *((_DWORD *)v44 + 5);
                        if (v46 >= 0x81)
                          v45 = v43 + ((v46 - 1) >> 7) - 1 + 3;
                      }
                      v43 = v45 + 1;
                      break;
                    default:
                      ++v43;
                      break;
                  }
                  v44 += 32;
                }
                while (v44 != v17);
                v47 = AUSM::Metadata::prepareParameterTracks(*((AUSM::Metadata **)this + 96), (v17 - v16) >> 5, v43);
                v50 = v49;
                v52 = (float *)*((_QWORD *)this + 48);
                v51 = (unsigned int *)*((_QWORD *)this + 49);
                if (v52 != (float *)v51)
                {
                  *(_QWORD *)&v387 = (char *)this + 3592;
                  *((_QWORD *)&v48 + 1) = 0;
                  v395 = xmmword_1B66A0960;
                  v385 = 0x8200302uLL;
                  v388 = 0x8200202uLL;
                  while (1)
                  {
                    v53 = *(_QWORD *)(v47 + 32);
                    if (v53 >= *(_QWORD *)(v47 + 40))
                      break;
                    v54 = *(_QWORD *)v52;
                    v55 = *((_DWORD *)v52 + 2);
                    v56 = *(_QWORD *)(v47 + 24);
                    v57 = v56 + 32 * v53;
                    v58 = v56;
                    if (v53)
                    {
                      v59 = 32 * v53;
                      v58 = *(_QWORD *)(v47 + 24);
                      do
                      {
                        if (*(_DWORD *)v58 == (_DWORD)v54 && *(_QWORD *)(v58 + 4) == __PAIR64__(v55, HIDWORD(v54)))
                          goto LABEL_49;
                        v58 += 32;
                        v59 -= 32;
                      }
                      while (v59);
                      v58 = v56 + 32 * v53;
                    }
LABEL_49:
                    if (v53 == (v58 - v56) >> 5)
                    {
                      *(_QWORD *)v57 = v54;
                      *(_DWORD *)(v57 + 8) = v55;
                      *(_OWORD *)(v57 + 16) = v395;
                      ++*(_QWORD *)(v47 + 32);
                      LODWORD(v402.__r_.__value_.__l.__data_) = 0;
                      if (!(*(unsigned int (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, _QWORD, std::string *))(*(_QWORD *)this + 144))(this, *((unsigned int *)v52 + 2), *(unsigned int *)v52, *((unsigned int *)v52 + 1), &v402))
                      {
                        switch(*((_DWORD *)v52 + 3))
                        {
                          case 1:
                          case 2:
                          case 4:
                            if (((_DWORD)v52[4] & 0x80000000) != 0)
                              goto LABEL_62;
                            goto LABEL_93;
                          case 3:
                            if (*((_DWORD *)v52 + 5) + *((_DWORD *)v52 + 4) < 0)
                              goto LABEL_62;
                            goto LABEL_93;
                          default:
                            if (getAUSMV2Log(void)::onceToken != -1)
                              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                            v77 = (id)getAUSMV2Log(void)::gLog;
                            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
                            {
                              v86 = (_QWORD *)v387;
                              if (*((char *)this + 3615) < 0)
                                v86 = *(_QWORD **)v387;
                              v87 = *((_DWORD *)v52 + 3);
                              v404 = v385;
                              p_mNumberBuffers = v86;
                              v406 = 2080;
                              v407 = "ProcessMultipleBufferListsSlicingPrivate";
                              v408 = 1024;
                              LODWORD(v409) = v87;
                              _os_log_debug_impl(&dword_1B5ED0000, v77, OS_LOG_TYPE_DEBUG, "[%s|%s] Parameter event type unknown (%u)", (uint8_t *)&v404, 0x1Cu);
                            }

LABEL_93:
                            if (AUSM::ParameterControlPointContainer::insertUnique((_QWORD *)v50, v58, (unint64_t)LODWORD(v402.__r_.__value_.__l.__data_) << 32))
                            {
                              goto LABEL_62;
                            }
                            goto LABEL_59;
                        }
                      }
                      if (getAUSMV2Log(void)::onceToken != -1)
                        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                      v60 = (id)getAUSMV2Log(void)::gLog;
                      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
                      {
                        v78 = (_QWORD *)v387;
                        if (*((char *)this + 3615) < 0)
                          v78 = *(_QWORD **)v387;
                        v404 = v388;
                        p_mNumberBuffers = v78;
                        v406 = 2080;
                        v407 = "ProcessMultipleBufferListsSlicingPrivate";
                        _os_log_debug_impl(&dword_1B5ED0000, v60, OS_LOG_TYPE_DEBUG, "[%s|%s] Can't fetch the current parameter value", (uint8_t *)&v404, 0x16u);
                      }
LABEL_58:

                      goto LABEL_59;
                    }
                    if (v56)
                    {
LABEL_62:
                      switch(*((_DWORD *)v52 + 3))
                      {
                        case 1:
                          v61 = *((unsigned int *)v52 + 4);
                          KnownValueForParameter = AUSM::ParameterControlPointContainer::lastKnownValueForParameter((uint64_t *)v50, v58);
                          v63 = *((unsigned int *)v52 + 5);
                          if (!AUSM::ParameterControlPointContainer::insertUnique((_QWORD *)v50, v58, v61 | ((unint64_t)LODWORD(KnownValueForParameter) << 32)))break;
                          v64 = v61 | (v63 << 32);
                          goto LABEL_109;
                        case 2:
                          v72 = AUSM::ParameterControlPointContainer::lastKnownValueForParameter((uint64_t *)v50, v58);
                          v73 = *((unsigned int *)v52 + 4);
                          if (!AUSM::ParameterControlPointContainer::insertUnique((_QWORD *)v50, v58, v73 | ((unint64_t)LODWORD(v72) << 32)))break;
                          v74 = *((unsigned int *)v52 + 7);
                          v75 = *((_DWORD *)v52 + 5);
                          if (!AUSM::ParameterControlPointContainer::insertUnique((_QWORD *)v50, v58, v73 | ((unint64_t)*((unsigned int *)v52 + 6) << 32)))break;
                          v64 = (v75 + v73) | (unint64_t)(v74 << 32);
                          goto LABEL_109;
                        case 3:
                          v64 = (*((_DWORD *)v52 + 5) + *((_DWORD *)v52 + 4)) | ((unint64_t)*((unsigned int *)v52 + 7) << 32);
                          goto LABEL_109;
                        case 4:
                          v65 = AUSM::ParameterControlPointContainer::lastKnownValueForParameter((uint64_t *)v50, v58);
                          v66 = *((unsigned int *)v52 + 4);
                          if (!AUSM::ParameterControlPointContainer::insertUnique((_QWORD *)v50, v58, v66 | ((unint64_t)LODWORD(v65) << 32)))break;
                          v67 = v52[7];
                          v68 = *((_DWORD *)v52 + 5);
                          v69 = LODWORD(v67);
                          if (v68 < 0x81)
                            goto LABEL_108;
                          v70 = *((_DWORD *)v52 + 2);
                          if (v70 >= 2)
                          {
                            if (v70 != 2 || vabds_f32(v67, v65) < 0.1)
                              goto LABEL_108;
                            v71 = v67 - v65;
LABEL_101:
                            v79 = (float)(v71 * 128.0) / (float)v68;
                            v80 = (v68 - 1) >> 7;
                            v384 = (AudioBufferList *)v66;
                            v81 = v66 + 128;
                            v82 = 1;
                            do
                            {
                              _CF = !AUSM::ParameterControlPointContainer::insertUnique((_QWORD *)v50, v58, v81 | ((unint64_t)COERCE_UNSIGNED_INT(v65 + (float)((float)v82* v79)) << 32))|| v82 >= v80;
                              ++v82;
                              v81 += 128;
                            }
                            while (!_CF);
                            v68 = *((_DWORD *)v52 + 5);
                            v69 = *((unsigned int *)v52 + 7);
                            LODWORD(v66) = (_DWORD)v384;
                            goto LABEL_108;
                          }
                          v71 = v67 - v65;
                          if (!v70)
                          {
                            v71 = remainderf(v71, 360.0);
                            if (v71 == -180.0)
                              v71 = 180.0;
                          }
                          if (fabsf(v71) >= 3.0)
                            goto LABEL_101;
LABEL_108:
                          v64 = (v68 + v66) | (unint64_t)(v69 << 32);
LABEL_109:
                          AUSM::ParameterControlPointContainer::insertUnique((_QWORD *)v50, v58, v64);
                          break;
                        default:
                          if (getAUSMV2Log(void)::onceToken != -1)
                            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                          v60 = (id)getAUSMV2Log(void)::gLog;
                          if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
                          {
                            v84 = (_QWORD *)v387;
                            if (*((char *)this + 3615) < 0)
                              v84 = *(_QWORD **)v387;
                            v85 = *((_DWORD *)v52 + 3);
                            v404 = v385;
                            p_mNumberBuffers = v84;
                            v406 = 2080;
                            v407 = "ProcessMultipleBufferListsSlicingPrivate";
                            v408 = 1024;
                            LODWORD(v409) = v85;
                            _os_log_debug_impl(&dword_1B5ED0000, v60, OS_LOG_TYPE_DEBUG, "[%s|%s] Parameter event type unknown (%u)", (uint8_t *)&v404, 0x1Cu);
                          }
                          goto LABEL_58;
                      }
                    }
LABEL_59:
                    v52 += 8;
                    if (v52 == (float *)v51)
                      goto LABEL_423;
                  }
                  if (getAUSMV2Log(void)::onceToken != -1)
                    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                  v60 = (id)getAUSMV2Log(void)::gLog;
                  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
                  {
                    v76 = v47;
                    if (*(char *)(v47 + 23) < 0)
                      v76 = *(_QWORD *)v47;
                    v404 = v388;
                    p_mNumberBuffers = (_QWORD *)v76;
                    v406 = 2080;
                    v407 = "insertUnique";
                    _os_log_debug_impl(&dword_1B5ED0000, v60, OS_LOG_TYPE_DEBUG, "[%s|%s] Can't insert a new track: not enough capacity", (uint8_t *)&v404, 0x16u);
                  }
                  goto LABEL_58;
                }
LABEL_423:
                v258 = *(_QWORD *)(v50 + 32);
                if (v258)
                {
                  v259 = 0;
                  v260 = 0;
                  *(_QWORD *)&v48 = 136315394;
                  v395 = v48;
                  do
                  {
                    v261 = *(_QWORD *)(*(_QWORD *)(v50 + 24) + v259);
                    if (v261)
                    {
                      if (*(_QWORD *)(v261 + 16) > v260)
                        *(_QWORD *)(v261 + 16) = v260;
                      *(_QWORD *)(v261 + 24) = v260;
                    }
                    else
                    {
                      if (getAUSMV2Log(void)::onceToken != -1)
                        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                      v262 = (id)getAUSMV2Log(void)::gLog;
                      if (os_log_type_enabled(v262, OS_LOG_TYPE_DEBUG))
                      {
                        v263 = (_QWORD *)v50;
                        if (*(char *)(v50 + 23) < 0)
                          v263 = *(_QWORD **)v50;
                        v404 = v395;
                        p_mNumberBuffers = v263;
                        v406 = 2080;
                        v407 = "compileTrackInfo";
                        _os_log_debug_impl(&dword_1B5ED0000, v262, OS_LOG_TYPE_DEBUG, "[%s|%s] Unexpected nullptr track", (uint8_t *)&v404, 0x16u);
                      }

                      v258 = *(_QWORD *)(v50 + 32);
                    }
                    ++v260;
                    v259 += 16;
                  }
                  while (v260 < v258);
                }
                v264 = *(_QWORD *)(v47 + 32);
                if (v264)
                {
                  v265 = 0;
                  v266 = *(_QWORD *)(v47 + 24);
                  v267 = *(_QWORD *)(v50 + 24) + 24;
                  while (2)
                  {
                    v268 = v266 + 32 * v265;
                    v269 = *(_QWORD *)(v268 + 16);
                    v270 = *(_QWORD *)(v268 + 24);
                    v271 = v269 + 1;
                    if (v269 + 1 > v270)
                      goto LABEL_447;
                    v272 = 0;
                    v273 = (signed int *)(v267 + 16 * v269);
                    v274 = 0x80000000;
                    while (2)
                    {
                      if (*((_QWORD *)v273 - 1) != v268)
                      {
                        v275 = v272;
                        goto LABEL_446;
                      }
                      v275 = v271;
                      v276 = v274 <= *v273;
                      v274 = *v273;
                      if (v276)
                      {
LABEL_446:
                        ++v271;
                        v273 += 4;
                        v272 = v275;
                        if (v271 > v270)
                          goto LABEL_447;
                        continue;
                      }
                      break;
                    }
                    *(_QWORD *)(v268 + 24) = v272;
LABEL_447:
                    if (++v265 != v264)
                      continue;
                    break;
                  }
                  v277 = 0;
                  v278 = *(_QWORD *)(v47 + 24);
                  v279 = *(_QWORD *)(v50 + 24) + 24;
                  do
                  {
                    v280 = v278 + 32 * v277;
                    v281 = *(_QWORD *)(v280 + 16);
                    v282 = *(_QWORD *)(v280 + 24);
                    v283 = v281 + 1;
                    if (v281 + 1 <= v282)
                    {
                      v284 = (int *)(v279 + 16 * v281);
                      do
                      {
                        if (*((_QWORD *)v284 - 1) == v280)
                        {
                          if (*v284 > 0)
                            break;
                          *(_QWORD *)(v280 + 16) = v283;
                        }
                        ++v283;
                        v284 += 4;
                      }
                      while (v283 <= v282);
                    }
                    ++v277;
                  }
                  while (v277 != v264);
                  v285 = (unint64_t *)(*(_QWORD *)(v47 + 24) + 16);
                  v286 = 0x7FFFFFFF;
                  do
                  {
                    v288 = *v285;
                    v285 += 4;
                    v287 = v288;
                    if (v288 < v258)
                    {
                      v289 = *(_DWORD *)(*(_QWORD *)(v50 + 24) + 16 * v287 + 8);
                      if (v286 >= v289)
                        v286 = v289;
                    }
                    --v264;
                  }
                  while (v264);
                  if (v286 <= 0)
                  {
                    v290 = 0;
                    v291 = 0;
                    LODWORD(v395) = 0;
                    *(_QWORD *)&v388 = (char *)this + 3592;
                    *(_QWORD *)&v48 = 136315650;
                    v387 = v48;
                    while (1)
                    {
                      v292 = *(_QWORD *)(v47 + 24);
                      v293 = (unsigned int *)(v292 + v290);
                      v294 = *(_QWORD *)(v292 + v290 + 16);
                      if (v294 >= *(_QWORD *)(v50 + 32))
                        goto LABEL_471;
                      if (*(int *)(*(_QWORD *)(v50 + 24) + 16 * v294 + 8) > 0)
                        goto LABEL_471;
                      v295 = AUSM::ParameterControlPointContainer::computeIntermediateParameterValueAndAdvance((uint64_t *)v50, 0, v292 + v290);
                      if ((v295 & 0xFF00000000) == 0)
                        goto LABEL_471;
                      v296 = *(float *)&v295;
                      LODWORD(v402.__r_.__value_.__l.__data_) = 0;
                      v297 = (unsigned int *)(v292 + v290);
                      v298 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, _QWORD, std::string *))(*(_QWORD *)this + 144))(this, v297[2], *v297, v297[1], &v402);
                      if (v298)
                        break;
                      if (*(float *)&v402.__r_.__value_.__l.__data_ == v296)
                        goto LABEL_471;
                      v300 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, _QWORD, _QWORD, float, float))(*(_QWORD *)this + 152))(this, v297[2], *v293, v297[1], 0, v296, *(float *)&v402.__r_.__value_.__l.__data_);
                      if (!v300)
                      {
                        LODWORD(v395) = 1;
                        goto LABEL_471;
                      }
                      if (getAUSMV2Log(void)::onceToken != -1)
                        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                      v299 = (id)getAUSMV2Log(void)::gLog;
                      if (os_log_type_enabled(v299, OS_LOG_TYPE_DEBUG))
                      {
                        v301 = (_QWORD *)v388;
                        if (*((char *)this + 3615) < 0)
                          v301 = *(_QWORD **)v388;
                        v404 = v387;
                        p_mNumberBuffers = v301;
                        v406 = 2080;
                        v407 = "ProcessMultipleBufferListsSlicingPrivate";
                        v408 = 1024;
                        LODWORD(v409) = v300;
                        v302 = v299;
                        v303 = "[%s|%s] SetParameter failed, err = %d";
LABEL_485:
                        _os_log_debug_impl(&dword_1B5ED0000, v302, OS_LOG_TYPE_DEBUG, v303, (uint8_t *)&v404, 0x1Cu);
                      }
LABEL_470:

LABEL_471:
                      ++v291;
                      v290 += 32;
                      if (v291 >= *(_QWORD *)(v47 + 32))
                      {
                        if ((v395 & 1) != 0)
                        {
                          v309 = AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(this, v396, 0, v394, v399, v393, v400, (AudioTimeStamp *)v410);
                          if (v309)
                          {
                            if (getAUSMV2Log(void)::onceToken != -1)
                              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                            v310 = (id)getAUSMV2Log(void)::gLog;
                            if (os_log_type_enabled(v310, OS_LOG_TYPE_DEBUG))
                            {
                              if (*((char *)this + 3615) < 0)
                                *(_QWORD *)&v388 = *(_QWORD *)v388;
                              v404 = v387;
                              p_mNumberBuffers = (_QWORD *)v388;
                              v406 = 2080;
                              v407 = "ProcessMultipleBufferListsSlicingPrivate";
                              v408 = 1024;
                              LODWORD(v409) = v309;
                              _os_log_debug_impl(&dword_1B5ED0000, v310, OS_LOG_TYPE_DEBUG, "[%s|%s] Error %d while processing a 0-length time slice", (uint8_t *)&v404, 0x1Cu);
                            }

                          }
                        }
                        goto LABEL_505;
                      }
                    }
                    if (getAUSMV2Log(void)::onceToken != -1)
                      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                    v299 = (id)getAUSMV2Log(void)::gLog;
                    if (!os_log_type_enabled(v299, OS_LOG_TYPE_DEBUG))
                      goto LABEL_470;
                    v304 = (_QWORD *)v388;
                    if (*((char *)this + 3615) < 0)
                      v304 = *(_QWORD **)v388;
                    v404 = v387;
                    p_mNumberBuffers = v304;
                    v406 = 2080;
                    v407 = "ProcessMultipleBufferListsSlicingPrivate";
                    v408 = 1024;
                    LODWORD(v409) = v298;
                    v302 = v299;
                    v303 = "[%s|%s] GetParameter failed, err = %d";
                    goto LABEL_485;
                  }
                }
LABEL_505:
                TargetTimeCue = AUSM::ParameterTrackContainer::findTargetTimeCue(v47, *(_QWORD *)(v50 + 24));
                LODWORD(v395) = 0;
                if (TargetTimeCue >= v392)
                  v313 = v392;
                else
                  v313 = TargetTimeCue;
                *(_QWORD *)&v388 = (char *)this + 3592;
                *(_QWORD *)&v312 = 136315650;
                v387 = v312;
                while (2)
                {
                  if (*(_QWORD *)(v47 + 32))
                  {
                    v314 = 0;
                    v315 = 0;
                    while (1)
                    {
                      v316 = (unsigned int *)(*(_QWORD *)(v47 + 24) + v314);
                      v317 = AUSM::ParameterControlPointContainer::computeIntermediateParameterValueAndAdvance((uint64_t *)v50, v313, (uint64_t)v316);
                      if ((v317 & 0xFF00000000) != 0)
                        break;
LABEL_517:
                      ++v315;
                      v314 += 32;
                      if (v315 >= *(_QWORD *)(v47 + 32))
                        goto LABEL_531;
                    }
                    v318 = *(float *)&v317;
                    LODWORD(v402.__r_.__value_.__l.__data_) = 0;
                    v319 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, _QWORD, std::string *))(*(_QWORD *)this + 144))(this, v316[2], *v316, v316[1], &v402);
                    if (v319)
                    {
                      if (getAUSMV2Log(void)::onceToken != -1)
                        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                      v320 = (id)getAUSMV2Log(void)::gLog;
                      if (!os_log_type_enabled(v320, OS_LOG_TYPE_DEBUG))
                        goto LABEL_516;
                      v325 = (_QWORD *)v388;
                      if (*((char *)this + 3615) < 0)
                        v325 = *(_QWORD **)v388;
                      v404 = v387;
                      p_mNumberBuffers = v325;
                      v406 = 2080;
                      v407 = "ProcessMultipleBufferListsSlicingPrivate";
                      v408 = 1024;
                      LODWORD(v409) = v319;
                      v323 = v320;
                      v324 = "[%s|%s] GetParameter failed, err = %d";
                    }
                    else
                    {
                      if (*(float *)&v402.__r_.__value_.__l.__data_ == v318)
                        goto LABEL_517;
                      v321 = (*(uint64_t (**)(AUSpatialMixerV2 *, _QWORD, _QWORD, _QWORD, _QWORD, float, float))(*(_QWORD *)this + 152))(this, v316[2], *v316, v316[1], 0, v318, *(float *)&v402.__r_.__value_.__l.__data_);
                      if (!v321)
                        goto LABEL_517;
                      if (getAUSMV2Log(void)::onceToken != -1)
                        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                      v320 = (id)getAUSMV2Log(void)::gLog;
                      if (!os_log_type_enabled(v320, OS_LOG_TYPE_DEBUG))
                        goto LABEL_516;
                      v322 = (_QWORD *)v388;
                      if (*((char *)this + 3615) < 0)
                        v322 = *(_QWORD **)v388;
                      v404 = v387;
                      p_mNumberBuffers = v322;
                      v406 = 2080;
                      v407 = "ProcessMultipleBufferListsSlicingPrivate";
                      v408 = 1024;
                      LODWORD(v409) = v321;
                      v323 = v320;
                      v324 = "[%s|%s] SetParameter failed, err = %d";
                    }
                    _os_log_debug_impl(&dword_1B5ED0000, v323, OS_LOG_TYPE_DEBUG, v324, (uint8_t *)&v404, 0x1Cu);
LABEL_516:

                    goto LABEL_517;
                  }
LABEL_531:
                  v326 = v313 - v395;
                  v327 = v326 & ~(v326 >> 31);
                  v93 = AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(this, v396, v327, v394, v399, v393, v400, (AudioTimeStamp *)v410);
                  if ((_DWORD)v93)
                  {
                    if (getAUSMV2Log(void)::onceToken != -1)
                      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
                    v328 = (id)getAUSMV2Log(void)::gLog;
                    if (os_log_type_enabled(v328, OS_LOG_TYPE_DEBUG))
                    {
                      v349 = (_QWORD *)v388;
                      if (*((char *)this + 3615) < 0)
                        v349 = *(_QWORD **)v388;
                      v404 = v387;
                      p_mNumberBuffers = v349;
                      v406 = 2080;
                      v407 = "ProcessMultipleBufferListsSlicingPrivate";
                      v408 = 1024;
                      LODWORD(v409) = v93;
                      _os_log_debug_impl(&dword_1B5ED0000, v328, OS_LOG_TYPE_DEBUG, "[%s|%s] Error %d while processing a time slice", (uint8_t *)&v404, 0x1Cu);
                    }

                    v329 = v395;
                    if (v326 < 1)
                      goto LABEL_566;
LABEL_547:
                    *(double *)v410 = *(double *)v410 + (double)v327;
                    if ((_DWORD)v394)
                    {
                      v338 = 0;
                      do
                      {
                        v339 = v399[(_QWORD)v338];
                        if (v339)
                        {
                          (*(void (**)(int *__return_ptr, AUSpatialMixerV2 *, uint64_t, unsigned __int8 *))(*(_QWORD *)this + 392))(&v404, this, 1, v338);
                          v340 = v339->mNumberBuffers;
                          if ((_DWORD)v340)
                          {
                            v341 = v409 * v327;
                            v342 = &v339->mBuffers[0].mData;
                            do
                            {
                              if (*((_DWORD *)v342 - 2))
                              {
                                *v342 = (char *)*v342 + v341;
                                *((_DWORD *)v342 - 1) -= v341;
                              }
                              v342 += 2;
                              --v340;
                            }
                            while (v340);
                          }
                        }
                        ++v338;
                      }
                      while (v338 != v398);
                    }
                    if ((_DWORD)v393)
                    {
                      v343 = 0;
                      do
                      {
                        v344 = v400[v343];
                        if (v344)
                        {
                          (*(void (**)(int *__return_ptr, AUSpatialMixerV2 *, uint64_t, uint64_t))(*(_QWORD *)this + 392))(&v404, this, 2, v343);
                          v345 = v344->mNumberBuffers;
                          if ((_DWORD)v345)
                          {
                            v346 = v409 * v327;
                            v347 = &v344->mBuffers[0].mData;
                            do
                            {
                              if (*((_DWORD *)v347 - 2))
                              {
                                *v347 = (char *)*v347 + v346;
                                *((_DWORD *)v347 - 1) -= v346;
                              }
                              v347 += 2;
                              --v345;
                            }
                            while (v345);
                          }
                        }
                        ++v343;
                      }
                      while (v343 != v397);
                    }
                    v329 = v313;
                  }
                  else
                  {
                    if (v326 >= 1)
                    {
                      v330 = atomic_load((unsigned __int8 *)v386);
                      if ((v330 & 1) == 0
                        || (v331 = (AUSM::AUFXWrapper **)*((_QWORD *)this + 445),
                            v332 = (AUSM::AUFXWrapper **)*((_QWORD *)this + 446),
                            v331 == v332))
                      {
LABEL_546:
                        v93 = 0;
                      }
                      else
                      {
                        v333 = (uint64_t)*v400;
                        while (1)
                        {
                          v334 = *(_DWORD *)(v333 + 12);
                          AUSM::AUFXWrapper::processInPlace(*v331, v396, v327, (AudioBufferList *)v333);
                          v93 = v335;
                          v333 = (uint64_t)*v400;
                          v336 = (*v400)->mNumberBuffers;
                          if ((_DWORD)v336)
                          {
                            v337 = (_DWORD *)(v333 + 12);
                            do
                            {
                              *v337 = v334;
                              v337 += 4;
                              --v336;
                            }
                            while (v336);
                          }
                          if ((_DWORD)v335)
                            break;
                          if (++v331 == v332)
                            goto LABEL_546;
                        }
                      }
                      goto LABEL_547;
                    }
                    v93 = 0;
                    v329 = v395;
                  }
LABEL_566:
                  v348 = AUSM::ParameterTrackContainer::findTargetTimeCue(v47, *(_QWORD *)(v50 + 24));
                  if (v329 == v392 && v348 > v392)
                  {
                    *((_QWORD *)this + 49) = *((_QWORD *)this + 48);
                    goto LABEL_576;
                  }
                  LODWORD(v395) = v329;
                  if (v348 >= v392)
                    v313 = v392;
                  else
                    v313 = v348;
                  continue;
                }
              }
              if (getAUSMV2Log(void)::onceToken != -1)
                dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
              v257 = (id)getAUSMV2Log(void)::gLog;
              if (os_log_type_enabled(v257, OS_LOG_TYPE_ERROR))
              {
                v370 = (_QWORD *)((char *)this + 3592);
                if (*((char *)this + 3615) < 0)
                  v370 = (_QWORD *)*v370;
                v404 = 136315394;
                p_mNumberBuffers = v370;
                v406 = 2080;
                v407 = "ProcessMultipleBufferListsSlicingPrivate";
                _os_log_error_impl(&dword_1B5ED0000, v257, OS_LOG_TYPE_ERROR, "[%s|%s] Error: null input or output buffer lists", (uint8_t *)&v404, 0x16u);
              }

              v93 = 4294956428;
LABEL_607:
              std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v403);
              goto LABEL_608;
            }
          }
          v93 = AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(this, v396, v392, v394, v12, v393, v391, (AudioTimeStamp *)v399);
          if ((_DWORD)v93)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v94 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
            {
              v369 = (_QWORD *)((char *)this + 3592);
              if (*((char *)this + 3615) < 0)
                v369 = (_QWORD *)*v369;
              *(_DWORD *)v410 = 136315650;
              *(_QWORD *)&v410[4] = v369;
              *(_WORD *)&v410[12] = 2080;
              *(_QWORD *)&v410[14] = "ProcessMultipleBufferListsSlicingPrivate";
              *(_WORD *)&v410[22] = 1024;
              *(_DWORD *)&v410[24] = v93;
              _os_log_debug_impl(&dword_1B5ED0000, v94, OS_LOG_TYPE_DEBUG, "[%s|%s] Error %d while processing multiple buffer lists", v410, 0x1Cu);
            }

          }
          else
          {
            v101 = atomic_load((unsigned __int8 *)v386);
            if ((v101 & 1) != 0)
            {
              v305 = (AUSM::AUFXWrapper **)*((_QWORD *)this + 445);
              v306 = (AUSM::AUFXWrapper **)*((_QWORD *)this + 446);
              while (v305 != v306)
              {
                AUSM::AUFXWrapper::processInPlace(*v305, v396, v392, *v391);
                v93 = v307;
                if ((_DWORD)v307)
                  goto LABEL_576;
                ++v305;
              }
            }
            v93 = 0;
          }
LABEL_576:
          if (!(_DWORD)v393)
            goto LABEL_607;
          if (!*(_BYTE *)(v386 + 2512))
            goto LABEL_607;
          v350 = *v391;
          if (!(*v391)->mNumberBuffers)
            goto LABEL_607;
          v351 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
          v352 = -1.0;
          v353 = -1.0;
          if (!v392)
          {
LABEL_606:
            *(float *)v410 = v353;
            v404 = LODWORD(v352);
            kdebug_trace();
            goto LABEL_607;
          }
          v354 = 0;
          v355 = 0;
          v356 = *(double *)(v351 + 80);
          v357 = (float *)v350->mBuffers[0].mData;
          mNumberChannels = v350->mBuffers[0].mNumberChannels;
          v359 = 1;
          while (2)
          {
            if (fabsf(v357[v359 - 1]) > 0.01 && v353 == -1.0)
              v353 = (double)(int)v355 / v356;
            if (mNumberChannels >= 2)
            {
              v361 = &v357[v359];
              goto LABEL_591;
            }
            v362 = 0.0;
            if (v350->mNumberBuffers >= 2)
            {
              v361 = (float *)(*(_QWORD *)&v350[1].mBuffers[0].mNumberChannels + v354);
LABEL_591:
              v362 = *v361;
            }
            if (fabsf(v362) > 0.01 && v352 == -1.0)
              v352 = (double)(int)v355 / v356;
            v365 = v352 != -1.0 && v353 != -1.0 || v392 - 1 == v355++;
            v354 += 4;
            v359 += mNumberChannels;
            if (v365)
              goto LABEL_606;
            continue;
          }
        }
      }
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v96 = (id)getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
      goto LABEL_493;
    v255 = v400 + 13;
    if (*((char *)v400 + 127) < 0)
      v255 = (AudioBufferList **)*v255;
    *(_DWORD *)v410 = 136315394;
    *(_QWORD *)&v410[4] = v255;
    *(_WORD *)&v410[12] = 2080;
    *(_QWORD *)&v410[14] = "ingestEABL";
    v256 = "[%s|%s] EABL ingestion: Mismatch between the configured number of channels and the actual number of channels "
           "of the first input";
    goto LABEL_618;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v92 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
  {
    v308 = v400 + 13;
    if (*((char *)v400 + 127) < 0)
      v308 = (AudioBufferList **)*v308;
    *(_DWORD *)v410 = 136315394;
    *(_QWORD *)&v410[4] = v308;
    *(_WORD *)&v410[12] = 2080;
    *(_QWORD *)&v410[14] = "ingestEABL";
    _os_log_error_impl(&dword_1B5ED0000, v92, OS_LOG_TYPE_ERROR, "[%s|%s] EABL ingestion: can't process since the ImmersiveRendererData configuration has not been set", v410, 0x16u);
  }

  v93 = 4294900553;
LABEL_608:
  v366 = BYTE4(v389);
  v367 = v390;
  *v390 = v389;
  *((_BYTE *)v367 + 4) = v366;
  return v93;
}

void sub_1B61A7EE0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  __cxa_end_catch();
  if (*(char *)(v1 + 343) < 0)
    operator delete(*(void **)(v1 + 320));
  std::istringstream::~istringstream(v1 + 416);
  if (*(char *)(v1 + 367) < 0)
    operator delete(*(void **)(v1 + 344));
  v3 = *(_QWORD *)(v1 + 208);
  v4 = *(_QWORD *)(v1 + 216);
  *(_DWORD *)v4 = v3;
  *(_BYTE *)(v4 + 4) = BYTE4(v3);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(AUSpatialMixerV2 *this, unsigned int *a2, vDSP_Length a3, unsigned int a4, const AudioBufferList **a5, int a6, AudioBufferList **a7, AudioTimeStamp *a8)
{
  unsigned __int8 v11;
  void *v12;
  NSObject *v13;
  unsigned __int8 v14;
  int v15;
  unsigned __int8 v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t result;
  _QWORD *v20;
  caulk::concurrent::messenger *v21;
  uint64_t v22;
  unsigned __int8 v23;
  int v25;
  AUSM *CurrentHeadPose;
  int v27;
  NSObject *v28;
  _QWORD *v29;
  const char *v30;
  NSObject *v31;
  uint32_t v32;
  unsigned __int8 v33;
  float v34;
  __float2 v35;
  float32x4_t v36;
  int32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x2_t v43;
  float32x4_t v44;
  unsigned __int32 v45;
  float32x2_t v46;
  float32x2_t v47;
  unsigned __int128 *v48;
  unsigned __int128 v49;
  unsigned __int128 v50;
  unsigned __int128 *v51;
  unsigned __int128 v52;
  int32x4_t v53;
  int8x16_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x2_t v58;
  float32x4_t v59;
  unsigned __int32 v60;
  float32x2_t v61;
  float32x2_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x2_t v65;
  float32x2_t v66;
  float32x4_t v67;
  int8x16_t v68;
  float32x2_t v69;
  float v70;
  float v71;
  unsigned __int32 v73;
  float32x2_t v74;
  float32x2_t v75;
  uint64_t v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  _QWORD *v89;
  uint64_t Element;
  unsigned int *v91;
  unint64_t v92;
  uint64_t v93;
  float v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  unint64_t v101;
  unsigned int v102;
  uint64_t v103;
  void **v104;
  void **v105;
  uint64_t v106;
  void **v107;
  void **i;
  unsigned __int8 v109;
  unsigned __int8 v110;
  int v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int *v122;
  const AudioBufferList *v123;
  unsigned __int8 v124;
  char *v125;
  _BOOL4 MustProcessPostProcReverb;
  char *v127;
  unsigned int v128;
  char *v129;
  unsigned int v130;
  unsigned __int8 v131;
  char *v132;
  float v133;
  const float *v134;
  unsigned int v135;
  const float *v136;
  unsigned int v137;
  const float *v138;
  unsigned int v139;
  TorqueEngine *v140;
  uint64_t v141;
  int v142;
  unsigned int v143;
  uint64_t v144;
  unint64_t v145;
  unsigned int v146;
  float **v147;
  uint64_t v148;
  uint64_t v149;
  int v150;
  float *v151;
  float *v152;
  uint64_t v153;
  unint64_t v154;
  unsigned int v155;
  const float **v156;
  float *v157;
  float v158;
  float v159;
  float v160;
  uint64_t v161;
  uint64_t v162;
  unsigned __int8 v163;
  float **v164;
  int v165;
  uint64_t v167;
  uint64_t v168;
  double v169;
  const float **v170;
  int v171;
  int v172;
  unsigned __int8 v173;
  unsigned int *v174;
  unsigned int *v175;
  unsigned int v176;
  void **v177;
  int v178;
  unsigned __int8 v179;
  int v180;
  _DWORD *v181;
  int v182;
  __n128 v183;
  __n128 v184;
  unsigned int v185;
  unsigned int v186;
  int v187;
  float v188;
  uint64_t v189;
  uint64_t v190;
  const float *v191;
  const float *v192;
  uint64_t v193;
  uint64_t v194;
  float *v195;
  unsigned int v196;
  float v197;
  uint64_t v198;
  float v199;
  float v200;
  float v201;
  float v202;
  float v203;
  float v204;
  float v205;
  float v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float v213;
  float v214;
  float v215;
  float v216;
  float v217;
  float v218;
  float v219;
  float v220;
  float v221;
  float v222;
  float v223;
  float v224;
  float v225;
  float v226;
  float v227;
  float v228;
  float v229;
  float v230;
  float v231;
  float v232;
  float v233;
  float v234;
  float v235;
  _DWORD *v236;
  int v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  float *v241;
  unsigned int v242;
  float v243;
  float v244;
  float v245;
  float v246;
  float v247;
  float v248;
  float v249;
  float v250;
  float v251;
  float v252;
  float v253;
  float v254;
  float v255;
  float v256;
  float v257;
  float v258;
  float v259;
  float v260;
  float v261;
  float v262;
  float v263;
  float v264;
  float v265;
  float v266;
  float v267;
  float v268;
  float v269;
  float v270;
  float v271;
  float v272;
  float v273;
  float v274;
  float v275;
  float *v276;
  unint64_t v277;
  const float **v278;
  float v279;
  float v280;
  uint64_t v281;
  uint64_t v282;
  float v283;
  _DWORD *v284;
  int v285;
  int v286;
  int v287;
  const float **v288;
  unsigned int v289;
  unsigned int v290;
  int v291;
  int v292;
  int v293;
  unsigned int v294;
  unsigned int v295;
  unsigned int v296;
  unsigned int v297;
  unsigned int v298;
  unsigned int v299;
  int v300;
  _DWORD *v301;
  uint64_t v302;
  unint64_t v303;
  float **v304;
  unsigned int v305;
  const float **v306;
  const float **v307;
  unint64_t v308;
  int v309;
  int v310;
  int v311;
  _BYTE *v312;
  _BOOL4 v313;
  ParametricFilters *v314;
  unsigned int v315;
  unsigned __int8 v316;
  uint64_t v317;
  _QWORD *SampleDataPtrs;
  unsigned int j;
  _QWORD *v320;
  uint64_t v321;
  uint64_t v322;
  _QWORD *v323;
  unsigned int k;
  _QWORD *v325;
  uint64_t v326;
  uint64_t v327;
  _QWORD *v328;
  unsigned int m;
  _QWORD *v330;
  uint64_t v331;
  int v332;
  uint64_t v333;
  _QWORD *v334;
  unsigned int n;
  _QWORD *v336;
  uint64_t v337;
  uint64_t v338;
  _QWORD *v339;
  unsigned int ii;
  _QWORD *v341;
  uint64_t v342;
  uint64_t v343;
  _QWORD *v344;
  unsigned int jj;
  _QWORD *v346;
  uint64_t v347;
  int v348;
  unsigned int v349;
  unsigned int v350;
  unsigned int v351;
  unsigned int v352;
  caulk::concurrent::messenger *v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  char v357;
  unint64_t kk;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  void **v362;
  void **mm;
  int v364;
  uint64_t v365;
  void **v366;
  void **i1;
  uint64_t v368;
  void **v369;
  void **nn;
  unsigned __int8 v371;
  int v372;
  uint64_t v374;
  float **v375;
  uint64_t v376;
  int v377;
  int v378;
  int v379;
  _QWORD *v380;
  float v381;
  float v382;
  float v383;
  unsigned __int8 v384;
  float v385;
  float v386;
  float v387;
  float v388;
  uint64_t v389;
  uint64_t i2;
  unsigned __int8 v391;
  unsigned int *v392;
  unsigned int v393;
  unsigned int v394;
  uint64_t v395;
  int v396;
  float v397;
  uint64_t v398;
  const float **v399;
  char *v400;
  int v401;
  int v402;
  NSObject *v403;
  int v404;
  int v405;
  _QWORD *v406;
  __int128 *v407;
  IR::SharedIRBuses *v410;
  int v412;
  unint64_t v414;
  int v415;
  int v416;
  int v417;
  int v418;
  int v419;
  float v421;
  float32x4_t __Step;
  _BYTE buf[12];
  _BYTE v424[12];
  double v425;
  _BYTE v426[12];
  double v427;
  _BYTE v428[12];
  double v429;
  __int16 v430;
  double v431;
  __int16 v432;
  double v433;
  __int16 v434;
  int v435;
  uint64_t v436;

  v436 = *MEMORY[0x1E0C80C00];
  v11 = atomic_load((unsigned __int8 *)this + 3668);
  if ((v11 & 1) != 0)
  {
    v12 = (void *)*((_QWORD *)this + 356);
    applesauce::dispatch::v1::queue::get(v12);
    v13 = objc_claimAutoreleasedReturnValue();
    dispatch_sync(v13, &__block_literal_global_155);

  }
  if (a6 != 1)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v18 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v20 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v20 = (_QWORD *)*v20;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v20;
      *(_WORD *)v424 = 2080;
      *(_QWORD *)&v424[2] = "ProcessMultipleBufferListsPrivate";
      *(_WORD *)&v424[10] = 1024;
      LODWORD(v425) = a6;
      _os_log_error_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_ERROR, "[%s|%s] The number of output buffer lists is not 1 (%u)", buf, 0x1Cu);
    }

    return 4294900553;
  }
  v14 = atomic_load((unsigned __int8 *)this + 2865);
  if ((v14 & 1) != 0 && *((_DWORD *)this + 3773) == -1)
  {
    *(_QWORD *)buf = (char *)this + 3336;
    v15 = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 3336);
    buf[8] = v15;
    if (v15 && *((_QWORD *)this + 369))
    {
      v16 = atomic_load((unsigned __int8 *)this + 3746);
      if ((v16 & 1) != 0)
      {
        v17 = *((_QWORD *)this + 368);
        *((_QWORD *)this + 368) = *((_QWORD *)this + 370);
        *((_QWORD *)this + 370) = v17;
        *((_DWORD *)this + 3773) = 0;
      }
      else
      {
        v17 = *((_QWORD *)this + 370);
      }
      *((_QWORD *)this + 370) = *((_QWORD *)this + 369);
      *((_QWORD *)this + 369) = v17;
      atomic_store(0, (unsigned __int8 *)this + 2865);
      v21 = (caulk::concurrent::messenger *)*((_QWORD *)this + 440);
      if (!v21)
        __assert_rtn("ProcessMultipleBufferListsPrivate", "AUSpatialMixerV2.mm", 2940, "mMessenger.get() != nullptr");
      *((_QWORD *)this + 369) = 0;
      __Step.i64[0] = v17;
      v22 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)*MEMORY[0x1E0DDB688] + 16))(*MEMORY[0x1E0DDB688], 40, 8);
      *(_DWORD *)(v22 + 16) = 0;
      __Step.i64[0] = 0;
      *(_QWORD *)(v22 + 24) = v17;
      *(_QWORD *)v22 = &off_1E69CA670;
      *(_QWORD *)(v22 + 8) = 0;
      caulk::concurrent::messenger::enqueue(v21, (caulk::concurrent::message *)v22);
    }
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)buf);
  }
  v407 = (__int128 *)((char *)this + 2376);
  v23 = atomic_load((unsigned __int8 *)this + 5080);
  if ((v23 & 1) != 0)
  {
    if (atomic_load((unsigned int *)this + 1271))
    {
      if (AudioDSP::Core::HeadTracker::HasActiveRMConnection((AUSpatialMixerV2 *)((char *)this + 7408)))
      {
        v25 = *((_DWORD *)this + 1524);
        CurrentHeadPose = (AUSM *)AudioDSP::Core::HeadTracker::GetCurrentHeadPose((AUSpatialMixerV2 *)((char *)this + 7408), (simd_quatf *)&__Step);
        v27 = (int)CurrentHeadPose;
        if ((_DWORD)CurrentHeadPose == 102)
        {
          if ((v25 & 1) == 0)
            goto LABEL_64;
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v28 = (id)getAUSMV2Log(void)::gLog;
          if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            goto LABEL_63;
          v29 = (_QWORD *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v29 = (_QWORD *)*v29;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v29;
          *(_WORD *)v424 = 2080;
          *(_QWORD *)&v424[2] = "ProcessMultipleBufferListsPrivate";
          *(_WORD *)&v424[10] = 1024;
          LODWORD(v425) = 102;
          v30 = "[%s|%s] AUSMTrackedHeadPose: Error %d in getting head-pose.";
          v31 = v28;
          v32 = 28;
          goto LABEL_62;
        }
        v33 = atomic_load((unsigned __int8 *)this + 7443);
        if ((v33 & 1) != 0)
        {
          CurrentHeadPose = (AUSM *)AudioDSP::Core::HeadTracker::GetAppliedFaceToDevicePitchAngleOffset((AUSpatialMixerV2 *)((char *)this + 7408));
          if (fabsf(v34) > 0.00000011921)
          {
            v35 = __sincosf_stret((float)(v34 * 0.017453) * 0.5);
            v36.i32[0] = 0;
            v36.i32[2] = 0;
            v36.i32[1] = LODWORD(v35.__sinval);
            v36.i32[3] = LODWORD(v35.__cosval);
            v37 = (int32x4_t)vnegq_f32(v36);
            v38 = (int8x16_t)vtrn2q_s32((int32x4_t)v36, vtrn1q_s32((int32x4_t)v36, v37));
            v39 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v37, 8uLL), *(float32x2_t *)__Step.f32, 1), (float32x4_t)vextq_s8(v38, v38, 8uLL), __Step.f32[0]);
            v40 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
            v40.i32[0] = v37.i32[1];
            v40.i32[3] = v37.i32[2];
            v41 = vaddq_f32(v39, vmlaq_laneq_f32(vmulq_laneq_f32(v36, __Step, 3), v40, __Step, 2));
            v42 = (int8x16_t)vmulq_f32(v41, v41);
            v43 = vadd_f32(*(float32x2_t *)v42.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL));
            if (vaddv_f32(v43) == 0.0)
            {
              v44 = (float32x4_t)xmmword_1B6629CC0;
            }
            else
            {
              v45 = vadd_f32(v43, (float32x2_t)vdup_lane_s32((int32x2_t)v43, 1)).u32[0];
              v46 = vrsqrte_f32((float32x2_t)v45);
              v47 = vmul_f32(v46, vrsqrts_f32((float32x2_t)v45, vmul_f32(v46, v46)));
              v44 = vmulq_n_f32(v41, vmul_f32(v47, vrsqrts_f32((float32x2_t)v45, vmul_f32(v47, v47))).f32[0]);
            }
            __Step = v44;
          }
        }
        v48 = (unsigned __int128 *)((char *)this + 3712);
        do
          v49 = __ldaxp(v48);
        while (__stlxp(v49, v48));
        v50 = (unsigned __int128)__Step;
        if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(__Step, (float32x4_t)v49))), 0xFuLL))) & 1) != 0)
        {
          do
            __ldaxp(v48);
          while (__stlxp(v50, v48));
          atomic_store(1u, (unsigned __int8 *)this + 7361);
          v51 = (unsigned __int128 *)((char *)this + 3696);
          do
            v52 = __ldaxp(v51);
          while (__stlxp(v52, v51));
          v53 = (int32x4_t)vnegq_f32(__Step);
          v54 = (int8x16_t)vtrn2q_s32((int32x4_t)__Step, vtrn1q_s32((int32x4_t)__Step, v53));
          v55 = (float32x4_t)vrev64q_s32((int32x4_t)__Step);
          v55.i32[0] = v53.i32[1];
          v55.i32[3] = v53.i32[2];
          v56 = vaddq_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)__Step, (int8x16_t)v53, 8uLL), *(float32x2_t *)&v52, 1), (float32x4_t)vextq_s8(v54, v54, 8uLL), *(float *)&v52), vmlaq_laneq_f32(vmulq_laneq_f32(__Step, (float32x4_t)v52, 3), v55, (float32x4_t)v52, 2));
          v57 = (int8x16_t)vmulq_f32(v56, v56);
          v58 = vadd_f32(*(float32x2_t *)v57.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL));
          if (vaddv_f32(v58) == 0.0)
          {
            v59 = (float32x4_t)xmmword_1B6629CC0;
          }
          else
          {
            v60 = vadd_f32(v58, (float32x2_t)vdup_lane_s32((int32x2_t)v58, 1)).u32[0];
            v61 = vrsqrte_f32((float32x2_t)v60);
            v62 = vmul_f32(v61, vrsqrts_f32((float32x2_t)v60, vmul_f32(v61, v61)));
            v59 = vmulq_n_f32(v56, vmul_f32(v62, vrsqrts_f32((float32x2_t)v60, vmul_f32(v62, v62))).f32[0]);
          }
          v63 = vmulq_f32(v59, (float32x4_t)xmmword_1B66A07B0);
          v64 = (int8x16_t)vmulq_f32(v59, v59);
          *(float32x2_t *)v64.i8 = vadd_f32(*(float32x2_t *)v64.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v64, v64, 8uLL));
          v64.i32[0] = vadd_f32(*(float32x2_t *)v64.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v64.i8, 1)).u32[0];
          v65 = vrecpe_f32((float32x2_t)v64.u32[0]);
          v66 = vmul_f32(v65, vrecps_f32((float32x2_t)v64.u32[0], v65));
          v67 = vmulq_n_f32(v63, vmul_f32(v66, vrecps_f32((float32x2_t)v64.u32[0], v66)).f32[0]);
          v68 = (int8x16_t)vmulq_f32(v67, v67);
          v69 = vadd_f32(*(float32x2_t *)v68.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL));
          v70 = vaddv_f32(v69);
          v71 = 0.0;
          if (sqrtf(v70) >= 0.0001)
          {
            if (v70 == 0.0)
            {
              _Q1 = (float32x4_t)xmmword_1B6629CC0;
            }
            else
            {
              v73 = vadd_f32(v69, (float32x2_t)vdup_lane_s32((int32x2_t)v69, 1)).u32[0];
              v74 = vrsqrte_f32((float32x2_t)v73);
              v75 = vmul_f32(v74, vrsqrts_f32((float32x2_t)v73, vmul_f32(v74, v74)));
              _Q1 = vmulq_n_f32(v67, vmul_f32(v75, vrsqrts_f32((float32x2_t)v73, vmul_f32(v75, v75))).f32[0]);
            }
            _S2 = _Q1.i32[2];
            _S3 = _Q1.i32[1];
            __asm
            {
              FMLA            S0, S2, V1.S[3]
              FMLA            S2, S3, V1.S[1]
            }
            v71 = atan2f(_S0 + _S0, (float)(_S2 * -2.0) + 1.0) * 57.296;
          }
          v83 = *((_QWORD *)this + 401);
          if (v83)
          {
            *(float *)(v83 + 8) = v71;
          }
          else
          {
            *((float *)this + 799) = v71;
            MidSideRotation::calculateCoefficients((__float2 *)((char *)this + 3180));
          }
        }
        if ((v25 & 1) != 0)
        {
          v84 = AUSM::auCoordQuaternionToEuler(CurrentHeadPose, __Step);
          v86 = v85;
          v88 = v87;
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v28 = (id)getAUSMV2Log(void)::gLog;
          if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            goto LABEL_63;
          v89 = (_QWORD *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v89 = (_QWORD *)*v89;
          *(_DWORD *)buf = 136317442;
          *(_QWORD *)&buf[4] = v89;
          *(_WORD *)v424 = 2080;
          *(_QWORD *)&v424[2] = "ProcessMultipleBufferListsPrivate";
          *(_WORD *)&v424[10] = 2048;
          v425 = v84;
          *(_WORD *)v426 = 2048;
          *(double *)&v426[2] = v86;
          *(_WORD *)&v426[10] = 2048;
          v427 = v88;
          *(_WORD *)v428 = 2048;
          *(double *)&v428[2] = __Step.f32[0];
          *(_WORD *)&v428[10] = 2048;
          v429 = __Step.f32[1];
          v430 = 2048;
          v431 = __Step.f32[2];
          v432 = 2048;
          v433 = __Step.f32[3];
          v434 = 1024;
          v435 = v27;
          v30 = "[%s|%s] AUSMTrackedHeadPose: Y: %.2f, P: %.2f, R: %.2f, Quat: (%.4f, %.4f, %.4f, %.4f. Error = %d)";
          v31 = v28;
          v32 = 98;
LABEL_62:
          _os_log_impl(&dword_1B5ED0000, v31, OS_LOG_TYPE_DEFAULT, v30, buf, v32);
LABEL_63:

        }
      }
    }
  }
LABEL_64:
  AUSM::GlobalGeometry::update((float32x2_t *)this + 792, a3, 0);
  Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
  if (!a7)
    __assert_rtn("ProcessMultipleBufferListsPrivate", "AUSpatialMixerV2.mm", 2999, "ioOutputBufferLists");
  v91 = (unsigned int *)*a7;
  if (!*a7)
    __assert_rtn("ProcessMultipleBufferListsPrivate", "AUSpatialMixerV2.mm", 3000, "ioOutputBufferLists[0]");
  v92 = *v91;
  v93 = *((_QWORD *)this + 370);
  if ((_DWORD)v92 != *(_DWORD *)(v93 + 380))
    __assert_rtn("ProcessMultipleBufferListsPrivate", "AUSpatialMixerV2.mm", 3003, "numMixBuffers == mSharedBuffers->mixBufferPtrs.numChannels()");
  v94 = *(float *)(Element + 192);
  v95 = *(_QWORD *)(v93 + 328);
  v96 = *(_QWORD *)(v93 + 336) - v95;
  v97 = (unint64_t)v96 >> 3;
  if (v92 >= ((unint64_t)v96 >> 3))
    v97 = v97;
  else
    v97 = v92;
  if ((_DWORD)v97)
  {
    v98 = 0;
    v99 = (uint64_t *)(v91 + 4);
    do
    {
      v100 = *v99;
      v99 += 2;
      *(_QWORD *)(*(_QWORD *)(v93 + 328) + v98) = v100;
      v98 += 8;
    }
    while (8 * v97 != v98);
    v95 = *(_QWORD *)(v93 + 328);
    v96 = *(_QWORD *)(v93 + 336) - v95;
    v101 = v97;
  }
  else
  {
    v101 = 0;
  }
  v414 = v92;
  if (v101 < v96 >> 3)
  {
    v102 = v97 + 1;
    do
    {
      *(_QWORD *)(v95 + 8 * v101) = 0;
      v101 = v102;
      v95 = *(_QWORD *)(v93 + 328);
      ++v102;
    }
    while (v101 < (*(_QWORD *)(v93 + 336) - v95) >> 3);
  }
  *(_DWORD *)(v93 + 380) = v97;
  v103 = *((_QWORD *)this + 370);
  v104 = *(void ***)(v103 + 328);
  v105 = *(void ***)(v103 + 336);
  v106 = v103;
  if (v104 != v105)
  {
    do
    {
      if (*v104)
        bzero(*v104, 4 * a3);
      ++v104;
    }
    while (v104 != v105);
    v106 = *((_QWORD *)this + 370);
  }
  *(_BYTE *)(v103 + 376) = 1;
  v107 = *(void ***)(v106 + 392);
  for (i = *(void ***)(v106 + 400); v107 != i; ++v107)
  {
    if (*v107)
      bzero(*v107, 4 * a3);
  }
  *(_BYTE *)(v106 + 440) = 1;
  v109 = atomic_load((unsigned __int8 *)this + 2473);
  if ((v109 & 1) != 0)
  {
    v110 = atomic_load((unsigned __int8 *)this + 2474);
    if ((v110 & 1) == 0)
    {
      *(_QWORD *)buf = (char *)this + 2476;
      v111 = caulk::pooled_semaphore_mutex::try_lock((AUSpatialMixerV2 *)((char *)this + 2476));
      buf[8] = v111;
      if (v111)
      {
        v112 = *(_OWORD *)((char *)this + 2408);
        v113 = *(_OWORD *)((char *)this + 2424);
        v114 = *(_OWORD *)((char *)this + 2440);
        v115 = *v407;
        v116 = *(_OWORD *)((char *)this + 2392);
        *(_OWORD *)((char *)this + 2408) = *(_OWORD *)((char *)this + 2456);
        *(_OWORD *)((char *)this + 2424) = v115;
        *(_OWORD *)((char *)this + 2440) = v116;
        *(_OWORD *)((char *)this + 2456) = v112;
        *v407 = v113;
        *(_OWORD *)((char *)this + 2392) = v114;
        atomic_store(0, (unsigned __int8 *)this + 2473);
        atomic_store(1u, (unsigned __int8 *)this + 2472);
        atomic_store(1u, (unsigned __int8 *)this + 2474);
      }
      std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)buf);
    }
  }
  v117 = *((_QWORD *)this + 15);
  if (v117)
    LODWORD(v118) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v117 + 24))(v117);
  else
    v118 = (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
  v410 = (AUSpatialMixerV2 *)((char *)this + 2328);
  if ((_DWORD)v118)
  {
    v119 = 0;
    v419 = 0;
    v415 = 0;
    v416 = 1;
    v417 = 1;
    v418 = 1;
    v120 = v118;
    while (1)
    {
      v121 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 80), v119);
      v122 = (unsigned int *)v121;
      if (*((_BYTE *)this + 540) && *((_DWORD *)this + 134) == 1)
      {
        if (v119 < a4)
        {
          v123 = a5[v119];
          if (v123)
          {
            ausdk::AUBufferList::SetBufferList((ausdk::AUBufferList *)(v121 + 144), v123);
LABEL_103:
            v124 = atomic_load((unsigned __int8 *)this + 2816);
            if ((v124 & 1) != 0)
            {
              v125 = (char *)this + 2768;
              vDSP_vclr(*((float **)this + 346), 1, a3);
              *((_BYTE *)this + 2792) = 1;
            }
            else
            {
              v125 = 0;
            }
            MustProcessPostProcReverb = AUSpatialMixerV2InputElement::MustProcessPostProcReverb((AUSpatialMixerV2InputElement *)v122);
            if (MustProcessPostProcReverb)
              v127 = (char *)this + 2664;
            else
              v127 = 0;
            if (AUSpatialMixerV2InputElement::MustProcessInternalReverb((AUSpatialMixerV2InputElement *)v122))
            {
              v128 = atomic_load(v122 + 282);
              if (v128 - 7 <= 2
                && AUSpatialMixerV2InputElement::MustProcessInternalReverb((AUSpatialMixerV2InputElement *)v122))
              {
                v415 = 1;
                v129 = (char *)this + 2616;
              }
              else
              {
                v130 = atomic_load(v122 + 282);
                if (v130 == 6
                  && AUSpatialMixerV2InputElement::MustProcessInternalReverb((AUSpatialMixerV2InputElement *)v122))
                {
                  v415 = 1;
                  v129 = (char *)this + 2272;
                }
                else
                {
                  v131 = atomic_load((unsigned __int8 *)this + 2176);
                  v415 = v131 & 1;
                  if ((v131 & 1) != 0)
                    v129 = (char *)this + 2200;
                  else
                    v129 = 0;
                }
              }
            }
            else
            {
              v129 = 0;
            }
            if (v129 != 0 && MustProcessPostProcReverb)
              v132 = (char *)this + 2712;
            else
              v132 = 0;
            AUSpatialMixerV2InputElement::Process((uint64_t)v122, a2, (__int128 *)a8, *((_QWORD *)this + 370), (uint64_t)v129, (uint64_t)v127, (uint64_t)v132, (uint64_t)v125, v94, a3);
            if ((v418 & 1) != 0)
            {
              if (*((_BYTE *)this + 2640))
              {
                v418 = 1;
              }
              else
              {
                v134 = (const float *)*((_QWORD *)this + 327);
                v135 = atomic_load((unsigned int *)this + 1867);
                IR::SharedIRBuses::sumToBus(v410, v134, v119 + v135, a3, v133);
                vDSP_vclr(*((float **)this + 327), 1, a3);
                v418 = 0;
                *((_BYTE *)this + 2640) = 1;
              }
            }
            else
            {
              v418 = 0;
            }
            if ((v417 & 1) != 0)
            {
              if (*((_BYTE *)this + 2688))
              {
                v417 = 1;
              }
              else
              {
                v136 = (const float *)*((_QWORD *)this + 333);
                v137 = atomic_load((unsigned int *)this + 1868);
                IR::SharedIRBuses::sumToBus(v410, v136, v119 + v137, a3, v133);
                vDSP_vclr(*((float **)this + 333), 1, a3);
                v417 = 0;
                *((_BYTE *)this + 2688) = 1;
              }
            }
            else
            {
              v417 = 0;
            }
            v419 |= MustProcessPostProcReverb;
            if ((v416 & 1) != 0)
            {
              if (*((_BYTE *)this + 2736))
              {
                v416 = 1;
              }
              else
              {
                v138 = (const float *)*((_QWORD *)this + 339);
                v139 = atomic_load((unsigned int *)this + 1869);
                IR::SharedIRBuses::sumToBus(v410, v138, v119 + v139, a3, v133);
                vDSP_vclr(*((float **)this + 339), 1, a3);
                v416 = 0;
                *((_BYTE *)this + 2736) = 1;
              }
            }
            else
            {
              v416 = 0;
            }
          }
        }
      }
      else if (ausdk::AUBase::HasInput(this, v119))
      {
        goto LABEL_103;
      }
      if (v120 == ++v119)
        goto LABEL_141;
    }
  }
  v418 = 1;
  v419 = 0;
  v417 = 1;
  v415 = 0;
  v416 = 1;
LABEL_141:
  v140 = (TorqueEngine *)*((_QWORD *)this + 401);
  v141 = *((_QWORD *)this + 370);
  v142 = *(unsigned __int8 *)(v141 + 440);
  if (v140)
  {
    if (!*(_BYTE *)(v141 + 440) || (v143 = *((_DWORD *)this + 804), v143 <= 0xFF))
    {
      v144 = *(_QWORD *)(v141 + 392);
      if (*(_QWORD *)(v141 + 400) != v144)
      {
        v145 = 0;
        v146 = 1;
        do
        {
          *(_QWORD *)(*(_QWORD *)(v141 + 416) + 8 * v145) = *(_QWORD *)(v144 + 8 * v145);
          v145 = v146;
          v144 = *(_QWORD *)(v141 + 392);
          ++v146;
        }
        while (v145 < (*(_QWORD *)(v141 + 400) - v144) >> 3);
        v141 = *((_QWORD *)this + 370);
        v140 = (TorqueEngine *)*((_QWORD *)this + 401);
      }
      v147 = *(float ***)(v141 + 416);
      TorqueEngine::processInplace(v140, *v147, v147[1], a3);
      v148 = 0;
      v149 = *((_QWORD *)this + 370);
      do
      {
        vDSP_vadd(*(const float **)(*(_QWORD *)(v149 + 328) + v148 * 8), 1, v147[v148], 1, *(float **)(*(_QWORD *)(v149 + 328) + v148 * 8), 1, a3);
        ++v148;
      }
      while (v148 != 2);
      *(_BYTE *)(v149 + 376) = 0;
      if (!v142)
      {
        *((_DWORD *)this + 804) = 0;
        goto LABEL_169;
      }
      v143 = *((_DWORD *)this + 804);
    }
    v150 = v143 + a3;
    if (__CFADD__(v143, (_DWORD)a3))
      v150 = -1;
    *((_DWORD *)this + 804) = v150;
  }
  else if (!*(_BYTE *)(v141 + 440))
  {
    v151 = *(float **)(v141 + 128);
    v152 = *(float **)(v141 + 152);
    v153 = *(_QWORD *)(v141 + 392);
    if (*(_QWORD *)(v141 + 400) != v153)
    {
      v154 = 0;
      v155 = 1;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v141 + 416) + 8 * v154) = *(_QWORD *)(v153 + 8 * v154);
        v154 = v155;
        v153 = *(_QWORD *)(v141 + 392);
        ++v155;
      }
      while (v154 < (*(_QWORD *)(v141 + 400) - v153) >> 3);
      v141 = *((_QWORD *)this + 370);
    }
    v156 = *(const float ***)(v141 + 416);
    vDSP_vadd(*v156, 1, v156[1], 1, v151, 1, a3);
    *(_DWORD *)buf = 1060439283;
    vDSP_vsbsm(*v156, 1, v156[1], 1, (const float *)buf, v152, 1, a3);
    v157 = (float *)((char *)this + 3180);
    v158 = *((float *)this + 797);
    v159 = *((float *)this + 795);
    if (vabds_f32(v158, v159) >= 0.00001 || vabds_f32(*((float *)this + 798), *((float *)this + 796)) >= 0.00001)
    {
      v160 = 1.0 / (float)a3;
      __Step.f32[0] = v160 * (float)(v158 - v159);
      vDSP_vrampmul(v151, 1, v157, __Step.f32, (float *)*v156, 1, a3);
      __Step.f32[0] = v160 * (float)(*((float *)this + 798) - *((float *)this + 796));
      vDSP_vrampmul(v151, 1, (float *)this + 796, __Step.f32, (float *)v156[1], 1, a3);
    }
    else
    {
      vDSP_vsmul(v151, 1, v157, (float *)*v156, 1, a3);
      vDSP_vsmul(v151, 1, (const float *)this + 796, (float *)v156[1], 1, a3);
    }
    vDSP_vasm(v152, 1, *v156, 1, (const float *)buf, (float *)*v156, 1, a3);
    vDSP_vsbsm(v156[1], 1, v152, 1, (const float *)buf, (float *)v156[1], 1, a3);
    v161 = 0;
    v162 = *((_QWORD *)this + 370);
    do
    {
      vDSP_vadd(*(const float **)(*(_QWORD *)(v162 + 328) + v161 * 8), 1, v156[v161], 1, *(float **)(*(_QWORD *)(v162 + 328) + v161 * 8), 1, a3);
      ++v161;
    }
    while (v161 != 2);
    *(_BYTE *)(v162 + 376) = 0;
  }
LABEL_169:
  v163 = atomic_load((unsigned __int8 *)this + 15144);
  if ((v163 & 1) != 0)
  {
    v164 = *(float ***)(*((_QWORD *)this + 370) + 328);
    *(_QWORD *)buf = (char *)this + 15148;
    v165 = caulk::pooled_semaphore_mutex::try_lock((AUSpatialMixerV2 *)((char *)this + 15148));
    buf[8] = v165;
    if (v165)
    {
      if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)this + 1888) - *((_QWORD *)this + 1887)) >> 3) >= v414
        && (_DWORD)v414 != 0)
      {
        v167 = 0;
        do
        {
          IR::FixedIntegerDelay::process((IR::FixedIntegerDelay *)(*((_QWORD *)this + 1887) + v167), *v164, *v164, a3);
          v167 += 56;
          ++v164;
        }
        while (56 * v414 != v167);
      }
    }
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)buf);
  }
  v168 = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
  if (((v415 | v419) & 1) == 0)
  {
    v172 = 0;
    goto LABEL_401;
  }
  v169 = *(double *)(v168 + 80);
  v170 = *(const float ***)(*((_QWORD *)this + 370) + 328);
  if (*((float *)this + 790) == 0.0 || !*((_BYTE *)this + 3168))
  {
    v173 = atomic_load((unsigned __int8 *)this + 15145);
    if ((v173 & 1) == 0)
      goto LABEL_190;
    v171 = 0;
  }
  else
  {
    v171 = 1;
  }
  v174 = AUSM::ABLBuffer::setupBufferList((AUSpatialMixerV2 *)((char *)this + 3048), v414, 0, a3, 4);
  if (*v174)
  {
    v175 = v174;
    v176 = 0;
    v177 = (void **)(v174 + 4);
    do
    {
      bzero(*v177, *((unsigned int *)v177 - 1));
      ++v176;
      v177 += 2;
    }
    while (v176 < *v175);
  }
  v170 = (const float **)*((_QWORD *)this + 387);
  if (v171)
  {
    v178 = *((_DWORD *)this + 735);
    v412 = 1;
    goto LABEL_191;
  }
LABEL_190:
  v412 = 0;
  v178 = 0;
LABEL_191:
  v179 = atomic_load((unsigned __int8 *)this + 15145);
  if ((v179 & 1) != 0)
  {
    *(_QWORD *)buf = (char *)this + 15148;
    v180 = caulk::pooled_semaphore_mutex::try_lock((AUSpatialMixerV2 *)((char *)this + 15148));
    buf[8] = v180;
    if (v180)
    {
      v181 = (_DWORD *)*((_QWORD *)this + 1890);
      if (v181 != *((_DWORD **)this + 1891))
        v178 += *v181;
    }
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)buf);
  }
  v421 = 0.0;
  v182 = (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, float *))(*(_QWORD *)this + 144))(this, 9, 0, 0, &v421);
  v184.n128_u32[0] = 1.0;
  if (!v182)
    v184.n128_f32[0] = __exp10f(v421 * 0.05);
  v421 = v184.n128_f32[0];
  if (*((_BYTE *)this + 2224)
    && (v185 = *((_DWORD *)this + 560), v186 = atomic_load((unsigned int *)this + 561), v185 >= v186 + v178))
  {
    v172 = 0;
  }
  else
  {
    __Step.i64[0] = (uint64_t)this + 2192;
    v187 = caulk::pooled_semaphore_mutex::try_lock((AUSpatialMixerV2 *)((char *)this + 2192));
    __Step.i8[8] = v187;
    if (v187)
    {
      v188 = v421;
      *((float *)this + 234) = v421;
      *((float *)this + 237) = v188 * *((float *)this + 235);
      v189 = *((_QWORD *)this + 275);
      if ((_DWORD)v414 == 2)
      {
        if ((_DWORD)a3)
        {
          v190 = 0;
          v191 = *v170;
          v192 = v170[1];
          do
          {
            v193 = 0;
            v194 = -1152;
            do
            {
              v195 = (float *)((char *)this + v194);
              v196 = *(_DWORD *)((char *)this + v194 + 2220);
              v197 = (float)(*(float *)(*(_QWORD *)((char *)this + v194 + 2176)
                                      + 4 * (*(_DWORD *)((_BYTE *)this + v194 + 2216) & v196))
                           * *(float *)((char *)this + v194 + 2204))
                   + (float)(*(float *)((char *)this + v194 + 2200) * *(float *)((char *)this + v194 + 2208));
              *(float *)&buf[v193] = v197;
              v195[552] = v197;
              *((_DWORD *)v195 + 555) = v196 + 1;
              v193 += 4;
              v194 += 72;
            }
            while (v194);
            v198 = 0;
            v199 = (float)(*(float *)buf + *(float *)&buf[4]) + (float)(*(float *)&buf[8] + *(float *)v424);
            v200 = (float)(*(float *)buf - *(float *)&buf[4]) + (float)(*(float *)&buf[8] - *(float *)v424);
            v201 = (float)(*(float *)buf + *(float *)&buf[4]) - (float)(*(float *)&buf[8] + *(float *)v424);
            v202 = (float)(*(float *)buf - *(float *)&buf[4]) - (float)(*(float *)&buf[8] - *(float *)v424);
            v203 = (float)(*(float *)&v424[4] + *(float *)&v424[8]) + (float)(*(float *)&v425 + *((float *)&v425 + 1));
            v204 = (float)(*(float *)&v424[4] - *(float *)&v424[8]) + (float)(*(float *)&v425 - *((float *)&v425 + 1));
            v205 = (float)(*(float *)&v424[4] + *(float *)&v424[8]) - (float)(*(float *)&v425 + *((float *)&v425 + 1));
            v206 = (float)(*(float *)&v424[4] - *(float *)&v424[8]) - (float)(*(float *)&v425 - *((float *)&v425 + 1));
            v207 = (float)(*(float *)v426 + *(float *)&v426[4]) + (float)(*(float *)&v426[8] + *(float *)&v427);
            v208 = (float)(*(float *)v426 - *(float *)&v426[4]) + (float)(*(float *)&v426[8] - *(float *)&v427);
            v209 = (float)(*(float *)v426 + *(float *)&v426[4]) - (float)(*(float *)&v426[8] + *(float *)&v427);
            v210 = (float)(*(float *)v426 - *(float *)&v426[4]) - (float)(*(float *)&v426[8] - *(float *)&v427);
            v211 = (float)(*((float *)&v427 + 1) + *(float *)v428) + (float)(*(float *)&v428[4] + *(float *)&v428[8]);
            v212 = (float)(*((float *)&v427 + 1) - *(float *)v428) + (float)(*(float *)&v428[4] - *(float *)&v428[8]);
            v213 = (float)(*((float *)&v427 + 1) + *(float *)v428) - (float)(*(float *)&v428[4] + *(float *)&v428[8]);
            v214 = (float)(*((float *)&v427 + 1) - *(float *)v428) - (float)(*(float *)&v428[4] - *(float *)&v428[8]);
            v215 = v199 + v203;
            v216 = v200 + v204;
            v217 = v201 + v205;
            v218 = v202 + v206;
            v219 = v199 - v203;
            v220 = v200 - v204;
            v221 = v201 - v205;
            v222 = v202 - v206;
            v223 = v207 + v211;
            v224 = v208 + v212;
            v225 = v209 + v213;
            v226 = v210 + v214;
            v227 = v207 - v211;
            v228 = v208 - v212;
            v229 = v209 - v213;
            v230 = v210 - v214;
            *(float *)buf = v215 + v223;
            *(float *)&buf[4] = v216 + v224;
            *(float *)&buf[8] = v217 + v225;
            *(float *)v424 = v218 + v226;
            *(float *)&v424[4] = v219 + v227;
            *(float *)&v424[8] = v220 + v228;
            *(float *)&v425 = v221 + v229;
            *((float *)&v425 + 1) = v222 + v230;
            *(float *)v426 = v215 - v223;
            *(float *)&v426[4] = v216 - v224;
            *(float *)&v426[8] = v217 - v225;
            *(float *)&v427 = v218 - v226;
            *((float *)&v427 + 1) = v219 - v227;
            *(float *)v428 = v220 - v228;
            *(float *)&v428[4] = v221 - v229;
            *(float *)&v428[8] = v222 - v230;
            v231 = *((float *)this + 238);
            v232 = *((float *)this + 239);
            v233 = (float)((float)(v216 + v224) * v231) + (float)(v232 * *((float *)this + 240));
            *((float *)this + 240) = v216 + v224;
            v234 = (float)(v231 * (float)(v217 + v225)) + (float)(v232 * *((float *)this + 241));
            *((float *)this + 241) = v217 + v225;
            v191[v190] = v191[v190] + (float)(v233 * *((float *)this + 237));
            v192[v190] = v192[v190] + (float)(v234 * *((float *)this + 237));
            v235 = *(float *)(v189 + 4 * v190);
            v236 = (_DWORD *)((char *)this + 1072);
            do
            {
              v237 = *v236;
              *(float *)(*((_QWORD *)v236 - 6) + 4 * (*(v236 - 2) & *v236)) = v235
                                                                                            + *(float *)&buf[v198];
              *v236 = v237 + 1;
              v236 += 18;
              v198 += 4;
            }
            while (v198 != 64);
            ++v190;
          }
          while (v190 != a3);
        }
      }
      else if ((_DWORD)a3)
      {
        v238 = 0;
        do
        {
          v239 = 0;
          v240 = -1152;
          do
          {
            v241 = (float *)((char *)this + v240);
            v242 = *(_DWORD *)((char *)this + v240 + 2220);
            v243 = (float)(*(float *)(*(_QWORD *)((char *)this + v240 + 2176)
                                    + 4 * (*(_DWORD *)((_BYTE *)this + v240 + 2216) & v242))
                         * *(float *)((char *)this + v240 + 2204))
                 + (float)(*(float *)((char *)this + v240 + 2200) * *(float *)((char *)this + v240 + 2208));
            *(float *)&buf[v239] = v243;
            v241[552] = v243;
            *((_DWORD *)v241 + 555) = v242 + 1;
            v239 += 4;
            v240 += 72;
          }
          while (v240);
          v244 = (float)(*(float *)buf + *(float *)&buf[4]) + (float)(*(float *)&buf[8] + *(float *)v424);
          v245 = (float)(*(float *)buf - *(float *)&buf[4]) + (float)(*(float *)&buf[8] - *(float *)v424);
          v246 = (float)(*(float *)buf + *(float *)&buf[4]) - (float)(*(float *)&buf[8] + *(float *)v424);
          v247 = (float)(*(float *)buf - *(float *)&buf[4]) - (float)(*(float *)&buf[8] - *(float *)v424);
          v248 = (float)(*(float *)&v424[4] + *(float *)&v424[8]) + (float)(*(float *)&v425 + *((float *)&v425 + 1));
          v249 = (float)(*(float *)&v424[4] - *(float *)&v424[8]) + (float)(*(float *)&v425 - *((float *)&v425 + 1));
          v250 = (float)(*(float *)&v424[4] + *(float *)&v424[8]) - (float)(*(float *)&v425 + *((float *)&v425 + 1));
          v251 = (float)(*(float *)&v424[4] - *(float *)&v424[8]) - (float)(*(float *)&v425 - *((float *)&v425 + 1));
          v252 = (float)(*(float *)v426 + *(float *)&v426[4]) + (float)(*(float *)&v426[8] + *(float *)&v427);
          v253 = (float)(*(float *)v426 - *(float *)&v426[4]) + (float)(*(float *)&v426[8] - *(float *)&v427);
          v254 = (float)(*(float *)v426 + *(float *)&v426[4]) - (float)(*(float *)&v426[8] + *(float *)&v427);
          v255 = (float)(*(float *)v426 - *(float *)&v426[4]) - (float)(*(float *)&v426[8] - *(float *)&v427);
          v256 = (float)(*((float *)&v427 + 1) + *(float *)v428) + (float)(*(float *)&v428[4] + *(float *)&v428[8]);
          v257 = (float)(*((float *)&v427 + 1) - *(float *)v428) + (float)(*(float *)&v428[4] - *(float *)&v428[8]);
          v258 = (float)(*((float *)&v427 + 1) + *(float *)v428) - (float)(*(float *)&v428[4] + *(float *)&v428[8]);
          v259 = (float)(*((float *)&v427 + 1) - *(float *)v428) - (float)(*(float *)&v428[4] - *(float *)&v428[8]);
          v260 = v244 + v248;
          v261 = v245 + v249;
          v262 = v246 + v250;
          v263 = v247 + v251;
          v264 = v244 - v248;
          v265 = v245 - v249;
          v266 = v246 - v250;
          v267 = v247 - v251;
          v268 = v252 + v256;
          v269 = v253 + v257;
          v270 = v254 + v258;
          v271 = v255 + v259;
          v272 = v252 - v256;
          v273 = v253 - v257;
          v274 = v254 - v258;
          *(float *)buf = v260 + v268;
          *(float *)&buf[4] = v261 + v269;
          *(float *)&buf[8] = v262 + v270;
          *(float *)v424 = v263 + (float)(v255 + v259);
          *(float *)&v424[4] = v264 + v272;
          *(float *)&v424[8] = v265 + v273;
          v275 = v255 - v259;
          *(float *)&v425 = v266 + v274;
          *((float *)&v425 + 1) = v267 + v275;
          *(float *)v426 = v260 - v268;
          *(float *)&v426[4] = v261 - v269;
          *(float *)&v426[8] = v262 - v270;
          *(float *)&v427 = v263 - v271;
          *((float *)&v427 + 1) = v264 - v272;
          *(float *)v428 = v265 - v273;
          *(float *)&v428[4] = v266 - v274;
          *(float *)&v428[8] = v267 - v275;
          v276 = (float *)&buf[4];
          v277 = v414;
          v278 = v170;
          if ((_DWORD)v414)
          {
            do
            {
              v279 = *v276++;
              v280 = v279 * *((float *)this + 237);
              v281 = (uint64_t)*v278++;
              *(float *)(v281 + 4 * v238) = v280 + *(float *)(v281 + 4 * v238);
              --v277;
            }
            while (v277);
          }
          v282 = 0;
          v283 = *(float *)(v189 + 4 * v238);
          v284 = (_DWORD *)((char *)this + 1072);
          do
          {
            v285 = *v284;
            *(float *)(*((_QWORD *)v284 - 6) + 4 * (*(v284 - 2) & *v284)) = v283 + *(float *)&buf[v282];
            *v284 = v285 + 1;
            v284 += 18;
            v282 += 4;
          }
          while (v282 != 64);
          ++v238;
        }
        while (v238 != a3);
      }
    }
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&__Step);
    if (*((_BYTE *)this + 2224))
    {
      v286 = *((_DWORD *)this + 560);
      _CF = __CFADD__(v286, (_DWORD)a3);
      v287 = v286 + a3;
      if (_CF)
        v287 = -1;
      *((_DWORD *)this + 560) = v287;
    }
    else
    {
      *((_DWORD *)this + 560) = 0;
      vDSP_vclr(*((float **)this + 275), 1, a3);
      *((_BYTE *)this + 2224) = 1;
    }
    *((_QWORD *)this + 279) = *((_QWORD *)this + 275);
    v172 = 1;
  }
  v288 = *(const float ***)(*((_QWORD *)this + 370) + 200);
  if (!*((_BYTE *)this + 2296)
    || (v289 = *((_DWORD *)this + 578), v290 = atomic_load((unsigned int *)this + 579), v289 < v290 + v178))
  {
    *(_QWORD *)buf = (char *)this + 2256;
    v291 = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 2256);
    buf[8] = v291;
    if (v291)
    {
      (*(void (**)(_QWORD, _QWORD, const float **, uint64_t, vDSP_Length, _QWORD, float))(**((_QWORD **)this + 281)
                                                                                                  + 40))(*((_QWORD *)this + 281), *((_QWORD *)this + 284), v288, 2, a3, 0, v421);
      vDSP_vadd(*v288, 1, *v170, 1, (float *)*v170, 1, a3);
      vDSP_vadd(v288[1], 1, v170[1], 1, (float *)v170[1], 1, a3);
    }
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)buf);
    if (*((_BYTE *)this + 2296))
    {
      v292 = *((_DWORD *)this + 578);
      _CF = __CFADD__(v292, (_DWORD)a3);
      v293 = v292 + a3;
      if (_CF)
        v293 = -1;
      *((_DWORD *)this + 578) = v293;
    }
    else
    {
      *((_DWORD *)this + 578) = 0;
      vDSP_vclr(*((float **)this + 284), 1, a3);
      *((_BYTE *)this + 2296) = 1;
    }
    *((_QWORD *)this + 288) = *((_QWORD *)this + 284);
    v172 = 1;
  }
  if ((v418 & v417 & v416 & 1) == 0
    || (v294 = *((_DWORD *)this + 664), v295 = atomic_load((unsigned int *)this + 665), v294 < v295 + v178)
    || (v296 = *((_DWORD *)this + 676), v297 = atomic_load((unsigned int *)this + 677), v296 < v297 + v178)
    || (v298 = *((_DWORD *)this + 688), v299 = atomic_load((unsigned int *)this + 689), v298 < v299 + v178))
  {
    __Step.i32[0] = 0;
    IR::SharedIRBuses::process(v410, (float **)v288, v414, a3, v421, (unsigned int *)&__Step);
    *(_QWORD *)buf = (char *)this + 2608;
    v300 = caulk::pooled_semaphore_mutex::try_lock((AUSpatialMixerV2 *)((char *)this + 2608));
    buf[8] = v300;
    if (v300)
    {
      v301 = (_DWORD *)*((_QWORD *)this + 323);
      if (v301 != *((_DWORD **)this + 324))
      {
        if ((_DWORD)v414)
        {
          v302 = 0;
          v303 = 0;
          v304 = (float **)v288;
          while (1)
          {
            v301 = (_DWORD *)*((_QWORD *)this + 323);
            if (v303 >= -1227133513 * ((*((_QWORD *)this + 324) - (_QWORD)v301) >> 3))
              break;
            IR::FixedIntegerDelay::process((IR::FixedIntegerDelay *)&v301[v302], *v304, *v304, a3);
            ++v303;
            v302 += 14;
            ++v304;
            if (14 * v414 == v302)
            {
              v301 = (_DWORD *)*((_QWORD *)this + 323);
              break;
            }
          }
        }
        __Step.i32[0] += *v301;
      }
    }
    v305 = __Step.i32[0];
    atomic_store(__Step.u32[0], (unsigned int *)this + 665);
    atomic_store(v305, (unsigned int *)this + 677);
    atomic_store(v305, (unsigned int *)this + 689);
    if ((_DWORD)v414)
    {
      v306 = v288;
      v307 = v170;
      v308 = v414;
      do
      {
        vDSP_vadd(*v306, 1, *v307, 1, (float *)*v307, 1, a3);
        ++v307;
        ++v306;
        --v308;
      }
      while (v308);
    }
    if ((v418 & 1) != 0)
      v309 = *((_DWORD *)this + 664) + a3;
    else
      v309 = 0;
    *((_DWORD *)this + 664) = v309;
    if ((v417 & 1) != 0)
      v310 = *((_DWORD *)this + 676) + a3;
    else
      v310 = 0;
    *((_DWORD *)this + 676) = v310;
    if ((v416 & 1) != 0)
      v311 = *((_DWORD *)this + 688) + a3;
    else
      v311 = 0;
    *((_DWORD *)this + 688) = v311;
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)buf);
    v172 = 1;
  }
  v312 = (_BYTE *)*((_QWORD *)this + 370);
  v313 = v312[536] && v312[632] && v312[728] != 0;
  v314 = (ParametricFilters *)*((_QWORD *)this + 931);
  if (v314)
    LODWORD(v314) = ParametricFilters::getTailLength(v314);
  if (v313)
  {
    v184.n128_f32[0] = (float)v314;
    v315 = *((_DWORD *)this + 1861);
    v183.n128_f32[0] = (float)v315;
    if ((float)v315 > (float)v314)
      goto LABEL_355;
  }
  v316 = atomic_load((unsigned __int8 *)this + 3746);
  if ((v316 & 1) != 0)
  {
    if ((v415 & 1) != 0)
    {
      v317 = *((_QWORD *)this + 370);
      if (IR::ComplexDataCircBuffer::isInitialized((IR::ComplexDataCircBuffer *)(v317 + 784)))
      {
        SampleDataPtrs = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v317 + 784));
        if (*(unsigned int *)(v317 + 540) < (unint64_t)((uint64_t)(SampleDataPtrs[1] - *SampleDataPtrs) >> 3))
          __assert_rtn("operator()", "AUSpatialMixerV2.mm", 3233, "fftBuffer.getSampleDataPtrs().size() <= erBuffer.numChannels()");
        for (j = 0; ; ++j)
        {
          v320 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v317 + 784));
          if (j >= (unint64_t)((uint64_t)(v320[1] - *v320) >> 3))
            break;
          v321 = *(_QWORD *)(*(_QWORD *)(v317 + 488) + 8 * j);
          *(_QWORD *)(*(_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v317 + 784))
                    + 8 * j) = v321;
        }
        IR::ComplexDataCircBuffer::inverseFFTOverlapAdd((IR::ComplexDataCircBuffer *)(v317 + 784));
      }
    }
    if ((v419 & 1) == 0)
      goto LABEL_292;
    v322 = *((_QWORD *)this + 370);
    if (IR::ComplexDataCircBuffer::isInitialized((IR::ComplexDataCircBuffer *)(v322 + 792)))
    {
      v323 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v322 + 792));
      if (*(unsigned int *)(v322 + 636) < (unint64_t)((uint64_t)(v323[1] - *v323) >> 3))
        __assert_rtn("operator()", "AUSpatialMixerV2.mm", 3233, "fftBuffer.getSampleDataPtrs().size() <= erBuffer.numChannels()");
      for (k = 0; ; ++k)
      {
        v325 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v322 + 792));
        if (k >= (unint64_t)((uint64_t)(v325[1] - *v325) >> 3))
          break;
        v326 = *(_QWORD *)(*(_QWORD *)(v322 + 584) + 8 * k);
        *(_QWORD *)(*(_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v322 + 792))
                  + 8 * k) = v326;
      }
      IR::ComplexDataCircBuffer::inverseFFTOverlapAdd((IR::ComplexDataCircBuffer *)(v322 + 792));
    }
    if ((v415 & 1) != 0)
    {
      v327 = *((_QWORD *)this + 370);
      if (IR::ComplexDataCircBuffer::isInitialized((IR::ComplexDataCircBuffer *)(v327 + 800)))
      {
        v328 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v327 + 800));
        if (*(unsigned int *)(v327 + 732) < (unint64_t)((uint64_t)(v328[1] - *v328) >> 3))
          __assert_rtn("operator()", "AUSpatialMixerV2.mm", 3233, "fftBuffer.getSampleDataPtrs().size() <= erBuffer.numChannels()");
        for (m = 0; ; ++m)
        {
          v330 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v327 + 800));
          if (m >= (unint64_t)((uint64_t)(v330[1] - *v330) >> 3))
            break;
          v331 = *(_QWORD *)(*(_QWORD *)(v327 + 680) + 8 * m);
          *(_QWORD *)(*(_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v327 + 800))
                    + 8 * m) = v331;
        }
        IR::ComplexDataCircBuffer::inverseFFTOverlapAdd((IR::ComplexDataCircBuffer *)(v327 + 800));
      }
      v332 = 1;
    }
    else
    {
LABEL_292:
      v332 = 0;
    }
    if ((*((_DWORD *)this + 3773) & 0x80000000) == 0)
    {
      v333 = *((_QWORD *)this + 368);
      if (v333)
      {
        if ((v415 & 1) != 0
          && IR::ComplexDataCircBuffer::isInitialized((IR::ComplexDataCircBuffer *)(v333 + 784)))
        {
          v334 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v333 + 784));
          if (*(unsigned int *)(v333 + 540) < (unint64_t)((uint64_t)(v334[1] - *v334) >> 3))
            __assert_rtn("operator()", "AUSpatialMixerV2.mm", 3233, "fftBuffer.getSampleDataPtrs().size() <= erBuffer.numChannels()");
          for (n = 0; ; ++n)
          {
            v336 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v333 + 784));
            if (n >= (unint64_t)((uint64_t)(v336[1] - *v336) >> 3))
              break;
            v337 = *(_QWORD *)(*(_QWORD *)(v333 + 488) + 8 * n);
            *(_QWORD *)(*(_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v333 + 784))
                      + 8 * n) = v337;
          }
          IR::ComplexDataCircBuffer::inverseFFTOverlapAdd((IR::ComplexDataCircBuffer *)(v333 + 784));
        }
        if ((v419 & 1) != 0)
        {
          v338 = *((_QWORD *)this + 368);
          if (IR::ComplexDataCircBuffer::isInitialized((IR::ComplexDataCircBuffer *)(v338 + 792)))
          {
            v339 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v338 + 792));
            if (*(unsigned int *)(v338 + 636) < (unint64_t)((uint64_t)(v339[1] - *v339) >> 3))
              __assert_rtn("operator()", "AUSpatialMixerV2.mm", 3233, "fftBuffer.getSampleDataPtrs().size() <= erBuffer.numChannels()");
            for (ii = 0; ; ++ii)
            {
              v341 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v338 + 792));
              if (ii >= (unint64_t)((uint64_t)(v341[1] - *v341) >> 3))
                break;
              v342 = *(_QWORD *)(*(_QWORD *)(v338 + 584) + 8 * ii);
              *(_QWORD *)(*(_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v338 + 792))
                        + 8 * ii) = v342;
            }
            IR::ComplexDataCircBuffer::inverseFFTOverlapAdd((IR::ComplexDataCircBuffer *)(v338 + 792));
          }
        }
        if (v332)
        {
          v343 = *((_QWORD *)this + 368);
          if (IR::ComplexDataCircBuffer::isInitialized((IR::ComplexDataCircBuffer *)(v343 + 800)))
          {
            v344 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v343 + 800));
            if (*(unsigned int *)(v343 + 732) < (unint64_t)((uint64_t)(v344[1] - *v344) >> 3))
              __assert_rtn("operator()", "AUSpatialMixerV2.mm", 3233, "fftBuffer.getSampleDataPtrs().size() <= erBuffer.numChannels()");
            for (jj = 0; ; ++jj)
            {
              v346 = (_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v343 + 800));
              if (jj >= (unint64_t)((uint64_t)(v346[1] - *v346) >> 3))
                break;
              v347 = *(_QWORD *)(*(_QWORD *)(v343 + 680) + 8 * jj);
              *(_QWORD *)(*(_QWORD *)IR::ComplexDataCircBuffer::getSampleDataPtrs((IR::ComplexDataCircBuffer *)(v343 + 800))
                        + 8 * jj) = v347;
            }
            IR::ComplexDataCircBuffer::inverseFFTOverlapAdd((IR::ComplexDataCircBuffer *)(v343 + 800));
          }
        }
        v348 = *((_DWORD *)this + 3773);
        _CF = __CFADD__(v348, (_DWORD)a3);
        v349 = v348 + a3;
        if (_CF)
          v350 = -1;
        else
          v350 = v349;
        *((_DWORD *)this + 3773) = v350;
        if (v350 >= IR::ComplexDataCircBuffer::getFFTPartitionLength((IR::ComplexDataCircBuffer *)(*((_QWORD *)this + 368) + 784)))
        {
          v351 = *((_DWORD *)this + 3773);
          if (v351 >= IR::ComplexDataCircBuffer::getFFTPartitionLength((IR::ComplexDataCircBuffer *)(*((_QWORD *)this + 368) + 792)))
          {
            v352 = *((_DWORD *)this + 3773);
            if (v352 >= IR::ComplexDataCircBuffer::getFFTPartitionLength((IR::ComplexDataCircBuffer *)(*((_QWORD *)this + 368) + 800)))
            {
              *((_DWORD *)this + 3773) = -1;
              v353 = (caulk::concurrent::messenger *)*((_QWORD *)this + 440);
              if (!v353)
                __assert_rtn("ProcessMultipleBufferListsPrivate", "AUSpatialMixerV2.mm", 3257, "mMessenger.get() != nullptr");
              v354 = *((_QWORD *)this + 368);
              *((_QWORD *)this + 368) = 0;
              *(_QWORD *)buf = v354;
              caulk::concurrent::messenger::enqueue_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_3>(v353, (uint64_t *)buf);
              std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)buf, 0);
            }
          }
        }
      }
    }
  }
  if ((v419 & 1) == 0)
    goto LABEL_333;
  v355 = *((_QWORD *)this + 931);
  if (v355)
    ParametricFilters::process(v355, *(float *const **)(*((_QWORD *)this + 370) + 584), 0, a3, (float **)v288);
  if ((v415 & 1) != 0)
  {
    v356 = *((_QWORD *)this + 932);
    if (v356)
      ParametricFilters::process(v356, *(float *const **)(*((_QWORD *)this + 370) + 680), 0, a3, (float **)v288);
    v357 = 0;
  }
  else
  {
LABEL_333:
    v357 = 1;
  }
  if ((_DWORD)v414)
  {
    for (kk = 0; kk != v414; ++kk)
    {
      if ((v415 & 1) != 0)
        vDSP_vadd(*(const float **)(*(_QWORD *)(*((_QWORD *)this + 370) + 488) + 8 * kk), 1, v170[kk], 1, (float *)v170[kk], 1, a3);
      if ((v419 & 1) != 0)
      {
        v359 = *((_QWORD *)this + 370);
        if (kk < *(unsigned int *)(v359 + 636))
          vDSP_vadd(*(const float **)(*(_QWORD *)(v359 + 584) + 8 * kk), 1, v170[kk], 1, (float *)v170[kk], 1, a3);
      }
      if ((v357 & 1) == 0)
      {
        v360 = *((_QWORD *)this + 370);
        if (kk < *(unsigned int *)(v360 + 732))
          vDSP_vadd(*(const float **)(*(_QWORD *)(v360 + 680) + 8 * kk), 1, v170[kk], 1, (float *)v170[kk], 1, a3);
      }
    }
  }
  if ((v415 & 1) != 0)
  {
    v361 = *((_QWORD *)this + 370);
    v362 = *(void ***)(v361 + 488);
    for (mm = *(void ***)(v361 + 496); v362 != mm; ++v362)
    {
      if (*v362)
        bzero(*v362, 4 * a3);
    }
    *(_BYTE *)(v361 + 536) = 1;
  }
  if ((v419 & 1) == 0)
  {
    if ((v357 & 1) != 0)
      goto LABEL_353;
LABEL_364:
    v368 = *((_QWORD *)this + 370);
    v369 = *(void ***)(v368 + 680);
    for (nn = *(void ***)(v368 + 688); v369 != nn; ++v369)
    {
      if (*v369)
        bzero(*v369, 4 * a3);
    }
    *(_BYTE *)(v368 + 728) = 1;
    if (v313)
      goto LABEL_354;
    goto LABEL_369;
  }
  v365 = *((_QWORD *)this + 370);
  v366 = *(void ***)(v365 + 584);
  for (i1 = *(void ***)(v365 + 592); v366 != i1; ++v366)
  {
    if (*v366)
      bzero(*v366, 4 * a3);
  }
  *(_BYTE *)(v365 + 632) = 1;
  if ((v357 & 1) == 0)
    goto LABEL_364;
LABEL_353:
  if (v313)
  {
LABEL_354:
    v315 = *((_DWORD *)this + 1861);
    v172 = 1;
LABEL_355:
    _CF = __CFADD__(v315, (_DWORD)a3);
    v364 = v315 + a3;
    if (_CF)
      v364 = -1;
    *((_DWORD *)this + 1861) = v364;
    goto LABEL_370;
  }
LABEL_369:
  *((_DWORD *)this + 1861) = 0;
  v172 = 1;
LABEL_370:
  v371 = atomic_load((unsigned __int8 *)this + 15145);
  if ((v371 & 1) != 0)
  {
    *(_QWORD *)buf = (char *)this + 15148;
    v372 = caulk::pooled_semaphore_mutex::try_lock((AUSpatialMixerV2 *)((char *)this + 15148));
    buf[8] = v372;
    if (v372)
    {
      if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)this + 1891) - *((_QWORD *)this + 1890)) >> 3) >= v414
        && (_DWORD)v414 != 0)
      {
        v374 = 0;
        v375 = (float **)v170;
        do
        {
          IR::FixedIntegerDelay::process((IR::FixedIntegerDelay *)(*((_QWORD *)this + 1890) + v374), *v375, *v375, a3);
          v374 += 56;
          ++v375;
        }
        while (56 * v414 != v374);
      }
    }
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)buf);
  }
  if (v412)
  {
    v376 = *((_QWORD *)this + 384);
    v377 = *((_DWORD *)this + 793);
    v378 = *((unsigned __int8 *)this + 3168);
    v379 = *((_DWORD *)this + 791);
    if (*((_DWORD *)this + 794) == v377)
    {
      v380 = (_QWORD *)((char *)this + 2904);
      if (*((_BYTE *)this + 2936))
        goto LABEL_393;
      v381 = *((float *)this + 728);
      v382 = *((float *)this + 729);
      v383 = *((float *)this + 730);
LABEL_387:
      v386 = *((float *)this + 731);
      v387 = *((float *)this + 732);
      v388 = *((float *)this + 733);
      if (vabds_f32(v381, v386) >= 0.5 || vabds_f32(v382, v387) >= 0.1 || vabds_f32(v383, v388) >= 0.1)
      {
        v381 = v386 + (float)((float)(v381 - v386) * 0.1);
        v382 = v387 + (float)((float)(v382 - v387) * 0.1);
        v383 = v388 + (float)((float)(v383 - v388) * 0.1);
      }
      else
      {
        *((_BYTE *)this + 2936) = 1;
      }
      *((float *)this + 731) = v381;
      *((float *)this + 732) = v382;
      *((float *)this + 733) = v383;
      v385 = v169;
      AUSpatialMixerV2::SetReverbFilter(this, v381, v382, v383, v379, v385);
LABEL_393:
      if (*v380 && v378)
        (*(void (**)(_QWORD, vDSP_Length, uint64_t, uint64_t, __n128, __n128))(*(_QWORD *)*v380 + 32))(*v380, a3, v376, v376, v184, v183);
      goto LABEL_397;
    }
    v381 = *((float *)this + 788);
    v382 = *((float *)this + 789);
    v383 = *((float *)this + 790);
    *((_DWORD *)this + 794) = v377;
    if (v378)
    {
      v380 = (_QWORD *)((char *)this + 2904);
      *((float *)this + 728) = v381;
      *((float *)this + 729) = v382;
      *((float *)this + 730) = v383;
      *((_BYTE *)this + 2936) = 0;
      goto LABEL_387;
    }
    *((_BYTE *)this + 2936) = 1;
    *(_QWORD *)((char *)this + 2924) = *((_QWORD *)this + 364);
    *((_DWORD *)this + 733) = *((_DWORD *)this + 730);
LABEL_397:
    v389 = *((_QWORD *)this + 370);
    if ((_DWORD)v414)
    {
      for (i2 = 0; i2 != v414; ++i2)
        vDSP_vadd(*(const float **)(*(_QWORD *)(v389 + 328) + i2 * 8), 1, v170[i2], 1, *(float **)(*(_QWORD *)(v389 + 328) + i2 * 8), 1, a3);
    }
    *(_BYTE *)(v389 + 376) = 0;
    goto LABEL_401;
  }
  v384 = atomic_load((unsigned __int8 *)this + 15145);
  if ((v384 & 1) != 0)
    goto LABEL_397;
LABEL_401:
  v391 = atomic_load((unsigned __int8 *)this + 2816);
  if ((v391 & 1) != 0)
  {
    v392 = (unsigned int *)*a7;
    if (!*((_BYTE *)this + 2792)
      || (v393 = *((_DWORD *)this + 702), v394 = atomic_load((unsigned int *)this + 703), v393 < v394 + 512))
    {
      if (*v392 >= 0x10)
        v395 = 16;
      else
        v395 = *v392;
      v396 = *((_DWORD *)this + 3771);
      v397 = 0.0;
      if ((v396 - 17) >= 0xFFFFFFF0)
        v397 = AUSM::kDiffuseIRCompensationGains[v396 - 1];
      if ((_DWORD)v395)
      {
        v398 = *((_QWORD *)this + 346);
        v399 = (const float **)(v392 + 4);
        v400 = (char *)this + 7784;
        while (*((_DWORD *)v399 - 2) == 1)
        {
          if (v400[448])
          {
            *(_QWORD *)buf = *(_QWORD *)(*((_QWORD *)this + 370) + 128);
            (*(void (**)(char *, uint64_t, _BYTE *, uint64_t, vDSP_Length, _QWORD, float))(*(_QWORD *)v400
                                                                                                  + 40))(v400, v398, buf, 1, a3, 0, v397);
            vDSP_vadd(*(const float **)buf, 1, *v399, 1, (float *)*v399, 1, a3);
          }
          v399 += 2;
          v400 += 456;
          if (!--v395)
            goto LABEL_415;
        }
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v403 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v403, OS_LOG_TYPE_DEBUG))
        {
          v406 = (_QWORD *)((char *)this + 3592);
          if (*((char *)this + 3615) < 0)
            v406 = (_QWORD *)*v406;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v406;
          *(_WORD *)v424 = 2080;
          *(_QWORD *)&v424[2] = "ProcessDiffuse";
          _os_log_debug_impl(&dword_1B5ED0000, v403, OS_LOG_TYPE_DEBUG, "[%s|%s] ERROR: diffuse does not support interleaved output formats", buf, 0x16u);
        }

      }
      else
      {
LABEL_415:
        if (*((_BYTE *)this + 2792))
        {
          v401 = *((_DWORD *)this + 702);
          _CF = __CFADD__(v401, (_DWORD)a3);
          v402 = v401 + a3;
          if (_CF)
            v402 = -1;
          *((_DWORD *)this + 702) = v402;
        }
        else
        {
          *((_DWORD *)this + 702) = 0;
          vDSP_vclr(*((float **)this + 346), 1, a3);
          *((_BYTE *)this + 2792) = 1;
        }
        *((_QWORD *)this + 350) = *((_QWORD *)this + 346);
      }
    }
  }
  result = 0;
  if (*(_BYTE *)(*((_QWORD *)this + 370) + 376))
    v404 = v172;
  else
    v404 = 1;
  if (v404)
    v405 = 0;
  else
    v405 = 16;
  *a2 = v405 | *a2 & 0xFFFFFFEF;
  return result;
}

void sub_1B61AA57C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](&a35, 0);
  _Unwind_Resume(a1);
}

double AUSM::AUFXWrapper::processInPlace(AUSM::AUFXWrapper *this, AudioUnitRenderActionFlags *ioActionFlags, UInt32 inNumberFrames, AudioBufferList *ioData)
{
  OpaqueAudioComponentInstance *v5;
  int v9;
  UInt32 v10;
  unint64_t mNumberBuffers;
  unsigned int v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  UInt32 mDataByteSize;
  size_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  int64_t v22;
  AudioBufferList *v23;
  UInt32 v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  double result;
  AudioBufferList *ioOutputBufferLists;
  AudioBufferList *inInputBufferLists[2];

  inInputBufferLists[1] = *(AudioBufferList **)MEMORY[0x1E0C80C00];
  v5 = *(OpaqueAudioComponentInstance **)this;
  if (v5 && *((_BYTE *)this + 124))
  {
    v9 = *((_DWORD *)this + 32);
    if (v9 == 2)
    {
      v10 = *((_DWORD *)this + 53);
      if (v10 >= ioData->mNumberBuffers)
        mNumberBuffers = ioData->mNumberBuffers;
      else
        mNumberBuffers = v10;
      **((_DWORD **)this + 20) = mNumberBuffers;
      v12 = (*((_DWORD *)this + 36) - *((_DWORD *)this + 34)) & 0xFFFFFFFC;
      if ((_DWORD)mNumberBuffers)
        v13 = v12 == 0;
      else
        v13 = 1;
      if (v13)
      {
        LODWORD(v15) = 0;
      }
      else
      {
        v14 = 0;
        v15 = 0;
        v16 = 0;
        do
        {
          mDataByteSize = ioData->mBuffers[v14].mDataByteSize;
          if (mDataByteSize >= v12 - v16)
            v18 = v12 - v16;
          else
            v18 = mDataByteSize;
          v19 = *((_QWORD *)this + 20) + v14 * 16;
          *(_DWORD *)(v19 + 8) = ioData->mBuffers[v14].mNumberChannels;
          *(_DWORD *)(v19 + 12) = v18;
          v20 = (void *)(*((_QWORD *)this + 17) + v16);
          *(_QWORD *)(v19 + 16) = v20;
          memcpy(v20, ioData->mBuffers[v14].mData, v18);
          if (++v15 >= mNumberBuffers)
            break;
          v16 += v18;
          ++v14;
        }
        while (v16 < v12);
      }
      if (v15 < ioData->mNumberBuffers && v15 < mNumberBuffers)
        bzero((void *)(*((_QWORD *)this + 20) + 16 * v15 + 8), 16 * (mNumberBuffers + ~(_DWORD)v15) + 16);
      v21 = (void *)*((_QWORD *)this + 23);
      v22 = *((_QWORD *)this + 24) - (_QWORD)v21;
      if (v22 >= 1)
        bzero(v21, v22);
      v23 = (AudioBufferList *)*((_QWORD *)this + 20);
      if (v23->mBuffers[0].mNumberChannels == 1 && *((_DWORD *)this + 52) == 4)
      {
        v24 = v23->mNumberBuffers;
        v25 = *((_QWORD *)this + 23);
        if (v23->mNumberBuffers >= ((unint64_t)(*((_QWORD *)this + 24) - v25) >> 3))
          v24 = (unint64_t)(*((_QWORD *)this + 24) - v25) >> 3;
        if (v24)
        {
          v26 = 0;
          v27 = 16;
          do
          {
            *(_QWORD *)(v25 + 8 * v26++) = *(_QWORD *)((char *)&v23->mNumberBuffers + v27);
            v23 = (AudioBufferList *)*((_QWORD *)this + 20);
            LODWORD(v28) = v23->mNumberBuffers;
            v25 = *((_QWORD *)this + 23);
            v29 = (unint64_t)(*((_QWORD *)this + 24) - v25) >> 3;
            if (v23->mNumberBuffers >= v29)
              v28 = v29;
            else
              v28 = v28;
            v27 += 16;
          }
          while (v26 < v28);
        }
      }
      ioOutputBufferLists = ioData;
      inInputBufferLists[0] = v23;
      AudioUnitProcessMultiple(*(AudioUnit *)this, ioActionFlags, (const AudioTimeStamp *)((char *)this + 8), inNumberFrames, 1u, (const AudioBufferList **)inInputBufferLists, 1u, &ioOutputBufferLists);
    }
    else
    {
      if (v9 != 1)
        return result;
      AudioUnitProcess(v5, ioActionFlags, (const AudioTimeStamp *)((char *)this + 8), inNumberFrames, ioData);
    }
    result = *((double *)this + 1) + (double)inNumberFrames;
    *((double *)this + 1) = result;
  }
  return result;
}

uint64_t AUSM::Metadata::prepareParameterTracks(AUSM::Metadata *this, unint64_t a2, unint64_t a3)
{
  std::string *v6;
  const std::string *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const std::string *v19;
  unsigned __int8 *v20;
  uint64_t v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  __int128 v33;
  char *v34;
  char *v35;
  _BYTE *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;

  v6 = (std::string *)((char *)this + 200);
  v7 = (const std::string *)((char *)this + 104);
  v8 = *((unsigned __int8 *)this + 223);
  if ((v8 & 0x80u) == 0)
    v9 = *((unsigned __int8 *)this + 223);
  else
    v9 = *((_QWORD *)this + 26);
  v10 = *((unsigned __int8 *)this + 127);
  v11 = v10;
  v12 = *((_QWORD *)this + 14);
  if ((v10 & 0x80u) == 0)
    v13 = *((unsigned __int8 *)this + 127);
  else
    v13 = *((_QWORD *)this + 14);
  if (v9 == v13)
  {
    if ((v10 & 0x80u) == 0)
      v14 = (unsigned __int8 *)this + 104;
    else
      v14 = (unsigned __int8 *)v7->__r_.__value_.__r.__words[0];
    if ((v8 & 0x80) != 0)
    {
      if (!memcmp(v6->__r_.__value_.__l.__data_, v14, *((_QWORD *)this + 26)))
        goto LABEL_19;
    }
    else
    {
      if (!*((_BYTE *)this + 223))
        goto LABEL_19;
      v15 = (unsigned __int8 *)this + 200;
      while (*v15 == *v14)
      {
        ++v15;
        ++v14;
        if (!--v8)
          goto LABEL_19;
      }
    }
  }
  std::string::operator=(v6, v7);
  v10 = *((unsigned __int8 *)this + 127);
  v12 = *((_QWORD *)this + 14);
  v11 = *((_BYTE *)this + 127);
LABEL_19:
  v16 = *((unsigned __int8 *)this + 151);
  if ((v16 & 0x80u) == 0)
    v17 = *((unsigned __int8 *)this + 151);
  else
    v17 = *((_QWORD *)this + 17);
  if (v11 >= 0)
    v18 = v10;
  else
    v18 = v12;
  if (v17 == v18)
  {
    if (v11 >= 0)
      v19 = v7;
    else
      v19 = (const std::string *)v7->__r_.__value_.__r.__words[0];
    if ((v16 & 0x80) != 0)
    {
      if (!memcmp(*((const void **)this + 16), v19, *((_QWORD *)this + 17)))
        goto LABEL_37;
    }
    else
    {
      if (!*((_BYTE *)this + 151))
        goto LABEL_37;
      v20 = (unsigned __int8 *)this + 128;
      while (*v20 == v19->__r_.__value_.__s.__data_[0])
      {
        ++v20;
        v19 = (const std::string *)((char *)v19 + 1);
        if (!--v16)
          goto LABEL_37;
      }
    }
  }
  std::string::operator=((std::string *)((char *)this + 128), v7);
LABEL_37:
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = a2;
  v21 = *((_QWORD *)this + 22);
  v22 = (char *)*((_QWORD *)this + 23);
  v23 = (uint64_t)&v22[-v21] >> 5;
  if (a2 <= v23)
  {
    if (a2 >= v23)
      goto LABEL_58;
    v34 = (char *)(v21 + 32 * a2);
    goto LABEL_57;
  }
  v24 = *((_QWORD *)this + 24);
  if (a2 - v23 <= (v24 - (uint64_t)v22) >> 5)
  {
    v34 = &v22[32 * (a2 - v23)];
    do
    {
      *(_QWORD *)v22 = 0;
      *((_QWORD *)v22 + 1) = 0;
      *((_OWORD *)v22 + 1) = xmmword_1B66A0960;
      v22 += 32;
    }
    while (v22 != v34);
LABEL_57:
    *((_QWORD *)this + 23) = v34;
    goto LABEL_58;
  }
  if (a2 >> 59)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  v25 = v24 - v21;
  v26 = v25 >> 4;
  if (v25 >> 4 <= a2)
    v26 = a2;
  if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFE0)
    v27 = 0x7FFFFFFFFFFFFFFLL;
  else
    v27 = v26;
  if (v27 >> 59)
LABEL_77:
    std::__throw_bad_array_new_length[abi:ne180100]();
  v28 = (char *)operator new(32 * v27);
  v29 = &v28[32 * v23];
  v30 = &v28[32 * a2];
  v31 = v29;
  do
  {
    *(_QWORD *)v31 = 0;
    *((_QWORD *)v31 + 1) = 0;
    *((_OWORD *)v31 + 1) = xmmword_1B66A0960;
    v31 += 32;
  }
  while (v31 != v30);
  v32 = (char *)*((_QWORD *)this + 22);
  if (v22 != v32)
  {
    do
    {
      v33 = *((_OWORD *)v22 - 1);
      *((_OWORD *)v29 - 2) = *((_OWORD *)v22 - 2);
      *((_OWORD *)v29 - 1) = v33;
      v29 -= 32;
      v22 -= 32;
    }
    while (v22 != v32);
    v22 = (char *)*((_QWORD *)this + 22);
  }
  *((_QWORD *)this + 22) = v29;
  *((_QWORD *)this + 23) = v30;
  *((_QWORD *)this + 24) = &v28[32 * v27];
  if (v22)
    operator delete(v22);
LABEL_58:
  *((_QWORD *)this + 19) = *((_QWORD *)this + 22);
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = a3;
  v36 = (_BYTE *)*((_QWORD *)this + 31);
  v35 = (char *)*((_QWORD *)this + 32);
  v37 = (v35 - v36) >> 4;
  if (a3 <= v37)
  {
    if (a3 >= v37)
      goto LABEL_76;
    v47 = &v36[16 * a3];
LABEL_75:
    *((_QWORD *)this + 32) = v47;
    goto LABEL_76;
  }
  v38 = a3 - v37;
  v39 = *((_QWORD *)this + 33);
  if (a3 - v37 <= (v39 - (uint64_t)v35) >> 4)
  {
    bzero(*((void **)this + 32), 16 * v38);
    v47 = &v35[16 * v38];
    goto LABEL_75;
  }
  if (a3 >> 60)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  v40 = v39 - (_QWORD)v36;
  v41 = v40 >> 3;
  if (v40 >> 3 <= a3)
    v41 = a3;
  if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF0)
    v42 = 0xFFFFFFFFFFFFFFFLL;
  else
    v42 = v41;
  if (v42 >> 60)
    goto LABEL_77;
  v43 = (char *)operator new(16 * v42);
  v44 = &v43[16 * v37];
  v45 = &v43[16 * v42];
  bzero(v44, 16 * v38);
  v46 = &v44[16 * v38];
  if (v35 != v36)
  {
    do
    {
      *((_OWORD *)v44 - 1) = *((_OWORD *)v35 - 1);
      v44 -= 16;
      v35 -= 16;
    }
    while (v35 != v36);
    v35 = (char *)*((_QWORD *)this + 31);
  }
  *((_QWORD *)this + 31) = v44;
  *((_QWORD *)this + 32) = v46;
  *((_QWORD *)this + 33) = v45;
  if (v35)
    operator delete(v35);
LABEL_76:
  *((_QWORD *)this + 28) = *((_QWORD *)this + 31);
  return (uint64_t)this + 128;
}

BOOL AUSM::ParameterControlPointContainer::insertUnique(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  int v12;
  _QWORD *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v3 = a1;
  v16 = *MEMORY[0x1E0C80C00];
  v4 = a1[4];
  v5 = a1[5];
  if (v4 >= v5)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v10 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)v3 + 23) < 0)
        v3 = (_QWORD *)*v3;
      v12 = 136315394;
      v13 = v3;
      v14 = 2080;
      v15 = "insertUnique";
      _os_log_debug_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEBUG, "[%s|%s] Can't insert a new control point: not enough capacity", (uint8_t *)&v12, 0x16u);
    }

  }
  else
  {
    v6 = a1[3];
    v7 = (_QWORD *)(v6 + 16 * v4);
    if (v4)
    {
      v8 = 16 * v4;
      v9 = a1[3];
      while (*(_QWORD *)v9 != a2 || *(_DWORD *)(v9 + 8) != (_DWORD)a3 || *(float *)(v9 + 12) != *((float *)&a3 + 1))
      {
        v9 += 16;
        v8 -= 16;
        if (!v8)
        {
          v9 = v6 + 16 * v4;
          break;
        }
      }
    }
    else
    {
      v9 = a1[3];
    }
    if (v4 == (v9 - v6) >> 4)
    {
      *v7 = a2;
      v7[1] = a3;
      a1[4] = v4 + 1;
    }
  }
  return v4 < v5;
}

float AUSM::ParameterControlPointContainer::lastKnownValueForParameter(uint64_t *a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  uint64_t *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v3 = a1;
  v20 = *MEMORY[0x1E0C80C00];
  v4 = a1[4];
  v5 = 16 * v4 - 16;
  while (v4)
  {
    --v4;
    v6 = a1[3];
    v7 = *(_QWORD *)(v6 + v5);
    v5 -= 16;
    if (v7 == a2)
      return *(float *)(v6 + 16 * v4 + 12);
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v9 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)v3 + 23) < 0)
      v3 = (uint64_t *)*v3;
    if (a2)
    {
      v11 = *(_DWORD *)(a2 + 4);
      v10 = *(_DWORD *)(a2 + 8);
    }
    else
    {
      v10 = -1;
      v11 = -1;
    }
    v12 = 136315906;
    v13 = v3;
    v14 = 2080;
    v15 = "lastKnownValueForParameter";
    v16 = 1024;
    v17 = v10;
    v18 = 1024;
    v19 = v11;
    _os_log_debug_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "[%s|%s] Can't find a parameter value for parameter = %u, element = %u", (uint8_t *)&v12, 0x22u);
  }

  return 0.0;
}

uint64_t AUSM::ParameterControlPointContainer::computeIntermediateParameterValueAndAdvance(uint64_t *a1, int a2, uint64_t a3)
{
  unint64_t v3;
  float v4;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  NSObject *v21;
  int v23;
  int v24;
  int v25;
  const char *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a3 + 16);
  v4 = 0.0;
  if (v3 >= a1[4])
    goto LABEL_26;
  v6 = a1;
  v7 = a1[3];
  v8 = *(_QWORD *)(a3 + 24);
  if (v3 != v8)
  {
    if (v3 > v8)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v21 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        if (*((char *)v6 + 23) < 0)
          v6 = (uint64_t *)*v6;
        v30 = *(_DWORD *)(a3 + 4);
        v29 = *(_DWORD *)(a3 + 8);
        v31 = 136315906;
        v32 = v6;
        v33 = 2080;
        v34 = "computeIntermediateParameterValueAndAdvance";
        v35 = 1024;
        v36 = v29;
        v37 = 1024;
        v38 = v30;
        v26 = "[%s|%s] Inconsistent indexes for parameter = %u, element = %u";
LABEL_35:
        _os_log_debug_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_DEBUG, v26, (uint8_t *)&v31, 0x22u);
      }
    }
    else
    {
      v11 = *(_DWORD *)(v7 + 16 * v3 + 8);
      if (a2 < v11)
        goto LABEL_26;
      if (a2 == v11)
      {
        v12 = v7 + 16 * v3;
        v4 = *(float *)(v12 + 12);
        v13 = (uint64_t *)(v12 + 16);
        while (++v3 <= v8)
        {
          v14 = *v13;
          v13 += 2;
          if (v14 == a3)
          {
            v15 = v7 + 16 * v3;
            if (*(_DWORD *)(v15 + 8) == a2)
            {
              *(_QWORD *)(a3 + 16) = v3;
              v4 = *(float *)(v15 + 12);
            }
            goto LABEL_5;
          }
        }
        goto LABEL_5;
      }
      v16 = (uint64_t *)(v7 + 16 * v3 + 16);
      v17 = *(_QWORD *)(a3 + 16);
      while (++v17 <= v8)
      {
        v18 = *v16;
        v16 += 2;
        if (v18 == a3)
        {
          v19 = *(_DWORD *)(v7 + 16 * v17 + 8);
          if (v19 < a2)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v20 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
            {
              if (*((char *)v6 + 23) < 0)
                v6 = (uint64_t *)*v6;
              v28 = *(_DWORD *)(a3 + 4);
              v27 = *(_DWORD *)(a3 + 8);
              v31 = 136315906;
              v32 = v6;
              v33 = 2080;
              v34 = "computeIntermediateParameterValueAndAdvance";
              v35 = 1024;
              v36 = v27;
              v37 = 1024;
              v38 = v28;
              _os_log_debug_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_DEBUG, "[%s|%s] Can't compute the intermediate parameter value for parameter = %u, element = %u", (uint8_t *)&v31, 0x22u);
            }

            v10 = 0;
            *(_QWORD *)(a3 + 16) = v17;
            return v10 | LODWORD(v4);
          }
          if (v19 == a2)
          {
            *(_QWORD *)(a3 + 16) = v17;
            v9 = v7 + 16 * v17;
            goto LABEL_4;
          }
          v4 = *(float *)(v7 + 16 * v17 + 12);
          v23 = v19 - v11;
          if (v23)
            v4 = *(float *)(v7 + 16 * v3 + 12)
               + (float)((float)((float)(a2 - v11) / (float)v23) * (float)(v4 - *(float *)(v7 + 16 * v3 + 12)));
          goto LABEL_5;
        }
      }
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v21 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        if (*((char *)v6 + 23) < 0)
          v6 = (uint64_t *)*v6;
        v25 = *(_DWORD *)(a3 + 4);
        v24 = *(_DWORD *)(a3 + 8);
        v31 = 136315906;
        v32 = v6;
        v33 = 2080;
        v34 = "computeIntermediateParameterValueAndAdvance";
        v35 = 1024;
        v36 = v24;
        v37 = 1024;
        v38 = v25;
        v26 = "[%s|%s] Inconsistent data for parameter = %u, element = %u";
        goto LABEL_35;
      }
    }

    goto LABEL_26;
  }
  v9 = v7 + 16 * v3;
  if (*(_DWORD *)(v9 + 8) > a2)
  {
LABEL_26:
    v10 = 0;
    return v10 | LODWORD(v4);
  }
LABEL_4:
  v4 = *(float *)(v9 + 12);
LABEL_5:
  v10 = 0x100000000;
  return v10 | LODWORD(v4);
}

uint64_t AUSM::ParameterTrackContainer::findTargetTimeCue(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;

  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    return 0x7FFFFFFFLL;
  v3 = 0;
  v4 = *(_QWORD *)(a1 + 24);
  result = 0x7FFFFFFFLL;
  do
  {
    v6 = v4 + 32 * v3;
    v7 = *(_QWORD *)(v6 + 16);
    v8 = (uint64_t *)(a2 + 16 + 16 * v7);
    while ((unint64_t)++v7 <= *(_QWORD *)(v6 + 24))
    {
      v9 = *v8;
      v8 += 2;
      if (v9 == v6)
      {
        v10 = *(_DWORD *)(a2 + 16 * v7 + 8);
        if (v10 >= (int)result)
          result = result;
        else
          result = v10;
        break;
      }
    }
    ++v3;
  }
  while (v3 != v2);
  return result;
}

void *ausdk::AUBufferList::SetBufferList(ausdk::AUBufferList *this, const AudioBufferList *a2)
{
  uint64_t mNumberBuffers;
  ausdk::AUException *exception;
  _DWORD v5[2];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  mNumberBuffers = a2->mNumberBuffers;
  if (*((_DWORD *)this + 4) < mNumberBuffers)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v5[0] = 67109120;
      v5[1] = -1;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", (uint8_t *)v5, 8u);
    }
    exception = (ausdk::AUException *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(exception, -1);
  }
  *(_DWORD *)this = 2;
  return memcpy((void *)(*((_QWORD *)this + 1) + 48), a2, (16 * mNumberBuffers) | 8);
}

void sub_1B61AB3A0(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t caulk::concurrent::messenger::enqueue_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_3>(caulk::concurrent::messenger *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)*MEMORY[0x1E0DDB688] + 16))(*MEMORY[0x1E0DDB688], 40, 8);
  *(_DWORD *)(v4 + 16) = 0;
  v5 = *a2;
  *a2 = 0;
  *(_QWORD *)(v4 + 24) = v5;
  *(_QWORD *)v4 = &off_1E69CA6C0;
  *(_QWORD *)(v4 + 8) = 0;
  return caulk::concurrent::messenger::enqueue(a1, (caulk::concurrent::message *)v4);
}

void AUSpatialMixerV2::SetReverbFilter(AUSpatialMixerV2 *this, float a2, float a3, float a4, int a5, float a6)
{
  double v7;
  BOOL v8;
  double v9;
  __double2 v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  __double2 v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  int v24;
  double v25;
  double v26;
  int v27;
  uint64_t v28;
  double v29;
  double v30;
  float v31;
  unsigned int v32;
  double v35;
  double v36;
  uint64_t v37;
  double v38;
  double v39;

  v7 = a2 / (a6 * 0.5);
  v8 = v7 <= 0.99;
  v9 = v7 * 3.14159265;
  if (!v8)
    v9 = 3.11017673;
  v35 = 0.0;
  v36 = 0.0;
  v38 = 0.0;
  v39 = 0.0;
  v37 = 0x3FF0000000000000;
  switch(a5)
  {
    case 1:
      if (v9 <= 0.0)
        goto LABEL_20;
      v10 = __sincos_stret(fmin(v9, 3.11017673));
      v11 = __exp10(0.0);
      v12 = 0.5 - v10.__cosval * 0.5;
      v13 = 1.0 / (v10.__sinval * 0.707106781 + 1.0);
      v14 = v13 * v11;
      v35 = v10.__cosval * -2.0 * v13;
      v36 = v13 - v10.__sinval * 0.707106781 * v13;
      v15 = v12 * v14;
      v16 = v12 * (v14 + v14);
      goto LABEL_8;
    case 2:
      if (v9 <= 0.0)
        goto LABEL_20;
      v17 = __sincos_stret(fmin(v9, 3.11017673));
      v18 = __exp10(0.0);
      v19 = v17.__cosval * 0.5 + 0.5;
      v20 = 1.0 / (v17.__sinval * 0.707106781 + 1.0);
      v21 = v20 * v18;
      v35 = v17.__cosval * -2.0 * v20;
      v36 = v20 - v17.__sinval * 0.707106781 * v20;
      v15 = v19 * v21;
      v16 = v19 * -2.0 * v21;
LABEL_8:
      v37 = *(_QWORD *)&v15;
      v38 = v16;
      v39 = v15;
      break;
    case 3:
      v22 = a3;
      v23 = 0.0;
      v24 = 1;
      goto LABEL_22;
    case 4:
      v22 = a3;
      v23 = 0.0;
      v24 = 2;
      goto LABEL_22;
    case 5:
      v22 = a3;
      v23 = 0.0;
      v24 = 3;
      goto LABEL_22;
    case 6:
      v22 = a3;
      v23 = 0.0;
      v24 = 4;
      goto LABEL_22;
    case 7:
      if (v9 <= 0.0)
        goto LABEL_20;
      v25 = a4;
      v26 = fmin(v9, 3.11017673);
      v27 = 7;
      goto LABEL_19;
    case 8:
      if (v9 <= 0.0)
      {
LABEL_20:
        v37 = 0x3FF0000000000000;
      }
      else
      {
        v25 = a4;
        v26 = fmin(v9, 3.11017673);
        v27 = 8;
LABEL_19:
        BiquadCoefficients::SetPriv((BiquadCoefficients *)&v35, v27, v26, 0.707106781, v25);
      }
      break;
    case 9:
      v22 = a3;
      v23 = a4;
      v24 = 7;
      goto LABEL_22;
    case 10:
      v22 = a3;
      v23 = a4;
      v24 = 8;
      goto LABEL_22;
    default:
      v22 = a3;
      v23 = a4;
      v24 = 11;
LABEL_22:
      BiquadCoefficients::SetBW((BiquadCoefficients *)&v35, v24, v9, v22, v23);
      break;
  }
  v28 = *((_QWORD *)this + 363);
  if (v28)
  {
    v29 = (*(double (**)(uint64_t, uint64_t, double *))(*(_QWORD *)v28 + 16))(v28, 1, &v35);
    BiquadCoefficients::GetT((BiquadCoefficients *)&v35, v29);
    v31 = v30;
    v32 = v31;
    if ((SLODWORD(v31) <= -1 || ((LODWORD(v31) & 0x7FFFFFFFu) - 0x800000) >> 24 >= 0x7F)
      && (LODWORD(v31) - 1) >= 0x7FFFFF)
    {
      v32 = 0;
    }
    *((_DWORD *)this + 735) = v32;
  }
}

void caulk::concurrent::details::rt_message_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_3>::~rt_message_call(uint64_t *a1)
{
  *a1 = (uint64_t)&off_1E69CA6E8;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
}

{
  *a1 = (uint64_t)&off_1E69CA6E8;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t caulk::concurrent::details::rt_message_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_3>::perform(uint64_t *a1)
{
  uint64_t *v2;

  v2 = a1 + 3;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  *a1 = (uint64_t)&off_1E69CA6E8;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](v2, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
  return (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)*MEMORY[0x1E0DDB688] + 24))(*MEMORY[0x1E0DDB688], a1, 40, 8);
}

void caulk::concurrent::details::message_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_3>::~message_call(uint64_t *a1)
{
  *a1 = (uint64_t)&off_1E69CA6E8;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
}

{
  *a1 = (uint64_t)&off_1E69CA6E8;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t *caulk::concurrent::details::message_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_3>::perform(uint64_t a1)
{
  return std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)(a1 + 24), 0);
}

void caulk::concurrent::details::rt_message_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_0>::~rt_message_call(uint64_t *a1)
{
  *a1 = (uint64_t)&off_1E69CA698;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
}

{
  *a1 = (uint64_t)&off_1E69CA698;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t caulk::concurrent::details::rt_message_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_0>::perform(uint64_t *a1)
{
  uint64_t *v2;

  v2 = a1 + 3;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  *a1 = (uint64_t)&off_1E69CA698;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](v2, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
  return (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)*MEMORY[0x1E0DDB688] + 24))(*MEMORY[0x1E0DDB688], a1, 40, 8);
}

void caulk::concurrent::details::message_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_0>::~message_call(uint64_t *a1)
{
  *a1 = (uint64_t)&off_1E69CA698;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
}

{
  *a1 = (uint64_t)&off_1E69CA698;
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a1 + 3, 0);
  caulk::concurrent::message::~message((caulk::concurrent::message *)a1);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t *caulk::concurrent::details::message_call<AUSpatialMixerV2::ProcessMultipleBufferListsPrivate(unsigned int &,unsigned int,unsigned int,AudioBufferList const**,unsigned int,AudioBufferList**,AudioTimeStamp const&)::$_0>::perform(uint64_t a1)
{
  return std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)(a1 + 24), 0);
}

double AUSM::eulerToAUCoordQuaternion(AUSM *this, float a2, float a3, float a4)
{
  __float2 v6;
  __float2 v7;
  __float2 v8;
  double v9;

  v6 = __sincosf_stret((float)(a2 * 0.017453) * 0.5);
  v7 = __sincosf_stret((float)(a3 * 0.017453) * 0.5);
  v8 = __sincosf_stret((float)(a4 * 0.017453) * 0.5);
  *(float *)&v9 = (float)(v8.__sinval * (float)(v6.__cosval * v7.__cosval))
                - (float)(v8.__cosval * (float)(v6.__sinval * v7.__sinval));
  *((float *)&v9 + 1) = (float)(v6.__sinval * (float)(v7.__cosval * v8.__sinval))
                      + (float)((float)(v7.__sinval * v8.__cosval) * v6.__cosval);
  return v9;
}

uint64_t AUSpatialMixerV2InputElement::SetDecorrFilterLengthsOnReverbSend(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v6;
  _QWORD **v7;
  uint64_t v8;
  _QWORD **i;

  v6 = a1 + 720;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a1 + 720);
  v7 = *(_QWORD ***)(a1 + 256);
  if ((a3 & 0x80000000) != 0)
  {
    for (i = *(_QWORD ***)(a1 + 248); i != v7; ++i)
      AUSpatialMixerV2ChannelProcessor::setDecorrFilterLengthsOnReverbSend(*i, a2);
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 248);
    if (a3 < (unint64_t)(((uint64_t)v7 - v8) >> 3))
      AUSpatialMixerV2ChannelProcessor::setDecorrFilterLengthsOnReverbSend(*(_QWORD **)(v8 + 8 * a3), a2);
  }
  return caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v6);
}

void sub_1B61ABB14(_Unwind_Exception *a1)
{
  uint64_t v1;

  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t AUSpatialMixerV2InputElement::SetDecorrFilterCoeffsOnReverbSend(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v6;
  _QWORD **v7;
  uint64_t v8;
  _QWORD **i;

  v6 = a1 + 720;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a1 + 720);
  v7 = *(_QWORD ***)(a1 + 256);
  if ((a3 & 0x80000000) != 0)
  {
    for (i = *(_QWORD ***)(a1 + 248); i != v7; ++i)
      AUSpatialMixerV2ChannelProcessor::setDecorrFilterCoeffsOnReverbSend(*i, a2);
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 248);
    if (a3 < (unint64_t)(((uint64_t)v7 - v8) >> 3))
      AUSpatialMixerV2ChannelProcessor::setDecorrFilterCoeffsOnReverbSend(*(_QWORD **)(v8 + 8 * a3), a2);
  }
  return caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v6);
}

void sub_1B61ABBC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v1);
  _Unwind_Resume(a1);
}

void applesauce::CF::DictionaryRef::from_get_noexcept(applesauce::CF::DictionaryRef *this, CFTypeRef cf)
{
  CFTypeID v4;

  if (cf && (CFRetain(cf), v4 = CFGetTypeID(cf), v4 != CFDictionaryGetTypeID()))
  {
    *(_QWORD *)this = 0;
    CFRelease(cf);
  }
  else
  {
    *(_QWORD *)this = cf;
  }
}

uint64_t AUSM::ExclusionZone::exclusionZonesFromDictionary(AUSM::ExclusionZone *this, const __CFDictionary **a2)
{
  uint64_t result;
  const void *v5;
  const void *v6;
  CFTypeID v7;
  uint64_t Count;
  float *v9;
  unint64_t v10;
  const __CFDictionary *v11;
  const __CFNumber *v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  unint64_t v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  unint64_t v28;
  float *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  float *v38;
  float *v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  std::runtime_error *exception;
  CFTypeRef cf;
  const __CFDictionary *v46;
  const void *v47;
  char v48;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  if (!*a2)
    goto LABEL_56;
  result = applesauce::CF::details::has_key<char const(&)[15]>(*a2, "ExclusionZones");
  if (!(_DWORD)result)
    return result;
  if (!*a2)
  {
LABEL_56:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
LABEL_57:
  }
  v5 = applesauce::CF::details::at_key<char const(&)[15]>(*a2, "ExclusionZones");
  if (v5)
  {
    v6 = v5;
    CFRetain(v5);
    v7 = CFGetTypeID(v6);
    if (v7 == CFArrayGetTypeID())
    {
      v47 = v6;
      v48 = 1;
      CFRetain(v6);
      Count = CFArrayGetCount((CFArrayRef)v6);
      if (Count)
      {
        v9 = 0;
        v10 = 0;
        while (1)
        {
          cf = 0;
          applesauce::CF::at_or<applesauce::CF::DictionaryRef>(&v46, (CFArrayRef)v6, v10, &cf);
          if (cf)
            CFRelease(cf);
          v11 = v46;
          if (!v46)
          {
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Could not construct");
            goto LABEL_57;
          }
          v12 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[16]>(v46, "coordinatesType");
          if (!v12 || (v13 = applesauce::CF::convert_as<unsigned int,0>(v12), (v13 & 0xFF00000000) == 0))
          {
LABEL_46:
            CFRelease(v11);
            v20 = v9;
            goto LABEL_47;
          }
          if ((_DWORD)v13 != 1)
            break;
          LODWORD(cf) = 0;
          v21 = applesauce::CF::at_or<float,char const(&)[5]>(v11, "minX", (uint64_t)&cf);
          LODWORD(cf) = 0;
          v22 = applesauce::CF::at_or<float,char const(&)[5]>(v11, "maxX", (uint64_t)&cf);
          LODWORD(cf) = 0;
          v23 = applesauce::CF::at_or<float,char const(&)[5]>(v11, "minY", (uint64_t)&cf);
          LODWORD(cf) = 0;
          v24 = applesauce::CF::at_or<float,char const(&)[5]>(v11, "maxY", (uint64_t)&cf);
          LODWORD(cf) = 0;
          v25 = applesauce::CF::at_or<float,char const(&)[5]>(v11, "minZ", (uint64_t)&cf);
          LODWORD(cf) = 0;
          v26 = applesauce::CF::at_or<float,char const(&)[5]>(v11, "maxZ", (uint64_t)&cf);
          v27 = v26;
          v28 = *((_QWORD *)this + 2);
          if ((unint64_t)v9 < v28)
          {
            *(_DWORD *)v9 = 1;
            v9[1] = v21;
            v9[2] = v22;
            v9[3] = v23;
            v9[4] = v24;
            v20 = v9 + 7;
            v9[5] = v25;
            v9[6] = v26;
            goto LABEL_45;
          }
          v29 = *(float **)this;
          v35 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v9 - *(_QWORD *)this) >> 2);
          v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) > 0x924924924924924)
LABEL_58:
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          v37 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v28 - (_QWORD)v29) >> 2);
          if (2 * v37 > v36)
            v36 = 2 * v37;
          if (v37 >= 0x492492492492492)
            v33 = 0x924924924924924;
          else
            v33 = v36;
          if (v33)
            v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v33);
          else
            v34 = 0;
          v38 = (float *)(v33 + 28 * v35);
          *(_DWORD *)v38 = 1;
          v38[1] = v21;
          v38[2] = v22;
          v38[3] = v23;
          v38[4] = v24;
          v38[5] = v25;
          v38[6] = v27;
          v39 = v38;
          if (v9 != v29)
          {
            do
            {
              v41 = *(_OWORD *)(v9 - 7);
              *((_OWORD *)v39 - 1) = *((_OWORD *)v9 - 1);
              *(_OWORD *)(v39 - 7) = v41;
              v39 -= 7;
              v9 -= 7;
            }
            while (v9 != v29);
LABEL_42:
            v9 = v29;
          }
LABEL_43:
          v20 = v38 + 7;
          *(_QWORD *)this = v39;
          *((_QWORD *)this + 1) = v38 + 7;
          *((_QWORD *)this + 2) = v33 + 28 * v34;
          if (v9)
            operator delete(v9);
LABEL_45:
          *((_QWORD *)this + 1) = v20;
          v11 = v46;
          v9 = v20;
          if (v46)
            goto LABEL_46;
LABEL_47:
          ++v10;
          v9 = v20;
          if (v10 == Count)
            goto LABEL_48;
        }
        if ((_DWORD)v13)
          goto LABEL_46;
        LODWORD(cf) = 0;
        v14 = applesauce::CF::at_or<float,char const(&)[13]>(v11, "minElevation", (uint64_t)&cf);
        LODWORD(cf) = 0;
        v15 = applesauce::CF::at_or<float,char const(&)[13]>(v11, "maxElevation", (uint64_t)&cf);
        LODWORD(cf) = 0;
        v16 = applesauce::CF::at_or<float,char const(&)[11]>(v11, "minAzimuth", (uint64_t)&cf);
        LODWORD(cf) = 0;
        v17 = applesauce::CF::at_or<float,char const(&)[11]>(v11, "maxAzimuth", (uint64_t)&cf);
        v18 = v17;
        v19 = *((_QWORD *)this + 2);
        if ((unint64_t)v9 < v19)
        {
          *v9 = 0.0;
          v9[1] = v14;
          v9[2] = v15;
          v20 = v9 + 7;
          v9[3] = v16;
          v9[4] = v17;
          goto LABEL_45;
        }
        v29 = *(float **)this;
        v30 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v9 - *(_QWORD *)this) >> 2);
        v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) > 0x924924924924924)
          goto LABEL_58;
        v32 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v19 - (_QWORD)v29) >> 2);
        if (2 * v32 > v31)
          v31 = 2 * v32;
        if (v32 >= 0x492492492492492)
          v33 = 0x924924924924924;
        else
          v33 = v31;
        if (v33)
          v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v33);
        else
          v34 = 0;
        v38 = (float *)(v33 + 28 * v30);
        *v38 = 0.0;
        v38[1] = v14;
        v38[2] = v15;
        v38[3] = v16;
        v38[4] = v18;
        v39 = v38;
        if (v9 == v29)
          goto LABEL_43;
        do
        {
          v40 = *(_OWORD *)(v9 - 7);
          *((_OWORD *)v39 - 1) = *((_OWORD *)v9 - 1);
          *(_OWORD *)(v39 - 7) = v40;
          v39 -= 7;
          v9 -= 7;
        }
        while (v9 != v29);
        goto LABEL_42;
      }
LABEL_48:
      CFRelease(v6);
      goto LABEL_51;
    }
    CFRelease(v6);
  }
  LOBYTE(v47) = 0;
  v48 = 0;
LABEL_51:
  result = std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v47);
  v43 = *(_QWORD *)this;
  v42 = *((_QWORD *)this + 1);
  while (v43 != v42)
  {
    result = AUSM::ExclusionZone::clampValues(v43);
    v43 += 28;
  }
  return result;
}

void sub_1B61AC17C(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

uint64_t AUSpatialMixerV2InputElement::SetExclusionZones(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  _QWORD *v8;
  _BYTE *v9;
  uint64_t v10;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;

  v4 = a1 + 720;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a1 + 720);
  v5 = *(uint64_t **)(a1 + 248);
  v6 = *(uint64_t **)(a1 + 256);
  while (v5 != v6)
  {
    v7 = AUSpatialMixerV2ChannelProcessor::setExclusionZones(*v5, a2);
    if ((_DWORD)v7)
      goto LABEL_10;
    ++v5;
  }
  v12 = 0;
  v13 = 0;
  v14 = 0;
  std::vector<AUSM::ExclusionZone>::__init_with_size[abi:ne180100]<AUSM::ExclusionZone*,AUSM::ExclusionZone*>(&v12, *(const void **)a2, *(_QWORD *)(a2 + 8), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2));
  caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(a1 + 1720));
  v8 = (_QWORD *)operator new();
  *v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  v9 = v12;
  std::vector<AUSM::ExclusionZone>::__init_with_size[abi:ne180100]<AUSM::ExclusionZone*,AUSM::ExclusionZone*>(v8, v12, (uint64_t)v13, 0x6DB6DB6DB6DB6DB7 * ((v13 - v12) >> 2));
  v10 = *(_QWORD *)(a1 + 1704);
  *(_QWORD *)(a1 + 1704) = v8;
  if (v10)
    std::default_delete<std::vector<AUSM::ExclusionZone>>::operator()[abi:ne180100](v10);
  atomic_store(1u, (unsigned __int8 *)(a1 + 1724));
  caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(a1 + 1720));
  if (v9)
  {
    v13 = v9;
    operator delete(v9);
  }
  atomic_store(1u, (unsigned __int8 *)(a1 + 1921));
  v7 = 0;
  atomic_store(AUSM::ExclusionZone::getPresetFromExclusionZones((float **)a2), (unsigned int *)(a1 + 1260));
LABEL_10:
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v4);
  return v7;
}

void sub_1B61AC310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  uint64_t v10;
  caulk::pooled_semaphore_mutex *v11;
  uint64_t v12;

  MEMORY[0x1BCC95CEC](v12, 0x20C40960023A9);
  caulk::pooled_semaphore_mutex::_unlock(v11);
  if (__p)
    operator delete(__p);
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v10);
  _Unwind_Resume(a1);
}

void AUSM::ExclusionZone::exclusionZonesFromArray(AUSM::ExclusionZone *this, const float *a2, unsigned int a3)
{
  _DWORD *v6;
  unsigned int v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;
  _DWORD *v14;
  int v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  unint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  float *v35;
  float *v36;
  __int128 v37;
  float *v38;
  float *v39;
  __int128 v40;
  uint64_t i;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  if (!a3)
    return;
  v6 = 0;
  v7 = 0;
  while (1)
  {
    v8 = a2[v7];
    if (a3 - v7 < 5 || v8 != 0.0)
      break;
    v9 = a2[v7 + 1];
    v10 = a2[v7 + 2];
    v11 = a2[v7 + 3];
    v12 = a2[v7 + 4];
    v13 = *((_QWORD *)this + 2);
    if ((unint64_t)v6 >= v13)
    {
      v23 = *(_DWORD **)this;
      v24 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v6 - *(_QWORD *)this) >> 2);
      v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) > 0x924924924924924)
        goto LABEL_48;
      v26 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v13 - (_QWORD)v23) >> 2);
      if (2 * v26 > v25)
        v25 = 2 * v26;
      if (v26 >= 0x492492492492492)
        v27 = 0x924924924924924;
      else
        v27 = v25;
      if (v27)
        v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v27);
      else
        v28 = 0;
      v35 = (float *)(v27 + 28 * v24);
      *v35 = 0.0;
      v35[1] = v9;
      v35[2] = v10;
      v35[3] = v11;
      v35[4] = v12;
      v36 = v35;
      if (v6 != v23)
      {
        do
        {
          v37 = *(_OWORD *)(v6 - 7);
          *((_OWORD *)v36 - 1) = *((_OWORD *)v6 - 1);
          *(_OWORD *)(v36 - 7) = v37;
          v36 -= 7;
          v6 -= 7;
        }
        while (v6 != v23);
        v6 = v23;
      }
      v14 = v35 + 7;
      *(_QWORD *)this = v36;
      *((_QWORD *)this + 1) = v35 + 7;
      *((_QWORD *)this + 2) = v27 + 28 * v28;
      if (v6)
        operator delete(v6);
      v15 = 5;
    }
    else
    {
      *v6 = 0;
      *((float *)v6 + 1) = v9;
      *((float *)v6 + 2) = v10;
      v14 = v6 + 7;
      v15 = 5;
      *((float *)v6 + 3) = v11;
      *((float *)v6 + 4) = v12;
    }
LABEL_41:
    *((_QWORD *)this + 1) = v14;
    v7 += v15;
    v6 = v14;
    if (v7 >= a3)
      goto LABEL_44;
  }
  if (a3 - v7 >= 7 && v8 == 1.0)
  {
    v16 = a2[v7 + 1];
    v17 = a2[v7 + 2];
    v18 = a2[v7 + 3];
    v19 = a2[v7 + 4];
    v20 = a2[v7 + 5];
    v21 = a2[v7 + 6];
    v22 = *((_QWORD *)this + 2);
    if ((unint64_t)v6 >= v22)
    {
      v29 = *(_DWORD **)this;
      v30 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v6 - *(_QWORD *)this) >> 2);
      v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) > 0x924924924924924)
LABEL_48:
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v32 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v22 - (_QWORD)v29) >> 2);
      if (2 * v32 > v31)
        v31 = 2 * v32;
      if (v32 >= 0x492492492492492)
        v33 = 0x924924924924924;
      else
        v33 = v31;
      if (v33)
        v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v33);
      else
        v34 = 0;
      v38 = (float *)(v33 + 28 * v30);
      *(_DWORD *)v38 = 1;
      v38[1] = v16;
      v38[2] = v17;
      v38[3] = v18;
      v38[4] = v19;
      v38[5] = v20;
      v38[6] = v21;
      v39 = v38;
      if (v6 != v29)
      {
        do
        {
          v40 = *(_OWORD *)(v6 - 7);
          *((_OWORD *)v39 - 1) = *((_OWORD *)v6 - 1);
          *(_OWORD *)(v39 - 7) = v40;
          v39 -= 7;
          v6 -= 7;
        }
        while (v6 != v29);
        v6 = v29;
      }
      v14 = v38 + 7;
      *(_QWORD *)this = v39;
      *((_QWORD *)this + 1) = v38 + 7;
      *((_QWORD *)this + 2) = v33 + 28 * v34;
      if (v6)
        operator delete(v6);
      v15 = 7;
    }
    else
    {
      *v6 = 1;
      *((float *)v6 + 1) = v16;
      *((float *)v6 + 2) = v17;
      *((float *)v6 + 3) = v18;
      *((float *)v6 + 4) = v19;
      v14 = v6 + 7;
      v15 = 7;
      *((float *)v6 + 5) = v20;
      *((float *)v6 + 6) = v21;
    }
    goto LABEL_41;
  }
  v14 = v6;
LABEL_44:
  for (i = *(_QWORD *)this; (_DWORD *)i != v14; i += 28)
    AUSM::ExclusionZone::clampValues(i);
}

void applesauce::CF::ArrayRef::from_get_noexcept(applesauce::CF::ArrayRef *this, CFTypeRef cf)
{
  CFTypeID v4;

  if (cf && (CFRetain(cf), v4 = CFGetTypeID(cf), v4 != CFArrayGetTypeID()))
  {
    *(_QWORD *)this = 0;
    CFRelease(cf);
  }
  else
  {
    *(_QWORD *)this = cf;
  }
}

void applesauce::CF::ArrayRef_proxy::pretty_print(applesauce::CF::ArrayRef_proxy *this, const void *a2)
{
  const __CFString *v3;

  if (a2)
  {
    v3 = CFCopyDescription(a2);
    applesauce::CF::details::CFString_get_value<true>(v3, (uint64_t)this);
    if (v3)
      CFRelease(v3);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(this, "(null)");
  }
}

void sub_1B61AC780(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *applesauce::CF::ArrayRef_iterator<applesauce::CF::DictionaryRef>::ArrayRef_iterator(_QWORD *a1, CFArrayRef theArray)
{
  CFIndex Count;

  *a1 = theArray;
  a1[1] = 0;
  if (theArray)
    Count = CFArrayGetCount(theArray);
  else
    Count = 0;
  a1[2] = Count;
  return a1;
}

uint64_t AUSpatialMixerV2::UpdateTuningWarper(AUSpatialMixerV2 *this)
{
  AUSpatialMixerV2 *v1;
  unint64_t v2;
  char *v3;
  uint64_t v4;
  char *v5;
  _QWORD *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  _OWORD *v10;
  __int128 v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  __int128 v16;
  _OWORD *v17;
  unint64_t v18;
  __int128 v19;
  char *v20;
  _QWORD *v21;
  _QWORD *v22;
  BOOL v23;
  int v24;
  NSObject *v25;
  _QWORD *v27;
  std::runtime_error *exception;
  AUSpatialMixerV2 *v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  char v34;
  CFTypeRef cf;
  std::string __p;
  uint64_t v37;

  v1 = this;
  v37 = *MEMORY[0x1E0C80C00];
  v33 = (char *)this + 3320;
  v34 = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 3320);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v2 = *((_QWORD *)v1 + 410);
  if (v2)
  {
    if (v2 >> 59)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v3 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v2);
    v5 = &v3[32 * v4];
    v30 = v3;
    v31 = v3;
    v32 = v5;
  }
  else
  {
    v5 = 0;
    v3 = 0;
  }
  v6 = (_QWORD *)*((_QWORD *)v1 + 408);
  v7 = (_QWORD *)((char *)v1 + 3272);
  if (v6 == (_QWORD *)((char *)v1 + 3272))
  {
    v9 = v3;
  }
  else
  {
    v29 = v1;
    v8 = v31;
    v9 = v3;
    do
    {
      v10 = v6 + 4;
      if (v3 >= v5)
      {
        v12 = (v3 - v9) >> 5;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 59)
        {
          v30 = v9;
          v31 = v8;
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        }
        if ((v5 - v9) >> 4 > v13)
          v13 = (v5 - v9) >> 4;
        if ((unint64_t)(v5 - v9) >= 0x7FFFFFFFFFFFFFE0)
          v14 = 0x7FFFFFFFFFFFFFFLL;
        else
          v14 = v13;
        if (v14)
          v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v14);
        else
          v15 = 0;
        v16 = *((_OWORD *)v6 + 3);
        v17 = (_OWORD *)(v14 + 32 * v12);
        *v17 = *v10;
        v17[1] = v16;
        if (v3 == v9)
        {
          v20 = (char *)(v14 + 32 * v12);
        }
        else
        {
          v18 = v14 + 32 * v12;
          do
          {
            v19 = *((_OWORD *)v3 - 1);
            v20 = (char *)(v18 - 32);
            *(_OWORD *)(v18 - 32) = *((_OWORD *)v3 - 2);
            *(_OWORD *)(v18 - 16) = v19;
            v3 -= 32;
            v18 -= 32;
          }
          while (v3 != v9);
        }
        v5 = (char *)(v14 + 32 * v15);
        v8 = (char *)(v17 + 2);
        v32 = v5;
        if (v9)
          operator delete(v9);
        v9 = v20;
      }
      else
      {
        v11 = *((_OWORD *)v6 + 3);
        *(_OWORD *)v3 = *v10;
        *((_OWORD *)v3 + 1) = v11;
        v8 = v3 + 32;
      }
      v21 = (_QWORD *)v6[1];
      if (v21)
      {
        do
        {
          v22 = v21;
          v21 = (_QWORD *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          v22 = (_QWORD *)v6[2];
          v23 = *v22 == (_QWORD)v6;
          v6 = v22;
        }
        while (!v23);
      }
      v3 = v8;
      v6 = v22;
    }
    while (v22 != v7);
    v30 = v9;
    v31 = v8;
    v1 = v29;
  }
  CFRetain(CFSTR("AUSMSoundStageLargeParameters"));
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, CFSTR("AUSMSoundStageLargeParameters"));
  if (!cf)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)&__p);
  v24 = AUSM::SoundStage::setSoundStageParameters((uint64_t)v1 + 6912, 3, &v30, &__p, 0, 0, 0, 1.0, 0.0);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (cf)
    CFRelease(cf);
  if (v24)
  {
    atomic_store(3u, (unsigned int *)v1 + 1830);
    *((_DWORD *)v1 + 1834) = 1065353216;
    atomic_store(1u, (unsigned __int8 *)v1 + 7365);
  }
  else
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v25 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v27 = (_QWORD *)((char *)v1 + 3592);
      if (*((char *)v1 + 3615) < 0)
        v27 = (_QWORD *)*v27;
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"UpdateTuningWarper";
      _os_log_error_impl(&dword_1B5ED0000, v25, OS_LOG_TYPE_ERROR, "[%s|%s] failed to set tuning warper parameters", (uint8_t *)&__p, 0x16u);
    }

  }
  if (v9)
  {
    v31 = v9;
    operator delete(v9);
  }
  return std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v33);
}

void sub_1B61ACB70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(exception_object);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,__CFString const*&>(const __CFDictionary *a1)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<__CFString const*&>(a1, (const void *)kPresetKeyChannelLabel);
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<unsigned int,0>(result);
  return result;
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,__CFString const*&>(const __CFDictionary *a1, const void *a2)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<__CFString const*&>(a1, a2);
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  return result;
}

char *std::__tree<std::__value_type<unsigned int,AUSMChannelParameters>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,AUSMChannelParameters>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,AUSMChannelParameters>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  char *v5;
  uint64_t **v6;
  char *v7;
  unsigned int v8;
  char *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = (char *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *(char **)v7;
        v6 = (uint64_t **)v7;
        if (!*(_QWORD *)v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = (char *)*((_QWORD *)v7 + 1);
      if (!v5)
      {
        v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = (char *)(a1 + 1);
LABEL_9:
    v9 = v7;
    v7 = (char *)operator new(0x40uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((_QWORD *)v7 + 4) = 0;
    *(_OWORD *)(v7 + 40) = xmmword_1B6627BD0;
    *((_QWORD *)v7 + 7) = 0xFFFFFFFF00000001;
    *(_QWORD *)v7 = 0;
    *((_QWORD *)v7 + 1) = 0;
    *((_QWORD *)v7 + 2) = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

_QWORD *std::vector<AUSMChannelParameters>::vector(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<AUSMChannelParameters>::__vallocate[abi:ne180100](a1, a2);
    v4 = a1[1];
    v5 = v4 + 32 * a2;
    do
    {
      *(_QWORD *)v4 = 0;
      *(_OWORD *)(v4 + 8) = xmmword_1B6627BD0;
      *(_QWORD *)(v4 + 24) = 0xFFFFFFFF00000001;
      v4 += 32;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B61ACD90(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<unsigned int>(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  int *v4;
  uint64_t v5;
  CFNumberRef *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  void **v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  int64x2_t v15;
  void **v16;
  CFArrayRef v17;
  int64x2_t v19;
  _QWORD v20[3];
  void **v21;
  int64x2_t v22;
  void **v23;
  _QWORD *v24;

  v2 = *(_QWORD *)(a1 + 8);
  v19 = 0uLL;
  v20[0] = 0;
  std::vector<applesauce::CF::NumberRef>::reserve((char **)&v19, v2);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    v4 = *(int **)a1;
    v5 = *(_QWORD *)a1 + 4 * v3;
    v6 = (CFNumberRef *)v19.i64[1];
    do
    {
      if ((unint64_t)v6 >= v20[0])
      {
        v7 = ((uint64_t)v6 - v19.i64[0]) >> 3;
        if ((unint64_t)(v7 + 1) >> 61)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v8 = (v20[0] - v19.i64[0]) >> 2;
        if (v8 <= v7 + 1)
          v8 = v7 + 1;
        if (v20[0] - v19.i64[0] >= 0x7FFFFFFFFFFFFFF8uLL)
          v9 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v9 = v8;
        v24 = v20;
        if (v9)
          v10 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,float>>>((uint64_t)v20, v9);
        else
          v10 = 0;
        v21 = v10;
        v22.i64[0] = (uint64_t)&v10[v7];
        v22.i64[1] = v22.i64[0];
        v23 = &v10[v9];
        std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned int const&,applesauce::CF::NumberRef*>((CFNumberRef *)v22.i64[0], *v4);
        v11 = v22.i64[0];
        v6 = (CFNumberRef *)(v22.i64[1] + 8);
        v22.i64[1] += 8;
        v12 = (_QWORD *)v19.i64[1];
        v13 = (_QWORD *)v19.i64[0];
        if (v19.i64[1] == v19.i64[0])
        {
          v15 = vdupq_n_s64(v19.u64[1]);
        }
        else
        {
          do
          {
            v14 = *--v12;
            *(_QWORD *)(v11 - 8) = v14;
            v11 -= 8;
            *v12 = 0;
          }
          while (v12 != v13);
          v15 = v19;
          v6 = (CFNumberRef *)v22.i64[1];
        }
        v19.i64[0] = v11;
        v19.i64[1] = (uint64_t)v6;
        v22 = v15;
        v16 = (void **)v20[0];
        v20[0] = v23;
        v23 = v16;
        v21 = (void **)v15.i64[0];
        std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)&v21);
      }
      else
      {
        std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned int const&,applesauce::CF::NumberRef*>(v6++, *v4);
      }
      v19.i64[1] = (uint64_t)v6;
      ++v4;
    }
    while (v4 != (int *)v5);
  }
  v17 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::NumberRef>((uint64_t **)&v19);
  v21 = (void **)&v19;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&v21);
  return v17;
}

void sub_1B61ACF38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a9;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&a13);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[5],float const&>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "CDDR");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61AD00C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[16],float const&>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "SharpeningLimit");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61AD0DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[19],float const&>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "DecorrelationLimit");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61AD1AC(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],float const&>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "AnalysisType");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61AD27C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[10],unsigned int>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "FrameSize");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61AD34C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[8],unsigned int>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "HopSize");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61AD41C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

CFNumberRef *std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned int const&,applesauce::CF::NumberRef*>(CFNumberRef *a1, int a2)
{
  CFNumberRef v3;
  std::runtime_error *exception;
  int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *a1 = v3;
  if (!v3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61AD4D8(_Unwind_Exception *exception_object)
{
  CFTypeRef *v1;

  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(exception_object);
}

char *std::vector<AUSMChannelParameters>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(unint64_t a1)
{
  if (a1 >= 0x924924924924925)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(28 * a1);
}

uint64_t AUSM::ExclusionZone::clampValues(uint64_t this)
{
  float v1;
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;

  if (*(_DWORD *)this == 1)
  {
    v9 = -1.0;
    v10 = *(float *)(this + 4);
    v11 = *(float *)(this + 8);
    if (v10 <= 1.0)
      v12 = *(float *)(this + 4);
    else
      v12 = 1.0;
    if (v10 >= -1.0)
      v13 = v12;
    else
      v13 = -1.0;
    if (v11 <= 1.0)
      v14 = *(float *)(this + 8);
    else
      v14 = 1.0;
    if (v11 >= -1.0)
      v15 = v14;
    else
      v15 = -1.0;
    *(float *)(this + 4) = v13;
    *(float *)(this + 8) = v15;
    v16 = *(float *)(this + 12);
    v17 = *(float *)(this + 16);
    if (v16 <= 1.0)
      v18 = *(float *)(this + 12);
    else
      v18 = 1.0;
    if (v16 >= -1.0)
      v19 = v18;
    else
      v19 = -1.0;
    if (v17 <= 1.0)
      v20 = *(float *)(this + 16);
    else
      v20 = 1.0;
    if (v17 >= -1.0)
      v21 = v20;
    else
      v21 = -1.0;
    *(float *)(this + 12) = v19;
    *(float *)(this + 16) = v21;
    v23 = *(float *)(this + 20);
    v22 = *(float *)(this + 24);
    if (v23 <= 1.0)
      v24 = *(float *)(this + 20);
    else
      v24 = 1.0;
    if (v23 >= -1.0)
      v25 = v24;
    else
      v25 = -1.0;
    *(float *)(this + 20) = v25;
    if (v22 >= -1.0)
    {
      v9 = 1.0;
      if (v22 <= 1.0)
        v9 = v22;
    }
    *(float *)(this + 24) = v9;
  }
  else if (!*(_DWORD *)this)
  {
    v1 = -90.0;
    v2 = 90.0;
    v3 = *(float *)(this + 4);
    v4 = *(float *)(this + 8);
    if (v3 <= 90.0)
      v2 = *(float *)(this + 4);
    if (v3 >= -90.0)
      v1 = v2;
    v5 = -90.0;
    v6 = 90.0;
    if (v4 <= 90.0)
      v6 = *(float *)(this + 8);
    if (v4 >= -90.0)
      v5 = v6;
    *(float *)(this + 4) = v1;
    *(float *)(this + 8) = v5;
    v7 = *(float *)(this + 12);
    if (v7 < -180.0)
    {
      do
        v7 = v7 + 360.0;
      while (v7 < -180.0);
      *(float *)(this + 12) = v7;
    }
    if (v7 > 180.0)
    {
      do
        v7 = v7 + -360.0;
      while (v7 > 180.0);
      *(float *)(this + 12) = v7;
    }
    v8 = *(float *)(this + 16);
    if (v8 < -180.0)
    {
      do
        v8 = v8 + 360.0;
      while (v8 < -180.0);
      *(float *)(this + 16) = v8;
    }
    if (v8 > 180.0)
    {
      do
        v8 = v8 + -360.0;
      while (v8 > 180.0);
      *(float *)(this + 16) = v8;
    }
  }
  return this;
}

_QWORD *std::vector<AUSM::ExclusionZone>::__init_with_size[abi:ne180100]<AUSM::ExclusionZone*,AUSM::ExclusionZone*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<AUSM::ExclusionZone>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B61AD798(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AUSM::ExclusionZone::getPresetFromExclusionZones(float **a1)
{
  float *v2;
  float *v3;
  void *v4;
  char *v5;
  _BOOL4 v6;
  char v7;
  uint64_t v8;
  float *v9;
  float *v10;
  void *v11;
  char *v12;
  char v13;
  float *v14;
  float *v15;
  void *v16;
  char *v17;
  _BOOL4 v18;
  float *v19;
  float *v20;
  void *v21;
  char *v22;
  char v23;
  float *v24;
  float *v25;
  void *v26;
  char *v27;
  _BOOL4 v28;
  float *v29;
  float *v30;
  void *v31;
  char *v32;
  _BOOL4 v33;
  char v34;
  float *v35;
  float *v36;
  int64_t v37;
  void *v38;
  char *v39;
  _BOOL4 v40;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;

  if (a1[1] == *a1)
    return 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  AUSM::ExclusionZone::getPreset(1, (void **)&v44);
  v2 = *a1;
  v3 = a1[1];
  v4 = v44;
  if ((char *)v3 - (char *)*a1 != v45 - (_QWORD)v44)
  {
    v7 = 0;
    goto LABEL_10;
  }
  if (v2 != v3)
  {
    v5 = v44;
    do
    {
      v6 = AUSM::ExclusionZone::operator==(v2, (uint64_t)v5);
      v7 = v6;
      if (!v6)
        break;
      v2 += 7;
      v5 += 28;
    }
    while (v2 != v3);
LABEL_10:
    if (!v4)
      goto LABEL_12;
    goto LABEL_11;
  }
  v7 = 1;
  if (v44)
LABEL_11:
    operator delete(v4);
LABEL_12:
  if ((v7 & 1) != 0)
    return 1;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  AUSM::ExclusionZone::getPreset(2, (void **)&v44);
  v9 = *a1;
  v10 = a1[1];
  v11 = v44;
  if ((char *)v10 - (char *)*a1 == v45 - (_QWORD)v44)
  {
    if (v9 == v10)
    {
LABEL_19:
      v13 = 1;
      goto LABEL_31;
    }
    v12 = v44;
    while (AUSM::ExclusionZone::operator==(v9, (uint64_t)v12))
    {
      v9 += 7;
      v12 += 28;
      if (v9 == v10)
        goto LABEL_19;
    }
  }
  AUSM::ExclusionZone::getPresetReversed((void **)&v42, 2);
  v14 = *a1;
  v15 = a1[1];
  v16 = v42;
  if ((char *)v15 - (char *)*a1 != v43 - (_QWORD)v42)
  {
    v13 = 0;
    goto LABEL_29;
  }
  if (v14 != v15)
  {
    v17 = v42;
    do
    {
      v18 = AUSM::ExclusionZone::operator==(v14, (uint64_t)v17);
      v13 = v18;
      if (!v18)
        break;
      v14 += 7;
      v17 += 28;
    }
    while (v14 != v15);
LABEL_29:
    if (!v16)
      goto LABEL_31;
    goto LABEL_30;
  }
  v13 = 1;
  if (v42)
LABEL_30:
    operator delete(v16);
LABEL_31:
  if (v11)
    operator delete(v11);
  if ((v13 & 1) != 0)
    return 2;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  AUSM::ExclusionZone::getPreset(3, (void **)&v44);
  v19 = *a1;
  v20 = a1[1];
  v21 = v44;
  if ((char *)v20 - (char *)*a1 == v45 - (_QWORD)v44)
  {
    if (v19 == v20)
    {
LABEL_40:
      v23 = 1;
      goto LABEL_50;
    }
    v22 = v44;
    while (AUSM::ExclusionZone::operator==(v19, (uint64_t)v22))
    {
      v19 += 7;
      v22 += 28;
      if (v19 == v20)
        goto LABEL_40;
    }
  }
  AUSM::ExclusionZone::getPresetReversed((void **)&v42, 3);
  v24 = *a1;
  v25 = a1[1];
  v26 = v42;
  if ((char *)v25 - (char *)*a1 != v43 - (_QWORD)v42)
  {
    v23 = 0;
    goto LABEL_48;
  }
  if (v24 != v25)
  {
    v27 = v42;
    do
    {
      v28 = AUSM::ExclusionZone::operator==(v24, (uint64_t)v27);
      v23 = v28;
      if (!v28)
        break;
      v24 += 7;
      v27 += 28;
    }
    while (v24 != v25);
LABEL_48:
    if (!v26)
      goto LABEL_50;
    goto LABEL_49;
  }
  v23 = 1;
  if (v42)
LABEL_49:
    operator delete(v26);
LABEL_50:
  if (v21)
    operator delete(v21);
  if ((v23 & 1) != 0)
    return 3;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  AUSM::ExclusionZone::getPreset(4, (void **)&v44);
  v29 = *a1;
  v30 = a1[1];
  v31 = v44;
  if ((char *)v30 - (char *)*a1 != v45 - (_QWORD)v44)
  {
    v34 = 0;
    goto LABEL_63;
  }
  if (v29 != v30)
  {
    v32 = v44;
    do
    {
      v33 = AUSM::ExclusionZone::operator==(v29, (uint64_t)v32);
      v34 = v33;
      if (!v33)
        break;
      v29 += 7;
      v32 += 28;
    }
    while (v29 != v30);
LABEL_63:
    if (!v31)
      goto LABEL_65;
    goto LABEL_64;
  }
  v34 = 1;
  if (v44)
LABEL_64:
    operator delete(v31);
LABEL_65:
  if ((v34 & 1) != 0)
    return 4;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  AUSM::ExclusionZone::getPreset(5, (void **)&v44);
  v35 = *a1;
  v36 = a1[1];
  v37 = (char *)v36 - (char *)*a1;
  v38 = v44;
  if (v37 == v45 - (_QWORD)v44)
  {
    if (v35 == v36)
    {
      v8 = 5;
    }
    else
    {
      v39 = v44;
      do
      {
        v40 = AUSM::ExclusionZone::operator==(v35, (uint64_t)v39);
        if (!v40)
          break;
        v35 += 7;
        v39 += 28;
      }
      while (v35 != v36);
      if (v40)
        v8 = 5;
      else
        v8 = 0xFFFFFFFFLL;
    }
  }
  else
  {
    v8 = 0xFFFFFFFFLL;
  }
  if (v38)
    operator delete(v38);
  return v8;
}

void AUSM::ExclusionZone::getPreset(int a1, void **a2)
{
  char *v3;
  char *v4;
  __int128 v5;
  char *v6;
  char *v7;
  char *v8;
  _DWORD *v9;
  char *v10;
  void *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  __int128 v43;
  unint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  __int128 v48;
  _BYTE *v49;
  __int128 v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  char *v56;
  __int128 v57;
  char *v58;
  __int128 v59;
  unint64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  __int128 v64;
  _BYTE *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  char *v71;
  __int128 v72;
  char *v73;
  __int128 v74;

  switch(a1)
  {
    case 1:
      v4 = (char *)a2[1];
      v3 = (char *)a2[2];
      if (v4 >= v3)
      {
        v29 = 0x6DB6DB6DB6DB6DB7 * ((v4 - (_BYTE *)*a2) >> 2);
        v30 = v29 + 1;
        if ((unint64_t)(v29 + 1) <= 0x924924924924924)
        {
          v31 = 0x6DB6DB6DB6DB6DB7 * ((v3 - (_BYTE *)*a2) >> 2);
          if (2 * v31 > v30)
            v30 = 2 * v31;
          if (v31 >= 0x492492492492492)
            v32 = 0x924924924924924;
          else
            v32 = v30;
          if (v32)
            v32 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v32);
          else
            v33 = 0;
          v39 = v32 + 28 * v29;
          v40 = v32 + 28 * v33;
          *(_DWORD *)v39 = 0;
          *(_OWORD *)(v39 + 4) = xmmword_1B66A09C0;
          v11 = (void *)(v39 + 28);
          v58 = (char *)*a2;
          v41 = (char *)a2[1];
          if (v41 == *a2)
            goto LABEL_106;
          do
          {
            v59 = *(_OWORD *)(v41 - 28);
            *(_OWORD *)(v39 - 16) = *((_OWORD *)v41 - 1);
            *(_OWORD *)(v39 - 28) = v59;
            v39 -= 28;
            v41 -= 28;
          }
          while (v41 != v58);
LABEL_105:
          v41 = (char *)*a2;
LABEL_106:
          *a2 = (void *)v39;
          a2[1] = v11;
          a2[2] = (void *)v40;
          if (v41)
            operator delete(v41);
          goto LABEL_108;
        }
LABEL_109:
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      }
      *(_DWORD *)v4 = 0;
      v5 = xmmword_1B66A09C0;
LABEL_10:
      *(_OWORD *)(v4 + 4) = v5;
      v11 = v4 + 28;
LABEL_108:
      a2[1] = v11;
      return;
    case 2:
      v13 = (char *)a2[1];
      v12 = (char *)a2[2];
      if (v13 >= v12)
      {
        v34 = 0x6DB6DB6DB6DB6DB7 * ((v13 - (_BYTE *)*a2) >> 2);
        v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) > 0x924924924924924)
          goto LABEL_109;
        v36 = 0x6DB6DB6DB6DB6DB7 * ((v12 - (_BYTE *)*a2) >> 2);
        if (2 * v36 > v35)
          v35 = 2 * v36;
        if (v36 >= 0x492492492492492)
          v37 = 0x924924924924924;
        else
          v37 = v35;
        if (v37)
          v37 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v37);
        else
          v38 = 0;
        v60 = v37 + 28 * v34;
        v61 = v37 + 28 * v38;
        *(_DWORD *)v60 = 0;
        *(_OWORD *)(v60 + 4) = xmmword_1B66A09A0;
        v9 = (_DWORD *)(v60 + 28);
        v63 = (char *)*a2;
        v62 = (char *)a2[1];
        if (v62 != *a2)
        {
          do
          {
            v64 = *(_OWORD *)(v62 - 28);
            *(_OWORD *)(v60 - 16) = *((_OWORD *)v62 - 1);
            *(_OWORD *)(v60 - 28) = v64;
            v60 -= 28;
            v62 -= 28;
          }
          while (v62 != v63);
          v62 = (char *)*a2;
        }
        *a2 = (void *)v60;
        a2[1] = v9;
        a2[2] = (void *)v61;
        if (v62)
          operator delete(v62);
      }
      else
      {
        *(_DWORD *)v13 = 0;
        *(_OWORD *)(v13 + 4) = xmmword_1B66A09A0;
        v9 = v13 + 28;
      }
      a2[1] = v9;
      v65 = a2[2];
      if (v9 >= (_DWORD *)v65)
      {
        v66 = 0x6DB6DB6DB6DB6DB7 * (((char *)v9 - (_BYTE *)*a2) >> 2);
        if ((unint64_t)(v66 + 1) <= 0x924924924924924)
        {
          v67 = 0x6DB6DB6DB6DB6DB7 * ((v65 - (_BYTE *)*a2) >> 2);
          v68 = 2 * v67;
          if (2 * v67 <= v66 + 1)
            v68 = v66 + 1;
          if (v67 >= 0x492492492492492)
            v69 = 0x924924924924924;
          else
            v69 = v68;
          if (v69)
            v69 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v69);
          else
            v70 = 0;
          v39 = v69 + 28 * v66;
          v40 = v69 + 28 * v70;
          *(_DWORD *)v39 = 0;
          *(_OWORD *)(v39 + 4) = xmmword_1B66A09B0;
          v11 = (void *)(v39 + 28);
          v73 = (char *)*a2;
          v41 = (char *)a2[1];
          if (v41 == *a2)
            goto LABEL_106;
          do
          {
            v74 = *(_OWORD *)(v41 - 28);
            *(_OWORD *)(v39 - 16) = *((_OWORD *)v41 - 1);
            *(_OWORD *)(v39 - 28) = v74;
            v39 -= 28;
            v41 -= 28;
          }
          while (v41 != v73);
          goto LABEL_105;
        }
        goto LABEL_109;
      }
      *v9 = 0;
      v50 = xmmword_1B66A09B0;
      goto LABEL_89;
    case 3:
      v8 = (char *)a2[1];
      v7 = (char *)a2[2];
      if (v8 >= v7)
      {
        v19 = 0x6DB6DB6DB6DB6DB7 * ((v8 - (_BYTE *)*a2) >> 2);
        v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) > 0x924924924924924)
          goto LABEL_109;
        v21 = 0x6DB6DB6DB6DB6DB7 * ((v7 - (_BYTE *)*a2) >> 2);
        if (2 * v21 > v20)
          v20 = 2 * v21;
        if (v21 >= 0x492492492492492)
          v22 = 0x924924924924924;
        else
          v22 = v20;
        if (v22)
          v22 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v22);
        else
          v23 = 0;
        v44 = v22 + 28 * v19;
        v45 = v22 + 28 * v23;
        *(_DWORD *)v44 = 0;
        *(_OWORD *)(v44 + 4) = xmmword_1B66A0980;
        v9 = (_DWORD *)(v44 + 28);
        v47 = (char *)*a2;
        v46 = (char *)a2[1];
        if (v46 != *a2)
        {
          do
          {
            v48 = *(_OWORD *)(v46 - 28);
            *(_OWORD *)(v44 - 16) = *((_OWORD *)v46 - 1);
            *(_OWORD *)(v44 - 28) = v48;
            v44 -= 28;
            v46 -= 28;
          }
          while (v46 != v47);
          v46 = (char *)*a2;
        }
        *a2 = (void *)v44;
        a2[1] = v9;
        a2[2] = (void *)v45;
        if (v46)
          operator delete(v46);
      }
      else
      {
        *(_DWORD *)v8 = 0;
        *(_OWORD *)(v8 + 4) = xmmword_1B66A0980;
        v9 = v8 + 28;
      }
      a2[1] = v9;
      v49 = a2[2];
      if (v9 < (_DWORD *)v49)
      {
        *v9 = 0;
        v50 = xmmword_1B66A0990;
LABEL_89:
        *(_OWORD *)(v9 + 1) = v50;
        v11 = v9 + 7;
        goto LABEL_108;
      }
      v51 = 0x6DB6DB6DB6DB6DB7 * (((char *)v9 - (_BYTE *)*a2) >> 2);
      if ((unint64_t)(v51 + 1) <= 0x924924924924924)
      {
        v52 = 0x6DB6DB6DB6DB6DB7 * ((v49 - (_BYTE *)*a2) >> 2);
        v53 = 2 * v52;
        if (2 * v52 <= v51 + 1)
          v53 = v51 + 1;
        if (v52 >= 0x492492492492492)
          v54 = 0x924924924924924;
        else
          v54 = v53;
        if (v54)
          v54 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v54);
        else
          v55 = 0;
        v39 = v54 + 28 * v51;
        v40 = v54 + 28 * v55;
        *(_DWORD *)v39 = 0;
        *(_OWORD *)(v39 + 4) = xmmword_1B66A0990;
        v11 = (void *)(v39 + 28);
        v71 = (char *)*a2;
        v41 = (char *)a2[1];
        if (v41 == *a2)
          goto LABEL_106;
        do
        {
          v72 = *(_OWORD *)(v41 - 28);
          *(_OWORD *)(v39 - 16) = *((_OWORD *)v41 - 1);
          *(_OWORD *)(v39 - 28) = v72;
          v39 -= 28;
          v41 -= 28;
        }
        while (v41 != v71);
        goto LABEL_105;
      }
      goto LABEL_109;
    case 4:
      v4 = (char *)a2[1];
      v10 = (char *)a2[2];
      if (v4 < v10)
      {
        *(_DWORD *)v4 = 0;
        v5 = xmmword_1B66A0970;
        goto LABEL_10;
      }
      v24 = 0x6DB6DB6DB6DB6DB7 * ((v4 - (_BYTE *)*a2) >> 2);
      v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) > 0x924924924924924)
        goto LABEL_109;
      v26 = 0x6DB6DB6DB6DB6DB7 * ((v10 - (_BYTE *)*a2) >> 2);
      if (2 * v26 > v25)
        v25 = 2 * v26;
      if (v26 >= 0x492492492492492)
        v27 = 0x924924924924924;
      else
        v27 = v25;
      if (v27)
        v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v27);
      else
        v28 = 0;
      v39 = v27 + 28 * v24;
      v40 = v27 + 28 * v28;
      *(_DWORD *)v39 = 0;
      *(_OWORD *)(v39 + 4) = xmmword_1B66A0970;
      v11 = (void *)(v39 + 28);
      v56 = (char *)*a2;
      v41 = (char *)a2[1];
      if (v41 == *a2)
        goto LABEL_106;
      do
      {
        v57 = *(_OWORD *)(v41 - 28);
        *(_OWORD *)(v39 - 16) = *((_OWORD *)v41 - 1);
        *(_OWORD *)(v39 - 28) = v57;
        v39 -= 28;
        v41 -= 28;
      }
      while (v41 != v56);
      goto LABEL_105;
    case 5:
      v4 = (char *)a2[1];
      v6 = (char *)a2[2];
      if (v4 < v6)
      {
        *(_DWORD *)v4 = 0;
        v5 = xmmword_1B66A09D0;
        goto LABEL_10;
      }
      v14 = 0x6DB6DB6DB6DB6DB7 * ((v4 - (_BYTE *)*a2) >> 2);
      v15 = v14 + 1;
      if ((unint64_t)(v14 + 1) > 0x924924924924924)
        goto LABEL_109;
      v16 = 0x6DB6DB6DB6DB6DB7 * ((v6 - (_BYTE *)*a2) >> 2);
      if (2 * v16 > v15)
        v15 = 2 * v16;
      if (v16 >= 0x492492492492492)
        v17 = 0x924924924924924;
      else
        v17 = v15;
      if (v17)
        v17 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(v17);
      else
        v18 = 0;
      v39 = v17 + 28 * v14;
      v40 = v17 + 28 * v18;
      *(_DWORD *)v39 = 0;
      *(_OWORD *)(v39 + 4) = xmmword_1B66A09D0;
      v11 = (void *)(v39 + 28);
      v42 = (char *)*a2;
      v41 = (char *)a2[1];
      if (v41 == *a2)
        goto LABEL_106;
      do
      {
        v43 = *(_OWORD *)(v41 - 28);
        *(_OWORD *)(v39 - 16) = *((_OWORD *)v41 - 1);
        *(_OWORD *)(v39 - 28) = v43;
        v39 -= 28;
        v41 -= 28;
      }
      while (v41 != v42);
      goto LABEL_105;
    default:
      return;
  }
}

BOOL AUSM::ExclusionZone::operator==(float *a1, uint64_t a2)
{
  float v2;
  float v3;
  float v4;

  v2 = *a1;
  if (*(_DWORD *)a1 == *(_DWORD *)a2)
  {
    if (LODWORD(v2) == 1)
    {
      if (a1[1] == *(float *)(a2 + 4)
        && a1[2] == *(float *)(a2 + 8)
        && a1[3] == *(float *)(a2 + 12)
        && a1[4] == *(float *)(a2 + 16)
        && a1[5] == *(float *)(a2 + 20))
      {
        v3 = a1[6];
        v4 = *(float *)(a2 + 24);
        return v3 == v4;
      }
    }
    else if (v2 == 0.0 && a1[1] == *(float *)(a2 + 4) && a1[2] == *(float *)(a2 + 8) && a1[3] == *(float *)(a2 + 12))
    {
      v3 = a1[4];
      v4 = *(float *)(a2 + 16);
      return v3 == v4;
    }
  }
  return 0;
}

__n128 AUSM::ExclusionZone::getPresetReversed(void **a1, int a2)
{
  __n128 result;
  char *v4;
  char *v5;
  char *v6;
  char *v8;
  __int128 v9;
  BOOL v10;
  _BYTE v11[28];

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  AUSM::ExclusionZone::getPreset(a2, a1);
  v4 = (char *)*a1;
  v5 = (char *)a1[1];
  v6 = v5 - 28;
  if (*a1 != v5 && v6 > v4)
  {
    v8 = v4 + 28;
    do
    {
      *(_OWORD *)v11 = *(_OWORD *)(v8 - 28);
      *(_OWORD *)&v11[12] = *((_OWORD *)v8 - 1);
      v9 = *(_OWORD *)(v6 + 12);
      *(_OWORD *)(v8 - 28) = *(_OWORD *)v6;
      *((_OWORD *)v8 - 1) = v9;
      *(_OWORD *)(v6 + 12) = *(_OWORD *)&v11[12];
      result = *(__n128 *)v11;
      *(_OWORD *)v6 = *(_OWORD *)v11;
      v6 -= 28;
      v10 = v8 >= v6;
      v8 += 28;
    }
    while (!v10);
  }
  return result;
}

void std::default_delete<std::vector<AUSM::ExclusionZone>>::operator()[abi:ne180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1BCC95CECLL);
}

char *std::vector<AUSM::ExclusionZone>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x924924924924925)
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AUSM::ExclusionZone>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[28 * v4];
  return result;
}

float applesauce::CF::at_or<float,char const(&)[13]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  const __CFNumber *v4;
  uint64_t v5;
  float result;

  v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[13]>(a1, a2);
  if (!v4)
    return *(float *)a3;
  v5 = applesauce::CF::convert_as<float,0>(v4);
  result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0)
    return *(float *)a3;
  return result;
}

float applesauce::CF::at_or<float,char const(&)[5]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  const __CFNumber *v4;
  uint64_t v5;
  float result;

  v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[5]>(a1, a2);
  if (!v4)
    return *(float *)a3;
  v5 = applesauce::CF::convert_as<float,0>(v4);
  result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0)
    return *(float *)a3;
  return result;
}

const void *applesauce::CF::details::at_key<char const(&)[16]>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1B61AE550(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B61AE534);
}

_QWORD *AUSM::InputGeometry::getExclusionZones(AUSM::InputGeometry *this, uint64_t a2)
{
  uint64_t v4;

  AUSM::RealtimeSafePingPongContainer<std::vector<AUSM::ExclusionZone>>::update((int8x16_t *)(a2 + 24));
  v4 = *(_QWORD *)(a2 + 32);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  return std::vector<AUSM::ExclusionZone>::__init_with_size[abi:ne180100]<AUSM::ExclusionZone*,AUSM::ExclusionZone*>(this, *(const void **)v4, *(_QWORD *)(v4 + 8), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(v4 + 8) - *(_QWORD *)v4) >> 2));
}

void AUSM::ExclusionZone::exclusionZonesToDictionary(CFDictionaryRef *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4;
  CFNumberRef v5;
  CFTypeRef *v6;
  CFTypeRef **v7;
  CFArrayRef v8;
  void **v9;
  void **v10;
  void **v11;
  void **v12;
  void **v13;
  void **v14;
  void **v15;
  void **v16;
  void **v17;
  void **v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  CFArrayRef *v26;
  unint64_t v27;
  _QWORD *v28;
  const __CFArray *v29;
  CFArrayRef v30;
  __int128 v31;
  unint64_t v32;
  CFArrayRef v33;
  std::runtime_error *exception;
  std::runtime_error *v35;
  std::runtime_error *v36;
  std::runtime_error *v37;
  std::runtime_error *v38;
  std::runtime_error *v39;
  std::runtime_error *v40;
  std::runtime_error *v41;
  std::runtime_error *v42;
  std::runtime_error *v43;
  std::runtime_error *v44;
  __int128 v46;
  unint64_t v47;
  CFTypeRef *valuePtr;
  __int128 v49;
  unint64_t v50;
  unint64_t *v51;
  CFArrayRef v52;
  CFTypeRef p_cf;
  CFTypeRef cf;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v46 = 0uLL;
  v47 = 0;
  if (a2 != a3)
  {
    v4 = a2;
    do
    {
      cf = 0;
      v55 = 0;
      p_cf = &cf;
      LODWORD(valuePtr) = *v4;
      v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      if (!v5)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
      }
      v6 = (CFTypeRef *)operator new(0x30uLL);
      valuePtr = v6;
      *(_QWORD *)&v49 = &cf;
      BYTE8(v49) = 0;
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)(v6 + 4), "coordinatesType");
      CFRetain(v5);
      v6[5] = v5;
      BYTE8(v49) = 1;
      v7 = (CFTypeRef **)std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__find_equal<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>((uint64_t)&p_cf, &v52, v6 + 4);
      if (!*v7)
      {
        v8 = v52;
        *v6 = 0;
        v6[1] = 0;
        v6[2] = v8;
        *v7 = v6;
        if (*(_QWORD *)p_cf)
        {
          p_cf = *(CFTypeRef *)p_cf;
          v6 = *v7;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)cf, (uint64_t *)v6);
        ++v55;
        valuePtr = 0;
      }
      std::unique_ptr<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>>>>::reset[abi:ne180100]((uint64_t)&valuePtr);
      CFRelease(v5);
      if (*v4 == 1)
      {
        LODWORD(v52) = v4[1];
        v13 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v13;
        if (!v13)
        {
          v35 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v35, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[5],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "minX", (const void **)&valuePtr);
        CFRelease(v13);
        LODWORD(v52) = v4[2];
        v14 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v14;
        if (!v14)
        {
          v39 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v39, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[5],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "maxX", (const void **)&valuePtr);
        CFRelease(v14);
        LODWORD(v52) = v4[3];
        v15 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v15;
        if (!v15)
        {
          v37 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v37, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[5],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "minY", (const void **)&valuePtr);
        CFRelease(v15);
        LODWORD(v52) = v4[4];
        v16 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v16;
        if (!v16)
        {
          v42 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v42, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[5],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "maxY", (const void **)&valuePtr);
        CFRelease(v16);
        LODWORD(v52) = v4[5];
        v17 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v17;
        if (!v17)
        {
          v41 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v41, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[5],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "minZ", (const void **)&valuePtr);
        CFRelease(v17);
        LODWORD(v52) = v4[6];
        v18 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v18;
        if (!v18)
        {
          v44 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v44, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[5],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "maxZ", (const void **)&valuePtr);
        CFRelease(v18);
      }
      else if (!*v4)
      {
        LODWORD(v52) = v4[1];
        v9 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v9;
        if (!v9)
        {
          v36 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v36, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[13],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "minElevation", (const void **)&valuePtr);
        CFRelease(v9);
        LODWORD(v52) = v4[2];
        v10 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v10;
        if (!v10)
        {
          v40 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v40, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[13],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "maxElevation", (const void **)&valuePtr);
        CFRelease(v10);
        LODWORD(v52) = v4[3];
        v11 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v11;
        if (!v11)
        {
          v38 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v38, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[11],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "minAzimuth", (const void **)&valuePtr);
        CFRelease(v11);
        LODWORD(v52) = v4[4];
        v12 = (void **)CFNumberCreate(0, kCFNumberFloatType, &v52);
        valuePtr = (CFTypeRef *)v12;
        if (!v12)
        {
          v43 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v43, "Could not construct");
        }
        std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[11],applesauce::CF::NumberRef>((uint64_t **)&p_cf, "maxAzimuth", (const void **)&valuePtr);
        CFRelease(v12);
      }
      applesauce::CF::make_DictionaryRef<applesauce::CF::StringRef,applesauce::CF::TypeRef>(&v52, (const void ***)&p_cf);
      v19 = (_QWORD *)*((_QWORD *)&v46 + 1);
      if (*((_QWORD *)&v46 + 1) >= v47)
      {
        v20 = (_QWORD *)v46;
        v21 = (uint64_t)(*((_QWORD *)&v46 + 1) - v46) >> 3;
        v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 61)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v23 = v47 - v46;
        if ((uint64_t)(v47 - v46) >> 2 > v22)
          v22 = v23 >> 2;
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
          v24 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v24 = v22;
        v51 = &v47;
        if (v24)
        {
          v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v24);
          v19 = (_QWORD *)*((_QWORD *)&v46 + 1);
          v20 = (_QWORD *)v46;
        }
        else
        {
          v25 = 0;
        }
        v26 = (CFArrayRef *)(v24 + 8 * v21);
        v27 = v24 + 8 * v25;
        v50 = v27;
        *v26 = v52;
        v28 = v26 + 1;
        v52 = 0;
        *((_QWORD *)&v49 + 1) = v26 + 1;
        if (v19 == v20)
        {
          v30 = 0;
        }
        else
        {
          do
          {
            v29 = (const __CFArray *)*--v19;
            *--v26 = v29;
            *v19 = 0;
          }
          while (v19 != v20);
          v28 = (_QWORD *)*((_QWORD *)&v49 + 1);
          v27 = v50;
          v30 = v52;
        }
        v31 = v46;
        *(_QWORD *)&v46 = v26;
        v49 = v31;
        v32 = v47;
        v47 = v27;
        v50 = v32;
        valuePtr = (CFTypeRef *)v31;
        std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer((uint64_t)&valuePtr);
        *((_QWORD *)&v46 + 1) = v28;
        if (v30)
          CFRelease(v30);
      }
      else
      {
        **((_QWORD **)&v46 + 1) = v52;
        *((_QWORD *)&v46 + 1) = v19 + 1;
      }
      std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::destroy(cf);
      v4 += 7;
    }
    while (v4 != a3);
  }
  v33 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)&v46);
  v52 = v33;
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],applesauce::CF::ArrayRef>((applesauce::CF::TypeRef *)&p_cf, "ExclusionZones", (const void **)&v52);
  valuePtr = &p_cf;
  *(_QWORD *)&v49 = 1;
  *a1 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&valuePtr);
  if (cf)
    CFRelease(cf);
  if (p_cf)
    CFRelease(p_cf);
  if (v33)
    CFRelease(v33);
  valuePtr = (CFTypeRef *)&v46;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&valuePtr);
}

void sub_1B61AED90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

_DWORD *AUSM::ExclusionZone::arrayFromZones(_DWORD *result, _DWORD *a2, uint64_t a3)
{
  unsigned int v3;
  _DWORD *v4;
  int v5;
  int v6;

  if (result != a2)
  {
    v3 = 0;
    while (*result != 1)
    {
      if (!*result)
      {
        *(_DWORD *)(a3 + 4 * v3) = 0;
        *(_DWORD *)(a3 + 4 * (v3 + 1)) = result[1];
        *(_DWORD *)(a3 + 4 * (v3 + 2)) = result[2];
        *(_DWORD *)(a3 + 4 * (v3 + 3)) = result[3];
        v4 = result + 4;
        v5 = 5;
        v6 = 4;
LABEL_7:
        *(_DWORD *)(a3 + 4 * (v3 + v6)) = *v4;
        v3 += v5;
      }
      result += 7;
      if (result == a2)
        return result;
    }
    *(_DWORD *)(a3 + 4 * v3) = 1065353216;
    *(_DWORD *)(a3 + 4 * (v3 + 1)) = result[1];
    *(_DWORD *)(a3 + 4 * (v3 + 2)) = result[2];
    *(_DWORD *)(a3 + 4 * (v3 + 3)) = result[3];
    *(_DWORD *)(a3 + 4 * (v3 + 4)) = result[4];
    *(_DWORD *)(a3 + 4 * (v3 + 5)) = result[5];
    v4 = result + 6;
    v5 = 7;
    v6 = 6;
    goto LABEL_7;
  }
  return result;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],float>(applesauce::CF::TypeRef *a1, int *a2)
{
  CFNumberRef v4;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, "FilterLength");
  valuePtr = *a2;
  v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((_QWORD *)a1 + 1) = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61AEFC0(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

id AUSpatialMixerV2::GetFileNamesDictionary(AUSpatialMixerV2 *this)
{
  void *v1;
  _BYTE *v2;
  void *v3;
  IR *v4;
  void *v5;
  _BYTE *v6;
  void *v7;
  void *v8;
  _BYTE *v9;
  void *v10;
  void *v11;
  void *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  void *v18;
  void *v19;
  int v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  IR *v26;
  _BYTE *v27;
  void *v28;
  void *v29;
  void *v30;
  NSObject *v31;
  id v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t j;
  void *v37;
  void *v38;
  int v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  _QWORD *v46;
  _QWORD *v47;
  id v49;
  id v50;
  IR *v51;
  id obj;
  IR *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  id v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  id v63;
  _BYTE v64[128];
  _BYTE v65[128];
  _BYTE buf[12];
  __int16 v67;
  const char *v68;
  char v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v53 = (IR *)objc_alloc_init(MEMORY[0x1E0C99E08]);
  v1 = (void *)MEMORY[0x1E0CB3940];
  IR::getProductTypeXTCIRFullPath(v53);
  if (v69 >= 0)
    v2 = buf;
  else
    v2 = *(_BYTE **)buf;
  objc_msgSend(v1, "stringWithUTF8String:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  -[IR setObject:forKeyedSubscript:](v53, "setObject:forKeyedSubscript:", v3, CFSTR("XTCIRFullPath"));

  if (v69 < 0)
    operator delete(*(void **)buf);
  v5 = (void *)MEMORY[0x1E0CB3940];
  IR::getGenericIRBasePath(v4);
  if (v69 >= 0)
    v6 = buf;
  else
    v6 = *(_BYTE **)buf;
  objc_msgSend(v5, "stringWithUTF8String:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  -[IR setObject:forKeyedSubscript:](v53, "setObject:forKeyedSubscript:", v7, CFSTR("HRIRFullPath"));

  if (v69 < 0)
    operator delete(*(void **)buf);
  v51 = (IR *)objc_alloc_init(MEMORY[0x1E0CB3620]);
  v8 = (void *)MEMORY[0x1E0CB3940];
  IR::getProductTypeXTCIRFullPath(v51);
  if (v69 >= 0)
    v9 = buf;
  else
    v9 = *(_BYTE **)buf;
  objc_msgSend(v8, "stringWithUTF8String:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v63 = 0;
  -[IR subpathsOfDirectoryAtPath:error:](v51, "subpathsOfDirectoryAtPath:error:", v10, &v63);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = v63;
  objc_msgSend(v11, "sortedArrayUsingSelector:");
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  if (v69 < 0)
    operator delete(*(void **)buf);
  if (v50)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v13 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v46 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v46 = (_QWORD *)*v46;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v46;
      v67 = 2080;
      v68 = "GetFileNamesDictionary";
      _os_log_error_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_ERROR, "[%s|%s] XTCIRFileList error or empty list", buf, 0x16u);
    }

  }
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  obj = v12;
  v14 = 0;
  v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v59, v65, 16);
  if (v15)
  {
    v16 = *(_QWORD *)v60;
    do
    {
      for (i = 0; i != v15; ++i)
      {
        if (*(_QWORD *)v60 != v16)
          objc_enumerationMutation(obj);
        v18 = *(void **)(*((_QWORD *)&v59 + 1) + 8 * i);
        objc_msgSend(v18, "pathExtension");
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        v20 = objc_msgSend(v19, "isEqualToString:", CFSTR("ir"));

        if (v20)
        {
          v14 = (v14 + 1);
          v21 = (void *)MEMORY[0x1E0CB3940];
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v14);
          v22 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v21, "stringWithFormat:", CFSTR("XTCIRFile%@"), v22);
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          -[IR setObject:forKeyedSubscript:](v53, "setObject:forKeyedSubscript:", v18, v23);

        }
      }
      v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v59, v65, 16);
    }
    while (v15);
  }

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v14);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  -[IR setObject:forKeyedSubscript:](v53, "setObject:forKeyedSubscript:", v24, CFSTR("NumXTCIRFiles"));

  v25 = (void *)MEMORY[0x1E0CB3940];
  IR::getGenericIRBasePath(v26);
  if (v69 >= 0)
    v27 = buf;
  else
    v27 = *(_BYTE **)buf;
  objc_msgSend(v25, "stringWithUTF8String:", v27);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v58 = v50;
  -[IR subpathsOfDirectoryAtPath:error:](v51, "subpathsOfDirectoryAtPath:error:", v28, &v58);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v49 = v58;

  objc_msgSend(v29, "sortedArrayUsingSelector:", sel_compare_);
  v30 = (void *)objc_claimAutoreleasedReturnValue();

  if (v69 < 0)
    operator delete(*(void **)buf);
  if (v49)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v31 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v47 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v47 = (_QWORD *)*v47;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v47;
      v67 = 2080;
      v68 = "GetFileNamesDictionary";
      _os_log_error_impl(&dword_1B5ED0000, v31, OS_LOG_TYPE_ERROR, "[%s|%s] IRFileList error or empty list", buf, 0x16u);
    }

  }
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v32 = v30;
  v33 = 0;
  v34 = objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", &v54, v64, 16);
  if (v34)
  {
    v35 = *(_QWORD *)v55;
    do
    {
      for (j = 0; j != v34; ++j)
      {
        if (*(_QWORD *)v55 != v35)
          objc_enumerationMutation(v32);
        v37 = *(void **)(*((_QWORD *)&v54 + 1) + 8 * j);
        objc_msgSend(v37, "pathExtension");
        v38 = (void *)objc_claimAutoreleasedReturnValue();
        v39 = objc_msgSend(v38, "isEqualToString:", CFSTR("ir"));

        if (v39)
        {
          v33 = (v33 + 1);
          v40 = (void *)MEMORY[0x1E0CB3940];
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v33);
          v41 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v40, "stringWithFormat:", CFSTR("IRFile%@"), v41);
          v42 = (void *)objc_claimAutoreleasedReturnValue();
          -[IR setObject:forKeyedSubscript:](v53, "setObject:forKeyedSubscript:", v37, v42);

        }
      }
      v34 = objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", &v54, v64, 16);
    }
    while (v34);
  }

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v33);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  -[IR setObject:forKeyedSubscript:](v53, "setObject:forKeyedSubscript:", v43, CFSTR("NumIRFiles"));

  v44 = (void *)-[IR copy](v53, "copy");
  return v44;
}

void sub_1B61AF678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

float applesauce::CF::details::find_at_key<float,char const(&)[5]>(const __CFDictionary *a1)
{
  const __CFNumber *v1;
  std::runtime_error *exception;

  v1 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[5]>(a1, "CDDR");
  if (!v1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  return applesauce::CF::convert_to<float,0>(v1);
}

void sub_1B61AF864(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

float applesauce::CF::details::find_at_key<float,char const(&)[16]>(const __CFDictionary *a1)
{
  const __CFNumber *v1;
  std::runtime_error *exception;

  v1 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[16]>(a1, "SharpeningLimit");
  if (!v1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  return applesauce::CF::convert_to<float,0>(v1);
}

void sub_1B61AF8CC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

float applesauce::CF::details::find_at_key<float,char const(&)[19]>(const __CFDictionary *a1)
{
  const __CFNumber *v1;
  std::runtime_error *exception;

  v1 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[19]>(a1, "DecorrelationLimit");
  if (!v1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  return applesauce::CF::convert_to<float,0>(v1);
}

void sub_1B61AF934(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

float applesauce::CF::details::find_at_key<float,char const(&)[13]>(const __CFDictionary *a1, char *a2)
{
  const __CFNumber *v2;
  std::runtime_error *exception;

  v2 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[13]>(a1, a2);
  if (!v2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  return applesauce::CF::convert_to<float,0>(v2);
}

void sub_1B61AF994(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

float applesauce::CF::details::find_at_key<float,char const(&)[10]>(const __CFDictionary *a1)
{
  const __CFNumber *v1;
  std::runtime_error *exception;

  v1 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[10]>(a1, "FrameSize");
  if (!v1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  return applesauce::CF::convert_to<float,0>(v1);
}

void sub_1B61AF9FC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

float applesauce::CF::details::find_at_key<float,char const(&)[8]>(const __CFDictionary *a1)
{
  const __CFNumber *v1;
  std::runtime_error *exception;

  v1 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[8]>(a1, "HopSize");
  if (!v1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  return applesauce::CF::convert_to<float,0>(v1);
}

void sub_1B61AFA64(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::ArrayRef>(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  CFArrayRef CFArray;
  void *__p[3];

  std::vector<void const*>::vector(__p, a1[1] - *a1);
  v2 = *a1;
  v3 = a1[1];
  if (*a1 != v3)
  {
    v4 = __p[0];
    do
    {
      v5 = *v2++;
      *v4++ = v5;
    }
    while (v2 != v3);
  }
  CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return CFArray;
}

void sub_1B61AFAF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<applesauce::CF::ArrayRef>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::ArrayRef,0>((const void **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],applesauce::CF::ArrayRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  const void *v5;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  v5 = *a3;
  if (v5)
    CFRetain(v5);
  *((_QWORD *)a1 + 1) = v5;
  return a1;
}

void std::vector<applesauce::CF::ArrayRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  const void **v2;
  const void **v4;
  void *v5;

  v1 = *a1;
  v2 = (const void **)**a1;
  if (v2)
  {
    v4 = (const void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::__destroy_at[abi:ne180100]<applesauce::CF::ArrayRef,0>(--v4);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[13],applesauce::CF::NumberRef>(uint64_t **a1, char *a2, const void **a3)
{
  uint64_t **v6;
  uint64_t *v7;
  const void *v8;
  uint64_t **v9;
  uint64_t v10;
  _QWORD v11[2];
  char v12;

  v6 = a1 + 1;
  v7 = (uint64_t *)operator new(0x30uLL);
  v11[0] = v7;
  v11[1] = v6;
  v12 = 0;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)(v7 + 4), a2);
  v8 = *a3;
  if (v8)
    CFRetain(v8);
  v7[5] = (uint64_t)v8;
  v12 = 1;
  v9 = (uint64_t **)std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__find_equal<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>((uint64_t)a1, &v10, (CFTypeRef *)v7 + 4);
  if (!*v9)
  {
    std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(a1, v10, v9, v7);
    v11[0] = 0;
  }
  std::unique_ptr<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>>>>::reset[abi:ne180100]((uint64_t)v11);
}

void sub_1B61AFCC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[11],applesauce::CF::NumberRef>(uint64_t **a1, char *a2, const void **a3)
{
  uint64_t **v6;
  uint64_t *v7;
  const void *v8;
  uint64_t **v9;
  uint64_t v10;
  _QWORD v11[2];
  char v12;

  v6 = a1 + 1;
  v7 = (uint64_t *)operator new(0x30uLL);
  v11[0] = v7;
  v11[1] = v6;
  v12 = 0;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)(v7 + 4), a2);
  v8 = *a3;
  if (v8)
    CFRetain(v8);
  v7[5] = (uint64_t)v8;
  v12 = 1;
  v9 = (uint64_t **)std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__find_equal<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>((uint64_t)a1, &v10, (CFTypeRef *)v7 + 4);
  if (!*v9)
  {
    std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(a1, v10, v9, v7);
    v11[0] = 0;
  }
  std::unique_ptr<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>>>>::reset[abi:ne180100]((uint64_t)v11);
}

void sub_1B61AFD98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__emplace_unique_impl<char const(&)[5],applesauce::CF::NumberRef>(uint64_t **a1, char *a2, const void **a3)
{
  uint64_t **v6;
  uint64_t *v7;
  const void *v8;
  uint64_t **v9;
  uint64_t v10;
  _QWORD v11[2];
  char v12;

  v6 = a1 + 1;
  v7 = (uint64_t *)operator new(0x30uLL);
  v11[0] = v7;
  v11[1] = v6;
  v12 = 0;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)(v7 + 4), a2);
  v8 = *a3;
  if (v8)
    CFRetain(v8);
  v7[5] = (uint64_t)v8;
  v12 = 1;
  v9 = (uint64_t **)std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__find_equal<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>((uint64_t)a1, &v10, (CFTypeRef *)v7 + 4);
  if (!*v9)
  {
    std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(a1, v10, v9, v7);
    v11[0] = 0;
  }
  std::unique_ptr<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>>>>::reset[abi:ne180100]((uint64_t)v11);
}

void sub_1B61AFE68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void applesauce::CF::make_DictionaryRef<applesauce::CF::StringRef,applesauce::CF::TypeRef>(CFDictionaryRef *a1, const void ***a2)
{
  const void ***v4;
  const void **v5;
  const void **v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  void **v11;
  void **v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int64x2_t v17;
  void **v18;
  const void **v19;
  const void ***v20;
  BOOL v21;
  CFDictionaryRef CFDictionaryRef;
  int v23[4];
  _QWORD v24[3];
  void **v25;
  int64x2_t v26;
  void **v27;
  _QWORD *v28;

  memset(v23, 0, sizeof(v23));
  v24[0] = 0;
  std::vector<applesauce::CF::TypeRefPair>::reserve(v23, (unint64_t)a2[2]);
  v6 = *a2;
  v4 = a2 + 1;
  v5 = v6;
  if (v6 != (const void **)v4)
  {
    v7 = *(_QWORD **)&v23[2];
    do
    {
      if ((unint64_t)v7 >= v24[0])
      {
        v8 = ((uint64_t)v7 - *(_QWORD *)v23) >> 4;
        if ((unint64_t)(v8 + 1) >> 60)
          std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
        v9 = (uint64_t)(v24[0] - *(_QWORD *)v23) >> 3;
        if (v9 <= v8 + 1)
          v9 = v8 + 1;
        if (v24[0] - *(_QWORD *)v23 >= 0x7FFFFFFFFFFFFFF0uLL)
          v10 = 0xFFFFFFFFFFFFFFFLL;
        else
          v10 = v9;
        v28 = v24;
        if (v10)
          v11 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,applesauce::CF::DictionaryRef>>>((uint64_t)v24, v10);
        else
          v11 = 0;
        v12 = &v11[2 * v8];
        v25 = v11;
        v26.i64[0] = (uint64_t)v12;
        v27 = &v11[2 * v10];
        applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef const&,applesauce::CF::TypeRef const&>(v12, v5[4], v5 + 5);
        v7 = v12 + 2;
        v26.i64[1] = (uint64_t)v7;
        v14 = *(_QWORD **)v23;
        v13 = *(_QWORD **)&v23[2];
        v15 = v26.i64[0];
        if (*(_QWORD *)&v23[2] == *(_QWORD *)v23)
        {
          v17 = vdupq_n_s64(*(unint64_t *)&v23[2]);
        }
        else
        {
          do
          {
            v16 = *(v13 - 2);
            v13 -= 2;
            *(_QWORD *)(v15 - 16) = v16;
            v15 -= 16;
            *v13 = 0;
            *(_QWORD *)(v15 + 8) = v13[1];
            v13[1] = 0;
          }
          while (v13 != v14);
          v17 = *(int64x2_t *)v23;
          v7 = (_QWORD *)v26.i64[1];
        }
        *(_QWORD *)v23 = v15;
        *(_QWORD *)&v23[2] = v7;
        v26 = v17;
        v18 = (void **)v24[0];
        v24[0] = v27;
        v27 = v18;
        v25 = (void **)v17.i64[0];
        std::__split_buffer<applesauce::CF::TypeRefPair>::~__split_buffer((uint64_t)&v25);
      }
      else
      {
        applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef const&,applesauce::CF::TypeRef const&>(v7, v5[4], v5 + 5);
        v7 += 2;
      }
      *(_QWORD *)&v23[2] = v7;
      v19 = (const void **)v5[1];
      if (v19)
      {
        do
        {
          v20 = (const void ***)v19;
          v19 = (const void **)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = (const void ***)v5[2];
          v21 = *v20 == v5;
          v5 = (const void **)v20;
        }
        while (!v21);
      }
      v5 = (const void **)v20;
    }
    while (v20 != v4);
  }
  CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((void ***)v23);
  v25 = (void **)v23;
  std::vector<applesauce::CF::TypeRefPair>::__destroy_vector::operator()[abi:ne180100](&v25);
  *a1 = CFDictionaryRef;
}

void sub_1B61B0054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a9;
  std::vector<applesauce::CF::TypeRefPair>::__destroy_vector::operator()[abi:ne180100](&a13);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::destroy(*a1);
    std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<applesauce::CF::StringRef const,applesauce::CF::TypeRef>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[15],applesauce::CF::ArrayRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  const void *v5;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  v5 = *a3;
  if (v5)
    CFRetain(v5);
  *((_QWORD *)a1 + 1) = v5;
  return a1;
}

void std::__destroy_at[abi:ne180100]<std::pair<applesauce::CF::StringRef const,applesauce::CF::TypeRef>,0>(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    CFRelease(v2);
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
}

_QWORD *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef const&,applesauce::CF::TypeRef const&>(_QWORD *a1, CFTypeRef cf, const void **a3)
{
  const void *v6;

  if (cf)
    CFRetain(cf);
  *a1 = cf;
  v6 = *a3;
  if (v6)
    CFRetain(v6);
  a1[1] = v6;
  return a1;
}

_QWORD *std::__tree<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::__map_value_compare<applesauce::CF::StringRef,std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,std::less<applesauce::CF::StringRef>,true>,std::allocator<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>>::__find_equal<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>>(uint64_t a1, _QWORD *a2, CFTypeRef *a3)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v7;
  CFTypeRef *v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = (_QWORD *)v4;
        v8 = (CFTypeRef *)(v4 + 32);
        if ((unint64_t)applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>(a3, (const __CFString **)(v4 + 32)) < 2)break;
        v4 = *v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if ((unint64_t)applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>(v8, (const __CFString **)a3) < 2)break;
      v5 = v7 + 1;
      v4 = v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void std::unique_ptr<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<applesauce::CF::StringRef,applesauce::CF::TypeRef>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<applesauce::CF::StringRef const,applesauce::CF::TypeRef>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

uint64_t AUSM::RealtimeSafePingPongContainer<std::vector<AUSM::ExclusionZone>>::update(int8x16_t *a1)
{
  int v2;
  unsigned __int8 v3;
  int8x16_t *v5;
  char v6;

  v5 = a1 + 1;
  v2 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)&a1[1]);
  v6 = v2;
  if (v2)
  {
    v3 = atomic_load(&a1[1].u8[4]);
    if ((v3 & 1) != 0)
    {
      *a1 = vextq_s8(*a1, *a1, 8uLL);
      atomic_store(0, &a1[1].u8[4]);
    }
  }
  return std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v5);
}

void ___ZN16AUSpatialMixerV27CleanupEv_block_invoke(uint64_t a1)
{
  dispatch_source_t source;

  source = *(dispatch_source_t *)(*(_QWORD *)(a1 + 32) + 2856);
  applesauce::dispatch::v1::queue::get(source);
  objc_claimAutoreleasedReturnValue();
  dispatch_source_cancel(source);

}

void AUSpatialMixerV2OrientationObserver::unregister(AUSpatialMixerV2OrientationObserver *this)
{
  std::__shared_weak_count *v1;
  uint64_t v3;
  unint64_t *p_shared_weak_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unsigned __int8 v7;
  NSObject *v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  NSObject *v11;
  _QWORD *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint8_t buf[4];
  _QWORD *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v1)
  {
    v3 = *(_QWORD *)this;
    p_shared_weak_owners = (unint64_t *)&v1->__shared_weak_owners_;
    do
      v5 = __ldxr(p_shared_weak_owners);
    while (__stxr(v5 + 1, p_shared_weak_owners));
    v6 = std::__shared_weak_count::lock(v1);
    v15 = v6;
    if (v6)
    {
      if (v3)
      {
        std::mutex::lock((std::mutex *)((char *)this + 80));
        v7 = atomic_load((unsigned __int8 *)this + 72);
        if ((v7 & 1) != 0)
        {
          atomic_store(0, (unsigned __int8 *)this + 72);
          if (*((_DWORD *)this + 4) == 1)
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v8 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
            {
              v9 = (_QWORD *)((char *)this + 40);
              if (*((char *)this + 63) < 0)
                v9 = (_QWORD *)*v9;
              *(_DWORD *)buf = 136315138;
              v17 = v9;
              _os_log_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_DEFAULT, "Unregistering UI orientation observer %s", buf, 0xCu);
            }

            CAUnregisterUIOrientation();
          }
          else
          {
            if (getAUSMV2Log(void)::onceToken != -1)
              dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
            v11 = (id)getAUSMV2Log(void)::gLog;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              v12 = (_QWORD *)((char *)this + 40);
              if (*((char *)this + 63) < 0)
                v12 = (_QWORD *)*v12;
              *(_DWORD *)buf = 136315138;
              v17 = v12;
              _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_DEFAULT, "Unregistering device orientation observer %s", buf, 0xCu);
            }

            CAUnregisterDeviceOrientation();
          }
        }
        std::mutex::unlock((std::mutex *)((char *)this + 80));
        v10 = v15;
        if (!v15)
          goto LABEL_28;
      }
      else
      {
        v10 = v6;
      }
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
LABEL_28:
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1B61B052C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  std::mutex *v10;

  std::mutex::unlock(v10);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::__shared_weak_count::__release_weak(v9);
  _Unwind_Resume(a1);
}

uint64_t std::__lock_first<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8;
  int v9;
  uint64_t v11;
  char v12;

  while (a1 == 1)
  {
    v11 = a3;
    v12 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a3);
    v9 = std::try_lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(a4, a2);
    if (v9 == -1)
    {
LABEL_10:
      v11 = 0;
      v12 = 0;
      return std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v11);
    }
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v11);
    if (v9 == 1)
      a1 = 0;
    else
      a1 = v9 + 2;
LABEL_9:
    sched_yield();
  }
  if (!a1)
  {
    v11 = a2;
    v12 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a2);
    v8 = std::try_lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(a3, a4);
    if (v8 == -1)
      goto LABEL_10;
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v11);
    a1 = v8 + 1;
    goto LABEL_9;
  }
  return std::__lock_first<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>((a1 - 2), a4, a2, a3);
}

void sub_1B61B0654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

OpaqueAudioConverter *AUSpatialMixerV2::DisposeInputConverters(AUSpatialMixerV2 *this)
{
  OpaqueAudioConverter *v2;
  OpaqueAudioConverter *result;

  v2 = (OpaqueAudioConverter *)*((_QWORD *)this + 391);
  if (v2)
    AudioConverterDispose(v2);
  *((_QWORD *)this + 391) = 0;
  result = (OpaqueAudioConverter *)*((_QWORD *)this + 392);
  if (result)
    result = (OpaqueAudioConverter *)AudioConverterDispose(result);
  *((_QWORD *)this + 392) = 0;
  return result;
}

uint64_t AUSpatialMixerV2::DisposeOutputConverter(AUSpatialMixerV2 *this)
{
  OpaqueAudioConverter *v2;

  v2 = (OpaqueAudioConverter *)*((_QWORD *)this + 393);
  if (v2)
    AudioConverterDispose(v2);
  *((_QWORD *)this + 393) = 0;
  return AUSpatialMixerV2::DisposeOutputCaptureFile((uint64_t)this);
}

AUSM::AUFXWrapper *std::unique_ptr<AUSM::AUFXWrapper>::reset[abi:ne180100](AUSM::AUFXWrapper **a1)
{
  AUSM::AUFXWrapper *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    AUSM::AUFXWrapper::~AUFXWrapper(result);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

uint64_t std::scoped_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::__unlock_unpack[abi:ne180100]<0ul,1ul,2ul>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = a1[1];
  v2 = a1[2];
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(*a1);
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v1);
  return caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(v2);
}

void AUSM::AUFXWrapper::~AUFXWrapper(AUSM::AUFXWrapper *this)
{
  OpaqueAudioComponentInstance *v2;
  NSObject *v3;
  _QWORD *v4;
  void *v5;
  void *v6;
  void *v7;
  int v8;
  const char *v9;
  __int16 v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = *(OpaqueAudioComponentInstance **)this;
  if (v2)
  {
    AudioComponentInstanceDispose(v2);
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v3 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = (_QWORD *)((char *)this + 72);
      if (*((char *)this + 95) < 0)
        v4 = (_QWORD *)*v4;
      v8 = 136315394;
      v9 = "~AUFXWrapper";
      v10 = 2080;
      v11 = v4;
      _os_log_impl(&dword_1B5ED0000, v3, OS_LOG_TYPE_DEFAULT, "%s: disposing of %s", (uint8_t *)&v8, 0x16u);
    }

    *(_QWORD *)this = 0;
  }
  v5 = (void *)*((_QWORD *)this + 23);
  if (v5)
  {
    *((_QWORD *)this + 24) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 20);
  if (v6)
  {
    *((_QWORD *)this + 21) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 17);
  if (v7)
  {
    *((_QWORD *)this + 18) = v7;
    operator delete(v7);
  }
  if (*((char *)this + 119) < 0)
    operator delete(*((void **)this + 12));
  if (*((char *)this + 95) < 0)
    operator delete(*((void **)this + 9));
}

void sub_1B61B08A0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t AUSpatialMixerV2::DisposeOutputCaptureFile(uint64_t this)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD *v3;
  int v4;
  _QWORD *v5;
  __int16 v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(this + 3288))
  {
    v1 = this;
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v2 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      v3 = (_QWORD *)(v1 + 3592);
      if (*(char *)(v1 + 3615) < 0)
        v3 = (_QWORD *)*v3;
      v4 = 136315394;
      v5 = v3;
      v6 = 2080;
      v7 = "DisposeOutputCaptureFile";
      _os_log_debug_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEBUG, "[%s|%s] Disposing output capture file", (uint8_t *)&v4, 0x16u);
    }

    this = ExtAudioFileDispose(*(ExtAudioFileRef *)(v1 + 3288));
    *(_QWORD *)(v1 + 3288) = 0;
  }
  return this;
}

uint64_t std::try_lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  uint64_t v6;
  char v7;

  v6 = a1;
  v3 = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock(a1);
  v7 = v3;
  if (v3)
  {
    if (caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock(a2))
    {
      v6 = 0;
      v7 = 0;
      v4 = 0xFFFFFFFFLL;
    }
    else
    {
      v4 = 1;
    }
  }
  else
  {
    v4 = 0;
  }
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v6);
  return v4;
}

void sub_1B61B0A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const*&>(const __CFDictionary *a1, const void *a2)
{
  const __CFBoolean *v2;
  int v3;

  v2 = (const __CFBoolean *)applesauce::CF::details::at_key<__CFString const*&>(a1, a2);
  if (v2)
  {
    LOWORD(v2) = applesauce::CF::convert_as<BOOL,0>(v2);
    v3 = BYTE1(v2);
  }
  else
  {
    v3 = 0;
  }
  return v2 | (v3 << 8);
}

CFIndex ___ZN16AUSpatialMixerV210InitializeEv_block_invoke_100(uint64_t a1)
{
  uint64_t v1;
  unsigned int AppIntegerValue;
  BOOL v3;
  unsigned int v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  AUSM::Properties *v8;
  NSObject *v9;
  _QWORD *v11;
  uint64_t v12;
  char v13;
  CFTypeRef v14;
  uint8_t buf[4];
  _QWORD *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const __CFString *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  HIBYTE(v14) = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("ausm_source_mode_override"), CFSTR("com.apple.coreaudio"), (Boolean *)&v14 + 7);
  LODWORD(v14) = AppIntegerValue;
  if (HIBYTE(v14))
    v3 = AppIntegerValue > 3;
  else
    v3 = 1;
  if (!v3)
  {
    v12 = v1 + 3352;
    v13 = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v1 + 3352));
    v4 = 0;
    v5 = 0;
    while (1)
    {
      v6 = *(_QWORD *)(v1 + 120);
      if (v6)
        LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
      else
        v7 = (*(_QWORD *)(v1 + 104) - *(_QWORD *)(v1 + 96)) >> 3;
      if (v4 >= v7)
        break;
      *(_DWORD *)buf = 0;
      v8 = (AUSM::Properties *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(v1 + 80), v4) + 1056);
      AUSM::Properties::getProperty(v8, 0xBBDu, buf);
      if (*(_DWORD *)buf != (_DWORD)v14)
      {
        AUSM::Properties::setProperty(v8, 3005, &v14, 4, 0);
        v5 = 1;
      }
      ++v4;
    }
    if ((v5 & 1) != 0)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v9 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v11 = (_QWORD *)(v1 + 3592);
        if (*(char *)(v1 + 3615) < 0)
          v11 = (_QWORD *)*v11;
        *(_DWORD *)buf = 136315906;
        v16 = v11;
        v17 = 2080;
        v18 = "Initialize_block_invoke";
        v19 = 2112;
        v20 = CFSTR("ausm_source_mode_override");
        v21 = 1024;
        v22 = (int)v14;
        _os_log_debug_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_DEBUG, "[%s|%s] Applied defaults write %@ %u", buf, 0x26u);
      }

      atomic_store(1u, (unsigned __int8 *)(v1 + 3240));
    }
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v12);
  }
  return AUSpatialMixerV2::DebugSoloInputElement((AUSpatialMixerV2 *)v1);
}

void sub_1B61B0C7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _Unwind_Resume(exception_object);
}

CFIndex AUSpatialMixerV2::DebugSoloInputElement(AUSpatialMixerV2 *this)
{
  CFIndex result;
  __n128 v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  char *v10;
  const char *v11;
  Boolean keyExistsAndHasValidFormat;
  uint8_t buf[4];
  char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  keyExistsAndHasValidFormat = 0;
  result = CFPreferencesGetAppIntegerValue(CFSTR("ausm_solo_input"), CFSTR("com.apple.coreaudio"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
  {
    v4 = result;
    v5 = 0;
    v3.n128_u32[1] = 0;
    while (1)
    {
      v6 = *((_QWORD *)this + 15);
      result = v6
             ? (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6)
             : (*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3;
      if (v5 >= result)
        break;
      if (v4 == (_DWORD)v5)
        v3.n128_f32[0] = 1.0;
      else
        v3.n128_f32[0] = 0.0;
      v7 = (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, uint64_t, uint64_t, _QWORD, __n128))(*(_QWORD *)this + 152))(this, 5, 1, v5, 0, v3);
      if (v7)
      {
        v8 = v7;
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v9 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          v10 = (char *)this + 3592;
          if (*((char *)this + 3615) < 0)
            v10 = (char *)*((_QWORD *)this + 449);
          *(_DWORD *)buf = 136316162;
          v11 = "disabled";
          if (v4 == (_DWORD)v5)
            v11 = "enabled";
          v14 = v10;
          v15 = 2080;
          v16 = "DebugSoloInputElement";
          v17 = 1024;
          v18 = v5;
          v19 = 2080;
          v20 = v11;
          v21 = 1024;
          v22 = v8;
          _os_log_error_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_ERROR, "[%s|%s] Solo: could not set input #%u to %s, err = %d", buf, 0x2Cu);
        }

      }
      v5 = (v5 + 1);
    }
  }
  return result;
}

void AUSpatialMixerV2::InitializeOutputConverter(AudioConverterRef *this)
{
  uint64_t Element;
  __int128 v3;
  NSObject *v4;
  void *v5;
  int v6;
  NSObject *v7;
  CATimeUtilities *v8;
  unint64_t CurrentGregorianDate;
  _QWORD *v10;
  double v11;
  char *v12;
  char *v13;
  void **v14;
  CFStringRef v15;
  NSObject *v16;
  char *v17;
  Float64 mSampleRate;
  CFURLRef v19;
  uint64_t v20;
  ExtAudioFileRef *v21;
  __int128 v22;
  OSStatus v23;
  NSObject *v24;
  NSObject *v25;
  OSStatus v26;
  NSObject *v27;
  _QWORD *v28;
  const char *v29;
  _QWORD *v30;
  _QWORD *v31;
  std::runtime_error *exception;
  AudioStreamBasicDescription inSourceFormat;
  AudioStreamBasicDescription inDestinationFormat;
  AudioStreamBasicDescription __p;
  CFURLRef inURL;
  CFStringRef filePath;
  void *v38[2];
  char v39;
  uint8_t v40[4];
  char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  OSStatus v45;
  _BYTE buf[32];
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  AUSpatialMixerV2::DisposeOutputConverter((AUSpatialMixerV2 *)this);
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(this + 16), 0);
  v3 = *(_OWORD *)(Element + 96);
  *(_OWORD *)&inDestinationFormat.mSampleRate = *(_OWORD *)(Element + 80);
  *(_OWORD *)&inDestinationFormat.mBytesPerPacket = v3;
  *(_QWORD *)&inDestinationFormat.mBitsPerChannel = *(_QWORD *)(Element + 112);
  inDestinationFormat.mSampleRate = 44100.0;
  inSourceFormat.mSampleRate = 44100.0;
  *(_OWORD *)&inSourceFormat.mFormatID = xmmword_1B6626900;
  inSourceFormat.mBytesPerFrame = 4;
  inSourceFormat.mChannelsPerFrame = HIDWORD(v3);
  *(_QWORD *)&inSourceFormat.mBitsPerChannel = 32;
  AudioConverterNew(&inSourceFormat, &inDestinationFormat, this + 393);
  if (this[411])
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v4 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v30 = this + 449;
      if (*((char *)this + 3615) < 0)
        v30 = (_QWORD *)*v30;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v30;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "CreateOutputCaptureFileIfNecessary";
      _os_log_debug_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "[%s|%s] Inconsistent behaviour: there was already an output capture file! Disposing of it.", buf, 0x16u);
    }

    AUSpatialMixerV2::DisposeOutputCaptureFile((uint64_t)this);
  }
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99EA0]), "initWithSuiteName:", CFSTR("com.apple.coreaudio"));
  if ((objc_msgSend(v5, "BOOLForKey:", CFSTR("ausm_capture_all")) & 1) != 0)
    v6 = 1;
  else
    v6 = objc_msgSend(v5, "BOOLForKey:", CFSTR("ausm_capture_output"));
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v7 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v28 = this + 449;
    if (*((char *)this + 3615) < 0)
      v28 = (_QWORD *)*v28;
    v29 = "no";
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = v28;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "CreateOutputCaptureFileIfNecessary";
    if (v6)
      v29 = "yes";
    *(_WORD *)&buf[22] = 2080;
    *(_QWORD *)&buf[24] = v29;
    _os_log_debug_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_DEBUG, "[%s|%s] Creating the output capture file: %s", buf, 0x20u);
  }

  if (v6)
  {
    if (*((char *)this + 6127) < 0)
    {
      if (this[764])
      {
LABEL_15:
        CurrentGregorianDate = CATimeUtilities::GetCurrentGregorianDate(v8);
        v10 = this + 763;
        caulk::make_string((caulk *)"%d%02d%02d.%02d%02d%02d", (uint64_t)v38, CurrentGregorianDate, ((int)(CurrentGregorianDate >> 8) >> 24), ((int)(CurrentGregorianDate >> 16) >> 24), ((int)(CurrentGregorianDate >> 24) >> 24), (SHIDWORD(CurrentGregorianDate) >> 24), (int)v11);
        if (*((char *)this + 6127) < 0)
          v10 = (_QWORD *)*v10;
        v12 = (char *)(this + 449);
        v13 = (char *)(this + 449);
        if (*((char *)this + 3615) < 0)
          v13 = *(char **)v12;
        v14 = v38;
        if (v39 < 0)
          v14 = (void **)v38[0];
        v15 = CFStringCreateWithFormat(0, 0, CFSTR("%s/ausm_%s_output_%s_%u.caf"), v10, v13, v14, *((unsigned int *)this + 824));
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&filePath, v15);
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v16 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = (char *)(this + 449);
          if (*((char *)this + 3615) < 0)
            v17 = *(char **)v12;
          if (!filePath)
          {
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Could not construct");
          }
          applesauce::CF::convert_to<std::string,0>(filePath, (uint64_t)&__p);
          if ((__p.mFramesPerPacket & 0x80000000) == 0)
            mSampleRate = COERCE_DOUBLE(&__p);
          else
            mSampleRate = __p.mSampleRate;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v17;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "CreateOutputCaptureFileIfNecessary";
          *(_WORD *)&buf[22] = 2080;
          *(Float64 *)&buf[24] = mSampleRate;
          _os_log_impl(&dword_1B5ED0000, v16, OS_LOG_TYPE_DEFAULT, "[%s|%s] Capture file: %s", buf, 0x20u);
          if (SHIBYTE(__p.mFramesPerPacket) < 0)
            operator delete(*(void **)&__p.mSampleRate);
        }

        v19 = CFURLCreateWithFileSystemPath(0, filePath, kCFURLPOSIXPathStyle, 0);
        applesauce::CF::URLRef::URLRef((applesauce::CF::URLRef *)&inURL, v19);
        v20 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(this + 16), 0);
        v21 = this + 411;
        v22 = *(_OWORD *)(v20 + 96);
        *(_OWORD *)buf = *(_OWORD *)(v20 + 80);
        *(_OWORD *)&buf[16] = v22;
        v47 = *(_QWORD *)(v20 + 112);
        __p.mSampleRate = *(Float64 *)buf;
        *(_QWORD *)&__p.mFormatID = 0x96C70636DLL;
        __p.mBytesPerPacket = 4 * HIDWORD(v22);
        __p.mFramesPerPacket = 1;
        __p.mBytesPerFrame = 4 * HIDWORD(v22);
        __p.mChannelsPerFrame = HIDWORD(v22);
        *(_QWORD *)&__p.mBitsPerChannel = 32;
        v23 = ExtAudioFileCreateWithURL(inURL, 0x63616666u, &__p, 0, 1u, this + 411);
        if (v23)
        {
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v24 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            if (*((char *)this + 3615) < 0)
              v12 = *(char **)v12;
            *(_DWORD *)v40 = 136315650;
            v41 = v12;
            v42 = 2080;
            v43 = "CreateOutputCaptureFileIfNecessary";
            v44 = 1024;
            v45 = v23;
            _os_log_error_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_ERROR, "[%s|%s] ERROR: Could not create mixer output capture file (ExtAudioFileCreateWithURL returned %d)", v40, 0x1Cu);
          }

        }
        else
        {
          v26 = ExtAudioFileSetProperty(*v21, 0x63666D74u, 0x28u, buf);
          if (!v26)
          {
LABEL_48:
            ++*((_DWORD *)this + 824);
            if (inURL)
              CFRelease(inURL);
            if (filePath)
              CFRelease(filePath);
            if (v39 < 0)
              operator delete(v38[0]);
            goto LABEL_54;
          }
          if (getAUSMV2Log(void)::onceToken != -1)
            dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
          v27 = (id)getAUSMV2Log(void)::gLog;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            if (*((char *)this + 3615) < 0)
              v12 = *(char **)v12;
            *(_DWORD *)v40 = 136315650;
            v41 = v12;
            v42 = 2080;
            v43 = "CreateOutputCaptureFileIfNecessary";
            v44 = 1024;
            v45 = v26;
            _os_log_error_impl(&dword_1B5ED0000, v27, OS_LOG_TYPE_ERROR, "[%s|%s] ERROR: Could not create mixer output file (ExtAudioFileSetProperty with kExtAudioFileProperty_ClientDataFormat returned %d)", v40, 0x1Cu);
          }

          ExtAudioFileDispose(*v21);
        }
        *v21 = 0;
        goto LABEL_48;
      }
    }
    else if (*((_BYTE *)this + 6127))
    {
      goto LABEL_15;
    }
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v25 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v31 = this + 449;
      if (*((char *)this + 3615) < 0)
        v31 = (_QWORD *)*v31;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v31;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "CreateOutputCaptureFileIfNecessary";
      _os_log_error_impl(&dword_1B5ED0000, v25, OS_LOG_TYPE_ERROR, "[%s|%s] ERROR: Could not create mixer output capture file (no capture dir path available)", buf, 0x16u);
    }

  }
LABEL_54:

}

void sub_1B61B15E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,CFTypeRef a32,CFTypeRef cf,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  void *v39;
  void *v40;
  void *v41;

  __cxa_free_exception(v40);

  if (cf)
    CFRelease(cf);
  if (a39 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void AUSpatialMixerV2::UpdateDiffuseProcessors(AUSpatialMixerV2 *this)
{
  unsigned __int8 v1;
  ausdk::AUScope *v3;
  uint64_t Element;
  ausdk::AUChannelLayout *v5;
  const AudioChannelLayout *v6;
  unsigned int v7;
  NSObject *v8;
  IR::IRProcessor *v9;
  uint64_t v10;
  unsigned int v11;
  _QWORD *v12;
  _QWORD *v13;
  const char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  unsigned int v18;
  BOOL v19;
  float v20;
  uint64_t v21;
  IR::IRProcessor *v22;
  _QWORD *v23;
  char *v24;
  int v25;
  AudioChannelLayout buf;

  *(_QWORD *)&buf.mChannelDescriptions[0].mCoordinates[1] = *MEMORY[0x1E0C80C00];
  v1 = atomic_load((unsigned __int8 *)this + 2816);
  if ((v1 & 1) == 0)
    return;
  v3 = (AUSpatialMixerV2 *)((char *)this + 128);
  Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
  v5 = *(ausdk::AUChannelLayout **)(Element + 120);
  v7 = ausdk::AUChannelLayout::NumberChannels(v5, v6);
  if ((*(_DWORD *)v5 | 0x10000) == 0x10000)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v8 = (id)getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      goto LABEL_6;
    v23 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v23 = (_QWORD *)*v23;
    buf.mChannelLayoutTag = 136315394;
    *(_QWORD *)&buf.mChannelBitmap = v23;
    LOWORD(buf.mChannelDescriptions[0].mChannelLabel) = 2080;
    *(_QWORD *)((char *)&buf.mChannelDescriptions[0].mChannelLabel + 2) = "UpdateDiffuseProcessors";
    v14 = "[%s|%s] Error: this output layout tag is not supported";
LABEL_53:
    _os_log_error_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&buf, 0x16u);
LABEL_6:

    v9 = (AUSpatialMixerV2 *)((char *)this + 7784);
    v10 = 7296;
    do
    {
      if (*((_BYTE *)v9 + 448))
      {
        IR::IRProcessor::~IRProcessor(v9);
        *((_BYTE *)v9 + 448) = 0;
      }
      v9 = (IR::IRProcessor *)((char *)v9 + 456);
      v10 -= 456;
    }
    while (v10);
    *((_DWORD *)this + 3771) = 0;
    return;
  }
  v11 = v7;
  if (!v7)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v8 = (id)getAUSMV2Log(void)::gLog;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      goto LABEL_6;
    v13 = (_QWORD *)((char *)this + 3592);
    if (*((char *)this + 3615) < 0)
      v13 = (_QWORD *)*v13;
    buf.mChannelLayoutTag = 136315394;
    *(_QWORD *)&buf.mChannelBitmap = v13;
    LOWORD(buf.mChannelDescriptions[0].mChannelLabel) = 2080;
    *(_QWORD *)((char *)&buf.mChannelDescriptions[0].mChannelLabel + 2) = "UpdateDiffuseProcessors";
    v14 = "[%s|%s] Error: this output layout is invalid";
    goto LABEL_53;
  }
  if (v7 >= 0x11)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v8 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v12 = (_QWORD *)((char *)this + 3592);
      if (*((char *)this + 3615) < 0)
        v12 = (_QWORD *)*v12;
      buf.mChannelLayoutTag = 136315394;
      *(_QWORD *)&buf.mChannelBitmap = v12;
      LOWORD(buf.mChannelDescriptions[0].mChannelLabel) = 2080;
      *(_QWORD *)((char *)&buf.mChannelDescriptions[0].mChannelLabel + 2) = "UpdateDiffuseProcessors";
      _os_log_debug_impl(&dword_1B5ED0000, v8, OS_LOG_TYPE_DEBUG, "[%s|%s] Not enough DiffuseProcessors for this output layout!", (uint8_t *)&buf, 0x16u);
    }
    goto LABEL_6;
  }
  if (*(_DWORD *)v5 != *((_DWORD *)this + 3770))
  {
    *((_DWORD *)this + 3771) = 0;
    GetChannelLayoutChannelLabels(&buf, (int *)v5);
    v15 = 0;
    v16 = (char *)this + 7784;
    v17 = (char *)&AUSM::kDiffuseCoeffs;
    do
    {
      v18 = *(_DWORD *)(*(_QWORD *)&buf.mChannelLayoutTag + v15);
      v19 = v18 > 0x3E || ((0x4000002000000010uLL >> v18) & 1) == 0;
      if (!v19 || v18 == 45 || v18 == 40)
      {
        if (v16[448])
        {
          IR::IRProcessor::~IRProcessor((IR::IRProcessor *)v16);
          v16[448] = 0;
        }
      }
      else
      {
        if (v16[448])
        {
          (*(void (**)(char *))(*(_QWORD *)v16 + 24))(v16);
          (*(void (**)(char *))(*(_QWORD *)v16 + 32))(v16);
        }
        else
        {
          IR::IRProcessor::IRProcessor((IR::IRProcessor *)v16, 512, 0.0, 1, 128, 1, 0);
          v16[448] = 1;
        }
        v20 = *(double *)(ausdk::AUScope::SafeGetElement(v3, 0) + 80);
        (*(void (**)(char *, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)v16 + 16))(v16, *((unsigned int *)this + 84), 128, 0, 0, 0, 0, v20);
        v25 = 0;
        v24 = v17;
        (*(void (**)(char *, char **, int *, uint64_t, uint64_t))(*(_QWORD *)v16 + 208))(v16, &v24, &v25, 1, 512);
        ++*((_DWORD *)this + 3771);
      }
      v15 += 4;
      v17 += 2048;
      v16 += 456;
    }
    while (4 * v11 != v15);
    if (v11 <= 0xF)
    {
      v21 = v11 + 1;
      v22 = (AUSpatialMixerV2 *)((char *)this + 456 * v11 + 7784);
      do
      {
        if (*((_BYTE *)v22 + 448))
        {
          IR::IRProcessor::~IRProcessor(v22);
          *((_BYTE *)v22 + 448) = 0;
        }
        v22 = (IR::IRProcessor *)((char *)v22 + 456);
        v19 = (_DWORD)v21++ == 16;
      }
      while (!v19);
    }
    *((_DWORD *)this + 3770) = **(_DWORD **)(Element + 120);
    if (*(_QWORD *)&buf.mChannelLayoutTag)
    {
      *(_QWORD *)&buf.mNumberChannelDescriptions = *(_QWORD *)&buf.mChannelLayoutTag;
      operator delete(*(void **)&buf.mChannelLayoutTag);
    }
  }
}

void sub_1B61B1AF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[20],unsigned int &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  std::runtime_error *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1B61B1BB0(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

void IR::IRProcessor::~IRProcessor(IR::IRProcessor *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  void **v5;

  *(_QWORD *)this = &off_1E69E7F58;
  v2 = (void *)*((_QWORD *)this + 42);
  if (v2)
  {
    *((_QWORD *)this + 43) = v2;
    operator delete(v2);
  }
  v5 = (void **)((char *)this + 312);
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)((char *)this + 288);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v3 = (void *)*((_QWORD *)this + 33);
  if (v3)
  {
    *((_QWORD *)this + 34) = v3;
    operator delete(v3);
  }
  v5 = (void **)((char *)this + 240);
  std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)((char *)this + 216);
  std::vector<IR::DelayLine>::__destroy_vector::operator()[abi:ne180100](&v5);
  v4 = *((_QWORD *)this + 25);
  *((_QWORD *)this + 25) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 184);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRProcessor *)((char *)this + 24));
}

{
  IR::IRProcessor::~IRProcessor(this);
  JUMPOUT(0x1BCC95CECLL);
}

uint64_t AUSM::AUFXWrapper::AUFXWrapper(uint64_t a1, OSType a2, __int128 *a3)
{
  _OWORD *v5;
  __int128 v6;
  void **v7;
  OpaqueAudioComponent *Next;
  NSObject *v9;
  NSObject *v10;
  AudioComponentDescription inDesc;
  std::vector<char>::value_type __x[4];
  const char *v14;
  __int16 v15;
  _OWORD *v16;
  __int16 v17;
  void **v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = 0;
  v5 = (_OWORD *)(a1 + 72);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 72), *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v6 = *a3;
    *(_QWORD *)(a1 + 88) = *((_QWORD *)a3 + 2);
    *v5 = v6;
  }
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  v7 = (void **)(a1 + 96);
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 120) = a2;
  *(_BYTE *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  __x[0] = 0;
  std::vector<char>::vector((std::vector<char> *)(a1 + 160), 8uLL, __x);
  **(_DWORD **)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  if (*(char *)(a1 + 119) < 0)
    operator delete(*v7);
  *(_BYTE *)(a1 + 96) = HIBYTE(a2);
  *(_BYTE *)(a1 + 97) = BYTE2(a2);
  *(_BYTE *)(a1 + 98) = BYTE1(a2);
  *(_BYTE *)(a1 + 99) = a2;
  *(_WORD *)(a1 + 100) = 0;
  *(_BYTE *)(a1 + 119) = 5;
  inDesc.componentType = 1635083896;
  inDesc.componentSubType = a2;
  *(_QWORD *)&inDesc.componentManufacturer = 1634758764;
  inDesc.componentFlagsMask = 0;
  Next = AudioComponentFindNext(0, &inDesc);
  if (!Next)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v10 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 95) < 0)
        v5 = *(_OWORD **)v5;
      if (*(char *)(a1 + 119) < 0)
        v7 = (void **)*v7;
      *(_DWORD *)__x = 136315650;
      v14 = "AUFXWrapper";
      v15 = 2080;
      v16 = v5;
      v17 = 2080;
      v18 = v7;
      _os_log_error_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_ERROR, "%s %s: could not find aufx %s appl", (uint8_t *)__x, 0x20u);
    }
    goto LABEL_39;
  }
  if (!AudioComponentInstanceNew(Next, (AudioComponentInstance *)a1))
  {
    if (AudioComponentInstanceCanDo(*(AudioComponentInstance *)a1, 20))
    {
      *(_DWORD *)(a1 + 128) = 1;
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v10 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 95) < 0)
          v5 = *(_OWORD **)v5;
        if (*(char *)(a1 + 119) < 0)
          v7 = (void **)*v7;
        *(_DWORD *)__x = 136315650;
        v14 = "AUFXWrapper";
        v15 = 2080;
        v16 = v5;
        v17 = 2080;
        v18 = v7;
        _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEFAULT, "%s %s: aufx %s appl created; using BaseProcess",
          (uint8_t *)__x,
          0x20u);
      }
    }
    else if (AudioComponentInstanceCanDo(*(AudioComponentInstance *)a1, 21))
    {
      *(_DWORD *)(a1 + 128) = 2;
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v10 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 95) < 0)
          v5 = *(_OWORD **)v5;
        if (*(char *)(a1 + 119) < 0)
          v7 = (void **)*v7;
        *(_DWORD *)__x = 136315650;
        v14 = "AUFXWrapper";
        v15 = 2080;
        v16 = v5;
        v17 = 2080;
        v18 = v7;
        _os_log_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEFAULT, "%s %s: aufx %s appl created; using ProcessMultiple",
          (uint8_t *)__x,
          0x20u);
      }
    }
    else
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v10 = (id)getAUSMV2Log(void)::gLog;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a1 + 95) < 0)
          v5 = *(_OWORD **)v5;
        if (*(char *)(a1 + 119) < 0)
          v7 = (void **)*v7;
        *(_DWORD *)__x = 136315650;
        v14 = "AUFXWrapper";
        v15 = 2080;
        v16 = v5;
        v17 = 2080;
        v18 = v7;
        _os_log_error_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_ERROR, "%s %s: aufx %s appl only supports render method; processing will be bypassed",
          (uint8_t *)__x,
          0x20u);
      }
    }
LABEL_39:

    return a1;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v9 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a1 + 95) < 0)
      v5 = *(_OWORD **)v5;
    if (*(char *)(a1 + 119) < 0)
      v7 = (void **)*v7;
    *(_DWORD *)__x = 136315650;
    v14 = "AUFXWrapper";
    v15 = 2080;
    v16 = v5;
    v17 = 2080;
    v18 = v7;
    _os_log_error_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_ERROR, "%s %s: could not instantiate aufx %s appl", (uint8_t *)__x, 0x20u);
  }

  *(_QWORD *)a1 = 0;
  return a1;
}

void sub_1B61B2348(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<std::unique_ptr<AUSM::AUFXWrapper>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::unique_ptr<AUSM::AUFXWrapper>::reset[abi:ne180100]((AUSM::AUFXWrapper **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<std::unique_ptr<AUSM::AUFXWrapper>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  AUSM::AUFXWrapper **v2;
  AUSM::AUFXWrapper **v4;
  void *v5;

  v1 = *a1;
  v2 = (AUSM::AUFXWrapper **)**a1;
  if (v2)
  {
    v4 = (AUSM::AUFXWrapper **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<AUSM::AUFXWrapper>::reset[abi:ne180100](--v4);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ___ZN35AUSpatialMixerV2OrientationObserver16registerObserverEP28OpaqueAudioComponentInstancejRKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE_block_invoke(_QWORD *a1, int a2)
{
  uint64_t v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unsigned __int8 v9;
  NSObject *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  std::__shared_weak_count *v15;
  int inData;
  uint8_t buf[4];
  _DWORD v18[7];

  *(_QWORD *)&v18[5] = *MEMORY[0x1E0C80C00];
  inData = a2;
  v3 = a1[4];
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v4 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v13 = (_QWORD *)(v3 + 40);
    if (*(char *)(v3 + 63) < 0)
      v13 = (_QWORD *)*v13;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)v18 = v13;
    _os_log_debug_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "Orientation handler callback %s", buf, 0xCu);
  }

  v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    v15 = v6;
    if (v6)
    {
      v7 = v6;
      v8 = a1[5];
      if (!v8 || !std::mutex::try_lock((std::mutex *)(v8 + 80)))
        goto LABEL_14;
      v9 = atomic_load((unsigned __int8 *)(v8 + 72));
      if ((v9 & 1) != 0)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v10 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          v14 = (_QWORD *)(v8 + 40);
          if (*(char *)(v8 + 63) < 0)
            v14 = (_QWORD *)*v14;
          *(_DWORD *)buf = 67109378;
          v18[0] = inData;
          LOWORD(v18[1]) = 2080;
          *(_QWORD *)((char *)&v18[1] + 2) = v14;
          _os_log_debug_impl(&dword_1B5ED0000, v10, OS_LOG_TYPE_DEBUG, "Setting orientation %u on %s", buf, 0x12u);
        }

        AudioUnitSetProperty(*(AudioUnit *)(v8 + 24), *(_DWORD *)(v8 + 32), 0, 0, &inData, 4u);
      }
      std::mutex::unlock((std::mutex *)(v8 + 80));
      v7 = v15;
      if (v15)
      {
LABEL_14:
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v12 = __ldaxr(p_shared_owners);
        while (__stlxr(v12 - 1, p_shared_owners));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
  }
}

void sub_1B61B2690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  std::mutex *v10;

  std::mutex::unlock(v10);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_40c60_ZTSNSt3__18weak_ptrI35AUSpatialMixerV2OrientationObserverEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_ea8_40c60_ZTSNSt3__18weak_ptrI35AUSpatialMixerV2OrientationObserverEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void std::__shared_ptr_emplace<AUSpatialMixerV2OrientationObserver>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69CA5B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AUSpatialMixerV2OrientationObserver>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E69CA5B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC95CECLL);
}

void std::__shared_ptr_emplace<AUSpatialMixerV2OrientationObserver>::__on_zero_shared(uint64_t a1)
{
  const void *v2;
  std::__shared_weak_count *v3;

  AUSpatialMixerV2OrientationObserver::unregister((AUSpatialMixerV2OrientationObserver *)(a1 + 24));
  std::mutex::~mutex((std::mutex *)(a1 + 104));
  v2 = *(const void **)(a1 + 88);
  if (v2)
    CFRelease(v2);
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

void sub_1B61B2C80(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void ___ZN16AUSpatialMixerV2D2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD *v3;
  int v4;
  _QWORD *v5;
  __int16 v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v2 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = (_QWORD *)(v1 + 3592);
    if (*(char *)(v1 + 3615) < 0)
      v3 = (_QWORD *)*v3;
    v4 = 136315394;
    v5 = v3;
    v6 = 2080;
    v7 = "~AUSpatialMixerV2_block_invoke";
    _os_log_impl(&dword_1B5ED0000, v2, OS_LOG_TYPE_DEFAULT, "[%s|%s] Dispatch queue cleared", (uint8_t *)&v4, 0x16u);
  }

}

uint64_t std::__lock_first<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,std::shared_mutex>(int a1, uint64_t a2, uint64_t a3, std::__shared_mutex_base *a4)
{
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v17;
  char v18;

  while (a1 == 1)
  {
    v17 = a3;
    v18 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a3);
    v9 = std::try_lock[abi:ne180100]<std::shared_mutex,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(a4, a2);
    if (v9 == -1)
    {
LABEL_30:
      v17 = 0;
      v18 = 0;
      return std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v17);
    }
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v17);
    if (v9 == 1)
      a1 = 0;
    else
      a1 = v9 + 2;
LABEL_9:
    sched_yield();
  }
  if (!a1)
  {
    v17 = a2;
    v18 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a2);
    v8 = std::try_lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,std::shared_mutex>(a3, a4);
    if (v8 == -1)
      goto LABEL_30;
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v17);
    a1 = v8 + 1;
    goto LABEL_9;
  }
  v10 = a1 - 2;
  while (v10 == 1)
  {
    v17 = a2;
    v18 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a2);
    v12 = std::try_lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,std::shared_mutex>(a3, a4);
    if (v12 == -1)
      goto LABEL_30;
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v17);
    if (v12 == 1)
      v10 = 0;
    else
      v10 = v12 + 2;
LABEL_19:
    sched_yield();
  }
  if (!v10)
  {
    v17 = (uint64_t)a4;
    v18 = 1;
    std::__shared_mutex_base::lock(a4);
    v11 = std::try_lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(a2, a3);
    if (v11 == -1)
    {
LABEL_31:
      v17 = 0;
      v18 = 0;
      return std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v17);
    }
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v17);
    v10 = v11 + 1;
    goto LABEL_19;
  }
  v13 = v10 - 2;
  while (v13 == 1)
  {
    v17 = (uint64_t)a4;
    v18 = 1;
    std::__shared_mutex_base::lock(a4);
    v15 = std::try_lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(a2, a3);
    if (v15 == -1)
      goto LABEL_31;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v17);
    if (v15 == 1)
      v13 = 0;
    else
      v13 = v15 + 2;
LABEL_29:
    sched_yield();
  }
  if (!v13)
  {
    v17 = a3;
    v18 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(a3);
    v14 = std::try_lock[abi:ne180100]<std::shared_mutex,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(a4, a2);
    if (v14 == -1)
      goto LABEL_30;
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v17);
    v13 = v14 + 1;
    goto LABEL_29;
  }
  return std::__lock_first<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,std::shared_mutex>((v13 - 2), a2, a3, a4);
}

void sub_1B61B2FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<AUSM::RoomCongruence::Processor>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  void *v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    AUSM::RoomCongruence::Cache::~Cache((AUSM::RoomCongruence::Cache *)(v2 + 168));
    v3 = *(void **)(v2 + 104);
    if (v3)
    {
      *(_QWORD *)(v2 + 112) = v3;
      operator delete(v3);
    }
    std::__hash_table<std::__hash_value_type<IR::IRPreset,AUSM::RoomCongruence::UserData>,std::__unordered_map_hasher<IR::IRPreset,std::__hash_value_type<IR::IRPreset,AUSM::RoomCongruence::UserData>,std::hash<IR::IRPreset>,std::equal_to<IR::IRPreset>,true>,std::__unordered_map_equal<IR::IRPreset,std::__hash_value_type<IR::IRPreset,AUSM::RoomCongruence::UserData>,std::equal_to<IR::IRPreset>,std::hash<IR::IRPreset>,true>,std::allocator<std::__hash_value_type<IR::IRPreset,AUSM::RoomCongruence::UserData>>>::~__hash_table(v2 + 64);
    v4 = *(void **)(v2 + 40);
    if (v4)
    {
      *(_QWORD *)(v2 + 48) = v4;
      operator delete(v4);
    }
    if (*(char *)(v2 + 23) < 0)
      operator delete(*(void **)v2);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void AUSM::GlobalProperties::~GlobalProperties(AUSM::GlobalProperties *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;

  *(_QWORD *)this = &off_1E69D5650;
  if (*((char *)this + 2543) < 0)
    operator delete(*((void **)this + 315));
  std::mutex::~mutex((std::mutex *)((char *)this + 2352));
  v2 = (const void *)*((_QWORD *)this + 293);
  if (v2)
    CFRelease(v2);
  std::mutex::~mutex((std::mutex *)((char *)this + 2280));
  v3 = (const void *)*((_QWORD *)this + 284);
  if (v3)
    CFRelease(v3);
  std::mutex::~mutex((std::mutex *)((char *)this + 2208));
  v4 = (const void *)*((_QWORD *)this + 275);
  if (v4)
    CFRelease(v4);
  std::mutex::~mutex((std::mutex *)((char *)this + 2136));
  v5 = (const void *)*((_QWORD *)this + 266);
  if (v5)
    CFRelease(v5);
  std::mutex::~mutex((std::mutex *)((char *)this + 2064));
  v6 = (const void *)*((_QWORD *)this + 257);
  if (v6)
    CFRelease(v6);
  std::mutex::~mutex((std::mutex *)((char *)this + 1992));
  v7 = (const void *)*((_QWORD *)this + 248);
  if (v7)
    CFRelease(v7);
  std::mutex::~mutex((std::mutex *)this + 30);
  v8 = (const void *)*((_QWORD *)this + 239);
  if (v8)
    CFRelease(v8);
  std::mutex::~mutex((std::mutex *)((char *)this + 1848));
  v9 = (const void *)*((_QWORD *)this + 230);
  if (v9)
    CFRelease(v9);
  std::mutex::~mutex((std::mutex *)((char *)this + 1776));
  v10 = (const void *)*((_QWORD *)this + 221);
  if (v10)
    CFRelease(v10);
  std::mutex::~mutex((std::mutex *)((char *)this + 1704));
  v11 = (const void *)*((_QWORD *)this + 212);
  if (v11)
    CFRelease(v11);
  std::mutex::~mutex((std::mutex *)((char *)this + 1632));
  v12 = (const void *)*((_QWORD *)this + 203);
  if (v12)
    CFRelease(v12);
  v13 = (void *)*((_QWORD *)this + 200);
  if (v13)
  {
    *((_QWORD *)this + 201) = v13;
    operator delete(v13);
  }
  std::mutex::~mutex((std::mutex *)this + 24);
  v14 = (const void *)*((_QWORD *)this + 191);
  if (v14)
    CFRelease(v14);
  std::mutex::~mutex((std::mutex *)((char *)this + 1432));
  v15 = (const void *)*((_QWORD *)this + 178);
  if (v15)
    CFRelease(v15);
  std::mutex::~mutex((std::mutex *)((char *)this + 1360));
  v16 = (const void *)*((_QWORD *)this + 169);
  if (v16)
    CFRelease(v16);
  std::mutex::~mutex((std::mutex *)this + 20);
  v17 = (const void *)*((_QWORD *)this + 159);
  if (v17)
    CFRelease(v17);
  std::mutex::~mutex((std::mutex *)((char *)this + 1200));
  v18 = (const void *)*((_QWORD *)this + 149);
  if (v18)
    CFRelease(v18);
  std::mutex::~mutex((std::mutex *)((char *)this + 1120));
  v19 = (const void *)*((_QWORD *)this + 139);
  if (v19)
    CFRelease(v19);
  std::mutex::~mutex((std::mutex *)((char *)this + 1048));
  v20 = (const void *)*((_QWORD *)this + 130);
  if (v20)
    CFRelease(v20);
  std::mutex::~mutex((std::mutex *)((char *)this + 976));
  v21 = (const void *)*((_QWORD *)this + 121);
  if (v21)
    CFRelease(v21);
  std::mutex::~mutex((std::mutex *)((char *)this + 904));
  v22 = (const void *)*((_QWORD *)this + 112);
  if (v22)
    CFRelease(v22);
  std::mutex::~mutex((std::mutex *)this + 13);
  v23 = (const void *)*((_QWORD *)this + 103);
  if (v23)
    CFRelease(v23);
  std::mutex::~mutex((std::mutex *)((char *)this + 760));
  v24 = (const void *)*((_QWORD *)this + 94);
  if (v24)
    CFRelease(v24);
  std::mutex::~mutex((std::mutex *)((char *)this + 688));
  v25 = (const void *)*((_QWORD *)this + 85);
  if (v25)
    CFRelease(v25);
  std::mutex::~mutex((std::mutex *)((char *)this + 616));
  v26 = (const void *)*((_QWORD *)this + 76);
  if (v26)
    CFRelease(v26);
  std::mutex::~mutex((std::mutex *)((char *)this + 544));
  v27 = (const void *)*((_QWORD *)this + 67);
  if (v27)
    CFRelease(v27);
  std::mutex::~mutex((std::mutex *)((char *)this + 472));
  v28 = (const void *)*((_QWORD *)this + 58);
  if (v28)
    CFRelease(v28);
  std::mutex::~mutex((std::mutex *)((char *)this + 400));
  v29 = (const void *)*((_QWORD *)this + 49);
  if (v29)
    CFRelease(v29);
  std::mutex::~mutex((std::mutex *)((char *)this + 328));
  v30 = (const void *)*((_QWORD *)this + 40);
  if (v30)
    CFRelease(v30);
  std::mutex::~mutex((std::mutex *)this + 4);
  v31 = (const void *)*((_QWORD *)this + 31);
  if (v31)
    CFRelease(v31);
  std::mutex::~mutex((std::mutex *)((char *)this + 184));
  v32 = (const void *)*((_QWORD *)this + 22);
  if (v32)
    CFRelease(v32);
  *(_QWORD *)this = &off_1E69E0768;
  std::__tree<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<AUSM::PropertyDescriptor>>>>::destroy(*((_QWORD **)this + 6));
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

void ***std::unique_ptr<TorqueEngine>::reset[abi:ne180100](void ***result, void **a2)
{
  void **v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    free(v2[1975]);
    free(v2[1845]);
    free(v2[1715]);
    free(v2[1585]);
    free(v2[1455]);
    free(v2[1325]);
    free(v2[1195]);
    free(v2[1065]);
    STFT<float>::~STFT((uint64_t)(v2 + 5));
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

void IR::SharedIRBuses::~SharedIRBuses(IR::SharedIRBuses *this)
{
  void *v2;
  void *v3;
  void *v4;
  void **v5;

  v5 = (void **)((char *)this + 200);
  std::vector<std::shared_ptr<vp::vx::io::Node_Terminal>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)((char *)this + 176);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)((char *)this + 152);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)
  {
    *((_QWORD *)this + 16) = v2;
    operator delete(v2);
  }
  v5 = (void **)((char *)this + 96);
  std::vector<std::shared_ptr<vp::vx::io::Node_Terminal>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v3 = (void *)*((_QWORD *)this + 9);
  if (v3)
  {
    *((_QWORD *)this + 10) = v3;
    operator delete(v3);
  }
  v5 = (void **)((char *)this + 48);
  std::vector<std::shared_ptr<vp::vx::io::Node_Terminal>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v4 = (void *)*((_QWORD *)this + 3);
  if (v4)
  {
    *((_QWORD *)this + 4) = v4;
    operator delete(v4);
  }
  v5 = (void **)this;
  std::vector<std::shared_ptr<vp::vx::io::Node_Terminal>>::__destroy_vector::operator()[abi:ne180100](&v5);
}

uint64_t *std::unique_ptr<AUSM::Metadata>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  void *v4;
  _QWORD *v5;
  void *v6;
  uint64_t v7;
  void **v8;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = *(void **)(v2 + 248);
    if (v3)
    {
      *(_QWORD *)(v2 + 256) = v3;
      operator delete(v3);
    }
    if (*(char *)(v2 + 223) < 0)
      operator delete(*(void **)(v2 + 200));
    v4 = *(void **)(v2 + 176);
    if (v4)
    {
      *(_QWORD *)(v2 + 184) = v4;
      operator delete(v4);
    }
    if (*(char *)(v2 + 151) < 0)
      operator delete(*(void **)(v2 + 128));
    if (*(char *)(v2 + 127) < 0)
      operator delete(*(void **)(v2 + 104));
    v5 = *(_QWORD **)(v2 + 88);
    *(_QWORD *)(v2 + 88) = 0;
    if (v5)
      std::default_delete<AUSM::InputABLBuffer>::operator()[abi:ne180100](v5);
    v6 = *(void **)(v2 + 56);
    if (v6)
    {
      *(_QWORD *)(v2 + 64) = v6;
      operator delete(v6);
    }
    v8 = (void **)(v2 + 32);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v8);
    std::unique_ptr<APAC::Metadata>::reset[abi:ne180100]((uint64_t *)(v2 + 24), 0);
    std::unique_ptr<AUSM::Metadata::PImpl>::reset[abi:ne180100]((uint64_t *)(v2 + 16), 0);
    v7 = *(_QWORD *)(v2 + 8);
    *(_QWORD *)(v2 + 8) = 0;
    if (v7)
      MEMORY[0x1BCC95CEC](v7, 0xC400A2AC0F1);
    JUMPOUT(0x1BCC95CECLL);
  }
  return result;
}

uint64_t std::try_lock[abi:ne180100]<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>,std::shared_mutex>(uint64_t a1, std::__shared_mutex_base *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v6;
  char v7;

  v6 = a1;
  v3 = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock(a1);
  v7 = v3;
  if (v3)
  {
    if (std::__shared_mutex_base::try_lock(a2))
    {
      v6 = 0;
      v7 = 0;
      v4 = 0xFFFFFFFFLL;
    }
    else
    {
      v4 = 1;
    }
  }
  else
  {
    v4 = 0;
  }
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v6);
  return v4;
}

void sub_1B61B3660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::try_lock[abi:ne180100]<std::shared_mutex,caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>(std::__shared_mutex_base *a1, uint64_t a2)
{
  _BOOL4 v3;
  uint64_t v4;
  std::__shared_mutex_base *v6;
  BOOL v7;

  v6 = a1;
  v3 = std::__shared_mutex_base::try_lock(a1);
  v7 = v3;
  if (v3)
  {
    if (caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock(a2))
    {
      v6 = 0;
      v7 = 0;
      v4 = 0xFFFFFFFFLL;
    }
    else
    {
      v4 = 1;
    }
  }
  else
  {
    v4 = 0;
  }
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v6);
  return v4;
}

void sub_1B61B36DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void AUSpatialMixerV2::AUSpatialMixerV2(AUSpatialMixerV2 *this, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t i;
  char *v10;
  void **v11;
  size_t v12;
  _BYTE *v13;
  char **v14;
  char *v15;
  size_t v16;
  std::string *p_p;
  char *v18;
  size_t v19;
  std::string *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  NSObject *v25;
  char *v26;
  void *v27;
  void *v28;
  int v29;
  NSObject *v30;
  char *v31;
  void *v32;
  int v33;
  NSObject *v34;
  char *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  void *v39;
  NSObject *v40;
  char *v41;
  void *v42;
  void *v43;
  NSObject *v44;
  char *v45;
  void *v46;
  void *v47;
  NSObject *v48;
  char *v49;
  void *v50;
  int v51;
  int v52;
  void *v53;
  void *v54;
  void *v55;
  char v56;
  NSObject *v57;
  char *v58;
  const char *v59;
  void *v60;
  char v61;
  NSObject *v62;
  NSObject *v63;
  IR::IRDataLoader *AppBooleanValue;
  int v65;
  NSObject *v66;
  void *v67;
  NSObject *v68;
  NSObject *v69;
  void *v70;
  uint64_t Element;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  uint64_t v77;
  uint64_t j;
  unint64_t v79;
  _QWORD *v80;
  _DWORD *v81;
  uint64_t v82;
  char *v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  ausdk::AUElement *v88;
  ausdk::AUElement **v89;
  uint64_t v90;
  ausdk::AUElement *v91;
  ausdk::AUElement **v92;
  uint64_t v93;
  ausdk::AUElement *v94;
  ausdk::AUElement **v95;
  uint64_t v96;
  ausdk::AUElement *v97;
  ausdk::AUElement **v98;
  uint64_t v99;
  ausdk::AUElement *v100;
  ausdk::AUElement **v101;
  uint64_t v102;
  ausdk::AUElement *v103;
  ausdk::AUElement **v104;
  uint64_t v105;
  ausdk::AUElement *v106;
  ausdk::AUElement **v107;
  uint64_t v108;
  ausdk::AUElement *v109;
  ausdk::AUElement **v110;
  uint64_t v111;
  ausdk::AUElement *v112;
  ausdk::AUElement **v113;
  uint64_t v114;
  ausdk::AUElement *v115;
  ausdk::AUElement **v116;
  uint64_t v117;
  ausdk::AUElement *v118;
  ausdk::AUElement **v119;
  uint64_t v120;
  ausdk::AUElement *v121;
  ausdk::AUElement **v122;
  unint64_t v123;
  char *v124;
  _BYTE *v125;
  unint64_t v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  char *v131;
  char *v132;
  char *v133;
  char *v134;
  uint64_t *v135;
  int v136;
  int v137;
  int v138;
  int v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  _WORD *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t *v147;
  void *v148;
  size_t v149;
  void *v150;
  char *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  size_t v156;
  uint64_t v157;
  void *v158;
  char *v159;
  int AppIntegerValue;
  int v161;
  char *v162;
  uint64_t v163;
  _QWORD *v164;
  _QWORD *v165;
  uint64_t v166;
  _QWORD *v168;
  _QWORD *v169;
  uint64_t v170;
  NSObject *v171;
  char *v172;
  char *v173;
  char *v174;
  char *v175;
  std::runtime_error *exception;
  std::runtime_error *v177;
  std::runtime_error *v178;
  AUSM::TuningManager *v179;
  void *v180;
  uint64_t *v181;
  char *v182;
  void *v184;
  std::string __p;
  __int128 v186;
  CFTypeRef v187;
  CFTypeRef v188;
  CFTypeRef cf;
  Boolean keyExistsAndHasValidFormat;
  _BYTE __x[32];
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  _QWORD v202[4];

  v202[1] = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase(this, a2, 32, 1);
  *(_QWORD *)v3 = &off_1E69CA230;
  *((_QWORD *)v3 + 66) = &unk_1E69CA4A8;
  *((_BYTE *)v3 + 536) = 0;
  *((_BYTE *)v3 + 540) = 0;
  *((_BYTE *)v3 + 544) = 0;
  *((_BYTE *)v3 + 696) = 0;
  MEMORY[0x1BCC958E4]((char *)v3 + 704);
  *((_QWORD *)this + 96) = 0;
  *((_QWORD *)this + 98) = 0;
  *((_DWORD *)this + 198) = 0;
  *((_QWORD *)this + 97) = &off_1E69EDB38;
  *((_QWORD *)this + 100) = 0;
  CADeprecated::CAMutex::CAMutex((AUSpatialMixerV2 *)((char *)this + 808), "AUScopeDynamic NRT lock");
  *((_QWORD *)this + 97) = &off_1E69ECAD8;
  *((_QWORD *)this + 112) = this;
  *((_BYTE *)this + 904) = 0;
  *((_QWORD *)this + 114) = 0x3CA3D70A3BA3D70ALL;
  *((_QWORD *)this + 115) = 0x3FD99999A0000000;
  *((_QWORD *)this + 116) = 0x3FD3333340000000;
  __asm { FMOV            V8.2S, #1.0 }
  *((_QWORD *)this + 117) = _D8;
  *((_QWORD *)this + 127) = 0;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  for (i = 1024; i != 2176; i += 72)
  {
    v10 = (char *)this + i;
    *((_QWORD *)v10 + 6) = 0;
    *((_OWORD *)v10 + 1) = 0uLL;
    *((_OWORD *)v10 + 2) = 0uLL;
    *(_OWORD *)v10 = 0uLL;
  }
  *((_DWORD *)this + 236) = 1065353216;
  *((_BYTE *)this + 2176) = 1;
  *((_QWORD *)this + 273) = 0x3FD999999999999ALL;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((AUSpatialMixerV2 *)((char *)this + 2192));
  *((_QWORD *)this + 277) = 0;
  *(_OWORD *)((char *)this + 2200) = 0u;
  *((_BYTE *)this + 2224) = 1;
  *((_QWORD *)this + 279) = 0;
  *((_DWORD *)this + 560) = -1;
  *(_QWORD *)((char *)this + 2244) = 0;
  *(_OWORD *)((char *)this + 2252) = 0u;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((AUSpatialMixerV2 *)((char *)this + 2268));
  *((_QWORD *)this + 286) = 0;
  *((_OWORD *)this + 142) = 0u;
  *((_BYTE *)this + 2296) = 1;
  *((_QWORD *)this + 288) = 0;
  *((_QWORD *)this + 289) = 0xFFFFFFFFLL;
  *((_BYTE *)this + 2320) = 0;
  *(_OWORD *)((char *)this + 2328) = 0u;
  *(_OWORD *)((char *)this + 2344) = 0u;
  *(_OWORD *)((char *)this + 2360) = 0u;
  *(_OWORD *)((char *)this + 2376) = 0u;
  *(_OWORD *)((char *)this + 2392) = 0u;
  *(_OWORD *)((char *)this + 2408) = 0u;
  *(_OWORD *)((char *)this + 2424) = 0u;
  *(_OWORD *)((char *)this + 2440) = 0u;
  *(_OWORD *)((char *)this + 2456) = 0u;
  *(_DWORD *)((char *)this + 2471) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((AUSpatialMixerV2 *)((char *)this + 2476));
  *((_OWORD *)this + 158) = 0u;
  *((_OWORD *)this + 157) = 0u;
  *((_OWORD *)this + 156) = 0u;
  *((_OWORD *)this + 155) = 0u;
  *(_OWORD *)((char *)this + 2541) = 0u;
  *((_BYTE *)this + 2557) = 1;
  *((_QWORD *)this + 321) = 0;
  *((_QWORD *)this + 320) = 0;
  *((_QWORD *)this + 322) = 0x10000000000;
  *((_QWORD *)this + 323) = 0;
  *((_QWORD *)this + 325) = 0;
  *((_QWORD *)this + 324) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((AUSpatialMixerV2 *)((char *)this + 2608));
  *((_QWORD *)this + 329) = 0;
  *(_OWORD *)((char *)this + 2616) = 0u;
  *((_BYTE *)this + 2640) = 1;
  *((_QWORD *)this + 331) = 0;
  *((_DWORD *)this + 664) = -1;
  *((_DWORD *)this + 671) = 0;
  *(_QWORD *)((char *)this + 2660) = 0;
  *(_OWORD *)((char *)this + 2668) = 0u;
  *((_BYTE *)this + 2688) = 1;
  *((_QWORD *)this + 337) = 0;
  *((_DWORD *)this + 676) = -1;
  *((_DWORD *)this + 683) = 0;
  *(_QWORD *)((char *)this + 2708) = 0;
  *(_OWORD *)((char *)this + 2716) = 0u;
  *((_BYTE *)this + 2736) = 1;
  *((_QWORD *)this + 343) = 0;
  *((_QWORD *)this + 344) = 0xFFFFFFFFLL;
  *((_WORD *)this + 1380) = 0;
  *((_QWORD *)this + 348) = 0;
  *((_OWORD *)this + 173) = 0u;
  *((_BYTE *)this + 2792) = 1;
  *((_QWORD *)this + 350) = 0;
  *((_QWORD *)this + 351) = 0xFFFFFFFFLL;
  *((_BYTE *)this + 2816) = 1;
  *(_OWORD *)((char *)this + 2824) = 0u;
  *(_OWORD *)((char *)this + 2840) = 0u;
  *((_QWORD *)this + 357) = 0;
  *((_WORD *)this + 1432) = 1;
  *(_QWORD *)((char *)this + 2868) = 0x8000000080;
  *((_OWORD *)this + 180) = 0u;
  *((_OWORD *)this + 181) = 0u;
  *((_OWORD *)this + 182) = xmmword_1B66A09E0;
  *((_QWORD *)this + 366) = 1128792064;
  *((_WORD *)this + 1468) = 1;
  *((_DWORD *)this + 747) = 0;
  *(_OWORD *)((char *)this + 2972) = 0u;
  *(_OWORD *)((char *)this + 2956) = 0u;
  *(_OWORD *)((char *)this + 2940) = 0u;
  __x[0] = 0;
  std::vector<char>::vector((std::vector<char> *)((char *)this + 2992), 8uLL, __x);
  **((_DWORD **)this + 374) = 0;
  *(_OWORD *)((char *)this + 3016) = 0u;
  *(_OWORD *)((char *)this + 3032) = 0u;
  *(_OWORD *)((char *)this + 3048) = 0u;
  *((_QWORD *)this + 383) = 0;
  __x[0] = 0;
  std::vector<char>::vector((std::vector<char> *)this + 128, 8uLL, __x);
  **((_DWORD **)this + 384) = 0;
  *(_OWORD *)((char *)this + 3096) = 0u;
  *(_OWORD *)((char *)this + 3112) = 0u;
  *(_OWORD *)((char *)this + 3128) = 0u;
  *((_QWORD *)this + 393) = 0;
  *((_QWORD *)this + 394) = 0x3E80000044FA0000;
  *((_QWORD *)this + 395) = 0;
  *((_BYTE *)this + 3168) = 1;
  *(_QWORD *)((char *)this + 3172) = 0xFFFFFFFF00000000;
  *(int32x2_t *)((char *)this + 3180) = vdup_n_s32(0x3F3504F3u);
  *(_OWORD *)((char *)this + 3188) = xmmword_1B66A09F0;
  *((_QWORD *)this + 401) = 0;
  *((_DWORD *)this + 804) = -1;
  *(_OWORD *)((char *)this + 3272) = 0u;
  *((_DWORD *)this + 810) = 0;
  *(_OWORD *)((char *)this + 3224) = 0u;
  *((_OWORD *)this + 203) = 0u;
  *((_QWORD *)this + 408) = (char *)this + 3272;
  *((_DWORD *)this + 828) = 0;
  *((_QWORD *)this + 413) = 0;
  *(_OWORD *)((char *)this + 3288) = 0u;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((AUSpatialMixerV2 *)((char *)this + 3316));
  *((_QWORD *)this + 415) = 0;
  *((_DWORD *)this + 832) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((AUSpatialMixerV2 *)((char *)this + 3332));
  *((_QWORD *)this + 417) = 0;
  *((_DWORD *)this + 836) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((AUSpatialMixerV2 *)((char *)this + 3348));
  std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 3352));
  *((_QWORD *)this + 443) = 0;
  *((_DWORD *)this + 888) = 0;
  *((_OWORD *)this + 220) = 0u;
  *((_BYTE *)this + 3536) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((AUSpatialMixerV2 *)((char *)this + 3556));
  *((_QWORD *)this + 447) = 0;
  *(_OWORD *)((char *)this + 3560) = 0u;
  caulk::make_string((caulk *)"%p", (uint64_t)__x, a2);
  AUSM::GlobalProperties::GlobalProperties((uint64_t)this + 3584, (uint64_t)this + 528, (__int128 *)__x);
  if ((__x[23] & 0x80000000) != 0)
    operator delete(*(void **)__x);
  *((_QWORD *)this + 770) = this;
  v11 = (void **)((char *)this + 6168);
  *(_OWORD *)((char *)this + 6200) = 0u;
  *(_OWORD *)((char *)this + 6216) = 0u;
  *((_QWORD *)this + 771) = 0;
  *((_QWORD *)this + 773) = 0;
  *((_QWORD *)this + 772) = 0;
  *((_WORD *)this + 3096) = 0;
  *((_DWORD *)this + 1558) = 1065353216;
  *((_OWORD *)this + 390) = 0u;
  *((_OWORD *)this + 391) = 0u;
  *((_DWORD *)this + 1568) = 1065353216;
  *(_OWORD *)((char *)this + 6280) = 0u;
  v179 = (AUSpatialMixerV2 *)((char *)this + 6160);
  *(_OWORD *)((char *)this + 6296) = 0u;
  *((_DWORD *)this + 1578) = 1065353216;
  if (*((char *)this + 3615) >= 0)
    v12 = *((unsigned __int8 *)this + 3615);
  else
    v12 = *((_QWORD *)this + 450);
  *((_DWORD *)this + 1580) = 0;
  v13 = __x;
  std::string::basic_string[abi:ne180100]((uint64_t)__x, v12 + 14);
  v14 = (char **)((char *)this + 3592);
  if (__x[23] < 0)
    v13 = *(_BYTE **)__x;
  if (v12)
  {
    if (*((char *)this + 3615) >= 0)
      v15 = (char *)this + 3592;
    else
      v15 = (char *)*((_QWORD *)this + 449);
    memmove(v13, v15, v12);
  }
  strcpy(&v13[v12], "|TuningManager");
  if (*((char *)this + 6191) < 0)
    operator delete(*v11);
  *(_OWORD *)v11 = *(_OWORD *)__x;
  *((_QWORD *)this + 773) = *(_QWORD *)&__x[16];
  AUSM::TuningManager::PopulateReservedGlobalAPACPropertyList(v179);
  AUSM::TuningManager::ResizeBuffers(v179, 0x20u);
  *((_QWORD *)this + 791) = 0;
  AUSM::SoundStage::getDefaultParameters((AUSM::SoundStage *)__x, 4);
  if (*((char *)this + 3615) >= 0)
    v16 = *((unsigned __int8 *)this + 3615);
  else
    v16 = *((_QWORD *)this + 450);
  p_p = &__p;
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v16 + 18);
  v182 = (char *)this + 6336;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (v16)
  {
    if (*((char *)this + 3615) >= 0)
      v18 = (char *)this + 3592;
    else
      v18 = (char *)*((_QWORD *)this + 449);
    memmove(p_p, v18, v16);
  }
  strcpy((char *)p_p + v16, "|SoundStageManager");
  AUSM::SoundStage::SoundStage((uint64_t)v182, __x, (__int128 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (*(_QWORD *)__x)
  {
    *(_QWORD *)&__x[8] = *(_QWORD *)__x;
    operator delete(*(void **)__x);
  }
  *((_QWORD *)this + 848) = (char *)this + 3584;
  *((_WORD *)this + 3396) = 0;
  *((_OWORD *)this + 425) = xmmword_1B6629CC0;
  *((_QWORD *)this + 852) = _D8;
  *((_DWORD *)this + 1706) = 0;
  *((_OWORD *)this + 427) = 0u;
  *((_OWORD *)this + 428) = xmmword_1B6629CC0;
  *((_QWORD *)this + 858) = _D8;
  *((_DWORD *)this + 1718) = 0;
  *((_WORD *)this + 3438) = 0;
  *(_QWORD *)((char *)this + 6884) = 0x23E99999ALL;
  *((_BYTE *)this + 6880) = 1;
  *(_OWORD *)((char *)this + 6892) = xmmword_1B66A0930;
  *((_DWORD *)this + 1726) = -1082130432;
  AUSM::SoundStage::getDefaultParameters((AUSM::SoundStage *)__x, 4);
  if (*((char *)this + 3615) >= 0)
    v19 = *((unsigned __int8 *)this + 3615);
  else
    v19 = *((_QWORD *)this + 450);
  v20 = &__p;
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v19 + 13);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (v19)
  {
    if (*((char *)this + 3615) >= 0)
      v21 = (char *)this + 3592;
    else
      v21 = (char *)*((_QWORD *)this + 449);
    memmove(v20, v21, v19);
  }
  strcpy((char *)v20 + v19, "|TuningWarper");
  AUSM::SoundStage::SoundStage((uint64_t)this + 6912, __x, (__int128 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (*(_QWORD *)__x)
  {
    *(_QWORD *)&__x[8] = *(_QWORD *)__x;
    operator delete(*(void **)__x);
  }
  *((_WORD *)this + 3682) = 257;
  *((_DWORD *)this + 1840) = 16843009;
  *(_OWORD *)((char *)this + 7368) = 0u;
  *(_QWORD *)((char *)this + 7381) = 0;
  AUSM::SoundStage::getDefaultParameters((AUSM::SoundStage *)__x, 1);
  CFRetain(CFSTR("AUSMSoundStageSmallParameters"));
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, CFSTR("AUSMSoundStageSmallParameters"));
  if (!cf)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)&__p);
  AUSM::SoundStage::setSoundStageParameters((uint64_t)v182, 1, __x, &__p, 1, 1, 1, 1.0, 1.0);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (cf)
    CFRelease(cf);
  if (*(_QWORD *)__x)
  {
    *(_QWORD *)&__x[8] = *(_QWORD *)__x;
    operator delete(*(void **)__x);
  }
  AUSM::SoundStage::getDefaultParameters((AUSM::SoundStage *)__x, 2);
  CFRetain(CFSTR("AUSMSoundStageMediumParameters"));
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, CFSTR("AUSMSoundStageMediumParameters"));
  if (!cf)
  {
    v177 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v177, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)&__p);
  AUSM::SoundStage::setSoundStageParameters((uint64_t)v182, 2, __x, &__p, 1, 0, 1, 1.0, 0.0);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (cf)
    CFRelease(cf);
  if (*(_QWORD *)__x)
  {
    *(_QWORD *)&__x[8] = *(_QWORD *)__x;
    operator delete(*(void **)__x);
  }
  AUSM::SoundStage::getDefaultParameters((AUSM::SoundStage *)__x, 3);
  CFRetain(CFSTR("AUSMSoundStageLargeParameters"));
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, CFSTR("AUSMSoundStageLargeParameters"));
  if (!cf)
  {
    v178 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v178, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)&__p);
  AUSM::SoundStage::setSoundStageParameters((uint64_t)v182, 3, __x, &__p, 0, 0, 1, 1.0, 0.0);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (cf)
    CFRelease(cf);
  if (*(_QWORD *)__x)
  {
    *(_QWORD *)&__x[8] = *(_QWORD *)__x;
    operator delete(*(void **)__x);
  }
  *((_DWORD *)this + 1848) = 0;
  *((_QWORD *)this + 925) = 0;
  caulk::make_string((caulk *)"%p", (uint64_t)__x, a2);
  MEMORY[0x1BCC95110]((char *)this + 7408, __x, 1);
  if ((__x[23] & 0x80000000) != 0)
    operator delete(*(void **)__x);
  *((_QWORD *)this + 930) = 0xFFFFFFFF00000000;
  *((_QWORD *)this + 933) = 0xFFFFFFFF00000000;
  *(_OWORD *)((char *)this + 7448) = 0u;
  *((_QWORD *)this + 934) = -1;
  v188 = 0;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)this + 7480, 0, 0, 0, 0.0);
  if (v188)
    CFRelease(v188);
  v187 = 0;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)this + 7632, 0, 0, 0, 0.0);
  if (v187)
    CFRelease(v187);
  v22 = (char *)this + 15080;
  v23 = 7784;
  do
  {
    v24 = (char *)this + v23;
    *v24 = 0;
    v24[448] = 0;
    v23 += 456;
  }
  while (v24 + 456 != v22);
  *(_OWORD *)v22 = xmmword_1B66A0A00;
  *(_OWORD *)((char *)this + 15096) = 0u;
  *(_OWORD *)((char *)this + 15112) = 0u;
  *(_OWORD *)((char *)this + 15128) = 0u;
  *((_WORD *)this + 7572) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((AUSpatialMixerV2 *)((char *)this + 15148));
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v25 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    v26 = (char *)this + 3592;
    if (*((char *)this + 3615) < 0)
      v26 = *v14;
    *(_DWORD *)__x = 136315394;
    *(_QWORD *)&__x[4] = v26;
    *(_WORD *)&__x[12] = 2080;
    *(_QWORD *)&__x[14] = "AUSpatialMixerV2";
    _os_log_impl(&dword_1B5ED0000, v25, OS_LOG_TYPE_DEFAULT, "[%s|%s] Constructing", __x, 0x16u);
  }

  v27 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99EA0]), "initWithSuiteName:", CFSTR("com.apple.coreaudio"));
  LODWORD(cf) = 0;
  v184 = v27;
  objc_msgSend(v27, "objectForKey:", CFSTR("ausm_enable_optimized_binaural_hoa_decoding"));
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = objc_msgSend(v28, "intValue");

  LODWORD(cf) = v29;
  if (v29)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v30 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      v31 = (char *)this + 3592;
      if (*((char *)this + 3615) < 0)
        v31 = *v14;
      *(_DWORD *)__x = 136315650;
      *(_QWORD *)&__x[4] = v31;
      *(_WORD *)&__x[12] = 2080;
      *(_QWORD *)&__x[14] = "AUSpatialMixerV2";
      *(_WORD *)&__x[22] = 1024;
      *(_DWORD *)&__x[24] = (_DWORD)cf;
      _os_log_impl(&dword_1B5ED0000, v30, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting OBHD = %u based on defaults write.", __x, 0x1Cu);
    }

    (*(void (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, CFTypeRef *, uint64_t))(*(_QWORD *)this + 96))(this, 3289, 0, 0, &cf, 4);
  }
  objc_msgSend(v184, "objectForKey:", CFSTR("ausm_enable_room_congruence"));
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = objc_msgSend(v32, "intValue");

  if (v33)
  {
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v34 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      v35 = (char *)this + 3592;
      if (*((char *)this + 3615) < 0)
        v35 = *v14;
      *(_DWORD *)__x = 136315650;
      *(_QWORD *)&__x[4] = v35;
      *(_WORD *)&__x[12] = 2080;
      *(_QWORD *)&__x[14] = "AUSpatialMixerV2";
      *(_WORD *)&__x[22] = 1024;
      *(_DWORD *)&__x[24] = v33;
      _os_log_impl(&dword_1B5ED0000, v34, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting room congruence = %u based on defaults write.", __x, 0x1Cu);
    }

    v36 = operator new();
    AUSM::RoomCongruence::Processor::Processor(v36, (const void **)this + 449);
    std::unique_ptr<AUSM::RoomCongruence::Processor>::reset[abi:ne180100]((uint64_t *)this + 791, v36);
  }
  objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v37, "bundleIdentifier");
  v180 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v180, "isEqualToString:", CFSTR("com.apple.audiomxd"));
  AudioDSP::Core::HeadTracker::SetCanAccessHALAPIs((AUSpatialMixerV2 *)((char *)this + 7408));
  objc_msgSend(v184, "objectForKey:", CFSTR("ausm_enable_head_tracking"));
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = v38;
  if (v38)
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 0;
    LODWORD(__p.__r_.__value_.__l.__data_) = objc_msgSend(v38, "intValue");
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v40 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      v41 = (char *)this + 3592;
      if (*((char *)this + 3615) < 0)
        v41 = *v14;
      *(_DWORD *)__x = 136315650;
      *(_QWORD *)&__x[4] = v41;
      *(_WORD *)&__x[12] = 2080;
      *(_QWORD *)&__x[14] = "AUSpatialMixerV2";
      *(_WORD *)&__x[22] = 1024;
      *(_DWORD *)&__x[24] = __p.__r_.__value_.__l.__data_;
      _os_log_impl(&dword_1B5ED0000, v40, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting head tracking = %u based on defaults write.", __x, 0x1Cu);
    }

    (*(void (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, std::string *, uint64_t))(*(_QWORD *)this + 96))(this, 3111, 0, 0, &__p, 4);
  }

  objc_msgSend(v184, "objectForKey:", CFSTR("ausm_personalized_hrtf_mode"));
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = v42;
  if (v42)
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 0;
    LODWORD(__p.__r_.__value_.__l.__data_) = objc_msgSend(v42, "intValue");
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v44 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      v45 = (char *)this + 3592;
      if (*((char *)this + 3615) < 0)
        v45 = *v14;
      *(_DWORD *)__x = 136315650;
      *(_QWORD *)&__x[4] = v45;
      *(_WORD *)&__x[12] = 2080;
      *(_QWORD *)&__x[14] = "AUSpatialMixerV2";
      *(_WORD *)&__x[22] = 1024;
      *(_DWORD *)&__x[24] = __p.__r_.__value_.__l.__data_;
      _os_log_impl(&dword_1B5ED0000, v44, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting personalized HRTF mode = %u based on defaults write.", __x, 0x1Cu);
    }

    (*(void (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, std::string *, uint64_t))(*(_QWORD *)this + 96))(this, 3113, 0, 0, &__p, 4);
  }

  objc_msgSend(v184, "objectForKey:", CFSTR("ausm_gui_version"));
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  v47 = v46;
  if (v46)
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 0;
    LODWORD(__p.__r_.__value_.__l.__data_) = objc_msgSend(v46, "intValue");
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v48 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      v49 = (char *)this + 3592;
      if (*((char *)this + 3615) < 0)
        v49 = *v14;
      *(_DWORD *)__x = 136315650;
      *(_QWORD *)&__x[4] = v49;
      *(_WORD *)&__x[12] = 2080;
      *(_QWORD *)&__x[14] = "AUSpatialMixerV2";
      *(_WORD *)&__x[22] = 1024;
      *(_DWORD *)&__x[24] = __p.__r_.__value_.__l.__data_;
      _os_log_impl(&dword_1B5ED0000, v48, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting GUI version = %u based on defaults write.", __x, 0x1Cu);
    }

    (*(void (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, std::string *, uint64_t))(*(_QWORD *)this + 96))(this, 3288, 0, 0, &__p, 4);
  }

  v50 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99EA0]), "initWithSuiteName:", CFSTR("com.apple.coreaudio"));
  if ((objc_msgSend(v50, "BOOLForKey:", CFSTR("ausm_capture_all")) & 1) != 0
    || (v51 = objc_msgSend(v50, "BOOLForKey:", CFSTR("ausm_capture_input")),
        v52 = objc_msgSend(v50, "BOOLForKey:", CFSTR("ausm_capture_output")),
        ((v51 | v52 | objc_msgSend(v50, "BOOLForKey:", CFSTR("ausm_capture_config"))) & 1) != 0))
  {
    NSTemporaryDirectory();
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v53, "stringByAppendingPathComponent:", CFSTR("AudioCapture/AUSM"));
    v54 = (void *)objc_claimAutoreleasedReturnValue();

    __p.__r_.__value_.__s.__data_[0] = 1;
    objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    v56 = objc_msgSend(v55, "fileExistsAtPath:isDirectory:", v54, &__p);

    if ((v56 & 1) != 0)
    {
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v57 = (id)getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
        goto LABEL_133;
      v58 = (char *)this + 3592;
      if (*((char *)this + 3615) < 0)
        v58 = *v14;
      *(_DWORD *)__x = 136315650;
      *(_QWORD *)&__x[4] = v58;
      *(_WORD *)&__x[12] = 2080;
      *(_QWORD *)&__x[14] = "PrepareCaptureDir";
      *(_WORD *)&__x[22] = 2112;
      *(_QWORD *)&__x[24] = v54;
      v59 = "[%s|%s] Reusing existing directory for capture: %@";
    }
    else
    {
      objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
      v60 = (void *)objc_claimAutoreleasedReturnValue();
      v61 = objc_msgSend(v60, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v54, 1, 0, 0);

      if ((v61 & 1) == 0)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v63 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          v175 = (char *)this + 3592;
          if (*((char *)this + 3615) < 0)
            v175 = *v14;
          *(_DWORD *)__x = 136315650;
          *(_QWORD *)&__x[4] = v175;
          *(_WORD *)&__x[12] = 2080;
          *(_QWORD *)&__x[14] = "PrepareCaptureDir";
          *(_WORD *)&__x[22] = 2112;
          *(_QWORD *)&__x[24] = v54;
          _os_log_error_impl(&dword_1B5ED0000, v63, OS_LOG_TYPE_ERROR, "[%s|%s] Failed to create capture directory: %@", __x, 0x20u);
        }

        goto LABEL_143;
      }
      if (getAUSMV2Log(void)::onceToken != -1)
        dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
      v57 = (id)getAUSMV2Log(void)::gLog;
      if (!os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
      {
LABEL_133:

        std::string::__assign_external((std::string *)((char *)this + 6104), (const std::string::value_type *)objc_msgSend(objc_retainAutorelease(v54), "UTF8String"));
LABEL_143:

        goto LABEL_144;
      }
      v174 = (char *)this + 3592;
      if (*((char *)this + 3615) < 0)
        v174 = *v14;
      *(_DWORD *)__x = 136315650;
      *(_QWORD *)&__x[4] = v174;
      *(_WORD *)&__x[12] = 2080;
      *(_QWORD *)&__x[14] = "PrepareCaptureDir";
      *(_WORD *)&__x[22] = 2112;
      *(_QWORD *)&__x[24] = v54;
      v59 = "[%s|%s] Directory created for capture: %@";
    }
    _os_log_debug_impl(&dword_1B5ED0000, v57, OS_LOG_TYPE_DEBUG, v59, __x, 0x20u);
    goto LABEL_133;
  }
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v62 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
  {
    v173 = (char *)this + 3592;
    if (*((char *)this + 3615) < 0)
      v173 = *v14;
    *(_DWORD *)__x = 136315394;
    *(_QWORD *)&__x[4] = v173;
    *(_WORD *)&__x[12] = 2080;
    *(_QWORD *)&__x[14] = "PrepareCaptureDir";
    _os_log_debug_impl(&dword_1B5ED0000, v62, OS_LOG_TYPE_DEBUG, "[%s|%s] No capture is configured. Not preparing the capture directory.", __x, 0x16u);
  }

  if (*((char *)this + 6127) < 0)
  {
    **((_BYTE **)this + 763) = 0;
    *((_QWORD *)this + 764) = 0;
  }
  else
  {
    *((_BYTE *)this + 6104) = 0;
    *((_BYTE *)this + 6127) = 0;
  }
LABEL_144:

  *((_BYTE *)this + 6128) = objc_msgSend(v184, "BOOLForKey:", CFSTR("ausm_soundstage_disabled"));
  *((_BYTE *)this + 6192) = 1;
  keyExistsAndHasValidFormat = 0;
  AppBooleanValue = (IR::IRDataLoader *)CFPreferencesGetAppBooleanValue(CFSTR("ausm_force_offlinerender"), CFSTR("com.apple.coreaudio"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
  {
    if ((_DWORD)AppBooleanValue)
    {
      LODWORD(__p.__r_.__value_.__l.__data_) = 1;
      AppBooleanValue = (IR::IRDataLoader *)(*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, _QWORD, _QWORD, std::string *, uint64_t))(*(_QWORD *)this + 96))(this, 37, 0, 0, &__p, 4);
      v65 = (int)AppBooleanValue;
      if ((_DWORD)AppBooleanValue)
      {
        if (getAUSMV2Log(void)::onceToken != -1)
          dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
        v66 = (id)getAUSMV2Log(void)::gLog;
        if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
        {
          v172 = (char *)this + 3592;
          if (*((char *)this + 3615) < 0)
            v172 = *v14;
          *(_DWORD *)__x = 136315650;
          *(_QWORD *)&__x[4] = v172;
          *(_WORD *)&__x[12] = 2080;
          *(_QWORD *)&__x[14] = "AUSpatialMixerV2";
          *(_WORD *)&__x[22] = 1024;
          *(_DWORD *)&__x[24] = v65;
          _os_log_error_impl(&dword_1B5ED0000, v66, OS_LOG_TYPE_ERROR, "[%s|%s] Could not force offline rendering, err = %d", __x, 0x1Cu);
        }

      }
    }
  }
  IR::IRDataLoader::instance(AppBooleanValue);
  *((_BYTE *)this + 6068) = IR::IRDataLoader::fileExists();
  std::vector<AudioUnitParameterEvent>::reserve((void **)this + 48, 0x100uLL);
  v67 = (void *)operator new();
  bzero(v67, 0x340uLL);
  AUSM::SharedBuffers::SharedBuffers((AUSM::SharedBuffers *)v67);
  std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)this + 370, (uint64_t)v67);
  dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  v68 = objc_claimAutoreleasedReturnValue();
  v69 = dispatch_queue_create("com.apple.coreaudio.ausm", v68);

  v70 = (void *)*((_QWORD *)this + 356);
  *((_QWORD *)this + 356) = v69;

  kGainParameterName = (uint64_t)CFSTR("gain");
  kMinGainParameterName = (uint64_t)CFSTR("min gain");
  kMaxGainParameterName = (uint64_t)CFSTR("max gain");
  kAzimuthParameterName = (uint64_t)CFSTR("azimuth");
  kElevationParameterName = (uint64_t)CFSTR("elevation");
  kDistanceParameterName = (uint64_t)CFSTR("distance");
  kEnableParameterName = (uint64_t)CFSTR("enable");
  kPlaybackRateParameterName = (uint64_t)CFSTR("rate");
  kReverbGainParameterName = (uint64_t)CFSTR("global reverb gain");
  kReverbBlendParameterName = (uint64_t)CFSTR("reverb blend");
  kPostProcReverbBlendParameterName = (uint64_t)CFSTR("post-processing reverb blend");
  kOcclusionAttenuationParameterName = (uint64_t)CFSTR("occlusion attenuation");
  kObstructionAttenuationParameterName = (uint64_t)CFSTR("obstruction attenuation");
  kHeadOrientationYawName = (uint64_t)CFSTR("head yaw");
  kHeadOrientationPitchName = (uint64_t)CFSTR("head pitch");
  kHeadOrientationRollName = (uint64_t)CFSTR("head roll");
  kSourceYawName = (uint64_t)CFSTR("source directivity yaw");
  kSourcePitchName = (uint64_t)CFSTR("source directivity pitch");
  kSourceRollName = (uint64_t)CFSTR("source directivity roll");
  kSourceWidthParamName = (uint64_t)CFSTR("source width");
  kSourceHeightParamName = (uint64_t)CFSTR("source height");
  kSourceDepthParamName = (uint64_t)CFSTR("source depth");
  kSourceDivergenceParamName = (uint64_t)CFSTR("source divergence");
  kSourceDivergenceAzimuthRangeParamName = (uint64_t)CFSTR("source divergence azimuth range");
  kSourceDivergencePositionRangeParamName = (uint64_t)CFSTR("source divergence position range");
  kHeadLockedParamName = (uint64_t)CFSTR("head locked");
  kSpeakerSnapParamName = (uint64_t)CFSTR("speaker snap");
  kDiffuseParamName = (uint64_t)CFSTR("diffuse");
  kSceneScaleParamName = (uint64_t)CFSTR("scene scale");
  kListenerPositionXName = (uint64_t)CFSTR("listener position X");
  kListenerPositionYName = (uint64_t)CFSTR("listener position Y");
  kListenerPositionZName = (uint64_t)CFSTR("listener position Z");
  kInternalizedParamName = (uint64_t)CFSTR("internalized");
  kStereoPanningRefAngleParamName = (uint64_t)CFSTR("stereo panning ref angle");
  *((_QWORD *)this + 15) = (char *)this + 776;
  ausdk::AUBase::CreateElements((int64x2_t *)this);
  (*(void (**)(AUSpatialMixerV2 *, uint64_t))(*(_QWORD *)this + 512))(this, 4096);
  __p.__r_.__value_.__r.__words[0] = 0x40E5888000000000;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_1B6626900;
  v186 = xmmword_1B66A0830;
  Element = ausdk::AUScope::SafeGetElement((AUSpatialMixerV2 *)((char *)this + 128), 0);
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)Element + 56))(Element, &__p);
  *(_OWORD *)__x = xmmword_1B66A0A10;
  *(_OWORD *)&__x[16] = xmmword_1B66A0A20;
  v194 = xmmword_1B66A0A50;
  v195 = xmmword_1B66A0A60;
  v196 = xmmword_1B66A0A70;
  v197 = xmmword_1B66A0A80;
  v198 = xmmword_1B66A0A90;
  v199 = xmmword_1B66A0AA0;
  v200 = xmmword_1B66A0AB0;
  v201 = xmmword_1B66A0AC0;
  v72 = *((_QWORD *)this + 355);
  v73 = (char *)*((_QWORD *)this + 353);
  v192 = xmmword_1B66A0A30;
  v193 = xmmword_1B66A0A40;
  if ((unint64_t)(v72 - (_QWORD)v73) >= 0xC0)
  {
    v76 = (char *)*((_QWORD *)this + 354);
    if ((unint64_t)(v76 - v73) >= 0xC0)
    {
      for (j = 0; j != 192; j += 8)
      {
        v84 = &v73[j];
        *(_DWORD *)v84 = *(_DWORD *)&__x[j];
        *((_DWORD *)v84 + 1) = *(_DWORD *)&__x[j + 4];
      }
      v76 = v73;
    }
    else
    {
      v79 = (unint64_t)(v76 - v73) >> 3;
      v80 = &__x[8 * v79];
      if (v76 != v73)
      {
        v81 = __x;
        do
        {
          *(_DWORD *)v73 = *v81;
          *((_DWORD *)v73 + 1) = v81[1];
          v81 += 2;
          v73 += 8;
        }
        while (v81 != (_DWORD *)v80);
      }
      if (v80 == v202)
      {
        v83 = v76;
      }
      else
      {
        v82 = 8 * v79;
        v83 = v76;
        do
        {
          *(_QWORD *)v83 = *(_QWORD *)&__x[v82];
          v83 += 8;
          v82 += 8;
        }
        while (v82 != 192);
      }
      j = v83 - v76;
    }
  }
  else
  {
    if (v73)
    {
      *((_QWORD *)this + 354) = v73;
      operator delete(v73);
      v72 = 0;
      *((_QWORD *)this + 353) = 0;
      *((_QWORD *)this + 354) = 0;
      *((_QWORD *)this + 355) = 0;
    }
    v74 = v72 >> 2;
    if ((unint64_t)(v72 >> 2) <= 0x18)
      v74 = 24;
    if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8)
      v75 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v75 = v74;
    if (v75 >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v76 = (char *)operator new(8 * v75);
    v77 = 0;
    *((_QWORD *)this + 353) = v76;
    *((_QWORD *)this + 354) = v76;
    *((_QWORD *)this + 355) = &v76[8 * v75];
    j = 192;
    do
    {
      *(_OWORD *)&v76[v77] = *(_OWORD *)&__x[v77];
      v77 += 16;
    }
    while (v77 != 192);
  }
  *((_QWORD *)this + 354) = &v76[j];
  atomic_load((unsigned int *)this + 914);
  v85 = operator new();
  IR::IRProcessor::IRProcessor(v85);
  v86 = *((_QWORD *)this + 281);
  *((_QWORD *)this + 281) = v85;
  if (v86)
    (*(void (**)(uint64_t))(*(_QWORD *)v86 + 8))(v86);
  v87 = *((_QWORD *)this + 9);
  if (v87)
  {
    v88 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v87 + 32))(v87, 0);
  }
  else
  {
    v89 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v89)
      v88 = 0;
    else
      v88 = *v89;
  }
  ausdk::AUElement::SetParameter(v88, 9u, 0.0, 0);
  v90 = *((_QWORD *)this + 9);
  if (v90)
  {
    v91 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v90 + 32))(v90, 0);
  }
  else
  {
    v92 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v92)
      v91 = 0;
    else
      v91 = *v92;
  }
  ausdk::AUElement::SetParameter(v91, 0xEu, 800.0, 0);
  v93 = *((_QWORD *)this + 9);
  if (v93)
  {
    v94 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v93 + 32))(v93, 0);
  }
  else
  {
    v95 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v95)
      v94 = 0;
    else
      v94 = *v95;
  }
  ausdk::AUElement::SetParameter(v94, 0xFu, 3.0, 0);
  v96 = *((_QWORD *)this + 9);
  if (v96)
  {
    v97 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v96 + 32))(v96, 0);
  }
  else
  {
    v98 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v98)
      v97 = 0;
    else
      v97 = *v98;
  }
  ausdk::AUElement::SetParameter(v97, 0x10u, 0.0, 0);
  v99 = *((_QWORD *)this + 9);
  if (v99)
  {
    v100 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v99 + 32))(v99, 0);
  }
  else
  {
    v101 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v101)
      v100 = 0;
    else
      v100 = *v101;
  }
  ausdk::AUElement::SetParameter(v100, 0x11u, 0.0, 0);
  v102 = *((_QWORD *)this + 9);
  if (v102)
  {
    v103 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v102 + 32))(v102, 0);
  }
  else
  {
    v104 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v104)
      v103 = 0;
    else
      v103 = *v104;
  }
  ausdk::AUElement::SetParameter(v103, 0x12u, 1.0, 0);
  v105 = *((_QWORD *)this + 9);
  if (v105)
  {
    v106 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v105 + 32))(v105, 0);
  }
  else
  {
    v107 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v107)
      v106 = 0;
    else
      v106 = *v107;
  }
  ausdk::AUElement::SetParameter(v106, 0x13u, 0.0, 0);
  v108 = *((_QWORD *)this + 9);
  if (v108)
  {
    v109 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v108 + 32))(v108, 0);
  }
  else
  {
    v110 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v110)
      v109 = 0;
    else
      v109 = *v110;
  }
  ausdk::AUElement::SetParameter(v109, 0x14u, 0.0, 0);
  v111 = *((_QWORD *)this + 9);
  if (v111)
  {
    v112 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v111 + 32))(v111, 0);
  }
  else
  {
    v113 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v113)
      v112 = 0;
    else
      v112 = *v113;
  }
  ausdk::AUElement::SetParameter(v112, 0x15u, 0.0, 0);
  v114 = *((_QWORD *)this + 9);
  if (v114)
  {
    v115 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v114 + 32))(v114, 0);
  }
  else
  {
    v116 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v116)
      v115 = 0;
    else
      v115 = *v116;
  }
  ausdk::AUElement::SetParameter(v115, 0x24u, 0.0, 0);
  v117 = *((_QWORD *)this + 9);
  if (v117)
  {
    v118 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v117 + 32))(v117, 0);
  }
  else
  {
    v119 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v119)
      v118 = 0;
    else
      v118 = *v119;
  }
  ausdk::AUElement::SetParameter(v118, 0x25u, 0.0, 0);
  v120 = *((_QWORD *)this + 9);
  if (v120)
  {
    v121 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v120 + 32))(v120, 0);
  }
  else
  {
    v122 = (ausdk::AUElement **)*((_QWORD *)this + 6);
    if (*((ausdk::AUElement ***)this + 7) == v122)
      v121 = 0;
    else
      v121 = *v122;
  }
  ausdk::AUElement::SetParameter(v121, 0x26u, 0.0, 0);
  v123 = ((*((_DWORD *)this + 718) - 1) * *((_DWORD *)this + 717));
  v124 = (char *)*((_QWORD *)this + 361);
  v125 = (_BYTE *)*((_QWORD *)this + 360);
  v126 = (v124 - v125) >> 2;
  if (v123 <= v126)
  {
    v135 = (uint64_t *)((char *)this + 2880);
    if (v123 < v126)
      *((_QWORD *)this + 361) = &v125[4 * v123];
  }
  else
  {
    v127 = v123 - v126;
    v128 = *((_QWORD *)this + 362);
    if (v123 - v126 <= (v128 - (uint64_t)v124) >> 2)
    {
      bzero(*((void **)this + 361), 4 * v127);
      *((_QWORD *)this + 361) = &v124[4 * v127];
      v135 = (uint64_t *)((char *)this + 2880);
    }
    else
    {
      v129 = v128 - (_QWORD)v125;
      if (v129 >> 1 > v123)
        v123 = v129 >> 1;
      if ((unint64_t)v129 >= 0x7FFFFFFFFFFFFFFCLL)
        v130 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v130 = v123;
      if (v130 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v131 = (char *)operator new(4 * v130);
      v132 = &v131[4 * v126];
      v133 = &v131[4 * v130];
      bzero(v132, 4 * v127);
      v134 = &v132[4 * v127];
      if (v124 == v125)
      {
        v135 = (uint64_t *)((char *)this + 2880);
      }
      else
      {
        v135 = (uint64_t *)((char *)this + 2880);
        do
        {
          v136 = *((_DWORD *)v124 - 1);
          v124 -= 4;
          *((_DWORD *)v132 - 1) = v136;
          v132 -= 4;
        }
        while (v124 != v125);
        v124 = (char *)*((_QWORD *)this + 360);
      }
      *((_QWORD *)this + 360) = v132;
      *((_QWORD *)this + 361) = v134;
      *((_QWORD *)this + 362) = v133;
      if (v124)
        operator delete(v124);
    }
  }
  v137 = *((_DWORD *)this + 718) - 1;
  if (*((_DWORD *)this + 718) != 1)
  {
    v138 = 0;
    v139 = 0;
    v140 = *((unsigned int *)this + 717);
    do
    {
      if ((_DWORD)v140)
      {
        v141 = 0;
        v142 = *v135;
        do
        {
          v143 = v141 + 1;
          v144 = (_WORD *)(v142 + 4 * (v138 + v141));
          *v144 = v143;
          v144[1] = v139 + 2;
          v141 = v143;
        }
        while (v140 != v143);
      }
      ++v139;
      v138 += v140;
    }
    while (v139 != v137);
  }
  v145 = operator new();
  v146 = v145;
  *(_QWORD *)v145 = this;
  *(_OWORD *)(v145 + 8) = 0u;
  v147 = (uint64_t *)(v145 + 8);
  v181 = (uint64_t *)(v145 + 16);
  *(_OWORD *)(v145 + 24) = 0u;
  *(_QWORD *)(v145 + 88) = 0;
  *(_WORD *)(v145 + 96) = 0;
  v148 = (void *)(v145 + 104);
  *(_OWORD *)(v145 + 40) = 0u;
  *(_OWORD *)(v145 + 56) = 0u;
  *(_OWORD *)(v145 + 68) = 0u;
  if (*((char *)this + 3615) >= 0)
    v149 = *((unsigned __int8 *)this + 3615);
  else
    v149 = *((_QWORD *)this + 450);
  std::string::basic_string[abi:ne180100](v145 + 104, v149 + 9);
  if (*(char *)(v146 + 127) >= 0)
    v150 = v148;
  else
    v150 = *(void **)(v146 + 104);
  if (v149)
  {
    if (*((char *)this + 3615) >= 0)
      v151 = (char *)this + 3592;
    else
      v151 = (char *)*((_QWORD *)this + 449);
    memmove(v150, v151, v149);
  }
  strcpy((char *)v150 + v149, "|Metadata");
  *(_OWORD *)(v146 + 128) = 0u;
  *(_OWORD *)(v146 + 240) = 0u;
  *(_OWORD *)(v146 + 256) = 0u;
  *(_OWORD *)(v146 + 208) = 0u;
  *(_OWORD *)(v146 + 224) = 0u;
  *(_OWORD *)(v146 + 176) = 0u;
  *(_OWORD *)(v146 + 192) = 0u;
  *(_OWORD *)(v146 + 144) = 0u;
  *(_OWORD *)(v146 + 160) = 0u;
  v152 = operator new();
  v153 = *v147;
  *v147 = v152;
  if (v153)
    MEMORY[0x1BCC95CEC](v153, 0xC400A2AC0F1);
  v154 = operator new();
  v155 = *(_QWORD *)v146;
  *(_QWORD *)(v154 + 16) = 0;
  *(_QWORD *)(v154 + 24) = 0;
  *(_QWORD *)(v154 + 8) = 0;
  *(_QWORD *)v154 = v154 + 8;
  *(_DWORD *)(v154 + 32) = 0;
  *(_QWORD *)(v154 + 40) = v155;
  if (*((char *)this + 3615) >= 0)
    v156 = *((unsigned __int8 *)this + 3615);
  else
    v156 = *((_QWORD *)this + 450);
  v157 = std::string::basic_string[abi:ne180100](v154 + 48, v156 + 9);
  if (*(char *)(v154 + 71) >= 0)
    v158 = (void *)v157;
  else
    v158 = *(void **)(v154 + 48);
  if (v156)
  {
    if (*((char *)this + 3615) >= 0)
      v159 = (char *)this + 3592;
    else
      v159 = (char *)*((_QWORD *)this + 449);
    memmove(v158, v159, v156);
  }
  strcpy((char *)v158 + v156, "|Metadata");
  *(_QWORD *)(v154 + 112) = 0;
  *(_QWORD *)(v154 + 104) = 0;
  *(_QWORD *)(v154 + 72) = 0;
  *(_QWORD *)(v154 + 80) = 0;
  *(_QWORD *)(v154 + 86) = 0;
  *(_QWORD *)(v154 + 96) = v154 + 104;
  *(_BYTE *)(v154 + 120) = 1;
  std::unique_ptr<AUSM::Metadata::PImpl>::reset[abi:ne180100](v181, v154);
  __x[0] = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("ausm_metadata_trace"), CFSTR("com.apple.coreaudio"), __x);
  if (__x[0])
    v161 = AppIntegerValue;
  else
    v161 = 0;
  AUSM::Metadata::mTraceLevel = v161;
  std::unique_ptr<AUSM::Metadata>::reset[abi:ne180100]((uint64_t *)this + 96, v146);
  v162 = (char *)this + 3592;
  if (_os_feature_enabled_impl())
  {
    v163 = operator new();
    *(_DWORD *)v163 = 0;
    *(_BYTE *)(v163 + 4) = 0;
    *(_QWORD *)(v163 + 8) = 0x437A000000000000;
    *(_WORD *)(v163 + 16) = 1;
    *(_BYTE *)(v163 + 18) = 0;
    *(_QWORD *)(v163 + 20) = 0x40000000442F0000;
    *(_QWORD *)(v163 + 28) = 0x3F6B851F00000001;
    *(_QWORD *)(v163 + 48) = 0;
    *(_QWORD *)(v163 + 56) = 0;
    *(_QWORD *)(v163 + 64) = &off_1E69E9A10;
    *(_QWORD *)(v163 + 88) = v163 + 64;
    bzero((void *)(v163 + 96), 0x1048uLL);
    *(_QWORD *)(v163 + 40) = &off_1E69E99A0;
    *(_DWORD *)(v163 + 4264) = 0;
    bzero((void *)(v163 + 4272), 0x1060uLL);
    *(_QWORD *)(v163 + 8496) = 0;
    *(_QWORD *)(v163 + 8488) = 0;
    *(_QWORD *)(v163 + 8504) = 0;
    v164 = operator new(0x20uLL);
    *v164 = &off_1E69E9A58;
    v164[1] = STFT<float>::privateProcessBlock;
    v164[2] = 0;
    v164[3] = v163 + 40;
    *(_QWORD *)&__x[24] = v164;
    std::__function::__value_func<void ()(applesauce::CF::DictionaryRef)>::operator=[abi:ne180100]((_QWORD *)(v163 + 64), (uint64_t)__x);
    v165 = *(_QWORD **)&__x[24];
    if (*(_BYTE **)&__x[24] == __x)
    {
      v166 = 4;
      v165 = __x;
    }
    else
    {
      if (!*(_QWORD *)&__x[24])
        goto LABEL_296;
      v166 = 5;
    }
    (*(void (**)(void))(*v165 + 8 * v166))();
LABEL_296:
    bzero((void *)(v163 + 8512), 0x2080uLL);
    *(_OWORD *)(v163 + 16832) = xmmword_1B66A0AD0;
    __asm { FMOV            V0.2S, #-1.0 }
    *(_QWORD *)(v163 + 16848) = _D0;
    *(_DWORD *)(v163 + 16856) = -998637568;
    v168 = operator new(0x20uLL);
    *v168 = &off_1E69E9AA0;
    v168[1] = TorqueEngine::processBlock;
    v168[2] = 0;
    v168[3] = v163;
    v169 = *(_QWORD **)(v163 + 8488);
    *(_QWORD *)(v163 + 8488) = 0;
    if (v169 == (_QWORD *)(v163 + 8464))
    {
      v170 = 4;
      v169 = (_QWORD *)(v163 + 8464);
    }
    else
    {
      if (!v169)
      {
LABEL_301:
        *(_QWORD *)(v163 + 8488) = v168;
        std::unique_ptr<TorqueEngine>::reset[abi:ne180100]((void ***)this + 401, (void **)v163);
        goto LABEL_302;
      }
      v170 = 5;
    }
    (*(void (**)(void))(*v169 + 8 * v170))();
    goto LABEL_301;
  }
LABEL_302:
  if (getAUSMV2Log(void)::onceToken != -1)
    dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
  v171 = (id)getAUSMV2Log(void)::gLog;
  if (os_log_type_enabled(v171, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)this + 3615) < 0)
      v162 = (char *)*((_QWORD *)this + 449);
    *(_DWORD *)__x = 136315394;
    *(_QWORD *)&__x[4] = v162;
    *(_WORD *)&__x[12] = 2080;
    *(_QWORD *)&__x[14] = "AUSpatialMixerV2";
    _os_log_impl(&dword_1B5ED0000, v171, OS_LOG_TYPE_DEFAULT, "[%s|%s] Constructed", __x, 0x16u);
  }

}

void sub_1B61B5C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *exception_object, void **a12, IR::IRDataAttributes *a13, IR::IRDataAttributes *a14, void ***a15, AUSM::SoundStage *a16, AUSM::GlobalProperties *a17, void *a18, uint64_t a19, _QWORD **a20,uint64_t a21,AUSM::ABLBuffer *a22,AUSM::ABLBuffer *a23,void **a24,IR::SharedIRBuses *a25,void **a26,std::recursive_mutex *a27,void **a28,void ***a29,uint64_t a30,uint64_t *a31,uint64_t a32,void **a33,uint64_t *a34,uint64_t *a35,AUScopeDynamic *a36,void **a37,void *a38,uint64_t a39,AUSM::SoundStage *a40,void *a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,uint64_t a49,char a50,int a51,__int16 a52,char a53,char a54,CFTypeRef cf,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  uint64_t v62;
  void *v63;
  void *v64;
  void *v65;
  IR::IRProcessor *v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  void **v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  uint64_t v77;
  void *v78;
  uint64_t v79;
  void *v80;

  AUSpatialMixerV2::AlignmentDelay::~AlignmentDelay(a12);
  v66 = (IR::IRProcessor *)(v62 + 14624);
  v67 = -7296;
  while (1)
  {
    if (*((_BYTE *)v66 + 448))
      IR::IRProcessor::~IRProcessor(v66);
    v66 = (IR::IRProcessor *)((char *)v66 - 456);
    v67 += 456;
    if (!v67)
    {
      IR::IRDataAttributes::~IRDataAttributes(a13);
      IR::IRDataAttributes::~IRDataAttributes(a14);
      std::unique_ptr<ParametricFilters>::reset[abi:ne180100]((void ***)(v62 + 7456), 0);
      std::unique_ptr<ParametricFilters>::reset[abi:ne180100](a15, 0);
      MEMORY[0x1BCC9511C](a32);
      std::unique_ptr<AUSpatialMixerV2DynamicXTCFilter>::reset[abi:ne180100]((uint64_t *)(v62 + 7400), 0);
      AUSM::SoundStage::~SoundStage(a16);
      AUSM::SoundStage::~SoundStage(a40);
      std::unique_ptr<AUSM::RoomCongruence::Processor>::reset[abi:ne180100](a31, 0);
      AUSM::TuningManager::~TuningManager(a37);
      AUSM::GlobalProperties::~GlobalProperties(a17);
      a42 = a18;
      std::vector<std::unique_ptr<AUSM::AUFXWrapper>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a42);
      std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v62 + 3520);
      std::shared_mutex::~shared_mutex[abi:ne180100](a19);
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*a20);
      applesauce::CF::DictionaryRef::~DictionaryRef((const void **)(v62 + 3256));
      applesauce::CF::DictionaryRef::~DictionaryRef((const void **)(v62 + 3248));
      std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](a21);
      std::unique_ptr<TorqueEngine>::reset[abi:ne180100](a29, 0);
      AUSM::ABLBuffer::~ABLBuffer(a22);
      AUSM::ABLBuffer::~ABLBuffer(a23);
      std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100](a35, 0);
      std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)(v62 + 2952), 0);
      std::unique_ptr<AUSM::SharedBuffers>::reset[abi:ne180100]((uint64_t *)(v62 + 2944), 0);
      v68 = *(_QWORD *)(v62 + 2904);
      *(_QWORD *)(v62 + 2904) = 0;
      if (v68)
        (*(void (**)(uint64_t))(*(_QWORD *)v68 + 8))(v68);
      v69 = *a33;
      if (*a33)
      {
        *(_QWORD *)(v62 + 2888) = v69;
        operator delete(v69);
      }
      v70 = (void **)(v62 + 2768);
      applesauce::dispatch::v1::source::~source((id *)(v62 + 2856));
      applesauce::dispatch::v1::source::~source((id *)(v62 + 2848));
      v71 = *a28;
      if (*a28)
      {
        *(_QWORD *)(v62 + 2832) = v71;
        operator delete(v71);
      }
      v72 = *v70;
      if (*v70)
      {
        *(_QWORD *)(v62 + 2776) = v72;
        operator delete(v72);
      }
      v73 = *(void **)(v62 + 2712);
      if (v73)
      {
        *(_QWORD *)(v62 + 2720) = v73;
        operator delete(v73);
      }
      v74 = *(void **)(v62 + 2664);
      if (v74)
      {
        *(_QWORD *)(v62 + 2672) = v74;
        operator delete(v74);
      }
      v75 = *a24;
      if (*a24)
      {
        *(_QWORD *)(v62 + 2624) = v75;
        operator delete(v75);
      }
      a42 = (void *)(v62 + 2584);
      std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100]((void ***)&a42);
      IR::SharedIRBuses::~SharedIRBuses(a25);
      v76 = *(void **)(v62 + 2272);
      if (v76)
      {
        *(_QWORD *)(v62 + 2280) = v76;
        operator delete(v76);
      }
      v77 = *(_QWORD *)(v62 + 2248);
      *(_QWORD *)(v62 + 2248) = 0;
      if (v77)
        (*(void (**)(uint64_t))(*(_QWORD *)v77 + 8))(v77);
      v78 = *a26;
      if (*a26)
      {
        *(_QWORD *)(v62 + 2208) = v78;
        operator delete(v78);
      }
      v79 = 1152;
      while (1)
      {
        v80 = *(void **)(v62 + v79 + 952);
        if (v80)
        {
          *(_QWORD *)(v62 + v79 + 960) = v80;
          operator delete(v80);
        }
        v79 -= 72;
        if (!v79)
        {
          AUScopeDynamic::~AUScopeDynamic(a36);
          std::unique_ptr<AUSM::Metadata>::reset[abi:ne180100](a34, 0);
          std::recursive_mutex::~recursive_mutex(a27);
          if (*(_BYTE *)(v62 + 696))
            IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)(v62 + 544));
          ausdk::AUBase::~AUBase((ausdk::AUBase *)v62);
          _Unwind_Resume(a1);
        }
      }
    }
  }
}

void std::vector<AudioUnitParameterEvent>::reserve(void **a1, unint64_t a2)
{
  int64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  __int128 v11;

  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 5)
  {
    v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFE0];
    v7 = &v4[32 * v6];
    v9 = (char *)*a1;
    v8 = (char *)a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *((_OWORD *)v8 - 1);
        *((_OWORD *)v10 - 2) = *((_OWORD *)v8 - 2);
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 32;
        v8 -= 32;
      }
      while (v8 != v9);
      v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

void AUSpatialMixerV2::AlignmentDelay::~AlignmentDelay(void **this)
{
  void **v2;

  v2 = this + 3;
  std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = this;
  std::vector<IR::FixedIntegerDelay>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void AUSM::TuningManager::~TuningManager(void **this)
{
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)(this + 15));
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)(this + 10));
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table((uint64_t)(this + 5));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

void std::shared_mutex::~shared_mutex[abi:ne180100](uint64_t a1)
{
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 112));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 64));
  std::mutex::~mutex((std::mutex *)a1);
}

void applesauce::dispatch::v1::source::~source(id *this)
{
  id v2;

  v2 = *this;
  *this = 0;

}

uint64_t AUSpatialMixerV2::SetAPACProperty(AUSpatialMixerV2 *this, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  unint64_t v12;
  _QWORD *v13;
  uint8x8_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t **v17;
  uint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  NSObject *v21;
  _QWORD *v22;
  unint64_t v24;
  void **v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t *v31;
  float v32;
  float v33;
  _BOOL8 v35;
  unint64_t v36;
  unint64_t v37;
  size_t v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  char *v42;
  uint8_t buf[4];
  _QWORD *v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  int v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a3 || !*((_BYTE *)this + 6192))
    return (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, uint64_t, uint64_t, const void *, uint64_t))(*(_QWORD *)this + 96))(this, a2, a3, a4, a5, a6);
  v12 = *((_QWORD *)this + 776);
  if (!v12)
    goto LABEL_20;
  v13 = (_QWORD *)((char *)this + 6200);
  v14 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
  v14.i16[0] = vaddlv_u8(v14);
  v15 = v14.u32[0];
  if (v14.u32[0] > 1uLL)
  {
    v16 = a2;
    if (v12 <= a2)
      v16 = a2 % v12;
  }
  else
  {
    v16 = ((_DWORD)v12 - 1) & a2;
  }
  v17 = *(uint64_t ***)(*v13 + 8 * v16);
  if (!v17 || (v18 = *v17) == 0)
  {
LABEL_20:
    if (getAUSMV2Log(void)::onceToken != -1)
      dispatch_once(&getAUSMV2Log(void)::onceToken, &__block_literal_global_5474);
    v21 = (id)getAUSMV2Log(void)::gLog;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v22 = (_QWORD *)((char *)this + 6168);
      if (*((char *)this + 6191) < 0)
        v22 = (_QWORD *)*v22;
      *(_DWORD *)buf = 136315650;
      v44 = v22;
      v45 = 2080;
      v46 = "UpdateReservedGlobalAPACPropertyList";
      v47 = 1024;
      v48 = a2;
      _os_log_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_DEFAULT, "[%s|%s] property %u is not listed as reserved, hence is not going to be intercepted.", buf, 0x1Cu);
    }

    return (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, uint64_t, uint64_t, const void *, uint64_t))(*(_QWORD *)this + 96))(this, a2, a3, a4, a5, a6);
  }
  v19 = v12 - 1;
  while (1)
  {
    v20 = v18[1];
    if (v20 == a2)
      break;
    if (v14.u32[0] > 1uLL)
    {
      if (v20 >= v12)
        v20 %= v12;
    }
    else
    {
      v20 &= v19;
    }
    if (v20 != v16)
      goto LABEL_20;
LABEL_19:
    v18 = (uint64_t *)*v18;
    if (!v18)
      goto LABEL_20;
  }
  if (*((_DWORD *)v18 + 4) != (_DWORD)a2)
    goto LABEL_19;
  if (v14.u32[0] > 1uLL)
  {
    v24 = a2;
    if (v12 <= a2)
      v24 = a2 % v12;
  }
  else
  {
    v24 = ((_DWORD)v12 - 1) & a2;
  }
  v25 = *(void ***)(*v13 + 8 * v24);
  if (v25)
  {
    v26 = *v25;
    if (*v25)
    {
      do
      {
        v27 = v26[1];
        if (v27 == a2)
        {
          if (*((_DWORD *)v26 + 4) == (_DWORD)a2)
            goto LABEL_68;
        }
        else
        {
          if (v14.u32[0] > 1uLL)
          {
            if (v27 >= v12)
              v27 %= v12;
          }
          else
          {
            v27 &= v19;
          }
          if (v27 != v24)
            break;
        }
        v26 = (_QWORD *)*v26;
      }
      while (v26);
    }
  }
  v42 = (char *)this + 6200;
  v28 = v24;
  v29 = operator new(0x18uLL);
  v30 = v28;
  v26 = v29;
  v31 = (uint64_t *)v42;
  *v26 = 0;
  v26[1] = a2;
  *((_DWORD *)v26 + 4) = a2;
  v32 = (float)(unint64_t)(*((_QWORD *)this + 778) + 1);
  *((_BYTE *)v26 + 20) = 0;
  v33 = *((float *)this + 1558);
  if ((float)(v33 * (float)v12) < v32)
  {
    v35 = v12 < 3 || v15 > 1;
    v36 = v35 | (2 * v12);
    v37 = vcvtps_u32_f32(v32 / v33);
    if (v36 <= v37)
      v38 = v37;
    else
      v38 = v36;
    std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__rehash<true>((uint64_t)v42, v38);
    v12 = *((_QWORD *)this + 776);
    v31 = (uint64_t *)v42;
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= a2)
        v30 = a2 % v12;
      else
        v30 = a2;
    }
    else
    {
      v30 = ((_DWORD)v12 - 1) & a2;
    }
  }
  v39 = *v31;
  v40 = *(_QWORD **)(*v31 + 8 * v30);
  if (v40)
  {
    *v26 = *v40;
    goto LABEL_66;
  }
  *v26 = *((_QWORD *)this + 777);
  *((_QWORD *)this + 777) = v26;
  *(_QWORD *)(v39 + 8 * v30) = (char *)this + 6216;
  if (*v26)
  {
    v41 = *(_QWORD *)(*v26 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v41 >= v12)
        v41 %= v12;
    }
    else
    {
      v41 &= v12 - 1;
    }
    v40 = (_QWORD *)(*v31 + 8 * v41);
LABEL_66:
    *v40 = v26;
  }
  ++*((_QWORD *)this + 778);
LABEL_68:
  *((_BYTE *)v26 + 20) = 1;
  return (*(uint64_t (**)(AUSpatialMixerV2 *, uint64_t, uint64_t, uint64_t, const void *, uint64_t))(*(_QWORD *)this + 96))(this, a2, a3, a4, a5, a6);
}

void sub_1B61B69EC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void LPFilterBank::~LPFilterBank(LPFilterBank *this)
{
  LPFilterBank::~LPFilterBank(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  _BYTE *v2;
  _QWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;

  *(_QWORD *)this = &off_1E69CA758;
  v3 = (_QWORD *)((char *)this + 64);
  v2 = (_BYTE *)*((_QWORD *)this + 8);
  if (v2)
  {
    v4 = (_BYTE *)*((_QWORD *)this + 9);
    if (v4 != v2)
      *((_QWORD *)this + 9) = &v4[(v2 - v4 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    operator delete(v2);
    *v3 = 0;
    v3[1] = 0;
  }
  v5 = (_BYTE *)*((_QWORD *)this + 6);
  if (v5)
  {
    v6 = (_BYTE *)*((_QWORD *)this + 7);
    if (v6 != v5)
      *((_QWORD *)this + 7) = &v6[(v5 - v6 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    operator delete(v5);
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 7) = 0;
  }
  v7 = (_BYTE *)*((_QWORD *)this + 4);
  if (v7)
  {
    v8 = (_BYTE *)*((_QWORD *)this + 5);
    if (v8 != v7)
      *((_QWORD *)this + 5) = &v8[(v7 - v8 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    operator delete(v7);
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 5) = 0;
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

uint64_t LPFilterBank::Initialize(LPFilterBank *this, int a2, int a3, unsigned int a4, int a5, int a6)
{
  void *v9;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;

  if (a4 == 64 && a5 == 32 && a6 == 3)
  {
    v9 = &h_64_32_3;
  }
  else if (a4 == 128 && a5 == 64 && a6 == 3)
  {
    v9 = &h_128_64_3;
  }
  else if (a4 == 256 && a5 == 128 && a6 == 3)
  {
    v9 = &h_256_128_3;
  }
  else if (a4 == 512 && a5 == 256 && a6 == 3)
  {
    v9 = &h_512_256_3;
  }
  else if (a4 == 1024 && a5 == 512 && a6 == 3)
  {
    v9 = &h_1024_512_3;
  }
  else if (a4 == 64 && a5 == 40 && a6 == 4)
  {
    v9 = &h_64_40_4;
  }
  else if (a4 == 128 && a5 == 80 && a6 == 4)
  {
    v9 = &h_128_80_4;
  }
  else if (a4 == 256 && a5 == 160 && a6 == 4)
  {
    v9 = &h_256_160_4;
  }
  else if (a4 == 512 && a5 == 320 && a6 == 4)
  {
    v9 = &h_512_320_4;
  }
  else if (a4 == 1024 && a5 == 640 && a6 == 4)
  {
    v9 = &h_1024_640_4;
  }
  else
  {
    if (a4 != 480 || a5 != 240 || a6 != 1)
    {
      *((_QWORD *)this + 3) = 0;
      return 0xFFFFFFFFLL;
    }
    v9 = &h_480_240_1;
  }
  *((_QWORD *)this + 3) = v9;
  *((_DWORD *)this + 21) = a4;
  *((_DWORD *)this + 22) = a5;
  *((_DWORD *)this + 23) = a6;
  if (MultiRadixRealFFT::Initialize((LPFilterBank *)((char *)this + 8), a4))
    return 4294967294;
  v11 = (*((_DWORD *)this + 23) * *((_DWORD *)this + 21));
  std::valarray<float>::resize((uint64_t)this + 32, (v11 * a2), 0.0);
  std::valarray<float>::resize((uint64_t)this + 48, (v11 * a3), 0.0);
  std::valarray<float>::resize((uint64_t)this + 64, v11, 0.0);
  *((float *)this + 24) = 1.0 / (float)*((unsigned int *)this + 21);
  v12 = (void *)*((_QWORD *)this + 4);
  v13 = *((_QWORD *)this + 5) - (_QWORD)v12;
  if (v13 >= 1)
    bzero(v12, 4 * (((unint64_t)v13 >> 2) - ((unint64_t)v13 > 3)) + 4);
  v14 = (void *)*((_QWORD *)this + 6);
  v15 = *((_QWORD *)this + 7) - (_QWORD)v14;
  if (v15 >= 1)
    bzero(v14, 4 * (((unint64_t)v15 >> 2) - ((unint64_t)v15 > 3)) + 4);
  return 0;
}

void std::valarray<float>::resize(uint64_t a1, unint64_t a2, float a3)
{
  _BYTE *v6;
  _BYTE *v7;
  float *v8;

  v6 = *(_BYTE **)a1;
  if (v6)
  {
    v7 = *(_BYTE **)(a1 + 8);
    if (v7 != v6)
      *(_QWORD *)(a1 + 8) = &v7[(v6 - v7 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    operator delete(v6);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  if (a2)
  {
    if (a2 >> 62)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v8 = (float *)operator new(4 * a2);
    *(_QWORD *)a1 = v8;
    do
    {
      *v8++ = a3;
      --a2;
    }
    while (a2);
    *(_QWORD *)(a1 + 8) = v8;
  }
}

void LPFilterBank::Analysis(LPFilterBank *this, int a2, const float *a3, DSPSplitComplex *a4)
{
  vDSP_Length v7;
  char *v8;
  int v9;
  float v10;

  v7 = (*((_DWORD *)this + 23) * *((_DWORD *)this + 21));
  v8 = (char *)(*((_QWORD *)this + 4) + 4 * (v7 * a2));
  memmove(v8, &v8[4 * *((unsigned int *)this + 22)], 4 * (v7 - *((_DWORD *)this + 22)));
  memcpy(&v8[4 * (v7 - *((_DWORD *)this + 22))], a3, 4 * *((unsigned int *)this + 22));
  vDSP_vmul((const float *)v8, 1, *((const float **)this + 3), 1, *((float **)this + 8), 1, v7);
  if (*((int *)this + 23) >= 2)
  {
    v9 = 1;
    do
      vDSP_vadd(*((const float **)this + 8), 1, (const float *)(*((_QWORD *)this + 8) + 4 * (*((_DWORD *)this + 21) * v9++)), 1, *((float **)this + 8), 1, *((unsigned int *)this + 21));
    while (v9 < *((_DWORD *)this + 23));
  }
  vDSP_ctoz(*((const DSPComplex **)this + 8), 2, a4, 1, (unint64_t)*((unsigned int *)this + 21) >> 1);
  MultiRadixRealFFT::RealInPlaceTransform((LPFilterBank *)((char *)this + 8), a4, 1, v10);
  vDSP_vsmul(a4->realp, 1, (const float *)this + 24, a4->realp, 1, (unint64_t)*((unsigned int *)this + 21) >> 1);
  vDSP_vsmul(a4->imagp, 1, (const float *)this + 24, a4->imagp, 1, (unint64_t)*((unsigned int *)this + 21) >> 1);
}

void LPFilterBank::Synthesis(LPFilterBank *this, int a2, const DSPSplitComplex *a3, float *a4)
{
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  float *v12;

  v7 = *((_DWORD *)this + 21);
  v8 = *((_DWORD *)this + 23);
  v9 = *((_QWORD *)this + 6);
  MultiRadixRealFFT::RealOutOfPlaceInverseTransform((const vDSP_DFT_SetupStruct ***)this + 1, a3, *((DSPComplex **)this + 8));
  if (*((int *)this + 23) >= 2)
  {
    v10 = 1;
    do
      memcpy((void *)(*((_QWORD *)this + 8) + 4 * (*((_DWORD *)this + 21) * v10++)), *((const void **)this + 8), 4 * *((unsigned int *)this + 21));
    while (v10 < *((_DWORD *)this + 23));
  }
  v11 = v8 * v7;
  v12 = (float *)(v9 + 4 * (v11 * a2));
  vDSP_vma(*((const float **)this + 8), 1, *((const float **)this + 3), 1, v12, 1, a4, 1, *((unsigned int *)this + 22));
  vDSP_vma((const float *)(*((_QWORD *)this + 8) + 4 * *((unsigned int *)this + 22)), 1, (const float *)(*((_QWORD *)this + 3) + 4 * *((unsigned int *)this + 22)), 1, &v12[*((unsigned int *)this + 22)], 1, v12, 1, (v11 - *((_DWORD *)this + 22)));
  vDSP_vclr(&v12[v11 - *((_DWORD *)this + 22)], 1, *((unsigned int *)this + 22));
}

uint64_t GetAcousticID(void)
{
  unint64_t v0;
  char v2;
  char **v3;
  char *v4;

  v0 = atomic_load(GetAcousticID(void)::sOnceFlag);
  if (v0 != -1)
  {
    v4 = &v2;
    v3 = &v4;
    std::__call_once(GetAcousticID(void)::sOnceFlag, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<GetAcousticID(void)::$_0 &&>>);
  }
  return GetAcousticID(void)::optionalValue;
}

CFIndex std::__call_once_proxy[abi:ne180100]<std::tuple<GetAcousticID(void)::$_0 &&>>()
{
  CFIndex result;

  result = CFPreferencesGetAppIntegerValue(CFSTR("acoustic_id"), CFSTR("com.apple.coreaudio"), 0);
  if (result)
  {
    if (!BYTE4(GetAcousticID(void)::optionalValue))
      BYTE4(GetAcousticID(void)::optionalValue) = 1;
    LODWORD(GetAcousticID(void)::optionalValue) = result;
  }
  else
  {
    result = MGIsQuestionValid();
    if ((_DWORD)result)
    {
      result = MGGetSInt32Answer();
      LODWORD(GetAcousticID(void)::optionalValue) = result;
      BYTE4(GetAcousticID(void)::optionalValue) = (_DWORD)result != 0;
    }
    else if (BYTE4(GetAcousticID(void)::optionalValue))
    {
      BYTE4(GetAcousticID(void)::optionalValue) = 0;
    }
  }
  return result;
}

void GetHWIdentifierString(uint64_t a1, uint64_t __val)
{
  std::string *v3;
  std::string::size_type v4;
  char v5;
  uint64_t v6;
  std::string __p;
  _QWORD v8[3];

  v8[2] = *MEMORY[0x1E0C80C00];
  if ((__val & 0xFF00000000) != 0)
  {
    std::to_string(&__p, __val);
    v3 = std::string::insert(&__p, 0, "AID", 3uLL);
    v4 = v3->__r_.__value_.__r.__words[0];
    v8[0] = v3->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v8 + 7) = *(std::string::size_type *)((char *)&v3->__r_.__value_.__r.__words[1] + 7);
    v5 = HIBYTE(v3->__r_.__value_.__r.__words[2]);
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    v6 = v8[0];
    *(_QWORD *)a1 = v4;
    *(_QWORD *)(a1 + 8) = v6;
    *(_QWORD *)(a1 + 15) = *(_QWORD *)((char *)v8 + 7);
    *(_BYTE *)(a1 + 23) = v5;
    *(_BYTE *)(a1 + 24) = 1;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 24) = 0;
  }
}

void sub_1B61B7240(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t IR::IRProcessor::initialize(IR::IRProcessor *this, float a2, unsigned int a3, unsigned int a4, int a5, BOOL a6, char a7, int a8)
{
  uint64_t FilterLength;
  IR::IRData **v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  float v20;
  IR::FFTFilter *v21;
  uint64_t v22;
  uint64_t DataLayout;
  uint64_t v24;
  const void *v25;
  int64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char canInterpolateInDimension;
  BOOL v32;
  char v33;
  uint64_t v34;
  IR::IRDataLoader *v35;
  unint64_t v36;
  uint64_t ScratchKernels;
  __int128 v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  IR::FFTFilterKernel *v52;
  IR::FFTFilterKernel *v53;
  unsigned int v54;
  _QWORD *v55;
  _QWORD *v56;
  IR::FixedIntegerDelay *v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unsigned int v62;
  _QWORD *v63;
  IR::FixedIntegerDelay *v64;
  unsigned int v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  unint64_t v74;
  char **v75;
  uint64_t v76;
  IR::FFTFilterKernel *v77;
  uint64_t *v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  char *v86;
  IR::FFTFilterKernel *v87;
  uint64_t v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  IR::FFTFilterKernel *v97;
  uint64_t v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  unint64_t v103;
  unsigned int v105;
  unsigned int v106;
  BOOL v107;
  unsigned int v108;
  __int128 v110;
  char *v111;
  char v112;
  _BYTE v113[32];
  char *v114;

  v111 = (char *)this + 8;
  v112 = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 8);
  FilterLength = (*(uint64_t (**)(IR::IRProcessor *))(*(_QWORD *)this + 24))(this);
  *((float *)this + 8) = a2;
  *((_DWORD *)this + 107) = 0;
  if (!*((_DWORD *)this + 18) && !*((_BYTE *)this + 40) && *((_DWORD *)this + 9))
  {
    if (*((_BYTE *)this + 416))
    {
      v35 = (IR::IRDataLoader *)IR::IRDataLoader::instance((IR::IRDataLoader *)FilterLength);
      FilterLength = IR::IRDataLoader::getFilterLength(v35, (IR::IRProcessor *)((char *)this + 24));
      if (!(_DWORD)FilterLength)
        goto LABEL_3;
    }
    else
    {
      FilterLength = *((unsigned int *)this + 106);
      if (!(_DWORD)FilterLength)
        goto LABEL_3;
    }
    v105 = *((_DWORD *)this + 9);
    if (FilterLength < v105)
    {
      v106 = 1 << -(char)__clz(FilterLength - 1);
      if (v106 <= 2)
        v106 = 2;
      v107 = v105 >= v106;
      v108 = v105 - v106;
      if (v108 != 0 && v107)
      {
        *((_DWORD *)this + 107) = v108;
        *((_DWORD *)this + 9) = v106;
      }
    }
  }
LABEL_3:
  if (*((_BYTE *)this + 416))
  {
    IR::IRDataLoader::instance((IR::IRDataLoader *)FilterLength);
    std::string::basic_string[abi:ne180100]<0>(v113, "IRProcessor|");
    IR::IRDataLoader::load();
    v16 = (IR::IRData **)((char *)this + 184);
    std::shared_ptr<vp::xml::_xmlNode const>::operator=[abi:ne180100]((uint64_t)this + 184, &v110);
    v17 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
    if (*((_QWORD *)&v110 + 1))
    {
      v18 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    if ((v113[23] & 0x80000000) != 0)
      operator delete(*(void **)v113);
    if (!*v16)
    {
      v34 = 4294956425;
      goto LABEL_132;
    }
    *((_DWORD *)this + 105) = IR::IRData::getNumFiltersPerSpatialPoint(*v16);
    *((_DWORD *)this + 106) = IR::IRData::getFilterLength(*((IR::IRData **)this + 23));
    IR::IRData::getMaxDelay(*((IR::IRData **)this + 23));
    *((_DWORD *)this + 108) = vcvtps_u32_f32(v20);
    *((_DWORD *)this + 109) = IR::IRData::getAudioChannelLayoutTag(*((IR::IRData **)this + 23));
    *((_DWORD *)this + 18) = *(_DWORD *)(IR::IRData::getIRDataAttributes(*((IR::IRData **)this + 23)) + 48);
  }
  *((_BYTE *)this + 417) = a7;
  *((_BYTE *)this + 208) = a5;
  if (a5)
  {
    v21 = (IR::FFTFilter *)operator new();
    MEMORY[0x1BCC94D74]();
  }
  else
  {
    v21 = (IR::FFTFilter *)operator new();
    IR::FFTFilter::FFTFilter(v21);
  }
  v22 = *((_QWORD *)this + 25);
  *((_QWORD *)this + 25) = v21;
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
  if (*((_BYTE *)this + 416))
  {
    DataLayout = IR::IRData::getDataLayout(*((IR::IRData **)this + 23));
    v25 = *(const void **)DataLayout;
    v24 = *(_QWORD *)(DataLayout + 8);
    v26 = v24 - *(_QWORD *)DataLayout;
    if (v24 == *(_QWORD *)DataLayout)
    {
      v32 = 0;
    }
    else
    {
      if (v26 < 0)
        std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
      v27 = (char *)operator new(v24 - *(_QWORD *)DataLayout);
      v28 = 4 * (v26 >> 2);
      memmove(v27, v25, v26);
      if (v28)
      {
        v29 = 0;
        v30 = v28 - 4;
        do
        {
          canInterpolateInDimension = IR::IRData::canInterpolateInDimension();
          v32 = canInterpolateInDimension;
          if (v30 == v29)
            v33 = 1;
          else
            v33 = canInterpolateInDimension;
          v29 += 4;
        }
        while ((v33 & 1) == 0);
      }
      else
      {
        v32 = 0;
        v27 += 4 * (v26 >> 2);
      }
      operator delete(v27);
    }
  }
  else
  {
    v32 = 1;
  }
  v34 = IR::FFTFilter::initialize(*((IR::FFTFilter **)this + 25), *((_DWORD *)this + 106), *((_DWORD *)this + 9), *((_DWORD *)this + 105), *((_BYTE *)this + 40), a3, a4, a6, v32, *((_BYTE *)this + 417));
  if (!(_DWORD)v34)
  {
    v36 = *((unsigned int *)this + 105);
    *(_DWORD *)v113 = 0;
    std::vector<float>::assign((char **)this + 33, v36, v113);
    ScratchKernels = IR::FFTFilter::getScratchKernels(*((IR::FFTFilter **)this + 25));
    if (*((_BYTE *)this + 416))
    {
      IR::IRData::getDefaultCoordinates(*((IR::IRData **)this + 23));
      *((_DWORD *)this + 98) = (_DWORD)v114;
      v38 = *(_OWORD *)&v113[16];
      *(_OWORD *)((char *)this + 360) = *(_OWORD *)v113;
      *(_OWORD *)((char *)this + 376) = v38;
      IR::IRData::getInterpolatedCoeffs();
    }
    else
    {
      v53 = *(IR::FFTFilterKernel **)ScratchKernels;
      v52 = *(IR::FFTFilterKernel **)(ScratchKernels + 8);
      while (v53 != v52)
      {
        IR::FFTFilterKernel::reset(v53);
        v53 = (IR::FFTFilterKernel *)((char *)v53 + 40);
      }
    }
    IR::FFTFilter::setFilterKernels();
    v39 = *((_DWORD *)this + 103);
    if (v39)
    {
      if (v39 == 1 && *((_DWORD *)this + 108))
      {
        if (*((_DWORD *)this + 105))
        {
          v40 = 0;
          v41 = 0;
          v42 = (_QWORD *)((char *)this + 216);
          do
          {
            v43 = *((_DWORD *)this + 107) + *((_DWORD *)this + 108);
            v45 = *((_QWORD *)this + 28);
            v44 = *((_QWORD *)this + 29);
            if (v45 >= v44)
            {
              v47 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v45 - *v42) >> 4);
              v48 = v47 + 1;
              if (v47 + 1 > 0xD79435E50D7943)
                std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
              v49 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v44 - *v42) >> 4);
              if (2 * v49 > v48)
                v48 = 2 * v49;
              if (v49 >= 0x6BCA1AF286BCA1)
                v50 = 0xD79435E50D7943;
              else
                v50 = v48;
              v114 = (char *)this + 232;
              if (v50)
                v50 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::DelayLine>>(v50);
              else
                v51 = 0;
              *(_QWORD *)v113 = v50;
              *(_QWORD *)&v113[8] = v50 + 304 * v47;
              *(_QWORD *)&v113[16] = *(_QWORD *)&v113[8];
              *(_QWORD *)&v113[24] = v50 + 304 * v51;
              IR::DelayLine::DelayLine(*(uint64_t *)&v113[8], v43, 5, 1uLL, 0, a3);
              *(_QWORD *)&v113[16] += 304;
              std::vector<IR::DelayLine>::__swap_out_circular_buffer((uint64_t *)this + 27, v113);
              v46 = *((_QWORD *)this + 28);
              std::__split_buffer<IR::DelayLine>::~__split_buffer((uint64_t)v113);
            }
            else
            {
              IR::DelayLine::DelayLine(*((_QWORD *)this + 28), *((_DWORD *)this + 107) + *((_DWORD *)this + 108), 5, 1uLL, 0, a3);
              v46 = v45 + 304;
              *((_QWORD *)this + 28) = v45 + 304;
            }
            *((_QWORD *)this + 28) = v46;
            IR::DelayLine::setDelay(*((_QWORD *)this + 27) + v40, *(float *)(*((_QWORD *)this + 33) + 4 * v41++) + (float)*((unsigned int *)this + 107));
            v40 += 304;
          }
          while (v41 < *((unsigned int *)this + 105));
        }
      }
      else
      {
        *((_DWORD *)this + 103) = 2;
        if (*((_DWORD *)this + 105))
        {
          v62 = 0;
          v63 = (_QWORD *)((char *)this + 240);
          v64 = (IR::FixedIntegerDelay *)*((_QWORD *)this + 31);
          do
          {
            v65 = *((_DWORD *)this + 107) + 5;
            v66 = *((_QWORD *)this + 32);
            if ((unint64_t)v64 >= v66)
            {
              v67 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v64 - *v63) >> 3);
              v68 = v67 + 1;
              if ((unint64_t)(v67 + 1) > 0x492492492492492)
                std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
              v69 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v66 - *v63) >> 3);
              if (2 * v69 > v68)
                v68 = 2 * v69;
              if (v69 >= 0x249249249249249)
                v70 = 0x492492492492492;
              else
                v70 = v68;
              v114 = (char *)this + 256;
              if (v70)
                v70 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::FixedIntegerDelay>>(v70);
              else
                v71 = 0;
              *(_QWORD *)v113 = v70;
              *(_QWORD *)&v113[8] = v70 + 56 * v67;
              *(_QWORD *)&v113[16] = *(_QWORD *)&v113[8];
              *(_QWORD *)&v113[24] = v70 + 56 * v71;
              IR::FixedIntegerDelay::FixedIntegerDelay(*(IR::FixedIntegerDelay **)&v113[8], v65, 1);
              *(_QWORD *)&v113[16] += 56;
              std::vector<IR::FixedIntegerDelay>::__swap_out_circular_buffer((uint64_t *)this + 30, v113);
              v64 = (IR::FixedIntegerDelay *)*((_QWORD *)this + 31);
              std::__split_buffer<IR::FixedIntegerDelay>::~__split_buffer((uint64_t)v113);
            }
            else
            {
              IR::FixedIntegerDelay::FixedIntegerDelay(v64, *((_DWORD *)this + 107) + 5, 1);
              v64 = (IR::FixedIntegerDelay *)((char *)v64 + 56);
              *((_QWORD *)this + 31) = v64;
            }
            *((_QWORD *)this + 31) = v64;
            ++v62;
          }
          while (v62 < *((_DWORD *)this + 105));
        }
      }
    }
    else if (*((_DWORD *)this + 107) && *((_DWORD *)this + 105))
    {
      v54 = 0;
      v55 = (_QWORD *)((char *)this + 240);
      v56 = (_QWORD *)((char *)this + 256);
      v57 = (IR::FixedIntegerDelay *)*((_QWORD *)this + 31);
      do
      {
        if ((unint64_t)v57 >= *v56)
        {
          v58 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v57 - *v55) >> 3);
          v59 = v58 + 1;
          if ((unint64_t)(v58 + 1) > 0x492492492492492)
            std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
          if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*v56 - *v55) >> 3) > v59)
            v59 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*v56 - *v55) >> 3);
          if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*v56 - *v55) >> 3)) >= 0x249249249249249)
            v60 = 0x492492492492492;
          else
            v60 = v59;
          v114 = (char *)this + 256;
          if (v60)
            v60 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::FixedIntegerDelay>>(v60);
          else
            v61 = 0;
          *(_QWORD *)v113 = v60;
          *(_QWORD *)&v113[8] = v60 + 56 * v58;
          *(_QWORD *)&v113[16] = *(_QWORD *)&v113[8];
          *(_QWORD *)&v113[24] = v60 + 56 * v61;
          IR::FixedIntegerDelay::FixedIntegerDelay(*(IR::FixedIntegerDelay **)&v113[8], *((_DWORD *)this + 107), 1);
          *(_QWORD *)&v113[16] += 56;
          std::vector<IR::FixedIntegerDelay>::__swap_out_circular_buffer((uint64_t *)this + 30, v113);
          v57 = (IR::FixedIntegerDelay *)*((_QWORD *)this + 31);
          std::__split_buffer<IR::FixedIntegerDelay>::~__split_buffer((uint64_t)v113);
        }
        else
        {
          IR::FixedIntegerDelay::FixedIntegerDelay(v57, *((_DWORD *)this + 107), 1);
          v57 = (IR::FixedIntegerDelay *)((char *)v57 + 56);
          *((_QWORD *)this + 31) = v57;
        }
        *((_QWORD *)this + 31) = v57;
        ++v54;
      }
      while (v54 < *((_DWORD *)this + 105));
    }
    *((_BYTE *)this + 408) = 1;
    *((_BYTE *)this + 176) = 1;
    if (*((_BYTE *)this + 208))
    {
      std::vector<std::vector<float>>::resize((uint64_t *)this + 36, *((unsigned int *)this + 105));
      v72 = a8;
      if (*((_DWORD *)this + 105))
      {
        v73 = 0;
        v74 = 0;
        do
        {
          v75 = (char **)(*((_QWORD *)this + 36) + v73);
          *(_DWORD *)v113 = 0;
          std::vector<float>::assign(v75, a3, v113);
          ++v74;
          v73 += 24;
        }
        while (v74 < *((unsigned int *)this + 105));
      }
    }
    else
    {
      std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 36);
      v72 = a8;
    }
    v77 = (IR::FFTFilterKernel *)*((_QWORD *)this + 39);
    v76 = *((_QWORD *)this + 40);
    if (!v72)
    {
      while ((IR::FFTFilterKernel *)v76 != v77)
        v76 = MEMORY[0x1BCC94D68](v76 - 40);
      v34 = 0;
      *((_QWORD *)this + 40) = v77;
      *((_QWORD *)this + 43) = *((_QWORD *)this + 42);
      goto LABEL_132;
    }
    v78 = (uint64_t *)((char *)this + 312);
    if ((IR::FFTFilterKernel *)v76 != v77)
    {
      do
        v76 = MEMORY[0x1BCC94D68](v76 - 40);
      while ((IR::FFTFilterKernel *)v76 != v77);
      v76 = *v78;
    }
    *((_QWORD *)this + 40) = v77;
    v79 = *((unsigned int *)this + 105);
    v80 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v77 - v76) >> 3);
    v81 = v79 - v80;
    if (v79 <= v80)
    {
      if (v79 >= v80)
      {
LABEL_128:
        std::vector<float>::resize((uint64_t)this + 336, *((unsigned int *)this + 105));
        if (*((_DWORD *)this + 105))
        {
          v102 = 0;
          v103 = 0;
          do
          {
            IR::FFTFilterKernel::initialize((IR::FFTFilterKernel *)(*((_QWORD *)this + 39) + v102));
            ++v103;
            v102 += 40;
          }
          while (v103 < *((unsigned int *)this + 105));
        }
        v34 = 0;
        goto LABEL_132;
      }
      v97 = (IR::FFTFilterKernel *)(v76 + 40 * v79);
      while (v77 != v97)
      {
        v77 = (IR::FFTFilterKernel *)((char *)v77 - 40);
        MEMORY[0x1BCC94D68](v77);
      }
    }
    else
    {
      v82 = *((_QWORD *)this + 41);
      if (0xCCCCCCCCCCCCCCCDLL * ((v82 - (uint64_t)v77) >> 3) < v81)
      {
        v83 = 0xCCCCCCCCCCCCCCCDLL * ((v82 - v76) >> 3);
        v84 = 2 * v83;
        if (2 * v83 <= v79)
          v84 = *((unsigned int *)this + 105);
        if (v83 >= 0x333333333333333)
          v85 = 0x666666666666666;
        else
          v85 = v84;
        v114 = (char *)this + 328;
        if (v85 > 0x666666666666666)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v86 = (char *)operator new(40 * v85);
        v87 = (IR::FFTFilterKernel *)&v86[40 * v80];
        *(_QWORD *)v113 = v86;
        *(_QWORD *)&v113[8] = v87;
        *(_QWORD *)&v113[16] = v87;
        *(_QWORD *)&v113[24] = &v86[40 * v85];
        v88 = 5 * v79;
        v89 = &v86[40 * v79];
        v90 = 8 * v88 - 40 * v80;
        do
        {
          IR::FFTFilterKernel::FFTFilterKernel(v87);
          v87 = (IR::FFTFilterKernel *)((char *)v87 + 40);
          v90 -= 40;
        }
        while (v90);
        *(_QWORD *)&v113[16] = v89;
        v92 = *((_QWORD *)this + 39);
        v91 = *((_QWORD *)this + 40);
        v93 = 40;
        v94 = *(_QWORD *)&v113[8];
        while (1)
        {
          v95 = v94 + v93;
          if (v91 + v93 - 40 == v92)
            break;
          v96 = v91 + v93 - 80;
          v93 -= 40;
          MEMORY[0x1BCC94D50](v95 - 80, v96);
        }
        v99 = *((_QWORD *)this + 41);
        v100 = *(_OWORD *)&v113[16];
        v101 = *(_OWORD *)v78;
        *((_QWORD *)this + 39) = v95 - 40;
        *(_OWORD *)&v113[8] = v101;
        *((_OWORD *)this + 20) = v100;
        *(_QWORD *)&v113[24] = v99;
        *(_QWORD *)v113 = v101;
        std::__split_buffer<IR::FFTFilterKernel>::~__split_buffer((uint64_t)v113);
        goto LABEL_128;
      }
      v97 = (IR::FFTFilterKernel *)((char *)v77 + 40 * v81);
      v98 = 40 * v79 - 8 * (((uint64_t)v77 - v76) >> 3);
      do
      {
        IR::FFTFilterKernel::FFTFilterKernel(v77);
        v77 = (IR::FFTFilterKernel *)((char *)v77 + 40);
        v98 -= 40;
      }
      while (v98);
    }
    *((_QWORD *)this + 40) = v97;
    goto LABEL_128;
  }
LABEL_132:
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v111);
  return v34;
}

void sub_1B61B7D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&a18);
  _Unwind_Resume(a1);
}

uint64_t IR::IRProcessor::uninitialize(IR::IRProcessor *this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  _QWORD *j;
  _QWORD *v9;
  char *v11;
  char v12;

  v11 = (char *)this + 8;
  v12 = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 8);
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 24);
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = *((_QWORD *)this + 25);
  *((_QWORD *)this + 25) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v7 = *((_QWORD *)this + 27);
  for (i = *((_QWORD *)this + 28); i != v7; IR::DelayLine::~DelayLine((IR::DelayLine *)(i - 304)))
    ;
  *((_QWORD *)this + 28) = v7;
  v9 = (_QWORD *)*((_QWORD *)this + 30);
  for (j = (_QWORD *)*((_QWORD *)this + 31); j != v9; std::__destroy_at[abi:ne180100]<IR::FixedIntegerDelay,0>(j))
    j -= 7;
  *((_QWORD *)this + 31) = v9;
  *((_QWORD *)this + 34) = *((_QWORD *)this + 33);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 36);
  *((_BYTE *)this + 176) = 0;
  return std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v11);
}

uint64_t IR::IRProcessor::reset(IR::FFTFilter **this)
{
  IR::DelayLine *v2;
  IR::DelayLine *v3;
  IR::FixedIntegerDelay *v4;
  IR::FixedIntegerDelay *v5;
  char *v7;
  char v8;

  v7 = (char *)(this + 1);
  v8 = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)(this + 1));
  if (*((_BYTE *)this + 176))
  {
    IR::FFTFilter::reset(this[25]);
    v2 = this[27];
    v3 = this[28];
    while (v2 != v3)
    {
      IR::DelayLine::reset(v2);
      v2 = (IR::DelayLine *)((char *)v2 + 304);
    }
    v4 = this[30];
    v5 = this[31];
    while (v4 != v5)
    {
      IR::FixedIntegerDelay::reset(v4);
      v4 = (IR::FixedIntegerDelay *)((char *)v4 + 56);
    }
    *((_BYTE *)this + 408) = 1;
  }
  return std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v7);
}

void sub_1B61B7FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t IR::IRProcessor::process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, &v7, a3, 1, a4, a5, a6);
}

uint64_t IR::IRProcessor::processMultipleInputs(IR::IRProcessor *this, const float **a2, float *const *a3, unsigned int a4, unsigned int a5, vDSP_Length a6, float a7, IR::ComplexDataCircBuffer *a8)
{
  uint64_t result;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  void *v25;
  const float *v26;
  const float **v27;
  uint64_t v28;
  unsigned __int8 v29;
  _QWORD *ScratchKernels;
  _QWORD *AverageIR;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  float *const *v35;
  size_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  uint64_t v43;
  float v44;
  vDSP_Length v45;
  float *v46;
  IR::DelayLine *v47;
  uint64_t v48;
  float *v49;
  float *v50;
  float v51;
  float v52;
  uint64_t v53;
  char v54;
  float v55;
  IR::FFTFilter *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  float *v61;
  uint64_t v62;
  float v63;
  _QWORD v64[2];
  IR::ComplexDataCircBuffer *v65;
  uint64_t v66;
  vDSP_Length v67;
  char *v68;
  float __Step;
  char *v70;
  char v71;
  float __B;
  float *__Start[2];

  __Start[1] = *(float **)MEMORY[0x1E0C80C00];
  __B = a7;
  if (!*((_BYTE *)this + 176))
    return 4294956429;
  result = 4294967246;
  if (a4 && a5)
  {
    v70 = (char *)this + 8;
    v16 = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 8);
    v71 = v16;
    if ((v16 & 1) == 0)
    {
      v24 = a5;
      do
      {
        v25 = *a3++;
        bzero(v25, 4 * a6);
        --v24;
      }
      while (v24);
      goto LABEL_69;
    }
    v17 = *((_DWORD *)this + 105);
    if (v17 >= a5)
      v17 = a5;
    if (v17 >= a4)
      v18 = a4;
    else
      v18 = v17;
    if (*((_BYTE *)this + 417))
      v19 = v18;
    else
      v19 = v17;
    MEMORY[0x1E0C80A78](v16);
    if (8 * (unint64_t)v19 >= 0x200)
      v21 = 512;
    else
      v21 = 8 * v19;
    v68 = (char *)v64 - v20;
    bzero((char *)v64 - v20, v21);
    v23 = *((unsigned __int8 *)this + 417);
    v66 = v19;
    if (v23)
    {
      if ((_DWORD)v19)
        v22 = (uint64_t)memcpy(v68, a2, 8 * v19);
    }
    else if ((_DWORD)v19)
    {
      v26 = *a2;
      v27 = (const float **)v68;
      v28 = v66;
      do
      {
        *v27++ = v26;
        --v28;
      }
      while (v28);
    }
    if (*((_BYTE *)this + 416))
    {
      v29 = atomic_load((unsigned __int8 *)this + 440);
      if ((v29 & 1) != 0)
      {
        atomic_store(0, (unsigned __int8 *)this + 440);
        v22 = IR::FFTFilter::doXFadeUpdate(*((IR::FFTFilter **)this + 25));
        if ((_DWORD)v22)
        {
          ScratchKernels = (_QWORD *)IR::FFTFilter::getScratchKernels(*((IR::FFTFilter **)this + 25));
          IR::IRData::getInterpolatedCoeffs();
          if (IR::IRData::isAverageIRComputed(*((IR::IRData **)this + 23)) && *((float *)this + 99) > 0.0)
          {
            AverageIR = (_QWORD *)IR::IRData::getAverageIR(*((IR::IRData **)this + 23));
            v32 = -858993459 * ((ScratchKernels[1] - *ScratchKernels) >> 3) >= -858993459
                                                                                           * ((AverageIR[1] - *AverageIR) >> 3)
                ? -858993459 * ((AverageIR[1] - *AverageIR) >> 3)
                : -858993459 * ((ScratchKernels[1] - *ScratchKernels) >> 3);
            if (v32)
            {
              v65 = a8;
              v33 = 0;
              do
              {
                IR::FFTFilterKernel::scale((IR::FFTFilterKernel *)(*ScratchKernels + v33), 1.0 - *((float *)this + 99));
                IR::FFTFilterKernel::accumulate();
                v33 += 40;
              }
              while (40 * v32 != v33);
              a8 = v65;
              if (v32 == 2)
                **((float32x2_t **)this + 33) = vmul_f32(vmla_n_f32((float32x2_t)vrev64_s32((int32x2_t)vmul_n_f32(**((float32x2_t **)this + 33), 1.0- (float)(1.0- *((float *)this + 99)))), **((float32x2_t **)this + 33), (float)(1.0 - *((float *)this + 99)) + 1.0), (float32x2_t)0x3F0000003F000000);
            }
          }
          v22 = IR::FFTFilter::setFilterKernels();
        }
      }
    }
    if (!*((_BYTE *)this + 208))
    {
      v56 = (IR::FFTFilter *)*((_QWORD *)this + 25);
      v57 = v66;
      if (*((_BYTE *)this + 417))
        IR::FFTFilter::processMultipleInputs(v56, (float *const *)a2, a3, a6, v66, v66, 0);
      else
        IR::FFTFilter::process(v56, *a2, a3);
      if ((_DWORD)v57)
      {
        v58 = 0;
        v59 = 0;
        v60 = 0;
        do
        {
          if (*((_DWORD *)this + 103) == 1)
          {
            IR::DelayLine::setDelay(*((_QWORD *)this + 27) + v58, *(float *)(*((_QWORD *)this + 33) + 4 * v60) + (float)*((unsigned int *)this + 107));
            v61 = (float *)(*((_QWORD *)this + 27) + v58);
            v61[24] = expf(-1.0 / *((float *)this + 100));
            __Start[0] = a3[v60];
            IR::DelayLine::process((IR::DelayLine *)v61, __Start[0], __Start, a6);
          }
          else
          {
            v62 = *((_QWORD *)this + 30);
            if (v62 != *((_QWORD *)this + 31))
              IR::FixedIntegerDelay::process((IR::FixedIntegerDelay *)(v62 + v59), a3[v60], a3[v60], a6);
          }
          v63 = *((float *)this + 101);
          if (__B == v63 || *((_BYTE *)this + 408))
          {
            vDSP_vsmul(a3[v60], 1, &__B, a3[v60], 1, a6);
          }
          else if ((_DWORD)a6)
          {
            LODWORD(__Start[0]) = *((_DWORD *)this + 101);
            __Step = (float)(__B - v63) / (float)a6;
            vDSP_vrampmul(a3[v60], 1, (float *)__Start, &__Step, a3[v60], 1, a6);
          }
          ++v60;
          v59 += 56;
          v58 += 304;
        }
        while (v57 != v60);
      }
      goto LABEL_68;
    }
    MEMORY[0x1E0C80A78](v22);
    v35 = (float *const *)((char *)v64 - ((v34 + 15) & 0xFFFFFFFF0));
    if (v34 >= 0x200)
      v36 = 512;
    else
      v36 = v34;
    bzero((char *)v64 - ((v34 + 15) & 0xFFFFFFFF0), v36);
    v37 = v66;
    if ((_DWORD)v66)
    {
      v64[0] = v64;
      v64[1] = v64;
      v65 = a8;
      v38 = 0;
      v39 = 0;
      v40 = 0;
      v41 = 0;
      v67 = a6;
      v42 = (float)a6;
      v43 = 24 * v66;
      do
      {
        v44 = *((float *)this + 101);
        if (__B == v44 || *((_BYTE *)this + 408))
        {
          vDSP_vsmul(*(const float **)&v68[8 * v41], 1, &__B, *(float **)(*((_QWORD *)this + 36) + v40), 1, v67);
        }
        else if ((_DWORD)a6)
        {
          LODWORD(__Start[0]) = *((_DWORD *)this + 101);
          __Step = (float)(__B - v44) / v42;
          vDSP_vrampmul(*(const float **)&v68[8 * v41], 1, (float *)__Start, &__Step, *(float **)(*((_QWORD *)this + 36) + v40), 1, v67);
        }
        if (*((_DWORD *)this + 103) == 1)
        {
          IR::DelayLine::setDelay(*((_QWORD *)this + 27) + v38, *(float *)(*((_QWORD *)this + 33) + 4 * v41) + (float)*((unsigned int *)this + 107));
          v45 = a6;
          v46 = (float *)(*((_QWORD *)this + 27) + v38);
          v46[24] = expf(-1.0 / *((float *)this + 100));
          __Start[0] = *(float **)(*((_QWORD *)this + 36) + v40);
          v47 = (IR::DelayLine *)v46;
          a6 = v45;
          IR::DelayLine::process(v47, __Start[0], __Start, v45);
        }
        else
        {
          v48 = *((_QWORD *)this + 30);
          if (v48 != *((_QWORD *)this + 31))
            IR::FixedIntegerDelay::process((IR::FixedIntegerDelay *)(v48 + v39), *(float **)(*((_QWORD *)this + 36) + v40), *(float **)(*((_QWORD *)this + 36) + v40), a6);
        }
        v35[v41++] = *(float *const *)(*((_QWORD *)this + 36) + v40);
        v40 += 24;
        v39 += 56;
        v38 += 304;
      }
      while (v43 != v40);
      a8 = v65;
      v37 = v66;
      if (!*((_BYTE *)this + 417))
      {
        if (v66 >= 2)
        {
          v49 = (float *)*((_QWORD *)this + 33);
          v51 = *v49;
          v50 = v49 + 1;
          v52 = v51;
          v53 = v66 - 1;
          v54 = 1;
          do
          {
            v55 = *v50++;
            v54 &= v55 == v52;
            --v53;
          }
          while (v53);
          if ((v54 & 1) == 0)
          {
            IR::FFTFilter::processMultipleInputs(*((IR::FFTFilter **)this + 25), v35, a3, a6, v66, v66, v65);
LABEL_68:
            *((_BYTE *)this + 408) = 0;
            *((float *)this + 101) = __B;
LABEL_69:
            std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v70);
            return 0;
          }
        }
LABEL_67:
        IR::FFTFilter::process(*((IR::FFTFilter **)this + 25), *(const float **)v35, a3, a6, v37, a8);
        goto LABEL_68;
      }
    }
    else if (!*((_BYTE *)this + 417))
    {
      goto LABEL_67;
    }
    IR::FFTFilter::processMultipleInputs(*((IR::FFTFilter **)this + 25), v35, a3, a6, v37, v37, a8);
    goto LABEL_68;
  }
  return result;
}

void sub_1B61B86D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100](v1 - 136);
  _Unwind_Resume(a1);
}

uint64_t IR::IRProcessor::getFilterLength(IR::IRProcessor *this)
{
  return *((unsigned int *)this + 106);
}

uint64_t IR::IRProcessor::getFFTFilterConfigParams(IR::IRProcessor *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 25) + 16))(*((_QWORD *)this + 25));
}

uint64_t IR::IRProcessor::getNumOutputChannels(IR::IRProcessor *this)
{
  return *((unsigned int *)this + 105);
}

uint64_t IR::IRProcessor::isInitialized(IR::IRProcessor *this)
{
  return *((unsigned __int8 *)this + 176);
}

uint64_t IR::IRProcessor::getAudioChannelLayoutTag(IR::IRProcessor *this)
{
  return *((unsigned int *)this + 109);
}

uint64_t IR::IRProcessor::getMaxDelay(IR::IRProcessor *this)
{
  return *((unsigned int *)this + 108);
}

uint64_t IR::IRProcessor::getUserData@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  if (*(_BYTE *)(this + 416))
  {
    if (!*(_BYTE *)(this + 176))
      JUMPOUT(0x1BCC94E10);
    return IR::IRData::getUserData(*(IR::IRData **)(this + 184));
  }
  else
  {
    *a2 = 0;
  }
  return this;
}

float IR::IRProcessor::getCurrentDelay(IR::IRProcessor *this, unsigned int a2)
{
  uint64_t v2;
  float result;

  v2 = *((_QWORD *)this + 33);
  result = 0.0;
  if (a2 < (unint64_t)((*((_QWORD *)this + 34) - v2) >> 2))
    return *(float *)(v2 + 4 * a2);
  return result;
}

unint64_t IR::IRProcessor::getLatency(IR::IRProcessor *this)
{
  unint64_t result;

  result = *((_QWORD *)this + 23);
  if (result)
    LODWORD(result) = IR::IRData::getProcessingDelay((IR::IRData *)result);
  if (*((_DWORD *)this + 103))
    result = (result + 5);
  else
    result = result;
  if (!*((_BYTE *)this + 40))
    return (*((_DWORD *)this + 9) + *((_DWORD *)this + 107) + result);
  return result;
}

uint64_t IR::IRProcessor::getTailLength(IR::IRProcessor *this)
{
  int v2;
  int v3;
  int v4;

  v2 = (*(uint64_t (**)(IR::IRProcessor *))(*(_QWORD *)this + 56))(this);
  v3 = (*(uint64_t (**)(IR::IRProcessor *))(*(_QWORD *)this + 120))(this);
  if (*((_DWORD *)this + 103) == 1)
    v4 = *((_DWORD *)this + 108);
  else
    v4 = 0;
  return (v3 + v2 + v4);
}

uint64_t IR::IRProcessor::getModelingDelay(IR::IRProcessor *this)
{
  if (!*((_BYTE *)this + 416))
    return 0;
  if (!*((_BYTE *)this + 176))
    JUMPOUT(0x1BCC94E1CLL);
  return IR::IRData::getModelingDelay(*((IR::IRData **)this + 23));
}

uint64_t IR::IRProcessor::setCoordinate(uint64_t a1, float a2)
{
  uint64_t result;
  float v5;

  result = IR::IRCoordinates::get();
  if (v5 != a2)
  {
    result = IR::IRCoordinates::set();
    if (*(_BYTE *)(a1 + 416))
    {
      result = IR::IRData::canInterpolateInDimension();
      if ((_DWORD)result)
        atomic_store(1u, (unsigned __int8 *)(a1 + 440));
    }
  }
  return result;
}

uint64_t IR::IRProcessor::getCoordinate()
{
  return IR::IRCoordinates::get();
}

void IR::IRProcessor::setAverageIRMix(IR::IRProcessor *this, float a2)
{
  float v2;
  BOOL v3;
  float v4;

  if (*((float *)this + 99) != a2)
  {
    v2 = 1.0;
    if (a2 <= 1.0)
      v2 = a2;
    v3 = a2 < 0.0;
    v4 = 0.0;
    if (!v3)
      v4 = v2;
    *((float *)this + 99) = v4;
    atomic_store(1u, (unsigned __int8 *)this + 440);
  }
}

float IR::IRProcessor::getAverageIRMix(IR::IRProcessor *this)
{
  return *((float *)this + 99);
}

__n128 IR::IRProcessor::setCoordinates(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __n128 result;
  __int128 v6;

  v4 = a1 + 360;
  if (IR::IRCoordinates::operator!=())
  {
    result = *(__n128 *)a2;
    v6 = *(_OWORD *)(a2 + 16);
    *(_DWORD *)(v4 + 32) = *(_DWORD *)(a2 + 32);
    *(__n128 *)v4 = result;
    *(_OWORD *)(v4 + 16) = v6;
    atomic_store(1u, (unsigned __int8 *)(a1 + 440));
  }
  return result;
}

__n128 IR::IRProcessor::getCoordinates@<Q0>(IR::IRProcessor *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  __int128 v3;

  *(_DWORD *)(a2 + 32) = *((_DWORD *)this + 98);
  result = *(__n128 *)((char *)this + 360);
  v3 = *(_OWORD *)((char *)this + 376);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t IR::IRProcessor::setFirstRender(uint64_t this, char a2)
{
  *(_BYTE *)(this + 408) = a2;
  return this;
}

uint64_t IR::IRProcessor::setIR(IR::IRProcessor *this, const IR::IRDataAttributes *a2)
{
  if (*((_BYTE *)this + 176) || !*((_BYTE *)this + 416))
    return 4294956418;
  IR::IRDataAttributes::operator=((uint64_t)this + 24, (uint64_t)a2);
  return 0;
}

uint64_t IR::IRProcessor::setIRCoeffs(IR::IRProcessor *this, const float *const *a2, const float *a3, int a4, uint64_t a5)
{
  _QWORD *ScratchKernels;
  unint64_t v12;
  int v13;

  if (!*((_BYTE *)this + 176) || *((_BYTE *)this + 416))
    return 4294956429;
  ScratchKernels = (_QWORD *)IR::FFTFilter::getScratchKernels(*((IR::FFTFilter **)this + 25));
  if (a4)
  {
    v12 = 0;
    do
    {
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(ScratchKernels[1] - *ScratchKernels) >> 3) <= v12)
        break;
      IR::FFTFilterKernel::storeCoeffs((IR::FFTFilterKernel *)(*ScratchKernels + 40 * v12), a2[v12], a5, 0);
      v13 = a3 ? LODWORD(a3[v12]) : 0;
      *(_DWORD *)(*((_QWORD *)this + 33) + 4 * v12++) = v13;
    }
    while (v12 != a4);
  }
  IR::FFTFilter::setFilterKernels();
  return 0;
}

uint64_t IR::IRProcessor::setWeightedKernel(IR::IRProcessor *this, const IR::IRCoordinates *a2, float *a3, unsigned int a4)
{
  _QWORD *ScratchKernels;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!*((_BYTE *)this + 176) || *((_QWORD *)this + 43) == *((_QWORD *)this + 42))
    return 4294956429;
  ScratchKernels = (_QWORD *)IR::FFTFilter::getScratchKernels(*((IR::FFTFilter **)this + 25));
  IR::IRData::getInterpolatedCoeffs();
  v7 = -858993459 * ((ScratchKernels[1] - *ScratchKernels) >> 3);
  if ((_DWORD)v7)
  {
    v8 = 0;
    do
    {
      IR::FFTFilterKernel::scale((IR::FFTFilterKernel *)(*ScratchKernels + v8), *a3);
      v8 += 40;
    }
    while (40 * v7 != v8);
  }
  if (a4 >= 2)
  {
    v9 = 1;
    do
    {
      IR::IRData::getInterpolatedCoeffs();
      if (v7)
      {
        v10 = 0;
        do
        {
          IR::FFTFilterKernel::accumulate();
          v10 += 40;
        }
        while (40 * v7 != v10);
      }
      ++v9;
    }
    while (v9 != a4);
  }
  IR::FFTFilter::setFilterKernels();
  return 0;
}

uint64_t IR::IRProcessor::getIRDataAttributes(IR::IRProcessor *this)
{
  return (uint64_t)this + 24;
}

uint64_t std::__split_buffer<IR::FFTFilterKernel>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    MEMORY[0x1BCC94D68]();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IR::DelayLine>>(unint64_t a1)
{
  if (a1 >= 0xD79435E50D7944)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(304 * a1);
}

uint64_t *std::vector<IR::DelayLine>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  SincKernelFactorySingleton *v20;
  double v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v2 = 0;
  v26 = result;
  v28 = *result;
  v29 = result[1];
  v3 = a2[1];
  v30 = v3;
  while (1)
  {
    v4 = v3 + v2;
    v5 = v29 + v2;
    if (v29 + v2 == v28)
      break;
    v6 = v5 - 304;
    *(_QWORD *)(v4 - 304) = *(_QWORD *)(v5 - 304);
    *(_DWORD *)(v4 - 296) = *(_DWORD *)(v5 - 296);
    *(_BYTE *)(v4 - 292) = 1;
    v7 = (_QWORD *)(v4 - 288);
    v7[1] = 0;
    v7[2] = 0;
    *v7 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v4 - 288), *(const void **)(v5 - 288), *(_QWORD *)(v5 - 280), (uint64_t)(*(_QWORD *)(v5 - 280) - *(_QWORD *)(v5 - 288)) >> 2);
    v8 = v3 + v2;
    v9 = *(_QWORD *)(v6 + 40);
    *(_QWORD *)(v3 + v2 - 256) = 0;
    v10 = (_QWORD *)(v3 + v2 - 256);
    *(v10 - 1) = v9;
    v10[1] = 0;
    v10[2] = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v10, *(const void **)(v6 + 48), *(_QWORD *)(v6 + 56), (uint64_t)(*(_QWORD *)(v6 + 56) - *(_QWORD *)(v6 + 48)) >> 2);
    *(_QWORD *)(v8 - 232) = 0;
    *(_QWORD *)(v8 - 224) = 0;
    v11 = (_QWORD *)(v3 + v2 - 232);
    v11[2] = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v11, *(const void **)(v6 + 72), *(_QWORD *)(v6 + 80), (uint64_t)(*(_QWORD *)(v6 + 80) - *(_QWORD *)(v6 + 72)) >> 2);
    v12 = v3 + v2;
    *(_DWORD *)(v12 - 208) = *(_DWORD *)(v6 + 96);
    *(_QWORD *)(v12 - 200) = *(_QWORD *)(v6 + 104);
    *(_QWORD *)(v12 - 192) = 0;
    *(_OWORD *)(v12 - 184) = *(_OWORD *)(v6 + 120);
    *(_QWORD *)(v3 + v2 - 168) = 0;
    *(_QWORD *)(v12 - 160) = 0;
    *(_QWORD *)(v12 - 152) = 0;
    std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((_QWORD *)(v3 + v2 - 168), *(const void **)(v6 + 136), *(_QWORD *)(v6 + 144), (uint64_t)(*(_QWORD *)(v6 + 144) - *(_QWORD *)(v6 + 136)) >> 2);
    *(_QWORD *)(v12 - 144) = 0;
    *(_QWORD *)(v12 - 136) = 0;
    *(_QWORD *)(v12 - 128) = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v3 + v2 - 144), *(const void **)(v6 + 160), *(_QWORD *)(v6 + 168), (uint64_t)(*(_QWORD *)(v6 + 168) - *(_QWORD *)(v6 + 160)) >> 2);
    v13 = v3 + v2;
    v14 = v3 + v2;
    *(_QWORD *)(v14 - 120) = 0;
    *(_QWORD *)(v14 - 112) = 0;
    *(_QWORD *)(v3 + v2 - 104) = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(v3 + v2 - 120), *(const void **)(v6 + 184), *(_QWORD *)(v6 + 192), (uint64_t)(*(_QWORD *)(v6 + 192) - *(_QWORD *)(v6 + 184)) >> 2);
    *(_QWORD *)(v13 - 96) = 0;
    *(_QWORD *)(v13 - 88) = 0;
    v15 = (_QWORD *)(v3 + v2 - 96);
    v15[2] = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v15, *(const void **)(v6 + 208), *(_QWORD *)(v6 + 216), (uint64_t)(*(_QWORD *)(v6 + 216) - *(_QWORD *)(v6 + 208)) >> 2);
    v16 = (_QWORD *)(v3 + v2);
    *(v16 - 9) = 0;
    *(v16 - 8) = 0;
    v17 = (_QWORD *)(v3 + v2 - 72);
    v17[2] = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v17, *(const void **)(v6 + 232), *(_QWORD *)(v6 + 240), (uint64_t)(*(_QWORD *)(v6 + 240) - *(_QWORD *)(v6 + 232)) >> 2);
    *(v16 - 6) = 0;
    *(v16 - 5) = 0;
    v16 -= 6;
    v16[2] = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v16, *(const void **)(v6 + 256), *(_QWORD *)(v6 + 264), (uint64_t)(*(_QWORD *)(v6 + 264) - *(_QWORD *)(v6 + 256)) >> 2);
    v18 = v30 + v2;
    *(_QWORD *)(v18 - 24) = 0;
    *(_QWORD *)(v18 - 16) = 0;
    v19 = (_QWORD *)(v30 + v2 - 24);
    v19[2] = 0;
    result = std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v19, *(const void **)(v6 + 280), *(_QWORD *)(v6 + 288), (uint64_t)(*(_QWORD *)(v6 + 288) - *(_QWORD *)(v6 + 280)) >> 2);
    v3 = v30;
    if ((*(_DWORD *)(v4 - 300) - 5) <= 2)
    {
      SincKernelFactorySingleton::instance((SincKernelFactorySingleton *)result);
      result = (uint64_t *)SincKernelFactorySingleton::ReferenceSincKernel(v20, v21, v22);
      *(_QWORD *)(v12 - 192) = result;
    }
    v2 -= 304;
  }
  a2[1] = v4;
  v23 = *v26;
  *v26 = v4;
  a2[1] = v23;
  v24 = v26[1];
  v26[1] = a2[2];
  a2[2] = v24;
  v25 = v26[2];
  v26[2] = a2[3];
  a2[3] = v25;
  *a2 = a2[1];
  return result;
}

void sub_1B61B8F1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, IR::DelayLine *a16)
{
  uint64_t v16;
  uint64_t v17;
  IR::DelayLine *v19;
  void **v20;
  void **v21;
  void **v22;
  void **v23;
  void **v24;
  void **v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void **v36;
  void **v37;
  void **v38;

  v19 = (IR::DelayLine *)(v17 + v16);
  v20 = (void **)(v17 + v16 - 48);
  v21 = (void **)(v17 + v16 - 72);
  v22 = (void **)((char *)v19 - 96);
  v23 = (void **)((char *)v19 - 120);
  v24 = (void **)((char *)v19 - 144);
  v36 = (void **)((char *)v19 - 288);
  v37 = (void **)((char *)v19 - 256);
  v25 = (void **)((char *)v19 - 232);
  v26 = (void *)*((_QWORD *)v19 - 3);
  if (v26)
  {
    *((_QWORD *)v19 - 2) = v26;
    operator delete(v26);
  }
  v27 = *v20;
  if (*v20)
  {
    *((_QWORD *)v19 - 5) = v27;
    operator delete(v27);
  }
  v28 = *v21;
  if (*v21)
  {
    *((_QWORD *)v19 - 8) = v28;
    operator delete(v28);
  }
  v29 = *v22;
  if (*v22)
  {
    *((_QWORD *)v19 - 11) = v29;
    operator delete(v29);
  }
  v30 = *v23;
  if (*v23)
  {
    *((_QWORD *)v19 - 14) = v30;
    operator delete(v30);
  }
  v38 = (void **)((char *)v19 - 168);
  v31 = *v24;
  if (*v24)
  {
    *((_QWORD *)v19 - 17) = v31;
    operator delete(v31);
  }
  v32 = *v38;
  if (*v38)
  {
    *((_QWORD *)v19 - 20) = v32;
    operator delete(v32);
  }
  v33 = *v25;
  if (*v25)
  {
    *((_QWORD *)v19 - 28) = v33;
    operator delete(v33);
  }
  v34 = *v37;
  if (*v37)
  {
    *((_QWORD *)v19 - 31) = v34;
    operator delete(v34);
  }
  v35 = *v36;
  if (*v36)
  {
    *((_QWORD *)v19 - 35) = v35;
    operator delete(v35);
  }
  while (v19 != a16)
  {
    IR::DelayLine::~DelayLine(v19);
    v19 = (IR::DelayLine *)((char *)v19 + 304);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<IR::DelayLine>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 304;
    IR::DelayLine::~DelayLine((IR::DelayLine *)(i - 304));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t GetVPSmartCoverIsAttached(BOOL *a1)
{
  void *v2;
  void *v3;
  CFArrayRef v4;
  CFArrayRef v5;
  const __CFArray *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  void *KeyboardEvent;
  void *v11;
  int IntegerValue;
  uint64_t v13;
  BOOL *v16;
  void *v17;
  unsigned int v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _BYTE v23[128];
  _QWORD v24[2];
  _QWORD v25[4];

  v25[2] = *MEMORY[0x1E0C80C00];
  v18 = 1768452981;
  if (GetVPSmartCoverIsAttached::gIOHIDEventSystemClientRef
    || (GetVPSmartCoverIsAttached::gIOHIDEventSystemClientRef = IOHIDEventSystemClientCreate()) != 0)
  {
    v16 = a1;
    v24[0] = CFSTR("PrimaryUsagePage");
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 65280);
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v24[1] = CFSTR("PrimaryUsage");
    v25[0] = v2;
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 41);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v25[1] = v3;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v25, v24, 2);
    v17 = (void *)objc_claimAutoreleasedReturnValue();

    IOHIDEventSystemClientSetMatching();
    v4 = IOHIDEventSystemClientCopyServices((IOHIDEventSystemClientRef)GetVPSmartCoverIsAttached::gIOHIDEventSystemClientRef);
    v5 = v4;
    if (v4)
    {
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v6 = v4;
      v7 = -[__CFArray countByEnumeratingWithState:objects:count:](v6, "countByEnumeratingWithState:objects:count:", &v19, v23, 16);
      if (v7)
      {
        v8 = *(_QWORD *)v20;
        while (2)
        {
          for (i = 0; i != v7; ++i)
          {
            if (*(_QWORD *)v20 != v8)
              objc_enumerationMutation(v6);
            KeyboardEvent = (void *)IOHIDEventCreateKeyboardEvent();
            v11 = (void *)IOHIDServiceClientCopyEvent();
            if (!v11)
            {
              v18 = 1768452965;
LABEL_20:

              goto LABEL_21;
            }
            IntegerValue = IOHIDEventGetIntegerValue();
            v13 = IOHIDEventGetIntegerValue();
            if (IntegerValue == 65289 && v13 == 16)
            {
              v18 = 0;
              *v16 = IOHIDEventGetIntegerValue() != 0;
              goto LABEL_20;
            }

          }
          v7 = -[__CFArray countByEnumeratingWithState:objects:count:](v6, "countByEnumeratingWithState:objects:count:", &v19, v23, 16);
          if (v7)
            continue;
          break;
        }
      }
LABEL_21:

    }
    else
    {
      v18 = 1768452963;
    }

  }
  else
  {
    return 1768449395;
  }
  return v18;
}

void sub_1B61B937C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

uint64_t DOABasedProbability::UpdateModelsWithShapeParameter(DOABasedProbability *this, float a2)
{
  (*(void (**)(_QWORD))(**((_QWORD **)this + 58) + 32))(*((_QWORD *)this + 58));
  (*(void (**)(_QWORD, float))(**((_QWORD **)this + 59) + 32))(*((_QWORD *)this + 59), a2);
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 60) + 32))(*((_QWORD *)this + 60), a2);
}

uint64_t DOABasedProbability::UpdateModelsWithShapeParameter(_QWORD **a1, uint64_t a2)
{
  (*(void (**)(_QWORD *))(*a1[58] + 40))(a1[58]);
  (*(void (**)(_QWORD *, uint64_t))(*a1[59] + 40))(a1[59], a2);
  return (*(uint64_t (**)(_QWORD *, uint64_t))(*a1[60] + 40))(a1[60], a2);
}

float DOABasedProbability::EstimateSpatialProbabilities(DOABasedProbability *this)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  vDSP_Length v6;
  uint64_t v7;
  float *v8;
  float v9;
  float v10;
  __float2 v11;
  __float2 v12;
  float *v13;
  int v14;
  float *v15;
  const void **v16;
  NSObject *v17;
  float *v18;
  float *v19;
  int v20;
  int v21;
  vDSP_Length v22;
  float *v23;
  NSObject *v24;
  unint64_t v25;
  uint64_t v26;
  float v27;
  char v28;
  uint64_t i;
  float v30;
  float v31;
  BOOL v32;
  float v33;
  vDSP_Length v34;
  float *v35;
  NSObject *v36;
  int v37;
  uint64_t v38;
  uint64_t j;
  float *v40;
  int v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  unsigned int v50;
  float __B;
  uint8_t buf[4];
  const char *v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  SpatialProbabilityBase::UpdatePriorProbabilities(this);
  SpatialProbabilityBase::UpdateShapeParameter(this);
  if (*((_BYTE *)this + 452))
  {
    CircularModelDOA::SetTargetDOA(*((CircularModelDOA **)this + 58), *((float *)this + 110), *((float *)this + 111), *((float *)this + 112));
    CircularModelDOA::SetTargetDOA(*((CircularModelDOA **)this + 59), *((float *)this + 110), *((float *)this + 111), *((float *)this + 112));
    CircularModelDOA::SetTargetDOA(*((CircularModelDOA **)this + 60), *((float *)this + 110), *((float *)this + 111), *((float *)this + 112));
  }
  *((_BYTE *)this + 452) = 0;
  if (!*((_BYTE *)this + 488))
  {
    v16 = (const void **)((char *)this + 504);
    goto LABEL_81;
  }
  v2 = *((_QWORD *)this + 67);
  v3 = *((_DWORD *)this + 2);
  DOAConditioner::LogDOA((uint64_t)this + 504, *(_QWORD **)(v2 + 56));
  v4 = *((_DWORD *)this + 126);
  if (v4 != *(_DWORD *)(v2 + 160))
    __assert_rtn("SetXYZFromPolarDOA", "SubbandXYZ.hpp", 52, "polarDOA.GetNumBands() == GetNumBands()");
  v5 = v4 + 1;
  if (v4 + 1 < v3)
    v6 = (v4 + 1);
  else
    v6 = v3;
  if ((_DWORD)v6)
  {
    v7 = 0;
    do
    {
      if (4 * (v4 + 1) == v7)
        __assert_rtn("Get", "SubbandDOA.h", 56, "bandIdx < GetNumBands()");
      v8 = (float *)(*((_QWORD *)this + 64) + v7);
      v9 = *v8 * 3.14159265 / 180.0;
      v10 = v8[v4 + 1] * 3.14159265 / 180.0;
      v11 = __sincosf_stret(v9);
      v12 = __sincosf_stret(v10);
      v13 = (float *)(*(_QWORD *)(v2 + 168) + v7);
      *v13 = v11.__cosval * v12.__cosval;
      v13[v4 + 1] = v11.__sinval * v12.__cosval;
      v13[2 * v4 + 2] = v12.__sinval;
      v7 += 4;
    }
    while (4 * v6 != v7);
  }
  if (*(_BYTE *)(v2 + 32))
  {
    v14 = *(_DWORD *)(v2 + 24);
    switch(v14)
    {
      case 1:
        v15 = (float *)(*(_QWORD *)(v2 + 168) + 4 * v5);
        goto LABEL_22;
      case 2:
        v15 = (float *)(*(_QWORD *)(v2 + 168) + 4 * (2 * v4 + 2));
LABEL_22:
        vDSP_vneg(v15, 1, v15, 1, v6);
        vDSP_vswap((float *)(*(_QWORD *)(v2 + 168) + 4 * (*(_DWORD *)(v2 + 160) + 1)), 1, (float *)(*(_QWORD *)(v2 + 168) + 4 * (2 * *(_DWORD *)(v2 + 160) + 2)), 1, v6);
        goto LABEL_27;
      case 3:
        goto LABEL_27;
      case 4:
        v18 = (float *)(*(_QWORD *)(v2 + 168) + 4 * v5);
        vDSP_vneg(v18, 1, v18, 1, v6);
        v19 = (float *)(*(_QWORD *)(v2 + 168) + 4 * (2 * *(_DWORD *)(v2 + 160) + 2));
        vDSP_vneg(v19, 1, v19, 1, v6);
        goto LABEL_27;
      default:
        if (SCLogScope(void)::once != -1)
          dispatch_once(&SCLogScope(void)::once, &__block_literal_global_11993);
        if (SCLogScope(void)::scope)
        {
          v17 = *(NSObject **)SCLogScope(void)::scope;
          if (!*(_QWORD *)SCLogScope(void)::scope)
            goto LABEL_27;
        }
        else
        {
          v17 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(float *)buf = 4.8152e-34;
          v54 = "SubbandXYZ.cpp";
          v55 = 1024;
          v56 = 123;
          v57 = 1024;
          v58 = v14;
          _os_log_impl(&dword_1B5ED0000, v17, OS_LOG_TYPE_ERROR, "%25s:%-5d Invalid orientation %u", buf, 0x18u);
        }
LABEL_27:
        v20 = *(_DWORD *)(v2 + 28);
        if (v20 == 1)
          break;
        if (v20)
        {
          if (SCLogScope(void)::once != -1)
            dispatch_once(&SCLogScope(void)::once, &__block_literal_global_11993);
          if (SCLogScope(void)::scope)
          {
            v24 = *(NSObject **)SCLogScope(void)::scope;
            if (!*(_QWORD *)SCLogScope(void)::scope)
              break;
          }
          else
          {
            v24 = MEMORY[0x1E0C81028];
          }
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(float *)buf = 4.8152e-34;
            v54 = "SubbandXYZ.cpp";
            v55 = 1024;
            v56 = 150;
            v57 = 1024;
            v58 = v20;
            _os_log_impl(&dword_1B5ED0000, v24, OS_LOG_TYPE_ERROR, "%25s:%-5d Invalid camera direction %u", buf, 0x18u);
          }
        }
        else
        {
          v21 = *(_DWORD *)(v2 + 160);
          if (v21 + 1 < v3)
            v22 = (v21 + 1);
          else
            v22 = v3;
          vDSP_vneg(*(const float **)(v2 + 168), 1, *(float **)(v2 + 168), 1, v22);
          v23 = (float *)(*(_QWORD *)(v2 + 168) + 4 * (*(_DWORD *)(v2 + 160) + 1));
          vDSP_vneg(v23, 1, v23, 1, v22);
        }
        break;
    }
  }
  if (!*(_BYTE *)(v2 + 40))
  {
    *(_DWORD *)(v2 + 128) = *(_DWORD *)(v2 + 160);
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(v2 + 136), *(char **)(v2 + 168), *(_QWORD *)(v2 + 176), (uint64_t)(*(_QWORD *)(v2 + 176) - *(_QWORD *)(v2 + 168)) >> 2);
  }
  *(_BYTE *)(v2 + 40) = 1;
  if (*(_BYTE *)(v2 + 8))
  {
    v25 = *(unsigned int *)(v2 + 36);
    v26 = *(_QWORD *)(v2 + 72);
    if (v25 >= (*(_QWORD *)(v2 + 80) - v26) >> 3)
      std::vector<std::vector<float>>::__throw_out_of_range[abi:ne180100]();
    if (*(_QWORD *)(v26 + 8 * v25))
    {
      v27 = *(float *)(v2 + 16);
      *(float *)buf = *(float *)(v2 + 12);
      v28 = 1;
      vDSP_vsmul(*(const float **)(v2 + 136), 1, (const float *)buf, *(float **)(v2 + 136), 1, (uint64_t)(*(_QWORD *)(v2 + 144) - *(_QWORD *)(v2 + 136)) >> 2);
      for (i = 0; i != 3; ++i)
      {
        v30 = SubbandXYZ::UpdateWithTimeFrequencySmoothing(SubbandXYZ const&,float,sparse_m_float *&,float)::regularizationVecXYZ[i];
        v31 = (1.0 - *(float *)buf) * (1.0 - (float)(v30 * v27));
        v32 = sparse_matrix_vector_product_dense_float(CblasNoTrans, v31, *(sparse_matrix_float *)(v26 + 8 * v25), (const float *)(*(_QWORD *)(v2 + 168) + 4 * (i + i * *(_DWORD *)(v2 + 160))), 1, (float *)(*(_QWORD *)(v2 + 136) + 4 * (i + i * *(_DWORD *)(v2 + 128))), 1) == SPARSE_SUCCESS;
        if (fabsf(v30) > 1.0e-15)
        {
          v33 = (1.0 - *(float *)buf) * v27 * v30;
          __B = v33;
          v34 = (*(_DWORD *)(v2 + 128) + 1);
          v35 = (float *)(*(_QWORD *)(v2 + 136) + 4 * (v34 * i));
          vDSP_vsadd(v35, 1, &__B, v35, 1, v34);
        }
        v28 &= v32;
      }
      if ((v28 & 1) != 0)
        goto LABEL_60;
    }
    if (SCLogScope(void)::once != -1)
      dispatch_once(&SCLogScope(void)::once, &__block_literal_global_11993);
    if (SCLogScope(void)::scope)
    {
      v36 = *(NSObject **)SCLogScope(void)::scope;
      if (!*(_QWORD *)SCLogScope(void)::scope)
        goto LABEL_60;
    }
    else
    {
      v36 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(float *)buf = 4.8151e-34;
      v54 = "DOAConditioner.cpp";
      v55 = 1024;
      v56 = 34;
      _os_log_impl(&dword_1B5ED0000, v36, OS_LOG_TYPE_ERROR, "%25s:%-5d Time-frequency smoothing update failed", buf, 0x12u);
    }
    goto LABEL_60;
  }
  *(_DWORD *)(v2 + 128) = *(_DWORD *)(v2 + 160);
  std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(v2 + 136), *(char **)(v2 + 168), *(_QWORD *)(v2 + 176), (uint64_t)(*(_QWORD *)(v2 + 176) - *(_QWORD *)(v2 + 168)) >> 2);
LABEL_60:
  v37 = *(_DWORD *)(v2 + 96);
  if (v37 != *(_DWORD *)(v2 + 128))
    __assert_rtn("SetPolarDOAFromXYZ", "SubbandXYZ.cpp", 182, "polarDOA.GetNumBands() == GetNumBands()");
  if (v37 + 1 < v3)
    v38 = (v37 + 1);
  else
    v38 = v3;
  if ((_DWORD)v38)
  {
    for (j = 0; j != v38; ++j)
    {
      v40 = (float *)(*(_QWORD *)(v2 + 136) + 4 * j);
      v41 = *(_DWORD *)(v2 + 128);
      v42 = v40[2 * v41 + 2];
      v43 = 1.0;
      if (v42 <= 1.0)
      {
        v43 = v40[2 * v41 + 2];
        if (v42 < -1.0)
          v43 = -1.0;
      }
      if (fabsf(v43) > 1.0)
        __assert_rtn("SetPolarDOAFromXYZ", "SubbandXYZ.cpp", 196, "fabsf(z) <= 1.0");
      v44 = *v40;
      v45 = v40[v41 + 1];
      v46 = asinf(v43);
      if ((LODWORD(v46) & 0x7FFFFFFFu) >= 0x7F800000)
        __assert_rtn("SetPolarDOAFromXYZ", "SubbandXYZ.cpp", 198, "isfinite(el)");
      if (fabsf(v45) < 1.0e-15 && fabsf(v44) < 1.0e-15)
        v45 = 1.0e-15;
      v47 = atan2f(-v45, v44);
      if ((LODWORD(v47) & 0x7FFFFFFFu) >= 0x7F800000)
        __assert_rtn("SetPolarDOAFromXYZ", "SubbandXYZ.cpp", 204, "isfinite(az)");
      v48 = (float)(v47 * -180.0) / 3.14159265;
      v49 = (float)(v46 * 180.0) / 3.14159265;
      SubbandDOA::Set((SubbandDOA *)(v2 + 96), j, v48, v49);
    }
  }
  if (*(_BYTE *)(v2 + 41) && *(_DWORD *)(v2 + 96) != -1)
  {
    v50 = 0;
    do
      SubbandDOA::Set((SubbandDOA *)(v2 + 96), v50++, *(float *)(v2 + 44), *(float *)(v2 + 48));
    while (v50 < *(_DWORD *)(v2 + 96) + 1);
  }
  DOAConditioner::LogDOA(v2 + 96, *(_QWORD **)(v2 + 64));
  v16 = (const void **)(*((_QWORD *)this + 67) + 96);
LABEL_81:
  memcpy(*((void **)this + 68), v16[1], 4 * *((unsigned int *)this + 2));
  memcpy(*((void **)this + 71), (char *)v16[1] + 4 * *((unsigned int *)this + 2), 4 * *((unsigned int *)this + 2));
  (*(void (**)(_QWORD, char *, char *, char *))(**((_QWORD **)this + 58) + 48))(*((_QWORD *)this + 58), (char *)this + 544, (char *)this + 568, (char *)this + 96);
  (*(void (**)(_QWORD, char *, char *, char *))(**((_QWORD **)this + 59) + 48))(*((_QWORD *)this + 59), (char *)this + 544, (char *)this + 568, (char *)this + 120);
  (*(void (**)(_QWORD, char *, char *, char *))(**((_QWORD **)this + 60) + 48))(*((_QWORD *)this + 60), (char *)this + 544, (char *)this + 568, (char *)this + 144);
  return SpatialProbabilityBase::UpdatePosteriorProbabilities(this);
}

void DOABasedProbability::~DOABasedProbability(DOABasedProbability *this)
{
  DOABasedProbability::~DOABasedProbability(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)this = &off_1E69CA778;
  v2 = (void *)*((_QWORD *)this + 71);
  if (v2)
  {
    *((_QWORD *)this + 72) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 68);
  if (v3)
  {
    *((_QWORD *)this + 69) = v3;
    operator delete(v3);
  }
  v4 = *((_QWORD *)this + 67);
  *((_QWORD *)this + 67) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = (void *)*((_QWORD *)this + 64);
  if (v5)
  {
    *((_QWORD *)this + 65) = v5;
    operator delete(v5);
  }
  v6 = *((_QWORD *)this + 60);
  *((_QWORD *)this + 60) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  v7 = *((_QWORD *)this + 59);
  *((_QWORD *)this + 59) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  v8 = *((_QWORD *)this + 58);
  *((_QWORD *)this + 58) = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  SpatialProbabilityBase::~SpatialProbabilityBase(this);
}

uint64_t DOABasedProbability::ProcessBufferList(DOABasedProbability *this, const AudioBufferList *a2)
{
  return (*(uint64_t (**)(DOABasedProbability *))(*(_QWORD *)this + 16))(this);
}

uint64_t DOABasedProbability::SetTargetAzimuth(uint64_t this, float a2)
{
  *(float *)(this + 440) = a2;
  *(_BYTE *)(this + 452) = 1;
  return this;
}

void DOABasedProbability::SetTargetElevation(DOABasedProbability *this, float a2)
{
  NSObject *v5;
  double v6;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  double v12;
  __int16 v13;
  double v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2 >= -90.0 && a2 <= 90.0)
  {
    *((float *)this + 111) = a2;
    *((_BYTE *)this + 452) = 1;
    return;
  }
  if (AUSpatialProbabilityLogScope(void)::once != -1)
    dispatch_once(&AUSpatialProbabilityLogScope(void)::once, &__block_literal_global_5486);
  if (AUSpatialProbabilityLogScope(void)::scope)
  {
    v5 = *(NSObject **)AUSpatialProbabilityLogScope(void)::scope;
    if (!*(_QWORD *)AUSpatialProbabilityLogScope(void)::scope)
      return;
  }
  else
  {
    v5 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *((float *)this + 111);
    v7 = 136315906;
    v8 = "DOABasedProbability.hpp";
    v9 = 1024;
    v10 = 144;
    v11 = 2048;
    v12 = a2;
    v13 = 2048;
    v14 = v6;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Target elevation not set to (%f), it remains at the current value (%f). Elevation must be in range [-90, 90].\n", (uint8_t *)&v7, 0x26u);
  }
}

void DOABasedProbability::SetTargetDistance(DOABasedProbability *this, float a2)
{
  NSObject *v4;
  double v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  double v11;
  __int16 v12;
  double v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2 >= 0.0)
  {
    *((float *)this + 112) = a2;
    *((_BYTE *)this + 452) = 1;
    return;
  }
  if (AUSpatialProbabilityLogScope(void)::once != -1)
    dispatch_once(&AUSpatialProbabilityLogScope(void)::once, &__block_literal_global_5486);
  if (AUSpatialProbabilityLogScope(void)::scope)
  {
    v4 = *(NSObject **)AUSpatialProbabilityLogScope(void)::scope;
    if (!*(_QWORD *)AUSpatialProbabilityLogScope(void)::scope)
      return;
  }
  else
  {
    v4 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *((float *)this + 112);
    v6 = 136315906;
    v7 = "DOABasedProbability.hpp";
    v8 = 1024;
    v9 = 157;
    v10 = 2048;
    v11 = a2;
    v12 = 2048;
    v13 = v5;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Target distance not set to (%f), it remains at the current value (%f). Distance must be nonnegative.\n", (uint8_t *)&v6, 0x26u);
  }
}

void DOABasedProbability::SetSubbandDOA(DOABasedProbability *this, const float *a2, size_t __n)
{
  int v3;
  uint64_t v5;
  void *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v3 = __n;
  v17 = *MEMORY[0x1E0C80C00];
  v5 = *((_QWORD *)this + 65);
  v6 = (void *)*((_QWORD *)this + 64);
  if (v5 - (_QWORD)v6 == __n)
  {
    memcpy(v6, a2, __n);
    return;
  }
  if (AUSpatialProbabilityLogScope(void)::once != -1)
    dispatch_once(&AUSpatialProbabilityLogScope(void)::once, &__block_literal_global_5486);
  if (AUSpatialProbabilityLogScope(void)::scope)
  {
    v7 = *(NSObject **)AUSpatialProbabilityLogScope(void)::scope;
    if (!*(_QWORD *)AUSpatialProbabilityLogScope(void)::scope)
      return;
  }
  else
  {
    v7 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *((_QWORD *)this + 65) - *((_QWORD *)this + 64);
    v9 = 136315906;
    v10 = "DOABasedProbability.hpp";
    v11 = 1024;
    v12 = 115;
    v13 = 1024;
    v14 = v3;
    v15 = 2048;
    v16 = v8;
    _os_log_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_DEFAULT, "%25s:%-5d SubbandDOA not set. Input size (%u) and internal size (%lu) do not match.\n", (uint8_t *)&v9, 0x22u);
  }
}

uint64_t DOABasedProbability::SetSubbandDOATimeSmoothing(uint64_t this, float a2)
{
  uint64_t v2;

  if (*(_BYTE *)(this + 488))
  {
    v2 = *(_QWORD *)(this + 536);
    if (v2)
    {
      *(float *)(this + 492) = a2;
      *(float *)(v2 + 12) = a2;
    }
  }
  return this;
}

void SpatialProbabilityBase::~SpatialProbabilityBase(SpatialProbabilityBase *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  *(_QWORD *)this = &unk_1E69ECDB0;
  v2 = (void *)*((_QWORD *)this + 52);
  if (v2)
  {
    *((_QWORD *)this + 53) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 46);
  if (v3)
  {
    *((_QWORD *)this + 47) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 41);
  if (v4)
  {
    *((_QWORD *)this + 42) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 38);
  if (v5)
  {
    *((_QWORD *)this + 39) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 35);
  if (v6)
  {
    *((_QWORD *)this + 36) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 30);
  if (v7)
  {
    *((_QWORD *)this + 31) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 27);
  if (v8)
  {
    *((_QWORD *)this + 28) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 24);
  if (v9)
  {
    *((_QWORD *)this + 25) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 21);
  if (v10)
  {
    *((_QWORD *)this + 22) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 18);
  if (v11)
  {
    *((_QWORD *)this + 19) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 15);
  if (v12)
  {
    *((_QWORD *)this + 16) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 12);
  if (v13)
  {
    *((_QWORD *)this + 13) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 8);
  if (v14)
  {
    *((_QWORD *)this + 9) = v14;
    operator delete(v14);
  }
}

uint64_t CircularModelDOAFactory::CreateModel(uint64_t *a1, int a2, unsigned int a3, float a4, float a5, float a6)
{
  uint64_t v11;
  uint64_t result;
  std::logic_error *exception;
  float __A;
  float v15;
  float v16;

  switch(a2)
  {
    case 0:
      v11 = operator new();
      CircularModelDOA::CircularModelDOA((CircularModelDOA *)v11, a3, a4, a5, a6);
      *(_QWORD *)v11 = &off_1E69D8878;
      __A = 0.0001;
      vDSP_vfill(&__A, *(float **)(v11 + 24), 1, *(unsigned int *)(v11 + 8));
      result = (**(uint64_t (***)(uint64_t, float))v11)(v11, __A);
      break;
    case 1:
      v11 = operator new();
      CircularModelDOA::CircularModelDOA((CircularModelDOA *)v11, a3, a4, a5, a6);
      *(_QWORD *)v11 = &off_1E69D8908;
      *(_QWORD *)(v11 + 216) = 0x3FC000003F000000;
      v15 = 0.0001;
      vDSP_vfill(&v15, *(float **)(v11 + 24), 1, *(unsigned int *)(v11 + 8));
      result = (**(uint64_t (***)(uint64_t, float))v11)(v11, v15);
      break;
    case 2:
      v11 = operator new();
      CircularModelDOA::CircularModelDOA((CircularModelDOA *)v11, a3, a4, a5, a6);
      *(_QWORD *)v11 = &off_1E69D8950;
      std::vector<float>::vector((_QWORD *)(v11 + 216), *(unsigned int *)(v11 + 8), (_DWORD *)(v11 + 80));
      result = (*(uint64_t (**)(uint64_t, float))(*(_QWORD *)v11 + 32))(v11, 0.0001);
      break;
    case 3:
      v11 = operator new();
      CircularModelDOA::CircularModelDOA((CircularModelDOA *)v11, a3, a4, a5, a6);
      *(_QWORD *)v11 = &off_1E69D8998;
      *(_QWORD *)(v11 + 216) = 0x3FC000003F000000;
      std::vector<float>::vector((_QWORD *)(v11 + 224), *(unsigned int *)(v11 + 8), (_DWORD *)(v11 + 80));
      result = (*(uint64_t (**)(uint64_t, float))(*(_QWORD *)v11 + 32))(v11, 0.0001);
      break;
    case 4:
      v11 = operator new();
      CircularModelDOA::CircularModelDOA((CircularModelDOA *)v11, a3, a4, a5, a6);
      *(_QWORD *)v11 = &off_1E69D89E0;
      v16 = 0.0;
      vDSP_vfill(&v16, *(float **)(v11 + 24), 1, *(unsigned int *)(v11 + 8));
      result = (**(uint64_t (***)(uint64_t, float))v11)(v11, v16);
      break;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "Unknown selected model!");
  }
  *a1 = v11;
  return result;
}

void sub_1B61BA70C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void CircularModelDOA::CircularModelDOA(CircularModelDOA *this, unsigned int a2, float a3, float a4, float a5)
{
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;

  *((_DWORD *)this + 2) = a2;
  *(_QWORD *)this = &unk_1E69D88C0;
  v15 = 0;
  std::vector<float>::vector((_QWORD *)this + 3, a2, &v15);
  v9 = *((unsigned int *)this + 2);
  v15 = 1065353216;
  std::vector<float>::vector((_QWORD *)this + 6, v9, &v15);
  v10 = *((unsigned int *)this + 2);
  *((_DWORD *)this + 18) = v10;
  *(_OWORD *)((char *)this + 76) = xmmword_1B66A0AE0;
  *((_DWORD *)this + 23) = 1016003125;
  v15 = 1065353216;
  std::vector<float>::vector((_QWORD *)this + 12, v10, &v15);
  v11 = *((unsigned int *)this + 2);
  v15 = 0;
  std::vector<float>::vector((_QWORD *)this + 15, v11, &v15);
  v12 = *((unsigned int *)this + 2);
  v15 = 1065353216;
  std::vector<float>::vector((_QWORD *)this + 18, v12, &v15);
  v13 = *((unsigned int *)this + 2);
  v15 = 0;
  std::vector<float>::vector((_QWORD *)this + 21, v13, &v15);
  v14 = *((unsigned int *)this + 2);
  v15 = 0;
  std::vector<float>::vector((_QWORD *)this + 24, v14, &v15);
  CircularModelDOA::SetTargetDOA(this, a3, a4, a5);
}

void sub_1B61BA93C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void **v7;
  void **v8;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  v8 = v5;
  v10 = *v8;
  if (*v8)
  {
    v1[22] = v10;
    operator delete(v10);
  }
  v11 = *v7;
  if (*v7)
  {
    v1[19] = v11;
    operator delete(v11);
  }
  v12 = *v6;
  if (*v6)
  {
    v1[16] = v12;
    operator delete(v12);
  }
  v13 = *v4;
  if (*v4)
  {
    v1[13] = v13;
    operator delete(v13);
  }
  v14 = *v3;
  if (*v3)
  {
    v1[7] = v14;
    operator delete(v14);
  }
  v15 = *v2;
  if (*v2)
  {
    v1[4] = v15;
    operator delete(v15);
  }
  _Unwind_Resume(exception_object);
}

char *SubbandDOA::Reset(char **this, int a2)
{
  int v3;

  if (!a2)
    __assert_rtn("Reset", "SubbandDOA.h", 41, "blockSize > 0");
  *(_DWORD *)this = a2;
  v3 = 0;
  return std::vector<float>::assign(this + 1, (2 * a2 + 2), &v3);
}

char *SubbandXYZ::Reset(char **this, int a2)
{
  int v3;

  if (!a2)
    __assert_rtn("Reset", "SubbandXYZ.hpp", 28, "blockSize > 0");
  *(_DWORD *)this = a2;
  v3 = 0;
  return std::vector<float>::assign(this + 1, (3 * a2 + 3), &v3);
}

void sub_1B61BAB54(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1BCC95BE4](v1 + 416);
  _Unwind_Resume(a1);
}

void DOAConditioner::~DOAConditioner(DOAConditioner *this)
{
  DOAConditioner::~DOAConditioner(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void **v2;
  void **v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)this = &off_1E69CA800;
  v2 = (void **)*((_QWORD *)this + 9);
  v3 = (void **)*((_QWORD *)this + 10);
  while (v2 != v3)
  {
    if (*v2)
      sparse_matrix_destroy(*v2);
    ++v2;
  }
  v4 = (void *)*((_QWORD *)this + 21);
  if (v4)
  {
    *((_QWORD *)this + 22) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 17);
  if (v5)
  {
    *((_QWORD *)this + 18) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 13);
  if (v6)
  {
    *((_QWORD *)this + 14) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 9);
  if (v7)
  {
    *((_QWORD *)this + 10) = v7;
    operator delete(v7);
  }
  v8 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  v9 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
}

void AUSPLMeter::~AUSPLMeter(AUSPLMeter *this)
{
  AUSPLMeter::~AUSPLMeter(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  void (**v2)(AUSPLMeter *__hidden);
  OpaqueAudioComponentInstance *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;

  v2 = &off_1E69CA820;
  *(_QWORD *)this = &off_1E69CA820;
  v3 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 87);
  if (v3)
  {
    AudioComponentInstanceDispose(v3);
    *((_QWORD *)this + 87) = 0;
    v2 = *(void (***)(AUSPLMeter *__hidden))this;
  }
  v2[8](this);
  v4 = *((_QWORD *)this + 88);
  *((_QWORD *)this + 88) = 0;
  if (v4)
    std::default_delete<CA::AudioBuffers>::operator()[abi:ne180100]();
  v5 = (void *)*((_QWORD *)this + 84);
  if (v5)
  {
    *((_QWORD *)this + 85) = v5;
    operator delete(v5);
  }
  v6 = *((_QWORD *)this + 83);
  *((_QWORD *)this + 83) = 0;
  if (v6)
    std::default_delete<LoudnessMeter>::operator()[abi:ne180100](v6);
  v7 = *((_QWORD *)this + 82);
  *((_QWORD *)this + 82) = 0;
  if (v7)
    std::default_delete<LoudnessMeter>::operator()[abi:ne180100](v7);
  v8 = *((_QWORD *)this + 81);
  *((_QWORD *)this + 81) = 0;
  if (v8)
    std::default_delete<LoudnessMeter>::operator()[abi:ne180100](v8);
  v9 = (void *)*((_QWORD *)this + 78);
  if (v9)
  {
    *((_QWORD *)this + 79) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 75);
  if (v10)
  {
    *((_QWORD *)this + 76) = v10;
    operator delete(v10);
  }
  ausdk::AUBase::~AUBase(this);
}

uint64_t AUSPLMeter::Initialize(AUSPLMeter *this)
{
  uint64_t Element;
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  float mSampleRate;
  CA::AudioBuffers *v17;
  uint64_t v18;
  AudioStreamBasicDescription v19;
  AudioStreamBasicDescription v20;

  Element = ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 80), 0);
  v3 = *(_OWORD *)(Element + 96);
  *(_OWORD *)&v20.mSampleRate = *(_OWORD *)(Element + 80);
  *(_OWORD *)&v20.mBytesPerPacket = v3;
  *(_QWORD *)&v20.mBitsPerChannel = *(_QWORD *)(Element + 112);
  v4 = ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 128), 0);
  v5 = *(_OWORD *)(v4 + 96);
  *(_OWORD *)&v19.mSampleRate = *(_OWORD *)(v4 + 80);
  *(_OWORD *)&v19.mBytesPerPacket = v5;
  *(_QWORD *)&v19.mBitsPerChannel = *(_QWORD *)(v4 + 112);
  if (v20.mSampleRate != v19.mSampleRate
    || v20.mFormatID != v19.mFormatID
    || *(_QWORD *)&v20.mBytesPerPacket != *(_QWORD *)&v19.mBytesPerPacket
    || *(_QWORD *)&v20.mChannelsPerFrame != *(_QWORD *)&v19.mChannelsPerFrame
    || !CA::Implementation::EquivalentFormatFlags((CA::Implementation *)&v20, &v19, 0, 0)
    || v20.mChannelsPerFrame > 2)
  {
    return 4294956428;
  }
  std::vector<void const*>::resize((uint64_t)this + 672, v20.mChannelsPerFrame);
  v7 = *((_DWORD *)this + 84);
  v8 = operator new();
  LoudnessMeter::LoudnessMeter(v8, 0, v20.mChannelsPerFrame, v20.mSampleRate, v7);
  v9 = *((_QWORD *)this + 81);
  *((_QWORD *)this + 81) = v8;
  if (v9)
    std::default_delete<LoudnessMeter>::operator()[abi:ne180100](v9);
  v10 = *((_DWORD *)this + 84);
  v11 = operator new();
  LoudnessMeter::LoudnessMeter(v11, 1, v20.mChannelsPerFrame, v20.mSampleRate, v10);
  v12 = *((_QWORD *)this + 82);
  *((_QWORD *)this + 82) = v11;
  if (v12)
    std::default_delete<LoudnessMeter>::operator()[abi:ne180100](v12);
  v13 = *((_DWORD *)this + 84);
  v14 = operator new();
  LoudnessMeter::LoudnessMeter(v14, 3, v20.mChannelsPerFrame, v20.mSampleRate, v13);
  v15 = *((_QWORD *)this + 83);
  *((_QWORD *)this + 83) = v14;
  if (v15)
    std::default_delete<LoudnessMeter>::operator()[abi:ne180100](v15);
  mSampleRate = v20.mSampleRate;
  *((float *)this + 145) = mSampleRate;
  v17 = (CA::AudioBuffers *)operator new();
  CA::AudioBuffers::AudioBuffers(v17, &v20);
  v18 = *((_QWORD *)this + 88);
  *((_QWORD *)this + 88) = v17;
  if (v18)
    std::default_delete<CA::AudioBuffers>::operator()[abi:ne180100]();
  result = (uint64_t)AUSPLMeter::InitializeVarEQ((AudioUnit *)this);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(AUSPLMeter *, _QWORD, _QWORD))(*(_QWORD *)this + 72))(this, 0, 0);
  return result;
}

void sub_1B61BAEE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC95CEC](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

uint64_t AUSPLMeter::Reset(AUSPLMeter *this)
{
  OpaqueAudioComponentInstance *v1;
  OSStatus v2;
  OSStatus v3;
  NSObject *v4;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  OSStatus v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v1 = (OpaqueAudioComponentInstance *)*((_QWORD *)this + 87);
  if (v1)
  {
    v2 = AudioUnitReset(v1, 0, 0);
    if (v2)
    {
      v3 = v2;
      if (AUSPLMeterLogScope(void)::once != -1)
        dispatch_once(&AUSPLMeterLogScope(void)::once, &__block_literal_global_2837);
      if (AUSPLMeterLogScope(void)::scope)
      {
        v4 = *(NSObject **)AUSPLMeterLogScope(void)::scope;
        if (!*(_QWORD *)AUSPLMeterLogScope(void)::scope)
          return 0;
      }
      else
      {
        v4 = MEMORY[0x1E0C81028];
      }
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v6 = 136315650;
        v7 = "AUSPLMeter.cpp";
        v8 = 1024;
        v9 = 246;
        v10 = 1024;
        v11 = v3;
        _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Embedded VarEQ fails with error %u", (uint8_t *)&v6, 0x18u);
      }
    }
  }
  return 0;
}

uint64_t AUSPLMeter::GetPropertyInfo(AUSPLMeter *this, int a2, int a3, unsigned int a4, unsigned int *a5, BOOL *a6)
{
  uint64_t result;
  unsigned int v7;

  if (a3)
    return 4294956417;
  v7 = 4;
  result = 4294956417;
  if (a2 <= 64001)
  {
    if (a2 != 21)
    {
      if (a2 != 64001)
        return result;
      goto LABEL_10;
    }
    goto LABEL_11;
  }
  if (a2 == 64002)
  {
LABEL_10:
    v7 = 8;
    goto LABEL_11;
  }
  if (a2 == 64003)
  {
LABEL_11:
    result = 0;
    *a6 = 1;
    *a5 = v7;
  }
  return result;
}

uint64_t AUSPLMeter::GetProperty(AUSPLMeter *this, int a2, int a3, AudioUnitElement a4, CFDictionaryRef *outData)
{
  uint64_t result;
  char *v8;
  char *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  BOOL v13;
  CFDictionaryRef CFDictionaryRef;
  int v15;
  uint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  void *__p[2];
  uint64_t v20;
  void **v21;

  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 64001)
  {
    if (a2 != 21)
    {
      if (a2 == 64001)
      {
        v17 = 0;
        v18 = 0;
        v16 = (uint64_t *)&v17;
        std::string::basic_string[abi:ne180100]<0>(__p, "InputMap");
        v21 = __p;
        v8 = (char *)(std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(&v16, __p, (_OWORD **)&v21)+ 7);
        if (v8 != (char *)this + 600)
          std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v8, *((char **)this + 75), *((_QWORD *)this + 76), (uint64_t)(*((_QWORD *)this + 76) - *((_QWORD *)this + 75)) >> 2);
        if (SHIBYTE(v20) < 0)
          operator delete(__p[0]);
        std::string::basic_string[abi:ne180100]<0>(__p, "OutputMap");
        v21 = __p;
        v9 = (char *)(std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(&v16, __p, (_OWORD **)&v21)+ 7);
        if (v9 != (char *)this + 624)
          std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v9, *((char **)this + 78), *((_QWORD *)this + 79), (uint64_t)(*((_QWORD *)this + 79) - *((_QWORD *)this + 78)) >> 2);
        if (SHIBYTE(v20) < 0)
          operator delete(__p[0]);
        __p[0] = 0;
        __p[1] = 0;
        v20 = 0;
        std::vector<applesauce::CF::TypeRefPair>::reserve(__p, v18);
        v10 = v16;
        if (v16 != (uint64_t *)&v17)
        {
          do
          {
            std::vector<applesauce::CF::TypeRefPair>::emplace_back<std::string const&,std::vector<float> const&>(__p, (const UInt8 *)v10 + 32, v10 + 7);
            v11 = (uint64_t *)v10[1];
            if (v11)
            {
              do
              {
                v12 = v11;
                v11 = (uint64_t *)*v11;
              }
              while (v11);
            }
            else
            {
              do
              {
                v12 = (uint64_t *)v10[2];
                v13 = *v12 == (_QWORD)v10;
                v10 = v12;
              }
              while (!v13);
            }
            v10 = v12;
          }
          while (v12 != (uint64_t *)&v17);
        }
        CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((void ***)__p);
        v21 = __p;
        std::vector<applesauce::CF::TypeRefPair>::__destroy_vector::operator()[abi:ne180100](&v21);
        CFRetain(CFDictionaryRef);
        *outData = CFDictionaryRef;
        if (CFDictionaryRef)
          CFRelease(CFDictionaryRef);
        std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(v17);
        return 0;
      }
      return result;
    }
    result = 0;
    v15 = *((unsigned __int8 *)this + 528);
LABEL_29:
    *(_DWORD *)outData = v15;
    return result;
  }
  if (a2 == 64002)
  {
    LODWORD(__p[0]) = 0;
    return AudioUnitGetProperty(*((AudioUnit *)this + 87), 0, 0, a4, outData, (UInt32 *)__p);
  }
  if (a2 == 64003)
  {
    result = 0;
    v15 = *((_DWORD *)this + 148);
    goto LABEL_29;
  }
  return result;
}

void sub_1B61BB2D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _QWORD *a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&a9);
  std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(a11);
  _Unwind_Resume(a1);
}

uint64_t AUSPLMeter::SetProperty(AUSPLMeter *this, int a2, int a3, AudioUnitElement a4, CFTypeRef *a5, UInt32 a6)
{
  uint64_t result;
  CFTypeRef v8;
  const __CFArray *v9;
  int v10;
  const __CFArray *v11;
  void *v12;
  void *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  void *v18;
  unint64_t v19;
  void *v20;
  float *v21;
  float *v22;
  float *v23;
  float v24;
  float *v25;
  float v26;
  float v27;
  NSObject *v28;
  void **v29;
  NSObject *v30;
  void **v31;
  float v32;
  ausdk::AUElement *Element;
  float *v34;
  float *v35;
  float *v36;
  float v37;
  float *v38;
  float v39;
  float v40;
  float v41;
  float v42;
  ausdk::AUElement *v43;
  _DWORD *exception;
  std::runtime_error *v45;
  NSObject *v46;
  const char *v47;
  _DWORD *v48;
  NSObject *v49;
  const char *v50;
  uint32_t v51;
  _DWORD *v52;
  void **v53;
  _DWORD *v54;
  void **v55;
  _DWORD *v56;
  CFTypeRef cf;
  void *v58;
  _BYTE *v59;
  uint64_t v60;
  void *__src;
  _BYTE *v62;
  uint64_t v63;
  void *v64;
  uint64_t v65;
  char v66;
  void *__p[2];
  char v68;
  void *v69[2];
  char v70;
  _BYTE v71[18];
  char v72;
  uint8_t buf[4];
  const char *v74;
  __int16 v75;
  int v76;
  __int16 v77;
  void **v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  if (a3)
    return 4294956417;
  result = 4294956417;
  if (a2 <= 64001)
  {
    if (a2 == 21)
    {
      if (a6 < 4)
        return 4294956445;
      result = 0;
      *((_BYTE *)this + 528) = *(_DWORD *)a5 != 0;
      return result;
    }
    if (a2 != 64001)
      return result;
    v8 = *a5;
    if (*a5)
      CFRetain(*a5);
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, v8);
    if (!cf)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v71 = 136315394;
        *(_QWORD *)&v71[4] = "AUSPLMeter.cpp";
        *(_WORD *)&v71[12] = 1024;
        *(_DWORD *)&v71[14] = 428;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  Invalid value for kAUSPLMeterProperty_VolumeMap", v71, 0x12u);
      }
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &off_1E69EE218;
      exception[2] = 2003329396;
    }
    v9 = (const __CFArray *)applesauce::CF::details::at_key<char const(&)[9]>((const __CFDictionary *)cf, "InputMap");
    if (v9)
    {
      applesauce::CF::convert_as<std::vector<float>,0>((uint64_t)v71, v9);
    }
    else
    {
      v71[0] = 0;
      v72 = 0;
    }
    if (!cf)
    {
      v45 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v45, "Could not construct");
    }
    v11 = (const __CFArray *)applesauce::CF::details::at_key<char const(&)[10]>((const __CFDictionary *)cf, "OutputMap");
    if (v11)
    {
      applesauce::CF::convert_as<std::vector<float>,0>((uint64_t)&v64, v11);
    }
    else
    {
      LOBYTE(v64) = 0;
      v66 = 0;
    }
    if (v72)
    {
      if (v66)
      {
        __src = 0;
        v62 = 0;
        v63 = 0;
        v12 = *(void **)v71;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__src, *(const void **)v71, *(uint64_t *)&v71[8], (uint64_t)(*(_QWORD *)&v71[8] - *(_QWORD *)v71) >> 2);
        v58 = 0;
        v59 = 0;
        v60 = 0;
        v13 = v64;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v58, v64, v65, (v65 - (uint64_t)v64) >> 2);
        v14 = v62 - (_BYTE *)__src;
        v15 = (unint64_t)(v62 - (_BYTE *)__src) >> 2;
        v16 = v59 - (_BYTE *)v58;
        if ((_DWORD)v15 == ((unint64_t)(v59 - (_BYTE *)v58) >> 2))
        {
          if (v15 > 1)
          {
            if (!AUSPLMeter::ValidateMap((float **)&__src))
            {
              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
              {
                AUSPLMeter::ConvertToString(v69, &__src);
                v53 = v70 >= 0 ? v69 : (void **)v69[0];
                *(_DWORD *)buf = 136315650;
                v74 = "AUSPLMeter.cpp";
                v75 = 1024;
                v76 = 598;
                v77 = 2080;
                v78 = v53;
                _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  Input volume curve is not monotonic. %s", buf, 0x1Cu);
                if (v70 < 0)
                  operator delete(v69[0]);
              }
              v54 = __cxa_allocate_exception(0x10uLL);
              *(_QWORD *)v54 = &off_1E69EE218;
              v54[2] = 2003329396;
            }
            if (!AUSPLMeter::ValidateMap((float **)&v58))
            {
              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
              {
                AUSPLMeter::ConvertToString(v69, &v58);
                v55 = v70 >= 0 ? v69 : (void **)v69[0];
                *(_DWORD *)buf = 136315650;
                v74 = "AUSPLMeter.cpp";
                v75 = 1024;
                v76 = 601;
                v77 = 2080;
                v78 = v55;
                _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  Output volume curve is not monotonic. %s", buf, 0x1Cu);
                if (v70 < 0)
                  operator delete(v69[0]);
              }
              v56 = __cxa_allocate_exception(0x10uLL);
              *(_QWORD *)v56 = &off_1E69EE218;
              v56[2] = 2003329396;
            }
            v17 = (v14 >> 2);
            v18 = (void *)*((_QWORD *)this + 75);
            if (v17 != (uint64_t)(*((_QWORD *)this + 76) - (_QWORD)v18) >> 2)
            {
              std::vector<float>::resize((uint64_t)this + 600, v17);
              v18 = (void *)*((_QWORD *)this + 75);
            }
            memcpy(v18, __src, 4 * v17);
            v19 = (v16 >> 2);
            v20 = (void *)*((_QWORD *)this + 78);
            if (v19 != (uint64_t)(*((_QWORD *)this + 79) - (_QWORD)v20) >> 2)
            {
              std::vector<float>::resize((uint64_t)this + 624, v19);
              v20 = (void *)*((_QWORD *)this + 78);
            }
            memcpy(v20, v58, 4 * v19);
            v21 = (float *)*((_QWORD *)this + 75);
            v22 = (float *)*((_QWORD *)this + 76);
            if (v21 != v22)
            {
              v23 = v21 + 1;
              if (v21 + 1 != v22)
              {
                v24 = *v21;
                v25 = v21 + 1;
                do
                {
                  v26 = *v25++;
                  v27 = v26;
                  if (v26 < v24)
                  {
                    v24 = v27;
                    v21 = v23;
                  }
                  v23 = v25;
                }
                while (v25 != v22);
              }
            }
            *((float *)this + 144) = *v21;
            AUSPLMeter::ConvertToString(v69, (_QWORD *)this + 75);
            if (AUSPLMeterLogScope(void)::once != -1)
              dispatch_once(&AUSPLMeterLogScope(void)::once, &__block_literal_global_2837);
            if (AUSPLMeterLogScope(void)::scope)
            {
              v28 = *(NSObject **)AUSPLMeterLogScope(void)::scope;
              if (!*(_QWORD *)AUSPLMeterLogScope(void)::scope)
                goto LABEL_52;
            }
            else
            {
              v28 = MEMORY[0x1E0C81028];
            }
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
            {
              v29 = v69;
              if (v70 < 0)
                v29 = (void **)v69[0];
              *(_DWORD *)buf = 136315650;
              v74 = "AUSPLMeter.cpp";
              v75 = 1024;
              v76 = 661;
              v77 = 2080;
              v78 = v29;
              _os_log_impl(&dword_1B5ED0000, v28, OS_LOG_TYPE_DEBUG, "%25s:%-5d Volume Input Map: %s", buf, 0x1Cu);
            }
LABEL_52:
            AUSPLMeter::ConvertToString(__p, (_QWORD *)this + 78);
            if (AUSPLMeterLogScope(void)::once != -1)
              dispatch_once(&AUSPLMeterLogScope(void)::once, &__block_literal_global_2837);
            if (AUSPLMeterLogScope(void)::scope)
            {
              v30 = *(NSObject **)AUSPLMeterLogScope(void)::scope;
              if (!*(_QWORD *)AUSPLMeterLogScope(void)::scope)
              {
LABEL_62:
                if (v68 < 0)
                  operator delete(__p[0]);
                if (v70 < 0)
                  operator delete(v69[0]);
                if (v58)
                {
                  v59 = v58;
                  operator delete(v58);
                }
                if (__src)
                {
                  v62 = __src;
                  operator delete(__src);
                }
                if (v13)
                  operator delete(v13);
                if (v12)
                  operator delete(v12);
                v32 = AUSPLMeter::MapVolume(*((float **)this + 75), *((_QWORD *)this + 76), *((_QWORD *)this + 78), *((_QWORD *)this + 79), *((float *)this + 133));
                *((float *)this + 134) = v32;
                Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 32), 0);
                ausdk::AUElement::SetParameter(Element, 0xAu, v32, 0);
                v34 = (float *)*((_QWORD *)this + 78);
                v35 = (float *)*((_QWORD *)this + 79);
                if (v34 != v35)
                {
                  v36 = v34 + 1;
                  if (v34 + 1 != v35)
                  {
                    v37 = *v34;
                    v38 = v34 + 1;
                    do
                    {
                      v39 = *v38++;
                      v40 = v39;
                      if (v37 < v39)
                      {
                        v37 = v40;
                        v34 = v36;
                      }
                      v36 = v38;
                    }
                    while (v38 != v35);
                  }
                }
                v41 = *v34;
                *((float *)this + 146) = *v34;
                v42 = (float)((float)(*((float *)this + 134) + *((float *)this + 135)) - v41) + 13.0;
                *((float *)this + 136) = v42;
                v43 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 32), 0);
                ausdk::AUElement::SetParameter(v43, 0xBu, v42, 0);
                if (cf)
                  CFRelease(cf);
                return 0;
              }
            }
            else
            {
              v30 = MEMORY[0x1E0C81028];
            }
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
            {
              v31 = __p;
              if (v68 < 0)
                v31 = (void **)__p[0];
              *(_DWORD *)buf = 136315650;
              v74 = "AUSPLMeter.cpp";
              v75 = 1024;
              v76 = 664;
              v77 = 2080;
              v78 = v31;
              _os_log_impl(&dword_1B5ED0000, v30, OS_LOG_TYPE_DEBUG, "%25s:%-5d Volume Output Map: %s", buf, 0x1Cu);
            }
            goto LABEL_62;
          }
          if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
LABEL_99:
            v52 = __cxa_allocate_exception(0x10uLL);
            *(_QWORD *)v52 = &off_1E69EE218;
            v52[2] = 2003329396;
          }
          *(_DWORD *)buf = 136315650;
          v74 = "AUSPLMeter.cpp";
          v75 = 1024;
          v76 = 594;
          v77 = 1024;
          LODWORD(v78) = v15;
          v49 = MEMORY[0x1E0C81028];
          v50 = "%25s:%-5d  Not enough volume map points. Mapping requires 2 or more points. Only found %d.";
          v51 = 24;
        }
        else
        {
          if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            goto LABEL_99;
          *(_DWORD *)buf = 136315394;
          v74 = "AUSPLMeter.cpp";
          v75 = 1024;
          v76 = 593;
          v49 = MEMORY[0x1E0C81028];
          v50 = "%25s:%-5d  Volume curve steps must match";
          v51 = 18;
        }
        _os_log_impl(&dword_1B5ED0000, v49, OS_LOG_TYPE_ERROR, v50, buf, v51);
        goto LABEL_99;
      }
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
LABEL_93:
        v48 = __cxa_allocate_exception(0x10uLL);
        *(_QWORD *)v48 = &off_1E69EE218;
        v48[2] = 2003329396;
      }
      *(_DWORD *)buf = 136315394;
      v74 = "AUSPLMeter.cpp";
      v75 = 1024;
      v76 = 584;
      v46 = MEMORY[0x1E0C81028];
      v47 = "%25s:%-5d  Output volume curve cannot be null";
    }
    else
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_93;
      *(_DWORD *)buf = 136315394;
      v74 = "AUSPLMeter.cpp";
      v75 = 1024;
      v76 = 583;
      v46 = MEMORY[0x1E0C81028];
      v47 = "%25s:%-5d  Input volume curve cannot be null";
    }
    _os_log_impl(&dword_1B5ED0000, v46, OS_LOG_TYPE_ERROR, v47, buf, 0x12u);
    goto LABEL_93;
  }
  if (a2 == 64002)
    return AudioUnitSetProperty(*((AudioUnit *)this + 87), 0, 0, a4, a5, a6);
  if (a2 == 64003)
  {
    v10 = *(_DWORD *)a5;
    *((_DWORD *)this + 148) = *(_DWORD *)a5;
    if (v10 == 8228 || v10 == 8212)
    {
      result = 0;
      atomic_store(1u, (unsigned __int8 *)this + 588);
    }
    else
    {
      result = 0;
      atomic_store(0, (unsigned __int8 *)this + 588);
    }
  }
  return result;
}

void sub_1B61BBDAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,uint64_t a32,char a33)
{
  if (a2)
  {
    if (__p)
    {
      a12 = (uint64_t)__p;
      operator delete(__p);
    }
    if (a14)
    {
      a15 = (uint64_t)a14;
      operator delete(a14);
    }
    if (a17)
      operator delete(a17);
    if (a33 && a30)
      operator delete(a30);
    applesauce::CF::DictionaryRef::~DictionaryRef(&a10);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1B61BB370);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B61BBEB8()
{
  JUMPOUT(0x1B61BBDE0);
}

uint64_t AUSPLMeter::SetParameter(AUSPLMeter *this, unsigned int a2, unsigned int a3, unsigned int a4, float a5, UInt32 a6)
{
  ausdk::AUScope *Scope;
  ausdk::AUElement *Element;
  float v15;
  ausdk::AUElement *v16;
  float v17;
  ausdk::AUElement *v18;
  NSObject *v19;
  float *v20;
  float v21;
  ausdk::AUElement *v22;
  NSObject *v23;
  double v24;
  double v25;
  const char *v26;
  NSObject *v27;
  uint32_t v28;
  double v29;
  AudioUnitParameterValue inValue;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  double v35;
  __int16 v36;
  double v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  Scope = (ausdk::AUScope *)ausdk::AUBase::GetScope(this, a3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(Scope, a4);
  ausdk::AUElement::SetParameter(Element, a2, a5, 0);
  if (!a3)
  {
    switch(a2)
    {
      case 0u:
        (*(void (**)(AUSPLMeter *, _QWORD, _QWORD, _QWORD, char *))(*(_QWORD *)this + 144))(this, 0, 0, 0, (char *)this + 532);
        v15 = AUSPLMeter::MapVolume(*((float **)this + 75), *((_QWORD *)this + 76), *((_QWORD *)this + 78), *((_QWORD *)this + 79), *((float *)this + 133));
        *((float *)this + 134) = v15;
        v16 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 32), 0);
        ausdk::AUElement::SetParameter(v16, 0xAu, v15, 0);
        v17 = (float)((float)(*((float *)this + 134) + *((float *)this + 135)) - *((float *)this + 146)) + 13.0;
        *((float *)this + 136) = v17;
        v18 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 32), 0);
        ausdk::AUElement::SetParameter(v18, 0xBu, v17, 0);
        if (AUSPLMeterLogScope(void)::once != -1)
          dispatch_once(&AUSPLMeterLogScope(void)::once, &__block_literal_global_2837);
        if (AUSPLMeterLogScope(void)::scope)
        {
          v19 = *(NSObject **)AUSPLMeterLogScope(void)::scope;
          if (!*(_QWORD *)AUSPLMeterLogScope(void)::scope)
            return 0;
        }
        else
        {
          v19 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          v24 = *((float *)this + 133);
          v25 = *((float *)this + 134);
          inValue = 4.8153e-34;
          v31 = "AUSPLMeter.cpp";
          v32 = 1024;
          v33 = 522;
          v34 = 2048;
          v35 = v24;
          v36 = 2048;
          v37 = v25;
          v26 = "%25s:%-5d Volume Input/Mapped: %f, %f";
          v27 = v19;
          v28 = 38;
          goto LABEL_24;
        }
        return 0;
      case 1u:
        v20 = (float *)((char *)this + 540);
        (*(void (**)(AUSPLMeter *, uint64_t, _QWORD, _QWORD, char *))(*(_QWORD *)this + 144))(this, 1, 0, 0, (char *)this + 540);
        v21 = (float)((float)(*((float *)this + 134) + *((float *)this + 135)) - *((float *)this + 146)) + 13.0;
        *((float *)this + 136) = v21;
        v22 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 32), 0);
        ausdk::AUElement::SetParameter(v22, 0xBu, v21, 0);
        if (AUSPLMeterLogScope(void)::once != -1)
          dispatch_once(&AUSPLMeterLogScope(void)::once, &__block_literal_global_2837);
        if (AUSPLMeterLogScope(void)::scope)
        {
          v23 = *(NSObject **)AUSPLMeterLogScope(void)::scope;
          if (!*(_QWORD *)AUSPLMeterLogScope(void)::scope)
            return 0;
        }
        else
        {
          v23 = MEMORY[0x1E0C81028];
        }
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          v29 = *v20;
          inValue = 4.8152e-34;
          v31 = "AUSPLMeter.cpp";
          v32 = 1024;
          v33 = 529;
          v34 = 2048;
          v35 = v29;
          v26 = "%25s:%-5d Output Sensitivity: %f";
          v27 = v23;
          v28 = 28;
LABEL_24:
          _os_log_impl(&dword_1B5ED0000, v27, OS_LOG_TYPE_DEBUG, v26, (uint8_t *)&inValue, v28);
        }
        break;
      case 2u:
        inValue = 0.0;
        (*(void (**)(AUSPLMeter *, uint64_t, _QWORD, _QWORD, AudioUnitParameterValue *))(*(_QWORD *)this
                                                                                                 + 144))(this, 2, 0, 0, &inValue);
        *((_BYTE *)this + 548) = inValue > 0.0;
        return 0;
      case 4u:
        inValue = 0.0;
        (*(void (**)(AUSPLMeter *, uint64_t, _QWORD, _QWORD, AudioUnitParameterValue *))(*(_QWORD *)this
                                                                                                 + 144))(this, 4, 0, 0, &inValue);
        *((_BYTE *)this + 556) = inValue > 0.0;
        return 0;
      case 6u:
        inValue = 0.0;
        (*(void (**)(AUSPLMeter *, uint64_t, _QWORD, _QWORD, AudioUnitParameterValue *))(*(_QWORD *)this
                                                                                                 + 144))(this, 6, 0, 0, &inValue);
        *((_BYTE *)this + 564) = inValue > 0.0;
        return 0;
      case 0xCu:
        inValue = 0.0;
        (*(void (**)(AUSPLMeter *, uint64_t, _QWORD, _QWORD, AudioUnitParameterValue *))(*(_QWORD *)this
                                                                                                 + 144))(this, 12, 0, 0, &inValue);
        AudioUnitSetParameter(*((AudioUnit *)this + 87), 5u, 0, a4, inValue, a6);
        return 0;
      default:
        return 0;
    }
  }
  return 0;
}

uint64_t AUSPLMeter::CanScheduleParameters(AUSPLMeter *this)
{
  return 0;
}

uint64_t AUSPLMeter::ProcessBufferLists(AUSPLMeter *this, unsigned int *a2, const AudioBufferList *a3, AudioBufferList *a4, UInt32 a5)
{
  AudioBufferList *v10;
  unint64_t mNumberBuffers;
  uint64_t v13;
  unint64_t v14;
  size_t mDataByteSize;
  void *mData;
  void *v17;
  uint64_t Element;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  size_t v22;
  void *v23;
  void *v24;
  unsigned __int8 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void **p_mData;
  void *v32;
  float v33;
  ausdk::AUElement *v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  ausdk::AUElement *v41;
  float v42;
  float v43;
  ausdk::AUElement *v44;
  float v45;
  float v46;
  float v47;
  ausdk::AUElement *v48;
  AudioUnitRenderActionFlags ioActionFlags;
  AudioTimeStamp inTimeStamp;

  if (*((_DWORD *)this + 84) < a5)
    return 4294956422;
  v10 = (AudioBufferList *)**((_QWORD **)this + 88);
  mNumberBuffers = a3->mNumberBuffers;
  if (mNumberBuffers == a4->mNumberBuffers && mNumberBuffers != 0)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      mDataByteSize = a3->mBuffers[v13].mDataByteSize;
      if ((_DWORD)mDataByteSize == a4->mBuffers[v13].mDataByteSize)
      {
        mData = a3->mBuffers[v13].mData;
        v17 = a4->mBuffers[v13].mData;
        if (mData != v17)
        {
          memcpy(v17, mData, mDataByteSize);
          mNumberBuffers = a3->mNumberBuffers;
        }
      }
      ++v14;
      ++v13;
    }
    while (v14 < mNumberBuffers);
  }
  if (!*((_BYTE *)this + 528))
  {
    Element = ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 80), 0);
    v19 = a3->mNumberBuffers;
    if (v19 == v10[2].mNumberBuffers && a3->mNumberBuffers)
    {
      v20 = 0;
      v21 = 0;
      v22 = *(_DWORD *)(Element + 104) * a5;
      do
      {
        if (a3->mBuffers[v20].mDataByteSize >= v22
          && v10[2].mBuffers[v20].mDataByteSize >= v22)
        {
          v23 = a3->mBuffers[v20].mData;
          v24 = v10[2].mBuffers[v20].mData;
          if (v23 != v24)
          {
            memcpy(v24, v23, v22);
            v19 = a3->mNumberBuffers;
          }
        }
        ++v21;
        ++v20;
      }
      while (v21 < v19);
    }
    v25 = atomic_load((unsigned __int8 *)this + 588);
    if ((v25 & 1) != 0 && *((_BYTE *)this + 596))
    {
      v26 = *((_OWORD *)this + 18);
      *(_OWORD *)&inTimeStamp.mSampleTime = *((_OWORD *)this + 17);
      *(_OWORD *)&inTimeStamp.mRateScalar = v26;
      v27 = *((_OWORD *)this + 20);
      *(_OWORD *)&inTimeStamp.mSMPTETime.mSubframes = *((_OWORD *)this + 19);
      *(_OWORD *)&inTimeStamp.mSMPTETime.mHours = v27;
      ioActionFlags = 512;
      AudioUnitProcess(*((AudioUnit *)this + 87), &ioActionFlags, &inTimeStamp, a5, v10 + 2);
    }
    v28 = a3->mNumberBuffers;
    if ((_DWORD)v28)
    {
      v29 = 0;
      v30 = 8 * v28;
      p_mData = &v10[2].mBuffers[0].mData;
      do
      {
        v32 = *p_mData;
        p_mData += 2;
        *(_QWORD *)(*((_QWORD *)this + 84) + v29) = v32;
        v29 += 8;
      }
      while (v30 != v29);
    }
    v33 = (float)a5 / *((float *)this + 145);
    *((float *)this + 143) = v33;
    v34 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(v34, 8u, v33, 0);
    v35 = *((float *)this + 133);
    v36 = *((float *)this + 144);
    v37 = 0.0;
    v38 = 0.0;
    if (*((_BYTE *)this + 548))
    {
      v39 = LoudnessMeter::Process(*((float ****)this + 81), *((float ***)this + 84), a5);
      if (v35 > v36)
      {
        v40 = fmax(v39, 1.0e-15);
        v38 = fmaxf(*((float *)this + 136) + (float)(log10f(v40) * 10.0), 0.0);
      }
    }
    *((float *)this + 138) = v38;
    v41 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(v41, 3u, v38, 0);
    if (*((_BYTE *)this + 556))
    {
      v42 = LoudnessMeter::Process(*((float ****)this + 82), *((float ***)this + 84), a5);
      if (v35 > v36)
      {
        v43 = fmax(v42, 1.0e-15);
        v37 = fmaxf(*((float *)this + 136) + (float)(log10f(v43) * 10.0), 0.0);
      }
    }
    *((float *)this + 140) = v37;
    v44 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(v44, 5u, v37, 0);
    v45 = 0.0;
    if (*((_BYTE *)this + 564))
    {
      v46 = LoudnessMeter::Process(*((float ****)this + 83), *((float ***)this + 84), a5);
      if (v35 > v36)
      {
        v47 = fmax(v46, 1.0e-15);
        v45 = log10f(v47) * 10.0;
      }
    }
    *((float *)this + 142) = v45;
    v48 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 32), 0);
    ausdk::AUElement::SetParameter(v48, 7u, v45, 0);
  }
  return 0;
}

uint64_t AUSPLMeter::Render(AUSPLMeter *this, unsigned int *a2, const AudioTimeStamp *a3, uint64_t a4)
{
  ausdk::AUScope *v8;
  uint64_t Element;
  uint64_t v10;
  ausdk::AUInputElement *v11;
  uint64_t result;
  uint64_t BufferList;
  uint64_t v14;
  unsigned int v15;

  v8 = (AUSPLMeter *)((char *)this + 80);
  Element = ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 80), 0);
  v10 = ausdk::AUScope::SafeGetElement((AUSPLMeter *)((char *)this + 128), 0);
  v15 = 0;
  v11 = (ausdk::AUInputElement *)ausdk::AUScope::SafeGetElement(v8, 0);
  result = ausdk::AUInputElement::PullInput(v11, &v15, a3, 0, a4);
  if (!(_DWORD)result)
  {
    BufferList = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(Element + 144));
    v14 = ausdk::AUBufferList::GetBufferList((ausdk::AUBufferList *)(v10 + 144));
    return (*(uint64_t (**)(AUSPLMeter *, unsigned int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 176))(this, a2, BufferList, v14, a4);
  }
  return result;
}

uint64_t AUSPLMeter::GetParameterInfo(AUSPLMeter *this, int a2, unsigned int a3, AudioUnitParameterInfo *buffer)
{
  uint64_t result;
  char *v5;
  uint64_t v6;
  const __CFString *v7;

  result = 4294956418;
  if (!a2 && a3 <= 0xC)
  {
    v5 = (char *)&paramInfo + 104 * a3;
    *(_OWORD *)&buffer->clumpID = *((_OWORD *)v5 + 4);
    v6 = *((_QWORD *)v5 + 12);
    *(_QWORD *)&buffer->flags = v6;
    *(_OWORD *)&buffer->name[48] = *((_OWORD *)v5 + 3);
    *(_OWORD *)&buffer->unit = *((_OWORD *)v5 + 5);
    *(_OWORD *)buffer->name = *(_OWORD *)v5;
    *(_OWORD *)&buffer->name[16] = *((_OWORD *)v5 + 1);
    *(_OWORD *)&buffer->name[32] = *((_OWORD *)v5 + 2);
    v7 = (const __CFString *)*((_QWORD *)v5 + 9);
    buffer->cfNameString = v7;
    buffer->flags = v6 | 0x8000000;
    CFStringGetCString(v7, buffer->name, 52, 0x8000100u);
    return 0;
  }
  return result;
}

double AUSPLMeter::GetLatency(AUSPLMeter *this)
{
  return 0.0;
}

double AUSPLMeter::GetTailTime(AUSPLMeter *this)
{
  return 0.0;
}

uint64_t AUSPLMeter::SupportsTail(AUSPLMeter *this)
{
  return 1;
}

BOOL AUSPLMeter::StreamFormatWritable(AUSPLMeter *this)
{
  return *((_BYTE *)this + 17) == 0;
}

uint64_t AUSPLMeter::SupportedNumChannels(AUSPLMeter *this, const AUChannelInfo **a2)
{
  if (a2)
    *a2 = (const AUChannelInfo *)&AUSPLMeter::SupportedNumChannels(AUChannelInfo const**)::sSupportedChannelConfigs;
  return 2;
}

float AUSPLMeter::MapVolume(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5)
{
  unint64_t v5;
  uint64_t v6;

  if (*a1 >= a5)
    return *(float *)a3;
  if (*(float *)(a2 - 4) <= a5)
    return *(float *)(a4 - 4);
  v5 = (unint64_t)(a2 - (_QWORD)a1) >> 2;
  if (v5 < 2)
  {
    LODWORD(v5) = 1;
  }
  else
  {
    v6 = 1;
    while (a1[v6] < a5)
    {
      if (((unint64_t)(a2 - (_QWORD)a1) >> 2) == ++v6)
        return *(float *)(a3 + 4 * v5)
             + (float)((float)(*(float *)(a3 + 4 * (v5 - 1)) - *(float *)(a3 + 4 * v5))
                     * (float)((float)(a5 - a1[v5])
                             / (float)(a1[(v5 - 1)] - a1[v5])));
    }
    LODWORD(v5) = v6;
  }
  return *(float *)(a3 + 4 * v5)
       + (float)((float)(*(float *)(a3 + 4 * (v5 - 1)) - *(float *)(a3 + 4 * v5))
               * (float)((float)(a5 - a1[v5]) / (float)(a1[(v5 - 1)] - a1[v5])));
}

os_log_t ___ZL18AUSPLMeterLogScopev_block_invoke()
{
  _QWORD *v0;
  os_log_t result;

  v0 = (_QWORD *)operator new();
  v0[1] = 0;
  result = os_log_create("com.apple.coreaudio", "splmeter");
  *v0 = result;
  AUSPLMeterLogScope(void)::scope = (uint64_t)v0;
  return result;
}

BOOL AUSPLMeter::ValidateMap(float **a1)
{
  float *v1;
  float *v2;
  NSObject *v4;
  void **v5;
  float *v6;
  float *v7;
  int v8;
  uint64_t v10;
  _BOOL8 result;
  unint64_t v12;
  unsigned int v13;
  unint64_t v14;
  float v15;
  float v16;
  void *__p[2];
  char v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  void **v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  v2 = a1[1];
  if (**a1 <= *(v2 - 1))
    goto LABEL_19;
  if (AUSPLMeterLogScope(void)::once != -1)
    dispatch_once(&AUSPLMeterLogScope(void)::once, &__block_literal_global_2837);
  if (!AUSPLMeterLogScope(void)::scope)
  {
    v4 = MEMORY[0x1E0C81028];
    goto LABEL_8;
  }
  v4 = *(NSObject **)AUSPLMeterLogScope(void)::scope;
  if (*(_QWORD *)AUSPLMeterLogScope(void)::scope)
  {
LABEL_8:
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      AUSPLMeter::ConvertToString(__p, a1);
      v5 = v19 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136315650;
      v21 = "AUSPLMeter.cpp";
      v22 = 1024;
      v23 = 623;
      v24 = 2080;
      v25 = v5;
      _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Volume Map component is not in increasing order: %s. Reversing the order.", buf, 0x1Cu);
      if (v19 < 0)
        operator delete(__p[0]);
    }
  }
  v1 = *a1;
  v2 = a1[1];
  if (*a1 != v2)
  {
    v6 = v2 - 1;
    if (v2 - 1 > v1)
    {
      v7 = v1 + 1;
      do
      {
        v8 = *((_DWORD *)v7 - 1);
        *(v7 - 1) = *v6;
        *(_DWORD *)v6-- = v8;
      }
      while (v7++ < v6);
    }
  }
LABEL_19:
  v10 = (char *)v2 - (char *)v1;
  if ((unint64_t)v10 < 8)
    return 1;
  v12 = v10 >> 2;
  v13 = 2;
  v14 = 1;
  do
  {
    v15 = v1[v13 - 2];
    v16 = v1[v14];
    result = v15 <= v16;
    v14 = v13++;
  }
  while (v15 <= v16 && v12 > v14);
  return result;
}

uint64_t AUSPLMeter::ConvertToString(_QWORD *a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD v7[2];
  uint64_t v8;
  _QWORD v9[10];
  char v10;
  uint64_t v11;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v7);
  if (a2[1] != *a2)
  {
    v4 = 0;
    do
    {
      if (v4)
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v8, (uint64_t)", ", 2);
      std::ostream::operator<<();
      ++v4;
    }
    while (v4 < (uint64_t)(a2[1] - *a2) >> 2);
  }
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v9, a1);
  v7[0] = *MEMORY[0x1E0DE4F50];
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v7 + *(_QWORD *)(v7[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v8 = v5;
  v9[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v10 < 0)
    operator delete((void *)v9[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCC95BE4](&v11);
}

void sub_1B61BCBE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, void **a2, _OWORD **a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v8;
  _QWORD *v9;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;

  v6 = a1 + 1;
  v5 = a1[1];
  if (!v5)
  {
    v8 = a1 + 1;
LABEL_9:
    v10 = (uint64_t *)operator new(0x50uLL);
    v11 = *a3;
    v12 = *((_QWORD *)*a3 + 2);
    *((_OWORD *)v10 + 2) = **a3;
    v10[6] = v12;
    *v11 = 0;
    v11[1] = 0;
    v11[2] = 0;
    v10[8] = 0;
    v10[9] = 0;
    v10[7] = 0;
    *v10 = 0;
    v10[1] = 0;
    v10[2] = (uint64_t)v8;
    *v6 = v10;
    v13 = (uint64_t *)**a1;
    v14 = v10;
    if (v13)
    {
      *a1 = v13;
      v14 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return v10;
  }
  while (1)
  {
    while (1)
    {
      v8 = (uint64_t **)v5;
      v9 = v5 + 4;
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, (void **)v5 + 4) & 0x80) == 0)
        break;
      v5 = *v8;
      v6 = v8;
      if (!*v8)
        goto LABEL_9;
    }
    if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v9, a2) & 0x80) == 0)
      break;
    v6 = v8 + 1;
    v5 = v8[1];
    if (!v5)
      goto LABEL_9;
  }
  v10 = *v6;
  if (!*v6)
    goto LABEL_9;
  return v10;
}

uint64_t std::vector<applesauce::CF::TypeRefPair>::emplace_back<std::string const&,std::vector<float> const&>(_QWORD *a1, const UInt8 *a2, _QWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t result;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  CFStringRef *v18;
  CFStringRef *v19;
  char *v20;
  uint64_t v21;

  v8 = a1[2];
  v6 = (uint64_t)(a1 + 2);
  v7 = v8;
  v9 = *(_QWORD *)(v6 - 8);
  if (v9 >= v8)
  {
    v12 = (uint64_t)(v9 - *a1) >> 4;
    if ((unint64_t)(v12 + 1) >> 60)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v13 = v7 - *a1;
    v14 = v13 >> 3;
    if (v13 >> 3 <= (unint64_t)(v12 + 1))
      v14 = v12 + 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v14;
    v21 = v6;
    if (v15)
      v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,applesauce::CF::DictionaryRef>>>(v6, v15);
    else
      v16 = 0;
    v17 = v16;
    v18 = (CFStringRef *)&v16[16 * v12];
    v20 = &v16[16 * v15];
    applesauce::CF::TypeRefPair::TypeRefPair<std::string const&,std::vector<float> const&>(v18, a2, a3);
    v19 = v18 + 2;
    std::vector<applesauce::CF::TypeRefPair>::__swap_out_circular_buffer(a1, &v17);
    v11 = a1[1];
    result = std::__split_buffer<applesauce::CF::TypeRefPair>::~__split_buffer((uint64_t)&v17);
  }
  else
  {
    result = (uint64_t)applesauce::CF::TypeRefPair::TypeRefPair<std::string const&,std::vector<float> const&>(*(CFStringRef **)(v6 - 8), a2, a3);
    v11 = v9 + 16;
    a1[1] = v9 + 16;
  }
  a1[1] = v11;
  return result;
}

void sub_1B61BCDFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<float>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<float>>,0>(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

CFStringRef *applesauce::CF::TypeRefPair::TypeRefPair<std::string const&,std::vector<float> const&>(CFStringRef *a1, const UInt8 *a2, _QWORD *a3)
{
  CFIndex v5;
  CFIndex v6;
  CFStringRef v7;
  std::runtime_error *exception;

  v5 = *((_QWORD *)a2 + 1);
  if (*((char *)a2 + 23) >= 0)
  {
    v6 = a2[23];
  }
  else
  {
    a2 = *(const UInt8 **)a2;
    v6 = v5;
  }
  v7 = CFStringCreateWithBytes(0, a2, v6, 0x8000100u, 0);
  *a1 = v7;
  if (!v7)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  a1[1] = (CFStringRef)applesauce::CF::details::make_CFArrayRef<float>(a3);
  return a1;
}

void sub_1B61BCF40(_Unwind_Exception *exception_object)
{
  CFTypeRef *v1;

  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::default_delete<LoudnessMeter>::operator()[abi:ne180100](uint64_t a1)
{
  void *v2;
  void *v3;
  void **v5;

  v2 = *(void **)(a1 + 96);
  if (v2)
  {
    *(_QWORD *)(a1 + 104) = v2;
    operator delete(v2);
  }
  v5 = (void **)(a1 + 72);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::Biquad::SetupWrapper *)(a1 + 48));
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v3;
    operator delete(v3);
  }
  return MEMORY[0x1BCC95CEC](a1, 0x10A0C40D09BC750);
}

_QWORD *CA::AudioBuffers::AudioBuffers(CA::AudioBuffers *this, const AudioStreamBasicDescription *a2)
{
  uint64_t v3;

  v3 = ExtendedAudioBufferList_CreateWithFormat();
  return CA::AudioBuffers::AudioBuffers(this, v3);
}

void std::default_delete<CA::AudioBuffers>::operator()[abi:ne180100]()
{
  ExtendedAudioBufferList_Destroy();
  JUMPOUT(0x1BCC95CECLL);
}

OpaqueAudioComponentInstance *AUSPLMeter::InitializeVarEQ(AudioUnit *this)
{
  uint64_t Element;
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  OpaqueAudioComponentInstance *result;
  _BOOL4 AppBooleanValue;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const __CFBoolean *Value;
  NSObject *v11;
  const char *v12;
  int v13;
  BOOL v14;
  _OWORD v15[2];
  uint64_t v16;
  _OWORD inData[2];
  uint64_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  AudioUnitUninitialize(this[87]);
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(this + 10), 0);
  v3 = *(_OWORD *)(Element + 96);
  inData[0] = *(_OWORD *)(Element + 80);
  inData[1] = v3;
  v18 = *(_QWORD *)(Element + 112);
  v4 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(this + 16), 0);
  v5 = *(_OWORD *)(v4 + 96);
  v15[0] = *(_OWORD *)(v4 + 80);
  v15[1] = v5;
  v16 = *(_QWORD *)(v4 + 112);
  result = (OpaqueAudioComponentInstance *)AudioUnitSetProperty(this[87], 8u, 1u, 0, inData, 0x28u);
  if (!(_DWORD)result)
  {
    result = (OpaqueAudioComponentInstance *)AudioUnitSetProperty(this[87], 8u, 2u, 0, v15, 0x28u);
    if (!(_DWORD)result)
    {
      result = this[87];
      if (result)
      {
        result = (OpaqueAudioComponentInstance *)AudioUnitInitialize(result);
        if (!(_DWORD)result)
        {
          *((_BYTE *)this + 596) = 1;
          if (queryBuildType(void)::once != -1)
            dispatch_once(&queryBuildType(void)::once, &__block_literal_global_67);
          if (!gIsInternal)
            return 0;
          CFPreferencesAppSynchronize(CFSTR("com.apple.coreaudio"));
          v14 = 0;
          AppBooleanValue = CACFPreferencesGetAppBooleanValue(CFSTR("auspl_lc_menu"), CFSTR("com.apple.coreaudio"), &v14);
          if (!v14)
            return 0;
          if (!AppBooleanValue)
            return 0;
          CFPreferencesAppSynchronize(CFSTR("com.apple.MobileBluetooth.debug"));
          v8 = (const __CFDictionary *)CFPreferencesCopyAppValue(CFSTR("A2DP"), CFSTR("com.apple.MobileBluetooth.debug"));
          if (!v8)
            return 0;
          v9 = v8;
          *((_BYTE *)this + 596) = 0;
          if (CFDictionaryContainsKey(v8, CFSTR("LoudnessCompensationEQEnable")))
          {
            Value = (const __CFBoolean *)CFDictionaryGetValue(v9, CFSTR("LoudnessCompensationEQEnable"));
            *((_BYTE *)this + 596) = CFBooleanGetValue(Value) != 0;
          }
          if (AUSPLMeterLogScope(void)::once != -1)
            dispatch_once(&AUSPLMeterLogScope(void)::once, &__block_literal_global_2837);
          if (AUSPLMeterLogScope(void)::scope)
          {
            v11 = *(NSObject **)AUSPLMeterLogScope(void)::scope;
            if (!*(_QWORD *)AUSPLMeterLogScope(void)::scope)
            {
LABEL_24:
              CFRelease(v9);
              return 0;
            }
          }
          else
          {
            v11 = MEMORY[0x1E0C81028];
          }
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            v12 = "YES";
            v13 = *((unsigned __int8 *)this + 596);
            v20 = "AUSPLMeter.cpp";
            *(_DWORD *)buf = 136315650;
            if (!v13)
              v12 = "NO";
            v21 = 1024;
            v22 = 300;
            v23 = 2080;
            v24 = v12;
            _os_log_impl(&dword_1B5ED0000, v11, OS_LOG_TYPE_DEFAULT, "%25s:%-5d LoudnessCompensationEQEnable defaults-preferences is enabled: %s", buf, 0x1Cu);
          }
          goto LABEL_24;
        }
      }
    }
  }
  return result;
}

_QWORD *CA::AudioBuffers::AudioBuffers(_QWORD *a1, uint64_t a2)
{
  std::logic_error *exception;

  *a1 = a2;
  if (!a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "ExtendedAudioBufferList_CreateWithFormat failed");
    goto LABEL_6;
  }
  if (!ExtendedAudioBufferList_Prepare())
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "ExtendedAudioBufferList_Prepare failed");
LABEL_6:
  }
  return a1;
}

void sub_1B61BD3B4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void ULDATFeaturesChain::~ULDATFeaturesChain(AudioUnit *this)
{
  ULDATFeaturesChain::~ULDATFeaturesChain(this);
  JUMPOUT(0x1BCC95CECLL);
}

{
  AudioUnit v2;

  *this = (AudioUnit)&off_1E69CAFF8;
  ULDATFeaturesChain::Uninitialize(this);
  v2 = this[7];
  this[7] = 0;
  if (v2)
    MEMORY[0x1BCC95CEC](v2, 0x1000C40FF89C88ELL);
}

uint64_t ULDATFeaturesChain::Initialize(uint64_t a1, double *a2, const __CFDictionary *a3)
{
  OpaqueAudioComponent *Next;
  AudioUnit *v7;
  OpaqueAudioComponent *v8;
  NSObject *v9;
  const __CFDictionary *Value;
  const __CFDictionary *v11;
  const __CFNumber *v12;
  int v13;
  OSStatus v14;
  const __CFNumber *v15;
  int v16;
  AudioUnitParameterValue v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  const __CFNumber *v23;
  double v24;
  uint64_t v25;
  BiquadCoefficients *v26;
  uint64_t v27;
  float v28;
  uint64_t v29;
  NSObject *v31;
  AudioComponentDescription inValue;
  int inData;
  unsigned int valuePtr;
  _BYTE inDesc[32];
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  FeaturesDSPChain::InitializeInputOutputBufferSizes(a1, a2, a3, 10);
  inDesc[13] = 0;
  *(_WORD *)&inDesc[14] = 0;
  *(_DWORD *)&inDesc[16] = 0;
  strcpy(inDesc, "xfuasncolppa");
  Next = AudioComponentFindNext(0, (const AudioComponentDescription *)inDesc);
  v7 = (AudioUnit *)(a1 + 64);
  if (!AudioComponentInstanceNew(Next, (AudioComponentInstance *)(a1 + 64)))
  {
    inValue.componentFlagsMask = 0;
    *(_QWORD *)&inValue.componentManufacturer = 0;
    *(_QWORD *)&inValue.componentType = 0x6167633261756678;
    v8 = AudioComponentFindNext(0, &inValue);
    if (!AudioComponentInstanceNew(v8, (AudioComponentInstance *)(a1 + 72)))
      goto LABEL_11;
  }
  if (EndpointVAD2LogScope(void)::once != -1)
    dispatch_once(&EndpointVAD2LogScope(void)::once, &__block_literal_global_5);
  if (EndpointVAD2LogScope(void)::scope)
  {
    v9 = *(NSObject **)EndpointVAD2LogScope(void)::scope;
    if (!*(_QWORD *)EndpointVAD2LogScope(void)::scope)
      goto LABEL_11;
  }
  else
  {
    v9 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)inDesc = 136315394;
    *(_QWORD *)&inDesc[4] = "ULDATFeaturesChain.cpp";
    *(_WORD *)&inDesc[12] = 1024;
    *(_DWORD *)&inDesc[14] = 36;
    _os_log_impl(&dword_1B5ED0000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to instantiate internal audio units.", inDesc, 0x12u);
  }
LABEL_11:
  Value = (const __CFDictionary *)CFDictionaryGetValue(a3, CFSTR("AUOneChannelNSProperties"));
  v11 = (const __CFDictionary *)CFDictionaryGetValue(a3, CFSTR("AUAGCV2Properties"));
  if (AudioUnitSetProperty(*v7, 8u, 1u, 0, a2, 0x28u))
    goto LABEL_59;
  if (AudioUnitSetProperty(*v7, 8u, 2u, 0, a2, 0x28u))
    goto LABEL_59;
  inData = 1;
  if (AudioUnitSetProperty(*v7, 0xE74u, 0, 0, &inData, 4u)
    || AudioUnitSetProperty(*(AudioUnit *)(a1 + 64), 0xEu, 0, 0, (const void *)(a1 + 16), 4u))
  {
    goto LABEL_59;
  }
  *(_QWORD *)inDesc = 0;
  v12 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("NoiseSuppressFloorDB"));
  v13 = CFNumberGetValue(v12, kCFNumberFloat64Type, inDesc);
  if (v13)
    v14 = 0;
  else
    v14 = -50;
  if (v13)
  {
    inValue.componentType = 0;
    v15 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("UseVADMode"));
    v16 = CFNumberGetValue(v15, kCFNumberSInt32Type, &inValue);
    v14 = v16 ? 0 : -50;
    if (v16)
    {
      v17 = *(double *)inDesc;
      v14 = AudioUnitSetParameter(*v7, 0, 0, 0, v17, 0);
      if (!v14)
      {
        v14 = AudioUnitSetParameter(*v7, 1u, 0, 0, 0.0, 0);
        if (!v14)
        {
          v14 = AudioUnitSetParameter(*v7, 2u, 0, 0, 40.0, 0);
          if (!v14)
          {
            v14 = AudioUnitSetParameter(*v7, 3u, 0, 0, 0.0, 0);
            if (!v14)
            {
              v14 = AudioUnitSetParameter(*v7, 4u, 0, 0, 4.0, 0);
              if (!v14)
              {
                v14 = AudioUnitSetParameter(*v7, 5u, 0, 0, 40.0, 0);
                if (!v14)
                {
                  v14 = AudioUnitSetParameter(*v7, 6u, 0, 0, 70.0, 0);
                  if (!v14)
                  {
                    AudioUnitSetParameter(*v7, 7u, 0, 0, 4.0, 0);
                    v14 = AudioUnitSetProperty(*v7, 0x11ABu, 0, 0, &inValue, 4u);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (v14
    || AudioUnitSetProperty(*(AudioUnit *)(a1 + 72), 8u, 1u, 0, a2, 0x28u)
    || AudioUnitSetProperty(*(AudioUnit *)(a1 + 72), 8u, 2u, 0, a2, 0x28u)
    || AudioUnitSetProperty(*(AudioUnit *)(a1 + 72), 0xEu, 0, 0, (const void *)(a1 + 16), 4u)
    || AudioUnitSetParameter(*(AudioUnit *)(a1 + 72), 0x20u, 0, 0, 0.0, 0))
  {
    goto LABEL_59;
  }
  AudioUnitSetParameter(*(AudioUnit *)(a1 + 72), 0x1Bu, 0, 0, 4.0, 0);
  inValue.componentType = -1035993088;
  valuePtr = 1;
  if (!v11)
    goto LABEL_40;
  v18 = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("AbsoluteSilenceThdDb"));
  if (CFNumberGetValue(v18, kCFNumberFloat32Type, &inValue))
  {
    if (!CFDictionaryContainsKey(v11, CFSTR("UseNoiseDithering"))
      || (v19 = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("UseNoiseDithering")),
          CFNumberGetValue(v19, kCFNumberSInt32Type, &valuePtr)))
    {
LABEL_40:
      AudioUnitSetParameter(*(AudioUnit *)(a1 + 72), 0x22u, 0, 0, *(AudioUnitParameterValue *)&inValue.componentType, 0);
      if (!AudioUnitSetParameter(*(AudioUnit *)(a1 + 72), 0x40u, 0, 0, (float)valuePtr, 0))
        goto LABEL_67;
      goto LABEL_59;
    }
    if (EndpointVAD2LogScope(void)::once != -1)
      dispatch_once(&EndpointVAD2LogScope(void)::once, &__block_literal_global_5);
    if (EndpointVAD2LogScope(void)::scope)
    {
      v20 = *(NSObject **)EndpointVAD2LogScope(void)::scope;
      if (!*(_QWORD *)EndpointVAD2LogScope(void)::scope)
        goto LABEL_59;
    }
    else
    {
      v20 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)inDesc = 136315394;
      *(_QWORD *)&inDesc[4] = "ULDATFeaturesChain.cpp";
      *(_WORD *)&inDesc[12] = 1024;
      *(_DWORD *)&inDesc[14] = 273;
      goto LABEL_58;
    }
  }
  else
  {
    if (EndpointVAD2LogScope(void)::once != -1)
      dispatch_once(&EndpointVAD2LogScope(void)::once, &__block_literal_global_5);
    if (EndpointVAD2LogScope(void)::scope)
    {
      v20 = *(NSObject **)EndpointVAD2LogScope(void)::scope;
      if (!*(_QWORD *)EndpointVAD2LogScope(void)::scope)
        goto LABEL_59;
    }
    else
    {
      v20 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)inDesc = 136315394;
      *(_QWORD *)&inDesc[4] = "ULDATFeaturesChain.cpp";
      *(_WORD *)&inDesc[12] = 1024;
      *(_DWORD *)&inDesc[14] = 265;
LABEL_58:
      _os_log_impl(&dword_1B5ED0000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d Error reading AbsoluteSilenceThdDb from AGC plist dictionary.", inDesc, 0x12u);
    }
  }
LABEL_59:
  if (EndpointVAD2LogScope(void)::once != -1)
    dispatch_once(&EndpointVAD2LogScope(void)::once, &__block_literal_global_5);
  if (EndpointVAD2LogScope(void)::scope)
  {
    v21 = *(NSObject **)EndpointVAD2LogScope(void)::scope;
    if (!*(_QWORD *)EndpointVAD2LogScope(void)::scope)
      goto LABEL_67;
  }
  else
  {
    v21 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)inDesc = 136315394;
    *(_QWORD *)&inDesc[4] = "ULDATFeaturesChain.cpp";
    *(_WORD *)&inDesc[12] = 1024;
    *(_DWORD *)&inDesc[14] = 45;
    _os_log_impl(&dword_1B5ED0000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to set up internal audio units.", inDesc, 0x12u);
  }
LABEL_67:
  if (AudioUnitInitialize(*v7) || AudioUnitInitialize(*(AudioUnit *)(a1 + 72)))
  {
    if (EndpointVAD2LogScope(void)::once != -1)
      dispatch_once(&EndpointVAD2LogScope(void)::once, &__block_literal_global_5);
    if (EndpointVAD2LogScope(void)::scope)
    {
      v22 = *(NSObject **)EndpointVAD2LogScope(void)::scope;
      if (!*(_QWORD *)EndpointVAD2LogScope(void)::scope)
        goto LABEL_77;
    }
    else
    {
      v22 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)inDesc = 136315394;
      *(_QWORD *)&inDesc[4] = "ULDATFeaturesChain.cpp";
      *(_WORD *)&inDesc[12] = 1024;
      *(_DWORD *)&inDesc[14] = 52;
      _os_log_impl(&dword_1B5ED0000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to initialize internal audio units.", inDesc, 0x12u);
    }
  }
LABEL_77:
  *(_QWORD *)&inValue.componentType = 0;
  v23 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("HighpassFilterCutoffHz"));
  if (CFNumberGetValue(v23, kCFNumberFloat64Type, &inValue))
    goto LABEL_78;
  if (EndpointVAD2LogScope(void)::once != -1)
    dispatch_once(&EndpointVAD2LogScope(void)::once, &__block_literal_global_5);
  if (EndpointVAD2LogScope(void)::scope)
  {
    v31 = *(NSObject **)EndpointVAD2LogScope(void)::scope;
    if (!*(_QWORD *)EndpointVAD2LogScope(void)::scope)
      goto LABEL_78;
  }
  else
  {
    v31 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)inDesc = 136315394;
    *(_QWORD *)&inDesc[4] = "ULDATFeaturesChain.cpp";
    *(_WORD *)&inDesc[12] = 1024;
    *(_DWORD *)&inDesc[14] = 60;
    _os_log_impl(&dword_1B5ED0000, v31, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to read ULDAT highpass filter cutoff frequency from plist.", inDesc, 0x12u);
  }
LABEL_78:
  v24 = *(double *)&inValue.componentType;
  v25 = operator new();
  *(_QWORD *)v25 = 0;
  *(_QWORD *)(v25 + 8) = 0;
  *(_QWORD *)(v25 + 24) = 0;
  *(_QWORD *)(v25 + 32) = 0;
  *(_QWORD *)(v25 + 16) = 0x3FF0000000000000;
  *(_OWORD *)(v25 + 40) = 0u;
  *(_OWORD *)(v25 + 56) = 0u;
  v27 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = v25;
  if (v27)
    MEMORY[0x1BCC95CEC](v27, 0x1000C40FF89C88ELL);
  v28 = v24;
  *(_QWORD *)inDesc = 0;
  *(_QWORD *)&inDesc[8] = 0;
  *(_QWORD *)&inDesc[24] = 0;
  v36 = 0;
  *(_QWORD *)&inDesc[16] = 0x3FF0000000000000;
  Biquad::GetHipassParams((Biquad *)inDesc, (float)(v28 + v28) / *a2, *a2, v26);
  v29 = *(_QWORD *)(a1 + 56);
  *(_OWORD *)v29 = *(_OWORD *)inDesc;
  *(_OWORD *)(v29 + 16) = *(_OWORD *)&inDesc[16];
  *(_QWORD *)(v29 + 32) = v36;
  *(_BYTE *)(a1 + 8) = 1;
  return 0;
}

uint64_t ULDATFeaturesChain::Uninitialize(AudioUnit *this)
{
  uint64_t v2;
  OpaqueAudioComponentInstance *v3;
  OpaqueAudioComponentInstance *v4;

  v2 = AudioUnitUninitialize(this[8]);
  if (!(_DWORD)v2)
  {
    v2 = AudioUnitUninitialize(this[9]);
    if (!(_DWORD)v2)
      *((_BYTE *)this + 8) = 0;
    v3 = this[9];
    if (v3)
    {
      AudioComponentInstanceDispose(v3);
      this[9] = 0;
    }
    v4 = this[8];
    if (v4)
    {
      AudioComponentInstanceDispose(v4);
      this[8] = 0;
    }
    *((_DWORD *)this + 3) = 0;
  }
  return v2;
}

uint64_t ULDATFeaturesChain::ComputeAllFeaturesFromAudio(uint64_t a1, uint64_t a2, UInt32 a3, Float64 *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  const char *v15;
  AudioUnitParameterValue *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  float *v23;
  unint64_t v24;
  float v25;
  float v26;
  float v27;
  double *v28;
  unint64_t v29;
  double v30;
  double v31;
  AudioUnitRenderActionFlags ioActionFlags;
  AudioTimeStamp inTimeStamp;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  int v38;
  AudioBufferList *ioOutputBufferLists;
  AudioBufferList *inInputBufferLists[2];

  inInputBufferLists[1] = *(AudioBufferList **)MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 16) != a3)
    __assert_rtn("ComputeAllFeaturesFromAudio", "ULDATFeaturesChain.cpp", 322, "numAudioSamples == mAudioBufferSize");
  inTimeStamp.mSampleTime = *a4;
  memset(&inTimeStamp.mHostTime, 0, 24);
  *(_QWORD *)&inTimeStamp.mFlags = 1;
  Biquad::Process_Float32(*(Biquad **)(a1 + 56), *(float **)(a2 + 16), *(float **)(a5 + 16), a3);
  ioActionFlags = 512;
  ioOutputBufferLists = (AudioBufferList *)a5;
  inInputBufferLists[0] = (AudioBufferList *)a5;
  v11 = AudioUnitProcessMultiple(*(AudioUnit *)(a1 + 64), &ioActionFlags, &inTimeStamp, a3, 1u, (const AudioBufferList **)inInputBufferLists, 1u, &ioOutputBufferLists);
  if ((_DWORD)v11)
  {
    v12 = v11;
    if (EndpointVAD2LogScope(void)::once != -1)
      dispatch_once(&EndpointVAD2LogScope(void)::once, &__block_literal_global_5);
    if (EndpointVAD2LogScope(void)::scope)
    {
      v13 = *(NSObject **)EndpointVAD2LogScope(void)::scope;
      if (!*(_QWORD *)EndpointVAD2LogScope(void)::scope)
        return v12;
    }
    else
    {
      v13 = MEMORY[0x1E0C81028];
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v36 = "ULDATFeaturesChain.cpp";
      v37 = 1024;
      v38 = 355;
      v15 = "%25s:%-5d Noise suppressor failed to process.";
LABEL_45:
      _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_ERROR, v15, buf, 0x12u);
      return v12;
    }
    return v12;
  }
  v14 = AudioUnitProcess(*(AudioUnit *)(a1 + 72), &ioActionFlags, &inTimeStamp, a3, (AudioBufferList *)a5);
  if (!(_DWORD)v14)
  {
    v16 = (AudioUnitParameterValue *)a6[3];
    if ((AudioUnitParameterValue *)a6[4] != v16)
    {
      AudioUnitGetParameter(*(AudioUnit *)(a1 + 64), 1u, 0, 0, v16);
      v17 = a6[3];
      if ((unint64_t)(a6[4] - v17) > 4)
      {
        AudioUnitGetParameter(*(AudioUnit *)(a1 + 64), 2u, 0, 0, (AudioUnitParameterValue *)(v17 + 4));
        v18 = a6[3];
        if ((unint64_t)(a6[4] - v18) > 8)
        {
          AudioUnitGetParameter(*(AudioUnit *)(a1 + 72), 0x3Du, 0, 0, (AudioUnitParameterValue *)(v18 + 8));
          v19 = a6[3];
          if ((unint64_t)(a6[4] - v19) > 0xC)
          {
            AudioUnitGetParameter(*(AudioUnit *)(a1 + 72), 0x3Cu, 0, 0, (AudioUnitParameterValue *)(v19 + 12));
            v20 = a6[3];
            v21 = a6[4] - v20;
            if (v21 <= 0x1C)
              goto LABEL_47;
            *(_DWORD *)(v20 + 28) = 1056964608;
            if (v21 > 0x20)
            {
              AudioUnitGetParameter(*(AudioUnit *)(a1 + 72), 0x3Bu, 0, 0, (AudioUnitParameterValue *)(v20 + 32));
              v22 = a6[3];
              if ((unint64_t)(a6[4] - v22) > 0x24)
              {
                AudioUnitGetParameter(*(AudioUnit *)(a1 + 72), 0x37u, 0, 0, (AudioUnitParameterValue *)(v22 + 36));
                v23 = (float *)a6[3];
                v24 = a6[4] - (_QWORD)v23;
                if (v24 > 0x10)
                {
                  v25 = 0.0;
                  v26 = *v23 <= 0.5 ? 0.0 : 1.0;
                  v23[4] = v26;
                  if (v24 > 0x20)
                  {
                    if (v23[2] > v23[8])
                      v25 = 1.0;
                    v23[5] = v25;
                    if (v24 > 0x24)
                    {
                      v27 = 0.0;
                      if (v23[3] > v23[9])
                        v27 = 1.0;
                      v23[6] = v27;
                      v28 = (double *)a6[7];
                      v29 = a6[8] - (_QWORD)v28;
                      if (v29)
                      {
                        v30 = *(double *)(a1 + 40) * a4[1];
                        v31 = v30 + 0.0;
                        *v28 = v30 + 0.0;
                        v28[1] = (v30 + 0.0) / *(double *)(a1 + 40);
                        if (v29 > 0x10)
                        {
                          v28[2] = v31;
                          v28[3] = v31 / *(double *)(a1 + 40);
                          if (v29 > 0x20)
                          {
                            v28[4] = v31;
                            v28[5] = v31 / *(double *)(a1 + 40);
                            if (v29 > 0x30)
                            {
                              v28[6] = v31;
                              v28[7] = v31 / *(double *)(a1 + 40);
                              if (v29 > 0x70)
                              {
                                v28[14] = v30;
                                v28[15] = v30 / *(double *)(a1 + 40);
                                if (v29 > 0x80)
                                {
                                  v28[16] = v30;
                                  v28[17] = v30 / *(double *)(a1 + 40);
                                  if (v29 > 0x90)
                                  {
                                    v12 = 0;
                                    v28[18] = v30;
                                    v28[19] = v30 / *(double *)(a1 + 40);
                                    v28[8] = v31;
                                    v28[9] = v31 / *(double *)(a1 + 40);
                                    v28[10] = v31;
                                    v28[11] = v31 / *(double *)(a1 + 40);
                                    v28[12] = v31;
                                    v28[13] = v31 / *(double *)(a1 + 40);
                                    ++*(_DWORD *)(a1 + 12);
                                    return v12;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
LABEL_47:
                __assert_rtn("operator[]", "FeatureTimeSeries.h", 91, "index < mArray.size()");
              }
            }
          }
        }
      }
    }
    __assert_rtn("PointerAt", "FeatureTimeSeries.h", 70, "index < mArray.size()");
  }
  v12 = v14;
  if (EndpointVAD2LogScope(void)::once != -1)
    dispatch_once(&EndpointVAD2LogScope(void)::once, &__block_literal_global_5);
  if (EndpointVAD2LogScope(void)::scope)
  {
    v13 = *(NSObject **)EndpointVAD2LogScope(void)::scope;
    if (!*(_QWORD *)EndpointVAD2LogScope(void)::scope)
      return v12;
  }
  else
  {
    v13 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    v36 = "ULDATFeaturesChain.cpp";
    v37 = 1024;
    v38 = 367;
    v15 = "%25s:%-5d AGC failed to process.";
    goto LABEL_45;
  }
  return v12;
}

uint64_t ULDATFeaturesChain::GetInputAudioFormat(uint64_t a1, void *outData)
{
  UInt32 ioDataSize;

  ioDataSize = 40;
  return AudioUnitGetProperty(*(AudioUnit *)(a1 + 64), 8u, 1u, 0, outData, &ioDataSize);
}

uint64_t ULDATFeaturesChain::GetNumSuperFeatures(ULDATFeaturesChain *this)
{
  return 3;
}

void ULDATFeaturesChain::GetSuperFeatureDimensions(int a1, std::vector<unsigned int> *this)
{
  unsigned int *end;

  std::vector<unsigned int>::resize(this, 3uLL);
  end = this->__end_;
  if (this->__begin_ != end)
    memset_pattern16(this->__begin_, &unk_1B66A2A20, (((char *)end - (char *)this->__begin_ - 4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
}

double FeaturesDSPChain::InitializeInputOutputBufferSizes(uint64_t a1, _QWORD *a2, CFDictionaryRef theDict, int a4)
{
  void *v8;
  const __CFNumber *Value;
  const __CFNumber *v10;
  const __CFNumber *v11;
  unint64_t v12;
  double result;

  v8 = (void *)(a1 + 32);
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("AudioSampleRateHz"));
  CFNumberGetValue(Value, kCFNumberFloat64Type, v8);
  *a2 = *(_QWORD *)(a1 + 32);
  v10 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("AudioBufferSizeSamples"));
  CFNumberGetValue(v10, kCFNumberSInt32Type, (void *)(a1 + 16));
  v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("AudioAnalysisSizeSamples"));
  CFNumberGetValue(v11, kCFNumberSInt32Type, (void *)(a1 + 20));
  *(_DWORD *)(a1 + 24) = a4;
  LODWORD(v12) = *(_DWORD *)(a1 + 16);
  result = *(double *)(a1 + 32) / (double)v12;
  *(double *)(a1 + 40) = result;
  return result;
}

float **DistanceEstimator::processBufferList(DistanceEstimator *this, const AudioBufferList *a2, const AudioBufferList *a3, AudioBufferList *a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t mNumberBuffers;
  float v11;
  uint64_t v12;
  void **p_mData;
  void **v14;
  float *v15;
  float *v16;
  uint64_t v17;
  float *v18;
  float *v19;
  unsigned int v20;
  float v21;
  float *v22;
  uint64_t v23;
  float v24;
  uint64_t v25;
  float v26;
  unsigned int v27;
  void *v28;
  int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  float **result;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  DSPSplitComplex v43;
  DSPSplitComplex __A;
  float v45;
  float __B;

  if (a4->mNumberBuffers)
  {
    v8 = 0;
    v9 = 16;
    do
    {
      memcpy(*(void **)((char *)&a4->mNumberBuffers + v9), *(const void **)((char *)&a2->mNumberBuffers + v9), 4 * (2 * *((_DWORD *)this + 2)));
      ++v8;
      v9 += 16;
    }
    while (v8 < a4->mNumberBuffers);
  }
  mNumberBuffers = a2->mNumberBuffers;
  v11 = *((float *)this + 8) * *((float *)this + 8);
  v45 = *((float *)this + 9) * *((float *)this + 9);
  __B = v11;
  vDSP_vclr(*((float **)this + 8), 1, (*((_DWORD *)this + 12) * mNumberBuffers));
  vDSP_vclr(*((float **)this + 11), 1, (*((_DWORD *)this + 12) * mNumberBuffers));
  if ((_DWORD)mNumberBuffers)
  {
    v12 = 0;
    p_mData = &a3->mBuffers[0].mData;
    v14 = &a2->mBuffers[0].mData;
    do
    {
      v16 = (float *)*v14;
      v14 += 2;
      v15 = v16;
      v17 = *((unsigned int *)this + 2);
      v18 = &v16[v17];
      v19 = (float *)*p_mData;
      p_mData += 2;
      __A.realp = v15 + 1;
      __A.imagp = v18 + 1;
      v20 = *((_DWORD *)this + 12) * v12;
      v21 = *v15 * *v15;
      v22 = &v19[v17];
      v23 = *((_QWORD *)this + 8);
      *(float *)(v23 + 4 * v20) = v21;
      v24 = *v19;
      v43.realp = v19 + 1;
      v25 = *((_QWORD *)this + 11);
      *(float *)(v25 + 4 * v20) = v24 * v24;
      v26 = *v18 * *v18;
      LODWORD(v18) = v20 + v17;
      *(float *)(v23 + 4 * v18) = v26;
      *(float *)&v19 = *v22;
      v43.imagp = v22 + 1;
      v27 = v20 + 1;
      *(float *)(v25 + 4 * v18) = *(float *)&v19 * *(float *)&v19;
      vDSP_zvmags(&__A, 1, (float *)(v23 + 4 * (v20 + 1)), 1, (v17 - 1));
      vDSP_zvmags(&v43, 1, (float *)(*((_QWORD *)this + 11) + 4 * v27), 1, (*((_DWORD *)this + 2) - 1));
      ++v12;
    }
    while (mNumberBuffers != v12);
  }
  vDSP_vsmul(*((const float **)this + 8), 1, &__B, *((float **)this + 8), 1, (*((_DWORD *)this + 12) * mNumberBuffers));
  vDSP_vsmul(*((const float **)this + 11), 1, &v45, *((float **)this + 11), 1, (*((_DWORD *)this + 12) * mNumberBuffers));
  v28 = (void *)*((_QWORD *)this + 14);
  if (*((float *)this + 6) <= 0.0)
  {
    memcpy(v28, *((const void **)this + 8), 4 * (*((_DWORD *)this + 12) * mNumberBuffers));
    memcpy(*((void **)this + 17), *((const void **)this + 11), 4 * (*((_DWORD *)this + 12) * mNumberBuffers));
  }
  else
  {
    vDSP_vsmsma((const float *)v28, 1, (const float *)this + 6, *((const float **)this + 8), 1, (const float *)this + 7, (float *)v28, 1, (*((_DWORD *)this + 12) * mNumberBuffers));
    vDSP_vsmsma(*((const float **)this + 17), 1, (const float *)this + 6, *((const float **)this + 11), 1, (const float *)this + 7, *((float **)this + 17), 1, (*((_DWORD *)this + 12) * mNumberBuffers));
  }
  vDSP_vclr(*((float **)this + 28), 1, *((unsigned int *)this + 62));
  if ((_DWORD)mNumberBuffers)
  {
    v29 = 0;
    do
    {
      v30 = *((_DWORD *)this + 13);
      v31 = *((_DWORD *)this + 12) * v29;
      v32 = v30 * (mNumberBuffers + v29);
      sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 7), (const float *)(*((_QWORD *)this + 14) + 4 * v31), 1, (float *)(*((_QWORD *)this + 28) + 4 * (v30 * v29)), 1);
      sparse_matrix_vector_product_dense_float(CblasNoTrans, 1.0, *((sparse_matrix_float *)this + 7), (const float *)(*((_QWORD *)this + 17) + 4 * v31), 1, (float *)(*((_QWORD *)this + 28) + 4 * v32), 1);
      ++v29;
    }
    while ((_DWORD)mNumberBuffers != v29);
    vDSP_vthr(*((const float **)this + 28), 1, (const float *)this + 10, *((float **)this + 28), 1, *((unsigned int *)this + 62));
    v33 = 0;
    LODWORD(__A.realp) = 2 * *((_DWORD *)this + 13);
    do
    {
      vvlogf((float *)(*((_QWORD *)this + 28) + 4 * (LODWORD(__A.realp) * v33)), (const float *)(*((_QWORD *)this + 28) + 4 * (LODWORD(__A.realp) * v33)), (const int *)&__A);
      ++v33;
    }
    while ((_DWORD)mNumberBuffers != v33);
  }
  else
  {
    vDSP_vthr(*((const float **)this + 28), 1, (const float *)this + 10, *((float **)this + 28), 1, *((unsigned int *)this + 62));
    LODWORD(__A.realp) = 2 * *((_DWORD *)this + 13);
  }
  result = (float **)(*(uint64_t (**)(_QWORD, char *))(***((_QWORD ***)this + 32) + 72))(**((_QWORD **)this + 32), (char *)this + 224);
  v35 = **result;
  *((float *)this + 49) = v35;
  if (*((float *)this + 11) <= 0.0)
  {
    v42 = *((float *)this + 53);
    if (*((_BYTE *)this + 216))
    {
      v42 = v42 + 1.0;
      *((float *)this + 53) = v42;
    }
    if (v42 > (float)*((unsigned int *)this + 52))
    {
      *((_DWORD *)this + 53) = 0;
      *((_WORD *)this + 108) = 256;
    }
  }
  else
  {
    *((_DWORD *)this + 53) = 0;
    *((_WORD *)this + 108) = 1;
    v36 = *((float *)this + 50);
    v37 = *((float *)this + 41);
    v38 = *((float *)this + 40) + *((float *)this + 47);
    *((float *)this + 42) = v38;
    *((float *)this + 43) = v35 - v36;
    v39 = v38 / (float)((float)(v38 + v37) + *((float *)this + 10));
    *((float *)this + 44) = v38 + v37;
    *((float *)this + 45) = v39;
    v40 = v36 + (float)(v39 * (float)(v35 - v36));
    v41 = (float)(v37 * (float)(v39 * v39)) + (float)((float)((float)(1.0 - v39) * (float)(1.0 - v39)) * v38);
    *((float *)this + 46) = v40;
    *((float *)this + 47) = v41;
    *((float *)this + 48) = v35 - v40;
    *((float *)this + 50) = v40;
    *((float *)this + 51) = v41;
  }
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBoostClip>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x298uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBoostClip>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBoostClip>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSoftClip>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x298uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSoftClip>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSoftClip>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolume>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2A0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolume>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolume>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSpatialMap>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x508uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSpatialMap>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSpatialMap>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeakerProtectionV2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x370uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeakerProtectionV2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeakerProtectionV2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeakerProtectionV3>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x5A0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeakerProtectionV3>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeakerProtectionV3>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeam2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0xB18uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeam2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeam2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeamNF>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0xAC8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeamNF>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeamNF>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeamNFSelector>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x580uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeamNFSelector>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeamNFSelector>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMixSwitch>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x290uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMixSwitch>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMixSwitch>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMixSwitchNF>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2C0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMixSwitchNF>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMixSwitchNF>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUFIRFilter>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2C0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUFIRFilter>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUFIRFilter>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDereverb>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x478uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDereverb>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDereverb>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDenoise>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x528uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDenoise>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDenoise>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNetRES>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x410uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNetRES>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNetRES>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNetSPP>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x458uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNetSPP>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNetSPP>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNet>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x5C0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNet>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNet>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNetVAD>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x348uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNetVAD>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNeuralNetVAD>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSeparate>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x300uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSeparate>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSeparate>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpatialProbability>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x400uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpatialProbability>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpatialProbability>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDistance>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2D8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDistance>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDistance>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeamIt>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x4B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeamIt>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBeamIt>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNFNSwitch>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2E8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNFNSwitch>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNFNSwitch>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUWindKill>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x648uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUWindKill>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUWindKill>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUFTSpatialAC>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x1530uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUFTSpatialAC>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUFTSpatialAC>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudnessInNoise>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x12E8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudnessInNoise>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudnessInNoise>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULevelDrivenSuppressor>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x758uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULevelDrivenSuppressor>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULevelDrivenSuppressor>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCNG>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x258uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCNG>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCNG>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<AUAuxVPLookup,AUAuxVPUplink>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x260uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = AUAuxVPLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<AUAuxVPLookup,AUAuxVPUplink>::Construct;
  result[5] = ausdk::APFactory<AUAuxVPLookup,AUAuxVPUplink>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<AUAuxVPLookup,AUAuxVPDownlink>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x260uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = AUAuxVPLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<AUAuxVPLookup,AUAuxVPDownlink>::Construct;
  result[5] = ausdk::APFactory<AUAuxVPLookup,AUAuxVPDownlink>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCPMSVolumeV1>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCPMSVolumeV1>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCPMSVolumeV1>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUAGCV2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x298uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUAGCV2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUAGCV2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULinearEchoCancelerV3>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x340uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULinearEchoCancelerV3>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULinearEchoCancelerV3>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMultiChanEchoCanceler>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x360uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMultiChanEchoCanceler>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMultiChanEchoCanceler>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEchoCancelerV5>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2F8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEchoCancelerV5>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEchoCancelerV5>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMIMO>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x350uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMIMO>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMIMO>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECSUMO>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x390uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECSUMO>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECSUMO>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECRMGS>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2A8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECRMGS>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECRMGS>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECRMDF>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x320uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECRMDF>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECRMDF>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMicRef>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x360uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMicRef>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMicRef>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUTTYEchoSuppressor>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x300uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUTTYEchoSuppressor>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUTTYEchoSuppressor>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSubBandMultEchoCanceler>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0xED0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSubBandMultEchoCanceler>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSubBandMultEchoCanceler>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUOneChannelNS>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUOneChannelNS>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUOneChannelNS>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUOneChannelNSV4>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUOneChannelNSV4>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUOneChannelNSV4>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUOneChannelNoiseEstimator>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2B0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUOneChannelNoiseEstimator>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUOneChannelNoiseEstimator>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeechLevelEstimator>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x320uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeechLevelEstimator>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeechLevelEstimator>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUResidualEchoSuppressorV3>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x278uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUResidualEchoSuppressorV3>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUResidualEchoSuppressorV3>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUResidualEchoSuppressorV4>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x280uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUResidualEchoSuppressorV4>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUResidualEchoSuppressorV4>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUResidualEchoSuppressorV5>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x308uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUResidualEchoSuppressorV5>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUResidualEchoSuppressorV5>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEchoGateV3>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x378uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEchoGateV3>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEchoGateV3>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolumeCompressorV2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x738uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolumeCompressorV2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolumeCompressorV2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDeesser>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x3E8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDeesser>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDeesser>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSelectorV2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x5D0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSelectorV2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSelectorV2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressor>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x268uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressor>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressor>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressorV4>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x268uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressorV4>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressorV4>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS1>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x328uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS1>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS1>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x300uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHandsetNoiseEQ>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2A0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHandsetNoiseEQ>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHandsetNoiseEQ>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNoiseSelector>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2A0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNoiseSelector>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNoiseSelector>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReverbSuppressor>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x1308uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReverbSuppressor>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReverbSuppressor>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMultiBandDynamicsProcessorV2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x620uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMultiBandDynamicsProcessorV2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMultiBandDynamicsProcessorV2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDynamicDucker>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x368uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDynamicDucker>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDynamicDucker>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDynamicDuckerV2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x5B0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDynamicDuckerV2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDynamicDuckerV2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUAnomalyDetection>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x278uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUAnomalyDetection>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUAnomalyDetection>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVariableEQV2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x568uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVariableEQV2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVariableEQV2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMNBandEQ>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x348uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMNBandEQ>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMNBandEQ>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReferenceSignalMixer>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2E8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReferenceSignalMixer>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReferenceSignalMixer>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AURotationShading>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2C8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AURotationShading>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AURotationShading>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUEarPlug>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2A0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUEarPlug>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUEarPlug>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDCBlocker>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x298uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDCBlocker>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDCBlocker>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUTweakaLeakIR>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x4C0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUTweakaLeakIR>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUTweakaLeakIR>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDecorrelator>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2C0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDecorrelator>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDecorrelator>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDSPGraph>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x480uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDSPGraph>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDSPGraph>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMatrixPatcher>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x290uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMatrixPatcher>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMatrixPatcher>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUFIREngine>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0xB80uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUFIREngine>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUFIREngine>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCarter>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x3B0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCarter>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCarter>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULando>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x268uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULando>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULando>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUScotty>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x338uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUScotty>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUScotty>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCircArray>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0xC00uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCircArray>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCircArray>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessWarrior>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0xB40uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessWarrior>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessWarrior>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHapticsProtection>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x320uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHapticsProtection>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHapticsProtection>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUFixedGain>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x270uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUFixedGain>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUFixedGain>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUChannelSpecificDelay>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x910uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUChannelSpecificDelay>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUChannelSpecificDelay>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpatialCapture>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x410uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpatialCapture>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpatialCapture>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHOAZoom>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2D0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHOAZoom>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHOAZoom>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSense>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x318uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSense>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSense>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMultiChannelAGC>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x318uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMultiChannelAGC>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMultiChannelAGC>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUChannelSelector>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x300uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUChannelSelector>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUChannelSelector>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMidSide>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x268uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMidSide>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMidSide>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeechEnhancer>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2E8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeechEnhancer>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeechEnhancer>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHearingLossCompensator>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2E8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHearingLossCompensator>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHearingLossCompensator>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULimitWindBoost>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x430uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULimitWindBoost>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULimitWindBoost>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUClipDetector>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x288uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUClipDetector>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUClipDetector>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUExpanseController>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x280uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUExpanseController>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUExpanseController>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSignalCombiner>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x690uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSignalCombiner>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSignalCombiner>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicIssueDetector>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x388uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicIssueDetector>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicIssueDetector>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUControlFreak>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUControlFreak>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUControlFreak>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBuzzKill>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBuzzKill>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBuzzKill>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVirtualBass>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVirtualBass>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVirtualBass>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,BassKoenig>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8C0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,BassKoenig>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,BassKoenig>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBassQueen>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBassQueen>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBassQueen>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AULowFlow>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8C8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULowFlow>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULowFlow>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMeisterStueck>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x1250uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMeisterStueck>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMeisterStueck>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUToneMeister>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x1180uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUToneMeister>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUToneMeister>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessMeter>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessMeter>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessMeter>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMozartCompressorSingleBand>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMozartCompressorSingleBand>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMozartCompressorSingleBand>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AULittleLateNightMode>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2C0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULittleLateNightMode>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULittleLateNightMode>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUPeakPowerGuard>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8C0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUPeakPowerGuard>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUPeakPowerGuard>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUThermalSpeakerProtection>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUThermalSpeakerProtection>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUThermalSpeakerProtection>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUXTC>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x13C0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUXTC>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUXTC>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessAndMultipleLookup,AULoudnessNormalizer>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8B8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessAndMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessAndMultipleLookup,AULoudnessNormalizer>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessAndMultipleLookup,AULoudnessNormalizer>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManager>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8E0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManager>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManager>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManagerV2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x998uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManagerV2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManagerV2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudspeakerSystemIDV2>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8F8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudspeakerSystemIDV2>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudspeakerSystemIDV2>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolumeTaper>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x8E8uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolumeTaper>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolumeTaper>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUAmbienceLeveler>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x980uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUAmbienceLeveler>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUAmbienceLeveler>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMixGainCompensation>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x260uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMixGainCompensation>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMixGainCompensation>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSilenceNonFiniteAnalyzer>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x2A0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSilenceNonFiniteAnalyzer>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSilenceNonFiniteAnalyzer>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEcConvergenceOversight>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x918uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEcConvergenceOversight>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEcConvergenceOversight>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMIMOHelper>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x360uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMIMOHelper>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMIMOHelper>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSPLMeter>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x308uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSPLMeter>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSPLMeter>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCrossCorrelator>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x3D0uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCrossCorrelator>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCrossCorrelator>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUADAMSink>::Factory()
{
  _QWORD *result;

  result = malloc_type_malloc(0x270uLL, 0xB0CA1167uLL);
  *result = ausdk::ComponentBase::AP_Open;
  result[1] = ausdk::ComponentBase::AP_Close;
  result[2] = ausdk::AUBaseProcessMultipleLookup::Lookup;
  result[3] = 0;
  result[4] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUADAMSink>::Construct;
  result[5] = ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUADAMSink>::Destruct;
  result[6] = 0;
  result[7] = 0;
  return result;
}

ausdk::AUBase *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUADAMSink>::Construct(ausdk::AUBase *a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  unsigned __int8 v4;
  NSObject *v5;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase(a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69DBDC0;
  *((_QWORD *)v3 + 66) = 561211748;
  *((_BYTE *)v3 + 536) = 0;
  *((_BYTE *)v3 + 540) = 0;
  *((_QWORD *)v3 + 68) = 0;
  *((_BYTE *)v3 + 552) = 0;
  {
    AU::ADAMSink::get_log(void)::auadam_os_log = (uint64_t)os_log_create("com.apple.coreaudio", "AUADAMSink");
  }
  v5 = AU::ADAMSink::get_log(void)::auadam_os_log;
  if (os_log_type_enabled((os_log_t)AU::ADAMSink::get_log(void)::auadam_os_log, OS_LOG_TYPE_INFO))
  {
    v7 = 136315394;
    v8 = "AUADAMSink.cpp";
    v9 = 1024;
    v10 = 31;
    _os_log_impl(&dword_1B5ED0000, v5, OS_LOG_TYPE_INFO, "%s:%-5d created", (uint8_t *)&v7, 0x12u);
  }
  return a1;
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCrossCorrelator>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t Element;
  unsigned int i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  _QWORD *v16;
  _OWORD *v17;
  BOOL v18;
  uint64_t v20;
  _OWORD v21[2];

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69E88A8;
  *((_BYTE *)v3 + 528) = 0;
  *(_OWORD *)((char *)v3 + 532) = 0u;
  *(_OWORD *)((char *)v3 + 548) = 0u;
  *(_OWORD *)((char *)v3 + 564) = 0u;
  *(_OWORD *)((char *)v3 + 580) = 0u;
  *(_OWORD *)((char *)v3 + 600) = 0u;
  *(_OWORD *)((char *)v3 + 616) = 0u;
  *(_OWORD *)((char *)v3 + 632) = 0u;
  *(_OWORD *)((char *)v3 + 648) = 0u;
  *(_OWORD *)((char *)v3 + 664) = 0u;
  *(_OWORD *)((char *)v3 + 680) = xmmword_1B6687B2C;
  *(_OWORD *)((char *)v3 + 696) = unk_1B6687B3C;
  *(_OWORD *)((char *)v3 + 712) = 0u;
  *(_OWORD *)((char *)v3 + 728) = 0u;
  *((_BYTE *)v3 + 744) = 1;
  *((_DWORD *)v3 + 188) = 0;
  *((_DWORD *)v3 + 187) = 0;
  *((_DWORD *)v3 + 210) = 0;
  *(_OWORD *)((char *)v3 + 824) = 0u;
  *((_OWORD *)v3 + 53) = 0u;
  *((_OWORD *)v3 + 54) = 0u;
  *((_DWORD *)v3 + 220) = 0;
  *((_QWORD *)v3 + 113) = 0;
  *(_OWORD *)((char *)v3 + 888) = 0u;
  *(_OWORD *)((char *)v3 + 760) = 0u;
  *(_OWORD *)((char *)v3 + 776) = 0u;
  *(_OWORD *)((char *)v3 + 792) = 0u;
  *(_OWORD *)((char *)v3 + 804) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v4 = 0;
  v20 = 0x408F400000000000;
  v21[0] = xmmword_1B6626900;
  v21[1] = xmmword_1B6626910;
  while (1)
  {
    v5 = a1[15];
    if (v5)
      LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    else
      v6 = (a1[13] - a1[12]) >> 3;
    if (v4 >= v6)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), v4);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v20);
    ++v4;
  }
  for (i = 0; ; ++i)
  {
    v9 = a1[21];
    if (v9)
      LODWORD(v10) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    else
      v10 = (a1[19] - a1[18]) >> 3;
    if (i >= v10)
      break;
    v11 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v11 + 56))(v11, &v20);
  }
  getParameterInfo(&v20);
  v12 = v20;
  if ((_OWORD *)v20 != v21)
  {
    do
    {
      v13 = 0;
      v14 = *(unsigned int *)(v12 + 32);
      v15 = *(float *)(v12 + 132);
      while (v13 < *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), 0) + 108))
      {
        (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, _QWORD, float))(*a1 + 152))(a1, v14, 4, v13, 0, v15);
        v13 = (v13 + 1);
      }
      v16 = *(_QWORD **)(v12 + 8);
      if (v16)
      {
        do
        {
          v17 = v16;
          v16 = (_QWORD *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          v17 = *(_OWORD **)(v12 + 16);
          v18 = *(_QWORD *)v17 == v12;
          v12 = (uint64_t)v17;
        }
        while (!v18);
      }
      v12 = (uint64_t)v17;
    }
    while (v17 != v21);
  }
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*(_QWORD **)&v21[0]);
  return a1;
}

void sub_1B61C171C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  CrossCorrelator *v10;
  void **v11;
  _QWORD **v12;
  uint64_t *v13;
  uint64_t v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  _QWORD *v19;

  v15 = *v13;
  *v13 = 0;
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  a9 = (void **)(v9 + 848);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a9);
  v16 = *v12;
  *v12 = 0;
  if (v16)
    std::default_delete<CADeprecated::CABufferList>::operator()[abi:ne180100](v16);
  CrossCorrelator::~CrossCorrelator(v10);
  v17 = *(void **)(v9 + 624);
  if (v17)
  {
    *(_QWORD *)(v9 + 632) = v17;
    operator delete(v17);
  }
  v18 = *v11;
  if (*v11)
  {
    *(_QWORD *)(v9 + 608) = v18;
    operator delete(v18);
  }
  v19 = *(_QWORD **)(v9 + 584);
  *(_QWORD *)(v9 + 584) = 0;
  if (v19)
    std::default_delete<CADeprecated::CABufferList>::operator()[abi:ne180100](v19);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v9);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUCrossCorrelator>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSPLMeter>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  char *v4;
  char *v5;
  float *v6;
  float *v7;
  float *v8;
  float v9;
  float *v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float *v16;
  OpaqueAudioComponent *Next;
  _DWORD *exception;
  _DWORD *v20;
  _DWORD *v21;
  int v22;
  const char *v23;
  __int16 v24;
  int v25;
  _BYTE inDesc[32];
  __int128 v27;
  __int128 v28;
  int v29;
  _BYTE v30[12];

  *(_QWORD *)&v30[4] = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69CA820;
  *((_BYTE *)v3 + 528) = 0;
  *(_OWORD *)((char *)v3 + 532) = 0u;
  *((_BYTE *)v3 + 548) = 1;
  *((_DWORD *)v3 + 138) = 0;
  *((_BYTE *)v3 + 556) = 0;
  *((_DWORD *)v3 + 140) = 0;
  *((_BYTE *)v3 + 564) = 0;
  *((_DWORD *)v3 + 148) = 0;
  *((_BYTE *)v3 + 596) = 0;
  v4 = (char *)v3 + 600;
  v5 = (char *)v3 + 624;
  *(_OWORD *)((char *)v3 + 568) = 0u;
  *(_QWORD *)((char *)v3 + 581) = 0;
  *(_OWORD *)((char *)v3 + 600) = 0u;
  *(_OWORD *)((char *)v3 + 616) = 0u;
  *(_OWORD *)((char *)v3 + 632) = 0u;
  *(_OWORD *)((char *)v3 + 648) = 0u;
  *((_QWORD *)v3 + 83) = 0;
  std::vector<float *>::vector((_QWORD *)v3 + 84, 0x20uLL);
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)inDesc = xmmword_1B6639820;
  *(_OWORD *)&inDesc[16] = unk_1B6639830;
  v27 = xmmword_1B6639840;
  v28 = unk_1B6639850;
  v29 = 0;
  std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v4, inDesc, (uint64_t)v30, 0x11uLL);
  *(_OWORD *)inDesc = xmmword_1B6639864;
  *(_OWORD *)&inDesc[16] = unk_1B6639874;
  v27 = xmmword_1B6639884;
  v28 = unk_1B6639894;
  v29 = 0;
  std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v5, inDesc, (uint64_t)v30, 0x11uLL);
  v6 = *(float **)(a1 + 608);
  v7 = *(float **)(a1 + 600);
  if ((char *)v6 - (char *)v7 != *(_QWORD *)(a1 + 632) - *(_QWORD *)(a1 + 624))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)inDesc = 136315394;
      *(_QWORD *)&inDesc[4] = "AUSPLMeter.cpp";
      *(_WORD *)&inDesc[12] = 1024;
      *(_DWORD *)&inDesc[14] = 166;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  Volume curve steps must match", inDesc, 0x12u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E69EE218;
    exception[2] = 2003329396;
  }
  if (v7 != v6)
  {
    v8 = v7 + 1;
    if (v7 + 1 != v6)
    {
      v9 = *v7;
      v10 = v7 + 1;
      do
      {
        v11 = *v10++;
        v12 = v11;
        if (v11 < v9)
        {
          v9 = v12;
          v7 = v8;
        }
        v8 = v10;
      }
      while (v10 != v6);
    }
  }
  *(float *)(a1 + 576) = *v7;
  v13 = *(_QWORD *)(a1 + 72);
  if (v13)
    v14 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  else
    v14 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 40))(v14, 13);
  v15 = 0;
  v16 = (float *)&dword_1E69CAABC;
  do
  {
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, v15++, 0, 0, 0, *v16);
    v16 += 26;
  }
  while (v15 != 13);
  *(_DWORD *)&inDesc[16] = 0;
  *(_OWORD *)inDesc = *(_OWORD *)"xfua2qrvlppa";
  Next = AudioComponentFindNext(0, (const AudioComponentDescription *)inDesc);
  if (!Next)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v22 = 136315394;
      v23 = "AUSPLMeter.cpp";
      v24 = 1024;
      v25 = 177;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  Unable to instantiate VarEQ AU", (uint8_t *)&v22, 0x12u);
    }
    v20 = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)v20 = &off_1E69EE218;
    v20[2] = 2003329396;
  }
  if (AudioComponentInstanceNew(Next, (AudioComponentInstance *)(a1 + 696)))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v22 = 136315394;
      v23 = "AUSPLMeter.cpp";
      v24 = 1024;
      v25 = 179;
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  Unable to instantiate VarEQ AU", (uint8_t *)&v22, 0x12u);
    }
    v21 = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)v21 = &off_1E69EE218;
    v21[2] = 2003329396;
  }
  return a1;
}

void sub_1B61C1BF4(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  void **v2;
  void **v3;
  void **v4;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;

  v6 = *((_QWORD *)v1 + 88);
  *((_QWORD *)v1 + 88) = 0;
  if (v6)
    std::default_delete<CA::AudioBuffers>::operator()[abi:ne180100]();
  v7 = *v4;
  if (*v4)
  {
    *((_QWORD *)v1 + 85) = v7;
    operator delete(v7);
  }
  v8 = *((_QWORD *)v1 + 83);
  *((_QWORD *)v1 + 83) = 0;
  if (v8)
    std::default_delete<LoudnessMeter>::operator()[abi:ne180100](v8);
  v9 = *((_QWORD *)v1 + 82);
  *((_QWORD *)v1 + 82) = 0;
  if (v9)
    std::default_delete<LoudnessMeter>::operator()[abi:ne180100](v9);
  v10 = *((_QWORD *)v1 + 81);
  *((_QWORD *)v1 + 81) = 0;
  if (v10)
    std::default_delete<LoudnessMeter>::operator()[abi:ne180100](v10);
  v11 = *v3;
  if (*v3)
  {
    *((_QWORD *)v1 + 79) = v11;
    operator delete(v11);
  }
  v12 = *v2;
  if (*v2)
  {
    *((_QWORD *)v1 + 76) = v12;
    operator delete(v12);
  }
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSPLMeter>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMIMOHelper>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _OWORD *v3;
  ausdk::AUBase *v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Element;
  unsigned int i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  uint64_t v33;
  ausdk::AUElement *v34;
  ausdk::AUElement **v35;
  uint64_t v36;
  ausdk::AUElement *v37;
  ausdk::AUElement **v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  ausdk::AUElement **v44;
  uint64_t v45;
  ausdk::AUElement *v46;
  ausdk::AUElement **v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  ausdk::AUElement **v50;
  uint64_t v51;
  ausdk::AUElement *v52;
  ausdk::AUElement **v53;
  uint64_t v54;
  ausdk::AUElement *v55;
  ausdk::AUElement **v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  ausdk::AUElement **v59;
  uint64_t v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  __int128 v65;
  __int128 v66;

  v3 = (_OWORD *)(a1 + 580);
  v4 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 2, 1);
  *(_QWORD *)v4 = &off_1E69D97E0;
  *((_OWORD *)v4 + 33) = xmmword_1B66A0AF0;
  *((_OWORD *)v4 + 34) = xmmword_1B66A0B00;
  *((_OWORD *)v4 + 35) = xmmword_1B66A0B10;
  *((_BYTE *)v4 + 576) = 0;
  *v3 = xmmword_1B66A0B20;
  *((_BYTE *)v4 + 596) = 1;
  *(_OWORD *)((char *)v3 + 20) = xmmword_1B66A0B30;
  *((_DWORD *)v4 + 154) = 1028443341;
  *(_OWORD *)((char *)v4 + 620) = 0u;
  *(_OWORD *)((char *)v4 + 636) = 0u;
  *(_OWORD *)((char *)v4 + 652) = 0u;
  *(_OWORD *)((char *)v4 + 668) = 0u;
  *(_OWORD *)((char *)v4 + 684) = 0u;
  *(_QWORD *)((char *)v4 + 700) = 0;
  *(_OWORD *)((char *)v4 + 712) = 0u;
  *(_OWORD *)((char *)v4 + 728) = 0u;
  *(_OWORD *)((char *)v4 + 744) = 0u;
  *(_OWORD *)((char *)v4 + 760) = 0u;
  *(_OWORD *)((char *)v4 + 776) = 0u;
  *((_DWORD *)v4 + 198) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v4);
  v5 = 0;
  v64 = 0x40D7700000000000;
  v65 = xmmword_1B6626900;
  v66 = xmmword_1B66A0820;
  v61 = 0x40D7700000000000;
  v62 = xmmword_1B6626900;
  v63 = xmmword_1B6626910;
  while (1)
  {
    v6 = *(_QWORD *)(a1 + 120);
    if (v6)
      LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
    else
      v7 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v5 >= v7)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v5);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v64);
    ++v5;
  }
  for (i = 0; ; ++i)
  {
    v10 = *(_QWORD *)(a1 + 168);
    if (v10)
      LODWORD(v11) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    else
      v11 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v11)
      break;
    v12 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v12 + 56))(v12, &v61);
  }
  v13 = *(_QWORD *)(a1 + 72);
  if (v13)
    v14 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  else
    v14 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 40))(v14, 15);
  v15 = *(_QWORD *)(a1 + 72);
  if (v15)
  {
    v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
  }
  else
  {
    v17 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v17)
      v16 = 0;
    else
      v16 = *v17;
  }
  ausdk::AUElement::SetParameter(v16, 0, 160.0, 0);
  v18 = *(_QWORD *)(a1 + 72);
  if (v18)
  {
    v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
  }
  else
  {
    v20 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v20)
      v19 = 0;
    else
      v19 = *v20;
  }
  ausdk::AUElement::SetParameter(v19, 1u, 0.0, 0);
  v21 = *(_QWORD *)(a1 + 72);
  if (v21)
  {
    v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
  }
  else
  {
    v23 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v23)
      v22 = 0;
    else
      v22 = *v23;
  }
  ausdk::AUElement::SetParameter(v22, 2u, 0.0, 0);
  v24 = *(_QWORD *)(a1 + 72);
  if (v24)
  {
    v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
  }
  else
  {
    v26 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v26)
      v25 = 0;
    else
      v25 = *v26;
  }
  ausdk::AUElement::SetParameter(v25, 3u, 0.0, 0);
  v27 = *(_QWORD *)(a1 + 72);
  if (v27)
  {
    v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
  }
  else
  {
    v29 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v29)
      v28 = 0;
    else
      v28 = *v29;
  }
  ausdk::AUElement::SetParameter(v28, 4u, 160.0, 0);
  v30 = *(_QWORD *)(a1 + 72);
  if (v30)
  {
    v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
  }
  else
  {
    v32 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v32)
      v31 = 0;
    else
      v31 = *v32;
  }
  ausdk::AUElement::SetParameter(v31, 5u, 0.95, 0);
  v33 = *(_QWORD *)(a1 + 72);
  if (v33)
  {
    v34 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v33 + 32))(v33, 0);
  }
  else
  {
    v35 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v35)
      v34 = 0;
    else
      v34 = *v35;
  }
  ausdk::AUElement::SetParameter(v34, 6u, 0.05, 0);
  v36 = *(_QWORD *)(a1 + 72);
  if (v36)
  {
    v37 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v36 + 32))(v36, 0);
  }
  else
  {
    v38 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v38)
      v37 = 0;
    else
      v37 = *v38;
  }
  ausdk::AUElement::SetParameter(v37, 7u, 0.0, 0);
  v39 = *(_QWORD *)(a1 + 72);
  if (v39)
  {
    v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
  }
  else
  {
    v41 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v41)
      v40 = 0;
    else
      v40 = *v41;
  }
  ausdk::AUElement::SetParameter(v40, 0xAu, 0.95, 0);
  v42 = *(_QWORD *)(a1 + 72);
  if (v42)
  {
    v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v42 + 32))(v42, 0);
  }
  else
  {
    v44 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v44)
      v43 = 0;
    else
      v43 = *v44;
  }
  ausdk::AUElement::SetParameter(v43, 0xBu, 0.95, 0);
  v45 = *(_QWORD *)(a1 + 72);
  if (v45)
  {
    v46 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v45 + 32))(v45, 0);
  }
  else
  {
    v47 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v47)
      v46 = 0;
    else
      v46 = *v47;
  }
  ausdk::AUElement::SetParameter(v46, 0xCu, 0.28, 0);
  v48 = *(_QWORD *)(a1 + 72);
  if (v48)
  {
    v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v48 + 32))(v48, 0);
  }
  else
  {
    v50 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v50)
      v49 = 0;
    else
      v49 = *v50;
  }
  ausdk::AUElement::SetParameter(v49, 9u, 1.0, 0);
  v51 = *(_QWORD *)(a1 + 72);
  if (v51)
  {
    v52 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v51 + 32))(v51, 0);
  }
  else
  {
    v53 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v53)
      v52 = 0;
    else
      v52 = *v53;
  }
  ausdk::AUElement::SetParameter(v52, 8u, 0.0, 0);
  v54 = *(_QWORD *)(a1 + 72);
  if (v54)
  {
    v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v54 + 32))(v54, 0);
  }
  else
  {
    v56 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v56)
      v55 = 0;
    else
      v55 = *v56;
  }
  ausdk::AUElement::SetParameter(v55, 0xDu, 100.0, 0);
  v57 = *(_QWORD *)(a1 + 72);
  if (v57)
  {
    v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v57 + 32))(v57, 0);
  }
  else
  {
    v59 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v59)
      v58 = 0;
    else
      v58 = *v59;
  }
  ausdk::AUElement::SetParameter(v58, 0xEu, -200.0, 0);
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 512);
  return a1;
}

void sub_1B61C22C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  void **v11;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  a10 = (void **)(v10 + 760);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a10);
  v13 = *(void **)(v10 + 736);
  if (v13)
  {
    *(_QWORD *)(v10 + 744) = v13;
    operator delete(v13);
  }
  v14 = *v11;
  if (*v11)
  {
    *(_QWORD *)(v10 + 720) = v14;
    operator delete(v14);
  }
  v15 = *(void **)(v10 + 672);
  if (v15)
  {
    *(_QWORD *)(v10 + 680) = v15;
    operator delete(v15);
  }
  v16 = *(void **)(v10 + 648);
  if (v16)
  {
    *(_QWORD *)(v10 + 656) = v16;
    operator delete(v16);
  }
  a10 = (void **)(v10 + 624);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a10);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v10);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUECMIMOHelper>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEcConvergenceOversight>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _OWORD *v3;
  ausdk::AUBase *v4;
  __int128 v5;
  _OWORD *v6;
  _OWORD *v7;
  _OWORD *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Element;
  unsigned int i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  uint64_t v25;
  ausdk::AUElement *v26;
  ausdk::AUElement **v27;
  uint64_t v28;
  ausdk::AUElement *v29;
  ausdk::AUElement **v30;
  uint64_t v31;
  ausdk::AUElement *v32;
  ausdk::AUElement **v33;
  uint64_t v34;
  ausdk::AUElement *v35;
  ausdk::AUElement **v36;
  uint64_t v37;
  ausdk::AUElement *v38;
  ausdk::AUElement **v39;
  uint64_t v40;
  ausdk::AUElement *v41;
  ausdk::AUElement **v42;
  uint64_t v43;
  ausdk::AUElement *v44;
  ausdk::AUElement **v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  ausdk::AUElement **v48;
  uint64_t v49;
  ausdk::AUElement *v50;
  ausdk::AUElement **v51;
  uint64_t v52;
  ausdk::AUElement *v53;
  ausdk::AUElement **v54;
  uint64_t v55;
  ausdk::AUElement *v56;
  ausdk::AUElement **v57;
  uint64_t v58;
  ausdk::AUElement *v59;
  ausdk::AUElement **v60;
  uint64_t v61;
  ausdk::AUElement *v62;
  ausdk::AUElement **v63;
  uint64_t v64;
  ausdk::AUElement *v65;
  ausdk::AUElement **v66;
  uint64_t v67;
  ausdk::AUElement *v68;
  ausdk::AUElement **v69;
  uint64_t v70;
  ausdk::AUElement *v71;
  ausdk::AUElement **v72;
  uint64_t v73;
  ausdk::AUElement *v74;
  ausdk::AUElement **v75;
  uint64_t v76;
  ausdk::AUElement *v77;
  ausdk::AUElement **v78;
  uint64_t v79;
  ausdk::AUElement *v80;
  ausdk::AUElement **v81;
  uint64_t v82;
  ausdk::AUElement *v83;
  ausdk::AUElement **v84;
  uint64_t v85;
  ausdk::AUElement *v86;
  ausdk::AUElement **v87;
  uint64_t v88;
  ausdk::AUElement *v89;
  ausdk::AUElement **v90;
  uint64_t v91;
  ausdk::AUElement *v92;
  ausdk::AUElement **v93;
  uint64_t v94;
  ausdk::AUElement *v95;
  ausdk::AUElement **v96;
  uint64_t v97;
  ausdk::AUElement *v98;
  ausdk::AUElement **v99;
  uint64_t v100;
  ausdk::AUElement *v101;
  ausdk::AUElement **v102;
  uint64_t v103;
  ausdk::AUElement *v104;
  ausdk::AUElement **v105;
  uint64_t v106;
  ausdk::AUElement *v107;
  ausdk::AUElement **v108;
  uint64_t v109;
  ausdk::AUElement *v110;
  ausdk::AUElement **v111;
  uint64_t v112;
  ausdk::AUElement *v113;
  ausdk::AUElement **v114;
  uint64_t v115;
  ausdk::AUElement *v116;
  ausdk::AUElement **v117;
  uint64_t v118;
  ausdk::AUElement *v119;
  ausdk::AUElement **v120;
  uint64_t v121;
  ausdk::AUElement *v122;
  ausdk::AUElement **v123;
  uint64_t v124;
  ausdk::AUElement *v125;
  ausdk::AUElement **v126;
  uint64_t v127;
  ausdk::AUElement *v128;
  ausdk::AUElement **v129;
  uint64_t v130;
  ausdk::AUElement *v131;
  ausdk::AUElement **v132;
  uint64_t v133;
  ausdk::AUElement *v134;
  ausdk::AUElement **v135;
  uint64_t v136;
  ausdk::AUElement *v137;
  ausdk::AUElement **v138;
  uint64_t v139;
  ausdk::AUElement *v140;
  ausdk::AUElement **v141;
  uint64_t v142;
  ausdk::AUElement *v143;
  ausdk::AUElement **v144;
  uint64_t v145;
  ausdk::AUElement *v146;
  ausdk::AUElement **v147;
  uint64_t v149;
  __int128 v150;
  __int128 v151;

  v3 = (_OWORD *)(a1 + 572);
  v4 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 3, 1);
  *(_QWORD *)v4 = &off_1E69E1D28;
  *((_QWORD *)v4 + 66) = 0;
  *(_QWORD *)((char *)v4 + 533) = 0;
  *((_QWORD *)v4 + 68) = 0x6447A0000;
  *((_QWORD *)v4 + 69) = 0x600000006;
  *((_BYTE *)v4 + 560) = 1;
  *(_QWORD *)((char *)v4 + 564) = 0x600000001;
  *v3 = xmmword_1B66A0B40;
  *((_DWORD *)v4 + 147) = 0x40000000;
  *(_QWORD *)&v5 = 0x100000001;
  *((_QWORD *)&v5 + 1) = 0x100000001;
  *((_OWORD *)v4 + 37) = v5;
  *((_DWORD *)v4 + 152) = 1;
  *((_WORD *)v4 + 306) = 0;
  *((_QWORD *)v4 + 77) = 0;
  *((_DWORD *)v4 + 180) = 0;
  v6 = (_OWORD *)((char *)v4 + 728);
  LOBYTE(v5) = 0;
  BYTE4(v5) = 0;
  BYTE8(v5) = 0;
  BYTE12(v5) = 0;
  *(_OWORD *)((char *)v4 + 728) = v5;
  *((_DWORD *)v4 + 186) = 1065353216;
  *((_QWORD *)v4 + 100) = 0x43FA000042480000;
  *((_DWORD *)v4 + 202) = 1;
  v3[21] = xmmword_1B66A0B50;
  v3[22] = xmmword_1B66A0B60;
  *((_DWORD *)v4 + 352) = 0;
  *((_WORD *)v4 + 918) = 0;
  *((_BYTE *)v4 + 1838) = 0;
  *((_QWORD *)v4 + 232) = 0;
  *((_OWORD *)v4 + 115) = v5;
  *((_DWORD *)v4 + 466) = 507307272;
  *((_WORD *)v4 + 934) = 0;
  *((_OWORD *)v4 + 117) = v5;
  *((_OWORD *)v4 + 118) = xmmword_1B66A0B70;
  *((_OWORD *)v4 + 120) = v5;
  *((_OWORD *)v4 + 121) = v5;
  *((_OWORD *)v4 + 122) = xmmword_1B66A0B80;
  *((_QWORD *)v4 + 246) = 0x200000001;
  v7 = (_OWORD *)((char *)v4 + 1976);
  *(_OWORD *)((char *)v4 + 1976) = xmmword_1B66A0B90;
  *((_DWORD *)v4 + 501) = 0;
  *((_QWORD *)v4 + 249) = 0;
  *((_BYTE *)v4 + 2000) = 0;
  *((_QWORD *)v4 + 251) = 0x1E0000003C0;
  *((_DWORD *)v4 + 504) = 0;
  *((_QWORD *)v4 + 271) = 0;
  *((_DWORD *)v4 + 544) = 1;
  v8 = (_OWORD *)((char *)v4 + 2184);
  *(_OWORD *)((char *)v4 + 2248) = v5;
  *((_DWORD *)v4 + 554) = 0;
  *(_OWORD *)((char *)v4 + 2184) = v5;
  *(_OWORD *)((char *)v4 + 2200) = v5;
  ausdk::AUBase::CreateElements((int64x2_t *)v4);
  v9 = 0;
  v149 = 0x408F400000000000;
  v150 = xmmword_1B6626900;
  v151 = xmmword_1B6626910;
  while (1)
  {
    v10 = *(_QWORD *)(a1 + 120);
    if (v10)
      LODWORD(v11) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    else
      v11 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v9 >= v11)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v9);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v149);
    ++v9;
  }
  for (i = 0; ; ++i)
  {
    v14 = *(_QWORD *)(a1 + 168);
    if (v14)
      LODWORD(v15) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
    else
      v15 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v15)
      break;
    v16 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v16 + 56))(v16, &v149);
  }
  v17 = *(_QWORD *)(a1 + 72);
  if (v17)
    v18 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 32))(v17, 0);
  else
    v18 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v18 + 40))(v18, 43);
  v19 = *(_QWORD *)(a1 + 72);
  if (v19)
  {
    v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
  }
  else
  {
    v21 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v21)
      v20 = 0;
    else
      v20 = *v21;
  }
  ausdk::AUElement::SetParameter(v20, 0, 0.0, 0);
  v22 = *(_QWORD *)(a1 + 72);
  if (v22)
  {
    v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
  }
  else
  {
    v24 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v24)
      v23 = 0;
    else
      v23 = *v24;
  }
  ausdk::AUElement::SetParameter(v23, 1u, 0.0, 0);
  v25 = *(_QWORD *)(a1 + 72);
  if (v25)
  {
    v26 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, 0);
  }
  else
  {
    v27 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v27)
      v26 = 0;
    else
      v26 = *v27;
  }
  ausdk::AUElement::SetParameter(v26, 2u, 0.0, 0);
  v28 = *(_QWORD *)(a1 + 72);
  if (v28)
  {
    v29 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 32))(v28, 0);
  }
  else
  {
    v30 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v30)
      v29 = 0;
    else
      v29 = *v30;
  }
  ausdk::AUElement::SetParameter(v29, 3u, 0.0, 0);
  v31 = *(_QWORD *)(a1 + 72);
  if (v31)
  {
    v32 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v31 + 32))(v31, 0);
  }
  else
  {
    v33 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v33)
      v32 = 0;
    else
      v32 = *v33;
  }
  ausdk::AUElement::SetParameter(v32, 4u, 1.0, 0);
  v34 = *(_QWORD *)(a1 + 72);
  if (v34)
  {
    v35 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v34 + 32))(v34, 0);
  }
  else
  {
    v36 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v36)
      v35 = 0;
    else
      v35 = *v36;
  }
  ausdk::AUElement::SetParameter(v35, 5u, 6.0, 0);
  v37 = *(_QWORD *)(a1 + 72);
  if (v37)
  {
    v38 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v37 + 32))(v37, 0);
  }
  else
  {
    v39 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v39)
      v38 = 0;
    else
      v38 = *v39;
  }
  ausdk::AUElement::SetParameter(v38, 6u, 4.0, 0);
  v40 = *(_QWORD *)(a1 + 72);
  if (v40)
  {
    v41 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v40 + 32))(v40, 0);
  }
  else
  {
    v42 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v42)
      v41 = 0;
    else
      v41 = *v42;
  }
  ausdk::AUElement::SetParameter(v41, 7u, 50.0, 0);
  v43 = *(_QWORD *)(a1 + 72);
  if (v43)
  {
    v44 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v43 + 32))(v43, 0);
  }
  else
  {
    v45 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v45)
      v44 = 0;
    else
      v44 = *v45;
  }
  ausdk::AUElement::SetParameter(v44, 8u, 300.0, 0);
  v46 = *(_QWORD *)(a1 + 72);
  if (v46)
  {
    v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 0);
  }
  else
  {
    v48 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v48)
      v47 = 0;
    else
      v47 = *v48;
  }
  ausdk::AUElement::SetParameter(v47, 0xBu, -70.0, 0);
  v49 = *(_QWORD *)(a1 + 72);
  if (v49)
  {
    v50 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v49 + 32))(v49, 0);
  }
  else
  {
    v51 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v51)
      v50 = 0;
    else
      v50 = *v51;
  }
  ausdk::AUElement::SetParameter(v50, 0xCu, -65.0, 0);
  v52 = *(_QWORD *)(a1 + 72);
  if (v52)
  {
    v53 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v52 + 32))(v52, 0);
  }
  else
  {
    v54 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v54)
      v53 = 0;
    else
      v53 = *v54;
  }
  ausdk::AUElement::SetParameter(v53, 9u, -20.0, 0);
  v55 = *(_QWORD *)(a1 + 72);
  if (v55)
  {
    v56 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v55 + 32))(v55, 0);
  }
  else
  {
    v57 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v57)
      v56 = 0;
    else
      v56 = *v57;
  }
  ausdk::AUElement::SetParameter(v56, 0xAu, -12.0, 0);
  v58 = *(_QWORD *)(a1 + 72);
  if (v58)
  {
    v59 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v58 + 32))(v58, 0);
  }
  else
  {
    v60 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v60)
      v59 = 0;
    else
      v59 = *v60;
  }
  ausdk::AUElement::SetParameter(v59, 0xDu, 0.2, 0);
  v61 = *(_QWORD *)(a1 + 72);
  if (v61)
  {
    v62 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v61 + 32))(v61, 0);
  }
  else
  {
    v63 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v63)
      v62 = 0;
    else
      v62 = *v63;
  }
  ausdk::AUElement::SetParameter(v62, 0xEu, 6.0, 0);
  v64 = *(_QWORD *)(a1 + 72);
  if (v64)
  {
    v65 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v64 + 32))(v64, 0);
  }
  else
  {
    v66 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v66)
      v65 = 0;
    else
      v65 = *v66;
  }
  ausdk::AUElement::SetParameter(v65, 0xFu, 4.0, 0);
  v67 = *(_QWORD *)(a1 + 72);
  if (v67)
  {
    v68 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v67 + 32))(v67, 0);
  }
  else
  {
    v69 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v69)
      v68 = 0;
    else
      v68 = *v69;
  }
  ausdk::AUElement::SetParameter(v68, 0x10u, 4.0, 0);
  v70 = *(_QWORD *)(a1 + 72);
  if (v70)
  {
    v71 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v70 + 32))(v70, 0);
  }
  else
  {
    v72 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v72)
      v71 = 0;
    else
      v71 = *v72;
  }
  ausdk::AUElement::SetParameter(v71, 0x11u, 4.0, 0);
  v73 = *(_QWORD *)(a1 + 72);
  if (v73)
  {
    v74 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v73 + 32))(v73, 0);
  }
  else
  {
    v75 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v75)
      v74 = 0;
    else
      v74 = *v75;
  }
  ausdk::AUElement::SetParameter(v74, 0x12u, 90.0, 0);
  v76 = *(_QWORD *)(a1 + 72);
  if (v76)
  {
    v77 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v76 + 32))(v76, 0);
  }
  else
  {
    v78 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v78)
      v77 = 0;
    else
      v77 = *v78;
  }
  ausdk::AUElement::SetParameter(v77, 0x13u, 80.0, 0);
  v79 = *(_QWORD *)(a1 + 72);
  if (v79)
  {
    v80 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v79 + 32))(v79, 0);
  }
  else
  {
    v81 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v81)
      v80 = 0;
    else
      v80 = *v81;
  }
  ausdk::AUElement::SetParameter(v80, 0x14u, 70.0, 0);
  v82 = *(_QWORD *)(a1 + 72);
  if (v82)
  {
    v83 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v82 + 32))(v82, 0);
  }
  else
  {
    v84 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v84)
      v83 = 0;
    else
      v83 = *v84;
  }
  ausdk::AUElement::SetParameter(v83, 0x15u, -65.0, 0);
  v85 = *(_QWORD *)(a1 + 72);
  if (v85)
  {
    v86 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v85 + 32))(v85, 0);
  }
  else
  {
    v87 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v87)
      v86 = 0;
    else
      v86 = *v87;
  }
  ausdk::AUElement::SetParameter(v86, 0x16u, 200.0, 0);
  v88 = *(_QWORD *)(a1 + 72);
  if (v88)
  {
    v89 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v88 + 32))(v88, 0);
  }
  else
  {
    v90 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v90)
      v89 = 0;
    else
      v89 = *v90;
  }
  ausdk::AUElement::SetParameter(v89, 0x17u, -200.0, 0);
  v91 = *(_QWORD *)(a1 + 72);
  if (v91)
  {
    v92 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v91 + 32))(v91, 0);
  }
  else
  {
    v93 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v93)
      v92 = 0;
    else
      v92 = *v93;
  }
  ausdk::AUElement::SetParameter(v92, 0x18u, 35.0, 0);
  v94 = *(_QWORD *)(a1 + 72);
  if (v94)
  {
    v95 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v94 + 32))(v94, 0);
  }
  else
  {
    v96 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v96)
      v95 = 0;
    else
      v95 = *v96;
  }
  ausdk::AUElement::SetParameter(v95, 0x19u, 60.0, 0);
  v97 = *(_QWORD *)(a1 + 72);
  if (v97)
  {
    v98 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v97 + 32))(v97, 0);
  }
  else
  {
    v99 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v99)
      v98 = 0;
    else
      v98 = *v99;
  }
  ausdk::AUElement::SetParameter(v98, 0x1Au, 2.0, 0);
  v100 = *(_QWORD *)(a1 + 72);
  if (v100)
  {
    v101 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v100 + 32))(v100, 0);
  }
  else
  {
    v102 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v102)
      v101 = 0;
    else
      v101 = *v102;
  }
  ausdk::AUElement::SetParameter(v101, 0x1Bu, 4.0, 0);
  v103 = *(_QWORD *)(a1 + 72);
  if (v103)
  {
    v104 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v103 + 32))(v103, 0);
  }
  else
  {
    v105 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v105)
      v104 = 0;
    else
      v104 = *v105;
  }
  ausdk::AUElement::SetParameter(v104, 0x1Cu, 0.0, 0);
  v106 = *(_QWORD *)(a1 + 72);
  if (v106)
  {
    v107 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v106 + 32))(v106, 0);
  }
  else
  {
    v108 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v108)
      v107 = 0;
    else
      v107 = *v108;
  }
  ausdk::AUElement::SetParameter(v107, 0x1Du, 1024.0, 0);
  v109 = *(_QWORD *)(a1 + 72);
  if (v109)
  {
    v110 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v109 + 32))(v109, 0);
  }
  else
  {
    v111 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v111)
      v110 = 0;
    else
      v110 = *v111;
  }
  ausdk::AUElement::SetParameter(v110, 0x1Eu, 80.0, 0);
  v112 = *(_QWORD *)(a1 + 72);
  if (v112)
  {
    v113 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v112 + 32))(v112, 0);
  }
  else
  {
    v114 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v114)
      v113 = 0;
    else
      v113 = *v114;
  }
  ausdk::AUElement::SetParameter(v113, 0x1Fu, 200.0, 0);
  v115 = *(_QWORD *)(a1 + 72);
  if (v115)
  {
    v116 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v115 + 32))(v115, 0);
  }
  else
  {
    v117 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v117)
      v116 = 0;
    else
      v116 = *v117;
  }
  ausdk::AUElement::SetParameter(v116, 0x20u, 350.0, 0);
  v118 = *(_QWORD *)(a1 + 72);
  if (v118)
  {
    v119 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v118 + 32))(v118, 0);
  }
  else
  {
    v120 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v120)
      v119 = 0;
    else
      v119 = *v120;
  }
  ausdk::AUElement::SetParameter(v119, 0x21u, 0.85, 0);
  v121 = *(_QWORD *)(a1 + 72);
  if (v121)
  {
    v122 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v121 + 32))(v121, 0);
  }
  else
  {
    v123 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v123)
      v122 = 0;
    else
      v122 = *v123;
  }
  ausdk::AUElement::SetParameter(v122, 0x22u, 7.25, 0);
  v124 = *(_QWORD *)(a1 + 72);
  if (v124)
  {
    v125 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v124 + 32))(v124, 0);
  }
  else
  {
    v126 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v126)
      v125 = 0;
    else
      v125 = *v126;
  }
  ausdk::AUElement::SetParameter(v125, 0x23u, 6.75, 0);
  v127 = *(_QWORD *)(a1 + 72);
  if (v127)
  {
    v128 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v127 + 32))(v127, 0);
  }
  else
  {
    v129 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v129)
      v128 = 0;
    else
      v128 = *v129;
  }
  ausdk::AUElement::SetParameter(v128, 0x24u, 5.75, 0);
  v130 = *(_QWORD *)(a1 + 72);
  if (v130)
  {
    v131 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v130 + 32))(v130, 0);
  }
  else
  {
    v132 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v132)
      v131 = 0;
    else
      v131 = *v132;
  }
  ausdk::AUElement::SetParameter(v131, 0x25u, 0.0, 0);
  v133 = *(_QWORD *)(a1 + 72);
  if (v133)
  {
    v134 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v133 + 32))(v133, 0);
  }
  else
  {
    v135 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v135)
      v134 = 0;
    else
      v134 = *v135;
  }
  ausdk::AUElement::SetParameter(v134, 0x26u, 0.0, 0);
  v136 = *(_QWORD *)(a1 + 72);
  if (v136)
  {
    v137 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v136 + 32))(v136, 0);
  }
  else
  {
    v138 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v138)
      v137 = 0;
    else
      v137 = *v138;
  }
  ausdk::AUElement::SetParameter(v137, 0x27u, 0.0, 0);
  v139 = *(_QWORD *)(a1 + 72);
  if (v139)
  {
    v140 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v139 + 32))(v139, 0);
  }
  else
  {
    v141 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v141)
      v140 = 0;
    else
      v140 = *v141;
  }
  ausdk::AUElement::SetParameter(v140, 0x28u, 0.0, 0);
  v142 = *(_QWORD *)(a1 + 72);
  if (v142)
  {
    v143 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v142 + 32))(v142, 0);
  }
  else
  {
    v144 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v144)
      v143 = 0;
    else
      v143 = *v144;
  }
  ausdk::AUElement::SetParameter(v143, 0x29u, 0.0, 0);
  v145 = *(_QWORD *)(a1 + 72);
  if (v145)
  {
    v146 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v145 + 32))(v145, 0);
  }
  else
  {
    v147 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v147)
      v146 = 0;
    else
      v146 = *v147;
  }
  ausdk::AUElement::SetParameter(v146, 0x2Au, 0.0, 0);
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 32);
  *(_BYTE *)(a1 + 540) = 0;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_QWORD *)(a1 + 712) = 0;
  *v6 = 0u;
  *(_OWORD *)(a1 + 1144) = 0u;
  *(_OWORD *)(a1 + 1160) = 0u;
  *(_OWORD *)(a1 + 1176) = 0u;
  *(_OWORD *)(a1 + 1192) = 0u;
  *(_OWORD *)(a1 + 1208) = 0u;
  *(_OWORD *)(a1 + 1224) = 0u;
  *(_OWORD *)(a1 + 1240) = 0u;
  *(_OWORD *)(a1 + 1256) = 0u;
  *(_OWORD *)(a1 + 1272) = 0u;
  *(_OWORD *)(a1 + 1392) = 0u;
  *(_OWORD *)(a1 + 1376) = 0u;
  *(_OWORD *)(a1 + 1360) = 0u;
  *(_OWORD *)(a1 + 1344) = 0u;
  *(_OWORD *)(a1 + 1328) = 0u;
  *(_OWORD *)(a1 + 1312) = 0u;
  *(_DWORD *)(a1 + 1864) = 507307272;
  *(_QWORD *)(a1 + 532) = 0;
  *(_WORD *)(a1 + 1868) = 0;
  *(_QWORD *)(a1 + 1888) = 0x20000000400;
  *(_DWORD *)(a1 + 1896) = 1;
  *(_OWORD *)(a1 + 1904) = 0u;
  *(_OWORD *)(a1 + 1920) = 0u;
  *(_OWORD *)(a1 + 1936) = 0u;
  *(_OWORD *)(a1 + 1952) = xmmword_1B66A0B80;
  *(_QWORD *)(a1 + 1968) = 0x100000001;
  *v7 = xmmword_1B66A0BA0;
  *(_QWORD *)(a1 + 1992) = 0;
  *(_QWORD *)(a1 + 2008) = 0x1E0000003C0;
  *(_DWORD *)(a1 + 2016) = 928;
  *(_QWORD *)(a1 + 2168) = 0;
  *(_DWORD *)(a1 + 2176) = 1;
  *(_BYTE *)(a1 + 2000) = 0;
  *(_DWORD *)(a1 + 2004) = 0;
  *(_QWORD *)(a1 + 2236) = 0;
  *(_OWORD *)(a1 + 2220) = 0u;
  *(_OWORD *)(a1 + 2024) = 0u;
  *(_OWORD *)(a1 + 2040) = 0u;
  *(_OWORD *)(a1 + 2056) = 0u;
  *(_OWORD *)(a1 + 2072) = 0u;
  *(_OWORD *)(a1 + 2088) = 0u;
  *(_OWORD *)(a1 + 2104) = 0u;
  *(_OWORD *)(a1 + 2120) = 0u;
  *(_OWORD *)(a1 + 2136) = 0u;
  *(_OWORD *)(a1 + 2152) = 0u;
  *v8 = 0u;
  v8[1] = 0u;
  return a1;
}

void sub_1B61C32B8(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  uint64_t v2;

  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100]((uint64_t)v1 + 1872);
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUEcConvergenceOversight>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSilenceNonFiniteAnalyzer>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  ausdk::AUElement *v7;
  ausdk::AUElement **v8;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  uint64_t v12;
  ausdk::AUElement *v13;
  ausdk::AUElement **v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69ED018;
  *((_DWORD *)v3 + 132) = 0;
  *(_DWORD *)((char *)v3 + 531) = 0;
  *(_OWORD *)((char *)v3 + 536) = 0u;
  *((_QWORD *)v3 + 69) = 0xBF80000000000000;
  *((_OWORD *)v3 + 35) = 0u;
  *((_OWORD *)v3 + 36) = 0u;
  *((_OWORD *)v3 + 37) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  else
    v5 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, 7);
  v6 = *(_QWORD *)(a1 + 72);
  if (v6)
  {
    v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
  }
  else
  {
    v8 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v8)
      v7 = 0;
    else
      v7 = *v8;
  }
  ausdk::AUElement::SetParameter(v7, 0, 0.0, 0);
  v9 = *(_QWORD *)(a1 + 72);
  if (v9)
  {
    v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
  }
  else
  {
    v11 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v11)
      v10 = 0;
    else
      v10 = *v11;
  }
  ausdk::AUElement::SetParameter(v10, 1u, 0.0, 0);
  v12 = *(_QWORD *)(a1 + 72);
  if (v12)
  {
    v13 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, 0);
  }
  else
  {
    v14 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v14)
      v13 = 0;
    else
      v13 = *v14;
  }
  ausdk::AUElement::SetParameter(v13, 2u, 0.0, 0);
  v15 = *(_QWORD *)(a1 + 72);
  if (v15)
  {
    v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
  }
  else
  {
    v17 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v17)
      v16 = 0;
    else
      v16 = *v17;
  }
  ausdk::AUElement::SetParameter(v16, 3u, 0.0, 0);
  v18 = *(_QWORD *)(a1 + 72);
  if (v18)
  {
    v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
  }
  else
  {
    v20 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v20)
      v19 = 0;
    else
      v19 = *v20;
  }
  ausdk::AUElement::SetParameter(v19, 6u, -1.0, 0);
  v21 = *(_QWORD *)(a1 + 72);
  if (v21)
  {
    v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
  }
  else
  {
    v23 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v23)
      v22 = 0;
    else
      v22 = *v23;
  }
  ausdk::AUElement::SetParameter(v22, 4u, 0.0, 0);
  v24 = *(_QWORD *)(a1 + 72);
  if (v24)
  {
    v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
  }
  else
  {
    v26 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v26)
      v25 = 0;
    else
      v25 = *v26;
  }
  ausdk::AUElement::SetParameter(v25, 5u, 0.0, 0);
  return a1;
}

void sub_1B61C3568(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;

  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUSilenceNonFiniteAnalyzer>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMixGainCompensation>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  ausdk::AUElement *v7;
  ausdk::AUElement **v8;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69C5D98;
  *((_BYTE *)v3 + 528) = 0;
  *(_QWORD *)((char *)v3 + 532) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  else
    v5 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, 2);
  v6 = *(_QWORD *)(a1 + 72);
  if (v6)
  {
    v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
  }
  else
  {
    v8 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v8)
      v7 = 0;
    else
      v7 = *v8;
  }
  ausdk::AUElement::SetParameter(v7, 0, 0.0, 0);
  v9 = *(_QWORD *)(a1 + 72);
  if (v9)
  {
    v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
  }
  else
  {
    v11 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v11)
      v10 = 0;
    else
      v10 = *v11;
  }
  ausdk::AUElement::SetParameter(v10, 1u, 0.0, 0);
  return a1;
}

void sub_1B61C368C(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;

  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUAmbienceLeveler>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  int64x2_t *v3;
  char *v4;
  _DWORD *v5;
  char *v6;
  _QWORD *v7;
  ausdk::AUElement *Element;

  v3 = AUDspLibWithNewParameters::AUDspLibWithNewParameters((int64x2_t *)a1, a2, (uint64_t)&DspLib::kBubbleParameterConverters, (int64x2_t *)&DspLib::AmbienceLeveler::Parameters::kSystemDefinition, (uint64_t)CFSTR("AUAmbienceLeveler_ViewFactory"));
  v3->i64[0] = (uint64_t)&off_1E69C6768;
  v3[137].i64[1] = 0;
  v3[138].i64[1] = 0;
  v3[138].i64[0] = 0;
  v4 = (char *)operator new(0x94uLL);
  *(_QWORD *)(a1 + 2200) = v4;
  *(_QWORD *)(a1 + 2216) = v4 + 148;
  qmemcpy(v4, "fphaf1baG1baQ1baf2baG2baQ2baf3baG3baQ3baf4baG4baQ4bafphdf1bdG1bdQ1bdf2bdG2bdQ2bdf3bdG3bdQ3bdfphbf1bbG1bbQ1bbf2bbG2bbQ2bbf3bbG3bbQ3bbf4bbG4bbQ4bbQEva", 148);
  *(_QWORD *)(a1 + 2208) = v4 + 148;
  *(_QWORD *)(a1 + 2224) = 0;
  *(_QWORD *)(a1 + 2240) = 0;
  *(_QWORD *)(a1 + 2232) = 0;
  v5 = operator new(0x94uLL);
  *(_QWORD *)(a1 + 2224) = v5;
  *(_QWORD *)(a1 + 2240) = v5 + 37;
  v5[36] = 0;
  *((_OWORD *)v5 + 6) = xmmword_1B662FC9C;
  *((_OWORD *)v5 + 7) = unk_1B662FCAC;
  *((_OWORD *)v5 + 8) = xmmword_1B662FCBC;
  *((_OWORD *)v5 + 2) = xmmword_1B662FC5C;
  *((_OWORD *)v5 + 3) = unk_1B662FC6C;
  *((_OWORD *)v5 + 4) = xmmword_1B662FC7C;
  *((_OWORD *)v5 + 5) = unk_1B662FC8C;
  *(_OWORD *)v5 = *(_OWORD *)"";
  *((_OWORD *)v5 + 1) = unk_1B662FC4C;
  *(_QWORD *)(a1 + 2232) = v5 + 37;
  *(_QWORD *)(a1 + 2248) = 0;
  *(_QWORD *)(a1 + 2264) = 0;
  *(_QWORD *)(a1 + 2256) = 0;
  v6 = (char *)operator new(0x1CuLL);
  *(_QWORD *)(a1 + 2248) = v6;
  *(_QWORD *)(a1 + 2264) = v6 + 28;
  qmemcpy(v6, "evaGravGevaSravSevaAravASmun", 28);
  *(_QWORD *)(a1 + 2256) = v6 + 28;
  *(_QWORD *)(a1 + 2272) = 0;
  *(_QWORD *)(a1 + 2288) = 0;
  *(_QWORD *)(a1 + 2280) = 0;
  v7 = operator new(0x1CuLL);
  *(_QWORD *)(a1 + 2272) = v7;
  *(_QWORD *)(a1 + 2288) = (char *)v7 + 28;
  v7[1] = 0;
  v7[2] = 0;
  *v7 = 0;
  *((_DWORD *)v7 + 6) = 0;
  *(_QWORD *)(a1 + 2280) = (char *)v7 + 28;
  *(_QWORD *)(a1 + 2360) = 0;
  *(_OWORD *)(a1 + 2296) = 0u;
  *(_OWORD *)(a1 + 2312) = 0u;
  *(_OWORD *)(a1 + 2328) = 0u;
  *(_OWORD *)(a1 + 2344) = 0u;
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(Element, 0x64u, 0.0, 0);
  return a1;
}

void sub_1B61C384C(_Unwind_Exception *a1)
{
  AUDspLib *v1;
  void *v3;
  void *v4;
  void *v5;

  v3 = (void *)*((_QWORD *)v1 + 281);
  if (v3)
  {
    *((_QWORD *)v1 + 282) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)v1 + 278);
  if (v4)
  {
    *((_QWORD *)v1 + 279) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)v1 + 275);
  if (v5)
  {
    *((_QWORD *)v1 + 276) = v5;
    operator delete(v5);
  }
  AUDspLib::~AUDspLib(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUAmbienceLeveler>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

int64x2_t *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolumeTaper>::Construct(int64x2_t *a1, OpaqueAudioComponentInstance *a2)
{
  int64x2_t *v3;
  ausdk::AUScope *v4;
  ausdk::AUElement *Element;
  ausdk::AUElement *v6;
  ausdk::AUElement *v7;

  v3 = AUDspLibWithNewParameters::AUDspLibWithNewParameters(a1, a2, (uint64_t)&DspLib::kBubbleParameterConverters, (int64x2_t *)&DspLib::VolumeTaper::Parameters::kSystemDefinition, (uint64_t)CFSTR("AUVolumeTaper_ViewFactory"));
  v3->i64[0] = (uint64_t)&off_1E69E96D8;
  v3[138].i64[0] = 0;
  v4 = (ausdk::AUScope *)&v3[2];
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&v3[2], 0);
  ausdk::AUElement::SetParameter(Element, 0x64u, 0.0, 0);
  v6 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v4, 0);
  ausdk::AUElement::SetParameter(v6, 0x65u, 0.0, 0);
  v7 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v4, 0);
  ausdk::AUElement::SetParameter(v7, 0x66u, 0.0, 0);
  return a1;
}

void sub_1B61C39AC(_Unwind_Exception *a1)
{
  id *v1;

  AUDspLib::~AUDspLib((AUDspLib *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolumeTaper>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

int64x2_t *ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudspeakerSystemIDV2>::Construct(int64x2_t *a1, OpaqueAudioComponentInstance *a2)
{
  int64x2_t *v3;
  ausdk::AUElement *Element;

  v3 = AUDspLibWithNewParameters::AUDspLibWithNewParameters(a1, a2, (uint64_t)&DspLib::kBubbleParameterConverters, (int64x2_t *)&DspLib::LoudspeakerSystemIDV2::Parameters::kSystemDefinition, (uint64_t)CFSTR("AULoudspeakerSystemIDV2ViewFactory"));
  v3->i64[0] = (uint64_t)&off_1E69E9B00;
  v3[137].i8[8] = 0;
  v3[139].i8[0] = 0;
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&v3[2], 0);
  ausdk::AUElement::SetParameter(Element, 0x40000000u, 0.0, 0);
  return a1;
}

void sub_1B61C3A40(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  if (*(_BYTE *)(v1 + 2224))
  {
    v3 = *(void **)(v1 + 2200);
    if (v3)
    {
      *(_QWORD *)(v1 + 2208) = v3;
      operator delete(v3);
    }
  }
  AUDspLib::~AUDspLib((AUDspLib *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudspeakerSystemIDV2>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

int64x2_t *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManagerV2>::Construct(int64x2_t *a1, OpaqueAudioComponentInstance *a2)
{
  int64x2_t *v3;
  ausdk::AUElement *Element;
  ausdk::AUElement *v5;
  CFTypeRef cf;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;
  char v13;
  CFTypeRef v14;
  char v15;
  char v16;
  char v17;
  char v18;
  char v19;
  char v20;
  CFTypeRef v21;
  char v22;
  char v23;
  char v24;
  char v25;
  char v26;
  char v27;

  v3 = AUDspLibWithNewParameters::AUDspLibWithNewParameters(a1, a2, (uint64_t)&DspLib::kBubbleParameterConverters, (int64x2_t *)&DspLib::LoudspeakerManagerV2::Parameters::kSystemDefinition, (uint64_t)CFSTR("AULoudspeakerManagerV2_ViewFactory"));
  v3->i64[0] = (uint64_t)&off_1E69E0418;
  *(int64x2_t *)((char *)&v3[137] + 8) = 0u;
  *(int64x2_t *)((char *)&v3[138] + 8) = 0u;
  *(int64x2_t *)((char *)&v3[139] + 8) = (int64x2_t)xmmword_1B66A0BB0;
  v3[140].i32[2] = 1112014848;
  v3[140].i8[12] = 0;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v3[141], "cpms_ts_i");
  a1[141].i8[8] = 0;
  a1[141].i8[12] = 0;
  a1[142].i8[0] = 0;
  a1[142].i8[4] = 0;
  a1[142].i8[8] = 0;
  a1[142].i8[12] = 0;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v21, "cpms_ts_100");
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  AULoudspeakerManagerV2::TimeScale<float>::withPowerSmootherTC((uint64_t)a1[143].i64, (uint64_t)&v21, 0.1);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v14, "cpms_ts_1000");
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  AULoudspeakerManagerV2::TimeScale<float>::withPowerSmootherTC((uint64_t)a1[145].i64, (uint64_t)&v14, 1.0);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, "cpms_ts_thermal");
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  AULoudspeakerManagerV2::TimeScale<float>::withPowerSmootherTC((uint64_t)a1[147].i64, (uint64_t)&cf, 60.0);
  if (cf)
    CFRelease(cf);
  if (v14)
    CFRelease(v14);
  if (v21)
    CFRelease(v21);
  a1[149].i16[0] = 257;
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&a1[2], 0);
  ausdk::AUElement::SetParameter(Element, 0x40000000u, 0.0, 0);
  v5 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&a1[2], 0);
  ausdk::AUElement::SetParameter(v5, 0x40000001u, 0.0, 0);
  return a1;
}

void sub_1B61C3C58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFTypeRef cf, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef a17)
{
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  const void *v21;
  const void *v22;
  const void *v23;

  if (cf)
    CFRelease(cf);
  if (a17)
    CFRelease(a17);
  while (1)
  {
    v22 = *(const void **)(v19 - 32);
    v19 -= 32;
    v21 = v22;
    if (v22)
      CFRelease(v21);
    if (v19 == v18)
    {
      a17 = v17 + 276;
      std::vector<std::unique_ptr<DspLib::LoudspeakerManagerV2::Calibration::SpTS::SpeakerCalibrationProperties>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
      v23 = (const void *)v17[275];
      if (v23)
        CFRelease(v23);
      AUDspLib::~AUDspLib((AUDspLib *)v17);
      _Unwind_Resume(a1);
    }
  }
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManagerV2>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

int64x2_t *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManager>::Construct(int64x2_t *a1, OpaqueAudioComponentInstance *a2)
{
  int64x2_t *result;

  result = AUDspLibWithNewParameters::AUDspLibWithNewParameters(a1, a2, (uint64_t)&DspLib::kBubbleParameterConverters, (int64x2_t *)&DspLib::LoudspeakerManagerV1::Parameters::kSystemDefinition, (uint64_t)CFSTR("AULoudspeakerManager_ViewFactory"));
  result->i64[0] = (uint64_t)&off_1E69E8408;
  result[137].i64[1] = 0;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULoudspeakerManager>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessAndMultipleLookup,AULoudnessNormalizer>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUXTC>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *v3;
  _OWORD *v4;
  ausdk::AUElement *Element;
  ausdk::AUElement *v6;
  uint64_t v7;
  void *v8;
  __int128 v10;
  uint64_t v11;

  v10 = 0uLL;
  v11 = 0;
  v3 = (_QWORD *)AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, &v10, (uint64_t)CFSTR("AUXTC_ViewFactory"), 0);
  *v3 = &off_1E69E3DF8;
  DspLib::XTC::Algorithm::Algorithm((DspLib::XTC::Algorithm *)(v3 + 271));
  *(_QWORD *)(a1 + 2696) = 0;
  *(_QWORD *)(a1 + 2704) = 850045863;
  *(_OWORD *)(a1 + 2712) = 0u;
  *(_OWORD *)(a1 + 2728) = 0u;
  *(_OWORD *)(a1 + 2744) = 0u;
  *(_OWORD *)(a1 + 2753) = 0u;
  *(_BYTE *)(a1 + 2769) = 1;
  dspLibMessenger((uint64_t *)(a1 + 2776));
  *(_QWORD *)(a1 + 2816) = &off_1E69E4328;
  *(_QWORD *)(a1 + 2880) = &off_1E69E4348;
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)(a1 + 2944));
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)(a1 + 3904));
  *(_BYTE *)(a1 + 4865) = 0;
  v4 = (_OWORD *)operator new();
  v4[15] = 0u;
  v4[16] = 0u;
  v4[13] = 0u;
  v4[14] = 0u;
  v4[11] = 0u;
  v4[12] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  *v4 = 0u;
  *(_QWORD *)(a1 + 4928) = v4;
  *(_QWORD *)(a1 + 4936) = 0;
  *(_DWORD *)(a1 + 4944) = 0;
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(Element, 0x73766F6Cu, 0.0, 0);
  v6 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v6, 0x6F726965u, 0.0, 0);
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v7 = objc_claimAutoreleasedReturnValue();
  v8 = *(void **)(a1 + 2696);
  *(_QWORD *)(a1 + 2696) = v7;

  return a1;
}

void sub_1B61C3F10(_Unwind_Exception *a1)
{
  uint64_t v1;
  DspLib::XTC::Algorithm *v2;
  std::mutex *v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(v1 + 2816) = v5;
  ca::concurrent::deferred_deletion_queue<DspLib::XTC::FIRMatrix,10ul,std::default_delete<DspLib::XTC::FIRMatrix>>::~deferred_deletion_queue(v1 + 2880);
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v4);
  std::mutex::~mutex(v3);

  DspLib::XTC::Algorithm::~Algorithm(v2);
  AUDspLib::~AUDspLib((AUDspLib *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUXTC>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUThermalSpeakerProtection>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *result;
  __int128 v3;
  uint64_t v4;

  v3 = 0uLL;
  v4 = 0;
  result = (_QWORD *)AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, &v3, (uint64_t)CFSTR("AUThermalSpeakerProtection_ViewFactory"), 0);
  *result = &off_1E69DC420;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUThermalSpeakerProtection>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUPeakPowerGuard>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *result;
  __int128 v3;
  uint64_t v4;
  _QWORD v5[20];

  v5[0] = DspLib::PeakPowerGuard::Parameters::kNames;
  v5[1] = 47;
  v5[2] = &DspLib::PeakPowerGuard::Parameters::kUnits;
  v5[3] = 47;
  v5[4] = &DspLib::PeakPowerGuard::Parameters::kFlags;
  v5[5] = 47;
  v5[6] = &_ZGRN6DspLib14PeakPowerGuard10ParametersL8kMinimumE__0;
  v5[7] = 47;
  v5[8] = &_ZGRN6DspLib14PeakPowerGuard10ParametersL8kMaximumE__0;
  v5[9] = 47;
  v5[10] = &_ZGRN6DspLib14PeakPowerGuard10ParametersL8kDefaultE__0;
  v5[11] = 47;
  v5[12] = &_ZGRN6DspLib14PeakPowerGuard10ParametersL13kAUParametersE_;
  v5[13] = 38;
  v5[14] = &_ZGRN6DspLib14PeakPowerGuard10ParametersL20kDefaultAUParametersE_;
  v5[15] = 38;
  v5[16] = &_ZGRN6DspLib14PeakPowerGuard10ParametersL7kClumpsE_;
  v5[17] = 38;
  v5[18] = DspLib::PeakPowerGuard::Parameters::kClumpNames;
  v5[19] = 5;
  v3 = 0uLL;
  v4 = 0;
  result = (_QWORD *)AUDspLib::AUDspLib(a1, a2, (uint64_t)v5, &v3, (uint64_t)CFSTR("AUPeakPowerGuard_ViewFactory"), 0);
  *result = &off_1E69E3A88;
  result[271] = 0;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUPeakPowerGuard>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AULittleLateNightMode>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  char v3;
  ausdk::AUBase *v4;
  unsigned int v5;
  ausdk::AUScope *v6;
  char v7;
  ausdk::AUElement *Element;
  const __CFDictionary *v9;
  const __CFDictionary *Value;
  CFStringRef v11;
  uint64_t v12;
  const __CFDictionary *v13;
  const __CFString *v14;
  OSType v15;
  OpaqueAudioComponent *Next;
  OSStatus v17;
  AudioComponentInstance v18;
  AudioComponentInstance *v19;
  unint64_t v20;
  _QWORD *v21;
  AudioComponentInstance *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  AudioComponentInstance *v28;
  OpaqueAudioComponentInstance *v29;
  __int128 v30;
  OpaqueAudioComponentInstance **v31;
  OpaqueAudioComponentInstance **v32;
  OSType v33;
  OpaqueAudioComponentInstance *v34;
  unsigned int v35;
  float v36;
  ausdk::AUElement *v37;
  NSObject *v38;
  const char *v39;
  char *v41;
  AudioComponentInstance **v42;
  const __CFDictionary *v43;
  AudioComponentInstance outInstance;
  AudioUnitParameterValue outValue;
  AudioComponentDescription inDesc;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v3 = 1;
  v4 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  v5 = 0;
  *((_WORD *)v4 + 276) = 0;
  *((_QWORD *)v4 + 68) = 0;
  *((_OWORD *)v4 + 33) = 0u;
  *((_BYTE *)v4 + 554) = 1;
  *((_DWORD *)v4 + 139) = 0;
  *((_BYTE *)v4 + 560) = 0;
  *((_DWORD *)v4 + 147) = 0;
  *(_OWORD *)((char *)v4 + 568) = 0u;
  *((_BYTE *)v4 + 584) = 0;
  *(_QWORD *)v4 = &off_1E69C5798;
  *(_QWORD *)((char *)v4 + 628) = 0x3F8000003F800000;
  *((_QWORD *)v4 + 74) = 0;
  v41 = (char *)v4 + 528;
  v42 = (AudioComponentInstance **)((char *)v4 + 592);
  *(_OWORD *)((char *)v4 + 600) = 0u;
  *((_BYTE *)v4 + 616) = 0;
  *((_BYTE *)v4 + 636) = 0;
  v6 = (ausdk::AUBase *)((char *)v4 + 32);
  *(_QWORD *)((char *)v4 + 620) = 0;
  do
  {
    v7 = v3;
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v6, 0);
    ausdk::AUElement::SetParameter(Element, v5, 0.0, 0);
    v3 = 0;
    v5 = *(_DWORD *)(a1 + 620) + 1;
    *(_DWORD *)(a1 + 620) = v5;
  }
  while ((v7 & 1) != 0);
  v9 = (const __CFDictionary *)presetCreateForNumberOfChannels(0, *(unsigned __int8 *)(a1 + 636));
  if (!CFDictionaryContainsKey(v9, CFSTR("DSPchain")))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_46;
    inDesc.componentType = 136315394;
    *(_QWORD *)&inDesc.componentSubType = "AULittleLateNightMode.cpp";
    LOWORD(inDesc.componentFlags) = 1024;
    *(UInt32 *)((char *)&inDesc.componentFlags + 2) = 63;
    v38 = MEMORY[0x1E0C81028];
    v39 = "%25s:%-5d  key 'DSPchain' not found";
LABEL_45:
    _os_log_impl(&dword_1B5ED0000, v38, OS_LOG_TYPE_ERROR, v39, (uint8_t *)&inDesc, 0x12u);
    goto LABEL_46;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(v9, CFSTR("DSPchain"));
  if (!Value)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_46;
    inDesc.componentType = 136315394;
    *(_QWORD *)&inDesc.componentSubType = "AULittleLateNightMode.cpp";
    LOWORD(inDesc.componentFlags) = 1024;
    *(UInt32 *)((char *)&inDesc.componentFlags + 2) = 66;
    v38 = MEMORY[0x1E0C81028];
    v39 = "%25s:%-5d  could not load DSPchain";
    goto LABEL_45;
  }
  v11 = CFStringCreateWithFormat(0, 0, CFSTR("Processor_%d"), 0, v41);
  LODWORD(v12) = 0;
  v43 = v9;
LABEL_6:
  if (CFDictionaryContainsKey(Value, v11))
  {
    v13 = Value;
    v14 = (const __CFString *)CFDictionaryGetValue(Value, v11);
    if (v14)
    {
      v15 = convertCFStringToOSType(v14);
      if (v15)
      {
        outInstance = 0;
        inDesc.componentType = 1635083896;
        inDesc.componentSubType = v15;
        *(_QWORD *)&inDesc.componentManufacturer = 1634758764;
        inDesc.componentFlagsMask = 0;
        Next = AudioComponentFindNext(0, &inDesc);
        v17 = AudioComponentInstanceNew(Next, &outInstance);
        v18 = outInstance;
        if (outInstance)
        {
          if (!v17)
          {
            v19 = *(AudioComponentInstance **)(a1 + 600);
            v20 = *(_QWORD *)(a1 + 608);
            if ((unint64_t)v19 >= v20)
            {
              v22 = *v42;
              v23 = v19 - *v42;
              v24 = v23 + 1;
              if ((unint64_t)(v23 + 1) >> 61)
                std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
              v25 = v20 - (_QWORD)v22;
              if (v25 >> 2 > v24)
                v24 = v25 >> 2;
              if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
                v24 = 0x1FFFFFFFFFFFFFFFLL;
              if (v24)
              {
                if (v24 >> 61)
                  std::__throw_bad_array_new_length[abi:ne180100]();
                v26 = v24;
                v27 = (char *)operator new(8 * v24);
              }
              else
              {
                v27 = 0;
                v26 = 0;
              }
              v28 = (AudioComponentInstance *)&v27[8 * v23];
              *v28 = v18;
              v21 = v28 + 1;
              while (v19 != v22)
              {
                v29 = *--v19;
                *v19 = 0;
                *--v28 = v29;
              }
              v30 = *(_OWORD *)(a1 + 592);
              *(_QWORD *)(a1 + 592) = v28;
              *(_QWORD *)(a1 + 600) = v21;
              *(_QWORD *)(a1 + 608) = &v27[8 * v26];
              v31 = (OpaqueAudioComponentInstance **)*((_QWORD *)&v30 + 1);
              v32 = (OpaqueAudioComponentInstance **)v30;
              while (v31 != v32)
                std::unique_ptr<OpaqueAudioComponentInstance,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioComponentInstance*,&(AudioComponentInstanceDispose)>>::reset[abi:ne180100](--v31);
              if (v32)
                operator delete(v32);
            }
            else
            {
              *v19 = outInstance;
              v21 = v19 + 1;
            }
            *(_QWORD *)(a1 + 600) = v21;
          }
        }
      }
      v33 = 0;
      v34 = *(OpaqueAudioComponentInstance **)(*(_QWORD *)(a1 + 600) - 8);
      while (1)
      {
        inDesc.componentType = 0;
        AudioUnitGetPropertyInfo(v34, 3u, 0, 0, &inDesc.componentType, 0);
        if (v33 >= inDesc.componentType >> 2)
        {
          CFRelease(v11);
          Value = v13;
          v9 = v43;
          v12 = (v12 + 1);
          v11 = CFStringCreateWithFormat(0, 0, CFSTR("Processor_%d"), v12);
          goto LABEL_6;
        }
        outValue = 0.0;
        if (AudioUnitGetParameter(v34, v33, 0, 0, &outValue))
          break;
        v35 = *(_DWORD *)(a1 + 620);
        v36 = outValue;
        v37 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v6, 0);
        ausdk::AUElement::SetParameter(v37, v35, v36, 0);
        ++*(_DWORD *)(a1 + 620);
        ++v33;
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        inDesc.componentType = 136315394;
        *(_QWORD *)&inDesc.componentSubType = "AULittleLateNightMode.cpp";
        LOWORD(inDesc.componentFlags) = 1024;
        *(UInt32 *)((char *)&inDesc.componentFlags + 2) = 83;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  could not get parameter value", (uint8_t *)&inDesc, 0x12u);
      }
      v9 = v43;
    }
    else
    {
      v9 = v43;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        inDesc.componentType = 136315394;
        *(_QWORD *)&inDesc.componentSubType = "AULittleLateNightMode.cpp";
        LOWORD(inDesc.componentFlags) = 1024;
        *(UInt32 *)((char *)&inDesc.componentFlags + 2) = 73;
        _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d  could not get processorSubType string", (uint8_t *)&inDesc, 0x12u);
      }
    }
  }
  if (v11)
    CFRelease(v11);
LABEL_46:
  if (v9)
    CFRelease(v9);
  return a1;
}

void sub_1B61C4624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, void **a11, uint64_t a12, uint64_t a13, void **a14)
{
  ausdk::AUBase *v14;

  a14 = a11;
  std::vector<std::unique_ptr<OpaqueAudioComponentInstance,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioComponentInstance*,&(AudioComponentInstanceDispose)>>>::__destroy_vector::operator()[abi:ne180100](&a14);
  *(_QWORD *)v14 = &off_1E69ED840;
  a14 = a10;
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a14);
  ausdk::AUBase::~AUBase(v14);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AULittleLateNightMode>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMozartCompressorSingleBand>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *result;

  result = (_QWORD *)AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, (__int128 *)&kPresetList, (uint64_t)CFSTR("AUMozartCompressorSingleBand_ViewFactory"), 0);
  *result = &off_1E69EC398;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMozartCompressorSingleBand>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessMeter>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *result;
  __int128 v3;
  uint64_t v4;

  v3 = 0uLL;
  v4 = 0;
  result = (_QWORD *)AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, &v3, (uint64_t)CFSTR("AULoudnessMeter_ViewFactory"), 0);
  *result = &off_1E69D12C0;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessMeter>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUToneMeister>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  uint64_t v3;
  __int128 v5;
  uint64_t v6;

  v5 = 0uLL;
  v6 = 0;
  v3 = AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, &v5, (uint64_t)CFSTR("AUToneMeister_ViewFactory"), 0);
  *(_QWORD *)v3 = &off_1E69DD810;
  *(_QWORD *)(v3 + 2168) = 0x447A000000000000;
  *(_BYTE *)(v3 + 2176) = 1;
  *(_QWORD *)(v3 + 2184) = 0;
  *(_QWORD *)(v3 + 2192) = 1;
  dspLibMessenger((uint64_t *)(v3 + 2200));
  *(_QWORD *)(a1 + 2240) = &off_1E69DF620;
  *(_QWORD *)(a1 + 2304) = &off_1E69DF640;
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)(a1 + 2368));
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)(a1 + 3328));
  *(_BYTE *)(a1 + 4289) = 0;
  *(_OWORD *)(a1 + 4352) = 0u;
  return a1;
}

void sub_1B61C47F0(_Unwind_Exception *a1)
{
  AUDspLib *v1;
  _QWORD *v2;
  _QWORD *v4;

  v4 = (_QWORD *)*v2;
  *v2 = 0;
  if (v4)
    std::default_delete<DspLib::ToneMeister::CrossFade>::operator()[abi:ne180100]((uint64_t)v2, v4);
  AUDspLib::~AUDspLib(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUToneMeister>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMeisterStueck>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *v3;
  __int128 v5;
  uint64_t v6;

  v5 = 0uLL;
  v6 = 0;
  v3 = (_QWORD *)AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, &v5, (uint64_t)CFSTR("AUMeisterStueck_ViewFactory"), 1);
  *v3 = &off_1E69D40E0;
  bzero(v3 + 271, 0x991uLL);
  return a1;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMeisterStueck>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AULowFlow>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  uint64_t result;
  __int128 v3;
  uint64_t v4;

  v3 = 0uLL;
  v4 = 0;
  result = AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, &v3, (uint64_t)CFSTR("AULowFlow_ViewFactory"), 0);
  *(_QWORD *)result = &off_1E69D8FE0;
  *(_DWORD *)(result + 2168) = 0;
  *(_QWORD *)(result + 2176) = 0;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AULowFlow>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBassQueen>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *v3;
  unsigned int v4;
  ausdk::AUScope *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Element;
  unsigned int i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v17 = 0uLL;
  v18 = 0;
  v3 = (_QWORD *)AUDspLib::AUDspLib((uint64_t)a1, a2, (uint64_t)&kParameterList, &v17, (uint64_t)CFSTR("AUBassQueenViewFactory"), 0);
  v4 = 0;
  *v3 = &off_1E69E5658;
  v5 = (ausdk::AUScope *)(v3 + 10);
  while (1)
  {
    v6 = a1[15];
    if (v6)
      LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
    else
      v7 = (a1[13] - a1[12]) >> 3;
    if (v4 >= v7)
      break;
    Element = ausdk::AUScope::SafeGetElement(v5, v4);
    v14 = 0x40E5888000000000;
    v15 = xmmword_1B6626900;
    v16 = xmmword_1B6626910;
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v14);
    ++v4;
  }
  for (i = 0; ; ++i)
  {
    v10 = a1[21];
    if (v10)
      LODWORD(v11) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    else
      v11 = (a1[19] - a1[18]) >> 3;
    if (i >= v11)
      break;
    v12 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), i);
    v14 = 0x40E5888000000000;
    v15 = xmmword_1B6626900;
    v16 = xmmword_1B6626910;
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v12 + 56))(v12, &v14);
  }
  return a1;
}

void sub_1B61C4A50(_Unwind_Exception *a1)
{
  AUDspLib *v1;

  AUDspLib::~AUDspLib(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBassQueen>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

double ausdk::APFactory<ausdk::AUBaseProcessLookup,BassKoenig>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  uint64_t v2;
  double result;
  __int128 v8;
  uint64_t v9;

  v8 = 0uLL;
  v9 = 0;
  v2 = AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, &v8, (uint64_t)CFSTR("BassKoenig_ViewFactory"), 0);
  *(_QWORD *)v2 = &off_1E69C81E0;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(v2 + 2168) = result;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,BassKoenig>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVirtualBass>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *result;
  __int128 v3;
  uint64_t v4;

  v3 = 0uLL;
  v4 = 0;
  result = (_QWORD *)AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, &v3, (uint64_t)CFSTR("AUVirtualBass_ViewFactory"), 0);
  *result = &off_1E69DCE70;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVirtualBass>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBuzzKill>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *result;
  __int128 v3;
  uint64_t v4;
  _QWORD v5[16];
  __int128 v6;
  __int128 v7;

  v5[0] = kDspLibBuzzKillParameterNames;
  v5[1] = 98;
  v5[2] = &_ZGRL29kDspLibBuzzKillParameterUnits_;
  v5[3] = 98;
  v5[4] = &_ZGRL29kDspLibBuzzKillParameterFlags_;
  v5[5] = 98;
  v5[6] = &_ZGRN6DspLib8BuzzKill10ParametersL8kMinimumE_;
  v5[7] = 98;
  v5[8] = &_ZGRN6DspLib8BuzzKill10ParametersL8kMaximumE_;
  v5[9] = 98;
  v5[10] = &_ZGRN6DspLib8BuzzKill10ParametersL8kDefaultE_;
  v5[11] = 98;
  v5[12] = &_ZGRN6DspLib8BuzzKill10ParametersL13kAUParametersE_;
  v5[13] = 45;
  v5[14] = &_ZGRN6DspLib8BuzzKill10ParametersL20kDefaultAUParametersE_;
  v5[15] = 45;
  v6 = 0u;
  v7 = 0u;
  v4 = 0;
  v3 = 0uLL;
  result = (_QWORD *)AUDspLib::AUDspLib(a1, a2, (uint64_t)v5, &v3, (uint64_t)CFSTR("AUBuzzKill_ViewFactory"), 0);
  *result = &off_1E69E7A50;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUBuzzKill>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUControlFreak>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _QWORD *result;

  result = (_QWORD *)AUDspLib::AUDspLib(a1, a2, (uint64_t)&kParameterList, (__int128 *)&kPresetList, (uint64_t)CFSTR("AUControlFreak_ViewFactory"), 1);
  *result = &off_1E69DB9C8;
  return result;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUControlFreak>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicIssueDetector>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  void **v4;
  _QWORD *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  unint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  char *v33;
  char *v34;
  __int128 v35;
  unint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  __int128 v47;
  unint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  unint64_t v56;
  char *v57;
  char *v58;
  __int128 v59;
  unint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  unint64_t v68;
  char *v69;
  char *v70;
  __int128 v71;
  unint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  _QWORD *v79;
  unint64_t v80;
  char *v81;
  char *v82;
  __int128 v83;
  unint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  _QWORD *v91;
  unint64_t v92;
  char *v93;
  char *v94;
  __int128 v95;
  unint64_t v96;
  _QWORD *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  _QWORD *v103;
  unint64_t v104;
  char *v105;
  char *v106;
  __int128 v107;
  unint64_t v108;
  _QWORD *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  _QWORD *v115;
  unint64_t v116;
  char *v117;
  char *v118;
  __int128 v119;
  unint64_t v120;
  _QWORD *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  _QWORD *v127;
  unint64_t v128;
  char *v129;
  char *v130;
  __int128 v131;
  unint64_t v132;
  _QWORD *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t v138;
  _QWORD *v139;
  unint64_t v140;
  char *v141;
  char *v142;
  __int128 v143;
  unint64_t v144;
  _QWORD *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  _QWORD *v151;
  unint64_t v152;
  char *v153;
  char *v154;
  __int128 v155;
  unint64_t v156;
  _QWORD *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  unint64_t v161;
  uint64_t v162;
  _QWORD *v163;
  unint64_t v164;
  char *v165;
  char *v166;
  __int128 v167;
  unint64_t v168;
  _QWORD *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unint64_t v173;
  uint64_t v174;
  _QWORD *v175;
  unint64_t v176;
  char *v177;
  char *v178;
  __int128 v179;
  unint64_t v180;
  _QWORD *v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  unint64_t v185;
  uint64_t v186;
  _QWORD *v187;
  unint64_t v188;
  char *v189;
  char *v190;
  __int128 v191;
  unint64_t v192;
  char *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  unint64_t v197;
  uint64_t v198;
  _QWORD *v199;
  unint64_t v200;
  char *v201;
  char *v202;
  __int128 v203;
  unint64_t v204;
  char *v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  uint64_t v210;
  _QWORD *v211;
  unint64_t v212;
  char *v213;
  char *v214;
  __int128 v215;
  unint64_t v216;
  char *v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  unint64_t v221;
  uint64_t v222;
  _QWORD *v223;
  unint64_t v224;
  char *v225;
  char *v226;
  __int128 v227;
  unint64_t v228;
  char *v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  unint64_t v233;
  uint64_t v234;
  _QWORD *v235;
  unint64_t v236;
  char *v237;
  char *v238;
  __int128 v239;
  unint64_t v240;
  char *v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  unint64_t v245;
  uint64_t v246;
  _QWORD *v247;
  unint64_t v248;
  char *v249;
  char *v250;
  __int128 v251;
  unint64_t v252;
  char *v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  unint64_t v257;
  uint64_t v258;
  _QWORD *v259;
  unint64_t v260;
  char *v261;
  char *v262;
  __int128 v263;
  unint64_t v264;
  char *v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  unint64_t v269;
  uint64_t v270;
  _QWORD *v271;
  unint64_t v272;
  char *v273;
  char *v274;
  __int128 v275;
  unint64_t v276;
  char *v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  unint64_t v281;
  uint64_t v282;
  _QWORD *v283;
  unint64_t v284;
  char *v285;
  char *v286;
  __int128 v287;
  unint64_t v288;
  char *v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  unint64_t v293;
  uint64_t v294;
  _QWORD *v295;
  unint64_t v296;
  char *v297;
  char *v298;
  __int128 v299;
  unint64_t v300;
  _QWORD *v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  unint64_t v305;
  uint64_t v306;
  _QWORD *v307;
  unint64_t v308;
  char *v309;
  char *v310;
  __int128 v311;
  _QWORD *v312;
  unint64_t v313;
  _QWORD *v314;
  uint64_t v315;
  uint64_t v316;
  unint64_t v317;
  uint64_t v318;
  unint64_t v319;
  uint64_t v320;
  _QWORD *v321;
  unint64_t v322;
  char *v323;
  char *v324;
  __int128 v325;
  unint64_t v326;
  _QWORD *v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  unint64_t v332;
  uint64_t v333;
  _QWORD *v334;
  unint64_t v335;
  char *v336;
  char *v337;
  __int128 v338;
  unint64_t v339;
  _QWORD *v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  unint64_t v345;
  uint64_t v346;
  _QWORD *v347;
  unint64_t v348;
  char *v349;
  char *v350;
  __int128 v351;
  unint64_t v352;
  _QWORD *v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  unint64_t v358;
  uint64_t v359;
  _QWORD *v360;
  unint64_t v361;
  char *v362;
  char *v363;
  __int128 v364;
  unint64_t v365;
  _QWORD *v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  unint64_t v371;
  uint64_t v372;
  _QWORD *v373;
  unint64_t v374;
  char *v375;
  char *v376;
  __int128 v377;
  unint64_t v378;
  _QWORD *v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  unint64_t v384;
  uint64_t v385;
  _QWORD *v386;
  unint64_t v387;
  char *v388;
  char *v389;
  __int128 v390;
  unint64_t v391;
  _QWORD *v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  unint64_t v397;
  uint64_t v398;
  _QWORD *v399;
  unint64_t v400;
  char *v401;
  char *v402;
  __int128 v403;
  unint64_t v404;
  _QWORD *v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  unint64_t v410;
  uint64_t v411;
  _QWORD *v412;
  unint64_t v413;
  char *v414;
  char *v415;
  __int128 v416;
  unint64_t v417;
  _QWORD *v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  unint64_t v423;
  uint64_t v424;
  _QWORD *v425;
  unint64_t v426;
  char *v427;
  char *v428;
  __int128 v429;
  unint64_t v430;
  _QWORD *v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  unint64_t v436;
  uint64_t v437;
  _QWORD *v438;
  unint64_t v439;
  char *v440;
  char *v441;
  __int128 v442;
  unint64_t v443;
  _QWORD *v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  unint64_t v449;
  uint64_t v450;
  _QWORD *v451;
  unint64_t v452;
  char *v453;
  char *v454;
  __int128 v455;
  int v456;
  unint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  unint64_t v462;
  uint64_t v463;
  _QWORD *v464;
  char *v465;
  char *v466;
  _QWORD *v467;
  __int128 v468;
  unint64_t v469;
  _QWORD *v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  unint64_t v475;
  uint64_t v476;
  _QWORD *v477;
  unint64_t v478;
  char *v479;
  char *v480;
  __int128 v481;
  unint64_t v482;
  _QWORD *v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  unint64_t v488;
  uint64_t v489;
  _QWORD *v490;
  unint64_t v491;
  char *v492;
  char *v493;
  __int128 v494;
  unint64_t v495;
  _QWORD *v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  unint64_t v501;
  uint64_t v502;
  _QWORD *v503;
  unint64_t v504;
  char *v505;
  char *v506;
  __int128 v507;
  unint64_t v508;
  _QWORD *v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  unint64_t v514;
  uint64_t v515;
  _QWORD *v516;
  unint64_t v517;
  char *v518;
  char *v519;
  __int128 v520;
  int i;
  unint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  unint64_t v527;
  uint64_t v528;
  _QWORD *v529;
  char *v530;
  char *v531;
  _QWORD *v532;
  __int128 v533;
  uint64_t v534;
  unint64_t v535;
  uint64_t v536;
  float v537;
  ausdk::AUElement *Element;
  unint64_t j;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  unint64_t v543;
  uint64_t v544;
  uint64_t v545;
  ausdk::AUElement *v546;
  uint64_t v547;
  unsigned int v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  unsigned int v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  uint64_t v559;
  __int128 v560;
  __int128 v561;
  uint64_t v562;
  __int128 v563;
  __int128 v564;
  uint64_t v565;
  __int128 v566;
  __int128 v567;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 2, 5);
  *(_QWORD *)v3 = &off_1E69D7330;
  v4 = (void **)((char *)v3 + 528);
  *((_OWORD *)v3 + 33) = 0u;
  *((_OWORD *)v3 + 34) = 0u;
  *((_OWORD *)v3 + 35) = 0u;
  *((_BYTE *)v3 + 576) = 0;
  *(_OWORD *)((char *)v3 + 580) = 0u;
  *(_OWORD *)((char *)v3 + 596) = xmmword_1B6627BC0;
  *((_DWORD *)v3 + 153) = 1;
  *(_OWORD *)((char *)v3 + 616) = 0u;
  *(_OWORD *)((char *)v3 + 632) = 0u;
  *(_OWORD *)((char *)v3 + 648) = 0u;
  *(_OWORD *)((char *)v3 + 664) = 0u;
  *(_OWORD *)((char *)v3 + 680) = 0u;
  *(_OWORD *)((char *)v3 + 696) = 0u;
  *(_OWORD *)((char *)v3 + 712) = 0u;
  *(_OWORD *)((char *)v3 + 728) = 0u;
  *(_OWORD *)((char *)v3 + 744) = 0u;
  *(_OWORD *)((char *)v3 + 760) = 0u;
  *(_OWORD *)((char *)v3 + 772) = 0u;
  *(_OWORD *)((char *)v3 + 792) = 0u;
  *(_OWORD *)((char *)v3 + 808) = 0u;
  *(_OWORD *)((char *)v3 + 824) = 0u;
  v5 = std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(1uLL);
  v7 = (char *)&v5[4 * v6];
  *v5 = CFSTR("Wind Flag");
  v5[1] = 0xA00000000001;
  v5[2] = 0x3F80000000000000;
  v5[3] = 0x100000000;
  v8 = (char *)(v5 + 4);
  v9 = *(char **)(a1 + 536);
  v10 = *(char **)(a1 + 528);
  v11 = v5;
  if (v9 != v10)
  {
    do
    {
      v12 = *((_OWORD *)v9 - 1);
      *((_OWORD *)v11 - 2) = *((_OWORD *)v9 - 2);
      *((_OWORD *)v11 - 1) = v12;
      v11 -= 4;
      v9 -= 32;
    }
    while (v9 != v10);
    v9 = (char *)*v4;
  }
  *(_QWORD *)(a1 + 528) = v11;
  *(_QWORD *)(a1 + 536) = v8;
  *(_QWORD *)(a1 + 544) = v7;
  if (v9)
  {
    operator delete(v9);
    v7 = *(char **)(a1 + 544);
  }
  *(_QWORD *)(a1 + 536) = v8;
  if (v8 >= v7)
  {
    v14 = (v8 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v14 + 1) >> 59)
      goto LABEL_717;
    v15 = v7 - (_BYTE *)*v4;
    v16 = v15 >> 4;
    if (v15 >> 4 <= (unint64_t)(v14 + 1))
      v16 = v14 + 1;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFE0)
      v17 = 0x7FFFFFFFFFFFFFFLL;
    else
      v17 = v16;
    if (v17)
      v17 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v17);
    else
      v18 = 0;
    v19 = (_QWORD *)(v17 + 32 * v14);
    v20 = v17 + 32 * v18;
    *v19 = CFSTR("Blocked Mic Flag");
    v19[1] = 0xA00000000001;
    v19[2] = 0x3F80000000000000;
    v19[3] = 0x100000000;
    v13 = v19 + 4;
    v21 = *(char **)(a1 + 536);
    v22 = *(char **)(a1 + 528);
    if (v21 != v22)
    {
      do
      {
        v23 = *((_OWORD *)v21 - 1);
        *((_OWORD *)v19 - 2) = *((_OWORD *)v21 - 2);
        *((_OWORD *)v19 - 1) = v23;
        v19 -= 4;
        v21 -= 32;
      }
      while (v21 != v22);
      v21 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v19;
    *(_QWORD *)(a1 + 536) = v13;
    *(_QWORD *)(a1 + 544) = v20;
    if (v21)
      operator delete(v21);
  }
  else
  {
    v5[4] = CFSTR("Blocked Mic Flag");
    v5[5] = 0xA00000000001;
    v5[6] = 0x3F80000000000000;
    v5[7] = 0x100000000;
    v13 = v5 + 8;
  }
  *(_QWORD *)(a1 + 536) = v13;
  v24 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v13 >= v24)
  {
    v26 = ((char *)v13 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v26 + 1) >> 59)
      goto LABEL_717;
    v27 = v24 - (_QWORD)*v4;
    v28 = v27 >> 4;
    if (v27 >> 4 <= (unint64_t)(v26 + 1))
      v28 = v26 + 1;
    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFE0)
      v29 = 0x7FFFFFFFFFFFFFFLL;
    else
      v29 = v28;
    if (v29)
      v29 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v29);
    else
      v30 = 0;
    v31 = (_QWORD *)(v29 + 32 * v26);
    v32 = v29 + 32 * v30;
    *v31 = CFSTR("Best Mic");
    v31[1] = 0xA00000000001;
    v31[2] = 0x4120000000000000;
    v31[3] = 0x100000000;
    v25 = v31 + 4;
    v33 = *(char **)(a1 + 536);
    v34 = *(char **)(a1 + 528);
    if (v33 != v34)
    {
      do
      {
        v35 = *((_OWORD *)v33 - 1);
        *((_OWORD *)v31 - 2) = *((_OWORD *)v33 - 2);
        *((_OWORD *)v31 - 1) = v35;
        v31 -= 4;
        v33 -= 32;
      }
      while (v33 != v34);
      v33 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v31;
    *(_QWORD *)(a1 + 536) = v25;
    *(_QWORD *)(a1 + 544) = v32;
    if (v33)
      operator delete(v33);
  }
  else
  {
    *v13 = CFSTR("Best Mic");
    v13[1] = 0xA00000000001;
    v13[2] = 0x4120000000000000;
    v13[3] = 0x100000000;
    v25 = v13 + 4;
  }
  *(_QWORD *)(a1 + 536) = v25;
  v36 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v25 >= v36)
  {
    v38 = ((char *)v25 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v38 + 1) >> 59)
      goto LABEL_717;
    v39 = v36 - (_QWORD)*v4;
    v40 = v39 >> 4;
    if (v39 >> 4 <= (unint64_t)(v38 + 1))
      v40 = v38 + 1;
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFE0)
      v41 = 0x7FFFFFFFFFFFFFFLL;
    else
      v41 = v40;
    if (v41)
      v41 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v41);
    else
      v42 = 0;
    v43 = (_QWORD *)(v41 + 32 * v38);
    v44 = v41 + 32 * v42;
    *v43 = CFSTR("Preferred Mic Override");
    v43[1] = 0xA00000000001;
    v43[2] = 0x41000000BF800000;
    v43[3] = 0x1BF800000;
    v37 = v43 + 4;
    v45 = *(char **)(a1 + 536);
    v46 = *(char **)(a1 + 528);
    if (v45 != v46)
    {
      do
      {
        v47 = *((_OWORD *)v45 - 1);
        *((_OWORD *)v43 - 2) = *((_OWORD *)v45 - 2);
        *((_OWORD *)v43 - 1) = v47;
        v43 -= 4;
        v45 -= 32;
      }
      while (v45 != v46);
      v45 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v43;
    *(_QWORD *)(a1 + 536) = v37;
    *(_QWORD *)(a1 + 544) = v44;
    if (v45)
      operator delete(v45);
  }
  else
  {
    *v25 = CFSTR("Preferred Mic Override");
    v25[1] = 0xA00000000001;
    v25[2] = 0x41000000BF800000;
    v25[3] = 0x1BF800000;
    v37 = v25 + 4;
  }
  *(_QWORD *)(a1 + 536) = v37;
  v48 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v37 >= v48)
  {
    v50 = ((char *)v37 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v50 + 1) >> 59)
      goto LABEL_717;
    v51 = v48 - (_QWORD)*v4;
    v52 = v51 >> 4;
    if (v51 >> 4 <= (unint64_t)(v50 + 1))
      v52 = v50 + 1;
    if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFE0)
      v53 = 0x7FFFFFFFFFFFFFFLL;
    else
      v53 = v52;
    if (v53)
      v53 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v53);
    else
      v54 = 0;
    v55 = (_QWORD *)(v53 + 32 * v50);
    v56 = v53 + 32 * v54;
    *v55 = CFSTR("Aggregate Omni Mode");
    v55[1] = 0x8000000000000001;
    v55[2] = 0x3F80000000000000;
    v55[3] = 0x200000000;
    v49 = v55 + 4;
    v57 = *(char **)(a1 + 536);
    v58 = *(char **)(a1 + 528);
    if (v57 != v58)
    {
      do
      {
        v59 = *((_OWORD *)v57 - 1);
        *((_OWORD *)v55 - 2) = *((_OWORD *)v57 - 2);
        *((_OWORD *)v55 - 1) = v59;
        v55 -= 4;
        v57 -= 32;
      }
      while (v57 != v58);
      v57 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v55;
    *(_QWORD *)(a1 + 536) = v49;
    *(_QWORD *)(a1 + 544) = v56;
    if (v57)
      operator delete(v57);
  }
  else
  {
    *v37 = CFSTR("Aggregate Omni Mode");
    v37[1] = 0x8000000000000001;
    v37[2] = 0x3F80000000000000;
    v37[3] = 0x200000000;
    v49 = v37 + 4;
  }
  *(_QWORD *)(a1 + 536) = v49;
  v60 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v49 >= v60)
  {
    v62 = ((char *)v49 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v62 + 1) >> 59)
      goto LABEL_717;
    v63 = v60 - (_QWORD)*v4;
    v64 = v63 >> 4;
    if (v63 >> 4 <= (unint64_t)(v62 + 1))
      v64 = v62 + 1;
    if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFE0)
      v65 = 0x7FFFFFFFFFFFFFFLL;
    else
      v65 = v64;
    if (v65)
      v65 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v65);
    else
      v66 = 0;
    v67 = (_QWORD *)(v65 + 32 * v62);
    v68 = v65 + 32 * v66;
    *v67 = CFSTR("Input Pre-Processing Gain");
    v67[1] = 0x800000000000000DLL;
    v67[2] = 0x43480000C3480000;
    v67[3] = 0x300000000;
    v61 = v67 + 4;
    v69 = *(char **)(a1 + 536);
    v70 = *(char **)(a1 + 528);
    if (v69 != v70)
    {
      do
      {
        v71 = *((_OWORD *)v69 - 1);
        *((_OWORD *)v67 - 2) = *((_OWORD *)v69 - 2);
        *((_OWORD *)v67 - 1) = v71;
        v67 -= 4;
        v69 -= 32;
      }
      while (v69 != v70);
      v69 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v67;
    *(_QWORD *)(a1 + 536) = v61;
    *(_QWORD *)(a1 + 544) = v68;
    if (v69)
      operator delete(v69);
  }
  else
  {
    *v49 = CFSTR("Input Pre-Processing Gain");
    v49[1] = 0x800000000000000DLL;
    v49[2] = 0x43480000C3480000;
    v49[3] = 0x300000000;
    v61 = v49 + 4;
  }
  *(_QWORD *)(a1 + 536) = v61;
  v72 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v61 >= v72)
  {
    v74 = ((char *)v61 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v74 + 1) >> 59)
      goto LABEL_717;
    v75 = v72 - (_QWORD)*v4;
    v76 = v75 >> 4;
    if (v75 >> 4 <= (unint64_t)(v74 + 1))
      v76 = v74 + 1;
    if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFE0)
      v77 = 0x7FFFFFFFFFFFFFFLL;
    else
      v77 = v76;
    if (v77)
      v77 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v77);
    else
      v78 = 0;
    v79 = (_QWORD *)(v77 + 32 * v74);
    v80 = v77 + 32 * v78;
    *v79 = CFSTR("Suppression Gain Floor");
    v79[1] = 0x800000000000000DLL;
    v79[2] = 3276275712;
    v79[3] = 0x3C1100000;
    v73 = v79 + 4;
    v81 = *(char **)(a1 + 536);
    v82 = *(char **)(a1 + 528);
    if (v81 != v82)
    {
      do
      {
        v83 = *((_OWORD *)v81 - 1);
        *((_OWORD *)v79 - 2) = *((_OWORD *)v81 - 2);
        *((_OWORD *)v79 - 1) = v83;
        v79 -= 4;
        v81 -= 32;
      }
      while (v81 != v82);
      v81 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v79;
    *(_QWORD *)(a1 + 536) = v73;
    *(_QWORD *)(a1 + 544) = v80;
    if (v81)
      operator delete(v81);
  }
  else
  {
    *v61 = CFSTR("Suppression Gain Floor");
    v61[1] = 0x800000000000000DLL;
    v61[2] = 3276275712;
    v61[3] = 0x3C1100000;
    v73 = v61 + 4;
  }
  *(_QWORD *)(a1 + 536) = v73;
  v84 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v73 >= v84)
  {
    v86 = ((char *)v73 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v86 + 1) >> 59)
      goto LABEL_717;
    v87 = v84 - (_QWORD)*v4;
    v88 = v87 >> 4;
    if (v87 >> 4 <= (unint64_t)(v86 + 1))
      v88 = v86 + 1;
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFE0)
      v89 = 0x7FFFFFFFFFFFFFFLL;
    else
      v89 = v88;
    if (v89)
      v89 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v89);
    else
      v90 = 0;
    v91 = (_QWORD *)(v89 + 32 * v86);
    v92 = v89 + 32 * v90;
    *v91 = CFSTR("Time Constant for PSD Est.");
    v91[1] = 0x8000000000000018;
    v91[2] = 0x461C400000000000;
    v91[3] = 0x442C80000;
    v85 = v91 + 4;
    v93 = *(char **)(a1 + 536);
    v94 = *(char **)(a1 + 528);
    if (v93 != v94)
    {
      do
      {
        v95 = *((_OWORD *)v93 - 1);
        *((_OWORD *)v91 - 2) = *((_OWORD *)v93 - 2);
        *((_OWORD *)v91 - 1) = v95;
        v91 -= 4;
        v93 -= 32;
      }
      while (v93 != v94);
      v93 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v91;
    *(_QWORD *)(a1 + 536) = v85;
    *(_QWORD *)(a1 + 544) = v92;
    if (v93)
      operator delete(v93);
  }
  else
  {
    *v73 = CFSTR("Time Constant for PSD Est.");
    v73[1] = 0x8000000000000018;
    v73[2] = 0x461C400000000000;
    v73[3] = 0x442C80000;
    v85 = v73 + 4;
  }
  *(_QWORD *)(a1 + 536) = v85;
  v96 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v85 >= v96)
  {
    v98 = ((char *)v85 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v98 + 1) >> 59)
      goto LABEL_717;
    v99 = v96 - (_QWORD)*v4;
    v100 = v99 >> 4;
    if (v99 >> 4 <= (unint64_t)(v98 + 1))
      v100 = v98 + 1;
    if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFE0)
      v101 = 0x7FFFFFFFFFFFFFFLL;
    else
      v101 = v100;
    if (v101)
      v101 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v101);
    else
      v102 = 0;
    v103 = (_QWORD *)(v101 + 32 * v98);
    v104 = v101 + 32 * v102;
    *v103 = CFSTR("Time Constant for Energy Smoothing");
    v103[1] = 0x8000000000000018;
    v103[2] = 0x461C400000000000;
    v103[3] = 0x441A00000;
    v97 = v103 + 4;
    v105 = *(char **)(a1 + 536);
    v106 = *(char **)(a1 + 528);
    if (v105 != v106)
    {
      do
      {
        v107 = *((_OWORD *)v105 - 1);
        *((_OWORD *)v103 - 2) = *((_OWORD *)v105 - 2);
        *((_OWORD *)v103 - 1) = v107;
        v103 -= 4;
        v105 -= 32;
      }
      while (v105 != v106);
      v105 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v103;
    *(_QWORD *)(a1 + 536) = v97;
    *(_QWORD *)(a1 + 544) = v104;
    if (v105)
      operator delete(v105);
  }
  else
  {
    *v85 = CFSTR("Time Constant for Energy Smoothing");
    v85[1] = 0x8000000000000018;
    v85[2] = 0x461C400000000000;
    v85[3] = 0x441A00000;
    v97 = v85 + 4;
  }
  *(_QWORD *)(a1 + 536) = v97;
  v108 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v97 >= v108)
  {
    v110 = ((char *)v97 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v110 + 1) >> 59)
      goto LABEL_717;
    v111 = v108 - (_QWORD)*v4;
    v112 = v111 >> 4;
    if (v111 >> 4 <= (unint64_t)(v110 + 1))
      v112 = v110 + 1;
    if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFE0)
      v113 = 0x7FFFFFFFFFFFFFFLL;
    else
      v113 = v112;
    if (v113)
      v113 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v113);
    else
      v114 = 0;
    v115 = (_QWORD *)(v113 + 32 * v110);
    v116 = v113 + 32 * v114;
    *v115 = CFSTR("Time Constant for Raw Ps Energy Smoothing");
    v115[1] = 0x8000000000000018;
    v115[2] = 0x461C400000000000;
    v115[3] = 0x43F800000;
    v109 = v115 + 4;
    v117 = *(char **)(a1 + 536);
    v118 = *(char **)(a1 + 528);
    if (v117 != v118)
    {
      do
      {
        v119 = *((_OWORD *)v117 - 1);
        *((_OWORD *)v115 - 2) = *((_OWORD *)v117 - 2);
        *((_OWORD *)v115 - 1) = v119;
        v115 -= 4;
        v117 -= 32;
      }
      while (v117 != v118);
      v117 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v115;
    *(_QWORD *)(a1 + 536) = v109;
    *(_QWORD *)(a1 + 544) = v116;
    if (v117)
      operator delete(v117);
  }
  else
  {
    *v97 = CFSTR("Time Constant for Raw Ps Energy Smoothing");
    v97[1] = 0x8000000000000018;
    v97[2] = 0x461C400000000000;
    v97[3] = 0x43F800000;
    v109 = v97 + 4;
  }
  *(_QWORD *)(a1 + 536) = v109;
  v120 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v109 >= v120)
  {
    v122 = ((char *)v109 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v122 + 1) >> 59)
      goto LABEL_717;
    v123 = v120 - (_QWORD)*v4;
    v124 = v123 >> 4;
    if (v123 >> 4 <= (unint64_t)(v122 + 1))
      v124 = v122 + 1;
    if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFE0)
      v125 = 0x7FFFFFFFFFFFFFFLL;
    else
      v125 = v124;
    if (v125)
      v125 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v125);
    else
      v126 = 0;
    v127 = (_QWORD *)(v125 + 32 * v122);
    v128 = v125 + 32 * v126;
    *v127 = CFSTR("Hysteresis Time for Wind/BlockeMic/BestMic Flags");
    v127[1] = 0x8000000000000018;
    v127[2] = 0x461C400000000000;
    v127[3] = 0x443FA0000;
    v121 = v127 + 4;
    v129 = *(char **)(a1 + 536);
    v130 = *(char **)(a1 + 528);
    if (v129 != v130)
    {
      do
      {
        v131 = *((_OWORD *)v129 - 1);
        *((_OWORD *)v127 - 2) = *((_OWORD *)v129 - 2);
        *((_OWORD *)v127 - 1) = v131;
        v127 -= 4;
        v129 -= 32;
      }
      while (v129 != v130);
      v129 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v127;
    *(_QWORD *)(a1 + 536) = v121;
    *(_QWORD *)(a1 + 544) = v128;
    if (v129)
      operator delete(v129);
  }
  else
  {
    *v109 = CFSTR("Hysteresis Time for Wind/BlockeMic/BestMic Flags");
    v109[1] = 0x8000000000000018;
    v109[2] = 0x461C400000000000;
    v109[3] = 0x443FA0000;
    v121 = v109 + 4;
  }
  *(_QWORD *)(a1 + 536) = v121;
  v132 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v121 >= v132)
  {
    v134 = ((char *)v121 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v134 + 1) >> 59)
      goto LABEL_717;
    v135 = v132 - (_QWORD)*v4;
    v136 = v135 >> 4;
    if (v135 >> 4 <= (unint64_t)(v134 + 1))
      v136 = v134 + 1;
    if ((unint64_t)v135 >= 0x7FFFFFFFFFFFFFE0)
      v137 = 0x7FFFFFFFFFFFFFFLL;
    else
      v137 = v136;
    if (v137)
      v137 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v137);
    else
      v138 = 0;
    v139 = (_QWORD *)(v137 + 32 * v134);
    v140 = v137 + 32 * v138;
    *v139 = CFSTR("Hysteresis Time for Wind/BlockeMic Flags offset");
    v139[1] = 0x8000000000000018;
    v139[2] = 0x461C400000000000;
    v139[3] = 0x4447A0000;
    v133 = v139 + 4;
    v141 = *(char **)(a1 + 536);
    v142 = *(char **)(a1 + 528);
    if (v141 != v142)
    {
      do
      {
        v143 = *((_OWORD *)v141 - 1);
        *((_OWORD *)v139 - 2) = *((_OWORD *)v141 - 2);
        *((_OWORD *)v139 - 1) = v143;
        v139 -= 4;
        v141 -= 32;
      }
      while (v141 != v142);
      v141 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v139;
    *(_QWORD *)(a1 + 536) = v133;
    *(_QWORD *)(a1 + 544) = v140;
    if (v141)
      operator delete(v141);
  }
  else
  {
    *v121 = CFSTR("Hysteresis Time for Wind/BlockeMic Flags offset");
    v121[1] = 0x8000000000000018;
    v121[2] = 0x461C400000000000;
    v121[3] = 0x4447A0000;
    v133 = v121 + 4;
  }
  *(_QWORD *)(a1 + 536) = v133;
  v144 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v133 >= v144)
  {
    v146 = ((char *)v133 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v146 + 1) >> 59)
      goto LABEL_717;
    v147 = v144 - (_QWORD)*v4;
    v148 = v147 >> 4;
    if (v147 >> 4 <= (unint64_t)(v146 + 1))
      v148 = v146 + 1;
    if ((unint64_t)v147 >= 0x7FFFFFFFFFFFFFE0)
      v149 = 0x7FFFFFFFFFFFFFFLL;
    else
      v149 = v148;
    if (v149)
      v149 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v149);
    else
      v150 = 0;
    v151 = (_QWORD *)(v149 + 32 * v146);
    v152 = v149 + 32 * v150;
    *v151 = CFSTR("Threshold on Wind Probability");
    v151[1] = 0x8000000000000000;
    v151[2] = 0x3F80000000000000;
    v151[3] = 0x53F333333;
    v145 = v151 + 4;
    v153 = *(char **)(a1 + 536);
    v154 = *(char **)(a1 + 528);
    if (v153 != v154)
    {
      do
      {
        v155 = *((_OWORD *)v153 - 1);
        *((_OWORD *)v151 - 2) = *((_OWORD *)v153 - 2);
        *((_OWORD *)v151 - 1) = v155;
        v151 -= 4;
        v153 -= 32;
      }
      while (v153 != v154);
      v153 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v151;
    *(_QWORD *)(a1 + 536) = v145;
    *(_QWORD *)(a1 + 544) = v152;
    if (v153)
      operator delete(v153);
  }
  else
  {
    *v133 = CFSTR("Threshold on Wind Probability");
    v133[1] = 0x8000000000000000;
    v133[2] = 0x3F80000000000000;
    v133[3] = 0x53F333333;
    v145 = v133 + 4;
  }
  *(_QWORD *)(a1 + 536) = v145;
  v156 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v145 >= v156)
  {
    v158 = ((char *)v145 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v158 + 1) >> 59)
      goto LABEL_717;
    v159 = v156 - (_QWORD)*v4;
    v160 = v159 >> 4;
    if (v159 >> 4 <= (unint64_t)(v158 + 1))
      v160 = v158 + 1;
    if ((unint64_t)v159 >= 0x7FFFFFFFFFFFFFE0)
      v161 = 0x7FFFFFFFFFFFFFFLL;
    else
      v161 = v160;
    if (v161)
      v161 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v161);
    else
      v162 = 0;
    v163 = (_QWORD *)(v161 + 32 * v158);
    v164 = v161 + 32 * v162;
    *v163 = CFSTR("Threshold on Blocked Mic Probability");
    v163[1] = 0x8000000000000000;
    v163[2] = 0x3F80000000000000;
    v163[3] = 0x53F333333;
    v157 = v163 + 4;
    v165 = *(char **)(a1 + 536);
    v166 = *(char **)(a1 + 528);
    if (v165 != v166)
    {
      do
      {
        v167 = *((_OWORD *)v165 - 1);
        *((_OWORD *)v163 - 2) = *((_OWORD *)v165 - 2);
        *((_OWORD *)v163 - 1) = v167;
        v163 -= 4;
        v165 -= 32;
      }
      while (v165 != v166);
      v165 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v163;
    *(_QWORD *)(a1 + 536) = v157;
    *(_QWORD *)(a1 + 544) = v164;
    if (v165)
      operator delete(v165);
  }
  else
  {
    *v145 = CFSTR("Threshold on Blocked Mic Probability");
    v145[1] = 0x8000000000000000;
    v145[2] = 0x3F80000000000000;
    v145[3] = 0x53F333333;
    v157 = v145 + 4;
  }
  *(_QWORD *)(a1 + 536) = v157;
  v168 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v157 >= v168)
  {
    v170 = ((char *)v157 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v170 + 1) >> 59)
      goto LABEL_717;
    v171 = v168 - (_QWORD)*v4;
    v172 = v171 >> 4;
    if (v171 >> 4 <= (unint64_t)(v170 + 1))
      v172 = v170 + 1;
    if ((unint64_t)v171 >= 0x7FFFFFFFFFFFFFE0)
      v173 = 0x7FFFFFFFFFFFFFFLL;
    else
      v173 = v172;
    if (v173)
      v173 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v173);
    else
      v174 = 0;
    v175 = (_QWORD *)(v173 + 32 * v170);
    v176 = v173 + 32 * v174;
    *v175 = CFSTR("ECLee Process");
    v175[1] = 0x8000000000000001;
    v175[2] = 0x3F80000000000000;
    v175[3] = 0x53F800000;
    v169 = v175 + 4;
    v177 = *(char **)(a1 + 536);
    v178 = *(char **)(a1 + 528);
    if (v177 != v178)
    {
      do
      {
        v179 = *((_OWORD *)v177 - 1);
        *((_OWORD *)v175 - 2) = *((_OWORD *)v177 - 2);
        *((_OWORD *)v175 - 1) = v179;
        v175 -= 4;
        v177 -= 32;
      }
      while (v177 != v178);
      v177 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v175;
    *(_QWORD *)(a1 + 536) = v169;
    *(_QWORD *)(a1 + 544) = v176;
    if (v177)
      operator delete(v177);
  }
  else
  {
    *v157 = CFSTR("ECLee Process");
    v157[1] = 0x8000000000000001;
    v157[2] = 0x3F80000000000000;
    v157[3] = 0x53F800000;
    v169 = v157 + 4;
  }
  *(_QWORD *)(a1 + 536) = v169;
  v180 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v169 >= v180)
  {
    v182 = ((char *)v169 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v182 + 1) >> 59)
      goto LABEL_717;
    v183 = v180 - (_QWORD)*v4;
    v184 = v183 >> 4;
    if (v183 >> 4 <= (unint64_t)(v182 + 1))
      v184 = v182 + 1;
    if ((unint64_t)v183 >= 0x7FFFFFFFFFFFFFE0)
      v185 = 0x7FFFFFFFFFFFFFFLL;
    else
      v185 = v184;
    if (v185)
      v185 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v185);
    else
      v186 = 0;
    v187 = (_QWORD *)(v185 + 32 * v182);
    v188 = v185 + 32 * v186;
    *v187 = CFSTR("Best Echo Mic Available?");
    v187[1] = 0x8000000000000001;
    v187[2] = 0x3F80000000000000;
    v187[3] = 0x600000000;
    v181 = v187 + 4;
    v189 = *(char **)(a1 + 536);
    v190 = *(char **)(a1 + 528);
    if (v189 != v190)
    {
      do
      {
        v191 = *((_OWORD *)v189 - 1);
        *((_OWORD *)v187 - 2) = *((_OWORD *)v189 - 2);
        *((_OWORD *)v187 - 1) = v191;
        v187 -= 4;
        v189 -= 32;
      }
      while (v189 != v190);
      v189 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v187;
    *(_QWORD *)(a1 + 536) = v181;
    *(_QWORD *)(a1 + 544) = v188;
    if (v189)
      operator delete(v189);
  }
  else
  {
    *v169 = CFSTR("Best Echo Mic Available?");
    v169[1] = 0x8000000000000001;
    v169[2] = 0x3F80000000000000;
    v169[3] = 0x600000000;
    v181 = v169 + 4;
  }
  *(_QWORD *)(a1 + 536) = v181;
  v192 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v181 >= v192)
  {
    v194 = ((char *)v181 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v194 + 1) >> 59)
      goto LABEL_717;
    v195 = v192 - (_QWORD)*v4;
    v196 = v195 >> 4;
    if (v195 >> 4 <= (unint64_t)(v194 + 1))
      v196 = v194 + 1;
    if ((unint64_t)v195 >= 0x7FFFFFFFFFFFFFE0)
      v197 = 0x7FFFFFFFFFFFFFFLL;
    else
      v197 = v196;
    if (v197)
      v197 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v197);
    else
      v198 = 0;
    v199 = (_QWORD *)(v197 + 32 * v194);
    v200 = v197 + 32 * v198;
    *v199 = CFSTR("Best Echo Mic Index (e.g., Mic2 for iPhone)");
    v199[1] = 0x8000000000000001;
    v199[2] = 0x4100000000000000;
    v199[3] = 0x640000000;
    v193 = v199 + 4;
    v201 = *(char **)(a1 + 536);
    v202 = *(char **)(a1 + 528);
    if (v201 != v202)
    {
      do
      {
        v203 = *((_OWORD *)v201 - 1);
        *((_OWORD *)v199 - 2) = *((_OWORD *)v201 - 2);
        *((_OWORD *)v199 - 1) = v203;
        v199 -= 4;
        v201 -= 32;
      }
      while (v201 != v202);
      v201 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v199;
    *(_QWORD *)(a1 + 536) = v193;
    *(_QWORD *)(a1 + 544) = v200;
    if (v201)
      operator delete(v201);
  }
  else
  {
    *v181 = CFSTR("Best Echo Mic Index (e.g., Mic2 for iPhone)");
    v181[1] = 0x8000000000000001;
    v181[2] = 0x4100000000000000;
    v181[3] = 0x640000000;
    v193 = v181 + 4;
  }
  *(_QWORD *)(a1 + 536) = v193;
  v204 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v193 >= v204)
  {
    v206 = ((char *)v193 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v206 + 1) >> 59)
      goto LABEL_717;
    v207 = v204 - (_QWORD)*v4;
    v208 = v207 >> 4;
    if (v207 >> 4 <= (unint64_t)(v206 + 1))
      v208 = v206 + 1;
    if ((unint64_t)v207 >= 0x7FFFFFFFFFFFFFE0)
      v209 = 0x7FFFFFFFFFFFFFFLL;
    else
      v209 = v208;
    if (v209)
      v209 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v209);
    else
      v210 = 0;
    v211 = (_QWORD *)(v209 + 32 * v206);
    v212 = v209 + 32 * v210;
    *v211 = CFSTR("Primary Mic Blocked or In High Echo Coupling State");
    v211[1] = 0xA00000000001;
    v211[2] = 0x3F80000000000000;
    v211[3] = 0x100000000;
    v205 = (char *)(v211 + 4);
    v213 = *(char **)(a1 + 536);
    v214 = *(char **)(a1 + 528);
    if (v213 != v214)
    {
      do
      {
        v215 = *((_OWORD *)v213 - 1);
        *((_OWORD *)v211 - 2) = *((_OWORD *)v213 - 2);
        *((_OWORD *)v211 - 1) = v215;
        v211 -= 4;
        v213 -= 32;
      }
      while (v213 != v214);
      v213 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v211;
    *(_QWORD *)(a1 + 536) = v205;
    *(_QWORD *)(a1 + 544) = v212;
    if (v213)
      operator delete(v213);
  }
  else
  {
    *v193 = CFSTR("Primary Mic Blocked or In High Echo Coupling State");
    v193[1] = 0xA00000000001;
    v193[2] = 0x3F80000000000000;
    v193[3] = 0x100000000;
    v205 = (char *)(v193 + 4);
  }
  *(_QWORD *)(a1 + 536) = v205;
  v216 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v205 >= v216)
  {
    v218 = (v205 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v218 + 1) >> 59)
      goto LABEL_717;
    v219 = v216 - (_QWORD)*v4;
    v220 = v219 >> 4;
    if (v219 >> 4 <= (unint64_t)(v218 + 1))
      v220 = v218 + 1;
    if ((unint64_t)v219 >= 0x7FFFFFFFFFFFFFE0)
      v221 = 0x7FFFFFFFFFFFFFFLL;
    else
      v221 = v220;
    if (v221)
      v221 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v221);
    else
      v222 = 0;
    v223 = (_QWORD *)(v221 + 32 * v218);
    v224 = v221 + 32 * v222;
    *v223 = CFSTR("Time Constant for ECLee Energy Smoothing");
    v223[1] = 0x8000000000000018;
    v223[2] = 0x461C400000000000;
    v223[3] = 0x642C80000;
    v217 = (char *)(v223 + 4);
    v225 = *(char **)(a1 + 536);
    v226 = *(char **)(a1 + 528);
    if (v225 != v226)
    {
      do
      {
        v227 = *((_OWORD *)v225 - 1);
        *((_OWORD *)v223 - 2) = *((_OWORD *)v225 - 2);
        *((_OWORD *)v223 - 1) = v227;
        v223 -= 4;
        v225 -= 32;
      }
      while (v225 != v226);
      v225 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v223;
    *(_QWORD *)(a1 + 536) = v217;
    *(_QWORD *)(a1 + 544) = v224;
    if (v225)
      operator delete(v225);
  }
  else
  {
    *(_QWORD *)v205 = CFSTR("Time Constant for ECLee Energy Smoothing");
    *((_QWORD *)v205 + 1) = 0x8000000000000018;
    *((_QWORD *)v205 + 2) = 0x461C400000000000;
    *((_QWORD *)v205 + 3) = 0x642C80000;
    v217 = v205 + 32;
  }
  *(_QWORD *)(a1 + 536) = v217;
  v228 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v217 >= v228)
  {
    v230 = (v217 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v230 + 1) >> 59)
      goto LABEL_717;
    v231 = v228 - (_QWORD)*v4;
    v232 = v231 >> 4;
    if (v231 >> 4 <= (unint64_t)(v230 + 1))
      v232 = v230 + 1;
    if ((unint64_t)v231 >= 0x7FFFFFFFFFFFFFE0)
      v233 = 0x7FFFFFFFFFFFFFFLL;
    else
      v233 = v232;
    if (v233)
      v233 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v233);
    else
      v234 = 0;
    v235 = (_QWORD *)(v233 + 32 * v230);
    v236 = v233 + 32 * v234;
    *v235 = CFSTR("Hangover Time Onset for Primary Mic Blocked/Coupling Flag");
    v235[1] = 0x8000000000000018;
    v235[2] = 0x461C400000000000;
    v235[3] = 0x641F00000;
    v229 = (char *)(v235 + 4);
    v237 = *(char **)(a1 + 536);
    v238 = *(char **)(a1 + 528);
    if (v237 != v238)
    {
      do
      {
        v239 = *((_OWORD *)v237 - 1);
        *((_OWORD *)v235 - 2) = *((_OWORD *)v237 - 2);
        *((_OWORD *)v235 - 1) = v239;
        v235 -= 4;
        v237 -= 32;
      }
      while (v237 != v238);
      v237 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v235;
    *(_QWORD *)(a1 + 536) = v229;
    *(_QWORD *)(a1 + 544) = v236;
    if (v237)
      operator delete(v237);
  }
  else
  {
    *(_QWORD *)v217 = CFSTR("Hangover Time Onset for Primary Mic Blocked/Coupling Flag");
    *((_QWORD *)v217 + 1) = 0x8000000000000018;
    *((_QWORD *)v217 + 2) = 0x461C400000000000;
    *((_QWORD *)v217 + 3) = 0x641F00000;
    v229 = v217 + 32;
  }
  *(_QWORD *)(a1 + 536) = v229;
  v240 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v229 >= v240)
  {
    v242 = (v229 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v242 + 1) >> 59)
      goto LABEL_717;
    v243 = v240 - (_QWORD)*v4;
    v244 = v243 >> 4;
    if (v243 >> 4 <= (unint64_t)(v242 + 1))
      v244 = v242 + 1;
    if ((unint64_t)v243 >= 0x7FFFFFFFFFFFFFE0)
      v245 = 0x7FFFFFFFFFFFFFFLL;
    else
      v245 = v244;
    if (v245)
      v245 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v245);
    else
      v246 = 0;
    v247 = (_QWORD *)(v245 + 32 * v242);
    v248 = v245 + 32 * v246;
    *v247 = CFSTR("Hangover Time Offset for Primary Mic Blocked/Coupling Flag");
    v247[1] = 0x8000000000000018;
    v247[2] = 0x461C400000000000;
    v247[3] = 0x643FA0000;
    v241 = (char *)(v247 + 4);
    v249 = *(char **)(a1 + 536);
    v250 = *(char **)(a1 + 528);
    if (v249 != v250)
    {
      do
      {
        v251 = *((_OWORD *)v249 - 1);
        *((_OWORD *)v247 - 2) = *((_OWORD *)v249 - 2);
        *((_OWORD *)v247 - 1) = v251;
        v247 -= 4;
        v249 -= 32;
      }
      while (v249 != v250);
      v249 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v247;
    *(_QWORD *)(a1 + 536) = v241;
    *(_QWORD *)(a1 + 544) = v248;
    if (v249)
      operator delete(v249);
  }
  else
  {
    *(_QWORD *)v229 = CFSTR("Hangover Time Offset for Primary Mic Blocked/Coupling Flag");
    *((_QWORD *)v229 + 1) = 0x8000000000000018;
    *((_QWORD *)v229 + 2) = 0x461C400000000000;
    *((_QWORD *)v229 + 3) = 0x643FA0000;
    v241 = v229 + 32;
  }
  *(_QWORD *)(a1 + 536) = v241;
  v252 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v241 >= v252)
  {
    v254 = (v241 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v254 + 1) >> 59)
      goto LABEL_717;
    v255 = v252 - (_QWORD)*v4;
    v256 = v255 >> 4;
    if (v255 >> 4 <= (unint64_t)(v254 + 1))
      v256 = v254 + 1;
    if ((unint64_t)v255 >= 0x7FFFFFFFFFFFFFE0)
      v257 = 0x7FFFFFFFFFFFFFFLL;
    else
      v257 = v256;
    if (v257)
      v257 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v257);
    else
      v258 = 0;
    v259 = (_QWORD *)(v257 + 32 * v254);
    v260 = v257 + 32 * v258;
    *v259 = CFSTR("Low Freq for Blocked Mic Detection Band");
    v259[1] = 0x8000000000000008;
    v259[2] = 0x469C400000000000;
    v259[3] = 0x6457A0000;
    v253 = (char *)(v259 + 4);
    v261 = *(char **)(a1 + 536);
    v262 = *(char **)(a1 + 528);
    if (v261 != v262)
    {
      do
      {
        v263 = *((_OWORD *)v261 - 1);
        *((_OWORD *)v259 - 2) = *((_OWORD *)v261 - 2);
        *((_OWORD *)v259 - 1) = v263;
        v259 -= 4;
        v261 -= 32;
      }
      while (v261 != v262);
      v261 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v259;
    *(_QWORD *)(a1 + 536) = v253;
    *(_QWORD *)(a1 + 544) = v260;
    if (v261)
      operator delete(v261);
  }
  else
  {
    *(_QWORD *)v241 = CFSTR("Low Freq for Blocked Mic Detection Band");
    *((_QWORD *)v241 + 1) = 0x8000000000000008;
    *((_QWORD *)v241 + 2) = 0x469C400000000000;
    *((_QWORD *)v241 + 3) = 0x6457A0000;
    v253 = v241 + 32;
  }
  *(_QWORD *)(a1 + 536) = v253;
  v264 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v253 >= v264)
  {
    v266 = (v253 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v266 + 1) >> 59)
      goto LABEL_717;
    v267 = v264 - (_QWORD)*v4;
    v268 = v267 >> 4;
    if (v267 >> 4 <= (unint64_t)(v266 + 1))
      v268 = v266 + 1;
    if ((unint64_t)v267 >= 0x7FFFFFFFFFFFFFE0)
      v269 = 0x7FFFFFFFFFFFFFFLL;
    else
      v269 = v268;
    if (v269)
      v269 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v269);
    else
      v270 = 0;
    v271 = (_QWORD *)(v269 + 32 * v266);
    v272 = v269 + 32 * v270;
    *v271 = CFSTR("High Freq for Blocked Mic Detection Band");
    v271[1] = 0x8000000000000008;
    v271[2] = 0x469C400000000000;
    v271[3] = 0x645FA0000;
    v265 = (char *)(v271 + 4);
    v273 = *(char **)(a1 + 536);
    v274 = *(char **)(a1 + 528);
    if (v273 != v274)
    {
      do
      {
        v275 = *((_OWORD *)v273 - 1);
        *((_OWORD *)v271 - 2) = *((_OWORD *)v273 - 2);
        *((_OWORD *)v271 - 1) = v275;
        v271 -= 4;
        v273 -= 32;
      }
      while (v273 != v274);
      v273 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v271;
    *(_QWORD *)(a1 + 536) = v265;
    *(_QWORD *)(a1 + 544) = v272;
    if (v273)
      operator delete(v273);
  }
  else
  {
    *(_QWORD *)v253 = CFSTR("High Freq for Blocked Mic Detection Band");
    *((_QWORD *)v253 + 1) = 0x8000000000000008;
    *((_QWORD *)v253 + 2) = 0x469C400000000000;
    *((_QWORD *)v253 + 3) = 0x645FA0000;
    v265 = v253 + 32;
  }
  *(_QWORD *)(a1 + 536) = v265;
  v276 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v265 >= v276)
  {
    v278 = (v265 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v278 + 1) >> 59)
      goto LABEL_717;
    v279 = v276 - (_QWORD)*v4;
    v280 = v279 >> 4;
    if (v279 >> 4 <= (unint64_t)(v278 + 1))
      v280 = v278 + 1;
    if ((unint64_t)v279 >= 0x7FFFFFFFFFFFFFE0)
      v281 = 0x7FFFFFFFFFFFFFFLL;
    else
      v281 = v280;
    if (v281)
      v281 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v281);
    else
      v282 = 0;
    v283 = (_QWORD *)(v281 + 32 * v278);
    v284 = v281 + 32 * v282;
    *v283 = CFSTR("Coherence Thr in Blocked Mic Detection Band");
    v283[1] = 0x8000000000000000;
    v283[2] = 0x3F80000000000000;
    v283[3] = 0x63F000000;
    v277 = (char *)(v283 + 4);
    v285 = *(char **)(a1 + 536);
    v286 = *(char **)(a1 + 528);
    if (v285 != v286)
    {
      do
      {
        v287 = *((_OWORD *)v285 - 1);
        *((_OWORD *)v283 - 2) = *((_OWORD *)v285 - 2);
        *((_OWORD *)v283 - 1) = v287;
        v283 -= 4;
        v285 -= 32;
      }
      while (v285 != v286);
      v285 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v283;
    *(_QWORD *)(a1 + 536) = v277;
    *(_QWORD *)(a1 + 544) = v284;
    if (v285)
      operator delete(v285);
  }
  else
  {
    *(_QWORD *)v265 = CFSTR("Coherence Thr in Blocked Mic Detection Band");
    *((_QWORD *)v265 + 1) = 0x8000000000000000;
    *((_QWORD *)v265 + 2) = 0x3F80000000000000;
    *((_QWORD *)v265 + 3) = 0x63F000000;
    v277 = v265 + 32;
  }
  *(_QWORD *)(a1 + 536) = v277;
  v288 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v277 >= v288)
  {
    v290 = (v277 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v290 + 1) >> 59)
      goto LABEL_717;
    v291 = v288 - (_QWORD)*v4;
    v292 = v291 >> 4;
    if (v291 >> 4 <= (unint64_t)(v290 + 1))
      v292 = v290 + 1;
    if ((unint64_t)v291 >= 0x7FFFFFFFFFFFFFE0)
      v293 = 0x7FFFFFFFFFFFFFFLL;
    else
      v293 = v292;
    if (v293)
      v293 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v293);
    else
      v294 = 0;
    v295 = (_QWORD *)(v293 + 32 * v290);
    v296 = v293 + 32 * v294;
    *v295 = CFSTR("Energy Thr in Blocked Mic Detection Band");
    v295[1] = 0x8000000000000000;
    v295[2] = 0x43480000C3480000;
    v295[3] = 0x6C2DC0000;
    v289 = (char *)(v295 + 4);
    v297 = *(char **)(a1 + 536);
    v298 = *(char **)(a1 + 528);
    if (v297 != v298)
    {
      do
      {
        v299 = *((_OWORD *)v297 - 1);
        *((_OWORD *)v295 - 2) = *((_OWORD *)v297 - 2);
        *((_OWORD *)v295 - 1) = v299;
        v295 -= 4;
        v297 -= 32;
      }
      while (v297 != v298);
      v297 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v295;
    *(_QWORD *)(a1 + 536) = v289;
    *(_QWORD *)(a1 + 544) = v296;
    if (v297)
      operator delete(v297);
  }
  else
  {
    *(_QWORD *)v277 = CFSTR("Energy Thr in Blocked Mic Detection Band");
    *((_QWORD *)v277 + 1) = 0x8000000000000000;
    *((_QWORD *)v277 + 2) = 0x43480000C3480000;
    *((_QWORD *)v277 + 3) = 0x6C2DC0000;
    v289 = v277 + 32;
  }
  *(_QWORD *)(a1 + 536) = v289;
  v300 = *(_QWORD *)(a1 + 544);
  if ((unint64_t)v289 >= v300)
  {
    v302 = (v289 - (_BYTE *)*v4) >> 5;
    if ((unint64_t)(v302 + 1) >> 59)
      goto LABEL_717;
    v303 = v300 - (_QWORD)*v4;
    v304 = v303 >> 4;
    if (v303 >> 4 <= (unint64_t)(v302 + 1))
      v304 = v302 + 1;
    if ((unint64_t)v303 >= 0x7FFFFFFFFFFFFFE0)
      v305 = 0x7FFFFFFFFFFFFFFLL;
    else
      v305 = v304;
    if (v305)
      v305 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v305);
    else
      v306 = 0;
    v307 = (_QWORD *)(v305 + 32 * v302);
    v308 = v305 + 32 * v306;
    *v307 = CFSTR("Energy Ration Thr in Blocked Mic Detection Band");
    v307[1] = 0x8000000000000000;
    v307[2] = 0x43480000C3480000;
    v307[3] = 0x641200000;
    v301 = v307 + 4;
    v309 = *(char **)(a1 + 536);
    v310 = *(char **)(a1 + 528);
    if (v309 != v310)
    {
      do
      {
        v311 = *((_OWORD *)v309 - 1);
        *((_OWORD *)v307 - 2) = *((_OWORD *)v309 - 2);
        *((_OWORD *)v307 - 1) = v311;
        v307 -= 4;
        v309 -= 32;
      }
      while (v309 != v310);
      v309 = (char *)*v4;
    }
    *(_QWORD *)(a1 + 528) = v307;
    *(_QWORD *)(a1 + 536) = v301;
    *(_QWORD *)(a1 + 544) = v308;
    if (v309)
      operator delete(v309);
  }
  else
  {
    *(_QWORD *)v289 = CFSTR("Energy Ration Thr in Blocked Mic Detection Band");
    *((_QWORD *)v289 + 1) = 0x8000000000000000;
    *((_QWORD *)v289 + 2) = 0x43480000C3480000;
    *((_QWORD *)v289 + 3) = 0x641200000;
    v301 = v289 + 32;
  }
  *(_QWORD *)(a1 + 536) = v301;
  v312 = *(_QWORD **)(a1 + 560);
  v313 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v312 >= v313)
  {
    v315 = *(_QWORD *)(a1 + 552);
    v316 = ((uint64_t)v312 - v315) >> 5;
    v317 = v316 + 1;
    if ((unint64_t)(v316 + 1) >> 59)
      goto LABEL_717;
    v318 = v313 - v315;
    if (v318 >> 4 > v317)
      v317 = v318 >> 4;
    if ((unint64_t)v318 >= 0x7FFFFFFFFFFFFFE0)
      v319 = 0x7FFFFFFFFFFFFFFLL;
    else
      v319 = v317;
    if (v319)
      v319 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v319);
    else
      v320 = 0;
    v321 = (_QWORD *)(v319 + 32 * v316);
    v322 = v319 + 32 * v320;
    *v321 = CFSTR("Wind Probability");
    v321[1] = 0xA00000000000;
    v321[2] = 0x3F80000000000000;
    v321[3] = 0xFFFFFFFF00000000;
    v314 = v321 + 4;
    v323 = *(char **)(a1 + 560);
    v324 = *(char **)(a1 + 552);
    if (v323 != v324)
    {
      do
      {
        v325 = *((_OWORD *)v323 - 1);
        *((_OWORD *)v321 - 2) = *((_OWORD *)v323 - 2);
        *((_OWORD *)v321 - 1) = v325;
        v321 -= 4;
        v323 -= 32;
      }
      while (v323 != v324);
      v323 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v321;
    *(_QWORD *)(a1 + 560) = v314;
    *(_QWORD *)(a1 + 568) = v322;
    if (v323)
      operator delete(v323);
  }
  else
  {
    *v312 = CFSTR("Wind Probability");
    v312[1] = 0xA00000000000;
    v312[2] = 0x3F80000000000000;
    v312[3] = 0xFFFFFFFF00000000;
    v314 = v312 + 4;
  }
  *(_QWORD *)(a1 + 560) = v314;
  v326 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v314 >= v326)
  {
    v328 = *(_QWORD *)(a1 + 552);
    v329 = ((uint64_t)v314 - v328) >> 5;
    if ((unint64_t)(v329 + 1) >> 59)
      goto LABEL_717;
    v330 = v326 - v328;
    v331 = v330 >> 4;
    if (v330 >> 4 <= (unint64_t)(v329 + 1))
      v331 = v329 + 1;
    if ((unint64_t)v330 >= 0x7FFFFFFFFFFFFFE0)
      v332 = 0x7FFFFFFFFFFFFFFLL;
    else
      v332 = v331;
    if (v332)
      v332 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v332);
    else
      v333 = 0;
    v334 = (_QWORD *)(v332 + 32 * v329);
    v335 = v332 + 32 * v333;
    *v334 = CFSTR("Wind Flag");
    v334[1] = 0xA00000000000;
    v334[2] = 0x3F80000000000000;
    v334[3] = 0xFFFFFFFF00000000;
    v327 = v334 + 4;
    v336 = *(char **)(a1 + 560);
    v337 = *(char **)(a1 + 552);
    if (v336 != v337)
    {
      do
      {
        v338 = *((_OWORD *)v336 - 1);
        *((_OWORD *)v334 - 2) = *((_OWORD *)v336 - 2);
        *((_OWORD *)v334 - 1) = v338;
        v334 -= 4;
        v336 -= 32;
      }
      while (v336 != v337);
      v336 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v334;
    *(_QWORD *)(a1 + 560) = v327;
    *(_QWORD *)(a1 + 568) = v335;
    if (v336)
      operator delete(v336);
  }
  else
  {
    *v314 = CFSTR("Wind Flag");
    v314[1] = 0xA00000000000;
    v314[2] = 0x3F80000000000000;
    v314[3] = 0xFFFFFFFF00000000;
    v327 = v314 + 4;
  }
  *(_QWORD *)(a1 + 560) = v327;
  v339 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v327 >= v339)
  {
    v341 = *(_QWORD *)(a1 + 552);
    v342 = ((uint64_t)v327 - v341) >> 5;
    if ((unint64_t)(v342 + 1) >> 59)
      goto LABEL_717;
    v343 = v339 - v341;
    v344 = v343 >> 4;
    if (v343 >> 4 <= (unint64_t)(v342 + 1))
      v344 = v342 + 1;
    if ((unint64_t)v343 >= 0x7FFFFFFFFFFFFFE0)
      v345 = 0x7FFFFFFFFFFFFFFLL;
    else
      v345 = v344;
    if (v345)
      v345 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v345);
    else
      v346 = 0;
    v347 = (_QWORD *)(v345 + 32 * v342);
    v348 = v345 + 32 * v346;
    *v347 = CFSTR("Blocked Mic Probability");
    v347[1] = 0xA00000000000;
    v347[2] = 0x3F80000000000000;
    v347[3] = 0xFFFFFFFF00000000;
    v340 = v347 + 4;
    v349 = *(char **)(a1 + 560);
    v350 = *(char **)(a1 + 552);
    if (v349 != v350)
    {
      do
      {
        v351 = *((_OWORD *)v349 - 1);
        *((_OWORD *)v347 - 2) = *((_OWORD *)v349 - 2);
        *((_OWORD *)v347 - 1) = v351;
        v347 -= 4;
        v349 -= 32;
      }
      while (v349 != v350);
      v349 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v347;
    *(_QWORD *)(a1 + 560) = v340;
    *(_QWORD *)(a1 + 568) = v348;
    if (v349)
      operator delete(v349);
  }
  else
  {
    *v327 = CFSTR("Blocked Mic Probability");
    v327[1] = 0xA00000000000;
    v327[2] = 0x3F80000000000000;
    v327[3] = 0xFFFFFFFF00000000;
    v340 = v327 + 4;
  }
  *(_QWORD *)(a1 + 560) = v340;
  v352 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v340 >= v352)
  {
    v354 = *(_QWORD *)(a1 + 552);
    v355 = ((uint64_t)v340 - v354) >> 5;
    if ((unint64_t)(v355 + 1) >> 59)
      goto LABEL_717;
    v356 = v352 - v354;
    v357 = v356 >> 4;
    if (v356 >> 4 <= (unint64_t)(v355 + 1))
      v357 = v355 + 1;
    if ((unint64_t)v356 >= 0x7FFFFFFFFFFFFFE0)
      v358 = 0x7FFFFFFFFFFFFFFLL;
    else
      v358 = v357;
    if (v358)
      v358 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v358);
    else
      v359 = 0;
    v360 = (_QWORD *)(v358 + 32 * v355);
    v361 = v358 + 32 * v359;
    *v360 = CFSTR("Blocked Mic Flag");
    v360[1] = 0xA00000000001;
    v360[2] = 0x3F80000000000000;
    v360[3] = 0xFFFFFFFF00000000;
    v353 = v360 + 4;
    v362 = *(char **)(a1 + 560);
    v363 = *(char **)(a1 + 552);
    if (v362 != v363)
    {
      do
      {
        v364 = *((_OWORD *)v362 - 1);
        *((_OWORD *)v360 - 2) = *((_OWORD *)v362 - 2);
        *((_OWORD *)v360 - 1) = v364;
        v360 -= 4;
        v362 -= 32;
      }
      while (v362 != v363);
      v362 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v360;
    *(_QWORD *)(a1 + 560) = v353;
    *(_QWORD *)(a1 + 568) = v361;
    if (v362)
      operator delete(v362);
  }
  else
  {
    *v340 = CFSTR("Blocked Mic Flag");
    v340[1] = 0xA00000000001;
    v340[2] = 0x3F80000000000000;
    v340[3] = 0xFFFFFFFF00000000;
    v353 = v340 + 4;
  }
  *(_QWORD *)(a1 + 560) = v353;
  v365 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v353 >= v365)
  {
    v367 = *(_QWORD *)(a1 + 552);
    v368 = ((uint64_t)v353 - v367) >> 5;
    if ((unint64_t)(v368 + 1) >> 59)
      goto LABEL_717;
    v369 = v365 - v367;
    v370 = v369 >> 4;
    if (v369 >> 4 <= (unint64_t)(v368 + 1))
      v370 = v368 + 1;
    if ((unint64_t)v369 >= 0x7FFFFFFFFFFFFFE0)
      v371 = 0x7FFFFFFFFFFFFFFLL;
    else
      v371 = v370;
    if (v371)
      v371 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v371);
    else
      v372 = 0;
    v373 = (_QWORD *)(v371 + 32 * v368);
    v374 = v371 + 32 * v372;
    *v373 = CFSTR("Wind Level");
    v373[1] = 0xA0000000000DLL;
    v373[2] = 0x42700000C30C0000;
    v373[3] = 0xFFFFFFFF00000000;
    v366 = v373 + 4;
    v375 = *(char **)(a1 + 560);
    v376 = *(char **)(a1 + 552);
    if (v375 != v376)
    {
      do
      {
        v377 = *((_OWORD *)v375 - 1);
        *((_OWORD *)v373 - 2) = *((_OWORD *)v375 - 2);
        *((_OWORD *)v373 - 1) = v377;
        v373 -= 4;
        v375 -= 32;
      }
      while (v375 != v376);
      v375 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v373;
    *(_QWORD *)(a1 + 560) = v366;
    *(_QWORD *)(a1 + 568) = v374;
    if (v375)
      operator delete(v375);
  }
  else
  {
    *v353 = CFSTR("Wind Level");
    v353[1] = 0xA0000000000DLL;
    v353[2] = 0x42700000C30C0000;
    v353[3] = 0xFFFFFFFF00000000;
    v366 = v353 + 4;
  }
  *(_QWORD *)(a1 + 560) = v366;
  v378 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v366 >= v378)
  {
    v380 = *(_QWORD *)(a1 + 552);
    v381 = ((uint64_t)v366 - v380) >> 5;
    if ((unint64_t)(v381 + 1) >> 59)
      goto LABEL_717;
    v382 = v378 - v380;
    v383 = v382 >> 4;
    if (v382 >> 4 <= (unint64_t)(v381 + 1))
      v383 = v381 + 1;
    if ((unint64_t)v382 >= 0x7FFFFFFFFFFFFFE0)
      v384 = 0x7FFFFFFFFFFFFFFLL;
    else
      v384 = v383;
    if (v384)
      v384 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v384);
    else
      v385 = 0;
    v386 = (_QWORD *)(v384 + 32 * v381);
    v387 = v384 + 32 * v385;
    *v386 = CFSTR("Mic Gain Linear");
    v386[1] = 0xA00000000000;
    v386[2] = 0x3F80000000000000;
    v386[3] = 0xFFFFFFFF00000000;
    v379 = v386 + 4;
    v388 = *(char **)(a1 + 560);
    v389 = *(char **)(a1 + 552);
    if (v388 != v389)
    {
      do
      {
        v390 = *((_OWORD *)v388 - 1);
        *((_OWORD *)v386 - 2) = *((_OWORD *)v388 - 2);
        *((_OWORD *)v386 - 1) = v390;
        v386 -= 4;
        v388 -= 32;
      }
      while (v388 != v389);
      v388 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v386;
    *(_QWORD *)(a1 + 560) = v379;
    *(_QWORD *)(a1 + 568) = v387;
    if (v388)
      operator delete(v388);
  }
  else
  {
    *v366 = CFSTR("Mic Gain Linear");
    v366[1] = 0xA00000000000;
    v366[2] = 0x3F80000000000000;
    v366[3] = 0xFFFFFFFF00000000;
    v379 = v366 + 4;
  }
  *(_QWORD *)(a1 + 560) = v379;
  v391 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v379 >= v391)
  {
    v393 = *(_QWORD *)(a1 + 552);
    v394 = ((uint64_t)v379 - v393) >> 5;
    if ((unint64_t)(v394 + 1) >> 59)
      goto LABEL_717;
    v395 = v391 - v393;
    v396 = v395 >> 4;
    if (v395 >> 4 <= (unint64_t)(v394 + 1))
      v396 = v394 + 1;
    if ((unint64_t)v395 >= 0x7FFFFFFFFFFFFFE0)
      v397 = 0x7FFFFFFFFFFFFFFLL;
    else
      v397 = v396;
    if (v397)
      v397 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v397);
    else
      v398 = 0;
    v399 = (_QWORD *)(v397 + 32 * v394);
    v400 = v397 + 32 * v398;
    *v399 = CFSTR("ECLee Engergy from EC");
    v399[1] = 0xA00000000000;
    v399[2] = 0x43480000C3480000;
    v399[3] = 0xFFFFFFFF00000000;
    v392 = v399 + 4;
    v401 = *(char **)(a1 + 560);
    v402 = *(char **)(a1 + 552);
    if (v401 != v402)
    {
      do
      {
        v403 = *((_OWORD *)v401 - 1);
        *((_OWORD *)v399 - 2) = *((_OWORD *)v401 - 2);
        *((_OWORD *)v399 - 1) = v403;
        v399 -= 4;
        v401 -= 32;
      }
      while (v401 != v402);
      v401 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v399;
    *(_QWORD *)(a1 + 560) = v392;
    *(_QWORD *)(a1 + 568) = v400;
    if (v401)
      operator delete(v401);
  }
  else
  {
    *v379 = CFSTR("ECLee Engergy from EC");
    v379[1] = 0xA00000000000;
    v379[2] = 0x43480000C3480000;
    v379[3] = 0xFFFFFFFF00000000;
    v392 = v379 + 4;
  }
  *(_QWORD *)(a1 + 560) = v392;
  v404 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v392 >= v404)
  {
    v406 = *(_QWORD *)(a1 + 552);
    v407 = ((uint64_t)v392 - v406) >> 5;
    if ((unint64_t)(v407 + 1) >> 59)
      goto LABEL_717;
    v408 = v404 - v406;
    v409 = v408 >> 4;
    if (v408 >> 4 <= (unint64_t)(v407 + 1))
      v409 = v407 + 1;
    if ((unint64_t)v408 >= 0x7FFFFFFFFFFFFFE0)
      v410 = 0x7FFFFFFFFFFFFFFLL;
    else
      v410 = v409;
    if (v410)
      v410 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v410);
    else
      v411 = 0;
    v412 = (_QWORD *)(v410 + 32 * v407);
    v413 = v410 + 32 * v411;
    *v412 = CFSTR("Echo2Lv from EC");
    v412[1] = 0xA00000000000;
    v412[2] = 0x43480000C3480000;
    v412[3] = 0xFFFFFFFF00000000;
    v405 = v412 + 4;
    v414 = *(char **)(a1 + 560);
    v415 = *(char **)(a1 + 552);
    if (v414 != v415)
    {
      do
      {
        v416 = *((_OWORD *)v414 - 1);
        *((_OWORD *)v412 - 2) = *((_OWORD *)v414 - 2);
        *((_OWORD *)v412 - 1) = v416;
        v412 -= 4;
        v414 -= 32;
      }
      while (v414 != v415);
      v414 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v412;
    *(_QWORD *)(a1 + 560) = v405;
    *(_QWORD *)(a1 + 568) = v413;
    if (v414)
      operator delete(v414);
  }
  else
  {
    *v392 = CFSTR("Echo2Lv from EC");
    v392[1] = 0xA00000000000;
    v392[2] = 0x43480000C3480000;
    v392[3] = 0xFFFFFFFF00000000;
    v405 = v392 + 4;
  }
  *(_QWORD *)(a1 + 560) = v405;
  v417 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v405 >= v417)
  {
    v419 = *(_QWORD *)(a1 + 552);
    v420 = ((uint64_t)v405 - v419) >> 5;
    if ((unint64_t)(v420 + 1) >> 59)
      goto LABEL_717;
    v421 = v417 - v419;
    v422 = v421 >> 4;
    if (v421 >> 4 <= (unint64_t)(v420 + 1))
      v422 = v420 + 1;
    if ((unint64_t)v421 >= 0x7FFFFFFFFFFFFFE0)
      v423 = 0x7FFFFFFFFFFFFFFLL;
    else
      v423 = v422;
    if (v423)
      v423 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v423);
    else
      v424 = 0;
    v425 = (_QWORD *)(v423 + 32 * v420);
    v426 = v423 + 32 * v424;
    *v425 = CFSTR("Echo Flag from EC");
    v425[1] = 0xA00000000000;
    v425[2] = 0x3F80000000000000;
    v425[3] = 0xFFFFFFFF00000000;
    v418 = v425 + 4;
    v427 = *(char **)(a1 + 560);
    v428 = *(char **)(a1 + 552);
    if (v427 != v428)
    {
      do
      {
        v429 = *((_OWORD *)v427 - 1);
        *((_OWORD *)v425 - 2) = *((_OWORD *)v427 - 2);
        *((_OWORD *)v425 - 1) = v429;
        v425 -= 4;
        v427 -= 32;
      }
      while (v427 != v428);
      v427 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v425;
    *(_QWORD *)(a1 + 560) = v418;
    *(_QWORD *)(a1 + 568) = v426;
    if (v427)
      operator delete(v427);
  }
  else
  {
    *v405 = CFSTR("Echo Flag from EC");
    v405[1] = 0xA00000000000;
    v405[2] = 0x3F80000000000000;
    v405[3] = 0xFFFFFFFF00000000;
    v418 = v405 + 4;
  }
  *(_QWORD *)(a1 + 560) = v418;
  v430 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v418 >= v430)
  {
    v432 = *(_QWORD *)(a1 + 552);
    v433 = ((uint64_t)v418 - v432) >> 5;
    if ((unint64_t)(v433 + 1) >> 59)
      goto LABEL_717;
    v434 = v430 - v432;
    v435 = v434 >> 4;
    if (v434 >> 4 <= (unint64_t)(v433 + 1))
      v435 = v433 + 1;
    if ((unint64_t)v434 >= 0x7FFFFFFFFFFFFFE0)
      v436 = 0x7FFFFFFFFFFFFFFLL;
    else
      v436 = v435;
    if (v436)
      v436 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v436);
    else
      v437 = 0;
    v438 = (_QWORD *)(v436 + 32 * v433);
    v439 = v436 + 32 * v437;
    *v438 = CFSTR("Echo Leakage from EC");
    v438[1] = 0xA00000000000;
    v438[2] = 0x43480000C3480000;
    v438[3] = 0xFFFFFFFF00000000;
    v431 = v438 + 4;
    v440 = *(char **)(a1 + 560);
    v441 = *(char **)(a1 + 552);
    if (v440 != v441)
    {
      do
      {
        v442 = *((_OWORD *)v440 - 1);
        *((_OWORD *)v438 - 2) = *((_OWORD *)v440 - 2);
        *((_OWORD *)v438 - 1) = v442;
        v438 -= 4;
        v440 -= 32;
      }
      while (v440 != v441);
      v440 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v438;
    *(_QWORD *)(a1 + 560) = v431;
    *(_QWORD *)(a1 + 568) = v439;
    if (v440)
      operator delete(v440);
  }
  else
  {
    *v418 = CFSTR("Echo Leakage from EC");
    v418[1] = 0xA00000000000;
    v418[2] = 0x43480000C3480000;
    v418[3] = 0xFFFFFFFF00000000;
    v431 = v418 + 4;
  }
  *(_QWORD *)(a1 + 560) = v431;
  v443 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v431 >= v443)
  {
    v445 = *(_QWORD *)(a1 + 552);
    v446 = ((uint64_t)v431 - v445) >> 5;
    if ((unint64_t)(v446 + 1) >> 59)
      goto LABEL_717;
    v447 = v443 - v445;
    v448 = v447 >> 4;
    if (v447 >> 4 <= (unint64_t)(v446 + 1))
      v448 = v446 + 1;
    if ((unint64_t)v447 >= 0x7FFFFFFFFFFFFFE0)
      v449 = 0x7FFFFFFFFFFFFFFLL;
    else
      v449 = v448;
    if (v449)
      v449 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v449);
    else
      v450 = 0;
    v451 = (_QWORD *)(v449 + 32 * v446);
    v452 = v449 + 32 * v450;
    *v451 = CFSTR("Threshold on ECLee Energy");
    v451[1] = 0x8000000000000000;
    v451[2] = 0x43480000C3480000;
    v451[3] = -1018691584;
    v444 = v451 + 4;
    v453 = *(char **)(a1 + 560);
    v454 = *(char **)(a1 + 552);
    if (v453 != v454)
    {
      do
      {
        v455 = *((_OWORD *)v453 - 1);
        *((_OWORD *)v451 - 2) = *((_OWORD *)v453 - 2);
        *((_OWORD *)v451 - 1) = v455;
        v451 -= 4;
        v453 -= 32;
      }
      while (v453 != v454);
      v453 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v451;
    *(_QWORD *)(a1 + 560) = v444;
    *(_QWORD *)(a1 + 568) = v452;
    if (v453)
      operator delete(v453);
  }
  else
  {
    *v431 = CFSTR("Threshold on ECLee Energy");
    v431[1] = 0x8000000000000000;
    v431[2] = 0x43480000C3480000;
    v431[3] = -1018691584;
    v444 = v431 + 4;
  }
  v456 = 0;
  *(_QWORD *)(a1 + 560) = v444;
  do
  {
    v457 = *(_QWORD *)(a1 + 568);
    if ((unint64_t)v444 >= v457)
    {
      v458 = *(_QWORD *)(a1 + 552);
      v459 = ((uint64_t)v444 - v458) >> 5;
      if ((unint64_t)(v459 + 1) >> 59)
        goto LABEL_717;
      v460 = v457 - v458;
      v461 = v460 >> 4;
      if (v460 >> 4 <= (unint64_t)(v459 + 1))
        v461 = v459 + 1;
      if ((unint64_t)v460 >= 0x7FFFFFFFFFFFFFE0)
        v462 = 0x7FFFFFFFFFFFFFFLL;
      else
        v462 = v461;
      if (v462)
        v462 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v462);
      else
        v463 = 0;
      v464 = (_QWORD *)(v462 + 32 * v459);
      *v464 = CFSTR("Threshold on ECLee Energy Diff");
      v464[1] = 0x8000000000000000;
      v464[2] = 0x43480000C3480000;
      v464[3] = -3166175232;
      v465 = *(char **)(a1 + 560);
      v466 = *(char **)(a1 + 552);
      v467 = v464;
      if (v465 != v466)
      {
        do
        {
          v468 = *((_OWORD *)v465 - 1);
          *((_OWORD *)v467 - 2) = *((_OWORD *)v465 - 2);
          *((_OWORD *)v467 - 1) = v468;
          v467 -= 4;
          v465 -= 32;
        }
        while (v465 != v466);
        v465 = *(char **)(a1 + 552);
      }
      *(_QWORD *)(a1 + 552) = v467;
      v444 = v464 + 4;
      *(_QWORD *)(a1 + 560) = v464 + 4;
      *(_QWORD *)(a1 + 568) = v462 + 32 * v463;
      if (v465)
        operator delete(v465);
    }
    else
    {
      *v444 = CFSTR("Threshold on ECLee Energy Diff");
      v444[1] = 0x8000000000000000;
      v444[2] = 0x43480000C3480000;
      v444[3] = -3166175232;
      v444 += 4;
    }
    *(_QWORD *)(a1 + 560) = v444;
    ++v456;
  }
  while (v456 != 8);
  v469 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v444 >= v469)
  {
    v471 = *(_QWORD *)(a1 + 552);
    v472 = ((uint64_t)v444 - v471) >> 5;
    if ((unint64_t)(v472 + 1) >> 59)
      goto LABEL_717;
    v473 = v469 - v471;
    v474 = v473 >> 4;
    if (v473 >> 4 <= (unint64_t)(v472 + 1))
      v474 = v472 + 1;
    if ((unint64_t)v473 >= 0x7FFFFFFFFFFFFFE0)
      v475 = 0x7FFFFFFFFFFFFFFLL;
    else
      v475 = v474;
    if (v475)
      v475 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v475);
    else
      v476 = 0;
    v477 = (_QWORD *)(v475 + 32 * v472);
    v478 = v475 + 32 * v476;
    *v477 = CFSTR("En Ratio Thr vs Ch0 for Blocked Mic In Echo");
    v477[1] = 0x8000000000000000;
    v477[2] = 0x43480000C3480000;
    v477[3] = -3202351104;
    v470 = v477 + 4;
    v479 = *(char **)(a1 + 560);
    v480 = *(char **)(a1 + 552);
    if (v479 != v480)
    {
      do
      {
        v481 = *((_OWORD *)v479 - 1);
        *((_OWORD *)v477 - 2) = *((_OWORD *)v479 - 2);
        *((_OWORD *)v477 - 1) = v481;
        v477 -= 4;
        v479 -= 32;
      }
      while (v479 != v480);
      v479 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v477;
    *(_QWORD *)(a1 + 560) = v470;
    *(_QWORD *)(a1 + 568) = v478;
    if (v479)
      operator delete(v479);
  }
  else
  {
    *v444 = CFSTR("En Ratio Thr vs Ch0 for Blocked Mic In Echo");
    v444[1] = 0x8000000000000000;
    v444[2] = 0x43480000C3480000;
    v444[3] = -3202351104;
    v470 = v444 + 4;
  }
  *(_QWORD *)(a1 + 560) = v470;
  v482 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v470 >= v482)
  {
    v484 = *(_QWORD *)(a1 + 552);
    v485 = ((uint64_t)v470 - v484) >> 5;
    if ((unint64_t)(v485 + 1) >> 59)
      goto LABEL_717;
    v486 = v482 - v484;
    v487 = v486 >> 4;
    if (v486 >> 4 <= (unint64_t)(v485 + 1))
      v487 = v485 + 1;
    if ((unint64_t)v486 >= 0x7FFFFFFFFFFFFFE0)
      v488 = 0x7FFFFFFFFFFFFFFLL;
    else
      v488 = v487;
    if (v488)
      v488 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v488);
    else
      v489 = 0;
    v490 = (_QWORD *)(v488 + 32 * v485);
    v491 = v488 + 32 * v489;
    *v490 = CFSTR("En Ratio Thr vs Ch1 for Blocked Mic In Echo");
    v490[1] = 0x8000000000000000;
    v490[2] = 0x43480000C3480000;
    v490[3] = -3191341056;
    v483 = v490 + 4;
    v492 = *(char **)(a1 + 560);
    v493 = *(char **)(a1 + 552);
    if (v492 != v493)
    {
      do
      {
        v494 = *((_OWORD *)v492 - 1);
        *((_OWORD *)v490 - 2) = *((_OWORD *)v492 - 2);
        *((_OWORD *)v490 - 1) = v494;
        v490 -= 4;
        v492 -= 32;
      }
      while (v492 != v493);
      v492 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v490;
    *(_QWORD *)(a1 + 560) = v483;
    *(_QWORD *)(a1 + 568) = v491;
    if (v492)
      operator delete(v492);
  }
  else
  {
    *v470 = CFSTR("En Ratio Thr vs Ch1 for Blocked Mic In Echo");
    v470[1] = 0x8000000000000000;
    v470[2] = 0x43480000C3480000;
    v470[3] = -3191341056;
    v483 = v470 + 4;
  }
  *(_QWORD *)(a1 + 560) = v483;
  v495 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v483 >= v495)
  {
    v497 = *(_QWORD *)(a1 + 552);
    v498 = ((uint64_t)v483 - v497) >> 5;
    if ((unint64_t)(v498 + 1) >> 59)
      goto LABEL_717;
    v499 = v495 - v497;
    v500 = v499 >> 4;
    if (v499 >> 4 <= (unint64_t)(v498 + 1))
      v500 = v498 + 1;
    if ((unint64_t)v499 >= 0x7FFFFFFFFFFFFFE0)
      v501 = 0x7FFFFFFFFFFFFFFLL;
    else
      v501 = v500;
    if (v501)
      v501 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v501);
    else
      v502 = 0;
    v503 = (_QWORD *)(v501 + 32 * v498);
    v504 = v501 + 32 * v502;
    *v503 = CFSTR("En Ratio Thr vs Ch2 for Blocked Mic In Echo");
    v503[1] = 0x8000000000000000;
    v503[2] = 0x43480000C3480000;
    v503[3] = -3202351104;
    v496 = v503 + 4;
    v505 = *(char **)(a1 + 560);
    v506 = *(char **)(a1 + 552);
    if (v505 != v506)
    {
      do
      {
        v507 = *((_OWORD *)v505 - 1);
        *((_OWORD *)v503 - 2) = *((_OWORD *)v505 - 2);
        *((_OWORD *)v503 - 1) = v507;
        v503 -= 4;
        v505 -= 32;
      }
      while (v505 != v506);
      v505 = *(char **)(a1 + 552);
    }
    *(_QWORD *)(a1 + 552) = v503;
    *(_QWORD *)(a1 + 560) = v496;
    *(_QWORD *)(a1 + 568) = v504;
    if (v505)
      operator delete(v505);
  }
  else
  {
    *v483 = CFSTR("En Ratio Thr vs Ch2 for Blocked Mic In Echo");
    v483[1] = 0x8000000000000000;
    v483[2] = 0x43480000C3480000;
    v483[3] = -3202351104;
    v496 = v483 + 4;
  }
  *(_QWORD *)(a1 + 560) = v496;
  v508 = *(_QWORD *)(a1 + 568);
  if ((unint64_t)v496 >= v508)
  {
    v510 = *(_QWORD *)(a1 + 552);
    v511 = ((uint64_t)v496 - v510) >> 5;
    if (!((unint64_t)(v511 + 1) >> 59))
    {
      v512 = v508 - v510;
      v513 = v512 >> 4;
      if (v512 >> 4 <= (unint64_t)(v511 + 1))
        v513 = v511 + 1;
      if ((unint64_t)v512 >= 0x7FFFFFFFFFFFFFE0)
        v514 = 0x7FFFFFFFFFFFFFFLL;
      else
        v514 = v513;
      if (v514)
        v514 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v514);
      else
        v515 = 0;
      v516 = (_QWORD *)(v514 + 32 * v511);
      v517 = v514 + 32 * v515;
      *v516 = CFSTR("En Ratio Thr vs Ch3 for Blocked Mic In Echo");
      v516[1] = 0x8000000000000000;
      v516[2] = 0x43480000C3480000;
      v516[3] = -3191341056;
      v509 = v516 + 4;
      v518 = *(char **)(a1 + 560);
      v519 = *(char **)(a1 + 552);
      if (v518 != v519)
      {
        do
        {
          v520 = *((_OWORD *)v518 - 1);
          *((_OWORD *)v516 - 2) = *((_OWORD *)v518 - 2);
          *((_OWORD *)v516 - 1) = v520;
          v516 -= 4;
          v518 -= 32;
        }
        while (v518 != v519);
        v518 = *(char **)(a1 + 552);
      }
      *(_QWORD *)(a1 + 552) = v516;
      *(_QWORD *)(a1 + 560) = v509;
      *(_QWORD *)(a1 + 568) = v517;
      if (v518)
        operator delete(v518);
      goto LABEL_664;
    }
LABEL_717:
    std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
  }
  *v496 = CFSTR("En Ratio Thr vs Ch3 for Blocked Mic In Echo");
  v496[1] = 0x8000000000000000;
  v496[2] = 0x43480000C3480000;
  v496[3] = -3191341056;
  v509 = v496 + 4;
LABEL_664:
  *(_QWORD *)(a1 + 560) = v509;
  for (i = 4; i != 8; ++i)
  {
    v522 = *(_QWORD *)(a1 + 568);
    if ((unint64_t)v509 >= v522)
    {
      v523 = *(_QWORD *)(a1 + 552);
      v524 = ((uint64_t)v509 - v523) >> 5;
      if ((unint64_t)(v524 + 1) >> 59)
        goto LABEL_717;
      v525 = v522 - v523;
      v526 = v525 >> 4;
      if (v525 >> 4 <= (unint64_t)(v524 + 1))
        v526 = v524 + 1;
      if ((unint64_t)v525 >= 0x7FFFFFFFFFFFFFE0)
        v527 = 0x7FFFFFFFFFFFFFFLL;
      else
        v527 = v526;
      if (v527)
        v527 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>(v527);
      else
        v528 = 0;
      v529 = (_QWORD *)(v527 + 32 * v524);
      *v529 = CFSTR("En Ratio Thr vs ChX for Blocked Mic In Echo");
      v529[1] = 0x8000000000000000;
      v529[2] = 0x43480000C3480000;
      v529[3] = -3166175232;
      v530 = *(char **)(a1 + 560);
      v531 = *(char **)(a1 + 552);
      v532 = v529;
      if (v530 != v531)
      {
        do
        {
          v533 = *((_OWORD *)v530 - 1);
          *((_OWORD *)v532 - 2) = *((_OWORD *)v530 - 2);
          *((_OWORD *)v532 - 1) = v533;
          v532 -= 4;
          v530 -= 32;
        }
        while (v530 != v531);
        v530 = *(char **)(a1 + 552);
      }
      *(_QWORD *)(a1 + 552) = v532;
      v509 = v529 + 4;
      *(_QWORD *)(a1 + 560) = v529 + 4;
      *(_QWORD *)(a1 + 568) = v527 + 32 * v528;
      if (v530)
        operator delete(v530);
    }
    else
    {
      *v509 = CFSTR("En Ratio Thr vs ChX for Blocked Mic In Echo");
      v509[1] = 0x8000000000000000;
      v509[2] = 0x43480000C3480000;
      v509[3] = -3166175232;
      v509 += 4;
    }
    *(_QWORD *)(a1 + 560) = v509;
  }
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v534 = *(_QWORD *)(a1 + 528);
  if (*(_QWORD *)(a1 + 536) != v534)
  {
    v535 = 0;
    v536 = 24;
    do
    {
      v537 = *(float *)(v534 + v536);
      Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
      ausdk::AUElement::SetParameter(Element, v535++, v537, 0);
      v534 = *(_QWORD *)(a1 + 528);
      v536 += 32;
    }
    while (v535 < (*(_QWORD *)(a1 + 536) - v534) >> 5);
  }
  for (j = 0; ; ++j)
  {
    v540 = *(_QWORD *)(a1 + 816);
    if (v540)
      LODWORD(v541) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v540 + 24))(v540);
    else
      v541 = (*(_QWORD *)(a1 + 800) - *(_QWORD *)(a1 + 792)) >> 3;
    if (j >= v541)
      break;
    v542 = *(_QWORD *)(a1 + 552);
    if (*(_QWORD *)(a1 + 560) != v542)
    {
      v543 = 0;
      v544 = 24;
      do
      {
        v545 = *(_QWORD *)(a1 + 816);
        if (v545)
        {
          v546 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v545 + 32))(v545, j);
          v542 = *(_QWORD *)(a1 + 552);
        }
        else
        {
          v547 = *(_QWORD *)(a1 + 792);
          if (j >= (*(_QWORD *)(a1 + 800) - v547) >> 3)
            v546 = 0;
          else
            v546 = *(ausdk::AUElement **)(v547 + 8 * j);
        }
        ausdk::AUElement::SetParameter(v546, v543++, *(float *)(v542 + v544), 0);
        v542 = *(_QWORD *)(a1 + 552);
        v544 += 32;
      }
      while (v543 < (*(_QWORD *)(a1 + 560) - v542) >> 5);
    }
  }
  v548 = 0;
  v565 = 0x40D7700000000000;
  v566 = xmmword_1B66A0BD0;
  v567 = xmmword_1B66A0BC0;
  while (1)
  {
    v549 = *(_QWORD *)(a1 + 120);
    if (v549)
      LODWORD(v550) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v549 + 24))(v549);
    else
      v550 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v548 >= v550)
      break;
    v551 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v548);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v551 + 56))(v551, &v565);
    ++v548;
  }
  v552 = 0;
  v562 = 0x40D7700000000000;
  v564 = xmmword_1B66A0BE0;
  v563 = xmmword_1B66A0BD0;
  v559 = 0x40D7700000000000;
  v560 = xmmword_1B6626900;
  v561 = xmmword_1B6626910;
  while (1)
  {
    v553 = *(_QWORD *)(a1 + 168);
    if (v553)
      LODWORD(v554) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v553 + 24))(v553);
    else
      v554 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (v552 >= v554)
      break;
    switch(v552)
    {
      case 0u:
      case 3u:
        v555 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), v552);
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v555 + 56))(v555, &v565);
        if (v552 == 2)
          goto LABEL_714;
        if (v552 == 1)
          goto LABEL_713;
        break;
      case 1u:
      case 4u:
LABEL_713:
        v556 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), v552);
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v556 + 56))(v556, &v562);
        if (v552 == 2)
          goto LABEL_714;
        break;
      case 2u:
LABEL_714:
        v557 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 2u);
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v557 + 56))(v557, &v559);
        break;
      default:
        break;
    }
    ++v552;
  }
  *(_BYTE *)(a1 + 376) = 1;
  return a1;
}

void sub_1B61C7824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11)
{
  uint64_t v11;
  void **v12;
  void *v14;
  void *v15;
  uint64_t v16;
  void *v17;
  void *v18;

  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v11 + 824);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a11);
  v14 = *(void **)(v11 + 752);
  if (v14)
  {
    *(_QWORD *)(v11 + 760) = v14;
    operator delete(v14);
  }
  a11 = (void **)(v11 + 728);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a11);
  a11 = (void **)(v11 + 704);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a11);
  v15 = *(void **)(v11 + 680);
  if (v15)
  {
    *(_QWORD *)(v11 + 688) = v15;
    operator delete(v15);
  }
  a11 = (void **)(v11 + 656);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a11);
  a11 = (void **)(v11 + 632);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a11);
  v16 = *(_QWORD *)(v11 + 624);
  *(_QWORD *)(v11 + 624) = 0;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  v17 = *(void **)(v11 + 552);
  if (v17)
  {
    *(_QWORD *)(v11 + 560) = v17;
    operator delete(v17);
  }
  v18 = *v12;
  if (*v12)
  {
    *(_QWORD *)(v11 + 536) = v18;
    operator delete(v18);
  }
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v11);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicIssueDetector>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSignalCombiner>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t **v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t **v10;
  uint64_t *v11;
  uint64_t **v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  uint64_t *v16;
  uint64_t **v17;
  unsigned int v18;
  _DWORD *v19;
  uint64_t *v20;
  uint64_t *v21;
  unsigned int v22;
  float v23;
  ausdk::AUElement *Element;
  uint64_t *v25;
  uint64_t *v26;
  BOOL v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  std::string *v31;
  __int128 v32;
  const char *v33;
  CFStringRef v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t j;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t *v46;
  unint64_t k;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  ausdk::AUElement *v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t *v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int m;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  std::string v65;
  _BYTE __p[40];

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 20, 21);
  v4 = 0;
  *(_QWORD *)v3 = &off_1E69D1578;
  *((_BYTE *)v3 + 528) = 0;
  *(_OWORD *)((char *)v3 + 532) = 0u;
  *(_OWORD *)((char *)v3 + 548) = xmmword_1B6627BC0;
  *(_QWORD *)((char *)v3 + 564) = 1;
  v5 = (uint64_t **)((char *)v3 + 576);
  v6 = (uint64_t **)((char *)v3 + 584);
  *((_QWORD *)v3 + 74) = 0;
  *((_QWORD *)v3 + 73) = 0;
  *((_QWORD *)v3 + 72) = (char *)v3 + 584;
  v7 = (uint64_t **)((char *)v3 + 600);
  v8 = (uint64_t *)((char *)v3 + 608);
  v9 = (uint64_t **)((char *)v3 + 608);
  *((_QWORD *)v3 + 77) = 0;
  *((_QWORD *)v3 + 76) = 0;
  *((_QWORD *)v3 + 75) = (char *)v3 + 608;
  *((_QWORD *)v3 + 80) = 0;
  *((_QWORD *)v3 + 79) = 0;
  *((_QWORD *)v3 + 78) = (char *)v3 + 632;
  v10 = (uint64_t **)((char *)v3 + 648);
  v11 = (uint64_t *)((char *)v3 + 656);
  v12 = (uint64_t **)((char *)v3 + 656);
  *((_QWORD *)v3 + 83) = 0;
  *((_QWORD *)v3 + 82) = 0;
  *((_QWORD *)v3 + 81) = (char *)v3 + 656;
  *((_DWORD *)v3 + 168) = 0;
  *((_WORD *)v3 + 338) = 0;
  *((_QWORD *)v3 + 85) = 0;
  *((_DWORD *)v3 + 172) = 0;
  *(_QWORD *)((char *)v3 + 692) = -1;
  *(_QWORD *)((char *)v3 + 700) = -1;
  *((_QWORD *)v3 + 90) = 0;
  *(_QWORD *)((char *)v3 + 708) = 0;
  *((_BYTE *)v3 + 716) = 0;
  do
  {
    v13 = a1 + v4;
    *(_QWORD *)(v13 + 728) = 0xFFFFFFFFLL;
    *(_BYTE *)(v13 + 736) = 0;
    *(_QWORD *)(a1 + v4 + 740) = 0xFFFFFFFFLL;
    *(_DWORD *)(v13 + 748) = -1;
    v4 += 24;
  }
  while (v4 != 480);
  *(_OWORD *)(a1 + 1600) = 0u;
  *(_OWORD *)(a1 + 1584) = 0u;
  *(_DWORD *)(a1 + 1576) = 0;
  *(_OWORD *)(a1 + 1208) = 0u;
  *(_OWORD *)(a1 + 1224) = 0u;
  *(_OWORD *)(a1 + 1240) = 0u;
  *(_OWORD *)(a1 + 1256) = 0u;
  *(_OWORD *)(a1 + 1272) = 0u;
  *(_OWORD *)(a1 + 1288) = 0u;
  *(_OWORD *)(a1 + 1304) = 0u;
  *(_OWORD *)(a1 + 1320) = 0u;
  *(_OWORD *)(a1 + 1336) = 0u;
  *(_OWORD *)(a1 + 1352) = 0u;
  *(_OWORD *)(a1 + 1368) = 0u;
  *(_OWORD *)(a1 + 1384) = 0u;
  *(_OWORD *)(a1 + 1400) = 0u;
  *(_OWORD *)(a1 + 1416) = 0u;
  *(_OWORD *)(a1 + 1432) = 0u;
  *(_OWORD *)(a1 + 1448) = 0u;
  *(_OWORD *)(a1 + 1464) = 0u;
  *(_OWORD *)(a1 + 1480) = 0u;
  *(_OWORD *)(a1 + 1496) = 0u;
  *(_OWORD *)(a1 + 1512) = 0u;
  *(_OWORD *)(a1 + 1528) = 0u;
  *(_OWORD *)(a1 + 1544) = 0u;
  *(_OWORD *)(a1 + 1560) = 0u;
  v14 = operator new(0x48uLL);
  v14[8] = 0;
  *((_QWORD *)v14 + 5) = CFSTR("Operation Mode");
  *((_QWORD *)v14 + 6) = 0x8000000000000001;
  *((_QWORD *)v14 + 7) = 0x3F80000000000000;
  *((_QWORD *)v14 + 8) = -3229614080;
  std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(v5, (uint64_t)v6, v6, (uint64_t *)v14);
  *(_DWORD *)__p = 10;
  *(_QWORD *)&__p[8] = CFSTR("Wind Flag");
  *(_OWORD *)&__p[16] = xmmword_1B66A0BF0;
  *(_QWORD *)&__p[32] = 0x100000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 11;
  *(_QWORD *)&__p[8] = CFSTR("Occlusion Flag");
  *(_OWORD *)&__p[16] = xmmword_1B66A0BF0;
  *(_QWORD *)&__p[32] = 0x100000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 50;
  *(_QWORD *)&__p[8] = CFSTR("Default Channel Selection");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C00;
  *(_QWORD *)&__p[32] = 0x200000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 51;
  *(_QWORD *)&__p[8] = CFSTR("External Channel Selection");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C10;
  *(_QWORD *)&__p[32] = 0x200000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 100;
  *(_QWORD *)&__p[8] = CFSTR("Main Mics Bus?");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C20;
  *(_QWORD *)&__p[32] = 0x3FFFFFFFFLL;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 101;
  *(_QWORD *)&__p[8] = CFSTR("ECLee Bus?");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C20;
  *(_QWORD *)&__p[32] = 0x3FFFFFFFFLL;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 102;
  *(_QWORD *)&__p[8] = CFSTR("Wind Suppressed Bus?");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C20;
  *(_QWORD *)&__p[32] = 0x3FFFFFFFFLL;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 103;
  *(_QWORD *)&__p[8] = CFSTR("Echo Suppressed Bus?");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C20;
  *(_QWORD *)&__p[32] = 0x3FFFFFFFFLL;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 150;
  *(_QWORD *)&__p[8] = CFSTR("Default Phase Bus");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C00;
  *(_QWORD *)&__p[32] = 0x400000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 151;
  *(_QWORD *)&__p[8] = CFSTR("Selected Phase Bus");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C10;
  *(_QWORD *)&__p[32] = 0x400000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 152;
  *(_QWORD *)&__p[8] = CFSTR("Low Frequency For Combining");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C30;
  *(_QWORD *)&__p[32] = 0x400000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 153;
  *(_QWORD *)&__p[8] = CFSTR("High Frequency For Combining");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C30;
  *(_QWORD *)&__p[32] = 0x400001B58;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 154;
  *(_QWORD *)&__p[8] = CFSTR("ECLee Energy");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C40;
  *(_QWORD *)&__p[32] = 0x400000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 155;
  *(_QWORD *)&__p[8] = CFSTR("ECLee Threshold");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C50;
  *(_QWORD *)&__p[32] = 0x4FFFFFFC4;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 156;
  *(_QWORD *)&__p[8] = CFSTR("ECLee Combine?");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C60;
  *(_QWORD *)&__p[32] = 0x400000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v5, (int32x2_t *)__p);
  *(_DWORD *)__p = 0;
  *(_QWORD *)&__p[8] = CFSTR("Default Channel Override");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C20;
  *(_QWORD *)&__p[32] = -1;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v7, (int32x2_t *)__p);
  v15 = operator new(0x48uLL);
  v15[8] = 1;
  *((_QWORD *)v15 + 5) = CFSTR("Channel Selection Rule");
  *((_QWORD *)v15 + 6) = 0x8000000000000001;
  *((_QWORD *)v15 + 7) = 0x4000000000000000;
  *((_QWORD *)v15 + 8) = 0xFFFFFFFF40000000;
  v16 = *v9;
  v17 = v9;
  if (*v9)
  {
    while (1)
    {
      while (1)
      {
        v17 = (uint64_t **)v16;
        v18 = *((_DWORD *)v16 + 8);
        if (v18 < 2)
          break;
        v16 = *v17;
        v9 = v17;
        if (!*v17)
          goto LABEL_10;
      }
      if (v18)
        break;
      v16 = v17[1];
      if (!v16)
      {
        v9 = v17 + 1;
        goto LABEL_10;
      }
    }
    operator delete(v15);
  }
  else
  {
LABEL_10:
    std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(v7, (uint64_t)v17, v9, (uint64_t *)v15);
  }
  *(_DWORD *)__p = 2;
  *(_QWORD *)&__p[8] = CFSTR("Combine?");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C60;
  *(_QWORD *)&__p[32] = 0xFFFFFFFF00000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v7, (int32x2_t *)__p);
  *(_DWORD *)__p = 3;
  *(_QWORD *)&__p[8] = CFSTR("Passthrough Output Bus?");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C20;
  *(_QWORD *)&__p[32] = -1;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v7, (int32x2_t *)__p);
  *(_DWORD *)__p = 50;
  *(_QWORD *)&__p[8] = CFSTR("Selected Channel");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C10;
  *(_QWORD *)&__p[32] = 0xFFFFFFFF00000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v7, (int32x2_t *)__p);
  *(_DWORD *)__p = 51;
  *(_QWORD *)&__p[8] = CFSTR("Combine Override");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C70;
  *(_QWORD *)&__p[32] = -1;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v7, (int32x2_t *)__p);
  v19 = operator new(0x48uLL);
  v19[8] = 0;
  *((_QWORD *)v19 + 5) = CFSTR("EC Delta EIR");
  *((_QWORD *)v19 + 6) = 0xA00000000000;
  *((_QWORD *)v19 + 7) = 0x501502F900000000;
  *((_QWORD *)v19 + 8) = 0xFFFFFFFF00000000;
  while (1)
  {
    v20 = *v12;
    if (!*v12)
      break;
    v12 = (uint64_t **)*v12;
    if (!*((_DWORD *)v20 + 8))
    {
      operator delete(v19);
      goto LABEL_17;
    }
  }
  std::__tree<std::__value_type<double,int>,std::__map_value_compare<double,std::__value_type<double,int>,std::less<double>,true>,std::allocator<std::__value_type<double,int>>>::__insert_node_at(v10, (uint64_t)v12, v12, (uint64_t *)v19);
LABEL_17:
  *(_DWORD *)__p = 1;
  *(_QWORD *)&__p[8] = CFSTR("EC IR Delay");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C80;
  *(_QWORD *)&__p[32] = 0xFFFFFFFF00000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v10, (int32x2_t *)__p);
  *(_DWORD *)__p = 2;
  *(_QWORD *)&__p[8] = CFSTR("EC Adapted flag");
  *(_OWORD *)&__p[16] = xmmword_1B66A0BF0;
  *(_QWORD *)&__p[32] = 0xFFFFFFFF00000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v10, (int32x2_t *)__p);
  *(_DWORD *)__p = 3;
  *(_QWORD *)&__p[8] = CFSTR("EC Time aligned ref signal energy");
  *(_OWORD *)&__p[16] = xmmword_1B66A0C90;
  *(_QWORD *)&__p[32] = 0xFFFFFFFF00000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v10, (int32x2_t *)__p);
  *(_DWORD *)__p = 4;
  *(_QWORD *)&__p[8] = CFSTR("EC Mic-Eclee cross correlation");
  *(_OWORD *)&__p[16] = xmmword_1B66A0BF0;
  *(_QWORD *)&__p[32] = 0xFFFFFFFF00000000;
  std::__tree<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,float,float,float,int>>>>::__emplace_unique_impl<std::pair<sicm::ParametersInScoped,std::tuple<__CFString const*,AudioUnitParameterUnit,unsigned int,int,int,int,int>>>(v10, (int32x2_t *)__p);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v21 = *v5;
  if (*v5 != (uint64_t *)v6)
  {
    do
    {
      v22 = *((_DWORD *)v21 + 8);
      v23 = *((float *)v21 + 16);
      Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
      ausdk::AUElement::SetParameter(Element, v22, v23, 0);
      v25 = (uint64_t *)v21[1];
      if (v25)
      {
        do
        {
          v26 = v25;
          v25 = (uint64_t *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          v26 = (uint64_t *)v21[2];
          v27 = *v26 == (_QWORD)v21;
          v21 = v26;
        }
        while (!v27);
      }
      v21 = v26;
    }
    while (v26 != (uint64_t *)v6);
  }
  for (i = 0; ; ++i)
  {
    v29 = *(_QWORD *)(a1 + 120);
    if (v29)
      LODWORD(v30) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
    else
      v30 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (i >= v30)
      break;
    std::to_string(&v65, i);
    v31 = std::string::insert(&v65, 0, "In", 2uLL);
    v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
    *(_QWORD *)&__p[16] = *((_QWORD *)&v31->__r_.__value_.__l + 2);
    *(_OWORD *)__p = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v65.__r_.__value_.__l.__data_);
    if (__p[23] >= 0)
      v33 = __p;
    else
      v33 = *(const char **)__p;
    v34 = CFStringCreateWithCString(0, v33, 0x8000100u);
    v35 = *(_QWORD *)(a1 + 120);
    if (v35)
    {
      v36 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v35 + 32))(v35, i);
    }
    else
    {
      v37 = *(_QWORD *)(a1 + 96);
      if (i >= (*(_QWORD *)(a1 + 104) - v37) >> 3)
        v36 = 0;
      else
        v36 = *(_QWORD *)(v37 + 8 * i);
    }
    ausdk::Owned<__CFString const*>::operator=((const void **)(v36 + 72), v34);
    CFRelease(v34);
    if ((__p[23] & 0x80000000) != 0)
      operator delete(*(void **)__p);
  }
  for (j = 0; ; ++j)
  {
    v39 = *(_QWORD *)(a1 + 120);
    if (v39)
      LODWORD(v40) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v39 + 24))(v39);
    else
      v40 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (j >= v40)
      break;
    v41 = *v7;
    if (*v7 != v8)
    {
      do
      {
        v42 = *(_QWORD *)(a1 + 120);
        if (v42)
        {
          v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v42 + 32))(v42, j);
        }
        else
        {
          v44 = *(_QWORD *)(a1 + 96);
          if (j >= (*(_QWORD *)(a1 + 104) - v44) >> 3)
            v43 = 0;
          else
            v43 = *(ausdk::AUElement **)(v44 + 8 * j);
        }
        ausdk::AUElement::SetParameter(v43, *((_DWORD *)v41 + 8), *((float *)v41 + 16), 0);
        v45 = (uint64_t *)v41[1];
        if (v45)
        {
          do
          {
            v46 = v45;
            v45 = (uint64_t *)*v45;
          }
          while (v45);
        }
        else
        {
          do
          {
            v46 = (uint64_t *)v41[2];
            v27 = *v46 == (_QWORD)v41;
            v41 = v46;
          }
          while (!v27);
        }
        v41 = v46;
      }
      while (v46 != v8);
    }
  }
  for (k = 0; ; ++k)
  {
    v48 = *(_QWORD *)(a1 + 1608);
    if (v48)
      LODWORD(v49) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v48 + 24))(v48);
    else
      v49 = (*(_QWORD *)(a1 + 1592) - *(_QWORD *)(a1 + 1584)) >> 3;
    if (k >= v49)
      break;
    v50 = *v10;
    if (*v10 != v11)
    {
      do
      {
        v51 = *(_QWORD *)(a1 + 1608);
        if (v51)
        {
          v52 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v51 + 32))(v51, k);
        }
        else
        {
          v53 = *(_QWORD *)(a1 + 1584);
          if (k >= (*(_QWORD *)(a1 + 1592) - v53) >> 3)
            v52 = 0;
          else
            v52 = *(ausdk::AUElement **)(v53 + 8 * k);
        }
        ausdk::AUElement::SetParameter(v52, *((_DWORD *)v50 + 8), *((float *)v50 + 16), 0);
        v54 = (uint64_t *)v50[1];
        if (v54)
        {
          do
          {
            v55 = v54;
            v54 = (uint64_t *)*v54;
          }
          while (v54);
        }
        else
        {
          do
          {
            v55 = (uint64_t *)v50[2];
            v27 = *v55 == (_QWORD)v50;
            v50 = v55;
          }
          while (!v27);
        }
        v50 = v55;
      }
      while (v55 != v11);
    }
  }
  v56 = 0;
  *(_QWORD *)__p = 0x40D7700000000000;
  *(_OWORD *)&__p[24] = xmmword_1B66A0BE0;
  *(_OWORD *)&__p[8] = xmmword_1B66A0BD0;
  while (1)
  {
    v57 = *(_QWORD *)(a1 + 120);
    if (v57)
      LODWORD(v58) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v57 + 24))(v57);
    else
      v58 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v56 >= v58)
      break;
    v59 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v56);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v59 + 56))(v59, __p);
    ++v56;
  }
  for (m = 0; ; ++m)
  {
    v61 = *(_QWORD *)(a1 + 168);
    if (v61)
      LODWORD(v62) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v61 + 24))(v61);
    else
      v62 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (m >= v62)
      break;
    v63 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), m);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v63 + 56))(v63, __p);
  }
  *(_BYTE *)(a1 + 376) = 1;
  return a1;
}

void sub_1B61C846C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  uint64_t v29;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;

  a17 = v29 + 1584;
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  v31 = *(void **)(v29 + 1544);
  if (v31)
  {
    *(_QWORD *)(v29 + 1552) = v31;
    operator delete(v31);
  }
  v32 = *(void **)(v29 + 1520);
  if (v32)
  {
    *(_QWORD *)(v29 + 1528) = v32;
    operator delete(v32);
  }
  v33 = *(void **)(v29 + 1496);
  if (v33)
  {
    *(_QWORD *)(v29 + 1504) = v33;
    operator delete(v33);
  }
  v34 = *(void **)(v29 + 1472);
  if (v34)
  {
    *(_QWORD *)(v29 + 1480) = v34;
    operator delete(v34);
  }
  v35 = *(void **)(v29 + 1448);
  if (v35)
  {
    *(_QWORD *)(v29 + 1456) = v35;
    operator delete(v35);
  }
  v36 = *(void **)(v29 + 1424);
  if (v36)
  {
    *(_QWORD *)(v29 + 1432) = v36;
    operator delete(v36);
  }
  v37 = *(void **)(v29 + 1400);
  if (v37)
  {
    *(_QWORD *)(v29 + 1408) = v37;
    operator delete(v37);
  }
  v38 = *(void **)(v29 + 1376);
  if (v38)
  {
    *(_QWORD *)(v29 + 1384) = v38;
    operator delete(v38);
  }
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*(_QWORD **)(v29 + 656));
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*(_QWORD **)(v29 + 632));
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*(_QWORD **)(v29 + 608));
  std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::destroy(*(_QWORD **)(v29 + 584));
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v29);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSignalCombiner>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUExpanseController>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  _OWORD *v3;
  int64x2_t *v4;
  unsigned int v5;
  char v6;
  char v7;
  uint64_t Element;
  unsigned int v9;
  char v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  uint64_t v25;
  ausdk::AUElement *v26;
  ausdk::AUElement **v27;
  uint64_t v28;
  ausdk::AUElement *v29;
  ausdk::AUElement **v30;
  uint64_t v31;
  ausdk::AUElement *v32;
  ausdk::AUElement **v33;
  uint64_t v34;
  ausdk::AUElement *v35;
  ausdk::AUElement **v36;
  uint64_t v37;
  ausdk::AUElement *v38;
  ausdk::AUElement **v39;
  uint64_t v40;
  ausdk::AUElement *v41;
  ausdk::AUElement **v42;
  NSObject *v43;
  _BYTE v45[24];
  __int128 v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v3 = (_OWORD *)((char *)a1 + 532);
  v4 = (int64x2_t *)ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 2, 2);
  v4->i64[0] = (uint64_t)&off_1E69D05F8;
  v4[33].i16[0] = 0;
  *v3 = xmmword_1B66A0CA0;
  v3[1] = xmmword_1B6629CC0;
  v4[35].i32[1] = 1065353216;
  v4[35].i64[1] = 1;
  ausdk::AUBase::CreateElements(v4);
  v5 = 0;
  *(_QWORD *)v45 = 0x40E7700000000000;
  *(_OWORD *)&v45[8] = xmmword_1B6626900;
  v46 = xmmword_1B6626910;
  v6 = 1;
  do
  {
    v7 = v6;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), v5);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)Element + 56))(Element, v45);
    v6 = 0;
    v5 = 1;
  }
  while ((v7 & 1) != 0);
  v9 = 0;
  v10 = 1;
  do
  {
    v11 = v10;
    v12 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), v9);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v12 + 56))(v12, v45);
    v10 = 0;
    v9 = 1;
  }
  while ((v11 & 1) != 0);
  v13 = a1[9];
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  }
  else
  {
    v15 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v15)
      v14 = 0;
    else
      v14 = *v15;
  }
  ausdk::AUElement::SetParameter(v14, 0, -15.0, 0);
  v16 = a1[9];
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  ausdk::AUElement::SetParameter(v17, 1u, -15.0, 0);
  v19 = a1[9];
  if (v19)
  {
    v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
  }
  else
  {
    v21 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v21)
      v20 = 0;
    else
      v20 = *v21;
  }
  ausdk::AUElement::SetParameter(v20, 2u, 0.0, 0);
  v22 = a1[9];
  if (v22)
  {
    v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
  }
  else
  {
    v24 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v24)
      v23 = 0;
    else
      v23 = *v24;
  }
  ausdk::AUElement::SetParameter(v23, 3u, 0.0, 0);
  v25 = a1[9];
  if (v25)
  {
    v26 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, 0);
  }
  else
  {
    v27 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v27)
      v26 = 0;
    else
      v26 = *v27;
  }
  ausdk::AUElement::SetParameter(v26, 4u, 0.0, 0);
  v28 = a1[9];
  if (v28)
  {
    v29 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 32))(v28, 0);
  }
  else
  {
    v30 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v30)
      v29 = 0;
    else
      v29 = *v30;
  }
  ausdk::AUElement::SetParameter(v29, 5u, 1.0, 0);
  v31 = a1[9];
  if (v31)
  {
    v32 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v31 + 32))(v31, 0);
  }
  else
  {
    v33 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v33)
      v32 = 0;
    else
      v32 = *v33;
  }
  ausdk::AUElement::SetParameter(v32, 6u, 0.0, 0);
  v34 = a1[9];
  if (v34)
  {
    v35 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v34 + 32))(v34, 0);
  }
  else
  {
    v36 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v36)
      v35 = 0;
    else
      v35 = *v36;
  }
  ausdk::AUElement::SetParameter(v35, 7u, 0.0, 0);
  v37 = a1[9];
  if (v37)
  {
    v38 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v37 + 32))(v37, 0);
  }
  else
  {
    v39 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v39)
      v38 = 0;
    else
      v38 = *v39;
  }
  ausdk::AUElement::SetParameter(v38, 8u, 0.0, 0);
  v40 = a1[9];
  if (v40)
  {
    v41 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v40 + 32))(v40, 0);
  }
  else
  {
    v42 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v42)
      v41 = 0;
    else
      v41 = *v42;
  }
  ausdk::AUElement::SetParameter(v41, 9u, 0.0, 0);
  if (getAUExpanseControllerLog(void)::onceToken != -1)
    dispatch_once(&getAUExpanseControllerLog(void)::onceToken, &__block_literal_global_6839);
  v43 = getAUExpanseControllerLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUExpanseControllerLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)v45 = 134217984;
    *(_QWORD *)&v45[4] = a1;
    _os_log_impl(&dword_1B5ED0000, v43, OS_LOG_TYPE_INFO, "[%p] created", v45, 0xCu);
  }
  return a1;
}

void sub_1B61C89D8(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;

  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUExpanseController>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUClipDetector>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t Element;
  unsigned int i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  _BYTE v14[24];
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69D3B38;
  *((_QWORD *)v3 + 66) = 0;
  *((_DWORD *)v3 + 134) = 0;
  *((_OWORD *)v3 + 34) = 0u;
  *((_OWORD *)v3 + 35) = 0u;
  *((_BYTE *)v3 + 576) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v4 = 0;
  *(_QWORD *)v14 = 0x40E7700000000000;
  *(_OWORD *)&v14[8] = xmmword_1B6626900;
  v15 = xmmword_1B6626910;
  while (1)
  {
    v5 = *(_QWORD *)(a1 + 120);
    if (v5)
      LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    else
      v6 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v4 >= v6)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v4);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)Element + 56))(Element, v14);
    ++v4;
  }
  for (i = 0; ; ++i)
  {
    v9 = *(_QWORD *)(a1 + 168);
    if (v9)
      LODWORD(v10) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    else
      v10 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v10)
      break;
    v11 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v11 + 56))(v11, v14);
  }
  AUClipDetector::SetDefaultParameters((AUClipDetector *)a1);
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, int), uint64_t))(*(_QWORD *)a1 + 112))(a1, 8, AUClipDetector::AUClipDetector(OpaqueAudioComponentInstance *)::$_0::__invoke<OpaqueAudioComponentInstance *,unsigned int,unsigned int,unsigned int>, a1);
  if (getAUClipDetectorLog(void)::onceToken != -1)
    dispatch_once(&getAUClipDetectorLog(void)::onceToken, &__block_literal_global_8933);
  v12 = getAUClipDetectorLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUClipDetectorLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)v14 = 134217984;
    *(_QWORD *)&v14[4] = a1;
    _os_log_impl(&dword_1B5ED0000, v12, OS_LOG_TYPE_INFO, "[%p] created", v14, 0xCu);
  }
  return a1;
}

void sub_1B61C8C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  void **v9;

  a9 = v9 + 68;
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a9);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v9);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUClipDetector>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULimitWindBoost>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  uint64_t v7;
  ausdk::AUElement *v8;
  ausdk::AUElement **v9;
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  uint64_t v25;
  ausdk::AUElement *v26;
  ausdk::AUElement **v27;
  uint64_t v28;
  ausdk::AUElement *v29;
  ausdk::AUElement **v30;
  uint64_t v31;
  ausdk::AUElement *v32;
  ausdk::AUElement **v33;
  uint64_t v34;
  ausdk::AUElement *v35;
  ausdk::AUElement **v36;
  uint64_t v37;
  ausdk::AUElement *v38;
  ausdk::AUElement **v39;
  uint64_t v40;
  ausdk::AUElement *v41;
  ausdk::AUElement **v42;
  uint64_t v43;
  ausdk::AUElement *v44;
  ausdk::AUElement **v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  ausdk::AUElement **v48;
  uint64_t v49;
  ausdk::AUElement *v50;
  ausdk::AUElement **v51;
  uint64_t v52;
  ausdk::AUElement *v53;
  ausdk::AUElement **v54;
  uint64_t v55;
  ausdk::AUElement *v56;
  ausdk::AUElement **v57;
  unsigned int *v58;
  unsigned int v59;
  uint64_t Element;
  uint64_t v61;
  unsigned int i;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;
  __int128 v71;
  __int128 v72;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 3, 1);
  *(_QWORD *)v3 = &off_1E69EA068;
  LimitWindBoost::LimitWindBoost((ausdk::AUBase *)((char *)v3 + 528));
  *(_DWORD *)(a1 + 928) = 0;
  *(_BYTE *)(a1 + 932) = 0;
  *(_DWORD *)(a1 + 936) = 1024;
  *(_QWORD *)(a1 + 944) = 0;
  *(_DWORD *)(a1 + 952) = 0;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 1024);
  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
  {
    v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  }
  else
  {
    v6 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v6)
      v5 = 0;
    else
      v5 = *v6;
  }
  ausdk::AUElement::SetParameter(v5, 0, 0.0, 0);
  v7 = *(_QWORD *)(a1 + 72);
  if (v7)
  {
    v8 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
  }
  else
  {
    v9 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v9)
      v8 = 0;
    else
      v8 = *v9;
  }
  ausdk::AUElement::SetParameter(v8, 1u, 500.0, 0);
  v10 = *(_QWORD *)(a1 + 72);
  if (v10)
  {
    v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
  }
  else
  {
    v12 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v12)
      v11 = 0;
    else
      v11 = *v12;
  }
  ausdk::AUElement::SetParameter(v11, 2u, 6.0, 0);
  v13 = *(_QWORD *)(a1 + 72);
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  }
  else
  {
    v15 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v15)
      v14 = 0;
    else
      v14 = *v15;
  }
  ausdk::AUElement::SetParameter(v14, 3u, 0.0, 0);
  v16 = *(_QWORD *)(a1 + 72);
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  ausdk::AUElement::SetParameter(v17, 4u, 20.0, 0);
  v19 = *(_QWORD *)(a1 + 72);
  if (v19)
  {
    v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
  }
  else
  {
    v21 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v21)
      v20 = 0;
    else
      v20 = *v21;
  }
  ausdk::AUElement::SetParameter(v20, 5u, -100.0, 0);
  v22 = *(_QWORD *)(a1 + 72);
  if (v22)
  {
    v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
  }
  else
  {
    v24 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v24)
      v23 = 0;
    else
      v23 = *v24;
  }
  ausdk::AUElement::SetParameter(v23, 6u, 0.03, 0);
  v25 = *(_QWORD *)(a1 + 72);
  if (v25)
  {
    v26 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, 0);
  }
  else
  {
    v27 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v27)
      v26 = 0;
    else
      v26 = *v27;
  }
  ausdk::AUElement::SetParameter(v26, 7u, -12.0, 0);
  v28 = *(_QWORD *)(a1 + 72);
  if (v28)
  {
    v29 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 32))(v28, 0);
  }
  else
  {
    v30 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v30)
      v29 = 0;
    else
      v29 = *v30;
  }
  ausdk::AUElement::SetParameter(v29, 8u, 1250.0, 0);
  v31 = *(_QWORD *)(a1 + 72);
  if (v31)
  {
    v32 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v31 + 32))(v31, 0);
  }
  else
  {
    v33 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v33)
      v32 = 0;
    else
      v32 = *v33;
  }
  ausdk::AUElement::SetParameter(v32, 9u, 0.1, 0);
  v34 = *(_QWORD *)(a1 + 72);
  if (v34)
  {
    v35 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v34 + 32))(v34, 0);
  }
  else
  {
    v36 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v36)
      v35 = 0;
    else
      v35 = *v36;
  }
  ausdk::AUElement::SetParameter(v35, 0xAu, 1.0, 0);
  v37 = *(_QWORD *)(a1 + 72);
  if (v37)
  {
    v38 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v37 + 32))(v37, 0);
  }
  else
  {
    v39 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v39)
      v38 = 0;
    else
      v38 = *v39;
  }
  ausdk::AUElement::SetParameter(v38, 0xBu, 1.5, 0);
  v40 = *(_QWORD *)(a1 + 72);
  if (v40)
  {
    v41 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v40 + 32))(v40, 0);
  }
  else
  {
    v42 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v42)
      v41 = 0;
    else
      v41 = *v42;
  }
  ausdk::AUElement::SetParameter(v41, 0xCu, 0.4, 0);
  v43 = *(_QWORD *)(a1 + 72);
  if (v43)
  {
    v44 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v43 + 32))(v43, 0);
  }
  else
  {
    v45 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v45)
      v44 = 0;
    else
      v44 = *v45;
  }
  ausdk::AUElement::SetParameter(v44, 0xDu, 250.0, 0);
  v46 = *(_QWORD *)(a1 + 72);
  if (v46)
  {
    v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 0);
  }
  else
  {
    v48 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v48)
      v47 = 0;
    else
      v47 = *v48;
  }
  ausdk::AUElement::SetParameter(v47, 0xEu, -90.0, 0);
  v49 = *(_QWORD *)(a1 + 72);
  if (v49)
  {
    v50 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v49 + 32))(v49, 0);
  }
  else
  {
    v51 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v51)
      v50 = 0;
    else
      v50 = *v51;
  }
  ausdk::AUElement::SetParameter(v50, 0xFu, 0.25, 0);
  v52 = *(_QWORD *)(a1 + 72);
  if (v52)
  {
    v53 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v52 + 32))(v52, 0);
  }
  else
  {
    v54 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v54)
      v53 = 0;
    else
      v53 = *v54;
  }
  ausdk::AUElement::SetParameter(v53, 0x10u, 0.25, 0);
  v55 = *(_QWORD *)(a1 + 72);
  if (v55)
  {
    v56 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v55 + 32))(v55, 0);
  }
  else
  {
    v57 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v57)
      v56 = 0;
    else
      v56 = *v57;
  }
  ausdk::AUElement::SetParameter(v56, 0x11u, 0.75, 0);
  v58 = (unsigned int *)(a1 + 928);
  do
    v59 = __ldaxr(v58);
  while (__stlxr(v59 + 1, v58));
  v70 = 0x40E5888000000000;
  v67 = 0x40E5888000000000;
  v69 = xmmword_1B66A0BC0;
  v71 = xmmword_1B66A0BD0;
  v72 = xmmword_1B66A0BE0;
  v68 = xmmword_1B66A0BD0;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v67);
  v61 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 2u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v61 + 56))(v61, &v70);
  for (i = 0; ; ++i)
  {
    v63 = *(_QWORD *)(a1 + 168);
    if (v63)
      LODWORD(v64) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v63 + 24))(v63);
    else
      v64 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v64)
      break;
    v65 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v65 + 56))(v65, &v67);
  }
  atomic_store(1u, (unsigned int *)(a1 + 928));
  return a1;
}

void sub_1B61C92D0(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;

  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULimitWindBoost>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHearingLossCompensator>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  float v7;
  ausdk::AUElement *Element;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69CCBC0;
  *((_QWORD *)v3 + 66) = 0;
  *((_DWORD *)v3 + 134) = 1133903872;
  *(_OWORD *)((char *)v3 + 540) = 0u;
  *(_QWORD *)((char *)v3 + 555) = 0;
  *(_OWORD *)((char *)v3 + 568) = 0u;
  *(_OWORD *)((char *)v3 + 584) = 0u;
  *(_OWORD *)((char *)v3 + 600) = 0u;
  *(_OWORD *)((char *)v3 + 616) = 0u;
  *(_OWORD *)((char *)v3 + 632) = 0u;
  *(_OWORD *)((char *)v3 + 648) = 0u;
  *(_OWORD *)((char *)v3 + 664) = 0u;
  v4 = *((_QWORD *)v3 + 9);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  else
    v5 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, 40);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  for (i = 0; i != 40; ++i)
  {
    v7 = AUHearingLossCompensator::kUserParameterDefault[i];
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
    ausdk::AUElement::SetParameter(Element, i, v7, 0);
  }
  v12 = 0x40E5888000000000;
  v13 = xmmword_1B6626900;
  v14 = xmmword_1B66A0830;
  v9 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v9 + 56))(v9, &v12);
  v10 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v10 + 56))(v10, &v12);
  *(_BYTE *)(a1 + 376) = 1;
  return a1;
}

void sub_1B61C9488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t *v11;
  void *v13;
  void *v14;

  v13 = *(void **)(v10 + 656);
  if (v13)
  {
    *(_QWORD *)(v10 + 664) = v13;
    operator delete(v13);
  }
  v14 = *(void **)(v10 + 632);
  if (v14)
  {
    *(_QWORD *)(v10 + 640) = v14;
    operator delete(v14);
  }
  a10 = (void **)(v10 + 608);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a10);
  a10 = (void **)(v10 + 584);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::unique_ptr<HearingLossCompensator_Core>::reset[abi:ne180100]((uint64_t *)(v10 + 576), 0);
  std::unique_ptr<BlockProcessor>::reset[abi:ne180100](v11, 0);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v10);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHearingLossCompensator>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeechEnhancer>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  float v9;
  ausdk::AUElement *Element;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69C7ED0;
  *((_QWORD *)v3 + 69) = 0;
  *((_DWORD *)v3 + 140) = 0;
  *((_OWORD *)v3 + 33) = 0u;
  *((_WORD *)v3 + 272) = 0;
  *(_OWORD *)((char *)v3 + 568) = 0u;
  *(_OWORD *)((char *)v3 + 584) = 0u;
  *(_OWORD *)((char *)v3 + 600) = 0u;
  *(_OWORD *)((char *)v3 + 616) = 0u;
  *(_OWORD *)((char *)v3 + 632) = 0u;
  *((_DWORD *)v3 + 162) = 1;
  *(_QWORD *)((char *)v3 + 652) = 0;
  *(_QWORD *)((char *)v3 + 668) = 0;
  *(_QWORD *)((char *)v3 + 660) = 0;
  *((_DWORD *)v3 + 169) = 0;
  spen::populateParameterInfoTable((void **)v3 + 82);
  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  else
    v5 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, (*(_QWORD *)(a1 + 664) - *(_QWORD *)(a1 + 656)) >> 5);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v6 = *(_QWORD *)(a1 + 656);
  if (*(_QWORD *)(a1 + 664) != v6)
  {
    v7 = 0;
    v8 = 24;
    do
    {
      v9 = *(float *)(v6 + v8);
      Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
      ausdk::AUElement::SetParameter(Element, v7++, v9, 0);
      v6 = *(_QWORD *)(a1 + 656);
      v8 += 32;
    }
    while (v7 < (*(_QWORD *)(a1 + 664) - v6) >> 5);
  }
  *(_BYTE *)(a1 + 376) = 1;
  return a1;
}

void sub_1B61C9658(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  uint64_t *v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v6 = *v3;
  if (*v3)
  {
    *((_QWORD *)v1 + 83) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)v1 + 78);
  if (v7)
  {
    *((_QWORD *)v1 + 79) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)v1 + 75);
  if (v8)
  {
    *((_QWORD *)v1 + 76) = v8;
    operator delete(v8);
  }
  std::unique_ptr<SpeechEnhancerCore<float>>::reset[abi:ne180100](v2, 0);
  v9 = *v4;
  if (*v4)
  {
    *((_QWORD *)v1 + 72) = v9;
    operator delete(v9);
  }
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpeechEnhancer>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMidSide>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  uint64_t v14;
  ausdk::AUElement *v15;
  ausdk::AUElement **v16;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69CE568;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)v3 + 66) = _D0;
  *((_QWORD *)v3 + 67) = 1;
  *((_BYTE *)v3 + 544) = 0;
  v9 = *((_QWORD *)v3 + 9);
  if (v9)
    v10 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
  else
    v10 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 40))(v10, 2);
  v11 = *(_QWORD *)(a1 + 72);
  if (v11)
  {
    v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
  }
  else
  {
    v13 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v13)
      v12 = 0;
    else
      v12 = *v13;
  }
  ausdk::AUElement::SetParameter(v12, 0, 0.0, 0);
  v14 = *(_QWORD *)(a1 + 72);
  if (v14)
  {
    v15 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 32))(v14, 0);
  }
  else
  {
    v16 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v16)
      v15 = 0;
    else
      v15 = *v16;
  }
  ausdk::AUElement::SetParameter(v15, 1u, 0.0, 0);
  *(float *)(a1 + 528) = __exp10f(0.0);
  *(float *)(a1 + 532) = __exp10f(0.0);
  return a1;
}

void sub_1B61C97EC(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;

  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMidSide>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

ausdk::AUBase *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUChannelSelector>::Construct(ausdk::AUBase *a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  NSObject *v4;
  int v6;
  ausdk::AUBase *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase(a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69CFD10;
  *((_BYTE *)v3 + 528) = 0;
  *((_BYTE *)v3 + 552) = 0;
  *((_BYTE *)v3 + 560) = 0;
  *(_OWORD *)((char *)v3 + 564) = 0u;
  *(_OWORD *)((char *)v3 + 580) = 0u;
  *(_OWORD *)((char *)v3 + 596) = 0u;
  *(_OWORD *)((char *)v3 + 612) = 0u;
  *(_OWORD *)((char *)v3 + 628) = 0u;
  *(_OWORD *)((char *)v3 + 644) = 0u;
  *(_OWORD *)((char *)v3 + 660) = 0u;
  *(_OWORD *)((char *)v3 + 676) = 0u;
  *((_OWORD *)v3 + 43) = 0u;
  if (getAUChannelSelectorLog(void)::onceToken != -1)
    dispatch_once(&getAUChannelSelectorLog(void)::onceToken, &__block_literal_global_6312);
  v4 = getAUChannelSelectorLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getAUChannelSelectorLog(void)::gLog, OS_LOG_TYPE_DEBUG))
  {
    v6 = 134217984;
    v7 = a1;
    _os_log_debug_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "[%p] constructed", (uint8_t *)&v6, 0xCu);
  }
  return a1;
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUChannelSelector>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMultiChannelAGC>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t v5;
  OpaqueAudioComponent *Next;
  AudioUnitParameterID i;
  float v8;
  ausdk::AUElement *Element;
  ausdk::AUElement *v10;
  AudioComponentDescription v12;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *((_WORD *)v3 + 276) = 0;
  *((_QWORD *)v3 + 68) = 0;
  *((_OWORD *)v3 + 33) = 0u;
  *((_BYTE *)v3 + 554) = 1;
  *((_DWORD *)v3 + 139) = 0;
  *((_BYTE *)v3 + 560) = 0;
  *((_DWORD *)v3 + 147) = 0;
  *(_OWORD *)((char *)v3 + 568) = 0u;
  *((_BYTE *)v3 + 584) = 0;
  *(_QWORD *)v3 = &off_1E69D3640;
  *((_QWORD *)v3 + 74) = 0;
  *((_DWORD *)v3 + 166) = 0;
  *((_OWORD *)v3 + 42) = 0u;
  *((_DWORD *)v3 + 172) = 1;
  *(_OWORD *)((char *)v3 + 692) = 0u;
  *(_OWORD *)((char *)v3 + 708) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  else
    v5 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, 66);
  BYTE1(v12.componentFlags) = 0;
  HIWORD(v12.componentFlags) = 0;
  v12.componentFlagsMask = 0;
  strcpy((char *)&v12, "xfua2cgalppa");
  Next = AudioComponentFindNext(0, &v12);
  if (Next)
    AudioComponentInstanceNew(Next, (AudioComponentInstance *)(a1 + 592));
  for (i = 0; i != 65; ++i)
  {
    v12.componentType = 0;
    AudioUnitGetParameter(*(AudioUnit *)(a1 + 592), i, 0, 0, (AudioUnitParameterValue *)&v12.componentType);
    v8 = *(float *)&v12.componentType;
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
    ausdk::AUElement::SetParameter(Element, i, v8, 0);
  }
  v10 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v10, 0x41u, 0.0, 0);
  *(_BYTE *)(a1 + 376) = 1;
  return a1;
}

void sub_1B61C9AA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  uint64_t v12;
  _QWORD **v14;
  void *v15;

  v14 = (_QWORD **)(v12 + 672);
  v15 = *(void **)(v12 + 696);
  if (v15)
  {
    *(_QWORD *)(v12 + 704) = v15;
    operator delete(v15);
  }
  if (*v14)
  {
    ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, *v14);
    *v14 = 0;
  }
  *(_QWORD *)(v12 + 680) = 0;
  *(_DWORD *)(v12 + 664) = 0;
  *(_QWORD *)v12 = &off_1E69ED840;
  a12 = (void **)(v12 + 528);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a12);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v12);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMultiChannelAGC>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSense>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  float v7;
  ausdk::AUElement *Element;
  unint64_t j;
  uint64_t k;
  uint64_t v11;
  ausdk::AUElement *v12;
  uint64_t v13;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69D4F88;
  *((_DWORD *)v3 + 132) = 0;
  *((_DWORD *)v3 + 154) = 0;
  *(_OWORD *)((char *)v3 + 648) = 0u;
  *(_OWORD *)((char *)v3 + 664) = 0u;
  *(_OWORD *)((char *)v3 + 536) = 0u;
  *(_OWORD *)((char *)v3 + 552) = 0u;
  *((_DWORD *)v3 + 142) = 0;
  *((_OWORD *)v3 + 36) = 0u;
  *((_OWORD *)v3 + 37) = 0u;
  *(_QWORD *)((char *)v3 + 605) = 0;
  *((_OWORD *)v3 + 39) = 0u;
  *((_DWORD *)v3 + 160) = 0;
  *((_BYTE *)v3 + 696) = 0;
  *(_OWORD *)((char *)v3 + 680) = 0u;
  *(_OWORD *)((char *)v3 + 700) = 0u;
  *(_QWORD *)((char *)v3 + 714) = 0;
  v4 = *((_QWORD *)v3 + 9);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  else
    v5 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, 14);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  for (i = 0; i != 14; ++i)
  {
    v7 = AUMicSense::kUserParameterDefault[i];
    Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
    ausdk::AUElement::SetParameter(Element, i, v7, 0);
  }
  for (j = 0; j != 8; ++j)
  {
    for (k = 0; k != 14; ++k)
    {
      v11 = *(_QWORD *)(a1 + 600);
      if (v11)
      {
        v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v11 + 32))(v11, j);
      }
      else
      {
        v13 = *(_QWORD *)(a1 + 576);
        if (j >= (*(_QWORD *)(a1 + 584) - v13) >> 3)
          v12 = 0;
        else
          v12 = *(ausdk::AUElement **)(v13 + 8 * j);
      }
      ausdk::AUElement::SetParameter(v12, k, AUMicSense::kUserParameterDefault[k], 0);
    }
  }
  *(_BYTE *)(a1 + 376) = 1;
  return a1;
}

void sub_1B61C9CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;

  a10 = (void **)(v10 + 672);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)(v10 + 624), 0);
  a10 = (void **)(v10 + 576);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::vector<AUMicSense::MicSenseInfo>::__destroy_vector::operator()[abi:ne180100](&a10);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v10);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSense>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHOAZoom>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  double v9;
  uint64_t *v10;
  void *v11;
  double v12;
  uint64_t *v13;
  void *v14;
  double v15;
  uint64_t *v16;
  void *v17;
  uint64_t Element;
  uint64_t v19;
  _QWORD *ParameterMap;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  ausdk::AUElement *v24;
  ausdk::AUElement **v25;
  _QWORD *v26;
  _QWORD *v27;
  BOOL v28;
  uint64_t *v30;
  uint64_t v31;
  _OWORD v32[2];
  void *v33[2];
  char v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38[2];
  char v39;
  void *v40;
  void *v41;
  uint64_t v42;
  void *__p[2];
  char v44;
  void *v45;
  void *v46;
  uint64_t v47;
  __int128 v48;
  uint64_t v49;
  std::string __str;
  std::string v51;
  __int128 v52;
  _QWORD v53[3];
  __int128 v54;

  *(_QWORD *)&v54 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = off_1E69D8A68;
  *((_OWORD *)v3 + 33) = 0u;
  *((_DWORD *)v3 + 136) = 1;
  v4 = (uint64_t *)operator new(0x18uLL);
  *(_OWORD *)v4 = xmmword_1B66A0CB0;
  v4[2] = 1120403456;
  v5 = (uint64_t *)operator new(0x10uLL);
  *(_OWORD *)v5 = xmmword_1B66A0CC0;
  v6 = v5 + 2;
  v30 = v5;
  v7 = (uint64_t *)operator new(0x10uLL);
  *(_OWORD *)v7 = xmmword_1B66A0CD0;
  std::string::basic_string[abi:ne180100]<0>(&v51, "HOAZoomCurve");
  std::string::basic_string[abi:ne180100]<0>(&v52, "HOAZoomInDominanceCurve");
  std::string::basic_string[abi:ne180100]<0>(v53, "HOAZoomOutDominanceCurve");
  v31 = 0;
  v32[0] = 0uLL;
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v31;
  __str.__r_.__value_.__s.__data_[8] = 0;
  v31 = (uint64_t)operator new(0x48uLL);
  *(_QWORD *)&v32[0] = v31;
  *((_QWORD *)&v32[0] + 1) = v31 + 72;
  v8 = 0;
  *(_QWORD *)&v32[0] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((uint64_t)v32 + 8, (__int128 *)&v51, &v54, (std::string *)v31);
  do
  {
    if (SHIBYTE(v53[v8 + 2]) < 0)
      operator delete((void *)v53[v8]);
    v8 -= 3;
  }
  while (v8 != -9);
  memset(&v51, 0, sizeof(v51));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v51, (__int128 *)v31, *(__int128 **)&v32[0], 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)&v32[0] - v31) >> 3));
  std::string::basic_string[abi:ne180100]<0>(&__str, "");
  ZoomCurveValue::ZoomCurveValue(a1 + 552, (uint64_t)&v51, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  *(_QWORD *)&v48 = &v51;
  std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100]((void ***)&v48);
  v46 = 0;
  v47 = 0;
  v45 = 0;
  std::vector<std::pair<float,float>>::__init_with_size[abi:ne180100]<std::pair<float,float>*,std::pair<float,float>*>((char *)&v45, v4, v4 + 3, 3uLL);
  PiecewiseLinearTransform::PiecewiseLinearTransform((uint64_t **)&v48, (uint64_t **)&v45, v9);
  std::string::basic_string[abi:ne180100]<0>(__p, "HOAZoomCurve");
  v10 = ZoomCurveValue::operator[](a1 + 552, (__int128 *)__p);
  v11 = (void *)*v10;
  if (*v10)
  {
    v10[1] = (uint64_t)v11;
    operator delete(v11);
    *v10 = 0;
    v10[1] = 0;
    v10[2] = 0;
  }
  *(_OWORD *)v10 = v48;
  v10[2] = v49;
  v48 = 0uLL;
  v49 = 0;
  if (v44 < 0)
  {
    operator delete(__p[0]);
    if ((_QWORD)v48)
    {
      *((_QWORD *)&v48 + 1) = v48;
      operator delete((void *)v48);
    }
  }
  if (v45)
  {
    v46 = v45;
    operator delete(v45);
  }
  v41 = 0;
  v42 = 0;
  v40 = 0;
  std::vector<std::pair<float,float>>::__init_with_size[abi:ne180100]<std::pair<float,float>*,std::pair<float,float>*>((char *)&v40, v30, v6, 2uLL);
  PiecewiseLinearTransform::PiecewiseLinearTransform((uint64_t **)&v48, (uint64_t **)&v40, v12);
  std::string::basic_string[abi:ne180100]<0>(v38, "HOAZoomInDominanceCurve");
  v13 = ZoomCurveValue::operator[](a1 + 552, (__int128 *)v38);
  v14 = (void *)*v13;
  if (*v13)
  {
    v13[1] = (uint64_t)v14;
    operator delete(v14);
    *v13 = 0;
    v13[1] = 0;
    v13[2] = 0;
  }
  *(_OWORD *)v13 = v48;
  v13[2] = v49;
  v48 = 0uLL;
  v49 = 0;
  if (v39 < 0)
  {
    operator delete(v38[0]);
    if ((_QWORD)v48)
    {
      *((_QWORD *)&v48 + 1) = v48;
      operator delete((void *)v48);
    }
  }
  if (v40)
  {
    v41 = v40;
    operator delete(v40);
  }
  v36 = 0;
  v37 = 0;
  v35 = 0;
  std::vector<std::pair<float,float>>::__init_with_size[abi:ne180100]<std::pair<float,float>*,std::pair<float,float>*>((char *)&v35, v7, v7 + 2, 2uLL);
  PiecewiseLinearTransform::PiecewiseLinearTransform((uint64_t **)&v48, (uint64_t **)&v35, v15);
  std::string::basic_string[abi:ne180100]<0>(v33, "HOAZoomOutDominanceCurve");
  v16 = ZoomCurveValue::operator[](a1 + 552, (__int128 *)v33);
  v17 = (void *)*v16;
  if (*v16)
  {
    v16[1] = (uint64_t)v17;
    operator delete(v17);
    *v16 = 0;
    v16[1] = 0;
    v16[2] = 0;
  }
  *(_OWORD *)v16 = v48;
  v16[2] = v49;
  v48 = 0uLL;
  v49 = 0;
  if (v34 < 0)
  {
    operator delete(v33[0]);
    if ((_QWORD)v48)
    {
      *((_QWORD *)&v48 + 1) = v48;
      operator delete((void *)v48);
    }
  }
  if (v35)
  {
    v36 = v35;
    operator delete(v35);
  }
  *(_QWORD *)&v48 = &v31;
  std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100]((void ***)&v48);
  operator delete(v7);
  operator delete(v30);
  operator delete(v4);
  *(_DWORD *)(a1 + 640) = 0;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_BYTE *)(a1 + 644) = 1;
  *(_DWORD *)(a1 + 648) = 0;
  *(_BYTE *)(a1 + 652) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  AUHOAZoom::UpdateChannelLayoutTag((AUHOAZoom *)a1, 12451844);
  v51.__r_.__value_.__r.__words[0] = 0x40E7700000000000;
  v52 = xmmword_1B66A0CE0;
  *(_OWORD *)&v51.__r_.__value_.__r.__words[1] = xmmword_1B66A0BD0;
  v31 = 0x40E7700000000000;
  v32[0] = xmmword_1B66A0BD0;
  v32[1] = xmmword_1B66A0CE0;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)Element + 56))(Element, &v51);
  v19 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v19 + 56))(v19, &v31);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 1156);
  *(_BYTE *)(a1 + 376) = 1;
  ParameterMap = (_QWORD *)AUHOAZoom::GetParameterMap((AUHOAZoom *)a1);
  v21 = ParameterMap + 1;
  v22 = (_QWORD *)*ParameterMap;
  if ((_QWORD *)*ParameterMap != ParameterMap + 1)
  {
    do
    {
      v23 = *(_QWORD *)(a1 + 72);
      if (v23)
      {
        v24 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
      }
      else
      {
        v25 = *(ausdk::AUElement ***)(a1 + 48);
        if (*(ausdk::AUElement ***)(a1 + 56) == v25)
          v24 = 0;
        else
          v24 = *v25;
      }
      ausdk::AUElement::SetParameter(v24, *((_DWORD *)v22 + 8), *((float *)v22 + 33), 0);
      v26 = (_QWORD *)v22[1];
      if (v26)
      {
        do
        {
          v27 = v26;
          v26 = (_QWORD *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          v27 = (_QWORD *)v22[2];
          v28 = *v27 == (_QWORD)v22;
          v22 = v27;
        }
        while (!v28);
      }
      v22 = v27;
    }
    while (v27 != v21);
  }
  return a1;
}

void sub_1B61CA2A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,char *a42,char *a43)
{
  uint64_t v43;
  void *v44;
  void *v45;
  uint64_t v47;

  if (a20 < 0)
    operator delete(__p);
  if (a42)
  {
    a43 = a42;
    operator delete(a42);
  }
  if (a21)
  {
    a22 = (uint64_t)a21;
    operator delete(a21);
  }
  if (*(char *)(v43 + 623) < 0)
    operator delete(*(void **)(v43 + 600));
  a42 = (char *)(v43 + 576);
  std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100]((void ***)&a42);
  std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(*(_QWORD **)(v43 + 560));
  a42 = &a10;
  std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100]((void ***)&a42);
  operator delete(v45);
  operator delete(a9);
  operator delete(v44);
  v47 = *(_QWORD *)(v43 + 536);
  *(_QWORD *)(v43 + 536) = 0;
  if (v47)
    std::default_delete<DominanceZoom>::operator()[abi:ne180100](v47);
  std::unique_ptr<std::map<unsigned int,HOAZoomParameterInfo>>::reset[abi:ne180100]((uint64_t *)(v43 + 528), 0);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v43);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHOAZoom>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpatialCapture>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  char *v4;
  DSPGraph *v5;
  unsigned int v6;
  uint64_t Element;
  uint64_t v8;
  _QWORD *ParameterMap;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  ausdk::AUElement *v13;
  ausdk::AUElement **v14;
  _QWORD *v15;
  _QWORD *v16;
  BOOL v17;
  std::runtime_error *exception;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint8_t buf[8];
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 3, 1);
  *(_QWORD *)v3 = &off_1E69CBB80;
  *((_OWORD *)v3 + 33) = 0u;
  *((_OWORD *)v3 + 34) = 0u;
  *((_OWORD *)v3 + 35) = 0u;
  *((_OWORD *)v3 + 36) = 0u;
  *((_DWORD *)v3 + 148) = 1;
  *((_QWORD *)v3 + 75) = 0x300000003;
  *((_DWORD *)v3 + 152) = 0;
  *((_BYTE *)v3 + 612) = 0;
  *((_QWORD *)v3 + 77) = 850045863;
  *((_OWORD *)v3 + 39) = 0u;
  *((_OWORD *)v3 + 40) = 0u;
  *((_OWORD *)v3 + 41) = 0u;
  *((_QWORD *)v3 + 84) = 0;
  *((_QWORD *)v3 + 85) = 850045863;
  *((_OWORD *)v3 + 43) = 0u;
  *((_OWORD *)v3 + 44) = 0u;
  *((_OWORD *)v3 + 45) = 0u;
  *((_QWORD *)v3 + 92) = 0;
  *((_QWORD *)v3 + 93) = 1018212795;
  *((_OWORD *)v3 + 47) = 0u;
  *((_OWORD *)v3 + 48) = 0u;
  *((_QWORD *)v3 + 98) = 0;
  *((_DWORD *)v3 + 198) = 1028443341;
  *((_DWORD *)v3 + 200) = 6946818;
  *(_OWORD *)((char *)v3 + 808) = 0u;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)v3 + 103, "/tmp/");
  v4 = (char *)(a1 + 848);
  *(_QWORD *)(a1 + 864) = 0;
  *(_OWORD *)(a1 + 848) = 0u;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(a1 + 872), "<plist path not set>");
  *(_WORD *)(a1 + 896) = 1;
  ZoomCurveValue::ZoomCurveValue((ZoomCurveValue *)(a1 + 904));
  if (DSPGraph::ABIVersion(v5) != 4)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = -10875;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", buf, 8u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(exception, -10875);
  }
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v6 = 0;
  *(_QWORD *)buf = 0x40E5888000000000;
  v24 = xmmword_1B6626900;
  v25 = xmmword_1B66A0820;
  v20 = 0x40E5888000000000;
  v21 = xmmword_1B6626900;
  v22 = xmmword_1B66A0830;
  do
  {
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v6);
    (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)Element + 56))(Element, buf);
    ++v6;
  }
  while (v6 != 3);
  v8 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v8 + 56))(v8, &v20);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 1156);
  ParameterMap = (_QWORD *)AUSpatialCapture::GetParameterMap((AUSpatialCapture *)a1);
  v10 = ParameterMap + 1;
  v11 = (_QWORD *)*ParameterMap;
  if ((_QWORD *)*ParameterMap != ParameterMap + 1)
  {
    do
    {
      v12 = *(_QWORD *)(a1 + 72);
      if (v12)
      {
        v13 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, 0);
      }
      else
      {
        v14 = *(ausdk::AUElement ***)(a1 + 48);
        if (*(ausdk::AUElement ***)(a1 + 56) == v14)
          v13 = 0;
        else
          v13 = *v14;
      }
      ausdk::AUElement::SetParameter(v13, *((_DWORD *)v11 + 8), *((float *)v11 + 33), 0);
      v15 = (_QWORD *)v11[1];
      if (v15)
      {
        do
        {
          v16 = v15;
          v15 = (_QWORD *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          v16 = (_QWORD *)v11[2];
          v17 = *v16 == (_QWORD)v11;
          v11 = v16;
        }
        while (!v17);
      }
      v11 = v16;
    }
    while (v16 != v10);
  }
  if (*(char *)(a1 + 871) < 0)
  {
    *(_QWORD *)(a1 + 856) = 18;
    v4 = *(char **)(a1 + 848);
  }
  else
  {
    *(_BYTE *)(a1 + 871) = 18;
  }
  strcpy(v4, "<no tuning loaded>");
  return a1;
}

void sub_1B61CA84C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v15;
  void **v16;
  void **v17;
  void *v18;
  uint64_t *v19;
  void **v20;
  uint64_t v22;
  const void *v23;
  void **v24;
  void *v25;
  void *v26;

  __cxa_free_exception(v18);
  if (*(char *)(v15 + 975) < 0)
    operator delete(*(void **)(v15 + 952));
  a15 = v15 + 928;
  std::vector<std::__fs::filesystem::path>::__destroy_vector::operator()[abi:ne180100]((void ***)&a15);
  std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(*(_QWORD **)(v15 + 912));
  if (*(char *)(v15 + 895) < 0)
    operator delete(*v17);
  if (*(char *)(v15 + 871) < 0)
    operator delete(*v20);
  if (*(char *)(v15 + 847) < 0)
    operator delete(*v16);
  v22 = *v19;
  *v19 = 0;
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
  std::condition_variable::~condition_variable((std::condition_variable *)(v15 + 744));
  std::mutex::~mutex((std::mutex *)(v15 + 680));
  std::mutex::~mutex((std::mutex *)(v15 + 616));
  v23 = *(const void **)(v15 + 584);
  if (v23)
    CFRelease(v23);
  v24 = (void **)(v15 + 528);
  std::unique_ptr<std::map<unsigned int,SpatialCaptureParameterInfo>>::reset[abi:ne180100]((uint64_t *)(v15 + 576), 0);
  v25 = *(void **)(v15 + 552);
  if (v25)
  {
    *(_QWORD *)(v15 + 560) = v25;
    operator delete(v25);
  }
  v26 = *v24;
  if (*v24)
  {
    *(_QWORD *)(v15 + 536) = v26;
    operator delete(v26);
  }
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v15);
  _Unwind_Resume(a1);
}

void sub_1B61CA964(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x1B61CA95CLL);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUSpatialCapture>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUChannelSpecificDelay>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int i;
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v12;
  unint64_t j;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  uint64_t v18;
  NSObject *v19;
  int v21;
  const char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  v4 = 0;
  *(_QWORD *)v3 = &off_1E69DD4E0;
  *((_DWORD *)v3 + 132) = 0;
  *((_WORD *)v3 + 266) = 0;
  v5 = (_OWORD *)((char *)v3 + 1816);
  do
  {
    v6 = a1 + v4;
    *(_OWORD *)(v6 + 560) = 0uLL;
    *(_DWORD *)(v6 + 552) = 0;
    *(_OWORD *)(a1 + v4 + 536) = xmmword_1B66A0CF0;
    v4 += 40;
  }
  while (v4 != 1280);
  *(_QWORD *)(a1 + 2200) = 0;
  *(_DWORD *)(a1 + 2208) = 0;
  *(_OWORD *)(a1 + 2232) = 0u;
  *(_OWORD *)(a1 + 2216) = 0u;
  *(_DWORD *)(a1 + 2248) = 0;
  v7 = *(_QWORD *)(a1 + 72);
  if (v7)
    v8 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
  else
    v8 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 40))(v8, 8);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  for (i = 0; i != 8; ++i)
  {
    v10 = *(_QWORD *)(a1 + 72);
    if (v10)
    {
      v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
    }
    else
    {
      v12 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v12)
        v11 = 0;
      else
        v11 = *v12;
    }
    ausdk::AUElement::SetParameter(v11, i, 0.0, 0);
  }
  for (j = 0; ; ++j)
  {
    v14 = *(_QWORD *)(a1 + 2240);
    if (v14)
      LODWORD(v15) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
    else
      v15 = (*(_QWORD *)(a1 + 2224) - *(_QWORD *)(a1 + 2216)) >> 3;
    if (j >= v15)
      break;
    v16 = *(_QWORD *)(a1 + 2240);
    if (v16)
    {
      v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v16 + 32))(v16, j);
    }
    else
    {
      v18 = *(_QWORD *)(a1 + 2216);
      if (j >= (*(_QWORD *)(a1 + 2224) - v18) >> 3)
        v17 = 0;
      else
        v17 = *(ausdk::AUElement **)(v18 + 8 * j);
    }
    ausdk::AUElement::SetParameter(v17, 0, 0.0, 0);
  }
  v5[22] = 0u;
  v5[23] = 0u;
  v5[20] = 0u;
  v5[21] = 0u;
  v5[18] = 0u;
  v5[19] = 0u;
  v5[16] = 0u;
  v5[17] = 0u;
  v5[14] = 0u;
  v5[15] = 0u;
  v5[12] = 0u;
  v5[13] = 0u;
  v5[10] = 0u;
  v5[11] = 0u;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  *v5 = 0u;
  v5[1] = 0u;
  if (AUChannelSpecificDelayLogScope(void)::once != -1)
    dispatch_once(&AUChannelSpecificDelayLogScope(void)::once, &__block_literal_global_15525);
  if (AUChannelSpecificDelayLogScope(void)::scope)
  {
    if ((*(_BYTE *)(AUChannelSpecificDelayLogScope(void)::scope + 8) & 1) != 0)
    {
      v19 = *(NSObject **)AUChannelSpecificDelayLogScope(void)::scope;
      if (*(_QWORD *)AUChannelSpecificDelayLogScope(void)::scope)
      {
        if (os_log_type_enabled(*(os_log_t *)AUChannelSpecificDelayLogScope(void)::scope, OS_LOG_TYPE_DEBUG))
        {
          v21 = 136315394;
          v22 = "AUChannelSpecificDelay.cpp";
          v23 = 1024;
          v24 = 65;
          _os_log_impl(&dword_1B5ED0000, v19, OS_LOG_TYPE_DEBUG, "%25s:%-5d AUChannelSpecificDelay instantiated", (uint8_t *)&v21, 0x12u);
        }
      }
    }
  }
  return a1;
}

void sub_1B61CAC38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  ausdk::AUBase *v9;
  uint64_t v11;
  char *v12;
  _BYTE *v13;
  _BYTE *v14;
  _QWORD *v15;

  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a9);
  v11 = 1280;
  while (1)
  {
    v12 = (char *)v9 + v11;
    v13 = *(_BYTE **)((char *)v9 + v11 + 520);
    if (v13)
    {
      v14 = (_BYTE *)*((_QWORD *)v12 + 66);
      if (v14 != v13)
        *((_QWORD *)v12 + 66) = &v14[(v13 - v14 + 3) & 0xFFFFFFFFFFFFFFFCLL];
      v15 = v12 + 520;
      operator delete(v13);
      *v15 = 0;
      v15[1] = 0;
    }
    v11 -= 40;
    if (!v11)
    {
      ausdk::AUBase::~AUBase(v9);
      _Unwind_Resume(a1);
    }
  }
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUChannelSpecificDelay>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUFixedGain>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  void **v4;
  unsigned int i;
  uint64_t v6;
  ausdk::AUElement *v7;
  ausdk::AUElement **v8;
  void *v9;
  uint64_t Element;
  uint64_t v11;
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69D6758;
  *((_DWORD *)v3 + 132) = 1;
  v4 = (void **)((char *)v3 + 552);
  *(_QWORD *)((char *)v3 + 540) = 0;
  *(_QWORD *)((char *)v3 + 548) = 0;
  *(_QWORD *)((char *)v3 + 532) = 0;
  *((_DWORD *)v3 + 139) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  for (i = 0; i != 16; ++i)
  {
    v6 = *(_QWORD *)(a1 + 72);
    if (v6)
    {
      v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
    }
    else
    {
      v8 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v8)
        v7 = 0;
      else
        v7 = *v8;
    }
    ausdk::AUElement::SetParameter(v7, i, 0.0, 0);
  }
  v9 = *(void **)(a1 + 544);
  if (v9)
  {
    free(v9);
    *(_QWORD *)(a1 + 544) = 0;
  }
  CADeprecated::CAAutoFree<float>::allocBytes(v4, 0x40uLL);
  memset_pattern16(*(void **)(a1 + 552), &unk_1B6627B80, 0x40uLL);
  v13 = 0x40E5888000000000;
  v14 = xmmword_1B6626900;
  v15 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v13);
  v11 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v11 + 56))(v11, &v13);
  return a1;
}

void sub_1B61CADF4(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  void **v2;
  void *v4;

  if (*v2)
  {
    free(*v2);
    *v2 = 0;
  }
  v4 = (void *)*((_QWORD *)v1 + 68);
  if (v4)
  {
    free(v4);
    *((_QWORD *)v1 + 68) = 0;
  }
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUFixedGain>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHapticsProtection>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t i;
  uint64_t v5;
  ausdk::AUElement *v6;
  ausdk::AUElement **v7;
  uint64_t Element;
  uint64_t v9;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69E4FA0;
  *((_OWORD *)v3 + 33) = 0u;
  *((_QWORD *)v3 + 68) = 1;
  *((_BYTE *)v3 + 552) = 0;
  *((_OWORD *)v3 + 35) = 0u;
  *((_OWORD *)v3 + 36) = 0u;
  *((_OWORD *)v3 + 37) = 0u;
  *((_OWORD *)v3 + 38) = 0u;
  *((_OWORD *)v3 + 39) = 0u;
  *((_OWORD *)v3 + 40) = 0u;
  *((_OWORD *)v3 + 41) = 0u;
  *((_OWORD *)v3 + 42) = 0u;
  *((_OWORD *)v3 + 43) = 0u;
  *((_OWORD *)v3 + 44) = 0u;
  *((_OWORD *)v3 + 45) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  for (i = 0; i != 47; ++i)
  {
    v5 = a1[9];
    if (v5)
    {
      v6 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
    }
    else
    {
      v7 = (ausdk::AUElement **)a1[6];
      if ((ausdk::AUElement **)a1[7] == v7)
        v6 = 0;
      else
        v6 = *v7;
    }
    ausdk::AUElement::SetParameter(v6, i + 4096, htlDefaultCoeffs[i], 0);
  }
  v14 = 0x40E5888000000000;
  v15 = xmmword_1B6626900;
  v16 = xmmword_1B66A0830;
  v11 = 0x40E5888000000000;
  v12 = xmmword_1B6626900;
  v13 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v14);
  v9 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v9 + 56))(v9, &v11);
  return a1;
}

void sub_1B61CAF80(_Unwind_Exception *a1)
{
  uint64_t *v1;
  void *v3;
  void *v4;
  void *v5;

  v3 = (void *)v1[78];
  if (v3)
  {
    v1[79] = (uint64_t)v3;
    operator delete(v3);
  }
  v4 = (void *)v1[75];
  if (v4)
  {
    v1[76] = (uint64_t)v4;
    operator delete(v4);
  }
  v5 = (void *)v1[72];
  if (v5)
  {
    v1[73] = (uint64_t)v5;
    operator delete(v5);
  }
  std::unique_ptr<HapticTravelLimiter::HTL>::reset[abi:ne180100](v1 + 66, 0);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHapticsProtection>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

int64x2_t *ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessWarrior>::Construct(int64x2_t *a1, OpaqueAudioComponentInstance *a2)
{
  NSObject *v4;
  uint64_t Element;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const __CFString *v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v14;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  void *__p;
  char v20;
  void *v21[2];
  char v22;
  _BYTE buf[24];
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  std::string::basic_string[abi:ne180100]<0>(v21, "AULoudnessWarrior");
  std::string::basic_string[abi:ne180100]<0>(&__p, "loudnesswarrior_verbose");
  AUJBase::AUJBase((uint64_t)a1, a2, (__int128 *)v21);
  if (v20 < 0)
    operator delete(__p);
  if (v22 < 0)
    operator delete(v21[0]);
  a1->i64[0] = (uint64_t)&off_1E69D4838;
  a1[40].i64[0] = (uint64_t)&off_1E69D4B38;
  a1[44].i64[0] = (uint64_t)&off_1E69D4B58;
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)&a1[48]);
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)&a1[108]);
  a1[168].i8[1] = 0;
  a1[172].i64[0] = 0;
  a1[172].i64[1] = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  a1[173].i16[0] = 257;
  a1[173].i8[8] = 0;
  a1[174].i64[0] = 0;
  a1[174].i8[8] = 0;
  a1[175].i64[0] = 0;
  if (AULoudnessWarriorLogScope(void)::once != -1)
    dispatch_once(&AULoudnessWarriorLogScope(void)::once, &__block_literal_global_9424);
  if (AULoudnessWarriorLogScope(void)::scope)
  {
    v4 = *(NSObject **)AULoudnessWarriorLogScope(void)::scope;
    if (!*(_QWORD *)AULoudnessWarriorLogScope(void)::scope)
      goto LABEL_13;
  }
  else
  {
    v4 = MEMORY[0x1E0C81028];
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "AULoudnessWarrior.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 136;
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d AULoudnessWarrior construction starting\n", buf, 0x12u);
  }
LABEL_13:
  ausdk::AUBase::CreateElements(a1);
  *(_QWORD *)buf = 0x40E5888000000000;
  *(_OWORD *)&buf[8] = xmmword_1B6626900;
  v24 = xmmword_1B66A0830;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&a1[5], 0);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)Element + 56))(Element, buf);
  v16 = 0x40E5888000000000;
  v17 = xmmword_1B6626900;
  v18 = xmmword_1B66A0830;
  v6 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)&a1[8], 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 56))(v6, &v16);
  v7 = 41;
  v8 = &qword_1EF1333E8;
  do
  {
    v9 = (const __CFString *)*(v8 - 3);
    *(_DWORD *)v8 |= 0x8000000u;
    CFStringGetCString(v9, (char *)v8 - 96, 52, 0x8000100u);
    v10 = *(_DWORD *)v8;
    v11 = *(_DWORD *)v8 | 0x40000000;
    *(_DWORD *)v8 = v11;
    if (*((_DWORD *)v8 - 8))
    {
      v11 = v10 | 0x40100000;
      *(_DWORD *)v8 = v10 | 0x40100000;
    }
    v12 = *((_DWORD *)v8 - 26);
    if (v12 > 0x24 || ((1 << v12) & 0x10020040F8) == 0)
      v14 = 0x80000000;
    else
      v14 = 0x8000;
    *(_DWORD *)v8 = v11 | v14;
    (*(void (**)(int64x2_t *, float))(a1->i64[0] + 152))(a1, *((float *)v8 - 1));
    v8 += 14;
    --v7;
  }
  while (v7);
  ausdk::AUBase::SetAFactoryPresetAsCurrent(a1->i8, &kAuPresets);
  return a1;
}

void sub_1B61CB310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  uint64_t v31;
  void *v33;
  void *v34;
  void *v35;

  CACFDictionary::~CACFDictionary((CACFDictionary *)(v30 + 2760));
  std::unique_ptr<AULoudnessWarriorKernel>::reset[abi:ne180100]((AULoudnessWarriorKernel **)(v30 + 2752), 0);
  *(_QWORD *)(v30 + 640) = v31;
  ca::concurrent::deferred_deletion_queue<AULoudnessWarriorKernel,10ul,std::default_delete<AULoudnessWarriorKernel>>::~deferred_deletion_queue(v30 + 704);
  *(_QWORD *)v30 = off_1E69E6E50;
  v33 = *(void **)(v30 + 608);
  if (v33)
  {
    *(_QWORD *)(v30 + 616) = v33;
    operator delete(v33);
  }
  v34 = *(void **)(v30 + 584);
  if (v34)
  {
    *(_QWORD *)(v30 + 592) = v34;
    operator delete(v34);
  }
  v35 = *(void **)(v30 + 560);
  if (v35)
  {
    *(_QWORD *)(v30 + 568) = v35;
    operator delete(v35);
  }
  if (*(char *)(v30 + 551) < 0)
    operator delete(*(void **)(v30 + 528));
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v30);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AULoudnessWarrior>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCircArray>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  AUDebugFeature *v8;
  void *__p;
  char v11;
  void *v12[2];
  char v13;

  std::string::basic_string[abi:ne180100]<0>(v12, "CircArray");
  std::string::basic_string[abi:ne180100]<0>(&__p, "circarray_verbose");
  AUJBase::AUJBase(a1, a2, (__int128 *)v12);
  if (v11 < 0)
    operator delete(__p);
  if (v13 < 0)
    operator delete(v12[0]);
  *(_QWORD *)a1 = &off_1E69D6418;
  *(_WORD *)(a1 + 632) = 0;
  *(_QWORD *)(a1 + 640) = &off_1E69D66D8;
  *(_QWORD *)(a1 + 704) = &off_1E69D66F8;
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)(a1 + 768));
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)(a1 + 1728));
  *(_BYTE *)(a1 + 2689) = 0;
  *(_OWORD *)(a1 + 2752) = 0u;
  *(_OWORD *)(a1 + 2768) = 0u;
  *(_OWORD *)(a1 + 2784) = 0u;
  *(_QWORD *)(a1 + 2800) = 0;
  *(_QWORD *)(a1 + 2808) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_WORD *)(a1 + 2816) = 257;
  *(_QWORD *)(a1 + 2824) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 2832) = 257;
  *(_QWORD *)(a1 + 2840) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 2848) = 257;
  *(_QWORD *)(a1 + 2856) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 2864) = 257;
  *(_QWORD *)(a1 + 2872) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 2880) = 257;
  *(_QWORD *)(a1 + 2888) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 2896) = 257;
  *(_QWORD *)(a1 + 2904) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 2912) = 257;
  *(_QWORD *)(a1 + 2920) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 2928) = 257;
  *(_QWORD *)(a1 + 2936) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 2944) = 257;
  *(_QWORD *)(a1 + 2952) = 0;
  *(_BYTE *)(a1 + 2960) = 1;
  *(_QWORD *)(a1 + 2968) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 2976) = 257;
  *(_DWORD *)(a1 + 2984) = 0;
  *(_QWORD *)(a1 + 2992) = 0;
  *(_DWORD *)(a1 + 3000) = 0;
  *(_BYTE *)(a1 + 3004) = 1;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v4 = 0;
  do
  {
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, v4, 0, 0, 0, 0.0);
    v5 = (v4 + 8);
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, v5, 0, 0, 0, 0.0);
    v6 = (v5 + 8);
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, v6, 0, 0, 0, 1.0);
    v7 = (v6 + 8);
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, v7, 0, 0, 0, 0.0);
    v4 = (v7 - 23);
  }
  while ((_DWORD)v4 != 8);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 32, 0, 0, 0, 40.0);
  v8 = (AUDebugFeature *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 33, 0, 0, 0, 0.0);
  *(_BYTE *)(a1 + 3004) = AUDebugFeature::IsNonFiniteHandlingEnabled(v8);
  return a1;
}

void sub_1B61CB714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  uint64_t v22;
  uint64_t v23;
  CircArrayKernel **v24;
  void *v25;
  void *v26;
  CircArrayKernel **v27;
  void *v28;
  void *v29;
  void *v30;

  CACFString::~CACFString((CACFString *)(v22 + 2952));
  CACFArray::~CACFArray((CACFArray *)(v22 + 2936));
  CACFArray::~CACFArray((CACFArray *)(v22 + 2920));
  CACFArray::~CACFArray((CACFArray *)(v22 + 2904));
  CACFArray::~CACFArray((CACFArray *)(v22 + 2888));
  CACFArray::~CACFArray((CACFArray *)(v22 + 2872));
  CACFArray::~CACFArray((CACFArray *)(v22 + 2856));
  CACFArray::~CACFArray((CACFArray *)(v22 + 2840));
  CACFArray::~CACFArray((CACFArray *)(v22 + 2824));
  CACFDictionary::~CACFDictionary((CACFDictionary *)(v22 + 2808));
  v24 = (CircArrayKernel **)(v22 + 2752);
  v25 = *(void **)(v22 + 2784);
  if (v25)
  {
    *(_QWORD *)(v22 + 2792) = v25;
    operator delete(v25);
    v24 = (CircArrayKernel **)(v22 + 2752);
  }
  v26 = *(void **)(v22 + 2760);
  if (v26)
  {
    *(_QWORD *)(v22 + 2768) = v26;
    v27 = v24;
    operator delete(v26);
    v24 = v27;
  }
  std::unique_ptr<CircArrayKernel>::reset[abi:ne180100](v24, 0);
  *(_QWORD *)(v22 + 640) = v23;
  ca::concurrent::deferred_deletion_queue<CircArrayKernel,10ul,std::default_delete<CircArrayKernel>>::~deferred_deletion_queue(v22 + 704);
  *(_QWORD *)v22 = off_1E69E6E50;
  v28 = *(void **)(v22 + 608);
  if (v28)
  {
    *(_QWORD *)(v22 + 616) = v28;
    operator delete(v28);
  }
  v29 = *(void **)(v22 + 584);
  if (v29)
  {
    *(_QWORD *)(v22 + 592) = v29;
    operator delete(v29);
  }
  v30 = *(void **)(v22 + 560);
  if (v30)
  {
    *(_QWORD *)(v22 + 568) = v30;
    operator delete(v30);
  }
  if (*(char *)(v22 + 551) < 0)
    operator delete(*(void **)(v22 + 528));
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v22);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCircArray>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUScotty>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Element;
  uint64_t v9;
  unsigned int i;
  float v11;
  ausdk::AUElement *v12;
  char *v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  __CFString **v17;
  NSObject *v18;
  _BYTE buf[24];
  __int128 v21[4];
  void *__p;
  char v23;
  uint64_t v24;
  uint8_t v25[4];
  const char *v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1) = &off_1E69CB110;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v21, (_QWORD *)(a1 + 528));
  *(_QWORD *)buf = *MEMORY[0x1E0DE4F50];
  v3 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&buf[16] = v3;
  *(_QWORD *)&v21[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v23 < 0)
    operator delete(__p);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1BCC95BE4](&v24);
  *(_QWORD *)(a1 + 552) = -1;
  *(_QWORD *)(a1 + 560) = 16777217;
  *(_BYTE *)(a1 + 568) = 1;
  *(_QWORD *)(a1 + 576) = 0;
  *(_DWORD *)(a1 + 584) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(a1 + 588));
  *(_QWORD *)(a1 + 752) = 0;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  if (getScottyLog(void)::onceToken != -1)
    dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
  v4 = getScottyLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    v5 = a1 + 528;
    if (*(char *)(a1 + 551) < 0)
      v5 = *(_QWORD *)(a1 + 528);
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v5;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "AUScotty";
    _os_log_impl(&dword_1B5ED0000, v4, OS_LOG_TYPE_DEFAULT, "[%s|%s] Constructing", buf, 0x16u);
  }
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v6 = *(_QWORD *)(a1 + 72);
  if (v6)
    v7 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
  else
    v7 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 40))(v7, 34);
  *(_QWORD *)buf = 0x40E5888000000000;
  *(_OWORD *)&buf[8] = xmmword_1B6626900;
  v21[0] = xmmword_1B66A0D00;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)Element + 56))(Element, buf);
  v9 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v9 + 56))(v9, buf);
  for (i = 0; i != 34; ++i)
  {
    *(_DWORD *)v25 = 0;
    if (ScottyUpmixer::GetParamDefault(i, 0, (float *)v25))
    {
      v11 = *(float *)v25;
      v12 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
      ausdk::AUElement::SetParameter(v12, i, v11, 0);
    }
  }
  v13 = ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)a1, (const AUPreset *)&kPresets);
  v14 = 0;
  *(_BYTE *)(a1 + 563) = AUDebugFeature::IsNonFiniteHandlingEnabled((AUDebugFeature *)v13);
  do
  {
    *(_DWORD *)v25 = 0;
    if ((ScottyUpmixer::GetParamDefault(v14, 0, (float *)v25) & 1) != 0)
    {
      v15 = *(_DWORD *)v25;
    }
    else
    {
      v16 = 0;
      while (1)
      {
        v17 = (__CFString **)((char *)&kParameterInfo + v16);
        if (*(_DWORD *)((char *)&kParameterInfo + v16) == (_DWORD)v14)
          break;
        v16 += 40;
        if (v16 == 1360)
          goto LABEL_25;
      }
      if (v17 != kDspLibBuzzKillParameterNames)
      {
        v15 = *((_DWORD *)v17 + 7);
        goto LABEL_29;
      }
LABEL_25:
      if (getScottyLog(void)::onceToken != -1)
        dispatch_once(&getScottyLog(void)::onceToken, &__block_literal_global_21994);
      v18 = getScottyLog(void)::gLog;
      v15 = 0;
      if (os_log_type_enabled((os_log_t)getScottyLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v25 = 136315394;
        v26 = "GetParamDefault";
        v27 = 1024;
        v28 = v14;
        _os_log_impl(&dword_1B5ED0000, v18, OS_LOG_TYPE_DEFAULT, "%s: Invalid Parameter ID: %u", v25, 0x12u);
      }
    }
LABEL_29:
    atomic_store(v15, (unsigned int *)(a1 + 592 + 4 * v14++));
  }
  while (v14 != 34);
  return a1;
}

void sub_1B61CBD10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  char *v27;
  void **v28;

  if (v27[551] < 0)
    operator delete(*v28);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v27);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUScotty>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULando>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t Element;
  unsigned int i;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE v28[48];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69C9130;
  *((_BYTE *)v3 + 528) = 0;
  *((_QWORD *)v3 + 67) = 0x40E5888000000000;
  v4 = operator new();
  *(_QWORD *)v4 = 0;
  IR::HilbertFIR::HilbertFIR((IR::HilbertFIR *)(v4 + 8));
  IR::HilbertFIR::HilbertFIR((IR::HilbertFIR *)(v4 + 16));
  IR::FixedIntegerDelay::FixedIntegerDelay((IR::FixedIntegerDelay *)(v4 + 24), 0x23u, 0);
  IR::FixedIntegerDelay::FixedIntegerDelay((IR::FixedIntegerDelay *)(v4 + 80), 0x23u, 0);
  IR::FixedIntegerDelay::FixedIntegerDelay((IR::FixedIntegerDelay *)(v4 + 136), 0x23u, 1);
  IR::FixedIntegerDelay::FixedIntegerDelay((IR::FixedIntegerDelay *)(v4 + 192), 0x23u, 1);
  *(_OWORD *)(v4 + 388) = xmmword_1B66A0D10;
  *(_QWORD *)(v4 + 416) = 0x500000002;
  *(_OWORD *)(v4 + 504) = 0u;
  *(_OWORD *)(v4 + 520) = 0u;
  *(_OWORD *)(v4 + 536) = 0u;
  *(_OWORD *)(v4 + 552) = 0u;
  *(_OWORD *)(v4 + 568) = 0u;
  *(_OWORD *)(v4 + 584) = 0u;
  *(_OWORD *)(v4 + 600) = 0u;
  *(_OWORD *)(v4 + 440) = unk_1B662F754;
  *(_OWORD *)(v4 + 456) = xmmword_1B662F764;
  *(_QWORD *)(v4 + 404) = 0x3F80000000000000;
  *(_QWORD *)(v4 + 616) = 0;
  *(_OWORD *)(v4 + 472) = unk_1B662F774;
  *(_OWORD *)(v4 + 488) = xmmword_1B662F784;
  *(_OWORD *)(v4 + 424) = xmmword_1B662F744;
  v5 = *(_OWORD *)(v4 + 592);
  v36 = *(_OWORD *)(v4 + 576);
  v37 = v5;
  v38 = *(_OWORD *)(v4 + 608);
  v6 = *(_OWORD *)(v4 + 528);
  v32 = *(_OWORD *)(v4 + 512);
  v33 = v6;
  v7 = *(_OWORD *)(v4 + 560);
  v34 = *(_OWORD *)(v4 + 544);
  v35 = v7;
  v8 = *(_OWORD *)(v4 + 464);
  *(_OWORD *)&v28[32] = *(_OWORD *)(v4 + 448);
  v29 = v8;
  v9 = *(_OWORD *)(v4 + 432);
  *(_OWORD *)v28 = *(_OWORD *)(v4 + 416);
  *(_OWORD *)&v28[16] = v9;
  v10 = *(_OWORD *)(v4 + 496);
  v30 = *(_OWORD *)(v4 + 480);
  v31 = v10;
  vDSP_vneg((const float *)((unint64_t)v28 | 0xC), 2, (float *)((unint64_t)v28 | 0xC), 2, *(int *)&v28[4] * (uint64_t)*(int *)v28);
  fb::ComplexMat::transposed((fb::ComplexMat *)(v4 + 624), (const float *)v28);
  fb::ComplexMat::pseudoInverse((fb::ComplexMat *)(v4 + 832), (const fb::ComplexMat *)(v4 + 416), (const fb::ComplexMat *)(v4 + 624));
  *(_QWORD *)(v4 + 1040) = 0x500000005;
  *(_QWORD *)(v4 + 1248) = 0x200000005;
  *(_OWORD *)(v4 + 1272) = 0u;
  *(_OWORD *)(v4 + 1288) = 0u;
  *(_OWORD *)(v4 + 1304) = 0u;
  *(_OWORD *)(v4 + 1320) = 0u;
  *(_OWORD *)(v4 + 1336) = 0u;
  *(_OWORD *)(v4 + 1352) = 0u;
  *(_OWORD *)(v4 + 1368) = 0u;
  *(_OWORD *)(v4 + 1384) = 0u;
  *(_OWORD *)(v4 + 1400) = 0u;
  *(_OWORD *)(v4 + 1416) = 0u;
  *(_OWORD *)(v4 + 1432) = 0u;
  *(_OWORD *)(v4 + 1256) = 0u;
  *(_QWORD *)(v4 + 1448) = 0;
  *(_QWORD *)(v4 + 1240) = 0;
  *(_OWORD *)(v4 + 1048) = 0u;
  *(_OWORD *)(v4 + 1064) = 0u;
  *(_OWORD *)(v4 + 1080) = 0u;
  *(_OWORD *)(v4 + 1096) = 0u;
  *(_OWORD *)(v4 + 1112) = 0u;
  *(_OWORD *)(v4 + 1128) = 0u;
  *(_OWORD *)(v4 + 1144) = 0u;
  *(_OWORD *)(v4 + 1160) = 0u;
  *(_OWORD *)(v4 + 1176) = 0u;
  *(_OWORD *)(v4 + 1192) = 0u;
  *(_OWORD *)(v4 + 1208) = 0u;
  *(_OWORD *)(v4 + 1224) = 0u;
  fb::ComplexMat::stabilize((_DWORD *)(v4 + 1040), 0.0);
  bzero((void *)(v4 + 1256), 8 * *(_DWORD *)(v4 + 1252) * *(_DWORD *)(v4 + 1248));
  *(_QWORD *)(v4 + 1456) = 0x400000002;
  *(_OWORD *)(v4 + 1528) = 0u;
  *(_OWORD *)(v4 + 1544) = 0u;
  *(_OWORD *)(v4 + 1560) = 0u;
  *(_OWORD *)(v4 + 1576) = 0u;
  *(_OWORD *)(v4 + 1592) = 0u;
  *(_OWORD *)(v4 + 1608) = 0u;
  *(_OWORD *)(v4 + 1624) = 0u;
  *(_OWORD *)(v4 + 1640) = 0u;
  *(_QWORD *)(v4 + 1656) = 0;
  *(_OWORD *)(v4 + 1464) = *(_OWORD *)"";
  *(_OWORD *)(v4 + 1480) = unk_1B6676510;
  *(_OWORD *)(v4 + 1496) = xmmword_1B6676520;
  *(_OWORD *)(v4 + 1512) = unk_1B6676530;
  v11 = *(_OWORD *)(v4 + 1600);
  v12 = *(_OWORD *)(v4 + 1632);
  v36 = *(_OWORD *)(v4 + 1616);
  v37 = v12;
  v38 = *(_OWORD *)(v4 + 1648);
  v13 = *(_OWORD *)(v4 + 1536);
  v14 = *(_OWORD *)(v4 + 1568);
  v32 = *(_OWORD *)(v4 + 1552);
  v33 = v14;
  v34 = *(_OWORD *)(v4 + 1584);
  v35 = v11;
  v15 = *(_OWORD *)(v4 + 1472);
  v16 = *(_OWORD *)(v4 + 1504);
  *(_OWORD *)&v28[32] = *(_OWORD *)(v4 + 1488);
  v29 = v16;
  *(_OWORD *)v28 = *(_OWORD *)(v4 + 1456);
  *(_OWORD *)&v28[16] = v15;
  v30 = *(_OWORD *)(v4 + 1520);
  v31 = v13;
  vDSP_vneg((const float *)((unint64_t)v28 | 0xC), 2, (float *)((unint64_t)v28 | 0xC), 2, *(int *)&v28[4] * (uint64_t)*(int *)v28);
  fb::ComplexMat::transposed((fb::ComplexMat *)(v4 + 1664), (const float *)v28);
  fb::ComplexMat::pseudoInverse((fb::ComplexMat *)(v4 + 1872), (const fb::ComplexMat *)(v4 + 1456), (const fb::ComplexMat *)(v4 + 1664));
  *(_QWORD *)(v4 + 2080) = 0x400000004;
  *(_QWORD *)(v4 + 2280) = 0;
  *(_OWORD *)(v4 + 2216) = 0u;
  *(_OWORD *)(v4 + 2232) = 0u;
  *(_OWORD *)(v4 + 2248) = 0u;
  *(_OWORD *)(v4 + 2264) = 0u;
  *(_QWORD *)(v4 + 2288) = 0x200000004;
  *(_OWORD *)(v4 + 2312) = 0u;
  *(_OWORD *)(v4 + 2328) = 0u;
  *(_OWORD *)(v4 + 2344) = 0u;
  *(_OWORD *)(v4 + 2360) = 0u;
  *(_OWORD *)(v4 + 2376) = 0u;
  *(_OWORD *)(v4 + 2392) = 0u;
  *(_OWORD *)(v4 + 2408) = 0u;
  *(_OWORD *)(v4 + 2424) = 0u;
  *(_OWORD *)(v4 + 2440) = 0u;
  *(_OWORD *)(v4 + 2456) = 0u;
  *(_OWORD *)(v4 + 2472) = 0u;
  *(_OWORD *)(v4 + 2296) = 0u;
  *(_QWORD *)(v4 + 2488) = 0;
  *(_OWORD *)(v4 + 2200) = 0u;
  *(_OWORD *)(v4 + 2184) = 0u;
  *(_OWORD *)(v4 + 2168) = 0u;
  *(_OWORD *)(v4 + 2152) = 0u;
  *(_OWORD *)(v4 + 2136) = 0u;
  *(_OWORD *)(v4 + 2120) = 0u;
  *(_OWORD *)(v4 + 2104) = 0u;
  *(_OWORD *)(v4 + 2088) = 0u;
  fb::ComplexMat::stabilize((_DWORD *)(v4 + 2080), 0.0);
  bzero((void *)(v4 + 2296), 8 * *(_DWORD *)(v4 + 2292) * *(_DWORD *)(v4 + 2288));
  *(_QWORD *)(a1 + 544) = v4;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v17 = 0;
  *(_QWORD *)v28 = 0x40E5888000000000;
  *(_OWORD *)&v28[8] = xmmword_1B6626900;
  *(_OWORD *)&v28[24] = xmmword_1B66A0830;
  v39 = 0x40E5888000000000;
  v40 = xmmword_1B6626900;
  v41 = xmmword_1B66A0D00;
  while (1)
  {
    v18 = *(_QWORD *)(a1 + 120);
    if (v18)
      LODWORD(v19) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
    else
      v19 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v17 >= v19)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v17);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)Element + 56))(Element, v28);
    ++v17;
  }
  for (i = 0; ; ++i)
  {
    v22 = *(_QWORD *)(a1 + 168);
    if (v22)
      LODWORD(v23) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
    else
      v23 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v23)
      break;
    v24 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v24 + 56))(v24, &v39);
  }
  *(_BYTE *)(a1 + 376) = 0;
  v25 = *(_QWORD *)(a1 + 72);
  if (v25)
    v26 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, 0);
  else
    v26 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v26 + 40))(v26, 12);
  (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 0, 0, 0, 0, 4.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 1, 0, 0, 0, 0.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 2, 0, 0, 0, 1.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 3, 0, 0, 0, -0.36);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 4, 0, 0, 0, 1.92);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 5, 0, 0, 0, 1.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 6, 0, 0, 0, 1.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 7, 0, 0, 0, 0.755);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 8, 0, 0, 0, 400.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 9, 0, 0, 0, 10000.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 10, 0, 0, 0, 1.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 11, 0, 0, 0, 0.0);
  return a1;
}

void sub_1B61CC4C0(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v5 = (void *)v2[21];
  if (v5)
  {
    v2[22] = (uint64_t)v5;
    operator delete(v5);
  }
  v6 = (void *)v2[18];
  if (v6)
  {
    v2[19] = (uint64_t)v6;
    operator delete(v6);
  }
  v7 = (void *)v2[14];
  if (v7)
  {
    v2[15] = (uint64_t)v7;
    operator delete(v7);
  }
  v8 = (void *)v2[11];
  if (v8)
  {
    v2[12] = (uint64_t)v8;
    operator delete(v8);
  }
  v9 = (void *)v2[7];
  if (v9)
  {
    v2[8] = (uint64_t)v9;
    operator delete(v9);
  }
  v10 = (void *)v2[4];
  if (v10)
  {
    v2[5] = (uint64_t)v10;
    operator delete(v10);
  }
  v11 = *v4;
  *v4 = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  v12 = *v3;
  *v3 = 0;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  v13 = *v2;
  *v2 = 0;
  if (v13)
    std::default_delete<Crossover2f>::operator()[abi:ne180100](v13);
  MEMORY[0x1BCC95CEC](v2, 0x10A0C4052BE26CALL);
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AULando>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCarter>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  int64x2_t *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t Element;
  unsigned int i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;

  v3 = (int64x2_t *)ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  v3->i64[0] = (uint64_t)&off_1E69E9E18;
  v3[33].i8[0] = 0;
  v3[33].i64[1] = 0x40E5888000000000;
  v3[34].i64[0] = 0;
  v3[44].i64[1] = 0;
  ausdk::AUBase::CreateElements(v3);
  v4 = 0;
  v16 = 0x40E7700000000000;
  v17 = xmmword_1B6626900;
  v18 = xmmword_1B66A0D00;
  v13 = 0x40E7700000000000;
  v14 = xmmword_1B6626900;
  v15 = xmmword_1B66A0830;
  while (1)
  {
    v5 = a1[15];
    if (v5)
      LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    else
      v6 = (a1[13] - a1[12]) >> 3;
    if (v4 >= v6)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), v4);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v16);
    ++v4;
  }
  for (i = 0; ; ++i)
  {
    v9 = a1[21];
    if (v9)
      LODWORD(v10) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    else
      v10 = (a1[19] - a1[18]) >> 3;
    if (i >= v10)
      break;
    v11 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v11 + 56))(v11, &v13);
  }
  return a1;
}

void sub_1B61CC744(_Unwind_Exception *a1)
{
  IR::DelayLine **v1;

  std::unique_ptr<IR::DelayLine>::reset[abi:ne180100](v1 + 89, 0);
  std::unique_ptr<IR::DelayLine>::reset[abi:ne180100](v1 + 68, 0);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUCarter>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUFIREngine>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  unsigned int i;
  int v5;
  void *__p;
  char v8;
  void *v9[2];
  char v10;

  std::string::basic_string[abi:ne180100]<0>(v9, "AUFIREngine_");
  std::string::basic_string[abi:ne180100]<0>(&__p, "firengine_verbose");
  AUJBase::AUJBase(a1, a2, (__int128 *)v9);
  if (v8 < 0)
    operator delete(__p);
  if (v10 < 0)
    operator delete(v9[0]);
  *(_QWORD *)a1 = &off_1E69E2FC0;
  *(_WORD *)(a1 + 632) = 0;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_QWORD *)(a1 + 704) = &off_1E69E3260;
  *(_QWORD *)(a1 + 768) = &off_1E69E3280;
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)(a1 + 832));
  boost::lockfree::queue<std::vector<std::vector<float>> *,boost::lockfree::capacity<10ul>>::queue((unsigned int *)(a1 + 1792));
  *(_BYTE *)(a1 + 2753) = 0;
  *(_OWORD *)(a1 + 2816) = 0u;
  *(_OWORD *)(a1 + 2832) = 0u;
  *(_OWORD *)(a1 + 2848) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 0, 0, 0, 0, 0.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 1, 0, 0, 0, 20.0);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, 2, 0, 0, 0, 0.0);
  for (i = 0; ; ++i)
  {
    v5 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0) + 108);
    if (i >= *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0) + 108) * v5)
      break;
    if (!(*(unsigned int (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 576))(a1, i + 1000000, 0, 0))(*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, i + 1000000, 0, 0, 0, 0.0);
    if (!(*(unsigned int (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 576))(a1, i + 2000000, 0, 0))(*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, i + 2000000, 0, 0, 0, 0.0);
    if (!(*(unsigned int (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 576))(a1, i + 3000000, 0, 0))(*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, i + 3000000, 0, 0, 0, 0.0);
  }
  return a1;
}

void sub_1B61CCA1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUFIREngine>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMatrixPatcher>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t Element;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  __int128 v9;
  __int128 v10;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69E01C8;
  *((_QWORD *)v3 + 66) = 0;
  *(_QWORD *)(a1 + 536) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 544) = 257;
  *(_QWORD *)(a1 + 552) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 560) = 257;
  *(_QWORD *)(a1 + 568) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_WORD *)(a1 + 576) = 257;
  *(_QWORD *)(a1 + 584) = 0x100000001;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v8 = 0x40E5888000000000;
  v9 = xmmword_1B6626900;
  v10 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v8);
  v5 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v5 + 56))(v5, &v8);
  if (*(_DWORD *)(a1 + 588) * *(_DWORD *)(a1 + 584))
  {
    v6 = 0;
    do
    {
      (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)a1 + 152))(a1, v6, 0, 0, 0, 0.0);
      v6 = (v6 + 1);
    }
    while (v6 < *(_DWORD *)(a1 + 588) * *(_DWORD *)(a1 + 584));
  }
  return a1;
}

void sub_1B61CCC70(_Unwind_Exception *a1)
{
  _QWORD *v1;

  CACFDictionary::~CACFDictionary((CACFDictionary *)(v1 + 71));
  CACFArray::~CACFArray((CACFArray *)(v1 + 69));
  CACFArray::~CACFArray((CACFArray *)(v1 + 67));
  std::unique_ptr<MatrixMixerCore>::reset[abi:ne180100](v1 + 66, 0);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMatrixPatcher>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDSPGraph>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  std::string *v4;
  _QWORD *v5;
  DSPGraph *Mutable;
  uint64_t Element;
  uint64_t v8;
  std::string::size_type size;
  tm *v10;
  uint64_t v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  std::runtime_error *exception;
  std::string __str;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  std::string::size_type v23;
  time_t v24;
  std::chrono::system_clock::time_point __t;
  uint8_t buf[32];
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69D0F78;
  *((_BYTE *)v3 + 528) = 0;
  v4 = (std::string *)((char *)v3 + 536);
  *((_BYTE *)v3 + 592) = 0;
  *((_BYTE *)v3 + 600) = 0;
  *((_BYTE *)v3 + 624) = 0;
  v5 = (_QWORD *)((char *)v3 + 632);
  *((_BYTE *)v3 + 632) = 0;
  *((_BYTE *)v3 + 656) = 0;
  *(_OWORD *)((char *)v3 + 532) = 0u;
  *(_OWORD *)((char *)v3 + 548) = 0u;
  *(_QWORD *)((char *)v3 + 561) = 0;
  *((_QWORD *)v3 + 83) = 0;
  *((_QWORD *)v3 + 85) = 0;
  *((_QWORD *)v3 + 84) = 0;
  *(_QWORD *)(a1 + 688) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_WORD *)(a1 + 696) = 257;
  *(_QWORD *)(a1 + 704) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_WORD *)(a1 + 712) = 257;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(a1 + 720) = Mutable;
  *(_WORD *)(a1 + 728) = 257;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(_OWORD *)(a1 + 880) = 0u;
  *(_QWORD *)(a1 + 893) = 0;
  *(_QWORD *)(a1 + 904) = 0;
  *(_QWORD *)(a1 + 920) = 0;
  *(_QWORD *)(a1 + 912) = 0;
  *(_QWORD *)(a1 + 928) = 850045863;
  *(_QWORD *)(a1 + 1008) = 0;
  *(_QWORD *)(a1 + 1016) = 0;
  *(_OWORD *)(a1 + 984) = 0u;
  *(_OWORD *)(a1 + 968) = 0u;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_OWORD *)(a1 + 936) = 0u;
  *(_QWORD *)(a1 + 1000) = a1 + 1008;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(_OWORD *)(a1 + 1024) = 0u;
  if (DSPGraph::ABIVersion(Mutable) != 4)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = -10875;
      _os_log_error_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "throwing %d", buf, 8u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x18uLL);
    ausdk::AUException::AUException(exception, -10875);
  }
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v19 = 0x40E5888000000000;
  v20 = xmmword_1B6626900;
  v21 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v19);
  v8 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v8 + 56))(v8, &v19);
  std::string::basic_string[abi:ne180100]<0>(&__str, "");
  size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __str.__r_.__value_.__l.__size_;
  if (size)
  {
    std::string::operator=(v4, &__str);
  }
  else
  {
    v27 = 0u;
    v28 = 0u;
    memset(buf, 0, sizeof(buf));
    __t.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    v24 = std::chrono::system_clock::to_time_t(&__t);
    v10 = localtime(&v24);
    strftime((char *)buf, 0x40uLL, "%Y%m%d.%H%M%S", v10);
    std::string::basic_string[abi:ne180100]<0>(&v22, (char *)buf);
    if (*(char *)(a1 + 559) < 0)
      operator delete(v4->__r_.__value_.__l.__data_);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v22;
    v4->__r_.__value_.__r.__words[2] = v23;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (*(_BYTE *)(a1 + 656))
  {
    if (getAUDSPGraphLog(void)::onceToken != -1)
      dispatch_once(&getAUDSPGraphLog(void)::onceToken, &__block_literal_global_6983);
    v11 = getAUDSPGraphLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUDSPGraphLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 655) < 0)
        v5 = (_QWORD *)*v5;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v5;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = a1;
      v12 = "[%s|%p] constructed";
      v13 = v11;
      v14 = 22;
      goto LABEL_22;
    }
  }
  else
  {
    if (getAUDSPGraphLog(void)::onceToken != -1)
      dispatch_once(&getAUDSPGraphLog(void)::onceToken, &__block_literal_global_6983);
    v15 = getAUDSPGraphLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)getAUDSPGraphLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a1;
      v12 = "[%p] constructed";
      v13 = v15;
      v14 = 12;
LABEL_22:
      _os_log_impl(&dword_1B5ED0000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
    }
  }
  return a1;
}

void sub_1B61CD108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16)
{
  uint64_t v16;
  void **v17;
  uint64_t v18;
  std::mutex *v19;
  void *v20;
  void **v21;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  void *v28;
  const void *v29;
  void *v30;
  void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  void *v35;
  void *v36;
  void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  uint64_t v41;

  __cxa_free_exception(v20);
  v23 = *(const void **)(v16 + 1080);
  if (v23)
    CFRelease(v23);
  v24 = *(const void **)(v16 + 1072);
  if (v24)
    CFRelease(v24);
  v25 = *(const void **)(v16 + 1064);
  if (v25)
    CFRelease(v25);
  v26 = *(const void **)(v16 + 1056);
  if (v26)
    CFRelease(v26);
  v27 = *(const void **)(v16 + 1048);
  if (v27)
    CFRelease(v27);
  v28 = *(void **)(v16 + 1024);
  if (v28)
  {
    *(_QWORD *)(v16 + 1032) = v28;
    operator delete(v28);
  }
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(_QWORD **)(v16 + 1008));
  v29 = *(const void **)(v16 + 992);
  if (v29)
    CFRelease(v29);
  std::mutex::~mutex(v19);
  a16 = v16 + 904;
  std::vector<AU::DSPGraph::MetaParameter>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  v30 = *(void **)(v16 + 872);
  if (v30)
  {
    *(_QWORD *)(v16 + 880) = v30;
    operator delete(v30);
  }
  v31 = *(void **)(v16 + 848);
  if (v31)
  {
    *(_QWORD *)(v16 + 856) = v31;
    operator delete(v31);
  }
  v32 = *(const void **)(v16 + 840);
  if (v32)
    CFRelease(v32);
  v33 = *(const void **)(v16 + 832);
  if (v33)
    CFRelease(v33);
  v34 = *(const void **)(v16 + 824);
  if (v34)
    CFRelease(v34);
  v35 = *(void **)(v16 + 800);
  if (v35)
  {
    *(_QWORD *)(v16 + 808) = v35;
    operator delete(v35);
  }
  v36 = *(void **)(v16 + 776);
  if (v36)
  {
    *(_QWORD *)(v16 + 784) = v36;
    operator delete(v36);
  }
  v37 = *(void **)(v16 + 752);
  if (v37)
  {
    *(_QWORD *)(v16 + 760) = v37;
    operator delete(v37);
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v18);
  CACFArray::~CACFArray((CACFArray *)(v16 + 720));
  CACFArray::~CACFArray((CACFArray *)(v16 + 704));
  CACFDictionary::~CACFDictionary((CACFDictionary *)(v16 + 688));
  v38 = *(const void **)(v16 + 680);
  if (v38)
    CFRelease(v38);
  v39 = *(const void **)(v16 + 672);
  if (v39)
    CFRelease(v39);
  v40 = *(const void **)(v16 + 664);
  if (v40)
    CFRelease(v40);
  if (*(_BYTE *)(v16 + 656) && *(char *)(v16 + 655) < 0)
    operator delete(*v21);
  if (*(_BYTE *)(v16 + 624) && *(char *)(v16 + 623) < 0)
    operator delete(*(void **)(v16 + 600));
  if (*(_BYTE *)(v16 + 592) && *(char *)(v16 + 591) < 0)
    operator delete(*(void **)(v16 + 568));
  v41 = *(_QWORD *)(v16 + 560);
  *(_QWORD *)(v16 + 560) = 0;
  if (v41)
    (*(void (**)(uint64_t))(*(_QWORD *)v41 + 8))(v41);
  if (*(char *)(v16 + 559) < 0)
    operator delete(*v17);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v16);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDSPGraph>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDecorrelator>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  ausdk::AUElement *v8;
  ausdk::AUElement **v9;
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  uint64_t Element;
  uint64_t v17;
  float v18;
  unsigned int v19;
  unint64_t v20;
  void *v21;
  unint64_t v23;
  void *__p[2];
  __int128 v25;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69D5E10;
  *((_BYTE *)v3 + 528) = 0;
  *(_QWORD *)((char *)v3 + 532) = 0;
  *((_QWORD *)v3 + 68) = 0x246BB8000;
  *((_DWORD *)v3 + 138) = 1045220557;
  *((_QWORD *)v3 + 74) = 0x100000000;
  *((_QWORD *)v3 + 75) = 0x3DCCCCCD00000002;
  v4 = (char *)v3 + 608;
  *((_OWORD *)v3 + 38) = 0u;
  *((_OWORD *)v3 + 39) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v5 = *(_QWORD *)(a1 + 72);
  if (v5)
    v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
  else
    v6 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 40))(v6, 3);
  v7 = *(_QWORD *)(a1 + 72);
  if (v7)
  {
    v8 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
  }
  else
  {
    v9 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v9)
      v8 = 0;
    else
      v8 = *v9;
  }
  ausdk::AUElement::SetParameter(v8, 0, 0.2, 0);
  v10 = *(_QWORD *)(a1 + 72);
  if (v10)
  {
    v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
  }
  else
  {
    v12 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v12)
      v11 = 0;
    else
      v11 = *v12;
  }
  ausdk::AUElement::SetParameter(v11, 1u, 0.0, 0);
  v13 = *(_QWORD *)(a1 + 72);
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  }
  else
  {
    v15 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v15)
      v14 = 0;
    else
      v14 = *v15;
  }
  ausdk::AUElement::SetParameter(v14, 2u, 1.0, 0);
  *(_DWORD *)(a1 + 552) = 1045220557;
  *(_QWORD *)(a1 + 592) = 0x100000000;
  v23 = 0x40D7700000000000;
  *(_OWORD *)__p = xmmword_1B6626900;
  v25 = xmmword_1B66A0830;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, unint64_t *))(*(_QWORD *)Element + 56))(Element, &v23);
  v17 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, unint64_t *))(*(_QWORD *)v17 + 56))(v17, &v23);
  *(_WORD *)(a1 + 540) = 0;
  v18 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0) + 80);
  *(float *)(a1 + 544) = v18;
  v19 = *(_DWORD *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0) + 108);
  if (v19 >= 2)
    v19 = 2;
  *(_DWORD *)(a1 + 548) = v19;
  v20 = *(unsigned int *)(a1 + 336);
  v23 = __PAIR64__(*(_DWORD *)(a1 + 552), v19);
  std::vector<float>::vector(__p, v20);
  *((_QWORD *)&v25 + 1) = *(_QWORD *)(a1 + 592);
  *(_QWORD *)(a1 + 600) = v23;
  if ((unint64_t *)(a1 + 600) != &v23)
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v4, (char *)__p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
  v21 = __p[0];
  *(_QWORD *)(a1 + 632) = *((_QWORD *)&v25 + 1);
  if (v21)
  {
    __p[1] = v21;
    operator delete(v21);
  }
  return a1;
}

void sub_1B61CD610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  ausdk::AUBase *v12;
  void **v13;
  void *v15;

  if (__p)
    operator delete(__p);
  v15 = *v13;
  if (*v13)
  {
    *((_QWORD *)v12 + 77) = v15;
    operator delete(v15);
  }
  ausdk::AUBase::~AUBase(v12);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDecorrelator>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUTweakaLeakIR>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  _OWORD *v3;
  ausdk::AUBase *v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t Element;
  unsigned int i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  uint64_t v25;
  ausdk::AUElement *v26;
  ausdk::AUElement **v27;
  uint64_t v28;
  ausdk::AUElement *v29;
  ausdk::AUElement **v30;
  uint64_t v31;
  ausdk::AUElement *v32;
  ausdk::AUElement **v33;
  uint64_t v34;
  ausdk::AUElement *v35;
  ausdk::AUElement **v36;
  uint64_t v37;
  ausdk::AUElement *v38;
  ausdk::AUElement **v39;
  uint64_t v40;
  ausdk::AUElement *v41;
  ausdk::AUElement **v42;
  uint64_t v43;
  ausdk::AUElement *v44;
  ausdk::AUElement **v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  ausdk::AUElement **v48;
  uint64_t v49;
  ausdk::AUElement *v50;
  ausdk::AUElement **v51;
  uint64_t v52;
  ausdk::AUElement *v53;
  ausdk::AUElement **v54;
  uint64_t v55;
  ausdk::AUElement *v56;
  ausdk::AUElement **v57;
  uint64_t v58;
  ausdk::AUElement *v59;
  ausdk::AUElement **v60;
  uint64_t v61;
  ausdk::AUElement *v62;
  ausdk::AUElement **v63;
  uint64_t v64;
  ausdk::AUElement *v65;
  ausdk::AUElement **v66;
  uint64_t v67;
  ausdk::AUElement *v68;
  ausdk::AUElement **v69;
  uint64_t v70;
  ausdk::AUElement *v71;
  ausdk::AUElement **v72;
  uint64_t v73;
  ausdk::AUElement *v74;
  ausdk::AUElement **v75;
  uint64_t v76;
  ausdk::AUElement *v77;
  ausdk::AUElement **v78;
  uint64_t v79;
  ausdk::AUElement *v80;
  ausdk::AUElement **v81;
  uint64_t v82;
  ausdk::AUElement *v83;
  ausdk::AUElement **v84;
  uint64_t v85;
  ausdk::AUElement *v86;
  ausdk::AUElement **v87;
  uint64_t v88;
  ausdk::AUElement *v89;
  ausdk::AUElement **v90;
  uint64_t v91;
  ausdk::AUElement *v92;
  ausdk::AUElement **v93;
  uint64_t v94;
  ausdk::AUElement *v95;
  ausdk::AUElement **v96;
  uint64_t v97;
  ausdk::AUElement *v98;
  ausdk::AUElement **v99;
  uint64_t v100;
  ausdk::AUElement *v101;
  ausdk::AUElement **v102;
  uint64_t v103;
  ausdk::AUElement *v104;
  ausdk::AUElement **v105;
  uint64_t v106;
  uint64_t v108;
  __int128 v109;
  __int128 v110;

  v3 = (_OWORD *)(a1 + 540);
  v4 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 2, 1);
  *(_QWORD *)v4 = &off_1E69CEA80;
  *((_QWORD *)v4 + 66) = 0;
  *(_DWORD *)((char *)v4 + 535) = 0;
  *v3 = xmmword_1B66A0D20;
  *(_QWORD *)((char *)v4 + 556) = 0x3F80000000000100;
  *(_OWORD *)((char *)v4 + 628) = xmmword_1B6686D34;
  *(_OWORD *)((char *)v4 + 644) = unk_1B6686D44;
  *(_OWORD *)((char *)v4 + 660) = xmmword_1B6686D54;
  *(_OWORD *)((char *)v4 + 564) = xmmword_1B6686CF4;
  *(_OWORD *)((char *)v4 + 580) = unk_1B6686D04;
  *(_OWORD *)((char *)v4 + 596) = xmmword_1B6686D14;
  *(_OWORD *)((char *)v4 + 612) = unk_1B6686D24;
  *((_BYTE *)v4 + 676) = 1;
  *(_OWORD *)((char *)v3 + 140) = xmmword_1B66A0D30;
  *((_QWORD *)v4 + 87) = 0x800000004;
  *((_DWORD *)v4 + 176) = 5;
  *(_OWORD *)((char *)v3 + 168) = xmmword_1B66A0D40;
  *(_OWORD *)((char *)v3 + 184) = xmmword_1B66A0D50;
  *(_OWORD *)((char *)v3 + 200) = xmmword_1B66A0D60;
  *((_DWORD *)v4 + 189) = 1151500288;
  *((_QWORD *)v4 + 95) = 0x3F80000044A28000;
  *((_BYTE *)v4 + 768) = 0;
  *(_OWORD *)((char *)v4 + 840) = 0u;
  *((_BYTE *)v4 + 887) = 0;
  *(_OWORD *)((char *)v4 + 772) = 0u;
  *(_OWORD *)((char *)v4 + 788) = 0u;
  *(_OWORD *)((char *)v4 + 804) = 0u;
  *((_DWORD *)v4 + 205) = 0;
  *(_OWORD *)((char *)v4 + 888) = xmmword_1B66A0D70;
  *((_BYTE *)v4 + 904) = 0;
  v5 = (uint64_t)v4 + 912;
  *((_BYTE *)v4 + 936) = 0;
  *((_QWORD *)v4 + 116) = 0;
  *((_OWORD *)v4 + 57) = 0u;
  *((_OWORD *)v4 + 59) = 0u;
  *((_OWORD *)v4 + 60) = 0u;
  *((_OWORD *)v4 + 61) = 0u;
  *((_OWORD *)v4 + 62) = 0u;
  *((_OWORD *)v4 + 63) = 0u;
  *((_OWORD *)v4 + 64) = 0u;
  *(_QWORD *)(a1 + 1040) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_WORD *)(a1 + 1048) = 257;
  *(_BYTE *)(a1 + 1064) = 0;
  *(_BYTE *)(a1 + 1072) = 0;
  *(_BYTE *)(a1 + 1128) = 0;
  *(_OWORD *)(a1 + 1080) = 0u;
  *(_OWORD *)(a1 + 1096) = 0u;
  *(_OWORD *)(a1 + 1112) = 0u;
  *(_DWORD *)(a1 + 1148) = 0;
  *(_OWORD *)(a1 + 1132) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v6 = 0;
  v108 = 0x40CF400000000000;
  v109 = xmmword_1B6626900;
  v110 = xmmword_1B6626910;
  while (1)
  {
    v7 = *(_QWORD *)(a1 + 120);
    if (v7)
      LODWORD(v8) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
    else
      v8 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v6 >= v8)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v6);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v108);
    ++v6;
  }
  for (i = 0; ; ++i)
  {
    v11 = *(_QWORD *)(a1 + 168);
    if (v11)
      LODWORD(v12) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
    else
      v12 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v12)
      break;
    v13 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v13 + 56))(v13, &v108);
  }
  v14 = *(_QWORD *)(a1 + 72);
  if (v14)
    v15 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 32))(v14, 0);
  else
    v15 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v15 + 40))(v15, 30);
  v16 = *(_QWORD *)(a1 + 72);
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  ausdk::AUElement::SetParameter(v17, 0, 0.0, 0);
  v19 = *(_QWORD *)(a1 + 72);
  if (v19)
  {
    v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
  }
  else
  {
    v21 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v21)
      v20 = 0;
    else
      v20 = *v21;
  }
  ausdk::AUElement::SetParameter(v20, 0x15u, 0.0, 0);
  v22 = *(_QWORD *)(a1 + 72);
  if (v22)
  {
    v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
  }
  else
  {
    v24 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v24)
      v23 = 0;
    else
      v23 = *v24;
  }
  ausdk::AUElement::SetParameter(v23, 1u, 0.0, 0);
  v25 = *(_QWORD *)(a1 + 72);
  if (v25)
  {
    v26 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, 0);
  }
  else
  {
    v27 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v27)
      v26 = 0;
    else
      v26 = *v27;
  }
  ausdk::AUElement::SetParameter(v26, 2u, 512.0, 0);
  v28 = *(_QWORD *)(a1 + 72);
  if (v28)
  {
    v29 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 32))(v28, 0);
  }
  else
  {
    v30 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v30)
      v29 = 0;
    else
      v29 = *v30;
  }
  ausdk::AUElement::SetParameter(v29, 3u, 192.0, 0);
  v31 = *(_QWORD *)(a1 + 72);
  if (v31)
  {
    v32 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v31 + 32))(v31, 0);
  }
  else
  {
    v33 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v33)
      v32 = 0;
    else
      v32 = *v33;
  }
  ausdk::AUElement::SetParameter(v32, 4u, 500.0, 0);
  v34 = *(_QWORD *)(a1 + 72);
  if (v34)
  {
    v35 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v34 + 32))(v34, 0);
  }
  else
  {
    v36 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v36)
      v35 = 0;
    else
      v35 = *v36;
  }
  ausdk::AUElement::SetParameter(v35, 5u, 1000.0, 0);
  v37 = *(_QWORD *)(a1 + 72);
  if (v37)
  {
    v38 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v37 + 32))(v37, 0);
  }
  else
  {
    v39 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v39)
      v38 = 0;
    else
      v38 = *v39;
  }
  ausdk::AUElement::SetParameter(v38, 6u, 11.0, 0);
  v40 = *(_QWORD *)(a1 + 72);
  if (v40)
  {
    v41 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v40 + 32))(v40, 0);
  }
  else
  {
    v42 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v42)
      v41 = 0;
    else
      v41 = *v42;
  }
  ausdk::AUElement::SetParameter(v41, 7u, 0.0, 0);
  v43 = *(_QWORD *)(a1 + 72);
  if (v43)
  {
    v44 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v43 + 32))(v43, 0);
  }
  else
  {
    v45 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v45)
      v44 = 0;
    else
      v44 = *v45;
  }
  ausdk::AUElement::SetParameter(v44, 8u, 6.0, 0);
  v46 = *(_QWORD *)(a1 + 72);
  if (v46)
  {
    v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 0);
  }
  else
  {
    v48 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v48)
      v47 = 0;
    else
      v47 = *v48;
  }
  ausdk::AUElement::SetParameter(v47, 9u, -2.0, 0);
  v49 = *(_QWORD *)(a1 + 72);
  if (v49)
  {
    v50 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v49 + 32))(v49, 0);
  }
  else
  {
    v51 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v51)
      v50 = 0;
    else
      v50 = *v51;
  }
  ausdk::AUElement::SetParameter(v50, 0xAu, 9.0, 0);
  v52 = *(_QWORD *)(a1 + 72);
  if (v52)
  {
    v53 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v52 + 32))(v52, 0);
  }
  else
  {
    v54 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v54)
      v53 = 0;
    else
      v53 = *v54;
  }
  ausdk::AUElement::SetParameter(v53, 0xBu, -5.0, 0);
  v55 = *(_QWORD *)(a1 + 72);
  if (v55)
  {
    v56 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v55 + 32))(v55, 0);
  }
  else
  {
    v57 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v57)
      v56 = 0;
    else
      v56 = *v57;
  }
  ausdk::AUElement::SetParameter(v56, 0xCu, -25.0, 0);
  v58 = *(_QWORD *)(a1 + 72);
  if (v58)
  {
    v59 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v58 + 32))(v58, 0);
  }
  else
  {
    v60 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v60)
      v59 = 0;
    else
      v59 = *v60;
  }
  ausdk::AUElement::SetParameter(v59, 0xDu, 0.01, 0);
  v61 = *(_QWORD *)(a1 + 72);
  if (v61)
  {
    v62 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v61 + 32))(v61, 0);
  }
  else
  {
    v63 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v63)
      v62 = 0;
    else
      v62 = *v63;
  }
  ausdk::AUElement::SetParameter(v62, 0xEu, 0.01, 0);
  v64 = *(_QWORD *)(a1 + 72);
  if (v64)
  {
    v65 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v64 + 32))(v64, 0);
  }
  else
  {
    v66 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v66)
      v65 = 0;
    else
      v65 = *v66;
  }
  ausdk::AUElement::SetParameter(v65, 0xFu, 1.1, 0);
  v67 = *(_QWORD *)(a1 + 72);
  if (v67)
  {
    v68 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v67 + 32))(v67, 0);
  }
  else
  {
    v69 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v69)
      v68 = 0;
    else
      v68 = *v69;
  }
  ausdk::AUElement::SetParameter(v68, 0x10u, 1300.0, 0);
  v70 = *(_QWORD *)(a1 + 72);
  if (v70)
  {
    v71 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v70 + 32))(v70, 0);
  }
  else
  {
    v72 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v72)
      v71 = 0;
    else
      v71 = *v72;
  }
  ausdk::AUElement::SetParameter(v71, 0x11u, 1300.0, 0);
  v73 = *(_QWORD *)(a1 + 72);
  if (v73)
  {
    v74 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v73 + 32))(v73, 0);
  }
  else
  {
    v75 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v75)
      v74 = 0;
    else
      v74 = *v75;
  }
  ausdk::AUElement::SetParameter(v74, 0x16u, 0.0, 0);
  v76 = *(_QWORD *)(a1 + 72);
  if (v76)
  {
    v77 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v76 + 32))(v76, 0);
  }
  else
  {
    v78 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v78)
      v77 = 0;
    else
      v77 = *v78;
  }
  ausdk::AUElement::SetParameter(v77, 0x17u, 70.0, 0);
  v79 = *(_QWORD *)(a1 + 72);
  if (v79)
  {
    v80 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v79 + 32))(v79, 0);
  }
  else
  {
    v81 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v81)
      v80 = 0;
    else
      v80 = *v81;
  }
  ausdk::AUElement::SetParameter(v80, 0x12u, 90.0, 0);
  v82 = *(_QWORD *)(a1 + 72);
  if (v82)
  {
    v83 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v82 + 32))(v82, 0);
  }
  else
  {
    v84 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v84)
      v83 = 0;
    else
      v83 = *v84;
  }
  ausdk::AUElement::SetParameter(v83, 0x13u, 5.0, 0);
  v85 = *(_QWORD *)(a1 + 72);
  if (v85)
  {
    v86 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v85 + 32))(v85, 0);
  }
  else
  {
    v87 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v87)
      v86 = 0;
    else
      v86 = *v87;
  }
  ausdk::AUElement::SetParameter(v86, 0x14u, 0.01, 0);
  v88 = *(_QWORD *)(a1 + 72);
  if (v88)
  {
    v89 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v88 + 32))(v88, 0);
  }
  else
  {
    v90 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v90)
      v89 = 0;
    else
      v89 = *v90;
  }
  ausdk::AUElement::SetParameter(v89, 0x18u, 0.0, 0);
  v91 = *(_QWORD *)(a1 + 72);
  if (v91)
  {
    v92 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v91 + 32))(v91, 0);
  }
  else
  {
    v93 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v93)
      v92 = 0;
    else
      v92 = *v93;
  }
  ausdk::AUElement::SetParameter(v92, 0x19u, 0.0, 0);
  v94 = *(_QWORD *)(a1 + 72);
  if (v94)
  {
    v95 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v94 + 32))(v94, 0);
  }
  else
  {
    v96 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v96)
      v95 = 0;
    else
      v95 = *v96;
  }
  ausdk::AUElement::SetParameter(v95, 0x1Au, 0.0, 0);
  v97 = *(_QWORD *)(a1 + 72);
  if (v97)
  {
    v98 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v97 + 32))(v97, 0);
  }
  else
  {
    v99 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v99)
      v98 = 0;
    else
      v98 = *v99;
  }
  ausdk::AUElement::SetParameter(v98, 0x1Bu, 2.0, 0);
  v100 = *(_QWORD *)(a1 + 72);
  if (v100)
  {
    v101 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v100 + 32))(v100, 0);
  }
  else
  {
    v102 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v102)
      v101 = 0;
    else
      v101 = *v102;
  }
  ausdk::AUElement::SetParameter(v101, 0x1Cu, 1.0, 0);
  v103 = *(_QWORD *)(a1 + 72);
  if (v103)
  {
    v104 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v103 + 32))(v103, 0);
  }
  else
  {
    v105 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v105)
      v104 = 0;
    else
      v104 = *v105;
  }
  ausdk::AUElement::SetParameter(v104, 0x1Du, 0.0, 0);
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 192);
  *(_BYTE *)(a1 + 856) = 0;
  *(_DWORD *)(a1 + 540) = *(_DWORD *)(a1 + 336);
  *(_DWORD *)(a1 + 544) = 16000;
  *(_QWORD *)(a1 + 857) = 0x101010101010101;
  *(_QWORD *)(a1 + 865) = 0x101010101010101;
  *(_QWORD *)(a1 + 873) = 0x101010101010101;
  *(_QWORD *)(a1 + 879) = 0x101010101010101;
  *(_WORD *)(a1 + 536) = 0;
  *(_BYTE *)(a1 + 538) = 0;
  *(_OWORD *)(a1 + 808) = 0u;
  *(_OWORD *)(a1 + 824) = 0u;
  *(_DWORD *)(a1 + 908) = 1;
  DspLib::Biquad::Filter::uninitialize((DspLib::Biquad::Filter *)(a1 + 936));
  v106 = *(_QWORD *)(a1 + 1008);
  *(_QWORD *)(a1 + 1008) = 0;
  if (v106)
    std::default_delete<BiquadInterpolator>::operator()[abi:ne180100](v106);
  *(_BYTE *)(a1 + 887) = 0;
  std::vector<DspLib::Biquad::Section>::resize(v5, 1uLL);
  return a1;
}

void sub_1B61CE1D8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  void **v3;
  uint64_t **v4;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t *v11;

  v6 = (void *)v1[127];
  if (v6)
  {
    v1[128] = v6;
    operator delete(v6);
  }
  v7 = v1[126];
  v1[126] = 0;
  if (v7)
    std::default_delete<BiquadInterpolator>::operator()[abi:ne180100](v7);
  DspLib::Biquad::SetupWrapper::destroyvDSPSetup((DspLib::Biquad::SetupWrapper *)(v1 + 123));
  v8 = (void *)v1[120];
  if (v8)
  {
    v1[121] = v8;
    operator delete(v8);
  }
  v9 = *v3;
  if (*v3)
  {
    v1[115] = v9;
    operator delete(v9);
  }
  std::shared_ptr<vp::services::Telephony_Utility>::~shared_ptr[abi:ne180100](v2);
  v10 = (void *)v1[98];
  if (v10)
  {
    v1[99] = v10;
    operator delete(v10);
  }
  v11 = *v4;
  *v4 = 0;
  if (v11)
    std::default_delete<AUTweakaLeakIR::AURealTimeDebugLog<AUTweakaLeakIR::TaLIRInternals,256ul>>::operator()[abi:ne180100](v11);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUTweakaLeakIR>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDCBlocker>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  void **v4;
  uint64_t v5;
  ausdk::AUElement *v6;
  ausdk::AUElement **v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  uint64_t Element;
  uint64_t v15;
  uint64_t v17;
  __int128 v18;
  __int128 v19;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69CDBE0;
  v4 = (void **)((char *)v3 + 544);
  *((_OWORD *)v3 + 33) = xmmword_1B66A0D80;
  *((_OWORD *)v3 + 34) = 0u;
  *((_OWORD *)v3 + 35) = 0u;
  *((_QWORD *)v3 + 72) = 0;
  *((_QWORD *)v3 + 73) = 1065353216;
  *((_QWORD *)v3 + 74) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  std::vector<BiquadCoefficients>::resize(v4, 1uLL);
  v5 = a1[9];
  if (v5)
  {
    v6 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
  }
  else
  {
    v7 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v7)
      v6 = 0;
    else
      v6 = *v7;
  }
  ausdk::AUElement::SetParameter(v6, 0, 30.0, 0);
  v8 = a1[9];
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  ausdk::AUElement::SetParameter(v9, 1u, 35.0, 0);
  v11 = a1[9];
  if (v11)
  {
    v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
  }
  else
  {
    v13 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v13)
      v12 = 0;
    else
      v12 = *v13;
  }
  ausdk::AUElement::SetParameter(v12, 2u, 0.0, 0);
  v17 = 0x40E5888000000000;
  v18 = xmmword_1B6626900;
  v19 = xmmword_1B66A0830;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v17);
  v15 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v15 + 56))(v15, &v17);
  return a1;
}

void sub_1B61CE46C(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  void **v2;
  void *v4;
  uint64_t v5;
  void *v6;

  v4 = (void *)*((_QWORD *)v1 + 74);
  if (v4)
  {
    free(v4);
    *((_QWORD *)v1 + 74) = 0;
  }
  CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set((_QWORD *)v1 + 72, 0);
  v5 = *((_QWORD *)v1 + 71);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    *((_QWORD *)v1 + 71) = 0;
  }
  v6 = *v2;
  if (*v2)
  {
    *((_QWORD *)v1 + 69) = v6;
    operator delete(v6);
  }
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDCBlocker>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUEarPlug>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  uint64_t i;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  char *v11;
  void *v12;
  void *v13;
  uint64_t Element;
  uint64_t v15;
  uint64_t v17;
  __int128 v18;
  __int128 v19;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69D23D8;
  *((_QWORD *)v3 + 66) = 0;
  *((_BYTE *)v3 + 536) = 0;
  *((_OWORD *)v3 + 36) = 0u;
  *((_OWORD *)v3 + 37) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v4 = a1[9];
  if (v4)
  {
    v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  }
  else
  {
    v6 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v6)
      v5 = 0;
    else
      v5 = *v6;
  }
  ausdk::AUElement::SetParameter(v5, 0, 5.0, 0);
  for (i = 0; i != 4; ++i)
  {
    v8 = a1[9];
    if (v8)
    {
      v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
    }
    else
    {
      v10 = (ausdk::AUElement **)a1[6];
      if ((ausdk::AUElement **)a1[7] == v10)
        v9 = 0;
      else
        v9 = *v10;
    }
    ausdk::AUElement::SetParameter(v9, i + 1, 0.0, 0);
    v11 = (char *)a1 + 4 * i;
    *((_DWORD *)v11 + 135) = 0;
    *((_DWORD *)v11 + 139) = 1065353216;
  }
  v12 = (void *)a1[74];
  if (v12)
  {
    free(v12);
    a1[74] = 0;
  }
  v13 = (void *)a1[75];
  if (v13)
  {
    free(v13);
    a1[75] = 0;
  }
  v17 = 0x40E5888000000000;
  v18 = xmmword_1B6626900;
  v19 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v17);
  v15 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v15 + 56))(v15, &v17);
  return a1;
}

void sub_1B61CE658(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  void *v3;
  void *v4;

  v3 = (void *)*((_QWORD *)v1 + 75);
  if (v3)
  {
    free(v3);
    *((_QWORD *)v1 + 75) = 0;
  }
  v4 = (void *)*((_QWORD *)v1 + 74);
  if (v4)
  {
    free(v4);
    *((_QWORD *)v1 + 74) = 0;
  }
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUEarPlug>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AURotationShading>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  void **v4;
  uint64_t v5;
  ausdk::AUElement *v6;
  ausdk::AUElement **v7;
  uint64_t v8;
  ausdk::AUElement *v9;
  ausdk::AUElement **v10;
  uint64_t v11;
  ausdk::AUElement *v12;
  ausdk::AUElement **v13;
  uint64_t v14;
  ausdk::AUElement *v15;
  ausdk::AUElement **v16;
  uint64_t Element;
  uint64_t v18;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69CDEB0;
  *((_DWORD *)v3 + 132) = 1;
  v4 = (void **)((char *)v3 + 544);
  *(_OWORD *)((char *)v3 + 532) = 0u;
  *(_OWORD *)((char *)v3 + 548) = 0u;
  *(_OWORD *)((char *)v3 + 564) = 0u;
  *(_OWORD *)((char *)v3 + 580) = 0u;
  *(_QWORD *)((char *)v3 + 596) = 1;
  *((_WORD *)v3 + 302) = 1;
  *((_BYTE *)v3 + 606) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  std::vector<BiquadCoefficients>::resize(v4, 2uLL);
  v5 = *(_QWORD *)(a1 + 72);
  if (v5)
  {
    v6 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
  }
  else
  {
    v7 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v7)
      v6 = 0;
    else
      v6 = *v7;
  }
  ausdk::AUElement::SetParameter(v6, 0, 1.0, 0);
  v8 = *(_QWORD *)(a1 + 72);
  if (v8)
  {
    v9 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  }
  else
  {
    v10 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v10)
      v9 = 0;
    else
      v9 = *v10;
  }
  ausdk::AUElement::SetParameter(v9, 1u, 1.0, 0);
  v11 = *(_QWORD *)(a1 + 72);
  if (v11)
  {
    v12 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 0);
  }
  else
  {
    v13 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v13)
      v12 = 0;
    else
      v12 = *v13;
  }
  ausdk::AUElement::SetParameter(v12, 2u, 4000.0, 0);
  v14 = *(_QWORD *)(a1 + 72);
  if (v14)
  {
    v15 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 32))(v14, 0);
  }
  else
  {
    v16 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v16)
      v15 = 0;
    else
      v15 = *v16;
  }
  ausdk::AUElement::SetParameter(v15, 3u, 4000.0, 0);
  v23 = 0x40E5888000000000;
  v24 = xmmword_1B6626900;
  v25 = xmmword_1B66A0830;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v23);
  v20 = 0x40E5888000000000;
  v21 = xmmword_1B6626900;
  v22 = xmmword_1B66A0820;
  v18 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v18 + 56))(v18, &v20);
  *(_QWORD *)(a1 + 640) = 0;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  return a1;
}

void sub_1B61CE8C4(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = (void *)*((_QWORD *)v1 + 71);
  if (v4)
  {
    *((_QWORD *)v1 + 72) = v4;
    operator delete(v4);
  }
  v5 = *v2;
  if (*v2)
  {
    *((_QWORD *)v1 + 69) = v5;
    operator delete(v5);
  }
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AURotationShading>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

ausdk::AUBase *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReferenceSignalMixer>::Construct(ausdk::AUBase *a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  NSObject *v7;
  int v9;
  ausdk::AUBase *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase(a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69C8A40;
  *((_BYTE *)v3 + 528) = 0;
  *((_DWORD *)v3 + 133) = 2;
  *((_BYTE *)v3 + 536) = 0;
  *((_BYTE *)v3 + 560) = 0;
  *((_DWORD *)v3 + 142) = 2;
  *((_BYTE *)v3 + 576) = 0;
  *((_BYTE *)v3 + 600) = 0;
  *((_QWORD *)v3 + 76) = 1;
  *((_QWORD *)v3 + 77) = &off_1E69C8CC8;
  *((_OWORD *)v3 + 39) = 0u;
  *((_OWORD *)v3 + 40) = 0u;
  *((_DWORD *)v3 + 164) = 1065353216;
  *(_OWORD *)((char *)v3 + 664) = 0u;
  v4 = *((_QWORD *)v3 + 9);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  else
    v5 = **((_QWORD **)a1 + 6);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, 1);
  AUReferenceSignalMixer::SetParameter((uint64_t)a1, 1.0);
  {
    AU::ReferenceSignalMixer::getLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AUReferenceSignalMixer");
  }
  v7 = AU::ReferenceSignalMixer::getLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)AU::ReferenceSignalMixer::getLog(void)::gLog, OS_LOG_TYPE_INFO))
  {
    v9 = 134217984;
    v10 = a1;
    _os_log_impl(&dword_1B5ED0000, v7, OS_LOG_TYPE_INFO, "[%p] created", (uint8_t *)&v9, 0xCu);
  }
  return a1;
}

void sub_1B61CEAA8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  const void *v4;
  void *v5;
  void *v6;

  v4 = *(const void **)(v1 + 672);
  if (v4)
    CFRelease(v4);
  std::__hash_table<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::__unordered_map_hasher<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::hash<AU::ReferenceSignalMixer::Orientation>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,true>,std::__unordered_map_equal<AU::ReferenceSignalMixer::Orientation,std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>,std::equal_to<AU::ReferenceSignalMixer::Orientation>,std::hash<AU::ReferenceSignalMixer::Orientation>,true>,std::allocator<std::__hash_value_type<AU::ReferenceSignalMixer::Orientation,std::shared_ptr<AUReferenceSignalMixer::MatrixKernel>>>>::~__hash_table(v2);
  if (*(_BYTE *)(v1 + 600))
  {
    v5 = *(void **)(v1 + 576);
    if (v5)
    {
      *(_QWORD *)(v1 + 584) = v5;
      operator delete(v5);
    }
  }
  if (*(_BYTE *)(v1 + 560))
  {
    v6 = *(void **)(v1 + 536);
    if (v6)
    {
      *(_QWORD *)(v1 + 544) = v6;
      operator delete(v6);
    }
  }
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v1);
  _Unwind_Resume(a1);
}

void sub_1B61CEB00(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x1B61CEAF8);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReferenceSignalMixer>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMNBandEQ>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  void **v4;
  unint64_t i;
  uint64_t v6;
  ausdk::AUElement *v7;
  uint64_t v8;
  unsigned int j;
  double v10;
  double v11;
  double v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  ausdk::AUElement *v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  uint64_t v23;
  float v24;
  unsigned int v25;
  uint64_t v26;
  ausdk::AUElement *v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t Element;
  uint64_t v35;
  uint64_t v37;
  __int128 v38;
  __int128 v39;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69DFF48;
  *(_OWORD *)((char *)v3 + 600) = 0u;
  *(_OWORD *)((char *)v3 + 616) = 0u;
  *((_DWORD *)v3 + 132) = 1;
  v4 = (void **)((char *)v3 + 536);
  *((_OWORD *)v3 + 40) = 0u;
  *((_OWORD *)v3 + 41) = 0u;
  *((_OWORD *)v3 + 42) = 0u;
  *((_OWORD *)v3 + 43) = 0u;
  *((_OWORD *)v3 + 44) = 0u;
  *((_OWORD *)v3 + 45) = 0u;
  *((_OWORD *)v3 + 46) = 0u;
  *((_OWORD *)v3 + 47) = 0u;
  *((_QWORD *)v3 + 96) = 0;
  *(_OWORD *)((char *)v3 + 532) = 0u;
  *(_OWORD *)((char *)v3 + 548) = 0u;
  *(_OWORD *)((char *)v3 + 564) = 0u;
  *(_OWORD *)((char *)v3 + 580) = 0u;
  *((_DWORD *)v3 + 158) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  std::vector<BiquadCoefficients>::resize(v4, 0x80uLL);
  for (i = 0; i != 8; ++i)
  {
    v6 = a1[78];
    if (v6)
    {
      v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v6 + 32))(v6, i);
    }
    else
    {
      v8 = a1[75];
      if (i >= (a1[76] - v8) >> 3)
        v7 = 0;
      else
        v7 = *(ausdk::AUElement **)(v8 + 8 * i);
    }
    ausdk::AUElement::SetParameter(v7, 0, 0.0, 0);
    for (j = 0; j != 16; j = v33 - 4999)
    {
      v10 = *(double *)(ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), 0) + 80) * 0.5;
      if (v10 >= 10000.0)
        v11 = 250.0;
      else
        v11 = v10 / 40.0;
      v12 = pow(v11, (double)j / 15.0);
      v13 = a1[78];
      if (v13)
      {
        v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v13 + 32))(v13, i);
      }
      else
      {
        v15 = a1[75];
        if (i >= (a1[76] - v15) >> 3)
          v14 = 0;
        else
          v14 = *(ausdk::AUElement **)(v15 + 8 * i);
      }
      v16 = j + 1000;
      ausdk::AUElement::SetParameter(v14, v16, 1.0, 0);
      v17 = a1[78];
      if (v17)
      {
        v18 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v17 + 32))(v17, i);
      }
      else
      {
        v19 = a1[75];
        if (i >= (a1[76] - v19) >> 3)
          v18 = 0;
        else
          v18 = *(ausdk::AUElement **)(v19 + 8 * i);
      }
      v20 = v16 + 1000;
      ausdk::AUElement::SetParameter(v18, v20, 0.0, 0);
      v21 = a1[78];
      if (v21)
      {
        v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v21 + 32))(v21, i);
      }
      else
      {
        v23 = a1[75];
        if (i >= (a1[76] - v23) >> 3)
          v22 = 0;
        else
          v22 = *(ausdk::AUElement **)(v23 + 8 * i);
      }
      v24 = v12 * 40.0;
      v25 = v20 + 1000;
      ausdk::AUElement::SetParameter(v22, v25, v24, 0);
      v26 = a1[78];
      if (v26)
      {
        v27 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v26 + 32))(v26, i);
      }
      else
      {
        v28 = a1[75];
        if (i >= (a1[76] - v28) >> 3)
          v27 = 0;
        else
          v27 = *(ausdk::AUElement **)(v28 + 8 * i);
      }
      v29 = v25 + 1000;
      ausdk::AUElement::SetParameter(v27, v29, 0.0, 0);
      v30 = a1[78];
      if (v30)
      {
        v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v30 + 32))(v30, i);
      }
      else
      {
        v32 = a1[75];
        if (i >= (a1[76] - v32) >> 3)
          v31 = 0;
        else
          v31 = *(ausdk::AUElement **)(v32 + 8 * i);
      }
      v33 = v29 + 1000;
      ausdk::AUElement::SetParameter(v31, v33, 0.5, 0);
    }
  }
  v37 = 0x40E5888000000000;
  v38 = xmmword_1B6626900;
  v39 = xmmword_1B66A0D90;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v37);
  v35 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v35 + 56))(v35, &v37);
  return a1;
}

void sub_1B61CEE88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void **v2;
  void **v3;
  void **v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a2);
  v5 = v2 + 80;
  v6 = v2[83];
  if (v6)
  {
    v2[84] = v6;
    operator delete(v6);
  }
  v7 = *v5;
  if (*v5)
  {
    v2[81] = v7;
    operator delete(v7);
  }
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  v8 = v2[70];
  if (v8)
  {
    v2[71] = v8;
    operator delete(v8);
  }
  v9 = *v3;
  if (*v3)
  {
    v2[68] = v9;
    operator delete(v9);
  }
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v2);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUMNBandEQ>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVariableEQV2>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  _OWORD *v3;
  ausdk::AUBase *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  uint64_t v12;
  ausdk::AUElement *v13;
  ausdk::AUElement **v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  unint64_t i;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  ausdk::AUElement *v34;
  uint64_t v35;
  unsigned int j;
  uint64_t v37;
  ausdk::AUElement *v38;
  uint64_t v39;
  uint64_t v40;
  ausdk::AUElement *v41;
  uint64_t v42;
  uint64_t v43;
  ausdk::AUElement *v44;
  uint64_t v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  uint64_t v48;
  uint64_t v49;
  ausdk::AUElement *v50;
  uint64_t v51;
  uint64_t Element;
  uint64_t v53;
  uint64_t v55;
  __int128 v56;
  __int128 v57;

  v3 = a1 + 67;
  v4 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v4 = &off_1E69DD280;
  *((_BYTE *)v4 + 528) = 0;
  *v3 = xmmword_1B6627BC0;
  *((_DWORD *)v4 + 138) = 0;
  *(_OWORD *)((char *)v3 + 20) = xmmword_1B6627E00;
  *((_WORD *)v4 + 286) = 256;
  *(_OWORD *)((char *)v4 + 574) = 0u;
  *((_WORD *)v4 + 295) = 0;
  *((_QWORD *)v4 + 76) = 0;
  *((_QWORD *)v4 + 78) = 0;
  *((_QWORD *)v4 + 77) = 0;
  *((_DWORD *)v4 + 158) = 0;
  *((_OWORD *)v4 + 40) = 0u;
  *((_OWORD *)v4 + 41) = 0u;
  v5 = 85;
  *((_BYTE *)v4 + 672) = 0;
  do
  {
    v6 = &a1[v5];
    *v6 = 0;
    v6[1] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v6[2] = 0x3FF0000000000000;
    v5 += 5;
  }
  while (v6 + 5 != (_QWORD *)((char *)v4 + 1000));
  v7 = 125;
  do
  {
    v8 = &a1[v7];
    *v8 = 0;
    v8[1] = 0;
    v8[3] = 0;
    v8[4] = 0;
    v8[2] = 0x3FF0000000000000;
    v7 += 5;
  }
  while (v8 + 5 != a1 + 165);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v9 = a1[9];
  if (v9)
  {
    v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
  }
  else
  {
    v11 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v11)
      v10 = 0;
    else
      v10 = *v11;
  }
  ausdk::AUElement::SetParameter(v10, 1u, 0.2, 0);
  v12 = a1[9];
  if (v12)
  {
    v13 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, 0);
  }
  else
  {
    v14 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v14)
      v13 = 0;
    else
      v13 = *v14;
  }
  ausdk::AUElement::SetParameter(v13, 2u, 0.5, 0);
  v15 = a1[9];
  if (v15)
  {
    v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
  }
  else
  {
    v17 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v17)
      v16 = 0;
    else
      v16 = *v17;
  }
  ausdk::AUElement::SetParameter(v16, 3u, 0.8, 0);
  v18 = a1[9];
  if (v18)
  {
    v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
  }
  else
  {
    v20 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v20)
      v19 = 0;
    else
      v19 = *v20;
  }
  ausdk::AUElement::SetParameter(v19, 4u, 0.9, 0);
  v21 = a1[9];
  if (v21)
  {
    v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
  }
  else
  {
    v23 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v23)
      v22 = 0;
    else
      v22 = *v23;
  }
  ausdk::AUElement::SetParameter(v22, 5u, 1.0, 0);
  v24 = a1[9];
  if (v24)
  {
    v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
  }
  else
  {
    v26 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v26)
      v25 = 0;
    else
      v25 = *v26;
  }
  ausdk::AUElement::SetParameter(v25, 7u, 0.0, 0);
  v27 = a1[9];
  if (v27)
  {
    v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
  }
  else
  {
    v29 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v29)
      v28 = 0;
    else
      v28 = *v29;
  }
  ausdk::AUElement::SetParameter(v28, 6u, 40.0, 0);
  for (i = 0; ; ++i)
  {
    v31 = a1[83];
    if (v31)
      LODWORD(v32) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v31 + 24))(v31);
    else
      v32 = (a1[81] - a1[80]) >> 3;
    if (i >= v32)
      break;
    v33 = a1[83];
    if (v33)
    {
      v34 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v33 + 32))(v33, i);
    }
    else
    {
      v35 = a1[80];
      if (i >= (a1[81] - v35) >> 3)
        v34 = 0;
      else
        v34 = *(ausdk::AUElement **)(v35 + 8 * i);
    }
    ausdk::AUElement::SetParameter(v34, 0, 0.0, 0);
    for (j = 3000; j != 3008; ++j)
    {
      v37 = a1[83];
      if (v37)
      {
        v38 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v37 + 32))(v37, i);
      }
      else
      {
        v39 = a1[80];
        if (i >= (a1[81] - v39) >> 3)
          v38 = 0;
        else
          v38 = *(ausdk::AUElement **)(v39 + 8 * i);
      }
      ausdk::AUElement::SetParameter(v38, j - 1000, 0.0, 0);
      v40 = a1[83];
      if (v40)
      {
        v41 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v40 + 32))(v40, i);
      }
      else
      {
        v42 = a1[80];
        if (i >= (a1[81] - v42) >> 3)
          v41 = 0;
        else
          v41 = *(ausdk::AUElement **)(v42 + 8 * i);
      }
      ausdk::AUElement::SetParameter(v41, j, 1000.0, 0);
      v43 = a1[83];
      if (v43)
      {
        v44 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v43 + 32))(v43, i);
      }
      else
      {
        v45 = a1[80];
        if (i >= (a1[81] - v45) >> 3)
          v44 = 0;
        else
          v44 = *(ausdk::AUElement **)(v45 + 8 * i);
      }
      ausdk::AUElement::SetParameter(v44, j + 1000, 0.0, 0);
      v46 = a1[83];
      if (v46)
      {
        v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v46 + 32))(v46, i);
      }
      else
      {
        v48 = a1[80];
        if (i >= (a1[81] - v48) >> 3)
          v47 = 0;
        else
          v47 = *(ausdk::AUElement **)(v48 + 8 * i);
      }
      ausdk::AUElement::SetParameter(v47, j + 2000, 0.5, 0);
      v49 = a1[83];
      if (v49)
      {
        v50 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v49 + 32))(v49, i);
      }
      else
      {
        v51 = a1[80];
        if (i >= (a1[81] - v51) >> 3)
          v50 = 0;
        else
          v50 = *(ausdk::AUElement **)(v51 + 8 * i);
      }
      ausdk::AUElement::SetParameter(v50, j - 2000, 1.0, 0);
    }
  }
  v55 = 0x40BF400000000000;
  v56 = xmmword_1B6626900;
  v57 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v55);
  v53 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v53 + 56))(v53, &v55);
  return a1;
}

void sub_1B61CF46C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  ausdk::AUBase *v9;
  _QWORD *v10;
  uint64_t v12;
  uint64_t v13;

  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a9);
  CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set((_QWORD *)v9 + 77, 0);
  CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set(v10, 0);
  v12 = *((_QWORD *)v9 + 73);
  if (v12)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
    *((_QWORD *)v9 + 73) = 0;
  }
  v13 = *((_QWORD *)v9 + 72);
  if (v13)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
    *((_QWORD *)v9 + 72) = 0;
  }
  ausdk::AUBase::~AUBase(v9);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVariableEQV2>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUAnomalyDetection>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t Element;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 3, 1);
  *(_QWORD *)v3 = &off_1E69CB380;
  *((_BYTE *)v3 + 528) = 0;
  *(_OWORD *)((char *)v3 + 532) = xmmword_1B66A0DA0;
  *(_QWORD *)((char *)v3 + 548) = 0x4040000000000001;
  *(_QWORD *)((char *)v3 + 556) = 0x3F80000000000000;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v23 = 0x40D7700000000000;
  v24 = xmmword_1B6626900;
  v25 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v23);
  v5 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 1u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v5 + 56))(v5, &v23);
  v20 = 0x40D7700000000000;
  v21 = xmmword_1B6626900;
  v22 = xmmword_1B6626910;
  v6 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 2u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 56))(v6, &v20);
  v7 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v7 + 56))(v7, &v20);
  v8 = *(_QWORD *)(a1 + 72);
  if (v8)
    v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 0);
  else
    v9 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 40))(v9, 3);
  v10 = *(_QWORD *)(a1 + 72);
  if (v10)
  {
    v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
  }
  else
  {
    v12 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v12)
      v11 = 0;
    else
      v11 = *v12;
  }
  ausdk::AUElement::SetParameter(v11, 0, 3.0, 0);
  v13 = *(_QWORD *)(a1 + 72);
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  }
  else
  {
    v15 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v15)
      v14 = 0;
    else
      v14 = *v15;
  }
  ausdk::AUElement::SetParameter(v14, 1u, 0.0, 0);
  v16 = *(_QWORD *)(a1 + 72);
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  ausdk::AUElement::SetParameter(v17, 2u, 1.0, 0);
  return a1;
}

void sub_1B61CF718(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;

  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUAnomalyDetection>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDynamicDuckerV2>::Construct(_QWORD *a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  unsigned int v12;
  uint64_t Element;
  uint64_t v14;
  uint64_t v15;
  _OWORD v17[2];
  uint64_t v18;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 5, 2);
  *(_QWORD *)v3 = &off_1E69D4CB0;
  *((_WORD *)v3 + 264) = 256;
  *((_BYTE *)v3 + 530) = 0;
  *((_DWORD *)v3 + 133) = 0;
  *((_QWORD *)v3 + 67) = 0x100000001;
  *((_BYTE *)v3 + 544) = 0;
  *((_BYTE *)v3 + 648) = 0;
  *((_BYTE *)v3 + 656) = 0;
  *((_BYTE *)v3 + 760) = 0;
  *((_BYTE *)v3 + 768) = 0;
  *((_BYTE *)v3 + 872) = 0;
  *((_BYTE *)v3 + 880) = 0;
  *((_BYTE *)v3 + 984) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *((_OWORD *)v3 + 62) = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)v3 + 126) = _Q0;
  *(_OWORD *)((char *)v3 + 1016) = 0u;
  *((_DWORD *)v3 + 258) = 0;
  *(_OWORD *)((char *)v3 + 1036) = xmmword_1B66A0DB0;
  *((_DWORD *)v3 + 263) = 1048576000;
  *((_QWORD *)v3 + 132) = 0x3DCCCCCD00000000;
  *((_QWORD *)v3 + 135) = 0;
  *((_QWORD *)v3 + 133) = 0;
  *(_QWORD *)((char *)v3 + 1069) = 0;
  *((_DWORD *)v3 + 272) = -1018691584;
  *((_QWORD *)v3 + 139) = 0;
  *((_BYTE *)v3 + 1120) = 0;
  *((_BYTE *)v3 + 1144) = 0;
  *((_QWORD *)v3 + 144) = 0;
  *((_BYTE *)v3 + 1160) = 0;
  *((_BYTE *)v3 + 1184) = 0;
  *((_QWORD *)v3 + 149) = 0;
  *((_BYTE *)v3 + 1200) = 0;
  *((_BYTE *)v3 + 1224) = 0;
  *((_QWORD *)v3 + 154) = 0;
  *((_BYTE *)v3 + 1240) = 0;
  *((_BYTE *)v3 + 1264) = 0;
  *((_QWORD *)v3 + 159) = 0;
  *((_BYTE *)v3 + 1280) = 0;
  *((_BYTE *)v3 + 1304) = 0;
  *((_BYTE *)v3 + 1312) = 0;
  *((_BYTE *)v3 + 1320) = 0;
  *((_BYTE *)v3 + 1328) = 0;
  *((_BYTE *)v3 + 1352) = 0;
  *((_BYTE *)v3 + 1360) = 0;
  *((_BYTE *)v3 + 1384) = 0;
  *((_BYTE *)v3 + 1108) = 0;
  *(_OWORD *)((char *)v3 + 1092) = 0u;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v9 = a1[9];
  if (v9)
  {
    v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
  }
  else
  {
    v11 = (ausdk::AUElement **)a1[6];
    if ((ausdk::AUElement **)a1[7] == v11)
      v10 = 0;
    else
      v10 = *v11;
  }
  (*(void (**)(ausdk::AUElement *, uint64_t))(*(_QWORD *)v10 + 40))(v10, 26);
  ausdk::AUElement::SetParameter(v10, 0, -18.0, 0);
  ausdk::AUElement::SetParameter(v10, 1u, -18.0, 0);
  ausdk::AUElement::SetParameter(v10, 2u, -18.0, 0);
  ausdk::AUElement::SetParameter(v10, 3u, -40.0, 0);
  ausdk::AUElement::SetParameter(v10, 4u, -40.0, 0);
  ausdk::AUElement::SetParameter(v10, 5u, -40.0, 0);
  ausdk::AUElement::SetParameter(v10, 6u, -45.0, 0);
  ausdk::AUElement::SetParameter(v10, 7u, -50.0, 0);
  ausdk::AUElement::SetParameter(v10, 8u, -18.0, 0);
  ausdk::AUElement::SetParameter(v10, 9u, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0xAu, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0xBu, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0xCu, -96.0, 0);
  ausdk::AUElement::SetParameter(v10, 0xDu, 0.25, 0);
  ausdk::AUElement::SetParameter(v10, 0xEu, 0.1, 0);
  ausdk::AUElement::SetParameter(v10, 0xFu, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0x10u, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0x13u, 0.5, 0);
  ausdk::AUElement::SetParameter(v10, 0x12u, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0x11u, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0x14u, -200.0, 0);
  ausdk::AUElement::SetParameter(v10, 0x15u, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0x16u, -200.0, 0);
  ausdk::AUElement::SetParameter(v10, 0x17u, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0x18u, 0.0, 0);
  ausdk::AUElement::SetParameter(v10, 0x19u, 0.0, 0);
  v12 = 0;
  v17[0] = xmmword_1B665D718;
  v17[1] = unk_1B665D728;
  v18 = 32;
  do
  {
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 10), v12);
    (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)Element + 56))(Element, v17);
    ++v12;
  }
  while (v12 != 5);
  v14 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), 0);
  (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v14 + 56))(v14, v17);
  v15 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 16), 1u);
  (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v15 + 56))(v15, v17);
  return a1;
}

void sub_1B61CFB90(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  if (*(_BYTE *)(v1 + 1384))
  {
    v3 = *(void **)(v1 + 1360);
    if (v3)
    {
      *(_QWORD *)(v1 + 1368) = v3;
      operator delete(v3);
    }
  }
  if (*(_BYTE *)(v1 + 1352))
  {
    v4 = *(void **)(v1 + 1328);
    if (v4)
    {
      *(_QWORD *)(v1 + 1336) = v4;
      operator delete(v4);
    }
  }
  std::__optional_destruct_base<CA::AudioBuffers,false>::~__optional_destruct_base[abi:ne180100](v1 + 1312);
  if (*(_BYTE *)(v1 + 1304))
  {
    v5 = *(void **)(v1 + 1280);
    if (v5)
    {
      *(_QWORD *)(v1 + 1288) = v5;
      operator delete(v5);
    }
  }
  std::unique_ptr<OpaqueAudioConverter,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioConverter*,&(AudioConverterDispose)>>::reset[abi:ne180100]((OpaqueAudioConverter **)(v1 + 1272), 0);
  if (*(_BYTE *)(v1 + 1264))
  {
    v6 = *(void **)(v1 + 1240);
    if (v6)
    {
      *(_QWORD *)(v1 + 1248) = v6;
      operator delete(v6);
    }
  }
  std::unique_ptr<OpaqueAudioConverter,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioConverter*,&(AudioConverterDispose)>>::reset[abi:ne180100]((OpaqueAudioConverter **)(v1 + 1232), 0);
  if (*(_BYTE *)(v1 + 1224))
  {
    v7 = *(void **)(v1 + 1200);
    if (v7)
    {
      *(_QWORD *)(v1 + 1208) = v7;
      operator delete(v7);
    }
  }
  std::unique_ptr<OpaqueAudioConverter,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioConverter*,&(AudioConverterDispose)>>::reset[abi:ne180100]((OpaqueAudioConverter **)(v1 + 1192), 0);
  if (*(_BYTE *)(v1 + 1184))
  {
    v8 = *(void **)(v1 + 1160);
    if (v8)
    {
      *(_QWORD *)(v1 + 1168) = v8;
      operator delete(v8);
    }
  }
  std::unique_ptr<OpaqueAudioConverter,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioConverter*,&(AudioConverterDispose)>>::reset[abi:ne180100]((OpaqueAudioConverter **)(v1 + 1152), 0);
  if (*(_BYTE *)(v1 + 1144))
  {
    v9 = *(void **)(v1 + 1120);
    if (v9)
    {
      *(_QWORD *)(v1 + 1128) = v9;
      operator delete(v9);
    }
  }
  std::unique_ptr<OpaqueAudioConverter,applesauce::raii::v1::detail::opaque_deletion_functor<OpaqueAudioConverter*,&(AudioConverterDispose)>>::reset[abi:ne180100]((OpaqueAudioConverter **)(v1 + 1112), 0);
  std::__optional_destruct_base<AUDynamicDuckerV2::PowerHistoryWindow,false>::~__optional_destruct_base[abi:ne180100](v1 + 880);
  std::__optional_destruct_base<AUDynamicDuckerV2::PowerHistoryWindow,false>::~__optional_destruct_base[abi:ne180100](v1 + 768);
  std::__optional_destruct_base<AUDynamicDuckerV2::PowerHistoryWindow,false>::~__optional_destruct_base[abi:ne180100](v1 + 656);
  std::__optional_destruct_base<AUDynamicDuckerV2::PowerHistoryWindow,false>::~__optional_destruct_base[abi:ne180100](v1 + 544);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDynamicDucker>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  unsigned int v4;
  uint64_t Element;
  unsigned int v6;
  char v7;
  char v8;
  uint64_t v9;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  uint64_t v33;
  ausdk::AUElement *v34;
  ausdk::AUElement **v35;
  uint64_t v36;
  ausdk::AUElement *v37;
  ausdk::AUElement **v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  ausdk::AUElement **v44;
  uint64_t v45;
  ausdk::AUElement *v46;
  ausdk::AUElement **v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  ausdk::AUElement **v50;
  uint64_t v51;
  ausdk::AUElement *v52;
  ausdk::AUElement **v53;
  uint64_t v54;
  ausdk::AUElement *v55;
  ausdk::AUElement **v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  ausdk::AUElement **v59;
  uint64_t v60;
  ausdk::AUElement *v61;
  ausdk::AUElement **v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  ausdk::AUElement **v65;
  uint64_t v66;
  ausdk::AUElement *v67;
  ausdk::AUElement **v68;
  uint64_t v69;
  ausdk::AUElement *v70;
  ausdk::AUElement **v71;
  uint64_t v72;
  ausdk::AUElement *v73;
  ausdk::AUElement **v74;
  uint64_t v75;
  ausdk::AUElement *v76;
  ausdk::AUElement **v77;
  uint64_t v78;
  ausdk::AUElement *v79;
  ausdk::AUElement **v80;
  uint64_t v81;
  ausdk::AUElement *v82;
  ausdk::AUElement **v83;
  uint64_t v85;
  __int128 v86;
  __int128 v87;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 5, 2);
  *(_QWORD *)v3 = &off_1E69EAB38;
  *((_DWORD *)v3 + 132) = 1;
  *(_QWORD *)((char *)v3 + 532) = 0;
  *((_BYTE *)v3 + 540) = 0;
  *((_QWORD *)v3 + 70) = 0;
  *((_DWORD *)v3 + 142) = 0;
  *((_QWORD *)v3 + 85) = 0;
  *((_QWORD *)v3 + 84) = 0;
  *((_QWORD *)v3 + 94) = 0;
  *((_QWORD *)v3 + 72) = 0;
  *((_QWORD *)v3 + 74) = 0;
  *((_QWORD *)v3 + 73) = 0;
  *((_DWORD *)v3 + 150) = 0;
  *((_QWORD *)v3 + 76) = 0;
  *((_QWORD *)v3 + 78) = 0;
  *((_QWORD *)v3 + 77) = 0;
  *((_DWORD *)v3 + 158) = 0;
  *((_QWORD *)v3 + 82) = 0;
  *((_DWORD *)v3 + 166) = 0;
  *((_QWORD *)v3 + 80) = 0;
  *((_QWORD *)v3 + 81) = 0;
  *((_WORD *)v3 + 380) = 1;
  *((_BYTE *)v3 + 762) = 0;
  *((_DWORD *)v3 + 191) = 0;
  *((_QWORD *)v3 + 96) = 0x3DCCCCCD3E800000;
  *((_QWORD *)v3 + 97) = 0;
  *((_DWORD *)v3 + 196) = 0;
  *((_DWORD *)v3 + 198) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v4 = 0;
  v85 = 0x40E5888000000000;
  v86 = xmmword_1B6626900;
  v87 = xmmword_1B6626910;
  do
  {
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v4);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v85);
    ++v4;
  }
  while (v4 != 5);
  v6 = 0;
  v7 = 1;
  do
  {
    v8 = v7;
    v9 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), v6);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v9 + 56))(v9, &v85);
    v7 = 0;
    v6 = 1;
  }
  while ((v8 & 1) != 0);
  *(_DWORD *)(a1 + 552) = 1065353216;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 544) = _D0;
  v15 = *(_QWORD *)(a1 + 72);
  if (v15)
  {
    v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
  }
  else
  {
    v17 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v17)
      v16 = 0;
    else
      v16 = *v17;
  }
  ausdk::AUElement::SetParameter(v16, 0, -18.0, 0);
  v18 = *(_QWORD *)(a1 + 72);
  if (v18)
  {
    v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
  }
  else
  {
    v20 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v20)
      v19 = 0;
    else
      v19 = *v20;
  }
  ausdk::AUElement::SetParameter(v19, 1u, -18.0, 0);
  v21 = *(_QWORD *)(a1 + 72);
  if (v21)
  {
    v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
  }
  else
  {
    v23 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v23)
      v22 = 0;
    else
      v22 = *v23;
  }
  ausdk::AUElement::SetParameter(v22, 2u, -18.0, 0);
  v24 = *(_QWORD *)(a1 + 72);
  if (v24)
  {
    v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
  }
  else
  {
    v26 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v26)
      v25 = 0;
    else
      v25 = *v26;
  }
  ausdk::AUElement::SetParameter(v25, 3u, -40.0, 0);
  v27 = *(_QWORD *)(a1 + 72);
  if (v27)
  {
    v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
  }
  else
  {
    v29 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v29)
      v28 = 0;
    else
      v28 = *v29;
  }
  ausdk::AUElement::SetParameter(v28, 4u, -40.0, 0);
  v30 = *(_QWORD *)(a1 + 72);
  if (v30)
  {
    v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
  }
  else
  {
    v32 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v32)
      v31 = 0;
    else
      v31 = *v32;
  }
  ausdk::AUElement::SetParameter(v31, 5u, -40.0, 0);
  v33 = *(_QWORD *)(a1 + 72);
  if (v33)
  {
    v34 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v33 + 32))(v33, 0);
  }
  else
  {
    v35 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v35)
      v34 = 0;
    else
      v34 = *v35;
  }
  ausdk::AUElement::SetParameter(v34, 6u, -45.0, 0);
  v36 = *(_QWORD *)(a1 + 72);
  if (v36)
  {
    v37 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v36 + 32))(v36, 0);
  }
  else
  {
    v38 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v38)
      v37 = 0;
    else
      v37 = *v38;
  }
  ausdk::AUElement::SetParameter(v37, 7u, -50.0, 0);
  v39 = *(_QWORD *)(a1 + 72);
  if (v39)
  {
    v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
  }
  else
  {
    v41 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v41)
      v40 = 0;
    else
      v40 = *v41;
  }
  ausdk::AUElement::SetParameter(v40, 8u, -18.0, 0);
  v42 = *(_QWORD *)(a1 + 72);
  if (v42)
  {
    v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v42 + 32))(v42, 0);
  }
  else
  {
    v44 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v44)
      v43 = 0;
    else
      v43 = *v44;
  }
  ausdk::AUElement::SetParameter(v43, 9u, 0.0, 0);
  v45 = *(_QWORD *)(a1 + 72);
  if (v45)
  {
    v46 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v45 + 32))(v45, 0);
  }
  else
  {
    v47 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v47)
      v46 = 0;
    else
      v46 = *v47;
  }
  ausdk::AUElement::SetParameter(v46, 0xAu, 0.0, 0);
  v48 = *(_QWORD *)(a1 + 72);
  if (v48)
  {
    v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v48 + 32))(v48, 0);
  }
  else
  {
    v50 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v50)
      v49 = 0;
    else
      v49 = *v50;
  }
  ausdk::AUElement::SetParameter(v49, 0xBu, 0.0, 0);
  v51 = *(_QWORD *)(a1 + 72);
  if (v51)
  {
    v52 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v51 + 32))(v51, 0);
  }
  else
  {
    v53 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v53)
      v52 = 0;
    else
      v52 = *v53;
  }
  ausdk::AUElement::SetParameter(v52, 0xCu, -96.0, 0);
  v54 = *(_QWORD *)(a1 + 72);
  if (v54)
  {
    v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v54 + 32))(v54, 0);
  }
  else
  {
    v56 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v56)
      v55 = 0;
    else
      v55 = *v56;
  }
  ausdk::AUElement::SetParameter(v55, 0xDu, 0.25, 0);
  v57 = *(_QWORD *)(a1 + 72);
  if (v57)
  {
    v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v57 + 32))(v57, 0);
  }
  else
  {
    v59 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v59)
      v58 = 0;
    else
      v58 = *v59;
  }
  ausdk::AUElement::SetParameter(v58, 0xEu, 0.1, 0);
  v60 = *(_QWORD *)(a1 + 72);
  if (v60)
  {
    v61 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v60 + 32))(v60, 0);
  }
  else
  {
    v62 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v62)
      v61 = 0;
    else
      v61 = *v62;
  }
  ausdk::AUElement::SetParameter(v61, 0xFu, 0.0, 0);
  v63 = *(_QWORD *)(a1 + 72);
  if (v63)
  {
    v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v63 + 32))(v63, 0);
  }
  else
  {
    v65 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v65)
      v64 = 0;
    else
      v64 = *v65;
  }
  ausdk::AUElement::SetParameter(v64, 0x10u, 0.0, 0);
  v66 = *(_QWORD *)(a1 + 72);
  if (v66)
  {
    v67 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v66 + 32))(v66, 0);
  }
  else
  {
    v68 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v68)
      v67 = 0;
    else
      v67 = *v68;
  }
  ausdk::AUElement::SetParameter(v67, 0x13u, 0.5, 0);
  v69 = *(_QWORD *)(a1 + 72);
  if (v69)
  {
    v70 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v69 + 32))(v69, 0);
  }
  else
  {
    v71 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v71)
      v70 = 0;
    else
      v70 = *v71;
  }
  ausdk::AUElement::SetParameter(v70, 0x12u, 0.0, 0);
  v72 = *(_QWORD *)(a1 + 72);
  if (v72)
  {
    v73 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v72 + 32))(v72, 0);
  }
  else
  {
    v74 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v74)
      v73 = 0;
    else
      v73 = *v74;
  }
  ausdk::AUElement::SetParameter(v73, 0x11u, 0.0, 0);
  v75 = *(_QWORD *)(a1 + 72);
  if (v75)
  {
    v76 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v75 + 32))(v75, 0);
  }
  else
  {
    v77 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v77)
      v76 = 0;
    else
      v76 = *v77;
  }
  ausdk::AUElement::SetParameter(v76, 0x14u, -200.0, 0);
  v78 = *(_QWORD *)(a1 + 72);
  if (v78)
  {
    v79 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v78 + 32))(v78, 0);
  }
  else
  {
    v80 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v80)
      v79 = 0;
    else
      v79 = *v80;
  }
  ausdk::AUElement::SetParameter(v79, 0x15u, 0.0, 0);
  v81 = *(_QWORD *)(a1 + 72);
  if (v81)
  {
    v82 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v81 + 32))(v81, 0);
  }
  else
  {
    v83 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v83)
      v82 = 0;
    else
      v82 = *v83;
  }
  ausdk::AUElement::SetParameter(v82, 0x16u, -200.0, 0);
  return a1;
}

void sub_1B61D0488(_Unwind_Exception *a1)
{
  uint64_t v1;

  CDSPSplitComplex::~CDSPSplitComplex((CDSPSplitComplex *)(v1 + 656));
  CDSPSplitComplex::~CDSPSplitComplex((CDSPSplitComplex *)(v1 + 624));
  CDSPSplitComplex::~CDSPSplitComplex((CDSPSplitComplex *)(v1 + 592));
  CDSPSplitComplex::~CDSPSplitComplex((CDSPSplitComplex *)(v1 + 560));
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUDynamicDucker>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMultiBandDynamicsProcessorV2>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  _QWORD *v4;
  uint64_t Element;
  uint64_t v6;
  uint64_t v7;
  OpaqueAudioComponent *Next;
  AudioUnit *v9;
  uint64_t v10;
  AudioUnit *v11;
  OpaqueAudioComponent *v12;
  uint64_t v13;
  OpaqueAudioComponent *v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  ausdk::AUElement **v19;
  uint64_t v20;
  ausdk::AUElement *v21;
  ausdk::AUElement **v22;
  uint64_t v23;
  ausdk::AUElement *v24;
  ausdk::AUElement **v25;
  uint64_t v26;
  ausdk::AUElement *v27;
  ausdk::AUElement **v28;
  uint64_t v29;
  ausdk::AUElement *v30;
  ausdk::AUElement **v31;
  uint64_t v32;
  ausdk::AUElement *v33;
  ausdk::AUElement **v34;
  uint64_t v35;
  ausdk::AUElement *v36;
  ausdk::AUElement **v37;
  uint64_t v38;
  ausdk::AUElement *v39;
  ausdk::AUElement **v40;
  uint64_t v41;
  ausdk::AUElement *v42;
  ausdk::AUElement **v43;
  uint64_t v44;
  ausdk::AUElement *v45;
  ausdk::AUElement **v46;
  uint64_t v47;
  ausdk::AUElement *v48;
  ausdk::AUElement **v49;
  uint64_t v50;
  ausdk::AUElement *v51;
  ausdk::AUElement **v52;
  uint64_t v53;
  ausdk::AUElement *v54;
  ausdk::AUElement **v55;
  uint64_t v56;
  ausdk::AUElement *v57;
  ausdk::AUElement **v58;
  uint64_t v59;
  ausdk::AUElement *v60;
  ausdk::AUElement **v61;
  uint64_t v62;
  ausdk::AUElement *v63;
  ausdk::AUElement **v64;
  uint64_t v65;
  ausdk::AUElement *v66;
  ausdk::AUElement **v67;
  uint64_t v68;
  ausdk::AUElement *v69;
  ausdk::AUElement **v70;
  uint64_t v71;
  ausdk::AUElement *v72;
  ausdk::AUElement **v73;
  uint64_t v74;
  ausdk::AUElement *v75;
  ausdk::AUElement **v76;
  uint64_t v77;
  ausdk::AUElement *v78;
  ausdk::AUElement **v79;
  uint64_t v80;
  ausdk::AUElement *v81;
  ausdk::AUElement **v82;
  uint64_t v83;
  ausdk::AUElement *v84;
  ausdk::AUElement **v85;
  uint64_t v86;
  ausdk::AUElement *v87;
  ausdk::AUElement **v88;
  int v89;
  uint64_t i;
  uint64_t v91;
  ausdk::AUElement *v92;
  ausdk::AUElement **v93;
  uint64_t v94;
  ausdk::AUElement *v95;
  ausdk::AUElement **v96;
  uint64_t v97;
  int v98;
  _QWORD v100[2];
  int v101;
  _BYTE inDesc[24];
  __int128 v103;
  uint64_t (*inData)(AUMultiBandDynamicsProcessorV2 *, void *, unsigned int *, const AudioTimeStamp *, int, _DWORD *, AudioBufferList *);
  uint64_t v105;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 2, 1);
  *(_QWORD *)v3 = &off_1E69EC848;
  *((_OWORD *)v3 + 33) = xmmword_1B6627BC0;
  *((_QWORD *)v3 + 68) = 0x100000000;
  *((_DWORD *)v3 + 138) = 0;
  *((_QWORD *)v3 + 107) = 2;
  *((_DWORD *)v3 + 216) = 0;
  v4 = (_QWORD *)((char *)v3 + 888);
  *((_QWORD *)v3 + 149) = 0;
  *((_QWORD *)v3 + 148) = 0;
  *(_OWORD *)((char *)v3 + 888) = 0u;
  *(_OWORD *)((char *)v3 + 904) = 0u;
  *(_OWORD *)((char *)v3 + 920) = 0u;
  *(_OWORD *)((char *)v3 + 936) = 0u;
  *(_OWORD *)((char *)v3 + 952) = 0u;
  *(_OWORD *)((char *)v3 + 968) = 0u;
  *(_OWORD *)((char *)v3 + 984) = 0u;
  *(_OWORD *)((char *)v3 + 1000) = 0u;
  *(_OWORD *)((char *)v3 + 1016) = 0u;
  *(_OWORD *)((char *)v3 + 1032) = 0u;
  *(_OWORD *)((char *)v3 + 1048) = 0u;
  *(_OWORD *)((char *)v3 + 1064) = 0u;
  *(_OWORD *)((char *)v3 + 1080) = 0u;
  *(_OWORD *)((char *)v3 + 1096) = 0u;
  *(_OWORD *)((char *)v3 + 1112) = 0u;
  *(_OWORD *)((char *)v3 + 1128) = 0u;
  *(_OWORD *)((char *)v3 + 1144) = 0u;
  *((_DWORD *)v3 + 290) = 0;
  *(_OWORD *)((char *)v3 + 1164) = xmmword_1B66A0DC0;
  *((_QWORD *)v3 + 154) = 0;
  *((_QWORD *)v3 + 153) = 0;
  *((_DWORD *)v3 + 304) = 0;
  *((_OWORD *)v3 + 75) = xmmword_1B66A0CF0;
  *((_BYTE *)v3 + 1240) = 0;
  *((_DWORD *)v3 + 318) = 4;
  *((_BYTE *)v3 + 1276) = 1;
  *((_WORD *)v3 + 656) = 0;
  *((_QWORD *)v3 + 165) = 0;
  *(_OWORD *)((char *)v3 + 1352) = 0u;
  *(_OWORD *)((char *)v3 + 1368) = 0u;
  *(_OWORD *)((char *)v3 + 1384) = 0u;
  *(_OWORD *)((char *)v3 + 1400) = 0u;
  *(_OWORD *)((char *)v3 + 1416) = 0u;
  *(_OWORD *)((char *)v3 + 1432) = 0u;
  *(_OWORD *)((char *)v3 + 1448) = 0u;
  *(_OWORD *)((char *)v3 + 1464) = 0u;
  *(_OWORD *)((char *)v3 + 1480) = 0u;
  *(_OWORD *)((char *)v3 + 1336) = 0u;
  *((_DWORD *)v3 + 332) = 0;
  *((_QWORD *)v3 + 187) = 0;
  v100[0] = 0;
  v100[1] = 0;
  v101 = 0;
  ausdk::ComponentBase::GetComponentDescription((ausdk::ComponentBase *)v100, *((OpaqueAudioComponentInstance **)v3 + 1));
  *(_BYTE *)(a1 + 1314) = HIDWORD(v100[0]) == 1835298866;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  *(_QWORD *)inDesc = 0x40E5888000000000;
  *(_OWORD *)&inDesc[8] = xmmword_1B6626900;
  v103 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)Element + 56))(Element, inDesc);
  v6 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 1u);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v6 + 56))(v6, inDesc);
  v7 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v7 + 56))(v7, inDesc);
  *(_QWORD *)(a1 + 1244) = 0x400000001;
  *(_DWORD *)(a1 + 868) = 0;
  *(_QWORD *)(a1 + 872) = 0x3F80000000000000;
  *(_QWORD *)(a1 + 880) = 0;
  CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set(v4, 0);
  CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set((_QWORD *)(a1 + 896), 0);
  *(_QWORD *)(a1 + 848) = 0;
  *(_DWORD *)(a1 + 1280) = 0;
  ++*(_DWORD *)(a1 + 528);
  inDesc[13] = 0;
  *(_WORD *)&inDesc[14] = 0;
  *(_DWORD *)&inDesc[16] = 0;
  strcpy(inDesc, "xfua2clvlppa");
  Next = AudioComponentFindNext(0, (const AudioComponentDescription *)inDesc);
  v9 = (AudioUnit *)(a1 + 848);
  inData = AUMultiBandDynamicsProcessorV2::RenderCallbackVolComp;
  v105 = a1;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  v10 = 816;
  while (1)
  {
    v11 = (AudioUnit *)(a1 + v10);
    if (AudioComponentInstanceNew(Next, (AudioComponentInstance *)(a1 + v10))
      || AudioUnitSetProperty(*v11, 0x17u, 1u, 0, &inData, 0x10u))
    {
      break;
    }
    AudioUnitSetParameter(*v11, 0xDu, 0, 0, 2.0, 0);
    AudioUnitSetParameter(*v11, 0xEu, 0, 0, 2.0, 0);
    v10 += 8;
    if (v10 == 848)
    {
      inDesc[13] = 0;
      *(_WORD *)&inDesc[14] = 0;
      *(_DWORD *)&inDesc[16] = 0;
      strcpy(inDesc, "xfuaqebnlppa");
      v12 = AudioComponentFindNext(0, (const AudioComponentDescription *)inDesc);
      inData = AUMultiBandDynamicsProcessorV2::RenderCallbackNBandEQ;
      v105 = a1;
      *(_OWORD *)(a1 + 688) = 0u;
      *(_OWORD *)(a1 + 704) = 0u;
      *(_OWORD *)(a1 + 720) = 0u;
      *(_OWORD *)(a1 + 736) = 0u;
      *(_OWORD *)(a1 + 752) = 0u;
      *(_OWORD *)(a1 + 768) = 0u;
      v13 = 688;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      while (!AudioComponentInstanceNew(v12, (AudioComponentInstance *)(a1 + v13))
           && !AudioUnitSetProperty(*(AudioUnit *)(a1 + v13), 0x17u, 1u, 0, &inData, 0x10u))
      {
        v13 += 8;
        if (v13 == 816)
        {
          inDesc[13] = 0;
          *(_WORD *)&inDesc[14] = 0;
          *(_DWORD *)&inDesc[16] = 0;
          strcpy(inDesc, "xfua2clvlppa");
          v14 = AudioComponentFindNext(0, (const AudioComponentDescription *)inDesc);
          if (!AudioComponentInstanceNew(v14, (AudioComponentInstance *)(a1 + 848)))
          {
            AudioUnitSetParameter(*v9, 0xAu, 0, 0, 0.0, 0);
            AudioUnitSetParameter(*v9, 0xBu, 0, 0, 0.0, 0);
            AudioUnitSetParameter(*v9, 0xDu, 0, 0, 2.0, 0);
            AudioUnitSetParameter(*v9, 0xEu, 0, 0, 2.0, 0);
            inData = AUMultiBandDynamicsProcessorV2::RenderCallbackVolComp;
            v105 = a1;
            AudioUnitSetProperty(*(AudioUnit *)(a1 + 848), 0x17u, 1u, 0, &inData, 0x10u);
          }
          goto LABEL_11;
        }
      }
      break;
    }
  }
LABEL_11:
  v15 = *(_QWORD *)(a1 + 72);
  if (*(_BYTE *)(a1 + 1314))
  {
    if (v15)
    {
      v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
    }
    else
    {
      v18 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v18)
        v16 = 0;
      else
        v16 = *v18;
    }
    ausdk::AUElement::SetParameter(v16, 0, 1.0, 0);
    v20 = *(_QWORD *)(a1 + 72);
    if (v20)
    {
      v21 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 32))(v20, 0);
    }
    else
    {
      v22 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v22)
        v21 = 0;
      else
        v21 = *v22;
    }
    ausdk::AUElement::SetParameter(v21, 6u, 0.0, 0);
    v23 = *(_QWORD *)(a1 + 72);
    if (v23)
    {
      v24 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
    }
    else
    {
      v25 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v25)
        v24 = 0;
      else
        v24 = *v25;
    }
    ausdk::AUElement::SetParameter(v24, 7u, 1.0, 0);
    v26 = *(_QWORD *)(a1 + 72);
    if (v26)
    {
      v27 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 32))(v26, 0);
    }
    else
    {
      v28 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v28)
        v27 = 0;
      else
        v27 = *v28;
    }
    ausdk::AUElement::SetParameter(v27, 0xCu, 0.0, 0);
    v29 = *(_QWORD *)(a1 + 72);
    if (v29)
    {
      v30 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v29 + 32))(v29, 0);
    }
    else
    {
      v31 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v31)
        v30 = 0;
      else
        v30 = *v31;
    }
    ausdk::AUElement::SetParameter(v30, 1u, 0.0, 0);
    v32 = *(_QWORD *)(a1 + 72);
    if (v32)
    {
      v33 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v32 + 32))(v32, 0);
    }
    else
    {
      v34 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v34)
        v33 = 0;
      else
        v33 = *v34;
    }
    ausdk::AUElement::SetParameter(v33, 5u, 0.0, 0);
    v35 = *(_QWORD *)(a1 + 72);
    if (v35)
    {
      v36 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 32))(v35, 0);
    }
    else
    {
      v37 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v37)
        v36 = 0;
      else
        v36 = *v37;
    }
    ausdk::AUElement::SetParameter(v36, 8u, 24000.0, 0);
    v38 = *(_QWORD *)(a1 + 72);
    if (v38)
    {
      v39 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v38 + 32))(v38, 0);
    }
    else
    {
      v40 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v40)
        v39 = 0;
      else
        v39 = *v40;
    }
    ausdk::AUElement::SetParameter(v39, 9u, 24000.0, 0);
    v41 = *(_QWORD *)(a1 + 72);
    if (v41)
    {
      v42 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v41 + 32))(v41, 0);
    }
    else
    {
      v43 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v43)
        v42 = 0;
      else
        v42 = *v43;
    }
    ausdk::AUElement::SetParameter(v42, 0xAu, 24000.0, 0);
    v44 = *(_QWORD *)(a1 + 72);
    if (v44)
    {
      v45 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v44 + 32))(v44, 0);
    }
    else
    {
      v46 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v46)
        v45 = 0;
      else
        v45 = *v46;
    }
    ausdk::AUElement::SetParameter(v45, 2u, 0.0, 0);
    v47 = *(_QWORD *)(a1 + 72);
    if (v47)
    {
      v48 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v47 + 32))(v47, 0);
    }
    else
    {
      v49 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v49)
        v48 = 0;
      else
        v48 = *v49;
    }
    ausdk::AUElement::SetParameter(v48, 3u, 0.0, 0);
    v50 = *(_QWORD *)(a1 + 72);
    if (v50)
    {
      v51 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v50 + 32))(v50, 0);
    }
    else
    {
      v52 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v52)
        v51 = 0;
      else
        v51 = *v52;
    }
    ausdk::AUElement::SetParameter(v51, 4u, 0.0, 0);
    v53 = *(_QWORD *)(a1 + 72);
    if (v53)
    {
      v54 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v53 + 32))(v53, 0);
    }
    else
    {
      v55 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v55)
        v54 = 0;
      else
        v54 = *v55;
    }
    ausdk::AUElement::SetParameter(v54, 0xDu, -18.0, 0);
    v56 = *(_QWORD *)(a1 + 72);
    if (v56)
    {
      v57 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v56 + 32))(v56, 0);
    }
    else
    {
      v58 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v58)
        v57 = 0;
      else
        v57 = *v58;
    }
    ausdk::AUElement::SetParameter(v57, 0xEu, -18.0, 0);
    v59 = *(_QWORD *)(a1 + 72);
    if (v59)
    {
      v60 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v59 + 32))(v59, 0);
    }
    else
    {
      v61 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v61)
        v60 = 0;
      else
        v60 = *v61;
    }
    ausdk::AUElement::SetParameter(v60, 0xFu, -18.0, 0);
    v62 = *(_QWORD *)(a1 + 72);
    if (v62)
    {
      v63 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v62 + 32))(v62, 0);
    }
    else
    {
      v64 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v64)
        v63 = 0;
      else
        v63 = *v64;
    }
    ausdk::AUElement::SetParameter(v63, 0x10u, -40.0, 0);
    v65 = *(_QWORD *)(a1 + 72);
    if (v65)
    {
      v66 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v65 + 32))(v65, 0);
    }
    else
    {
      v67 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v67)
        v66 = 0;
      else
        v66 = *v67;
    }
    ausdk::AUElement::SetParameter(v66, 0x11u, -40.0, 0);
    v68 = *(_QWORD *)(a1 + 72);
    if (v68)
    {
      v69 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v68 + 32))(v68, 0);
    }
    else
    {
      v70 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v70)
        v69 = 0;
      else
        v69 = *v70;
    }
    ausdk::AUElement::SetParameter(v69, 0x12u, -30.0, 0);
    v71 = *(_QWORD *)(a1 + 72);
    if (v71)
    {
      v72 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v71 + 32))(v71, 0);
    }
    else
    {
      v73 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v73)
        v72 = 0;
      else
        v72 = *v73;
    }
    ausdk::AUElement::SetParameter(v72, 0x13u, -45.0, 0);
    v74 = *(_QWORD *)(a1 + 72);
    if (v74)
    {
      v75 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v74 + 32))(v74, 0);
    }
    else
    {
      v76 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v76)
        v75 = 0;
      else
        v75 = *v76;
    }
    ausdk::AUElement::SetParameter(v75, 0x14u, -45.0, 0);
    v77 = *(_QWORD *)(a1 + 72);
    if (v77)
    {
      v78 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v77 + 32))(v77, 0);
    }
    else
    {
      v79 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v79)
        v78 = 0;
      else
        v78 = *v79;
    }
    ausdk::AUElement::SetParameter(v78, 0x15u, -18.0, 0);
    v80 = *(_QWORD *)(a1 + 72);
    if (v80)
    {
      v81 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v80 + 32))(v80, 0);
    }
    else
    {
      v82 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v82)
        v81 = 0;
      else
        v81 = *v82;
    }
    ausdk::AUElement::SetParameter(v81, 0x16u, 0.0, 0);
    v83 = *(_QWORD *)(a1 + 72);
    if (v83)
    {
      v84 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v83 + 32))(v83, 0);
    }
    else
    {
      v85 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v85)
        v84 = 0;
      else
        v84 = *v85;
    }
    ausdk::AUElement::SetParameter(v84, 0x17u, 0.0, 0);
    v86 = *(_QWORD *)(a1 + 72);
    if (v86)
    {
      v87 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v86 + 32))(v86, 0);
    }
    else
    {
      v88 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v88)
        v87 = 0;
      else
        v87 = *v88;
    }
    ausdk::AUElement::SetParameter(v87, 0x18u, 0.0, 0);
    AUMultiBandDynamicsProcessorV2::UpdateCrossOverEQs(a1);
    AUMultiBandDynamicsProcessorV2::SetVolCompParameters((AUMultiBandDynamicsProcessorV2 *)a1, *(AudioUnit *)(a1 + 848), 0);
    v89 = 100;
    for (i = 816; i != 848; i += 8)
    {
      AUMultiBandDynamicsProcessorV2::SetVolCompParameters((AUMultiBandDynamicsProcessorV2 *)a1, *(AudioUnit *)(a1 + i), v89);
      v89 += 100;
    }
  }
  else
  {
    if (v15)
    {
      v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
    }
    else
    {
      v19 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v19)
        v17 = 0;
      else
        v17 = *v19;
    }
    ausdk::AUElement::SetParameter(v17, 8u, 24000.0, 0);
    v91 = *(_QWORD *)(a1 + 72);
    if (v91)
    {
      v92 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v91 + 32))(v91, 0);
    }
    else
    {
      v93 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v93)
        v92 = 0;
      else
        v92 = *v93;
    }
    ausdk::AUElement::SetParameter(v92, 9u, 24000.0, 0);
    v94 = *(_QWORD *)(a1 + 72);
    if (v94)
    {
      v95 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v94 + 32))(v94, 0);
    }
    else
    {
      v96 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v96)
        v95 = 0;
      else
        v95 = *v96;
    }
    ausdk::AUElement::SetParameter(v95, 0xAu, 24000.0, 0);
    AUMultiBandDynamicsProcessorV2::UpdateCrossOverEQs(a1);
    v97 = 0;
    *(_BYTE *)(a1 + 1284) = 0;
    *(_DWORD *)(a1 + 1292) = 0;
    v98 = 100;
    do
    {
      AUMultiBandDynamicsProcessorV2::SetVolCompParameters((AUMultiBandDynamicsProcessorV2 *)a1, *(AudioUnit *)(a1 + 8 * v97 + 816), v98);
      *(_BYTE *)(a1 + v97 + 1285) = 0;
      *(_DWORD *)(a1 + 1296 + 4 * v97) = 0;
      v98 += 100;
      ++v97;
    }
    while (v97 != 4);
  }
  return a1;
}

void sub_1B61D10F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  ausdk::AUBase *v9;
  _QWORD *v10;
  void *v12;
  void *v13;
  _BYTE *v14;
  _BYTE *v15;
  _BYTE *v16;
  _BYTE *v17;
  uint64_t v18;
  _QWORD *v19;
  _BYTE *v20;
  _BYTE *v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  _BYTE *v25;
  _BYTE *v26;
  _QWORD *v27;

  v12 = (void *)*((_QWORD *)v9 + 174);
  if (v12)
  {
    *((_QWORD *)v9 + 175) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)v9 + 171);
  if (v13)
  {
    *((_QWORD *)v9 + 172) = v13;
    operator delete(v13);
  }
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100](&a9);
  v14 = (_BYTE *)*((_QWORD *)v9 + 153);
  if (v14)
  {
    v15 = (_BYTE *)*((_QWORD *)v9 + 154);
    if (v15 != v14)
      *((_QWORD *)v9 + 154) = &v15[(v14 - v15 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    operator delete(v14);
    *((_QWORD *)v9 + 153) = 0;
    *((_QWORD *)v9 + 154) = 0;
  }
  v16 = (_BYTE *)*((_QWORD *)v9 + 148);
  if (v16)
  {
    v17 = (_BYTE *)*((_QWORD *)v9 + 149);
    if (v17 != v16)
      *((_QWORD *)v9 + 149) = &v17[(v16 - v17 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    operator delete(v16);
    *((_QWORD *)v9 + 148) = 0;
    *((_QWORD *)v9 + 149) = 0;
  }
  v18 = 0;
  while (1)
  {
    v19 = (_QWORD *)((char *)v9 + v18);
    v20 = *(_BYTE **)((char *)v9 + v18 + 1144);
    if (v20)
    {
      v21 = (_BYTE *)v19[144];
      if (v21 != v20)
        v19[144] = &v21[(v20 - v21 + 3) & 0xFFFFFFFFFFFFFFFCLL];
      v22 = v19 + 143;
      operator delete(v20);
      *v22 = 0;
      v22[1] = 0;
    }
    v18 -= 16;
    if (v18 == -128)
    {
      v23 = 0;
      while (1)
      {
        v24 = (_QWORD *)((char *)v9 + v23);
        v25 = *(_BYTE **)((char *)v9 + v23 + 1016);
        if (v25)
        {
          v26 = (_BYTE *)v24[128];
          if (v26 != v25)
            v24[128] = &v26[(v25 - v26 + 3) & 0xFFFFFFFFFFFFFFFCLL];
          v27 = v24 + 127;
          operator delete(v25);
          *v27 = 0;
          v27[1] = 0;
        }
        v23 -= 16;
        if (v23 == -128)
        {
          CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set((_QWORD *)v9 + 112, 0);
          CADeprecated::CAAutoDelete<ausdk::AUBufferList>::set(v10, 0);
          ausdk::AUBase::~AUBase(v9);
          _Unwind_Resume(a1);
        }
      }
    }
  }
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMultiBandDynamicsProcessorV2>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReverbSuppressor>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  _DWORD *v4;
  uint64_t (***v5)();
  uint64_t v6;
  _DWORD *v7;
  uint64_t (***v8)();
  uint64_t v9;
  _DWORD *v10;
  uint64_t (***v11)();
  uint64_t v12;
  uint64_t (**v13)();
  uint64_t (**v14)();
  uint64_t (**v15)();
  _QWORD *v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t (***v32)();
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t (**v36)();
  void **v37;
  void ***v38;
  _BYTE *v39;
  uint64_t (***v40)();
  uint64_t (***v41)();
  void **v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  ausdk::AUElement **v48;
  uint64_t v49;
  ausdk::AUElement *v50;
  ausdk::AUElement **v51;
  uint64_t v52;
  ausdk::AUElement *v53;
  ausdk::AUElement **v54;
  uint64_t Element;
  unsigned int i;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void **p_p;
  _QWORD *exception;
  int inData;
  void *__p;
  __int128 v65;
  __int128 v66;
  void *v67[2];
  uint64_t v68;
  uint64_t (**v69)();
  __int128 v70;
  __int128 v71;
  uint8_t buf[4];
  const char *v73;
  __int16 v74;
  int v75;
  __int16 v76;
  const char *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 2);
  *(_QWORD *)v3 = &off_1E69EB070;
  *((_QWORD *)v3 + 66) = 1;
  *((_DWORD *)v3 + 134) = 0;
  *((_QWORD *)v3 + 68) = 0;
  *((_QWORD *)v3 + 70) = 0;
  *((_QWORD *)v3 + 72) = 0;
  *((_QWORD *)v3 + 71) = 0;
  *((_QWORD *)v3 + 69) = (char *)v3 + 560;
  *((_QWORD *)v3 + 74) = 0;
  *((_QWORD *)v3 + 73) = 0;
  DSPSplitComplexV<float>::DSPSplitComplexV((_QWORD *)v3 + 75, 0);
  std::string::basic_string[abi:ne180100]<0>(&v69, "InpFrameNode");
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::AutoValue((_QWORD *)(a1 + 664), (__int128 *)&v69);
  if (SHIBYTE(v70) < 0)
    operator delete(v69);
  std::string::basic_string[abi:ne180100]<0>(&v69, "OutFrameNode");
  AutoValue<DSPSplitComplexV<float>,(LogTypes)0>::AutoValue((_QWORD *)(a1 + 1056), (__int128 *)&v69);
  if (SHIBYTE(v70) < 0)
    operator delete(v69);
  std::string::basic_string[abi:ne180100]<0>(&v69, "pass1GainFloor(dB)");
  AutoValue<float,(LogTypes)0>::AutoValue(a1 + 1448, (__int128 *)&v69);
  if (SHIBYTE(v70) < 0)
    operator delete(v69);
  std::string::basic_string[abi:ne180100]<0>(&v69, "pass2GainFloor(dB)");
  AutoValue<float,(LogTypes)0>::AutoValue(a1 + 1784, (__int128 *)&v69);
  if (SHIBYTE(v70) < 0)
    operator delete(v69);
  std::string::basic_string[abi:ne180100]<0>(&v69, "reverbTailGain(dB)");
  AutoValue<float,(LogTypes)0>::AutoValue(a1 + 2120, (__int128 *)&v69);
  if (SHIBYTE(v70) < 0)
    operator delete(v69);
  std::string::basic_string[abi:ne180100]<0>(&__p, "pass1GainFloor(dB)_i");
  Trackable::Trackable<AutoValue<float,(LogTypes)0>>(a1 + 2456, (__int128 *)&__p, a1 + 1448);
  *(_QWORD *)(a1 + 2456) = &off_1E69EB300;
  *(_QWORD *)(a1 + 2712) = 0;
  *(_QWORD *)(a1 + 2704) = 0;
  *(_OWORD *)(a1 + 2736) = xmmword_1B6626830;
  *(_DWORD *)(a1 + 2752) = 0;
  *(_QWORD *)(a1 + 2760) = 0;
  *(_OWORD *)(a1 + 2768) = xmmword_1B66A0DC0;
  v4 = operator new(4uLL);
  *(_QWORD *)(a1 + 2760) = v4;
  *(_QWORD *)(a1 + 2776) = 1;
  *v4 = 0;
  *(_QWORD *)(a1 + 2784) = 0;
  v69 = &off_1E69EB340;
  *((_QWORD *)&v70 + 1) = a1 + 1448;
  *(_QWORD *)&v71 = &v69;
  std::__function::__value_func<float const& ()(float &)>::swap[abi:ne180100](&v69, (_QWORD *)(a1 + 2680));
  v5 = (uint64_t (***)())v71;
  if ((uint64_t (***)())v71 == &v69)
  {
    v6 = 4;
    v5 = &v69;
  }
  else
  {
    if (!(_QWORD)v71)
      goto LABEL_16;
    v6 = 5;
  }
  (*v5)[v6]();
LABEL_16:
  *(_DWORD *)(a1 + 2464) = 0;
  *(_QWORD *)(a1 + 2472) = 0;
  *(_QWORD *)(a1 + 2728) = 0;
  *(_QWORD *)(a1 + 2720) = 0;
  if (SHIBYTE(v65) < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "pass2GainFloor(dB)_i");
  Trackable::Trackable<AutoValue<float,(LogTypes)0>>(a1 + 2792, (__int128 *)&__p, a1 + 1784);
  *(_QWORD *)(a1 + 2792) = &off_1E69EB300;
  *(_QWORD *)(a1 + 3048) = 0;
  *(_QWORD *)(a1 + 3040) = 0;
  *(_OWORD *)(a1 + 3072) = xmmword_1B6626830;
  *(_DWORD *)(a1 + 3088) = 0;
  *(_QWORD *)(a1 + 3096) = 0;
  *(_OWORD *)(a1 + 3104) = xmmword_1B66A0DC0;
  v7 = operator new(4uLL);
  *(_QWORD *)(a1 + 3096) = v7;
  *(_QWORD *)(a1 + 3112) = 1;
  *v7 = 0;
  *(_QWORD *)(a1 + 3120) = 0;
  v69 = &off_1E69EB388;
  *((_QWORD *)&v70 + 1) = a1 + 1784;
  *(_QWORD *)&v71 = &v69;
  std::__function::__value_func<float const& ()(float &)>::swap[abi:ne180100](&v69, (_QWORD *)(a1 + 3016));
  v8 = (uint64_t (***)())v71;
  if ((uint64_t (***)())v71 == &v69)
  {
    v9 = 4;
    v8 = &v69;
  }
  else
  {
    if (!(_QWORD)v71)
      goto LABEL_23;
    v9 = 5;
  }
  (*v8)[v9]();
LABEL_23:
  *(_DWORD *)(a1 + 2800) = 0;
  *(_QWORD *)(a1 + 2808) = 0;
  *(_QWORD *)(a1 + 3064) = 0;
  *(_QWORD *)(a1 + 3056) = 0;
  if (SHIBYTE(v65) < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "reverbTailGain(dB)_i");
  Trackable::Trackable<AutoValue<float,(LogTypes)0>>(a1 + 3128, (__int128 *)&__p, a1 + 2120);
  *(_QWORD *)(a1 + 3128) = &off_1E69EB300;
  *(_QWORD *)(a1 + 3384) = 0;
  *(_QWORD *)(a1 + 3376) = 0;
  *(_OWORD *)(a1 + 3408) = xmmword_1B6626830;
  *(_DWORD *)(a1 + 3424) = 0;
  *(_QWORD *)(a1 + 3432) = 0;
  *(_OWORD *)(a1 + 3440) = xmmword_1B66A0DC0;
  v10 = operator new(4uLL);
  *(_QWORD *)(a1 + 3432) = v10;
  *(_QWORD *)(a1 + 3448) = 1;
  *v10 = 0;
  *(_QWORD *)(a1 + 3456) = 0;
  v69 = &off_1E69EB3D0;
  *((_QWORD *)&v70 + 1) = a1 + 2120;
  *(_QWORD *)&v71 = &v69;
  std::__function::__value_func<float const& ()(float &)>::swap[abi:ne180100](&v69, (_QWORD *)(a1 + 3352));
  v11 = (uint64_t (***)())v71;
  if ((uint64_t (***)())v71 == &v69)
  {
    v12 = 4;
    v11 = &v69;
  }
  else
  {
    if (!(_QWORD)v71)
      goto LABEL_30;
    v12 = 5;
  }
  (*v11)[v12]();
LABEL_30:
  *(_DWORD *)(a1 + 3136) = 0;
  *(_QWORD *)(a1 + 3144) = 0;
  *(_QWORD *)(a1 + 3400) = 0;
  *(_QWORD *)(a1 + 3392) = 0;
  if (SHIBYTE(v65) < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&v69, "internalBypass_pref");
  v13 = (uint64_t (**)())(a1 + 3464);
  AutoValue<BOOL,(LogTypes)0>::AutoValue(a1 + 3464, (__int128 *)&v69);
  if (SHIBYTE(v70) < 0)
    operator delete(v69);
  std::string::basic_string[abi:ne180100]<0>(&v69, "internalBypass_fail");
  v14 = (uint64_t (**)())(a1 + 3800);
  AutoValue<BOOL,(LogTypes)0>::AutoValue(a1 + 3800, (__int128 *)&v69);
  if (SHIBYTE(v70) < 0)
    operator delete(v69);
  std::string::basic_string[abi:ne180100]<0>(&v69, "internalBypass_noTail");
  v15 = (uint64_t (**)())(a1 + 4136);
  AutoValue<BOOL,(LogTypes)0>::AutoValue(a1 + 4136, (__int128 *)&v69);
  if (SHIBYTE(v70) < 0)
    operator delete(v69);
  std::string::basic_string[abi:ne180100]<0>(v67, "internalBypass");
  *(_QWORD *)(a1 + 4472) = &off_1E69EB2E0;
  *(_BYTE *)(a1 + 4496) = 0;
  *(_QWORD *)(a1 + 4504) = 0;
  *(_QWORD *)(a1 + 4520) = 0;
  *(_QWORD *)(a1 + 4512) = 0;
  *(_QWORD *)(a1 + 4536) = 0;
  if (SHIBYTE(v68) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 4544), (const std::string::value_type *)v67[0], (std::string::size_type)v67[1]);
  }
  else
  {
    *(_OWORD *)(a1 + 4544) = *(_OWORD *)v67;
    *(_QWORD *)(a1 + 4560) = v68;
  }
  *(_BYTE *)(a1 + 4568) = 0;
  *(_OWORD *)(a1 + 4576) = 0u;
  *(_OWORD *)(a1 + 4592) = 0u;
  *(_OWORD *)(a1 + 4608) = 0u;
  *(_OWORD *)(a1 + 4624) = 0u;
  *(_OWORD *)(a1 + 4640) = 0u;
  *(_OWORD *)(a1 + 4656) = 0u;
  *(_OWORD *)(a1 + 4672) = 0u;
  *(_QWORD *)(a1 + 4688) = 0;
  v16 = operator new(8uLL);
  *v16 = v13;
  *(_QWORD *)(a1 + 4600) = v16;
  *(_QWORD *)(a1 + 4608) = v16 + 1;
  *(_QWORD *)(a1 + 4616) = v16 + 1;
  v17 = std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(2uLL);
  v17[1] = v14;
  v18 = (char *)(v17 + 1);
  v20 = (char *)&v17[v19];
  v21 = (char *)(v17 + 2);
  v22 = *(char **)(a1 + 4608);
  v23 = *(char **)(a1 + 4600);
  if (v22 != v23)
  {
    do
    {
      v24 = *((_QWORD *)v22 - 1);
      v22 -= 8;
      *((_QWORD *)v18 - 1) = v24;
      v18 -= 8;
    }
    while (v22 != v23);
    v22 = *(char **)(a1 + 4600);
  }
  *(_QWORD *)(a1 + 4600) = v18;
  *(_QWORD *)(a1 + 4608) = v21;
  *(_QWORD *)(a1 + 4616) = v20;
  if (v22)
  {
    operator delete(v22);
    v20 = *(char **)(a1 + 4616);
  }
  *(_QWORD *)(a1 + 4608) = v21;
  if (v21 >= v20)
  {
    v26 = *(_QWORD *)(a1 + 4600);
    v27 = (uint64_t)&v21[-v26] >> 3;
    if ((unint64_t)(v27 + 1) >> 61)
      std::vector<vp::vx::database::v1::syntax::Rule>::__throw_length_error[abi:ne180100]();
    v28 = (uint64_t)&v20[-v26];
    v29 = v28 >> 2;
    if (v28 >> 2 <= (unint64_t)(v27 + 1))
      v29 = v27 + 1;
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
      v30 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v30 = v29;
    if (v30)
      v30 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<SlidingWindowDTFT<float> *>>(v30);
    else
      v31 = 0;
    v32 = (uint64_t (***)())(v30 + 8 * v27);
    v33 = v30 + 8 * v31;
    *v32 = v15;
    v25 = v32 + 1;
    v34 = *(char **)(a1 + 4608);
    v35 = *(char **)(a1 + 4600);
    if (v34 != v35)
    {
      do
      {
        v36 = (uint64_t (**)())*((_QWORD *)v34 - 1);
        v34 -= 8;
        *--v32 = v36;
      }
      while (v34 != v35);
      v34 = *(char **)(a1 + 4600);
    }
    *(_QWORD *)(a1 + 4600) = v32;
    *(_QWORD *)(a1 + 4608) = v25;
    *(_QWORD *)(a1 + 4616) = v33;
    if (v34)
      operator delete(v34);
  }
  else
  {
    v17[2] = v15;
    v25 = v17 + 3;
  }
  *(_QWORD *)(a1 + 4608) = v25;
  *(_QWORD *)(a1 + 4528) = 0;
  *(_DWORD *)(a1 + 4480) = 0;
  *(_QWORD *)(a1 + 4472) = &off_1E69EB2C0;
  v37 = (void **)(a1 + 4696);
  v38 = (void ***)(a1 + 4720);
  *(_QWORD *)(a1 + 4728) = 0;
  *(_QWORD *)(a1 + 4720) = 0;
  *(_OWORD *)(a1 + 4752) = xmmword_1B6626830;
  *(_BYTE *)(a1 + 4768) = 0;
  *(_QWORD *)(a1 + 4776) = 0;
  *(_OWORD *)(a1 + 4784) = xmmword_1B66A0DC0;
  v39 = operator new(1uLL);
  *(_QWORD *)(a1 + 4776) = v39;
  *v39 = 0;
  *(_OWORD *)(a1 + 4792) = xmmword_1B66A0DC0;
  v40 = (uint64_t (***)())operator new(0x28uLL);
  v41 = v40;
  *v40 = &off_1E69EB438;
  v40[1] = (uint64_t (**)())IfAnyNode::IfAnyFun<AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &,AutoValue<BOOL,(LogTypes)0> &>;
  v40[2] = v13;
  v40[3] = v14;
  v40[4] = v15;
  *(_QWORD *)&v71 = v40;
  if ((uint64_t (***)())(a1 + 4696) == &v69)
  {
    v43 = 5;
    goto LABEL_70;
  }
  v42 = *v38;
  if (*v38 == v37)
  {
    v41 = &v69;
    (*((void (**)(uint64_t, uint64_t (***)()))*v37 + 3))(a1 + 4696, &v69);
    (*((void (**)(void **))**v38 + 4))(*v38);
    *v38 = (void **)v71;
    *(_QWORD *)&v71 = &v69;
    goto LABEL_69;
  }
  *(_QWORD *)&v71 = *v38;
  *v38 = (void **)v40;
  v41 = &v69;
  if (v42 == (void **)&v69)
  {
LABEL_69:
    v43 = 4;
    goto LABEL_70;
  }
  if (v42)
  {
    v43 = 5;
    v41 = (uint64_t (***)())v42;
LABEL_70:
    ((void (*)(uint64_t (***)()))(*v41)[v43])(v41);
  }
  *(_DWORD *)(a1 + 4480) = 0;
  *(_QWORD *)(a1 + 4488) = 0;
  *(_QWORD *)(a1 + 4744) = 0;
  *(_QWORD *)(a1 + 4736) = 0;
  *(_QWORD *)(a1 + 4472) = &off_1E69EB418;
  if (SHIBYTE(v68) < 0)
    operator delete(v67[0]);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v44 = *(_QWORD *)(a1 + 72);
  if (v44)
    v45 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v44 + 32))(v44, 0);
  else
    v45 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v45 + 40))(v45, 3);
  v46 = *(_QWORD *)(a1 + 72);
  if (v46)
  {
    v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 0);
  }
  else
  {
    v48 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v48)
      v47 = 0;
    else
      v47 = *v48;
  }
  ausdk::AUElement::SetParameter(v47, 0, -24.0, 0);
  v49 = *(_QWORD *)(a1 + 72);
  if (v49)
  {
    v50 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v49 + 32))(v49, 0);
  }
  else
  {
    v51 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v51)
      v50 = 0;
    else
      v50 = *v51;
  }
  ausdk::AUElement::SetParameter(v50, 1u, -18.0, 0);
  v52 = *(_QWORD *)(a1 + 72);
  if (v52)
  {
    v53 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v52 + 32))(v52, 0);
  }
  else
  {
    v54 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v54)
      v53 = 0;
    else
      v53 = *v54;
  }
  ausdk::AUElement::SetParameter(v53, 2u, 0.0, 0);
  v69 = (uint64_t (**)())0x40E5888000000000;
  __p = (void *)0x40E5888000000000;
  v70 = xmmword_1B66A0BD0;
  v71 = xmmword_1B66A0BE0;
  v65 = xmmword_1B6626900;
  v66 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t (***)()))(*(_QWORD *)Element + 56))(Element, &v69);
  for (i = 0; ; ++i)
  {
    v57 = *(_QWORD *)(a1 + 168);
    if (v57)
      LODWORD(v58) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v57 + 24))(v57);
    else
      v58 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v58)
      break;
    if (i == 1)
    {
      v59 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 1u);
      p_p = &__p;
    }
    else
    {
      if (i)
        continue;
      v59 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
      p_p = (void **)&v69;
    }
    (*(void (**)(uint64_t, void **))(*(_QWORD *)v59 + 56))(v59, p_p);
  }
  inData = 1;
  if (AudioUnitSetProperty(*(AudioUnit *)(a1 + 8), 0xE74u, 0, 0, &inData, 4u))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v73 = "AUReverbSuppressor.cpp";
      v74 = 1024;
      v75 = 580;
      v76 = 2080;
      v77 = "UsesFixedBlockSize";
      _os_log_impl(&dword_1B5ED0000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d AudioUnitSetProperty failed for %s", buf, 0x1Cu);
    }
    exception = __cxa_allocate_exception(8uLL);
    *exception = MEMORY[0x1E0DE5060] + 16;
  }
  return a1;
}

void sub_1B61D1D38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, Trackable *a10, uint64_t a11, uint64_t a12, Trackable *a13, uint64_t a14, Trackable *a15, Trackable *a16, Trackable *a17, Trackable *a18, Trackable *a19, Trackable *a20,Trackable *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUReverbSuppressor>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNoiseSelector>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Element;
  unsigned int i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t *v16;
  float v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  int v28;
  const __CFString *v29;
  uint64_t v30;
  int v31;
  unint64_t v32;
  int v33;
  const __CFString *v34;
  unint64_t v35;
  int v36;
  unint64_t v37;
  int v38;
  const __CFString *v39;
  uint64_t v40;
  int v41;
  unint64_t v42;
  int v43;
  const __CFString *v44;
  uint64_t v45;
  int v46;
  unint64_t v47;
  int v48;
  const __CFString *v49;
  uint64_t v50;
  int v51;
  unint64_t v52;
  int v53;
  const __CFString *v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  const __CFString *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  const __CFString *v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  const __CFString *v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  const __CFString *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  const __CFString *v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  int v83;
  const __CFString *v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  int v88;
  const __CFString *v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  const __CFString *v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  uint64_t v98;

  v98 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 2, 2);
  *(_QWORD *)v3 = &off_1E69CFA70;
  *((_QWORD *)v3 + 66) = 1;
  *((_QWORD *)v3 + 67) = 0;
  *((_BYTE *)v3 + 552) = 1;
  v4 = (_QWORD *)((char *)v3 + 568);
  *((_OWORD *)v3 + 35) = 0u;
  *((_OWORD *)v3 + 36) = 0u;
  *((_QWORD *)v3 + 74) = 0;
  *((_DWORD *)v3 + 150) = 1065353216;
  v5 = *((_QWORD *)v3 + 9);
  if (v5)
    v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
  else
    v6 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 40))(v6, 15);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v7 = 0;
  *(_DWORD *)(a1 + 544) = 44100;
  v25 = 0x40E5888000000000;
  v27 = xmmword_1B66A0DD0;
  v26 = xmmword_1B66A0BD0;
  v22 = 0x40E5888000000000;
  v23 = xmmword_1B66A0BD0;
  v24 = xmmword_1B66A0BE0;
  while (1)
  {
    v8 = *(_QWORD *)(a1 + 120);
    if (v8)
      LODWORD(v9) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
    else
      v9 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v7 >= v9)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v7);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v25);
    ++v7;
  }
  for (i = 0; ; ++i)
  {
    v12 = *(_QWORD *)(a1 + 168);
    if (v12)
      LODWORD(v13) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    else
      v13 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v13)
      break;
    v14 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v14 + 56))(v14, &v22);
  }
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 1156);
  *(_BYTE *)(a1 + 376) = 1;
  if (AUNoiseSelectorLogScope(void)::once != -1)
    dispatch_once(&AUNoiseSelectorLogScope(void)::once, &__block_literal_global_6260);
  LODWORD(v25) = 0;
  *(_QWORD *)&v26 = CFSTR("Wind Probability");
  *((_QWORD *)&v26 + 1) = 0;
  LODWORD(v27) = 1065353216;
  *(_QWORD *)((char *)&v27 + 4) = 0xC080000000000000;
  v28 = 1;
  v29 = CFSTR("Pframe");
  v30 = 0;
  v31 = 1065353216;
  v32 = 0xC080000000000000;
  v33 = 2;
  v34 = CFSTR("No Wind Threshold");
  v35 = 0xC1A0000000000000;
  v37 = 0xC08000000000000DLL;
  v36 = 1101004800;
  v38 = 3;
  v39 = CFSTR("No Wind Low Frequency");
  v40 = 1120403456;
  v42 = 0xC080000000000008;
  v41 = 1157234688;
  v43 = 4;
  v44 = CFSTR("No Wind High Frequency");
  v45 = 0x457A000046BB8000;
  v46 = 1186693120;
  v48 = 5;
  v47 = 0xC080000000000008;
  v49 = CFSTR("Wind Threshold");
  v50 = 0x40000000;
  v52 = 0xC08000000000000DLL;
  v51 = 1101004800;
  v53 = 6;
  v54 = CFSTR("Wind Low Frequency");
  v55 = 1157234688;
  v56 = 0x844FA0000;
  v57 = -1065353216;
  v58 = 7;
  v59 = CFSTR("Wind High Frequency");
  v60 = 0x44FA000046BB8000;
  v61 = 0x846BB8000;
  v62 = -1065353216;
  v63 = 8;
  v64 = CFSTR("Voice Noise Probability Threshold");
  v65 = 1056964608;
  v66 = 1065353216;
  v67 = -1065353216;
  v68 = 9;
  v69 = CFSTR("Min Probability In Noise");
  v70 = 1036831949;
  v71 = 1065353216;
  v72 = -1065353216;
  v73 = 10;
  v74 = CFSTR("Min Probability In Voice");
  v75 = 1056964608;
  v76 = 1065353216;
  v77 = -1065353216;
  v78 = 11;
  v79 = CFSTR("Voice Time Out");
  v80 = 1048576000;
  v81 = 0x441200000;
  v82 = -1065353216;
  v83 = 12;
  v84 = CFSTR("Min Between Voice And Noise");
  v85 = 1065353216;
  v86 = 0x13F800000;
  v87 = -1065353216;
  v88 = 13;
  v89 = CFSTR("Mic Switch decided in NoiseSelector");
  v90 = 0;
  v91 = 0x23F800000;
  v92 = -1065353216;
  v93 = 14;
  v94 = CFSTR("Threshold for MagDiffVAD");
  v95 = 0xC1A00000C1200000;
  v96 = 0xD41A00000;
  v97 = -1065353216;
  std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__assign_unique<std::pair<unsigned int const,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>> const*>((uint64_t)v4, (unsigned int *)&v25, (unsigned int *)&v98);
  v15 = 0;
  LODWORD(v25) = 0;
  do
  {
    v16 = std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>(v4, v15);
    if (v16)
    {
      v17 = *((float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v4, v15, &v25)+ 8);
      v18 = *(_QWORD *)(a1 + 72);
      if (v18)
      {
        v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
      }
      else
      {
        v20 = *(ausdk::AUElement ***)(a1 + 48);
        if (*(ausdk::AUElement ***)(a1 + 56) == v20)
          v19 = 0;
        else
          v19 = *v20;
      }
      ausdk::AUElement::SetParameter(v19, v15, v17, 0);
    }
    LODWORD(v25) = ++v15;
  }
  while (v15 != 15);
  *(_BYTE *)(a1 + 552) = AUDebugFeature::IsNonFiniteHandlingEnabled((AUDebugFeature *)v16);
  return a1;
}

void sub_1B61D2A84(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  uint64_t v2;

  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table(v2);
  std::unique_ptr<NoiseSelectorCore>::reset[abi:ne180100]((_QWORD *)v1 + 70, 0);
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUNoiseSelector>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHandsetNoiseEQ>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Element;
  unsigned int i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t *v16;
  float v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  int v28;
  const __CFString *v29;
  unint64_t v30;
  int v31;
  unint64_t v32;
  int v33;
  const __CFString *v34;
  uint64_t v35;
  int v36;
  unint64_t v37;
  int v38;
  const __CFString *v39;
  uint64_t v40;
  int v41;
  unint64_t v42;
  int v43;
  const __CFString *v44;
  uint64_t v45;
  int v46;
  unint64_t v47;
  int v48;
  const __CFString *v49;
  uint64_t v50;
  int v51;
  unint64_t v52;
  int v53;
  const __CFString *v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  const __CFString *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  const __CFString *v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 2, 2);
  *(_QWORD *)v3 = &off_1E69CEF10;
  *((_DWORD *)v3 + 132) = 1;
  *(_OWORD *)((char *)v3 + 532) = 0u;
  *((_BYTE *)v3 + 556) = 1;
  v4 = (_QWORD *)((char *)v3 + 568);
  *((_OWORD *)v3 + 35) = 0u;
  *((_OWORD *)v3 + 36) = 0u;
  *((_QWORD *)v3 + 74) = 0;
  *((_DWORD *)v3 + 150) = 1065353216;
  v5 = *((_QWORD *)v3 + 9);
  if (v5)
    v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 32))(v5, 0);
  else
    v6 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 40))(v6, 9);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v7 = 0;
  *(_DWORD *)(a1 + 548) = 44100;
  v25 = 0x40E5888000000000;
  v27 = xmmword_1B66A0BC0;
  v26 = xmmword_1B66A0BD0;
  v22 = 0x40E5888000000000;
  v23 = xmmword_1B66A0BD0;
  v24 = xmmword_1B66A0BE0;
  while (1)
  {
    v8 = *(_QWORD *)(a1 + 120);
    if (v8)
      LODWORD(v9) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
    else
      v9 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v7 >= v9)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v7);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v25);
    ++v7;
  }
  for (i = 0; ; ++i)
  {
    v12 = *(_QWORD *)(a1 + 168);
    if (v12)
      LODWORD(v13) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    else
      v13 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v13)
      break;
    v14 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v14 + 56))(v14, &v22);
  }
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 1156);
  *(_BYTE *)(a1 + 376) = 1;
  if (AUHandsetNoiseEQLogScope(void)::once != -1)
    dispatch_once(&AUHandsetNoiseEQLogScope(void)::once, &__block_literal_global_5681);
  LODWORD(v25) = 0;
  *(_QWORD *)&v26 = CFSTR("Pframe");
  *((_QWORD *)&v26 + 1) = 0;
  LODWORD(v27) = 1065353216;
  *(_QWORD *)((char *)&v27 + 4) = 0xC080000000000000;
  v28 = 1;
  v29 = CFSTR("Min Gain");
  v30 = 0xC3480000C1A00000;
  v31 = 0;
  v32 = 0xC08000000000000DLL;
  v33 = 2;
  v34 = CFSTR("Max Gain");
  v35 = 1109393408;
  v37 = 0xC08000000000000DLL;
  v36 = 1128792064;
  v38 = 3;
  v39 = CFSTR("Voice Noise Threshold");
  v40 = 0x3F8000003FA00000;
  v42 = 0xC08000000000000DLL;
  v41 = 1101004800;
  v43 = 4;
  v44 = CFSTR("Speech Prob Threshold");
  v45 = 1056964608;
  v47 = 0xC080000000000000;
  v46 = 1065353216;
  v48 = 5;
  v49 = CFSTR("Gain TC in Noise");
  v50 = 1048576000;
  v52 = 0xC080000000000004;
  v51 = 1092616192;
  v53 = 6;
  v54 = CFSTR("Gain TC in Voice");
  v55 = 1008981770;
  v56 = 0x441200000;
  v57 = -1065353216;
  v58 = 7;
  v59 = CFSTR("Power Spectrum TC");
  v60 = 1000593162;
  v61 = 0x441200000;
  v62 = -1065353216;
  v63 = 8;
  v64 = CFSTR("Frequency Smooth");
  v65 = 1065353216;
  v66 = 0x13F800000;
  v67 = -1065353216;
  std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__assign_unique<std::pair<unsigned int const,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>> const*>((uint64_t)v4, (unsigned int *)&v25, (unsigned int *)&v68);
  v15 = 0;
  LODWORD(v25) = 0;
  do
  {
    v16 = std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>(v4, v15);
    if (v16)
    {
      v17 = *((float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v4, v15, &v25)+ 8);
      v18 = *(_QWORD *)(a1 + 72);
      if (v18)
      {
        v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
      }
      else
      {
        v20 = *(ausdk::AUElement ***)(a1 + 48);
        if (*(ausdk::AUElement ***)(a1 + 56) == v20)
          v19 = 0;
        else
          v19 = *v20;
      }
      ausdk::AUElement::SetParameter(v19, v15, v17, 0);
    }
    LODWORD(v25) = ++v15;
  }
  while (v15 != 9);
  *(_BYTE *)(a1 + 556) = AUDebugFeature::IsNonFiniteHandlingEnabled((AUDebugFeature *)v16);
  return a1;
}

void sub_1B61D2F1C(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;
  uint64_t v2;

  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table(v2);
  std::unique_ptr<HandsetNoiseEQCore>::reset[abi:ne180100]((_QWORD *)v1 + 70, 0);
  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUHandsetNoiseEQ>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS2>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  ausdk::AUScope *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Element;
  unsigned int i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  float v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  unsigned int j;
  uint64_t v23;
  AUDebugFeature *v24;
  ausdk::AUElement *v25;
  unsigned int v26;
  float *v27;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  int v35;
  const __CFString *v36;
  uint64_t v37;
  int v38;
  unint64_t v39;
  unsigned int v40;
  const __CFString *v41;
  uint64_t v42;
  int v43;
  unint64_t v44;
  int v45;
  const __CFString *v46;
  unint64_t v47;
  int v48;
  unint64_t v49;
  int v50;
  const __CFString *v51;
  unint64_t v52;
  int v53;
  unint64_t v54;
  int v55;
  const __CFString *v56;
  unint64_t v57;
  int v58;
  unint64_t v59;
  int v60;
  const __CFString *v61;
  unint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  const __CFString *v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  const __CFString *v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  const __CFString *v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  const __CFString *v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  const __CFString *v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  const __CFString *v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  const __CFString *v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  const __CFString *v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  int v105;
  const __CFString *v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  int v110;
  const __CFString *v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  int v115;
  const __CFString *v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  uint64_t v120;

  v120 = *MEMORY[0x1E0C80C00];
  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 8, 8);
  *(_QWORD *)v3 = &off_1E69C8698;
  *((_OWORD *)v3 + 33) = xmmword_1B66A0DC0;
  v4 = (ausdk::AUBase *)((char *)v3 + 552);
  *((_QWORD *)v3 + 69) = 0;
  *((_DWORD *)v3 + 140) = 0;
  *(_OWORD *)((char *)v3 + 568) = 0u;
  *(_OWORD *)((char *)v3 + 584) = 0u;
  *((_QWORD *)v3 + 75) = 0;
  *((_BYTE *)v3 + 608) = 1;
  v5 = (_QWORD *)((char *)v3 + 624);
  *(_OWORD *)((char *)v3 + 616) = 0u;
  *(_OWORD *)((char *)v3 + 632) = 0u;
  *((_QWORD *)v3 + 81) = 0;
  *((_DWORD *)v3 + 164) = 1065353216;
  v6 = (_QWORD *)((char *)v3 + 664);
  *(_OWORD *)((char *)v3 + 664) = 0u;
  *(_OWORD *)((char *)v3 + 680) = 0u;
  *((_DWORD *)v3 + 174) = 1065353216;
  v7 = *((_QWORD *)v3 + 9);
  if (v7)
    v8 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
  else
    v8 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 40))(v8, 18);
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v9 = 0;
  *(_DWORD *)(a1 + 540) = 44100;
  v32 = 0x40E5888000000000;
  v33 = xmmword_1B66A0BD0;
  v34 = xmmword_1B66A0DE0;
  v29 = 0x40E5888000000000;
  v31 = xmmword_1B66A0DE0;
  v30 = xmmword_1B66A0BD0;
  while (1)
  {
    v10 = *(_QWORD *)(a1 + 120);
    if (v10)
      LODWORD(v11) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
    else
      v11 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v9 >= v11)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v9);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v32);
    ++v9;
  }
  for (i = 0; ; ++i)
  {
    v14 = *(_QWORD *)(a1 + 168);
    if (v14)
      LODWORD(v15) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
    else
      v15 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v15)
      break;
    v16 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v16 + 56))(v16, &v29);
  }
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 1156);
  LODWORD(v32) = 0;
  *(_QWORD *)&v33 = CFSTR("Adapt BSS Filters");
  *((_QWORD *)&v33 + 1) = 1065353216;
  LODWORD(v34) = 1065353216;
  *(_QWORD *)((char *)&v34 + 4) = 0xC080000000000002;
  v35 = 1;
  v36 = CFSTR("Covariance Alpha TC");
  v37 = 0x3DCCCCCD3FC00000;
  v38 = 1084227584;
  v39 = 0xC080000000000000;
  v40 = 2;
  v41 = CFSTR("Mixture Phase");
  v42 = 0;
  v44 = 0xC080000000000001;
  v43 = 1065353216;
  v45 = 3;
  v46 = CFSTR("Energy Regularization");
  v47 = 0xC47A000042200000;
  v49 = 0xC08000000000000DLL;
  v48 = 1148846080;
  v50 = 4;
  v51 = CFSTR("Covariance Regularization");
  v52 = 0xC47A0000C3480000;
  v54 = 0xC08000000000000DLL;
  v53 = 1148846080;
  v55 = 5;
  v56 = CFSTR("Weighted Covariance Regularization");
  v57 = 0xC47A0000C38C0000;
  v59 = 0xC08000000000000DLL;
  v58 = 1148846080;
  v60 = 6;
  v61 = CFSTR("Unmixing Regularization");
  v62 = 0xC47A0000C38C0000;
  v63 = 0xD447A0000;
  v64 = -1065353216;
  v65 = 7;
  v66 = CFSTR("Scale Mode");
  v67 = 0;
  v68 = 0x141000000;
  v70 = 8;
  v69 = -1065353216;
  v71 = CFSTR("Source Prior Beta");
  v72 = 0x3727C5AC3F800000;
  v73 = 0xE40000000;
  v74 = -1065353216;
  v75 = 9;
  v76 = CFSTR("White Noise Gain Max");
  v77 = 0xC348000000000000;
  v78 = 0xD43480000;
  v79 = -1065353216;
  v80 = 10;
  v81 = CFSTR("Optimization Mode");
  v82 = 0;
  v83 = 0x141200000;
  v84 = -1065353216;
  v85 = 11;
  v86 = CFSTR("Minimum Energy Threshold");
  v87 = 0xC3960000C30C0000;
  v88 = 0xD00000000;
  v90 = 12;
  v89 = -1065353216;
  v91 = CFSTR("Start Up Wait");
  v92 = 1036831949;
  v93 = 0x440000000;
  v94 = -1065353216;
  v95 = 13;
  v96 = CFSTR("Covariance Diagonal Initialization");
  v97 = 0xC47A0000C3200000;
  v98 = 0xD447A0000;
  v99 = -1065353216;
  v100 = 14;
  v101 = CFSTR("Energy Low Frequency");
  v102 = 1133903872;
  v103 = 0x844FA0000;
  v104 = -1065353216;
  v105 = 15;
  v106 = CFSTR("Energy High Frequency");
  v107 = 0x44FA000046BB8000;
  v108 = 0x846BB8000;
  v109 = -1065353216;
  v110 = 16;
  v111 = CFSTR("Mixing Mode");
  v112 = 0;
  v113 = 0x140000000;
  v114 = -1065353216;
  v115 = 17;
  v116 = CFSTR("Num of Echo Chan");
  v117 = 0;
  v118 = 0x40000000;
  v119 = -1065353216;
  std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__assign_unique<std::pair<unsigned int const,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>> const*>((uint64_t)v5, (unsigned int *)&v32, (unsigned int *)&v120);
  LODWORD(v32) = 0;
  *(_QWORD *)&v33 = CFSTR("Adaptive Prior Probability");
  *((_QWORD *)&v33 + 1) = 1056964608;
  LODWORD(v34) = 1065353216;
  *(_QWORD *)((char *)&v34 + 4) = 0xC080000000000000;
  v35 = 1;
  v36 = CFSTR("Prior Strength");
  v37 = 1092616192;
  v38 = 1112014848;
  v39 = 0xC080000000000000;
  std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__assign_unique<std::pair<unsigned int const,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>> const*>((uint64_t)v6, (unsigned int *)&v32, &v40);
  v17 = 0;
  LODWORD(v32) = 0;
  do
  {
    if (std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>(v5, v17))
    {
      v18 = *((float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v5, v17, &v32)+ 8);
      v19 = *(_QWORD *)(a1 + 72);
      if (v19)
      {
        v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
      }
      else
      {
        v21 = *(ausdk::AUElement ***)(a1 + 48);
        if (*(ausdk::AUElement ***)(a1 + 56) == v21)
          v20 = 0;
        else
          v20 = *v21;
      }
      ausdk::AUElement::SetParameter(v20, v17, v18, 0);
    }
    LODWORD(v32) = ++v17;
  }
  while (v17 != 18);
  for (j = 0; ; ++j)
  {
    v23 = *(_QWORD *)(a1 + 592);
    v24 = (AUDebugFeature *)(v23
                           ? (*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23)
                           : (*(_QWORD *)(a1 + 576) - *(_QWORD *)(a1 + 568)) >> 3);
    if (j >= v24)
      break;
    v25 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement(v4, j);
    v26 = 0;
    LODWORD(v32) = 0;
    do
    {
      if (ausdk::AUElement::HasParameterID(v25, v26))
      {
        if (std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::find<unsigned int>(v6, v26))
        {
          v27 = (float *)std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<__CFString const*,float,float,float,AudioUnitParameterUnit,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v6, v26, &v32);
          ausdk::AUElement::SetParameter(v25, v26, v27[8], 0);
        }
      }
      LODWORD(v32) = ++v26;
    }
    while (v26 != 2);
  }
  *(_BYTE *)(a1 + 608) = AUDebugFeature::IsNonFiniteHandlingEnabled(v24);
  return a1;
}

void sub_1B61D3654(_Unwind_Exception *a1, uint64_t a2, ...)
{
  ausdk::AUBase *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v7;
  va_list va;

  va_start(va, a2);
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table(v4);
  std::__hash_table<vp::vx::io::Object_ID<vp::vx::io::Node>,std::hash<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::equal_to<vp::vx::io::Object_ID<vp::vx::io::Node>>,std::allocator<vp::vx::io::Object_ID<vp::vx::io::Node>>>::~__hash_table(v3);
  v7 = *v5;
  *v5 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 56))(v7);
  std::vector<std::unique_ptr<DspLib::AlgorithmBaseNewParameters>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  ausdk::AUBase::~AUBase(v2);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS2>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS1>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  ausdk::AUElement *v5;
  ausdk::AUElement **v6;
  uint64_t v7;
  ausdk::AUElement *v8;
  ausdk::AUElement **v9;
  uint64_t v10;
  ausdk::AUElement *v11;
  ausdk::AUElement **v12;
  uint64_t v13;
  ausdk::AUElement *v14;
  ausdk::AUElement **v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  uint64_t v25;
  ausdk::AUElement *v26;
  ausdk::AUElement **v27;
  uint64_t Element;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 2, 2);
  *(_QWORD *)v3 = &off_1E69C8E48;
  *((_BYTE *)v3 + 528) = 1;
  *((_DWORD *)v3 + 133) = 1;
  *(_QWORD *)((char *)v3 + 548) = 0;
  *(_QWORD *)((char *)v3 + 652) = 0x3F80000000000000;
  *((_QWORD *)v3 + 67) = 0;
  *((_BYTE *)v3 + 544) = 0;
  *((_OWORD *)v3 + 35) = 0u;
  *((_OWORD *)v3 + 36) = 0u;
  *((_OWORD *)v3 + 37) = 0u;
  *((_OWORD *)v3 + 38) = 0u;
  *((_OWORD *)v3 + 39) = 0u;
  *(_OWORD *)((char *)v3 + 633) = 0u;
  *((_QWORD *)v3 + 83) = 0;
  *((_DWORD *)v3 + 184) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 192);
  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
  {
    v5 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  }
  else
  {
    v6 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v6)
      v5 = 0;
    else
      v5 = *v6;
  }
  ausdk::AUElement::SetParameter(v5, 0, 0.0, 0);
  v7 = *(_QWORD *)(a1 + 72);
  if (v7)
  {
    v8 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
  }
  else
  {
    v9 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v9)
      v8 = 0;
    else
      v8 = *v9;
  }
  ausdk::AUElement::SetParameter(v8, 1u, 0.0, 0);
  v10 = *(_QWORD *)(a1 + 72);
  if (v10)
  {
    v11 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0);
  }
  else
  {
    v12 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v12)
      v11 = 0;
    else
      v11 = *v12;
  }
  ausdk::AUElement::SetParameter(v11, 2u, 1.0, 0);
  v13 = *(_QWORD *)(a1 + 72);
  if (v13)
  {
    v14 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 32))(v13, 0);
  }
  else
  {
    v15 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v15)
      v14 = 0;
    else
      v14 = *v15;
  }
  ausdk::AUElement::SetParameter(v14, 3u, 0.0, 0);
  v16 = *(_QWORD *)(a1 + 72);
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  ausdk::AUElement::SetParameter(v17, 4u, 0.0, 0);
  v19 = *(_QWORD *)(a1 + 72);
  if (v19)
  {
    v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
  }
  else
  {
    v21 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v21)
      v20 = 0;
    else
      v20 = *v21;
  }
  ausdk::AUElement::SetParameter(v20, 5u, 0.0, 0);
  v22 = *(_QWORD *)(a1 + 72);
  if (v22)
  {
    v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
  }
  else
  {
    v24 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v24)
      v23 = 0;
    else
      v23 = *v24;
  }
  ausdk::AUElement::SetParameter(v23, 6u, 40.0, 0);
  v25 = *(_QWORD *)(a1 + 72);
  if (v25)
  {
    v26 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, 0);
  }
  else
  {
    v27 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v27)
      v26 = 0;
    else
      v26 = *v27;
  }
  ausdk::AUElement::SetParameter(v26, 7u, 0.0, 0);
  v36 = 0x40CF400000000000;
  v37 = xmmword_1B6626900;
  v38 = xmmword_1B66A0830;
  v33 = 0x40CF400000000000;
  v34 = xmmword_1B6626900;
  v35 = xmmword_1B6626910;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v36);
  v29 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 1u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v29 + 56))(v29, &v36);
  v30 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v30 + 56))(v30, &v36);
  v31 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 1u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v31 + 56))(v31, &v33);
  AUBSS1::UpdateState((AUBSS1 *)a1);
  return a1;
}

void sub_1B61D3A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14)
{
  uint64_t v14;
  uint64_t v16;

  a14 = (void **)(v14 + 624);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&a14);
  a14 = (void **)(v14 + 600);
  std::vector<std::vector<std::vector<DspLib::Biquad::Section>>>::__destroy_vector::operator()[abi:ne180100](&a14);
  std::unique_ptr<BlockProcessor>::reset[abi:ne180100]((uint64_t *)(v14 + 592), 0);
  v16 = *(_QWORD *)(v14 + 584);
  *(_QWORD *)(v14 + 584) = 0;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  std::vector<std::unique_ptr<VPTimeFreqConverter>>::__destroy_vector::operator()[abi:ne180100](&a14);
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v14);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUBSS1>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressorV4>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  ausdk::AUElement *v7;
  ausdk::AUElement **v8;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  uint64_t v12;
  ausdk::AUElement *v13;
  ausdk::AUElement **v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  uint64_t v33;
  ausdk::AUElement *v34;
  ausdk::AUElement **v35;
  uint64_t v36;
  ausdk::AUElement *v37;
  ausdk::AUElement **v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  ausdk::AUElement **v44;
  uint64_t v45;
  ausdk::AUElement *v46;
  ausdk::AUElement **v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  ausdk::AUElement **v50;
  uint64_t v51;
  ausdk::AUElement *v52;
  ausdk::AUElement **v53;
  uint64_t v54;
  ausdk::AUElement *v55;
  ausdk::AUElement **v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  ausdk::AUElement **v59;
  uint64_t v60;
  ausdk::AUElement *v61;
  ausdk::AUElement **v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  ausdk::AUElement **v65;
  uint64_t v66;
  ausdk::AUElement *v67;
  ausdk::AUElement **v68;
  uint64_t v69;
  ausdk::AUElement *v70;
  ausdk::AUElement **v71;
  uint64_t v72;
  ausdk::AUElement *v73;
  ausdk::AUElement **v74;
  uint64_t Element;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v84;
  __int128 v85;
  __int128 v86;
  uint64_t v87;
  __int128 v88;
  __int128 v89;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 4, 4);
  *(_QWORD *)v3 = &off_1E69D52B8;
  *((_BYTE *)v3 + 528) = 0;
  *((_QWORD *)v3 + 68) = 0;
  *(_QWORD *)((char *)v3 + 532) = 0;
  *((_WORD *)v3 + 270) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  else
    v5 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, 23);
  v6 = *(_QWORD *)(a1 + 72);
  if (v6)
  {
    v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
  }
  else
  {
    v8 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v8)
      v7 = 0;
    else
      v7 = *v8;
  }
  ausdk::AUElement::SetParameter(v7, 1u, -24.0, 0);
  v9 = *(_QWORD *)(a1 + 72);
  if (v9)
  {
    v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
  }
  else
  {
    v11 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v11)
      v10 = 0;
    else
      v10 = *v11;
  }
  ausdk::AUElement::SetParameter(v10, 2u, 0.0, 0);
  v12 = *(_QWORD *)(a1 + 72);
  if (v12)
  {
    v13 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, 0);
  }
  else
  {
    v14 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v14)
      v13 = 0;
    else
      v13 = *v14;
  }
  ausdk::AUElement::SetParameter(v13, 9u, 40.0, 0);
  v15 = *(_QWORD *)(a1 + 72);
  if (v15)
  {
    v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
  }
  else
  {
    v17 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v17)
      v16 = 0;
    else
      v16 = *v17;
  }
  ausdk::AUElement::SetParameter(v16, 5u, 0.0, 0);
  v18 = *(_QWORD *)(a1 + 72);
  if (v18)
  {
    v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
  }
  else
  {
    v20 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v20)
      v19 = 0;
    else
      v19 = *v20;
  }
  ausdk::AUElement::SetParameter(v19, 6u, 0.0, 0);
  v21 = *(_QWORD *)(a1 + 72);
  if (v21)
  {
    v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
  }
  else
  {
    v23 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v23)
      v22 = 0;
    else
      v22 = *v23;
  }
  ausdk::AUElement::SetParameter(v22, 7u, 0.0, 0);
  v24 = *(_QWORD *)(a1 + 72);
  if (v24)
  {
    v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
  }
  else
  {
    v26 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v26)
      v25 = 0;
    else
      v25 = *v26;
  }
  ausdk::AUElement::SetParameter(v25, 8u, 0.0, 0);
  v27 = *(_QWORD *)(a1 + 72);
  if (v27)
  {
    v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
  }
  else
  {
    v29 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v29)
      v28 = 0;
    else
      v28 = *v29;
  }
  ausdk::AUElement::SetParameter(v28, 0xAu, 40.0, 0);
  v30 = *(_QWORD *)(a1 + 72);
  if (v30)
  {
    v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
  }
  else
  {
    v32 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v32)
      v31 = 0;
    else
      v31 = *v32;
  }
  ausdk::AUElement::SetParameter(v31, 0, 2.0, 0);
  v33 = *(_QWORD *)(a1 + 72);
  if (v33)
  {
    v34 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v33 + 32))(v33, 0);
  }
  else
  {
    v35 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v35)
      v34 = 0;
    else
      v34 = *v35;
  }
  ausdk::AUElement::SetParameter(v34, 0xBu, 0.0, 0);
  v36 = *(_QWORD *)(a1 + 72);
  if (v36)
  {
    v37 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v36 + 32))(v36, 0);
  }
  else
  {
    v38 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v38)
      v37 = 0;
    else
      v37 = *v38;
  }
  ausdk::AUElement::SetParameter(v37, 0xCu, 0.0, 0);
  v39 = *(_QWORD *)(a1 + 72);
  if (v39)
  {
    v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
  }
  else
  {
    v41 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v41)
      v40 = 0;
    else
      v40 = *v41;
  }
  ausdk::AUElement::SetParameter(v40, 0xDu, -24.0, 0);
  v42 = *(_QWORD *)(a1 + 72);
  if (v42)
  {
    v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v42 + 32))(v42, 0);
  }
  else
  {
    v44 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v44)
      v43 = 0;
    else
      v43 = *v44;
  }
  ausdk::AUElement::SetParameter(v43, 3u, 80.0, 0);
  v45 = *(_QWORD *)(a1 + 72);
  if (v45)
  {
    v46 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v45 + 32))(v45, 0);
  }
  else
  {
    v47 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v47)
      v46 = 0;
    else
      v46 = *v47;
  }
  ausdk::AUElement::SetParameter(v46, 4u, 2.0, 0);
  v48 = *(_QWORD *)(a1 + 72);
  if (v48)
  {
    v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v48 + 32))(v48, 0);
  }
  else
  {
    v50 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v50)
      v49 = 0;
    else
      v49 = *v50;
  }
  ausdk::AUElement::SetParameter(v49, 0xEu, 0.0, 0);
  v51 = *(_QWORD *)(a1 + 72);
  if (v51)
  {
    v52 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v51 + 32))(v51, 0);
  }
  else
  {
    v53 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v53)
      v52 = 0;
    else
      v52 = *v53;
  }
  ausdk::AUElement::SetParameter(v52, 0xFu, 0.0, 0);
  v54 = *(_QWORD *)(a1 + 72);
  if (v54)
  {
    v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v54 + 32))(v54, 0);
  }
  else
  {
    v56 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v56)
      v55 = 0;
    else
      v55 = *v56;
  }
  ausdk::AUElement::SetParameter(v55, 0x10u, 0.0, 0);
  v57 = *(_QWORD *)(a1 + 72);
  if (v57)
  {
    v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v57 + 32))(v57, 0);
  }
  else
  {
    v59 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v59)
      v58 = 0;
    else
      v58 = *v59;
  }
  ausdk::AUElement::SetParameter(v58, 0x11u, 0.0, 0);
  v60 = *(_QWORD *)(a1 + 72);
  if (v60)
  {
    v61 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v60 + 32))(v60, 0);
  }
  else
  {
    v62 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v62)
      v61 = 0;
    else
      v61 = *v62;
  }
  ausdk::AUElement::SetParameter(v61, 0x12u, 0.0, 0);
  v63 = *(_QWORD *)(a1 + 72);
  if (v63)
  {
    v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v63 + 32))(v63, 0);
  }
  else
  {
    v65 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v65)
      v64 = 0;
    else
      v64 = *v65;
  }
  ausdk::AUElement::SetParameter(v64, 0x13u, 0.0, 0);
  v66 = *(_QWORD *)(a1 + 72);
  if (v66)
  {
    v67 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v66 + 32))(v66, 0);
  }
  else
  {
    v68 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v68)
      v67 = 0;
    else
      v67 = *v68;
  }
  ausdk::AUElement::SetParameter(v67, 0x14u, 0.0, 0);
  v69 = *(_QWORD *)(a1 + 72);
  if (v69)
  {
    v70 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v69 + 32))(v69, 0);
  }
  else
  {
    v71 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v71)
      v70 = 0;
    else
      v70 = *v71;
  }
  ausdk::AUElement::SetParameter(v70, 0x15u, 0.0, 0);
  v72 = *(_QWORD *)(a1 + 72);
  if (v72)
  {
    v73 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v72 + 32))(v72, 0);
  }
  else
  {
    v74 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v74)
      v73 = 0;
    else
      v73 = *v74;
  }
  ausdk::AUElement::SetParameter(v73, 0x16u, 0.0, 0);
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 480);
  v87 = 0x40CF400000000000;
  v88 = xmmword_1B66A0BD0;
  v89 = xmmword_1B66A0BE0;
  v84 = 0x40CF400000000000;
  v86 = xmmword_1B6626910;
  v85 = xmmword_1B66A0DF0;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v87);
  v76 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 1u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v76 + 56))(v76, &v87);
  v77 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 2u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v77 + 56))(v77, &v84);
  v78 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 3u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v78 + 56))(v78, &v84);
  v79 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v79 + 56))(v79, &v87);
  v80 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 1u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v80 + 56))(v80, &v84);
  v81 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 2u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v81 + 56))(v81, &v84);
  v82 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 3u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v82 + 56))(v82, &v84);
  return a1;
}

void sub_1B61D42C0(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;

  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressorV4>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressor>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  ausdk::AUElement *v7;
  ausdk::AUElement **v8;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  uint64_t v12;
  ausdk::AUElement *v13;
  ausdk::AUElement **v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  uint64_t v33;
  ausdk::AUElement *v34;
  ausdk::AUElement **v35;
  uint64_t v36;
  ausdk::AUElement *v37;
  ausdk::AUElement **v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  ausdk::AUElement **v44;
  uint64_t v45;
  ausdk::AUElement *v46;
  ausdk::AUElement **v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  ausdk::AUElement **v50;
  uint64_t v51;
  ausdk::AUElement *v52;
  ausdk::AUElement **v53;
  uint64_t v54;
  ausdk::AUElement *v55;
  ausdk::AUElement **v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  ausdk::AUElement **v59;
  uint64_t v60;
  ausdk::AUElement *v61;
  ausdk::AUElement **v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  ausdk::AUElement **v65;
  uint64_t v66;
  ausdk::AUElement *v67;
  ausdk::AUElement **v68;
  uint64_t v69;
  ausdk::AUElement *v70;
  ausdk::AUElement **v71;
  uint64_t v72;
  ausdk::AUElement *v73;
  ausdk::AUElement **v74;
  uint64_t Element;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85;
  __int128 v86;
  __int128 v87;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 3, 3);
  *(_QWORD *)v3 = &off_1E69E9408;
  *((_BYTE *)v3 + 528) = 0;
  *((_QWORD *)v3 + 68) = 0;
  *(_QWORD *)((char *)v3 + 532) = 0;
  *((_WORD *)v3 + 270) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
  else
    v5 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, 23);
  v6 = *(_QWORD *)(a1 + 72);
  if (v6)
  {
    v7 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 32))(v6, 0);
  }
  else
  {
    v8 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v8)
      v7 = 0;
    else
      v7 = *v8;
  }
  ausdk::AUElement::SetParameter(v7, 1u, -6.0, 0);
  v9 = *(_QWORD *)(a1 + 72);
  if (v9)
  {
    v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
  }
  else
  {
    v11 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v11)
      v10 = 0;
    else
      v10 = *v11;
  }
  ausdk::AUElement::SetParameter(v10, 2u, 0.0, 0);
  v12 = *(_QWORD *)(a1 + 72);
  if (v12)
  {
    v13 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, 0);
  }
  else
  {
    v14 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v14)
      v13 = 0;
    else
      v13 = *v14;
  }
  ausdk::AUElement::SetParameter(v13, 9u, 40.0, 0);
  v15 = *(_QWORD *)(a1 + 72);
  if (v15)
  {
    v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
  }
  else
  {
    v17 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v17)
      v16 = 0;
    else
      v16 = *v17;
  }
  ausdk::AUElement::SetParameter(v16, 5u, 0.0, 0);
  v18 = *(_QWORD *)(a1 + 72);
  if (v18)
  {
    v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
  }
  else
  {
    v20 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v20)
      v19 = 0;
    else
      v19 = *v20;
  }
  ausdk::AUElement::SetParameter(v19, 6u, 0.0, 0);
  v21 = *(_QWORD *)(a1 + 72);
  if (v21)
  {
    v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
  }
  else
  {
    v23 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v23)
      v22 = 0;
    else
      v22 = *v23;
  }
  ausdk::AUElement::SetParameter(v22, 7u, 0.0, 0);
  v24 = *(_QWORD *)(a1 + 72);
  if (v24)
  {
    v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
  }
  else
  {
    v26 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v26)
      v25 = 0;
    else
      v25 = *v26;
  }
  ausdk::AUElement::SetParameter(v25, 8u, 0.0, 0);
  v27 = *(_QWORD *)(a1 + 72);
  if (v27)
  {
    v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
  }
  else
  {
    v29 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v29)
      v28 = 0;
    else
      v28 = *v29;
  }
  ausdk::AUElement::SetParameter(v28, 0xAu, 40.0, 0);
  v30 = *(_QWORD *)(a1 + 72);
  if (v30)
  {
    v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
  }
  else
  {
    v32 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v32)
      v31 = 0;
    else
      v31 = *v32;
  }
  ausdk::AUElement::SetParameter(v31, 0, 2.0, 0);
  v33 = *(_QWORD *)(a1 + 72);
  if (v33)
  {
    v34 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v33 + 32))(v33, 0);
  }
  else
  {
    v35 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v35)
      v34 = 0;
    else
      v34 = *v35;
  }
  ausdk::AUElement::SetParameter(v34, 0xBu, 0.0, 0);
  v36 = *(_QWORD *)(a1 + 72);
  if (v36)
  {
    v37 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v36 + 32))(v36, 0);
  }
  else
  {
    v38 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v38)
      v37 = 0;
    else
      v37 = *v38;
  }
  ausdk::AUElement::SetParameter(v37, 0xCu, 0.0, 0);
  v39 = *(_QWORD *)(a1 + 72);
  if (v39)
  {
    v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
  }
  else
  {
    v41 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v41)
      v40 = 0;
    else
      v40 = *v41;
  }
  ausdk::AUElement::SetParameter(v40, 0xDu, -24.0, 0);
  v42 = *(_QWORD *)(a1 + 72);
  if (v42)
  {
    v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v42 + 32))(v42, 0);
  }
  else
  {
    v44 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v44)
      v43 = 0;
    else
      v43 = *v44;
  }
  ausdk::AUElement::SetParameter(v43, 3u, 80.0, 0);
  v45 = *(_QWORD *)(a1 + 72);
  if (v45)
  {
    v46 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v45 + 32))(v45, 0);
  }
  else
  {
    v47 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v47)
      v46 = 0;
    else
      v46 = *v47;
  }
  ausdk::AUElement::SetParameter(v46, 4u, 2.0, 0);
  v48 = *(_QWORD *)(a1 + 72);
  if (v48)
  {
    v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v48 + 32))(v48, 0);
  }
  else
  {
    v50 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v50)
      v49 = 0;
    else
      v49 = *v50;
  }
  ausdk::AUElement::SetParameter(v49, 0xEu, 0.0, 0);
  v51 = *(_QWORD *)(a1 + 72);
  if (v51)
  {
    v52 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v51 + 32))(v51, 0);
  }
  else
  {
    v53 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v53)
      v52 = 0;
    else
      v52 = *v53;
  }
  ausdk::AUElement::SetParameter(v52, 0xFu, 0.0, 0);
  v54 = *(_QWORD *)(a1 + 72);
  if (v54)
  {
    v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v54 + 32))(v54, 0);
  }
  else
  {
    v56 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v56)
      v55 = 0;
    else
      v55 = *v56;
  }
  ausdk::AUElement::SetParameter(v55, 0x10u, 0.0, 0);
  v57 = *(_QWORD *)(a1 + 72);
  if (v57)
  {
    v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v57 + 32))(v57, 0);
  }
  else
  {
    v59 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v59)
      v58 = 0;
    else
      v58 = *v59;
  }
  ausdk::AUElement::SetParameter(v58, 0x11u, 0.0, 0);
  v60 = *(_QWORD *)(a1 + 72);
  if (v60)
  {
    v61 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v60 + 32))(v60, 0);
  }
  else
  {
    v62 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v62)
      v61 = 0;
    else
      v61 = *v62;
  }
  ausdk::AUElement::SetParameter(v61, 0x12u, 0.0, 0);
  v63 = *(_QWORD *)(a1 + 72);
  if (v63)
  {
    v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v63 + 32))(v63, 0);
  }
  else
  {
    v65 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v65)
      v64 = 0;
    else
      v64 = *v65;
  }
  ausdk::AUElement::SetParameter(v64, 0x13u, 0.0, 0);
  v66 = *(_QWORD *)(a1 + 72);
  if (v66)
  {
    v67 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v66 + 32))(v66, 0);
  }
  else
  {
    v68 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v68)
      v67 = 0;
    else
      v67 = *v68;
  }
  ausdk::AUElement::SetParameter(v67, 0x14u, 0.0, 0);
  v69 = *(_QWORD *)(a1 + 72);
  if (v69)
  {
    v70 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v69 + 32))(v69, 0);
  }
  else
  {
    v71 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v71)
      v70 = 0;
    else
      v70 = *v71;
  }
  ausdk::AUElement::SetParameter(v70, 0x15u, 0.0, 0);
  v72 = *(_QWORD *)(a1 + 72);
  if (v72)
  {
    v73 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v72 + 32))(v72, 0);
  }
  else
  {
    v74 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v74)
      v73 = 0;
    else
      v73 = *v74;
  }
  ausdk::AUElement::SetParameter(v73, 0x16u, 0.0, 0);
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 480);
  v85 = 0x40D5888000000000;
  v86 = xmmword_1B66A0BD0;
  v87 = xmmword_1B66A0BE0;
  v82 = 0x40D5888000000000;
  v84 = xmmword_1B6626910;
  v83 = xmmword_1B66A0DF0;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v85);
  v76 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 1u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v76 + 56))(v76, &v85);
  v77 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 2u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v77 + 56))(v77, &v82);
  v78 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v78 + 56))(v78, &v85);
  v79 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 1u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v79 + 56))(v79, &v82);
  v80 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 2u);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v80 + 56))(v80, &v82);
  return a1;
}

void sub_1B61D4AA0(_Unwind_Exception *a1)
{
  ausdk::AUBase *v1;

  ausdk::AUBase::~AUBase(v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMagnitudeDifferenceNoiseSuppressor>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSelectorV2>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  AudioComponentInstance *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  ausdk::AUElement *v10;
  ausdk::AUElement **v11;
  uint64_t v12;
  ausdk::AUElement *v13;
  ausdk::AUElement **v14;
  uint64_t v15;
  ausdk::AUElement *v16;
  ausdk::AUElement **v17;
  uint64_t v18;
  ausdk::AUElement *v19;
  ausdk::AUElement **v20;
  uint64_t v21;
  ausdk::AUElement *v22;
  ausdk::AUElement **v23;
  uint64_t v24;
  ausdk::AUElement *v25;
  ausdk::AUElement **v26;
  uint64_t v27;
  ausdk::AUElement *v28;
  ausdk::AUElement **v29;
  uint64_t v30;
  ausdk::AUElement *v31;
  ausdk::AUElement **v32;
  uint64_t v33;
  ausdk::AUElement *v34;
  ausdk::AUElement **v35;
  uint64_t v36;
  ausdk::AUElement *v37;
  ausdk::AUElement **v38;
  uint64_t v39;
  ausdk::AUElement *v40;
  ausdk::AUElement **v41;
  uint64_t v42;
  ausdk::AUElement *v43;
  ausdk::AUElement **v44;
  uint64_t v45;
  ausdk::AUElement *v46;
  ausdk::AUElement **v47;
  uint64_t v48;
  ausdk::AUElement *v49;
  ausdk::AUElement **v50;
  uint64_t v51;
  ausdk::AUElement *v52;
  ausdk::AUElement **v53;
  uint64_t v54;
  ausdk::AUElement *v55;
  ausdk::AUElement **v56;
  uint64_t v57;
  ausdk::AUElement *v58;
  ausdk::AUElement **v59;
  uint64_t v60;
  ausdk::AUElement *v61;
  ausdk::AUElement **v62;
  uint64_t v63;
  ausdk::AUElement *v64;
  ausdk::AUElement **v65;
  uint64_t v66;
  ausdk::AUElement *v67;
  ausdk::AUElement **v68;
  uint64_t v69;
  ausdk::AUElement *v70;
  ausdk::AUElement **v71;
  uint64_t v72;
  ausdk::AUElement *v73;
  ausdk::AUElement **v74;
  uint64_t v75;
  ausdk::AUElement *v76;
  ausdk::AUElement **v77;
  uint64_t v78;
  ausdk::AUElement *v79;
  ausdk::AUElement **v80;
  uint64_t v81;
  ausdk::AUElement *v82;
  ausdk::AUElement **v83;
  uint64_t v84;
  ausdk::AUElement *v85;
  ausdk::AUElement **v86;
  uint64_t v87;
  ausdk::AUElement *v88;
  ausdk::AUElement **v89;
  uint64_t v90;
  ausdk::AUElement *v91;
  ausdk::AUElement **v92;
  uint64_t v93;
  ausdk::AUElement *v94;
  ausdk::AUElement **v95;
  uint64_t v96;
  ausdk::AUElement *v97;
  ausdk::AUElement **v98;
  uint64_t v99;
  ausdk::AUElement *v100;
  ausdk::AUElement **v101;
  uint64_t v102;
  ausdk::AUElement *v103;
  ausdk::AUElement **v104;
  uint64_t v105;
  ausdk::AUElement *v106;
  ausdk::AUElement **v107;
  uint64_t v108;
  ausdk::AUElement *v109;
  ausdk::AUElement **v110;
  uint64_t v111;
  ausdk::AUElement *v112;
  ausdk::AUElement **v113;
  uint64_t v114;
  ausdk::AUElement *v115;
  ausdk::AUElement **v116;
  uint64_t v117;
  ausdk::AUElement *v118;
  ausdk::AUElement **v119;
  uint64_t v120;
  ausdk::AUElement *v121;
  ausdk::AUElement **v122;
  uint64_t v123;
  ausdk::AUElement *v124;
  ausdk::AUElement **v125;
  uint64_t v126;
  ausdk::AUElement *v127;
  ausdk::AUElement **v128;
  uint64_t v129;
  ausdk::AUElement *v130;
  ausdk::AUElement **v131;
  uint64_t v132;
  ausdk::AUElement *v133;
  ausdk::AUElement **v134;
  uint64_t v135;
  ausdk::AUElement *v136;
  ausdk::AUElement **v137;
  uint64_t v138;
  ausdk::AUElement *v139;
  ausdk::AUElement **v140;
  uint64_t v141;
  ausdk::AUElement *v142;
  ausdk::AUElement **v143;
  uint64_t v144;
  ausdk::AUElement *v145;
  ausdk::AUElement **v146;
  uint64_t v147;
  ausdk::AUElement *v148;
  ausdk::AUElement **v149;
  uint64_t v150;
  ausdk::AUElement *v151;
  ausdk::AUElement **v152;
  uint64_t v153;
  ausdk::AUElement *v154;
  ausdk::AUElement **v155;
  uint64_t v156;
  ausdk::AUElement *v157;
  ausdk::AUElement **v158;
  uint64_t v159;
  ausdk::AUElement *v160;
  ausdk::AUElement **v161;
  uint64_t v162;
  ausdk::AUElement *v163;
  ausdk::AUElement **v164;
  uint64_t v165;
  ausdk::AUElement *v166;
  ausdk::AUElement **v167;
  uint64_t v168;
  ausdk::AUElement *v169;
  ausdk::AUElement **v170;
  uint64_t v171;
  ausdk::AUElement *v172;
  ausdk::AUElement **v173;
  uint64_t v174;
  ausdk::AUElement *v175;
  ausdk::AUElement **v176;
  uint64_t v177;
  ausdk::AUElement *v178;
  ausdk::AUElement **v179;
  uint64_t v180;
  ausdk::AUElement *v181;
  ausdk::AUElement **v182;
  uint64_t v183;
  ausdk::AUElement *v184;
  ausdk::AUElement **v185;
  uint64_t v186;
  ausdk::AUElement *v187;
  ausdk::AUElement **v188;
  uint64_t v189;
  ausdk::AUElement *v190;
  ausdk::AUElement **v191;
  uint64_t v192;
  ausdk::AUElement *v193;
  ausdk::AUElement **v194;
  uint64_t v195;
  ausdk::AUElement *v196;
  ausdk::AUElement **v197;
  uint64_t v198;
  ausdk::AUElement *v199;
  ausdk::AUElement **v200;
  unsigned int v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t Element;
  unsigned int i;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  OpaqueAudioComponent *Next;
  uint64_t v210;
  _BYTE inDesc[24];
  __int128 v213;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 6, 1);
  *(_QWORD *)v3 = &off_1E69CB738;
  *((_BYTE *)v3 + 528) = 0;
  v4 = (AudioComponentInstance *)((char *)v3 + 968);
  *((_QWORD *)v3 + 121) = 0;
  *((_QWORD *)v3 + 145) = 0;
  *((_QWORD *)v3 + 144) = 0;
  *((_OWORD *)v3 + 65) = 0u;
  *((_OWORD *)v3 + 66) = 0u;
  *(_OWORD *)((char *)v3 + 1068) = 0u;
  *((_OWORD *)v3 + 68) = 0u;
  *((_OWORD *)v3 + 70) = 0u;
  *(_OWORD *)((char *)v3 + 1132) = 0u;
  v5 = 1192;
  *((_OWORD *)v3 + 69) = 0u;
  do
  {
    v6 = a1 + v5;
    *(_QWORD *)v6 = 0;
    *(_QWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    v5 += 24;
  }
  while (v5 != 1264);
  *((_QWORD *)v3 + 158) = 0;
  *((_QWORD *)v3 + 159) = 0;
  *((_DWORD *)v3 + 320) = 0;
  *(_DWORD *)(a1 + 1412) = 0;
  *(_BYTE *)(a1 + 1416) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  *(_QWORD *)(a1 + 552) = 0;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_QWORD *)(a1 + 752) = 0;
  *(_OWORD *)(a1 + 760) = 0u;
  *(_BYTE *)(a1 + 376) = 1;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 128);
  v7 = *(_QWORD *)(a1 + 72);
  if (v7)
    v8 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 32))(v7, 0);
  else
    v8 = **(_QWORD **)(a1 + 48);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 40))(v8, 66);
  v9 = *(_QWORD *)(a1 + 72);
  if (v9)
  {
    v10 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 0);
  }
  else
  {
    v11 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v11)
      v10 = 0;
    else
      v10 = *v11;
  }
  ausdk::AUElement::SetParameter(v10, 0, 0.0, 0);
  v12 = *(_QWORD *)(a1 + 72);
  if (v12)
  {
    v13 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, 0);
  }
  else
  {
    v14 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v14)
      v13 = 0;
    else
      v13 = *v14;
  }
  ausdk::AUElement::SetParameter(v13, 1u, 0.25, 0);
  v15 = *(_QWORD *)(a1 + 72);
  if (v15)
  {
    v16 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 0);
  }
  else
  {
    v17 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v17)
      v16 = 0;
    else
      v16 = *v17;
  }
  ausdk::AUElement::SetParameter(v16, 2u, 0.6, 0);
  v18 = *(_QWORD *)(a1 + 72);
  if (v18)
  {
    v19 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 32))(v18, 0);
  }
  else
  {
    v20 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v20)
      v19 = 0;
    else
      v19 = *v20;
  }
  ausdk::AUElement::SetParameter(v19, 3u, 2.0, 0);
  v21 = *(_QWORD *)(a1 + 72);
  if (v21)
  {
    v22 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 32))(v21, 0);
  }
  else
  {
    v23 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v23)
      v22 = 0;
    else
      v22 = *v23;
  }
  ausdk::AUElement::SetParameter(v22, 4u, 6.0, 0);
  v24 = *(_QWORD *)(a1 + 72);
  if (v24)
  {
    v25 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, 0);
  }
  else
  {
    v26 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v26)
      v25 = 0;
    else
      v25 = *v26;
  }
  ausdk::AUElement::SetParameter(v25, 5u, 15.0, 0);
  v27 = *(_QWORD *)(a1 + 72);
  if (v27)
  {
    v28 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 32))(v27, 0);
  }
  else
  {
    v29 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v29)
      v28 = 0;
    else
      v28 = *v29;
  }
  ausdk::AUElement::SetParameter(v28, 6u, 4.0, 0);
  v30 = *(_QWORD *)(a1 + 72);
  if (v30)
  {
    v31 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 32))(v30, 0);
  }
  else
  {
    v32 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v32)
      v31 = 0;
    else
      v31 = *v32;
  }
  ausdk::AUElement::SetParameter(v31, 7u, 0.0, 0);
  v33 = *(_QWORD *)(a1 + 72);
  if (v33)
  {
    v34 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v33 + 32))(v33, 0);
  }
  else
  {
    v35 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v35)
      v34 = 0;
    else
      v34 = *v35;
  }
  ausdk::AUElement::SetParameter(v34, 0x40u, -120.0, 0);
  v36 = *(_QWORD *)(a1 + 72);
  if (v36)
  {
    v37 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v36 + 32))(v36, 0);
  }
  else
  {
    v38 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v38)
      v37 = 0;
    else
      v37 = *v38;
  }
  ausdk::AUElement::SetParameter(v37, 8u, 7.0, 0);
  v39 = *(_QWORD *)(a1 + 72);
  if (v39)
  {
    v40 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v39 + 32))(v39, 0);
  }
  else
  {
    v41 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v41)
      v40 = 0;
    else
      v40 = *v41;
  }
  ausdk::AUElement::SetParameter(v40, 9u, 20.0, 0);
  v42 = *(_QWORD *)(a1 + 72);
  if (v42)
  {
    v43 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v42 + 32))(v42, 0);
  }
  else
  {
    v44 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v44)
      v43 = 0;
    else
      v43 = *v44;
  }
  ausdk::AUElement::SetParameter(v43, 0xAu, 5.0, 0);
  v45 = *(_QWORD *)(a1 + 72);
  if (v45)
  {
    v46 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v45 + 32))(v45, 0);
  }
  else
  {
    v47 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v47)
      v46 = 0;
    else
      v46 = *v47;
  }
  ausdk::AUElement::SetParameter(v46, 0xBu, 0.0, 0);
  v48 = *(_QWORD *)(a1 + 72);
  if (v48)
  {
    v49 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v48 + 32))(v48, 0);
  }
  else
  {
    v50 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v50)
      v49 = 0;
    else
      v49 = *v50;
  }
  ausdk::AUElement::SetParameter(v49, 0x41u, -140.0, 0);
  v51 = *(_QWORD *)(a1 + 72);
  if (v51)
  {
    v52 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v51 + 32))(v51, 0);
  }
  else
  {
    v53 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v53)
      v52 = 0;
    else
      v52 = *v53;
  }
  ausdk::AUElement::SetParameter(v52, 0xCu, 7.0, 0);
  v54 = *(_QWORD *)(a1 + 72);
  if (v54)
  {
    v55 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v54 + 32))(v54, 0);
  }
  else
  {
    v56 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v56)
      v55 = 0;
    else
      v55 = *v56;
  }
  ausdk::AUElement::SetParameter(v55, 0xDu, 20.0, 0);
  v57 = *(_QWORD *)(a1 + 72);
  if (v57)
  {
    v58 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v57 + 32))(v57, 0);
  }
  else
  {
    v59 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v59)
      v58 = 0;
    else
      v58 = *v59;
  }
  ausdk::AUElement::SetParameter(v58, 0xEu, 4.0, 0);
  v60 = *(_QWORD *)(a1 + 72);
  if (v60)
  {
    v61 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v60 + 32))(v60, 0);
  }
  else
  {
    v62 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v62)
      v61 = 0;
    else
      v61 = *v62;
  }
  ausdk::AUElement::SetParameter(v61, 0xFu, -10.0, 0);
  v63 = *(_QWORD *)(a1 + 72);
  if (v63)
  {
    v64 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v63 + 32))(v63, 0);
  }
  else
  {
    v65 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v65)
      v64 = 0;
    else
      v64 = *v65;
  }
  ausdk::AUElement::SetParameter(v64, 0x3Eu, -35.0, 0);
  v66 = *(_QWORD *)(a1 + 72);
  if (v66)
  {
    v67 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v66 + 32))(v66, 0);
  }
  else
  {
    v68 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v68)
      v67 = 0;
    else
      v67 = *v68;
  }
  ausdk::AUElement::SetParameter(v67, 0x10u, 0.0, 0);
  v69 = *(_QWORD *)(a1 + 72);
  if (v69)
  {
    v70 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v69 + 32))(v69, 0);
  }
  else
  {
    v71 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v71)
      v70 = 0;
    else
      v70 = *v71;
  }
  ausdk::AUElement::SetParameter(v70, 0x11u, 0.95, 0);
  v72 = *(_QWORD *)(a1 + 72);
  if (v72)
  {
    v73 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v72 + 32))(v72, 0);
  }
  else
  {
    v74 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v74)
      v73 = 0;
    else
      v73 = *v74;
  }
  ausdk::AUElement::SetParameter(v73, 0x12u, 8.0, 0);
  v75 = *(_QWORD *)(a1 + 72);
  if (v75)
  {
    v76 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v75 + 32))(v75, 0);
  }
  else
  {
    v77 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v77)
      v76 = 0;
    else
      v76 = *v77;
  }
  ausdk::AUElement::SetParameter(v76, 0x13u, 8.0, 0);
  v78 = *(_QWORD *)(a1 + 72);
  if (v78)
  {
    v79 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v78 + 32))(v78, 0);
  }
  else
  {
    v80 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v80)
      v79 = 0;
    else
      v79 = *v80;
  }
  ausdk::AUElement::SetParameter(v79, 0x14u, 20.0, 0);
  v81 = *(_QWORD *)(a1 + 72);
  if (v81)
  {
    v82 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v81 + 32))(v81, 0);
  }
  else
  {
    v83 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v83)
      v82 = 0;
    else
      v82 = *v83;
  }
  ausdk::AUElement::SetParameter(v82, 0x15u, 3.0, 0);
  v84 = *(_QWORD *)(a1 + 72);
  if (v84)
  {
    v85 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v84 + 32))(v84, 0);
  }
  else
  {
    v86 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v86)
      v85 = 0;
    else
      v85 = *v86;
  }
  ausdk::AUElement::SetParameter(v85, 0x16u, 4.0, 0);
  v87 = *(_QWORD *)(a1 + 72);
  if (v87)
  {
    v88 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v87 + 32))(v87, 0);
  }
  else
  {
    v89 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v89)
      v88 = 0;
    else
      v88 = *v89;
  }
  ausdk::AUElement::SetParameter(v88, 0x17u, 4.0, 0);
  v90 = *(_QWORD *)(a1 + 72);
  if (v90)
  {
    v91 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v90 + 32))(v90, 0);
  }
  else
  {
    v92 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v92)
      v91 = 0;
    else
      v91 = *v92;
  }
  ausdk::AUElement::SetParameter(v91, 0x18u, 15.0, 0);
  v93 = *(_QWORD *)(a1 + 72);
  if (v93)
  {
    v94 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v93 + 32))(v93, 0);
  }
  else
  {
    v95 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v95)
      v94 = 0;
    else
      v94 = *v95;
  }
  ausdk::AUElement::SetParameter(v94, 0x19u, 0.5, 0);
  v96 = *(_QWORD *)(a1 + 72);
  if (v96)
  {
    v97 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v96 + 32))(v96, 0);
  }
  else
  {
    v98 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v98)
      v97 = 0;
    else
      v97 = *v98;
  }
  ausdk::AUElement::SetParameter(v97, 0x1Au, 0.5, 0);
  v99 = *(_QWORD *)(a1 + 72);
  if (v99)
  {
    v100 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v99 + 32))(v99, 0);
  }
  else
  {
    v101 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v101)
      v100 = 0;
    else
      v100 = *v101;
  }
  ausdk::AUElement::SetParameter(v100, 0x1Bu, 0.0, 0);
  v102 = *(_QWORD *)(a1 + 72);
  if (v102)
  {
    v103 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v102 + 32))(v102, 0);
  }
  else
  {
    v104 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v104)
      v103 = 0;
    else
      v103 = *v104;
  }
  ausdk::AUElement::SetParameter(v103, 0x1Eu, 0.0, 0);
  v105 = *(_QWORD *)(a1 + 72);
  if (v105)
  {
    v106 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v105 + 32))(v105, 0);
  }
  else
  {
    v107 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v107)
      v106 = 0;
    else
      v106 = *v107;
  }
  ausdk::AUElement::SetParameter(v106, 0x1Fu, 0.0, 0);
  v108 = *(_QWORD *)(a1 + 72);
  if (v108)
  {
    v109 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v108 + 32))(v108, 0);
  }
  else
  {
    v110 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v110)
      v109 = 0;
    else
      v109 = *v110;
  }
  ausdk::AUElement::SetParameter(v109, 0x20u, 0.0, 0);
  v111 = *(_QWORD *)(a1 + 72);
  if (v111)
  {
    v112 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v111 + 32))(v111, 0);
  }
  else
  {
    v113 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v113)
      v112 = 0;
    else
      v112 = *v113;
  }
  ausdk::AUElement::SetParameter(v112, 0x21u, 0.0, 0);
  v114 = *(_QWORD *)(a1 + 72);
  if (v114)
  {
    v115 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v114 + 32))(v114, 0);
  }
  else
  {
    v116 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v116)
      v115 = 0;
    else
      v115 = *v116;
  }
  ausdk::AUElement::SetParameter(v115, 0x22u, 0.0, 0);
  v117 = *(_QWORD *)(a1 + 72);
  if (v117)
  {
    v118 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v117 + 32))(v117, 0);
  }
  else
  {
    v119 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v119)
      v118 = 0;
    else
      v118 = *v119;
  }
  ausdk::AUElement::SetParameter(v118, 0x23u, 0.0, 0);
  v120 = *(_QWORD *)(a1 + 72);
  if (v120)
  {
    v121 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v120 + 32))(v120, 0);
  }
  else
  {
    v122 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v122)
      v121 = 0;
    else
      v121 = *v122;
  }
  ausdk::AUElement::SetParameter(v121, 0x24u, 0.0, 0);
  v123 = *(_QWORD *)(a1 + 72);
  if (v123)
  {
    v124 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v123 + 32))(v123, 0);
  }
  else
  {
    v125 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v125)
      v124 = 0;
    else
      v124 = *v125;
  }
  ausdk::AUElement::SetParameter(v124, 0x25u, 0.0, 0);
  v126 = *(_QWORD *)(a1 + 72);
  if (v126)
  {
    v127 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v126 + 32))(v126, 0);
  }
  else
  {
    v128 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v128)
      v127 = 0;
    else
      v127 = *v128;
  }
  ausdk::AUElement::SetParameter(v127, 0x26u, 0.0, 0);
  v129 = *(_QWORD *)(a1 + 72);
  if (v129)
  {
    v130 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v129 + 32))(v129, 0);
  }
  else
  {
    v131 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v131)
      v130 = 0;
    else
      v130 = *v131;
  }
  ausdk::AUElement::SetParameter(v130, 0x27u, 0.0, 0);
  v132 = *(_QWORD *)(a1 + 72);
  if (v132)
  {
    v133 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v132 + 32))(v132, 0);
  }
  else
  {
    v134 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v134)
      v133 = 0;
    else
      v133 = *v134;
  }
  ausdk::AUElement::SetParameter(v133, 0x28u, 0.0, 0);
  v135 = *(_QWORD *)(a1 + 72);
  if (v135)
  {
    v136 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v135 + 32))(v135, 0);
  }
  else
  {
    v137 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v137)
      v136 = 0;
    else
      v136 = *v137;
  }
  ausdk::AUElement::SetParameter(v136, 0x29u, 0.0, 0);
  v138 = *(_QWORD *)(a1 + 72);
  if (v138)
  {
    v139 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v138 + 32))(v138, 0);
  }
  else
  {
    v140 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v140)
      v139 = 0;
    else
      v139 = *v140;
  }
  ausdk::AUElement::SetParameter(v139, 0x2Au, 0.0, 0);
  v141 = *(_QWORD *)(a1 + 72);
  if (v141)
  {
    v142 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v141 + 32))(v141, 0);
  }
  else
  {
    v143 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v143)
      v142 = 0;
    else
      v142 = *v143;
  }
  ausdk::AUElement::SetParameter(v142, 0x2Bu, 0.0, 0);
  v144 = *(_QWORD *)(a1 + 72);
  if (v144)
  {
    v145 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v144 + 32))(v144, 0);
  }
  else
  {
    v146 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v146)
      v145 = 0;
    else
      v145 = *v146;
  }
  ausdk::AUElement::SetParameter(v145, 0x30u, 0.0, 0);
  v147 = *(_QWORD *)(a1 + 72);
  if (v147)
  {
    v148 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v147 + 32))(v147, 0);
  }
  else
  {
    v149 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v149)
      v148 = 0;
    else
      v148 = *v149;
  }
  ausdk::AUElement::SetParameter(v148, 0x31u, 0.0, 0);
  v150 = *(_QWORD *)(a1 + 72);
  if (v150)
  {
    v151 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v150 + 32))(v150, 0);
  }
  else
  {
    v152 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v152)
      v151 = 0;
    else
      v151 = *v152;
  }
  ausdk::AUElement::SetParameter(v151, 0x2Cu, 0.0, 0);
  v153 = *(_QWORD *)(a1 + 72);
  if (v153)
  {
    v154 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v153 + 32))(v153, 0);
  }
  else
  {
    v155 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v155)
      v154 = 0;
    else
      v154 = *v155;
  }
  ausdk::AUElement::SetParameter(v154, 0x2Du, -83.0, 0);
  v156 = *(_QWORD *)(a1 + 72);
  if (v156)
  {
    v157 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v156 + 32))(v156, 0);
  }
  else
  {
    v158 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v158)
      v157 = 0;
    else
      v157 = *v158;
  }
  ausdk::AUElement::SetParameter(v157, 0x2Eu, -65.0, 0);
  v159 = *(_QWORD *)(a1 + 72);
  if (v159)
  {
    v160 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v159 + 32))(v159, 0);
  }
  else
  {
    v161 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v161)
      v160 = 0;
    else
      v160 = *v161;
  }
  ausdk::AUElement::SetParameter(v160, 0x2Fu, -90.0, 0);
  v162 = *(_QWORD *)(a1 + 72);
  if (v162)
  {
    v163 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v162 + 32))(v162, 0);
  }
  else
  {
    v164 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v164)
      v163 = 0;
    else
      v163 = *v164;
  }
  ausdk::AUElement::SetParameter(v163, 0x32u, 0.0, 0);
  v165 = *(_QWORD *)(a1 + 72);
  if (v165)
  {
    v166 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v165 + 32))(v165, 0);
  }
  else
  {
    v167 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v167)
      v166 = 0;
    else
      v166 = *v167;
  }
  ausdk::AUElement::SetParameter(v166, 0x33u, 0.0, 0);
  v168 = *(_QWORD *)(a1 + 72);
  if (v168)
  {
    v169 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v168 + 32))(v168, 0);
  }
  else
  {
    v170 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v170)
      v169 = 0;
    else
      v169 = *v170;
  }
  ausdk::AUElement::SetParameter(v169, 0x34u, 0.0, 0);
  v171 = *(_QWORD *)(a1 + 72);
  if (v171)
  {
    v172 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v171 + 32))(v171, 0);
  }
  else
  {
    v173 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v173)
      v172 = 0;
    else
      v172 = *v173;
  }
  ausdk::AUElement::SetParameter(v172, 0x35u, 0.6, 0);
  v174 = *(_QWORD *)(a1 + 72);
  if (v174)
  {
    v175 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v174 + 32))(v174, 0);
  }
  else
  {
    v176 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v176)
      v175 = 0;
    else
      v175 = *v176;
  }
  ausdk::AUElement::SetParameter(v175, 0x36u, 1.25, 0);
  v177 = *(_QWORD *)(a1 + 72);
  if (v177)
  {
    v178 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v177 + 32))(v177, 0);
  }
  else
  {
    v179 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v179)
      v178 = 0;
    else
      v178 = *v179;
  }
  ausdk::AUElement::SetParameter(v178, 0x37u, 4.0, 0);
  v180 = *(_QWORD *)(a1 + 72);
  if (v180)
  {
    v181 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v180 + 32))(v180, 0);
  }
  else
  {
    v182 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v182)
      v181 = 0;
    else
      v181 = *v182;
  }
  ausdk::AUElement::SetParameter(v181, 0x38u, 1.0, 0);
  v183 = *(_QWORD *)(a1 + 72);
  if (v183)
  {
    v184 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v183 + 32))(v183, 0);
  }
  else
  {
    v185 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v185)
      v184 = 0;
    else
      v184 = *v185;
  }
  ausdk::AUElement::SetParameter(v184, 0x39u, 0.0, 0);
  v186 = *(_QWORD *)(a1 + 72);
  if (v186)
  {
    v187 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v186 + 32))(v186, 0);
  }
  else
  {
    v188 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v188)
      v187 = 0;
    else
      v187 = *v188;
  }
  ausdk::AUElement::SetParameter(v187, 0x3Au, 0.0, 0);
  v189 = *(_QWORD *)(a1 + 72);
  if (v189)
  {
    v190 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v189 + 32))(v189, 0);
  }
  else
  {
    v191 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v191)
      v190 = 0;
    else
      v190 = *v191;
  }
  ausdk::AUElement::SetParameter(v190, 0x1Cu, 2.0, 0);
  v192 = *(_QWORD *)(a1 + 72);
  if (v192)
  {
    v193 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v192 + 32))(v192, 0);
  }
  else
  {
    v194 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v194)
      v193 = 0;
    else
      v193 = *v194;
  }
  ausdk::AUElement::SetParameter(v193, 0x3Bu, 0.0, 0);
  v195 = *(_QWORD *)(a1 + 72);
  if (v195)
  {
    v196 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v195 + 32))(v195, 0);
  }
  else
  {
    v197 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v197)
      v196 = 0;
    else
      v196 = *v197;
  }
  ausdk::AUElement::SetParameter(v196, 0x3Cu, 0.0, 0);
  v198 = *(_QWORD *)(a1 + 72);
  if (v198)
  {
    v199 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v198 + 32))(v198, 0);
  }
  else
  {
    v200 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v200)
      v199 = 0;
    else
      v199 = *v200;
  }
  ausdk::AUElement::SetParameter(v199, 0x3Du, 0.0, 0);
  v201 = 0;
  *(_QWORD *)inDesc = 0x40BF400000000000;
  *(_OWORD *)&inDesc[8] = xmmword_1B6626900;
  v213 = xmmword_1B6626910;
  while (1)
  {
    v202 = *(_QWORD *)(a1 + 120);
    if (v202)
      LODWORD(v203) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v202 + 24))(v202);
    else
      v203 = (*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3;
    if (v201 >= v203)
      break;
    Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), v201);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)Element + 56))(Element, inDesc);
    ++v201;
  }
  for (i = 0; ; ++i)
  {
    v206 = *(_QWORD *)(a1 + 168);
    if (v206)
      LODWORD(v207) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v206 + 24))(v206);
    else
      v207 = (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 3;
    if (i >= v207)
      break;
    v208 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), i);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v208 + 56))(v208, inDesc);
  }
  inDesc[13] = 0;
  *(_WORD *)&inDesc[14] = 0;
  *(_DWORD *)&inDesc[16] = 0;
  strcpy(inDesc, "xfuaqebnlppa");
  Next = AudioComponentFindNext(0, (const AudioComponentDescription *)inDesc);
  v210 = -24;
  while (!AudioComponentInstanceNew(Next, (AudioComponentInstance *)(a1 + v210 + 560))
       && !AudioComponentInstanceNew(Next, (AudioComponentInstance *)(a1 + v210 + 776)))
  {
    v210 += 8;
    if (!v210)
    {
      AudioComponentInstanceNew(Next, v4);
      return a1;
    }
  }
  return a1;
}

void sub_1B61D5E6C(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD **v3;
  _QWORD *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  if (*v4)
    MEMORY[0x1BCC95CC8](*v4, 0x1000C8052888210);
  v6 = 0;
  *(_QWORD *)(v1 + 1264) = 0;
  v7 = v1 + 1240;
  while (1)
  {
    v8 = *(_QWORD *)(v7 + v6);
    if (v8)
      MEMORY[0x1BCC95CC8](v8, 0x1000C8052888210);
    *(_QWORD *)(v7 + v6) = 0;
    v6 -= 24;
    if (v6 == -72)
    {
      if (*v3)
      {
        ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, *v3);
        *v3 = 0;
      }
      *(_QWORD *)(v1 + 1160) = 0;
      *(_DWORD *)(v1 + 1144) = 0;
      v9 = *(_QWORD **)(v1 + 1088);
      if (v9)
      {
        ((void (*)(int, _QWORD *))ausdk::BufferAllocator::instance(void)::global[3])((int)&ausdk::BufferAllocator::instance(void)::global, v9);
        *v2 = 0;
      }
      *(_QWORD *)(v1 + 1096) = 0;
      *(_DWORD *)(v1 + 1080) = 0;
      ausdk::AUBase::~AUBase((ausdk::AUBase *)v1);
      _Unwind_Resume(a1);
    }
  }
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessMultipleLookup,AUMicSelectorV2>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDeesser>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  ausdk::AUElement *Element;
  ausdk::AUElement *v5;
  ausdk::AUElement *v6;
  ausdk::AUElement *v7;
  ausdk::AUElement *v8;
  ausdk::AUElement *v9;
  ausdk::AUElement *v10;
  ausdk::AUElement *v11;
  ausdk::AUElement *v12;
  ausdk::AUElement *v13;
  ausdk::AUElement *v14;
  ausdk::AUElement *v15;
  ausdk::AUElement *v16;
  ausdk::AUElement *v17;
  ausdk::AUElement *v18;
  ausdk::AUElement *v19;
  ausdk::AUElement *v20;
  ausdk::AUElement *v21;
  ausdk::AUElement *v22;
  uint64_t v23;
  uint64_t v24;
  OpaqueAudioComponent *Next;
  AudioUnit *v26;
  uint64_t v27;
  OSStatus v28;
  BOOL v29;
  OpaqueAudioComponent *v30;
  AudioUnit *v31;
  _BYTE inDesc[24];
  uint64_t v34;
  uint64_t v35;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69D8CD8;
  *((_OWORD *)v3 + 33) = 0u;
  *((_QWORD *)v3 + 68) = 0x100000000;
  *((_QWORD *)v3 + 69) = 0;
  *((_DWORD *)v3 + 140) = 0;
  *((_BYTE *)v3 + 856) = 0;
  *((_BYTE *)v3 + 864) = 0;
  *((_BYTE *)v3 + 888) = 0;
  *((_BYTE *)v3 + 896) = 0;
  *((_BYTE *)v3 + 920) = 0;
  *((_DWORD *)v3 + 232) = 0;
  *((_OWORD *)v3 + 51) = 0u;
  *((_BYTE *)v3 + 832) = 0;
  *((_QWORD *)v3 + 71) = 0;
  *((_QWORD *)v3 + 73) = 0;
  *((_QWORD *)v3 + 72) = 0;
  *((_DWORD *)v3 + 148) = 0;
  *((_QWORD *)v3 + 76) = 0;
  *((_QWORD *)v3 + 75) = 0;
  *((_DWORD *)v3 + 156) = 0;
  *((_QWORD *)v3 + 77) = 0;
  *((_QWORD *)v3 + 80) = 0;
  *((_WORD *)v3 + 324) = 0;
  *((_QWORD *)v3 + 79) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)v3);
  Element = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(Element, 0, 2500.0, 0);
  v5 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v5, 1u, 6000.0, 0);
  v6 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v6, 2u, 48000.0, 0);
  v7 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v7, 3u, -38.0, 0);
  v8 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v8, 5u, -9.0, 0);
  v9 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v9, 7u, 24.0, 0);
  v10 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v10, 9u, 10.0, 0);
  v11 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v11, 0xBu, 100.0, 0);
  v12 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v12, 0xDu, -96.0, 0);
  v13 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v13, 0xFu, 0.0, 0);
  v14 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v14, 0x11u, 0.0, 0);
  v15 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v15, 4u, -48.0, 0);
  v16 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v16, 6u, -9.0, 0);
  v17 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v17, 8u, 24.0, 0);
  v18 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v18, 0xAu, 10.0, 0);
  v19 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v19, 0xCu, 100.0, 0);
  v20 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v20, 0xEu, -96.0, 0);
  v21 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v21, 0x10u, 0.0, 0);
  v22 = (ausdk::AUElement *)ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 32), 0);
  ausdk::AUElement::SetParameter(v22, 0x12u, 0.0, 0);
  v23 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  v35 = 32;
  *(_QWORD *)inDesc = 0x40E5888000000000;
  v34 = 0x100000004;
  *(_OWORD *)&inDesc[8] = xmmword_1B6626900;
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v23 + 56))(v23, inDesc);
  v24 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  v35 = 32;
  *(_QWORD *)inDesc = 0x40E5888000000000;
  v34 = 0x100000004;
  *(_OWORD *)&inDesc[8] = xmmword_1B6626900;
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v24 + 56))(v24, inDesc);
  inDesc[13] = 0;
  *(_WORD *)&inDesc[14] = 0;
  *(_DWORD *)&inDesc[16] = 0;
  strcpy(inDesc, "xfuaqebnlppa");
  Next = AudioComponentFindNext(0, (const AudioComponentDescription *)inDesc);
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  v26 = (AudioUnit *)(a1 + 816);
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  v27 = 736;
  do
  {
    v28 = AudioComponentInstanceNew(Next, (AudioComponentInstance *)(a1 + v27));
    if (v28)
      break;
    v29 = v27 == 808;
    v27 += 8;
  }
  while (!v29);
  if (!v28)
  {
    inDesc[13] = 0;
    *(_WORD *)&inDesc[14] = 0;
    *(_DWORD *)&inDesc[16] = 0;
    strcpy(inDesc, "xfua2clvlppa");
    v30 = AudioComponentFindNext(0, (const AudioComponentDescription *)inDesc);
    if (!AudioComponentInstanceNew(v30, (AudioComponentInstance *)(a1 + 816)))
    {
      AudioUnitSetParameter(*v26, 0xAu, 0, 0, 0.0, 0);
      AudioUnitSetParameter(*v26, 0xBu, 0, 0, 0.0, 0);
      AudioUnitSetParameter(*v26, 0xDu, 0, 0, 2.0, 0);
      AudioUnitSetParameter(*v26, 0xEu, 0, 0, 2.0, 0);
      v31 = (AudioUnit *)(a1 + 824);
      if (!AudioComponentInstanceNew(v30, (AudioComponentInstance *)(a1 + 824)))
      {
        AudioUnitSetParameter(*v31, 0xAu, 0, 0, 0.0, 0);
        AudioUnitSetParameter(*v31, 0xBu, 0, 0, 0.0, 0);
        AudioUnitSetParameter(*v31, 0xDu, 0, 0, 2.0, 0);
        AudioUnitSetParameter(*v31, 0xEu, 0, 0, 2.0, 0);
      }
    }
  }
  return a1;
}

void sub_1B61D6460(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__optional_destruct_base<ausdk::AUBufferList,false>::~__optional_destruct_base[abi:ne180100](v1 + 896);
  std::__optional_destruct_base<ausdk::AUBufferList,false>::~__optional_destruct_base[abi:ne180100](v1 + 864);
  std::__optional_destruct_base<ausdk::AUBufferList,false>::~__optional_destruct_base[abi:ne180100](v1 + 832);
  CDSPSplitComplex::~CDSPSplitComplex((CDSPSplitComplex *)(v1 + 616));
  CDSPSplitComplex::~CDSPSplitComplex((CDSPSplitComplex *)(v1 + 584));
  CDSPSplitComplex::~CDSPSplitComplex((CDSPSplitComplex *)(v1 + 552));
  ausdk::AUBase::~AUBase((ausdk::AUBase *)v1);
  _Unwind_Resume(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUDeesser>::Destruct(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t ausdk::APFactory<ausdk::AUBaseProcessLookup,AUVolumeCompressorV2>::Construct(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  ausdk::AUBase *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD *v7;
  _OWORD *v8;
  _OWORD *v9;
  _OWORD *v10;
  _OWORD *v11;
  uint64_t Element;
  uint64_t v13;
  float v14;
  float v15;
  uint64_t v16;
  ausdk::AUElement *v17;
  ausdk::AUElement **v18;
  uint64_t v19;
  ausdk::AUElement *v20;
  ausdk::AUElement **v21;
  uint64_t v22;
  ausdk::AUElement *v23;
  ausdk::AUElement **v24;
  uint64_t v25;
  ausdk::AUElement *v26;
  ausdk::AUElement **v27;
  uint64_t v28;
  ausdk::AUElement *v29;
  ausdk::AUElement **v30;
  uint64_t v31;
  ausdk::AUElement *v32;
  ausdk::AUElement **v33;
  uint64_t v34;
  ausdk::AUElement *v35;
  ausdk::AUElement **v36;
  uint64_t v37;
  ausdk::AUElement *v38;
  ausdk::AUElement **v39;
  uint64_t v40;
  ausdk::AUElement *v41;
  ausdk::AUElement **v42;
  uint64_t v43;
  ausdk::AUElement *v44;
  ausdk::AUElement **v45;
  uint64_t v46;
  ausdk::AUElement *v47;
  ausdk::AUElement **v48;
  uint64_t v49;
  ausdk::AUElement *v50;
  ausdk::AUElement **v51;
  uint64_t v52;
  ausdk::AUElement *v53;
  ausdk::AUElement **v54;
  uint64_t v55;
  ausdk::AUElement *v56;
  ausdk::AUElement **v57;
  uint64_t v58;
  ausdk::AUElement *v59;
  ausdk::AUElement **v60;
  uint64_t v61;
  ausdk::AUElement *v62;
  ausdk::AUElement **v63;
  uint64_t v64;
  ausdk::AUElement *v65;
  ausdk::AUElement **v66;
  uint64_t v67;
  ausdk::AUElement *v68;
  ausdk::AUElement **v69;
  uint64_t v70;
  ausdk::AUElement *v71;
  ausdk::AUElement **v72;
  uint64_t v73;
  ausdk::AUElement *v74;
  ausdk::AUElement **v75;
  uint64_t v76;
  ausdk::AUElement *v77;
  ausdk::AUElement **v78;
  uint64_t v79;
  ausdk::AUElement *v80;
  ausdk::AUElement **v81;
  uint64_t v82;
  ausdk::AUElement *v83;
  ausdk::AUElement **v84;
  uint64_t v85;
  ausdk::AUElement *v86;
  ausdk::AUElement **v87;
  uint64_t v88;
  ausdk::AUElement *v89;
  ausdk::AUElement **v90;
  uint64_t v91;
  ausdk::AUElement *v92;
  ausdk::AUElement **v93;
  uint64_t v94;
  ausdk::AUElement *v95;
  ausdk::AUElement **v96;
  uint64_t v97;
  ausdk::AUElement *v98;
  ausdk::AUElement **v99;
  uint64_t v100;
  ausdk::AUElement *v101;
  ausdk::AUElement **v102;
  uint64_t v103;
  ausdk::AUElement *v104;
  ausdk::AUElement **v105;
  uint64_t v106;
  ausdk::AUElement *v107;
  ausdk::AUElement **v108;
  uint64_t v109;
  ausdk::AUElement *v110;
  ausdk::AUElement **v111;
  uint64_t v112;
  ausdk::AUElement *v113;
  ausdk::AUElement **v114;
  uint64_t v115;
  ausdk::AUElement *v116;
  ausdk::AUElement **v117;
  uint64_t v118;
  ausdk::AUElement *v119;
  ausdk::AUElement **v120;
  uint64_t v121;
  ausdk::AUElement *v122;
  ausdk::AUElement **v123;
  uint64_t v124;
  ausdk::AUElement *v125;
  ausdk::AUElement **v126;
  uint64_t v127;
  ausdk::AUElement *v128;
  ausdk::AUElement **v129;
  float v130;
  float v131;
  float v132;
  _DWORD *v133;
  uint64_t v134;
  uint64_t i;
  uint64_t v136;
  ausdk::AUElement *v137;
  ausdk::AUElement **v138;
  uint64_t v139;
  ausdk::AUElement *v140;
  ausdk::AUElement **v141;
  unint64_t v142;
  float v143;
  unint64_t v144;
  uint64_t v145;
  uint64_t v146;
  ausdk::AUElement *v147;
  ausdk::AUElement **v148;
  uint64_t v149;
  ausdk::AUElement *v150;
  ausdk::AUElement **v151;
  unsigned int v153;
  uint64_t v154;
  ausdk::AUElement *v155;
  ausdk::AUElement **v156;
  uint64_t v157;
  ausdk::AUElement *v158;
  ausdk::AUElement **v159;
  uint64_t v161;
  __int128 v162;
  __int128 v163;

  v3 = ausdk::AUBase::AUBase((ausdk::AUBase *)a1, a2, 1, 1);
  *(_QWORD *)v3 = &off_1E69CE7B8;
  *((_QWORD *)v3 + 93) = 0;
  *((_QWORD *)v3 + 97) = 0;
  v4 = (char *)v3 + 1040;
  *(_QWORD *)(a1 + 528) = 0;
  *(_WORD *)(a1 + 536) = 0;
  v5 = 784;
  do
  {
    v6 = a1 + v5;
    *(_QWORD *)v6 = 0;
    *(_DWORD *)(v6 + 8) = 0;
    *(_QWORD *)(v6 + 16) = 0;
    *(_QWORD *)(v6 + 24) = 0;
    v5 += 32;
  }
  while ((void *)(v6 + 32) != v4);
  bzero(v4, 0x228uLL);
  *(_DWORD *)(a1 + 1676) = 5;
  *(_OWORD *)(a1 + 1680) = 0u;
  v7 = operator new(0x20uLL);
  *(_QWORD *)(a1 + 1680) = v7;
  *v7 = 0u;
  v7[1] = 0u;
  *(_QWORD *)(a1 + 1688) = v7 + 2;
  *(_OWORD *)(a1 + 1696) = 0u;
  v8 = operator new(0x20uLL);
  *(_QWORD *)(a1 + 1696) = v8;
  *v8 = 0u;
  v8[1] = 0u;
  *(_QWORD *)(a1 + 1704) = v8 + 2;
  *(_DWORD *)(a1 + 1712) = 5;
  *(_OWORD *)(a1 + 1720) = 0u;
  v9 = operator new(0x20uLL);
  *(_QWORD *)(a1 + 1720) = v9;
  *v9 = 0u;
  v9[1] = 0u;
  *(_QWORD *)(a1 + 1728) = v9 + 2;
  *(_OWORD *)(a1 + 1736) = 0u;
  v10 = operator new(0x20uLL);
  *(_QWORD *)(a1 + 1736) = v10;
  *v10 = 0u;
  v10[1] = 0u;
  *(_QWORD *)(a1 + 1744) = v10 + 2;
  *(_OWORD *)(a1 + 1752) = 0u;
  v11 = operator new(0x20uLL);
  *(_QWORD *)(a1 + 1752) = v11;
  *v11 = 0u;
  v11[1] = 0u;
  *(_QWORD *)(a1 + 1760) = v11 + 2;
  *(_QWORD *)(a1 + 1768) = 1;
  *(_DWORD *)(a1 + 1776) = 0;
  ausdk::AUBase::CreateElements((int64x2_t *)a1);
  v161 = 0x40E5888000000000;
  v162 = xmmword_1B6626900;
  v163 = xmmword_1B66A0830;
  Element = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 80), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)Element + 56))(Element, &v161);
  v13 = ausdk::AUScope::SafeGetElement((ausdk::AUScope *)(a1 + 128), 0);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v13 + 56))(v13, &v161);
  *(_OWORD *)(a1 + 1624) = 0u;
  *(_OWORD *)(a1 + 1640) = 0u;
  *(_OWORD *)(a1 + 1592) = 0u;
  *(_OWORD *)(a1 + 1608) = 0u;
  *(_QWORD *)(a1 + 592) = 0xC2980000C28C0000;
  *(_QWORD *)(a1 + 648) = 0xBF8000003F800000;
  *(_DWORD *)(a1 + 640) = 1128792064;
  *(_DWORD *)(a1 + 600) = 529;
  *(_QWORD *)(a1 + 624) = 0x3F800000C1F00000;
  *(_DWORD *)(a1 + 632) = 1065353216;
  *(_DWORD *)(a1 + 1676) = 5;
  *(_DWORD *)(a1 + 1712) = 5;
  *(_OWORD *)(a1 + 608) = xmmword_1B66A0E00;
  *(_BYTE *)(a1 + 752) = 0;
  *(_OWORD *)(a1 + 560) = xmmword_1B66A0E10;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_QWORD *)(a1 + 656) = 0x4080000000000000;
  *(_BYTE *)(a1 + 684) = 0;
  *(_DWORD *)(a1 + 664) = 0;
  *(_OWORD *)(a1 + 688) = xmmword_1B66A0E20;
  *(_OWORD *)(a1 + 760) = 0u;
  v14 = (float)(44100.0 / (float)*(unsigned int *)(a1 + 336)) * 360.0;
  v15 = 0.0;
  if (v14 >= 0.00001)
    v15 = expf(-4.6052 / v14);
  *(float *)(a1 + 704) = 1.0 - v15;
  v16 = *(_QWORD *)(a1 + 72);
  if (v16)
  {
    v17 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 32))(v16, 0);
  }
  else
  {
    v18 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v18)
      v17 = 0;
    else
      v17 = *v18;
  }
  ausdk::AUElement::SetParameter(v17, 0, -199.0, 0);
  v19 = *(_QWORD *)(a1 + 72);
  if (v19)
  {
    v20 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0);
  }
  else
  {
    v21 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v21)
      v20 = 0;
    else
      v20 = *v21;
  }
  ausdk::AUElement::SetParameter(v20, 0xFu, 0.0, 0);
  v22 = *(_QWORD *)(a1 + 72);
  if (v22)
  {
    v23 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 0);
  }
  else
  {
    v24 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v24)
      v23 = 0;
    else
      v23 = *v24;
  }
  ausdk::AUElement::SetParameter(v23, 1u, 0.0, 0);
  v25 = *(_QWORD *)(a1 + 72);
  if (v25)
  {
    v26 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, 0);
  }
  else
  {
    v27 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v27)
      v26 = 0;
    else
      v26 = *v27;
  }
  ausdk::AUElement::SetParameter(v26, 2u, 0.0, 0);
  v28 = *(_QWORD *)(a1 + 72);
  if (v28)
  {
    v29 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 32))(v28, 0);
  }
  else
  {
    v30 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v30)
      v29 = 0;
    else
      v29 = *v30;
  }
  ausdk::AUElement::SetParameter(v29, 3u, 0.0, 0);
  v31 = *(_QWORD *)(a1 + 72);
  if (v31)
  {
    v32 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v31 + 32))(v31, 0);
  }
  else
  {
    v33 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v33)
      v32 = 0;
    else
      v32 = *v33;
  }
  ausdk::AUElement::SetParameter(v32, 4u, -70.0, 0);
  v34 = *(_QWORD *)(a1 + 72);
  if (v34)
  {
    v35 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v34 + 32))(v34, 0);
  }
  else
  {
    v36 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v36)
      v35 = 0;
    else
      v35 = *v36;
  }
  ausdk::AUElement::SetParameter(v35, 5u, -76.0, 0);
  v37 = *(_QWORD *)(a1 + 72);
  if (v37)
  {
    v38 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v37 + 32))(v37, 0);
  }
  else
  {
    v39 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v39)
      v38 = 0;
    else
      v38 = *v39;
  }
  ausdk::AUElement::SetParameter(v38, 0x3Cu, -70.0, 0);
  v40 = *(_QWORD *)(a1 + 72);
  if (v40)
  {
    v41 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v40 + 32))(v40, 0);
  }
  else
  {
    v42 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v42)
      v41 = 0;
    else
      v41 = *v42;
  }
  ausdk::AUElement::SetParameter(v41, 0x3Du, -76.0, 0);
  v43 = *(_QWORD *)(a1 + 72);
  if (v43)
  {
    v44 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v43 + 32))(v43, 0);
  }
  else
  {
    v45 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v45)
      v44 = 0;
    else
      v44 = *v45;
  }
  ausdk::AUElement::SetParameter(v44, 6u, 1.0, 0);
  v46 = *(_QWORD *)(a1 + 72);
  if (v46)
  {
    v47 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 0);
  }
  else
  {
    v48 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v48)
      v47 = 0;
    else
      v47 = *v48;
  }
  ausdk::AUElement::SetParameter(v47, 7u, -1.0, 0);
  v49 = *(_QWORD *)(a1 + 72);
  if (v49)
  {
    v50 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v49 + 32))(v49, 0);
  }
  else
  {
    v51 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v51)
      v50 = 0;
    else
      v50 = *v51;
  }
  ausdk::AUElement::SetParameter(v50, 8u, 200.0, 0);
  v52 = *(_QWORD *)(a1 + 72);
  if (v52)
  {
    v53 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v52 + 32))(v52, 0);
  }
  else
  {
    v54 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v54)
      v53 = 0;
    else
      v53 = *v54;
  }
  ausdk::AUElement::SetParameter(v53, 9u, 12.0, 0);
  v55 = *(_QWORD *)(a1 + 72);
  if (v55)
  {
    v56 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v55 + 32))(v55, 0);
  }
  else
  {
    v57 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v57)
      v56 = 0;
    else
      v56 = *v57;
  }
  ausdk::AUElement::SetParameter(v56, 0xBu, 0.0, 0);
  v58 = *(_QWORD *)(a1 + 72);
  if (v58)
  {
    v59 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v58 + 32))(v58, 0);
  }
  else
  {
    v60 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v60)
      v59 = 0;
    else
      v59 = *v60;
  }
  ausdk::AUElement::SetParameter(v59, 0xAu, -60.0, 0);
  v61 = *(_QWORD *)(a1 + 72);
  if (v61)
  {
    v62 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v61 + 32))(v61, 0);
  }
  else
  {
    v63 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v63)
      v62 = 0;
    else
      v62 = *v63;
  }
  ausdk::AUElement::SetParameter(v62, 0x14u, 0.5, 0);
  v64 = *(_QWORD *)(a1 + 72);
  if (v64)
  {
    v65 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v64 + 32))(v64, 0);
  }
  else
  {
    v66 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v66)
      v65 = 0;
    else
      v65 = *v66;
  }
  ausdk::AUElement::SetParameter(v65, 0x1Eu, -30.0, 0);
  v67 = *(_QWORD *)(a1 + 72);
  if (v67)
  {
    v68 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v67 + 32))(v67, 0);
  }
  else
  {
    v69 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v69)
      v68 = 0;
    else
      v68 = *v69;
  }
  ausdk::AUElement::SetParameter(v68, 0xCu, 1.0, 0);
  v70 = *(_QWORD *)(a1 + 72);
  if (v70)
  {
    v71 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v70 + 32))(v70, 0);
  }
  else
  {
    v72 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v72)
      v71 = 0;
    else
      v71 = *v72;
  }
  ausdk::AUElement::SetParameter(v71, 0x10u, 1.0, 0);
  v73 = *(_QWORD *)(a1 + 72);
  if (v73)
  {
    v74 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v73 + 32))(v73, 0);
  }
  else
  {
    v75 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v75)
      v74 = 0;
    else
      v74 = *v75;
  }
  ausdk::AUElement::SetParameter(v74, 0xDu, 5.0, 0);
  v76 = *(_QWORD *)(a1 + 72);
  if (v76)
  {
    v77 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v76 + 32))(v76, 0);
  }
  else
  {
    v78 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v78)
      v77 = 0;
    else
      v77 = *v78;
  }
  ausdk::AUElement::SetParameter(v77, 0xEu, 5.0, 0);
  v79 = *(_QWORD *)(a1 + 72);
  if (v79)
  {
    v80 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v79 + 32))(v79, 0);
  }
  else
  {
    v81 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v81)
      v80 = 0;
    else
      v80 = *v81;
  }
  ausdk::AUElement::SetParameter(v80, 0x11u, 0.0, 0);
  v82 = *(_QWORD *)(a1 + 72);
  if (v82)
  {
    v83 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v82 + 32))(v82, 0);
  }
  else
  {
    v84 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v84)
      v83 = 0;
    else
      v83 = *v84;
  }
  ausdk::AUElement::SetParameter(v83, 0x12u, 0.0, 0);
  v85 = *(_QWORD *)(a1 + 72);
  if (v85)
  {
    v86 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v85 + 32))(v85, 0);
  }
  else
  {
    v87 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v87)
      v86 = 0;
    else
      v86 = *v87;
  }
  ausdk::AUElement::SetParameter(v86, 0x41u, 0.0, 0);
  v88 = *(_QWORD *)(a1 + 72);
  if (v88)
  {
    v89 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v88 + 32))(v88, 0);
  }
  else
  {
    v90 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v90)
      v89 = 0;
    else
      v89 = *v90;
  }
  ausdk::AUElement::SetParameter(v89, 0x43u, 4.0, 0);
  v91 = *(_QWORD *)(a1 + 72);
  if (v91)
  {
    v92 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v91 + 32))(v91, 0);
  }
  else
  {
    v93 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v93)
      v92 = 0;
    else
      v92 = *v93;
  }
  ausdk::AUElement::SetParameter(v92, 0x42u, 0.0, 0);
  v94 = *(_QWORD *)(a1 + 72);
  if (v94)
  {
    v95 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v94 + 32))(v94, 0);
  }
  else
  {
    v96 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v96)
      v95 = 0;
    else
      v95 = *v96;
  }
  ausdk::AUElement::SetParameter(v95, 0x44u, 0.004, 0);
  v97 = *(_QWORD *)(a1 + 72);
  if (v97)
  {
    v98 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v97 + 32))(v97, 0);
  }
  else
  {
    v99 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v99)
      v98 = 0;
    else
      v98 = *v99;
  }
  ausdk::AUElement::SetParameter(v98, 0x45u, 0.008, 0);
  v100 = *(_QWORD *)(a1 + 72);
  if (v100)
  {
    v101 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v100 + 32))(v100, 0);
  }
  else
  {
    v102 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v102)
      v101 = 0;
    else
      v101 = *v102;
  }
  ausdk::AUElement::SetParameter(v101, 0x46u, -6.0, 0);
  v103 = *(_QWORD *)(a1 + 72);
  if (v103)
  {
    v104 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v103 + 32))(v103, 0);
  }
  else
  {
    v105 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v105)
      v104 = 0;
    else
      v104 = *v105;
  }
  ausdk::AUElement::SetParameter(v104, 0x47u, 0.0, 0);
  v106 = *(_QWORD *)(a1 + 72);
  if (v106)
  {
    v107 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v106 + 32))(v106, 0);
  }
  else
  {
    v108 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v108)
      v107 = 0;
    else
      v107 = *v108;
  }
  ausdk::AUElement::SetParameter(v107, 0x48u, 0.0, 0);
  v109 = *(_QWORD *)(a1 + 72);
  if (v109)
  {
    v110 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v109 + 32))(v109, 0);
  }
  else
  {
    v111 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v111)
      v110 = 0;
    else
      v110 = *v111;
  }
  ausdk::AUElement::SetParameter(v110, 0x49u, 360.0, 0);
  v112 = *(_QWORD *)(a1 + 72);
  if (v112)
  {
    v113 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v112 + 32))(v112, 0);
  }
  else
  {
    v114 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v114)
      v113 = 0;
    else
      v113 = *v114;
  }
  ausdk::AUElement::SetParameter(v113, 0x4Au, 0.003, 0);
  v115 = *(_QWORD *)(a1 + 72);
  if (v115)
  {
    v116 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v115 + 32))(v115, 0);
  }
  else
  {
    v117 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v117)
      v116 = 0;
    else
      v116 = *v117;
  }
  ausdk::AUElement::SetParameter(v116, 0x4Bu, 0.012, 0);
  v118 = *(_QWORD *)(a1 + 72);
  if (v118)
  {
    v119 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v118 + 32))(v118, 0);
  }
  else
  {
    v120 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v120)
      v119 = 0;
    else
      v119 = *v120;
  }
  ausdk::AUElement::SetParameter(v119, 0x4Cu, -6.0, 0);
  v121 = *(_QWORD *)(a1 + 72);
  if (v121)
  {
    v122 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v121 + 32))(v121, 0);
  }
  else
  {
    v123 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v123)
      v122 = 0;
    else
      v122 = *v123;
  }
  ausdk::AUElement::SetParameter(v122, 0x3Eu, 0.0, 0);
  v124 = *(_QWORD *)(a1 + 72);
  if (v124)
  {
    v125 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v124 + 32))(v124, 0);
  }
  else
  {
    v126 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v126)
      v125 = 0;
    else
      v125 = *v126;
  }
  ausdk::AUElement::SetParameter(v125, 0x3Fu, 0.0, 0);
  v127 = *(_QWORD *)(a1 + 72);
  if (v127)
  {
    v128 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v127 + 32))(v127, 0);
  }
  else
  {
    v129 = *(ausdk::AUElement ***)(a1 + 48);
    if (*(ausdk::AUElement ***)(a1 + 56) == v129)
      v128 = 0;
    else
      v128 = *v129;
  }
  v130 = 0.0;
  ausdk::AUElement::SetParameter(v128, 0x40u, 0.0, 0);
  v131 = *(float *)(a1 + 616);
  v132 = (float)(*(float *)(a1 + 612) - v131) / 6.0;
  v133 = *(_DWORD **)(a1 + 1680);
  *v133 = 0;
  v134 = *(_QWORD *)(a1 + 1696);
  *(float *)v134 = v131;
  v133[7] = 1065353216;
  *(_DWORD *)(v134 + 28) = *(_DWORD *)(a1 + 612);
  for (i = 1; i != 6; ++i)
  {
    v130 = v130 + 0.16667;
    v131 = v132 + v131;
    *(float *)(*(_QWORD *)(a1 + 1680) + 4 * i) = v130;
    *(float *)(*(_QWORD *)(a1 + 1696) + 4 * i) = v131;
    v136 = *(_QWORD *)(a1 + 72);
    if (v136)
    {
      v137 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v136 + 32))(v136, 0);
    }
    else
    {
      v138 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v138)
        v137 = 0;
      else
        v137 = *v138;
    }
    ausdk::AUElement::SetParameter(v137, i + 19, v130, 0);
    v139 = *(_QWORD *)(a1 + 72);
    if (v139)
    {
      v140 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v139 + 32))(v139, 0);
    }
    else
    {
      v141 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v141)
        v140 = 0;
      else
        v140 = *v141;
    }
    ausdk::AUElement::SetParameter(v140, i + 29, v131, 0);
  }
  **(_DWORD **)(a1 + 1720) = -1031012352;
  **(_DWORD **)(a1 + 1752) = 1065353216;
  LODWORD(v142) = *(_DWORD *)(a1 + 1712);
  if (!(_DWORD)v142)
    goto LABEL_222;
  v143 = -70.0;
  v144 = 1;
  do
  {
    v143 = v143 + 11.667;
    v145 = *(_QWORD *)(a1 + 1720);
    *(float *)(v145 + 4 * v144) = v143;
    *(float *)(*(_QWORD *)(a1 + 1752) + 4 * v144) = 1.0 / (float)v144;
    v146 = *(_QWORD *)(a1 + 72);
    if (v146)
    {
      v147 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v146 + 32))(v146, 0);
      v145 = *(_QWORD *)(a1 + 1720);
    }
    else
    {
      v148 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v148)
        v147 = 0;
      else
        v147 = *v148;
    }
    ausdk::AUElement::SetParameter(v147, v144 + 39, *(float *)(v145 + 4 * v144), 0);
    v149 = *(_QWORD *)(a1 + 72);
    if (v149)
    {
      v150 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v149 + 32))(v149, 0);
    }
    else
    {
      v151 = *(ausdk::AUElement ***)(a1 + 48);
      if (*(ausdk::AUElement ***)(a1 + 56) == v151)
        v150 = 0;
      else
        v150 = *v151;
    }
    ausdk::AUElement::SetParameter(v150, v144 + 49, 1.0, 0);
    v142 = *(unsigned int *)(a1 + 1712);
  }
  while (v144++ < v142);
  if (v142 < 5)
  {
LABEL_222:
    v153 = v142 + 40;
    do
    {
      v154 = *(_QWORD *)(a1 + 72);
      if (v154)
      {
        v155 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v154 + 32))(v154, 0);
      }
      else
      {
        v156 = *(ausdk::AUElement ***)(a1 + 48);
        if (*(ausdk::AUElement ***)(a1 + 56) == v156)
          v155 = 0;
        else
          v155 = *v156;
      }
      ausdk::AUElement::SetParameter(v155, v153, *(float *)(*(_QWORD *)(a1 + 1720) + 4 * (*(_DWORD *)(a1 + 1712) - 1)), 0);
      v157 = *(_QWORD *)(a1 + 72);
      if (v157)
      {
        v158 = (ausdk::AUElement *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v157 + 32))(v157, 0);
      }
      else
      {
        v159 = *(ausdk::AUElement ***)(a1 + 48);
        if (*(ausdk::AUElement ***)(a1 + 56) == v159)
          v158 = 0;
        else
          v158 = *v159;
      }
      ausdk::AUElement::SetParameter(v158, v153 + 10, 1.0, 0);
      ++v153;
    }
    while (v153 != 45);
    LODWORD(v142) = *(_DWORD *)(a1 + 1712);
  }
  *(float *)(*(_QWORD *)(a1 + 1720) + 4 * (v142 + 1)) = *(float *)(*(_QWORD *)(a1 + 1720)
                                                                                 + 4 * (v142 + 1))
                                                                      + 100.0;
  ausdk::AUBase::SetAFactoryPresetAsCurrent((char *)a1, (const AUPreset *)&sAUVolumeCompressorV2Presets);
  return a1;
}

